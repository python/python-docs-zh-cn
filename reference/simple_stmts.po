# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "简单语句"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple"
" statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr "简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的句法为:"

#: ../../reference/simple_stmts.rst:37
msgid "Expression statements"
msgstr "表达式语句"

#: ../../reference/simple_stmts.rst:44
msgid ""
"Expression statements are used (mostly interactively) to compute and write a"
" value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 "
"``None``)。 表达式语句的其他使用方式也是允许且有特定用处的。 表达式语句的句法为:"

#: ../../reference/simple_stmts.rst:53
msgid ""
"An expression statement evaluates the expression list (which may be a single"
" expression)."
msgstr "表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。"

#: ../../reference/simple_stmts.rst:65
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"在交互模式下，如果结果值不为 ``None``，它会通过内置的 :func:`repr` "
"函数转换为一个字符串，该结果字符串将以单独一行的形式写入标准输出（例外情况是如果结果为 ``None``，则该过程调用不产生任何输出。）"

#: ../../reference/simple_stmts.rst:73
msgid "Assignment statements"
msgstr "赋值语句"

#: ../../reference/simple_stmts.rst:83
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr "赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项:"

#: ../../reference/simple_stmts.rst:97
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*,"
" *subscription*, and *slicing*.)"
msgstr "(请参阅 :ref:`primaries` 一节了解 *属性引用*, *抽取* 和 *切片* 的句法定义。)"

#: ../../reference/simple_stmts.rst:100
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。"

#: ../../reference/simple_stmts.rst:109
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"赋值是根据目标（列表）的格式递归地定义的。 "
"当目标为一个可变对象（属性引用、抽取或切片）的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发异常。 "
"各种类型可用的规则和引发的异常通过对象类型的定义给出（参见 :ref:`types` 一节）。"

#: ../../reference/simple_stmts.rst:122
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses"
" or square brackets, is recursively defined as follows."
msgstr "对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。"

#: ../../reference/simple_stmts.rst:125
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr "如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。"

#: ../../reference/simple_stmts.rst:128
msgid "Else:"
msgstr "否则:"

#: ../../reference/simple_stmts.rst:130
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets"
" after the starred target.  A list of the remaining items in the iterable is"
" then assigned to the starred target (the list can be empty)."
msgstr ""
"如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标列表项数减一相同项数的可迭代对象。 "
"该可迭代对象前面的项将按从左至右的顺序被赋值给加星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 "
"然后该可迭代对象中剩余项的列表将被赋值给加星目标（该列表可以为空）。"

#: ../../reference/simple_stmts.rst:138
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr "否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。"

#: ../../reference/simple_stmts.rst:142
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr "对象赋值给单个目标的操作按以下方式递归地定义。"

#: ../../reference/simple_stmts.rst:144
msgid "If the target is an identifier (name):"
msgstr "如果目标为标识符（名称）:"

#: ../../reference/simple_stmts.rst:146
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"如果该名称未出现于当前代码块的 :keyword:`global` 或 :keyword:`nonlocal` "
"语句中：该名称将被绑定到当前局部命名空间的对象。"

#: ../../reference/simple_stmts.rst:150
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr "否则：该名称将被分别绑定到全局命名空间或由 :keyword:`nonlocal` 所确定的外层命名空间的对象。"

#: ../../reference/simple_stmts.rst:155
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the"
" object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为零，造成该对象进入释放过程并调用其析构器（如果存在）。"

#: ../../reference/simple_stmts.rst:161
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not"
" necessarily :exc:`AttributeError`)."
msgstr ""
"如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对象；否则将引发 :exc:`TypeError`。 "
"该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行赋值，则会引发异常 (通常应为 :exc:`AttributeError` 但并不强制要求)。"

#: ../../reference/simple_stmts.rst:170
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute"
" exists) a class attribute.  The left-hand side target ``a.x`` is always set"
" as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 ``a.x`` 可以访问实例属性或（如果实例属性不存在）类属性。 左侧目标 "
"``a.x`` 将总是设定为实例属性，并在必要时创建该实例属性。 因此 ``a.x`` "
"的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属性，则左侧会创建一个新的实例属性作为赋值的目标::"

#: ../../reference/simple_stmts.rst:179
msgid ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""
"class Cls:\n"
"    x = 3             # 类变量\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # 将 inst.x 改为 4 而 Cls.x 仍为 3"

#: ../../reference/simple_stmts.rst:184
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr "此描述不一定作用于描述器属性，例如通过 :func:`property` 创建的特征属性。"

#: ../../reference/simple_stmts.rst:191
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。"

#: ../../reference/simple_stmts.rst:200
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to"
" it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, "
":exc:`IndexError` is raised (assignment to a subscripted sequence cannot add"
" new items to a list)."
msgstr ""
"如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列长度。 "
"结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引号的项。 如果索引超出范围，将会引发 :exc:`IndexError` "
"(给被抽取序列赋值不能向列表添加新项)。"

#: ../../reference/simple_stmts.rst:211
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/value pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"如果原型为一个映射对象（例如字典），下标必须具有与该映射的键类型相兼容的类型，然后映射中会创建一个将下标映射到被赋值对象的键/值对。 "
"这可以是替换一个现有键/值对并保持相同键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。"

#: ../../reference/simple_stmts.rst:217
msgid ""
"For user-defined objects, the :meth:`~object.__setitem__` method is called "
"with appropriate arguments."
msgstr "对于用户自定义对象，会调用 :meth:`~object.__setitem__` 方法并附带适当的参数。"

#: ../../reference/simple_stmts.rst:222
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The"
" assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to it."
"  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）。 被赋值对象应当是一个相同类型的序列对象。 "
"接下来，下界与上界表达式如果存在的话将被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上序列长度。 "
"求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋值序列的项替换该切片。 "
"切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况下改变目标序列的长度。"

#: ../../reference/simple_stmts.rst:236
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr "在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导致不太详细的错误信息。"

#: ../../reference/simple_stmts.rst:240
msgid ""
"Although the definition of assignment implies that overlaps between the "
"left-hand side and the right-hand side are 'simultaneous' (for example ``a, "
"b = b, a`` swaps two variables), overlaps *within* the collection of "
"assigned-to variables occur left-to-right, sometimes resulting in confusion."
"  For instance, the following program prints ``[0, 2]``::"
msgstr ""
"虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 ``a, b = b, a`` 会交换两个变量的值），但在赋值给变量的多项集 *之内* "
"的重叠是从左至右进行的，这有时会令人混淆。 例如，以下程序将会打印出 ``[0, 2]``::"

#: ../../reference/simple_stmts.rst:246
msgid ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"
msgstr ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # 先更新 i，再更新 x[i]\n"
"print(x)"

#: ../../reference/simple_stmts.rst:254
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - 扩展的可迭代对象拆包"

#: ../../reference/simple_stmts.rst:255
msgid "The specification for the ``*target`` feature."
msgstr "对 ``*target`` 特性的规范说明。"

#: ../../reference/simple_stmts.rst:261
msgid "Augmented assignment statements"
msgstr "增强赋值语句"

#: ../../reference/simple_stmts.rst:279
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体:"

#: ../../reference/simple_stmts.rst:288
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr "（请参阅 :ref:`primaries` 一节了解最后三种符号的句法定义。）"

#: ../../reference/simple_stmts.rst:291
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only"
" evaluated once."
msgstr ""
"增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。"
" 目标仅会被求值一次。"

#: ../../reference/simple_stmts.rst:296
msgid ""
"An augmented assignment statement like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented"
" version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"增强赋值语句如 ``x += 1`` 可以被改写为 ``x = x + 1`` 以获得类似的、但并非完全等价的效果。 在增强赋值版本中，``x`` "
"仅会被求值一次。 而且，在可能的情况下，实际的运算是 *原地* 执行的，这意味着并不是创建一个新对象并将其赋值给目标，而是直接修改原对象。"

#: ../../reference/simple_stmts.rst:302
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side"
" *before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"不同于普通赋值，增强赋值会在对右手边求值 *之前* 对左手边求值。 例如，``a[i] += f(x)`` 首先查找 ``a[i]``，然后对 "
"``f(x)`` 求值并执行加法操作，最后将结果写回到 ``a[i]``。"

#: ../../reference/simple_stmts.rst:307
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled"
" the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋值相同。 类似地，除了可能存在 *原地* "
"操作行为的例外情况，增强赋值语句执行的二元运算也与普通二元运算相同。"

#: ../../reference/simple_stmts.rst:313
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr "对于属性引用类目标，针对常规赋值的 :ref:`关于类和实例属性的警告 <attr-target-note>` 也同样适用。"

#: ../../reference/simple_stmts.rst:320
msgid "Annotated assignment statements"
msgstr "带标注的赋值语句"

#: ../../reference/simple_stmts.rst:327
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a"
" single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ":term:`标注 <variable annotation>` 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体:"

#: ../../reference/simple_stmts.rst:334
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is"
" allowed."
msgstr "与普通 :ref:`assignment` 的差别在于仅允许单个目标。"

#: ../../reference/simple_stmts.rst:336
msgid ""
"The assignment target is considered \"simple\" if it consists of a single "
"name that is not enclosed in parentheses. For simple assignment targets, if "
"in class or module scope, the annotations are evaluated and stored in a "
"special class or module attribute :attr:`__annotations__` that is a "
"dictionary mapping from variable names (mangled if private) to evaluated "
"annotations. This attribute is writable and is automatically created at the "
"start of class or module body execution, if annotations are found "
"statically."
msgstr ""
"如果赋值目标由不带圆括号的单个名称组成则称为“简单”赋值目标。 对于简单赋值目标，如果处在类或模块作用域中，标注将被求值并存储到一个特殊的类或模块属性 "
":attr:`__annotations__` 中，该属性是一个将变量名称（如为私有则将移除）映射到被求值标注的字典。 "
"此属性为可写属性并且在类或模块体开始执行时自动创建，如果静态地发现标注的话。"

#: ../../reference/simple_stmts.rst:346
msgid ""
"If the assignment target is not simple (an attribute, subscript node, or "
"parenthesized name), the annotation is evaluated if in class or module "
"scope, but not stored."
msgstr "如果赋值目标不是简单赋值目标（属性、下标节点或带圆括号的名称），则如果标注处在类或模块作用域中则会被求值，但不会被存储。"

#: ../../reference/simple_stmts.rst:350
msgid ""
"If a name is annotated in a function scope, then this name is local for that"
" scope. Annotations are never evaluated and stored in function scopes."
msgstr "如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域内被求值和保存。"

#: ../../reference/simple_stmts.rst:353
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last "
":meth:`~object.__setitem__` or :meth:`~object.__setattr__` call."
msgstr ""
"如果存在右手边，带标注的赋值会在对标注求值之前（如果适用）执行实际的赋值。 如果用作表达式目标的右手边不存在，则解释器会对目标求值，但最后的 "
":meth:`~object.__setitem__` 或 :meth:`~object.__setattr__` 调用除外。"

#: ../../reference/simple_stmts.rst:361
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 变量标注的语法"

#: ../../reference/simple_stmts.rst:362
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr "该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行表达。"

#: ../../reference/simple_stmts.rst:366
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - 类型提示"

#: ../../reference/simple_stmts.rst:367
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr "该提议增加了 :mod:`typing` 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使用。"

#: ../../reference/simple_stmts.rst:371
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr "现在带有标注的赋值允许在右边以同样的表达式作为常规赋值。 之前某些表达式（例如未加圆括号的元组表达式）会导致语法错误。"

#: ../../reference/simple_stmts.rst:380
msgid "The :keyword:`!assert` statement"
msgstr ":keyword:`!assert` 语句"

#: ../../reference/simple_stmts.rst:387
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a"
" program:"
msgstr "assert 语句是在程序中插入调试性断言的简便方式:"

#: ../../reference/simple_stmts.rst:393
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "简单形式 ``assert expression`` 等价于 ::"

#: ../../reference/simple_stmts.rst:395
msgid ""
"if __debug__:\n"
"    if not expression: raise AssertionError"
msgstr ""
"if __debug__:\n"
"    if not expression: raise AssertionError"

#: ../../reference/simple_stmts.rst:398
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "扩展形式 ``assert expression1, expression2`` 等价于 ::"

#: ../../reference/simple_stmts.rst:400
msgid ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"
msgstr ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"

#: ../../reference/simple_stmts.rst:407
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable ``__debug__`` is ``True`` under normal"
" circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
":keyword:`assert` statement when optimization is requested at compile time."
"  Note that it is unnecessary to include the source code for the expression "
"that failed in the error message; it will be displayed as part of the stack "
"trace."
msgstr ""
"这些等价形式假定 :const:`__debug__` 和 :exc:`AssertionError` 指向具有指定名称的内置变量。 "
"在当前实现中，内置变量 ``__debug__`` 在正常情况下为 ``True``，在请求优化时为 ``False`` (对应命令行选项为 "
":option:`-O`)。 如果在编译时请求优化则当前代码生成器不会为 :keyword:`assert` 语句发出任何代码。 "
"请注意不需要在错误信息中包括失败的表达式的源代码；它会作为栈回溯的一部分被显示。"

#: ../../reference/simple_stmts.rst:416
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr "赋值给 :const:`__debug__` 是非法的。 该内置变量的值会在解释器启动时确定。"

#: ../../reference/simple_stmts.rst:423
msgid "The :keyword:`!pass` statement"
msgstr ":keyword:`!pass` 语句"

#: ../../reference/simple_stmts.rst:433
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` 是一个空操作 --- 当它被执行时，什么都不发生。 "
"它适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位，例如::"

#: ../../reference/simple_stmts.rst:437
msgid ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"
msgstr ""
"def f(arg): pass    # 一个（目前）不做任何事的函数\n"
"\n"
"class C: pass       # 一个（目前）没有任何方法的类"

#: ../../reference/simple_stmts.rst:445
msgid "The :keyword:`!del` statement"
msgstr ":keyword:`!del` 语句"

#: ../../reference/simple_stmts.rst:455
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr "删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。"

#: ../../reference/simple_stmts.rst:458
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "目标列表的删除将从左至右递归地删除每一个目标。"

#: ../../reference/simple_stmts.rst:464
msgid ""
"Deletion of a name removes the binding of that name from the local or global"
" namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a "
":exc:`NameError` exception will be raised."
msgstr ""
"名称的删除将从局部或全局命名空间中移除该名称的绑定，具体作用域的确定是看该名称是否有在同一代码块的 :keyword:`global` 语句中出现。 "
"如果该名称未被绑定，将会引发 :exc:`NameError`。"

#: ../../reference/simple_stmts.rst:471
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr "属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右侧类型的空切片（但即便这一点也是由切片对象决定的）。"

#: ../../reference/simple_stmts.rst:476
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr "在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将其从局部命名空间中删除是非法的。"

#: ../../reference/simple_stmts.rst:484
msgid "The :keyword:`!return` statement"
msgstr ":keyword:`!return` 语句"

#: ../../reference/simple_stmts.rst:494
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ":keyword:`return` 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。"

#: ../../reference/simple_stmts.rst:497
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr "如果提供了表达式列表，它将被求值，否则以 ``None`` 替代。"

#: ../../reference/simple_stmts.rst:499
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ":keyword:`return` 会离开当前函数调用，并以表达式列表 (或 ``None``) 作为返回值。"

#: ../../reference/simple_stmts.rst:504
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with"
" a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"当 :keyword:`return` 将控制流传出一个带有 :keyword:`finally` 子句的 :keyword:`try` 语句时，该 "
":keyword:`!finally` 子句会先被执行然后再真正离开该函数。"

#: ../../reference/simple_stmts.rst:508
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct "
":exc:`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"在一个生成器函数中，:keyword:`return` 语句表示生成器已完成并将导致 :exc:`StopIteration` 被引发。 "
"返回值（如果有的话）会被当作一个参数用来构建 :exc:`StopIteration` 并成为 :attr:`StopIteration.value` "
"属性。"

#: ../../reference/simple_stmts.rst:513
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause "
":exc:`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` "
"statement is a syntax error in an asynchronous generator function."
msgstr ""
"在一个异步生成器函数中，一个空的 :keyword:`return` 语句表示异步生成器已完成并将导致 "
":exc:`StopAsyncIteration` 被引发。 一个非空的 :keyword:`!return` 语句在异步生成器函数中会导致语法错误。"

#: ../../reference/simple_stmts.rst:521
msgid "The :keyword:`!yield` statement"
msgstr ":keyword:`!yield` 语句"

#: ../../reference/simple_stmts.rst:533
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The ``yield`` statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
":keyword:`yield` 语句在语义上等同于 :ref:`yield 表达式 <yieldexpr>`。 ``yield`` "
"语句可用来省略在使用等效的 yield 表达式语句时所必须的圆括号。 例如，以下 yield 语句 ::"

#: ../../reference/simple_stmts.rst:538
msgid ""
"yield <expr>\n"
"yield from <expr>"
msgstr ""
"yield <expr>\n"
"yield from <expr>"

#: ../../reference/simple_stmts.rst:541
msgid "are equivalent to the yield expression statements ::"
msgstr "等同于以下 yield 表达式语句 ::"

#: ../../reference/simple_stmts.rst:543
msgid ""
"(yield <expr>)\n"
"(yield from <expr>)"
msgstr ""
"(yield <expr>)\n"
"(yield from <expr>)"

#: ../../reference/simple_stmts.rst:546
msgid ""
"Yield expressions and statements are only used when defining a "
":term:`generator` function, and are only used in the body of the generator "
"function.  Using :keyword:`yield` in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""
"yield 表达式和语句仅在定义 :term:`generator` 函数时使用，并且仅被用于生成器函数的函数体内部。 在函数定义中使用 "
":keyword:`yield` 就足以使得该定义创建的是生成器函数而非普通函数。"

#: ../../reference/simple_stmts.rst:551
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr "有关 :keyword:`yield` 语义的完整细节请参看 :ref:`yieldexpr` 一节。"

#: ../../reference/simple_stmts.rst:557
msgid "The :keyword:`!raise` statement"
msgstr ":keyword:`!raise` 语句"

#: ../../reference/simple_stmts.rst:568
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that"
" is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"如果没有提供表达式，则 :keyword:`raise` 会重新引发当前正在处理的异常，它也被称为 *活动的异常*。 如果当前没有活动的异常，则会引发 "
":exc:`RuntimeError` 来提示发生了错误。"

#: ../../reference/simple_stmts.rst:573
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of "
":class:`BaseException`. If it is a class, the exception instance will be "
"obtained when needed by instantiating the class with no arguments."
msgstr ""
"否则的话，:keyword:`raise` 会将第一个表达式求值为异常对象。 它必须为 :class:`BaseException` 的子类或实例。 "
"如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。"

#: ../../reference/simple_stmts.rst:578
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the "
":dfn:`value` is the instance itself."
msgstr "异常的 :dfn:`类型` 为异常实例的类，:dfn:`值` 为实例本身。"

#: ../../reference/simple_stmts.rst:583
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`~BaseException.__traceback__` "
"attribute. You can create an exception and set your own traceback in one "
"step using the :meth:`~BaseException.with_traceback` exception method (which"
" returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"当有异常被引发时通常会自动创建一个回溯对象并将其关联到它的 :attr:`~BaseException.__traceback__` 属性。 "
"你可以创建一个异常并使用 :meth:`~BaseException.with_traceback` "
"异常方法直接设置你的回溯对象（该方法将返回同一异常实例，并将回溯对象设为其参数），就像这样::"

#: ../../reference/simple_stmts.rst:589
msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"

#: ../../reference/simple_stmts.rst:595
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`~BaseException.__cause__` attribute (which is "
"writable). If the expression is an exception class, the class will be "
"instantiated and the resulting exception instance will be attached to the "
"raised exception as the :attr:`!__cause__` attribute. If the raised "
"exception is not handled, both exceptions will be printed:"
msgstr ""
"``from`` 子句用于异常串连：如果给出该子句，则第二个 *表达式* 必须为另一个异常类或实例。 如果第二个表达式是一个异常实例，它将作为 "
":attr:`~BaseException.__cause__` 属性（为一个可写属性）被关联到所引发的异常。 "
"如果该表达式是一个异常类，这个类将被实例化且所生成的异常实例将作为 :attr:`!__cause__` 属性被关联到所引发的异常。 "
"如果所引发的异常未被处理，则两个异常都将被打印："

#: ../../reference/simple_stmts.rst:604
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:624
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an "
":keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`~BaseException.__context__` attribute:"
msgstr ""
"当已经有一个异常在处理时如果有新的异常被引发则类似的机制会隐式地起作用。 异常可以通过使用 :keyword:`except` 或 "
":keyword:`finally` 子句或者 :keyword:`with` 语句来处理。 之前的异常将被关联至新异常的 "
":attr:`~BaseException.__context__` 属性："

#: ../../reference/simple_stmts.rst:630
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:650
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause:"
msgstr "异常串连可通过在 ``from`` 子句中指定 :const:`None` 来显式地加以抑制："

#: ../../reference/simple_stmts.rst:653
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:664
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in section "
":ref:`try`."
msgstr "有关异常的更多信息可在 :ref:`exceptions` 一节查看，有关处理异常的信息可在 :ref:`try` 一节查看。"

#: ../../reference/simple_stmts.rst:667
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` 现在允许被用作 ``raise X from Y`` 中的 ``Y``。"

#: ../../reference/simple_stmts.rst:670
msgid ""
"Added the :attr:`~BaseException.__suppress_context__` attribute to suppress "
"automatic display of the exception context."
msgstr "增加了 :attr:`~BaseException.__suppress_context__` 属性向来抑制异常上下文的自动显示。"

#: ../../reference/simple_stmts.rst:673
msgid ""
"If the traceback of the active exception is modified in an :keyword:`except`"
" clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""
"如果活动异常的回溯在 :keyword:`except` 子句中被修改，则会有后续的 ``raise`` 语句重新引发该异常并附带被修改的回溯。 "
"在之前版本中，重新引发该异常则会附带它被捕获时的回溯。"

#: ../../reference/simple_stmts.rst:682
msgid "The :keyword:`!break` statement"
msgstr ":keyword:`!break` 语句"

#: ../../reference/simple_stmts.rst:693
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or "
":keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` 在语法上只会出现于 :keyword:`for` 或 :keyword:`while` "
"循环所嵌套的代码，但不会出现于该循环内部的函数或类定义所嵌套的代码。"

#: ../../reference/simple_stmts.rst:700
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`!else` clause if the loop has one."
msgstr "它会终结最近的外层循环，如果循环有可选的 :keyword:`!else` 子句，也会跳过该子句。"

#: ../../reference/simple_stmts.rst:703
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control"
" target keeps its current value."
msgstr "如果一个 :keyword:`for` 循环被 :keyword:`break` 所终结，该循环的控制目标会保持其当前值。"

#: ../../reference/simple_stmts.rst:708
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"当 :keyword:`break` 将控制流传出一个带有 :keyword:`finally` 子句的 :keyword:`try` 语句时，该 "
":keyword:`!finally` 子句会先被执行然后再真正离开该循环。"

#: ../../reference/simple_stmts.rst:716
msgid "The :keyword:`!continue` statement"
msgstr ":keyword:`!continue` 语句"

#: ../../reference/simple_stmts.rst:728
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing"
" loop."
msgstr ""
":keyword:`continue` 在语法上只会出现于 :keyword:`for` 或 :keyword:`while` "
"循环所嵌套的代码中，但不会出现于该循环内部的函数或类定义中。 它会继续执行最近的外层循环的下一个轮次。"

#: ../../reference/simple_stmts.rst:732
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"当 :keyword:`continue` 将控制流传出一个带有 :keyword:`finally` 子句的 :keyword:`try` 语句时，该"
" :keyword:`!finally` 子句会先被执行然后再真正开始循环的下一个轮次。"

#: ../../reference/simple_stmts.rst:741
msgid "The :keyword:`!import` statement"
msgstr ":keyword:`!import` 语句"

#: ../../reference/simple_stmts.rst:762
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr "基本的 import 语句（不带 :keyword:`from` 子句）会分两步执行:"

#: ../../reference/simple_stmts.rst:765
msgid "find a module, loading and initializing it if necessary"
msgstr "查找一个模块，如果有必要还会加载并初始化模块。"

#: ../../reference/simple_stmts.rst:766
msgid ""
"define a name or names in the local namespace for the scope where the "
":keyword:`import` statement occurs."
msgstr "在局部命名空间中为 :keyword:`import` 语句发生位置所处的作用域定义一个或多个名称。"

#: ../../reference/simple_stmts.rst:769
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses"
" had been separated out into individual import statements."
msgstr "当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独立的 import 语句一样。"

#: ../../reference/simple_stmts.rst:774
msgid ""
"The details of the first step, finding and loading modules, are described in"
" greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"第一个步骤，即查找和加载模块的细节在 :ref:`导入系统 <importsystem>` "
"一节中有更详细的描述，其中也描述了可被导入的多种类型的包和模块，以及可用于定制导入系统的所有钩子对象。 "
"请注意如果这一步失败，则可能说明模块无法找到，*或者* 是在初始化模块，包括执行模块代码期间发生了错误。"

#: ../../reference/simple_stmts.rst:782
msgid ""
"If the requested module is retrieved successfully, it will be made available"
" in the local namespace in one of three ways:"
msgstr "如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:"

#: ../../reference/simple_stmts.rst:787
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following "
":keyword:`!as` is bound directly to the imported module."
msgstr "模块名后使用 :keyword:`!as` 时，直接把 :keyword:`!as` 后的名称与导入模块绑定。"

#: ../../reference/simple_stmts.rst:789
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr "如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空间作为对所导入模块的引用。"

#: ../../reference/simple_stmts.rst:792
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"如果被导入的模块 *不是* 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空间作为对该最高层级包的引用。 "
"所导入的模块必须使用其完整限定名称来访问而不能直接访问。"

#: ../../reference/simple_stmts.rst:802
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ":keyword:`from` 形式使用的过程略微繁复一些:"

#: ../../reference/simple_stmts.rst:804
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr "查找 :keyword:`from` 子句中指定的模块，如有必要还会加载并初始化模块；"

#: ../../reference/simple_stmts.rst:806
msgid ""
"for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr "对于 :keyword:`import` 子句中指定的每个标识符："

#: ../../reference/simple_stmts.rst:808
msgid "check if the imported module has an attribute by that name"
msgstr "检查被导入模块是否有该名称的属性"

#: ../../reference/simple_stmts.rst:809
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr "如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性"

#: ../../reference/simple_stmts.rst:811
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "如果未找到该属性，则引发 :exc:`ImportError`。"

#: ../../reference/simple_stmts.rst:812
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using"
" the name in the :keyword:`!as` clause if it is present, otherwise using the"
" attribute name"
msgstr "否则的话，将对该值的引用存入局部命名空间，如果有 :keyword:`!as` 子句则使用其指定的名称，否则使用该属性的名称"

#: ../../reference/simple_stmts.rst:816
msgid "Examples::"
msgstr "示例::"

#: ../../reference/simple_stmts.rst:818
msgid ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"
msgstr ""
"import foo                 # foo 被导入并且被局部绑定\n"
"import foo.bar.baz         # foo, foo.bar 和 foo.bar.baz 被导入，foo 被局部绑定\n"
"import foo.bar.baz as fbb  # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定为 fbb\n"
"from foo.bar import baz    # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定为 baz\n"
"from foo import attr       # foo 被导入并且 foo.attr 被绑定为 attr"

#: ../../reference/simple_stmts.rst:826
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names"
" defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"如果标识符列表改为一个星号 (``'*'``)，则在模块中定义的全部公有名称都将按 :keyword:`import` "
"语句所在的作用域被绑定到局部命名空间。"

#: ../../reference/simple_stmts.rst:832
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to"
" exist.  If ``__all__`` is not defined, the set of public names includes all"
" names found in the module's namespace which do not begin with an underscore"
" character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the "
"module)."
msgstr ""
"一个模块所定义的 *公有名称* 是由在模块的命名空间中检测一个名为 ``__all__`` "
"的变量来确定的；如果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 ``__all__`` "
"中所给出的名称都会被视为公有并且应当存在。 如果 ``__all__`` 没有被定义，则公有名称的集合将包含在模块的命名空间中找到的所有不以下划线字符 "
"(``'_'``) 打头的名称。 ``__all__`` 应当包括整个公有 API。 它的目标是避免意外地导出不属于 API "
"的一部分的项（例如在模块内部被导入和使用的库模块）。"

#: ../../reference/simple_stmts.rst:842
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"通配符形式的导入 --- ``from module import *`` --- 仅在模块层级上被允许。 尝试在类或函数定义中使用它将引发 "
":exc:`SyntaxError`。"

#: ../../reference/simple_stmts.rst:849
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top"
" package without having to mention the package name. By using leading dots "
"in the specified module or package after :keyword:`from` you can specify how"
" high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the"
" import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 "
"通过在 :keyword:`from` 之后指定的模块或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。 "
"一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示上溯两级，依此类推。 因此如果你执行 ``from . "
"import mod`` 时所处位置为 ``pkg`` 包内的一个模块，则最终你将导入 ``pkg.mod``。 如果你执行 ``from "
"..subpkg2 import mod`` 时所处位置为 ``pkg.subpkg1`` 则你将导入 ``pkg.subpkg2.mod``。 "
"有关相对导入的规范说明包含在 :ref:`relativeimports` 一节中。"

#: ../../reference/simple_stmts.rst:863
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ":func:`importlib.import_module` 被提供用来为动态地确定要导入模块的应用提供支持。"

#: ../../reference/simple_stmts.rst:866
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, "
"``sys.path_hooks``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``import`` 并附带参数 ``module``, ``filename``, "
"``sys.path``, ``sys.meta_path``, ``sys.path_hooks``。"

#: ../../reference/simple_stmts.rst:871
msgid "Future statements"
msgstr "future 语句"

#: ../../reference/simple_stmts.rst:877
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
":dfn:`future 语句` 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版中成为标准特性的语法或语义。"

#: ../../reference/simple_stmts.rst:881
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"future 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 "
"它允许基于每个模块在某种新特性成为标准之前的发行版中使用该特性。"

#: ../../reference/simple_stmts.rst:893
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr "future 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:"

#: ../../reference/simple_stmts.rst:896
msgid "the module docstring (if any),"
msgstr "模块的文档字符串（如果存在），"

#: ../../reference/simple_stmts.rst:897
msgid "comments,"
msgstr "注释，"

#: ../../reference/simple_stmts.rst:898
msgid "blank lines, and"
msgstr "空行，以及"

#: ../../reference/simple_stmts.rst:899
msgid "other future statements."
msgstr "其他 future 语句。"

#: ../../reference/simple_stmts.rst:901
msgid ""
"The only feature that requires using the future statement is ``annotations``"
" (see :pep:`563`)."
msgstr "唯一需要使用 future 语句的特性是 ``标注`` (参见 :pep:`563`)。"

#: ../../reference/simple_stmts.rst:904
msgid ""
"All historical features enabled by the future statement are still recognized"
" by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"future 语句所启用的所有历史特性仍然为 Python 3 所认可。  其中包括 ``absolute_import``, "
"``division``, ``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` 和 ``with_statement``。 "
"它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后兼容。"

#: ../../reference/simple_stmts.rst:911
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"future 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来实现。 "
"新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。"

#: ../../reference/simple_stmts.rst:918
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr "对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的特性则会引发编译时错误。"

#: ../../reference/simple_stmts.rst:922
msgid ""
"The direct runtime semantics are the same as for any import statement: there"
" is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 :mod:`__future__`，它会在执行 future "
"语句时以通常的方式被导入。"

#: ../../reference/simple_stmts.rst:926
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr "相应的运行时语义取决于 future 语句所启用的指定特性。"

#: ../../reference/simple_stmts.rst:929
msgid "Note that there is nothing special about the statement::"
msgstr "请注意以下语句没有任何特别之处::"

#: ../../reference/simple_stmts.rst:931
msgid "import __future__ [as name]"
msgstr "import __future__ [as name]"

#: ../../reference/simple_stmts.rst:933
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr "这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。"

#: ../../reference/simple_stmts.rst:936
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and "
":func:`compile` that occur in a module :mod:`!M` containing a future "
"statement will, by default, use the new syntax or semantics associated with "
"the future statement.  This can be controlled by optional arguments to "
":func:`compile` --- see the documentation of that function for details."
msgstr ""
"在默认情况下，通过对内置函数 :func:`exec` 和 :func:`compile` 的调用编译的代码如果出现于一个包含有 future "
"语句的模块 :mod:`!M` 之中，就会使用该 future 语句所关联的语法和语义。 此行为可以通过传给 :func:`compile` "
"的可选参数来控制 --- 请参阅该函数的文档了解详情。"

#: ../../reference/simple_stmts.rst:942
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的启动使用了 :option:`-i` "
"选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互式会话开始执行脚本之后保持有效。"

#: ../../reference/simple_stmts.rst:950
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - 回到 __future__"

#: ../../reference/simple_stmts.rst:951
msgid "The original proposal for the __future__ mechanism."
msgstr "有关 __future__ 机制的最初提议。"

#: ../../reference/simple_stmts.rst:957
msgid "The :keyword:`!global` statement"
msgstr ":keyword:`!global` 语句"

#: ../../reference/simple_stmts.rst:967
msgid ""
"The :keyword:`global` statement causes the listed identifiers to be "
"interpreted as globals. It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` 语句将使其所列出的标识符被解读为全局变量。 要给全局变量赋值不可能不用到 :keyword:`!global` "
"关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。"

#: ../../reference/simple_stmts.rst:972
msgid ""
"The :keyword:`global` statement applies to the entire scope of a function or"
" class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its global declaration in the scope."
msgstr ""
":keyword:`global` 语句将应用于函数或类语句体的整个作用域。 如果一个变量在本作用域的 global 声明之前被使用或赋值则会引发 "
":exc:`SyntaxError`。"

#: ../../reference/simple_stmts.rst:981
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained"
" in such a string is unaffected by :keyword:`!global` statements in the code"
" containing the function call.  The same applies to the :func:`eval` and "
":func:`compile` functions."
msgstr ""
"**程序员注意事项:** :keyword:`global` 是对解析器的指令。 它仅对与 :keyword:`!global` "
"语句同时被解析的代码起作用。 特别地，包含在提供给内置 :func:`exec` 函数字符串或代码对象中的 :keyword:`!global` "
"语句并不会影响 *包含* 该函数调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 :keyword:`!global` "
"语句影响。 这同样适用于 :func:`eval` 和 :func:`compile` 函数。"

#: ../../reference/simple_stmts.rst:993
msgid "The :keyword:`!nonlocal` statement"
msgstr ":keyword:`!nonlocal` 语句"

#: ../../reference/simple_stmts.rst:1001
msgid ""
"When the definition of a function or class is nested (enclosed) within the "
"definitions of other functions, its nonlocal scopes are the local scopes of "
"the enclosing functions. The :keyword:`nonlocal` statement causes the listed"
" identifiers to refer to names previously bound in nonlocal scopes. It "
"allows encapsulated code to rebind such nonlocal identifiers.  If a name is "
"bound in more than one nonlocal scope, the nearest binding is used. If a "
"name is not bound in any nonlocal scope, or if there is no nonlocal scope, a"
" :exc:`SyntaxError` is raised."
msgstr ""
"当一个函数或类的定义嵌套（被包围）在其他函数的定义中时，其非局部作用域就是包围它的函数的局部作用域 。 :keyword:`nonlocal` "
"语句会使其所列出的标识符指向之前在非局部作用域中绑定的名称。 它允许封装的代码重新绑定这样的非局部标识符。 "
"如果一个名称在多个非局部作用域中都被绑定，则会使用最近的绑定。 如果一个名称在任何非局部作用域中都未被绑定，或者不存在非局部作用域，则会引发 "
":exc:`SyntaxError`。"

#: ../../reference/simple_stmts.rst:1010
msgid ""
"The :keyword:`nonlocal` statement applies to the entire scope of a function "
"or class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its nonlocal declaration in the scope."
msgstr ""
":keyword:`nonlocal` 语句将应用于函数或类语句体的整个作用域。 如果一个变量在本作用域的 nonlocal "
"声明之前被使用或赋值则会引发 :exc:`SyntaxError`。"

#: ../../reference/simple_stmts.rst:1016
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - 访问外层作用域中的名称"

#: ../../reference/simple_stmts.rst:1017
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "有关 :keyword:`nonlocal` 语句的规范说明。"

#: ../../reference/simple_stmts.rst:1019
msgid ""
"**Programmer's note:** :keyword:`nonlocal` is a directive to the parser and "
"applies only to code parsed along with it.  See the note for the "
":keyword:`global` statement."
msgstr ""
"**程序员注意事项:** :keyword:`nonlocal` 是对解析器的指令并且仅会在与其一同被解析的代码上应用。 参见 "
":keyword:`global` 语句的相关注意事项。"

#: ../../reference/simple_stmts.rst:1027
msgid "The :keyword:`!type` statement"
msgstr ":keyword:`!type` 语句"

#: ../../reference/simple_stmts.rst:1034
msgid ""
"The :keyword:`!type` statement declares a type alias, which is an instance "
"of :class:`typing.TypeAliasType`."
msgstr ":keyword:`!type` 语句声明一个类型别名，即 :class:`typing.TypeAliasType` 的实例。"

#: ../../reference/simple_stmts.rst:1037
msgid "For example, the following statement creates a type alias::"
msgstr "例如，以下语句创建了一个类型别名::"

#: ../../reference/simple_stmts.rst:1039
msgid "type Point = tuple[float, float]"
msgstr "type Point = tuple[float, float]"

#: ../../reference/simple_stmts.rst:1041
msgid "This code is roughly equivalent to::"
msgstr "此代码大致等价于::"

#: ../../reference/simple_stmts.rst:1043
msgid ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"
msgstr ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"

#: ../../reference/simple_stmts.rst:1047
msgid ""
"``annotation-def`` indicates an :ref:`annotation scope <annotation-scopes>`,"
" which behaves mostly like a function, but with several small differences."
msgstr ""
"``annotation-def`` 指定一个 :ref:`标注作用域 <annotation-scopes>`，其行为很像是一个函数，但有几个小差别。"

#: ../../reference/simple_stmts.rst:1050
msgid ""
"The value of the type alias is evaluated in the annotation scope. It is not "
"evaluated when the type alias is created, but only when the value is "
"accessed through the type alias's :attr:`!__value__` attribute (see "
":ref:`lazy-evaluation`). This allows the type alias to refer to names that "
"are not yet defined."
msgstr ""
"类型别名的值是在标注作用域中被求值的。 当创建类型别名时它不会被求值，只有当通过该类型别名的 :attr:`!__value__` "
"属性访问时它才会被求值 (参见 :ref:`lazy-evaluation`)。 这允许类型别名引用尚未被定义的名称。"

#: ../../reference/simple_stmts.rst:1056
msgid ""
"Type aliases may be made generic by adding a :ref:`type parameter list "
"<type-params>` after the name. See :ref:`generic-type-aliases` for more."
msgstr ""
"类型别名可以通过在名称之后添加 :ref:`类型形参列表 <type-params>` 来泛型化。 请参阅 :ref:`generic-type-"
"aliases` 了解详情。"

#: ../../reference/simple_stmts.rst:1059
msgid ":keyword:`!type` is a :ref:`soft keyword <soft-keywords>`."
msgstr ":keyword:`!type` 是一个 :ref:`软关键字 <soft-keywords>`。"

#: ../../reference/simple_stmts.rst:1065
msgid ":pep:`695` - Type Parameter Syntax"
msgstr ":pep:`695` - 类型形参语法"

#: ../../reference/simple_stmts.rst:1066
msgid ""
"Introduced the :keyword:`!type` statement and syntax for generic classes and"
" functions."
msgstr "引入了 :keyword:`!type` 语句和用于泛型类和函数的语法。"

#: ../../reference/simple_stmts.rst:8
msgid "simple"
msgstr "simple"

#: ../../reference/simple_stmts.rst:8 ../../reference/simple_stmts.rst:39
#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322 ../../reference/simple_stmts.rst:382
#: ../../reference/simple_stmts.rst:425 ../../reference/simple_stmts.rst:447
#: ../../reference/simple_stmts.rst:460 ../../reference/simple_stmts.rst:486
#: ../../reference/simple_stmts.rst:523 ../../reference/simple_stmts.rst:559
#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:873
#: ../../reference/simple_stmts.rst:959 ../../reference/simple_stmts.rst:995
#: ../../reference/simple_stmts.rst:1029
msgid "statement"
msgstr "statement -- 语句"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
msgid "expression"
msgstr "expression -- 表达式"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:196 ../../reference/simple_stmts.rst:447
msgid "list"
msgstr "list"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:976
msgid "built-in function"
msgstr "内置函数"

#: ../../reference/simple_stmts.rst:56
msgid "repr"
msgstr "repr"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:75
#: ../../reference/simple_stmts.rst:187 ../../reference/simple_stmts.rst:196
#: ../../reference/simple_stmts.rst:207 ../../reference/simple_stmts.rst:581
msgid "object"
msgstr "object -- 对象"

#: ../../reference/simple_stmts.rst:56
msgid "None"
msgstr "None"

#: ../../reference/simple_stmts.rst:56
msgid "string"
msgstr "string"

#: ../../reference/simple_stmts.rst:56
msgid "conversion"
msgstr "conversion"

#: ../../reference/simple_stmts.rst:56
msgid "output"
msgstr "output"

#: ../../reference/simple_stmts.rst:56
msgid "standard"
msgstr "标准"

#: ../../reference/simple_stmts.rst:56
msgid "writing"
msgstr "writing"

#: ../../reference/simple_stmts.rst:56
msgid "values"
msgstr "values"

#: ../../reference/simple_stmts.rst:56
msgid "procedure"
msgstr "procedure"

#: ../../reference/simple_stmts.rst:56
msgid "call"
msgstr "call"

#: ../../reference/simple_stmts.rst:75
msgid "= (equals)"
msgstr "= (等于号)"

#: ../../reference/simple_stmts.rst:75
msgid "assignment statement"
msgstr "赋值语句"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:159 ../../reference/simple_stmts.rst:187
#: ../../reference/simple_stmts.rst:220 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322
msgid "assignment"
msgstr "赋值"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:743
#: ../../reference/simple_stmts.rst:798 ../../reference/simple_stmts.rst:959
msgid "binding"
msgstr "绑定"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:460
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:798
#: ../../reference/simple_stmts.rst:959
msgid "name"
msgstr "name"

#: ../../reference/simple_stmts.rst:75
msgid "rebinding"
msgstr "重新绑定"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:187
msgid "mutable"
msgstr "mutable -- 可变对象"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:159
#: ../../reference/simple_stmts.rst:469
msgid "attribute"
msgstr "attribute -- 属性"

#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:447 ../../reference/simple_stmts.rst:697
msgid "target"
msgstr "target"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:382
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:959
#: ../../reference/simple_stmts.rst:995
msgid ", (comma)"
msgstr ", (逗号)"

#: ../../reference/simple_stmts.rst:116
msgid "in target list"
msgstr "在目标列表中"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:824
msgid "* (asterisk)"
msgstr "* (星号)"

#: ../../reference/simple_stmts.rst:116
msgid "in assignment target list"
msgstr "在赋值目标列表中"

#: ../../reference/simple_stmts.rst:116
msgid "[] (square brackets)"
msgstr "[] (方括号)"

#: ../../reference/simple_stmts.rst:116
msgid "() (parentheses)"
msgstr "() (圆括号)"

#: ../../reference/simple_stmts.rst:153
msgid "destructor"
msgstr "destructor"

#: ../../reference/simple_stmts.rst:187
msgid "subscription"
msgstr "下标"

#: ../../reference/simple_stmts.rst:196
msgid "sequence"
msgstr "sequence"

#: ../../reference/simple_stmts.rst:207
msgid "mapping"
msgstr "mapping -- 映射"

#: ../../reference/simple_stmts.rst:207
msgid "dictionary"
msgstr "dictionary -- 字典"

#: ../../reference/simple_stmts.rst:220
msgid "slicing"
msgstr "切片"

#: ../../reference/simple_stmts.rst:263
msgid "augmented"
msgstr "增强"

#: ../../reference/simple_stmts.rst:263
msgid "assignment, augmented"
msgstr "赋值, 增强的"

#: ../../reference/simple_stmts.rst:263
msgid "+="
msgstr "+="

#: ../../reference/simple_stmts.rst:263
msgid "augmented assignment"
msgstr "增强赋值"

#: ../../reference/simple_stmts.rst:263
msgid "-="
msgstr "-="

#: ../../reference/simple_stmts.rst:263
msgid "*="
msgstr "*="

#: ../../reference/simple_stmts.rst:263
msgid "/="
msgstr "/="

#: ../../reference/simple_stmts.rst:263
msgid "%="
msgstr "%="

#: ../../reference/simple_stmts.rst:263
msgid "&="
msgstr "&="

#: ../../reference/simple_stmts.rst:263
msgid "^="
msgstr "^="

#: ../../reference/simple_stmts.rst:263
msgid "|="
msgstr "|="

#: ../../reference/simple_stmts.rst:263
msgid "**="
msgstr "**="

#: ../../reference/simple_stmts.rst:263
msgid "//="
msgstr "//="

#: ../../reference/simple_stmts.rst:263
msgid ">>="
msgstr ">>="

#: ../../reference/simple_stmts.rst:263
msgid "<<="
msgstr "<<="

#: ../../reference/simple_stmts.rst:322
msgid "annotated"
msgstr "带标注的"

#: ../../reference/simple_stmts.rst:322
msgid "assignment, annotated"
msgstr "赋值, 带标注的"

#: ../../reference/simple_stmts.rst:322
msgid ": (colon)"
msgstr ": (冒号)"

#: ../../reference/simple_stmts.rst:322
msgid "annotated variable"
msgstr "带标注的变量"

#: ../../reference/simple_stmts.rst:382
msgid "assert"
msgstr "assert"

#: ../../reference/simple_stmts.rst:382
msgid "debugging"
msgstr "调试"

#: ../../reference/simple_stmts.rst:382
msgid "assertions"
msgstr "断言"

#: ../../reference/simple_stmts.rst:382
msgid "expression list"
msgstr "表达式列表"

#: ../../reference/simple_stmts.rst:403
msgid "__debug__"
msgstr "__debug__"

#: ../../reference/simple_stmts.rst:403 ../../reference/simple_stmts.rst:523
#: ../../reference/simple_stmts.rst:559 ../../reference/simple_stmts.rst:591
#: ../../reference/simple_stmts.rst:743
msgid "exception"
msgstr "异常"

#: ../../reference/simple_stmts.rst:403
msgid "AssertionError"
msgstr "AssertionError"

#: ../../reference/simple_stmts.rst:425
msgid "pass"
msgstr "pass"

#: ../../reference/simple_stmts.rst:425
msgid "null"
msgstr "null"

#: ../../reference/simple_stmts.rst:425
msgid "operation"
msgstr "operation"

#: ../../reference/simple_stmts.rst:447
msgid "del"
msgstr "del"

#: ../../reference/simple_stmts.rst:447 ../../reference/simple_stmts.rst:469
msgid "deletion"
msgstr "删除"

#: ../../reference/simple_stmts.rst:460 ../../reference/simple_stmts.rst:959
msgid "global"
msgstr "global"

#: ../../reference/simple_stmts.rst:460
msgid "unbinding"
msgstr "解绑"

#: ../../reference/simple_stmts.rst:486
msgid "return"
msgstr "return"

#: ../../reference/simple_stmts.rst:486 ../../reference/simple_stmts.rst:523
msgid "function"
msgstr "function -- 函数"

#: ../../reference/simple_stmts.rst:486
msgid "definition"
msgstr "定义"

#: ../../reference/simple_stmts.rst:486
msgid "class"
msgstr "class"

#: ../../reference/simple_stmts.rst:502 ../../reference/simple_stmts.rst:697
#: ../../reference/simple_stmts.rst:706 ../../reference/simple_stmts.rst:718
#: ../../reference/simple_stmts.rst:743
msgid "keyword"
msgstr "关键字"

#: ../../reference/simple_stmts.rst:502 ../../reference/simple_stmts.rst:706
#: ../../reference/simple_stmts.rst:718
msgid "finally"
msgstr "finally"

#: ../../reference/simple_stmts.rst:523
msgid "yield"
msgstr "yield"

#: ../../reference/simple_stmts.rst:523
msgid "generator"
msgstr "generator -- 生成器"

#: ../../reference/simple_stmts.rst:523
msgid "iterator"
msgstr "iterator -- 迭代器"

#: ../../reference/simple_stmts.rst:523
msgid "StopIteration"
msgstr "StopIteration"

#: ../../reference/simple_stmts.rst:559
msgid "raise"
msgstr "raise"

#: ../../reference/simple_stmts.rst:559
msgid "raising"
msgstr "引发"

#: ../../reference/simple_stmts.rst:559
msgid "__traceback__ (exception attribute)"
msgstr "__traceback__ (异常属性)"

#: ../../reference/simple_stmts.rst:581
msgid "traceback"
msgstr "traceback -- 回溯"

#: ../../reference/simple_stmts.rst:591
msgid "chaining"
msgstr "chaining"

#: ../../reference/simple_stmts.rst:591
msgid "__cause__ (exception attribute)"
msgstr "__cause__ (异常属性)"

#: ../../reference/simple_stmts.rst:591
msgid "__context__ (exception attribute)"
msgstr "__context__ (异常属性)"

#: ../../reference/simple_stmts.rst:684
msgid "break"
msgstr "break"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "for"
msgstr "for"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "while"
msgstr "while"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "loop"
msgstr "循环"

#: ../../reference/simple_stmts.rst:697
msgid "else"
msgstr "else"

#: ../../reference/simple_stmts.rst:697
msgid "loop control"
msgstr "循环控制"

#: ../../reference/simple_stmts.rst:718
msgid "continue"
msgstr "continue"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:846
msgid "import"
msgstr "import"

#: ../../reference/simple_stmts.rst:743
msgid "module"
msgstr "module"

#: ../../reference/simple_stmts.rst:743
msgid "importing"
msgstr "importing -- 导入"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:798
msgid "from"
msgstr "from"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:785
msgid "as"
msgstr "as"

#: ../../reference/simple_stmts.rst:743
msgid "ImportError"
msgstr "ImportError"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:785
#: ../../reference/simple_stmts.rst:798 ../../reference/simple_stmts.rst:824
msgid "import statement"
msgstr "import 语句statement"

#: ../../reference/simple_stmts.rst:830
msgid "__all__ (optional module attribute)"
msgstr "__all__ (可选的模块属性)"

#: ../../reference/simple_stmts.rst:846
msgid "relative"
msgstr "相关"

#: ../../reference/simple_stmts.rst:873
msgid "future"
msgstr "future"

#: ../../reference/simple_stmts.rst:873
msgid "__future__"
msgstr "__future__"

#: ../../reference/simple_stmts.rst:873
msgid "future statement"
msgstr "future 语句"

#: ../../reference/simple_stmts.rst:959 ../../reference/simple_stmts.rst:995
msgid "identifier list"
msgstr "标识符列表"

#: ../../reference/simple_stmts.rst:976
msgid "exec"
msgstr "exec"

#: ../../reference/simple_stmts.rst:976
msgid "eval"
msgstr "eval"

#: ../../reference/simple_stmts.rst:976
msgid "compile"
msgstr "编译"

#: ../../reference/simple_stmts.rst:995
msgid "nonlocal"
msgstr "nonlocal"

#: ../../reference/simple_stmts.rst:1029
msgid "type"
msgstr "type"
