# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# 操旭 <caoxu3000@126.com>, 2017
# ww song <sww4718168@gmail.com>, 2018
# Fred <fred.wei@foxmail.com>, 2018
# dannyvi <dannyvis@icloud.com>, 2018
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-30 04:29+0000\n"
"PO-Revision-Date: 2017-02-16 23:38+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "表达式"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "本章将解释 Python 中组成表达式的各种元素的的含义。"

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr "**语法注释:** 在本章和后续章节中，会使用扩展 BNF 标注来描述语法而不是词法分析。 当（某种替代的）语法规则具有如下形式"

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr "并且没有给出语义，则这种形式的 ``name`` 在语法上与 ``othername`` 相同。"

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "算术转换"

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr "当对下述某个算术运算符的描述中使用了“数值参数被转换为普通类型”这样的说法，这意味着内置类型的运算符实现采用了如下运作方式:"

#: ../../reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr "如果任一参数为复数，另一参数会被转换为复数；"

#: ../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr "否则，如果任一参数为浮点数，另一参数会被转换为浮点数；"

#: ../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "否则，两者应该都为整数，不需要进行转换。"

#: ../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr "某些附加规则会作用于特定运算符（例如，字符串作为 '%' 运算符的左运算参数）。 扩展必须定义它们自己的转换行为。"

#: ../../reference/expressions.rst:49
msgid "Atoms"
msgstr "原子"

#: ../../reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"“原子”指表达式的最基本构成元素。 最简单的原子是标识符和字面值。 以圆括号、方括号或花括号包括的形式在语法上也被归类为原子。 原子的句法为:"

#: ../../reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "标识符（名称）"

#: ../../reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section "
":ref:`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"作为原子出现的标识符叫做名称。 请参看 :ref:`identifiers` 一节了解其词法定义，以及 :ref:`naming` "
"获取有关命名与绑定的文档。"

#: ../../reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a "
":exc:`NameError` exception."
msgstr "当名称被绑定到一个对象时，对该原子求值将返回相应对象。 当名称未被绑定时，尝试对其求值将引发 :exc:`NameError` 异常。"

#: ../../reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading"
" underscores removed and a single underscore inserted, in front of the name."
"  For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**私有名称转换:** 当以文本形式出现在类定义中的一个标识符以两个或更多下划线开头并且不以两个或更多下划线结尾，它会被视为该类的 "
":dfn:`私有名称`。 私有名称会在为其生成代码之前被转换为一种更长的形式。 转换时会插入类名，移除打头的下划线再在名称前增加一个下划线。 "
"例如，出现在一个名为 ``Ham`` 的类中的标识符 ``__spam`` 会被转换为 ``_Ham__spam``。 "
"这种转换独立于标识符所使用的相关句法。 如果转换后的名称太长（超过 255 个字符），可能发生由具体实现定义的截断。 "
"如果类名仅由下划线组成，则不会进行转换。"

#: ../../reference/expressions.rst:100
msgid "Literals"
msgstr "字面值"

#: ../../reference/expressions.rst:104
msgid ""
"Python supports string and bytes literals and various numeric literals:"
msgstr "Python 支持字符串和字节串字面值，以及几种数字字面值:"

#: ../../reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"对字面值求值将返回一个该值所对应类型的对象（字符串、字节串、整数、浮点数、复数）。 对于浮点数和虚数（复数）的情况，该值可能为近似值。 详情参见 "
":ref:`literals`。"

#: ../../reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals"
" with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"所有字面值都对应与不可变数据类型，因此对象标识的重要性不如其实际值。 "
"多次对具有相同值的字面值求值（不论是发生在程序文本的相同位置还是不同位置）可能得到相同对象或是具有相同值的不同对象。"

#: ../../reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr "带圆括号的形式"

#: ../../reference/expressions.rst:135
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "带圆括号的形式是包含在圆括号中的可选表达式列表。"

#: ../../reference/expressions.rst:140
msgid ""
"A parenthesized expression list yields whatever that expression list yields:"
" if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"带圆括号的表达式列表将返回该表达式列表所产生的任何东西：如果该列表包含至少一个逗号，它会产生一个元组；否则，它会产生该表达式列表所对应的单一表达式。"

#: ../../reference/expressions.rst:146
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are"
" immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"一对内容为空的圆括号将产生一个空的元组对象。 由于元组是不可变对象，因此适用与字面值相同的规则（即两次出现的空元组产生的对象可能相同也可能不同）。"

#: ../../reference/expressions.rst:154
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the"
" comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would"
" cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"请注意元组并不是由圆括号构建，实际起作用的是逗号操作符。 例外情况是空元组，这时圆括号 *才是* 必须的 --- 允许在表达式中使用不带圆括号的 "
"\"空\" 会导致歧义，并会造成常见输入错误无法被捕获。"

#: ../../reference/expressions.rst:163
msgid "Displays for lists, sets and dictionaries"
msgstr "列表、集合与字典的显示"

#: ../../reference/expressions.rst:167
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr "为了构建列表、集合或字典，Python 提供了名为“显示”的特殊句法，每个类型各有两种形式:"

#: ../../reference/expressions.rst:170
msgid "either the container contents are listed explicitly, or"
msgstr "第一种是显式地列出容器内容"

#: ../../reference/expressions.rst:172
msgid ""
"they are computed via a set of looping and filtering instructions, called a "
":dfn:`comprehension`."
msgstr "第二种是通过一组循环和筛选指令计算出来，称为 :dfn:`推导式`。"

#: ../../reference/expressions.rst:180
msgid "Common syntax elements for comprehensions are:"
msgstr "推导式的常用句法元素为:"

#: ../../reference/expressions.rst:188
msgid ""
"The comprehension consists of a single expression followed by at least one "
":keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or "
":keyword:`!if` clauses a block, nesting from left to right, and evaluating "
"the expression to produce an element each time the innermost block is "
"reached."
msgstr ""
"推导式的结构是一个单独表达式后面加至少一个 :keyword:`!for` 子句以及零个或更多个 :keyword:`!for` 或 "
":keyword:`!if` 子句。 在这种情况下，新容器的元素产生方式是将每个 :keyword:`!for` 或 :keyword:`!if` "
"子句视为一个代码块，按从左至右的顺序嵌套，然后每次到达最内层代码块时就对表达式进行求值以产生一个元素。"

#: ../../reference/expressions.rst:195
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope."
" This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"不过，除了最左边 :keyword:`!for` 子句中的可迭代表达式，推导式是在另一个隐式嵌套的作用域内执行的。 "
"这能确保赋给目标列表的名称不会“泄露”到外层的作用域。"

#: ../../reference/expressions.rst:199
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"最左边的 :keyword:`!for` 子句中的可迭代对象表达式会直接在外层作用域中被求值，然后作为一个参数被传给隐式嵌套的作用域。 后续的 "
":keyword:`!for` 子句以及最左侧 :keyword:`!for` "
"子句中的任何筛选条件不能在外层作用域中被求值，因为它们可能依赖于从最左侧可迭代对象中获得的值。 例如: ``[x*y for x in "
"range(10) for y in range(x, x+10)]``。"

#: ../../reference/expressions.rst:206
msgid ""
"To ensure the comprehension always results in a container of the appropriate"
" type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr "为了确保推导式得出的结果总是一个类型正确的容器，在隐式嵌套作用域内禁止使用 ``yield`` 和 ``yield from`` 表达式。"

#: ../../reference/expressions.rst:213
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a "
":keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions it is called an :dfn:`asynchronous comprehension`.  An "
"asynchronous comprehension may suspend the execution of the coroutine "
"function in which it appears. See also :pep:`530`."
msgstr ""
"从 Python 3.6 开始，在 :keyword:`async def` 函数中可以使用 :keyword:`!async for` 子句来迭代 "
":term:`asynchronous iterator`。 在 :keyword:`!async def` "
"函数中构建推导式可以通过在打头的表达式后加上 :keyword:`!for` 或 :keyword:`!async for` 子句，也可能包含额外的 "
":keyword:`!for` 或 :keyword:`!async for` 子句，还可能使用 :keyword:`await` 表达式。 "
"如果一个推导式包含 :keyword:`!async for` 子句或者 :keyword:`!await` 表达式，则被称为 "
":dfn:`异步推导式`。 异步推导式可以暂停执行它所在的协程函数。 另请参阅 :pep:`530`。"

#: ../../reference/expressions.rst:225
msgid "Asynchronous comprehensions were introduced."
msgstr "引入了异步推导式。"

#: ../../reference/expressions.rst:228 ../../reference/expressions.rst:401
msgid ""
"``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr "``yield`` 和 ``yield from`` 在隐式嵌套的作用域中已被禁用。"

#: ../../reference/expressions.rst:235
msgid "List displays"
msgstr "列表显示"

#: ../../reference/expressions.rst:245
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr "列表显示是一个用方括号括起来的可能为空的表达式系列:"

#: ../../reference/expressions.rst:251
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"列表显示会产生一个新的列表对象，其内容通过一系列表达式或一个推导式来指定。 "
"当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并按此顺序放入列表对象。 当提供一个推导式时，列表会根据推导式所产生的结果元素进行构建。"

#: ../../reference/expressions.rst:261
msgid "Set displays"
msgstr "集合显示"

#: ../../reference/expressions.rst:270
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary"
" displays by the lack of colons separating keys and values:"
msgstr "集合显示是用花括号标明的，与字典显示的区别在于没有冒号分隔的键和值:"

#: ../../reference/expressions.rst:276
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"集合显示会产生一个新的可变集合对象，其内容通过一系列表达式或一个推导式来指定。 "
"当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并加入到集合对象。 当提供一个推导式时，集合会根据推导式所产生的结果元素进行构建。"

#: ../../reference/expressions.rst:282
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr "空集合不能用 ``{}`` 来构建；该字面值所构建的是一个空字典。"

#: ../../reference/expressions.rst:289
msgid "Dictionary displays"
msgstr "字典显示"

#: ../../reference/expressions.rst:300
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr "字典显示是一个用花括号括起来的可能为空的键/数据对系列:"

#: ../../reference/expressions.rst:309
msgid "A dictionary display yields a new dictionary object."
msgstr "字典显示会产生一个新的字典对象。"

#: ../../reference/expressions.rst:311
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"如果给出一个由逗号分隔的键/数据对序列，它们会从左至右被求值以定义字典的条目：每个键对象会被用作在字典中存放相应数据的键。 "
"这意味着你可以在键/数据对序列中多次指定相同的键，最终字典的值将由最后一次给出的键决定。"

#: ../../reference/expressions.rst:321
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"双星号 ``**`` 表示 :dfn:`字典拆包`。 它的操作数必须是一个 :term:`mapping`。 每个映射项被会加入新的字典。 "
"后续的值会替代先前的键/数据对和先前的字典拆包所设置的值。"

#: ../../reference/expressions.rst:326
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr "拆包到字典显示，最初由 :pep:`448` 提出。"

#: ../../reference/expressions.rst:329
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements"
" are inserted in the new dictionary in the order they are produced."
msgstr ""
"字典推导式与列表和集合推导式有所不同，它需要以冒号分隔的两个表达式，后面带上标准的 \"for\" 和 \"if\" 子句。 "
"当推导式被执行时，作为结果的键和值元素会按它们的产生顺序被加入新的字典。"

#: ../../reference/expressions.rst:337
msgid ""
"Restrictions on the types of the key values are listed earlier in section "
":ref:`types`.  (To summarize, the key type should be :term:`hashable`, which"
" excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"对键取值类型的限制已列在之前的 :ref:`types` 一节中。 (总的说来，键的类型应该为 "
":term:`hashable`，这就把所有可变对象都排除在外。) 重复键之间的冲突不会被检测；指定键所保存的最后一个数据 (即在显示中排最右边的文本)"
" 为最终有效数据。"

#: ../../reference/expressions.rst:343
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and"
" value was not well-defined.  In CPython, the value was evaluated before the"
" key.  Starting with 3.8, the key is evaluated before the value, as proposed"
" by :pep:`572`."
msgstr ""
"在 Python 3.8 之前的字典推导式中，并没有定义好键和值的求值顺序。 在 CPython 中，值会先于键被求值。 根据 :pep:`572` "
"的提议，从 3.8 开始，键会先于值被求值。"

#: ../../reference/expressions.rst:353
msgid "Generator expressions"
msgstr "生成器表达式"

#: ../../reference/expressions.rst:360
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "生成器表达式是用圆括号括起来的紧凑形式生成器标注。"

#: ../../reference/expressions.rst:365
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr "生成器表达式会产生一个新的生成器对象。 其句法与推导式相同，区别在于它是用圆括号而不是用方括号或花括号括起来的。"

#: ../../reference/expressions.rst:369
msgid ""
"Variables used in the generator expression are evaluated lazily when the "
":meth:`~generator.__next__` method is called for the generator object (in "
"the same fashion as normal generators).  However, the iterable expression in"
" the leftmost :keyword:`!for` clause is immediately evaluated, so that an "
"error produced by it will be emitted at the point where the generator "
"expression is defined, rather than at the point where the first value is "
"retrieved. Subsequent :keyword:`!for` clauses and any filter condition in "
"the leftmost :keyword:`!for` clause cannot be evaluated in the enclosing "
"scope as they may depend on the values obtained from the leftmost iterable. "
"For example: ``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"在生成器表达式中使用的变量会在为生成器对象调用 :meth:`~generator.__next__` "
"方法的时候以惰性方式被求值（即与普通生成器相同的方式）。 但是，最左侧 :keyword:`!for` "
"子句内的可迭代对象是会被立即求值的，因此它所造成的错误会在生成器表达式被定义时被检测到，而不是在获取第一个值时才出错。 后续的 "
":keyword:`!for` 子句以及最左侧 :keyword:`!for` "
"子句内的任何筛选条件无法在外层作用域内被求值，因为它们可能会依赖于从最左侧可迭代对象获取的值。 例如: ``(x*y for x in "
"range(10) for y in range(x, x+10))``."

#: ../../reference/expressions.rst:380
msgid ""
"The parentheses can be omitted on calls with only one argument.  See section"
" :ref:`calls` for details."
msgstr "圆括号在只附带一个参数的调用中可以被省略。 详情参见 :ref:`calls` 一节。"

#: ../../reference/expressions.rst:383
msgid ""
"To avoid interfering with the expected operation of the generator expression"
" itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr "为了避免干扰到生成器表达式本身的预期操作，禁止在隐式定义的生成器中使用 ``yield`` 和 ``yield from`` 表达式。"

#: ../../reference/expressions.rst:387
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or "
":keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref"
":`async-iterators`)."
msgstr ""
"如果生成器表达式包含 :keyword:`!async for` 子句或 :keyword:`await` 表达式，则称为 "
":dfn:`异步生成器表达式`。 异步生成器表达式会返回一个新的异步生成器对象，此对象属于异步迭代器 (参见 :ref:`async-"
"iterators`)。"

#: ../../reference/expressions.rst:393
msgid "Asynchronous generator expressions were introduced."
msgstr "引入了异步生成器表达式。"

#: ../../reference/expressions.rst:396
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear in"
" :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"在 Python 3.7 之前，异步生成器表达式只能在 :keyword:`async def` 协和中出现。 从 3.7 "
"开始，任何函数都可以使用异步生成器表达式。"

#: ../../reference/expressions.rst:408
msgid "Yield expressions"
msgstr "yield 表达式"

#: ../../reference/expressions.rst:420
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator, and using it in an "
":keyword:`async def` function's body causes that coroutine function to be an"
" asynchronous generator. For example::"
msgstr ""
"yield 表达式在定义 :term:`generator` 函数或是 :term:`asynchronous generator` 的时候才会用到。 "
"因此只能在函数定义的内部使用yield表达式。 在一个函数体内使用 yield 表达式会使这个函数变成一个生成器，并且在一个 "
":keyword:`async def` 定义的函数体内使用 yield 表达式会让协程函数变成异步的生成器。 比如说::"

#: ../../reference/expressions.rst:433
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are"
" not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr "由于它们会对外层作用域造成附带影响，``yield`` 表达式不被允许作为用于实现推导式和生成器表达式的隐式定义作用域的一部分。"

#: ../../reference/expressions.rst:437
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr "禁止在实现推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达式。"

#: ../../reference/expressions.rst:441
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"下面是对生成器函数的描述，异步生成器函数会在 :ref:`asynchronous-generator-functions` 一节中单独介绍。"

#: ../../reference/expressions.rst:445
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield expression,"
" where it is suspended again, returning the value of "
":token:`expression_list` to the generator's caller.  By suspended, we mean "
"that all local state is retained, including the current bindings of local "
"variables, the instruction pointer, the internal evaluation stack, and the "
"state of any exception handling.  When the execution is resumed by calling "
"one of the generator's methods, the function can proceed exactly as if the "
"yield expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the execution."
"  If :meth:`~generator.__next__` is used (typically via either a "
":keyword:`for` or the :func:`next` builtin) then the result is "
":const:`None`.  Otherwise, if :meth:`~generator.send` is used, then the "
"result will be the value passed in to that method."
msgstr ""
"当一个生成器函数被调用的时候，它返回一个迭代器，称为生成器。然后这个生成器来控制生成器函数的执行。当这个生成器的某一个方法被调用的时候，生成器函数开始执行。这时会一直执行到第一个"
" yield 表达式，在此执行再次被挂起，给生成器的调用者返回  :token:`expression_list` "
"的值。挂起后，我们说所有局部状态都被保留下来，包括局部变量的当前绑定，指令指针，内部求值栈和任何异常处理的状态。通过调用生成器的某一个方法，生成器函数继续执行。此时函数的运行就和"
" yield 表达式只是一个外部函数调用的情况完全一致。恢复后 yield 表达式的值取决于调用的哪个方法来恢复执行。 如果用的是 "
":meth:`~generator.__next__` (通常通过语言内置的 :keyword:`for` 或是 :func:`next` 来调用) "
"那么结果就是 :const:`None`.  否则，如果用 :meth:`~generator.send`, 那么结果就是传递给send方法的值。"

#: ../../reference/expressions.rst:464
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields;"
" the control is always transferred to the generator's caller."
msgstr ""
"所有这些使生成器函数与协程非常相似；它们 yield 多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是生成器函数不能控制在它在 "
"yield 后交给哪里继续执行；控制权总是转移到生成器的调用者。"

#: ../../reference/expressions.rst:470
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's "
":meth:`~generator.close` method will be called, allowing any pending "
":keyword:`finally` clauses to execute."
msgstr ""
"在 :keyword:`try` 结构中的任何位置都允许yield表达式。如果生成器在(因为引用计数到零或是因为被垃圾回收)销毁之前没有恢复执行"
"，将调用生成器-迭代器的 :meth:`~generator.close` 方法. close 方法允许任何挂起的 :keyword:`finally`"
" 子句执行。"

#: ../../reference/expressions.rst:479
msgid ""
"When ``yield from <expr>`` is used, it treats the supplied expression as a "
"subiterator. All values produced by that subiterator are passed directly to "
"the caller of the current generator's methods. Any values passed in with "
":meth:`~generator.send` and any exceptions passed in with "
":meth:`~generator.throw` are passed to the underlying iterator if it has the"
" appropriate methods.  If this is not the case, then :meth:`~generator.send`"
" will raise :exc:`AttributeError` or :exc:`TypeError`, while "
":meth:`~generator.throw` will just raise the passed in exception "
"immediately."
msgstr ""
"当使用 ``yield from <expr>`` 时，它会将所提供的表达式视为一个子迭代器。 "
"这个子迭代器产生的所有值都直接被传递给当前生成器方法的调用者。 通过 :meth:`~generator.send` 传入的任何值以及通过 "
":meth:`~generator.throw` 传入的任何异常如果有适当的方法则会被传给下层迭代器。 如果不是这种情况，那么 "
":meth:`~generator.send` 将引发 :exc:`AttributeError` 或 :exc:`TypeError`，而 "
":meth:`~generator.throw` 将立即引发所传入的异常。"

#: ../../reference/expressions.rst:488
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising "
":exc:`StopIteration`, or automatically when the subiterator is a generator "
"(by returning a value from the subgenerator)."
msgstr ""
"当下层迭代器完成时，被引发的 :exc:`StopIteration` 实例的 :attr:`~StopIteration.value` 属性会成为 "
"yield 表达式的值。 它可以在引发 :exc:`StopIteration` "
"时被显式地设置，也可以在子迭代器是一个生成器时自动地设置（通过从子生成器返回一个值）。"

#: ../../reference/expressions.rst:494
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr "添加 ``yield from <expr>`` 以委托控制流给一个子迭代器。"

#: ../../reference/expressions.rst:497
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr "当yield表达式是赋值语句右侧的唯一表达式时，括号可以省略。"

#: ../../reference/expressions.rst:503
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 简单生成器"

#: ../../reference/expressions.rst:503
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "在 Python 中加入生成器和 :keyword:`yield` 语句的提议。"

#: ../../reference/expressions.rst:507
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 通过增强型生成器实现协程"

#: ../../reference/expressions.rst:506
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable"
" as simple coroutines."
msgstr "增强生成器 API 和语法的提议，使其可以被用作简单的协程。"

#: ../../reference/expressions.rst:511
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - 委托给子生成器的语法"

#: ../../reference/expressions.rst:510
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making delegation "
"to subgenerators easy."
msgstr "引入 :token:`yield_from` 语法以方便地委托给子生成器的提议。"

#: ../../reference/expressions.rst:514
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - 异步生成器"

#: ../../reference/expressions.rst:514
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to"
" coroutine functions."
msgstr "通过给协程函数加入生成器功能对 :pep:`492` 进行扩展的提议。"

#: ../../reference/expressions.rst:521
msgid "Generator-iterator methods"
msgstr "生成器-迭代器的方法"

#: ../../reference/expressions.rst:523
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr "这个子小节描述了生成器迭代器的方法。 它们可被用于控制生成器函数的执行。"

#: ../../reference/expressions.rst:526
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr "请注意在生成器已经在执行时调用以下任何方法都会引发 :exc:`ValueError` 异常。"

#: ../../reference/expressions.rst:534
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a "
":meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the "
":token:`expression_list` is returned to :meth:`__next__`'s caller.  If the "
"generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised."
msgstr ""
"开始一个生成器函数的执行或是从上次执行的 yield 表达式位置恢复执行。 当一个生成器函数通过 :meth:`~generator.__next__`"
" 方法恢复执行时，当前的 yield 表达式总是取值为 :const:`None`。 随后会继续执行到下一个 yield 表达式，其 "
":token:`expression_list` 的值会返回给 :meth:`__next__` 的调用者。 如果生成器没有产生下一个值就退出，则将引发"
" :exc:`StopIteration` 异常。"

#: ../../reference/expressions.rst:543
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or"
" by the built-in :func:`next` function."
msgstr "此方法通常是隐式地调用，例如通过 :keyword:`for` 循环或是内置的 :func:`next` 函数。"

#: ../../reference/expressions.rst:549
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"恢复执行并向生成器函数“发送”一个值。 *value* 参数将成为当前 yield 表达式的结果。 :meth:`send` "
"方法会返回生成器所产生的下一个值，或者如果生成器没有产生下一个值就退出则会引发 :exc:`StopIteration`。 当调用 "
":meth:`send` 来启动生成器时，它必须以 :const:`None` 作为调用参数，因为这时没有可以接收值的 yield 表达式。"

#: ../../reference/expressions.rst:560
msgid ""
"Raises an exception of type ``type`` at the point where the generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in"
" exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""
"在生成器暂停的位置引发 ``type`` 类型的异常，并返回该生成器函数所产生的下一个值。 如果生成器没有产生下一个值就退出，则将引发 "
":exc:`StopIteration` 异常。 如果生成器函数没有捕获传入的异常，或引发了另一个异常，则该异常会被传播给调用者。"

#: ../../reference/expressions.rst:571
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed,"
" or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a "
":exc:`RuntimeError` is raised.  If the generator raises any other exception,"
" it is propagated to the caller.  :meth:`close` does nothing if the "
"generator has already exited due to an exception or normal exit."
msgstr ""
"在生成器函数暂停的位置引发 :exc:`GeneratorExit`。 如果之后生成器函数正常退出、关闭或引发 :exc:`GeneratorExit`"
" (由于未捕获该异常) 则关闭并返回其调用者。 如果生成器产生了一个值，关闭会引发 :exc:`RuntimeError`。 "
"如果生成器引发任何其他异常，它会被传播给调用者。 如果生成器已经由于异常或正常退出则 :meth:`close` 不会做任何事。"

#: ../../reference/expressions.rst:582
msgid "Examples"
msgstr "示例"

#: ../../reference/expressions.rst:584
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr "这里是一个简单的例子，演示了生成器和生成器函数的行为::"

#: ../../reference/expressions.rst:611
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr "对于 ``yield from`` 的例子, 参见“Python 有什么新变化”中的 :ref:`pep-380`。"

#: ../../reference/expressions.rst:617
msgid "Asynchronous generator functions"
msgstr "异步生成器函数"

#: ../../reference/expressions.rst:619
msgid ""
"The presence of a yield expression in a function or method defined using "
":keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"在一个使用 :keyword:`async def` 定义的函数或方法中出现的 yield 表达式会进一步将该函数定义为一个 "
":term:`asynchronous generator` 函数。"

#: ../../reference/expressions.rst:623
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object"
" then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a"
" coroutine function analogously to how a generator object would be used in a"
" :keyword:`for` statement."
msgstr ""
"当一个异步生成器函数被调用时，它会返回一个名为异步生成器对象的异步迭代器。 此对象将在之后控制该生成器函数的执行。 异步生成器对象通常被用在协程函数的 "
":keyword:`async for` 语句中，类似于在 :keyword:`for` 语句中使用生成器对象。"

#: ../../reference/expressions.rst:630
msgid ""
"Calling one of the asynchronous generator's methods returns an "
":term:`awaitable` object, and the execution starts when this object is "
"awaited on. At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the awaiting coroutine. As with a generator, "
"suspension means that all local state is retained, including the current "
"bindings of local variables, the instruction pointer, the internal "
"evaluation stack, and the state of any exception handling.  When the "
"execution is resumed by awaiting on the next object returned by the "
"asynchronous generator's methods, the function can proceed exactly as if the"
" yield expression were just another external call. The value of the yield "
"expression after resuming depends on the method which resumed the execution."
"  If :meth:`~agen.__anext__` is used then the result is :const:`None`. "
"Otherwise, if :meth:`~agen.asend` is used, then the result will be the value"
" passed in to that method."
msgstr ""
"调用异步生成器的方法之一将返回 :term:`awaitable` 对象，执行会在此对象被等待时启动。 到那时，执行将前往第一个 yield "
"表达式，在那里它会再次暂停，将 :token:`expression_list` 的值返回给等待中的协程。 "
"与生成器一样，挂起意味着局部的所有状态会被保留，包括局部变量的当前绑定、指令的指针、内部求值的堆栈以及任何异常处理的状态。 "
"当执行在等待异步生成器的方法返回下一个对象后恢复时，该函数可以从原状态继续进行，就仿佛 yield 表达式只是另一个外部调用。 恢复执行之后 yield"
" 表达式的值取决于恢复执行所用的方法。 如果使用 :meth:`~agen.__anext__` 则结果为 :const:`None`。 "
"否则的话，如果使用 :meth:`~agen.asend` 则结果将是传递给该方法的值。"

#: ../../reference/expressions.rst:646
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending "
":keyword:`!finally` clauses to execute."
msgstr ""
"在异步生成器函数中，yield 表达式允许出现在 :keyword:`try` 结构的任何位置。 "
"但是，如果一个异步生成器在其被终结（由于引用计数达到零或被作为垃圾回收）之前未被恢复，则then a yield expression within a"
" :keyword:`!try` 结构中的 yield 表达式可能导致挂起的 :keyword:`finally` 子句执行失败。 在此情况下"
"，应由运行该异步生成器的事件循环或任务调度器来负责调用异步生成器-迭代器的 :meth:`~agen.aclose` "
"方法并运行所返回的协程对象，从而允许任何挂起的 :keyword:`!finally` 子句得以执行。"

#: ../../reference/expressions.rst:657
msgid ""
"To take care of finalization, an event loop should define a *finalizer* "
"function which takes an asynchronous generator-iterator and presumably calls"
" :meth:`~agen.aclose` and executes the coroutine. This  *finalizer* may be "
"registered by calling :func:`sys.set_asyncgen_hooks`. When first iterated "
"over, an asynchronous generator-iterator will store the registered "
"*finalizer* to be called upon finalization. For a reference example of a "
"*finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/asyncio/base_events.py`."
msgstr ""
"为了能处理最终化，事件循环应该定义一个 *终结器* 函数，它接受一个异步生成器-迭代器且可能调用 :meth:`~agen.aclose` 并执行协程。"
" 这个  *终结器* 可能通过调用 :func:`sys.set_asyncgen_hooks` 来注册。 当首次迭代时，异步生成器-"
"迭代器将保存已注册的 *终结器* 以便在最终化时调用。 有关For a reference example of a *终结器* 方法的参考示例请查看 "
":source:`Lib/asyncio/base_events.py` 中实现的 "
"``asyncio.Loop.shutdown_asyncgens``。"

#: ../../reference/expressions.rst:666
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr "``yield from <expr>`` 表达式如果在异步生成器函数中使用会引发语法错误。"

#: ../../reference/expressions.rst:673
msgid "Asynchronous generator-iterator methods"
msgstr "异步生成器-迭代器方法"

#: ../../reference/expressions.rst:675
msgid ""
"This subsection describes the methods of an asynchronous generator iterator,"
" which are used to control the execution of a generator function."
msgstr "这个子小节描述了异步生成器迭代器的方法，它们可被用于控制生成器函数的执行。"

#: ../../reference/expressions.rst:683
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`expression_list` of the yield "
"expression is the value of the :exc:`StopIteration` exception raised by the "
"completing coroutine.  If the asynchronous generator exits without yielding "
"another value, the awaitable instead raises a :exc:`StopAsyncIteration` "
"exception, signalling that the asynchronous iteration has completed."
msgstr ""
"返回一个可等待对象，它在运行时会开始执行该异步生成器或是从上次执行的 yield 表达式位置恢复执行。 当一个异步生成器函数通过 "
":meth:`~agen.__anext__` 方法恢复执行时，当前的 yield 表达式所返回的可等待对象总是取值为 "
":const:`None`，它在运行时将继续执行到下一个 yield 表达式。 该 yield 表达式的 "
":token:`expression_list` 的值会是完成的协程所引发的 :exc:`StopIteration` 异常的值。 "
"如果异步生成器没有产生下一个值就退出，则该可等待对象将引发 :exc:`StopAsyncIteration` 异常，提示该异步迭代操作已完成。"

#: ../../reference/expressions.rst:695
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr "此方法通常是通过 :keyword:`async for` 循环隐式地调用。"

#: ../../reference/expressions.rst:700
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression."
" The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised "
":exc:`StopIteration`, or raises :exc:`StopAsyncIteration` if the "
"asynchronous generator exits without yielding another value.  When "
":meth:`asend` is called to start the asynchronous generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"返回一个可等待对象，它在运行时会恢复该异步生成器的执行。 与生成器的 :meth:`~generator.send()` "
"方法一样，此方法会“发送”一个值给异步生成器函数，其 *value* 参数会成为当前 yield 表达式的结果值。 :meth:`asend` "
"方法所返回的可等待对象将返回生成器产生的下一个值，其值为所引发的 "
":exc:`StopIteration`，或者如果异步生成器没有产生下一个值就退出则引发 :exc:`StopAsyncIteration`。 当调用 "
":meth:`asend` 来启动异步生成器时，它必须以 :const:`None` 作为调用参数，因为这时没有可以接收值的 yield 表达式。"

#: ../../reference/expressions.rst:715
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised "
":exc:`StopIteration` exception.  If the asynchronous generator exits without"
" yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"返回一个可等待对象，它会在异步生成器暂停的位置引发 ``type`` 类型的异常，并返回该生成器函数所产生的下一个值，其值为所引发的 "
":exc:`StopIteration` 异常。 如果异步生成器没有产生下一个值就退出，则将由该可等待对象引发 "
":exc:`StopAsyncIteration` 异步。 "
"如果生成器函数没有捕获传入的异常，或引发了另一个异常，则当可等待对象运行时该异常会被传播给可等待对象的调用者。"

#: ../../reference/expressions.rst:730
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the"
" asynchronous generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"返回一个可等待对象，它会在运行时向异步生成器函数暂停的位置抛入一个 :exc:`GeneratorExit`。 如果该异步生成器函数正常退出、关闭或引发"
" :exc:`GeneratorExit` (由于未捕获该异常) 则返回的可等待对象将引发 :exc:`StopIteration` 异常。 "
"后续调用异步生成器所返回的任何其他可等待对象将引发 :exc:`StopAsyncIteration` 异常。 "
"如果异步生成器产生了一个值，该可等待对象会引发 :exc:`RuntimeError`。 "
"如果异步生成器引发任何其他异常，它会被传播给可等待对象的调用者。 如果异步生成器已经由于异常或正常退出则后续调用 :meth:`aclose` "
"将返回一个不会做任何事的可等待对象。"

#: ../../reference/expressions.rst:746
msgid "Primaries"
msgstr "原型"

#: ../../reference/expressions.rst:750
msgid ""
"Primaries represent the most tightly bound operations of the language. Their"
" syntax is:"
msgstr "原型代表编程语言中最紧密绑定的操作。 它们的句法如下:"

#: ../../reference/expressions.rst:760
msgid "Attribute references"
msgstr "属性引用"

#: ../../reference/expressions.rst:766
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "属性引用是后面带有一个句点加一个名称的原型:"

#: ../../reference/expressions.rst:776
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the"
" attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple"
" evaluations of the same attribute reference may yield different objects."
msgstr ""
"此原型必须求值为一个支持属性引用的类型的对象，多数对象都支持属性引用。 随后该对象会被要求产生以指定标识符为名称的属性。 这个产生过程可通过重载 "
":meth:`__getattr__` 方法来自定义。 如果这个属性不可用，则将引发 :exc:`AttributeError` 异常。 "
"否则的话，所产生对象的类型和值会根据该对象来确定。 对同一属性引用的多次求值可能产生不同的对象。"

#: ../../reference/expressions.rst:788
msgid "Subscriptions"
msgstr "抽取"

#: ../../reference/expressions.rst:803
msgid ""
"Subscription of a sequence (string, tuple or list) or mapping (dictionary) "
"object usually selects an item from the collection:"
msgstr "对序列（字符串、元组或列表）或映射（字典）对象的抽取操作通常就是从相应的多项集中选择一项:"

#: ../../reference/expressions.rst:809
msgid ""
"The primary must evaluate to an object that supports subscription (lists or "
"dictionaries for example).  User-defined objects can support subscription by"
" defining a :meth:`__getitem__` method."
msgstr ""
"此原型必须求值为一个支持抽取操作的对象（例如列表或字典）。 用户定义的对象可通过定义 :meth:`__getitem__` 方法来支持抽取操作。"

#: ../../reference/expressions.rst:813
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr "对于内置对象，有两种类型的对象支持抽取操作:"

#: ../../reference/expressions.rst:815
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list"
" is a tuple except if it has exactly one item.)"
msgstr ""
"如果原型为映射，表达式列表必须求值为一个以该映射的键为值的对象，抽取操作会在映射中选出该键所对应的值。（表达式列表为一个元组，除非其中只有一项。）"

#: ../../reference/expressions.rst:820
msgid ""
"If the primary is a sequence, the expression list must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr "如果原型为序列，表达式列表必须求值为一个整数或一个切片（详情见下节）。"

#: ../../reference/expressions.rst:823
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the sequence"
" to the index (so that ``x[-1]`` selects the last item of ``x``).  The "
"resulting value must be a nonnegative integer less than the number of items "
"in the sequence, and the subscription selects the item whose index is that "
"value (counting from zero). Since the support for negative indices and "
"slicing occurs in the object's :meth:`__getitem__` method, subclasses "
"overriding this method will need to explicitly add that support."
msgstr ""
"正式句法规则并没有在序列中设置负标号的特殊保留条款；但是，内置序列所提供的 :meth:`__getitem__` "
"方法都可通过在索引中添加序列长度来解析负标号 (这样 ``x[-1]`` 会选出 ``x`` 中的最后一项)。 "
"结果值必须为一个小于序列中项数的非负整数，抽取操作会选出标号为该值的项（从零开始数）。 由于对负标号和切片的支持存在于对象的 "
":meth:`__getitem__` 方法，重载此方法的子类需要显式地添加这种支持。"

#: ../../reference/expressions.rst:837
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr "字符串的项是字符。 字符不是单独的数据类型而是仅有一个字符的字符串。"

#: ../../reference/expressions.rst:840
msgid ""
"Subscription of certain :term:`classes <class>` or :term:`types <type>` "
"creates a :ref:`generic alias <types-genericalias>`. In this case, user-"
"defined classes can support subscription by providing a "
":meth:`__class_getitem__` classmethod."
msgstr ""

#: ../../reference/expressions.rst:849
msgid "Slicings"
msgstr "切片"

#: ../../reference/expressions.rst:863
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"切片就是在序列对象（字符串、元组或列表）中选择某个范围内的项。 切片可被用作表达式以及赋值或 :keyword:`del` 语句的目标。 "
"切片的句法如下:"

#: ../../reference/expressions.rst:876
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this"
" is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"此处的正式句法中存在一点歧义：任何形似表达式列表的东西同样也会形似切片列表，因此任何抽取操作也可以被解析为切片。 "
"为了不使句法更加复杂，于是通过定义将此情况解析为抽取优先于解析为切片来消除这种歧义（切片列表未包含正确的切片就属于此情况）。"

#: ../../reference/expressions.rst:888
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section "
":ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and "
":attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for"
" missing expressions."
msgstr ""
"切片的语义如下所述。 元型通过一个根据下面的切片列表来构造的键进行索引（与普通抽取一样使用 :meth:`__getitem__` 方法）。 "
"如果切片列表包含至少一个逗号，则键将是一个包含切片项转换的元组；否则的话，键将是单个切片项的转换。 切片项如为一个表达式，则其转换就是该表达式。 "
"一个正确切片的转换就是一个切片对象（参见 :ref:`types` 一节），该对象的 :attr:`~slice.start`, "
":attr:`~slice.stop` 和 :attr:`~slice.step` 属性将分别为表达式所给出的下界、上界和步长值，省略的表达式将用 "
"``None`` 来替换。"

#: ../../reference/expressions.rst:912
msgid "Calls"
msgstr "调用"

#: ../../reference/expressions.rst:914
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"所谓调用就是附带可能为空的一系列 :term:`参数 <argument>` 来执行一个可调用对象 (例如 :term:`function`):"

#: ../../reference/expressions.rst:931
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr "一个可选项为在位置和关键字参数后加上逗号而不影响语义。"

#: ../../reference/expressions.rst:937
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of formal"
" :term:`parameter` lists."
msgstr ""
"此原型必须求值为一个可调用对象（用户定义的函数，内置函数，内置对象的方法，类对象，类实例的方法以及任何具有 :meth:`__call__` "
"方法的对象都是可调用对象）。 所有参数表达式将在尝试调用前被求值。 请参阅 :ref:`function` 一节了解正式的 "
":term:`parameter` 列表句法。"

#: ../../reference/expressions.rst:945
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"如果存在关键字参数，它们会先通过以下操作被转换为位置参数。 首先，为正式参数创建一个未填充空位的列表. 如果有 N 个位置参数，则将它们放入前 N "
"个空位。 然后，对于每个关键字参数，使用标识符来确定其对应的空位（如果标识符与第一个正式参数名相同则使用第一个个空位，依此类推）。 "
"如果空位已被填充，则会引发 :exc:`TypeError` 异常。 否则，将参数值放入空位进行填充（即使表达式为 ``None`` 也会填充空位）。 "
"当所有参数处理完毕时，尚未填充的空位将用来自函数定义的相应默认值来填充。 "
"（函数一旦定义其参数默认值就会被计算；因此，当列表或字典这类可变对象被用作默认值时，将会被所有未指定相应空位参数值的调用所共享；这种情况通常应当避免。）"
" 如果任何一个未填充空位没有指定默认值，则会引发 :exc:`TypeError` 异常。 否则的话，已填充空位的列表会被作为调用的参数列表。"

#: ../../reference/expressions.rst:965
msgid ""
"An implementation may provide built-in functions whose positional parameters"
" do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use "
":c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"某些实现可能提供位置参数没有名称的内置函数，即使它们在文档说明的场合下有“命名”，因此不能以关键字形式提供参数。 在 CPython 中，以 C "
"编写并使用 :c:func:`PyArg_ParseTuple` 来解析其参数的函数实现就属于这种情况。"

#: ../../reference/expressions.rst:971
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an"
" empty tuple if there were no excess positional arguments)."
msgstr ""
"如果存在比正式参数空位多的位置参数，将会引发 :exc:`TypeError` 异常，除非有一个正式参数使用了 ``*identifier`` "
"句法；在此情况下，该正式参数将接受一个包含了多余位置参数的元组（如果没有多余位置参数则为一个空元组）。"

#: ../../reference/expressions.rst:977
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a "
":exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"如果任何关键字参数没有与之对应的正式参数名称，将会引发 :exc:`TypeError` 异常，除非有一个正式参数使用了 "
"``**identifier`` "
"句法，该正式参数将接受一个包含了多余关键字参数的字典（使用关键字作为键而参数值作为与键对应的值），如果没有多余关键字参数则为一个（新的）空字典。"

#: ../../reference/expressions.rst:988
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, *y1*,"
" ..., *yM*, *x3*, *x4*."
msgstr ""
"如果函数调用中出现了 ``*expression`` 句法，``expression`` 必须求值为一个 :term:`iterable`。 "
"来自该可迭代对象的元素会被当作是额外的位置参数。 对于 ``f(x1, x2, *y, x3, x4)`` 调用，如果 *y* 求值为一个序列 "
"*y1*, ..., *yM*，则它就等价于一个带有 M+4 个位置参数 *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*"
" 的调用。"

#: ../../reference/expressions.rst:995
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear"
" *after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"这样做的一个后果是虽然 ``*expression`` 句法可能出现于显式的关键字参数 *之后*，但它会在关键字参数（以及任何 "
"``**expression`` 参数 -- 见下文） *之前* 被处理。 因此::"

#: ../../reference/expressions.rst:1011
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr "在同一个调用中同时使用关键字参数和 ``*expression`` 句法并不常见，因此实际上这样的混淆不会发生。"

#: ../../reference/expressions.rst:1017
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments.  If a keyword is already present (as an "
"explicit keyword argument, or from another unpacking), a :exc:`TypeError` "
"exception is raised."
msgstr ""
"如果函数调用中出现了 ``**expression`` 句法，``expression`` 必须求值为一个 "
":term:`mapping`，其内容会被当作是额外的关键字参数。 如果一个关键字已存在（作为显式关键字参数，或来自另一个拆包），则将引发 "
":exc:`TypeError` 异常。"

#: ../../reference/expressions.rst:1023
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr "使用 ``*identifier`` 或 ``**identifier`` 句法的正式参数不能被用作位置参数空位或关键字参数名称。"

#: ../../reference/expressions.rst:1026
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"函数调用接受任意数量的 ``*`` 和 ``**`` 拆包，位置参数可能跟在可迭代对象拆包 (``*``) 之后，而关键字参数可能跟在字典拆包 "
"(``**``) 之后。 由 :pep:`448` 发起最初提议。"

#: ../../reference/expressions.rst:1032
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr "除非引发了异常，调用总是会有返回值，返回值也可能为 ``None``。 返回值的计算方式取决于可调用对象的类型。"

#: ../../reference/expressions.rst:1036
msgid "If it is---"
msgstr "如果类型为---"

#: ../../reference/expressions.rst:1049
msgid "a user-defined function:"
msgstr "用户自定义函数:"

#: ../../reference/expressions.rst:1045
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"函数的代码块会被执行，并向其传入参数列表。 代码块所做的第一件事是将正式形参绑定到对应参数；相关描述参见 :ref:`function` 一节。 "
"当代码块执行 :keyword:`return` 语句时，由其指定函数调用的返回值。"

#: ../../reference/expressions.rst:1063
msgid "a built-in function or method:"
msgstr "内置函数或方法:"

#: ../../reference/expressions.rst:1062
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr "具体结果依赖于解释器；有关内置函数和方法的描述参见 :ref:`built-in-funcs`。"

#: ../../reference/expressions.rst:1070
msgid "a class object:"
msgstr "类对象:"

#: ../../reference/expressions.rst:1070
msgid "A new instance of that class is returned."
msgstr "返回该类的一个新实例。"

#: ../../reference/expressions.rst:1080
msgid "a class instance method:"
msgstr "类实例方法:"

#: ../../reference/expressions.rst:1078
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr "调用相应的用户自定义函数，向其传入的参数列表会比调用的参数列表多一项：该实例将成为第一个参数。"

#: ../../reference/expressions.rst:1089
msgid "a class instance:"
msgstr "类实例:"

#: ../../reference/expressions.rst:1087
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same"
" as if that method was called."
msgstr "该类必须定义有 :meth:`__call__` 方法；作用效果将等价于调用该方法。"

#: ../../reference/expressions.rst:1095 ../../reference/expressions.rst:1860
msgid "Await expression"
msgstr "await 表达式"

#: ../../reference/expressions.rst:1097
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"挂起 :term:`coroutine` 的执行以等待一个 :term:`awaitable` 对象。 只能在 :term:`coroutine "
"function` 内部使用。"

#: ../../reference/expressions.rst:1109
msgid "The power operator"
msgstr "幂运算符"

#: ../../reference/expressions.rst:1115
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr "幂运算符的绑定比在其左侧的一元运算符更紧密；但绑定紧密程度不及在其右侧的一元运算符。 句法如下:"

#: ../../reference/expressions.rst:1121
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"因此，在一个未加圆括号的幂运算符和单目运算符序列中，运算符将从右向左求值（这不会限制操作数的求值顺序）: ``-1**2`` 结果将为 ``-1``。"

#: ../../reference/expressions.rst:1125
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised"
" to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"幂运算符与附带两个参数调用内置 :func:`pow` 函数具有相同的语义：结果为对其左参数进行其右参数所指定幂次的乘方运算。 "
"数值参数会先转换为相同类型，结果也为转换后的类型。"

#: ../../reference/expressions.rst:1130
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"对于 int 类型的操作数，结果将具有与操作数相同的类型，除非第二个参数为负数；在那种情况下，所有参数会被转换为 float 类型并输出 float "
"类型的结果。 例如，``10**2`` 返回 ``100``，而 ``10**-2`` 返回 ``0.01``。"

#: ../../reference/expressions.rst:1135
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a "
":class:`complex` number. (In earlier versions it raised a "
":exc:`ValueError`.)"
msgstr ""
"对 ``0.0`` 进行负数幂次运算将导致 :exc:`ZeroDivisionError`。 对负数进行分数幂次运算将返回 "
":class:`complex` 数值。 （在早期版本中这将引发 :exc:`ValueError`。）"

#: ../../reference/expressions.rst:1143
msgid "Unary arithmetic and bitwise operations"
msgstr "一元算术和位运算"

#: ../../reference/expressions.rst:1149
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "所有算术和位运算具有相同的优先级:"

#: ../../reference/expressions.rst:1160
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument."
msgstr "一元运算符 ``-`` (负) 会产生其数值参数的负值。"

#: ../../reference/expressions.rst:1167
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "一元运算符 ``+`` (正) 会产生与其数值参数相同的值。"

#: ../../reference/expressions.rst:1173
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``."
"  It only applies to integral numbers."
msgstr "一元运算符 ``~`` (取反) 的结果是对其整数参数按位取反。 ``x`` 的按位取反被定义为 ``-(x+1)``。 它只作用于整数。"

#: ../../reference/expressions.rst:1179
msgid ""
"In all three cases, if the argument does not have the proper type, a "
":exc:`TypeError` exception is raised."
msgstr "在所有三种情况下，如果参数的类型不正确，将引发 :exc:`TypeError` 异常。"

#: ../../reference/expressions.rst:1186
msgid "Binary arithmetic operations"
msgstr "二元算术运算符"

#: ../../reference/expressions.rst:1190
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types."
"  Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"二元算术运算符遵循传统的优先级。 请注意某些此类运算符也作用于特定的非数字类型。 "
"除幂运算符以外只有两个优先级别，一个作用于乘法型运算符，另一个作用于加法型运算符:"

#: ../../reference/expressions.rst:1205
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"运算符 ``*`` (乘) 将输出其参数的乘积。 两个参数或者必须都为数字，或者一个参数必须为整数而另一个参数必须为序列。 "
"在前一种情况下，两个数字将被转换为相同类型然后相乘。 在后一种情况下，将执行序列的重复；重复因子为负数将输出空序列。"

#: ../../reference/expressions.rst:1215
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr "运算符 ``@`` (at) 的目标是用于矩阵乘法。 没有内置 Python 类型实现此运算符。"

#: ../../reference/expressions.rst:1226
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a"
" common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"运算符 ``/`` (除) 和 ``//`` (整除) 将输出其参数的商。 两个数字参数将先被转换为相同类型。 整数相除会输出一个 float "
"值，整数相整除的结果仍是整数；整除的结果就是使用 'floor' 函数进行算术除法的结果。 除以零的运算将引发 "
":exc:`ZeroDivisionError` 异常。"

#: ../../reference/expressions.rst:1237
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or"
" zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"运算符 ``%`` (模) 将输出第一个参数除以第二个参数的余数。 两个数字参数将先被转换为相同类型。 右参数为零将引发 "
":exc:`ZeroDivisionError` 异常。 参数可以为浮点数，例如 ``3.14%0.7`` 等于 ``0.34`` (因为 "
"``3.14`` 等于 ``4*0.7 + 0.34``)。 "
"模运算符的结果的正负总是与第二个操作数一致（或是为零）；结果的绝对值一定小于第二个操作数的绝对值 [#]_。"

#: ../../reference/expressions.rst:1246
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == "
"(x//y, x%y)``. [#]_."
msgstr ""
"整除与模运算符的联系可通过以下等式说明: ``x == (x//y)*y + (x%y)``。 此外整除与模也可通过内置函数 "
":func:`divmod` 来同时进行: ``divmod(x, y) == (x//y, x%y)``。 [#]_。"

#: ../../reference/expressions.rst:1251
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"除了对数字执行模运算，运算符 ``%`` 还被字符串对象重载用于执行旧式的字符串格式化（又称插值）。 字符串格式化句法的描述参见 Python 库参考的"
" :ref:`old-string-formatting` 一节。"

#: ../../reference/expressions.rst:1256
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"整除运算符，模运算符和 :func:`divmod` 函数未被定义用于复数。 如果有必要可以使用 :func:`abs` 函数将其转换为浮点数。"

#: ../../reference/expressions.rst:1265
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same type."
"  In the former case, the numbers are converted to a common type and then "
"added together. In the latter case, the sequences are concatenated."
msgstr ""
"运算符 ``+`` (addition) 将输出其参数的和。 两个参数或者必须都为数字，或者都为相同类型的序列。 "
"在前一种情况下，两个数字将被转换为相同类型然后相加。 在后一种情况下，将执行序列拼接操作。"

#: ../../reference/expressions.rst:1275
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr "运算符 ``-`` (减) 将输出其参数的差。 两个数字参数将先被转换为相同类型。"

#: ../../reference/expressions.rst:1282
msgid "Shifting operations"
msgstr "移位运算"

#: ../../reference/expressions.rst:1289
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "移位运算的优先级低于算术运算:"

#: ../../reference/expressions.rst:1294
msgid ""
"These operators accept integers as arguments.  They shift the first argument"
" to the left or right by the number of bits given by the second argument."
msgstr "这些运算符接受整数参数。 它们会将第一个参数左移或右移第二个参数所指定的比特位数。"

#: ../../reference/expressions.rst:1299
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr "右移 *n* 位被定义为被 ``pow(2,n)`` 整除。 左移 *n* 位被定义为乘以 ``pow(2,n)``。"

#: ../../reference/expressions.rst:1306
msgid "Binary bitwise operations"
msgstr "二元位运算"

#: ../../reference/expressions.rst:1310
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "三种位运算具有各不相同的优先级:"

#: ../../reference/expressions.rst:1321
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr "运算符 ``&`` 对两个参数进行按位 AND (与) 运算，两个参数必须为整数。"

#: ../../reference/expressions.rst:1329
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr "运算符 ``^`` 对两个参数进行按位 XOR (异或) 运算，两个参数必须为整数。"

#: ../../reference/expressions.rst:1337
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which"
" must be integers."
msgstr "运算符 ``|`` 对两个参数进行按位 OR (或) 运算，两个参数必须为整数。"

#: ../../reference/expressions.rst:1344
msgid "Comparisons"
msgstr "比较运算"

#: ../../reference/expressions.rst:1356
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"与 C 不同，Python 中所有比较运算的优先级相同，低于任何算术、移位或位运算。 另一个与 C 不同之处在于 ``a < b < c`` "
"这样的表达式会按传统算术法则来解读:"

#: ../../reference/expressions.rst:1366
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "比较运算将输出布尔值: ``True`` 或 ``False``。"

#: ../../reference/expressions.rst:1370
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"比较运算可以任意串连，例如 ``x < y <= z`` 等价于 ``x < y and y <= z``，除了 ``y`` "
"只被求值一次（但在两种写法下当 ``x < y`` 值为假时 ``z`` 都不会被求值）。"

#: ../../reference/expressions.rst:1374
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, "
"..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is "
"equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each "
"expression is evaluated at most once."
msgstr ""
"正式的说法是这样：如果 *a*, *b*, *c*, ..., *y*, *z* 为表达式而 *op1*, *op2*, ..., *opN* "
"为比较运算符，则 ``a op1 b op2 c ... y opN z`` 就等价于 ``a op1 b and b op2 c and ... y "
"opN z``，后者的不同之处只是每个表达式最多只被求值一次。"

#: ../../reference/expressions.rst:1379
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a*"
" and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps "
"not pretty)."
msgstr ""
"请注意 ``a op1 b op2 c`` 不意味着在 *a* 和 *c* 之间进行任何比较，因此，如 ``x < y > z`` "
"这样的写法是完全合法的（虽然也许不太好看）。"

#: ../../reference/expressions.rst:1384
msgid "Value comparisons"
msgstr "值比较"

#: ../../reference/expressions.rst:1386
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"运算符 ``<``, ``>``, ``==``, ``>=``, ``<=`` 和 ``!=`` 将比较两个对象的值。 两个对象不要求为相同类型。"

#: ../../reference/expressions.rst:1389
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type"
" and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
":ref:`objects` 一章已说明对象都有相应的值（还有类型和标识号）。 对象值在 Python "
"中是一个相当抽象的概念：例如，对象值并没有一个规范的访问方法。 而且，对象值并不要求具有特定的构建方式，例如由其全部数据属性组成等。 "
"比较运算符实现了一个特定的对象值概念。 人们可以认为这是通过实现对象比较间接地定义了对象值。"

#: ../../reference/expressions.rst:1398
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they"
" inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""
"由于所有类型都是 :class:`object` 的（直接或间接）子类型，它们都从 :class:`object` 继承了默认的比较行为。 "
"类型可以通过实现 :dfn:`丰富比较方法` 例如 :meth:`__lt__` 来定义自己的比较行为，详情参见 "
":ref:`customization`。"

#: ../../reference/expressions.rst:1404
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on"
" the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"默认的一致性比较 (``==`` 和 ``!=``) 是基于对象的标识号。 "
"因此，具有相同标识号的实例一致性比较结果为相等，具有不同标识号的实例一致性比较结果为不等。 规定这种默认行为的动机是希望所有对象都应该是自反射的 (即 "
"``x is y`` 就意味着 ``x == y``)。"

#: ../../reference/expressions.rst:1411
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default"
" behavior is the lack of a similar invariant as for equality."
msgstr ""
"次序比较 (``<``, ``>``, ``<=`` 和 ``>=``) 默认没有提供；如果尝试比较会引发 :exc:`TypeError`。 "
"规定这种默认行为的原因是缺少与一致性比较类似的固定值。"

#: ../../reference/expressions.rst:1415
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"按照默认的一致性比较行为，具有不同标识号的实例总是不相等，这可能不适合某些对象值需要有合理定义并有基于值的一致性的类型。 "
"这样的类型需要定制自己的比较行为，实际上，许多内置类型都是这样做的。"

#: ../../reference/expressions.rst:1421
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr "以下列表描述了最主要内置类型的比较行为。"

#: ../../reference/expressions.rst:1424
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex"
" numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss"
" of precision."
msgstr ""
"内置数值类型 (:ref:`typesnumeric`) 以及标准库类型 :class:`fractions.Fraction` 和 "
":class:`decimal.Decimal` 可进行类型内部和跨类型的比较，例外限制是复数不支持次序比较。 "
"在类型相关的限制以内，它们会按数学（算法）规则正确进行比较且不会有精度损失。"

#: ../../reference/expressions.rst:1431
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x <"
" 3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"非数字值 ``float('NaN')`` 和 ``decimal.Decimal('NaN')`` 属于特例。 "
"任何数字与非数字值的排序比较均返回假值。 还有一个反直觉的结果是非数字值不等于其自身。 举例来说，如果 ``x = float('NaN')`` 则 "
"``3 < x``, ``x < 3`` 和 ``x == x`` 均为假值，而 ``x != x`` 则为真值。 此行为是遵循 IEEE 754 "
"标准的。"

#: ../../reference/expressions.rst:1438
msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` 和 ``NotImplemented`` 都是单例对象。 :PEP:`8` 建议单例对象的比较应当总是通过 ``is`` 或 ``is"
" not`` 而不是等于运算符来进行。"

#: ../../reference/expressions.rst:1442
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"二进制码序列 (:class:`bytes` 或 :class:`bytearray` 的实例) 可进行类型内部和跨类型的比较。 "
"它们使用其元素的数字值按字典顺序进行比较。"

#: ../../reference/expressions.rst:1446
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function "
":func:`ord`) of their characters. [#]_"
msgstr ""
"字符串 (:class:`str` 的实例) 使用其字符的 Unicode 码位数字值 (内置函数 :func:`ord` 的结果) "
"按字典顺序进行比较。 [#]_"

#: ../../reference/expressions.rst:1450
msgid "Strings and binary sequences cannot be directly compared."
msgstr "字符串和二进制码序列不能直接比较。"

#: ../../reference/expressions.rst:1452
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"序列 (:class:`tuple`, :class:`list` 或 :class:`range` 的实例) 只可进行类型内部的比较，range "
"还有一个限制是不支持次序比较。 以上对象的跨类型一致性比较结果将是不相等，跨类型次序比较将引发 :exc:`TypeError`。"

#: ../../reference/expressions.rst:1458
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"序列比较是按字典序对相应元素进行逐个比较。 内置容器通常设定同一对象与其自身是相等的。 "
"这使得它们能跳过同一对象的相等性检测以提升运行效率并保持它们的内部不变性。"

#: ../../reference/expressions.rst:1463
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr "内置多项集间的字典序比较规则如下:"

#: ../../reference/expressions.rst:1465
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"两个多项集若要相等，它们必须为相同类型、相同长度，并且每对相应的元素都必须相等（例如，``[1,2] == (1,2)`` 为假值，因为类型不同）。"

#: ../../reference/expressions.rst:1470
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"对于支持次序比较的多项集，排序与其第一个不相等元素的排序相同（例如 ``[1,2,x] <= [1,2,y]`` 的值与``x <= y`` 相同）。 "
"如果对应元素不存在，较短的多项集排序在前（例如 ``[1,2] < [1,2,3]`` 为真值）。"

#: ../../reference/expressions.rst:1476
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have"
" equal `(key, value)` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"两个映射 (:class:`dict` 的实例) 若要相等，必须当且仅当它们具有相同的 `(键, 值)` 对。 键和值的一致性比较强制规定自反射性。"

#: ../../reference/expressions.rst:1480
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr "次序比较 (``<``, ``>``, ``<=`` 和 ``>=``) 将引发 :exc:`TypeError`。"

#: ../../reference/expressions.rst:1482
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr "集合 (:class:`set` 或 :class:`frozenset` 的实例) 可进行类型内部和跨类型的比较。"

#: ../../reference/expressions.rst:1485
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, "
":func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"它们将比较运算符定义为子集和超集检测。 这类关系没有定义完全排序（例如 ``{1,2}`` 和 ``{2,3}`` "
"两个集合不相等，即不为彼此的子集，也不为彼此的超集。 相应地，集合不适宜作为依赖于完全排序的函数的参数（例如如果给出一个集合列表作为 "
":func:`min`, :func:`max` 和 :func:`sorted` 的输入将产生未定义的结果）。"

#: ../../reference/expressions.rst:1493
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "集合的比较强制规定其元素的自反射性。"

#: ../../reference/expressions.rst:1495
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr "大多数其他内置类型没有实现比较方法，因此它们会继承默认的比较行为。"

#: ../../reference/expressions.rst:1498
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr "在可能的情况下，用户定义类在定制其比较行为时应当遵循一些一致性规则:"

#: ../../reference/expressions.rst:1501
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr "相等比较应该是自反射的。 换句话说，相同的对象比较时应该相等:"

#: ../../reference/expressions.rst:1504
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` 意味着 ``x == y``"

#: ../../reference/expressions.rst:1506
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr "比较应该是对称的。 换句话说，下列表达式应该有相同的结果:"

#: ../../reference/expressions.rst:1509
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` 和 ``y == x``"

#: ../../reference/expressions.rst:1511
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` 和 ``y != x``"

#: ../../reference/expressions.rst:1513
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` 和 ``y > x``"

#: ../../reference/expressions.rst:1515
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` 和 ``y >= x``"

#: ../../reference/expressions.rst:1517
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr "比较应该是可传递的。 下列（简要的）例子显示了这一点:"

#: ../../reference/expressions.rst:1520
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` 意味着 ``x > z``"

#: ../../reference/expressions.rst:1522
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` 意味着 ``x < z``"

#: ../../reference/expressions.rst:1524
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr "反向比较应该导致布尔值取反。 换句话说，下列表达式应该有相同的结果:"

#: ../../reference/expressions.rst:1527
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` 和 ``not x != y``"

#: ../../reference/expressions.rst:1529
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` 和 ``not x >= y`` (对于完全排序)"

#: ../../reference/expressions.rst:1531
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` 和 ``not x <= y`` (对于完全排序)"

#: ../../reference/expressions.rst:1533
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the "
":func:`~functools.total_ordering` decorator."
msgstr ""
"最后两个表达式适用于完全排序的多项集（即序列而非集合或映射）。 另请参阅 :func:`~functools.total_ordering` 装饰器。"

#: ../../reference/expressions.rst:1537
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are"
" equal should either have the same hash value, or be marked as unhashable."
msgstr ":func:`hash` 的结果应该与是否相等一致。 相等的对象应该或者具有相同的哈希值，或者标记为不可哈希。"

#: ../../reference/expressions.rst:1541
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr "Python 并不强制要求这些一致性规则。 实际上，非数字值就是一个不遵循这些规则的例子。"

#: ../../reference/expressions.rst:1550
msgid "Membership test operations"
msgstr "成员检测运算"

#: ../../reference/expressions.rst:1552
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which "
":keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"运算符 :keyword:`in` 和 :keyword:`not in` 用于成员检测。 如果 *x* 是 *s* 的成员则 ``x in s`` "
"求值为 ``True``，否则为 ``False``。 ``x not in s`` 返回 ``x in s`` 取反后的值。 "
"所有内置序列和集合类型以及字典都支持此运算，对于字典来说 :keyword:`!in` 检测其是否有给定的键。 对于 list, tuple, set,"
" frozenset, dict 或 collections.deque 这样的容器类型，表达式 ``x in y`` 等价于 ``any(x is e"
" or x == e for e in y)``。"

#: ../../reference/expressions.rst:1560
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is"
" a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"对于字符串和字节串类型来说，当且仅当 *x* 是 *y* 的子串时 ``x in y`` 为 ``True``。 一个等价的检测是 "
"``y.find(x) != -1``。 空字符串总是被视为任何其他字符串的子串，因此 ``\"\" in \"abc\"`` 将返回 "
"``True``。"

#: ../../reference/expressions.rst:1565
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
"对于定义了 :meth:`__contains__` 方法的用户自定义类来说，如果 ``y.__contains__(x)`` 返回真值则 ``x in"
" y`` 返回 ``True``，否则返回 ``False``。"

#: ../../reference/expressions.rst:1569
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it is "
"as if :keyword:`in` raised that exception."
msgstr ""
"对于未定义 :meth:`__contains__` 但定义了 :meth:`__iter__` 的用户自定义类来说，如果在对 ``y`` "
"进行迭代时产生了值 ``z`` 使得表达式 ``x is z or x == z`` 为真，则 ``x in y`` 为 ``True``。 "
"如果在迭代期间引发了异常，则等同于 :keyword:`in` 引发了该异常。"

#: ../../reference/expressions.rst:1575
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines "
":meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x is y[i] or x == y[i]``, and no "
"lower integer index raises the :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"最后将会尝试旧式的迭代协议：如果一个类定义了 :meth:`__getitem__`，则当且仅当存在非负整数索引号 *i* 使得 ``x is y[i]"
" or x == y[i]`` 并且没有更小的索引号引发 :exc:`IndexError` 异常时 ``x in y`` 为 ``True``。 "
"（如果引发了任何其他异常，则等同于 :keyword:`in` 引发了该异常）。"

#: ../../reference/expressions.rst:1587
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value of"
" :keyword:`in`."
msgstr "运算符 :keyword:`not in` 被定义为具有与 :keyword:`in` 相反的逻辑值。"

#: ../../reference/expressions.rst:1600
msgid "Identity comparisons"
msgstr "标识号比较"

#: ../../reference/expressions.rst:1602
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same object."
"  An Object's identity is determined using the :meth:`id` function.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""
"运算符 :keyword:`is` 和 :keyword:`is not` 用于检测对象的标识号：当且仅当 *x* 和 *y* 是同一对象时 ``x "
"is y`` 为真。 一个对象的标识号可使用 :meth:`id` 函数来确定。 ``x is not y`` 会产生相反的逻辑值。 [#]_"

#: ../../reference/expressions.rst:1614
msgid "Boolean operations"
msgstr "布尔运算"

#: ../../reference/expressions.rst:1625
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"在执行布尔运算的情况下，或是当表达式被用于流程控制语句时，以下值会被解析为假值: ``False``, ``None``, "
"所有类型的数字零，以及空字符串和空容器（包括字符串、元组、列表、字典、集合与冻结集合）。 所有其他值都会被解析为真值。 用户自定义对象可通过提供 "
":meth:`__bool__` 方法来定制其逻辑值。"

#: ../../reference/expressions.rst:1634
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr "运算符 :keyword:`not` 将在其参数为假值时产生 ``True``，否则产生 ``False``。"

#: ../../reference/expressions.rst:1639
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is "
"returned."
msgstr "表达式 ``x and y`` 首先对 *x* 求值；如果 *x* 为假则返回该值；否则对 *y* 求值并返回其结果值。"

#: ../../reference/expressions.rst:1644
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr "表达式 ``x or y`` 首先对 *x* 求值；如果 *x* 为真则返回该值；否则对 *y* 求值并返回其结果值。"

#: ../../reference/expressions.rst:1647
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its"
" argument (for example, ``not 'foo'`` produces ``False`` rather than "
"``''``.)"
msgstr ""
"请注意 :keyword:`and` 和 :keyword:`or` 都不限制其返回的值和类型必须为 ``False`` 和 "
"``True``，而是返回最终求值的参数。 此行为是有必要的，例如假设 ``s`` 为一个当其为空时应被替换为某个默认值的字符串，表达式 ``s or "
"'foo'`` 将产生希望的值。 由于 :keyword:`not` 必须创建一个新值，不论其参数为何种类型它都会返回一个布尔值（例如，``not "
"'foo'`` 结果为 ``False`` 而非 ``''``。）"

#: ../../reference/expressions.rst:1657
msgid "Assignment expressions"
msgstr "赋值表达式"

#: ../../reference/expressions.rst:1662
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`expression` to an :token:`identifier`, while "
"also returning the value of the :token:`expression`."
msgstr ""
"赋值表达式（有时又被叫做“命名表达式”或“海象表达式”）将一个 :token:`expression` 赋值给一个 "
":token:`identifier`，同时还返回 :token:`expression` 的值。"

#: ../../reference/expressions.rst:1666
msgid "One common use case is when handling matched regular expressions:"
msgstr "一个常见用例是在处理匹配的正则表达式的时候:"

#: ../../reference/expressions.rst:1673
msgid "Or, when processing a file stream in chunks:"
msgstr "或者是在处理分块的文件流的时候:"

#: ../../reference/expressions.rst:1680
msgid "See :pep:`572` for more details about assignment expressions."
msgstr "请参阅 :pep:`572` 了解有关赋值表达式的详情。"

#: ../../reference/expressions.rst:1687
msgid "Conditional expressions"
msgstr "条件表达式"

#: ../../reference/expressions.rst:1700
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr "条件表达式（有时称为“三元运算符”）在所有 Python 运算中具有最低的优先级。"

#: ../../reference/expressions.rst:1703
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"表达式 ``x if C else y`` 首先是对条件 *C* 而非 *x* 求值。 如果 *C* 为真，*x* 将被求值并返回其值；否则将对 *y*"
" 求值并返回其值。"

#: ../../reference/expressions.rst:1707
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "请参阅 :pep:`308` 了解有关条件表达式的详情。"

#: ../../reference/expressions.rst:1714
msgid "Lambdas"
msgstr "lambda 表达式"

#: ../../reference/expressions.rst:1726
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields"
" a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"lambda 表达式（有时称为 lambda 构型）被用于创建匿名函数。 表达式 ``lambda parameters: expression`` "
"会产生一个函数对象 。 该未命名对象的行为类似于用以下方式定义的函数:"

#: ../../reference/expressions.rst:1735
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr "请参阅 :ref:`function` 了解有关参数列表的句法。 请注意通过 lambda 表达式创建的函数不能包含语句或标注。"

#: ../../reference/expressions.rst:1743
msgid "Expression lists"
msgstr "表达式列表"

#: ../../reference/expressions.rst:1757
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr "除了作为列表或集合显示的一部分，包含至少一个逗号的表达式列表将生成一个元组。 元组的长度就是列表中表达式的数量。 表达式将从左至右被求值。"

#: ../../reference/expressions.rst:1766
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be an"
" :term:`iterable`.  The iterable is expanded into a sequence of items, which"
" are included in the new tuple, list, or set, at the site of the unpacking."
msgstr ""
"一个星号 ``*`` 表示 :dfn:`可迭代拆包`。 其操作数必须为一个 :term:`iterable`。 "
"该可迭代对象将被拆解为迭代项的序列，并被包含于在拆包位置上新建的元组、列表或集合之中。"

#: ../../reference/expressions.rst:1771
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr "表达式列表中的可迭代对象拆包，最初由 :pep:`448` 提出。"

#: ../../reference/expressions.rst:1776
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value"
" of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"末尾的逗号仅在创建单独元组 (或称 *单例*) 时需要；在所有其他情况下都是可选项。 没有末尾逗号的单独表达式不会创建一个元组，而是产生该表达式的值。 "
"（要创建一个空元组，应使用一对内容为空的圆括号: ``()``。）"

#: ../../reference/expressions.rst:1786
msgid "Evaluation order"
msgstr "求值顺序"

#: ../../reference/expressions.rst:1790
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr "Python 按从左至右的顺序对表达式求值。 但注意在对赋值操作求值时，右侧会先于左侧被求值。"

#: ../../reference/expressions.rst:1793
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr "在以下几行中，表达式将按其后缀的算术优先顺序被求值。::"

#: ../../reference/expressions.rst:1807
msgid "Operator precedence"
msgstr "运算符优先级"

#: ../../reference/expressions.rst:1812
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation, which groups from right to left)."
msgstr ""
"下表对 Python 中运算符的优先顺序进行了总结，从最低优先级（最后绑定）到最高优先级（最先绑定）。 相同单元格内的运算符具有相同优先级。 "
"除非句法显式地给出，否则运算符均指二元运算。 相同单元格内的运算符均从左至右分组（除了幂运算是从右至左分组）。"

#: ../../reference/expressions.rst:1818
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr "请注意比较、成员检测和标识号检测均为相同优先级，并具有如 :ref:`comparisons` 一节所描述的从左至右串连特性。"

#: ../../reference/expressions.rst:1824
msgid "Operator"
msgstr "运算符"

#: ../../reference/expressions.rst:1824
msgid "Description"
msgstr "描述"

#: ../../reference/expressions.rst:1826
msgid "``:=``"
msgstr "``:=``"

#: ../../reference/expressions.rst:1826
msgid "Assignment expression"
msgstr "赋值表达式"

#: ../../reference/expressions.rst:1828
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:1828
msgid "Lambda expression"
msgstr "lambda 表达式"

#: ../../reference/expressions.rst:1830
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../../reference/expressions.rst:1830
msgid "Conditional expression"
msgstr "条件表达式"

#: ../../reference/expressions.rst:1832
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:1832
msgid "Boolean OR"
msgstr "布尔逻辑或 OR"

#: ../../reference/expressions.rst:1834
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:1834
msgid "Boolean AND"
msgstr "布尔逻辑与 AND"

#: ../../reference/expressions.rst:1836
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../../reference/expressions.rst:1836
msgid "Boolean NOT"
msgstr "布尔逻辑非 NOT"

#: ../../reference/expressions.rst:1838
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1838
msgid "Comparisons, including membership tests and identity tests"
msgstr "比较运算，包括成员检测和标识号检测"

#: ../../reference/expressions.rst:1842
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1842
msgid "Bitwise OR"
msgstr "按位或 OR"

#: ../../reference/expressions.rst:1844
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1844
msgid "Bitwise XOR"
msgstr "按位异或 XOR"

#: ../../reference/expressions.rst:1846
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1846
msgid "Bitwise AND"
msgstr "按位与 AND"

#: ../../reference/expressions.rst:1848
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1848
msgid "Shifts"
msgstr "移位"

#: ../../reference/expressions.rst:1850
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1850
msgid "Addition and subtraction"
msgstr "加和减"

#: ../../reference/expressions.rst:1852
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1852
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr "乘，矩阵乘，除，整除，取余 [#]_"

#: ../../reference/expressions.rst:1856
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1856
msgid "Positive, negative, bitwise NOT"
msgstr "正，负，按位非 NOT"

#: ../../reference/expressions.rst:1858
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1858
msgid "Exponentiation [#]_"
msgstr "乘方 [#]_"

#: ../../reference/expressions.rst:1860
msgid ":keyword:`await` ``x``"
msgstr ":keyword:`await` ``x``"

#: ../../reference/expressions.rst:1862
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""
"``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1862
msgid "Subscription, slicing, call, attribute reference"
msgstr "抽取，切片，调用，属性引用"

#: ../../reference/expressions.rst:1865
msgid "``(expressions...)``,"
msgstr "``(expressions...)``,"

#: ../../reference/expressions.rst:1867
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"

#: ../../reference/expressions.rst:1865
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr "绑定或加圆括号的表达式，列表显示，字典显示，集合显示"

#: ../../reference/expressions.rst:1874
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/expressions.rst:1875
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be"
" true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"虽然 ``abs(x%y) < abs(y)`` 在数学中必为真，但对于浮点数而言，由于舍入的存在，其在数值上未必为真。 例如，假设在某个平台上的 "
"Python 浮点数为一个 IEEE 754 双精度数值，为了使 ``-1e-100 % 1e100`` 具有与 ``1e100`` "
"相同的正负性，计算结果将是 ``-1e-100 + 1e100``，这在数值上正好等于 ``1e100``。 函数 :func:`math.fmod` "
"返回的结果则会具有与第一个参数相同的正负性，因此在这种情况下将返回 ``-1e-100``。 何种方式更适宜取决于具体的应用。"

#: ../../reference/expressions.rst:1884
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``x//y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""
"如果 x 恰好非常接近于 y 的整数倍，则由于舍入的存在 ``x//y`` 可能会比 ``(x-x%y)//y`` 大。 在这种情况下，Python "
"会返回后一个结果，以便保持令 ``divmod(x,y)[0] * y + x % y`` 尽量接近 ``x``."

#: ../../reference/expressions.rst:1889
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most"
" abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented"
" using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode 标准明确区分 :dfn:`码位` (例如 U+0041) 和 :dfn:`抽象字符` (例如 \"大写拉丁字母 A\")。 虽然 "
"Unicode 中的大多数抽象字符都只用一个码位来代表，但也存在一些抽象字符可使用由多个码位组成的序列来表示。 例如，抽象字符 "
"\"带有下加符的大写拉丁字母 C\" 可以用 U+00C7 码位上的单个 :dfn:`预设字符` 来表示，也可以用一个 U+0043 码位上的 "
":dfn:`基础字符` (大写拉丁字母 C) 加上一个 U+0327 码位上的 :dfn:`组合字符` (组合下加符) 组成的序列来表示。"

#: ../../reference/expressions.rst:1900
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\""
" == \"\\u0043\\u0327\"`` is ``False``, even though both strings represent "
"the same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"对于字符串，比较运算符会按 Unicode 码位级别进行比较。 这可能会违反人类的直觉。 例如，``\"\\u00C7\" == "
"\"\\u0043\\u0327\"`` 为 ``False``，虽然两个字符串都代表同一个抽象字符 \"带有下加符的大写拉丁字母 C\"。"

#: ../../reference/expressions.rst:1905
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr "要按抽象字符级别（即对人类来说更直观的方式）对字符串进行比较，应使用 :func:`unicodedata.normalize`。"

#: ../../reference/expressions.rst:1908
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"由于存在自动垃圾收集、空闲列表以及描述器的动态特性，你可能会注意到在特定情况下使用 :keyword:`is` "
"运算符会出现看似不正常的行为，例如涉及到实例方法或常量之间的比较时就是如此。 更多信息请查看有关它们的文档。"

#: ../../reference/expressions.rst:1913
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr "``%`` 运算符也被用于字符串格式化；在此场合下会使用同样的优先级。"

#: ../../reference/expressions.rst:1916
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr "幂运算符 ``**`` 绑定的紧密程度低于在其右侧的算术或按位一元运算符，也就是说 ``2**-1`` 为 ``0.5``。"
