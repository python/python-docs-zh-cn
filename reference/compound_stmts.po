# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Kade For, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# ProgramRipper, 2023
# Y. Z. Chen <754097987@qq.com>, 2023
# WH-2099 <wh2099@outlook.com>, 2023
# Shengjing Zhu <zsj950618@gmail.com>, 2023
# cissoid <yangtukun1412@gmail.com>, 2023
# Xu Siyuan, 2023
# Jiuh.star <jiuh.star@gmail.com>, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# Dai Xu <daixu61@hotmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "复合语句"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它语句的执行。 "
"通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能包含于一行之内。"

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the "
":keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions "
"are also syntactically compound statements."
msgstr ""
":keyword:`if`, :keyword:`while` 和 :keyword:`for` 语句用来实现传统的控制流程构造。 "
":keyword:`try` 语句为一组语句指定异常处理和/和清理代码，而 :keyword:`with` "
"语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上也属于复合语句。"

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be"
" clear to which :keyword:`if` clause a following :keyword:`else` clause "
"would belong::"
msgstr ""
"一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特定复合语句的子句头都处于相同的缩进层级。 "
"每个子句头以一个作为唯一标识的关键字开始并以一个冒号结束。 子句体是由一个子句控制的一组语句。 "
"子句体可以是在子句头的冒号之后与其同处一行的一条或由分号分隔的多条简单语句，或者也可以是在其之后缩进的一行或多行语句。 "
"只有后一种形式的子句体才能包含嵌套的复合语句；以下形式是不合法的，这主要是因为无法分清某个后续的 :keyword:`else` 子句应该属于哪个 "
":keyword:`if` 子句::"

#: ../../reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr "还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 :func:`print` 调用或者都不执行，或者都执行::"

#: ../../reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "总结:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested "
":keyword:`if` statements to be indented)."
msgstr ""
"请注意语句总是以 ``NEWLINE`` 结束，之后可能跟随一个 ``DEDENT``。 "
"还要注意可选的后续子句总是以一个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空的 :keyword:`else`’问题在 Python "
"中是通过要求嵌套的 :keyword:`if` 语句必须缩进来解决的)。"

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr "为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。"

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 语句"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 语句用于有条件的执行:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"它通过对表达式逐个求值直至找到一个真值（请参阅 :ref:`booleans` "
"了解真值与假值的定义）在子句体中选择唯一匹配的一个；然后执行该子句体（而且 :keyword:`if` 语句的其他部分不会被执行或求值）。 "
"如果所有表达式均为假值，则如果 :keyword:`else` 子句体如果存在就会被执行。"

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 语句"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ":keyword:`while` 语句用于在表达式保持为真的情况下重复地执行:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested)"
" the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第一次检验时就发生）则如果 :keyword:`!else` "
"子句体存在就会被执行并终止循环。"

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and goes back to testing the expression."
msgstr ""
"第一个子句体中的 :keyword:`break` 语句在执行时将终止循环且不执行 :keyword:`!else` 子句体。 第一个子句体中的 "
":keyword:`continue` 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。"

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 语句"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ":keyword:`for` 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代:"

#: ../../reference/compound_stmts.rst:160
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an "
":term:`iterable` object.  An :term:`iterator` is created for that iterable. "
"The first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if"
" present, is executed, and the loop terminates."
msgstr ""
"``starred_list`` 表达式会被求值一次；它应当产生一个 :term:`iterable` 对象。 将针对该可迭代对象创建一个 "
":term:`iterator`。 随后该迭代器所提供的第一个条目将使用标准的赋值规则被赋值给目标列表 (参见 "
":ref:`assignment`)，而代码块将被执行。 此过程将针对该迭代器所提供每个条目重复进行。 当迭代器被耗尽时，如果存在 "
":keyword:`!else` 子句中的代码块，则它将被执行，并终结循环。"

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and continues with the next item, or with the :keyword:`!else` "
"clause if there is no next item."
msgstr ""
"第一个子句体中的 :keyword:`break` 语句在执行时将终止循环且不执行 :keyword:`!else` 子句体。 第一个子句体中的 "
":keyword:`continue` 语句在执行时将跳过子句体中的剩余部分并转往下一项继续执行，或者在没有下一项时转往 "
":keyword:`!else` 子句执行。"

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr "for 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括在 for 循环体中的赋值::"

#: ../../reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # 这不会影响 for 循环\n"
"                      # 因为它将被 range 对象中的下一个索引\n"
"                      # 所覆盖"

#: ../../reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic"
" sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"目标列表中的名称在循环结束时不会被删除，但是如果序列为空，则它们将根本不会被循环所赋值。 提示：内置类型 :func:`range` "
"代表由整数组成的不可变算数序列。 例如，迭代 ``range(3)`` 将依次产生 0, 1 和 2。"

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr "现在允许在表达式列表中使用带星号的元素。"

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 语句"

#: ../../reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ":keyword:`!try` 语句可为一组语句指定异常处理器和/或清理代码:"

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` statement "
"to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"有关异常的更多信息可以在 :ref:`exceptions` 一节找到，有关使用 :keyword:`raise` 语句生成异常的信息可以在 "
":ref:`raise` 一节找到。"

#: ../../reference/compound_stmts.rst:235
msgid ""
"Support for optionally dropping grouping parentheses when using multiple "
"exception types. See :pep:`758`."
msgstr ""

#: ../../reference/compound_stmts.rst:241
msgid ":keyword:`!except` clause"
msgstr ":keyword:`!except` 子句"

#: ../../reference/compound_stmts.rst:243
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search"
" for an exception handler is started. This search inspects the "
":keyword:`!except` clauses in turn until one is found that matches the "
"exception. An expression-less :keyword:`!except` clause, if present, must be"
" last; it matches any exception."
msgstr ""
":keyword:`!except` 子句指定一个或多个异常处理器。 当在 :keyword:`try` 子句中未发生异常时，将不会执行任何异常处理器。"
" 当在 :keyword:`!try` 语句块中发生异常时，将启动对异常处理器的搜索。 此搜索会依次检查 :keyword:`!except` "
"子句直至找到与异常相匹配的处理器。 不带表达式的 :keyword:`!except` 子句如果存在，则它必须是最后一个；它将匹配任何异常。"

#: ../../reference/compound_stmts.rst:251
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. Parentheses can"
" be dropped if multiple exception types are provided and the ``as`` clause "
"is not used. The raised exception matches an :keyword:`!except` clause whose"
" expression evaluates to the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or to a tuple that contains "
"such a class."
msgstr ""

#: ../../reference/compound_stmts.rst:258
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr "如果没有 :keyword:`!except` 子句与异常相匹配，则会在周边代码和唤起栈上继续搜索异常处理器。 [#]_"

#: ../../reference/compound_stmts.rst:262
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the"
" call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"如果在对 :keyword:`!except` "
"子句头部的表达式求值时引发了异常，则对处理器的原始搜索会被取消并在周边代码和调用栈上启动对新异常的搜索（它会被视作是整个 :keyword:`try` "
"语句所引发的异常）。"

#: ../../reference/compound_stmts.rst:270
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that "
":keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the "
":keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"当代到一个匹配的 :keyword:`!except` 子句时，异常将被赋值给该 :keyword:`!except` 子句在 "
":keyword:`!as` 关键字之后指定的目标，如果存在此关键字的话，并且该 :keyword:`!except` 子句的代码块将被执行。 所有 "
":keyword:`!except` 子句都必须有可执行的代码块。 当到达此类代码块的末尾时，通常会转到整个 :keyword:`try` "
"语句之后继续执行。 （这意味着如果对同一异常存在两个嵌套的处理器，并且异常发生在内层处理器的 :keyword:`!try` "
"子句中，则外层处理器将不会处理该异常。）"

#: ../../reference/compound_stmts.rst:281
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr "当使用 ``as target`` 来为异常赋值时，它将在 :keyword:`!except` 子句结束时被清除。 这就相当于 ::"

#: ../../reference/compound_stmts.rst:284
msgid ""
"except E as N:\n"
"    foo"
msgstr ""
"except E as N:\n"
"    foo"

#: ../../reference/compound_stmts.rst:287
msgid "was translated to ::"
msgstr "被转写为 ::"

#: ../../reference/compound_stmts.rst:289
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"

#: ../../reference/compound_stmts.rst:295
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"这意味着异常必须被赋值给一个不同的名称才能在 :keyword:`!except` 子句之后引用它。 "
"异常会被清除是因为在附加了回溯信息的情况下它们会形成栈帧的循环引用，使得帧中的所有局部变量保持存活直到发生下一次垃圾回收。"

#: ../../reference/compound_stmts.rst:305
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When"
" leaving an exception handler, the exception stored in the :mod:`sys` module"
" is reset to its previous value::"
msgstr ""
"在 :keyword:`!except` 子句的代码块被执行之前，异常将保存在 :mod:`sys` 模块中，在那里它可以从 "
":keyword:`!except` 子句的语句体内部通过 :func:`sys.exception` 被访问。 当离开一个异常处理器时，保存在 "
":mod:`sys` 模块中的异常将被重置为在此之前的值::"

#: ../../reference/compound_stmts.rst:311
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"

#: ../../reference/compound_stmts.rst:336
msgid ":keyword:`!except*` clause"
msgstr ":keyword:`!except*` 子句"

#: ../../reference/compound_stmts.rst:338
msgid ""
"The :keyword:`!except*` clause(s) are used for handling "
":exc:`ExceptionGroup`\\s. The exception type for matching is interpreted as "
"in the case of :keyword:`except`, but in the case of exception groups we can"
" have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once"
" and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first"
" that matches it. ::"
msgstr ""
":keyword:`!except*` 子句被用来处理 :exc:`ExceptionGroup`。 要匹配的异常类型将按与 "
":keyword:`except` 中的相同的方式来解读，但在使用异常组的情况下当类型与组内的某些异常相匹配时我们可以有部分匹配。 这意味着有多个 "
":keyword:`!except*` 子句可被执行，各自处理异常组的一部分。 每个子句最多执行一次并处理所有匹配异常中的一个异常组。 "
"组内的每个异常将至多由一个 :keyword:`!except*` 子句来处理，即第一个与其匹配的子句。 ::"

#: ../../reference/compound_stmts.rst:348
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"

#: ../../reference/compound_stmts.rst:366
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than"
" one exception to reraise, they are combined into an exception group."
msgstr ""
"任何未被 :keyword:`!except*` 子句处理的剩余异常最后都会在 :keyword:`!except*` 子句中被重新引发。 "
"如果此列表包含一个以上的要被重新引发的异常，它们将被合并成一个异常组。"

#: ../../reference/compound_stmts.rst:372
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception"
" group with an empty message string. ::"
msgstr ""
"如果被引发的异常不是一个异常组并且其类型与某个 :keyword:`!except*` 子句相匹配，它将被捕获并由附带空消息字符串的异常组来包装。 ::"

#: ../../reference/compound_stmts.rst:376
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"

#: ../../reference/compound_stmts.rst:383
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""
":keyword:`!except*` 子句必须有一个匹配的表达式；它不可为 ``except*:``。 "
"并且，该表达式不可包括异常组类型，因为这将导致模糊的语义。"

#: ../../reference/compound_stmts.rst:387
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. :keyword:`break`, :keyword:`continue` and "
":keyword:`return` cannot appear in an :keyword:`!except*` clause."
msgstr ""
"在同一个 :keyword:`try` 中不可以混用 :keyword:`except` 和 :keyword:`!except*`。 "
":keyword:`break`, :keyword:`continue` 和 :keyword:`return` 不可以在 "
":keyword:`!except*` 子句中出现。"

#: ../../reference/compound_stmts.rst:402
msgid ":keyword:`!else` clause"
msgstr ":keyword:`!else` 子句"

#: ../../reference/compound_stmts.rst:404
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:`return`,"
" :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding "
":keyword:`except` clauses."
msgstr ""
"如果控制流离开 :keyword:`try` 子句体时没有引发异常，并且没有执行 :keyword:`return`, "
":keyword:`continue` 或 :keyword:`break` 语句，可选的 :keyword:`!else` 子句将被执行。  "
":keyword:`!else` 语句中的异常不会由之前的 :keyword:`except` 子句处理。"

#: ../../reference/compound_stmts.rst:416
msgid ":keyword:`!finally` clause"
msgstr ":keyword:`!finally` 子句"

#: ../../reference/compound_stmts.rst:418
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The "
":keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a "
":keyword:`return`, :keyword:`break` or :keyword:`continue` statement, the "
"saved exception is discarded. For example, this function returns 42."
msgstr ""

#: ../../reference/compound_stmts.rst:429
msgid ""
"def f():\n"
"    try:\n"
"        1/0\n"
"    finally:\n"
"        return 42"
msgstr ""

#: ../../reference/compound_stmts.rst:437
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr "在 :keyword:`!finally` 子句执行期间程序将不能获取到异常信息。"

#: ../../reference/compound_stmts.rst:445
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ "
":keyword:`!finally` statement, the :keyword:`!finally` clause is also "
"executed 'on the way out.'"
msgstr ""
"当 :keyword:`return`, :keyword:`break` 或 :keyword:`continue` 语句在一个 "
":keyword:`!try`...\\ :keyword:`!finally` 语句的 :keyword:`try` "
"子句的代码块中被执行时，:keyword:`!finally` 子句也会在‘离开时’被执行。"

#: ../../reference/compound_stmts.rst:449
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, a"
" :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed. The following function returns "
"'finally'."
msgstr ""

#: ../../reference/compound_stmts.rst:454
msgid ""
"def foo():\n"
"    try:\n"
"        return 'try'\n"
"    finally:\n"
"        return 'finally'"
msgstr ""

#: ../../reference/compound_stmts.rst:462
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the "
":keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"在 Python 3.8 之前，:keyword:`continue` 语句不允许在 :keyword:`!finally` "
"子句中使用，这是因为具体实现中存在一个问题。"

#: ../../reference/compound_stmts.rst:466
msgid ""
"The compiler emits a :exc:`SyntaxWarning` when a :keyword:`return`, "
":keyword:`break` or :keyword:`continue` appears in a :keyword:`!finally` "
"block (see :pep:`765`)."
msgstr ""

#: ../../reference/compound_stmts.rst:476
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 语句"

#: ../../reference/compound_stmts.rst:485
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` 语句用于包装带有使用上下文管理器 (参见 :ref:`context-managers` 一节) "
"定义的方法的代码块的执行。 这允许对普通的 :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` 使用模式进行封装以方便地重用。"

#: ../../reference/compound_stmts.rst:495
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as"
" follows:"
msgstr "带有一个“项目”的 :keyword:`with` 语句的执行过程如下:"

#: ../../reference/compound_stmts.rst:497
msgid ""
"The context expression (the expression given in the :token:`~python-"
"grammar:with_item`) is evaluated to obtain a context manager."
msgstr "对上下文表达式（在 :token:`~python-grammar:with_item` 中给出的表达式）进行求值来获得上下文管理器。"

#: ../../reference/compound_stmts.rst:500
msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr "载入上下文管理器的 :meth:`~object.__enter__` 以便后续使用。"

#: ../../reference/compound_stmts.rst:502
msgid ""
"The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr "载入上下文管理器的 :meth:`~object.__exit__` 以便后续使用。"

#: ../../reference/compound_stmts.rst:504
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "唤起上下文管理器的 :meth:`~object.__enter__` 方法。"

#: ../../reference/compound_stmts.rst:506
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr "如果一个目标被包括在 :keyword:`with` 语句中，则把它赋值为 :meth:`~object.__enter__` 的返回值。"

#: ../../reference/compound_stmts.rst:511
msgid ""
"The :keyword:`with` statement guarantees that if the "
":meth:`~object.__enter__` method returns without an error, then "
":meth:`~object.__exit__` will always be called. Thus, if an error occurs "
"during the assignment to the target list, it will be treated the same as an "
"error occurring within the suite would be. See step 7 below."
msgstr ""
":keyword:`with` 语句会保证如果 :meth:`~object.__enter__` 方法未发生错误地返回，则 "
":meth:`~object.__exit__` 将一定被调用。 因此，如果在对目标列表赋值期间发生错误，它将被当作在语句体内部发生的错误来处理。 "
"参见下面的第 7 步。"

#: ../../reference/compound_stmts.rst:517
msgid "The suite is executed."
msgstr "执行语句体。"

#: ../../reference/compound_stmts.rst:519
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, three "
":const:`None` arguments are supplied."
msgstr ""
"唤起上下文管理器的 :meth:`~object.__exit__` 方法。 如果语句体的退出是由异常导致的，则其类型、值和回溯信息将被作为参数传递给 "
":meth:`~object.__exit__`。 否则的话，将提供三个 :const:`None` 参数。"

#: ../../reference/compound_stmts.rst:524
msgid ""
"If the suite was exited due to an exception, and the return value from the "
":meth:`~object.__exit__` method was false, the exception is reraised.  If "
"the return value was true, the exception is suppressed, and execution "
"continues with the statement following the :keyword:`with` statement."
msgstr ""
"如果语句体的退出是由异常导致的，并且来自 :meth:`~object.__exit__` 方法的返回值为假，则该异常会被重新引发。 "
"如果返回值为真，则该异常会被抑制，并会继续执行 :keyword:`with` 语句之后的语句。"

#: ../../reference/compound_stmts.rst:529
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"如果语句体由于异常以外的任何原因退出，则来自 :meth:`~object.__exit__` 的返回值会被忽略，并会在该类退出正常的发生位置继续执行。"

#: ../../reference/compound_stmts.rst:533
#: ../../reference/compound_stmts.rst:1550
#: ../../reference/compound_stmts.rst:1591
msgid "The following code::"
msgstr "以下代码::"

#: ../../reference/compound_stmts.rst:535
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"with EXPRESSION as TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:538
#: ../../reference/compound_stmts.rst:563
#: ../../reference/compound_stmts.rst:1596
msgid "is semantically equivalent to::"
msgstr "在语义上等价于::"

#: ../../reference/compound_stmts.rst:540
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:557
msgid ""
"With more than one item, the context managers are processed as if multiple "
":keyword:`with` statements were nested::"
msgstr "如果有多个项目，则会视作存在多个 :keyword:`with` 语句嵌套来处理多个上下文管理器::"

#: ../../reference/compound_stmts.rst:560
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""
"with A() as a, B() as b:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:565
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"

#: ../../reference/compound_stmts.rst:569
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr "也可以用圆括号包围的多行形式的多项目上下文管理器。例如::"

#: ../../reference/compound_stmts.rst:572
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:578
msgid "Support for multiple context expressions."
msgstr "支持多个上下文表达式。"

#: ../../reference/compound_stmts.rst:581
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr " 支持用圆括号将语句分成多行。"

#: ../../reference/compound_stmts.rst:586
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 语句"

#: ../../reference/compound_stmts.rst:587
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python :keyword:`with` 语句的规范描述、背景和示例。"

#: ../../reference/compound_stmts.rst:593
msgid "The :keyword:`!match` statement"
msgstr ":keyword:`!match` 语句"

#: ../../reference/compound_stmts.rst:607
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "匹配语句用于进行模式匹配。语法如下："

#: ../../reference/compound_stmts.rst:616
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr "本节使用单引号来表示 :ref:`软关键字 <soft-keywords>`。"

#: ../../reference/compound_stmts.rst:619
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject"
" value (following ``match``).  The pattern (which may contain subpatterns) "
"is matched against the subject value.  The outcomes are:"
msgstr ""
"模式匹配接受一个模式作为输入（跟在 ``case`` 后），一个目标值（跟在 ``match`` "
"后）。该模式（可能包含子模式）将与目标值进行匹配。输出是："

#: ../../reference/compound_stmts.rst:623
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr "匹配成功或失败（也被称为模式成功或失败）。"

#: ../../reference/compound_stmts.rst:625
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr "可能将匹配的值绑定到一个名字上。 这方面的先决条件将在下面进一步讨论。"

#: ../../reference/compound_stmts.rst:628
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-"
"keywords>`."
msgstr "关键字 ``match`` 和 ``case`` 是 :ref:`soft keywords <soft-keywords>` 。"

#: ../../reference/compound_stmts.rst:632
#: ../../reference/compound_stmts.rst:1189
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` —— 结构化模式匹配：规范"

#: ../../reference/compound_stmts.rst:633
#: ../../reference/compound_stmts.rst:1190
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` —— 结构化模式匹配：教程"

#: ../../reference/compound_stmts.rst:637
msgid "Overview"
msgstr "概述"

#: ../../reference/compound_stmts.rst:639
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "匹配语句逻辑流程的概述如下："

#: ../../reference/compound_stmts.rst:642
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject"
" value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"对目标表达式 ``subject_expr`` 求值后将结果作为匹配用的目标值。 如果目标表达式包含逗号，则使用 :ref:`the standard "
"rules <typesseq-tuple>` 构建一个元组。"

#: ../../reference/compound_stmts.rst:646
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"目标值将依次与 ``case_block`` "
"中的每个模式进行匹配。匹配成功或失败的具体规则在下面描述。匹配尝试也可以与模式中的一些或所有的独立名称绑定。准确的模式绑定规则因模式类型而异，具体规定见下文。**成功的模式匹配过程中产生的名称绑定将超越所执行的块的范围，可以在匹配语句之后使用**。"

#: ../../reference/compound_stmts.rst:655
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on"
" bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"在模式匹配失败时，一些子模式可能会成功。 不要依赖于失败匹配进行的绑定。 反过来说，不要认为变量在匹配失败后保持不变。 "
"确切的行为取决于实现，可能会有所不同。 这是一个有意的决定，允许不同的实现添加优化。"

#: ../../reference/compound_stmts.rst:662
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr "如果该模式匹配成功，并且完成了对相应的约束项（如果存在）的求值。在这种情况下，保证完成所有的名称绑定。"

#: ../../reference/compound_stmts.rst:665
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr "如果约束项求值为真或缺失，执行 ``case_block`` 中的 ``block`` 。"

#: ../../reference/compound_stmts.rst:668
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "否则，将按照上述方法尝试下一个 ``case_block`` 。"

#: ../../reference/compound_stmts.rst:670
msgid "If there are no further case blocks, the match statement is completed."
msgstr "如果没有进一步的 case 块，匹配语句终止。"

#: ../../reference/compound_stmts.rst:674
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr "用户一般不应依赖正在求值的模式。 根据不同的实现方式，解释器可能会缓存数值或使用其他优化方法来避免重复求值。"

#: ../../reference/compound_stmts.rst:678
msgid "A sample match statement::"
msgstr "匹配语句示例::"

#: ../../reference/compound_stmts.rst:680
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # 不匹配: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # 成功匹配，但防护检查失败\n"
"...        print('Case 2')\n"
"...    case (100, y):  # 匹配并将 y 绑定到 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # 未尝试的模式\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"

#: ../../reference/compound_stmts.rst:694
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr "在这个示例中，``if flag`` 是约束项。请阅读下一节以了解更多相关内容。"

#: ../../reference/compound_stmts.rst:697
msgid "Guards"
msgstr "约束项"

#: ../../reference/compound_stmts.rst:704
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the"
" ``case`` block to execute.  It takes the form: :keyword:`if` followed by an"
" expression."
msgstr ""
"``guard`` (它是 ``case`` 的一部分) 必须成立才能让 ``case`` 语句块中的代码被执行。 它所采用的形式为: "
":keyword:`if` 之后跟一个表达式。"

#: ../../reference/compound_stmts.rst:709
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "拥有 ``guard`` 的 ``case`` 块的逻辑流程如下："

#: ../../reference/compound_stmts.rst:711
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"检查 ``case`` 块中的模式是否匹配成功。如果该模式匹配失败，则不对 ``guard`` 进行求值，检查下一个 ``case`` 块。"

#: ../../reference/compound_stmts.rst:715
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "如果该模式匹配成功，对 ``guard`` 求值。"

#: ../../reference/compound_stmts.rst:717
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "如果 ``guard`` 求值为真，则选用该 case 块。"

#: ../../reference/compound_stmts.rst:720
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr "如果 ``guard`` 求值为假，则不选用该 case 块。"

#: ../../reference/compound_stmts.rst:723
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr "如果在对 ``guard`` 求值过程中引发了异常，则异常将被抛出。"

#: ../../reference/compound_stmts.rst:726
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"允许约束项产生副作用，因为他们是表达式。约束项求值必须从第一个 case 块到最后一个 case 块依次逐个进行，模式匹配失败的 case "
"块将被跳过。（也就是说，约束项求值必须按顺序进行。）一旦选用了一个 case 块，约束项求值必须由此终止。"

#: ../../reference/compound_stmts.rst:736
msgid "Irrefutable Case Blocks"
msgstr "必定匹配的 case 块"

#: ../../reference/compound_stmts.rst:740
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr "必定匹配的 case 块是能匹配所有情况的 case 块。一个匹配语句最多可以有一个必定匹配的 case 块，而且必须是最后一个。"

#: ../../reference/compound_stmts.rst:743
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is"
" irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"如果一个 case 块没有约束项，并且其模式是必定匹配的，那么它就被认为是必定匹配的。 "
"如果我们可以仅从语法上证明一个模式总是能匹配成功，那么这个模式就被认为是必定匹配的。 只有以下模式是必定匹配的："

#: ../../reference/compound_stmts.rst:748
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr "左侧模式是必定匹配的 :ref:`as-patterns`"

#: ../../reference/compound_stmts.rst:750
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr "包含至少一个必定匹配模式的 :ref:`or-patterns`"

#: ../../reference/compound_stmts.rst:752
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../../reference/compound_stmts.rst:754
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../../reference/compound_stmts.rst:756
msgid "parenthesized irrefutable patterns"
msgstr "括号内的必定匹配模式"

#: ../../reference/compound_stmts.rst:760
msgid "Patterns"
msgstr "模式"

#: ../../reference/compound_stmts.rst:767
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr "本节使用了超出标准 EBNF 的语法符号。"

#: ../../reference/compound_stmts.rst:769
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "符号 ``SEP.RULE+`` 是 ``RULE (SEP RULE)*`` 的简写"

#: ../../reference/compound_stmts.rst:771
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr "符号 ``!RULE`` 是前向否定断言的简写"

#: ../../reference/compound_stmts.rst:774
msgid "The top-level syntax for ``patterns`` is:"
msgstr "``patterns`` 的顶层语法是："

#: ../../reference/compound_stmts.rst:788
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"下面的描述将包括一个“简而言之”以描述模式的作用，便于说明问题（感谢 Raymond Hettinger "
"提供的一份文件，大部分的描述受其启发）。请注意，这些描述纯粹是为了说明问题，**可能不** 反映底层的实现。此外，它们并没有涵盖所有有效的形式。"

#: ../../reference/compound_stmts.rst:798
msgid "OR Patterns"
msgstr "或模式"

#: ../../reference/compound_stmts.rst:800
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr "或模式是由竖杠 ``|`` 分隔的两个或更多的模式。语法："

#: ../../reference/compound_stmts.rst:806
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr "只有最后的子模式可以是 :ref:`必定匹配的 <irrefutable_case>`，且每个子模式必须绑定相同的名字集以避免歧义。"

#: ../../reference/compound_stmts.rst:809
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"或模式将目标值依次与其每个子模式尝试匹配，直到有一个匹配成功，然后该或模式被视作匹配成功。 否则，如果没有任何子模式匹配成功，则或模式匹配失败。"

#: ../../reference/compound_stmts.rst:813
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"简而言之，``P1 | P2 | ...`` 会首先尝试匹配 ``P1`` ，如果失败将接着尝试匹配 ``P2`` "
"，如果出现成功的匹配则立即结束且模式匹配成功，否则模式匹配失败。"

#: ../../reference/compound_stmts.rst:819
msgid "AS Patterns"
msgstr "AS 模式"

#: ../../reference/compound_stmts.rst:821
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword"
" against a subject.  Syntax:"
msgstr "AS 模式将关键字 :keyword:`as` 左侧的或模式与目标值进行匹配。语法："

#: ../../reference/compound_stmts.rst:827
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"如果 OR 模式匹配失败，则 AS 模式也会失败。 在其他情况下，AS 模块会将目标与 as 关键字右边的名称绑定并匹配成功。 "
"``capture_pattern`` 不可为 ``_``。"

#: ../../reference/compound_stmts.rst:831
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr "简而言之， ``P as NAME`` 将与 ``P`` 匹配，成功后将设置 ``NAME = <subject>`` 。"

#: ../../reference/compound_stmts.rst:838
msgid "Literal Patterns"
msgstr "字面值模式"

#: ../../reference/compound_stmts.rst:840
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python."
"  Syntax:"
msgstr "字面值模式对应 Python 中的大多数 :ref:`字面值 <literals>`。 语法为:"

#: ../../reference/compound_stmts.rst:853
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the "
":doc:`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"规则 ``strings`` 和标记 ``NUMBER`` 是在 :doc:`standard Python grammar <./grammar>` "
"中定义的。支持三引号的字符串。不支持原始字符串和字节字符串。也不支持 :ref:`f-strings` 。"

#: ../../reference/compound_stmts.rst:858
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"``signed_number '+' NUMBER`` 和 ``signed_number '-' NUMBER`` 形式是用于表示 :ref:`复数"
" <imaginary>`；它们要求左边是一个实数而右边是一个虚数。 例如 ``3 + 4j``。"

#: ../../reference/compound_stmts.rst:862
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"简而言之， ``LITERAL`` 只会在 ``<subject> == LITERAL`` 时匹配成功。对于单例 ``None`` 、 "
"``True`` 和 ``False`` ，会使用 :keyword:`is` 运算符。"

#: ../../reference/compound_stmts.rst:868
msgid "Capture Patterns"
msgstr "捕获模式"

#: ../../reference/compound_stmts.rst:870
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "捕获模式将目标值与一个名称绑定。语法："

#: ../../reference/compound_stmts.rst:876
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-"
"grammar:wildcard_pattern`."
msgstr ""
"单独的一个下划线 ``_`` 不是捕获模式（ ``!'_'`` 表达的就是这个含义）。 它会被当作 :token:`~python-"
"grammar:wildcard_pattern` 。"

#: ../../reference/compound_stmts.rst:880
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, x: "
"...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"在给定的模式中，一个名字只能被绑定一次。例如 ``case x, x: ...`` 时无效的，但 ``case [x] | x: ...`` "
"是被允许的。"

#: ../../reference/compound_stmts.rst:883
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"捕获模式总是能匹配成功。绑定遵循 :pep:`572` 中赋值表达式运算符设立的作用域规则；名字在最接近的包含函数作用域内成为一个局部变量，除非有适用的"
" :keyword:`global` 或 :keyword:`nonlocal` 语句。"

#: ../../reference/compound_stmts.rst:888
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr "简而言之， ``NAME`` 总是会匹配成功且将设置 ``NAME = <subject>`` 。"

#: ../../reference/compound_stmts.rst:893
msgid "Wildcard Patterns"
msgstr "通配符模式"

#: ../../reference/compound_stmts.rst:895
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr "通配符模式总是会匹配成功（匹配任何内容）并且不绑定任何名称。语法："

#: ../../reference/compound_stmts.rst:901
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"在且仅在任何模式中 ``_`` 是一个 :ref:`软关键字 <soft-keywords>`。 通常情况下它是一个标识符，即使是在 ``match``"
" 的目标表达式、``guard`` 和 ``case`` 代码块中也是如此。"

#: ../../reference/compound_stmts.rst:905
msgid "In simple terms, ``_`` will always succeed."
msgstr "简而言之，``_`` 总是会匹配成功。"

#: ../../reference/compound_stmts.rst:910
msgid "Value Patterns"
msgstr "值模式"

#: ../../reference/compound_stmts.rst:912
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "值模式代表 Python 中具有名称的值。语法："

#: ../../reference/compound_stmts.rst:920
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name"
" resolution rules <resolve_names>`.  The pattern succeeds if the value found"
" compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"模式中带点的名称会使用标准的 Python :ref:`名称解析规则 <resolve_names>` 来查找。 "
"如果找到的值与目标值比较结果相等则模式匹配成功（使用 ``==`` 相等运算符）。"

#: ../../reference/compound_stmts.rst:925
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == "
"NAME1.NAME2``"
msgstr "简而言之， ``NAME1.NAME2`` 仅在 ``<subject> == NAME1.NAME2`` 时匹配成功。"

#: ../../reference/compound_stmts.rst:929
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"如果相同的值在同一个匹配语句中出现多次，解释器可能会缓存找到的第一个值并重新使用它，而不是重复查找。 这种缓存与特定匹配语句的执行严格挂钩。"

#: ../../reference/compound_stmts.rst:937
msgid "Group Patterns"
msgstr "组模式"

#: ../../reference/compound_stmts.rst:939
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize"
" the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr "组模式允许用户在模式周围添加括号，以强调预期的分组。 除此之外，它没有额外的语法。语法："

#: ../../reference/compound_stmts.rst:946
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "简单来说 ``(P)`` 具有与 ``P`` 相同的效果。"

#: ../../reference/compound_stmts.rst:951
msgid "Sequence Patterns"
msgstr "序列模式"

#: ../../reference/compound_stmts.rst:953
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or "
"tuple."
msgstr "一个序列模式包含数个将与序列元素进行匹配的子模式。其语法类似于列表或元组的解包。"

#: ../../reference/compound_stmts.rst:964
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr "序列模式中使用圆括号或方括号没有区别（例如 ``(...)`` 和 ``[...]`` ）。"

#: ../../reference/compound_stmts.rst:968
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3"
" | 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"用圆括号括起来且没有跟随逗号的单个模式 (例如 ``(3 | 4)``) 是一个 :ref:`分组模式 <group-patterns>`。 "
"而用方括号括起来的单个模式 (例如 ``[3 | 4]``) 则仍是一个序列模式。"

#: ../../reference/compound_stmts.rst:973
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"一个序列模式中最多可以有一个星号子模式。星号子模式可以出现在任何位置。如果没有星号子模式，该序列模式是固定长度的序列模式；否则，其是一个可变长度的序列模式。"

#: ../../reference/compound_stmts.rst:978
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr "下面是将一个序列模式与一个目标值相匹配的逻辑流程："

#: ../../reference/compound_stmts.rst:981
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr "如果目标值不是一个序列 [#]_ ，该序列模式匹配失败。"

#: ../../reference/compound_stmts.rst:984
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr "如果目标值是 ``str`` 、 ``bytes`` 或 ``bytearray`` 的实例，则该序列模式匹配失败。"

#: ../../reference/compound_stmts.rst:987
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr "随后的步骤取决于序列模式是固定长度还是可变长度的。"

#: ../../reference/compound_stmts.rst:990
msgid "If the sequence pattern is fixed-length:"
msgstr "如果序列模式是固定长度的："

#: ../../reference/compound_stmts.rst:992
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr "如果目标序列的长度与子模式的数量不相等，则该序列模式匹配失败"

#: ../../reference/compound_stmts.rst:995
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items"
" in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"序列模式中的子模式与目标序列中的相应项目从左到右进行匹配。 一旦一个子模式匹配失败，就停止匹配。 "
"如果所有的子模式都成功地与它们的对应项相匹配，那么该序列模式就匹配成功了。"

#: ../../reference/compound_stmts.rst:1000
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "否则，如果序列模式是变长的："

#: ../../reference/compound_stmts.rst:1002
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr "如果目标序列的长度小于非星号子模式的数量，则该序列模式匹配失败。"

#: ../../reference/compound_stmts.rst:1005
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as"
" for fixed-length sequences."
msgstr "与固定长度的序列一样，靠前的非星形子模式与其相应的项目进行匹配。"

#: ../../reference/compound_stmts.rst:1008
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr "如果上一步成功，星号子模式与剩余的目标项形成的列表相匹配，不包括星号子模式之后的非星号子模式所对应的剩余项。"

#: ../../reference/compound_stmts.rst:1012
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr "剩余的非星号子模式将与相应的目标项匹配，就像固定长度的序列一样。"

#: ../../reference/compound_stmts.rst:1015
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via the"
" :meth:`__len__` protocol).  This length may be cached by the interpreter in"
" a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"目标序列的长度可通过 :func:`len` (即通过 :meth:`__len__` 协议) 获得。 解释器可能会以类似于 :ref:`值模式 "
"<value-patterns>` 的方式缓存这个长度信息。"

#: ../../reference/compound_stmts.rst:1021
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr "简而言之， ``[P1, P2, P3,`` ... ``, P<N>]`` 仅在满足以下情况时匹配成功："

#: ../../reference/compound_stmts.rst:1024
msgid "check ``<subject>`` is a sequence"
msgstr "检查 ``<subject>`` 是一个序列"

#: ../../reference/compound_stmts.rst:1025
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../../reference/compound_stmts.rst:1026
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr "将 ``P1`` 与 ``<subject>[0]`` 进行匹配（请注意此匹配可以绑定名称）"

#: ../../reference/compound_stmts.rst:1027
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr "将 ``P2`` 与 ``<subject>[1]`` 进行匹配（请注意此匹配可以绑定名称）"

#: ../../reference/compound_stmts.rst:1028
msgid "... and so on for the corresponding pattern/element."
msgstr "…… 剩余对应的模式/元素也以此类推。"

#: ../../reference/compound_stmts.rst:1033
msgid "Mapping Patterns"
msgstr "映射模式"

#: ../../reference/compound_stmts.rst:1035
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr "映射模式包含一个或多个键值模式。其语法类似于字典的构造。语法："

#: ../../reference/compound_stmts.rst:1046
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr "一个映射模式中最多可以有一个双星号模式。双星号模式必须是映射模式中的最后一个子模式。"

#: ../../reference/compound_stmts.rst:1049
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value"
" will raise a :exc:`ValueError` at runtime."
msgstr ""
"映射模式中不允许出现重复的键。重复的字面值键会引发  :exc:`SyntaxError` 。若是两个键有相同的值将会在运行时引发 "
":exc:`ValueError` 。"

#: ../../reference/compound_stmts.rst:1053
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr "以下是映射模式与目标值匹配的逻辑流程："

#: ../../reference/compound_stmts.rst:1056
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr "如果目标值不是一个映射 [#]_，则映射模式匹配失败。"

#: ../../reference/compound_stmts.rst:1058
msgid ""
"If every key given in the mapping pattern is present in the subject mapping,"
" and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr "若映射模式中给出的每个键都存在于目标映射中，且每个键的模式都与目标映射的相应项匹配成功，则该映射模式匹配成功。"

#: ../../reference/compound_stmts.rst:1062
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"如果在映射模式中检测到重复的键，该模式将被视作无效。对于重复的字面值，会引发  :exc:`SyntaxError` ；对于相同值的命名键，会引发  "
":exc:`ValueError` 。"

#: ../../reference/compound_stmts.rst:1066
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present"
" in the mapping, and not created on-the-fly via :meth:`__missing__` or "
":meth:`~object.__getitem__`."
msgstr ""
"键值对使用映射目标的 ``get()`` 方法的双参数形式进行匹配。 匹配的键值对必须已经存在于映射中，而不是通过 "
":meth:`__missing__` 或 :meth:`~object.__getitem__` 即时创建。"

#: ../../reference/compound_stmts.rst:1071
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr "简而言之， ``{KEY1: P1, KEY2: P2, ... }`` 仅在满足以下情况时匹配成功："

#: ../../reference/compound_stmts.rst:1074
msgid "check ``<subject>`` is a mapping"
msgstr "检查 ``<subject>`` 是映射"

#: ../../reference/compound_stmts.rst:1075
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

#: ../../reference/compound_stmts.rst:1076
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` 与 ``<subject>[KEY1]`` 相匹配"

#: ../../reference/compound_stmts.rst:1077
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "…… 剩余对应的键/模式对也以此类推。"

#: ../../reference/compound_stmts.rst:1083
msgid "Class Patterns"
msgstr "类模式"

#: ../../reference/compound_stmts.rst:1085
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr "类模式表示一个类以及它的位置参数和关键字参数（如果有的话）。语法："

#: ../../reference/compound_stmts.rst:1096
msgid "The same keyword should not be repeated in class patterns."
msgstr "同一个关键词不应该在类模式中重复出现。"

#: ../../reference/compound_stmts.rst:1098
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr "以下是类模式与目标值匹配的逻辑流程："

#: ../../reference/compound_stmts.rst:1101
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise "
":exc:`TypeError`."
msgstr "如果 ``name_or_attr`` 不是内置 :class:`type` 的实例，引发 :exc:`TypeError` 。"

#: ../../reference/compound_stmts.rst:1104
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via "
":func:`isinstance`), the class pattern fails."
msgstr "如果目标值不是 ``name_or_attr`` 的实例（通过 :func:`isinstance` 测试），该类模式匹配失败。"

#: ../../reference/compound_stmts.rst:1107
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr "如果没有模式参数存在，则该模式匹配成功。 否则，后面的步骤取决于是否有关键字或位置参数模式存在。"

#: ../../reference/compound_stmts.rst:1111
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr "对于一些内置的类型（将在后文详述），接受一个位置子模式，它将与整个目标值相匹配；对于这些类型，关键字模式也像其他类型一样工作。"

#: ../../reference/compound_stmts.rst:1115
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr "如果只存在关键词模式，它们将被逐一处理，如下所示："

#: ../../reference/compound_stmts.rst:1118
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "一. 该关键词被视作主体的一个属性进行查找。"

#: ../../reference/compound_stmts.rst:1120
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr "如果这引发了除 :exc:`AttributeError` 以外的异常，该异常会被抛出。"

#: ../../reference/compound_stmts.rst:1123
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "如果这引发了 :exc:`AttributeError` ，该类模式匹配失败。"

#: ../../reference/compound_stmts.rst:1125
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr "否则，与关键词模式相关的子模式将与目标的属性值进行匹配。 如果失败，则类模式匹配失败；如果成功，则继续对下一个关键词进行匹配。"

#: ../../reference/compound_stmts.rst:1130
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "二. 如果所有的关键词模式匹配成功，该类模式匹配成功。"

#: ../../reference/compound_stmts.rst:1132
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"如果存在位置模式，在匹配前会用类 ``name_or_attr`` 的 :data:`~object.__match_args__` "
"属性将其转换为关键词模式。"

#: ../../reference/compound_stmts.rst:1136
msgid "I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr "一. 进行与 ``getattr(cls, \"__match_args__\", ())`` 等价的调用。"

#: ../../reference/compound_stmts.rst:1138
msgid "If this raises an exception, the exception bubbles up."
msgstr "如果这引发一个异常，该异常将被抛出。"

#: ../../reference/compound_stmts.rst:1140
msgid ""
"If the returned value is not a tuple, the conversion fails and "
":exc:`TypeError` is raised."
msgstr "如果返回值不是一个元组，则转换失败且引发 :exc:`TypeError` 。"

#: ../../reference/compound_stmts.rst:1143
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, "
":exc:`TypeError` is raised."
msgstr "若位置模式的数量超出 ``len(cls.__match_args__)`` ，将引发 :exc:`TypeError` 。"

#: ../../reference/compound_stmts.rst:1146
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"否则，位置模式 ``i`` 会使用 ``__match_args__[i]`` 转换为关键词。 ``__match_args__[i]`` "
"必须是一个字符串；如果不是则引发 :exc:`TypeError` 。"

#: ../../reference/compound_stmts.rst:1150
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "如果有重复的关键词，引发 :exc:`TypeError` 。"

#: ../../reference/compound_stmts.rst:1152
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../../reference/compound_stmts.rst:1154
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr "二. 若所有的位置模式都被转换为关键词模式，"

#: ../../reference/compound_stmts.rst:1155
msgid "the match proceeds as if there were only keyword patterns."
msgstr "匹配的过程就像只有关键词模式一样。"

#: ../../reference/compound_stmts.rst:1157
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr "对于以下内置类型，位置子模式的处理是不同的："

#: ../../reference/compound_stmts.rst:1160
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1161
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../../reference/compound_stmts.rst:1162
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1163
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1164
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1165
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1166
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1167
#: ../../reference/compound_stmts.rst:1919
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../reference/compound_stmts.rst:1168
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1169
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1170
#: ../../reference/compound_stmts.rst:1922
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1172
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"这些类接受一个位置参数，其模式是针对整个对象而不是某个属性进行匹配。 例如，``int(0|1)`` 匹配值 ``0``，但不匹配值 ``0.0``。"

#: ../../reference/compound_stmts.rst:1176
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr "简而言之， ``CLS(P1, attr=P2)`` 仅在满足以下情况时匹配成功："

#: ../../reference/compound_stmts.rst:1178
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: ../../reference/compound_stmts.rst:1179
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr "用 ``CLS.__match_args__`` 将 ``P1`` 转换为关键词模式"

#: ../../reference/compound_stmts.rst:1180
msgid "For each keyword argument ``attr=P2``:"
msgstr "对于每个关键词参数 ``attr=P2`` ："

#: ../../reference/compound_stmts.rst:1182
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: ../../reference/compound_stmts.rst:1183
msgid "``P2`` matches ``<subject>.attr``"
msgstr "将 ``P2`` 与 ``<subject>.attr`` 进行匹配"

#: ../../reference/compound_stmts.rst:1185
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "…… 剩余对应的关键字参数/模式对也以此类推。"

#: ../../reference/compound_stmts.rst:1200
msgid "Function definitions"
msgstr "函数定义"

#: ../../reference/compound_stmts.rst:1215
msgid ""
"A function definition defines a user-defined function object (see section "
":ref:`types`):"
msgstr "函数定义就是对用户自定义函数的定义（参见 :ref:`types` 一节）:"

#: ../../reference/compound_stmts.rst:1237
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper"
" around the executable code for the function).  This function object "
"contains a reference to the current global namespace as the global namespace"
" to be used when the function is called."
msgstr ""
"函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个函数对象（函数可执行代码的包装器）。 "
"这个函数对象包含对当前全局命名空间的引用，作为函数被调用时所使用的全局命名空间。"

#: ../../reference/compound_stmts.rst:1243
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。 [#]_"

#: ../../reference/compound_stmts.rst:1249
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"一个函数定义可以被一个或多个 :term:`decorator` 表达式所包装。 当函数被定义时将在包含该函数定义的作用域中对装饰器表达式求值。 "
"求值结果必须是一个可调用对象，它会以该函数对象作为唯一参数被唤起。 其返回值将被绑定到函数名称而非函数对象。 多个装饰器会以嵌套方式被应用。 "
"例如以下代码 ::"

#: ../../reference/compound_stmts.rst:1256
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"

#: ../../reference/compound_stmts.rst:1260
#: ../../reference/compound_stmts.rst:1449
msgid "is roughly equivalent to ::"
msgstr "大致等价于 ::"

#: ../../reference/compound_stmts.rst:1262
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"

#: ../../reference/compound_stmts.rst:1265
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "不同之处在于原始函数并不会被临时绑定到名称 ``func``。"

#: ../../reference/compound_stmts.rst:1267
msgid ""
"Functions may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"函数可使用任何有效的 :token:`~python-grammar:assignment_expression` 来装饰。 "
"在之前版本中，此语法则更为受限，详情参见 :pep:`614`。"

#: ../../reference/compound_stmts.rst:1272
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""
"可以在函数名及其形参列表开头圆括号之间加方括号给出一个 :ref:`类型形参 <type-params>` 的列表。 "
"这将向静态类型检查器指明该函数是泛型尾数。 在运行时，类型形参可以从函数的 :attr:`~function.__type_params__` "
"属性中提取。 请参阅 :ref:`generic-functions` 了解详情。"

#: ../../reference/compound_stmts.rst:1279
#: ../../reference/compound_stmts.rst:1468
msgid "Type parameter lists are new in Python 3.12."
msgstr "类型形参列表是在 Python 3.12 中新增的。"

#: ../../reference/compound_stmts.rst:1287
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the parameter's "
"default value is substituted.  If a parameter has a default value, all "
"following parameters up until the \"``*``\" must also have a default value "
"--- this is a syntactic restriction that is not expressed by the grammar."
msgstr ""
"当一个或多个 :term:`形参 <parameter>` 具有 *形参* ``=`` *表达式* 这样的形式时，该函数就被称为具有“默认形参值”。 "
"对于一个具有默认值的形参，其对应的 :term:`argument` 可以在调用中被省略，在此情况下会用形参的默认值来替代。 "
"如果一个形参具有默认值，后续所有在 \"``*``\" 之前的形参也必须具有默认值 --- 这个句法限制并未在语法中明确表达。"

#: ../../reference/compound_stmts.rst:1295
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending"
" an item to a list), the default parameter value is in effect modified.  "
"This is generally not what was intended.  A way around this is to use "
"``None`` as the default, and explicitly test for it in the body of the "
"function, e.g.::"
msgstr ""
"**默认形参值会在执行函数定义时按从左至右的顺序被求值。** 这意味着当函数被定义时将对表达式求值一次，相同的“预计算”值将在每次调用时被使用。 "
"这一点在默认形参为可变对象，例如列表或字典的时候尤其需要重点理解：如果函数修改了该对象（例如向列表添加了一项），则实际上默认值也会被修改。 "
"这通常不是人们所想要的。 绕过此问题的一个方法是使用 ``None`` 作为默认值，并在函数体中显式地对其进测试，例如::"

#: ../../reference/compound_stmts.rst:1305
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"

#: ../../reference/compound_stmts.rst:1316
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from positional arguments, from "
"keyword arguments, or from default values.  If the form \"``*identifier``\" "
"is present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"函数调用的语义在 :ref:`calls` 一节中有更详细的描述。 "
"函数调用总是会给形参列表中列出的所有形参赋值，或是用位置参数，或是用关键字参数，或是用默认值。 如果存在 \"``*identifier``\" "
"这样的形式，它会被初始化为一个元组来接收任何额外的位置参数，默认为一个空元组。 如果存在 \"``**identifier``\" "
"这样的形式，它会被初始化为一个新的有序映射来接收任何额外的关键字参数，默认为一个相同类型的空映射。 在 \"``*``\" 或 "
"\"``*identifier``\" 之后的形参都是仅限关键字形参因而只能通过关键字参数传入。 在 \"``/``\" "
"之前的形参都是仅限位置形参因而只能通过位置参数传入。"

#: ../../reference/compound_stmts.rst:1328
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr "可以使用 ``/`` 函数形参语法来标示仅限位置形参。 请参阅 :pep:`570` 了解详情。"

#: ../../reference/compound_stmts.rst:1337
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations"
" does not change the semantics of a function. See :ref:`annotations` for "
"more information on annotations."
msgstr ""

#: ../../reference/compound_stmts.rst:1345
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr "形式为 \"``*identifier``\" 的形参可以带有 \"``: *expression``\" 标注。 参见 :pep:`646`。"

#: ../../reference/compound_stmts.rst:1351
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The "
"\":keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需要使用 lambda 表达式，具体描述见 :ref:`lambda` "
"一节。 请注意 lambda 只是简单函数定义的一种简化写法；在 \":keyword:`def`\" 语句中定义的函数也可以像用 lambda "
"表达式定义的函数一样被传递或赋值给其他名称。 \":keyword:`!def`\" 形式实际上更为强大，因为它允许执行多条语句和使用标注。"

#: ../../reference/compound_stmts.rst:1359
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def."
"  See section :ref:`naming` for details."
msgstr ""
"**程序员注意事项:** 函数属于一类对象。 在一个函数内部执行的 \"``def``\" 语句会定义一个局部函数并可被返回或传递。 "
"在嵌套函数中使用的自由变量可以访问包含该 def 语句的函数的局部变量。 详情参见 :ref:`naming` 一节。"

#: ../../reference/compound_stmts.rst:1367
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - 函数标注"

#: ../../reference/compound_stmts.rst:1368
msgid "The original specification for function annotations."
msgstr "最初的函数标注规范说明。"

#: ../../reference/compound_stmts.rst:1370
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` —— 类型注解"

#: ../../reference/compound_stmts.rst:1371
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "标注的标准含意定义：类型提示。"

#: ../../reference/compound_stmts.rst:1373
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 变量标注的语法"

#: ../../reference/compound_stmts.rst:1374
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr "变量声明的类型提示功能，包括类变量和实例变量。"

#: ../../reference/compound_stmts.rst:1377
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - 延迟的标注求值"

#: ../../reference/compound_stmts.rst:1378
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr "支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。"

#: ../../reference/compound_stmts.rst:1381
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`318` - 函数和方法的装饰器"

#: ../../reference/compound_stmts.rst:1382
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr "引入了函数和方法的装饰器。 类装饰器是在 :pep:`3129` 中引入的。"

#: ../../reference/compound_stmts.rst:1388
msgid "Class definitions"
msgstr "类定义"

#: ../../reference/compound_stmts.rst:1403
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "类定义就是对类对象的定义 (参见 :ref:`types` 一节):"

#: ../../reference/compound_stmts.rst:1410
msgid ""
"A class definition is an executable statement.  The inheritance list usually"
" gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 "
":ref:`metaclasses`)，列表中的每一项都应当被求值为一个允许子类的类对象。 没有继承列表的类默认继承自基类 "
":class:`object`；因此，::"

#: ../../reference/compound_stmts.rst:1416
msgid ""
"class Foo:\n"
"    pass"
msgstr ""
"class Foo:\n"
"    pass"

#: ../../reference/compound_stmts.rst:1419
msgid "is equivalent to ::"
msgstr "等价于 ::"

#: ../../reference/compound_stmts.rst:1421
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""
"class Foo(object):\n"
"    pass"

#: ../../reference/compound_stmts.rst:1424
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function definitions.)"
"  When the class's suite finishes execution, its execution frame is "
"discarded but its local namespace is saved. [#]_ A class object is then "
"created using the inheritance list for the base classes and the saved local "
"namespace for the attribute dictionary.  The class name is bound to this "
"class object in the original local namespace."
msgstr ""
"随后类体将在一个新的执行帧 (参见 :ref:`naming`) 中被执行，使用新创建的局部命名空间和原有的全局命名空间。 "
"（通常，类体主要包含函数定义。） 当类体结束执行时，其执行帧将被丢弃而其局部命名空间会被保存。 [#]_ "
"一个类对象随后会被创建，其基类使用给定的继承列表，属性字典使用保存的局部命名空间。 类名称将在原有的全局命名空间中绑定到该类对象。"

#: ../../reference/compound_stmts.rst:1433
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"在类体内定义的属性的顺序保存在新类的 :attr:`~type.__dict__` 中。 "
"请注意此顺序的可靠性只限于类刚被创建时，并且只适用于定义语法所定义的类。"

#: ../../reference/compound_stmts.rst:1438
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "类的创建可使用 :ref:`元类 <metaclasses>` 进行重度定制。"

#: ../../reference/compound_stmts.rst:1443
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "类也可以被装饰：就像装饰函数一样，::"

#: ../../reference/compound_stmts.rst:1445
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"

#: ../../reference/compound_stmts.rst:1451
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"

#: ../../reference/compound_stmts.rst:1454
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。"

#: ../../reference/compound_stmts.rst:1457
msgid ""
"Classes may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"类可使用任何有效的 :token:`~python-grammar:assignment_expression` 来装饰。 "
"在之前版本中，此语法则更为受限，详情参见 :pep:`614`。"

#: ../../reference/compound_stmts.rst:1462
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. See "
":ref:`generic-classes` for more."
msgstr ""
"可以在类名之后的方括号中列出 :ref:`类型形参 <type-params>`。 这将向静态类型检查器指明该类是泛型类。 在运行时，可以从类的 "
":attr:`~type.__type_params__` 属性中获取类型形参。 请参阅 :ref:`generic-classes` 了解详情。"

#: ../../reference/compound_stmts.rst:1471
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in"
" a method with ``self.name = value``.  Both class and instance attributes "
"are accessible through the notation \"``self.name``\", and an instance "
"attribute hides a class attribute with the same name when accessed in this "
"way.  Class attributes can be used as defaults for instance attributes, but "
"using mutable values there can lead to unexpected results.  "
":ref:`Descriptors <descriptors>` can be used to create instance variables "
"with different implementation details."
msgstr ""
"**程序员注意事项:** 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例属性可通过 ``self.name = value`` "
"在方法中设定。 类和实例属性均可通过 \"``self.name``\" 表示法来访问，当通过此方式访问时实例属性会隐藏同名的类属性。 "
"类属性可被用作实例属性的默认值，但在此场景下使用可变值可能导致未预期的结果。 可以使用 :ref:`描述器 <descriptors>` "
"来创建具有不同实现细节的实例变量。"

#: ../../reference/compound_stmts.rst:1483
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Python 3000 中的元类"

#: ../../reference/compound_stmts.rst:1484
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr "将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。"

#: ../../reference/compound_stmts.rst:1488
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 类装饰器"

#: ../../reference/compound_stmts.rst:1489
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr "增加类装饰器的提议。 函数和方法装饰器是在 :pep:`318` 中被引入的。"

#: ../../reference/compound_stmts.rst:1496
msgid "Coroutines"
msgstr "协程"

#: ../../reference/compound_stmts.rst:1504
msgid "Coroutine function definition"
msgstr "协程函数定义"

#: ../../reference/compound_stmts.rst:1514
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Python 协程的执行可以在多个位置上被挂起和恢复 (参见 :term:`coroutine`)。 :keyword:`await` "
"表达式，:keyword:`async for` 以及 :keyword:`async with` 只能在协程函数体中使用。"

#: ../../reference/compound_stmts.rst:1518
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr "使用 ``async def`` 语法定义的函数总是为协程函数，即使它们不包含 ``await`` 或 ``async`` 关键字。"

#: ../../reference/compound_stmts.rst:1521
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr "在协程函数体中使用 ``yield from`` 表达式将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1524
msgid "An example of a coroutine function::"
msgstr "协程函数的例子::"

#: ../../reference/compound_stmts.rst:1526
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"

#: ../../reference/compound_stmts.rst:1530
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr "``await`` 和 ``async`` 现在是保留关键字；在之前版本中它们仅在协程函数内被当作保留关键字。"

#: ../../reference/compound_stmts.rst:1538
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 语句"

#: ../../reference/compound_stmts.rst:1543
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` 提供了 ``__aiter__`` 方法，该方法会直接返回 "
":term:`asynchronous iterator`，它可以在其 ``__anext__`` 方法中调用异步代码。"

#: ../../reference/compound_stmts.rst:1547
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr "``async for`` 语句允许方便地对异步可迭代对象进行迭代。"

#: ../../reference/compound_stmts.rst:1552
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1557
msgid "Is semantically equivalent to::"
msgstr "在语义上等价于::"

#: ../../reference/compound_stmts.rst:1559
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1573
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for "
"details."
msgstr "另请参阅 :meth:`~object.__aiter__` 和 :meth:`~object.__anext__` 了解详情。"

#: ../../reference/compound_stmts.rst:1575
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr "在协程函数体之外使用 ``async for`` 语句将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1583
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 语句"

#: ../../reference/compound_stmts.rst:1588
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is"
" able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`asynchronous context manager` 是一种 :term:`context manager`，能够在其 "
"*enter* 和 *exit* 方法中暂停执行。"

#: ../../reference/compound_stmts.rst:1593
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:1598
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:1615
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr "另请参阅 :meth:`~object.__aenter__` 和 :meth:`~object.__aexit__` 了解详情。"

#: ../../reference/compound_stmts.rst:1617
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr "在协程函数体之外使用 ``async with`` 语句将引发 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1622
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - 使用 async 和 await 语法实现协程"

#: ../../reference/compound_stmts.rst:1623
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and"
" added supporting syntax."
msgstr "将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。"

#: ../../reference/compound_stmts.rst:1629
msgid "Type parameter lists"
msgstr "类型形参列表"

#: ../../reference/compound_stmts.rst:1633
msgid "Support for default values was added (see :pep:`696`)."
msgstr "增加了对默认值的支持 (参见 :pep:`696`)。"

#: ../../reference/compound_stmts.rst:1646
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), "
":ref:`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""
":ref:`函数 <def>` (包括 :ref:`协程 <async def>`), :ref:`类 <class>` 和 :ref:`类型别名 "
"<type>` 可能包含类型形参列表::"

#: ../../reference/compound_stmts.rst:1650
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1665
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""
"从语义上讲，这表明函数、类或类型别名是类型变量的泛型。 此信息主要供静态类型检查器使用，并且在运行时，泛型对象的行为与其对应的非泛型对象非常相似。"

#: ../../reference/compound_stmts.rst:1670
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available"
" in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""
"类型参数是紧接在函数、类或类型别名的名称之后的方括号 (``[]``) 中声明的。 类型参数可在泛型对象的作用域内访问，但不能在其他地方访问。 "
"因此，在声明 ``def func[T](): pass`` 之后，模块作用域中就不能再使用 ``T`` 这个名称。 "
"在下文中，将更精确地描述泛型对象的语义。 类型形参的作用域是用一个特殊函数 (从技术上说，是一个 :ref:`标注作用域 <annotation-"
"scopes>`) 来模拟的，它封装了泛型对象的创建操作。"

#: ../../reference/compound_stmts.rst:1679
msgid ""
"Generic functions, classes, and type aliases have a "
":attr:`~definition.__type_params__` attribute listing their type parameters."
msgstr "泛型函数、类和类型别名都有一个 :attr:`~definition.__type_params__` 属性用来列出它们的类型形参。"

#: ../../reference/compound_stmts.rst:1682
msgid "Type parameters come in three kinds:"
msgstr "类型形参可分为三种:"

#: ../../reference/compound_stmts.rst:1684
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""
":data:`typing.TypeVar`，由一个普通名称 (例如 ``T``) 引入。 从语义上讲，这对类型检查器来说代表了一个单独类型。"

#: ../../reference/compound_stmts.rst:1686
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""
":data:`typing.TypeVarTuple`，通过在前面添加一个星号的名称来引入 (例如 ``*Ts``)。 "
"从语义上讲，它代表由任意多个类型组成的元组。"

#: ../../reference/compound_stmts.rst:1689
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""
":data:`typing.ParamSpec`，通过在前面添加两个星号的名称来引入 (例如 ``**P``)。 "
"从语义上讲，它代表一个可调用对象的形参。"

#: ../../reference/compound_stmts.rst:1692
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that"
" the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a"
" set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""
":data:`typing.TypeVar` 声明可以通过在冒号 (``:`` ) 后跟一个表达式来定义 *范围* 和 *约束*。 "
"冒号后的单独表达式表示一个范围 (例如 ``T: int``)。 从语义上讲，这意味着 :data:`!typing.TypeVar` "
"能表示的类型只能是该范围的子类型。 冒号后在圆括号内的表达式元组指定了一组约束 (例如 ``T: (str, bytes)``)。 "
"元组中的每个成员都应为一个类型 (同样，在运行时并不强制要求这一点)。 约束的类型变量只能使用约束列表内的类型中选择一种。 "

#: ../../reference/compound_stmts.rst:1701
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""
"对于使用类型形参列表语法声明的 :data:`!typing.TypeVar`，范围和约束在创建泛型对象时并不会被求值，只有在通过属性 "
"``__bound__`` 和 ``__constraints__`` 显式地访问它时才会被求值。 要做到这一点，需要在单独的 :ref:`标注作用域 "
"<annotation-scopes>` 中对范围和约束进行求值。"

#: ../../reference/compound_stmts.rst:1707
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have"
" bounds or constraints."
msgstr ":data:`typing.TypeVarTuple` 和 :data:`typing.ParamSpec` 不能拥有范围或约束。"

#: ../../reference/compound_stmts.rst:1710
msgid ""
"All three flavors of type parameters can also have a *default value*, which "
"is used when the type parameter is not explicitly provided. This is added by"
" appending a single equals sign (``=``) followed by an expression. Like the "
"bounds and constraints of type variables, the default value is not evaluated"
" when the object is created, but only when the type parameter's "
"``__default__`` attribute is accessed. To this end, the default value is "
"evaluated in a separate :ref:`annotation scope <annotation-scopes>`. If no "
"default value is specified for a type parameter, the ``__default__`` "
"attribute is set to the special sentinel object :data:`typing.NoDefault`."
msgstr ""
"所有三种风格的类型形参都还可以具有 *默认值*，它会在未显式提供类型形参值时被使用。 这是通过添加单个等号 (``=``) 跟一个表达式来添加的。 "
"与类型变量的绑定和约束类似，默认值不是在创建对象时被求值的，而是在类型形参的 ``__default__`` 属性被访问的时候。 为此，默认值将在单独的"
" :ref:`标注作用域 <annotation-scopes>` 中被求值。 如果没有为类型形参指定默认值，``__default__`` "
"属性将被设为特殊的哨兵对象 :data:`typing.NoDefault`。"

#: ../../reference/compound_stmts.rst:1720
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr "下面的例子显示了所有被允许的类型形参声明::"

#: ../../reference/compound_stmts.rst:1722
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."

#: ../../reference/compound_stmts.rst:1740
msgid "Generic functions"
msgstr "泛型函数"

#: ../../reference/compound_stmts.rst:1742
msgid "Generic functions are declared as follows::"
msgstr "泛型函数的声明方式如下::"

#: ../../reference/compound_stmts.rst:1744
msgid "def func[T](arg: T): ..."
msgstr "def func[T](arg: T): ..."

#: ../../reference/compound_stmts.rst:1746
#: ../../reference/compound_stmts.rst:1806
msgid "This syntax is equivalent to::"
msgstr "该语法等价于::"

#: ../../reference/compound_stmts.rst:1748
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"

#: ../../reference/compound_stmts.rst:1755
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of "
":data:`typing.TypeVar` directly.)"
msgstr ""
"这里 ``annotation-def`` 指定了一个 :ref:`标注作用域 <annotation-"
"scopes>`，它在运行时并不会实际绑定到任何名称。 （另一项自由是在翻译中达成的：该语法没有通过 :mod:`typing` "
"模块的属性访问，而是直接创建了一个 :data:`typing.TypeVar` 的实例）。"

#: ../../reference/compound_stmts.rst:1761
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr "泛型函数的标注会在用于声明类型形参的标注作用域内进行求值，但函数的默认值和装饰器则不会。"

#: ../../reference/compound_stmts.rst:1765
msgid ""
"The following example illustrates the scoping rules for these cases, as well"
" as for additional flavors of type parameters::"
msgstr "下面的例子演示了针对这些场景，以及类型形参的变化形式的作用域规则::"

#: ../../reference/compound_stmts.rst:1768
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."

#: ../../reference/compound_stmts.rst:1772
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the "
":class:`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""
"除了 :class:`~typing.TypeVar` 绑定的 :ref:`惰性求值 <lazy-evaluation>` 以外，这等同于::"

#: ../../reference/compound_stmts.rst:1775
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # 在现实中，BOUND_OF_T() 仅会在需要时被求值。\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"

#: ../../reference/compound_stmts.rst:1794
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr "大写形式的名称如 ``DEFAULT_OF_arg`` 在运行时不会被实际绑定。"

#: ../../reference/compound_stmts.rst:1800
msgid "Generic classes"
msgstr "泛型类"

#: ../../reference/compound_stmts.rst:1802
msgid "Generic classes are declared as follows::"
msgstr "泛型类的声明方式如下::"

#: ../../reference/compound_stmts.rst:1804
msgid "class Bag[T]: ..."
msgstr "class Bag[T]: ..."

#: ../../reference/compound_stmts.rst:1808
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"

#: ../../reference/compound_stmts.rst:1816
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an "
":ref:`annotation scope <annotation-scopes>`, and the name "
"``TYPE_PARAMS_OF_Bag`` is not actually bound at runtime."
msgstr ""
"这里还是用 ``annotation-def`` (不是真正的关键字) 指明 :ref:`标注作用域 <annotation-scopes>`，而名称 "
"``TYPE_PARAMS_OF_Bag`` 在不会运行时实际被绑定。"

#: ../../reference/compound_stmts.rst:1820
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""
"泛型类隐式地继承自 :data:`typing.Generic`。 "
"泛型类的基类和关键字参数在类型形参的类型作用域内进行求值，而装饰器则在该作用域之外进行求值。 以下示例对此进行了说明::"

#: ../../reference/compound_stmts.rst:1826
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."

#: ../../reference/compound_stmts.rst:1829
msgid "This is equivalent to::"
msgstr "这相当于："

#: ../../reference/compound_stmts.rst:1831
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"

#: ../../reference/compound_stmts.rst:1842
msgid "Generic type aliases"
msgstr "泛型类型别名"

#: ../../reference/compound_stmts.rst:1844
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ":keyword:`type` 语句也可被用来创建泛型类型别名::"

#: ../../reference/compound_stmts.rst:1846
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr "type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1848
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr "除了会对值执行 :ref:`惰性求值 <lazy-evaluation>` 以外，这等同于::"

#: ../../reference/compound_stmts.rst:1851
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # 在现实中，该值将被惰性地求值\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"

#: ../../reference/compound_stmts.rst:1860
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""
"这里，``annotation-def`` (不是一个真正的关键字) 指明 :ref:`标注作用域 <annotation-scopes>`。 像 "
"``TYPE_PARAMS_OF_ListOrSet`` 这样的大写名称不会在运行时实际被绑定。"

#: ../../reference/compound_stmts.rst:1867
msgid "Annotations"
msgstr ""

#: ../../reference/compound_stmts.rst:1869
msgid "Annotations are now lazily evaluated by default."
msgstr ""

#: ../../reference/compound_stmts.rst:1872
msgid ""
"Variables and function parameters may carry :term:`annotations "
"<annotation>`, created by adding a colon after the name, followed by an "
"expression::"
msgstr ""

#: ../../reference/compound_stmts.rst:1875
msgid ""
"x: annotation = 1\n"
"def f(param: annotation): ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1878
msgid "Functions may also carry a return annotation following an arrow::"
msgstr ""

#: ../../reference/compound_stmts.rst:1880
msgid "def f() -> annotation: ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1882
msgid ""
"Annotations are conventionally used for :term:`type hints <type hint>`, but "
"this is not enforced by the language, and in general annotations may contain"
" arbitrary expressions. The presence of annotations does not change the "
"runtime semantics of the code, except if some mechanism is used that "
"introspects and uses the annotations (such as :mod:`dataclasses` or "
":func:`functools.singledispatch`)."
msgstr ""

#: ../../reference/compound_stmts.rst:1888
msgid ""
"By default, annotations are lazily evaluated in a :ref:`annotation scope "
"<annotation-scopes>`. This means that they are not evaluated when the code "
"containing the annotation is evaluated. Instead, the interpreter saves "
"information that can be used to evaluate the annotation later if requested. "
"The :mod:`annotationlib` module provides tools for evaluating annotations."
msgstr ""

#: ../../reference/compound_stmts.rst:1893
msgid ""
"If the :ref:`future statement <future>` ``from __future__ import "
"annotations`` is present, all annotations are instead stored as strings::"
msgstr ""

#: ../../reference/compound_stmts.rst:1896
msgid ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"
msgstr ""

#: ../../reference/compound_stmts.rst:1903
msgid "Footnotes"
msgstr "备注"

#: ../../reference/compound_stmts.rst:1904
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That new"
" exception causes the old one to be lost."
msgstr "异常会被传播给唤起栈，除非存在一个 :keyword:`finally` 子句正好引发了另一个异常。 新引发的异常将导致旧异常的丢失。"

#: ../../reference/compound_stmts.rst:1908
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr "在模式匹配中，序列被定义为以下几种之一:"

#: ../../reference/compound_stmts.rst:1910
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "继承自 :class:`collections.abc.Sequence` 的类"

#: ../../reference/compound_stmts.rst:1911
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr "注册为 :class:`collections.abc.Sequence` 的 Python 类"

#: ../../reference/compound_stmts.rst:1912
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit "
"set"
msgstr "设置了 (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` 比特位的内置类"

#: ../../reference/compound_stmts.rst:1913
#: ../../reference/compound_stmts.rst:1932
msgid "a class that inherits from any of the above"
msgstr "继承自上述任何一个类的类"

#: ../../reference/compound_stmts.rst:1915
msgid "The following standard library classes are sequences:"
msgstr "下列标准库中的类都是序列:"

#: ../../reference/compound_stmts.rst:1917
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1918
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1920
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1921
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../../reference/compound_stmts.rst:1924
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr "类型为 ``str``, ``bytes`` 和 ``bytearray`` 的目标值不能匹配序列模式。"

#: ../../reference/compound_stmts.rst:1927
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr "在模式匹配中，映射被定义为以下几种之一:"

#: ../../reference/compound_stmts.rst:1929
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "继承自 :class:`collections.abc.Mapping` 的类"

#: ../../reference/compound_stmts.rst:1930
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr "注册为 :class:`collections.abc.Mapping` 的 Python 类"

#: ../../reference/compound_stmts.rst:1931
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr "设置了 (CPython) :c:macro:`Py_TPFLAGS_MAPPING` 比特位的内置类"

#: ../../reference/compound_stmts.rst:1934
msgid ""
"The standard library classes :class:`dict` and "
":class:`types.MappingProxyType` are mappings."
msgstr "标准库中的 :class:`dict` 和 :class:`types.MappingProxyType` 类都属于映射。"

#: ../../reference/compound_stmts.rst:1937
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"作为函数体的第一条语句出现的字符串字面值会被转换为函数的 :attr:`~function.__doc__` 属性也就是该函数的 "
":term:`docstring`。"

#: ../../reference/compound_stmts.rst:1941
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"作为类体的第一条语句出现的字符串字面值会被转为命名空间的 :attr:`~type.__doc__` 条目，也就是该类的 "
":term:`docstring`。"

#: ../../reference/compound_stmts.rst:7
msgid "compound"
msgstr "compound"

#: ../../reference/compound_stmts.rst:7 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:440
#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:595
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
#: ../../reference/compound_stmts.rst:1500
#: ../../reference/compound_stmts.rst:1534
#: ../../reference/compound_stmts.rst:1579
msgid "statement"
msgstr "statement -- 语句"

#: ../../reference/compound_stmts.rst:21
msgid "clause"
msgstr "clause"

#: ../../reference/compound_stmts.rst:21
msgid "suite"
msgstr "suite"

#: ../../reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr "; (分号)"

#: ../../reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr "NEWLINE 形符"

#: ../../reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr "DEDENT 形符"

#: ../../reference/compound_stmts.rst:64
msgid "dangling"
msgstr "dangling"

#: ../../reference/compound_stmts.rst:64 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
msgid "else"
msgstr "else"

#: ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:595
msgid "if"
msgstr "if"

#: ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:330
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:411
#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:595
#: ../../reference/compound_stmts.rst:1510
msgid "keyword"
msgstr "关键字"

#: ../../reference/compound_stmts.rst:86
msgid "elif"
msgstr "elif"

#: ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:595
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1332
#: ../../reference/compound_stmts.rst:1390
msgid ": (colon)"
msgstr ": (冒号)"

#: ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:595
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "compound statement"
msgstr "复合语句"

#: ../../reference/compound_stmts.rst:111
msgid "while"
msgstr "while"

#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
msgid "loop"
msgstr "循环"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:440
msgid "break"
msgstr "break"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:440
msgid "continue"
msgstr "continue"

#: ../../reference/compound_stmts.rst:144
msgid "for"
msgstr "for"

#: ../../reference/compound_stmts.rst:144
msgid "in"
msgstr "in"

#: ../../reference/compound_stmts.rst:144
msgid "target"
msgstr "target"

#: ../../reference/compound_stmts.rst:144
msgid "list"
msgstr "list"

#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:301
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "object"
msgstr "object -- 对象"

#: ../../reference/compound_stmts.rst:144
msgid "sequence"
msgstr "sequence"

#: ../../reference/compound_stmts.rst:190
msgid "built-in function"
msgstr "内置函数"

#: ../../reference/compound_stmts.rst:190
msgid "range"
msgstr "range"

#: ../../reference/compound_stmts.rst:207
msgid "try"
msgstr "try"

#: ../../reference/compound_stmts.rst:207
msgid "except"
msgstr "except"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:411
msgid "finally"
msgstr "finally"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:268
#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:595
msgid "as"
msgstr "as"

#: ../../reference/compound_stmts.rst:268
msgid "except clause"
msgstr "except 子句"

#: ../../reference/compound_stmts.rst:301
msgid "module"
msgstr "module"

#: ../../reference/compound_stmts.rst:301
msgid "sys"
msgstr "sys"

#: ../../reference/compound_stmts.rst:301
msgid "traceback"
msgstr "traceback -- 回溯"

#: ../../reference/compound_stmts.rst:330
msgid "except_star"
msgstr "except_star"

#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:440
msgid "return"
msgstr "return"

#: ../../reference/compound_stmts.rst:478
msgid "with"
msgstr "with"

#: ../../reference/compound_stmts.rst:478
msgid "with statement"
msgstr "with 语句"

#: ../../reference/compound_stmts.rst:478
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid ", (comma)"
msgstr ", (逗号)"

#: ../../reference/compound_stmts.rst:595
msgid "match"
msgstr "match"

#: ../../reference/compound_stmts.rst:595
msgid "case"
msgstr "case"

#: ../../reference/compound_stmts.rst:595
msgid "pattern matching"
msgstr "模式匹配"

#: ../../reference/compound_stmts.rst:595
msgid "match statement"
msgstr "match 语句"

#: ../../reference/compound_stmts.rst:699
msgid "guard"
msgstr "约束项"

#: ../../reference/compound_stmts.rst:738
msgid "irrefutable case block"
msgstr "必须匹配的 case 块"

#: ../../reference/compound_stmts.rst:738
msgid "case block"
msgstr "case 块"

#: ../../reference/compound_stmts.rst:762
msgid "! patterns"
msgstr "! 模式"

#: ../../reference/compound_stmts.rst:762
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "AS 模式, OR 模式, 捕获模式, 通配符模式"

#: ../../reference/compound_stmts.rst:1193
#: ../../reference/compound_stmts.rst:1282
msgid "parameter"
msgstr "parameter -- 形参"

#: ../../reference/compound_stmts.rst:1193
#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1246
#: ../../reference/compound_stmts.rst:1282
#: ../../reference/compound_stmts.rst:1311
msgid "function definition"
msgstr "函数定义"

#: ../../reference/compound_stmts.rst:1202
msgid "def"
msgstr "def"

#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1332
msgid "function"
msgstr "function -- 函数"

#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "definition"
msgstr "定义"

#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "name"
msgstr "name"

#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "binding"
msgstr "绑定"

#: ../../reference/compound_stmts.rst:1202
msgid "user-defined function"
msgstr "用户自定义函数"

#: ../../reference/compound_stmts.rst:1202
#: ../../reference/compound_stmts.rst:1390
msgid "() (parentheses)"
msgstr "() (圆括号)"

#: ../../reference/compound_stmts.rst:1202
msgid "parameter list"
msgstr "形参列表"

#: ../../reference/compound_stmts.rst:1246
#: ../../reference/compound_stmts.rst:1440
msgid "@ (at)"
msgstr "@ (at)"

#: ../../reference/compound_stmts.rst:1282
msgid "default"
msgstr "默认值"

#: ../../reference/compound_stmts.rst:1282
msgid "value"
msgstr "value"

#: ../../reference/compound_stmts.rst:1282
msgid "argument"
msgstr "argument -- 参数"

#: ../../reference/compound_stmts.rst:1282
msgid "= (equals)"
msgstr "= (等于号)"

#: ../../reference/compound_stmts.rst:1311
msgid "/ (slash)"
msgstr "/ (斜杠)"

#: ../../reference/compound_stmts.rst:1311
msgid "* (asterisk)"
msgstr "* (星号)"

#: ../../reference/compound_stmts.rst:1311
msgid "**"
msgstr "**"

#: ../../reference/compound_stmts.rst:1332
msgid "annotations"
msgstr "annotations"

#: ../../reference/compound_stmts.rst:1332
msgid "->"
msgstr "->"

#: ../../reference/compound_stmts.rst:1332
msgid "function annotations"
msgstr "函数标注"

#: ../../reference/compound_stmts.rst:1349
msgid "lambda"
msgstr "lambda"

#: ../../reference/compound_stmts.rst:1349
msgid "expression"
msgstr "expression -- 表达式"

#: ../../reference/compound_stmts.rst:1390
msgid "class"
msgstr "class"

#: ../../reference/compound_stmts.rst:1390
msgid "execution"
msgstr "执行"

#: ../../reference/compound_stmts.rst:1390
msgid "frame"
msgstr "frame -- 帧"

#: ../../reference/compound_stmts.rst:1390
msgid "inheritance"
msgstr "继承"

#: ../../reference/compound_stmts.rst:1390
msgid "docstring"
msgstr "docstring -- 文档字符串"

#: ../../reference/compound_stmts.rst:1390
#: ../../reference/compound_stmts.rst:1440
msgid "class definition"
msgstr "类定义"

#: ../../reference/compound_stmts.rst:1390
msgid "expression list"
msgstr "表达式列表"

#: ../../reference/compound_stmts.rst:1500
msgid "async def"
msgstr "async def"

#: ../../reference/compound_stmts.rst:1510
msgid "async"
msgstr "async"

#: ../../reference/compound_stmts.rst:1510
msgid "await"
msgstr "await"

#: ../../reference/compound_stmts.rst:1534
msgid "async for"
msgstr "async for"

#: ../../reference/compound_stmts.rst:1579
msgid "async with"
msgstr "async with"

#: ../../reference/compound_stmts.rst:1636
msgid "type parameters"
msgstr "类型形参"
