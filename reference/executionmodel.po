# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "执行模型"

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "程序的结构"

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks:"
" a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a "
":option:`-m` argument is also a code block. The string argument passed to "
"the built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Python 程序是由代码块构成的。 :dfn:`代码块` 是被作为一个单元来执行的一段 Python 程序文本。 "
"以下几个都属于代码块：模块、函数体和类定义。 交互式输入的每条命令都是代码块。 "
"一个脚本文件（作为标准输入发送给解释器或是作为命令行参数发送给解释器的文件）也是代码块。 一条脚本命令（通过 :option:`-c` "
"选项在解释器命令行中指定的命令）也是代码块。 通过在命令行中使用 :option:`-m` 参数作为最高层级脚本（即 ``__main__`` "
"模块）运行的模块也是代码块。 传递给内置函数 :func:`eval` 和 :func:`exec` 的字符串参数也是代码块。"

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr "代码块在 :dfn:`执行帧` 中被执行。 一个帧会包含某些管理信息（用于调试）并决定代码块执行完成后应前往何处以及如何继续执行。"

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "命名与绑定"

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "名称的绑定"

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ":dfn:`名称` 用于指代对象。 名称是通过名称绑定操作来引入的。"

#: ../../reference/executionmodel.rst:59
msgid ""
"The following constructs bind names: formal parameters to functions, "
":keyword:`import` statements, class and function definitions (these bind the"
" class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or "
"after :keyword:`!as` in a :keyword:`with` statement or :keyword:`except` "
"clause. The :keyword:`!import` statement of the form ``from ... import *`` "
"binds all names defined in the imported module, except those beginning with "
"an underscore.  This form may only be used at the module level."
msgstr ""
"以下构造会绑定名称：传给函数的正式形参，:keyword:`import` "
"语句，类与函数定义（这会在定义的代码块中绑定类或函数名称）以及发生以标识符为目标的赋值，:keyword:`for` 循环的开头，或 "
":keyword:`with` 语句和 :keyword:`except` 子句的 :keyword:`!as` 之后。 "
":keyword:`!import` 语句的 ``from ... import *`` "
"形式会绑定在被导入模块中定义的所有名称，那些以下划线开头的除外。 这种形式仅在模块层级上被使用。"

#: ../../reference/executionmodel.rst:69
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ":keyword:`del` 语句的目标也被视作一种绑定（虽然其实际语义为解除名称绑定）。"

#: ../../reference/executionmodel.rst:72
msgid ""
"Each assignment or import statement occurs within a block defined by a class"
" or function definition or at the module level (the top-level code block)."
msgstr "每条赋值或导入语句均发生于类或函数内部定义的代码块中，或是发生于模块层级（即最高层级的代码块）。"

#: ../../reference/executionmodel.rst:77
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at"
" the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but"
" not defined there, it is a :dfn:`free variable`."
msgstr ""
"如果名称绑定在一个代码块中，则为该代码块的局部变量，除非声明为 :keyword:`nonlocal` 或 :keyword:`global`。 "
"如果名称绑定在模块层级，则为全局变量。 (模块代码块的变量既为局部变量又为全局变量。) 如果变量在一个代码块中被使用但不是在其中定义，则为 "
":dfn:`自由变量`。"

#: ../../reference/executionmodel.rst:83
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr "每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 :dfn:`绑定`。"

#: ../../reference/executionmodel.rst:89
msgid "Resolution of names"
msgstr "名称的解析"

#: ../../reference/executionmodel.rst:93
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`作用域` 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该代码块。 "
"如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。"

#: ../../reference/executionmodel.rst:101
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr "当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种作用域的集合称为该代码块的 :dfn:`环境`。"

#: ../../reference/executionmodel.rst:109
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. "
":exc:`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"当一个名称完全找不到时，将会引发 :exc:`NameError` 异常。 "
"如果当前作用域为函数作用域，且该名称指向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发 "
":exc:`UnboundLocalError` 异常。 :exc:`UnboundLocalError` 为 :exc:`NameError` "
"的一个子类。"

#: ../../reference/executionmodel.rst:115
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of"
" the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""
"如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用会被认为是对当前代码块的引用。 "
"当一个名称在其被绑定前就在代码块内被使用时则会导致错误。 这个一个很微妙的规则。 Python "
"缺少声明语法，并允许名称绑定操作发生于代码块内的任何位置。 一个代码块的局部变量可通过在整个代码块文本中扫描名称绑定操作来确定。"

#: ../../reference/executionmodel.rst:122
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"name specified in the statement refer to the binding of that name in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module "
":mod:`builtins`.  The global namespace is searched first.  If the name is "
"not found there, the builtins namespace is searched.  The :keyword:`!global`"
" statement must precede all uses of the name."
msgstr ""
"如果 :keyword:`global` 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空间内对该名称绑定的引用。 "
"名称在最高层级命名内的解析是通过全局命名空间，也就是包含该代码块的模块的命名空间，以及内置命名空间即 :mod:`builtins` 模块的命名空间。 "
"全局命名空间会先被搜索。 如果未在其中找到指定名称，再搜索内置命名空间。  :keyword:`!global` "
"语句必须位于所有对其所指定名称的使用之前。"

#: ../../reference/executionmodel.rst:131
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
":keyword:`global` 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中有一条 global "
"语句，则该自由变量也会被当作是全局变量。"

#: ../../reference/executionmodel.rst:137
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. "
":exc:`SyntaxError` is raised at compile time if the given name does not "
"exist in any enclosing function scope."
msgstr ""
":keyword:`nonlocal` 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 "
"如果指定名称不存在于任何包含函数作用域中则将在编译时引发 :exc:`SyntaxError`。"

#: ../../reference/executionmodel.rst:144
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr "模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 :mod:`__main__`。"

#: ../../reference/executionmodel.rst:147
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names"
" defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""
"类定义代码块以及传给 :func:`exec` 和 :func:`eval` 的参数是名称解析上下文中的特殊情况。 "
"类定义是可能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部变量将会在全局命名空间中查找。 "
"类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中 -- "
"这也包括推导式和生成器表达式，因为它们都是使用函数作用域实现的。 这意味着以下代码将会失败::"

#: ../../reference/executionmodel.rst:165
msgid "Builtins and restricted execution"
msgstr "内置命名空间和受限的执行"

#: ../../reference/executionmodel.rst:171
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should "
":keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"用户不应该接触 ``__builtins__``，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值则应该 :keyword:`import` "
":mod:`builtins` 并相应地修改该模块中的属性。"

#: ../../reference/executionmodel.rst:176
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any"
" other module, ``__builtins__`` is an alias for the dictionary of the "
":mod:`builtins` module itself."
msgstr ""
"与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称 ``__builtins__`` "
"来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。 默认情况下，当在 :mod:`__main__` "
"模块中时，``__builtins__`` 就是内置模块 :mod:`builtins`；当在任何其他模块中时，``__builtins__`` 则是 "
":mod:`builtins` 模块自身的字典的一个别名。"

#: ../../reference/executionmodel.rst:188
msgid "Interaction with dynamic features"
msgstr "与动态特性的交互"

#: ../../reference/executionmodel.rst:190
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr "自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42::"

#: ../../reference/executionmodel.rst:201
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The "
":func:`exec` and :func:`eval` functions have optional arguments to override "
"the global and local namespace.  If only one namespace is specified, it is "
"used for both."
msgstr ""
":func:`eval` 和 :func:`exec` 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命名空间中被解析。 "
"自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 [#]_ :func:`exec` 和 :func:`eval` "
"函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它会同时作用于两者。"

#: ../../reference/executionmodel.rst:212
msgid "Exceptions"
msgstr "异常"

#: ../../reference/executionmodel.rst:223
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测到的位置 "
"*引发*，它可以被当前包围代码块或是任何直接或间接发起调用发生错误的代码块的其他代码块所 *处理*。"

#: ../../reference/executionmodel.rst:229
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The "
":keyword:`finally` clause of such a statement can be used to specify cleanup"
" code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Python 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以通过 :keyword:`raise` "
"语句显式地引发异常。 异常处理是通过 :keyword:`try` ... :keyword:`except` 语句来指定的。 该语句的 "
":keyword:`finally` 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被执行。"

#: ../../reference/executionmodel.rst:239
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level,"
" but it cannot repair the cause of the error and retry the failing operation"
" (except by re-entering the offending piece of code from the top)."
msgstr ""
"Python "
"的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。"

#: ../../reference/executionmodel.rst:246
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is "
":exc:`SystemExit`."
msgstr ""
"当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种情况，它都会打印栈回溯信息，除非是当异常为 "
":exc:`SystemExit` 的时候。"

#: ../../reference/executionmodel.rst:250
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a base class thereof.  The instance can be received"
" by the handler and can carry additional information about the exceptional "
"condition."
msgstr ""
"异常是通过类实例来标识的。 :keyword:`except` 子句会依据实例的类来选择：它必须引用实例的类或是其所属的基类。 "
"实例可通过处理器被接收，并可携带有关异常条件的附加信息。"

#: ../../reference/executionmodel.rst:257
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not"
" be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"异常消息不是 Python API 的组成部分。 其内容可能在 Python "
"升级到新版本时不经警告地发生改变，不应该被需要在多版本解释器中运行的代码所依赖。"

#: ../../reference/executionmodel.rst:261
msgid ""
"See also the description of the :keyword:`try` statement in section "
":ref:`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"另请参看  :ref:`try` 小节中对 :keyword:`try` 语句的描述以及 :ref:`raise` 小节中对 "
":keyword:`raise` 语句的描述。"

#: ../../reference/executionmodel.rst:266
msgid "Footnotes"
msgstr "备注"

#: ../../reference/executionmodel.rst:267
msgid ""
"This limitation occurs because the code that is executed by these operations"
" is not available at the time the module is compiled."
msgstr "出现这样的限制是由于通过这些操作执行的代码在模块被编译的时候并不可用。"
