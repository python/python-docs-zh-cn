# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "执行模型"

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "程序的结构"

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks:"
" a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a "
":option:`-m` argument is also a code block. The string argument passed to "
"the built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Python 程序是由代码块构成的。 :dfn:`代码块` 是被作为一个单元来执行的一段 Python 程序文本。 "
"以下几个都属于代码块：模块、函数体和类定义。 交互式输入的每条命令都是代码块。 "
"一个脚本文件（作为标准输入发送给解释器或是作为命令行参数发送给解释器的文件）也是代码块。 一条脚本命令（通过 :option:`-c` "
"选项在解释器命令行中指定的命令）也是代码块。 通过在命令行中使用 :option:`-m` 参数作为最高层级脚本（即 ``__main__`` "
"模块）运行的模块也是代码块。 传递给内置函数 :func:`eval` 和 :func:`exec` 的字符串参数也是代码块。"

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr "代码块在 :dfn:`执行帧` 中被执行。 一个帧会包含某些管理信息（用于调试）并决定代码块执行完成后应前往何处以及如何继续执行。"

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "命名与绑定"

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "名称的绑定"

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ":dfn:`名称` 用于指代对象。 名称是通过名称绑定操作来引入的。"

#: ../../reference/executionmodel.rst:59
msgid "The following constructs bind names:"
msgstr "下面的结构将名字绑定:"

#: ../../reference/executionmodel.rst:61
msgid "formal parameters to functions,"
msgstr "函数的正式参数，"

#: ../../reference/executionmodel.rst:62
msgid "class definitions,"
msgstr "类定义，"

#: ../../reference/executionmodel.rst:63
msgid "function definitions,"
msgstr "函数定义，"

#: ../../reference/executionmodel.rst:64
msgid "assignment expressions,"
msgstr "赋值表达式,"

#: ../../reference/executionmodel.rst:65
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr "如果在一个赋值中出现，则为标识符的 :ref:`目标 <assignment>`  :"

#: ../../reference/executionmodel.rst:68
msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` 循环头,"

#: ../../reference/executionmodel.rst:69
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"在 :keyword:`with` 语句, :keyword:`except` 子句, :keyword:`except* <except_star>`"
" 子句，或格式化模式匹配的 as 模式的 :keyword:`!as` 之后，"

#: ../../reference/executionmodel.rst:71
msgid "in a capture pattern in structural pattern matching"
msgstr "在结构模式匹配中的捕获模式"

#: ../../reference/executionmodel.rst:73
msgid ":keyword:`import` statements."
msgstr ":keyword:`import` 语句。"

#: ../../reference/executionmodel.rst:74
msgid ":keyword:`type` statements."
msgstr ":keyword:`type` 语句。"

#: ../../reference/executionmodel.rst:75
msgid ":ref:`type parameter lists <type-params>`."
msgstr ":ref:`类型形参列表 <type-params>`。"

#: ../../reference/executionmodel.rst:77
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all"
" names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"形式为 ``from ... import *`` 的 :keyword:`!import` "
"语句绑定所有在导入的模块中定义的名字，除了那些以下划线开头的名字。这种形式只能在模块级别上使用。"

#: ../../reference/executionmodel.rst:81
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ":keyword:`del` 语句的目标也被视作一种绑定（虽然其实际语义为解除名称绑定）。"

#: ../../reference/executionmodel.rst:84
msgid ""
"Each assignment or import statement occurs within a block defined by a class"
" or function definition or at the module level (the top-level code block)."
msgstr "每条赋值或导入语句均发生于类或函数内部定义的代码块中，或是发生于模块层级（即最高层级的代码块）。"

#: ../../reference/executionmodel.rst:89
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at"
" the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but"
" not defined there, it is a :term:`free variable`."
msgstr ""
"如果某个名称绑定在一个代码块中，则它就是该代码块的局部变量，除非声明为 :keyword:`nonlocal` 或 :keyword:`global`。"
" 如果某个名称绑定在模块层级，则它就是全局变量。 （模块代码块的变量既是局部变量又是全局变量。） "
"如果某个变量在一个代码块中被使用但不是在其中定义的，则它是 :term:`free variable`。"

#: ../../reference/executionmodel.rst:95
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr "每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 :dfn:`绑定`。"

#: ../../reference/executionmodel.rst:101
msgid "Resolution of names"
msgstr "名称的解析"

#: ../../reference/executionmodel.rst:105
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`作用域` 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该代码块。 "
"如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。"

#: ../../reference/executionmodel.rst:113
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr "当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种作用域的集合称为该代码块的 :dfn:`环境`。"

#: ../../reference/executionmodel.rst:121
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. "
":exc:`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"当一个名称完全找不到时，将会引发 :exc:`NameError` 异常。 "
"如果当前作用域为函数作用域，且该名称指向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发 "
":exc:`UnboundLocalError` 异常。 :exc:`UnboundLocalError` 为 :exc:`NameError` "
"的一个子类。"

#: ../../reference/executionmodel.rst:127
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of"
" the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用都会被视为对当前代码块的引用。 "
"当一个名称在其被绑定前就在代码块内被使用时将会导致错误。 这个规则是很微妙的。 Python 缺少声明语法并且允许名称绑定操作发生于代码块内的任何位置。"
" 一个代码块的局部变量可通过在整个代码块文本中扫描名称绑定操作来确定。 请参阅 :ref:`UnboundLocalError 的 FAQ 条目 "
"<faq-unboundlocalerror>` 来获取示例。"

#: ../../reference/executionmodel.rst:136
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the"
" top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module "
":mod:`builtins`.  The global namespace is searched first.  If the names are "
"not found there, the builtins namespace is searched next. If the names are "
"also not found in the builtins namespace, new variables are created in the "
"global namespace. The global statement must precede all uses of the listed "
"names."
msgstr ""
"如果 :keyword:`global` 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空间内对该名称绑定的引用。 "
"名称在最高层级命名空间内的解析是通过搜索全局命名空间，也就是包含该代码块的模块的命名空间，以及内置命名空间即 :mod:`builtins` "
"模块的命名空间。 全局命名空间会先被搜索。 如果未在其中找到相应名称，将再搜索内置命名空间。 "
"如果未在内置命名空间中找到相应名称，将在全局命名空间中创建新变量。 global 语句必须位于所有对其所列名称的使用之前。"

#: ../../reference/executionmodel.rst:146
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
":keyword:`global` 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中有一条 global "
"语句，则该自由变量也会被当作是全局变量。"

#: ../../reference/executionmodel.rst:152
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. "
":exc:`SyntaxError` is raised at compile time if the given name does not "
"exist in any enclosing function scope. :ref:`Type parameters <type-params>` "
"cannot be rebound with the :keyword:`!nonlocal` statement."
msgstr ""
":keyword:`nonlocal` 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 "
"如果指定的名称不存在于任何包含函数作用域中则将在编译时引发 :exc:`SyntaxError`。 :ref:`类型形参 <type-params>` "
"不能使用 :keyword:`!nonlocal` 语句来重新绑定。"

#: ../../reference/executionmodel.rst:160
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr "模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 :mod:`__main__`。"

#: ../../reference/executionmodel.rst:163
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names"
" defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods. This includes comprehensions and generator "
"expressions, but it does not include :ref:`annotation scopes <annotation-"
"scopes>`, which have access to their enclosing class scopes. This means that"
" the following will fail::"
msgstr ""
"类定义代码块以及传给 :func:`exec` 和 :func:`eval` 的参数是名称解析的上下文中的特殊情况。 "
"类定义是可能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部变量会在全局命名空间中查找。 "
"类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中。 "
"这包括推导式和生成器表达式，但不包括 :ref:`标注作用域 <annotation-scopes>`，因为它可以访问所包含的类作用域。 "
"这意味着以下代码将会失败::"

#: ../../reference/executionmodel.rst:176
msgid ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"
msgstr ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"

#: ../../reference/executionmodel.rst:180
msgid "However, the following will succeed::"
msgstr "但是，下面的代码将会成功::"

#: ../../reference/executionmodel.rst:182
msgid ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"
msgstr ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"

#: ../../reference/executionmodel.rst:191
msgid "Annotation scopes"
msgstr "标注作用域"

#: ../../reference/executionmodel.rst:193
msgid ""
":ref:`Type parameter lists <type-params>` and :keyword:`type` statements "
"introduce *annotation scopes*, which behave mostly like function scopes, but"
" with some exceptions discussed below. :term:`Annotations <annotation>` "
"currently do not use annotation scopes, but they are expected to use "
"annotation scopes in Python 3.13 when :pep:`649` is implemented."
msgstr ""
":ref:`类型形参列表 <type-params>` 和 :keyword:`type` 语句引入了 "
"*标注作用域*，其行为很像函数作用域，但具有下述的几处例外。 :term:`标注 <annotation>` "
"目前没有使用标注作用域，但它们预期会在实现了 :pep:`649` 的 Python 3.13 中使用标注作用域。"

#: ../../reference/executionmodel.rst:199
msgid "Annotation scopes are used in the following contexts:"
msgstr "标注作用域将在下列情况中使用:"

#: ../../reference/executionmodel.rst:201
msgid ""
"Type parameter lists for :ref:`generic type aliases <generic-type-aliases>`."
msgstr "针对 :ref:`泛型类型别名 <generic-type-aliases>` 的类型形参列表。"

#: ../../reference/executionmodel.rst:202
msgid ""
"Type parameter lists for :ref:`generic functions <generic-functions>`. A "
"generic function's annotations are executed within the annotation scope, but"
" its defaults and decorators are not."
msgstr ""
"针对 :ref:`泛型函数 <generic-functions>` 的类型形参列表。 泛型函数的标注会在标注作用域内执行，但其默认值和装饰器则不会。"

#: ../../reference/executionmodel.rst:205
msgid ""
"Type parameter lists for :ref:`generic classes <generic-classes>`. A generic"
" class's base classes and keyword arguments are executed within the "
"annotation scope, but its decorators are not."
msgstr ""
"针对 :ref:`泛型类 <generic-classes>` 的类型形参列表。 泛型类的基类和关键字参数会在标注作用域内执行，但其装饰器则不会。"

#: ../../reference/executionmodel.rst:208
msgid ""
"The bounds, constraints, and default values for type parameters "
"(:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr "针对类型形参的绑定、约束和默认值 (:ref:`惰性求值 <lazy-evaluation>`)。"

#: ../../reference/executionmodel.rst:210
msgid "The value of type aliases (:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr "类型别名的值 (:ref:`惰性求值 <lazy-evaluation>`)。"

#: ../../reference/executionmodel.rst:212
msgid "Annotation scopes differ from function scopes in the following ways:"
msgstr "标注作用域在以下几个方面不同于函数作用域:"

#: ../../reference/executionmodel.rst:214
msgid ""
"Annotation scopes have access to their enclosing class namespace. If an "
"annotation scope is immediately within a class scope, or within another "
"annotation scope that is immediately within a class scope, the code in the "
"annotation scope can use names defined in the class scope as if it were "
"executed directly within the class body. This contrasts with regular "
"functions defined within classes, which cannot access names defined in the "
"class scope."
msgstr ""
"标注作用域能够访问其所包含的类命名空间。 "
"如果某个标注作用域紧接在一个类作用域之内，或是位于紧接一个类作用域的另一个标注作用域之内，则该标注作用域中的代码将能使用在该类作用域中定义的名称，就像它是在该类内部直接执行一样。"
" 这不同于在类中定义的常规函数，后者无法访问在类作用域中定义的名称。"

#: ../../reference/executionmodel.rst:220
msgid ""
"Expressions in annotation scopes cannot contain :keyword:`yield`, ``yield "
"from``, :keyword:`await`, or :token:`:= <python-"
"grammar:assignment_expression>` expressions. (These expressions are allowed "
"in other scopes contained within the annotation scope.)"
msgstr ""
"标注作用域中的表达式不能包含 :keyword:`yield`, ``yield from``, :keyword:`await` 或 "
":token:`:= <python-grammar:assignment_expression>` 表达式。 "
"（这些表达式在包含于标注作用域之内的其他作用域中则是允许的。）"

#: ../../reference/executionmodel.rst:224
msgid ""
"Names defined in annotation scopes cannot be rebound with "
":keyword:`nonlocal` statements in inner scopes. This includes only type "
"parameters, as no other syntactic elements that can appear within annotation"
" scopes can introduce new names."
msgstr ""
"在标注作用域中定义的名称不能在内部作用域中通过 :keyword:`nonlocal` 语句来重新绑定。 "
"这只包括类型形参，因为没有其他可以在标注作用域内部出现的语法元素能够引入新的名称。"

#: ../../reference/executionmodel.rst:227
msgid ""
"While annotation scopes have an internal name, that name is not reflected in"
" the :term:`qualified name` of objects defined within the scope. Instead, "
"the :attr:`~definition.__qualname__` of such objects is as if the object "
"were defined in the enclosing scope."
msgstr ""
"虽然标注作用域具有一个内部名称，但该名称不会反映在作用域内定义的对象的 :term:`qualified name` 中。 相反，这些对象的 "
":attr:`~definition.__qualname__` 就像它们是定义在包含作用域中的对象一样。"

#: ../../reference/executionmodel.rst:232
msgid ""
"Annotation scopes were introduced in Python 3.12 as part of :pep:`695`."
msgstr "标注作用域是在 Python 3.12 中作为 :pep:`695` 的一部分引入的。"

#: ../../reference/executionmodel.rst:235
msgid ""
"Annotation scopes are also used for type parameter defaults, as introduced "
"by :pep:`696`."
msgstr "标注作用域也被用于类型形参默认值，这是由 :pep:`696` 引入的。"

#: ../../reference/executionmodel.rst:242
msgid "Lazy evaluation"
msgstr "惰性求值"

#: ../../reference/executionmodel.rst:244
msgid ""
"The values of type aliases created through the :keyword:`type` statement are"
" *lazily evaluated*. The same applies to the bounds, constraints, and "
"default values of type variables created through the :ref:`type parameter "
"syntax <type-params>`. This means that they are not evaluated when the type "
"alias or type variable is created. Instead, they are only evaluated when "
"doing so is necessary to resolve an attribute access."
msgstr ""
"通过 :keyword:`type` 语句创建的类型别名的值将被 *惰性求值*。 此特性也适用于通过 :ref:`类型形参语法 <type-"
"params>` 创建的类型变量的绑定、约束和默认值。 这意味着它们在创建类型别名或类型变量时不会被求值。 "
"相反，它们只有在需要处理属性访问时才会被求值。"

#: ../../reference/executionmodel.rst:251
msgid "Example:"
msgstr "示例:"

#: ../../reference/executionmodel.rst:253
msgid ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"
msgstr ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"

#: ../../reference/executionmodel.rst:267
msgid ""
"Here the exception is raised only when the ``__value__`` attribute of the "
"type alias or the ``__bound__`` attribute of the type variable is accessed."
msgstr "此处的异常只有在类型别名的 ``__value__`` 属性或类型变量的 ``__bound__`` 属性被访问时才会被引发。"

#: ../../reference/executionmodel.rst:271
msgid ""
"This behavior is primarily useful for references to types that have not yet "
"been defined when the type alias or type variable is created. For example, "
"lazy evaluation enables creation of mutually recursive type aliases::"
msgstr "此行为主要适用于当创建类型别名或类型变量时对尚未被定义的类型进行引用。 例如，惰性求值将允许创建相互递归的类型别名::"

#: ../../reference/executionmodel.rst:275
msgid ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"
msgstr ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"

#: ../../reference/executionmodel.rst:281
msgid ""
"Lazily evaluated values are evaluated in :ref:`annotation scope <annotation-"
"scopes>`, which means that names that appear inside the lazily evaluated "
"value are looked up as if they were used in the immediately enclosing scope."
msgstr ""
"被惰性求值的值是在 :ref:`标记作用域 <annotation-scopes>` "
"内进行求值的，这意味着出现在被惰性求值的值内部的名称的查找范围就相当于它们是在紧邻的作用域中被使用。"

#: ../../reference/executionmodel.rst:290
msgid "Builtins and restricted execution"
msgstr "内置命名空间和受限的执行"

#: ../../reference/executionmodel.rst:296
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should "
":keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"用户不应该接触 ``__builtins__``，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值则应该 :keyword:`import` "
":mod:`builtins` 并相应地修改该模块中的属性。"

#: ../../reference/executionmodel.rst:301
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any"
" other module, ``__builtins__`` is an alias for the dictionary of the "
":mod:`builtins` module itself."
msgstr ""
"与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称 ``__builtins__`` "
"来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。 默认情况下，当在 :mod:`__main__` "
"模块中时，``__builtins__`` 就是内置模块 :mod:`builtins`；当在任何其他模块中时，``__builtins__`` 则是 "
":mod:`builtins` 模块自身的字典的一个别名。"

#: ../../reference/executionmodel.rst:313
msgid "Interaction with dynamic features"
msgstr "与动态特性的交互"

#: ../../reference/executionmodel.rst:315
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr "自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42::"

#: ../../reference/executionmodel.rst:318
msgid ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"
msgstr ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"

#: ../../reference/executionmodel.rst:326
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The "
":func:`exec` and :func:`eval` functions have optional arguments to override "
"the global and local namespace.  If only one namespace is specified, it is "
"used for both."
msgstr ""
":func:`eval` 和 :func:`exec` 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命名空间中被解析。 "
"自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 [#]_ :func:`exec` 和 :func:`eval` "
"函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它会同时作用于两者。"

#: ../../reference/executionmodel.rst:340
msgid "Exceptions"
msgstr "异常"

#: ../../reference/executionmodel.rst:351
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测到的位置 "
"*引发*，它可以被当前包围代码块或是任何直接或间接唤起发生错误的代码块的其他代码块所 *处理*。"

#: ../../reference/executionmodel.rst:357
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The "
":keyword:`finally` clause of such a statement can be used to specify cleanup"
" code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Python 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以通过 :keyword:`raise` "
"语句显式地引发异常。 异常处理是通过 :keyword:`try` ... :keyword:`except` 语句来指定的。 该语句的 "
":keyword:`finally` 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被执行。"

#: ../../reference/executionmodel.rst:367
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level,"
" but it cannot repair the cause of the error and retry the failing operation"
" (except by re-entering the offending piece of code from the top)."
msgstr ""
"Python "
"的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。"

#: ../../reference/executionmodel.rst:374
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is "
":exc:`SystemExit`."
msgstr ""
"当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种情况，它都会打印栈回溯信息，除非是当异常为 "
":exc:`SystemExit` 的时候。"

#: ../../reference/executionmodel.rst:378
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"异常是通过类实例来标识的。 :keyword:`except` 子句会依据实例的类来选择：它必须引用实例的类或是其所属的 :term:`非虚基类 "
"<abstract base class>` 。 实例可通过处理器被接收，并可携带有关异常条件的附加信息。"

#: ../../reference/executionmodel.rst:386
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not"
" be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"异常消息不是 Python API 的组成部分。 其内容可能在 Python "
"升级到新版本时不经警告地发生改变，不应该被需要在多版本解释器中运行的代码所依赖。"

#: ../../reference/executionmodel.rst:390
msgid ""
"See also the description of the :keyword:`try` statement in section "
":ref:`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"另请参看  :ref:`try` 小节中对 :keyword:`try` 语句的描述以及 :ref:`raise` 小节中对 "
":keyword:`raise` 语句的描述。"

#: ../../reference/executionmodel.rst:395
msgid "Footnotes"
msgstr "备注"

#: ../../reference/executionmodel.rst:396
msgid ""
"This limitation occurs because the code that is executed by these operations"
" is not available at the time the module is compiled."
msgstr "出现这样的限制是由于通过这些操作执行的代码在模块被编译的时候并不可用。"

#: ../../reference/executionmodel.rst:8
msgid "execution model"
msgstr "执行模型"

#: ../../reference/executionmodel.rst:8
msgid "code"
msgstr "code -- 代码"

#: ../../reference/executionmodel.rst:8 ../../reference/executionmodel.rst:17
msgid "block"
msgstr "block"

#: ../../reference/executionmodel.rst:31
#: ../../reference/executionmodel.rst:292
msgid "execution"
msgstr "执行"

#: ../../reference/executionmodel.rst:31
msgid "frame"
msgstr "frame -- 帧"

#: ../../reference/executionmodel.rst:42
msgid "namespace"
msgstr "namespace -- 命名空间"

#: ../../reference/executionmodel.rst:42
#: ../../reference/executionmodel.rst:103
msgid "scope"
msgstr "作用域"

#: ../../reference/executionmodel.rst:51
msgid "name"
msgstr "name"

#: ../../reference/executionmodel.rst:51
msgid "binding"
msgstr "绑定"

#: ../../reference/executionmodel.rst:57
msgid "from"
msgstr "from"

#: ../../reference/executionmodel.rst:57
msgid "import statement"
msgstr "import 语句"

#: ../../reference/executionmodel.rst:87
msgid "free"
msgstr "free"

#: ../../reference/executionmodel.rst:87
msgid "variable"
msgstr "variable"

#: ../../reference/executionmodel.rst:111
msgid "environment"
msgstr "环境"

#: ../../reference/executionmodel.rst:117
msgid "NameError (built-in exception)"
msgstr "NameError (内置异常)"

#: ../../reference/executionmodel.rst:117
msgid "UnboundLocalError"
msgstr "UnboundLocalError"

#: ../../reference/executionmodel.rst:158
msgid "module"
msgstr "module"

#: ../../reference/executionmodel.rst:158
msgid "__main__"
msgstr "__main__"

#: ../../reference/executionmodel.rst:292
msgid "restricted"
msgstr "restricted"

#: ../../reference/executionmodel.rst:342
msgid "exception"
msgstr "异常"

#: ../../reference/executionmodel.rst:344
msgid "raise an exception"
msgstr "引发异常"

#: ../../reference/executionmodel.rst:344
msgid "handle an exception"
msgstr "处理异常"

#: ../../reference/executionmodel.rst:344
msgid "exception handler"
msgstr "异常处理器"

#: ../../reference/executionmodel.rst:344
msgid "errors"
msgstr "错误"

#: ../../reference/executionmodel.rst:344
msgid "error handling"
msgstr "错误处理"

#: ../../reference/executionmodel.rst:365
msgid "termination model"
msgstr "终结模型termination model"

#: ../../reference/executionmodel.rst:372
msgid "SystemExit (built-in exception)"
msgstr "SystemExit (内置异常)"
