# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:06+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "词法分析"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr "Python 程序由 *解析器* 读取，输入解析器的是 *词法分析器* 生成的 *形符* 流。本章介绍词法分析器怎样把文件拆成形符。"

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see "
":pep:`3120` for details.  If the source file cannot be decoded, a "
":exc:`SyntaxError` is raised."
msgstr ""
"Python 将读取的程序文本转为 Unicode 代码点；编码声明用于指定源文件的编码，默认为 UTF-8，详见 "
":pep:`3120`。源文件不能解码时，触发 :exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "行结构"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Python 程序可以拆分为多个 *逻辑行*。"

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "逻辑行"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"NEWLINE 形符表示结束逻辑行。语句不能超出逻辑行的边界，除非句法支持 NEWLINE （例如，复合语句中的多行子语句）。根据显式或隐式 *行拼接*"
" 规则，一个或多个 *物理行* 可组成逻辑行。"

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "物理行"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed),"
" the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character."
"  All of these forms can be used equally, regardless of platform. The end of"
" input also serves as an implicit terminator for the final physical line."
msgstr ""
"物理行是一序列字符，由行尾序列终止。源文件和字符串可使用任意标准平台行终止序列 - Unix ASCII 字符 LF （换行）、 Windows "
"ASCII 字符序列 CR LF （回车换行）、或老式 Macintosh ASCII 字符 CR "
"（回车）。不管在哪个平台，这些形式均可等价使用。输入结束也可以用作最终物理行的隐式终止符。"

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"嵌入 Python 时，传入 Python API 的源码字符串应使用 C 标准惯例换行符（``\\n``，代表 ASCII 字符 LF， 行终止符）。"

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "注释"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"注释以井号 （``#``） 开头，在物理行末尾截止。注意，井号不是字符串字面值。除非应用隐式行拼接规则，否则，注释代表逻辑行结束。句法不解析注释。"

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "编码声明"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Python 脚本第一或第二行的注释匹配正则表达式 ``coding[=:]\\s*([-\\w.]+)`` "
"时，该注释会被当作编码声明；这个表达式的第一组指定了源码文件的编码。编码声明必须独占一行，在第二行时，则第一行必须也是注释。编码表达式的形式如下："

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "这也是 GNU Emacs 认可的形式，此外，还支持如下形式："

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "这是 Bram Moolenaar 的 VIM 认可的形式。"

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  If the "
"implicit or explicit encoding of a file is UTF-8, an initial UTF-8 byte-"
"order mark (b'\\xef\\xbb\\xbf') is ignored rather than being a syntax error."
msgstr ""
"如果没有找到编码格式声明，则默认编码格式为 UTF-8。 如果文件的隐式或显式编码格式为 UTF-8，则初始的 UTF-8 "
"字节序标志（b'\\xef\\xbb\\xbf'）将被忽略而不会报告语法错误。"

#: ../../reference/lexical_analysis.rst:103
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"如果声明了编码格式，该编码格式的名称必须是 Python 可识别的 (参见 :ref:`standard-encodings`)。 "
"编码格式会被用于所有的词法分析，包括字符串字面值、注释和标识符等。"

#: ../../reference/lexical_analysis.rst:112
msgid "Explicit line joining"
msgstr "显式拼接行"

#: ../../reference/lexical_analysis.rst:116
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"两个及两个以上的物理行可用反斜杠（``\\``）拼接为一个逻辑行，规则如下：以不在字符串或注释内的反斜杠结尾时，物理行将与下一行拼接成一个逻辑行，并删除反斜杠及其后的换行符。例如："

#: ../../reference/lexical_analysis.rst:127
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string"
" literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"以反斜杠结尾的行，不能加注释；反斜杠也不能拼接注释。除字符串字面值外，反斜杠不能拼接形符（如，除字符串字面值外，不能用反斜杠把形符切分至两个物理行）。反斜杠只能在代码的字符串字面值里，在其他任何位置都是非法的。"

#: ../../reference/lexical_analysis.rst:137
msgid "Implicit line joining"
msgstr "隐式拼接行"

#: ../../reference/lexical_analysis.rst:139
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr "圆括号、方括号、花括号内的表达式可以分成多个物理行，不必使用反斜杠。例如："

#: ../../reference/lexical_analysis.rst:147
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"隐式行拼接可含注释；后续行的缩进并不重要；还支持空的后续行。隐式拼接行之间没有 NEWLINE "
"形符。三引号字符串支持隐式拼接行（见下文），但不支持注释。"

#: ../../reference/lexical_analysis.rst:157
msgid "Blank lines"
msgstr "空白行"

#: ../../reference/lexical_analysis.rst:161
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"只包含空格符、制表符、换页符、注释的逻辑行会被忽略（即不生成 NEWLINE 形符）。交互模式输入语句时，空白行的处理方式可能因读取 - 求值 - "
"打印循环（REPL）的具体实现方式而不同。标准交互模式解释器中，完全空白的逻辑行（即连空格或注释都没有）将结束多行复合语句。"

#: ../../reference/lexical_analysis.rst:172
msgid "Indentation"
msgstr "缩进"

#: ../../reference/lexical_analysis.rst:176
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr "逻辑行开头的空白符（空格符和制表符）用于计算该行的缩进层级，决定语句组块。"

#: ../../reference/lexical_analysis.rst:180
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple"
" of eight (this is intended to be the same rule as used by Unix).  The total"
" number of spaces preceding the first non-blank character then determines "
"the line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines"
" the indentation."
msgstr ""
"制表符（从左至右）被替换为一至八个空格，缩进空格的总数是八的倍数（与 Unix "
"的规则保持一致）。首个非空字符前的空格数决定了该行的缩进层次。缩进不能用反斜杠进行多行拼接；首个反斜杠之前的空白符决定了缩进的层次。"

#: ../../reference/lexical_analysis.rst:188
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"源文件混用制表符和空格符缩进时，因空格数量与制表符相关，由此产生的不一致将导致不能正常识别缩进层次，从而触发 :exc:`TabError`。"

#: ../../reference/lexical_analysis.rst:192
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors"
" on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for"
" the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**跨平台兼容性说明：** 鉴于非 UNIX "
"平台文本编辑器本身的特性，请勿在源文件中混用制表符和空格符。另外也请注意，不同平台有可能会显式限制最大缩进层级。"

#: ../../reference/lexical_analysis.rst:197
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr "行首含换页符时，缩进计算将忽略该换页符。换页符在行首空白符内其他位置的效果未定义（例如，可能导致空格计数重置为零）。"

#: ../../reference/lexical_analysis.rst:204
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr "连续行的缩进层级以堆栈形式生成 INDENT 和 DEDENT 形符，说明如下。"

#: ../../reference/lexical_analysis.rst:207
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack"
" will always be strictly increasing from bottom to top.  At the beginning of"
" each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on"
" the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"读取文件第一行前，先向栈推入一个零值，该零值不会被移除。推入栈的层级值从底至顶持续增加。每个逻辑行开头的行缩进层级将与栈顶行比较。如果相等，则不做处理。如果新行层级较高，则会被推入栈顶，并生成一个"
" INDENT 形符。如果新行层级较低，则 *应当* 是栈中的层级数值之一；栈中高于该层级的所有数值都将被移除，每移除一级数值生成一个 DEDENT "
"形符。文件末尾，栈中剩余的每个大于零的数值生成一个 DEDENT 形符。"

#: ../../reference/lexical_analysis.rst:218
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "下面的 Python 代码缩进示例虽然正确，但含混不清："

#: ../../reference/lexical_analysis.rst:233
msgid "The following example shows various indentation errors::"
msgstr "下例展示了多种缩进错误："

#: ../../reference/lexical_analysis.rst:243
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"（实际上，解析器可以识别前三个错误；只有最后一个错误由词法分析器识别  --- ``return r`` 的缩进无法匹配从栈里移除的缩进层级。）"

#: ../../reference/lexical_analysis.rst:251
msgid "Whitespace between tokens"
msgstr "形符间的空白字符"

#: ../../reference/lexical_analysis.rst:253
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to"
" separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"除非在逻辑行开头或字符串内，空格符、制表符、换页符等空白符都可以分隔形符。要把两个相连形符解读为不同形符，需要用空白符分隔（例如，ab 是一个形符，a "
"b 则是两个形符）。"

#: ../../reference/lexical_analysis.rst:263
msgid "Other tokens"
msgstr "其他形符"

#: ../../reference/lexical_analysis.rst:265
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*."
" Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"除 NEWLINE、INDENT、DEDENT 外，还有 *标识符*、*关键字*、*字面值*、*运算符* 、*分隔符* 等形符。 "
"空白符（前述的行终止符除外）不是形符，可用于分隔形符。存在二义性时，将从左至右，读取尽量长的字符串组成合法形符。"

#: ../../reference/lexical_analysis.rst:275
msgid "Identifiers and keywords"
msgstr "标识符和关键字"

#: ../../reference/lexical_analysis.rst:279
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "标识符（也称为 *名称*）的词法定义说明如下。"

#: ../../reference/lexical_analysis.rst:282
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr "Python 标识符的句法基于 Unicode 标准附件 UAX-31，并加入了下文定义的细化与修改；详见 :pep:`3131` 。"

#: ../../reference/lexical_analysis.rst:286
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"与 Python 2.x 一样，在 ASCII 范围内（U+0001..U+007F），有效标识符字符为： 大小写字母 ``A`` 至 "
"``Z``、下划线 ``_`` 、数字 ``0`` 至 ``9``，但不能以数字开头。"

#: ../../reference/lexical_analysis.rst:291
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the "
":mod:`unicodedata` module."
msgstr ""
"Python 3.0 引入了 ASCII 之外的更多字符（请参阅 :pep:`3131`）。这些字符的分类使用 :mod:`unicodedata` "
"模块中的 Unicode 字符数据库版本。"

#: ../../reference/lexical_analysis.rst:295
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "标识符的长度没有限制，但区分大小写。"

#: ../../reference/lexical_analysis.rst:304
msgid "The Unicode category codes mentioned above stand for:"
msgstr "上述 Unicode 类别码的含义:"

#: ../../reference/lexical_analysis.rst:306
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - 大写字母"

#: ../../reference/lexical_analysis.rst:307
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - 小写字母"

#: ../../reference/lexical_analysis.rst:308
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - 词首大写字母"

#: ../../reference/lexical_analysis.rst:309
msgid "*Lm* - modifier letters"
msgstr "*Lm* - 修饰符字母"

#: ../../reference/lexical_analysis.rst:310
msgid "*Lo* - other letters"
msgstr "*Lo* - 其他字母"

#: ../../reference/lexical_analysis.rst:311
msgid "*Nl* - letter numbers"
msgstr "*Nl* - 字母数字"

#: ../../reference/lexical_analysis.rst:312
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - 非空白标识"

#: ../../reference/lexical_analysis.rst:313
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - 含空白标识"

#: ../../reference/lexical_analysis.rst:314
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - 十进制数字"

#: ../../reference/lexical_analysis.rst:315
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - 连接标点"

#: ../../reference/lexical_analysis.rst:316
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt "
"<https://www.unicode.org/Public/14.0.0/ucd/PropList.txt>`_ to support "
"backwards compatibility"
msgstr ""
"*Other_ID_Start* - 在 `PropList.txt "
"<https://www.unicode.org/Public/14.0.0/ucd/PropList.txt>`_ "
"中显式定义的用于支持向下兼容的字符列表。"

#: ../../reference/lexical_analysis.rst:319
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 同上"

#: ../../reference/lexical_analysis.rst:321
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr "在解析时，所有标识符都会被转换为规范形式 NFKC；标识符的比较都是基于 NFKC。"

#: ../../reference/lexical_analysis.rst:324
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 14.0.0 can be found at "
"https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt"
msgstr ""
"一份列出 Unicode 14.0.0 中所有可用标识符字符的非规范 HTML 文件可在 "
"https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt 获取。"

#: ../../reference/lexical_analysis.rst:332
msgid "Keywords"
msgstr "关键字"

#: ../../reference/lexical_analysis.rst:338
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr "以下标识符为保留字，或称 *关键字*，不可用于普通标识符。关键字的拼写必须与这里列出的完全一致："

#: ../../reference/lexical_analysis.rst:356
msgid "Soft Keywords"
msgstr "软关键字"

#: ../../reference/lexical_analysis.rst:362
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""
"某些标识符仅在特定上下文中被保留。 它们被称为 *软关键字*。 ``match``, ``case`` 和 ``_`` "
"等标识符在模式匹配语句相关的上下文中具有相当于关键字的语义，但这种区分是在解析器层级完成，而不是在形符化的时候。"

#: ../../reference/lexical_analysis.rst:368
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""
"作为软关键字，它们能够与模式匹配一起使用，同时仍然保持与使用 ``match``, ``case`` 和 ``_`` 作为标识符名称的现有代码的兼容性。"

#: ../../reference/lexical_analysis.rst:379
msgid "Reserved classes of identifiers"
msgstr "保留的标识符类"

#: ../../reference/lexical_analysis.rst:381
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr "某些标识符类（除了关键字）具有特殊含义。这些类的命名模式以下划线字符开头，并以下划线结尾："

#: ../../reference/lexical_analysis.rst:386
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:386
msgid "Not imported by ``from module import *``."
msgstr "不会被 ``from module import *`` 所导入。"

#: ../../reference/lexical_analysis.rst:407
msgid "``_``"
msgstr "``_``"

#: ../../reference/lexical_analysis.rst:389
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a "
":ref:`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"在 :keyword:`match` 语句内部的 ``case`` 模式中，``_`` 是一个 :ref:`软关键字 <soft-"
"keywords>`，它表示 :ref:`通配符 <wildcard-patterns>`。"

#: ../../reference/lexical_analysis.rst:393
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the "
":mod:`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"在此之外，交互式解释器会将最后一次求值的结果放到变量 ``_`` 中。 （它与 ``print`` 等内置函数一起被存储于 "
":mod:`builtins` 模块。）"

#: ../../reference/lexical_analysis.rst:398
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr "在其他地方，``_`` 是一个常规标识符。 它常常被用来命名 \"特殊\" 条目，但对 Python 本身来说毫无特殊之处。"

#: ../../reference/lexical_analysis.rst:403
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer"
" to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr "``_`` 常用于连接国际化文本；详见 :mod:`gettext` 模块文档。"

#: ../../reference/lexical_analysis.rst:407
msgid "It is also commonly used for unused variables."
msgstr "它还经常被用来命名无需使用的变量。"

#: ../../reference/lexical_analysis.rst:415
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:410
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"系统定义的名称，通常简称为 \"dunder\" 。这些名称由解释器及其实现（包括标准库）定义。现有系统定义名称相关的论述详见 "
":ref:`specialnames` 等章节。Python 未来版本中还将定义更多此类名称。任何情况下，*任何* 不显式遵从 ``__*__`` "
"名称的文档用法，都可能导致无警告提示的错误。"

#: ../../reference/lexical_analysis.rst:422
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:418
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See"
" section :ref:`atom-identifiers`."
msgstr ""
"类的私有名称。类定义时，此类名称以一种混合形式重写，以避免基类及派生类的 \"私有\" 属性之间产生名称冲突。详见 :ref:`atom-"
"identifiers`。"

#: ../../reference/lexical_analysis.rst:427
msgid "Literals"
msgstr "字面值"

#: ../../reference/lexical_analysis.rst:431
msgid "Literals are notations for constant values of some built-in types."
msgstr "字面值是内置类型常量值的表示法。"

#: ../../reference/lexical_analysis.rst:442
msgid "String and Bytes literals"
msgstr "字符串与字节串字面值"

#: ../../reference/lexical_analysis.rst:444
msgid "String literals are described by the following lexical definitions:"
msgstr "字符串字面值的词法定义如下："

#: ../../reference/lexical_analysis.rst:469
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section "
":ref:`encodings`."
msgstr ""
"这些产生式未指明的一个句法限制是空白符不允许在 :token:`~python-grammar:stringprefix` 或 "
":token:`~python-grammar:bytesprefix` 与字面值的其余部分之间出现。 "
"源字符集是由编码格式声明来定义的；如果源文件没有给出编码格式声明则默认 UTF-8；参见 :ref:`encodings` 一节。"

#: ../../reference/lexical_analysis.rst:479
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"自然语言描述: 两种字面值都可以用成对单引号 (``'``) 或双引号 (``\"``) 来标示首尾。它们也可以用成对的连续三个单引号或双引号来标示首尾"
" (这通常被称为 *三引号字符串*)。反斜杠 (``\\``) 字符被用来对特殊含义的字符进行转义，例如换行，反斜杠本身或是引号等字符。"

#: ../../reference/lexical_analysis.rst:490
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"字节串字面值要加前缀 ``'b'`` 或 ``'B'``；生成的是类型 :class:`bytes` 的实例，不是类型 :class:`str` "
"的实例；字节串只能包含 ASCII 字符；字节串数值大于等于 128 时，必须用转义表示。"

#: ../../reference/lexical_analysis.rst:499
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"字符串和字节串都可以加前缀 ``'r'`` 或 ``'R'``，称为 "
":dfn:`原始字符串`，原始字符串把反斜杠当作原义字符，不执行转义操作。因此，原始字符串不转义 ``'\\U'`` 和 ``'\\u'``。与 "
"Python 2.x 的原始 unicode 字面值操作不同，Python 3.x 现已不支持 ``'ur'`` 句法。"

#: ../../reference/lexical_analysis.rst:506
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr "新增原始字节串 ``'rb'`` 前缀，是 ``'br'`` 的同义词。"

#: ../../reference/lexical_analysis.rst:510
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See "
":pep:`414` for more information."
msgstr ""
"支持 unicode 字面值（``u'value'``）遗留代码，简化 Python 2.x 和 3.x 并行代码库的维护工作。详见 "
":pep:`414`。"

#: ../../reference/lexical_analysis.rst:518
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"前缀为 ``'f'`` 或 ``'F'`` 的字符串称为 :dfn:`格式字符串`；详见 :ref:`f-strings`。``'f'`` 可与 "
"``'r'`` 连用，但不能与 ``'b'`` 或 ``'u'`` 连用，因此，可以使用原始格式字符串，但不能使用格式字节串字面值。"

#: ../../reference/lexical_analysis.rst:523
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"三引号字面值可以包含未转义的换行和引号（原样保留），除了连在一起的，用于终止字面值的，未经转义的三个引号。（\"引号\" 是启用字面值的字符，可以是 "
"``'``，也可以是 ``\"``。）"

#: ../../reference/lexical_analysis.rst:545
msgid "Escape sequences"
msgstr "转义序列"

#: ../../reference/lexical_analysis.rst:547
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr "如未标注 ``'r'`` 或 ``'R'`` 前缀，字符串和字节串字面值中，转义序列以类似 C 标准的规则进行解释。可用的转义序列如下："

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Escape Sequence"
msgstr "转义序列"

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Meaning"
msgstr "含意"

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Notes"
msgstr "备注"

#: ../../reference/lexical_analysis.rst:554
msgid "``\\``\\ <newline>"
msgstr "``\\``\\ <newline>"

#: ../../reference/lexical_analysis.rst:554
msgid "Backslash and newline ignored"
msgstr "忽略反斜杠与换行符"

#: ../../reference/lexical_analysis.rst:554
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:556
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:556
msgid "Backslash (``\\``)"
msgstr "反斜杠（``\\``）"

#: ../../reference/lexical_analysis.rst:558
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:558
msgid "Single quote (``'``)"
msgstr "单引号（``'``）"

#: ../../reference/lexical_analysis.rst:560
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:560
msgid "Double quote (``\"``)"
msgstr "双引号（``\"``）"

#: ../../reference/lexical_analysis.rst:562
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:562
msgid "ASCII Bell (BEL)"
msgstr "ASCII 响铃（BEL）"

#: ../../reference/lexical_analysis.rst:564
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:564
msgid "ASCII Backspace (BS)"
msgstr "ASCII 退格符（BS）"

#: ../../reference/lexical_analysis.rst:566
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:566
msgid "ASCII Formfeed (FF)"
msgstr "ASCII 换页符（FF）"

#: ../../reference/lexical_analysis.rst:568
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:568
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 换行符（LF）"

#: ../../reference/lexical_analysis.rst:570
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:570
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 回车符（CR）"

#: ../../reference/lexical_analysis.rst:572
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:572
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平制表符（TAB）"

#: ../../reference/lexical_analysis.rst:574
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:574
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 垂直制表符（VT）"

#: ../../reference/lexical_analysis.rst:576
msgid ":samp:`\\\\\\\\{ooo}`"
msgstr ":samp:`\\\\\\\\{ooo}`"

#: ../../reference/lexical_analysis.rst:576
msgid "Character with octal value *ooo*"
msgstr "八进制数 *ooo* 字符"

#: ../../reference/lexical_analysis.rst:576
msgid "(2,4)"
msgstr "(2,4)"

#: ../../reference/lexical_analysis.rst:579
msgid ":samp:`\\\\x{hh}`"
msgstr ":samp:`\\\\x{hh}`"

#: ../../reference/lexical_analysis.rst:579
msgid "Character with hex value *hh*"
msgstr "十六进制数 *hh* 字符"

#: ../../reference/lexical_analysis.rst:579
msgid "(3,4)"
msgstr "(3,4)"

#: ../../reference/lexical_analysis.rst:582
msgid "Escape sequences only recognized in string literals are:"
msgstr "字符串字面值专用的转义序列："

#: ../../reference/lexical_analysis.rst:587
msgid ":samp:`\\\\N\\\\{{name}\\\\}`"
msgstr ":samp:`\\\\N\\\\{{name}\\\\}`"

#: ../../reference/lexical_analysis.rst:587
msgid "Character named *name* in the Unicode database"
msgstr "Unicode 数据库中名为 *name* 的字符"

#: ../../reference/lexical_analysis.rst:587
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:590
msgid ":samp:`\\\\u{xxxx}`"
msgstr ":samp:`\\\\u{xxxx}`"

#: ../../reference/lexical_analysis.rst:590
msgid "Character with 16-bit hex value *xxxx*"
msgstr "16 位十六进制数 *xxxx* 码位的字符"

#: ../../reference/lexical_analysis.rst:590
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:593
msgid ":samp:`\\\\U{xxxxxxxx}`"
msgstr ":samp:`\\\\U{xxxxxxxx}`"

#: ../../reference/lexical_analysis.rst:593
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "32 位 16 进制数 *xxxxxxxx* 码位的字符"

#: ../../reference/lexical_analysis.rst:593
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:597
msgid "Notes:"
msgstr "注释："

#: ../../reference/lexical_analysis.rst:600
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr "可以在行尾添加一个反斜杠来忽略换行符::"

#: ../../reference/lexical_analysis.rst:606
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""
"同样的效果也可以使用 :ref:`三重引号字符串 <strings>`，或者圆括号和 :ref:`字符串字面值拼接 <string-"
"concatenation>` 来达成。"

#: ../../reference/lexical_analysis.rst:611
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "与 C 标准一致，接受最多三个八进制数字。"

#: ../../reference/lexical_analysis.rst:613
msgid ""
"Octal escapes with value larger than ``0o377`` produce a "
":exc:`DeprecationWarning`. In a future Python version they will be a "
":exc:`SyntaxWarning` and eventually a :exc:`SyntaxError`."
msgstr ""
"数值大于 ``0o377`` 的八进制转义符会产生 :exc:`DeprecationWarning`。 在未来的 Python 版本中将为 "
":exc:`SyntaxWarning` 并最终改为 :exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:619
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "与 C 标准不同，必须为两个十六进制数字。"

#: ../../reference/lexical_analysis.rst:622
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"*字节串* 字面值中，十六进制数和八进制数的转义码以相应数值代表每个字节。*字符串* 字面值中，这些转义码以相应数值代表每个 Unicode 字符。"

#: ../../reference/lexical_analysis.rst:627
msgid "Support for name aliases [#]_ has been added."
msgstr "加入了对别名 [#]_ 的支持。"

#: ../../reference/lexical_analysis.rst:631
msgid "Exactly four hex digits are required."
msgstr "必须为 4 个十六进制数码。"

#: ../../reference/lexical_analysis.rst:634
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are"
" required."
msgstr "表示任意 Unicode 字符。必须为 8 个十六进制数码。"

#: ../../reference/lexical_analysis.rst:640
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"与 C "
"标准不同，无法识别的转义序列在字符串里原样保留，即，*输出结果保留反斜杠*。（调试时，这种方式很有用：输错转义序列时，更容易在输出结果中识别错误。）注意，在字节串字面值内，字符串字面值专用的转义序列属于无法识别的转义序列。"

#: ../../reference/lexical_analysis.rst:647
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a "
":exc:`SyntaxError`."
msgstr ""
"无法识别的转义序列触发 :exc:`DeprecationWarning`。未来的 Python 发行版将改为触发 "
":exc:`SyntaxWarning`，最终会改为触发 :exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:652
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote;"
" ``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a"
" single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"即使在原始字面值中，引号也可以用反斜杠转义，但反斜杠会保留在输出结果里；例如 ``r\"\\\"\"`` "
"是由两个字符组成的有效字符串字面值：反斜杠和双引号；``r\"\\\"`` "
"则不是有效字符串字面值（原始字符串也不能以奇数个反斜杠结尾）。尤其是，*原始字面值不能以单个反斜杠结尾* "
"（反斜杠会转义其后的引号)。还要注意，反斜杠加换行在字面值中被解释为两个字符，而 *不是* 连续行。"

#: ../../reference/lexical_analysis.rst:665
msgid "String literal concatenation"
msgstr "字符串字面值合并"

#: ../../reference/lexical_analysis.rst:667
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning"
" is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long"
" lines, or even to add comments to parts of strings, for example::"
msgstr ""
"以空白符分隔的多个相邻字符串或字节串字面值，可用不同引号标注，等同于合并操作。因此，``\"hello\" 'world'`` 等价于 "
"``\"helloworld\"``。此功能不需要反斜杠，即可将长字符串分为多个物理行，还可以为不同部分的字符串添加注释，例如："

#: ../../reference/lexical_analysis.rst:678
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"注意，此功能在句法层面定义，在编译时实现。在运行时，合并字符串表达式必须使用 '+' "
"运算符。还要注意，字面值合并可以为每个部分应用不同的引号风格（甚至混用原始字符串和三引号字符串)，格式字符串字面值也可以与纯字符串字面值合并。"

#: ../../reference/lexical_analysis.rst:701
msgid "f-strings"
msgstr "f 字符串"

#: ../../reference/lexical_analysis.rst:705
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
":dfn:`格式字符串字面值` 或称 :dfn:`f-string` 是标注了 ``'f'`` 或 ``'F'`` "
"前缀的字符串字面值。这种字符串可包含替换字段，即以 ``{}`` 标注的表达式。其他字符串字面值只是常量，格式字符串字面值则是可在运行时求值的表达式。"

#: ../../reference/lexical_analysis.rst:711
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a"
" literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr "除非字面值标记为原始字符串，否则，与在普通字符串字面值中一样，转义序列也会被解码。解码后，用于字符串内容的语法如下："

#: ../../reference/lexical_analysis.rst:725
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display"
" both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"双花括号 ``'{{'`` 或 ``'}}'`` 被替换为单花括号，花括号外的字符串仍按字面值处理。单左花括号 ``'{'`` 标记以 Python "
"表达式开头的替换字段。在表达式后加等于号 ``'='``，可在求值后，同时显示表达式文本及其结果（用于调试）。 随后是用叹号 ``'!'`` "
"标记的转换字段。还可以在冒号 ``':'``  后附加格式说明符。替换字段以右花括号 ``'}'`` 为结尾。"

#: ../../reference/lexical_analysis.rst:735
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"格式字符串字面值中，表达式的处理与圆括号中的常规 Python "
"表达式基本一样，但也有一些不同的地方。不允许使用空表达式；:keyword:`lambda` 和赋值表达式 ``:=`` "
"必须显式用圆括号标注；替换表达式可以包含换行（例如，三引号字符串中），但不能包含注释；在格式字符串字面值语境内，按从左至右的顺序，为每个表达式求值。"

#: ../../reference/lexical_analysis.rst:744
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in"
" formatted string literals due to a problem with the implementation."
msgstr ""
"Python 3.7 以前， 因为实现的问题，不允许在格式字符串字面值表达式中使用 :keyword:`await` 表达式与包含 "
":keyword:`async for` 子句的推导式。"

#: ../../reference/lexical_analysis.rst:749
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression"
" text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the"
" output. By default, the ``'='`` causes the :func:`repr` of the expression "
"to be provided, unless there is a format specified. When a format is "
"specified it defaults to the :func:`str` of the expression unless a "
"conversion ``'!r'`` is declared."
msgstr ""
"表达式里含等号 ``'='`` 时，输出内容包括表达式文本、``'='`` 、求值结果。输出内容可以保留表达式中左花括号 ``'{'`` 后，及 "
"``'='`` 后的空格。没有指定格式时，``'='`` 默认调用表达式的 :func:`repr`。指定了格式时，默认调用表达式的 "
":func:`str`，除非声明了转换字段 ``'!r'``。"

#: ../../reference/lexical_analysis.rst:757
msgid "The equal sign ``'='``."
msgstr "等号 ``'='``。"

#: ../../reference/lexical_analysis.rst:760
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"指定了转换符时，表达式求值的结果会先转换，再格式化。转换符 ``'!s'`` 调用 :func:`str` 转换求值结果，``'!r'`` 调用 "
":func:`repr`，``'!a'`` 调用 :func:`ascii`。"

#: ../../reference/lexical_analysis.rst:764
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`~object.__format__` method of the "
"expression or conversion result.  An empty string is passed when the format "
"specifier is omitted.  The formatted result is then included in the final "
"value of the whole string."
msgstr ""
"然后使用 :func:`format` 协议对结果进行格式化。 格式说明符将传给表达式或转换结果的 :meth:`~object.__format__`"
" 方法。 如果省略格式说明符则将传入空字符串。 格式化后的结果将包括在整个字符串的最终值中。"

#: ../../reference/lexical_analysis.rst:770
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement"
" fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"最高层级的格式说明符可以包括嵌套的替换字段。 这些嵌套字段也可以包括它们自己的转换字段和 :ref:`格式说明符 "
"<formatspec>`，但是不可再包括更深层嵌套的替换字段。 这里的 :ref:`格式说明符微语言 <formatspec>` 与 "
":meth:`str.format` 方法所使用的相同。"

#: ../../reference/lexical_analysis.rst:776
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot"
" be split across literals."
msgstr "格式化字符串字面值可以拼接，但是一个替换字段不能拆分到多个字面值。"

#: ../../reference/lexical_analysis.rst:779
msgid "Some examples of formatted string literals::"
msgstr "格式字符串字面值示例如下："

#: ../../reference/lexical_analysis.rst:811
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used"
" in the outer formatted string literal::"
msgstr "与常规字符串字面值的语法一样，替换字段中的字符不能与外层格式字符串字面值的引号冲突："

#: ../../reference/lexical_analysis.rst:818
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr "格式化表达式中不允许使用反斜杠，否则导致错误："

#: ../../reference/lexical_analysis.rst:823
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr "如果要包含带反斜杠的值，请创建一个临时变量。"

#: ../../reference/lexical_analysis.rst:830
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr "即便未包含表达式，格式字符串字面值也不能用作文档字符串。"

#: ../../reference/lexical_analysis.rst:841
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr "参阅 :pep:`498`，了解格式字符串字面值的提案，以及与格式字符串机制相关的 :meth:`str.format`。"

#: ../../reference/lexical_analysis.rst:848
msgid "Numeric literals"
msgstr "数值字面值"

#: ../../reference/lexical_analysis.rst:854
msgid ""
"There are three types of numeric literals: integers, floating point numbers,"
" and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr "数值字面值有三种类型：整数、浮点数、虚数。没有复数字面值（复数由实数加虚数构成）。"

#: ../../reference/lexical_analysis.rst:858
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr "注意，数值字面值不含正负号；实际上，``-1`` 等负数是由一元运算符 '``-``' 和字面值 ``1`` 合成的。"

#: ../../reference/lexical_analysis.rst:872
msgid "Integer literals"
msgstr "整数字面值"

#: ../../reference/lexical_analysis.rst:874
msgid "Integer literals are described by the following lexical definitions:"
msgstr "整数字面值词法定义如下："

#: ../../reference/lexical_analysis.rst:888
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr "整数字面值的长度没有限制，能一直大到占满可用内存。"

#: ../../reference/lexical_analysis.rst:891
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr "确定数值时，会忽略字面值中的下划线。下划线只是为了分组数字，让数字更易读。下划线可在数字之间，也可在 ``0x`` 等基数说明符后。"

#: ../../reference/lexical_analysis.rst:895
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr "注意，除了 0 以外，十进制数字的开头不允许有零。以免与 Python 3.0 版之前使用的 C 样式八进制字面值混淆。"

#: ../../reference/lexical_analysis.rst:899
msgid "Some examples of integer literals::"
msgstr "整数字面值示例如下："

#: ../../reference/lexical_analysis.rst:905
#: ../../reference/lexical_analysis.rst:937
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "现已支持在字面值中，用下划线分组数字。"

#: ../../reference/lexical_analysis.rst:916
msgid "Floating point literals"
msgstr "浮点数字面值"

#: ../../reference/lexical_analysis.rst:918
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "浮点数字面值词法定义如下："

#: ../../reference/lexical_analysis.rst:928
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"注意，解析时，整数和指数部分总以 10 为基数。例如，``077e010`` 是合法的，表示的数值与 ``77e10`` "
"相同。浮点数字面值的支持范围取决于具体实现。整数字面值支持用下划线分组数字。"

#: ../../reference/lexical_analysis.rst:933
msgid "Some examples of floating point literals::"
msgstr "浮点数字面值示例如下："

#: ../../reference/lexical_analysis.rst:946
msgid "Imaginary literals"
msgstr "虚数字面值"

#: ../../reference/lexical_analysis.rst:948
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "虚数字面值词法定义如下："

#: ../../reference/lexical_analysis.rst:953
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have"
" the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"虚数字面值生成实部为 0.0 的复数。复数由一对浮点数表示，它们的取值范围相同。创建实部不为零的复数，则需添加浮点数，例如 "
"``(3+4j)``。虚数字面值示例如下："

#: ../../reference/lexical_analysis.rst:965
msgid "Operators"
msgstr "运算符"

#: ../../reference/lexical_analysis.rst:969
msgid "The following tokens are operators:"
msgstr "运算符如下所示："

#: ../../reference/lexical_analysis.rst:982
msgid "Delimiters"
msgstr "分隔符"

#: ../../reference/lexical_analysis.rst:986
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "以下形符在语法中为分隔符："

#: ../../reference/lexical_analysis.rst:995
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically"
" as delimiters, but also perform an operation."
msgstr "句点也可以用于浮点数和虚数字面值。三个连续句点表示省略符。列表后半部分是增强赋值操作符，用作词法分隔符，但也可以执行运算。"

#: ../../reference/lexical_analysis.rst:1000
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "以下 ASCII 字符具有特殊含义，对词法分析器有重要意义："

#: ../../reference/lexical_analysis.rst:1007
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr "以下 ASCII 字符不用于 Python。在字符串字面值或注释外使用时，将直接报错："

#: ../../reference/lexical_analysis.rst:1016
msgid "Footnotes"
msgstr "备注"

#: ../../reference/lexical_analysis.rst:1017
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"

#: ../../reference/lexical_analysis.rst:8
msgid "lexical analysis"
msgstr "词法分析"

#: ../../reference/lexical_analysis.rst:8
msgid "parser"
msgstr "解析器"

#: ../../reference/lexical_analysis.rst:8
msgid "token"
msgstr "形符"

#: ../../reference/lexical_analysis.rst:25
msgid "line structure"
msgstr "行结构"

#: ../../reference/lexical_analysis.rst:35
msgid "logical line"
msgstr "逻辑行"

#: ../../reference/lexical_analysis.rst:35
#: ../../reference/lexical_analysis.rst:114
#: ../../reference/lexical_analysis.rst:527
msgid "physical line"
msgstr "物理行"

#: ../../reference/lexical_analysis.rst:35
#: ../../reference/lexical_analysis.rst:114
msgid "line joining"
msgstr "行连接"

#: ../../reference/lexical_analysis.rst:35
msgid "NEWLINE token"
msgstr "NEWLINE 形符"

#: ../../reference/lexical_analysis.rst:67
msgid "comment"
msgstr "注释"

#: ../../reference/lexical_analysis.rst:67
msgid "hash character"
msgstr "hash 字符"

#: ../../reference/lexical_analysis.rst:67
#: ../../reference/lexical_analysis.rst:81
msgid "# (hash)"
msgstr "# (hash)"

#: ../../reference/lexical_analysis.rst:81
msgid "source character set"
msgstr "源字符集合"

#: ../../reference/lexical_analysis.rst:81
msgid "encoding declarations (source file)"
msgstr "编码格式声明（源文件）"

#: ../../reference/lexical_analysis.rst:81
msgid "source encoding declaration"
msgstr "源文件编码格式声明"

#: ../../reference/lexical_analysis.rst:114
msgid "line continuation"
msgstr "行连续"

#: ../../reference/lexical_analysis.rst:114
msgid "backslash character"
msgstr "反斜杠字符"

#: ../../reference/lexical_analysis.rst:159
msgid "blank line"
msgstr "空行"

#: ../../reference/lexical_analysis.rst:174
msgid "indentation"
msgstr "缩进"

#: ../../reference/lexical_analysis.rst:174
msgid "leading whitespace"
msgstr "开头空格"

#: ../../reference/lexical_analysis.rst:174
msgid "space"
msgstr "space"

#: ../../reference/lexical_analysis.rst:174
msgid "tab"
msgstr "tab"

#: ../../reference/lexical_analysis.rst:174
msgid "grouping"
msgstr "分组"

#: ../../reference/lexical_analysis.rst:174
msgid "statement grouping"
msgstr "语句分组"

#: ../../reference/lexical_analysis.rst:202
msgid "INDENT token"
msgstr "INDENT 形符"

#: ../../reference/lexical_analysis.rst:202
msgid "DEDENT token"
msgstr "DEDENT 形符"

#: ../../reference/lexical_analysis.rst:277
msgid "identifier"
msgstr "标识符"

#: ../../reference/lexical_analysis.rst:277
msgid "name"
msgstr "name"

#: ../../reference/lexical_analysis.rst:334
#: ../../reference/lexical_analysis.rst:358
msgid "keyword"
msgstr "关键字"

#: ../../reference/lexical_analysis.rst:334
msgid "reserved word"
msgstr "保留字"

#: ../../reference/lexical_analysis.rst:358
msgid "soft keyword"
msgstr "软关键字"

#: ../../reference/lexical_analysis.rst:373
msgid "_, identifiers"
msgstr "_, 标识符"

#: ../../reference/lexical_analysis.rst:373
msgid "__, identifiers"
msgstr "__, 标识符"

#: ../../reference/lexical_analysis.rst:429
msgid "literal"
msgstr "字面值"

#: ../../reference/lexical_analysis.rst:429
msgid "constant"
msgstr "常量"

#: ../../reference/lexical_analysis.rst:434
#: ../../reference/lexical_analysis.rst:475
msgid "string literal"
msgstr "字符串字面值"

#: ../../reference/lexical_analysis.rst:434
#: ../../reference/lexical_analysis.rst:486
msgid "bytes literal"
msgstr "字节串字面值"

#: ../../reference/lexical_analysis.rst:434
msgid "ASCII"
msgstr "ASCII"

#: ../../reference/lexical_analysis.rst:434
msgid "' (single quote)"
msgstr "' (单引号)"

#: ../../reference/lexical_analysis.rst:434
msgid "\" (double quote)"
msgstr "\" (双引号)"

#: ../../reference/lexical_analysis.rst:434
msgid "u'"
msgstr "u'"

#: ../../reference/lexical_analysis.rst:434
msgid "u\""
msgstr "u\""

#: ../../reference/lexical_analysis.rst:475
msgid "triple-quoted string"
msgstr "triple-quoted string -- 三引号字符串"

#: ../../reference/lexical_analysis.rst:475
msgid "Unicode Consortium"
msgstr "Unicode Consortium"

#: ../../reference/lexical_analysis.rst:475
msgid "raw string"
msgstr "原始字符串"

#: ../../reference/lexical_analysis.rst:475
msgid "\"\"\""
msgstr "\"\"\""

#: ../../reference/lexical_analysis.rst:475
msgid "'''"
msgstr "'''"

#: ../../reference/lexical_analysis.rst:486
msgid "b'"
msgstr "b'"

#: ../../reference/lexical_analysis.rst:486
msgid "b\""
msgstr "b\""

#: ../../reference/lexical_analysis.rst:495
msgid "r'"
msgstr "r'"

#: ../../reference/lexical_analysis.rst:495
msgid "raw string literal"
msgstr "原始字符串字面值"

#: ../../reference/lexical_analysis.rst:495
msgid "r\""
msgstr "r\""

#: ../../reference/lexical_analysis.rst:514
msgid "f'"
msgstr "f'"

#: ../../reference/lexical_analysis.rst:514
#: ../../reference/lexical_analysis.rst:685
msgid "formatted string literal"
msgstr "格式字符串字面值"

#: ../../reference/lexical_analysis.rst:514
msgid "f\""
msgstr "f\""

#: ../../reference/lexical_analysis.rst:527
msgid "escape sequence"
msgstr "转义序列"

#: ../../reference/lexical_analysis.rst:527
msgid "Standard C"
msgstr "标准 C"

#: ../../reference/lexical_analysis.rst:527
msgid "C"
msgstr "C"

#: ../../reference/lexical_analysis.rst:527
msgid "\\ (backslash)"
msgstr "\\ (反斜杠)"

#: ../../reference/lexical_analysis.rst:527
msgid "\\\\"
msgstr "\\\\"

#: ../../reference/lexical_analysis.rst:527
msgid "\\a"
msgstr "\\a"

#: ../../reference/lexical_analysis.rst:527
msgid "\\b"
msgstr "\\b"

#: ../../reference/lexical_analysis.rst:527
msgid "\\f"
msgstr "\\f"

#: ../../reference/lexical_analysis.rst:527
msgid "\\n"
msgstr "\\n"

#: ../../reference/lexical_analysis.rst:527
msgid "\\r"
msgstr "\\r"

#: ../../reference/lexical_analysis.rst:527
msgid "\\t"
msgstr "\\t"

#: ../../reference/lexical_analysis.rst:527
msgid "\\v"
msgstr "\\v"

#: ../../reference/lexical_analysis.rst:527
msgid "\\x"
msgstr "\\x"

#: ../../reference/lexical_analysis.rst:527
msgid "\\u"
msgstr "\\u"

#: ../../reference/lexical_analysis.rst:527
msgid "\\U"
msgstr "\\U"

#: ../../reference/lexical_analysis.rst:638
msgid "unrecognized escape sequence"
msgstr "无法识别的转义序列"

#: ../../reference/lexical_analysis.rst:685
msgid "interpolated string literal"
msgstr "插值字符串字面值"

#: ../../reference/lexical_analysis.rst:685
msgid "string"
msgstr "string"

#: ../../reference/lexical_analysis.rst:685
msgid "formatted literal"
msgstr "格式化字面值"

#: ../../reference/lexical_analysis.rst:685
msgid "interpolated literal"
msgstr "插值字面值"

#: ../../reference/lexical_analysis.rst:685
msgid "f-string"
msgstr "f-string -- f-字符串"

#: ../../reference/lexical_analysis.rst:685
msgid "fstring"
msgstr "fstring"

#: ../../reference/lexical_analysis.rst:685
msgid "{} (curly brackets)"
msgstr "{} (花括号)"

#: ../../reference/lexical_analysis.rst:685
msgid "in formatted string literal"
msgstr "格式字符串字面值形式"

#: ../../reference/lexical_analysis.rst:685
msgid "! (exclamation)"
msgstr "! (感叹号)"

#: ../../reference/lexical_analysis.rst:685
msgid ": (colon)"
msgstr ": (冒号)"

#: ../../reference/lexical_analysis.rst:685
msgid "= (equals)"
msgstr "= (等于号)"

#: ../../reference/lexical_analysis.rst:685
msgid "for help in debugging using string literals"
msgstr "用于帮助使用字符串字面值进行调试"

#: ../../reference/lexical_analysis.rst:850
msgid "number"
msgstr "数字"

#: ../../reference/lexical_analysis.rst:850
msgid "numeric literal"
msgstr "数字字面值"

#: ../../reference/lexical_analysis.rst:850
#: ../../reference/lexical_analysis.rst:863
msgid "integer literal"
msgstr "整数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "floating point literal"
msgstr "浮点数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "hexadecimal literal"
msgstr "十六进制数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "octal literal"
msgstr "八进制数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "binary literal"
msgstr "二进制数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "decimal literal"
msgstr "十进制数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "imaginary literal"
msgstr "虚数字面值"

#: ../../reference/lexical_analysis.rst:850
msgid "complex literal"
msgstr "复数字面值"

#: ../../reference/lexical_analysis.rst:863
msgid "0b"
msgstr "0b"

#: ../../reference/lexical_analysis.rst:863
msgid "0o"
msgstr "0o"

#: ../../reference/lexical_analysis.rst:863
msgid "0x"
msgstr "0x"

#: ../../reference/lexical_analysis.rst:863
#: ../../reference/lexical_analysis.rst:909
msgid "_ (underscore)"
msgstr "_ (下划线)"

#: ../../reference/lexical_analysis.rst:863
#: ../../reference/lexical_analysis.rst:909
#: ../../reference/lexical_analysis.rst:941
msgid "in numeric literal"
msgstr "数字字面值形式"

#: ../../reference/lexical_analysis.rst:909
msgid ". (dot)"
msgstr ". (点号)"

#: ../../reference/lexical_analysis.rst:909
msgid "e"
msgstr "e"

#: ../../reference/lexical_analysis.rst:941
msgid "j"
msgstr "j"

#: ../../reference/lexical_analysis.rst:967
msgid "operators"
msgstr "运算符"

#: ../../reference/lexical_analysis.rst:984
msgid "delimiters"
msgstr "分隔符"
