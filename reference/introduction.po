# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/introduction.rst:6
msgid "Introduction"
msgstr "概述"

#: ../../reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is not "
"intended as a tutorial."
msgstr "本手册仅描述 Python 编程语言，不宜当作教程。"

#: ../../reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and lexical "
"analysis. This should make the document more understandable to the average "
"reader, but will leave room for ambiguities. Consequently, if you were "
"coming from Mars and tried to re-implement Python from this document alone, "
"you might have to guess things and in fact you would probably end up "
"implementing quite a different language. On the other hand, if you are using"
" Python and wonder what the precise rules about a particular area of the "
"language are, you should definitely be able to find them here. If you would "
"like to see a more formal definition of the language, maybe you could "
"volunteer your time --- or invent a cloning machine :-)."
msgstr ""
"我希望尽可能地保证内容精确无误，但还是选择使用自然词句进行描述，正式的规格定义仅用于句法和词法解析。这样应该能使文档对于普通人来说更易理解，但也可能导致一些歧义。因此，如果你是来自火星并且想凭借这份文档把"
" Python 重新实现一遍，也许有时需要自行猜测，实际上最终大概会得到一个十分不同的语言。而在另一方面，如果你正在使用 Python "
"并且想了解有关该语言特定领域的精确规则，你应该能够在这里找到它们。如果你希望查看对该语言更正式的定义，也许你可以花些时间自己写上一份 --- "
"或者发明一台克隆机器 :-)"

#: ../../reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, CPython is the one Python implementation in widespread use (although "
"alternate implementations continue to gain support), and its particular "
"quirks are sometimes worth being mentioned, especially where the "
"implementation imposes additional limitations. Therefore, you'll find short "
"\"implementation notes\" sprinkled throughout the text."
msgstr ""
"在语言参考文档里加入过多的实现细节是很危险的 --- 具体实现可能发生改变，对同一语言的其他实现可能使用不同的方式。而在另一方面，CPython "
"是得到广泛使用的 Python 实现 "
"(然而其他一些实现的拥护者也在增加)，其中的特殊细节有时也值得一提，特别是当其实现方式导致额外的限制时。因此，你会发现在正文里不时会跳出来一些简短的 "
"\"实现注释\"。"

#: ../../reference/introduction.rst:32
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""
"每种 Python 实现都带有一些内置和标准的模块。相关的文档可参见 :ref:`library-index` "
"索引。少数内置模块也会在此提及，如果它们同语言描述存在明显的关联。"

#: ../../reference/introduction.rst:41
msgid "Alternate Implementations"
msgstr "其他实现"

#: ../../reference/introduction.rst:43
msgid ""
"Though there is one Python implementation which is by far the most popular, "
"there are some alternate implementations which are of particular interest to"
" different audiences."
msgstr "虽然官方 Python 实现差不多得到最广泛的欢迎，但也有一些其他实现对特定领域的用户来说更具吸引力。"

#: ../../reference/introduction.rst:47
msgid "Known implementations include:"
msgstr "知名的实现包括:"

#: ../../reference/introduction.rst:49
msgid "CPython"
msgstr "CPython"

#: ../../reference/introduction.rst:50
msgid ""
"This is the original and most-maintained implementation of Python, written "
"in C. New language features generally appear here first."
msgstr "这是最早出现并持续维护的 Python 实现，以 C 语言编写。新的语言特性通常在此率先添加。"

#: ../../reference/introduction.rst:53
msgid "Jython"
msgstr "Jython"

#: ../../reference/introduction.rst:54
msgid ""
"Python implemented in Java.  This implementation can be used as a scripting "
"language for Java applications, or can be used to create applications using "
"the Java class libraries.  It is also often used to create tests for Java "
"libraries. More information can be found at `the Jython website "
"<https://www.jython.org/>`_."
msgstr ""
"以 Java 语言编写的 Python 实现。 此实现可以作为 Java 应用的一个脚本语言，或者可以用来创建需要 Java 类库支持的应用。 "
"想了解更多信息请访问 `Jython 网站 <https://www.jython.org/>`_。"

#: ../../reference/introduction.rst:59
msgid "Python for .NET"
msgstr "Python for .NET"

#: ../../reference/introduction.rst:60
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was created"
" by Brian Lloyd.  For more information, see the `Python for .NET home page "
"<https://pythonnet.github.io/>`_."
msgstr ""
"此实现实际上使用了 CPython 实现，但是属于 .NET 托管应用并且可以引入 .NET 类库。它的创造者是 Brian "
"Lloyd。想了解详情可访问 `Python for .NET 主页 <https://pythonnet.github.io/>`_。"

#: ../../reference/introduction.rst:65
msgid "IronPython"
msgstr "IronPython"

#: ../../reference/introduction.rst:66
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete Python "
"implementation that generates IL, and compiles Python code directly to .NET "
"assemblies.  It was created by Jim Hugunin, the original creator of Jython."
"  For more information, see `the IronPython website "
"<https://ironpython.net/>`_."
msgstr ""
"另一个 .NET 版 Python 实现，不同于 Python.NET，这是一个生成 IL 的完整 Python 实现，并会将 Python "
"代码直接编译为 .NET 程序集。 它的创造者就是当初创造 Jython 的 Jim Hugunin。 想了解更多信息，请参看 `IronPython "
"网站 <https://ironpython.net/>`_。"

#: ../../reference/introduction.rst:71
msgid "PyPy"
msgstr "PyPy"

#: ../../reference/introduction.rst:72
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like stackless "
"support and a Just in Time compiler. One of the goals of the project is to "
"encourage experimentation with the language itself by making it easier to "
"modify the interpreter (since it is written in Python).  Additional "
"information is available on `the PyPy project's home page "
"<https://pypy.org/>`_."
msgstr ""
"一个完全使用 Python 语言编写的 Python 实现。 它支持多个其他实现所没有的高级特性，例如非栈式支持和实时编译器等。 "
"此项目的目标之一是通过允许方便地修改解释器（因为它是用 Python 编写的）来鼓励对语言本身的试验。 更多信息可在 `PyPy 项目主页 "
"<https://pypy.org/>`_ 获取。"

#: ../../reference/introduction.rst:79
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond what's "
"covered in the standard Python documentation.  Please refer to the "
"implementation-specific documentation to determine what else you need to "
"know about the specific implementation you're using."
msgstr ""
"以上这些实现都可能在某些方面与此参考文档手册的描述有所差异，或是引入了超出标准 Python "
"文档范围的特定信息。请参考它们各自的专门文档，以确定你正在使用的这个实现有哪些你需要了解的东西。"

#: ../../reference/introduction.rst:89
msgid "Notation"
msgstr "标注"

#: ../../reference/introduction.rst:93
msgid ""
"The descriptions of lexical analysis and syntax use a grammar notation that "
"is a mixture of `EBNF "
"<https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>`_ and `PEG"
" <https://en.wikipedia.org/wiki/Parsing_expression_grammar>`_. For example:"
msgstr ""
"词法分析和语法的描述采用混合了 `EBNF "
"<https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>`_ 与 `PEG "
"<https://en.wikipedia.org/wiki/Parsing_expression_grammar>`_ 的语法标记形式。 例如："

#: ../../reference/introduction.rst:106
msgid ""
"In this example, the first line says that a ``name`` is a ``letter`` "
"followed by a sequence of zero or more ``letter``\\ s, ``digit``\\ s, and "
"underscores. A ``letter`` in turn is any of the single characters ``'a'`` "
"through ``'z'`` and ``A`` through ``Z``; a ``digit`` is a single character "
"from ``0`` to ``9``."
msgstr ""
"在这个示例中，第一行是说 ``name`` 是一个 ``letter`` 后面跟由零个或多个 ``letter``, ``digit`` "
"和下划线组成的序列。 而 ``letter`` 则是从 ``'a'`` 到 ``'z'`` 以及从 ``A`` 到 ``Z`` "
"的任意单个字符；``digit`` 是从 ``0`` 到 ``9`` 的任意单个字符。"

#: ../../reference/introduction.rst:112
msgid ""
"Each rule begins with a name (which identifies the rule that's being "
"defined) followed by a colon, ``:``. The definition to the right of the "
"colon uses the following syntax elements:"
msgstr "每条规则以一个名称打头（它用来标识所定义的规则）后面跟一个冒号 ``:``。 冒号右边的定义使用下列语法元素："

#: ../../reference/introduction.rst:116
msgid ""
"``name``: A name refers to another rule. Where possible, it is a link to the"
" rule's definition."
msgstr "``name``: 一个指向其他规则的名称。 如果可能，它将是一个指向规则定义的链接。"

#: ../../reference/introduction.rst:119
msgid ""
"``TOKEN``: An uppercase name refers to a :term:`token`. For the purposes of "
"grammar definitions, tokens are the same as rules."
msgstr "``TOKEN``: 一个指向特定 :term:`token` 的大写形式的名称。 对于语法定义的场景，token 与规则是一回事。"

#: ../../reference/introduction.rst:122
msgid ""
"``\"text\"``, ``'text'``: Text in single or double quotes must match "
"literally (without the quotes). The type of quote is chosen according to the"
" meaning of ``text``:"
msgstr ""
"``\"text\"``, ``'text'``: 单引号或双引号内的文本必须在字面上匹配（不带引号）。 引号的类型将根据 ``text`` "
"的含义来选择："

#: ../../reference/introduction.rst:126
msgid "``'if'``: A name in single quotes denotes a :ref:`keyword <keywords>`."
msgstr "``'if'``: 单引号内的名称标记了一个 :ref:`关键字 <keywords>`。"

#: ../../reference/introduction.rst:127
msgid ""
"``\"case\"``: A name in double quotes denotes a :ref:`soft-keyword <soft-"
"keywords>`."
msgstr "``\"case\"``：双引号内的名称表示一个 :ref:`软关键字 <soft-keywords>`。"

#: ../../reference/introduction.rst:129
msgid ""
"``'@'``: A non-letter symbol in single quotes denotes an "
":py:data:`~token.OP` token, that is, a :ref:`delimiter <delimiters>` or "
":ref:`operator <operators>`."
msgstr ""
"``'@'``: 单引号中的一个非字母符号表示一个 :py:data:`~token.OP` 记号，即 :ref:`定界符 <delimiters>` "
"或 :ref:`运算符 <operators>`。"

#: ../../reference/introduction.rst:133
msgid ""
"``e1 e2``: Items separated only by whitespace denote a sequence. Here, "
"``e1`` must be followed by ``e2``."
msgstr "``e1 e2``：仅用空格分隔的项表示一个序列。在这里，``e1``后面必须跟着``e2``。"

#: ../../reference/introduction.rst:135
msgid ""
"``e1 | e2``: A vertical bar is used to separate alternatives. It denotes "
"PEG's \"ordered choice\": if ``e1`` matches, ``e2`` is not considered. In "
"traditional PEG grammars, this is written as a slash, ``/``, rather than a "
"vertical bar. See :pep:`617` for more background and details."
msgstr ""
"``e1 | e2``: 竖条用于分隔选项。它表示 PEG 的“有序选择”: 如果匹配 ``e1``，则不考虑 ``e2``。 在传统的 PEG "
"语法中，它被写成斜杠 ``/``，而不是竖条。 有关更多背景和详细信息，请参阅 :pep:`617`。"

#: ../../reference/introduction.rst:141
msgid "``e*``: A star means zero or more repetitions of the preceding item."
msgstr "``e*``：星号表示前一项重复零次或多次。"

#: ../../reference/introduction.rst:142
msgid "``e+``: Likewise, a plus means one or more repetitions."
msgstr "``e+``：同样，加号表示一次或多次重复。"

#: ../../reference/introduction.rst:143
msgid ""
"``[e]``: A phrase enclosed in square brackets means zero or one occurrences."
" In other words, the enclosed phrase is optional."
msgstr "``[e]``：用方括号括起来的短语表示出现零次或一次。换句话说，所包含的短语是可选的。"

#: ../../reference/introduction.rst:145
msgid ""
"``e?``: A question mark has exactly the same meaning as square brackets: the"
" preceding item is optional."
msgstr "``e?``：问号与方括号的含义完全相同：前一项为可选项。"

#: ../../reference/introduction.rst:147
msgid "``(e)``: Parentheses are used for grouping."
msgstr "``(e)``：括号用于分组。"

#: ../../reference/introduction.rst:149
msgid ""
"The following notation is only used in :ref:`lexical definitions <notation-"
"lexical-vs-syntactic>`."
msgstr "以下符号表示法仅在 :ref:`词法定义 <notation-lexical-vs-syntactic>` 中使用。"

#: ../../reference/introduction.rst:152
msgid ""
"``\"a\"...\"z\"``: Two literal characters separated by three dots mean a "
"choice of any single character in the given (inclusive) range of ASCII "
"characters."
msgstr "``\"a\"...\"z\"``:  由三个点分隔的两个字面值字符表示在给定（包括）ASCII 字符范围内选择任何单个字符。 "

#: ../../reference/introduction.rst:154
msgid ""
"``<...>``: A phrase between angular brackets gives an informal description "
"of the matched symbol (for example, ``<any ASCII character except "
"\"\\\">``), or an abbreviation that is defined in nearby text (for example, "
"``<Lu>``)."
msgstr ""
"``<...>``：尖括号之间的短语给出了匹配符号的非正式描述（例如，``<any ASCII character except "
"\"\\\">``），或者在附近文本中定义的缩写（例如，``<Lu>``）。"

#: ../../reference/introduction.rst:160
msgid ""
"Some definitions also use *lookaheads*, which indicate that an element must "
"(or must not) match at a given position, but without consuming any input:"
msgstr "部分定义还使用了*前瞻断言*（lookaheads），这类断言用于指示某个元素必须在（或不能在）特定位置匹配，但不会消耗任何输入内容。"

#: ../../reference/introduction.rst:163
msgid "``&e``: a positive lookahead (that is, ``e`` is required to match)"
msgstr "``&e``：正向肯定前瞻断言（即要求必须匹配 ``e``）"

#: ../../reference/introduction.rst:164
msgid ""
"``!e``: a negative lookahead (that is, ``e`` is required *not* to match)"
msgstr "``!e``：负向否定前瞻断言（即要求 ``e`` **必须不匹配**）"

#: ../../reference/introduction.rst:166
msgid ""
"The unary operators (``*``, ``+``, ``?``) bind as tightly as possible; the "
"vertical bar (``|``) binds most loosely."
msgstr "一元运算符（``*``、``+``、``?``）尽可能紧密地绑定；竖条（``|``）绑定最松散。"

#: ../../reference/introduction.rst:169
msgid "White space is only meaningful to separate tokens."
msgstr "空格只对分隔记号有意义。"

#: ../../reference/introduction.rst:171
msgid ""
"Rules are normally contained on a single line, but rules that are too long "
"may be wrapped:"
msgstr "规则通常包含在一行中，但太长的规则可能会被换行："

#: ../../reference/introduction.rst:180
msgid ""
"Alternatively, rules may be formatted with the first line ending at the "
"colon, and each alternative beginning with a vertical bar on a new line. For"
" example:"
msgstr "或者，规则可以格式化为第一行以冒号结束，其余每一行以竖线开始。例如："

#: ../../reference/introduction.rst:195
msgid "This does *not* mean that there is an empty first alternative."
msgstr "这并不意味着第一个选项是空的。"

#: ../../reference/introduction.rst:202
msgid "Lexical and Syntactic definitions"
msgstr "词法和语法定义"

#: ../../reference/introduction.rst:204
msgid ""
"There is some difference between *lexical* and *syntactic* analysis: the "
":term:`lexical analyzer` operates on the individual characters of the input "
"source, while the *parser* (syntactic analyzer) operates on the stream of "
":term:`tokens <token>` generated by the lexical analysis. However, in some "
"cases the exact boundary between the two phases is a CPython implementation "
"detail."
msgstr ""
"*词法分析* 和 *语法分析* 之间有一些区别: :term:`lexical analyzer` 对输入源的单个字符进行操作，而 *解析器* "
"(语法分析器) 对词法分析生成的 :term:`词元 <token>` 流进行操作。 然而，在某些情况下，这两个阶段之间的确切界限是 CPython "
"的实现细节。"

#: ../../reference/introduction.rst:211
msgid ""
"The practical difference between the two is that in *lexical* definitions, "
"all whitespace is significant. The lexical analyzer :ref:`discards "
"<whitespace>` all whitespace that is not converted to tokens like "
":data:`token.INDENT` or :data:`~token.NEWLINE`. *Syntactic* definitions then"
" use these tokens, rather than source characters."
msgstr ""
"两者之间的实际区别在于，在 *词法* 定义中，所有空白符都是重要的。 词法分析器会 :ref:`丢弃 <whitespace>` 所有未转换为 "
":data:`token.INDENT` 或 :data:`~token.NEWLINE` 等记号的空白符。 *语法* "
"定义随后使用这些记号，而不是源字符。"

#: ../../reference/introduction.rst:217
msgid ""
"This documentation uses the same BNF grammar for both styles of definitions."
" All uses of BNF in the next chapter (:ref:`lexical`) are lexical "
"definitions; uses in subsequent chapters are syntactic definitions."
msgstr ""
"本文档对两种定义样式使用相同的BNF语法。下一章（:ref:`lexical`）中BNF的所有用法都是词法上的定义；后面章节中的用法是语法定义。"

#: ../../reference/introduction.rst:91
msgid "BNF"
msgstr "BNF"

#: ../../reference/introduction.rst:91
msgid "grammar"
msgstr "语法"

#: ../../reference/introduction.rst:91
msgid "syntax"
msgstr "句法"

#: ../../reference/introduction.rst:91
msgid "notation"
msgstr "标注"

#: ../../reference/introduction.rst:197
msgid "lexical definitions"
msgstr "语言定义"
