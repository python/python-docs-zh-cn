# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-03 15:14+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../using/cmdline.rst:9
msgid "Command line and environment"
msgstr "命令行与环境"

#: ../../using/cmdline.rst:11
msgid ""
"The CPython interpreter scans the command line and the environment for "
"various settings."
msgstr "为获取各种设置信息，CPython 解析器会扫描命令行与环境。"

#: ../../using/cmdline.rst:16
msgid ""
"Other implementations' command line schemes may differ.  See "
":ref:`implementations` for further resources."
msgstr "其他实现的命令行方案可能会有所不同。 详见 :ref:`implementations`。"

#: ../../using/cmdline.rst:23
msgid "Command line"
msgstr "命令行"

#: ../../using/cmdline.rst:25
msgid "When invoking Python, you may specify any of these options::"
msgstr "调用 Python 时，可以指定下列任意选项："

#: ../../using/cmdline.rst:27
msgid ""
"python [-bBdEhiIOPqRsSuvVWx?] [-c command | -m module-name | script | - ] "
"[args]"
msgstr ""
"python [-bBdEhiIOPqRsSuvVWx?] [-c command | -m module-name | script | - ] "
"[args]"

#: ../../using/cmdline.rst:29
msgid ""
"The most common use case is, of course, a simple invocation of a script::"
msgstr "最常见的用例是启动时执行脚本："

#: ../../using/cmdline.rst:31
msgid "python myscript.py"
msgstr "python myscript.py"

#: ../../using/cmdline.rst:37
msgid "Interface options"
msgstr "接口选项"

#: ../../using/cmdline.rst:39
msgid ""
"The interpreter interface resembles that of the UNIX shell, but provides "
"some additional methods of invocation:"
msgstr "解释器接口类似于 UNIX shell，但提供了额外的调用方法:"

#: ../../using/cmdline.rst:42
msgid ""
"When called with standard input connected to a tty device, it prompts for "
"commands and executes them until an EOF (an end-of-file character, you can "
"produce that with :kbd:`Ctrl-D` on UNIX or :kbd:`Ctrl-Z, Enter` on Windows) "
"is read. For more on interactive mode, see :ref:`tut-interac`."
msgstr ""
"当调用时附带连接到某个 tty 设备的标准输入时，它会提示输入命令并执行它们直至读到一个 EOF (文件结束字符，你可以在 UNIX 上按 "
":kbd:`Ctrl-D` 或在 Windows 上按 :kbd:`Ctrl-Z, Enter` 来产生此字符）。 有关交互模式的更多信息，请参阅 "
":ref:`tut-interac`。"

#: ../../using/cmdline.rst:46
msgid ""
"When called with a file name argument or with a file as standard input, it "
"reads and executes a script from that file."
msgstr "用文件名参数或以标准输入文件调用时，读取，并执行该脚本文件。"

#: ../../using/cmdline.rst:48
msgid ""
"When called with a directory name argument, it reads and executes an "
"appropriately named script from that directory."
msgstr "用目录名参数调用时，从该目录读取、执行适当名称的脚本。"

#: ../../using/cmdline.rst:50
msgid ""
"When called with ``-c command``, it executes the Python statement(s) given "
"as *command*.  Here *command* may contain multiple statements separated by "
"newlines. Leading whitespace is significant in Python statements!"
msgstr ""
"用 ``-c command`` 调用时，执行 *command* 表示的 Python 语句。*command* "
"可以包含用换行符分隔的多条语句。注意，前导空白字符在 Python 语句中非常重要！"

#: ../../using/cmdline.rst:53
msgid ""
"When called with ``-m module-name``, the given module is located on the "
"Python module path and executed as a script."
msgstr "用 ``-m module-name`` 调用时，在 Python 模块路径中查找指定的模块，并将其作为脚本执行。"

#: ../../using/cmdline.rst:56
msgid ""
"In non-interactive mode, the entire input is parsed before it is executed."
msgstr "非交互模式下，先解析全部输入，再执行。"

#: ../../using/cmdline.rst:58
msgid ""
"An interface option terminates the list of options consumed by the "
"interpreter, all consecutive arguments will end up in :data:`sys.argv` -- "
"note that the first element, subscript zero (``sys.argv[0]``), is a string "
"reflecting the program's source."
msgstr ""
"接口选项会终结解释器读入的选项列表，所有后续参数都在 :data:`sys.argv` 里 -- "
"注意，首个元素，即下标为零的元素（``sys.argv[0]``）是表示程序来源的字符串。"

#: ../../using/cmdline.rst:65
msgid ""
"Execute the Python code in *command*.  *command* can be one or more "
"statements separated by newlines, with significant leading whitespace as in "
"normal module code."
msgstr ""
"执行 *command* 中的 Python 代码。*command* "
"可以是一条语句，也可以是用换行符分隔的多条语句，其中，前导空白字符与普通模块代码中的作用一样。"

#: ../../using/cmdline.rst:69
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-c\"`` and the current directory will be added to the start of "
":data:`sys.path` (allowing modules in that directory to be imported as top "
"level modules)."
msgstr ""
"使用此选项时，:data:`sys.argv` 的首个元素为 ``\"-c\"``，并会把当前目录加入至 :data:`sys.path` "
"开头（让该目录中的模块作为顶层模块导入）。"

#: ../../using/cmdline.rst:74
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_command`` with "
"argument ``command``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``cpython.run_command`` 并附带参数 ``command``。"

#: ../../using/cmdline.rst:78
msgid ""
"Search :data:`sys.path` for the named module and execute its contents as the"
" :mod:`__main__` module."
msgstr "在 :data:`sys.path` 中搜索指定模块，并以 :mod:`__main__` 模块执行其内容。"

#: ../../using/cmdline.rst:81
msgid ""
"Since the argument is a *module* name, you must not give a file extension "
"(``.py``).  The module name should be a valid absolute Python module name, "
"but the implementation may not always enforce this (e.g. it may allow you to"
" use a name that includes a hyphen)."
msgstr ""
"该参数是 *模块名*，请勿输入文件扩展名（``.py``）。模块名应为有效的绝对 Python 模块名，但本实现对此不作强制要求（例如，允许使用含连字符"
" ``-`` 的名称）。"

#: ../../using/cmdline.rst:86
msgid ""
"Package names (including namespace packages) are also permitted. When a "
"package name is supplied instead of a normal module, the interpreter will "
"execute ``<pkg>.__main__`` as the main module. This behaviour is "
"deliberately similar to the handling of directories and zipfiles that are "
"passed to the interpreter as the script argument."
msgstr ""
"包名称（包括命名空间包）也允许使用。使用包名称而不是普通模块名时，解释器把 ``<pkg>.__main__`` "
"作为主模块执行。此行为特意被设计为与作为脚本参数传递给解释器的目录和 zip 文件的处理方式类似。"

#: ../../using/cmdline.rst:95
msgid ""
"This option cannot be used with built-in modules and extension modules "
"written in C, since they do not have Python module files. However, it can "
"still be used for precompiled modules, even if the original source file is "
"not available."
msgstr ""
"此选项不适用于内置模块和以 C 编写的扩展模块，因为它们并没有对应的 Python 模块文件。 但是它仍然适用于预编译的模块，即使没有可用的初始源文件。"

#: ../../using/cmdline.rst:100
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be the "
"full path to the module file (while the module file is being located, the "
"first element will be set to ``\"-m\"``). As with the :option:`-c` option, "
"the current directory will be added to the start of :data:`sys.path`."
msgstr ""
"如果给出此选项，:data:`sys.argv` 的首个元素将为模块文件的完整路径 (在定位模块文件期间，首个元素将设为 ``\"-m\"``)。 与 "
":option:`-c` 选项一样，当前目录将被加入 :data:`sys.path` 的开头。"

#: ../../using/cmdline.rst:105
msgid ""
":option:`-I` option can  be used to run the script in isolated mode where "
":data:`sys.path` contains neither the current directory nor the user's site-"
"packages directory. All ``PYTHON*`` environment variables are ignored, too."
msgstr ""
":option:`-I` 选项可用来在隔离模式下运行脚本，此模式中 :data:`sys.path` 既不包含当前目录也不包含用户的 site-"
"packages 目录。 所有 ``PYTHON*`` 环境变量也都会被忽略。"

#: ../../using/cmdline.rst:110
msgid ""
"Many standard library modules contain code that is invoked on their "
"execution as a script.  An example is the :mod:`timeit` module::"
msgstr "许多标准库模块都包含在执行时，以脚本方式调用的代码。例如 :mod:`timeit` 模块："

#: ../../using/cmdline.rst:113
msgid ""
"python -m timeit -s \"setup here\" \"benchmarked code here\"\n"
"python -m timeit -h # for details"
msgstr ""
"python -m timeit -s \"setup here\" \"benchmarked code here\"\n"
"python -m timeit -h # 获取详情"

#: ../../using/cmdline.rst:116
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_module`` with "
"argument ``module-name``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``cpython.run_module`` 并附带参数 ``module-name``。"

#: ../../using/cmdline.rst:119
msgid ":func:`runpy.run_module`"
msgstr ":func:`runpy.run_module`"

#: ../../using/cmdline.rst:120 ../../using/cmdline.rst:172
msgid "Equivalent functionality directly available to Python code"
msgstr "Python 代码可以直接使用的等效功能"

#: ../../using/cmdline.rst:122
msgid ":pep:`338` -- Executing modules as scripts"
msgstr ":pep:`338` -- 将模块作为脚本执行"

#: ../../using/cmdline.rst:124
msgid "Supply the package name to run a ``__main__`` submodule."
msgstr "提供包名称来运行 ``__main__`` 子模块。"

#: ../../using/cmdline.rst:127
msgid "namespace packages are also supported"
msgstr "同样支持命名空间包"

#: ../../using/cmdline.rst:134
msgid ""
"Read commands from standard input (:data:`sys.stdin`).  If standard input is"
" a terminal, :option:`-i` is implied."
msgstr "从标准输入 (:data:`sys.stdin`) 读取命令。标准输入为终端时，使用 :option:`-i`。"

#: ../../using/cmdline.rst:137
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-\"`` and the current directory will be added to the start of "
":data:`sys.path`."
msgstr ""
"使用此选项时，:data:`sys.argv` 的第一个元素是 ``\"-\"``， 同时，把当前目录加入 :data:`sys.path` 开头。"

#: ../../using/cmdline.rst:141 ../../using/cmdline.rst:796
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_stdin`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``cpython.run_stdin``。"

#: ../../using/cmdline.rst:147
msgid ""
"Execute the Python code contained in *script*, which must be a filesystem "
"path (absolute or relative) referring to either a Python file, a directory "
"containing a ``__main__.py`` file, or a zipfile containing a ``__main__.py``"
" file."
msgstr ""
"执行 *script* 中的 Python 代码，该参数应为（绝对或相对）文件系统路径，指向 Python 文件、包含 ``__main__.py`` "
"文件的目录，或包含 ``__main__.py`` 文件的 zip 文件。"

#: ../../using/cmdline.rst:152
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be the "
"script name as given on the command line."
msgstr "给出此选项时，:data:`sys.argv` 的第一个元素就是在命令行中指定的脚本名称。"

#: ../../using/cmdline.rst:155
msgid ""
"If the script name refers directly to a Python file, the directory "
"containing that file is added to the start of :data:`sys.path`, and the file"
" is executed as the :mod:`__main__` module."
msgstr ""
"如果脚本名称直接指向 Python 文件，则把该文件所在目录加入 :data:`sys.path` 的开头，并且把该文件当作 "
":mod:`__main__` 模块来执行。"

#: ../../using/cmdline.rst:159
msgid ""
"If the script name refers to a directory or zipfile, the script name is "
"added to the start of :data:`sys.path` and the ``__main__.py`` file in that "
"location is executed as the :mod:`__main__` module."
msgstr ""
"如果脚本名称指向目录或 zip 文件，则把脚本名加入 :data:`sys.path` 的开头，并把该位置中的 ``__main__.py`` 文件当作"
" :mod:`__main__` 模块来执行。"

#: ../../using/cmdline.rst:163
msgid ""
":option:`-I` option can  be used to run the script in isolated mode where "
":data:`sys.path` contains neither the script's directory nor the user's "
"site-packages directory. All ``PYTHON*`` environment variables are ignored, "
"too."
msgstr ""
":option:`-I` 选项可用来在隔离模式下运行脚本，此模式中 :data:`sys.path` 既不包含当前目录也不包含用户的 site-"
"packages 目录。 所有 ``PYTHON*`` 环境变量也都会被忽略。"

#: ../../using/cmdline.rst:168
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_file`` with "
"argument ``filename``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``cpython.run_file`` 并附带参数 ``filename``。"

#: ../../using/cmdline.rst:171
msgid ":func:`runpy.run_path`"
msgstr ":func:`runpy.run_path`"

#: ../../using/cmdline.rst:175
msgid ""
"If no interface option is given, :option:`-i` is implied, ``sys.argv[0]`` is"
" an empty string (``\"\"``) and the current directory will be added to the "
"start of :data:`sys.path`.  Also, tab-completion and history editing is "
"automatically enabled, if available on your platform (see :ref:`rlcompleter-"
"config`)."
msgstr ""
"未给出接口选项时，使用 :option:`-i`，``sys.argv[0]`` 为空字符串 (``\"\"``)，并把当前目录加至 "
":data:`sys.path` 的开头。 此外，如果系统支持，还能自动启用 tab 补全和历史编辑（参见 :ref:`rlcompleter-"
"config`）。"

#: ../../using/cmdline.rst:181
msgid ":ref:`tut-invoking`"
msgstr ":ref:`tut-invoking`"

#: ../../using/cmdline.rst:183
msgid "Automatic enabling of tab-completion and history editing."
msgstr "自动启用 tab 补全和历史编辑。"

#: ../../using/cmdline.rst:190
msgid "Generic options"
msgstr "通用选项"

#: ../../using/cmdline.rst:196
msgid ""
"Print a short description of all command line options and corresponding "
"environment variables and exit."
msgstr "打印所有命令行选项及对应环境变量的简短描述然后退出。"

#: ../../using/cmdline.rst:201
msgid ""
"Print a short description of Python-specific environment variables and exit."
msgstr "打印 Python 专属环境变量的简短描述然后退出。"

#: ../../using/cmdline.rst:208
msgid ""
"Print a description of implementation-specific :option:`-X` options and "
"exit."
msgstr "打印实现专属 :option:`-X` 选项的简短描述然后退出。"

#: ../../using/cmdline.rst:215
msgid "Print complete usage information and exit."
msgstr "打印完整使用信息然后退出。"

#: ../../using/cmdline.rst:222
msgid "Print the Python version number and exit.  Example output could be:"
msgstr "输出 Python 版本号并退出。示例如下："

#: ../../using/cmdline.rst:224
msgid "Python 3.8.0b2+"
msgstr "Python 3.8.0b2+"

#: ../../using/cmdline.rst:228
msgid "When given twice, print more information about the build, like:"
msgstr "输入两次 ``V`` 选项时，输出更多构建信息，例如："

#: ../../using/cmdline.rst:230
msgid ""
"Python 3.8.0b2+ (3.8:0c076caaa8, Apr 20 2019, 21:55:00)\n"
"[GCC 6.2.0 20161005]"
msgstr ""
"Python 3.8.0b2+ (3.8:0c076caaa8, Apr 20 2019, 21:55:00)\n"
"[GCC 6.2.0 20161005]"

#: ../../using/cmdline.rst:235
msgid "The ``-VV`` option."
msgstr "``-VV`` 选项。"

#: ../../using/cmdline.rst:242
msgid "Miscellaneous options"
msgstr "其他选项"

#: ../../using/cmdline.rst:246
msgid ""
"Issue a warning when converting :class:`bytes` or :class:`bytearray` to "
":class:`str` without specifying encoding or comparing :class:`!bytes` or "
":class:`!bytearray` with :class:`!str` or :class:`!bytes` with :class:`int`."
" Issue an error when the option is given twice (:option:`!-bb`)."
msgstr ""
"在将 :class:`bytes` 或 :class:`bytearray` 转换为 :class:`str` 时未指定编码格式或在将 "
":class:`!bytes` 或 :class:`!bytearray` 与 :class:`!str` 或者在将 :class:`!bytes` 与"
" :class:`int` 进行比较时将发出警告。 当选项被给出两次 (:option:`!-bb`) 时则会报错。"

#: ../../using/cmdline.rst:251
msgid "Affects also comparisons of :class:`bytes` with :class:`int`."
msgstr "也会影响 :class:`bytes` 与 :class:`int` 的比较。"

#: ../../using/cmdline.rst:256
msgid ""
"If given, Python won't try to write ``.pyc`` files on the import of source "
"modules.  See also :envvar:`PYTHONDONTWRITEBYTECODE`."
msgstr ""
"给出此选项时，Python 不在导入源模块时写入 ``.pyc`` 文件。另请参阅 :envvar:`PYTHONDONTWRITEBYTECODE`。"

#: ../../using/cmdline.rst:262
msgid ""
"Control the validation behavior of hash-based ``.pyc`` files. See :ref:`pyc-"
"invalidation`. When set to ``default``, checked and unchecked hash-based "
"bytecode cache files are validated according to their default semantics. "
"When set to ``always``, all hash-based ``.pyc`` files, whether checked or "
"unchecked, are validated against their corresponding source file. When set "
"to ``never``, hash-based ``.pyc`` files are not validated against their "
"corresponding source files."
msgstr ""
"控制基于哈希值的 ``.pyc`` 文件的验证行为。 参见 :ref:`pyc-invalidation`。 当设为 ``default`` "
"时，已选定和未选定的基于哈希值的字节码缓存文件将根据其默认语义进行验证。 当设为 ``always`` 时，所有基于哈希值的 ``.pyc`` "
"文件，不论是已选定还是未选定的都将根据其对应的源文件进行验证。 当设为 ``never`` 时，基于哈希值的 ``.pyc`` "
"文件将不会根据其对应的源文件进行验证。"

#: ../../using/cmdline.rst:270
msgid ""
"The semantics of timestamp-based ``.pyc`` files are unaffected by this "
"option."
msgstr "基于时间戳的 ``.pyc`` 文件的语义不会受此选项影响。"

#: ../../using/cmdline.rst:276
msgid ""
"Turn on parser debugging output (for expert only). See also the "
":envvar:`PYTHONDEBUG` environment variable."
msgstr "启用解析器调试输出（仅供专家查看）。 另请参见 :envvar:`PYTHONDEBUG` 环境变量。"

#: ../../using/cmdline.rst:279
msgid ""
"This option requires a :ref:`debug build of Python <debug-build>`, otherwise"
" it's ignored."
msgstr "此选项需要 :ref:`Python 的调试构建版 <debug-build>`，否则它将被忽略。"

#: ../../using/cmdline.rst:285
msgid ""
"Ignore all ``PYTHON*`` environment variables, e.g. :envvar:`PYTHONPATH` and "
":envvar:`PYTHONHOME`, that might be set."
msgstr ""
"忽略所有 ``PYTHON*`` 环境变量，例如可能已设置的 :envvar:`PYTHONPATH` 和 :envvar:`PYTHONHOME`。"

#: ../../using/cmdline.rst:288
msgid "See also the :option:`-P` and :option:`-I` (isolated) options."
msgstr "另请参阅 :option:`-P` 和 :option:`-I` (隔离) 选项。"

#: ../../using/cmdline.rst:293
msgid "Enter interactive mode after execution."
msgstr "在执行之后进入交互模式。"

#: ../../using/cmdline.rst:295
msgid ""
"Using the :option:`-i` option will enter interactive mode in any of the "
"following circumstances\\:"
msgstr "使用 :option:`-i` 选项将在下列任一情况下进入交互模式："

#: ../../using/cmdline.rst:297
msgid "When a script is passed as first argument"
msgstr "当将脚本作为第一个参数传入"

#: ../../using/cmdline.rst:298
msgid "When the :option:`-c` option is used"
msgstr "当使用了 :option:`-c` 选项"

#: ../../using/cmdline.rst:299
msgid "When the :option:`-m` option is used"
msgstr "当使用了 :option:`-m` 选项"

#: ../../using/cmdline.rst:301
msgid ""
"Interactive mode will start even when :data:`sys.stdin` does not appear to "
"be a terminal. The :envvar:`PYTHONSTARTUP` file is not read."
msgstr ""
"交互模式即使在 :data:`sys.stdin` 并非一个终端时也会启动。 :envvar:`PYTHONSTARTUP` 文件不会被读取。"

#: ../../using/cmdline.rst:304
msgid ""
"This can be useful to inspect global variables or a stack trace when a "
"script raises an exception.  See also :envvar:`PYTHONINSPECT`."
msgstr "本选项用于，脚本触发异常时，检查全局变量或堆栈回溯。 详见 :envvar:`PYTHONINSPECT`。"

#: ../../using/cmdline.rst:310
msgid ""
"Run Python in isolated mode. This also implies :option:`-E`, :option:`-P` "
"and :option:`-s` options."
msgstr "以隔离模式运行 Python。 这还将应用 :option:`-E`, :option:`-P` 和 :option:`-s` 选项。"

#: ../../using/cmdline.rst:313
msgid ""
"In isolated mode :data:`sys.path` contains neither the script's directory "
"nor the user's site-packages directory. All ``PYTHON*`` environment "
"variables are ignored, too. Further restrictions may be imposed to prevent "
"the user from injecting malicious code."
msgstr ""
"在隔离模式下 :data:`sys.path` 既不包含脚本所在目录也不包含用户的 site-packages 目录。 所有 ``PYTHON*`` "
"环境变量也都会被忽略。 还可以施加更进一步的限制以防止用户注入恶意代码。"

#: ../../using/cmdline.rst:323
msgid ""
"Remove assert statements and any code conditional on the value of "
":const:`__debug__`.  Augment the filename for compiled (:term:`bytecode`) "
"files by adding ``.opt-1`` before the ``.pyc`` extension (see :pep:`488`).  "
"See also :envvar:`PYTHONOPTIMIZE`."
msgstr ""
"移除 assert 语句以及任何以 :const:`__debug__` 的值作为条件的代码。 通过在 ``.pyc`` 扩展名之前添加 "
"``.opt-1`` 来扩充已编译文件 (:term:`bytecode`) 的文件名  (参见 :pep:`488`)。 另请参阅 "
":envvar:`PYTHONOPTIMIZE`。"

#: ../../using/cmdline.rst:328 ../../using/cmdline.rst:338
msgid "Modify ``.pyc`` filenames according to :pep:`488`."
msgstr "依据 :pep:`488` 修改 ``.pyc`` 文件名。"

#: ../../using/cmdline.rst:334
msgid ""
"Do :option:`-O` and also discard docstrings.  Augment the filename for "
"compiled (:term:`bytecode`) files by adding ``.opt-2`` before the ``.pyc`` "
"extension (see :pep:`488`)."
msgstr ""
"在启用 :option:`-O` 的同时丢弃文档字符串。 通过在 ``.pyc`` 扩展名之前添加 ``.opt-2`` 来扩展已编译文件 "
"(:term:`bytecode`) 的文件名 (参见 :pep:`488`)。"

#: ../../using/cmdline.rst:344
msgid "Don't prepend a potentially unsafe path to :data:`sys.path`:"
msgstr "不要将具有潜在不安全性的路径附加到 :data:`sys.path`:"

#: ../../using/cmdline.rst:346
msgid ""
"``python -m module`` command line: Don't prepend the current working "
"directory."
msgstr "``python -m module`` 命令行: 不要附加当前工作目录。"

#: ../../using/cmdline.rst:348
msgid ""
"``python script.py`` command line: Don't prepend the script's directory. If "
"it's a symbolic link, resolve symbolic links."
msgstr "``python script.py`` 命令行: 不要附加脚本所在目录。 如果是一个符号链接，则会解析符号链接。"

#: ../../using/cmdline.rst:350
msgid ""
"``python -c code`` and ``python`` (REPL) command lines: Don't prepend an "
"empty string, which means the current working directory."
msgstr "``python -c code`` 和 ``python`` (REPL) 命令行: 不要附加空字符串，这表示当前工作目录。"

#: ../../using/cmdline.rst:353
msgid ""
"See also the :envvar:`PYTHONSAFEPATH` environment variable, and :option:`-E`"
" and :option:`-I` (isolated) options."
msgstr ""
"另请参阅 :envvar:`PYTHONSAFEPATH` 环境变量，以及 :option:`-E` 和 :option:`-I` (隔离) 选项。"

#: ../../using/cmdline.rst:361
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr "即使在交互模式下也不显示版权和版本信息。"

#: ../../using/cmdline.rst:368
msgid ""
"Turn on hash randomization. This option only has an effect if the "
":envvar:`PYTHONHASHSEED` environment variable is set to anything other than "
"``random``, since hash randomization is enabled by default."
msgstr ""

#: ../../using/cmdline.rst:372
msgid ""
"On previous versions of Python, this option turns on hash randomization, so "
"that the :meth:`~object.__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"在之前版本的 Python 中，此选项会启用哈希随机化，以将字符串和字节串对象的 :meth:`~object.__hash__` "
"值用不可预测的随机值“加盐”。 虽然它们在单个 Python 进程内将保持恒定，但是在重复唤起的 Python 进程间它们将是不可预测的。"

#: ../../using/cmdline.rst:378
msgid ""
"Hash randomization is intended to provide protection against a denial-of-"
"service caused by carefully chosen inputs that exploit the worst case "
"performance of a dict construction, *O*\\ (*n*\\ :sup:`2`) complexity.  See "
"http://ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"哈希随机化旨在针对由精心选择的输入引起的拒绝服务攻击提供防护，这种输入利用了构造 dict 在最坏情况下的性能即 *O*\\ (*n*\\ "
":sup:`2`) 复杂度。 请参阅 http://ocert.org/advisories/ocert-2011-003.html 了解详情。"

#: ../../using/cmdline.rst:383
msgid ""
":envvar:`PYTHONHASHSEED` allows you to set a fixed value for the hash seed "
"secret."
msgstr ":envvar:`PYTHONHASHSEED` 允许你为哈希种子密码设置一个固定值。"

#: ../../using/cmdline.rst:388
msgid "The option is no longer ignored."
msgstr "此选项不会再被忽略。"

#: ../../using/cmdline.rst:394
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to "
":data:`sys.path`."
msgstr ""
"不要将 :data:`用户 site-packages 目录 <site.USER_SITE>` 添加到 :data:`sys.path`。"

#: ../../using/cmdline.rst:397
msgid "See also :envvar:`PYTHONNOUSERSITE`."
msgstr "另请参阅 :envvar:`PYTHONNOUSERSITE`。"

#: ../../using/cmdline.rst:401 ../../using/cmdline.rst:893
#: ../../using/cmdline.rst:905
msgid ":pep:`370` -- Per user site-packages directory"
msgstr ":pep:`370` -- 分用户的 site-packages 目录"

#: ../../using/cmdline.rst:406
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call "
":func:`site.main` if you want them to be triggered)."
msgstr ""
"禁用 :mod:`site` 的导入及其所附带的基于站点对 :data:`sys.path` 的操作。 如果 :mod:`site` "
"会在稍后被显式地导入也会禁用这些操作 (如果你希望触发它们则应调用 :func:`site.main`)。"

#: ../../using/cmdline.rst:414
msgid ""
"Force the stdout and stderr streams to be unbuffered.  This option has no "
"effect on the stdin stream."
msgstr "强制 stdout 和 stderr 流不使用缓冲。 此选项对 stdin 流无影响。"

#: ../../using/cmdline.rst:417
msgid "See also :envvar:`PYTHONUNBUFFERED`."
msgstr "另请参阅 :envvar:`PYTHONUNBUFFERED`。"

#: ../../using/cmdline.rst:419
msgid "The text layer of the stdout and stderr streams now is unbuffered."
msgstr "stdout 和 stderr 流在文本层现在不使用缓冲。"

#: ../../using/cmdline.rst:425
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  When given twice "
"(:option:`!-vv`), print a message for each file that is checked for when "
"searching for a module.  Also provides information on module cleanup at "
"exit."
msgstr ""
"每次在初始化模块时会打印一条信息，显示被加载的地方（文件名或内置模块名）。当给出两个v（ :option:`!-vv` "
"）时，搜索模块时会为每个文件打印一条信息。退出时模块清理的信息也会给出来。"

#: ../../using/cmdline.rst:430
msgid ""
"The :mod:`site` module reports the site-specific paths and :file:`.pth` "
"files being processed."
msgstr "由 :mod:`site` 模块可以得到将要处理的站点路径和 :file:`.pth` 文件。"

#: ../../using/cmdline.rst:434
msgid "See also :envvar:`PYTHONVERBOSE`."
msgstr "参阅 :envvar:`PYTHONVERBOSE` 。"

#: ../../using/cmdline.rst:440
msgid ""
"Warning control. Python's warning machinery by default prints warning "
"messages to :data:`sys.stderr`."
msgstr "警告信息的控制。Python 的警告机制默认将警告信息打印到  :data:`sys.stderr`。"

#: ../../using/cmdline.rst:443 ../../using/cmdline.rst:921
msgid ""
"The simplest settings apply a particular action unconditionally to all "
"warnings emitted by a process (even those that are otherwise ignored by "
"default)::"
msgstr "最简单的设置是将某个特定操作无条件地应用于进程所发出所有警告 (即使是在默认情况下会忽略的那些警告)::"

#: ../../using/cmdline.rst:447
msgid ""
"-Wdefault  # Warn once per call location\n"
"-Werror    # Convert to exceptions\n"
"-Walways   # Warn every time\n"
"-Wall      # Same as -Walways\n"
"-Wmodule   # Warn once per calling module\n"
"-Wonce     # Warn once per Python process\n"
"-Wignore   # Never warn"
msgstr ""
"-Wdefault  # 每个调用位置警告一次\n"
"-Werror    # 转换为异常\n"
"-Walways   # 每次都警告\n"
"-Wall      # 与 -Walways 相同\n"
"-Wmodule   # 每个调用模块警告一次\n"
"-Wonce     # 每个 Python 进程警告一次\n"
"-Wignore   # 从不警告"

#: ../../using/cmdline.rst:455
msgid ""
"The action names can be abbreviated as desired and the interpreter will "
"resolve them to the appropriate action name. For example, ``-Wi`` is the "
"same as ``-Wignore``."
msgstr "action 名可以根据需要进行缩写，解释器将会解析为合适的名称。例如，``-Wi`` 与 ``-Wignore`` 相同。"

#: ../../using/cmdline.rst:459
msgid "The full form of argument is::"
msgstr "完整的参数如下："

#: ../../using/cmdline.rst:461
msgid "action:message:category:module:lineno"
msgstr "action:message:category:module:lineno"

#: ../../using/cmdline.rst:463
msgid ""
"Empty fields match all values; trailing empty fields may be omitted. For "
"example ``-W ignore::DeprecationWarning`` ignores all DeprecationWarning "
"warnings."
msgstr ""
"空字段匹配所有值；尾部的空字段可以省略。例如，``-W ignore::DeprecationWarning`` 将忽略所有的 "
"DeprecationWarning 警告。"

#: ../../using/cmdline.rst:467
msgid ""
"The *action* field is as explained above but only applies to warnings that "
"match the remaining fields."
msgstr "*action* 字段如上所述，但只适用于匹配其余字段的警告。"

#: ../../using/cmdline.rst:470
msgid ""
"The *message* field must match the whole warning message; this match is "
"case-insensitive."
msgstr "*message* 字段必须与整个警告信息相匹配；不区分大小写。"

#: ../../using/cmdline.rst:473
msgid ""
"The *category* field matches the warning category (ex: "
"``DeprecationWarning``). This must be a class name; the match test whether "
"the actual warning category of the message is a subclass of the specified "
"warning category."
msgstr ""
"*category* 字段与警告类别相匹配（``DeprecationWarning`` "
"等）。必须是个类名；检测消息的实际警告类别是否为指定类别的子类。"

#: ../../using/cmdline.rst:478
msgid ""
"The *module* field matches the (fully qualified) module name; this match is "
"case-sensitive."
msgstr "*module* 字段匹配的是（完整限定）模块名称；这种匹配是大小写敏感的。"

#: ../../using/cmdline.rst:481
msgid ""
"The *lineno* field matches the line number, where zero matches all line "
"numbers and is thus equivalent to an omitted line number."
msgstr "*lineno* 字段匹配行号，其中 0 匹配所有行号，相当于省略了行号。"

#: ../../using/cmdline.rst:484
msgid ""
"Multiple :option:`-W` options can be given; when a warning matches more than"
" one option, the action for the last matching option is performed. Invalid "
":option:`-W` options are ignored (though, a warning message is printed about"
" invalid options when the first warning is issued)."
msgstr ""
"可以给出多个 :option:`-W` 选项；当某条警告信息匹配上多个选项时，将执行最后一个匹配项的操作。非法 :option:`-W` "
"选项将被忽略（不过，在触发第一条警告时，会打印出一条无效选项的警告信息）。"

#: ../../using/cmdline.rst:489
msgid ""
"Warnings can also be controlled using the :envvar:`PYTHONWARNINGS` "
"environment variable and from within a Python program using the "
":mod:`warnings` module. For example, the :func:`warnings.filterwarnings` "
"function can be used to use a regular expression on the warning message."
msgstr ""
"警告信息还可以用 :envvar:`PYTHONWARNINGS` 环境变量来控制，也可以在 Python 程序中用 :mod:`warnings` "
"模块进行控制。例如， :func:`warnings.filterwarnings` 函数可对警告信息使用正则表达式。"

#: ../../using/cmdline.rst:494 ../../using/cmdline.rst:933
msgid ""
"See :ref:`warning-filter` and :ref:`describing-warning-filters` for more "
"details."
msgstr "请参阅 :ref:`warning-filter` 和 :ref:`describing-warning-filters` 了解更多细节。"

#: ../../using/cmdline.rst:500
msgid ""
"Skip the first line of the source, allowing use of non-Unix forms of "
"``#!cmd``.  This is intended for a DOS specific hack only."
msgstr "跳过源中第一行，以允许使用非 Unix 形式的 ``#!cmd``。 这适用于 DOS 专属的破解操作。"

#: ../../using/cmdline.rst:506
msgid ""
"Reserved for various implementation-specific options.  CPython currently "
"defines the following possible values:"
msgstr "保留用于各种具体实现专属的选项。 CPython 目前定义了下列可用的值："

#: ../../using/cmdline.rst:509
msgid ""
"``-X faulthandler`` to enable :mod:`faulthandler`. See also "
":envvar:`PYTHONFAULTHANDLER`."
msgstr ""
"``-X faulthandler`` 将启用 :mod:`faulthandler`。 另请参阅 "
":envvar:`PYTHONFAULTHANDLER`。"

#: ../../using/cmdline.rst:514
msgid ""
"``-X showrefcount`` to output the total reference count and number of used "
"memory blocks when the program finishes or after each statement in the "
"interactive interpreter. This only works on :ref:`debug builds <debug-"
"build>`."
msgstr ""
"``-X showrefcount`` 可在程序结束时或在交互式解释器每条语句后，输出总的引用计数和使用的内存块数。这只适用于 :ref:`调试版本 "
"<debug-build>`。"

#: ../../using/cmdline.rst:521
msgid ""
"``-X tracemalloc`` to start tracing Python memory allocations using the "
":mod:`tracemalloc` module. By default, only the most recent frame is stored "
"in a traceback of a trace. Use ``-X tracemalloc=NFRAME`` to start tracing "
"with a traceback limit of *NFRAME* frames. See :func:`tracemalloc.start` and"
" :envvar:`PYTHONTRACEMALLOC` for more information."
msgstr ""
"``-X tracemalloc`` 使用 :mod:`tracemalloc` 模块启动对 Python 内存分配的跟踪。 "
"在默认情况下，只有最近的帧会保存在跟踪的回溯信息中。 使用 ``-X tracemalloc=NFRAME`` 来启动限定回溯 *NFRAME* "
"帧的跟踪。 请参阅 :func:`tracemalloc.start` 和 :envvar:`PYTHONTRACEMALLOC` 了解详情。"

#: ../../using/cmdline.rst:530
msgid ""
"``-X int_max_str_digits`` configures the :ref:`integer string conversion "
"length limitation <int_max_str_digits>`.  See also "
":envvar:`PYTHONINTMAXSTRDIGITS`."
msgstr ""
"``-X int_max_str_digits`` 将配置 :ref:`整数字符串转换长度限制 <int_max_str_digits>`。 另请参阅 "
":envvar:`PYTHONINTMAXSTRDIGITS`。"

#: ../../using/cmdline.rst:536
msgid ""
"``-X importtime`` to show how long each import takes. It shows module name, "
"cumulative time (including nested imports) and self time (excluding nested "
"imports).  Note that its output may be broken in multi-threaded application."
"  Typical usage is ``python3 -X importtime -c 'import asyncio'``.  See also "
":envvar:`PYTHONPROFILEIMPORTTIME`."
msgstr ""
"``-X importtime`` 显示每次导入耗费的时间。 它会显示模块名称，累计时间（包括嵌套的导入）和自身时间（排除嵌套的导入）。 "
"请注意它的输出在多线程应用程序中可能会出错。 典型用法如 ``python3 -X importtime -c 'import asyncio'``。 "
"另请参阅 :envvar:`PYTHONPROFILEIMPORTTIME`。"

#: ../../using/cmdline.rst:544
msgid ""
"``-X dev``: enable :ref:`Python Development Mode <devmode>`, introducing "
"additional runtime checks that are too expensive to be enabled by default.  "
"See also :envvar:`PYTHONDEVMODE`."
msgstr ""
"``-X dev``: 启用 :ref:`Python 开发模式 <devmode>`，引入在默认情况下启用会导致过大开销的运行时检查。 另请参阅 "
":envvar:`PYTHONDEVMODE`。"

#: ../../using/cmdline.rst:550
msgid ""
"``-X utf8`` enables the :ref:`Python UTF-8 Mode <utf8-mode>`. ``-X utf8=0`` "
"explicitly disables :ref:`Python UTF-8 Mode <utf8-mode>` (even when it would"
" otherwise activate automatically). See also :envvar:`PYTHONUTF8`."
msgstr ""
"``-X utf8`` 启用 :ref:`Python UTF-8 模式 <utf8-mode>`。 ``-X utf8=0`` 将显式地禁用 "
":ref:`Python UTF-8 模式 <utf8-mode>` (即使在该模式应该会自动激活时也是如此)。 另请参阅 "
":envvar:`PYTHONUTF8`。"

#: ../../using/cmdline.rst:557
msgid ""
"``-X pycache_prefix=PATH`` enables writing ``.pyc`` files to a parallel tree"
" rooted at the given directory instead of to the code tree. See also "
":envvar:`PYTHONPYCACHEPREFIX`."
msgstr ""
"``-X pycache_prefix=PATH`` 允许将 ``.pyc`` 文件写入以给定目录为根的并行树，而不是代码树。另见 "
":envvar:`PYTHONPYCACHEPREFIX` 。"

#: ../../using/cmdline.rst:563
msgid ""
"``-X warn_default_encoding`` issues a :class:`EncodingWarning` when the "
"locale-specific default encoding is used for opening files. See also "
":envvar:`PYTHONWARNDEFAULTENCODING`."
msgstr ""
" 当采用某地区默认编码打开文件时，``-X warn_default_encoding`` 将引发一条 "
":class:`EncodingWarning`。参见 :envvar:`PYTHONWARNDEFAULTENCODING`。"

#: ../../using/cmdline.rst:569
msgid ""
"``-X no_debug_ranges`` disables the inclusion of the tables mapping extra "
"location information (end line, start column offset and end column offset) "
"to every instruction in code objects. This is useful when smaller code "
"objects and pyc files are desired as well as suppressing the extra visual "
"location indicators when the interpreter displays tracebacks. See also "
":envvar:`PYTHONNODEBUGRANGES`."
msgstr ""
"``-X no_debug_ranges`` 会禁用在代码对象中包括将额外位置信息（结束行、开始列偏移量和结束列偏移量）映射到每条指令的映射表。 "
"这在需要较小的代码对象和 pyc 文件时很有用处并可在解释器显示回溯时屏蔽额外的视觉位置提示。 另请参阅 "
":envvar:`PYTHONNODEBUGRANGES`。"

#: ../../using/cmdline.rst:578
msgid ""
"``-X frozen_modules`` determines whether or not frozen modules are ignored "
"by the import machinery.  A value of ``on`` means they get imported and "
"``off`` means they are ignored.  The default is ``on`` if this is an "
"installed Python (the normal case).  If it's under development (running from"
" the source tree) then the default is ``off``. Note that the "
":mod:`!importlib_bootstrap` and :mod:`!importlib_bootstrap_external` frozen "
"modules are always used, even if this flag is set to ``off``. See also "
":envvar:`PYTHON_FROZEN_MODULES`."
msgstr ""
"``-X frozen_modules`` 确定已冻结模块是否要被导入机制所忽略。值为 ``on`` 表示它们将被导入而 ``off`` "
"表示它们将被忽略。 如果是安装版 Python（正常情况）则默认为 ``on``。 如果是在开发中（基于源代码树运行）则默认为 ``off``。 请注意"
" :mod:`!importlib_bootstrap` 和 :mod:`!importlib_bootstrap_external` "
"冻结模块总是会被使用，即使该旗标被设为 ``off``。 另请参阅 :envvar:`PYTHON_FROZEN_MODULES`。"

#: ../../using/cmdline.rst:589
msgid ""
"``-X perf`` enables support for the Linux ``perf`` profiler. When this "
"option is provided, the ``perf`` profiler will be able to report Python "
"calls. This option is only available on some platforms and will do nothing "
"if is not supported on the current system. The default value is \"off\". See"
" also :envvar:`PYTHONPERFSUPPORT` and :ref:`perf_profiling`."
msgstr ""
"``-X perf`` 会启用对 Linux ``perf`` 性能分析器的支持。 当提供了此选项时，``perf`` 性能分析器将能够报告 "
"Python 调用。 此选项仅在某些平台上可用而在当前系统不支持的情况下将不做任何事。 默认值为 \"off\"。 另请参阅 "
":envvar:`PYTHONPERFSUPPORT` 和 :ref:`perf_profiling`。"

#: ../../using/cmdline.rst:597
msgid ""
"``-X perf_jit`` enables support for the Linux ``perf`` profiler with DWARF "
"support. When this option is provided, the ``perf`` profiler will be able to"
" report Python calls using DWARF information. This option is only available "
"on some platforms and will do nothing if is not supported on the current "
"system. The default value is \"off\". See also "
":envvar:`PYTHON_PERF_JIT_SUPPORT` and :ref:`perf_profiling`."
msgstr ""
"``-X perf_jit`` 将启用对对 Linux ``perf`` 性能分析器的支持并附带 DWARF 支持。 当提供了此选项时，``perf``"
" 性能分析器将能够使用 DWARF 信息来报告 Python 调用。 此选项仅在某些平台上可用而在当前系统不支持的情况下将不做任何事。 默认值为 "
"\"off\"。 另请参阅 :envvar:`PYTHON_PERF_JIT_SUPPORT` 和 :ref:`perf_profiling`。"

#: ../../using/cmdline.rst:606
msgid ""
":samp:`-X cpu_count={n}` overrides :func:`os.cpu_count`, "
":func:`os.process_cpu_count`, and :func:`multiprocessing.cpu_count`. *n* "
"must be greater than or equal to 1. This option may be useful for users who "
"need to limit CPU resources of a container system. See also "
":envvar:`PYTHON_CPU_COUNT`. If *n* is ``default``, nothing is overridden."
msgstr ""
":samp:`-X cpu_count={n}` 将覆盖 :func:`os.cpu_count`, "
":func:`os.process_cpu_count` 和 :func:`multiprocessing.cpu_count`。 *n* 必须大于等于"
" 1。 此选项对于需要限制某个容器系统的 CPU 资源的用户来说会很有用处。 另请参阅 :envvar:`PYTHON_CPU_COUNT`。 如果 "
"*n* 为 ``default``，则不会覆盖任何值。"

#: ../../using/cmdline.rst:615
msgid ""
":samp:`-X presite={package.module}` specifies a module that should be "
"imported before the :mod:`site` module is executed and before the "
":mod:`__main__` module exists.  Therefore, the imported module isn't "
":mod:`__main__`. This can be used to execute code early during Python "
"initialization. Python needs to be :ref:`built in debug mode <debug-build>` "
"for this option to exist.  See also :envvar:`PYTHON_PRESITE`."
msgstr ""
":samp:`-X presite={package.module}` 指明一个模块应当 :mod:`site` 模块执行之前以及 "
":mod:`__main__` 模块存在之前被导入。 因此，这个被导入的模块不是 :mod:`__main__`。 此选项适用于要早在 Python "
"初始化期间就执行的代码。 Python 需要 :ref:`以调试模式构建 <debug-build>` 此选项才能存在。 另请参阅 "
":envvar:`PYTHON_PRESITE`。"

#: ../../using/cmdline.rst:624
msgid ""
":samp:`-X gil={0,1}` forces the GIL to be disabled or enabled, respectively."
" Setting to ``0`` is only available in builds configured with "
":option:`--disable-gil`. See also :envvar:`PYTHON_GIL` and "
":ref:`whatsnew313-free-threaded-cpython`."
msgstr ""
":samp:`-X gil={0,1}` 强制分别禁用或启用 GIL。 设为 ``0`` 仅在配置了 :option:`--disable-gil` "
"的构建版上可用。 另请参阅 :envvar:`PYTHON_GIL` 和 :ref:`whatsnew313-free-threaded-"
"cpython`。"

#: ../../using/cmdline.rst:631
msgid ""
"It also allows passing arbitrary values and retrieving them through the "
":data:`sys._xoptions` dictionary."
msgstr "它还允许传入任意值并通过 :data:`sys._xoptions` 字典来提取这些值。"

#: ../../using/cmdline.rst:636
msgid "Removed the ``-X showalloccount`` option."
msgstr "移除了 ``-X showalloccount`` 选项。"

#: ../../using/cmdline.rst:639
msgid "Removed the ``-X oldparser`` option."
msgstr "移除了 ``-X oldparser`` 选项。"

#: ../../using/cmdline.rst:645
msgid "Controlling color"
msgstr "控制颜色"

#: ../../using/cmdline.rst:647
msgid ""
"The Python interpreter is configured by default to use colors to highlight "
"output in certain situations such as when displaying tracebacks. This "
"behavior can be controlled by setting different environment variables."
msgstr "Python 解释器默认被配置为在特定场景例如当显示回溯信息时使用颜色高亮输出。 此行为可通过设置不同的环境变量来控制。"

#: ../../using/cmdline.rst:651
msgid ""
"Setting the environment variable ``TERM`` to ``dumb`` will disable color."
msgstr "将环境变量 ``TERM`` 设为 ``dumb`` 将禁用颜色。"

#: ../../using/cmdline.rst:653
msgid ""
"If the |FORCE_COLOR|_ environment variable is set, then color will be "
"enabled regardless of the value of TERM. This is useful on CI systems which "
"aren’t terminals but can still display ANSI escape sequences."
msgstr ""
"如果设置了 |FORCE_COLOR|_ 环境变量，则无论 TERM 的值为何都将启用彩色。 这适用于不属于终端但仍然会显示 ANSI 转义序列的的 "
"CI 系统。"

#: ../../using/cmdline.rst:657
msgid ""
"If the |NO_COLOR|_ environment variable is set, Python will disable all "
"color in the output. This takes precedence over ``FORCE_COLOR``."
msgstr ""
"如果设置了 |NO_COLOR|_ 环境变量，则 Python 将在输出中禁用所有彩色。 此变量的优先级高于 ``FORCE_COLOR``。"

#: ../../using/cmdline.rst:660
msgid ""
"All these environment variables are used also by other tools to control "
"color output. To control the color output only in the Python interpreter, "
"the :envvar:`PYTHON_COLORS` environment variable can be used. This variable "
"takes precedence over ``NO_COLOR``, which in turn takes precedence over "
"``FORCE_COLOR``."
msgstr ""
"所有这些环境变量也被其他工具用来控制颜色输出。 要仅在 Python 解释器中控制颜色输出，可以使用 :envvar:`PYTHON_COLORS` "
"环境变量。 此变量的优先级高于 ``NO_COLOR``，后者的优先级又高于 ``FORCE_COLOR``。"

#: ../../using/cmdline.rst:675
msgid "Options you shouldn't use"
msgstr "不应当使用的选项"

#: ../../using/cmdline.rst:679
msgid "Reserved for use by Jython_."
msgstr "保留给 Jython_ 使用。"

#: ../../using/cmdline.rst:687
msgid "Environment variables"
msgstr "环境变量"

#: ../../using/cmdline.rst:689
msgid ""
"These environment variables influence Python's behavior, they are processed "
"before the command-line switches other than -E or -I.  It is customary that "
"command-line switches override environmental variables where there is a "
"conflict."
msgstr ""
"这些环境变量会影响 Python 的行为，它们是在命令行开关之前被处理的，但 -E 或 -I 除外。 "
"根据约定，当存在冲突时命令行开关会覆盖环境变量的设置。"

#: ../../using/cmdline.rst:696
msgid ""
"Change the location of the standard Python libraries.  By default, the "
"libraries are searched in :file:`{prefix}/lib/python{version}` and "
":file:`{exec_prefix}/lib/python{version}`, where :file:`{prefix}` and "
":file:`{exec_prefix}` are installation-dependent directories, both "
"defaulting to :file:`/usr/local`."
msgstr ""
"更改标准 Python 库的位置。 默认情况下库是在 :file:`{prefix}/lib/python{version}` 和 "
":file:`{exec_prefix}/lib/python{version}` 中搜索，其中 :file:`{prefix}` 和 "
":file:`{exec_prefix}` 是由安装位置确定的目录，默认都位于 :file:`/usr/local`。"

#: ../../using/cmdline.rst:702
msgid ""
"When :envvar:`PYTHONHOME` is set to a single directory, its value replaces "
"both :file:`{prefix}` and :file:`{exec_prefix}`.  To specify different "
"values for these, set :envvar:`PYTHONHOME` to "
":file:`{prefix}:{exec_prefix}`."
msgstr ""
"当 :envvar:`PYTHONHOME` 被设为单个目录时，它的值会同时替代 :file:`{prefix}` 和 "
":file:`{exec_prefix}`。 要为两者指定不同的值，请将 :envvar:`PYTHONHOME` 设为 "
":file:`{prefix}:{exec_prefix}`。"

#: ../../using/cmdline.rst:709
msgid ""
"Augment the default search path for module files.  The format is the same as"
" the shell's :envvar:`PATH`: one or more directory pathnames separated by "
":data:`os.pathsep` (e.g. colons on Unix or semicolons on Windows). Non-"
"existent directories are silently ignored."
msgstr ""
"增加模块文件默认搜索路径。 所用格式与终端的 :envvar:`PATH` 相同：一个或多个由 :data:`os.pathsep` "
"分隔的目录路径名称（例如 Unix 上用冒号而在 Windows 上用分号）。 默认忽略不存在的目录。"

#: ../../using/cmdline.rst:714
msgid ""
"In addition to normal directories, individual :envvar:`PYTHONPATH` entries "
"may refer to zipfiles containing pure Python modules (in either source or "
"compiled form). Extension modules cannot be imported from zipfiles."
msgstr ""
"除了普通目录之外，单个 :envvar:`PYTHONPATH` "
"条目可以引用包含纯Python模块的zip文件（源代码或编译形式）。无法从zip文件导入扩展模块。"

#: ../../using/cmdline.rst:718
msgid ""
"The default search path is installation dependent, but generally begins with"
" :file:`{prefix}/lib/python{version}` (see :envvar:`PYTHONHOME` above).  It "
"is *always* appended to :envvar:`PYTHONPATH`."
msgstr ""
"默认索引路径依赖于安装路径，但通常都是以 :file:`{prefix}/lib/python{version}` 开始 (参见上文中的 "
":envvar:`PYTHONHOME`)。 它 *总是* 会被添加到 :envvar:`PYTHONPATH`。"

#: ../../using/cmdline.rst:722
msgid ""
"An additional directory will be inserted in the search path in front of "
":envvar:`PYTHONPATH` as described above under :ref:`using-on-interface-"
"options`. The search path can be manipulated from within a Python program as"
" the variable :data:`sys.path`."
msgstr ""
"有一个附加目录将被插入到索引路径的 :envvar:`PYTHONPATH` 之前，正如上文中 :ref:`using-on-interface-"
"options` 所描述的。 搜索路径可以在 Python 程序内作为变量 :data:`sys.path` 来进行操作。"

#: ../../using/cmdline.rst:730
msgid ""
"If this is set to a non-empty string, don't prepend a potentially unsafe "
"path to :data:`sys.path`: see the :option:`-P` option for details."
msgstr ""
"如果这被设为一个非空字符串，请不要将具有潜在不安全性的路径附加到 :data:`sys.path`: 参见 :option:`-P` 选项了解详情。"

#: ../../using/cmdline.rst:738
msgid ""
"If this is set to a non-empty string, it overrides the "
":data:`sys.platlibdir` value."
msgstr "如果它被设为非空字符串，则会覆盖 :data:`sys.platlibdir` 值。"

#: ../../using/cmdline.rst:746
msgid ""
"If this is the name of a readable file, the Python commands in that file are"
" executed before the first prompt is displayed in interactive mode.  The "
"file is executed in the same namespace where interactive commands are "
"executed so that objects defined or imported in it can be used without "
"qualification in the interactive session.  You can also change the prompts "
":data:`sys.ps1` and :data:`sys.ps2` and the hook "
":data:`sys.__interactivehook__` in this file."
msgstr ""
"这如果是一个可读文件的名称，该文件中的 Python 命令会在交互模式的首个提示符显示之前被执行。 "
"该文件会在与交互式命令执行所在的同一命名空间中被执行，因此其中所定义或导入的对象可以在交互式会话中无限制地使用。 你还可以在这个文件中修改提示符 "
":data:`sys.ps1` 和 :data:`sys.ps2` 以及钩子 :data:`sys.__interactivehook__`。"

#: ../../using/cmdline.rst:753 ../../using/cmdline.rst:755
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_startup`` with the "
"filename as the argument when called on startup."
msgstr "在启动时调用文件名作为参数会引发  :ref:`审计事件 <auditing>` ``cpython.run_startup`` 。"

#: ../../using/cmdline.rst:761
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-O` option.  If set to an integer, it is equivalent to specifying "
":option:`-O` multiple times."
msgstr ""
"这如果被设为一个非空字符串，它就相当于指定 :option:`-O` 选项。 如果设为一个整数，则它就相当于多次指定 :option:`-O`。"

#: ../../using/cmdline.rst:768
msgid ""
"If this is set, it names a callable using dotted-path notation.  The module "
"containing the callable will be imported and then the callable will be run "
"by the default implementation of :func:`sys.breakpointhook` which itself is "
"called by built-in :func:`breakpoint`.  If not set, or set to the empty "
"string, it is equivalent to the value \"pdb.set_trace\".  Setting this to "
"the string \"0\" causes the default implementation of "
":func:`sys.breakpointhook` to do nothing but return immediately."
msgstr ""
"此变量如果被设定，它会使用加点号的路径标记一个可调用对象。 包含该可调用对象的模块将被导入，随后该可调用对象将由 "
":func:`sys.breakpointhook` 的默认实现来运行，后者自身将由内置的 :func:`breakpoint` 来调用。 "
"如果未设定，或设定为空字符串，则它相当于值 \"pdb.set_trace\"。 将此变量设为字符串 \"0\" 会导致 "
":func:`sys.breakpointhook` 的默认实现不做任何事而直接返回。"

#: ../../using/cmdline.rst:780
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-d` option.  If set to an integer, it is equivalent to specifying "
":option:`-d` multiple times."
msgstr ""
"此变量如果被设为一个非空字符串，它就相当于指定 :option:`-d` 选项。 如果设为一个整数，则它就相当于多次指定 :option:`-d`。"

#: ../../using/cmdline.rst:784
msgid ""
"This environment variable requires a :ref:`debug build of Python <debug-"
"build>`, otherwise it's ignored."
msgstr "此环境变量需要 :ref:`Python 的调试构建版 <debug-build>`，否则它将被忽略。"

#: ../../using/cmdline.rst:790
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-i` option."
msgstr "此变量如果被设为一个非空字符串，它就相当于指定 :option:`-i` 选项。"

#: ../../using/cmdline.rst:793
msgid ""
"This variable can also be modified by Python code using :data:`os.environ` "
"to force inspect mode on program termination."
msgstr "此变量也可由 Python 代码使用 :data:`os.environ` 来修改以在程序终结时强制检查模式。"

#: ../../using/cmdline.rst:798
msgid "(also 3.11.10, 3.10.15, 3.9.20, and 3.8.20) Emits audit events."
msgstr "（还有 3.11.10, 3.10.15, 3.9.20 和 3.8.20） 发出审计事件。"

#: ../../using/cmdline.rst:801
msgid ""
"Uses PyREPL if possible, in which case :envvar:`PYTHONSTARTUP` is also "
"executed. Emits audit events."
msgstr "如果无法做到则使用 PyREPL，在此情况下 :envvar:`PYTHONSTARTUP` 也会被执行。 将发出审计事件。"

#: ../../using/cmdline.rst:808
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-u` option."
msgstr "此变量如果被设为一个非空字符串，它就相当于指定 :option:`-u` 选项。"

#: ../../using/cmdline.rst:814
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-v` option.  If set to an integer, it is equivalent to specifying "
":option:`-v` multiple times."
msgstr ""
"此变量如果被设为一个非空字符串，它就相当于指定 :option:`-v` 选项。 如果设为一个整数，则它就相当于多次指定 :option:`-v`。"

#: ../../using/cmdline.rst:821
msgid ""
"If this is set, Python ignores case in :keyword:`import` statements.  This "
"only works on Windows and macOS."
msgstr ""
"如果设置了此变量，Python 将忽略 :keyword:`import` 语句中的大小写。 这仅在 Windows 和 macOS 上有效。"

#: ../../using/cmdline.rst:827
msgid ""
"If this is set to a non-empty string, Python won't try to write ``.pyc`` "
"files on the import of source modules.  This is equivalent to specifying the"
" :option:`-B` option."
msgstr ""
"此变量如果被设为一个非空字符串，Python 将不会尝试在导入源模块时写入 ``.pyc`` 文件。 这相当于指定 :option:`-B` 选项。"

#: ../../using/cmdline.rst:834
msgid ""
"If this is set, Python will write ``.pyc`` files in a mirror directory tree "
"at this path, instead of in ``__pycache__`` directories within the source "
"tree. This is equivalent to specifying the :option:`-X` "
"``pycache_prefix=PATH`` option."
msgstr ""
"如果设置了此选项，Python将在镜像目录树中的此路径中写入 ``.pyc`` 文件，而不是源树中的 ``__pycache__`` "
"目录中。这相当于指定 :option:`-X` ``pycache_prefix=PATH`` 选项。"

#: ../../using/cmdline.rst:844
msgid ""
"If this variable is not set or set to ``random``, a random value is used to "
"seed the hashes of str and bytes objects."
msgstr "如果此变量未设置或设为 ``random``，将使用一个随机值作为 str 和 bytes 对象哈希运算的种子。"

#: ../../using/cmdline.rst:847
msgid ""
"If :envvar:`PYTHONHASHSEED` is set to an integer value, it is used as a "
"fixed seed for generating the hash() of the types covered by the hash "
"randomization."
msgstr ""
"如果 :envvar:`PYTHONHASHSEED` 被设为一个整数值，它将被作为固定的种子数用来生成哈希随机化所涵盖的类型的 hash() 结果。"

#: ../../using/cmdline.rst:851
msgid ""
"Its purpose is to allow repeatable hashing, such as for selftests for the "
"interpreter itself, or to allow a cluster of python processes to share hash "
"values."
msgstr "它的目的是允许可复现的哈希运算，例如用于解释器本身的自我检测，或允许一组 python 进程共享哈希值。"

#: ../../using/cmdline.rst:855
msgid ""
"The integer must be a decimal number in the range [0,4294967295].  "
"Specifying the value 0 will disable hash randomization."
msgstr "该整数必须为一个 [0,4294967295] 范围内的十进制数。 指定数值 0 将禁用哈希随机化。"

#: ../../using/cmdline.rst:862
msgid ""
"If this variable is set to an integer, it is used to configure the "
"interpreter's global :ref:`integer string conversion length limitation "
"<int_max_str_digits>`."
msgstr "如果将此变量设为一个整数，它会被用来配置解释器的全局 :ref:`整数字符串转换长度限制 <int_max_str_digits>`。"

#: ../../using/cmdline.rst:870
msgid ""
"If this is set before running the interpreter, it overrides the encoding "
"used for stdin/stdout/stderr, in the syntax ``encodingname:errorhandler``.  "
"Both the ``encodingname`` and the ``:errorhandler`` parts are optional and "
"have the same meaning as in :func:`str.encode`."
msgstr ""
"如果此变量在运行解释器之前被设置，它会覆盖通过 ``encodingname:errorhandler`` 语法设置的 "
"stdin/stdout/stderr 所用编码。 ``encodingname`` 和 ``:errorhandler`` 部分都是可选项，与在 "
":func:`str.encode` 中的含义相同。"

#: ../../using/cmdline.rst:875
msgid ""
"For stderr, the ``:errorhandler`` part is ignored; the handler will always "
"be ``'backslashreplace'``."
msgstr "对于 stderr，``:errorhandler`` 部分会被忽略；处理程序将总是为 ``'backslashreplace'``。"

#: ../../using/cmdline.rst:878
msgid "The ``encodingname`` part is now optional."
msgstr "“encodingname” 部分现在是可选的。"

#: ../../using/cmdline.rst:881
msgid ""
"On Windows, the encoding specified by this variable is ignored for "
"interactive console buffers unless :envvar:`PYTHONLEGACYWINDOWSSTDIO` is "
"also specified. Files and pipes redirected through the standard streams are "
"not affected."
msgstr ""
"在 Windows 上，对于交互式控制台缓冲区会忽略此变量所指定的编码，除非还指定了 "
":envvar:`PYTHONLEGACYWINDOWSSTDIO`。 通过标准流重定向的文件和管道则不受其影响。"

#: ../../using/cmdline.rst:888
msgid ""
"If this is set, Python won't add the :data:`user site-packages directory "
"<site.USER_SITE>` to :data:`sys.path`."
msgstr ""
"如果设置了此变量，Python 将不会把 :data:`用户 site-packages 目录 <site.USER_SITE>` 添加到 "
":data:`sys.path`。"

#: ../../using/cmdline.rst:898
msgid ""
"Defines the :data:`user base directory <site.USER_BASE>`, which is used to "
"compute the path of the :data:`user site-packages directory "
"<site.USER_SITE>` and :ref:`installation paths <sysconfig-user-scheme>` for "
"``python -m pip install --user``."
msgstr ""
"定义 :data:`用户基准目录 <site.USER_BASE>`，它将被用来计算 :data:`user site-packages 目录 "
"<site.USER_SITE>` 以及 ``python -m pip install --user`` 的 :ref:`安装路径 "
"<sysconfig-user-scheme>`。"

#: ../../using/cmdline.rst:910
msgid ""
"If this environment variable is set, ``sys.argv[0]`` will be set to its "
"value instead of the value got through the C runtime.  Only works on macOS."
msgstr ""
"如果设置了此环境变量，则 ``sys.argv[0]`` 将被设为此变量的值而不是通过 C 运行时所获得的值。 这仅在 macOS 上起作用。"

#: ../../using/cmdline.rst:916
msgid ""
"This is equivalent to the :option:`-W` option. If set to a comma separated "
"string, it is equivalent to specifying :option:`-W` multiple times, with "
"filters later in the list taking precedence over those earlier in the list."
msgstr ""
"此变量等价于 :option:`-W` 选项。 如果被设为一个以逗号分隔的字符串，它就相当于多次指定 "
":option:`-W`，列表中后出现的过滤器优先级会高于列表中先出现的。"

#: ../../using/cmdline.rst:925
msgid ""
"PYTHONWARNINGS=default  # Warn once per call location\n"
"PYTHONWARNINGS=error    # Convert to exceptions\n"
"PYTHONWARNINGS=always   # Warn every time\n"
"PYTHONWARNINGS=all      # Same as PYTHONWARNINGS=always\n"
"PYTHONWARNINGS=module   # Warn once per calling module\n"
"PYTHONWARNINGS=once     # Warn once per Python process\n"
"PYTHONWARNINGS=ignore   # Never warn"
msgstr ""
"PYTHONWARNINGS=default  # 每个调用位置警告一次\n"
"PYTHONWARNINGS=error    # 转换为异常\n"
"PYTHONWARNINGS=always   # 每次都警告\n"
"PYTHONWARNINGS=all      # 与 PYTHONWARNINGS=always 相同\n"
"PYTHONWARNINGS=module   # 每个调用模块警告一次\n"
"PYTHONWARNINGS=once     # 每个 Python 进程警告一次\n"
"PYTHONWARNINGS=ignore   # 从不警告"

#: ../../using/cmdline.rst:939
msgid ""
"If this environment variable is set to a non-empty string, "
":func:`faulthandler.enable` is called at startup: install a handler for "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`,"
" :const:`~signal.SIGBUS` and :const:`~signal.SIGILL` signals to dump the "
"Python traceback. This is equivalent to :option:`-X` ``faulthandler`` "
"option."
msgstr ""
"如果此环境变量被设为一个非空字符串，:func:`faulthandler.enable` 会在启动时被调用：为 "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`,"
" :const:`~signal.SIGBUS` 和 :const:`~signal.SIGILL` 等信号安装一个处理器以转储 Python "
"回溯信息。 此环境变量等价于 :option:`-X` ``faulthandler`` 选项。"

#: ../../using/cmdline.rst:951
msgid ""
"If this environment variable is set to a non-empty string, start tracing "
"Python memory allocations using the :mod:`tracemalloc` module. The value of "
"the variable is the maximum number of frames stored in a traceback of a "
"trace. For example, ``PYTHONTRACEMALLOC=1`` stores only the most recent "
"frame. See the :func:`tracemalloc.start` function for more information. This"
" is equivalent to setting the :option:`-X` ``tracemalloc`` option."
msgstr ""
"如果此环境变量被设为一个非空字符串，则会使用 :mod:`tracemalloc` 模块启动对 Python 内存分配的跟踪。 "
"该变量的值是保存在跟踪的回溯信息中的最大帧数。 例如， ``PYTHONTRACEMALLOC=1`` 只保存最近的帧。 请参阅 "
":func:`tracemalloc.start` 函数了解更多信息。 这等价于设置 :option:`-X` ``tracemalloc`` 选项。"

#: ../../using/cmdline.rst:964
msgid ""
"If this environment variable is set to a non-empty string, Python will show "
"how long each import takes. This is equivalent to setting the :option:`-X` "
"``importtime`` option."
msgstr ""
"如果此环境变量被设为一个非空字符串，Python 将会显示每次导入耗费了多长时间。 这等价于设置 :option:`-X` ``importtime``"
" 选项。"

#: ../../using/cmdline.rst:973
msgid ""
"If this environment variable is set to a non-empty string, enable the "
":ref:`debug mode <asyncio-debug-mode>` of the :mod:`asyncio` module."
msgstr ""
"如果此变量被设为一个非空字符串，则会启用 :mod:`asyncio` 模块的 :ref:`调试模式 <asyncio-debug-mode>`。"

#: ../../using/cmdline.rst:981
msgid "Set the Python memory allocators and/or install debug hooks."
msgstr "设置 Python 内存分配器和/或安装调试钩子。"

#: ../../using/cmdline.rst:983
msgid "Set the family of memory allocators used by Python:"
msgstr "设置 Python 所使用的内存分配器族群："

#: ../../using/cmdline.rst:985
msgid ""
"``default``: use the :ref:`default memory allocators <default-memory-"
"allocators>`."
msgstr "``default``: 使用 :ref:`默认内存分配器 <default-memory-allocators>`。"

#: ../../using/cmdline.rst:987
msgid ""
"``malloc``: use the :c:func:`malloc` function of the C library for all "
"domains (:c:macro:`PYMEM_DOMAIN_RAW`, :c:macro:`PYMEM_DOMAIN_MEM`, "
":c:macro:`PYMEM_DOMAIN_OBJ`)."
msgstr ""
"``malloc``: 对所有域 (:c:macro:`PYMEM_DOMAIN_RAW`, :c:macro:`PYMEM_DOMAIN_MEM`, "
":c:macro:`PYMEM_DOMAIN_OBJ`) 使用 C 库的 :c:func:`malloc` 函数。"

#: ../../using/cmdline.rst:990
msgid ""
"``pymalloc``: use the :ref:`pymalloc allocator <pymalloc>` for "
":c:macro:`PYMEM_DOMAIN_MEM` and :c:macro:`PYMEM_DOMAIN_OBJ` domains and use "
"the :c:func:`malloc` function for the :c:macro:`PYMEM_DOMAIN_RAW` domain."
msgstr ""
"``pymalloc``: 对 :c:macro:`PYMEM_DOMAIN_MEM` 和 :c:macro:`PYMEM_DOMAIN_OBJ` "
"域使用 :ref:`pymalloc 分配器 <pymalloc>` 而对 :c:macro:`PYMEM_DOMAIN_RAW` 域使用 "
":c:func:`malloc` 函数。"

#: ../../using/cmdline.rst:993
msgid ""
"``mimalloc``: use the :ref:`mimalloc allocator <mimalloc>` for "
":c:macro:`PYMEM_DOMAIN_MEM` and :c:macro:`PYMEM_DOMAIN_OBJ` domains and use "
"the :c:func:`malloc` function for the :c:macro:`PYMEM_DOMAIN_RAW` domain."
msgstr ""
"``mimalloc``: 对 :c:macro:`PYMEM_DOMAIN_MEM` 和 :c:macro:`PYMEM_DOMAIN_OBJ` "
"域使用 :ref:`mimalloc 分配器 <mimalloc>` 而对 :c:macro:`PYMEM_DOMAIN_RAW` 域使用 "
":c:func:`malloc` 函数。"

#: ../../using/cmdline.rst:997
msgid "Install :ref:`debug hooks <pymem-debug-hooks>`:"
msgstr "安装 :ref:`调试钩子 <pymem-debug-hooks>` ："

#: ../../using/cmdline.rst:999
msgid ""
"``debug``: install debug hooks on top of the :ref:`default memory allocators"
" <default-memory-allocators>`."
msgstr "``debug``: 在 :ref:`默认内存分配器 <default-memory-allocators>` 之上安装调试钩子。"

#: ../../using/cmdline.rst:1001
msgid "``malloc_debug``: same as ``malloc`` but also install debug hooks."
msgstr "``malloc_debug``: 与 ``malloc`` 相同但还会安装调试钩子。"

#: ../../using/cmdline.rst:1002
msgid "``pymalloc_debug``: same as ``pymalloc`` but also install debug hooks."
msgstr "``pymalloc_debug``: 与 ``pymalloc`` 相同但还会安装调试钩子。"

#: ../../using/cmdline.rst:1003
msgid "``mimalloc_debug``: same as ``mimalloc`` but also install debug hooks."
msgstr "``mimalloc_debug``: 与 ``mimalloc`` 相同但还会安装调试钩子。"

#: ../../using/cmdline.rst:1007
msgid "Added the ``\"default\"`` allocator."
msgstr "增加了 ``\"default\"`` 分配器。"

#: ../../using/cmdline.rst:1013
msgid ""
"If set to a non-empty string, Python will print statistics of the "
":ref:`pymalloc memory allocator <pymalloc>` every time a new pymalloc object"
" arena is created, and on shutdown."
msgstr ""
"如果设为一个非空字符串，Python 将在每次创建新的 pymalloc 对象区域以及在关闭时打印 :ref:`pymalloc 内存分配器 "
"<pymalloc>` 的统计信息。"

#: ../../using/cmdline.rst:1017
msgid ""
"This variable is ignored if the :envvar:`PYTHONMALLOC` environment variable "
"is used to force the :c:func:`malloc` allocator of the C library, or if "
"Python is configured without ``pymalloc`` support."
msgstr ""
"如果 :envvar:`PYTHONMALLOC` 环境变量被用来强制开启 C 库的 :c:func:`malloc` 分配器，或者如果 Python "
"的配置不支持 ``pymalloc``，则此变量将被忽略。"

#: ../../using/cmdline.rst:1021
msgid ""
"This variable can now also be used on Python compiled in release mode. It "
"now has no effect if set to an empty string."
msgstr "此变量现在也可以被用于在发布模式下编译的 Python。 如果它被设置为一个空字符串则将没有任何效果。"

#: ../../using/cmdline.rst:1028
msgid ""
"If set to a non-empty string, the default :term:`filesystem encoding and "
"error handler` mode will revert to their pre-3.6 values of 'mbcs' and "
"'replace', respectively.  Otherwise, the new defaults 'utf-8' and "
"'surrogatepass' are used."
msgstr ""
"如果设为非空字符串，默认的 :term:`filesystem encoding and error handler` 模式将恢复到 3.6 "
"版本之前的值 “mbcs”和“replace”。 否则，将采用新的默认值“utf-8”和“surrogatepass”。"

#: ../../using/cmdline.rst:1033
msgid ""
"This may also be enabled at runtime with "
":func:`sys._enablelegacywindowsfsencoding`."
msgstr "这也可以在运行时通过 :func:`sys._enablelegacywindowsfsencoding` 来启用。"

#: ../../using/cmdline.rst:1036 ../../using/cmdline.rst:1050
#: ../../using/cmdline.rst:1101
msgid "Availability"
msgstr "Availability"

#: ../../using/cmdline.rst:1038
msgid "See :pep:`529` for more details."
msgstr "更多详情请参阅 :pep:`529`。"

#: ../../using/cmdline.rst:1043
msgid ""
"If set to a non-empty string, does not use the new console reader and "
"writer. This means that Unicode characters will be encoded according to the "
"active console code page, rather than using utf-8."
msgstr ""
"如果设为一个非空字符串，则不使用新的控制台读取器和写入器。 这意味着 Unicode 字符将根据活动控制台的代码页进行编码，而不是使用 utf-8。"

#: ../../using/cmdline.rst:1047
msgid ""
"This variable is ignored if the standard streams are redirected (to files or"
" pipes) rather than referring to console buffers."
msgstr "如果标准流被重定向（到文件或管道）而不是指向控制台缓冲区则该变量会被忽略。"

#: ../../using/cmdline.rst:1057
msgid ""
"If set to the value ``0``, causes the main Python command line application "
"to skip coercing the legacy ASCII-based C and POSIX locales to a more "
"capable UTF-8 based alternative."
msgstr ""
"如果值设为 ``0``，将导致主 Python 命令行应用跳过将传统的基于 ASCII 的 C 与 POSIX 区域设置强制转换为更强大的基于 "
"UTF-8 的替代方案。"

#: ../../using/cmdline.rst:1061
msgid ""
"If this variable is *not* set (or is set to a value other than ``0``), the "
"``LC_ALL`` locale override environment variable is also not set, and the "
"current locale reported for the ``LC_CTYPE`` category is either the default "
"``C`` locale, or else the explicitly ASCII-based ``POSIX`` locale, then the "
"Python CLI will attempt to configure the following locales for the "
"``LC_CTYPE`` category in the order listed before loading the interpreter "
"runtime:"
msgstr ""
"如果此变量 *未被* 设置（或被设为 ``0`` 以外的值），则覆盖环境变量的 ``LC_ALL`` 区域选项也不会被设置，并且报告给 "
"``LC_CTYPE`` 类别的当前区域选项或者为默认的 ``C`` 区域，或者为显式指明的基于 ASCII 的 ``POSIX`` 区域，然后 "
"Python CLI 将在加载解释器运行时之前尝试为 ``LC_CTYPE`` 类别按指定的顺序配置下列区域选项："

#: ../../using/cmdline.rst:1069
msgid "``C.UTF-8``"
msgstr "``C.UTF-8``"

#: ../../using/cmdline.rst:1070
msgid "``C.utf8``"
msgstr "``C.utf8``"

#: ../../using/cmdline.rst:1071
msgid "``UTF-8``"
msgstr "``UTF-8``"

#: ../../using/cmdline.rst:1073
msgid ""
"If setting one of these locale categories succeeds, then the ``LC_CTYPE`` "
"environment variable will also be set accordingly in the current process "
"environment before the Python runtime is initialized. This ensures that in "
"addition to being seen by both the interpreter itself and other locale-aware"
" components running in the same process (such as the GNU ``readline`` "
"library), the updated setting is also seen in subprocesses (regardless of "
"whether or not those processes are running a Python interpreter), as well as"
" in operations that query the environment rather than the current C locale "
"(such as Python's own :func:`locale.getdefaultlocale`)."
msgstr ""
"如果成功设置了以上区域类别中的一个，则初始化 Python 运行时之前也将在当前进程环境中相应地设置 ``LC_CTYPE`` 环境变量。 "
"这会确保除了解释器本身和运行于同一进程中的其他可感知区域选项的组件 (例如 GNU ``readline`` 库) 之外，还能在子进程 "
"(无论这些进程是否在运行 Python 解释器) 以及在查询环境而非当前 C 区域的操作 (例如 Python 自己的 "
":func:`locale.getdefaultlocale`) 中看到更新的设置。"

#: ../../using/cmdline.rst:1083
msgid ""
"Configuring one of these locales (either explicitly or via the above "
"implicit locale coercion) automatically enables the ``surrogateescape`` "
":ref:`error handler <error-handlers>` for :data:`sys.stdin` and "
":data:`sys.stdout` (:data:`sys.stderr` continues to use ``backslashreplace``"
" as it does in any other locale). This stream handling behavior can be "
"overridden using :envvar:`PYTHONIOENCODING` as usual."
msgstr ""
"(显式地或通过上述的隐式区域强制转换) 配置其中一个区域选项将自动为 :data:`sys.stdin` 和 :data:`sys.stdout` 启用"
" ``surrogateescape`` :ref:`错误处理器 <error-handlers>` (:data:`sys.stderr` 会继续使用"
" ``backslashreplace`` 如同在任何其他区域选项中一样)。 这种流处理行为可以按通常方式使用 "
":envvar:`PYTHONIOENCODING` 来覆盖。"

#: ../../using/cmdline.rst:1090
msgid ""
"For debugging purposes, setting ``PYTHONCOERCECLOCALE=warn`` will cause "
"Python to emit warning messages on ``stderr`` if either the locale coercion "
"activates, or else if a locale that *would* have triggered coercion is still"
" active when the Python runtime is initialized."
msgstr ""
"出于调试目的，如果激活了区域强制转换，或者如果当 Python 运行时被初始化时某个 *应该* 触发强制转换的区域选项仍处于激活状态则设置 "
"``PYTHONCOERCECLOCALE=warn`` 将导致 Python 在 ``stderr`` 上发出警告消息。"

#: ../../using/cmdline.rst:1095
msgid ""
"Also note that even when locale coercion is disabled, or when it fails to "
"find a suitable target locale, :envvar:`PYTHONUTF8` will still activate by "
"default in legacy ASCII-based locales. Both features must be disabled in "
"order to force the interpreter to use ``ASCII`` instead of ``UTF-8`` for "
"system interfaces."
msgstr ""
"还要注意，即使在区域转换转换被禁用，或者在其无法找到合适的目标区域时，默认 :envvar:`PYTHONUTF8` 仍将在传统的基于 ASCII "
"的区域中被激活。 必须同时禁用这两项特性以强制解释器使用 ``ASCII`` 而不是 ``UTF-8`` 作为系统接口。"

#: ../../using/cmdline.rst:1103
msgid "See :pep:`538` for more details."
msgstr "请参阅 :pep:`538` 了解详情。"

#: ../../using/cmdline.rst:1109
msgid ""
"If this environment variable is set to a non-empty string, enable "
":ref:`Python Development Mode <devmode>`, introducing additional runtime "
"checks that are too expensive to be enabled by default. This is equivalent "
"to setting the :option:`-X` ``dev`` option."
msgstr ""
"如果此环境变量被设为一个非空字符串，则会启用 :ref:`Python 开发模式 "
"<devmode>`，引入在默认情况下启用扩展会导致开销过大的额外运行时检查。 这等价于设置 :option:`-X` ``dev`` 选项。"

#: ../../using/cmdline.rst:1118
msgid "If set to ``1``, enable the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "如果设为 ``1`` ，将会启用  :ref:`Python UTF-8 模式 <utf8-mode>`。"

#: ../../using/cmdline.rst:1120
msgid "If set to ``0``, disable the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "若设为 ``0`` ，则会禁用 :ref:`Python UTF-8 模式 <utf8-mode>` 。"

#: ../../using/cmdline.rst:1122
msgid ""
"Setting any other non-empty string causes an error during interpreter "
"initialisation."
msgstr "设置任何其他非空字符串会在解释器初始化期间导致错误。"

#: ../../using/cmdline.rst:1129
msgid ""
"If this environment variable is set to a non-empty string, issue a "
":class:`EncodingWarning` when the locale-specific default encoding is used."
msgstr "如果该环境变量设为一个非空字符串，则在采用某地区默认编码时，将会引发一条 :class:`EncodingWarning` 。"

#: ../../using/cmdline.rst:1132
msgid "See :ref:`io-encoding-warning` for details."
msgstr "请参阅 :ref:`io-encoding-warning` 来了解详情。"

#: ../../using/cmdline.rst:1138
msgid ""
"If this variable is set, it disables the inclusion of the tables mapping "
"extra location information (end line, start column offset and end column "
"offset) to every instruction in code objects. This is useful when smaller "
"code objects and pyc files are desired as well as suppressing the extra "
"visual location indicators when the interpreter displays tracebacks."
msgstr ""
"如果设置了此变量，它会禁用在代码对象中包括将额外位置信息（结束行、开始列偏移量和结束列偏移量）映射到每条指令的映射表。 这在需要较小的代码对象和 pyc"
" 文件时很有用处并可在解释器显示回溯时屏蔽额外的视觉位置提示。"

#: ../../using/cmdline.rst:1148
msgid ""
"If this variable is set to a nonzero value, it enables support for the Linux"
" ``perf`` profiler so Python calls can be detected by it."
msgstr "如果此变量被设为非零值，它将启用对 Linux ``perf`` 分析器的支持以便 Python 调用能被它检测到。"

#: ../../using/cmdline.rst:1151 ../../using/cmdline.rst:1164
msgid "If set to ``0``, disable Linux ``perf`` profiler support."
msgstr "如果设为 ``0``，则禁用 Linux ``perf`` 性能分析器支持。"

#: ../../using/cmdline.rst:1153
msgid ""
"See also the :option:`-X perf <-X>` command-line option and "
":ref:`perf_profiling`."
msgstr "另请参阅 :option:`-X perf <-X>` 命令行选项和 :ref:`perf_profiling`。"

#: ../../using/cmdline.rst:1160
msgid ""
"If this variable is set to a nonzero value, it enables support for the Linux"
" ``perf`` profiler so Python calls can be detected by it using DWARF "
"information."
msgstr "如果此变量被设为非零值，它将启用对 Linux ``perf`` 分析器的支持以便 Python 调用能被它使用 DWARF 信息来检测。"

#: ../../using/cmdline.rst:1166
msgid ""
"See also the :option:`-X perf_jit <-X>` command-line option and "
":ref:`perf_profiling`."
msgstr "另请参阅 :option:`-X perf_jit <-X>` 命令行选项和 :ref:`perf_profiling`。"

#: ../../using/cmdline.rst:1175
msgid ""
"If this variable is set to a positive integer, it overrides the return "
"values of :func:`os.cpu_count` and :func:`os.process_cpu_count`."
msgstr ""
"如果此变量被设为正整数值，它将覆盖 :func:`os.cpu_count` 和 :func:`os.process_cpu_count` 的返回值。"

#: ../../using/cmdline.rst:1178
msgid "See also the :option:`-X cpu_count <-X>` command-line option."
msgstr "另请参阅 :option:`-X cpu_count <-X>` 命令行选项。"

#: ../../using/cmdline.rst:1184
msgid ""
"If this variable is set to ``on`` or ``off``, it determines whether or not "
"frozen modules are ignored by the import machinery.  A value of ``on`` means"
" they get imported and ``off`` means they are ignored.  The default is "
"``on`` for non-debug builds (the normal case) and ``off`` for debug builds. "
"Note that the :mod:`!importlib_bootstrap` and "
":mod:`!importlib_bootstrap_external` frozen modules are always used, even if"
" this flag is set to ``off``."
msgstr ""
"如果此变量被设为 ``on`` 或 ``off``，它将确定已冻结模块是否要被导入机制所忽略。 值为 ``on`` 表示它们将被导入而 ``off`` "
"表示它们将被忽略。 对于非调试构建版（正常情况）默认为 ``on`` 而对调试构建版则为 ``off``。 请注意 "
":mod:`!importlib_bootstrap` 和 :mod:`!importlib_bootstrap_external` "
"冻结模块总是会被使用，即使该旗标被设为 ``off``。"

#: ../../using/cmdline.rst:1192
msgid "See also the :option:`-X frozen_modules <-X>` command-line option."
msgstr "另请参阅 :option:`-X frozen_modules <-X>` 命令行选项。"

#: ../../using/cmdline.rst:1198
msgid ""
"If this variable is set to ``1``, the interpreter will colorize various "
"kinds of output. Setting it to ``0`` deactivates this behavior. See also "
":ref:`using-on-controlling-color`."
msgstr ""
"如果此变量被设为 ``1``，解释器将对各种输出添加彩色。 将其设为 ``0`` 将禁用此行为。 另请参阅 :ref:`using-on-"
"controlling-color`。"

#: ../../using/cmdline.rst:1206
msgid ""
"If this variable is set to any value, the interpreter will not attempt to "
"load the Python-based :term:`REPL` that requires :mod:`curses` and "
":mod:`readline`, and will instead use the traditional parser-based "
":term:`REPL`."
msgstr ""
"如果此变量被设为任意值，解释器将不再尝试加载需要 :mod:`curses` 和 :mod:`readline` 的基于 Python 的 "
":term:`REPL`，而将改用传统的基于解析器的 :term:`REPL`。"

#: ../../using/cmdline.rst:1215
msgid ""
"This environment variable can be used to set the location of a "
"``.python_history`` file (by default, it is ``.python_history`` in the "
"user's home directory)."
msgstr ""
"此环境变量可被用来设置 ``.python_history`` 文件的位置（在默认情况下，它将为用户主目录下的 ``.python_history`` "
"文件）。"

#: ../../using/cmdline.rst:1223
msgid ""
"If this variable is set to ``1``, the global interpreter lock (GIL) will be "
"forced on. Setting it to ``0`` forces the GIL off (needs Python configured "
"with the :option:`--disable-gil` build option)."
msgstr ""
"如果将此变量设为 ``1``，则将强制启用全局解释器锁 (GIL)。 将其设为 ``0`` 将强制禁用 GIL (需要使用 "
":option:`--disable-gil` 构建选项来配置 Python)。"

#: ../../using/cmdline.rst:1227
msgid ""
"See also the :option:`-X gil <-X>` command-line option, which takes "
"precedence over this variable, and :ref:`whatsnew313-free-threaded-cpython`."
msgstr ""
"另请参阅 :option:`-X gil <-X>` 命令行选项，该选项的优先级高于此变量，并请参阅 :ref:`whatsnew313-free-"
"threaded-cpython`。"

#: ../../using/cmdline.rst:1234
msgid ""
"On builds where experimental just-in-time compilation is available, this "
"variable can force the JIT to be disabled (``0``) or enabled (``1``) at "
"interpreter startup."
msgstr ""
"在支持实验性即时编译（just-in-time compilation，简称 JIT）功能的构建版本中，这个变量可以在解释器启动时强制将 JIT "
"禁用(``0``)或者启用(``1``)。"

#: ../../using/cmdline.rst:1241
msgid "Debug-mode variables"
msgstr "调试模式变量"

#: ../../using/cmdline.rst:1245
msgid ""
"If set, Python will dump objects and reference counts still alive after "
"shutting down the interpreter."
msgstr "如果设置，Python 将在关闭解释器后转储仍存活的对象和引用计数。"

#: ../../using/cmdline.rst:1248 ../../using/cmdline.rst:1256
msgid ""
"Needs Python configured with the :option:`--with-trace-refs` build option."
msgstr "需要使用 :option:`--with-trace-refs` 构建选项来配置 Python。"

#: ../../using/cmdline.rst:1252
msgid ""
"If set, Python will dump objects and reference counts still alive after "
"shutting down the interpreter into a file under the path given as the value "
"to this environment variable."
msgstr "如果设置，Python 将在关闭解释器后将仍然存活的对象和引用计数转储至此环境变量给出的路径所对应的文件中。"

#: ../../using/cmdline.rst:1262
msgid ""
"If this variable is set to a module, that module will be imported early in "
"the interpreter lifecycle, before the :mod:`site` module is executed, and "
"before the :mod:`__main__` module is created. Therefore, the imported module"
" is not treated as :mod:`__main__`."
msgstr ""
"如果此变量被设为一个模块，则该模块将在解释器生命周期的较早阶段被导入，即在 :mod:`site` 模块被执行之前，并在 :mod:`__main__`"
" 模块被创建之前。 因此，这个被导入的模块不会被作为 :mod:`__main__`。"

#: ../../using/cmdline.rst:1267
msgid "This can be used to execute code early during Python initialization."
msgstr "这适用于要早在 Python 初始化期间就执行的代码。"

#: ../../using/cmdline.rst:1269
msgid ""
"To import a submodule, use ``package.module`` as the value, like in an "
"import statement."
msgstr "要导入一个子模块，请使用 ``package.module`` 作为值，就像在 import 语句中那样。"

#: ../../using/cmdline.rst:1272
msgid ""
"See also the :option:`-X presite <-X>` command-line option, which takes "
"precedence over this variable."
msgstr "另请参阅 :option:`-X presite <-X>` 命令行选项，该选项的优先级高于此变量。"

#: ../../using/cmdline.rst:1275
msgid ""
"Needs Python configured with the :option:`--with-pydebug` build option."
msgstr "需要使用 :option:`--with-pydebug` 构建选项来配置 Python。"
