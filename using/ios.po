# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alpha Du <alphanow@gmail.com>, 2024
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:20+0000\n"
"PO-Revision-Date: 2024-05-11 01:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../using/ios.rst:5
msgid "Using Python on iOS"
msgstr "在 iOS 上使用 Python"

#: ../../using/ios.rst:0
msgid "Authors"
msgstr "作者"

#: ../../using/ios.rst:8
msgid "Russell Keith-Magee (2024-03)"
msgstr "Russell Keith-Magee (2024-03)"

#: ../../using/ios.rst:10
msgid ""
"Python on iOS is unlike Python on desktop platforms. On a desktop platform, "
"Python is generally installed as a system resource that can be used by any "
"user of that computer. Users then interact with Python by running a "
":program:`python` executable and entering commands at an interactive prompt,"
" or by running a Python script."
msgstr ""
"在 iOS 上的 Python 不同于桌面平台上的 Python。 在桌面平台上，Python 通常是作为系统资源安装并可供该计算机上的任何用户使用。 "
"用户将通过运行 :program:`python` 可执行文件并在交互提示符下输入命令，或者通过运行 Python 脚本的方式与 Python "
"进行交互。"

#: ../../using/ios.rst:16
msgid ""
"On iOS, there is no concept of installing as a system resource. The only "
"unit of software distribution is an \"app\". There is also no console where "
"you could run a :program:`python` executable, or interact with a Python "
"REPL."
msgstr ""
"在 iOS，不存在作为系统资源安装种概念。 唯一的软件分发单元是 \"app\"。 也不存在可以让你运行 :program:`python` "
"可执行文件，或与 Python REPL 进行交互的控制台。"

#: ../../using/ios.rst:20
msgid ""
"As a result, the only way you can use Python on iOS is in embedded mode - "
"that is, by writing a native iOS application, and embedding a Python "
"interpreter using ``libPython``, and invoking Python code using the "
":ref:`Python embedding API <embedding>`. The full Python interpreter, the "
"standard library, and all your Python code is then packaged as a standalone "
"bundle that can be distributed via the iOS App Store."
msgstr ""
"因此，你在 iOS 上使用 Python 的唯一方式是嵌入模式 —— 也就是说，通过编写原生的 iOS 应用，并使用 ``libPython`` "
"嵌入一个 Python 解释器，然后使用 :ref:`Python 嵌入式 API <embedding>` 来唤起 Python 代码。 完整的 "
"Python 解释器、标准库，以及所有 Python 代码都将被打包为可通过 iOS App Store 发布的独立软件包。"

#: ../../using/ios.rst:27
msgid ""
"If you're looking to experiment for the first time with writing an iOS app "
"in Python, projects such as `BeeWare <https://beeware.org>`__ and `Kivy "
"<https://kivy.org>`__ will provide a much more approachable user experience."
" These projects manage the complexities associated with getting an iOS "
"project running, so you only need to deal with the Python code itself."
msgstr ""
"如果你想要上手尝试以 Python 来编写 iOS app，像 `BeeWare <https://beeware.org>`__ 和 `Kivy "
"<https://kivy.org>`__ 这样的项目将提供更方便的用户体验。 这些项目能够管理支持 iOS 项目运行的相关复杂问题，这样你只需要处理 "
"Python 代码本身。"

#: ../../using/ios.rst:34
msgid "Python at runtime on iOS"
msgstr "iOS 上的 Python 运行时"

#: ../../using/ios.rst:37
msgid "iOS version compatibility"
msgstr "iOS 版本兼容性"

#: ../../using/ios.rst:39
msgid ""
"The minimum supported iOS version is specified at compile time, using the "
":option:`--host` option to ``configure``. By default, when compiled for iOS,"
" Python will be compiled with a minimum supported iOS version of 13.0. To "
"use a different minimum iOS version, provide the version number as part of "
"the :option:`!--host` argument - for example, ``--host=arm64-apple-"
"ios15.4-simulator`` would compile an ARM64 simulator build with a deployment"
" target of 15.4."
msgstr ""
"受支持的最低 iOS 版本是在编译时指定的，对 ``configure`` 使用 :option:`--host` 选项。 在默认情况下，当针对 iOS"
" 编译时，Python 编译将设置受支持的最低 iOS 版本为 13.0。 我使用不同的最低 iOS 版本，请将版本号作为 :option:`!--"
"host` 参数的一部分提供 —— 例如，``--host=arm64-apple-ios15.4-simulator`` 将编译一份部署目标为 "
"15.4 的 ARM64 模拟器构建版。"

#: ../../using/ios.rst:48
msgid "Platform identification"
msgstr "平台识别"

#: ../../using/ios.rst:50
msgid ""
"When executing on iOS, ``sys.platform`` will report as ``ios``. This value "
"will be returned on an iPhone or iPad, regardless of whether the app is "
"running on the simulator or a physical device."
msgstr ""
"当在 iOS 上执行时，``sys.platform`` 将报告为 ``ios``。 无论 app 是在模拟器还是物理设备上运行，都将在 iPhone "
"或 iPad 上返回该值。"

#: ../../using/ios.rst:54
msgid ""
"Information about the specific runtime environment, including the iOS "
"version, device model, and whether the device is a simulator, can be "
"obtained using :func:`platform.ios_ver`. :func:`platform.system` will report"
" ``iOS`` or ``iPadOS``, depending on the device."
msgstr ""
"有关特定运行时环境的信息，包括 iOS 版本、设备型号以及设备是否为模拟器，可使用 :func:`platform.ios_ver` 来获取。 "
":func:`platform.system` 将根据具体设备报告为 ``iOS`` 或 ``iPadOS``。"

#: ../../using/ios.rst:59
msgid ""
":func:`os.uname` reports kernel-level details; it will report a name of "
"``Darwin``."
msgstr ":func:`os.uname` 报告内核等级的详情；它将报告系统名称 ``Darwin``。"

#: ../../using/ios.rst:63
msgid "Standard library availability"
msgstr "标准库可用性"

#: ../../using/ios.rst:65
msgid ""
"The Python standard library has some notable omissions and restrictions on "
"iOS. See the :ref:`API availability guide for iOS <mobile-availability>` for"
" details."
msgstr ""
"Python 标准库在standard library has some notable omissions and restrictions on "
"iOS 上有一点需要注意的缺失和限制。 请参阅 :ref:`针对 iOS 的 API 可用性指南 <mobile-availability>` "
"了解详情。"

#: ../../using/ios.rst:70
msgid "Binary extension modules"
msgstr "二进制扩展模块"

#: ../../using/ios.rst:72
msgid ""
"One notable difference about iOS as a platform is that App Store "
"distribution imposes hard requirements on the packaging of an application. "
"One of these requirements governs how binary extension modules are "
"distributed."
msgstr ""
"作为一个平台的 iOS 与别家的显著不同之处在于 App Store "
"分发机制对应用的打包方式设置了硬性要求。其中一项要求规定了应当如何分发二进制扩展模块。"

#: ../../using/ios.rst:76
msgid ""
"The iOS App Store requires that *all* binary modules in an iOS app must be "
"dynamic libraries, contained in a framework with appropriate metadata, "
"stored in the ``Frameworks`` folder of the packaged app. There can be only a"
" single binary per framework, and there can be no executable binary material"
" outside the ``Frameworks`` folder."
msgstr ""
"iOS App Store 要求 iOS app 中的 *所有* 二进制模块都必须为动态库，包含在具有适当元数据的框架中，保存于被打包 app 的 "
"``Frameworks`` 文件夹下。 每个框架只能有一个二进制模块，而在 ``Frameworks`` 文件夹之外不能有可执行的二进制文件。"

#: ../../using/ios.rst:82
msgid ""
"This conflicts with the usual Python approach for distributing binaries, "
"which allows a binary extension module to be loaded from any location on "
"``sys.path``. To ensure compliance with App Store policies, an iOS project "
"must post-process any Python packages, converting ``.so`` binary modules "
"into individual standalone frameworks with appropriate metadata and signing."
" For details on how to perform this post-processing, see the guide for "
":ref:`adding Python to your project <adding-ios>`."
msgstr ""
"这与 Python 通常用于发布二进制文件的方式存在冲突，此方式允许从 ``sys.path`` 上的任何位置加载二进制扩展模块。 为确保符合 App "
"Store 的政策，iOS 项目必须对任何 Python 包进行后期处理，将 ``.so`` 二进制模块转换为具有适当元数据和签名的单个独立框架。 "
"有关如何执行后期处理的更多细节，请参阅 :ref:`将 Python 添加到你的项目 <adding-ios>` 指南。"

#: ../../using/ios.rst:90
msgid ""
"To help Python discover binaries in their new location, the original ``.so``"
" file on ``sys.path`` is replaced with a ``.fwork`` file. This file is a "
"text file containing the location of the framework binary, relative to the "
"app bundle. To allow the framework to resolve back to the original location,"
" the framework must contain a ``.origin`` file that contains the location of"
" the ``.fwork`` file, relative to the app bundle."
msgstr ""
"为帮助 Python 在新位置中发现二进制文件，在 ``sys.path`` 中的原始 ``.so`` 文件将替换为 ``.fwork`` 文件。 "
"此文件是一个包含框架二进制文件相对于 app 捆绑包位置的文本文件。 为允许框架将其解析回原始位置，框架必须包含一个 ``.origin`` "
"文件，其中包含 ``.fwork`` 相对对 app 捆绑包的位置。"

#: ../../using/ios.rst:97
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module "
"``sources/foo/bar/_whiz.abi3.so``, with ``sources`` being the location "
"registered on ``sys.path``, relative to the application bundle. This module "
"*must* be distributed as "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (creating the framework"
" name from the full import path of the module), with an ``Info.plist`` file "
"in the ``.framework`` directory identifying the binary as a framework. The "
"``foo.bar._whiz`` module would be represented in the original location with "
"a ``sources/foo/bar/_whiz.abi3.fwork`` marker file, containing the path "
"``Frameworks/foo.bar._whiz/foo.bar._whiz``. The framework would also contain"
" ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, containing the"
" path to the ``.fwork`` file."
msgstr ""
"例如，考虑导入 ``from foo.bar import _whiz`` 的情况，其中 ``_whiz`` 是使用二进制模块 "
"``sources/foo/bar/_whiz.abi3.so`` 实现的，这里 ``sources`` 是在 ``sys.path`` 中注册的相对于"
" app 包的位置。 此模块 *必须* 发布为 ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz``"
" (根据模块的完整导入路径创建框架名称)，并通过 ``.framework`` 目录中的 ``Info.plist`` 文件将二进制文件标识为一个框架。"
" ``foo.bar._whiz`` 模块在原始位置中以一个 ``sources/foo/bar/_whiz.abi3.fwork`` "
"标记文件来代表，其中包含路径 ``Frameworks/foo.bar._whiz/foo.bar._whiz``。 该框架还要包含 "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``，其中包含 ``.fwork`` "
"文件的路径。"

#: ../../using/ios.rst:110
msgid ""
"When running on iOS, the Python interpreter will install an "
":class:`~importlib.machinery.AppleFrameworkLoader` that is able to read and "
"import ``.fwork`` files. Once imported, the ``__file__`` attribute of the "
"binary module will report as the location of the ``.fwork`` file. However, "
"the :class:`~importlib.machinery.ModuleSpec` for the loaded module will "
"report the ``origin`` as the location of the binary in the framework folder."
msgstr ""
"当在 iOS 上运行时，Python 解释器将安装一个能够读取并导入 ``.fwork`` 文件的 "
":class:`~importlib.machinery.AppleFrameworkLoader`。 一旦被导入，该二进制模块的 "
"``__file__`` 属性将报告为 ``.fwork`` 文件的位置。 不过，被加载模块的 "
":class:`~importlib.machinery.ModuleSpec` 则会将 ``origin`` 报告为框架文件夹下的二进制文件的位置。"

#: ../../using/ios.rst:118
msgid "Compiler stub binaries"
msgstr "编译器存根二进制文件"

#: ../../using/ios.rst:120
msgid ""
"Xcode doesn't expose explicit compilers for iOS; instead, it uses an "
"``xcrun`` script that resolves to a full compiler path (e.g., ``xcrun --sdk "
"iphoneos clang`` to get the ``clang`` for an iPhone device). However, using "
"this script poses two problems:"
msgstr ""
"Xcode 不会暴露针对 iOS 的显式编译器；作为替代，它会使用一个能解析出完整编译器路径的 ``xcrun`` 脚本 (例如，``xcrun "
"--sdk iphoneos clang`` 将获得针对 iPhone 设备的 ``clang``)。 不过，使用此脚本会导致两个问题："

#: ../../using/ios.rst:125
msgid ""
"The output of ``xcrun`` includes paths that are machine specific, resulting "
"in a sysconfig module that cannot be shared between users; and"
msgstr "``xcrun`` 的输出包括特定机器专属的路径，这导致无法在用户之间共享 sysconfig 模块；并且"

#: ../../using/ios.rst:128
msgid ""
"It results in ``CC``/``CPP``/``LD``/``AR`` definitions that include spaces. "
"There is a lot of C ecosystem tooling that assumes that you can split a "
"command line at the first space to get the path to the compiler executable; "
"this isn't the case when using ``xcrun``."
msgstr ""
"它会导致包括空格的 ``CC``/``CPP``/``LD``/``AR`` 定义。 有大量 C "
"生态系统工具假定你可以在第一个空格处拆分命令行来获取编译器可执行文件的路径；当使用 ``xcrun`` 这是不行的。"

#: ../../using/ios.rst:133
msgid ""
"To avoid these problems, Python provided stubs for these tools. These stubs "
"are shell script wrappers around the underingly ``xcrun`` tools, distributed"
" in a ``bin`` folder distributed alongside the compiled iOS framework. These"
" scripts are relocatable, and will always resolve to the appropriate local "
"system paths. By including these scripts in the bin folder that accompanies "
"a framework, the contents of the ``sysconfig`` module becomes useful for "
"end-users to compile their own modules. When compiling third-party Python "
"modules for iOS, you should ensure these stub binaries are on your path."
msgstr ""
"为避免这些问题，Python 提供了针对这些工具的程序段。 这些代码段是在下层 ``xcrun`` 工具之上的 shell "
"脚本包装器，发布在随同已编译的 iOS 框架一起分发的 ``bin`` 文件夹中。 这些脚本可以被重新调整位置，并且总是会解析到正确的本机系统路径。 "
"通过在配合框架的 bin 文件夹中包括这些脚本，``sysconfig`` 模块的内容将可适用于要编译他们自己的模块的最终用户。 在为 iOS "
"编译第三方 Python 模块时，你应当确保这些程序段二进制文件位于你的路径中。"

#: ../../using/ios.rst:143
msgid "Installing Python on iOS"
msgstr "在 iOS 上安装 Python"

#: ../../using/ios.rst:146
msgid "Tools for building iOS apps"
msgstr "构建 iOS 应用程序的工具"

#: ../../using/ios.rst:148
msgid ""
"Building for iOS requires the use of Apple's Xcode tooling. It is strongly "
"recommended that you use the most recent stable release of Xcode. This will "
"require the use of the most (or second-most) recently released macOS "
"version, as Apple does not maintain Xcode for older macOS versions. The "
"Xcode Command Line Tools are not sufficient for iOS development; you need a "
"*full* Xcode install."
msgstr ""
"针对 iOS 构建需要使用 Apple 的 Xcode 工具集。 强烈建议你使用 Xcode 最新稳定发布版。 这将需要使用最新（或者次新）发布的 "
"macOS 版本，因为 Apple 不会为更旧的 macOS 版本维护 Xcode。 Xcode 命令行工具对于 iOS 开发来说是不够的；你需要 "
"*完整的* Xcode 安装版。"

#: ../../using/ios.rst:155
msgid ""
"If you want to run your code on the iOS simulator, you'll also need to "
"install an iOS Simulator Platform. You should be prompted to select an iOS "
"Simulator Platform when you first run Xcode. Alternatively, you can add an "
"iOS Simulator Platform by selecting from the Platforms tab of the Xcode "
"Settings panel."
msgstr ""
"如果你想要在 iOS 模拟器上运行你的代码，你还需要安装 iOS 模拟器平台。 当你首次运行 Xcode 应该会提示你选择一个 iOS 模拟器平台。 "
"或者，你也可以通过在 Settings 面板的 Platforms 选项卡中添加一个 iOS 模拟器平台。"

#: ../../using/ios.rst:163
msgid "Adding Python to an iOS project"
msgstr "在 iOS 项目中添加 Python"

#: ../../using/ios.rst:165
msgid ""
"Python can be added to any iOS project, using either Swift or Objective C. "
"The following examples will use Objective C; if you are using Swift, you may"
" find a library like `PythonKit <https://github.com/pvieito/PythonKit>`__ to"
" be helpful."
msgstr ""
"Python 可以被添加到任何 iOS 项目，不论它是使用 Swift 还是 Objective C。 下面的例子将使用 Objective "
"C；如果你是使用 Swift，你可能会发现 `PythonKit <https://github.com/pvieito/PythonKit>`__ "
"这样的库非常有用。"

#: ../../using/ios.rst:170
msgid "To add Python to an iOS Xcode project:"
msgstr "要在 iOS Xcode 项目中添加 Python："

#: ../../using/ios.rst:172
msgid ""
"Build or obtain a Python ``XCFramework``. See the instructions in "
":source:`iOS/README.rst` (in the CPython source distribution) for details on"
" how to build a Python ``XCFramework``. At a minimum, you will need a build "
"that supports ``arm64-apple-ios``, plus one of either ``arm64-apple-ios-"
"simulator`` or ``x86_64-apple-ios-simulator``."
msgstr ""
"构建或是获取一个 Python ``XCFramework``。 请参阅 :source:`iOS/README.rst` (在 CPython "
"源代码发布包中) 中的说明了解有关如何构建 Python ``XCFramework`` 的细节。 要满足最基本要求，你需要一个支持 "
"``arm64-apple-ios``，再加上 ``arm64-apple-ios-simulator`` 或 ``x86_64-apple-ios-"
"simulator`` 之一的构建版。"

#: ../../using/ios.rst:178
msgid ""
"Drag the ``XCframework`` into your iOS project. In the following "
"instructions, we'll assume you've dropped the ``XCframework`` into the root "
"of your project; however, you can use any other location that you want by "
"adjusting paths as needed."
msgstr ""
"将 ``XCframework`` 拖到你的 iOS 项目中。 在下面的说明中，我们将假定你已将 ``XCframework`` "
"放到你的项目的根目录下；不过，你也可以通过按需调整路径来使用任何其他你想要的位置。"

#: ../../using/ios.rst:183
msgid ""
"Drag the ``iOS/Resources/dylib-Info-template.plist`` file into your project,"
" and ensure it is associated with the app target."
msgstr ""
"将 ``iOS/Resources/dylib-Info-template.plist`` 文件拖到你的项目中，并确保它已关联到 app 目标。"

#: ../../using/ios.rst:186
msgid ""
"Add your application code as a folder in your Xcode project. In the "
"following instructions, we'll assume that your user code is in a folder "
"named ``app`` in the root of your project; you can use any other location by"
" adjusting paths as needed. Ensure that this folder is associated with your "
"app target."
msgstr ""
"将你的应用程序代码作为一个文件夹添加到你的 Xcode 项目中。 在下面的说明中，我们将假定你的用户代码位于你的项目中名为 ``app`` "
"的文件夹；你也可以通过按需调整路径来使用任何其他位置。 请确保该文件夹已关联到你的 app 目标。"

#: ../../using/ios.rst:192
msgid ""
"Select the app target by selecting the root node of your Xcode project, then"
" the target name in the sidebar that appears."
msgstr "通过选择你的 Xcode 项目的根节点来选择 app 目标，然后在边栏中出现的目标名称进行选择。"

#: ../../using/ios.rst:195
msgid ""
"In the \"General\" settings, under \"Frameworks, Libraries and Embedded "
"Content\", add ``Python.xcframework``, with \"Embed & Sign\" selected."
msgstr ""
"在 \"General\" 设置中，在 \"Frameworks, Libraries and Embedded Content\" 之下，增加了 "
"``Python.xcframework``，并选中 \"Embed & Sign\"。"

#: ../../using/ios.rst:198
msgid "In the \"Build Settings\" tab, modify the following:"
msgstr "在\"构建设置\"选项卡中，修改以下内容："

#: ../../using/ios.rst:200
msgid "Build Options"
msgstr "构建选项"

#: ../../using/ios.rst:202
msgid "User Script Sandboxing: No"
msgstr "用户脚本沙盒：否"

#: ../../using/ios.rst:203
msgid "Enable Testability: Yes"
msgstr "启用可测试性：是"

#: ../../using/ios.rst:205
msgid "Search Paths"
msgstr "搜索路径"

#: ../../using/ios.rst:207
msgid "Framework Search Paths: ``$(PROJECT_DIR)``"
msgstr "框架搜索路径： ``$(PROJECT_DIR)``"

#: ../../using/ios.rst:208
msgid ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"
msgstr "头文件搜索路径： ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"

#: ../../using/ios.rst:210
msgid "Apple Clang - Warnings - All languages"
msgstr "Apple Clang - 警告 - 所有语言"

#: ../../using/ios.rst:212
msgid "Quoted Include In Framework Header: No"
msgstr "引用包含在框架头文件中：否"

#: ../../using/ios.rst:214
msgid ""
"Add a build step that copies the Python standard library into your app. In "
"the \"Build Phases\" tab, add a new \"Run Script\" build step *before* the "
"\"Embed Frameworks\" step, but *after* the \"Copy Bundle Resources\" step. "
"Name the step \"Install Target Specific Python Standard Library\", disable "
"the \"Based on dependency analysis\" checkbox, and set the script content "
"to:"
msgstr ""
"添加一个用于将 Python 标准库拷贝到你的 app 中的构建步骤。 在 \"Build Phases\" 选项卡中，在 \"Embed "
"Frameworks\" 步骤 *之前*，\"Copy Bundle Resources\" 步骤 *之后* 添加一个新的 \"Run Script\""
" 构建步骤。 将该步骤命名为 \"Install Target Specific Python Standard Library\"，取消 "
"\"Based on dependency analysis\" 复选框，并将脚本内容设为："

#: ../../using/ios.rst:220
msgid ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"
msgstr ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"

#: ../../using/ios.rst:233
msgid ""
"Note that the name of the simulator \"slice\" in the XCframework may be "
"different, depending the CPU architectures your ``XCFramework`` supports."
msgstr ""
"请注意 XCframework 中的模拟器名称 \"slice\" 可能有所不同，具体取决于你的 ``XCFramework`` 所支持的 CPU "
"架构。"

#: ../../using/ios.rst:236
msgid ""
"Add a second build step that processes the binary extension modules in the "
"standard library into \"Framework\" format. Add a \"Run Script\" build step "
"*directly after* the one you added in step 8, named \"Prepare Python Binary "
"Modules\". It should also have \"Based on dependency analysis\" unchecked, "
"with the following script content:"
msgstr ""
"再添加第二个用于将标准库中的二进制扩展模块处理为 \"Framework\" 格式的构建步骤。 紧随你在第 8 步添加的步骤 *之后立即* 添加一个 "
"\"Run Script\" 构建步骤，命名为 \"Prepare Python Binary Modules\"。 它应当取消选择 \"Based "
"on dependency analysis\"，并将脚本内容设为："

#: ../../using/ios.rst:242
msgid ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # The name of the extension file\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # The location of the extension file, relative to the bundle\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # The path to the extension file, relative to the install base\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # The full dotted name of the extension module, constructed from the file path.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \".\");\n"
"    # A bundle identifier; not actually used, but required by Xcode framework packaging\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME | tr \"_\" \"-\")\n"
"    # The name of the framework folder.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # If the framework folder doesn't exist, create it.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    # Create a placeholder .fwork file where the .so was\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Create a back reference to the .so file location in the framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name \"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Clean up dylib template\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME ($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" ${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"
msgstr ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # 扩展文件的名称\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # 扩展文件相对与捆绑包的位置\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # 扩展文件相对于安装目录的路径\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # 扩展模块带点号的完整名称，根据文件目录来构造。\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \".\");\n"
"    # 捆绑包标识；未实际使用，但为 Xcode 框架打包所必需\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME | tr \"_\" \"-\")\n"
"    # 框架文件夹的名称。\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # 如果框架文件夹不存在，则创建它。\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    # 创建占位用 .fwork 文件指明 .so 所在位置\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # 在框架中创建指向 .so 文件位置的反向引用\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name \"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # 清理 dylib 模板\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME ($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" ${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"

#: ../../using/ios.rst:292
msgid ""
"Add Objective C code to initialize and use a Python interpreter in embedded "
"mode. You should ensure that:"
msgstr "添加 Objective C 代码来初始化并使用嵌入模式的 Python 解释器。 你应当确保："

#: ../../using/ios.rst:295
msgid "UTF-8 mode (:c:member:`PyPreConfig.utf8_mode`) is *enabled*;"
msgstr "UTF-8 模式 (:c:member:`PyPreConfig.utf8_mode`) *已启用*;"

#: ../../using/ios.rst:296
msgid "Buffered stdio (:c:member:`PyConfig.buffered_stdio`) is *disabled*;"
msgstr "带缓冲的 stdio (:c:member:`PyConfig.buffered_stdio`) *已禁用*;"

#: ../../using/ios.rst:297
msgid "Writing bytecode (:c:member:`PyConfig.write_bytecode`) is *disabled*;"
msgstr "写入字节码 (:c:member:`PyConfig.write_bytecode`) *已禁用*;"

#: ../../using/ios.rst:298
msgid ""
"Signal handlers (:c:member:`PyConfig.install_signal_handlers`) are "
"*enabled*;"
msgstr "信号处理器 (:c:member:`PyConfig.install_signal_handlers`) *已启用*;"

#: ../../using/ios.rst:299
msgid ""
"System logging (:c:member:`PyConfig.use_system_logger`) is *enabled* "
"(optional, but strongly recommended; this is enabled by default);"
msgstr ""
"系统日志记录 (:c:member:`PyConfig.use_system_logger`) *已启用* (可选项，但强烈建议启用；默认是启用的);"

#: ../../using/ios.rst:301
msgid ""
":envvar:`PYTHONHOME` for the interpreter is configured to point at the "
"``python`` subfolder of your app's bundle; and"
msgstr "用于解释器的 :envvar:`PYTHONHOME` 将被配置为指向你的 app 捆绑包的 ``python`` 子文件夹；并且"

#: ../../using/ios.rst:303
msgid "The :envvar:`PYTHONPATH` for the interpreter includes:"
msgstr "用于解释器的 :envvar:`PYTHONPATH` 包括："

#: ../../using/ios.rst:305
msgid "the ``python/lib/python3.X`` subfolder of your app's bundle,"
msgstr "你的 app 的封包的 ``python/lib/python3.X`` 子文件夹，"

#: ../../using/ios.rst:306
msgid ""
"the ``python/lib/python3.X/lib-dynload`` subfolder of your app's bundle, and"
msgstr "你的 app 的封包的 ``python/lib/python3.X/lib-dynload`` 子文件夹，以及"

#: ../../using/ios.rst:307
msgid "the ``app`` subfolder of your app's bundle"
msgstr "你的 app 的封包的 ``app`` 子文件夹"

#: ../../using/ios.rst:309
msgid ""
"Your app's bundle location can be determined using ``[[NSBundle mainBundle] "
"resourcePath]``."
msgstr "你的 app 捆绑包的位置可使用 ``[[NSBundle mainBundle] resourcePath]`` 来确定。"

#: ../../using/ios.rst:312
msgid ""
"Steps 8, 9 and 10 of these instructions assume that you have a single folder"
" of pure Python application code, named ``app``. If you have third-party "
"binary modules in your app, some additional steps will be required:"
msgstr ""
"这些说明的步骤 8, 9 和 10 均假定你有一个单独的纯 Python 应用程序代码文件夹，其名称为 ``app``。 如果在你的 app "
"中还存在第三方二进制模块，则还需要一些额外的步骤："

#: ../../using/ios.rst:316
msgid ""
"You need to ensure that any folders containing third-party binaries are "
"either associated with the app target, or copied in as part of step 8. Step "
"8 should also purge any binaries that are not appropriate for the platform a"
" specific build is targeting (i.e., delete any device binaries if you're "
"building an app targeting the simulator)."
msgstr ""
"你需要确保任何包含第二方二进制文件的文件夹均已关联到 app 目标，或已作为第 8 步的一部分被拷贝。 第 8 "
"步还应当清理任何对于特定构建目标的平台来说不适用的二进制文件（即当你要构建以该模拟器为目标的 app 就应删除任何设备二进制文件）。"

#: ../../using/ios.rst:322
msgid ""
"Any folders that contain third-party binaries must be processed into "
"framework form by step 9. The invocation of ``install_dylib`` that processes"
" the ``lib-dynload`` folder can be copied and adapted for this purpose."
msgstr ""
"任何包含第三方二进制文件的文件夹都必须通过第 9 步处理为框架形式。 可以拷贝并调整对于处理 ``lib-dynload`` 文件夹的 "
"``install_dylib`` 唤起的代码以符合这一目的。"

#: ../../using/ios.rst:326
msgid ""
"If you're using a separate folder for third-party packages, ensure that "
"folder is included as part of the :envvar:`PYTHONPATH` configuration in step"
" 10."
msgstr ""
"如果你使用了单独的文件夹来放置第三方包，请确保该文件夹已在第 10 步中作为 :envvar:`PYTHONPATH` 配置的一部分被包括在内。"

#: ../../using/ios.rst:329
msgid ""
"If any of the folders that contain third-party packages will contain "
"``.pth`` files, you should add that folder as a *site directory* (using "
":meth:`site.addsitedir`), rather than adding to :envvar:`PYTHONPATH` or "
":attr:`sys.path` directly."
msgstr ""
"如果有任何包含第三方包的文件夹包含了 ``.pth`` 文件，你应当将该文件夹添加为 *site 目录* (使用 "
":meth:`site.addsitedir`)，而不是直接添加到 :envvar:`PYTHONPATH` 或 :attr:`sys.path`。"

#: ../../using/ios.rst:335
msgid "Testing a Python package"
msgstr "测试 Python 软件包"

#: ../../using/ios.rst:337
msgid ""
"The CPython source tree contains :source:`a testbed project <iOS/testbed>` "
"that is used to run the CPython test suite on the iOS simulator. This "
"testbed can also be used as a testbed project for running your Python "
"library's test suite on iOS."
msgstr ""
"CPython 源码树包含一个 :source:`testbed 项目 <iOS/testbed>` 用于在 iOS 模拟器上运行 CPython "
"测试套件。 这个 testbed 还可被用作在 iOS 上运行你的 Python 库的测试套件的 testbed 项目。"

#: ../../using/ios.rst:341
msgid ""
"After building or obtaining an iOS XCFramework (See :source:`iOS/README.rst`"
" for details), create a clone of the Python iOS testbed project by running:"
msgstr ""
"在构建或获取 iOS XCFramework (请参见 :source:`iOS/README.rst` 了解详情) 之后，通过运行以下命令创建 "
"Python iOS testbed 项目的克隆："

#: ../../using/ios.rst:344
msgid ""
"$ python iOS/testbed clone --framework <path/to/Python.xcframework> --app "
"<path/to/module1> --app <path/to/module2> app-testbed"
msgstr ""
"$ python iOS/testbed clone --framework <path/to/Python.xcframework> --app "
"<path/to/module1> --app <path/to/module2> app-testbed"

#: ../../using/ios.rst:348
msgid ""
"You will need to modify the ``iOS/testbed`` reference to point to that "
"directory in the CPython source tree; any folders specified with the "
"``--app`` flag will be copied into the cloned testbed project. The resulting"
" testbed will be created in the ``app-testbed`` folder. In this example, the"
" ``module1`` and ``module2`` would be importable modules at runtime. If your"
" project has additional dependencies, they can be installed into the ``app-"
"testbed/iOSTestbed/app_packages`` folder (using ``pip install --target app-"
"testbed/iOSTestbed/app_packages`` or similar)."
msgstr ""
"你将需要将 ``iOS/testbed`` 引用修改为指向 CPython 源码树的相应目录；任何使用 ``--app`` "
"旗标指定的文件夹都将被拷贝到克隆的 testbed 项目中。 结果 testbed 将在 ``app-testbed`` 文件夹中被创建。 "
"在本示例中，``module1`` 和 ``module2`` 将成为运行时可导入的模块。 如果你的项目还有额外的依赖项，它们可以被安装到 ``app-"
"testbed/iOSTestbed/app_packages`` 文件夹中 (使用类似 ``pip install --target app-"
"testbed/iOSTestbed/app_packages`` 的命令)。"

#: ../../using/ios.rst:357
msgid ""
"You can then use the ``app-testbed`` folder to run the test suite for your "
"app, For example, if ``module1.tests`` was the entry point to your test "
"suite, you could run:"
msgstr ""
"你可以随后使用 ``app-testbed`` 文件夹来运行你的 app 的测试套件，举例来说，如果 ``module1.tests`` "
"是你的测试套件的入口点，你可以运行："

#: ../../using/ios.rst:361
msgid "$ python app-testbed run -- module1.tests"
msgstr "$ python app-testbed run -- module1.tests"

#: ../../using/ios.rst:365
msgid ""
"This is the equivalent of running ``python -m module1.tests`` on a desktop "
"Python build. Any arguments after the ``--`` will be passed to the testbed "
"as if they were arguments to ``python -m`` on a desktop machine."
msgstr ""
"这相当于在桌面 Python 构建版上运行 ``python -m module1.tests``。 任何在 ``--`` 之后的参数都将被传给 "
"testbed 就像它们是桌面机上 ``python -m`` 的参数那样。"

#: ../../using/ios.rst:369
msgid "You can also open the testbed project in Xcode by running:"
msgstr "你还可以通过运行以下命令在 Xcode 中打开这个 testbed 项目："

#: ../../using/ios.rst:371
msgid "$ open app-testbed/iOSTestbed.xcodeproj"
msgstr "$ open app-testbed/iOSTestbed.xcodeproj"

#: ../../using/ios.rst:375
msgid ""
"This will allow you to use the full Xcode suite of tools for debugging."
msgstr "这将允许你使用完整的 Xcode 工具套件进行调试。"

#: ../../using/ios.rst:378
msgid "App Store Compliance"
msgstr "App Store 合规性"

#: ../../using/ios.rst:380
msgid ""
"The only mechanism for distributing apps to third-party iOS devices is to "
"submit the app to the iOS App Store; apps submitted for distribution must "
"pass Apple's app review process. This process includes a set of automated "
"validation rules that inspect the submitted application bundle for "
"problematic code."
msgstr ""
"将 app 发布到第三方 iOS 设备的唯一机制是将 app 提交到 iOS App Store；提交发布的 app 必须通过 Apple 的 app "
"审核进程。 此进程包括一组在所提交的应用程序包中自动检查有问题代码的验证规则。"

#: ../../using/ios.rst:385
msgid ""
"The Python standard library contains some code that is known to violate "
"these automated rules. While these violations appear to be false positives, "
"Apple's review rules cannot be challenged; so, it is necessary to modify the"
" Python standard library for an app to pass App Store review."
msgstr ""
"Python 标准库包含了一些已知会违反这些自动规则的代码。 虽然这些违规情况看来是属于误报，但 Apple 的审核规则是不可挑战的；因此，有必要修改 "
"Python 标准库以便 app 能够通过 App Store 的审核。"

#: ../../using/ios.rst:390
msgid ""
"The Python source tree contains :source:`a patch file <Mac/Resources/app-"
"store-compliance.patch>` that will remove all code that is known to cause "
"issues with the App Store review process. This patch is applied "
"automatically when building for iOS."
msgstr ""
"Python 源代码树包含 :source:`一个补丁文件 <Mac/Resources/app-store-compliance.patch>` "
"可移除所有已知的会导致 App Store 审核过程出现问题的代码。 这个补丁会在针对 iOS 进行构建时自动应用。"
