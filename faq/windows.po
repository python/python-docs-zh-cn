# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 18:10+0000\n"
"PO-Revision-Date: 2025-07-18 20:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/windows.rst:9
msgid "Python on Windows FAQ"
msgstr "Python在Windows上的常见问题"

#: ../../faq/windows.rst:12
msgid "Contents"
msgstr "目录"

#: ../../faq/windows.rst:22
msgid "How do I run a Python program under Windows?"
msgstr "我怎样在Windows下运行一个Python程序？"

#: ../../faq/windows.rst:24
msgid ""
"This is not necessarily a straightforward question. If you are already "
"familiar with running programs from the Windows command line then everything"
" will seem obvious; otherwise, you might need a little more guidance."
msgstr "这不一定是一个简单的问题。如果你已经熟悉在Windows的命令行中运行程序的方法，一切都显而易见；不然的话，你也许需要额外获得些许指导。"

#: ../../faq/windows.rst:28
msgid ""
"Unless you use some sort of integrated development environment, you will end"
" up *typing* Windows commands into what is referred to as a \"Command prompt"
" window\".  Usually you can create such a window from your search bar by "
"searching for ``cmd``.  You should be able to recognize when you have "
"started such a window because you will see a Windows \"command prompt\", "
"which usually looks like this:"
msgstr ""
"除非你使用某种集成开发环境，否则你最终会在所谓的 \"命令提示窗口 \"中 *输入* Windows命令。 通常情况下，你可以在搜索栏中搜索 "
"``cmd`` 来创建这样一个窗口。你应该能够发现你已经启动了这样一个窗口，因为你会看到一个 Windows \"命令提示符\"，它通常看起来像这样。"

#: ../../faq/windows.rst:39
msgid ""
"The letter may be different, and there might be other things after it, so "
"you might just as easily see something like:"
msgstr "前面的字母可能会不同，而且后面有可能会有其他东西，所以你也许会看到类似这样的东西："

#: ../../faq/windows.rst:46
msgid ""
"depending on how your computer has been set up and what else you have "
"recently done with it.  Once you have started such a window, you are well on"
" the way to running Python programs."
msgstr "出现的内容具体取决与你的电脑如何设置和最近用它做的事。 当你启动了这样一个窗口后，就可以开始运行Python程序了。"

#: ../../faq/windows.rst:50
msgid ""
"You need to realize that your Python scripts have to be processed by another"
" program called the Python *interpreter*.  The interpreter reads your "
"script, compiles it into bytecodes, and then executes the bytecodes to run "
"your program. So, how do you arrange for the interpreter to handle your "
"Python?"
msgstr ""
"Python 脚本需要被另外一个叫做 Python *解释器* 的程序来处理。 解释器读取脚本，把它编译成字节码，然后执行字节码来运行你的程序。 "
"所以怎样安排解释器来处理你的 Python 脚本呢？"

#: ../../faq/windows.rst:55
msgid ""
"First, you need to make sure that your command window recognises the word "
"\"py\" as an instruction to start the interpreter.  If you have opened a "
"command window, you should try entering the command ``py`` and hitting "
"return:"
msgstr "首先，确保命令窗口能够将“py”识别为指令来开启解释器。 如果你打开过一个命令窗口， 尝试输入命令 ``py`` 然后按回车："

#: ../../faq/windows.rst:64
msgid "You should then see something like:"
msgstr "然后你应当看见类似类似这样的东西："

#: ../../faq/windows.rst:72
msgid ""
"You have started the interpreter in \"interactive mode\". That means you can"
" enter Python statements or expressions interactively and have them executed"
" or evaluated while you wait.  This is one of Python's strongest features.  "
"Check it by entering a few expressions of your choice and seeing the "
"results:"
msgstr ""
"解释器已经以“交互模式”打开。这意味着你可以交互输入Python语句或表达式，并在等待时执行或评估它们。这是Python最强大的功能之一。输入几个表达式并看看结果："

#: ../../faq/windows.rst:84
msgid ""
"Many people use the interactive mode as a convenient yet highly programmable"
" calculator.  When you want to end your interactive Python session, call the"
" :func:`exit` function or hold the :kbd:`Ctrl` key down while you enter a "
":kbd:`Z`, then hit the \":kbd:`Enter`\" key to get back to your Windows "
"command prompt."
msgstr ""
"许多人把交互模式当作方便和高度可编程的计算器。 想结束交互式Python会话时，调用 :func:`exit` 函数，或者按住 :kbd:`Ctrl` "
"键时输入 :kbd:`Z`  ，之后按 :kbd:`Enter` 键返回Windows命令提示符。"

#: ../../faq/windows.rst:90
msgid ""
"You may also find that you have a Start-menu entry such as "
":menuselection:`Start --> Programs --> Python 3.x --> Python (command line)`"
" that results in you seeing the ``>>>`` prompt in a new window.  If so, the "
"window will disappear after you call the :func:`exit` function or enter the "
":kbd:`Ctrl-Z` character; Windows is running a single \"python\" command in "
"the window, and closes it when you terminate the interpreter."
msgstr ""
"你可能发现在开始菜单有这样一个条目 :menuselection:`开始 --> 所有程序 --> Python 3.x --> Python "
"(命令行)`， 运行它后会出现一个有着 ``>>>`` 提示的新窗口。 在此之后，如果调用 :func:`exit` 函数或按 "
":kbd:`Ctrl-Z` 组合键后窗口将会消失。 Windows 会在这个窗口中运行一个“python”命令，并且在你终止解释器的时候关闭它。"

#: ../../faq/windows.rst:97
msgid ""
"Now that we know the ``py`` command is recognized, you can give your Python "
"script to it. You'll have to give either an absolute or a relative path to "
"the Python script. Let's say your Python script is located in your desktop "
"and is named ``hello.py``, and your command prompt is nicely opened in your "
"home directory so you're seeing something similar to::"
msgstr ""
"现在我们知道 ``py`` 命令已经被识别，可以输入 Python 脚本了。 你需要提供 Python 脚本的绝对路径或相对路径。 假设 Python "
"脚本位于桌面上并命名为 ``hello.py``，并且命令提示符在用户主目录打开，那么可以看到类似于这样的东西::"

#: ../../faq/windows.rst:106
msgid ""
"So now you'll ask the ``py`` command to give your script to Python by typing"
" ``py`` followed by your script path::"
msgstr "那么现在可以让 ``py`` 命令执行你的脚本，只需要输入 ``py`` 和脚本路径::"

#: ../../faq/windows.rst:114
msgid "How do I make Python scripts executable?"
msgstr "我怎么让 Python 脚本可执行？"

#: ../../faq/windows.rst:116
msgid ""
"On Windows, the standard Python installer already associates the .py "
"extension with a file type (Python.File) and gives that file type an open "
"command that runs the interpreter (``D:\\Program Files\\Python\\python.exe "
"\"%1\" %*``).  This is enough to make scripts executable from the command "
"prompt as 'foo.py'.  If you'd rather be able to execute the script by simple"
" typing 'foo' with no extension you need to add .py to the PATHEXT "
"environment variable."
msgstr ""
"在 Windows 上，标准 Python 安装程序已将 .py 扩展名与文件类型 (Python.File) "
"相关联，并为该文件类型提供运行解释器的打开命令 (``D:\\Program Files\\Python\\python.exe \"%1\" "
"%*``) 。 这足以使脚本在命令提示符下作为“foo.py”命令被执行。 如果希望通过简单地键入“foo”而无需输入文件扩展名来执行脚本，则需要将 "
".py 添加到 PATHEXT 环境变量中。"

#: ../../faq/windows.rst:124
msgid "Why does Python sometimes take so long to start?"
msgstr "为什么有时候 Python 程序会启动缓慢？"

#: ../../faq/windows.rst:126
msgid ""
"Usually Python starts very quickly on Windows, but occasionally there are "
"bug reports that Python suddenly begins to take a long time to start up.  "
"This is made even more puzzling because Python will work fine on other "
"Windows systems which appear to be configured identically."
msgstr ""
"通常，Python 在 Windows 上启动得很快，但偶尔会有错误报告说 Python 突然需要很长时间才能启动。更令人费解的是，在其他配置相同的 "
"Windows 系统上，Python 却可以工作得很好。"

#: ../../faq/windows.rst:131
msgid ""
"The problem may be caused by a misconfiguration of virus checking software "
"on the problem machine.  Some virus scanners have been known to introduce "
"startup overhead of two orders of magnitude when the scanner is configured "
"to monitor all reads from the filesystem.  Try checking the configuration of"
" virus scanning software on your systems to ensure that they are indeed "
"configured identically. McAfee, when configured to scan all file system read"
" activity, is a particular offender."
msgstr ""
"该问题可能是由于计算机上的杀毒软件配置错误造成的。当将病毒扫描配置为监视文件系统中所有读取行为时，一些杀毒扫描程序会导致两个数量级的启动开销。请检查你系统安装的杀毒扫描程序的配置，确保两台机它们是同样的配置。已知的，"
" McAfee 杀毒软件在将它设置为扫描所有文件系统访问时，会产生这个问题。"

#: ../../faq/windows.rst:141
msgid "How do I make an executable from a Python script?"
msgstr "我怎样使用 Python 脚本制作可执行文件？"

#: ../../faq/windows.rst:143
msgid ""
"See :ref:`faq-create-standalone-binary` for a list of tools that can be used"
" to make executables."
msgstr "请参阅 :ref:`faq-create-standalone-binary` 查看可用来生成可执行文件的工具清单。"

#: ../../faq/windows.rst:148
msgid "Is a ``*.pyd`` file the same as a DLL?"
msgstr "``*.pyd`` 文件和 DLL 文件相同吗？"

#: ../../faq/windows.rst:150
msgid ""
"Yes, .pyd files are dll's, but there are a few differences.  If you have a "
"DLL named ``foo.pyd``, then it must have a function ``PyInit_foo()``.  You "
"can then write Python \"import foo\", and Python will search for foo.pyd (as"
" well as foo.py, foo.pyc) and if it finds it, will attempt to call "
"``PyInit_foo()`` to initialize it.  You do not link your .exe with foo.lib, "
"as that would cause Windows to require the DLL to be present."
msgstr ""
"是的， .pyd 文件也是 dll ，但有一些差异。如果你有一个名为 ``foo.pyd`` 的DLL，那么它必须有一个函数 "
"``PyInit_foo()`` 。 然后你可以编写 Python 代码 “import foo” ，Python 将搜索 foo.pyd （以及 "
"foo.py 、 foo.pyc ）。如果找到它，将尝试调用 ``PyInit_foo()`` 来初始化它。你不应将 .exe 与 foo.lib "
"链接，因为这会导致 Windows 要求存在 DLL 。"

#: ../../faq/windows.rst:157
msgid ""
"Note that the search path for foo.pyd is PYTHONPATH, not the same as the "
"path that Windows uses to search for foo.dll.  Also, foo.pyd need not be "
"present to run your program, whereas if you linked your program with a dll, "
"the dll is required.  Of course, foo.pyd is required if you want to say "
"``import foo``.  In a DLL, linkage is declared in the source code with "
"``__declspec(dllexport)``. In a .pyd, linkage is defined in a list of "
"available functions."
msgstr ""
"请注意， foo.pyd 的搜索路径是 PYTHONPATH ，与 Windows 用于搜索 foo.dll 的路径不同。此外， foo.pyd "
"不需要存在来运行你的程序，而如果你将程序与 dll 链接，则需要 dll 。 当然，如果你想 ``import foo`` ，则需要 foo.pyd "
"。在 DLL 中，链接在源代码中用 ``__declspec(dllexport)`` 声明。 在 .pyd 中，链接在可用函数列表中定义。"

#: ../../faq/windows.rst:166
msgid "How can I embed Python into a Windows application?"
msgstr "我怎样将 Python 嵌入一个 Windows 程序？"

#: ../../faq/windows.rst:168
msgid ""
"Embedding the Python interpreter in a Windows app can be summarized as "
"follows:"
msgstr "在 Windows 应用程序中嵌入 Python 解释器可以总结如下："

#: ../../faq/windows.rst:170
msgid ""
"Do **not** build Python into your .exe file directly.  On Windows, Python "
"must be a DLL to handle importing modules that are themselves DLL's.  (This "
"is the first key undocumented fact.)  Instead, link to "
":file:`python{NN}.dll`; it is typically installed in "
"``C:\\Windows\\System``.  *NN* is the Python version, a number such as "
"\"33\" for Python 3.3."
msgstr ""
"请 **不要** 直接将 Python 编译到你的 .exe 文件中。 在 Windows 上，Python 必须是一个 DLL 以便处理导入本身就是 "
"DLL 的模块。 （这是首先要知道的未写入文档的关键事实。） 正确的做法，应该是链接到 :file:`python{NN}.dll`；它通常安装在 "
"``C:\\Windows\\System`` 中。 *NN* 是 Python 的版本号，例如数字 \"33\" 代表 Python 3.3。"

#: ../../faq/windows.rst:176
msgid ""
"You can link to Python in two different ways.  Load-time linking means "
"linking against :file:`python{NN}.lib`, while run-time linking means linking"
" against :file:`python{NN}.dll`.  (General note: :file:`python{NN}.lib` is "
"the so-called \"import lib\" corresponding to :file:`python{NN}.dll`.  It "
"merely defines symbols for the linker.)"
msgstr ""
"你可以通过两种不同的方式链接到 Python 。加载时链接意味着链接到 :file:`python{NN}.lib` ，而运行时链接意味着链接 "
":file:`python{NN}.dll` 。（一般说明： :file:`python {NN}.lib` 是所谓的“import lib”，对应于 "
":file:`python{NN}.dll` 。它只定义了链接器的符号。）"

#: ../../faq/windows.rst:182
msgid ""
"Run-time linking greatly simplifies link options; everything happens at run "
"time.  Your code must load :file:`python{NN}.dll` using the Windows "
"``LoadLibraryEx()`` routine.  The code must also use access routines and "
"data in :file:`python{NN}.dll` (that is, Python's C API's) using pointers "
"obtained by the Windows ``GetProcAddress()`` routine.  Macros can make using"
" these pointers transparent to any C code that calls routines in Python's C "
"API."
msgstr ""
"运行时链接极大地简化了链接选项，一切都在运行时发生。你的代码必须使用 Windows 的 ``LoadLibraryEx()`` 程序加载 "
":file:`python{NN}.dll` 。代码还必须使用使用 Windows 的 ``GetProcAddress()`` 例程获得的指针访问 "
":file:`python{NN}.dll` 中程序和数据（即 Python 的 C API ）。宏可以使这些指针对任何调用 Python C API "
"中的例程的 C 代码都是透明的。"

#: ../../faq/windows.rst:191
msgid ""
"If you use SWIG, it is easy to create a Python \"extension module\" that "
"will make the app's data and methods available to Python.  SWIG will handle "
"just about all the grungy details for you.  The result is C code that you "
"link *into* your .exe file (!)  You do **not** have to create a DLL file, "
"and this also simplifies linking."
msgstr ""
"如果你是使用 SWIG，那么很容易创建一个将使得应用的数据和方法可供 Python 使用的 \"扩展模块\"。 SWIG 将为你处理所有繁琐的细节。 "
"结果是让你链接 *置入* 你的 .exe 文件当中的 C 代码 (!) 你 **无需** 创建一个 DLL 文件，而这也简化了链接过程。"

#: ../../faq/windows.rst:197
msgid ""
"SWIG will create an init function (a C function) whose name depends on the "
"name of the extension module.  For example, if the name of the module is "
"leo, the init function will be called initleo().  If you use SWIG shadow "
"classes, as you should, the init function will be called initleoc().  This "
"initializes a mostly hidden helper class used by the shadow class."
msgstr ""
"SWIG 将创建一个 init 函数（一个 C 函数），其名称取决于扩展模块的名称。例如，如果模块的名称是 leo ，则 init 函数将被称为 "
"initleo() 。 如果您使用 SWIG 阴影类，则 init 函数将被称为 initleoc() 。这初始化了一个由阴影类使用的隐藏辅助类。"

#: ../../faq/windows.rst:203
msgid ""
"The reason you can link the C code in step 2 into your .exe file is that "
"calling the initialization function is equivalent to importing the module "
"into Python! (This is the second key undocumented fact.)"
msgstr ""
"你可以将步骤 2 中的 C 代码链接到 .exe 文件的原因是调用初始化函数等同于将模块导入 Python ！ （这是第二个关键的未记载事实。）"

#: ../../faq/windows.rst:207
msgid ""
"In short, you can use the following code to initialize the Python "
"interpreter with your extension module."
msgstr "简而言之，你可以用以下代码使用扩展模块初始化 Python 解释器。"

#: ../../faq/windows.rst:218
msgid ""
"There are two problems with Python's C API which will become apparent if you"
" use a compiler other than MSVC, the compiler used to build pythonNN.dll."
msgstr "Python C API 存在两个问题，如果你使用除 MSVC 之外的编译器用于构建 python.dll ，这将会变得明显。"

#: ../../faq/windows.rst:221
msgid ""
"Problem 1: The so-called \"Very High Level\" functions that take ``FILE *`` "
"arguments will not work in a multi-compiler environment because each "
"compiler's notion of a ``struct FILE`` will be different.  From an "
"implementation standpoint these are very low level functions."
msgstr ""
"问题 1: 接受 ``FILE *`` 参数的所谓的 \"极高层级\" 函数在多编译器环境中将不起作用，因为每个编译器中 ``struct FILE``"
" 的概念都会是不同的。 从实现的角度看来这些都是极低层级的函数。"

#: ../../faq/windows.rst:226
msgid ""
"Problem 2: SWIG generates the following code when generating wrappers to "
"void functions:"
msgstr "问题2：在为 void 函数生成包装器时，SWIG 会生成以下代码："

#: ../../faq/windows.rst:235
msgid ""
"Alas, Py_None is a macro that expands to a reference to a complex data "
"structure called _Py_NoneStruct inside pythonNN.dll.  Again, this code will "
"fail in a mult-compiler environment.  Replace such code by:"
msgstr ""
"Py_None 是一个宏，它扩展为对 pythonNN.dll 中名为 _Py_NoneStruct "
"的复杂数据结构的引用。同样，此代码将在多编译器环境中失败。将此类代码替换为："

#: ../../faq/windows.rst:243
msgid ""
"It may be possible to use SWIG's ``%typemap`` command to make the change "
"automatically, though I have not been able to get this to work (I'm a "
"complete SWIG newbie)."
msgstr "有可能使用 SWIG 的 ``%typemap`` 命令自动进行更改，但我无法使其工作（我是一个完全的SWIG新手）。"

#: ../../faq/windows.rst:247
msgid ""
"Using a Python shell script to put up a Python interpreter window from "
"inside your Windows app is not a good idea; the resulting window will be "
"independent of your app's windowing system.  Rather, you (or the "
"wxPythonWindow class) should create a \"native\" interpreter window.  It is "
"easy to connect that window to the Python interpreter.  You can redirect "
"Python's i/o to _any_ object that supports read and write, so all you need "
"is a Python object (defined in your extension module) that contains read() "
"and write() methods."
msgstr ""
"使用 Python shell 脚本从 Windows 应用程序内部建立 Python "
"解释器窗口并不是一个好主意；生成的窗口将独立于应用程序的窗口系统。相反，你（或 wxPythonWindow "
"类）应该创建一个“本机”解释器窗口。将该窗口连接到Python解释器很容易。你可以将 Python的 i/o 重定向到支持读写的 _任意_ "
"对象，因此你只需要一个包含 read() 和 write() 方法的 Python 对象（在扩展模块中定义）。"

#: ../../faq/windows.rst:256
msgid "How do I keep editors from inserting tabs into my Python source?"
msgstr "如何让编辑器不要在我的 Python 源代码中插入 tab ？"

#: ../../faq/windows.rst:258
msgid ""
"The FAQ does not recommend using tabs, and the Python style guide, :pep:`8`,"
" recommends 4 spaces for distributed Python code; this is also the Emacs "
"python-mode default."
msgstr ""
"本 FAQ 不建议使用制表符， Python 样式指南 :pep:`8` ，为发行的 Python 代码推荐 4 个空格；这也是 Emacs "
"python-mode 默认值。"

#: ../../faq/windows.rst:262
msgid ""
"Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no "
"different in this respect, and is easily configured to use spaces: Take "
":menuselection:`Tools --> Options --> Tabs`, and for file type \"Default\" "
"set \"Tab size\" and \"Indent size\" to 4, and select the \"Insert spaces\" "
"radio button."
msgstr ""
"在任何编辑器下，混合制表符和空格都是一个坏主意。 MSVC 在这方面没有什么不同，并且很容易配置为使用空格： 点击 "
":menuselection:`Tools --> Options --> Tabs`，对于文件类型“Default”，设置“Tab "
"size”和“Indent size”为 4 ，并选择“插入空格”单选按钮。"

#: ../../faq/windows.rst:267
msgid ""
"Python raises :exc:`IndentationError` or :exc:`TabError` if mixed tabs and "
"spaces are causing problems in leading whitespace. You may also run the "
":mod:`tabnanny` module to check a directory tree in batch mode."
msgstr ""
"如果混合制表符和空格导致前导空格出现问题， Python 会引发 :exc:`IndentationError` 或 :exc:`TabError` "
"。你还可以运行 :mod:`tabnanny` 模块以批处理模式检查目录树。"

#: ../../faq/windows.rst:274
msgid "How do I check for a keypress without blocking?"
msgstr "如何在不阻塞的情况下检查按键？"

#: ../../faq/windows.rst:276
msgid ""
"Use the :mod:`msvcrt` module.  This is a standard Windows-specific extension"
" module. It defines a function ``kbhit()`` which checks whether a keyboard "
"hit is present, and ``getch()`` which gets one character without echoing it."
msgstr ""
"使用 :mod:`msvcrt` 模块。 这是一个标准的 Windows 专属扩展模块。 它定义了一个函数 ``kbhit()`` "
"用于检查是否有键盘中的某个键被按下，以及 ``getch()`` 用于获取一个字符而不将其回显。"

#: ../../faq/windows.rst:281
msgid "How do I solve the missing api-ms-win-crt-runtime-l1-1-0.dll error?"
msgstr "我该如何解决缺失 api-ms-win-crt-runtime-l1-1-0.dll 错误？"

#: ../../faq/windows.rst:283
msgid ""
"This can occur on Python 3.5 and later when using Windows 8.1 or earlier "
"without all updates having been installed. First ensure your operating "
"system is supported and is up to date, and if that does not resolve the "
"issue, visit the `Microsoft support page <https://support.microsoft.com/en-"
"us/help/3118401/>`_ for guidance on manually installing the C Runtime "
"update."
msgstr ""
"这将在使用未安装全部更新的 Windows 8.1 或更旧的系统时发生于 Python 3.5 及之后的版本上。 "
"首先请确保你的操作系统受支持并且已经更新补丁，如果此问题仍未解决，请访问 `Microsoft support page "
"<https://support.microsoft.com/en-us/help/3118401/>`_ 获取有关手动安装 C 运行时更新补丁的指导。"
