# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "编程常见问题"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "目录"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "一般问题"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr "Python 有没有提供带有断点、单步调试等功能的源码级调试器？"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "有的。"

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function "
":func:`breakpoint` allows you to drop into any of them."
msgstr "以下介绍了一些 Python 的调试器，用内置函数 :func:`breakpoint` 即可切入这些调试器中。"

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It"
" is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"pdb 模块是一个简单但是够用的控制台模式 Python 调试器。 它是标准 Python 库的一部分，并且 :mod:`已收录于库参考手册 "
"<pdb>`。 你也可以通过使用 pdb 代码作为样例来编写你自己的调试器。"

#: ../../faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 "
"<https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"includes a graphical debugger."
msgstr ""
"作为标准 Python 发行版组成部分的 IDLE 交互式开发环境 (通常位于 `Tools/scripts/idle3 "
"<https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_)，包括一个图形化的调试器。"

#: ../../faq/programming.rst:32
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such"
" as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin 是一种 Python IDE，其中包含了一个基于 pdb 的 GUI 调试器。PythonWin "
"的调试器会为断点着色，并提供了相当多的超酷特性，例如调试非 PythonWin 程序等。PythonWin 是 `pywin32 "
"<https://github.com/mhammond/pywin32>`_ 项目的组成部分，也是 `ActivePython "
"<https://www.activestate.com/products/python/>`_ 发行版的组成部分。"

#: ../../faq/programming.rst:39
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ 是一个基于 PyQt 和 Scintilla 编辑组件的"
" IDE。"

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ 是一个类似 gdb 的调试器。"

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ 是包含了调试工具的 "
"IDE，并集成了版本控制软件。"

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr "有许多商业 Python IDE 都包含了图形化调试器。包括："

#: ../../faq/programming.rst:50
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

#: ../../faq/programming.rst:52
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr "是否有能帮助寻找漏洞或执行静态分析的工具？"

#: ../../faq/programming.rst:60
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ 和 `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ 可执行基本检查来帮助你尽早捕捉漏洞。"

#: ../../faq/programming.rst:64
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype "
"<https://github.com/google/pytype>`_ can check type hints in Python source "
"code."
msgstr ""
"静态类型检查器例如 `Mypy <https://mypy-lang.org/>`_, `Pyre <https://pyre-"
"check.org/>`_ 和 `Pytype <https://github.com/google/pytype>`_ 可以检查 Python "
"源代码中的类型提示。"

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "如何由 Python 脚本创建能独立运行的二进制程序？"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"如果只是想要一个独立的程序，以便用户不必预先安装 Python 即可下载和运行它，则不需要将 Python 编译成 C "
"代码。有许多工具可以检测程序所需的模块，并将这些模块与 Python 二进制程序捆绑在一起生成单个可执行文件。"

#: ../../faq/programming.rst:81
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze "
"<https://github.com/python/cpython/tree/main/Tools/freeze>`_. It converts "
"Python byte code to C arrays; with a C compiler you can embed all your "
"modules into a new program, which is then linked with the standard Python "
"modules."
msgstr ""
"一种方案是使用 freeze 工具，它以 `Tools/freeze "
"<https://github.com/python/cpython/tree/main/Tools/freeze>`_ 的形式包含在 Python "
"源代码树中。 它可将 Python 字节码转换为 C 数组；你可以使用 C 编译器将你的所有模块嵌入到一个新程序中，再将其与标准 Python "
"模块进行链接。"

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in"
" the source directory (for built-in modules).  It then turns the bytecode "
"for modules written in Python into C code (array initializers that can be "
"turned into code objects using the marshal module) and creates a custom-made"
" config file that only contains those built-in modules which are actually "
"used in the program.  It then compiles the generated C code and links it "
"with the rest of the Python interpreter to form a self-contained binary "
"which acts exactly like your script."
msgstr ""
"它的工作原理是递归扫描源代码，获取两种格式的 import 语句，并在标准 Python 路径和源码目录（用于内置模块）检索这些模块。然后，把这些模块的"
" Python 字节码转换为 C 代码（可以利用 marshal "
"模块转换为代码对象的数组初始化器），并创建一个定制的配置文件，该文件仅包含程序实际用到的内置模块。然后，编译生成的 C 代码并将其与 Python "
"解释器的其余部分链接，形成一个自给自足的二进制文件，其功能与 Python 脚本代码完全相同。"

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr "下列包可以用于帮助创建控制台和 GUI 的可执行文件:"

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ （跨平台）"

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (跨平台)"

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-"
"platform)"
msgstr "`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ （跨平台）"

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr "`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ （跨平台）"

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ （仅限 macOS）"

#: ../../faq/programming.rst:104
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (仅限 Windows)"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr "是否有 Python 编码标准或风格指南？"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr "有的。 标准库模块所要求的编码风格记录于 :pep:`8` 之中。"

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "语言核心内容"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "变量明明有值，为什么还会出现 UnboundLocalError？"

#: ../../faq/programming.rst:121
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere"
" in the body of a function."
msgstr ""
"当在函数内部某处添加了一条赋值语句，因而导致之前正常工作的代码报出 :exc:`UnboundLocalError` 错误，这确实有点令人惊讶。"

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "以下代码："

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "正常工作，但是以下代码"

#: ../../faq/programming.rst:141
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "在 :exc:`!UnboundLocalError` 中的结果:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"原因就是，当对某作用域内的变量进行赋值时，该变量将成为该作用域内的局部变量，并覆盖外部作用域中的同名变量。由于 foo 的最后一条语句为 ``x`` "
"分配了一个新值，编译器会将其识别为局部变量。因此，前面的 ``print(x)`` 试图输出未初始化的局部变量，就会引发错误。"

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring it"
" global:"
msgstr "在上面的示例中，可以将外部作用域的变量声明为全局变量以便访问："

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you"
" are actually modifying the value of the variable in the outer scope:"
msgstr "与类和实例变量貌似但不一样，其实以上是在修改外部作用域的变量值，为了提示这一点，这里需要显式声明一下。"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr "你可以使用 :keyword:`nonlocal` 关键字在嵌套作用域中执行类似的操作："

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr "Python 的局部变量和全局变量有哪些规则？"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"函数内部只作引用的 Python 变量隐式视为全局变量。如果在函数内部任何位置为变量赋值，则除非明确声明为全局变量，否则均将其视为局部变量。"

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time."
"  You'd have to declare as global every reference to a built-in function or "
"to a component of an imported module.  This clutter would defeat the "
"usefulness of the ``global`` declaration for identifying side-effects."
msgstr ""
"起初尽管有点令人惊讶，不过考虑片刻即可释然。一方面，已分配的变量要求加上 :keyword:`global` "
"可以防止意外的副作用发生。另一方面，如果所有全局引用都要加上 ``global`` ，那处处都得用上 ``global`` "
"了。那么每次对内置函数或导入模块中的组件进行引用时，都得声明为全局变量。这种杂乱会破坏 ``global`` 声明用于警示副作用的有效性。"

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr "为什么在循环中定义的参数各异的 lambda 都返回相同的结果？"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr "假设用 for 循环来定义几个取值各异的 lambda（即便是普通函数也一样）："

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"以上会得到一个包含5个 lambda 函数的列表，这些函数将计算 ``x**2``。大家或许期望，调用这些函数会分别返回 ``0`` 、``1`` 、 "
"``4`` 、 ``9`` 和 ``16``。然而，真的试过就会发现，他们都会返回 ``16`` ："

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by"
" changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"这是因为 ``x`` 不是 lambda 函数的内部变量，而是定义于外部作用域中的，并且 ``x`` 是在调用 lambda "
"时访问的——而不是在定义时访问。循环结束时 ``x`` 的值是 ``4`` ，所以此时所有的函数都将返回 ``4**2`` ，即 ``16`` "
"。通过改变 ``x`` 的值并查看 lambda 的结果变化，也可以验证这一点。"

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr "为了避免发生上述情况，需要将值保存在 lambda 局部变量，以使其不依赖于全局 ``x`` 的值："

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in"
" the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"以上 ``n=x`` 创建了一个新的 lambda 本地变量 ``n``，并在定义 lambda 时计算其值，使其与循环当前时点的 ``x`` "
"值相同。这意味着 ``n`` 的值在第 1 个 lambda 中为 ``0`` ，在第 2 个 lambda 中为 ``1`` ，在第 3 个中为 "
"``2``，依此类推。因此现在每个 lambda 都会返回正确结果："

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr "请注意，上述表现并不是 lambda 所特有的，常规的函数也同样适用。"

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "如何跨模块共享全局变量？"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then"
" becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected everywhere."
"  For example:"
msgstr ""
"在单个程序中跨模块共享信息的规范方法是创建一个特殊模块（通常称为 config 或 cfg）。只需在应用程序的所有模块中导入该 config "
"模块；然后该模块就可当作全局名称使用了。因为每个模块只有一个实例，所以对该模块对象所做的任何更改将会在所有地方得以体现。 例如："

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py："

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py："

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py："

#: ../../faq/programming.rst:283
msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr "请注意，出于同样的原因，使用模块也是实现单例设计模式的基础。"

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr "导入模块的“最佳实践”是什么？"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"通常请勿使用 ``from modulename import *`` 。因为这会扰乱 importer 的命名空间，且会造成未定义名称更难以被 "
"Linter 检查出来。"

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"请在代码文件的首部就导入模块。这样代码所需的模块就一目了然了，也不用考虑模块名是否在作用域内的问题。每行导入一个模块则增删起来会比较容易，每行导入多个模块则更节省屏幕空间。"

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "按如下顺序导入模块就是一种好做法："

#: ../../faq/programming.rst:301
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, "
":mod:`re`"
msgstr "标准库模块——例如：:mod:`sys`、:mod:`os`、:mod:`argparse`、:mod:`re` 等。"

#: ../../faq/programming.rst:302
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"第三方库模块（安装于 Python site-packages "
"目录中的内容）——例如：:mod:`!dateutil`、:mod:`!requests`、:mod:`!PIL.Image` 等。"

#: ../../faq/programming.rst:304
msgid "locally developed modules"
msgstr "本地开发的模块"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr "为了避免循环导入引发的问题，有时需要将模块导入语句移入函数或类的内部。Gordon McMillan 的说法如下："

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level."
"  That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"当两个模块都采用  \"import <module>\" 的导入形式时，循环导入是没有问题的。但如果第 2 个模块想从第 1 "
"个模块中取出一个名称（\"from module import name\"）并且导入处于代码的最顶层，那导入就会失败。原因是第 1 "
"个模块中的名称还不可用，这时第 1 个模块正忙于导入第 2 个模块呢。"

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"如果只是在一个函数中用到第 2 个模块，那这时将导入语句移入该函数内部即可。当调用到导入语句时，第 1 个模块将已经完成初始化，第 2 "
"个模块就可以进行导入了。"

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be"
" possible to import all of the modules at the top of the file.  In this "
"case, importing the correct modules in the corresponding platform-specific "
"code is a good option."
msgstr ""
"如果某些模块是平台相关的，可能还需要把导入语句移出最顶级代码。这种情况下，甚至有可能无法导入文件首部的所有模块。于是在对应的平台相关代码中导入正确的模块，就是一种不错的选择。"

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is"
" especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module"
" the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"只有为了避免循环导入问题，或有必要减少模块初始化时间时，才把导入语句移入类似函数定义内部的局部作用域。如果根据程序的执行方式，许多导入操作不是必需的，那么这种技术尤其有用。如果模块仅在某个函数中用到，可能还要将导入操作移入该函数内部。请注意，因为模块有一次初始化过程，所以第一次加载模块的代价可能会比较高，但多次加载几乎没有什么花费，代价只是进行几次字典检索而已。即使模块名超出了作用域，模块在"
" :data:`sys.modules` 中也是可用的。 "

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "为什么对象之间会共享默认值？"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr "新手程序员常常中招这类 Bug。请看以下函数："

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins"
" executing, ``mydict`` starts out with an item already in it."
msgstr ""
"第一次调用此函数时， ``mydict``  中只有一个数据项。第二次调用 ``mydict`` 则会包含两个数据项，因为 ``foo()`` "
"开始执行时， ``mydict`` 中已经带有一个数据项了。"

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"大家往往希望，函数调用会为默认值创建新的对象。但事实并非如此。默认值只会在函数定义时创建一次。如果对象发生改变，就如上例中的字典那样，则后续调用该函数时将会引用这个改动的对象。"

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"按照定义，不可变对象改动起来是安全的，诸如数字、字符串、元组和 ``None`` 之类。而可变对象的改动则可能引起困惑，例如字典、列表和类实例等。"

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"因此，不把可变对象用作默认值是一种良好的编程做法。而应采用 ``None`` 作为默认值，然后在函数中检查参数是否为 ``None`` "
"并新建列表、字典或其他对象。例如，代码不应如下所示："

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "而应这么写："

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"参数默认值的特性有时会很有用处。 "
"如果有个函数的计算过程会比较耗时，有一种常见技巧是将每次函数调用的参数和结果缓存起来，并在同样的值被再次请求时返回缓存的值。这种技巧被称为“memoize”，实现代码可如下所示："

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr "也可以不用参数默认值来实现，而是采用全局的字典变量；这取决于个人偏好。"

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr "如何将可选参数或关键字参数从一个函数传递到另一个函数？"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"请利用函数参数列表中的标识符 ``*`` 和 ``**`` 归集实参；结果会是元组形式的位置实参和字典形式的关键字实参。然后就可利用 ``*`` 和 "
"``**`` 在调用其他函数时传入这些实参："

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "形参和实参之间有什么区别？"

#: ../../faq/programming.rst:417
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what "
":term:`kind of arguments <parameter>` a function can accept.  For example, "
"given the function definition::"
msgstr ""
":term:`形参 <parameter>` 是由出现在函数定义中的名称来定义的，而 :term:`参数 <argument>` "
"则是在调用函数时实际传入的值。 形参定义了一个函数能接受什么 :term:`参数种类 <parameter>`。 例如，对于以下函数定义::"

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling"
" ``func``, for example::"
msgstr "*foo* 、 *bar* 和 *kwargs* 是 ``func`` 的形参。 不过在调用 ``func`` 时，例如："

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "``42`` 、 ``314`` 和 ``somevar`` 则是实参。"

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "为什么修改列表 'y' 也会更改列表 'x'？"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "如果代码编写如下："

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr "或许大家很想知道，为什么在 y 中添加一个元素时， x 也会改变。"

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "产生这种结果有两个因素："

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"变量只是指向对象的一个名称。执行 ``y = x`` 并不会创建列表的副本——而只是创建了一个新变量 ``y``，并指向 ``x`` "
"所指的同一对象。这就意味着只存在一个列表对象，``x`` 和 ``y`` 都是对它的引用。"

#: ../../faq/programming.rst:455
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr "列表属于 :term:`mutable` 对象，这意味着它的内容是可以修改的。"

#: ../../faq/programming.rst:457
msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the same"
" object, using either name accesses the modified value ``[10]``."
msgstr ""
"在调用 :meth:`!append` 之后，该可变对象的内容由 ``[]`` 变为 ``[10]``。 "
"由于两个变量引用了同一对象，因此用其中任意一个名称所访问到的都是修改后的值 ``[10]``。"

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "如果把赋给 ``x`` 的对象换成一个不可变对象："

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is"
" because integers are :term:`immutable`, and when we do ``x = x + 1`` we are"
" not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"可见这时 ``x`` 和 ``y`` 就不再相等了。因为整数是 :term:`immutable` 对象，在执行 ``x = x + 1`` "
"时，并不会修改整数对象 ``5``，给它加上 1；而是创建了一个新的对象（整数对象 ``6`` ）并将其赋给 ``x`` （也就是改变了 ``x`` "
"所指向的对象）。在赋值完成后，就有了两个对象（整数对象 ``6`` 和 ``5`` ）和分别指向他俩的两个变量（ ``x`` 现在指向 ``6`` 而 "
"``y`` 仍然指向 ``5`` ）。"

#: ../../faq/programming.rst:479
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"某些操作 (例如 ``y.append(10)`` 和 ``y.sort()``) 是改变原对象，而看上去相似的另一些操作 (例如 ``y = y + "
"[10]`` 和  :func:`sorted(y) <sorted>) 则是创建新对象。 通常在 Python 中 (以及在标准库的所有代码中) "
"会改变原对象的方法将返回 ``None`` 以帮助避免混淆这两种不同类型的操作。 因此如果你错误地使用了 ``y.sort()`` "
"并期望它将返回一个经过排序的 ``y`` 的副本，你得到的结果将会是 ``None``，这将导致你的程序产生一个容易诊断的错误。"

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation sometimes"
" has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"不过还存在一类操作，用不同的类型执行相同的操作有时会发生不同的行为：即增量赋值运算符。例如，``+=`` "
"会修改列表，但不会修改元组或整数（``a_list += [1, 2, 3]`` 与 ``a_list.extend([1, 2, 3])`` "
"同样都会改变 ``a_list``，而 ``some_tuple += (1, 2, 3)`` 和 ``some_int += 1`` "
"则会创建新的对象）。"

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "换而言之："

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"对于一个可变对象（ :class:`list` 、 :class:`dict` 、 :class:`set` "
"等等），可以利用某些特定的操作进行修改，所有引用它的变量都会反映出改动情况。"

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"对于一个不可变对象（ :class:`str` 、 :class:`int` 、 :class:`tuple` "
"等），所有引用它的变量都会给出相同的值，但所有改变其值的操作都将返回一个新的对象。"

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr "如要知道两个变量是否指向同一个对象，可以利用 :keyword:`is` 运算符或内置函数 :func:`id`。"

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "如何编写带有输出参数的函数（按照引用调用）？"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se."
"  You can achieve the desired effect in a number of ways."
msgstr ""
"请记住，Python "
"中的实参是通过赋值传递的。由于赋值只是创建了对象的引用，所以调用方和被调用方的参数名都不存在别名，本质上也就不存在按引用调用的方式。通过以下几种方式，可以得到所需的效果。"

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "返回一个元组："

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "这差不多是最明晰的解决方案了。"

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr "使用全局变量。这不是线程安全的方案，不推荐使用。"

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr "传递一个可变（即可原地修改的） 对象："

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "传入一个接收可变对象的字典::"

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "或者把值用类实例封装起来："

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr "没有什么理由要把问题搞得这么复杂。"

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "最佳选择就是返回一个包含多个结果值的元组。"

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "如何在 Python 中创建高阶函数？"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested"
" scopes::"
msgstr ""
"有两种选择：嵌套作用域、可调用对象。假定需要定义 ``linear(a,b)`` ，其返回结果是一个计算出 ``a*x+b`` 的函数 "
"``f(x)``。 采用嵌套作用域的方案如下："

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "或者可采用可调用对象："

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "采用这两种方案时："

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "都会得到一个可调用对象，可实现 ``taxes(10e6) == 0.3 * 10e6 + 2`` 。"

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr "可调用对象的方案有个缺点，就是速度稍慢且生成的代码略长。不过值得注意的是，同一组可调用对象能够通过继承来共享签名（类声明）："

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "对象可以为多个方法的运行状态进行封装："

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the"
" same counting variable."
msgstr "以上 ``inc()`` 、 ``dec()`` 和 ``reset()`` 的表现，就如同共享了同一计数变量一样。"

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "如何复制 Python 对象？"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"一般情况下，用 :func:`copy.copy` 或 :func:`copy.deepcopy` "
"基本就可以了。并不是所有对象都支持复制，但多数是可以的。"

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a "
":meth:`~dict.copy` method::"
msgstr "某些对象可以用更简便的方法进行复制。比如字典对象就提供了 :meth:`~dict.copy` 方法："

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "序列可以用切片操作进行复制："

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "如何找到对象的方法或属性？"

#: ../../faq/programming.rst:654
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"对于一个用户定义类的实例 ``x``，:func:`dir(x) <dir>` "
"将返回一个按字母顺序排列的名称列表，其中包含实例属性及由类定义的方法和属性。"

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "如何用代码获取对象的名称？"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"一般而言这是无法实现的，因为对象并不存在真正的名称。赋值本质上是把某个名称绑定到某个值上；``def`` 和 ``class`` "
"语句同样如此，只是值换成了某个可调用对象。比如以下代码："

#: ../../faq/programming.rst:678
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"可以不太严谨地说上述类有一个名称：即使它绑定了两个名称并通过名称 ``B`` 唤起所创建的实例仍将被报告为类 ``A`` 的实例。 "
"但是，没有办法肯定地说实例的名称是 ``a`` 还是 ``b``，因为这两个名称都被绑定到同一个值上了。"

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr "代码一般没有必要去“知晓”某个值的名称。通常这种需求预示着还是改变方案为好，除非真的是要编写内审程序。"

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr "在 comp.lang.python 中，Fredrik Lundh 在回答这样的问题时曾经给出过一个绝佳的类比："

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"这就像要知道家门口的那只猫的名字一样：猫（对象）自己不会说出它的名字，它根本就不在乎自己叫什么——所以唯一方法就是问一遍你所有的邻居（命名空间），这是不是他们家的猫（对象）……"

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr "……并且如果你发现它有很多名字或根本没有名字，那也不必惊讶！"

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "逗号运算符的优先级是什么？"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "逗号不是 Python 的运算符。 请看以下例子："

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr "由于逗号不是运算符，而只是表达式之间的分隔符，因此上述代码就相当于："

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "而不是："

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr "对于各种赋值运算符（ ``=`` 、 ``+=`` 等）来说同样如此。他们并不是真正的运算符，而只是赋值语句中的语法分隔符。"

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "是否提供等价于 C 语言 \"?:\" 三目运算符的东西？"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "有的。语法如下："

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr "在 Python 2.5 引入上述语法之前，通常的做法是使用逻辑运算符："

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"然而这种做法并不保险，因为当 *on_true* 为布尔值“假”时，结果将会出错。所以肯定还是采用 ``... if ... else ...`` "
"形式为妙。"

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "是否可以用 Python 编写让人眼晕的单行程序?"

#: ../../faq/programming.rst:744
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within "
":keyword:`!lambda`.  See the following three examples, slightly adapted from"
" Ulf Bartelt::"
msgstr ""
"可以。 这一般是通过在 :keyword:`!lambda` 中嵌套 :keyword:`lambda` 来实现的。 请参阅以下三个示例，它们是基于 "
"Ulf Bartelt 的代码改写的::"

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "请不要在家里尝试，骚年！"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "函数形参列表中的斜杠（/）是什么意思？"

#: ../../faq/programming.rst:779
msgid ""
"A slash in the argument list of a function denotes that the parameters prior"
" to it are positional-only.  Positional-only parameters are the ones without"
" an externally usable name.  Upon calling a function that accepts "
"positional-only parameters, arguments are mapped to parameters based solely "
"on their position. For example, :func:`divmod` is a function that accepts "
"positional-only parameters. Its documentation looks like this::"
msgstr ""
"函数参数列表中的斜杠表示在它之前的形参都是仅限位置形参。 仅限位置形参没有可供外部使用的名称。 "
"在调用接受仅限位置形参的函数时，参数将只根据其位置被映射到形参上。 例如，:func:`divmod` 就是一个接受仅限位置形参的函数。 "
"它的文档说明是这样的::"

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr "形参列表尾部的斜杠说明，两个形参都是仅限位置形参。因此，用关键字参数调用 :func:`divmod` 将会引发错误："

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "数字和字符串"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "如何给出十六进制和八进制整数？"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"要给出八进制数，需在八进制数值前面加上一个零和一个小写或大写字母 \"o\" 作为前缀。例如，要将变量 \"a\" 设为八进制的 \"10\" "
"（十进制的 8），写法如下："

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"十六进制数也很简单。只要在十六进制数前面加上一个零和一个小写或大写的字母 \"x\"。十六进制数中的字母可以为大写或小写。比如在 Python "
"解释器中输入："

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "为什么 -22 // 10 会返回 -3 ？"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr "这主要是为了让 ``i % j`` 的正负与 ``j`` 一致，如果期望如此，且期望如下等式成立："

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"那么整除就必须返回向下取整的结果。C 语言同样要求保持这种一致性，于是编译器在截断 ``i // j`` 的结果时需要让 ``i % j`` 的正负与 "
"``i`` 一致。"

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"对于 ``i % j`` 来说 ``j`` 为负值的应用场景实际上是非常少的。 而 ``j`` 为正值的情况则非常多，并且实际上在所有情况下让 ``i "
"% j`` 的结果为 ``>= 0`` 会更有用处。 如果现在时间为 10 时，那么 200 小时前应是几时？ ``-190 % 12 == 2`` "
"是有用处的；``-190 % 12 == -10`` 则是会导致意外的漏洞。"

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "我如何获得 int 字面属性而不是 SyntaxError ？"

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a "
":exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr "尝试以正式方式查找一个 ``int`` 字面值属性会发生 :exc:`SyntaxError` 因为句点会被当作是小数点::"

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr "解决办法是用空格或括号将字词与句号分开。"

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "如何将字符串转换为数字？"

#: ../../faq/programming.rst:871
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point,"
" e.g. ``float('144') == 144.0``."
msgstr ""
"对于整数，可使用内置的 :func:`int` 类型构造器，例如 ``int('144') == 144``。 类似地，可使用 "
":func:`float` 转换为浮点数，例如 ``float('144') == 144.0``。"

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"默认情况下，这些操作会将数字按十进制来解读，因此 ``int('0144') == 144`` 为真值，而 ``int('0x144')`` 会引发 "
":exc:`ValueError`。 ``int(string, base)`` 接受第二个可选参数指定转换的基数，例如 ``int( '0x144',"
" 16) == 324``。 如果指定基数为 0，则按 Python 规则解读数字：前缀 '0o' 表示八进制，而 '0x' 表示十六进制。"

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"如果只是想把字符串转为数字，请不要使用内置函数 :func:`eval`。 :func:`eval` "
"的速度慢很多且存在安全风险：别人可能会传入带有不良副作用的 Python 表达式。比如可能会传入 "
"``__import__('os').system(\"rm -rf $HOME\")`` ，这会把 home 目录给删了。"

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python"
" does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` 还有把数字解析为 Python 表达式的后果，因此如 ``eval('09')`` 将会导致语法错误，因为 Python "
"不允许十进制数带有前导 '0'（'0' 除外）。"

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "如何将数字转换为字符串？"

#: ../../faq/programming.rst:897
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and "
"``\"{:.3f}\".format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"例如，要把数字 ``144`` 转换为字符串 ``'144'``，可使用内置类型构造器 :func:`str`。 "
"如果你需要十六进制或八进制表示形式，可使用内置函数 :func:`hex` 或 :func:`oct`。 更复杂的格式化方式，请参阅 "
":ref:`f-strings` 和 :ref:`formatstrings` 等章节，例如 ``\"{:04d}\".format(144)`` "
"将产生 ``'0144'`` 而 ``\"{:.3f}\".format(1.0/3.0)`` 将产生 ``'0.333'``。"

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "如何修改字符串？"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it"
" from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"无法修改，因为字符串是不可变对象。 在大多数情况下，只要将各个部分组合起来构造出一个新字符串即可。如果需要一个能原地修改 Unicode "
"数据的对象，可以试试 :class:`io.StringIO` 对象或 :mod:`array` 模块："

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "如何使用字符串调用函数/方法？"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "有多种技巧可供选择。"

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary"
" advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr "最好的做法是采用一个字典，将字符串映射为函数。其主要优势就是字符串不必与函数名一样。这也是用来模拟 case 结构的主要技巧："

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "利用内置函数 :func:`getattr` ："

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr "请注意 :func:`getattr` 可用于任何对象，包括类、类实例、模块等等。"

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr "标准库就多次使用了这个技巧，例如："

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "用 :func:`locals` 解析出函数名："

#: ../../faq/programming.rst:990
msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from"
" strings?"
msgstr "是否有与Perl 的chomp() 等效的方法，用于从字符串中删除尾随换行符？"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several"
" empty lines at the end, the line terminators for all the blank lines will "
"be removed::"
msgstr ""
"可以使用 ``S.rstrip(\"\\r\\n\")`` 从字符串 ``S`` 的末尾删除所有的换行符，而不删除其他尾随空格。如果字符串 ``S`` "
"表示多行，且末尾有几个空行，则将删除所有空行的换行符："

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr "由于通常只在一次读取一行文本时才需要这样做，所以使用 ``S.rstrip()`` 这种方式工作得很好。"

#: ../../faq/programming.rst:1009
msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "是否有 scanf() 或 sscanf() 的等价函数？"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "没有。"

#: ../../faq/programming.rst:1013
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using "
":func:`int` or :func:`float`.  :meth:`!split()` supports an optional \"sep\""
" parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"对于简单的输入解析，最容易的做法通常是用字符串对象的 :meth:`~str.split` 方法将一行内容按空白分隔符拆分为多个单词再用 "
":func:`int` 或 :func:`float` 将十进制数值字符串转换为数值。  :meth:`!split()` 支持可选的 \"sep\" "
"形参，适用于分隔符不是空白符的情况。"

#: ../../faq/programming.rst:1019
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr "对于更复杂的输入解析，正则表达式相比 C 的 ``sscanf`` 更为强大也更为适合。"

#: ../../faq/programming.rst:1024
msgid "What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?"
msgstr "'UnicodeDecodeError' 或 'UnicodeEncodeError' 错误是什么意思？"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr "见 :ref:`unicode-howto`"

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr "我能以奇数个反斜杠来结束一个原始字符串吗？"

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr "以奇数个反斜杠结尾的原始字符串将会转义用于标记字符串的引号::"

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr "有几种绕过此问题的办法。 其中之一是使用常规字符串以及双反斜杠::"

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr "另一种办法是将一个包含被转义反斜杠的常规字符串拼接到原始字符串上::"

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr "在 Windows 上还可以使用 :func:`os.path.join` 来添加反斜杠::"

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"请注意虽然在确定原始字符串的结束位置时反斜杠会对引号进行“转义“，但在解析原始字符串的值时并不会发生转义。 "
"也就是说，反斜杠会被保留在原始字符串的值中::"

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr "另请参阅 :ref:`语言参考 <strings>` 中的规范说明。"

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "性能"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "我的程序太慢了。该如何加快速度？"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr "总的来说，这是个棘手的问题。在进一步讨论之前，首先应该记住以下几件事："

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr "不同的 Python 实现具有不同的性能特点。 本 FAQ 着重解答的是 :term:`CPython`。"

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking about "
"I/O or multi-threading."
msgstr "不同操作系统可能会有不同表现，尤其是涉及 I/O 和多线程时。"

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr "在尝试优化代码 *之前* ，务必要先找出程序中的热点（请参阅 :mod:`profile` 模块）。"

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr "编写基准测试脚本，在寻求性能提升的过程中就能实现快速迭代（请参阅 :mod:`timeit` 模块）。"

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing or"
" any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr "强烈建议首先要保证足够高的代码测试覆盖率（通过单元测试或其他技术），因为复杂的优化有可能会导致代码回退。"

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr "话虽如此，Python 代码的提速还是有很多技巧的。以下列出了一些普适性的原则，对于让性能达到可接受的水平会有很大帮助："

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr "相较于试图对全部代码铺开做微观优化，优化算法（或换用更快的算法）可以产出更大的收益。"

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr "使用正确的数据结构。参考 :ref:`bltin-types` 和 :mod:`collections` 模块的文档。"

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the "
":meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"如果标准库已为某些操作提供了基础函数，则可能（当然不能保证）比所有自编的函数都要快。对于用 C "
"语言编写的基础函数则更是如此，比如内置函数和一些扩展类型。例如，一定要用内置方法 :meth:`list.sort` 或 :func:`sorted` "
"函数进行排序（某些高级用法的示例请参阅 :ref:`sortinghowto` ）。"

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done,"
" your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often"
" detrimental to readability)."
msgstr ""
"抽象往往会造成中间层，并会迫使解释器执行更多的操作。如果抽象出来的中间层级太多，工作量超过了要完成的有效任务，那么程序就会被拖慢。应该避免过度的抽象，而且往往也会对可读性产生不利影响，特别是当函数或方法比较小的时候。"

#: ../../faq/programming.rst:1115
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools"
" to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"如果你已经达到纯 Python 允许的限制，那么有一些工具可以让你走得更远。 例如，`Cython <https://cython.org>`_ "
"可以将稍加修改的 Python 代码版本编译为 C 扩展，并能在许多不同的平台上使用。 Cython "
"可以利用编译（和可选的类型标注）来让你的代码显著快于解释运行时的速度。 如果你对自己的 C 编程技能有信心，还可以自行 :ref:`编写 C 扩展模块 "
"<extending-index>`。"

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."
msgstr ""
"专门介绍 `性能提示 <https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_ "
"的wiki页面。"

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr "将多个字符串连接在一起的最有效方法是什么？"

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
":class:`str` 和 :class:`bytes` "
"对象是不可变的，因此连接多个字符串的效率会很低，因为每次连接都会创建一个新的对象。一般情况下，总耗时与字符串总长是二次方的关系。"

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr "如果要连接多个 :class:`str` 对象，通常推荐的方案是先全部放入列表，最后再调用 :meth:`str.join` ："

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr "（还有一种合理高效的习惯做法，就是利用 :class:`io.StringIO` ）"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"如果要连接多个 :class:`bytes` 对象，推荐做法是用 :class:`bytearray` 对象的原地连接操作（ ``+=`` "
"运算符）追加数据："

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "序列（元组/列表）"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "如何在元组和列表之间进行转换？"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr "类型构造器 ``tuple(seq)`` 可将任意序列（实际上是任意可迭代对象）转换为数据项和顺序均不变的元组。"

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"例如，``tuple([1, 2, 3])`` 会生成 ``(1, 2, 3)`` ， ``tuple('abc')`` 则会生成 ``('a', "
"'b', 'c')`` 。 如果参数就是元组，则不会创建副本而是返回同一对象，因此如果无法确定某个对象是否为元组时，直接调用 :func:`tuple`"
" 也没什么代价。"

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"类型构造器 ``list(seq)`` 可将任意序列或可迭代对象转换为数据项和顺序均不变的列表。例如，``list((1, 2, 3))`` 会生成 "
"``[1, 2, 3]`` 而 ``list('abc')`` 则会生成 ``['a', 'b', 'c']``。如果参数即为列表，则会像 "
"``seq[:]`` 那样创建一个副本。"

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "什么是负数索引？"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Python 序列的索引可以是正数或负数。索引为正数时，0 是第一个索引值， 1 为第二个，依此类推。索引为负数时，-1 为倒数第一个索引值，-2 "
"为倒数第二个，依此类推。可以认为 ``seq[-n]`` 就相当于 ``seq[len(seq)-n]``。"

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr "使用负数序号有时会很方便。 例如 ``S[:-1]`` 就是原字符串去掉最后一个字符，这可以用来移除某个字符串末尾的换行符。"

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "序列如何以逆序遍历？"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr "使用内置函数 :func:`reversed` ："

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr "原序列不会变化，而是构建一个逆序的新副本以供遍历。"

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "如何从列表中删除重复项？"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr "许多完成此操作的的详细介绍，可参阅 Python Cookbook："

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of"
" the list, deleting duplicates as you go::"
msgstr "如果列表允许重新排序，不妨先对其排序，然后从列表末尾开始扫描，依次删除重复项："

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all "
":term:`hashable`) this is often faster ::"
msgstr "如果列表的所有元素都能用作集合的键（即都是 :term:`hashable` ），以下做法速度往往更快："

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr "以上操作会将列表转换为集合，从而删除重复项，然后返回成列表。"

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "如何从列表中删除多个项？"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice"
" replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"类似于删除重复项，一种做法是反向遍历并根据条件删除。不过更简单快速的做法就是切片替换操作，采用隐式或显式的正向迭代遍历。以下是三种变体写法："

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "列表推导式可能是最快的。"

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "如何在 Python 中创建数组？"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "用列表："

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr "列表在时间复杂度方面相当于 C 或 Pascal 的数组；主要区别在于，Python 列表可以包含多种不同类型的对象。"

#: ../../faq/programming.rst:1254
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than lists."
"  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"``array`` 模块也提供了一些创建具有紧凑表示形式的固定类型数据的方法，但其索引速度要比列表慢。 还可关注 `NumPy "
"<https://numpy.org/>`_ 和其他一些第三方包也定义了一些各具特色的数组类结构体。"

#: ../../faq/programming.rst:1260
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr "要获得 Lisp 风格的列表，可以使用元组来模拟 *cons 单元*::"

#: ../../faq/programming.rst:1264
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"如果需要可变特性，你可以用列表来代替元组。 在这里模拟 Lisp *car* 的是 ``lisp_list[0]`` 而模拟 *cdr* 的是 "
"``lisp_list[1]``。 只有在你确定真有需要时才这样做，因为这通常会比使用 Python 列表要慢上许多。"

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "如何创建多维列表？"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "多维数组或许会用以下方式建立："

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "打印出来貌似没错："

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "但如果给某一项赋值，结果会同时在多个位置体现出来："

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"原因在于用 ``*`` 对列表执行重复操作并不会创建副本，而只是创建现有对象的引用。 ``*3`` 创建的是包含 3 "
"个引用的列表，每个引用指向的是同一个长度为 2 的列表。1 处改动会体现在所有地方，这一定不是应有的方案。"

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr "推荐做法是先创建一个所需长度的列表，然后将每个元素都填充为一个新建列表。"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr "以上生成了一个包含 3 个列表的列表，每个子列表的长度为 2。也可以采用列表推导式："

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr "或者，你也可以使用提供矩阵数据类型的扩展；其中最著名的是 `NumPy <https://numpy.org/>`_。"

#: ../../faq/programming.rst:1325
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "我如何将一个方法或函数应用于由对象组成的序列？"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, a "
":term:`list comprehension` is an elegant solution::"
msgstr "要调用一个方法或函数并将返回值累积到一个列表中，:term:`list comprehension` 是一种优雅的解决方案::"

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a plain"
" :keyword:`for` loop will suffice::"
msgstr "如果只需运行方法或函数而不保存返回值，那么一个简单的 :keyword:`for` 循环就足够了::"

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr "为什么 a_tuple[i] += ['item'] 会引发异常？"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and"
" immutable objects in Python."
msgstr "这是由两个因素共同导致的，一是增强赋值运算符属于 *赋值* 运算符，二是 Python 可变和不可变对象之间的差别。"

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr "只要元组的元素指向可变对象，这时对元素进行增强赋值，那么这里介绍的内容都是适用的。在此只以 ``list`` 和 ``+=`` 举例。"

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "如果你写成这样::"

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"触发异常的原因显而易见： ``1`` 会与指向（``1``）的对象 ``a_tuple[0]`` 相加，生成结果对象 ``2``，但在试图将运算结果 "
"``2`` 赋值给元组的 ``0`` 号元素时就会报错，因为元组元素的指向无法更改。"

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr "其实在幕后，上述增强赋值语句的执行过程大致如下："

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr "由于元组是不可变的，因此赋值这步会引发错误。"

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "如果写成以下这样："

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact"
" that even though there was an error, the append worked::"
msgstr "这时触发异常会令人略感惊讶，更让人吃惊的是虽有报错，但加法操作却生效了："

#: ../../faq/programming.rst:1396
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent"
" to calling :meth:`!extend` on the list and returning the list.  That's why "
"we say that for lists, ``+=`` is a \"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"要明白为什么会这样，你需要知道 (a) 如果一个对象实现了 :meth:`~object.__iadd__` 魔术方法，那么它就会在执行 ``+=`` "
"增强赋值时被调用，并且其返回值将在赋值语句中被使用；(b) 对于列表而言，:meth:`!__iadd__` 等价于在列表上调用 "
":meth:`!extend` 并返回该列表。 所以对于列表我们可以这样说，``+=`` 就是 :meth:`!list.extend` "
"的“快捷方式”::"

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "这相当于："

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"a_list 所引用的对象已被修改，而引用被修改对象的指针又重新被赋值给 ``a_list``。 赋值的最终结果没有变化，因为它是引用 "
"``a_list`` 之前所引用的同一对象的指针，但仍然发生了赋值操作。"

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "因此，在此元组示例中，发生的事情等同于："

#: ../../faq/programming.rst:1427
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
":meth:`!__iadd__` 执行成功，因此列表得到了扩充，但是即使 ``result`` 是指向 ``a_tuple[0]`` "
"所指向的同一个对象，最后的赋值仍然会导致错误，因为元组是不可变的。"

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr "我想做一个复杂的排序：能用 Python 进行施瓦茨变换吗？"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"归功于 Perl 社区的 Randal Schwartz，该技术根据度量值对列表进行排序，该度量值将每个元素映射为“顺序值”。在 Python "
"中，请利用 :meth:`list.sort` 方法的 ``key`` 参数："

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "如何根据另一个列表的值对某列表进行排序？"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr "将它们合并到元组的迭代器中，对结果列表进行排序，然后选择所需的元素。"

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "对象"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "什么是类？"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"类是通过执行 class 语句创建的某种对象的类型。创建实例对象时，用 Class "
"对象作为模板，实例对象既包含了数据（属性），又包含了数据类型特有的代码（方法）。"

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"类可以基于一个或多个其他类（称之为基类）进行创建。基类的属性和方法都得以继承。这样对象模型就可以通过继承不断地进行细化。比如通用的 "
"``Mailbox`` 类提供了邮箱的基本访问方法.，它的子类 ``MboxMailbox``、 ``MaildirMailbox``、 "
"``OutlookMailbox`` 则能够处理各种特定的邮箱格式。"

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "什么是方法？"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as "
"``x.name(arguments...)``.  Methods are defined as functions inside the class"
" definition::"
msgstr ""
"方法是属于对象的函数，对于对象 ``x`` ，通常以 ``x.name(arguments...)`` "
"的形式调用。方法以函数的形式给出定义，位于类的定义内："

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "什么是 self ？"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b,"
" c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self 只是方法的第一个参数的习惯性名称。假定某个类中有个方法定义为 ``meth(self, a, b, c)`` ，则其实例 ``x`` 应以 "
"``x.meth(a, b, c)`` 的形式进行调用；而被调用的方法则应视其为做了 ``meth(x, a, b, c)`` 形式的调用。"

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr "另请参阅 :ref:`why-self` 。"

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a subclass"
" of it?"
msgstr "如何检查对象是否为给定类或其子类的一个实例？"

#: ../../faq/programming.rst:1504
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1,"
" class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"使用内置函数 :func:`isinstance(obj, cls) <isinstance>`。 "
"你可以检测对象是否属于多个类中的某一个的实例，只要提供一个元组而非单个类即可，如 ``isinstance(obj, (class1, class2, "
"...))``，还可以检测对象是否属于 Python 的某个内置类型，如 ``isinstance(obj, str)`` 或 "
"``isinstance(obj, (int, float, complex))``。"

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an "
":term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"请注意 :func:`isinstance` 还会检测派生自 :term:`abstract base class` 的虚继承。 "
"因此对于已注册的类，即便没有直接或间接继承自抽象基类，对抽象基类的检测都将返回 ``True`` 。要想检测“真正的继承”，请扫描类的 "
":term:`MRO`:"

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"请注意，大多数程序不会经常用 :func:`isinstance` 对用户自定义类进行检测。 "
"如果是自已开发的类，更合适的面向对象编程风格应该是在类中定义多种方法，以封装特定的行为，而不是检查对象属于什么类再据此干不同的事。假定有如下执行某些操作的函数::"

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr "更好的方法是在所有类上定义一个 ``search()`` 方法，然后调用它："

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "什么是委托？"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all"
" other methods to the corresponding method of ``x``."
msgstr ""
"委托是一种面向对象的技术（也称为设计模式）。假设对象 ``x`` "
"已经存在，现在想要改变其某个方法的行为。可以创建一个新类，其中提供了所需修改方法的新实现，而将所有其他方法都委托给 ``x`` 的对应方法。"

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all"
" written data to uppercase::"
msgstr "Python 程序员可以轻松实现委托。比如以下实现了一个类似于文件的类，只是会把所有写入的数据转换为大写："

#: ../../faq/programming.rst:1598
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying "
"``self._outfile.write()`` method.  All other methods are delegated to the "
"underlying ``self._outfile`` object.  The delegation is accomplished via the"
" :meth:`~object.__getattr__` method; consult :ref:`the language reference "
"<attribute-access>` for more information about controlling attribute access."
msgstr ""
"这里 ``UpperOut`` 类重新定义了 ``write()`` 方法，在调用下层的 ``self._outfile.write()`` "
"方法之前将参数字符串转换为大写形式。 所有其他方法都被委托给下层的 ``self._outfile`` 对象。 委托是通过 "
":meth:`~object.__getattr__` 方法完成的；请参阅 :ref:`语言参考 <attribute-access>` "
"了解有关控制属性访问的更多信息。"

#: ../../faq/programming.rst:1605
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a "
":meth:`~object.__setattr__` method too, and it must do so carefully.  The "
"basic implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"请注意在更一般的情况下委托可能会变得比较棘手。 当属性即需要被设置又需要被提取时，类还必须定义 :meth:`~object.__setattr__` "
"方法，而这样做必须十分小心。 :meth:`!__setattr__` 的基本实现大致如下所示::"

#: ../../faq/programming.rst:1616
msgid ""
"Most :meth:`!__setattr__` implementations must modify :meth:`self.__dict__ "
"<object.__dict__>` to store local state for self without causing an infinite"
" recursion."
msgstr ""
"大多数 :meth:`!__setattr__` 实现都必须修改 :meth:`self.__dict__ <object.__dict__>` "
"来为自身保存局部状态而不至于造成无限递归。"

#: ../../faq/programming.rst:1622
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr "如何在扩展基类的派生类中调用基类中定义的方法？"

#: ../../faq/programming.rst:1624
msgid "Use the built-in :func:`super` function::"
msgstr "使用内置的 :func:`super` 函数："

#: ../../faq/programming.rst:1630
msgid ""
"In the example, :func:`super` will automatically determine the instance from"
" which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"在下面的例子中，:func:`super` 将自动根据它的调用方 (``self`` 值) 来确定实例对象，使用 "
"``type(self).__mro__`` 查找 :term:`method resolution order` (MRO)，并返回 MRO 中位于 "
"``Derived`` 之后的项: ``Base``。"

#: ../../faq/programming.rst:1637
msgid "How can I organize my code to make it easier to change the base class?"
msgstr "如何让代码更容易对基类进行修改？"

#: ../../faq/programming.rst:1639
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then"
" all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"可以为基类赋一个别名并基于该别名进行派生。这样只要修改赋给该别名的值即可。顺便提一下，如要动态地确定（例如根据可用的资源）该使用哪个基类，这个技巧也非常方便。例如："

#: ../../faq/programming.rst:1654
msgid "How do I create static class data and static class methods?"
msgstr "如何创建静态类数据和静态类方法？"

#: ../../faq/programming.rst:1656
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr "Python 支持静态数据和静态方法（以 C++ 或 Java 的定义而言）。"

#: ../../faq/programming.rst:1659
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr "静态数据只需定义一个类属性即可。若要为属性赋新值，则必须在赋值时显式使用类名："

#: ../../faq/programming.rst:1671
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"对于所有符合 ``isinstance(c, C)`` 的 ``c``， ``c.count`` 也同样指向 ``C.count`` ，除非被 "
"``c`` 自身或者被从 ``c.__class__`` 回溯到基类 ``C`` 的搜索路径上的某个类所覆盖。"

#: ../../faq/programming.rst:1675
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own dict."
"  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"注意：在 C 的某个方法内部，像 ``self.count = 42`` 这样的赋值将在 ``self`` 自身的字典中新建一个名为 \"count\""
" 的不相关实例。 想要重新绑定类静态数据名称就必须总是指明类名，无论是在方法内部还是外部::"

#: ../../faq/programming.rst:1682
msgid "Static methods are possible::"
msgstr "Python 支持静态方法："

#: ../../faq/programming.rst:1690
msgid ""
"However, a far more straightforward way to get the effect of a static method"
" is via a simple module-level function::"
msgstr "不过为了获得静态方法的效果，还有一种做法直接得多，也即使用模块级函数即可："

#: ../../faq/programming.rst:1696
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr "如果代码的结构化比较充分，每个模块只定义了一个类（或者多个类的层次关系密切相关），那就具备了应有的封装。"

#: ../../faq/programming.rst:1701
msgid "How can I overload constructors (or methods) in Python?"
msgstr "在 Python 中如何重载构造函数（或方法）？"

#: ../../faq/programming.rst:1703
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr "这个答案实际上适用于所有方法，但问题通常首先出现于构造函数的应用场景中。"

#: ../../faq/programming.rst:1706
msgid "In C++ you'd write"
msgstr "在 C++ 中，代码会如下所示："

#: ../../faq/programming.rst:1715
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr "在 Python 中，只能编写一个构造函数，并用默认参数捕获所有情况。例如："

#: ../../faq/programming.rst:1725
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "这不完全等同，但在实践中足够接近。"

#: ../../faq/programming.rst:1727
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "也可以试试采用变长参数列表，例如："

#: ../../faq/programming.rst:1732
msgid "The same approach works for all method definitions."
msgstr "上述做法同样适用于所有方法定义。"

#: ../../faq/programming.rst:1736
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "在用 __spam 的时候得到一个类似 _SomeClassName__spam 的错误信息。"

#: ../../faq/programming.rst:1738
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"以双下划线打头的变量名会被“破坏”，以便以一种简单高效的方式定义类私有变量。任何形式为 ``__spam`` "
"的标识符（至少前缀两个下划线，至多后缀一个下划线）文本均会被替换为 ``_classname__spam``，其中 ``classname`` "
"为去除了全部前缀下划线的当前类名称。"

#: ../../faq/programming.rst:1744
msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in"
" the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr ""
"这并不能保证私密性：外部用户仍然可以访问 \"_classname__spam\" 属性，私有变量值也在对象的 ``__dict__`` 中可见。 许多"
" Python 程序员根本不操心要去使用私有变量名。"

#: ../../faq/programming.rst:1751
msgid ""
"My class defines __del__ but it is not called when I delete the object."
msgstr "类定义了 __del__ 方法，但是删除对象时没有调用它。"

#: ../../faq/programming.rst:1753
msgid "There are several possible reasons for this."
msgstr "这有几个可能的原因。"

#: ../../faq/programming.rst:1755
msgid ""
"The :keyword:`del` statement does not necessarily call "
":meth:`~object.__del__` -- it simply decrements the object's reference "
"count, and if this reaches zero :meth:`!__del__` is called."
msgstr ""
":keyword:`del` 语句不一定要调用 :meth:`~object.__del__` -- 它只是减少对象的引用计数，如果计数达到零才会调用 "
":meth:`!__del__`。"

#: ../../faq/programming.rst:1759
msgid ""
"If your data structures contain circular links (e.g. a tree where each child"
" has a parent reference and each parent has a list of children) the "
"reference counts will never go back to zero.  Once in a while Python runs an"
" algorithm to detect such cycles, but the garbage collector might run some "
"time after the last reference to your data structure vanishes, so your "
":meth:`!__del__` method may be called at an inconvenient and random time. "
"This is inconvenient if you're trying to reproduce a problem. Worse, the "
"order in which object's :meth:`!__del__` methods are executed is arbitrary."
"  You can run :func:`gc.collect` to force a collection, but there *are* "
"pathological cases where objects will never be collected."
msgstr ""
"如果你的数据结构包含循环链接（如树每个子节点都带有父节点的引用，而每个父节点也带有子节点的列表），引用计数永远不会回零。 尽管 Python "
"偶尔会用某种算法检测这种循环引用，但在数据结构的最后一条引用消失之后，垃圾收集器可能还要过段时间才会运行，因此 :meth:`!__del__` "
"方法可能会在不方便或随机的时刻被调用。 这对于重现一个问题是非常不方便的。 更糟糕的是，各个对象的 :meth:`!__del__` "
"方法是以随机顺序执行的。 虽然你可以运行 :func:`gc.collect` 来强制执行垃圾回收操作，但 *仍会存在* "
"一些对象永远不会被回收的失控情况。"

#: ../../faq/programming.rst:1770
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects."
"  Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than"
" once for the same object."
msgstr ""
"尽管有垃圾回收器，但当对象使用完毕时在要调用的对象上定义显式的 ``close()`` 方法仍然是个好主意。 ``close()`` "
"方法可以随后移除引用子对象的属性。 请不要直接调用 :meth:`!__del__` -- :meth:`!__del__` 应当调用 "
"``close()`` 并且 ``close()`` 应当确保被可以被同一对象多次调用。"

#: ../../faq/programming.rst:1777
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"另一种避免循环引用的做法是利用 :mod:`weakref` "
"模块，该模块允许指向对象但不增加其引用计数。例如，树状数据结构应该对父节点和同级节点使用弱引用（如果真要用的话！）"

#: ../../faq/programming.rst:1790
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr "最后，如果你的 :meth:`!__del__` 方法引发了异常，会将警告消息打印到 :data:`sys.stderr`。"

#: ../../faq/programming.rst:1795
msgid "How do I get a list of all instances of a given class?"
msgstr "如何获取给定类的所有实例的列表？"

#: ../../faq/programming.rst:1797
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr "Python 不会记录类（或内置类型）的实例。可以在类的构造函数中编写代码，通过保留每个实例的弱引用列表来跟踪所有实例。"

#: ../../faq/programming.rst:1803
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "为什么 ``id()`` 的结果看起来不是唯一的？"

#: ../../faq/programming.rst:1805
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in"
" memory.  This is illustrated by this example:"
msgstr ""
":func:`id` 返回一个整数，该整数在对象的生命周期内保证是唯一的。 因为在 CPython "
"中，这是对象的内存地址，所以经常发生在从内存中删除对象之后，下一个新创建的对象被分配在内存中的相同位置。 这个例子说明了这一点："

#: ../../faq/programming.rst:1816
msgid ""
"The two ids belong to different integer objects that are created before, and"
" deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"这两个 id 属于不同的整数对象，之前先创建了对象，执行 ``id()`` 调用后又立即被删除了。若要确保检测 id "
"时的对象仍处于活动状态，请再创建一个对该对象的引用："

#: ../../faq/programming.rst:1829
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "什么情况下可以依靠 *is* 运算符进行对象的身份相等性测试？"

#: ../../faq/programming.rst:1831
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr "``is`` 运算符可用于测试对象的身份相等性。``a is b`` 等价于 ``id(a) == id(b)``。"

#: ../../faq/programming.rst:1834
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are"
" usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"身份相等性最重要的特性就是对象总是等同于自身，``a is a`` 一定返回 "
"``True``。身份相等性测试的速度通常比相等性测试要快。而且与相等性测试不一样，身份相等性测试会确保返回布尔值 ``True`` 或 "
"``False``。"

#: ../../faq/programming.rst:1839
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr "但是，身份相等性测试 *只能* 在对象身份确定的场景下才可替代相等性测试。一般来说，有以下3种情况对象身份是可以确定的："

#: ../../faq/programming.rst:1843
msgid ""
"1) Assignments create new names but do not change object identity.  After "
"the assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr "1） 赋值操作创建了新的名称但没有改变对象身份。 在赋值操作 ``new = old`` 之后，可以保证 ``new is old``。"

#: ../../faq/programming.rst:1846
msgid ""
"2) Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"2） 将对象置入存放对象引用的容器，对象身份不会改变。在列表赋值操作 ``s[0] = x`` 之后，可以保证 ``s[0] is x``。"

#: ../../faq/programming.rst:1850
msgid ""
"3) If an object is a singleton, it means that only one instance of that "
"object can exist.  After the assignments ``a = None`` and ``b = None``, it "
"is guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"3） 单例对象，也即该对象只能存在一个实例。在赋值操作 ``a = None`` 和 ``b = None`` 之后，可以保证 ``a is "
"b``，因为 ``None`` 是单例对象。"

#: ../../faq/programming.rst:1854
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"其他大多数情况下，都不建议使用身份相等性测试，而应采用相等性测试。尤其是不应将身份相等性测试用于检测常量值，例如 :class:`int` 和 "
":class:`str`，因为他们并不一定是单例对象："

#: ../../faq/programming.rst:1871
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr "同样地，可变容器的新实例，对象身份一定不同："

#: ../../faq/programming.rst:1878
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr "在标准库代码中，给出了一些正确使用对象身份测试的常见模式："

#: ../../faq/programming.rst:1881
msgid ""
"1) As recommended by :pep:`8`, an identity test is the preferred way to "
"check for ``None``.  This reads like plain English in code and avoids "
"confusion with other objects that may have boolean values that evaluate to "
"false."
msgstr ""
"1） 正如 :pep:`8` 所推荐的，对象身份测试是 ``None`` "
"值的推荐检测方式。这样的代码读起来就像自然的英文，并可以避免与其他可能为布尔值且计算结果为 False 的对象相混淆。"

#: ../../faq/programming.rst:1885
msgid ""
"2) Detecting optional arguments can be tricky when ``None`` is a valid input"
" value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`::"
msgstr ""
"2) 当 ``None`` 是一个有效的输入值时，检测可选参数可能很棘手。 在这些情况下，你可以创建一个单例哨兵对象，保证与其他对象不同。 "
"例如，这里是如何实现一个方法，其行为类似于 :meth:`dict.pop` ："

#: ../../faq/programming.rst:1901
msgid ""
"3) Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"3） 编写容器的实现代码时，有时需要用对象身份测试来加强相等性检测。这样代码就不会被 ``float('NaN')`` 这类与自身不相等的对象所干扰。"

#: ../../faq/programming.rst:1905
msgid ""
"For example, here is the implementation of "
":meth:`!collections.abc.Sequence.__contains__`::"
msgstr "例如，以下是 :meth:`!collections.abc.Sequence.__contains__` 的实现代码::"

#: ../../faq/programming.rst:1916
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr "一个子类如何控制哪些数据被存储在一个不可变的实例中？"

#: ../../faq/programming.rst:1918
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs"
" *after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"当子类化一个不可变类型时，请重写 :meth:`~object.__new__` 方法而不是 :meth:`~object.__init__` 方法。 "
"后者只在一个实例被创建 *之后* 运行，这对于改变不可变实例中的数据来说太晚了。"

#: ../../faq/programming.rst:1923
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr "所有这些不可变的类都有一个与它们的父类不同的签名:"

#: ../../faq/programming.rst:1949
msgid "The classes can be used like this:"
msgstr "这些类可以这样使用:"

#: ../../faq/programming.rst:1966
msgid "How do I cache method calls?"
msgstr "我该如何缓存方法调用？"

#: ../../faq/programming.rst:1968
msgid ""
"The two principal tools for caching methods are "
":func:`functools.cached_property` and :func:`functools.lru_cache`.  The "
"former stores results at the instance level and the latter at the class "
"level."
msgstr ""
"缓存方法的两个主要工具是 :func:`functools.cached_property` 和 "
":func:`functools.lru_cache`。 前者在实例层级上存储结果而后者在类层级上存储结果。"

#: ../../faq/programming.rst:1973
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"*cached_property* 方式仅适用于不接受任何参数的方法。 它不会创建对实例的引用。 被缓存的方法结果将仅在实例的生存其内被保留。"

#: ../../faq/programming.rst:1977
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr "其优点是，当一个实例不再被使用时，缓存的方法结果将被立即释放。缺点是，如果实例累积起来，累积的方法结果也会增加。它们可以无限制地增长。"

#: ../../faq/programming.rst:1982
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr "*lru_cache* 方式适用于具有 :term:`hashable` 参数的方法。 它会创建对实例的引用，除非特别设置了传入弱引用。"

#: ../../faq/programming.rst:1986
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr "最少近期使用算法的优点是缓存会受指定的 *maxsize* 限制。 它的缺点是实例会保持存活，直到其达到生存期或者缓存被清空。"

#: ../../faq/programming.rst:1991
msgid "This example shows the various techniques::"
msgstr "这个例子演示了几种不同的方式::"

#: ../../faq/programming.rst:2015
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"上面的例子假定 *station_id* 从不改变。 如果相关实例属性是可变对象，则 *cached_property* "
"方式就不再适用，因为它无法检测到属性的改变。"

#: ../../faq/programming.rst:2020
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and "
":meth:`~object.__hash__` methods so that the cache can detect relevant "
"attribute updates::"
msgstr ""
"要让 *lru_cache* 方式在 *station_id* 可变时仍然适用，类需要定义 :meth:`~object.__eq__` 和 "
":meth:`~object.__hash__` 方法以便缓存能检测到相关属性的更新::"

#: ../../faq/programming.rst:2046
msgid "Modules"
msgstr "模块"

#: ../../faq/programming.rst:2049
msgid "How do I create a .pyc file?"
msgstr "如何创建 .pyc 文件？"

#: ../../faq/programming.rst:2051
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for "
"details.)"
msgstr ""
"当首次导入模块时（或当前已编译文件创建之后源文件发生了改动），在 ``.py`` 文件所在目录的 ``__pycache__`` "
"子目录下会创建一个包含已编译代码的 ``.pyc`` 文件。该 ``.pyc`` 文件的名称开头部分将与 ``.py`` 文件名相同，并以 "
"``.pyc`` 为后缀，中间部分则依据创建它的 ``python`` 版本而各不相同。（详见 :pep:`3147`。）"

#: ../../faq/programming.rst:2059
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"``.pyc`` 文件有可能会无法创建，原因之一是源码文件所在的目录存在权限问题，这样就无法创建 ``__pycache__`` "
"子目录。假如以某个用户开发程序而以另一用户运行程序，就有可能发生权限问题，测试 Web 服务器就属于这种情况。"

#: ../../faq/programming.rst:2064
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python"
" has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"除非设置了 :envvar:`PYTHONDONTWRITEBYTECODE` 环境变量，否则导入模块并且 Python 能够创建 "
"``__pycache__`` 子目录并把已编译模块写入该子目录（权限、存储空间等等）时，.pyc 文件就将自动创建。"

#: ../../faq/programming.rst:2069
msgid ""
"Running Python on a top level script is not considered an import and no "
"``.pyc`` will be created.  For example, if you have a top-level module "
"``foo.py`` that imports another module ``xyz.py``, when you run ``foo`` (by "
"typing ``python foo.py`` as a shell command), a ``.pyc`` will be created for"
" ``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"在最高层级运行的 Python 脚本不会被视为经过了导入操作，因此不会创建 ``.pyc`` 文件。假定有一个最高层级的模块文件 "
"``foo.py``，它导入了另一个模块 ``xyz.py``，当运行 ``foo`` 模块（通过输入 shell 命令 ``python "
"foo.py`` ），则会为 ``xyz`` 创建一个 ``.pyc``，因为 ``xyz`` 是被导入的，但不会为 ``foo`` 创建 "
"``.pyc`` 文件，因为 ``foo.py`` 不是被导入的。"

#: ../../faq/programming.rst:2076
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a "
"``.pyc`` file for a module that is not imported -- you can, using the "
":mod:`py_compile` and :mod:`compileall` modules."
msgstr ""
"若要为 ``foo`` 创建 ``.pyc`` 文件 —— 即为未做导入的模块创建 ``.pyc`` 文件 —— 可以利用 "
":mod:`py_compile` 和 :mod:`compileall` 模块。"

#: ../../faq/programming.rst:2080
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to"
" use the ``compile()`` function in that module interactively::"
msgstr ":mod:`py_compile` 模块能够手动编译任意模块。 一种做法是交互式地使用该模块中的 ``compile()`` 函数::"

#: ../../faq/programming.rst:2086
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter"
" ``cfile``)."
msgstr ""
"这将会将  ``.pyc`` 文件写入与 ``foo.py`` 相同位置下的 ``__pycache__`` 子目录（或者你也可以通过可选参数 "
"``cfile`` 来重写该行为）。"

#: ../../faq/programming.rst:2090
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"还可以用 :mod:`compileall` 模块自动编译一个或多个目录下的所有文件。只要在命令行提示符中运行 ``compileall.py`` "
"并给出要编译的 Python 文件所在目录路径即可："

#: ../../faq/programming.rst:2099
msgid "How do I find the current module name?"
msgstr "如何找到当前模块名称？"

#: ../../faq/programming.rst:2101
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"模块可以查看预定义的全局变量 ``__name__`` 获悉自己的名称。如其值为 ``'__main__'`` "
"，程序将作为脚本运行。通常，许多通过导入使用的模块同时也提供命令行接口或自检代码，这些代码只在检测到处于 ``__name__`` 之后才会执行："

#: ../../faq/programming.rst:2116
msgid "How can I have modules that mutually import each other?"
msgstr "如何让模块相互导入？"

#: ../../faq/programming.rst:2118
msgid "Suppose you have the following modules:"
msgstr "假设有以下模块："

#: ../../faq/programming.rst:2120
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../../faq/programming.rst:2125
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../../faq/programming.rst:2130
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "问题是解释器将执行以下步骤："

#: ../../faq/programming.rst:2132
msgid "main imports ``foo``"
msgstr "首先导入  ``foo``"

#: ../../faq/programming.rst:2133
msgid "Empty globals for ``foo`` are created"
msgstr "为 ``foo``  创建空的全局变量"

#: ../../faq/programming.rst:2134
msgid "``foo`` is compiled and starts executing"
msgstr "编译 ``foo`` 并开始执行"

#: ../../faq/programming.rst:2135
msgid "``foo`` imports ``bar``"
msgstr "``foo`` 导入 ``bar``"

#: ../../faq/programming.rst:2136
msgid "Empty globals for ``bar`` are created"
msgstr "为 ``bar`` 创建空的全局变量"

#: ../../faq/programming.rst:2137
msgid "``bar`` is compiled and starts executing"
msgstr "编译 ``bar``  并开始执行"

#: ../../faq/programming.rst:2138
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr "``bar`` 导入 ``foo`` (该步骤无操作，因为已经有一个名为 ``foo`` 的模块)。"

#: ../../faq/programming.rst:2139
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr "导入机制尝试从 ``foo_var`` 全局变量读取 ``foo``，用来设置 ``bar.foo_var = foo.foo_var``"

#: ../../faq/programming.rst:2141
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet"
" and the global symbol dictionary for ``foo`` is still empty."
msgstr "最后一步失败了，因为 Python 还没有完成对 foo 的解释，foo 的全局符号字典仍然是空的。"

#: ../../faq/programming.rst:2144
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr "当你使用 ``import foo`` ，然后尝试在全局代码中访问 ``foo.foo_var`` 时，会发生同样的事情。"

#: ../../faq/programming.rst:2147
msgid "There are (at least) three possible workarounds for this problem."
msgstr "这个问题有（至少）三种可能的解决方法。"

#: ../../faq/programming.rst:2149
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import "
"...``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum 建议完全避免使用 ``from <module> import ...`` "
"，并将所有代码放在函数中。全局变量和类变量的初始化只应使用常量或内置函数。这意味着导入模块中的所有内容都以 ``<module>.<name>`` "
"的形式引用。"

#: ../../faq/programming.rst:2154
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr "Jim Roskind 建议每个模块都应遵循以下顺序："

#: ../../faq/programming.rst:2156
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr "导出（全局变量、函数和不需要导入基类的类）"

#: ../../faq/programming.rst:2158
msgid "``import`` statements"
msgstr "``import`` 语句"

#: ../../faq/programming.rst:2159
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr "本模块的功能代码（包括根据导入值进行初始化的全局变量）。"

#: ../../faq/programming.rst:2161
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr "Van Rossum 不太喜欢这种方法，因为import出现在一个奇怪的地方，但它确实有效。"

#: ../../faq/programming.rst:2164
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr "Matthias Urlichs 建议对代码进行重构，使得递归导入根本就没必要发生。"

#: ../../faq/programming.rst:2167
msgid "These solutions are not mutually exclusive."
msgstr "这些解决方案并不相互排斥。"

#: ../../faq/programming.rst:2171
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') 返回的是 <module 'x'> ；该如何得到 z 呢？"

#: ../../faq/programming.rst:2173
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr "不妨考虑换用 :mod:`importlib` 中的函数 :func:`~importlib.import_module` ："

#: ../../faq/programming.rst:2180
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr "对已导入的模块进行了编辑并重新导入，但变动没有得以体现。这是为什么？"

#: ../../faq/programming.rst:2182
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force"
" re-reading of a changed module, do this::"
msgstr ""
"出于效率和一致性的原因，Python "
"仅在第一次导入模块时读取模块文件。否则，在一个多模块的程序中，每个模块都会导入相同的基础模块，那么基础模块将会被一而再、再而三地解析。如果要强行重新读取已更改的模块，请执行以下操作："

#: ../../faq/programming.rst:2192
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr "警告：这种技术并非万无一失。尤其是模块包含了以下语句时："

#: ../../faq/programming.rst:2197
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr "仍将继续使用前一版的导入对象。如果模块包含了类的定义，并 *不会* 用新的类定义更新现有的类实例。这样可能会导致以下矛盾的行为："

#: ../../faq/programming.rst:2210
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of"
" the class objects::"
msgstr "只要把类对象的 id 打印出来，问题的性质就会一目了然："

#: ../../faq/programming.rst:408
msgid "argument"
msgstr "argument -- 参数"

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr "与形参的区别"

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr "parameter -- 形参"

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr "与参数的区别"
