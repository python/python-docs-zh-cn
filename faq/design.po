# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/design.rst:3
msgid "Design and History FAQ"
msgstr "设计和历史常见问题"

#: ../../faq/design.rst:6
msgid "Contents"
msgstr "目录"

#: ../../faq/design.rst:11
msgid "Why does Python use indentation for grouping of statements?"
msgstr "为什么 Python 使用缩进来分组语句？"

#: ../../faq/design.rst:13
msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum 认为使用缩进进行分组非常优雅，并且大大提高了普通 Python 程序的清晰度。 "
"大多数人在一段时间后就会喜欢上这个特性。"

#: ../../faq/design.rst:17
msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between"
" grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr "由于没有开始/结束括号，因此解析器感知的分组与人类读者之间不会存在分歧。 偶尔 C 程序员会遇到像这样的代码片段::"

#: ../../faq/design.rst:21
msgid ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"
msgstr ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"

#: ../../faq/design.rst:26
msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers"
" will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"如果条件为真，则只执行 ``x++`` 语句，但缩进会使你认为情况并非如此。 即使是经验丰富的 C 程序员有时也会长久地盯着它发呆，不明白为什么在 "
"``x > y`` 时 ``y`` 也会减少。"

#: ../../faq/design.rst:31
msgid ""
"Because there are no begin/end brackets, Python is much less prone to "
"coding-style conflicts.  In C there are many different ways to place the "
"braces. After becoming used to reading and writing code using a particular "
"style, it is normal to feel somewhat uneasy when reading (or being required "
"to write) in a different one."
msgstr ""
"因为没有开始/结束花括号，所以 Python 更不容易发生代码风格冲突。 在 C 中有许多不同的放置花括号的方式。 "
"在习惯了阅读和编写某种特定风格的代码之后，当阅读（或被要求编写）另一种风格的代码时通常都会令人感觉有点不舒服）。"

#: ../../faq/design.rst:38
msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more"
" work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"许多编码风格将开始/结束括号单独放在一行上。这使得程序相当长，浪费了宝贵的屏幕空间，使得更难以对程序进行全面的了解。 "
"理想情况下，函数应该适合一个屏幕（例如，20--30行）。 20 行 Python 可以完成比 20 行 C 更多的工作。 "
"这不仅仅是由于没有开始/结束括号 -- 无需声明以及高层级的数据类型也是其中的原因  -- 但基于缩进的语法肯定有帮助。"

#: ../../faq/design.rst:48
msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr "为什么简单的算术运算得到奇怪的结果？"

#: ../../faq/design.rst:50
msgid "See the next question."
msgstr "请看下一个问题。"

#: ../../faq/design.rst:54
msgid "Why are floating-point calculations so inaccurate?"
msgstr "为什么浮点计算不准确？"

#: ../../faq/design.rst:56
msgid "Users are often surprised by results like this::"
msgstr "用户经常对这样的结果感到惊讶::"

#: ../../faq/design.rst:58
msgid ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"
msgstr ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"

#: ../../faq/design.rst:61
msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr "并且认为这是 Python 中的一个 bug。其实不是这样。这与 Python 关系不大，而与底层平台如何处理浮点数字关系更大。"

#: ../../faq/design.rst:65
msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A "
":class:`float` object's value is stored in binary floating-point with a "
"fixed precision (typically 53 bits) and Python uses C operations, which in "
"turn rely on the hardware implementation in the processor, to perform "
"floating-point operations. This means that as far as floating-point "
"operations are concerned, Python behaves like many popular languages "
"including C and Java."
msgstr ""
"CPython 中的 :class:`float` 类型使用C语言的 ``double`` 类型进行存储。 :class:`float` "
"对象的值是以固定的精度（通常为 53 位）存储的二进制浮点数，由于 Python 使用 C 操作，而后者依赖于处理器中的硬件实现来执行浮点运算。 "
"这意味着就浮点运算而言，Python 的行为类似于许多流行的语言，包括 C 和 Java。"

#: ../../faq/design.rst:72
msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating point.  For example, after::"
msgstr "许多可以轻松地用十进制表示的数字不能用二进制浮点表示。 例如，在输入以下语句后::"

#: ../../faq/design.rst:75
msgid ">>> x = 1.2"
msgstr ">>> x = 1.2"

#: ../../faq/design.rst:77
msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr "为 ``x`` 存储的值是与十进制的值 ``1.2`` (非常接近) 的近似值，但不完全等于它。 在典型的机器上，实际存储的值是："

#: ../../faq/design.rst:81
msgid "1.0011001100110011001100110011001100110011001100110011 (binary)"
msgstr "1.0011001100110011001100110011001100110011001100110011 (二进制)"

#: ../../faq/design.rst:83
msgid "which is exactly::"
msgstr "它对应于十进制数值::"

#: ../../faq/design.rst:85
msgid "1.1999999999999999555910790149937383830547332763671875 (decimal)"
msgstr "1.1999999999999999555910790149937383830547332763671875 (十进制)"

#: ../../faq/design.rst:87
msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr "典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。"

#: ../../faq/design.rst:90
msgid ""
"For a fuller explanation, please see the :ref:`floating-point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr "要获得更完整的解释，请参阅 Python 教程中的 :ref:`浮点算术 <tut-fp-issues>`  一章。"

#: ../../faq/design.rst:95
msgid "Why are Python strings immutable?"
msgstr "为什么Python字符串是不可变的？"

#: ../../faq/design.rst:97
msgid "There are several advantages."
msgstr "有几个优点。"

#: ../../faq/design.rst:99
msgid ""
"One is performance: knowing that a string is immutable means we can allocate"
" space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr "一个是性能：知道字符串是不可变的，意味着我们可以在创建时为它分配空间，并且存储需求是固定不变的。这也是元组和列表之间区别的原因之一。"

#: ../../faq/design.rst:104
msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else,"
" and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"另一个优点是，Python 中的字符串被视为与数字一样“基本”。 任何动作都不会将值 8 更改为其他值，在 Python 中，任何动作都不会将字符串 "
"\"8\" 更改为其他值。"

#: ../../faq/design.rst:112
msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr "为什么必须在方法定义和调用中显式使用“self”？"

#: ../../faq/design.rst:114
msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr "这个想法借鉴了 Modula-3 语言。 出于多种原因它被证明是非常有用的。"

#: ../../faq/design.rst:117
msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it"
" absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"首先，更明显的显示出，使用的是方法或实例属性而不是局部变量。 阅读 ``self.x`` 或 ``self.meth()`` "
"可以清楚地表明，即使您不知道类的定义，也会使用实例变量或方法。在 C++ 中，可以通过缺少局部变量声明来判断（假设全局变量很少见或容易识别） —— "
"但是在 Python 中没有局部变量声明，所以必须查找类定义才能确定。 一些 C++ 和 Java 编码标准要求实例属性具有 ``m_`` "
"前缀，因此这种显式性在这些语言中仍然有用。"

#: ../../faq/design.rst:127
msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if"
" you want to use a method from a base class which is overridden in a derived"
" class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`~object.__init__` methods, and in general in cases where a"
" derived class method wants to extend the base class method of the same name"
" and thus has to call the base class method somehow."
msgstr ""
"其次，这意味着当要显式引用或从特定类调用该方法时无须特殊语法。 在 C++ 中，如果你想要使用在派生类中被重写的基类方法，你必须使用 ``::`` "
"运算符 -- 在 Python 中你可以写成 ``baseclass.methodname(self, <argument list>)``。 "
"这特别适用于 :meth:`~object.__init__` 方法，并且也适用于派生类方法想要扩展同名的基类方式因而必须以某种方式调用基类方法的情况。"

#: ../../faq/design.rst:136
msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't"
" have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"最后，它解决了变量赋值的语法问题：为了 Python "
"中的局部变量（根据定义！）在函数体中赋值的那些变量（并且没有明确声明为全局）赋值，就必须以某种方式告诉解释器一个赋值是为了分配一个实例变量而不是一个局部变量，它最好是通过语法实现的（出于效率原因）。"
" C++ 通过声明来做到这一点，但是 Python 没有声明，仅仅为了这个目的而引入它们会很可惜。 使用显式的 ``self.var`` "
"很好地解决了这个问题。 类似地，对于使用实例变量，必须编写 ``self.var`` 意味着对方法内部的非限定名称的引用不必搜索实例的目录。 "
"换句话说，局部变量和实例变量存在于两个不同的命名空间中，您需要告诉 Python 使用哪个命名空间。"

#: ../../faq/design.rst:154
msgid "Why can't I use an assignment in an expression?"
msgstr "为什么不能在表达式中赋值？"

#: ../../faq/design.rst:156
msgid "Starting in Python 3.8, you can!"
msgstr "自 Python 3.8 开始，你能做到的！"

#: ../../faq/design.rst:158
msgid ""
"Assignment expressions using the walrus operator ``:=`` assign a variable in"
" an expression::"
msgstr "赋值表达式使用海象运算符 ``:=`` 在表达式中为变量赋值::"

#: ../../faq/design.rst:161
msgid ""
"while chunk := fp.read(200):\n"
"   print(chunk)"
msgstr ""
"while chunk := fp.read(200):\n"
"   print(chunk)"

#: ../../faq/design.rst:164
msgid "See :pep:`572` for more information."
msgstr "请参阅 :pep:`572` 了解详情。"

#: ../../faq/design.rst:169
msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr "为什么Python对某些功能（例如list.index()）使用方法来实现，而其他功能（例如len(List)）使用函数实现？"

#: ../../faq/design.rst:171
msgid "As Guido said:"
msgstr "正如Guido所说："

#: ../../faq/design.rst:173
msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) 对于某些操作，前缀表示法比后缀更容易阅读 -- 前缀（和中缀！）运算在数学中有着悠久的传统，就像在视觉上帮助数学家思考问题的记法。比较一下我们将"
" x*(a+b) 这样的公式改写为 x*a+x*b 的容易程度，以及使用原始OO符号做相同事情的笨拙程度。"

#: ../../faq/design.rst:180
msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and"
" the argument is some kind of container. To the contrary, when I read "
"x.len(), I have to already know that x is some kind of container "
"implementing an interface or inheriting from a class that has a standard "
"len(). Witness the confusion we occasionally have when a class that is not "
"implementing a mapping has a get() or keys() method, or something that isn't"
" a file has a write() method."
msgstr ""
"(b)  "
"当读到写有len(X)的代码时，就知道它要求的是某件东西的长度。这告诉我们两件事：结果是一个整数，参数是某种容器。相反，当阅读x.len()时，必须已经知道x是某种实现接口的容器，或者是从具有标准len()的类继承的容器。当没有实现映射的类有get()或key()方法，或者不是文件的类有write()方法时，我们偶尔会感到困惑。"

#: ../../faq/design.rst:189
msgid ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

#: ../../faq/design.rst:193
msgid "Why is join() a string method instead of a list or tuple method?"
msgstr "为什么 join() 是一个字符串方法而不是列表或元组方法？"

#: ../../faq/design.rst:195
msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"从 Python 1.6 开始，字符串变得更像其他标准类型，当添加方法时，这些方法提供的功能与始终使用 String "
"模块的函数时提供的功能相同。这些新方法中的大多数已被广泛接受，但似乎让一些程序员感到不舒服的一种方法是："

#: ../../faq/design.rst:201
msgid "\", \".join(['1', '2', '4', '8', '16'])"
msgstr "\", \".join(['1', '2', '4', '8', '16'])"

#: ../../faq/design.rst:203
msgid "which gives the result::"
msgstr "结果如下::"

#: ../../faq/design.rst:205
msgid "\"1, 2, 4, 8, 16\""
msgstr "\"1, 2, 4, 8, 16\""

#: ../../faq/design.rst:207
msgid "There are two common arguments against this usage."
msgstr "反对这种用法有两个常见的论点。"

#: ../../faq/design.rst:209
msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed"
" on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"第一条是这样的：“使用字符串文本(String "
"Constant)的方法看起来真的很难看”，答案是也许吧，但是字符串文本只是一个固定值。如果在绑定到字符串的名称上允许使用这些方法，则没有逻辑上的理由使其在文字上不可用。"

#: ../../faq/design.rst:215
msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having "
":meth:`~str.split` as a string method, since in that case it is easy to see "
"that ::"
msgstr ""
"第二个异议通常是这样的：“我实际上是在告诉序列使用字符串常量将其成员连接在一起”。遗憾的是并非如此。出于某种原因，把 "
":meth:`~str.split` 作为一个字符串方法似乎要容易得多，因为在这种情况下，很容易看到::"

#: ../../faq/design.rst:220
msgid "\"1, 2, 4, 8, 16\".split(\", \")"
msgstr "\"1, 2, 4, 8, 16\".split(\", \")"

#: ../../faq/design.rst:222
msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr "是对字符串文本的指令，用于返回由给定分隔符分隔的子字符串（或在默认情况下，返回任意空格）。"

#: ../../faq/design.rst:225
msgid ""
":meth:`~str.join` is a string method because in using it you are telling the"
" separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` "
"是字符串方法，因为在使用该方法时，您告诉分隔符字符串去迭代一个字符串序列，并在相邻元素之间插入自身。此方法的参数可以是任何遵循序列规则的对象，包括您自己定义的任何新的类。对于字节和字节数组对象也有类似的方法。"

#: ../../faq/design.rst:233
msgid "How fast are exceptions?"
msgstr "异常有多快？"

#: ../../faq/design.rst:235
msgid ""
"A :keyword:`try`/:keyword:`except` block is extremely efficient if no "
"exceptions are raised.  Actually catching an exception is expensive.  In "
"versions of Python prior to 2.0 it was common to use this idiom::"
msgstr ""
"如果没有引发异常则 :keyword:`try`/:keyword:`except` 代码块是非常高效的。 实际上捕获异常是很消耗性能的。 在 2.0 "
"之前的 Python 版本中通常使用这例程::"

#: ../../faq/design.rst:240
msgid ""
"try:\n"
"    value = mydict[key]\n"
"except KeyError:\n"
"    mydict[key] = getvalue(key)\n"
"    value = mydict[key]"
msgstr ""
"try:\n"
"    value = mydict[key]\n"
"except KeyError:\n"
"    mydict[key] = getvalue(key)\n"
"    value = mydict[key]"

#: ../../faq/design.rst:246
msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr "只有当你期望dict在任何时候都有key时，这才有意义。如果不是这样的话，你就是应该这样编码："

#: ../../faq/design.rst:249
msgid ""
"if key in mydict:\n"
"    value = mydict[key]\n"
"else:\n"
"    value = mydict[key] = getvalue(key)"
msgstr ""
"if key in mydict:\n"
"    value = mydict[key]\n"
"else:\n"
"    value = mydict[key] = getvalue(key)"

#: ../../faq/design.rst:254
msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"对于这种特定的情况，您还可以使用 ``value = dict.setdefault(key, getvalue(key))``，但前提是调用 "
"``getvalue()`` 足够便宜，因为在所有情况下都会对其进行评估。"

#: ../../faq/design.rst:260
msgid "Why isn't there a switch or case statement in Python?"
msgstr "为什么Python中没有switch或case语句？"

#: ../../faq/design.rst:262
msgid ""
"In general, structured switch statements execute one block of code when an "
"expression has a particular value or set of values. Since Python 3.10 one "
"can easily match literal values, or constants within a namespace, with a "
"``match ... case`` statement. An older alternative is a sequence of ``if... "
"elif... elif... else``."
msgstr ""
"总的来说，结构化分支语句会在一个表达式具有特定值或值的集合时执行某个代码块。 从 Python 3.10 开始可以简单地通过 ``match ... "
"case`` 语句来匹配字面值，或特定命名空间中的常量。 一种较旧的替代方案是通过一系列的 ``if... elif... elif... "
"else``。"

#: ../../faq/design.rst:268
msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr "对于需要从大量可能性中进行选择的情况，可以创建一个字典，将case 值映射到要调用的函数。例如："

#: ../../faq/design.rst:272
msgid ""
"functions = {'a': function_1,\n"
"             'b': function_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = functions[value]\n"
"func()"
msgstr ""
"functions = {'a': function_1,\n"
"             'b': function_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = functions[value]\n"
"func()"

#: ../../faq/design.rst:279
msgid ""
"For calling methods on objects, you can simplify yet further by using the "
":func:`getattr` built-in to retrieve methods with a particular name::"
msgstr "对于对象调用方法，可以通过使用 :func:`getattr` 内置检索具有特定名称的方法来进一步简化："

#: ../../faq/design.rst:282
msgid ""
"class MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, value):\n"
"        method_name = 'visit_' + str(value)\n"
"        method = getattr(self, method_name)\n"
"        method()"
msgstr ""
"class MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, value):\n"
"        method_name = 'visit_' + str(value)\n"
"        method = getattr(self, method_name)\n"
"        method()"

#: ../../faq/design.rst:291
msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr "建议对方法名使用前缀，例如本例中的 ``visit_`` 。如果没有这样的前缀，如果值来自不受信任的源，攻击者将能够调用对象上的任何方法。"

#: ../../faq/design.rst:295
msgid ""
"Imitating switch with fallthrough, as with C's switch-case-default, is "
"possible, much harder, and less needed."
msgstr "模仿带有穿透方式的分支，就像 C 的 switch-case-default 那样是有可能的，但更为困难，也无甚必要。"

#: ../../faq/design.rst:300
msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr "难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实现吗？"

#: ../../faq/design.rst:302
msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"答案1： 不幸的是，解释器为每个Python堆栈帧推送至少一个C堆栈帧。此外，扩展可以随时回调Python。因此，一个完整的线程实现需要对C的线程支持。"

#: ../../faq/design.rst:307
msgid ""
"Answer 2: Fortunately, there is `Stackless Python "
"<https://github.com/stackless-dev/stackless/wiki>`_, which has a completely "
"redesigned interpreter loop that avoids the C stack."
msgstr ""
"答案2： 幸运的是， `Stackless Python <https://github.com/stackless-"
"dev/stackless/wiki>`_ 有一个完全重新设计的解释器循环，可以避免C堆栈。"

#: ../../faq/design.rst:312
msgid "Why can't lambda expressions contain statements?"
msgstr "为什么lambda表达式不能包含语句？"

#: ../../faq/design.rst:314
msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Python 的 lambda 表达式不能包含语句，因为Python的语法框架不能处理嵌套在表达式内部的语句。然而，在 Python "
"中，这并不是一个严重的问题。 与其他语言中添加功能的 lambda 形式不同，Python 的 lambda 只是一种速记符号，如果您懒得定义函数的话。"

#: ../../faq/design.rst:320
msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"函数已经是 Python 中的第一等对象，并且可以在局部作用域中声明。 因此使用 lambda 而非局部定义函数的唯一优点是你不需要为函数指定名称 --"
" 但那只是一个被赋值为函数对象（它的类型与 lambda 表达式所产生的对象完全相同）的局部变量！"

#: ../../faq/design.rst:328
msgid "Can Python be compiled to machine code, C or some other language?"
msgstr "可以将Python编译为机器代码，C或其他语言吗？"

#: ../../faq/design.rst:330
msgid ""
"`Cython <https://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <https://nuitka.net/>`_ is "
"an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language."
msgstr ""
"`Cython <https://cython.org/>`_ 会将带有可选标注的修改版 Python 编译为 C 扩展。 `Nuitka "
"<https://nuitka.net/>`_ 是一个 Python 转 C++ 代码的新兴编译器，其目标是支持完整的 Python 语言。"

#: ../../faq/design.rst:337
msgid "How does Python manage memory?"
msgstr "Python如何管理内存？"

#: ../../faq/design.rst:339
msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Python 内存管理的细节取决于实现。 Python 的标准实现 :term:`CPython` "
"使用引用计数来检测不可访问的对象，并使用另一种机制来收集引用循环，定期执行循环检测算法来查找不可访问的循环并删除所涉及的对象。 :mod:`gc` "
"模块提供了执行垃圾回收、获取调试统计信息和优化收集器参数的函数。"

#: ../../faq/design.rst:347
msgid ""
"Other implementations (such as `Jython <https://www.jython.org>`_ or `PyPy "
"<https://pypy.org>`_), however, can rely on a different mechanism such as a "
"full-blown garbage collector.  This difference can cause some subtle porting"
" problems if your Python code depends on the behavior of the reference "
"counting implementation."
msgstr ""
"不过，其他实现 (如 `Jython <https://www.jython.org>`_ 或 `PyPy "
"<https://pypy.org>`_)，可能会依赖不同的机制，如完全的垃圾回收器。 如果你的 Python "
"代码依赖于引用计数实现的行为则这种差异可能会导致某些微妙的移植问题。"

#: ../../faq/design.rst:353
msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr "在一些Python实现中，以下代码（在CPython中工作的很好）可能会耗尽文件描述符::"

#: ../../faq/design.rst:356
msgid ""
"for file in very_long_list_of_files:\n"
"    f = open(file)\n"
"    c = f.read(1)"
msgstr ""
"for file in very_long_list_of_files:\n"
"    f = open(file)\n"
"    c = f.read(1)"

#: ../../faq/design.rst:360
msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to ``f`` closes the previous file.  With a traditional GC, "
"however, those file objects will only get collected (and closed) at varying "
"and possibly long intervals."
msgstr ""
"实际上，使用 CPython 的引用计数或器方案，每次对 ``f`` 的新赋值都会关闭之前的文件。 然而，对于传统的 "
"GC，这些文件对象将只能以不同的并且可能很长的间隔被收集（和关闭）。"

#: ../../faq/design.rst:365
msgid ""
"If you want to write code that will work with any Python implementation, you"
" should explicitly close the file or use the :keyword:`with` statement; this"
" will work regardless of memory management scheme::"
msgstr ""
"如果要编写可用于任何python实现的代码，则应显式关闭该文件或使用  :keyword:`with` 语句；无论内存管理方案如何，这都有效："

#: ../../faq/design.rst:369
msgid ""
"for file in very_long_list_of_files:\n"
"    with open(file) as f:\n"
"        c = f.read(1)"
msgstr ""
"for file in very_long_list_of_files:\n"
"    with open(file) as f:\n"
"        c = f.read(1)"

#: ../../faq/design.rst:375
msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr "为什么CPython不使用更传统的垃圾回收方案？"

#: ../../faq/design.rst:377
msgid ""
"For one thing, this is not a C standard feature and hence it's not portable."
" (Yes, we know about the Boehm GC library.  It has bits of assembler code "
"for *most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"首先，这不是C标准特性，因此不能移植。(是的，我们知道Boehm GC库。它包含了 *大多数* "
"常见平台（但不是所有平台）的汇编代码，尽管它基本上是透明的，但也不是完全透明的; 要让Python使用它，需要使用补丁。)"

#: ../../faq/design.rst:383
msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard ``malloc()`` and ``free()`` with versions provided by the GC "
"library, an application embedding Python may want to have its *own* "
"substitute for ``malloc()`` and ``free()``, and may not want Python's.  "
"Right now, CPython works with anything that implements ``malloc()`` and "
"``free()`` properly."
msgstr ""
"当 Python 嵌入到其他应用程序中时传统的 GC 也会成为一个问题。 在独立的 Python 中可以用 GC 库提供的版本来替换标准的 "
"``malloc()`` 和 ``free()``，而嵌入 Python 的应用程序可能想要 *自行* 替代 ``malloc()`` 和 "
"``free()``，并不想要 Python 的版本。 现在，CPython 可以适用于任何正确实现了 ``malloc()`` 和 "
"``free()`` 的版本。"

#: ../../faq/design.rst:392
msgid "Why isn't all memory freed when CPython exits?"
msgstr "CPython退出时为什么不释放所有内存？"

#: ../../faq/design.rst:394
msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular"
" references.  There are also certain bits of memory that are allocated by "
"the C library that are impossible to free (e.g. a tool like Purify will "
"complain about these).  Python is, however, aggressive about cleaning up "
"memory on exit and does try to destroy every single object."
msgstr ""
"当Python退出时，从全局命名空间或Python模块引用的对象并不总是被释放。 如果存在循环引用，则可能发生这种情况 "
"C库分配的某些内存也是不可能释放的（例如像Purify这样的工具会抱怨这些内容）。 但是，Python在退出时清理内存并尝试销毁每个对象。"

#: ../../faq/design.rst:401
msgid ""
"If you want to force Python to delete certain things on deallocation use the"
" :mod:`atexit` module to run a function that will force those deletions."
msgstr "如果要强制 Python 在释放时删除某些内容，请使用 :mod:`atexit` 模块运行一个函数，强制删除这些内容。"

#: ../../faq/design.rst:406
msgid "Why are there separate tuple and list data types?"
msgstr "为什么有单独的元组和列表数据类型？"

#: ../../faq/design.rst:408
msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal ``records`` or C ``structs``; they're small collections of related "
"data which may be of different types which are operated on as a group.  For "
"example, a Cartesian coordinate is appropriately represented as a tuple of "
"two or three numbers."
msgstr ""
"列表和元组虽然在许多方式都很相似，但它们的使用方式有本质上的不同。 元组可被当作是类似于 Pascal ``records`` 或 C "
"``structs``；它们是由可能具有不同类型但可作为一个分组进行操作的相关数据组成的小多项集。 "
"例如，一个笛卡尔坐标可适当地用由两个或三个数字组成的元组来表示。"

#: ../../faq/design.rst:415
msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and"
" which are operated on one-by-one.  For example, :func:`os.listdir('.') "
"<os.listdir>` returns a list of strings representing the files in the "
"current directory.  Functions which operate on this output would generally "
"not break if you added another file or two to the directory."
msgstr ""
"另一方面，列表更像其他语言中的数组。 它们倾向于保存可变数量的全都具有相同类型并将被逐个操作的对象。 例如，:func:`os.listdir('.')"
" <os.listdir>` 返回一个代表当前目录中文件的字符串列表。 当你向该目录添加一两个文件时在此输出上执行操作的函数通常不会中断。"

#: ../../faq/design.rst:423
msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"元组是不可变的，这意味着一旦创建了元组，就不能用新值替换它的任何元素。列表是可变的，这意味着您始终可以更改列表的元素。只有不变元素可以用作字典的key，因此只能将元组和非列表用作key。"

#: ../../faq/design.rst:430
msgid "How are lists implemented in CPython?"
msgstr "列表是如何在CPython中实现的？"

#: ../../faq/design.rst:432
msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"CPython的列表实际上是可变长度的数组，而不是lisp风格的链表。该实现使用对其他对象的引用的连续数组，并在列表头结构中保留指向该数组和数组长度的指针。"

#: ../../faq/design.rst:436
msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr "这使得索引列表 ``a[i]`` 的操作成本与列表的大小或索引的值无关。"

#: ../../faq/design.rst:439
msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"当添加或插入项时，将调整引用数组的大小。并采用了一些巧妙的方法来提高重复添加项的性能; "
"当数组必须增长时，会分配一些额外的空间，以便在接下来的几次中不需要实际调整大小。"

#: ../../faq/design.rst:446
msgid "How are dictionaries implemented in CPython?"
msgstr "字典是如何在CPython中实现的？"

#: ../../faq/design.rst:448
msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr "CPython的字典实现为可调整大小的哈希表。与B-树相比，这在大多数情况下为查找（目前最常见的操作）提供了更好的性能，并且实现更简单。"

#: ../../faq/design.rst:452
msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, "
"``'Python'`` could hash to ``-539294296`` while ``'python'``, a string that "
"differs by a single bit, could hash to ``1142331976``.  The hash code is "
"then used to calculate a location in an internal array where the value will "
"be stored.  Assuming that you're storing keys that all have different hash "
"values, this means that dictionaries take constant time -- *O*\\ (1), in "
"Big-O notation -- to retrieve a key."
msgstr ""
"字典的工作方式是使用 :func:`hash` 内置函数计算字典中存储的每个键的哈希码。 "
"哈希码会根据键和基于进程的种子值而大幅改变；例如，``'Python'`` 的哈希码可能为 ``-539294296`` 而 ``'python'`` "
"这个只相差一丁点的字符串的哈希码却可能为 ``1142331976``。 随后哈希码将被用来计算在一个内部数组中相应值的存储位置。 "
"假设你存储的键都具有不同的哈希值，这意味着字典会耗费恒定的时间 -- 即大 O 表示法的 *O*\\ (1) -- 要检索一个键。"

#: ../../faq/design.rst:463
msgid "Why must dictionary keys be immutable?"
msgstr "为什么字典key必须是不可变的？"

#: ../../faq/design.rst:465
msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"字典的哈希表实现使用从键值计算的哈希值来查找键。如果键是可变对象，则其值可能会发生变化，因此其哈希值也会发生变化。但是，由于无论谁更改键对象都无法判断它是否被用作字典键值，因此无法在字典中修改条目。然后，当你尝试在字典中查找相同的对象时，将无法找到它，因为其哈希值不同。如果你尝试查找旧值，也不会找到它，因为在该哈希表中找到的对象的值会有所不同。"

#: ../../faq/design.rst:474
msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries"
" as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"如果你想要一个用列表索引的字典，只需先将列表转换为元组；用函数 ``tuple(L)`` 创建一个元组，其条目与列表 ``L`` 相同。 "
"元组是不可变的，因此可以用作字典键。"

#: ../../faq/design.rst:478
msgid "Some unacceptable solutions that have been proposed:"
msgstr "已经提出的一些不可接受的解决方案："

#: ../../faq/design.rst:480
msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr "哈希按其地址（对象ID）列出。这不起作用，因为如果你构造一个具有相同值的新列表，它将无法找到；例如::"

#: ../../faq/design.rst:483
msgid ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"
msgstr ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"

#: ../../faq/design.rst:486
msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using "
":keyword:`is`."
msgstr ""
"会引发一个 :exc:`KeyError` 异常，因为第二行中使用的 ``[1, 2]`` 的 id 与第一行中的 id 不同。换句话说，应该使用 "
"``==`` 来比较字典键，而不是使用 :keyword:`is` 。"

#: ../../faq/design.rst:490
msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list,"
" being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr "使用列表作为键时进行复制。这没有用的，因为作为可变对象的列表可以包含对自身的引用，然后复制代码将进入无限循环。"

#: ../../faq/design.rst:494
msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list"
" by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"允许列表作为键，但告诉用户不要修改它们。当你意外忘记或修改列表时，这将产生程序中的一类难以跟踪的错误。它还使一个重要的字典不变量无效： "
"``d.keys()`` 中的每个值都可用作字典的键。"

#: ../../faq/design.rst:499
msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem"
" is that it's not just the top-level object that could change its value; you"
" could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"将列表用作字典键后，应标记为其只读。问题是，它不仅仅是可以改变其值的顶级对象；你可以使用包含列表作为键的元组。将任何内容作为键关联到字典中都需要将从那里可到达的所有对象标记为只读"
" —— 并且自引用对象可能会导致无限循环。"

#: ../../faq/design.rst:505
msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`~object.__eq__` and a :meth:`~object.__hash__` method. You "
"must then make sure that the hash value for all such wrapper objects that "
"reside in a dictionary (or other hash based structure), remain fixed while "
"the object is in the dictionary (or other structure). ::"
msgstr ""
"如果你有需要，以下技巧可以绕过这个问题，但使用它必须自担风险：你可以将一个可变结构体包装在一个同时具有 :meth:`~object.__eq__` 和"
" :meth:`~object.__hash__` 方法的类实例中。 "
"然后你必须确保存放在字典（或其他基于哈希值的结构体）中的所有此类包装器对象的哈希值在该字典（或其他结构体）中保持固定。 ::"

#: ../../faq/design.rst:513
msgid ""
"class ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        result = 98767 - len(l)*555\n"
"        for i, el in enumerate(l):\n"
"            try:\n"
"                result = result + (hash(el) % 9999999) * 1001 + i\n"
"            except Exception:\n"
"                result = (result % 7777777) + i * 333\n"
"        return result"
msgstr ""
"class ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        result = 98767 - len(l)*555\n"
"        for i, el in enumerate(l):\n"
"            try:\n"
"                result = result + (hash(el) % 9999999) * 1001 + i\n"
"            except Exception:\n"
"                result = (result % 7777777) + i * 333\n"
"        return result"

#: ../../faq/design.rst:530
msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr "注意，哈希计算由于列表的某些成员可能不可用以及算术溢出的可能性而变得复杂。"

#: ../../faq/design.rst:534
msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie "
"``o1.__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, "
"``o1.__hash__() == o2.__hash__()``), regardless of whether the object is in "
"a dictionary or not.  If you fail to meet these restrictions dictionaries "
"and other hash based structures will misbehave."
msgstr ""
"此外，必须始终如此，如果 ``o1 == o2`` （即 ``o1.__eq__(o2) is True`` ）则 ``hash(o1) == "
"hash(o2)`` （即 ``o1.__hash__() == o2.__hash__()`` ），无论对象是否在字典中。 "
"如果你不能满足这些限制，字典和其他基于 hash 的结构将会出错。"

#: ../../faq/design.rst:539
msgid ""
"In the case of :class:`!ListWrapper`, whenever the wrapper object is in a "
"dictionary the wrapped list must not change to avoid anomalies.  Don't do "
"this unless you are prepared to think hard about the requirements and the "
"consequences of not meeting them correctly.  Consider yourself warned."
msgstr ""
"对于 :class:`!ListWrapper` 的情况，只要包装器位于字典中那么被包装的列表就不能更改以避免发生意外。 "
"除非你准备好认真考虑相关要求以及未能正确满足这些要求的后果否则请不要这样做。 你已经收到警告了。"

#: ../../faq/design.rst:546
msgid "Why doesn't list.sort() return the sorted list?"
msgstr "为什么 list.sort() 没有返回排序列表？"

#: ../../faq/design.rst:548
msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"在性能很重要的情况下，仅仅为了排序而复制一份列表将是一种浪费。因此， :meth:`list.sort` "
"对列表进行了适当的排序。为了提醒您这一事实，它不会返回已排序的列表。这样，当您需要排序的副本，但也需要保留未排序的版本时，就不会意外地覆盖列表。"

#: ../../faq/design.rst:554
msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"如果要返回新列表，请使用内置 :func:`sorted` "
"函数。此函数从提供的可迭代列表中创建新列表，对其进行排序并返回。例如，下面是如何迭代遍历字典并按keys排序::"

#: ../../faq/design.rst:559
msgid ""
"for key in sorted(mydict):\n"
"    ...  # do whatever with mydict[key]..."
msgstr ""
"for key in sorted(mydict):\n"
"    ...  # 对 mydict[key] 做点什么"

#: ../../faq/design.rst:564
msgid "How do you specify and enforce an interface spec in Python?"
msgstr "如何在Python中指定和实施接口规范？"

#: ../../faq/design.rst:566
msgid ""
"An interface specification for a module as provided by languages such as C++"
" and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications"
" helps in the construction of large programs."
msgstr "由C++和Java等语言提供的模块接口规范描述了模块的方法和函数的原型。许多人认为接口规范的编译时强制执行有助于构建大型程序。"

#: ../../faq/design.rst:571
msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The "
":mod:`collections.abc` module defines a set of useful ABCs such as "
":class:`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and"
" :class:`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6添加了一个 :mod:`abc` 模块，允许定义抽象基类 (ABCs)。然后可以使用 :func:`isinstance` 和 "
":func:`issubclass` 来检查实例或类是否实现了特定的ABC。 :mod:`collections.abc` 模块定义了一组有用的ABCs"
" 例如 :class:`~collections.abc.Iterable` ， :class:`~collections.abc.Container`"
" , 和 :class:`~collections.abc.MutableMapping`"

#: ../../faq/design.rst:578
msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr "对于 Python，接口规范的许多好处可以通过组件的适当测试规程来获得。"

#: ../../faq/design.rst:581
msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The "
":mod:`doctest` and :mod:`unittest` modules or third-party test frameworks "
"can be used to construct exhaustive test suites that exercise every line of "
"code in a module."
msgstr ""
"一个好的模块测试套件既可以提供回归测试，也可以作为模块接口规范和一组示例。许多Python模块可以作为脚本运行，以提供简单的“自我测试”。即使是使用复杂外部接口的模块，也常常可以使用外部接口的简单“桩代码（stub）”模拟进行隔离测试。可以使用"
" :mod:`doctest` 和 :mod:`unittest` 模块或第三方测试框架来构造详尽的测试套件，以运行模块中的每一行代码。"

#: ../../faq/design.rst:589
msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can"
" be better because an interface specification cannot test certain properties"
" of a program.  For example, the :meth:`!list.append` method is expected to "
"add new elements to the end of some internal list; an interface "
"specification cannot test that your :meth:`!list.append` implementation will"
" actually do this correctly, but it's trivial to check this property in a "
"test suite."
msgstr ""
"适当的测试规程能像完善的接口规范一样帮助在 Python 构建大型的复杂应用程序。 事实上，它能做得更好因为接口规范无法测试程序的某些属性。 "
"例如，:meth:`!list.append` 方法被期望向某个内部列表的末尾添加新元素；接口规范无法测试你的 :meth:`!list.append`"
" 实现是否真的能正确执行该操作，但在测试套件中检查该属性却是很容易的。"

#: ../../faq/design.rst:597
msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"编写测试套件非常有用，并且你可能希望将你的代码设计为易于测试。 "
"一种日益流行的技术是面向测试的开发，它要求在编写任何实际代码之前首先编写测试套件的各个部分。 当然 Python "
"也允许你采用更粗率的方式，不必编写任何测试用例。"

#: ../../faq/design.rst:605
msgid "Why is there no goto?"
msgstr "为什么没有goto？"

#: ../../faq/design.rst:607
msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with :keyword:`if` statements and :keyword:`or`, :keyword:`and`, and"
" :keyword:`if`/:keyword:`else` expressions) and loop (with :keyword:`while` "
"and :keyword:`for` statements, possibly containing :keyword:`continue` and "
":keyword:`break`)."
msgstr ""
"在 1970 年代人们了解到不受限制的 goto 可能导致混乱得像“意大利面”那样难以理解和修改的代码。 "
"在高级语言中，它也是不必要的，只需能够执行分支（在 Python 中是使用 :keyword:`if` 语句和 :keyword:`or`, "
":keyword:`and` 以及 :keyword:`if`/:keyword:`else` 表达式）和循环（使用 :keyword:`while` "
"和 :keyword:`for` 语句，还可能包含 :keyword:`continue` 和 :keyword:`break` 语句）就足够了。"

#: ../../faq/design.rst:614
msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even"
" across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the ``go`` or ``goto`` constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"人们还可以使用异常来提供甚至能跨函数调用的“结构化 goto”。 许多人觉得异常可以方便地模拟 C, Fortran 和其他语言中所有合理使用的 "
"``go`` 或 ``goto`` 结构::"

#: ../../faq/design.rst:620
msgid ""
"class label(Exception): pass  # declare a label\n"
"\n"
"try:\n"
"    ...\n"
"    if condition: raise label()  # goto label\n"
"    ...\n"
"except label:  # where to goto\n"
"    pass\n"
"..."
msgstr ""
"class label(Exception): pass  # 声明label\n"
"\n"
"try:\n"
"    ...\n"
"    if condition: raise label()  # 跳转到 label\n"
"    ...\n"
"except label:  # 跳转到哪里\n"
"    pass\n"
"..."

#: ../../faq/design.rst:630
msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually"
" considered an abuse of ``goto`` anyway.  Use sparingly."
msgstr "这并不允许跳到一个循环的中间，但这通常被视为是对 ``goto`` 的滥用。 应当谨慎使用。"

#: ../../faq/design.rst:635
msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr "为什么原始字符串（r-strings）不能以反斜杠结尾？"

#: ../../faq/design.rst:637
msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr "更准确地说，它们不能以奇数个反斜杠结束：结尾处的不成对反斜杠会转义结束引号字符，留下未结束的字符串。"

#: ../../faq/design.rst:641
msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to"
" pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"原始字符串的设计是为了方便想要执行自己的反斜杠转义处理的处理器(主要是正则表达式引擎)创建输入。此类处理器将不匹配的尾随反斜杠视为错误，因此原始字符串不允许这样做。反过来，允许通过使用引号字符转义反斜杠转义字符串。当r-"
"string用于它们的预期目的时，这些规则工作的很好。"

#: ../../faq/design.rst:648
msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr "如果您正在尝试构建Windows路径名，请注意所有Windows系统调用都使用正斜杠::"

#: ../../faq/design.rst:651
msgid "f = open(\"/mydir/file.txt\")  # works fine!"
msgstr "f = open(\"/mydir/file.txt\")  # 效果很好！"

#: ../../faq/design.rst:653
msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr "如果您正在尝试为DOS命令构建路径名，请尝试以下示例 ::"

#: ../../faq/design.rst:655
msgid ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\""
msgstr ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\""

#: ../../faq/design.rst:661
msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr "为什么Python没有属性赋值的“with”语句？"

#: ../../faq/design.rst:663
msgid ""
"Python has a :keyword:`with` statement that wraps the execution of a block, "
"calling code on the entrance and exit from the block.  Some languages have a"
" construct that looks like this::"
msgstr ""
"Python 有一种 :keyword:`with` 语句能将一个代码块的执行包装起来，在进入和退出该代码块时调用特定的代码。 "
"某些语言具有类似这样的结构::"

#: ../../faq/design.rst:667
msgid ""
"with obj:\n"
"    a = 1               # equivalent to obj.a = 1\n"
"    total = total + 1   # obj.total = obj.total + 1"
msgstr ""
"with obj:\n"
"    a = 1               # 相当于 to obj.a = 1\n"
"    total = total + 1   # obj.total = obj.total + 1"

#: ../../faq/design.rst:671
msgid "In Python, such a construct would be ambiguous."
msgstr "在Python中，这样的结构是不明确的。"

#: ../../faq/design.rst:673
msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"其他语言，如ObjectPascal、Delphi和C++ 使用静态类型，因此可以毫不含糊地知道分配给什么成员。这是静态类型的要点 -- 编译器 "
"*总是* 在编译时知道每个变量的作用域。"

#: ../../faq/design.rst:678
msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python使用动态类型。事先不可能知道在运行时引用哪个属性。可以动态地在对象中添加或删除成员属性。这使得无法通过简单的阅读就知道引用的是什么属性：局部属性、全局属性还是成员属性？"

#: ../../faq/design.rst:684
msgid "For instance, take the following incomplete snippet::"
msgstr "例如，采用以下不完整的代码段::"

#: ../../faq/design.rst:686
msgid ""
"def foo(a):\n"
"    with a:\n"
"        print(x)"
msgstr ""
"def foo(a):\n"
"    with a:\n"
"        print(x)"

#: ../../faq/design.rst:690
msgid ""
"The snippet assumes that ``a`` must have a member attribute called ``x``. "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if ``a`` is, let us say, an integer?  If there is a global "
"variable named ``x``, will it be used inside the :keyword:`with` block?  As "
"you see, the dynamic nature of Python makes such choices much harder."
msgstr ""
"该代码段假设 ``a`` 必须有一个名为 ``x`` 的成员属性。 然而，Python 中没有什么能告诉解释器这一点。 举例来说，如果 ``a`` "
"是一个整数那么会发生什么？ 如果有一个名为 ``x`` 的全局变量，它是否会在 :keyword:`with` 代码块内被使用？ 如你所见，Python"
" 的动态特性使得这样的选择更为困难。"

#: ../../faq/design.rst:696
msgid ""
"The primary benefit of :keyword:`with` and similar language features "
"(reduction of code volume) can, however, easily be achieved in Python by "
"assignment.  Instead of::"
msgstr "然而，:keyword:`with` 及类似语言特性的主要好处（减少代码量）在 Python 中可以通过赋值轻松地实现。 而不是使用::"

#: ../../faq/design.rst:699
msgid ""
"function(args).mydict[index][index].a = 21\n"
"function(args).mydict[index][index].b = 42\n"
"function(args).mydict[index][index].c = 63"
msgstr ""
"function(args).mydict[index][index].a = 21\n"
"function(args).mydict[index][index].b = 42\n"
"function(args).mydict[index][index].c = 63"

#: ../../faq/design.rst:703
msgid "write this::"
msgstr "写成这样::"

#: ../../faq/design.rst:705
msgid ""
"ref = function(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"
msgstr ""
"ref = function(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"

#: ../../faq/design.rst:710
msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr "这也具有提高执行速度的附带效果，因为 Python 在运行时解析名称绑定，而第二个版本只需要执行一次解析。"

#: ../../faq/design.rst:714
msgid ""
"Similar proposals that would introduce syntax to further reduce code volume,"
" such as using a 'leading dot', have been rejected in favour of explicitness"
" (see https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)."
msgstr ""
"引入可以进一步减小代码量的类似提议，例如使用“前导点号”，出于明白胜于隐晦的理由而被拒绝了 (参见 "
"https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)。"

#: ../../faq/design.rst:720
msgid "Why don't generators support the with statement?"
msgstr "生成器为什么不支持 with 语句？"

#: ../../faq/design.rst:722
msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as "
":func:`contextlib.closing(generator) <contextlib.closing>` in the "
":keyword:`with` statement."
msgstr ""
"由于技术原因，直接作为上下文管理器使用的生成器将无法正常工作。 最常见的情况下，当一个生成器被用作迭代器运行到完成时，不需要手动关闭。 如果需要，请在 "
":keyword:`with` 语句中将它包装为 :func:`contextlib.closing(generator) "
"<contextlib.closing>`。"

#: ../../faq/design.rst:730
msgid "Why are colons required for the if/while/def/class statements?"
msgstr "为什么 if/while/def/class语句需要冒号？"

#: ../../faq/design.rst:732
msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr "冒号主要用于增强可读性(ABC语言实验的结果之一)。考虑一下这个::"

#: ../../faq/design.rst:735
msgid ""
"if a == b\n"
"    print(a)"
msgstr ""
"if a == b\n"
"    print(a)"

#: ../../faq/design.rst:738
msgid "versus ::"
msgstr "与 ::"

#: ../../faq/design.rst:740
msgid ""
"if a == b:\n"
"    print(a)"
msgstr ""
"if a == b:\n"
"    print(a)"

#: ../../faq/design.rst:743
msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr "注意第二种方法稍微容易一些。请进一步注意，在这个FAQ解答的示例中，冒号是如何设置的；这是英语中的标准用法。"

#: ../../faq/design.rst:746
msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr "另一个次要原因是冒号使带有语法突出显示的编辑器更容易工作；他们可以寻找冒号来决定何时需要增加缩进，而不必对程序文本进行更精细的解析。"

#: ../../faq/design.rst:752
msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "为什么Python在列表和元组的末尾允许使用逗号？"

#: ../../faq/design.rst:754
msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr "Python 允许您在列表，元组和字典的末尾添加一个尾随逗号::"

#: ../../faq/design.rst:757
msgid ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\": [1, 5],\n"
"    \"B\": [6, 7],  # last trailing comma is optional but good style\n"
"}"
msgstr ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\":[1, 5],\n"
"    \"B\":[6, 7], # 最后的逗号是可选的，但风格很好\n"
"}"

#: ../../faq/design.rst:765
msgid "There are several reasons to allow this."
msgstr "有几个理由允许这样做。"

#: ../../faq/design.rst:767
msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across"
" multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr "如果列表，元组或字典的字面值分布在多行中，则更容易添加更多元素，因为不必记住在上一行中添加逗号。这些行也可以重新排序，而不会产生语法错误。"

#: ../../faq/design.rst:772
msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr "不小心省略逗号会导致难以诊断的错误。例如::"

#: ../../faq/design.rst:775
msgid ""
"x = [\n"
"  \"fee\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"
msgstr ""
"x = [\n"
"  \"fee\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"

#: ../../faq/design.rst:782
msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source"
" of error."
msgstr "这个列表看起来有四个元素，但实际上包含三个 : \"fee\", \"fiefoo\" 和 \"fum\" 。总是加上逗号可以避免这个错误的来源。"

#: ../../faq/design.rst:785
msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr "允许尾随逗号也可以使编程代码更容易生成。"
