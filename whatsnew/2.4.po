# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-15 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.4.rst:3
msgid "What's New in Python 2.4"
msgstr "Python 2.4 有什么新变化"

#: ../../whatsnew/2.4.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.4.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.4.rst:14
msgid ""
"This article explains the new features in Python 2.4.1, released on March "
"30, 2005."
msgstr "本文介绍了2005年3月30日发布的 Python 2.4.1 的新功能。"

#: ../../whatsnew/2.4.rst:17
msgid ""
"Python 2.4 is a medium-sized release.  It doesn't introduce as many changes "
"as the radical Python 2.2, but introduces more features than the "
"conservative 2.3 release.  The most significant new language features are "
"function decorators and generator expressions; most other changes are to the"
" standard library."
msgstr ""
"Python 2.4 是一个中等规模的发布版。 它引入的变化没有激进的 Python 2.2 那么多，但比保守的 2.3 发布版引入了更多的特性。 "
"最主要的新语言特性是函数装饰器和生成器表达式；其他大部分改动都是针对标准库。"

#: ../../whatsnew/2.4.rst:22
msgid ""
"According to the CVS change logs, there were 481 patches applied and 502 "
"bugs fixed between Python 2.3 and 2.4.  Both figures are likely to be "
"underestimates."
msgstr ""
"根据 CVS 变更日志，Python 2.3 和 2.4 之间共应用了 481 个补丁并修复了 502 个错误。 这两个数字可能都被低估了。"

#: ../../whatsnew/2.4.rst:25
msgid ""
"This article doesn't attempt to provide a complete specification of every "
"single new feature, but instead provides a brief introduction to each "
"feature.  For full details, you should refer to the documentation for Python"
" 2.4, such as the Python Library Reference and the Python Reference Manual."
"  Often you will be referred to the PEP for a particular new feature for "
"explanations of the implementation and design rationale."
msgstr ""
"本文并不试图提供每一个新特性的完整规范说明，而是对每个特性进行简要的介绍。 要了解完整细节，你应该参考 Python 2.4 的文档，如 Python "
"库参考和 Python 参考手册等。 通常你需要参阅特定新特性的 PEP 以了解有关具体实现和设计原理的说明。"

#: ../../whatsnew/2.4.rst:36
msgid "PEP 218: Built-In Set Objects"
msgstr "PEP 218: 内置集合对象"

#: ../../whatsnew/2.4.rst:38
msgid ""
"Python 2.3 introduced the :mod:`sets` module.  C implementations of set data"
" types have now been added to the Python core as two new built-in types, "
"``set(iterable)`` and ``frozenset(iterable)``.  They provide high speed "
"operations for membership testing, for eliminating duplicates from "
"sequences, and for mathematical operations like unions, intersections, "
"differences, and symmetric differences. ::"
msgstr ""
"Python 2.3 引入了 :mod:`sets` 模块。 现在集合数据类型的 C 语言实现作为两个新的内置类型 ``set(iterable)`` "
"和 ``frozenset(iterable)`` 被添加到 Python 内核中。 "
"它们为成员测试、消除序列中的重复数据以及并集、交集、差集和对称差集等数学运算提供了高速操作。 ::"

#: ../../whatsnew/2.4.rst:45
msgid ""
">>> a = set('abracadabra')              # form a set from a string\n"
">>> 'z' in a                            # fast membership testing\n"
"False\n"
">>> a                                   # unique letters in a\n"
"set(['a', 'r', 'b', 'c', 'd'])\n"
">>> ''.join(a)                          # convert back into a string\n"
"'arbcd'\n"
"\n"
">>> b = set('alacazam')                 # form a second set\n"
">>> a - b                               # letters in a but not in b\n"
"set(['r', 'd', 'b'])\n"
">>> a | b                               # letters in either a or b\n"
"set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])\n"
">>> a & b                               # letters in both a and b\n"
"set(['a', 'c'])\n"
">>> a ^ b                               # letters in a or b but not both\n"
"set(['r', 'd', 'b', 'm', 'z', 'l'])\n"
"\n"
">>> a.add('z')                          # add a new element\n"
">>> a.update('wxy')                     # add multiple new elements\n"
">>> a\n"
"set(['a', 'c', 'b', 'd', 'r', 'w', 'y', 'x', 'z'])\n"
">>> a.remove('x')                       # take one element out\n"
">>> a\n"
"set(['a', 'c', 'b', 'd', 'r', 'w', 'y', 'z'])"
msgstr ""
">>> a = set('abracadabra')              # 从字符串形成集合\n"
">>> 'z' in a                            # 快速成员测试\n"
"False\n"
">>> a                                   # a中的唯一字母\n"
"set(['a', 'r', 'b', 'c', 'd'])\n"
">>> ''.join(a)                          # 转换回字符串\n"
"'arbcd'\n"
"\n"
">>> b = set('alacazam')                 # 形成第二个集合\n"
">>> a - b                               # 在a中但不在b中的字母\n"
"set(['r', 'd', 'b'])\n"
">>> a | b                               # 在a或b中的字母\n"
"set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])\n"
">>> a & b                               # 在a和b中的字母\n"
"set(['a', 'c'])\n"
">>> a ^ b                               # 在a或b中但不在两者中的字母\n"
"set(['r', 'd', 'b', 'm', 'z', 'l'])\n"
"\n"
">>> a.add('z')                          # 添加新元素\n"
">>> a.update('wxy')                     # 添加多个新元素\n"
">>> a\n"
"set(['a', 'c', 'b', 'd', 'r', 'w', 'y', 'x', 'z'])\n"
">>> a.remove('x')                       # 移除一个元素\n"
">>> a\n"
"set(['a', 'c', 'b', 'd', 'r', 'w', 'y', 'z'])"

#: ../../whatsnew/2.4.rst:71
msgid ""
"The :func:`frozenset` type is an immutable version of :func:`set`. Since it "
"is immutable and hashable, it may be used as a dictionary key or as a member"
" of another set."
msgstr ""
":func:`frozenset` 类型是 :func:`set` 的不可变版本。 "
"由于它是不可变且不可哈希的对象，因而可被用作字典的键或另一个集合的成员。"

#: ../../whatsnew/2.4.rst:75
msgid ""
"The :mod:`sets` module remains in the standard library, and may be useful if"
" you wish to subclass the :class:`Set` or :class:`ImmutableSet` classes.  "
"There are currently no plans to deprecate the module."
msgstr ""
":mod:`sets` 模块仍被保留在标准库中，如果你想要子类化 :class:`Set` 或 :class:`ImmutableSet` "
"类时会很有用处。 目前还没有弃用该模块的计划。"

#: ../../whatsnew/2.4.rst:82
msgid ":pep:`218` - Adding a Built-In Set Object Type"
msgstr ":pep:`218` - 添加内置Set对象类型"

#: ../../whatsnew/2.4.rst:83
msgid ""
"Originally proposed by Greg Wilson and ultimately implemented by Raymond "
"Hettinger."
msgstr "最初由 Greg Wilson 提出，由 Raymond Hettinger 最终实现。"

#: ../../whatsnew/2.4.rst:90
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: 统一长整数和整数"

#: ../../whatsnew/2.4.rst:92
msgid ""
"The lengthy transition process for this PEP, begun in Python 2.2, takes "
"another step forward in Python 2.4.  In 2.3, certain integer operations that"
" would behave differently after int/long unification triggered "
":exc:`FutureWarning` warnings and returned values limited to 32 or 64 bits "
"(depending on your platform).  In 2.4, these expressions no longer produce a"
" warning and instead produce a different result that's usually a long "
"integer."
msgstr ""
"这个PEP的漫长过渡过程始于Python 2.2，在Python "
"2.4中又向前迈出了一步。在2.3中，某些在int/long统一后行为不同的整数操作会触发 :exc:`FutureWarning` "
"警告，并返回限于32位或64位（取决于您的平台）的值。在2.4中，这些表达式不再产生警告，而是产生一个通常为长整数的不同结果。"

#: ../../whatsnew/2.4.rst:99
msgid ""
"The problematic expressions are primarily left shifts and lengthy "
"hexadecimal and octal constants.  For example, ``2 << 32`` results in a "
"warning in 2.3, evaluating to 0 on 32-bit platforms.  In Python 2.4, this "
"expression now returns the correct answer, 8589934592."
msgstr ""
"问题表达式主要是左移和长十六进制和八进制常量。例如，``2 << 32`` 在2.3中会引发警告，在32位平台上评估为0。在Python "
"2.4中，这个表达式现在返回正确答案，8589934592。"

#: ../../whatsnew/2.4.rst:107
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - 统一长整数和整数"

#: ../../whatsnew/2.4.rst:108
msgid ""
"Original PEP written by Moshe Zadka and GvR.  The changes for 2.4 were "
"implemented by  Kalle Svensson."
msgstr "原始PEP由 Moshe Zadka 和 GvR 撰写，2.4 的变更由 Kalle Svensson 实现。"

#: ../../whatsnew/2.4.rst:115
msgid "PEP 289: Generator Expressions"
msgstr "PEP 289: 生成器表达式"

#: ../../whatsnew/2.4.rst:117
msgid ""
"The iterator feature introduced in Python 2.2 and the :mod:`itertools` "
"module make it easier to write programs that loop through large data sets "
"without having the entire data set in memory at one time.  List "
"comprehensions don't fit into this picture very well because they produce a "
"Python list object containing all of the items.  This unavoidably pulls all "
"of the objects into memory, which can be a problem if your data set is very "
"large.  When trying to write a functionally styled program, it would be "
"natural to write something like::"
msgstr ""
"Python 2.2中引入的迭代器特性和 :mod:`itertools` "
"模块使得编写循环遍历大数据集的程序变得更加容易，而无需将整个数据集一次性加载到内存中。列表推导式并不很适合这种场景，因为它们会产生一个包含所有项的Python列表对象。这不可避免地将所有对象拉入内存，如果数据集非常大，这可能会成为问题。当尝试编写函数式风格的程序时，自然会写出类似以下代码："

#: ../../whatsnew/2.4.rst:125
msgid ""
"links = [link for link in get_all_links() if not link.followed]\n"
"for link in links:\n"
"    ..."
msgstr ""
"links = [link for link in get_all_links() if not link.followed]\n"
"for link in links:\n"
"    ..."

#: ../../whatsnew/2.4.rst:129
msgid "instead of  ::"
msgstr "代替："

#: ../../whatsnew/2.4.rst:131
msgid ""
"for link in get_all_links():\n"
"    if link.followed:\n"
"        continue\n"
"    ..."
msgstr ""
"for link in get_all_links():\n"
"    if link.followed:\n"
"        continue\n"
"    ..."

#: ../../whatsnew/2.4.rst:136
msgid ""
"The first form is more concise and perhaps more readable, but if you're "
"dealing with a large number of link objects you'd have to write the second "
"form to avoid having all link objects in memory at the same time."
msgstr "第一种形式更简洁，可能也更易读，但如果你正在处理大量的链接对象，为了避免同时将所有链接对象加载到内存中，你将不得不编写第二种形式。"

#: ../../whatsnew/2.4.rst:140
msgid ""
"Generator expressions work similarly to list comprehensions but don't "
"materialize the entire list; instead they create a generator that will "
"return elements one by one.  The above example could be written as::"
msgstr "生成器表达式的工作方式类似于列表推导式，但不生成整个列表；相反，它们创建一个生成器，逐个返回元素。上述示例可以改写为："

#: ../../whatsnew/2.4.rst:144
msgid ""
"links = (link for link in get_all_links() if not link.followed)\n"
"for link in links:\n"
"    ..."
msgstr ""
"links = (link for link in get_all_links() if not link.followed)\n"
"for link in links:\n"
"    ..."

#: ../../whatsnew/2.4.rst:148
msgid ""
"Generator expressions always have to be written inside parentheses, as in "
"the above example.  The parentheses signalling a function call also count, "
"so if you want to create an iterator that will be immediately passed to a "
"function you could write::"
msgstr "生成器表达式必须像上述示例那样写在括号内。函数调用所用的括号也算在内，因此如果你想要创建一个将立即传递给函数的迭代器，可以写成："

#: ../../whatsnew/2.4.rst:153
msgid "print sum(obj.count for obj in list_all_objects())"
msgstr "print sum(obj.count for obj in list_all_objects())"

#: ../../whatsnew/2.4.rst:155
msgid ""
"Generator expressions differ from list comprehensions in various small ways."
" Most notably, the loop variable (*obj* in the above example) is not "
"accessible outside of the generator expression.  List comprehensions leave "
"the variable assigned to its last value; future versions of Python will "
"change this, making list comprehensions match generator expressions in this "
"respect."
msgstr ""
"生成器表达式与列表推导式在各方面有细微的不同。最显著的是，循环变量（上述示例中的*obj*）在生成器表达式外部是不可访问的。列表推导式会将变量赋值为最后一个值；Python的未来版本将改变这一点，使列表推导式在这方面与生成器表达式一致。"

#: ../../whatsnew/2.4.rst:164
msgid ":pep:`289` - Generator Expressions"
msgstr ":pep:`289` - 生成器表达式"

#: ../../whatsnew/2.4.rst:165
msgid ""
"Proposed by Raymond Hettinger and implemented by Jiwon Seo with early "
"efforts steered by Hye-Shik Chang."
msgstr "由Raymond Hettinger提出，Jiwon Seo实现，Hye-Shik Chang在早期进行了指导。"

#: ../../whatsnew/2.4.rst:172
msgid "PEP 292: Simpler String Substitutions"
msgstr "PEP 292: 更简单的字符串替换"

#: ../../whatsnew/2.4.rst:174
msgid ""
"Some new classes in the standard library provide an alternative mechanism "
"for substituting variables into strings; this style of substitution may be "
"better for applications where untrained users need to edit templates."
msgstr "标准库中的一些新类提供了将变量替换到字符串中的替代机制；这种替换风格可能更适合那些未经训练的用户需要编辑模板的应用程序。"

#: ../../whatsnew/2.4.rst:178
msgid ""
"The usual way of substituting variables by name is the ``%`` operator::"
msgstr "按名称替换变量的常用方式是 ``%`` 运算符::"

#: ../../whatsnew/2.4.rst:180
msgid ""
">>> '%(page)i: %(title)s' % {'page':2, 'title': 'The Best of Times'}\n"
"'2: The Best of Times'"
msgstr ""
">>> '%(page)i: %(title)s' % {'page':2, 'title': 'The Best of Times'}\n"
"'2: The Best of Times'"

#: ../../whatsnew/2.4.rst:183
msgid ""
"When writing the template string, it can be easy to forget the ``i`` or "
"``s`` after the closing parenthesis.  This isn't a big problem if the "
"template is in a Python module, because you run the code, get an "
"\"Unsupported format character\" :exc:`ValueError`, and fix the problem.  "
"However, consider an application such as Mailman where template strings or "
"translations are being edited by users who aren't aware of the Python "
"language.  The format string's syntax is complicated to explain to such "
"users, and if they make a mistake, it's difficult to provide helpful "
"feedback to them."
msgstr ""
"在编写模板字符串时，很容易忘记在闭合括号后加上 ``i`` 或 ``s``。如果模板在 Python "
"模块中，这并不是一个大问题，因为你可以运行代码，得到一个“不支持的格式字符” :exc:`ValueError`，然后修复这个问题。然而，考虑像 "
"Mailman 这样的应用程序，其中模板字符串或翻译是由不了解 Python "
"语言的用户编辑的。向这些用户解释格式字符串的语法是很复杂的，如果他们犯了错误，很难向他们提供有用的反馈。"

#: ../../whatsnew/2.4.rst:192
msgid ""
"PEP 292 adds a :class:`Template` class to the :mod:`string` module that uses"
" ``$`` to indicate a substitution::"
msgstr "PEP 292 给 :mod:`string` 模块增加了一个 :class:`Template`，它使用 ``$`` 来表示替换::"

#: ../../whatsnew/2.4.rst:195
msgid ""
">>> import string\n"
">>> t = string.Template('$page: $title')\n"
">>> t.substitute({'page':2, 'title': 'The Best of Times'})\n"
"'2: The Best of Times'"
msgstr ""
">>> import string\n"
">>> t = string.Template('$page: $title')\n"
">>> t.substitute({'page':2, 'title': 'The Best of Times'})\n"
"'2: The Best of Times'"

#: ../../whatsnew/2.4.rst:200
msgid ""
"If a key is missing from the dictionary, the :meth:`substitute` method will "
"raise a :exc:`KeyError`.  There's also a :meth:`safe_substitute` method that"
" ignores missing keys::"
msgstr ""
"如果某个键在字典中找不到，:meth:`substitute` 方法将引发 :exc:`KeyError`。 还有一个 "
":meth:`safe_substitute` 方法则会忽略找不到的键::"

#: ../../whatsnew/2.4.rst:204
msgid ""
">>> t = string.Template('$page: $title')\n"
">>> t.safe_substitute({'page':3})\n"
"'3: $title'"
msgstr ""
">>> t = string.Template('$page: $title')\n"
">>> t.safe_substitute({'page':3})\n"
"'3: $title'"

#: ../../whatsnew/2.4.rst:211
msgid ":pep:`292` - Simpler String Substitutions"
msgstr ":pep:`292` - 更简单的字符串替换"

#: ../../whatsnew/2.4.rst:212
msgid "Written and implemented  by Barry Warsaw."
msgstr "由 Barry Warsaw 撰写并实现。"

#: ../../whatsnew/2.4.rst:218
msgid "PEP 318: Decorators for Functions and Methods"
msgstr "PEP 318: 函数和方法的装饰器"

#: ../../whatsnew/2.4.rst:220
msgid ""
"Python 2.2 extended Python's object model by adding static methods and class"
" methods, but it didn't extend Python's syntax to provide any new way of "
"defining static or class methods.  Instead, you had to write a "
":keyword:`def` statement in the usual way, and pass the resulting method to "
"a :func:`staticmethod` or :func:`classmethod` function that would wrap up "
"the function as a method of the new type. Your code would look like this::"
msgstr ""
"Python 2.2 通过添加静态方法和类方法扩展了 Python 的对象模型，但它并没有扩展 Python "
"的语法来提供任何定义静态方法或类方法的新方式。相反，你必须以通常的方式编写一个 :keyword:`def` 语句，并将生成的函数传递给一个 "
":func:`staticmethod` 或 :func:`classmethod` 函数，该函数会将函数包装成新类型的方法。你的代码会像这样::"

#: ../../whatsnew/2.4.rst:227
msgid ""
"class C:\n"
"   def meth (cls):\n"
"       ...\n"
"\n"
"   meth = classmethod(meth)   # Rebind name to wrapped-up class method"
msgstr ""
"class C:\n"
"   def meth (cls):\n"
"       ...\n"
"\n"
"   meth = classmethod(meth)   # 将名称重新绑定到包装后的类方法"

#: ../../whatsnew/2.4.rst:233
msgid ""
"If the method was very long, it would be easy to miss or forget the "
":func:`classmethod` invocation after the function body."
msgstr "如果方法非常长，很容易错过或忘记在函数体后调用 :func:`classmethod`。"

#: ../../whatsnew/2.4.rst:236
msgid ""
"The intention was always to add some syntax to make such definitions more "
"readable, but at the time of 2.2's release a good syntax was not obvious.  "
"Today a good syntax *still* isn't obvious but users are asking for easier "
"access to the feature; a new syntactic feature has been added to meet this "
"need."
msgstr ""
"初衷一直是添加一些语法来使这样的定义更易读，但在 2.2 发布时，一个好的语法并不明显。今天，一个好的语法 *仍然* "
"不明显，但用户希望更方便地访问这个特性；为了满足这一需求，添加了一个新的语法特性。"

#: ../../whatsnew/2.4.rst:241
msgid ""
"The new feature is called \"function decorators\".  The name comes from the "
"idea that :func:`classmethod`, :func:`staticmethod`, and friends are storing"
" additional information on a function object; they're *decorating* functions"
" with more details."
msgstr ""
"这个新特性被称为“函数装饰器”。这个名字源于 :func:`classmethod`、:func:`staticmethod` "
"及其同类函数在函数对象上存储额外信息的想法；它们在用更多细节 *装饰* 函数。"

#: ../../whatsnew/2.4.rst:246
msgid ""
"The notation borrows from Java and uses the ``'@'`` character as an "
"indicator. Using the new syntax, the example above would be written::"
msgstr "这种表示法借鉴了 Java，并使用 ``'@'`` 字符作为指示符。使用新语法，上面的例子会写成::"

#: ../../whatsnew/2.4.rst:249
msgid ""
"class C:\n"
"\n"
"   @classmethod\n"
"   def meth (cls):\n"
"       ..."
msgstr ""
"class C:\n"
"\n"
"   @classmethod\n"
"   def meth (cls):\n"
"       ..."

#: ../../whatsnew/2.4.rst:256
msgid ""
"The ``@classmethod`` is shorthand for the ``meth=classmethod(meth)`` "
"assignment. More generally, if you have the following::"
msgstr "``@classmethod`` 是 ``meth=classmethod(meth)`` 赋值的简写。更一般地，如果你有以下代码："

#: ../../whatsnew/2.4.rst:259
msgid ""
"@A\n"
"@B\n"
"@C\n"
"def f ():\n"
"    ..."
msgstr ""
"@A\n"
"@B\n"
"@C\n"
"def f ():\n"
"    ..."

#: ../../whatsnew/2.4.rst:265
msgid "It's equivalent to the following pre-decorator code::"
msgstr "它等价于以下无装饰器的代码::"

#: ../../whatsnew/2.4.rst:267
msgid ""
"def f(): ...\n"
"f = A(B(C(f)))"
msgstr ""
"def f(): ...\n"
"f = A(B(C(f)))"

#: ../../whatsnew/2.4.rst:270
msgid ""
"Decorators must come on the line before a function definition, one decorator"
" per line, and can't be on the same line as the def statement, meaning that "
"``@A def f(): ...`` is illegal.  You can only decorate function definitions,"
" either at the module level or inside a class; you can't decorate class "
"definitions."
msgstr ""
"装饰器必须放在函数定义的前一行，每行一个装饰器，不能与 def 语句在同一行，这意味着 ``@A def f(): ...`` "
"是非法的。你只能装饰模块级别或类内部的函数定义；不能装饰类定义。"

#: ../../whatsnew/2.4.rst:275
msgid ""
"A decorator is just a function that takes the function to be decorated as an"
" argument and returns either the same function or some new object.  The "
"return value of the decorator need not be callable (though it typically is),"
" unless further decorators will be applied to the result.  It's easy to "
"write your own decorators.  The following simple example just sets an "
"attribute on the function object::"
msgstr ""
"装饰器只是一个函数，它接受要装饰的函数作为参数，并返回相同的函数或某个新对象。装饰器的返回值不一定是可调用的（尽管通常是这样），除非将进一步应用装饰器到结果上。编写自己的装饰器很容易。以下简单示例只是在函数对象上设置一个属性："

#: ../../whatsnew/2.4.rst:282
msgid ""
">>> def deco(func):\n"
"...    func.attr = 'decorated'\n"
"...    return func\n"
"...\n"
">>> @deco\n"
"... def f(): pass\n"
"...\n"
">>> f\n"
"<function f at 0x402ef0d4>\n"
">>> f.attr\n"
"'decorated'\n"
">>>"
msgstr ""
">>> def deco(func):\n"
"...    func.attr = 'decorated'\n"
"...    return func\n"
"...\n"
">>> @deco\n"
"... def f(): pass\n"
"...\n"
">>> f\n"
"<function f at 0x402ef0d4>\n"
">>> f.attr\n"
"'decorated'\n"
">>>"

#: ../../whatsnew/2.4.rst:295
msgid ""
"As a slightly more realistic example, the following decorator checks that "
"the supplied argument is an integer::"
msgstr "作为一个稍微更现实的例子，以下装饰器检查提供的参数是否为整数："

#: ../../whatsnew/2.4.rst:298
msgid ""
"def require_int (func):\n"
"    def wrapper (arg):\n"
"        assert isinstance(arg, int)\n"
"        return func(arg)\n"
"\n"
"    return wrapper\n"
"\n"
"@require_int\n"
"def p1 (arg):\n"
"    print arg\n"
"\n"
"@require_int\n"
"def p2(arg):\n"
"    print arg*2"
msgstr ""
"def require_int (func):\n"
"    def wrapper (arg):\n"
"        assert isinstance(arg, int)\n"
"        return func(arg)\n"
"\n"
"    return wrapper\n"
"\n"
"@require_int\n"
"def p1 (arg):\n"
"    print arg\n"
"\n"
"@require_int\n"
"def p2(arg):\n"
"    print arg*2"

#: ../../whatsnew/2.4.rst:313
msgid ""
"An example in :pep:`318` contains a fancier version of this idea that lets "
"you both specify the required type and check the returned type."
msgstr "在 :pep:`318` 中的一个示例包含了一个更复杂的版本，它允许你同时指定所需类型并检查返回类型。"

#: ../../whatsnew/2.4.rst:316
msgid ""
"Decorator functions can take arguments.  If arguments are supplied, your "
"decorator function is called with only those arguments and must return a new"
" decorator function; this function must take a single function and return a "
"function, as previously described.  In other words, ``@A @B @C(args)`` "
"becomes::"
msgstr ""
"装饰器函数可以接受参数。如果提供了参数，你的装饰器函数仅用这些参数调用，并且必须返回一个新的装饰器函数；这个函数必须接受单个函数并返回一个函数，如前所述。换句话说，``@A"
" @B @C(args)`` 变为："

#: ../../whatsnew/2.4.rst:321
msgid ""
"def f(): ...\n"
"_deco = C(args)\n"
"f = A(B(_deco(f)))"
msgstr ""
"def f(): ...\n"
"_deco = C(args)\n"
"f = A(B(_deco(f)))"

#: ../../whatsnew/2.4.rst:325
msgid ""
"Getting this right can be slightly brain-bending, but it's not too "
"difficult."
msgstr "理解这一点可能有点费脑筋，但并不太困难。"

#: ../../whatsnew/2.4.rst:327
msgid ""
"A small related change makes the :attr:`func_name <function.__name__>` "
"attribute of functions writable.  This attribute is used to display function"
" names in tracebacks, so decorators should change the name of any new "
"function that's constructed and returned."
msgstr ""
"一个小相关的更改使得函数的 :attr:`func_name <function.__name__>` "
"属性可写。此属性用于在跟踪信息中显示函数名称，因此装饰器应更改任何新构造并返回的函数的名称。"

#: ../../whatsnew/2.4.rst:336
msgid ":pep:`318` - Decorators for Functions, Methods and Classes"
msgstr ":pep:`318` - 函数、方法和类的装饰器"

#: ../../whatsnew/2.4.rst:337
msgid ""
"Written  by Kevin D. Smith, Jim Jewett, and Skip Montanaro.  Several people "
"wrote patches implementing function decorators, but the one that was "
"actually checked in was patch #979728, written by Mark Russell."
msgstr ""
"由 Kevin D. Smith、Jim Jewett 和 Skip Montanaro 编写。有几个人编写了实现函数装饰器的补丁，但实际被合并的是补丁"
" #979728，由 Mark Russell 编写。"

#: ../../whatsnew/2.4.rst:341
msgid "https://wiki.python.org/moin/PythonDecoratorLibrary"
msgstr "https://wiki.python.org/moin/PythonDecoratorLibrary"

#: ../../whatsnew/2.4.rst:342
msgid "This Wiki page contains several examples of decorators."
msgstr "该Wiki页面包含几个装饰器示例。"

#: ../../whatsnew/2.4.rst:348
msgid "PEP 322: Reverse Iteration"
msgstr "PEP 322: 反向迭代"

#: ../../whatsnew/2.4.rst:350
msgid ""
"A new built-in function, ``reversed(seq)``, takes a sequence and returns an "
"iterator that loops over the elements of the sequence  in reverse order.   "
"::"
msgstr "一个新的内置函数 ``reversed(seq)``，接受一个序列并返回一个以相反顺序遍历序列元素的迭代器。 ::"

#: ../../whatsnew/2.4.rst:353
msgid ""
">>> for i in reversed(xrange(1,4)):\n"
"...    print i\n"
"...\n"
"3\n"
"2\n"
"1"
msgstr ""
">>> for i in reversed(xrange(1,4)):\n"
"...    print i\n"
"...\n"
"3\n"
"2\n"
"1"

#: ../../whatsnew/2.4.rst:360
msgid ""
"Compared to extended slicing, such as ``range(1,4)[::-1]``, :func:`reversed`"
" is easier to read, runs faster, and uses substantially less memory."
msgstr "与扩展切片（如 ``range(1,4)[::-1]``）相比，:func:`reversed` 更易读，运行更快，且显著减少内存使用。"

#: ../../whatsnew/2.4.rst:363
msgid ""
"Note that :func:`reversed` only accepts sequences, not arbitrary iterators."
"  If you want to reverse an iterator, first convert it to  a list with "
":func:`list`. ::"
msgstr ""
"请注意，:func:`reversed` 只接受序列，不接受任意迭代器。如果你想反转一个迭代器，首先使用 :func:`list` 将其转换为列表。 "
"::"

#: ../../whatsnew/2.4.rst:367
msgid ""
">>> input = open('/etc/passwd', 'r')\n"
">>> for line in reversed(list(input)):\n"
"...   print line\n"
"...\n"
"root:*:0:0:System Administrator:/var/root:/bin/tcsh\n"
"  ..."
msgstr ""
">>> input = open('/etc/passwd', 'r')\n"
">>> for line in reversed(list(input)):\n"
"...   print line\n"
"...\n"
"root:*:0:0:System Administrator:/var/root:/bin/tcsh\n"
"  ..."

#: ../../whatsnew/2.4.rst:377
msgid ":pep:`322` - Reverse Iteration"
msgstr ":pep:`322` - 反向迭代"

#: ../../whatsnew/2.4.rst:378
msgid "Written and implemented by Raymond Hettinger."
msgstr "由 Raymond Hettinger 撰写并实现。"

#: ../../whatsnew/2.4.rst:384
msgid "PEP 324: New subprocess Module"
msgstr "PEP 324: 新的子进程模块"

#: ../../whatsnew/2.4.rst:386
msgid ""
"The standard library provides a number of ways to execute a subprocess, "
"offering different features and different levels of complexity. "
"``os.system(command)`` is easy to use, but slow (it runs a shell process "
"which executes the command) and dangerous (you have to be careful about "
"escaping the shell's metacharacters).  The :mod:`!popen2` module offers "
"classes that can capture standard output and standard error from the "
"subprocess, but the naming is confusing.  The :mod:`subprocess` module "
"cleans  this up, providing a unified interface that offers all the features "
"you might need."
msgstr ""
"标准库提供了多种执行子进程的方式，提供不同的功能和不同的复杂度。``os.system(command)`` 使用简单，但速度慢（它运行一个 shell"
" 进程来执行命令）且存在风险（你必须小心处理 shell 的元字符转义）。:mod:`!popen2` "
"模块提供可以捕获子进程标准输出和标准错误的类，但命名令人困惑。:mod:`subprocess` "
"模块对此进行了清理，提供了一个统一的接口，提供了你可能需要的所有功能。"

#: ../../whatsnew/2.4.rst:395
msgid ""
"Instead of :mod:`!popen2`'s collection of classes, :mod:`subprocess` "
"contains a single class called :class:`subprocess.Popen`  whose constructor "
"supports a number of different keyword arguments. ::"
msgstr ""
"与 :mod:`!popen2` 的一系列类不同，:mod:`subprocess` 包含一个名为 :class:`subprocess.Popen` "
"的单一类，其构造函数支持多种不同的关键字参数。 ::"

#: ../../whatsnew/2.4.rst:399
msgid ""
"class Popen(args, bufsize=0, executable=None,\n"
"            stdin=None, stdout=None, stderr=None,\n"
"            preexec_fn=None, close_fds=False, shell=False,\n"
"            cwd=None, env=None, universal_newlines=False,\n"
"            startupinfo=None, creationflags=0):"
msgstr ""
"class Popen(args, bufsize=0, executable=None,\n"
"            stdin=None, stdout=None, stderr=None,\n"
"            preexec_fn=None, close_fds=False, shell=False,\n"
"            cwd=None, env=None, universal_newlines=False,\n"
"            startupinfo=None, creationflags=0):"

#: ../../whatsnew/2.4.rst:405
msgid ""
"*args* is commonly a sequence of strings that will be the arguments to the "
"program executed as the subprocess.  (If the *shell* argument is true, "
"*args* can be a string which will then be passed on to the shell for "
"interpretation, just as :func:`os.system` does.)"
msgstr ""
"*args* 通常是一个字符串序列，用作子进程要执行的程序的参数。 (如果 *shell* 参数为真，*args* 可以是一个字符串，然后会传递给 "
"shell 进行解释，就像 :func:`os.system` 所做的那样。)"

#: ../../whatsnew/2.4.rst:410
msgid ""
"*stdin*, *stdout*, and *stderr* specify what the subprocess's input, output,"
" and error streams will be.  You can provide a file object or a file "
"descriptor, or you can use the constant ``subprocess.PIPE`` to create a pipe"
" between the subprocess and the parent."
msgstr ""
"*stdin*、*stdout* 和 *stderr* 指定子进程的输入、输出和错误流将会是什么。 "
"你可以提供一个文件对象或文件描述符，或者你可以使用常量 ``subprocess.PIPE`` 来在子进程和父进程之间创建一个管道。"

#: ../../whatsnew/2.4.rst:418
msgid "The constructor has a number of handy options:"
msgstr "此构造器有几个方便的选项:"

#: ../../whatsnew/2.4.rst:420
msgid ""
"*close_fds* requests that all file descriptors be closed before running the "
"subprocess."
msgstr "*close_fds* 将在运行子进程之前请求关闭所有文件描述符。"

#: ../../whatsnew/2.4.rst:423
msgid ""
"*cwd* specifies the working directory in which the subprocess will be "
"executed (defaulting to whatever the parent's working directory is)."
msgstr "*cwd* 指定执行子进程将使用的工作目录（默认为父进程的工作目录）。"

#: ../../whatsnew/2.4.rst:426
msgid "*env* is a dictionary specifying environment variables."
msgstr "*env* 是一个指定环境变量的字典。"

#: ../../whatsnew/2.4.rst:428
msgid ""
"*preexec_fn* is a function that gets called before the child is started."
msgstr "*preexec_fn* 是将在子进程启动之前被调用的函数。"

#: ../../whatsnew/2.4.rst:430
msgid ""
"*universal_newlines* opens the child's input and output using Python's "
":term:`universal newlines` feature."
msgstr ""
"*universal_newlines* 使用 Python 的 :term:`universal newlines` 特性打开子进程的输入和输出。"

#: ../../whatsnew/2.4.rst:433
msgid ""
"Once you've created the :class:`Popen` instance,  you can call its "
":meth:`wait` method to pause until the subprocess has exited, :meth:`poll` "
"to check if it's exited without pausing,  or ``communicate(data)`` to send "
"the string *data* to the subprocess's standard input.   "
"``communicate(data)``  then reads any data that the subprocess has sent to "
"its standard output  or standard error, returning a tuple ``(stdout_data, "
"stderr_data)``."
msgstr ""
"一旦你创建了 :class:`Popen` 实例，你可以调用它的 :meth:`wait` 方法来暂停直到子进程退出，:meth:`poll` "
"来检查它是否已退出而不暂停，或者 ``communicate(data)`` 来将字符串 *data* 发送到子进程的标准输入。 "
"``communicate(data)`` 然后读取子进程发送到其标准输出或标准错误的任何数据，返回一个元组 ``(stdout_data, "
"stderr_data)``。"

#: ../../whatsnew/2.4.rst:440
msgid ""
":func:`call` is a shortcut that passes its arguments along to the "
":class:`Popen` constructor, waits for the command to complete, and returns "
"the status code of the subprocess.  It can serve as a safer analog to "
":func:`os.system`::"
msgstr ""
":func:`call` 是一个快捷方式，它将其参数传递给 :class:`Popen` 构造函数，等待命令完成，并返回子进程的状态码。 它可以作为 "
":func:`os.system` 的更安全替代::"

#: ../../whatsnew/2.4.rst:444
msgid ""
"sts = subprocess.call(['dpkg', '-i', '/tmp/new-package.deb'])\n"
"if sts == 0:\n"
"    # Success\n"
"    ...\n"
"else:\n"
"    # dpkg returned an error\n"
"    ..."
msgstr ""
"sts = subprocess.call(['dpkg', '-i', '/tmp/new-package.deb'])\n"
"if sts == 0:\n"
"    # 成功\n"
"    ...\n"
"else:\n"
"    # dpkg 返回错误\n"
"    ..."

#: ../../whatsnew/2.4.rst:452
msgid ""
"The command is invoked without use of the shell.  If you really do want to  "
"use the shell, you can add ``shell=True`` as a keyword argument and provide "
"a string instead of a sequence::"
msgstr ""
"命令在不使用 shell 的情况下被调用。 如果你确实想使用 shell，你可以添加 ``shell=True`` "
"作为关键字参数，并提供一个字符串而不是序列::"

#: ../../whatsnew/2.4.rst:456
msgid "sts = subprocess.call('dpkg -i /tmp/new-package.deb', shell=True)"
msgstr "sts = subprocess.call('dpkg -i /tmp/new-package.deb', shell=True)"

#: ../../whatsnew/2.4.rst:458
msgid ""
"The PEP takes various examples of shell and Python code and shows how they'd"
" be translated into Python code that uses :mod:`subprocess`.  Reading this "
"section of the PEP is highly recommended."
msgstr ""
"PEP 提供了各种 shell 和 Python 代码示例，并展示了它们如何被翻译成使用 :mod:`subprocess` 的 Python "
"代码。强烈建议阅读 PEP 的这一部分。"

#: ../../whatsnew/2.4.rst:465
msgid ":pep:`324` - subprocess - New process module"
msgstr ":pep:`324` - 子进程 - 新的进程模块"

#: ../../whatsnew/2.4.rst:466
msgid ""
"Written and implemented by Peter Åstrand, with assistance from Fredrik Lundh"
" and others."
msgstr "由 Peter Åstrand 在 Fredrik Lundh 等人的协助下撰写并实现。"

#: ../../whatsnew/2.4.rst:473
msgid "PEP 327: Decimal Data Type"
msgstr "PEP 327: 十进制数据类型"

#: ../../whatsnew/2.4.rst:475
msgid ""
"Python has always supported floating-point (FP) numbers, based on the "
"underlying C :c:expr:`double` type, as a data type.  However, while most "
"programming languages provide a floating-point type, many people (even "
"programmers) are unaware that floating-point numbers don't represent certain"
" decimal fractions accurately.  The new :class:`Decimal` type can represent "
"these fractions accurately, up to a user-specified precision limit."
msgstr ""
"Python 一直支持基于底层 C 语言 :c:expr:`double` "
"类型的浮点数（FP）作为数据类型。然而，尽管大多数编程语言提供了浮点数类型，但许多人（甚至程序员）并不知道浮点数不能准确表示某些十进制分数。新的 "
":class:`Decimal` 类型可以准确表示这些分数，直至用户指定的精度限制。"

#: ../../whatsnew/2.4.rst:484
msgid "Why is Decimal needed?"
msgstr "为什么需要十进制？"

#: ../../whatsnew/2.4.rst:486
msgid ""
"The limitations arise from the representation used for floating-point "
"numbers. FP numbers are made up of three components:"
msgstr "这些限制源于浮点数的表示方式。FP 数由三个部分组成："

#: ../../whatsnew/2.4.rst:489
msgid "The sign, which is positive or negative."
msgstr "符号，可以是正或负。"

#: ../../whatsnew/2.4.rst:491
msgid ""
"The mantissa, which is a single-digit binary number   followed by a "
"fractional part.  For example, ``1.01`` in base-2 notation is ``1 + 0/2 + "
"1/4``, or 1.25 in decimal notation."
msgstr ""
"尾数，是一个单数字的二进制数后跟一个小数部分。例如，二进制表示的 ``1.01`` 是 ``1 + 0/2 + 1/4``，即十进制表示的 1.25。"

#: ../../whatsnew/2.4.rst:495
msgid ""
"The exponent, which tells where the decimal point is located in the number "
"represented."
msgstr "指数，指示数字表示中十进制点的位置。"

#: ../../whatsnew/2.4.rst:498
msgid ""
"For example, the number 1.25 has positive sign, a mantissa value of 1.01 (in"
" binary), and an exponent of 0 (the decimal point doesn't need to be "
"shifted). The number 5 has the same sign and mantissa, but the exponent is 2"
" because the mantissa is multiplied by 4 (2 to the power of the exponent 2);"
" 1.25 \\* 4 equals 5."
msgstr ""
"例如，数字 1.25 具有正符号，尾数值为 1.01（二进制），指数为 0（十进制点不需要移动）。数字 5 具有相同的符号和尾数，但指数为 "
"2，因为尾数乘以 4（2 的指数 2 次方）；1.25 \\* 4 等于 5。"

#: ../../whatsnew/2.4.rst:504
msgid ""
"Modern systems usually provide floating-point support that conforms to a "
"standard called IEEE 754.  C's :c:expr:`double` type is usually implemented "
"as a 64-bit IEEE 754 number, which uses 52 bits of space for the mantissa.  "
"This means that numbers can only be specified to 52 bits of precision.  If "
"you're trying to represent numbers whose expansion repeats endlessly, the "
"expansion is cut off after 52 bits. Unfortunately, most software needs to "
"produce output in base 10, and common fractions in base 10 are often "
"repeating decimals in binary. For example, 1.1 decimal is binary "
"``1.0001100110011 ...``; .1 = 1/16 + 1/32 + 1/256 plus an infinite number of"
" additional terms.  IEEE 754 has to chop off that infinitely repeated "
"decimal after 52 digits, so the representation is slightly inaccurate."
msgstr ""
"现代系统通常提供符合IEEE 754标准的浮点支持。C语言的 :c:expr:`double` 类型通常被实现为64位的IEEE "
"754数字，其中使用52位空间来存储尾数。这意味着数字只能精确到52位。如果你试图表示那些展开后会无限重复的数字，其展开会在52位后截断。不幸的是，大多数软件需要以十进制输出，而十进制中的常见分数在二进制中往往是无限循环小数。例如，十进制的1.1在二进制中是``1.0001100110011"
" ...``；0.1 = 1/16 + 1/32 + 1/256加上无限多个额外项。IEEE "
"754必须在52位后截断这个无限重复的小数，因此表示略有误差。"

#: ../../whatsnew/2.4.rst:516
msgid "Sometimes you can see this inaccuracy when the number is printed::"
msgstr "有时在打印数字时可以看到这种不准确性："

#: ../../whatsnew/2.4.rst:518
msgid ""
">>> 1.1\n"
"1.1000000000000001"
msgstr ""
">>> 1.1\n"
"1.1000000000000001"

#: ../../whatsnew/2.4.rst:521
msgid ""
"The inaccuracy isn't always visible when you print the number because the "
"FP-to-decimal-string conversion is provided by the C library, and most C "
"libraries try to produce sensible output.  Even if it's not displayed, "
"however, the inaccuracy is still there and subsequent operations can magnify"
" the error."
msgstr ""
"这种不准确性在打印数字时不总是可见，因为浮点数到十进制字符串的转换由C库提供，大多数C库会尝试生成合理的输出。即使没有显示出来，不准确性仍然存在，后续操作可能会放大这个误差。"

#: ../../whatsnew/2.4.rst:526
msgid ""
"For many applications this doesn't matter.  If I'm plotting points and "
"displaying them on my monitor, the difference between 1.1 and "
"1.1000000000000001 is too small to be visible.  Reports often limit output "
"to a certain number of decimal places, and if you round the number to two or"
" three or even eight decimal places, the error is never apparent.  However, "
"for applications where it does matter,  it's a lot of work to implement your"
" own custom arithmetic routines."
msgstr ""
"对于许多应用来说，这并不重要。如果我在绘制点并在显示器上显示它们，1.1和1.1000000000000001之间的差异太小，无法察觉。报告通常限制输出到一定的小数位数，如果你将数字四舍五入到两位、三位甚至八位小数，误差永远不会显现。然而，对于确实重要的应用，实现自己的自定义算术例程是一项大量工作。"

#: ../../whatsnew/2.4.rst:534
msgid "Hence, the :class:`Decimal` type was created."
msgstr "因此，创建了 :class:`Decimal` 类型。"

#: ../../whatsnew/2.4.rst:538
msgid "The :class:`Decimal` type"
msgstr ":class:`Decimal` 类型"

#: ../../whatsnew/2.4.rst:540
msgid ""
"A new module, :mod:`decimal`, was added to Python's standard library.  It "
"contains two classes, :class:`Decimal` and :class:`Context`.  "
":class:`Decimal` instances represent numbers, and :class:`Context` instances"
" are used to wrap up various settings such as the precision and default "
"rounding mode."
msgstr ""
"Python标准库中添加了一个新模块 :mod:`decimal` 。它包含两个类，:class:`Decimal` 和 "
":class:`Context`。:class:`Decimal` 实例表示数字，而 :class:`Context` "
"实例用于封装各种设置，例如精度和默认舍入模式。"

#: ../../whatsnew/2.4.rst:545
msgid ""
":class:`Decimal` instances are immutable, like regular Python integers and "
"FP numbers; once it's been created, you can't change the value an instance "
"represents.  :class:`Decimal` instances can be created from integers or "
"strings::"
msgstr ""
":class:`Decimal` 实例是不可变的，就像常规的 Python "
"整数和浮点数一样；一旦创建，就无法更改实例所表示的值。:class:`Decimal` 实例可以从整数或字符串创建："

#: ../../whatsnew/2.4.rst:550
msgid ""
">>> import decimal\n"
">>> decimal.Decimal(1972)\n"
"Decimal(\"1972\")\n"
">>> decimal.Decimal(\"1.1\")\n"
"Decimal(\"1.1\")"
msgstr ""
">>> import decimal\n"
">>> decimal.Decimal(1972)\n"
"Decimal(\"1972\")\n"
">>> decimal.Decimal(\"1.1\")\n"
"Decimal(\"1.1\")"

#: ../../whatsnew/2.4.rst:556
msgid ""
"You can also provide tuples containing the sign, the mantissa represented  "
"as a tuple of decimal digits, and the exponent::"
msgstr "你也可以提供包含符号、以十进制数字元组表示的尾数和指数的元组："

#: ../../whatsnew/2.4.rst:559
msgid ""
">>> decimal.Decimal((1, (1, 4, 7, 5), -2))\n"
"Decimal(\"-14.75\")"
msgstr ""
">>> decimal.Decimal((1, (1, 4, 7, 5), -2))\n"
"Decimal(\"-14.75\")"

#: ../../whatsnew/2.4.rst:562
msgid ""
"Cautionary note: the sign bit is a Boolean value, so 0 is positive and 1 is "
"negative."
msgstr "注意事项：符号位是一个布尔值，所以 0 表示正数，1 表示负数。"

#: ../../whatsnew/2.4.rst:565
msgid ""
"Converting from floating-point numbers poses a bit of a problem: should the "
"FP number representing 1.1 turn into the decimal number for exactly 1.1, or "
"for 1.1 plus whatever inaccuracies are introduced? The decision was to dodge"
" the issue and leave such a conversion out of the API.  Instead, you should "
"convert the floating-point number into a string using the desired precision "
"and pass the string to the :class:`Decimal` constructor::"
msgstr ""
"从浮点数转换会带来一些问题：表示 1.1 的浮点数应该转换为精确的 1.1 的十进制数，还是 1.1 "
"加上引入的任何不准确度？决定是回避这个问题，不将此类转换包含在 API 中。相反，你应该将浮点数转换为字符串，使用所需的精度，并将字符串传递给 "
":class:`Decimal` 构造函数："

#: ../../whatsnew/2.4.rst:572
msgid ""
">>> f = 1.1\n"
">>> decimal.Decimal(str(f))\n"
"Decimal(\"1.1\")\n"
">>> decimal.Decimal('%.12f' % f)\n"
"Decimal(\"1.100000000000\")"
msgstr ""
">>> f = 1.1\n"
">>> decimal.Decimal(str(f))\n"
"Decimal(\"1.1\")\n"
">>> decimal.Decimal('%.12f' % f)\n"
"Decimal(\"1.100000000000\")"

#: ../../whatsnew/2.4.rst:578
msgid ""
"Once you have :class:`Decimal` instances, you can perform the usual "
"mathematical operations on them.  One limitation: exponentiation requires an"
" integer exponent::"
msgstr "一旦你有了 :class:`Decimal` 实例，你可以在它们上执行常规的数学运算。一个限制：指数运算需要整数指数："

#: ../../whatsnew/2.4.rst:582
msgid ""
">>> a = decimal.Decimal('35.72')\n"
">>> b = decimal.Decimal('1.73')\n"
">>> a+b\n"
"Decimal(\"37.45\")\n"
">>> a-b\n"
"Decimal(\"33.99\")\n"
">>> a*b\n"
"Decimal(\"61.7956\")\n"
">>> a/b\n"
"Decimal(\"20.64739884393063583815028902\")\n"
">>> a ** 2\n"
"Decimal(\"1275.9184\")\n"
">>> a**b\n"
"Traceback (most recent call last):\n"
"  ...\n"
"decimal.InvalidOperation: x ** (non-integer)"
msgstr ""
">>> a = decimal.Decimal('35.72')\n"
">>> b = decimal.Decimal('1.73')\n"
">>> a+b\n"
"Decimal(\"37.45\")\n"
">>> a-b\n"
"Decimal(\"33.99\")\n"
">>> a*b\n"
"Decimal(\"61.7956\")\n"
">>> a/b\n"
"Decimal(\"20.64739884393063583815028902\")\n"
">>> a ** 2\n"
"Decimal(\"1275.9184\")\n"
">>> a**b\n"
"Traceback (most recent call last):\n"
"  ...\n"
"decimal.InvalidOperation: x ** (非整数)"

#: ../../whatsnew/2.4.rst:599
msgid ""
"You can combine :class:`Decimal` instances with integers, but not with "
"floating-point numbers::"
msgstr "你可以将 :class:`Decimal` 实例与整数组合，但不能与浮点数组合："

#: ../../whatsnew/2.4.rst:602
msgid ""
">>> a + 4\n"
"Decimal(\"39.72\")\n"
">>> a + 4.5\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: You can interact Decimal only with int, long or Decimal data types.\n"
">>>"
msgstr ""
">>> a + 4\n"
"Decimal(\"39.72\")\n"
">>> a + 4.5\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 你只能用 int, long 或 Decimal 数据类型与 Decimal 交互。\n"
">>>"

#: ../../whatsnew/2.4.rst:610
msgid ""
":class:`Decimal` numbers can be used with the :mod:`math` and :mod:`cmath` "
"modules, but note that they'll be immediately converted to  floating-point "
"numbers before the operation is performed, resulting in a possible loss of "
"precision and accuracy.  You'll also get back a regular floating-point "
"number and not a :class:`Decimal`.   ::"
msgstr ""
":class:`Decimal` 数字可以与 :mod:`math` 和 :mod:`cmath` "
"模块一起使用，但请注意，在进行操作之前，它们会立即转换为浮点数，这可能导致精度和准确性的损失。你也会得到一个普通的浮点数，而不是 "
":class:`Decimal`。 ::"

#: ../../whatsnew/2.4.rst:616
msgid ""
">>> import math, cmath\n"
">>> d = decimal.Decimal('123456789012.345')\n"
">>> math.sqrt(d)\n"
"351364.18288201344\n"
">>> cmath.sqrt(-d)\n"
"351364.18288201344j"
msgstr ""
">>> import math, cmath\n"
">>> d = decimal.Decimal('123456789012.345')\n"
">>> math.sqrt(d)\n"
"351364.18288201344\n"
">>> cmath.sqrt(-d)\n"
"351364.18288201344j"

#: ../../whatsnew/2.4.rst:623
msgid ""
":class:`Decimal` instances have a :meth:`sqrt` method that returns a "
":class:`Decimal`, but if you need other things such as trigonometric "
"functions you'll have to implement them. ::"
msgstr ""
":class:`Decimal` 实例有一个 :meth:`sqrt` 方法，返回一个 "
":class:`Decimal`，但如果你需要其他函数，比如三角函数，你将不得不自己实现它们。 ::"

#: ../../whatsnew/2.4.rst:627
msgid ""
">>> d.sqrt()\n"
"Decimal(\"351364.1828820134592177245001\")"
msgstr ""
">>> d.sqrt()\n"
"Decimal(\"351364.1828820134592177245001\")"

#: ../../whatsnew/2.4.rst:632
msgid "The :class:`Context` type"
msgstr ":class:`Context` 类型"

#: ../../whatsnew/2.4.rst:634
msgid ""
"Instances of the :class:`Context` class encapsulate several settings for "
"decimal operations:"
msgstr ":class:`Context` 类的实例封装了小数操作的几种设置："

#: ../../whatsnew/2.4.rst:637
msgid ":attr:`prec` is the precision, the number of decimal places."
msgstr ":attr:`prec` 是精度，即小数点后的位数。"

#: ../../whatsnew/2.4.rst:639
msgid ""
":attr:`rounding` specifies the rounding mode.  The :mod:`decimal` module has"
" constants for the various possibilities: :const:`ROUND_DOWN`, "
":const:`ROUND_CEILING`,  :const:`ROUND_HALF_EVEN`, and various others."
msgstr ""
":attr:`rounding` 指定舍入模式。:mod:`decimal` "
"模块为各种可能性提供了常量：:const:`ROUND_DOWN`、:const:`ROUND_CEILING`、:const:`ROUND_HALF_EVEN`"
" 以及其他几种。"

#: ../../whatsnew/2.4.rst:643
msgid ""
":attr:`traps` is a dictionary specifying what happens on encountering "
"certain error conditions: either  an exception is raised or  a value is "
"returned.  Some examples of error conditions are division by zero, loss of "
"precision, and overflow."
msgstr ""
":attr:`traps` 是一个字典，指定在遇到某些错误条件时会发生什么：要么抛出异常，要么返回一个值。一些错误条件的例子包括除以零、精度损失和溢出。"

#: ../../whatsnew/2.4.rst:648
msgid ""
"There's a thread-local default context available by calling "
":func:`getcontext`; you can change the properties of this context to alter "
"the default precision, rounding, or trap handling.  The following example "
"shows the effect of changing the precision of the default context::"
msgstr ""
"通过调用 :func:`getcontext` "
"可以获得线程本地的默认上下文；你可以更改此上下文的属性来改变默认的精度、舍入或错误处理。以下示例显示了更改默认上下文精度的效果::"

#: ../../whatsnew/2.4.rst:653
msgid ""
">>> decimal.getcontext().prec\n"
"28\n"
">>> decimal.Decimal(1) / decimal.Decimal(7)\n"
"Decimal(\"0.1428571428571428571428571429\")\n"
">>> decimal.getcontext().prec = 9\n"
">>> decimal.Decimal(1) / decimal.Decimal(7)\n"
"Decimal(\"0.142857143\")"
msgstr ""
">>> decimal.getcontext().prec\n"
"28\n"
">>> decimal.Decimal(1) / decimal.Decimal(7)\n"
"Decimal(\"0.1428571428571428571428571429\")\n"
">>> decimal.getcontext().prec = 9\n"
">>> decimal.Decimal(1) / decimal.Decimal(7)\n"
"Decimal(\"0.142857143\")"

#: ../../whatsnew/2.4.rst:661
msgid ""
"The default action for error conditions is selectable; the module can either"
" return a special value such as infinity or not-a-number, or exceptions can "
"be raised::"
msgstr "错误条件的默认行为是可选择的；模块可以返回特殊值，如无穷大或非数字，或者可以抛出异常::"

#: ../../whatsnew/2.4.rst:665
msgid ""
">>> decimal.Decimal(1) / decimal.Decimal(0)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"decimal.DivisionByZero: x / 0\n"
">>> decimal.getcontext().traps[decimal.DivisionByZero] = False\n"
">>> decimal.Decimal(1) / decimal.Decimal(0)\n"
"Decimal(\"Infinity\")\n"
">>>"
msgstr ""
">>> decimal.Decimal(1) / decimal.Decimal(0)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"decimal.DivisionByZero: x / 0\n"
">>> decimal.getcontext().traps[decimal.DivisionByZero] = False\n"
">>> decimal.Decimal(1) / decimal.Decimal(0)\n"
"Decimal(\"Infinity\")\n"
">>>"

#: ../../whatsnew/2.4.rst:674
msgid ""
"The :class:`Context` instance also has various methods for formatting  "
"numbers such as :meth:`to_eng_string` and :meth:`to_sci_string`."
msgstr ""
":class:`Context` 实例还包含多种用于格式化数字的方法，例如 :meth:`to_eng_string` 和 "
":meth:`to_sci_string`。"

#: ../../whatsnew/2.4.rst:677
msgid ""
"For more information, see the documentation for the :mod:`decimal` module, "
"which includes a quick-start tutorial and a reference."
msgstr "更多信息请参阅 :mod:`decimal` 模块的文档，其中包含快速入门教程和参考手册。"

#: ../../whatsnew/2.4.rst:683
msgid ":pep:`327` - Decimal Data Type"
msgstr ":pep:`327` - 十进数据类型"

#: ../../whatsnew/2.4.rst:684
msgid ""
"Written by Facundo Batista and implemented by Facundo Batista, Eric Price, "
"Raymond Hettinger, Aahz, and Tim Peters."
msgstr ""
"由 Facundo Batista 撰写，由Facundo Batista, Eric Price, Raymond Hettinger, Aahz 和"
" Tim Peters 实现。"

#: ../../whatsnew/2.4.rst:687
msgid ""
"`http://www.lahey.com/float.htm "
"<https://web.archive.org/web/20230604072523/http://www.lahey.com/float.htm>`__"
msgstr ""
"`http://www.lahey.com/float.htm "
"<https://web.archive.org/web/20230604072523/http://www.lahey.com/float.htm>`__"

#: ../../whatsnew/2.4.rst:688
msgid ""
"The article uses Fortran code to illustrate many of the problems that "
"floating-point inaccuracy can cause."
msgstr "该文章使用 Fortran 代码演示了浮点精度问题可能导致的许多问题。"

#: ../../whatsnew/2.4.rst:691
msgid "https://speleotrove.com/decimal/"
msgstr "https://speleotrove.com/decimal/"

#: ../../whatsnew/2.4.rst:692
msgid ""
"A description of a decimal-based representation.  This representation is "
"being proposed as a standard, and underlies the new Python decimal type.  "
"Much of this material was written by Mike Cowlishaw, designer of the Rexx "
"language."
msgstr ""
"描述了一种基于十进制的表示法。这种表示法已被提议作为标准，并且是新的 Python decimal 类型的基础。大部分内容由 Rexx 语言的设计者 "
"Mike Cowlishaw 撰写。"

#: ../../whatsnew/2.4.rst:700
msgid "PEP 328: Multi-line Imports"
msgstr "PEP 328: 多行导入"

#: ../../whatsnew/2.4.rst:702
msgid ""
"One language change is a small syntactic tweak aimed at making it easier to "
"import many names from a module.  In a ``from module import names`` "
"statement, *names* is a sequence of names separated by commas.  If the "
"sequence is  very long, you can either write multiple imports from the same "
"module, or you can use backslashes to escape the line endings like this::"
msgstr ""
"一个语言改动是针对从模块中导入多个名称的小语法调整。在 ``from module import names`` 语句中，*names* "
"是由逗号分隔的名称序列。如果序列非常长，您可以要么从同一模块多次导入，要么使用反斜杠转义行尾，如下所示::"

#: ../../whatsnew/2.4.rst:708
msgid ""
"from SimpleXMLRPCServer import SimpleXMLRPCServer,\\\n"
"            SimpleXMLRPCRequestHandler,\\\n"
"            CGIXMLRPCRequestHandler,\\\n"
"            resolve_dotted_attribute"
msgstr ""
"from SimpleXMLRPCServer import SimpleXMLRPCServer,\\\n"
"            SimpleXMLRPCRequestHandler,\\\n"
"            CGIXMLRPCRequestHandler,\\\n"
"            resolve_dotted_attribute"

#: ../../whatsnew/2.4.rst:713
msgid ""
"The syntactic change in Python 2.4 simply allows putting the names within "
"parentheses.  Python ignores newlines within a parenthesized expression, so "
"the backslashes are no longer needed::"
msgstr "Python 2.4 中的语法改动允许将名称放在括号内。Python 忽略括号表达式中的换行符，因此不再需要反斜杠::"

#: ../../whatsnew/2.4.rst:717
msgid ""
"from SimpleXMLRPCServer import (SimpleXMLRPCServer,\n"
"                                SimpleXMLRPCRequestHandler,\n"
"                                CGIXMLRPCRequestHandler,\n"
"                                resolve_dotted_attribute)"
msgstr ""
"from SimpleXMLRPCServer import (SimpleXMLRPCServer,\n"
"                                SimpleXMLRPCRequestHandler,\n"
"                                CGIXMLRPCRequestHandler,\n"
"                                resolve_dotted_attribute)"

#: ../../whatsnew/2.4.rst:722
msgid ""
"The PEP also proposes that all :keyword:`import` statements be absolute "
"imports, with a leading ``.`` character to indicate a relative import.  This"
" part of the PEP was not implemented for Python 2.4, but was completed for "
"Python 2.5."
msgstr ""
"PEP还提议所有 :keyword:`import` 语句应为绝对导入，使用前导的 ``.`` 字符表示相对导入。这部分PEP在Python "
"2.4中未实现，但在Python 2.5中完成了。"

#: ../../whatsnew/2.4.rst:729
msgid ":pep:`328` - Imports: Multi-Line and Absolute/Relative"
msgstr ":pep:`328` - 导入：多行和绝对/相对导入"

#: ../../whatsnew/2.4.rst:730
msgid "Written by Aahz.  Multi-line imports were implemented by Dima Dorfman."
msgstr "由 Aahz 撰写，多行导入由 Dima Dorfman 实现。"

#: ../../whatsnew/2.4.rst:736
msgid "PEP 331: Locale-Independent Float/String Conversions"
msgstr "PEP 331: 与区域设置无关的浮点数/字符串转换"

#: ../../whatsnew/2.4.rst:738
msgid ""
"The :mod:`locale` modules lets Python software select various conversions "
"and display conventions that are localized to a particular country or "
"language. However, the module was careful to not change the numeric locale "
"because various functions in Python's implementation required that the "
"numeric locale remain set to the ``'C'`` locale.  Often this was because the"
" code was using the C library's :c:func:`atof` function."
msgstr ""
":mod:`locale` "
"模块让Python软件选择针对特定国家或语言的多种转换和显示约定。然而，该模块小心翼翼地不更改数字区域设置，因为Python实现中的各种函数要求数字区域设置保持为"
" ``'C'`` 区域。这通常是因为代码使用了C库的 :c:func:`atof` 函数。"

#: ../../whatsnew/2.4.rst:745
msgid ""
"Not setting the numeric locale caused trouble for extensions that used "
"third-party C libraries, however, because they wouldn't have the correct "
"locale set. The motivating example was GTK+, whose user interface widgets "
"weren't displaying numbers in the current locale."
msgstr ""
"不设置数字区域设置给使用第三方C库的扩展带来了麻烦，因为它们不会有正确的区域设置。动机示例是GTK+，其用户界面小部件未在当前区域显示数字。"

#: ../../whatsnew/2.4.rst:750
msgid ""
"The solution described in the PEP is to add three new functions to the "
"Python API that perform ASCII-only conversions, ignoring the locale setting:"
msgstr "PEP中描述的解决方案是在Python API中添加三个新函数，执行仅ASCII的转换，忽略区域设置："

#: ../../whatsnew/2.4.rst:753
msgid ""
"``PyOS_ascii_strtod(str, ptr)``  and ``PyOS_ascii_atof(str, ptr)`` both "
"convert a string to a C :c:expr:`double`."
msgstr ""
"``PyOS_ascii_strtod(str, ptr)`` 和 ``PyOS_ascii_atof(str, ptr)`` 都将字符串转换为C "
":c:expr:`double`。"

#: ../../whatsnew/2.4.rst:756
msgid ""
"``PyOS_ascii_formatd(buffer, buf_len, format, d)`` converts a "
":c:expr:`double` to an ASCII string."
msgstr ""
"``PyOS_ascii_formatd(buffer, buf_len, format, d)`` 将 :c:expr:`double` 转换为 "
"ASCII 字符串。"

#: ../../whatsnew/2.4.rst:759
msgid ""
"The code for these functions came from the GLib library (`https://developer-"
"old.gnome.org/glib/2.26/ "
"<http://web.archive.org/web/20210306104320/https://developer.gnome.org/glib/2.26/>`__),"
" whose developers kindly relicensed the relevant functions and donated them "
"to the Python Software Foundation.  The :mod:`locale` module  can now change"
" the numeric locale, letting extensions such as GTK+  produce the correct "
"results."
msgstr ""
"这些函数的代码来自GLib库（`https://developer-old.gnome.org/glib/2.26/ "
"<http://web.archive.org/web/20210306104320/https://developer.gnome.org/glib/2.26/>`__），其开发者友好地重新许可了相关函数并捐赠给Python软件基金会。:mod:`locale`"
" 模块现在可以更改数字区域设置，让诸如GTK+之类的扩展产生正确的结果。"

#: ../../whatsnew/2.4.rst:768
msgid ":pep:`331` - Locale-Independent Float/String Conversions"
msgstr ":pep:`331` - 与区域设置无关的浮点数/字符串转换"

#: ../../whatsnew/2.4.rst:769
msgid "Written by Christian R. Reis, and implemented by Gustavo Carneiro."
msgstr "由Christian R. Reis撰写，由 Gustavo Carneiro 实现。"

#: ../../whatsnew/2.4.rst:775
msgid "Other Language Changes"
msgstr "其他语言特性修改"

#: ../../whatsnew/2.4.rst:777
msgid ""
"Here are all of the changes that Python 2.4 makes to the core Python "
"language."
msgstr "以下是 Python 2.4 针对核心 Python 语言的所有改变。"

#: ../../whatsnew/2.4.rst:779
msgid "Decorators for functions and methods were added (:pep:`318`)."
msgstr "增加了用于函数和方法的装饰器 (:pep:`318`)。"

#: ../../whatsnew/2.4.rst:781
msgid ""
"Built-in :func:`set` and :func:`frozenset` types were  added (:pep:`218`). "
"Other new built-ins include the ``reversed(seq)`` function (:pep:`322`)."
msgstr ""
"内置的 :func:`set` 和 :func:`frozenset` 类型被添加（:pep:`218`）。其他新内置函数包括 "
"``reversed(seq)`` 函数（:pep:`322`）。"

#: ../../whatsnew/2.4.rst:784
msgid "Generator expressions were added (:pep:`289`)."
msgstr "增加了生成器表达式 (:pep:`289`)。"

#: ../../whatsnew/2.4.rst:786
msgid ""
"Certain numeric expressions no longer return values restricted to 32 or 64 "
"bits (:pep:`237`)."
msgstr "某些数值表达式不再返回限于32位或64位的结果 (:pep:`237`)。"

#: ../../whatsnew/2.4.rst:789
msgid ""
"You can now put parentheses around the list of names in a ``from module "
"import names`` statement (:pep:`328`)."
msgstr "现在可以在 `from module import names` 语句中的名称列表周围加上括号 (:pep:`328`)。"

#: ../../whatsnew/2.4.rst:792
msgid ""
"The :meth:`dict.update` method now accepts the same argument forms as the "
":class:`dict` constructor.  This includes any mapping, any iterable of "
"key/value pairs, and keyword arguments. (Contributed by Raymond Hettinger.)"
msgstr ""
":meth:`dict.update` 方法现在接受与 :class:`dict` "
"构造函数相同的参数形式。这包括任何映射、任何键/值对的迭代器以及关键字参数。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:796
msgid ""
"The string methods :meth:`ljust`, :meth:`rjust`, and :meth:`center` now take"
" an optional argument for specifying a fill character other than a space. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"字符串方法 :meth:`ljust`、:meth:`rjust` 和 :meth:`center` "
"现在接受一个可选参数，用于指定除空格以外的填充字符。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:800
msgid ""
"Strings also gained an :meth:`rsplit` method that works like the "
":meth:`split` method but splits from the end of the string.   (Contributed "
"by Sean Reifschneider.) ::"
msgstr ""
"字符串还增加了一个 :meth:`rsplit` 方法，其工作方式类似于 :meth:`split` 方法，但从字符串末尾开始分割。（由 Sean "
"Reifschneider 贡献。） ::"

#: ../../whatsnew/2.4.rst:804
msgid ""
">>> 'www.python.org'.split('.', 1)\n"
"['www', 'python.org']\n"
"'www.python.org'.rsplit('.', 1)\n"
"['www.python', 'org']"
msgstr ""
">>> 'www.python.org'.split('.', 1)\n"
"['www', 'python.org']\n"
"'www.python.org'.rsplit('.', 1)\n"
"['www.python', 'org']"

#: ../../whatsnew/2.4.rst:809
msgid ""
"Three keyword parameters, *cmp*, *key*, and *reverse*, were added to the "
":meth:`sort` method of lists. These parameters make some common usages of "
":meth:`sort` simpler. All of these parameters are optional."
msgstr ""
"列表的 :meth:`sort` 方法增加了三个关键字参数：*cmp*、*key* 和 *reverse*。这些参数使一些常见的 "
":meth:`sort` 用法变得更简单。所有这些参数都是可选的。"

#: ../../whatsnew/2.4.rst:813
msgid ""
"For the *cmp* parameter, the value should be a comparison function that "
"takes two parameters and returns -1, 0, or +1 depending on how the "
"parameters compare. This function will then be used to sort the list.  "
"Previously this was the only parameter that could be provided to "
":meth:`sort`."
msgstr ""
"对于 *cmp* 参数，其值应为一个比较函数，该函数接受两个参数，根据参数的比较结果返回 -1、0 或 "
"+1。然后使用此函数对列表进行排序。以前这是唯一可以提供给 :meth:`sort` 的参数。"

#: ../../whatsnew/2.4.rst:818
msgid ""
"*key* should be a single-parameter function that takes a list element and "
"returns a comparison key for the element.  The list is then sorted using the"
" comparison keys.  The following example sorts a list case-insensitively::"
msgstr ""
"*key* "
"应该是一个单参数函数，该函数接受一个列表元素并返回该元素的比较键。然后使用比较键对列表进行排序。以下示例按不区分大小写的方式对列表进行排序::"

#: ../../whatsnew/2.4.rst:822
msgid ""
">>> L = ['A', 'b', 'c', 'D']\n"
">>> L.sort()                 # Case-sensitive sort\n"
">>> L\n"
"['A', 'D', 'b', 'c']\n"
">>> # Using 'key' parameter to sort list\n"
">>> L.sort(key=lambda x: x.lower())\n"
">>> L\n"
"['A', 'b', 'c', 'D']\n"
">>> # Old-fashioned way\n"
">>> L.sort(cmp=lambda x,y: cmp(x.lower(), y.lower()))\n"
">>> L\n"
"['A', 'b', 'c', 'D']"
msgstr ""
">>> L = ['A', 'b', 'c', 'D']\n"
">>> L.sort()                 # 区分大小写的排序\n"
">>> L\n"
"['A', 'D', 'b', 'c']\n"
">>> # 使用 'key' 参数对列表进行排序\n"
">>> L.sort(key=lambda x: x.lower())\n"
">>> L\n"
"['A', 'b', 'c', 'D']\n"
">>> # 旧式方法\n"
">>> L.sort(cmp=lambda x,y: cmp(x.lower(), y.lower()))\n"
">>> L\n"
"['A', 'b', 'c', 'D']"

#: ../../whatsnew/2.4.rst:835
msgid ""
"The last example, which uses the *cmp* parameter, is the old way to perform "
"a case-insensitive sort.  It works but is slower than using a *key* "
"parameter. Using *key* calls :meth:`lower` method once for each element in "
"the list while using *cmp* will call it twice for each comparison, so using "
"*key* saves on invocations of the :meth:`lower` method."
msgstr ""
"最后一个示例使用了 *cmp* 参数，这是旧方法来进行不区分大小写的排序。它可以工作，但比使用 *key* 参数慢。使用 *key* "
"参数会对列表中的每个元素调用一次 :meth:`lower` 方法，而使用 *cmp* 参数则会在每次比较时调用两次，因此使用 *key* "
"参数可以减少对 :meth:`lower` 方法的调用。"

#: ../../whatsnew/2.4.rst:841
msgid ""
"For simple key functions and comparison functions, it is often possible to "
"avoid a :keyword:`lambda` expression by using an unbound method instead.  "
"For example, the above case-insensitive sort is best written as::"
msgstr ""
"对于简单的键函数和比较函数，通常可以通过使用未绑定方法来避免使用 :keyword:`lambda` 表达式。例如，上述不区分大小写的排序最好写成："

#: ../../whatsnew/2.4.rst:845
msgid ""
">>> L.sort(key=str.lower)\n"
">>> L\n"
"['A', 'b', 'c', 'D']"
msgstr ""
">>> L.sort(key=str.lower)\n"
">>> L\n"
"['A', 'b', 'c', 'D']"

#: ../../whatsnew/2.4.rst:849
msgid ""
"Finally, the *reverse* parameter takes a Boolean value.  If the value is "
"true, the list will be sorted into reverse order. Instead of ``L.sort(); "
"L.reverse()``, you can now write ``L.sort(reverse=True)``."
msgstr ""
"最后，*reverse* 参数接受一个布尔值。如果值为真，列表将按逆序排序。现在你可以用 ``L.sort(reverse=True)`` 替代 "
"``L.sort(); L.reverse()``。"

#: ../../whatsnew/2.4.rst:853
msgid ""
"The results of sorting are now guaranteed to be stable.  This means that two"
" entries with equal keys will be returned in the same order as they were "
"input. For example, you can sort a list of people by name, and then sort the"
" list by age, resulting in a list sorted by age where people with the same "
"age are in name-sorted order."
msgstr ""
"排序结果现在保证是稳定的。这意味着具有相同键的两个条目将按照它们输入的顺序返回。例如，你可以先按名字对人员列表进行排序，然后再按年龄排序，结果是一个按年龄排序的列表，其中同年龄的人员按名字排序。"

#: ../../whatsnew/2.4.rst:859
msgid "(All changes to :meth:`sort` contributed by Raymond Hettinger.)"
msgstr "（所有对 :meth:`sort` 方法的更改由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:861
msgid ""
"There is a new built-in function ``sorted(iterable)`` that works like the "
"in-place :meth:`list.sort` method but can be used in expressions.  The "
"differences are:"
msgstr ""
"有一个新的内置函数 ``sorted(iterable)``，它类似于原地 :meth:`list.sort` 方法，但可以在表达式中使用。区别在于："

#: ../../whatsnew/2.4.rst:865
msgid "the input may be any iterable;"
msgstr "输入可以是任意可迭代对象;"

#: ../../whatsnew/2.4.rst:867
msgid "a newly formed copy is sorted, leaving the original intact; and"
msgstr "新生成的副本被排序，原始列表保持不变；以及"

#: ../../whatsnew/2.4.rst:869
msgid "the expression returns the new sorted copy"
msgstr "表达式返回新的已排序副本"

#: ../../whatsnew/2.4.rst:873
msgid ""
">>> L = [9,7,8,3,2,4,1,6,5]\n"
">>> [10+i for i in sorted(L)]       # usable in a list comprehension\n"
"[11, 12, 13, 14, 15, 16, 17, 18, 19]\n"
">>> L                               # original is left unchanged\n"
"[9,7,8,3,2,4,1,6,5]\n"
">>> sorted('Monty Python')          # any iterable may be an input\n"
"[' ', 'M', 'P', 'h', 'n', 'n', 'o', 'o', 't', 't', 'y', 'y']\n"
"\n"
">>> # List the contents of a dict sorted by key values\n"
">>> colormap = dict(red=1, blue=2, green=3, black=4, yellow=5)\n"
">>> for k, v in sorted(colormap.iteritems()):\n"
"...     print k, v\n"
"...\n"
"black 4\n"
"blue 2\n"
"green 3\n"
"red 1\n"
"yellow 5"
msgstr ""
">>> L = [9,7,8,3,2,4,1,6,5]\n"
">>> [10+i for i in sorted(L)]       # 可用于列表推导\n"
"[11, 12, 13, 14, 15, 16, 17, 18, 19]\n"
">>> L                               # 原列表保持不变\n"
"[9,7,8,3,2,4,1,6,5]\n"
">>> sorted('Monty Python')          # 任何可迭代对象都可以作为输入\n"
"[' ', 'M', 'P', 'h', 'n', 'n', 'o', 'o', 't', 't', 'y', 'y']\n"
"\n"
">>> # 按键值排序并列出字典内容\n"
">>> colormap = dict(red=1, blue=2, green=3, black=4, yellow=5)\n"
">>> for k, v in sorted(colormap.iteritems()):\n"
"...     print k, v\n"
"...\n"
"black 4\n"
"blue 2\n"
"green 3\n"
"red 1\n"
"yellow 5"

#: ../../whatsnew/2.4.rst:892 ../../whatsnew/2.4.rst:920
#: ../../whatsnew/2.4.rst:1213
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:894 ../../whatsnew/2.4.rst:1520
msgid ""
"Integer operations will no longer trigger an :exc:`OverflowWarning`. The "
":exc:`OverflowWarning` warning will disappear in Python 2.5."
msgstr ""
"整数运算将不再触发 :exc:`OverflowWarning`。:exc:`OverflowWarning` 警告将在 Python 2.5 中消失。"

#: ../../whatsnew/2.4.rst:897
msgid ""
"The interpreter gained a new switch, :option:`-m`, that takes a name, "
"searches for the corresponding  module on ``sys.path``, and runs the module "
"as a script. For example,  you can now run the Python profiler with ``python"
" -m profile``. (Contributed by Nick Coghlan.)"
msgstr ""
"解释器新增了一个开关 :option:`-m`，它接受一个名称，在 ``sys.path`` "
"上搜索相应的模块，并将该模块作为脚本运行。例如，你现在可以使用 ``python -m profile`` 运行 Python 分析器。（由 Nick "
"Coghlan 贡献。）"

#: ../../whatsnew/2.4.rst:902
msgid ""
"The ``eval(expr, globals, locals)`` and ``execfile(filename, globals, "
"locals)`` functions and the ``exec`` statement now accept any mapping type "
"for the *locals* parameter.  Previously this had to be a regular Python "
"dictionary.  (Contributed by Raymond Hettinger.)"
msgstr ""
"``eval(expr, globals, locals)`` 和 ``execfile(filename, globals, locals)`` "
"函数以及 ``exec`` 语句现在接受任何映射类型作为 *locals* 参数。以前这必须是一个普通的 Python 字典。（由 Raymond "
"Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:907
msgid ""
"The :func:`zip` built-in function and :func:`itertools.izip` now return an "
"empty list if called with no arguments. Previously they raised a "
":exc:`TypeError` exception.  This makes them more suitable for use with "
"variable length argument lists::"
msgstr ""
":func:`zip` 内置函数和 :func:`itertools.izip` 现在在无参数调用时返回一个空列表。以前它们会引发 "
":exc:`TypeError` 异常。这使得它们更适合用于可变长度参数列表::"

#: ../../whatsnew/2.4.rst:912
msgid ""
">>> def transpose(array):\n"
"...    return zip(*array)\n"
"...\n"
">>> transpose([(1,2,3), (4,5,6)])\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> transpose([])\n"
"[]"
msgstr ""
">>> def transpose(array):\n"
"...    return zip(*array)\n"
"...\n"
">>> transpose([(1,2,3), (4,5,6)])\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> transpose([])\n"
"[]"

#: ../../whatsnew/2.4.rst:922
msgid ""
"Encountering a failure while importing a module no longer leaves a partially"
" initialized module object in ``sys.modules``.  The incomplete module object"
" left behind would fool further imports of the same module into succeeding, "
"leading to confusing errors.   (Fixed by Tim Peters.)"
msgstr ""
"在导入模块时遇到失败将不再在 ``sys.modules`` "
"中留下部分初始化的模块对象。留下的不完整模块对象会导致后续导入同一模块时误以为成功，进而引发混淆的错误。（由 Tim Peters 修复。）"

#: ../../whatsnew/2.4.rst:927
msgid ""
":const:`None` is now a constant; code that binds a new value to  the name "
"``None`` is now a syntax error. (Contributed by Raymond Hettinger.)"
msgstr ""
":const:`None` 现在是一个常量；将一个新值绑定到名称 ``None`` 的代码现在会造成语法错误。 （由 Raymond Hettinger"
" 贡献。）"

#: ../../whatsnew/2.4.rst:934
msgid "Optimizations"
msgstr "性能优化"

#: ../../whatsnew/2.4.rst:936
msgid ""
"The inner loops for list and tuple slicing were optimized and now run about "
"one-third faster.  The inner loops for dictionaries were also optimized, "
"resulting in performance boosts for :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`iterkeys`, :meth:`itervalues`, and :meth:`iteritems`. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"列表和元组切片的内部循环经过优化，现在运行速度大约提高了三分之一。字典的内部循环也进行了优化，使得 "
":meth:`keys`、:meth:`values`、:meth:`items`、:meth:`iterkeys`、:meth:`itervalues`"
" 和 :meth:`iteritems` 的性能得到提升。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:942
msgid ""
"The machinery for growing and shrinking lists was optimized for speed and "
"for space efficiency.  Appending and popping from lists now runs faster due "
"to more efficient code paths and less frequent use of the underlying system "
":c:func:`realloc`.  List comprehensions also benefit.   :meth:`list.extend` "
"was also optimized and no longer converts its argument into a temporary list"
" before extending the base list.  (Contributed by Raymond Hettinger.)"
msgstr ""
"用于列表增长和缩小的机制进行了速度和空间效率的优化。由于更高效的代码路径和更少地使用底层系统 "
":c:func:`realloc`，向列表追加和弹出元素现在运行得更快。列表推导也从中受益。:meth:`list.extend` "
"也进行了优化，不再将其参数转换为临时列表后再扩展基础列表。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:949
msgid ""
":func:`list`, :func:`tuple`, :func:`map`, :func:`filter`, and :func:`zip` "
"now run several times faster with non-sequence arguments that supply a "
":meth:`__len__` method.  (Contributed by Raymond Hettinger.)"
msgstr ""
":func:`list`、:func:`tuple`、:func:`map`、:func:`filter` 和 :func:`zip` 在使用提供 "
":meth:`__len__` 方法的非序列参数时，现在运行速度提高了数倍。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:953
msgid ""
"The methods :meth:`list.__getitem__`, :meth:`dict.__getitem__`, and "
":meth:`dict.__contains__` are now implemented as :class:`method_descriptor` "
"objects rather than :class:`wrapper_descriptor` objects.  This form of  "
"access doubles their performance and makes them more suitable for use as "
"arguments to functionals: ``map(mydict.__getitem__, keylist)``. (Contributed"
" by Raymond Hettinger.)"
msgstr ""
":meth:`list.__getitem__`、:meth:`dict.__getitem__` 和 "
":meth:`dict.__contains__` 方法现在实现为 :class:`method_descriptor` 对象，而不是 "
":class:`wrapper_descriptor` "
"对象。这种访问形式使它们的性能翻倍，更适合作为函数式编程的参数使用：``map(mydict.__getitem__, keylist)``。（由 "
"Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:960
msgid ""
"Added a new opcode, ``LIST_APPEND``, that simplifies the generated bytecode "
"for list comprehensions and speeds them up by about a third.  (Contributed "
"by Raymond Hettinger.)"
msgstr ""
"添加了一个新的操作码 ``LIST_APPEND``，简化了列表推导生成的字节码，并使其速度提高了大约三分之一。（由 Raymond Hettinger"
" 贡献。）"

#: ../../whatsnew/2.4.rst:964
msgid ""
"The peephole bytecode optimizer has been improved to  produce shorter, "
"faster bytecode; remarkably, the resulting bytecode is  more readable.  "
"(Enhanced by Raymond Hettinger.)"
msgstr ""
"窥孔字节码优化器得到了改进，能够生成更短、更快的字节码；值得注意的是，生成的字节码更易读。（由 Raymond Hettinger 增强。）"

#: ../../whatsnew/2.4.rst:968
msgid ""
"String concatenations in statements of the form ``s = s + \"abc\"`` and ``s "
"+= \"abc\"`` are now performed more efficiently in certain circumstances.  "
"This optimization won't be present in other Python implementations such as "
"Jython, so you shouldn't rely on it; using the :meth:`join` method of "
"strings is still recommended when you want to efficiently glue a large "
"number of strings together. (Contributed by Armin Rigo.)"
msgstr ""
"在形式为 ``s = s + \"abc\"`` 和 ``s += \"abc\"`` "
"的语句中，字符串连接现在在某些情况下会更高效地执行。这种优化不会出现在其他Python实现中，例如Jython，因此你不应依赖它；当你需要高效地连接大量字符串时，仍然推荐使用字符串的"
" :meth:`join` 方法。（由Armin Rigo贡献。）"

#: ../../whatsnew/2.4.rst:975
msgid ""
"The net result of the 2.4 optimizations is that Python 2.4 runs the pystone "
"benchmark around 5% faster than Python 2.3 and 35% faster than Python 2.2. "
"(pystone is not a particularly good benchmark, but it's the most commonly "
"used measurement of Python's performance.  Your own applications may show "
"greater or smaller benefits from Python 2.4.)"
msgstr ""
"2.4版本优化的净结果是，Python 2.4运行pystone基准测试比Python 2.3快约5%，比Python "
"2.2快35%。（pystone并不是一个特别好的基准测试，但它是衡量Python性能最常用的方法。你的应用程序可能从Python "
"2.4中获得更大或更小的收益。）"

#: ../../whatsnew/2.4.rst:991
msgid "New, Improved, and Deprecated Modules"
msgstr "新增，改进和弃用的模块"

#: ../../whatsnew/2.4.rst:993
msgid ""
"As usual, Python's standard library received a number of enhancements and "
"bug fixes.  Here's a partial list of the most notable changes, sorted "
"alphabetically by module name. Consult the :file:`Misc/NEWS` file in the "
"source tree for a more complete list of changes, or look through the CVS "
"logs for all the details."
msgstr ""
"一如既往，Python的标准库获得了一些增强和错误修复。以下是一些最显著变化的部分列表，按模块名称字母顺序排序。请查阅源树中的 "
":file:`Misc/NEWS` 文件以获取更完整的变化列表，或通过CVS日志查看所有细节。"

#: ../../whatsnew/2.4.rst:998
msgid ""
"The :mod:`!asyncore` module's :func:`!loop` function now has a *count* "
"parameter that lets you perform a limited number of passes through the "
"polling loop.  The default is still to loop forever."
msgstr ""
":mod:`!asyncore` 模块的 :func:`!loop` 函数现在有一个 *count* "
"参数，允许你执行有限次数的轮询循环。默认情况下仍然是无限循环。"

#: ../../whatsnew/2.4.rst:1002
msgid ""
"The :mod:`base64` module now has more complete :rfc:`3548` support for "
"Base64, Base32, and Base16 encoding and decoding, including optional case "
"folding and optional alternative alphabets. (Contributed by Barry Warsaw.)"
msgstr ""
":mod:`base64` 模块现在更完整地支持 :rfc:`3548` "
"中的Base64、Base32和Base16编码和解码，包括可选的大小写折叠和可选的替代字母表。（由Barry Warsaw贡献。）"

#: ../../whatsnew/2.4.rst:1006
msgid ""
"The :mod:`bisect` module now has an underlying C implementation for improved"
" performance. (Contributed by Dmitry Vasiliev.)"
msgstr ":mod:`bisect` 模块现在有底层的C实现，以提升性能。（由Dmitry Vasiliev贡献。）"

#: ../../whatsnew/2.4.rst:1009
msgid ""
"The CJKCodecs collections of East Asian codecs, maintained by Hye-Shik "
"Chang, was integrated into 2.4.   The new encodings are:"
msgstr "由 Hye-Shik Chang 维护的东亚编解码器的 CJKCodecs 集合已集成到 2.4 中。新的编码为："

#: ../../whatsnew/2.4.rst:1012
msgid "Chinese (PRC): gb2312, gbk, gb18030, big5hkscs, hz"
msgstr "汉语（大陆）: gb2312, gbk, gb18030, big5hkscs, hz"

#: ../../whatsnew/2.4.rst:1014
msgid "Chinese (ROC): big5, cp950"
msgstr "汉语（台湾）: big5, cp950"

#: ../../whatsnew/2.4.rst:1016
msgid "Japanese: cp932, euc-jis-2004, euc-jp, euc-jisx0213, iso-2022-jp,"
msgstr "日语: cp932, euc-jis-2004, euc-jp, euc-jisx0213, iso-2022-jp,"

#: ../../whatsnew/2.4.rst:1017
msgid ""
"iso-2022-jp-1, iso-2022-jp-2, iso-2022-jp-3, iso-2022-jp-ext, "
"iso-2022-jp-2004, shift-jis, shift-jisx0213, shift-jis-2004"
msgstr ""
"iso-2022-jp-1, iso-2022-jp-2, iso-2022-jp-3, iso-2022-jp-ext, "
"iso-2022-jp-2004, shift-jis, shift-jisx0213, shift-jis-2004"

#: ../../whatsnew/2.4.rst:1020
msgid "Korean: cp949, euc-kr, johab, iso-2022-kr"
msgstr "韩语: cp949, euc-kr, johab, iso-2022-kr"

#: ../../whatsnew/2.4.rst:1022
msgid ""
"Some other new encodings were added: HP Roman8,  ISO_8859-11, ISO_8859-16, "
"PCTP-154, and TIS-620."
msgstr "添加了其他一些新的编码：HP Roman8、 ISO_8859-11、 ISO_8859-16、 PCTP-154 和 TIS-620。"

#: ../../whatsnew/2.4.rst:1025
msgid ""
"The UTF-8 and UTF-16 codecs now cope better with receiving partial input. "
"Previously the :class:`StreamReader` class would try to read more data, "
"making it impossible to resume decoding from the stream.  The :meth:`read` "
"method will now return as much data as it can and future calls will resume "
"decoding where previous ones left off.  (Implemented by Walter Dörwald.)"
msgstr ""
"UTF-8和UTF-16编解码器现在更好地处理接收部分输入的情况。以前，:class:`StreamReader` "
"类会尝试读取更多数据，使得无法从流中恢复解码。:meth:`read` "
"方法现在将返回尽可能多的数据，后续调用将从之前停止的地方恢复解码。（由Walter Dörwald实现。）"

#: ../../whatsnew/2.4.rst:1031
msgid ""
"There is a new :mod:`collections` module for  various specialized collection"
" datatypes.  Currently it contains just one type, :class:`deque`, a double-"
"ended queue that supports efficiently adding and removing elements from "
"either end::"
msgstr ""
"有一个新的 :mod:`collections` "
"模块，用于各种专业化的集合数据类型。目前它只包含一种类型，:class:`deque`，这是一个双端队列，支持高效地从两端添加和移除元素::"

#: ../../whatsnew/2.4.rst:1036
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')        # make a new deque with three items\n"
">>> d.append('j')           # add a new entry to the right side\n"
">>> d.appendleft('f')       # add a new entry to the left side\n"
">>> d                       # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
">>> d.pop()                 # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()             # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                 # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> 'h' in d                # search the deque\n"
"True"
msgstr ""
">>> from collections import deque\n"
">>> d = deque('ghi')        # 创建一个新的包含三个项目的 deque\n"
">>> d.append('j')           # 在右侧添加一个新的条目\n"
">>> d.appendleft('f')       # 在左侧添加一个新的条目\n"
">>> d                       # 显示 deque 的表示\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
">>> d.pop()                 # 返回并移除最右侧的条目\n"
"'j'\n"
">>> d.popleft()             # 返回并移除最左侧的条目\n"
"'f'\n"
">>> list(d)                 # 列出 deque 的内容\n"
"['g', 'h', 'i']\n"
">>> 'h' in d                # 搜索 deque\n"
"True"

#: ../../whatsnew/2.4.rst:1051
msgid ""
"Several modules, such as the :mod:`Queue` and :mod:`threading` modules, now "
"take advantage of :class:`collections.deque` for improved performance.  "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"多个模块，如 :mod:`Queue` 和 :mod:`threading` 模块，现在利用 :class:`collections.deque` "
"来提高性能。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:1055
msgid ""
"The :mod:`ConfigParser <configparser>` classes have been enhanced slightly. "
"The :meth:`~configparser.ConfigParser.read` method now returns a list of the"
" files that were successfully parsed, and the "
":meth:`~configparser.ConfigParser.set` method raises :exc:`TypeError` if "
"passed a *value* argument that isn't a string.   (Contributed by John "
"Belmonte and David Goodger.)"
msgstr ""
":mod:`ConfigParser <configparser>` "
"类略有增强。:meth:`~configparser.ConfigParser.read` 方法现在返回成功解析的文件列表，如果传递给 "
":meth:`~configparser.ConfigParser.set` 方法的 *value* 参数不是字符串，则会引发 "
":exc:`TypeError`。（由 John Belmonte 和 David Goodger 贡献。）"

#: ../../whatsnew/2.4.rst:1060
msgid ""
"The :mod:`curses` module now supports the ncurses extension "
":func:`use_default_colors`.  On platforms where the terminal supports "
"transparency, this makes it possible to use a transparent background. "
"(Contributed by Jörg Lehmann.)"
msgstr ""
":mod:`curses` 模块现在支持 ncurses 扩展 "
":func:`use_default_colors`。在终端支持透明度的平台上，这使得使用透明背景成为可能。（由 Jörg Lehmann 贡献。）"

#: ../../whatsnew/2.4.rst:1065
msgid ""
"The :mod:`difflib` module now includes an :class:`HtmlDiff` class that "
"creates an HTML table showing a side by side comparison of two versions of a"
" text. (Contributed by Dan Gass.)"
msgstr ""
":mod:`difflib` 模块现在包含一个 :class:`HtmlDiff` 类，该类创建一个 HTML 表格，显示两个文本版本的并列比较。（由 "
"Dan Gass 贡献。）"

#: ../../whatsnew/2.4.rst:1069
msgid ""
"The :mod:`email` package was updated to version 3.0,  which dropped various "
"deprecated APIs and removes support for Python versions earlier than 2.3.  "
"The 3.0 version of the package uses a new incremental parser for MIME "
"messages, available in the :mod:`email.FeedParser` module.  The new parser "
"doesn't require reading the entire message into memory, and doesn't raise "
"exceptions if a message is malformed; instead it records any problems in the"
"  :attr:`defect` attribute of the message.  (Developed by Anthony Baxter, "
"Barry Warsaw, Thomas Wouters, and others.)"
msgstr ""
":mod:`email` 包已更新至 3.0 版本，该版本移除了多种已弃用的 API，并取消了对于 Python 2.3 之前版本的支持。3.0 "
"版本的包使用了一个新的增量解析器来处理 MIME 消息，该解析器位于 :mod:`email.FeedParser` "
"模块中。新解析器不需要将整个消息读入内存，且在消息格式不正确时不会抛出异常；相反，它会将任何问题记录在消息的 :attr:`defect` 属性中。（由"
" Anthony Baxter、Barry Warsaw、Thomas Wouters 等人开发。）"

#: ../../whatsnew/2.4.rst:1078
msgid ""
"The :mod:`heapq` module has been converted to C.  The resulting tenfold "
"improvement in speed makes the module suitable for handling high volumes of "
"data.  In addition, the module has two new functions :func:`nlargest` and "
":func:`nsmallest` that use heaps to find the N largest or smallest values in"
" a dataset without the expense of a full sort.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`heapq` 模块已被转换为 C 语言实现。由此带来的速度提升达十倍，使得该模块适合处理大量数据。此外，该模块新增了两个函数 "
":func:`nlargest` 和 :func:`nsmallest`，它们使用堆来查找数据集中的 N 个最大或最小值，而无需进行完整的排序。（由 "
"Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:1084
msgid ""
"The :mod:`httplib <http>` module now contains constants for HTTP status "
"codes defined in various HTTP-related RFC documents.  Constants have names "
"such as :const:`OK`, :const:`CREATED`, :const:`CONTINUE`, and "
":const:`MOVED_PERMANENTLY`; use pydoc to get a full list.  (Contributed by "
"Andrew Eland.)"
msgstr ""
":mod:`httplib <http>` 模块现在包含了在多个与 HTTP 相关的 RFC 文档中定义的 HTTP 状态码常量。常量名称如 "
":const:`OK`、:const:`CREATED`、:const:`CONTINUE` 和 "
":const:`MOVED_PERMANENTLY`；使用 pydoc 可获取完整列表。（由 Andrew Eland 贡献。）"

#: ../../whatsnew/2.4.rst:1090
msgid ""
"The :mod:`imaplib` module now supports IMAP's THREAD command (contributed by"
" Yves Dionne) and new :meth:`deleteacl` and :meth:`myrights` methods "
"(contributed by Arnaud Mazin)."
msgstr ""
":mod:`imaplib` 模块现在支持 IMAP 的 THREAD 命令（由 Yves Dionne 贡献）以及新的 "
":meth:`deleteacl` 和 :meth:`myrights` 方法（由 Arnaud Mazin 贡献）。"

#: ../../whatsnew/2.4.rst:1094
msgid ""
"The :mod:`itertools` module gained a ``groupby(iterable[, *func*])`` "
"function. *iterable* is something that can be iterated over to return a "
"stream of elements, and the optional *func* parameter is a function that "
"takes an element and returns a key value; if omitted, the key is simply the "
"element itself.  :func:`groupby` then groups the elements into subsequences "
"which have matching values of the key, and returns a series of 2-tuples "
"containing the key value and an iterator over the subsequence."
msgstr ""
":mod:`itertools` 模块新增了 ``groupby(iterable[, *func*])`` 函数。*iterable* "
"是可以迭代以返回元素流的对象，可选的 *func* "
"参数是一个函数，它接受一个元素并返回一个键值；如果省略，键即为元素本身。:func:`groupby` "
"然后将元素分组为具有匹配键值的子序列，并返回一系列包含键值和子序列迭代器的 2 元组。"

#: ../../whatsnew/2.4.rst:1102
msgid ""
"Here's an example to make this clearer.  The *key* function simply returns "
"whether a number is even or odd, so the result of :func:`groupby` is to "
"return consecutive runs of odd or even numbers. ::"
msgstr ""
"以下是一个示例，以便更清晰地说明这一点。*key* 函数 simply 返回一个数字是奇数还是偶数，因此 :func:`groupby` "
"的结果就是返回连续的奇数或偶数序列。::"

#: ../../whatsnew/2.4.rst:1106
msgid ""
">>> import itertools\n"
">>> L = [2, 4, 6, 7, 8, 9, 11, 12, 14]\n"
">>> for key_val, it in itertools.groupby(L, lambda x: x % 2):\n"
"...    print key_val, list(it)\n"
"...\n"
"0 [2, 4, 6]\n"
"1 [7]\n"
"0 [8]\n"
"1 [9, 11]\n"
"0 [12, 14]\n"
">>>"
msgstr ""
">>> import itertools\n"
">>> L = [2, 4, 6, 7, 8, 9, 11, 12, 14]\n"
">>> for key_val, it in itertools.groupby(L, lambda x: x % 2):\n"
"...    print key_val, list(it)\n"
"...\n"
"0 [2, 4, 6]\n"
"1 [7]\n"
"0 [8]\n"
"1 [9, 11]\n"
"0 [12, 14]\n"
">>>"

#: ../../whatsnew/2.4.rst:1118
msgid ""
":func:`groupby` is typically used with sorted input.  The logic for "
":func:`groupby` is similar to the Unix ``uniq`` filter which makes it handy "
"for eliminating, counting, or identifying duplicate elements::"
msgstr ""
":func:`groupby` 通常用于处理已排序的输入。:func:`groupby` 的逻辑类似于 Unix 的 ``uniq`` "
"过滤器，这使得它非常适合用于消除、计数或识别重复元素::"

#: ../../whatsnew/2.4.rst:1122
msgid ""
">>> word = 'abracadabra'\n"
">>> letters = sorted(word)   # Turn string into a sorted list of letters\n"
">>> letters\n"
"['a', 'a', 'a', 'a', 'a', 'b', 'b', 'c', 'd', 'r', 'r']\n"
">>> for k, g in itertools.groupby(letters):\n"
"...    print k, list(g)\n"
"...\n"
"a ['a', 'a', 'a', 'a', 'a']\n"
"b ['b', 'b']\n"
"c ['c']\n"
"d ['d']\n"
"r ['r', 'r']\n"
">>> # List unique letters\n"
">>> [k for k, g in groupby(letters)]\n"
"['a', 'b', 'c', 'd', 'r']\n"
">>> # Count letter occurrences\n"
">>> [(k, len(list(g))) for k, g in groupby(letters)]\n"
"[('a', 5), ('b', 2), ('c', 1), ('d', 1), ('r', 2)]"
msgstr ""
">>> word = 'abracadabra'\n"
">>> letters = sorted(word)   # 将字符串转换为按字母排序的列表\n"
">>> letters\n"
"['a', 'a', 'a', 'a', 'a', 'b', 'b', 'c', 'd', 'r', 'r']\n"
">>> for k, g in itertools.groupby(letters):\n"
"...    print k, list(g)\n"
"...\n"
"a ['a', 'a', 'a', 'a', 'a']\n"
"b ['b', 'b']\n"
"c ['c']\n"
"d ['d']\n"
"r ['r', 'r']\n"
">>> # 列出唯一字母\n"
">>> [k for k, g in groupby(letters)]\n"
"['a', 'b', 'c', 'd', 'r']\n"
">>> # 计算字母出现次数\n"
">>> [(k, len(list(g))) for k, g in groupby(letters)]\n"
"[('a', 5), ('b', 2), ('c', 1), ('d', 1), ('r', 2)]"

#: ../../whatsnew/2.4.rst:1141
msgid "(Contributed by Hye-Shik Chang.)"
msgstr "（由 Hye-Shik Chang 贡献。）"

#: ../../whatsnew/2.4.rst:1143
msgid ""
":mod:`itertools` also gained a function named ``tee(iterator, N)`` that "
"returns *N* independent iterators that replicate *iterator*.  If *N* is "
"omitted, the default is 2. ::"
msgstr ""
":mod:`itertools` 还增加了一个名为 ``tee(iterator, N)`` 的函数，它返回 *N* 个独立迭代器，这些迭代器复制 "
"*iterator*。如果省略 *N*，默认值为 2。::"

#: ../../whatsnew/2.4.rst:1147
msgid ""
">>> L = [1,2,3]\n"
">>> i1, i2 = itertools.tee(L)\n"
">>> i1,i2\n"
"(<itertools.tee object at 0x402c2080>, <itertools.tee object at 0x402c2090>)\n"
">>> list(i1)               # Run the first iterator to exhaustion\n"
"[1, 2, 3]\n"
">>> list(i2)               # Run the second iterator to exhaustion\n"
"[1, 2, 3]"
msgstr ""
">>> L = [1,2,3]\n"
">>> i1, i2 = itertools.tee(L)\n"
">>> i1,i2\n"
"(<itertools.tee object at 0x402c2080>, <itertools.tee object at 0x402c2090>)\n"
">>> list(i1)               # 运行第一个迭代器直到耗尽\n"
"[1, 2, 3]\n"
">>> list(i2)               # 运行第二个迭代器直到耗尽\n"
"[1, 2, 3]"

#: ../../whatsnew/2.4.rst:1156
msgid ""
"Note that :func:`tee` has to keep copies of the values returned  by the "
"iterator; in the worst case, it may need to keep all of them.   This should "
"therefore be used carefully if the leading iterator can run far ahead of the"
" trailing iterator in a long stream of inputs. If the separation is large, "
"then you might as well use  :func:`list` instead.  When the iterators track "
"closely with one another, :func:`tee` is ideal.  Possible applications "
"include bookmarking, windowing, or lookahead iterators. (Contributed by "
"Raymond Hettinger.)"
msgstr ""
"请注意，:func:`tee` "
"需要保留由迭代器返回的值的副本；在最坏的情况下，它可能需要保留所有这些值。因此，如果领先迭代器在长输入流中远远领先于滞后迭代器，应谨慎使用此功能。如果分离较大，那么您可能还不如使用"
" :func:`list`。当迭代器彼此紧密跟踪时，:func:`tee` 是理想的。可能的用例包括书签、窗口化或前瞻迭代器。（由 Raymond "
"Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:1165
msgid ""
"A number of functions were added to the :mod:`locale`  module, such as "
":func:`bind_textdomain_codeset` to specify a particular encoding and a "
"family of :func:`!l\\*gettext` functions that return messages in the chosen "
"encoding. (Contributed by Gustavo Niemeyer.)"
msgstr ""
":mod:`locale` 模块添加了一些函数，例如 :func:`bind_textdomain_codeset` 用于指定特定编码，以及一系列 "
":func:`!l\\*gettext` 函数，这些函数返回所选编码中的消息。（由 Gustavo Niemeyer 贡献。）"

#: ../../whatsnew/2.4.rst:1170
msgid ""
"Some keyword arguments were added to the :mod:`logging` package's "
":func:`basicConfig` function to simplify log configuration.  The default "
"behavior is to log messages to standard error, but various keyword arguments"
" can be specified to log to a particular file, change the logging format, or"
" set the logging level. For example::"
msgstr ""
":mod:`logging` 包的 :func:`basicConfig` "
"函数添加了一些关键字参数，以简化日志配置。默认行为是将消息记录到标准错误，但可以指定各种关键字参数以将日志记录到特定文件、更改日志格式或设置日志级别。例如："

#: ../../whatsnew/2.4.rst:1176
msgid ""
"import logging\n"
"logging.basicConfig(filename='/var/log/application.log',\n"
"    level=0,  # Log all messages\n"
"    format='%(levelname):%(process):%(thread):%(message)')"
msgstr ""
"import logging\n"
"logging.basicConfig(filename='/var/log/application.log',\n"
"    level=0,  # 记录所有消息\n"
"    format='%(levelname):%(process):%(thread):%(message)')"

#: ../../whatsnew/2.4.rst:1181
msgid ""
"Other additions to the :mod:`logging` package include a ``log(level, msg)`` "
"convenience method, as well as a :class:`TimedRotatingFileHandler` class "
"that rotates its log files at a timed interval.  The module already had "
":class:`RotatingFileHandler`, which rotated logs once the file exceeded a "
"certain size.  Both classes derive from a new :class:`BaseRotatingHandler` "
"class that can be used to implement other rotating handlers."
msgstr ""
":mod:`logging` 包的其他添加内容包括一个 ``log(level, msg)`` 便捷方法，以及一个 "
":class:`TimedRotatingFileHandler` 类，该类在定时间隔旋转其日志文件。模块已经有一个 "
":class:`RotatingFileHandler`，它在文件超过特定大小时旋转日志。这两个类都派生自一个新的 "
":class:`BaseRotatingHandler` 类，该类可用于实现其他旋转处理程序。"

#: ../../whatsnew/2.4.rst:1188
msgid "(Changes implemented by Vinay Sajip.)"
msgstr "（更改由 Vinay Sajip 实现。）"

#: ../../whatsnew/2.4.rst:1190
msgid ""
"The :mod:`marshal` module now shares interned strings on unpacking a  data "
"structure.  This may shrink the size of certain pickle strings, but the "
"primary effect is to make :file:`.pyc` files significantly smaller. "
"(Contributed by Martin von Löwis.)"
msgstr ""
":mod:`marshal` 模块现在在解包数据结构时共享内部字符串。这可能会缩小某些 pickle 字符串的大小，但主要效果是使 "
":file:`.pyc` 文件显著变小。（由 Martin von Löwis 贡献。）"

#: ../../whatsnew/2.4.rst:1195
msgid ""
"The :mod:`!nntplib` module's :class:`NNTP` class gained :meth:`description` "
"and :meth:`descriptions` methods to retrieve  newsgroup descriptions for a "
"single group or for a range of groups. (Contributed by Jürgen A. Erhard.)"
msgstr ""
":mod:`!nntplib` 模块的 :class:`NNTP` 类新增了 :meth:`description` 和 "
":meth:`descriptions` 方法，用于检索单个新闻组或一系列新闻组的描述。（由 Jürgen A. Erhard 贡献。）"

#: ../../whatsnew/2.4.rst:1199
msgid ""
"Two new functions were added to the :mod:`operator` module, "
"``attrgetter(attr)`` and ``itemgetter(index)``. Both functions return "
"callables that take a single argument and return the corresponding attribute"
" or item; these callables make excellent data extractors when used with "
":func:`map` or :func:`sorted`.  For example::"
msgstr ""
":mod:`operator` 模块新增了两个函数，``attrgetter(attr)`` 和 "
"``itemgetter(index)``。这两个函数都返回一个接受单个参数并返回相应属性或项的可调用对象；这些可调用对象在与 :func:`map` "
"或 :func:`sorted` 一起使用时，是非常优秀的数据提取器。例如："

#: ../../whatsnew/2.4.rst:1205
msgid ""
">>> L = [('c', 2), ('d', 1), ('a', 4), ('b', 3)]\n"
">>> map(operator.itemgetter(0), L)\n"
"['c', 'd', 'a', 'b']\n"
">>> map(operator.itemgetter(1), L)\n"
"[2, 1, 4, 3]\n"
">>> sorted(L, key=operator.itemgetter(1)) # Sort list by second tuple item\n"
"[('d', 1), ('c', 2), ('b', 3), ('a', 4)]"
msgstr ""
">>> L = [('c', 2), ('d', 1), ('a', 4), ('b', 3)]\n"
">>> map(operator.itemgetter(0), L)\n"
"['c', 'd', 'a', 'b']\n"
">>> map(operator.itemgetter(1), L)\n"
"[2, 1, 4, 3]\n"
">>> sorted(L, key=operator.itemgetter(1)) # 按元组的第二个项对列表进行排序\n"
"[('d', 1), ('c', 2), ('b', 3), ('a', 4)]"

#: ../../whatsnew/2.4.rst:1215
msgid ""
"The :mod:`optparse` module was updated in various ways.  The module now "
"passes its messages through :func:`gettext.gettext`, making it possible to "
"internationalize Optik's help and error messages.  Help messages for options"
" can now include the string ``'%default'``, which will be replaced by the "
"option's default value.  (Contributed by Greg Ward.)"
msgstr ""
":mod:`optparse` 模块进行了多项更新。该模块现在通过 :func:`gettext.gettext` 传递其消息，使得可以国际化 "
"Optik 的帮助和错误消息。选项的帮助消息现在可以包含字符串 ``'%default'``，该字符串将被选项的默认值替换。（由 Greg Ward "
"贡献。）"

#: ../../whatsnew/2.4.rst:1221
msgid ""
"The long-term plan is to deprecate the :mod:`!rfc822` module in some future "
"Python release in favor of the :mod:`email` package. To this end, the "
":func:`email.Utils.formatdate <email.utils.formatdate>` function has been "
"changed to make it usable as a replacement for :func:`!rfc822.formatdate`.  "
"You may want to write new e-mail processing code with this in mind.  (Change"
" implemented by Anthony Baxter.)"
msgstr ""
"长期计划是在未来的某个 Python 版本中弃用 :mod:`!rfc822` 模块，转而使用 :mod:`email` "
"包。为此，:func:`email.Utils.formatdate <email.utils.formatdate>` 函数已被修改，使其可以作为 "
":func:`!rfc822.formatdate` 的替代。您在编写新的电子邮件处理代码时可能需要考虑这一点。（由 Anthony Baxter "
"实施。）"

#: ../../whatsnew/2.4.rst:1227
msgid ""
"A new ``urandom(n)`` function was added to the :mod:`os` module, returning a"
" string containing *n* bytes of random data.  This function provides access "
"to platform-specific sources of randomness such as :file:`/dev/urandom` on "
"Linux or the Windows CryptoAPI.  (Contributed by Trevor Perrin.)"
msgstr ""
":mod:`os` 模块新增了 ``urandom(n)`` 函数，返回一个包含 *n* 字节随机数据的字符串。该函数提供了对平台特定随机源（如 "
"Linux 上的 :file:`/dev/urandom` 或 Windows CryptoAPI）的访问。（由 Trevor Perrin 贡献。）"

#: ../../whatsnew/2.4.rst:1232
msgid ""
"Another new function: ``os.path.lexists(path)``  returns true if the file "
"specified by *path* exists, whether or not it's a symbolic link.  This "
"differs from the existing ``os.path.exists(path)`` function, which returns "
"false if *path* is a symlink that points to a destination that doesn't "
"exist. (Contributed by Beni Cherniavsky.)"
msgstr ""
"另一个新函数：``os.path.lexists(path)`` 如果指定的文件存在（无论是否为符号链接）则返回 true。这与现有的 "
"``os.path.exists(path)`` 函数不同，后者在 *path* 是指向不存在目标的符号链接时返回 false。（由 Beni "
"Cherniavsky 贡献。）"

#: ../../whatsnew/2.4.rst:1238
msgid ""
"A new :func:`getsid` function was added to the :mod:`posix` module that "
"underlies the :mod:`os` module. (Contributed by J. Raynor.)"
msgstr ""
"在 :mod:`os` 之下 :mod:`posix` 模块中新增了一个 :func:`getsid` 函数。 （由 J. Raynor 贡献。）"

#: ../../whatsnew/2.4.rst:1241
msgid ""
"The :mod:`poplib` module now supports POP over SSL.  (Contributed by Hector "
"Urtubia.)"
msgstr ":mod:`poplib` 模块现在已支持 SSL 上的 POP。 （由 Hector Urtubia 贡献。）"

#: ../../whatsnew/2.4.rst:1244
msgid ""
"The :mod:`profile` module can now profile C extension functions. "
"(Contributed by Nick Bastin.)"
msgstr "现在 :mod:`profile` 模块将可对 C 扩展函数执行性能分析。 （由 Nick Bastin 贡献。）"

#: ../../whatsnew/2.4.rst:1247
msgid ""
"The :mod:`random` module has a new method called ``getrandbits(N)`` that "
"returns a long integer *N* bits in length.  The existing :meth:`randrange` "
"method now uses :meth:`getrandbits` where appropriate, making generation of "
"arbitrarily large random numbers more efficient.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`random` 模块有一个新方法 ``getrandbits(N)``，返回一个长度为 *N* 位的长整数。现有的 "
":meth:`randrange` 方法现在在适当的情况下使用 :meth:`getrandbits`，使得生成任意大的随机数更加高效。（由 "
"Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:1253
msgid ""
"The regular expression language accepted by the :mod:`re` module was "
"extended with simple conditional expressions, written as ``(?(group)A|B)``."
"  *group* is either a numeric group ID or a group name defined with "
"``(?P<group>...)`` earlier in the expression.  If the specified group "
"matched, the regular expression pattern *A* will be tested against the "
"string; if the group didn't match, the pattern *B* will be used instead. "
"(Contributed by Gustavo Niemeyer.)"
msgstr ""
":mod:`re` 模块接受的正则表达式语言扩展了简单的条件表达式，写作 ``(?(group)A|B)``。*group* 可以是数字组 ID 或用 "
"``(?P<group>...)`` 在表达式中提前定义的组名。如果指定的组匹配，正则表达式模式 *A* 将被用于测试字符串；如果组未匹配，则使用模式 "
"*B*。（由 Gustavo Niemeyer 贡献。）"

#: ../../whatsnew/2.4.rst:1260
msgid ""
"The :mod:`re` module is also no longer recursive, thanks to a massive amount"
" of work by Gustavo Niemeyer.  In a recursive regular expression engine, "
"certain patterns result in a large amount of C stack space being consumed, "
"and it was possible to overflow the stack. For example, if you matched a "
"30000-byte string of ``a`` characters against the expression ``(a|b)+``, one"
" stack frame was consumed per character.  Python 2.3 tried to check for "
"stack overflow and raise a :exc:`RuntimeError` exception, but certain "
"patterns could sidestep the checking and if you were unlucky Python could "
"segfault. Python 2.4's regular expression engine can match this pattern "
"without problems."
msgstr ""
"由于 Gustavo Niemeyer 大量工作，:mod:`re` 模块也不再是递归的。在递归正则表达式引擎中，某些模式会导致大量 C "
"栈空间被消耗，甚至可能溢出栈。例如，如果你将一个 30000 字节的 ``a`` 字符串与表达式 ``(a|b)+`` "
"匹配，每个字符会消耗一个栈帧。Python 2.3 试图检查栈溢出并抛出 :exc:`RuntimeError` "
"异常，但某些模式可以绕过检查，如果你运气不好，Python 可能会段错误。Python 2.4 的正则表达式引擎可以无问题地匹配此模式。"

#: ../../whatsnew/2.4.rst:1270
msgid ""
"The :mod:`signal` module now performs tighter error-checking on the "
"parameters to the :func:`signal.signal` function.  For example, you can't "
"set a handler on the :const:`SIGKILL` signal; previous versions of Python "
"would quietly accept this, but 2.4 will raise a :exc:`RuntimeError` "
"exception."
msgstr ""
":mod:`signal` 模块现在对 :func:`signal.signal` 函数的参数进行更严格的错误检查。例如，你不能在 "
":const:`SIGKILL` 信号上设置处理程序；之前的 Python 版本会默默接受这一点，但 2.4 版本将引发一个 "
":exc:`RuntimeError` 异常。"

#: ../../whatsnew/2.4.rst:1275
msgid ""
"Two new functions were added to the :mod:`socket` module. :func:`socketpair`"
" returns a pair of connected sockets and ``getservbyport(port)`` looks up "
"the service name for a given port number. (Contributed by Dave Cole and "
"Barry Warsaw.)"
msgstr ""
":mod:`socket` 模块新增了两个函数。:func:`socketpair` 返回一对已连接的套接字，而 "
"``getservbyport(port)`` 用于查找给定端口号的服务名称。（由 Dave Cole 和 Barry Warsaw 贡献。）"

#: ../../whatsnew/2.4.rst:1280
msgid ""
"The :func:`sys.exitfunc` function has been deprecated.  Code should be using"
" the existing :mod:`atexit` module, which correctly handles calling multiple"
" exit functions.  Eventually :func:`sys.exitfunc` will become a purely "
"internal interface, accessed only by :mod:`atexit`."
msgstr ""
":func:`sys.exitfunc` 函数已被弃用。代码应使用现有的 :mod:`atexit` 模块，它能正确处理调用多个退出函数。最终 "
":func:`sys.exitfunc` 将成为一个纯内部接口，仅由 :mod:`atexit` 访问。"

#: ../../whatsnew/2.4.rst:1285
msgid ""
"The :mod:`tarfile` module now generates GNU-format tar files by default. "
"(Contributed by Lars Gustäbel.)"
msgstr "现在 :mod:`tarfile` 模块默认将生成 GNU 格式的 tar 文件。 （由 Lars Gustäbel 贡献。）"

#: ../../whatsnew/2.4.rst:1288
msgid ""
"The :mod:`threading` module now has an elegantly simple way to support "
"thread-local data.  The module contains a :class:`local` class whose "
"attribute values are local to different threads. ::"
msgstr ""
":mod:`threading` 模块现在有了一种优雅简洁的方式来支持线程本地数据。该模块包含一个 :class:`local` "
"类，其属性值对不同线程是本地的。::"

#: ../../whatsnew/2.4.rst:1292
msgid ""
"import threading\n"
"\n"
"data = threading.local()\n"
"data.number = 42\n"
"data.url = ('www.python.org', 80)"
msgstr ""
"import threading\n"
"\n"
"data = threading.local()\n"
"data.number = 42\n"
"data.url = ('www.python.org', 80)"

#: ../../whatsnew/2.4.rst:1298
msgid ""
"Other threads can assign and retrieve their own values for the "
":attr:`number` and :attr:`url` attributes.  You can subclass :class:`local` "
"to initialize attributes or to add methods. (Contributed by Jim Fulton.)"
msgstr ""
"其他线程可以为 :attr:`number` 和 :attr:`url` 属性分配和检索它们自己的值。你可以子类化 :class:`local` "
"来初始化属性或添加方法。（由 Jim Fulton 贡献。）"

#: ../../whatsnew/2.4.rst:1302
msgid ""
"The :mod:`timeit` module now automatically disables periodic garbage "
"collection during the timing loop.  This change makes consecutive timings "
"more comparable.  (Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`timeit` 模块现在在计时循环中自动禁用周期性垃圾收集。这一改变使得连续计时更具可比性。（由 Raymond Hettinger "
"贡献。）"

#: ../../whatsnew/2.4.rst:1306
msgid ""
"The :mod:`weakref` module now supports a wider variety of objects including "
"Python functions, class instances, sets, frozensets, deques, arrays, files, "
"sockets, and regular expression pattern objects. (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`weakref` 模块现在支持更多种类的对象，包括 Python "
"函数、类实例、集合、冻结集合、双端队列、数组、文件、套接字和正则表达式模式对象。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.4.rst:1311
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module now supports a multi-call "
"extension for transmitting multiple XML-RPC calls in a single HTTP "
"operation. (Contributed by Brian Quinlan.)"
msgstr ""
":mod:`xmlrpclib <xmlrpc.client>` 模块现在支持多调用扩展，用于在单个 HTTP 操作中传输多个 XML-RPC "
"调用。（由 Brian Quinlan 贡献。）"

#: ../../whatsnew/2.4.rst:1315
msgid ""
"The :mod:`mpz`, :mod:`rotor`, and :mod:`xreadlines` modules have  been "
"removed."
msgstr ":mod:`mpz`, :mod:`rotor` 和 :mod:`xreadlines` 模块已被移除。"

#: ../../whatsnew/2.4.rst:1324
msgid "cookielib"
msgstr "cookielib"

#: ../../whatsnew/2.4.rst:1326
msgid ""
"The :mod:`cookielib <http.cookiejar>` library supports client-side handling "
"for HTTP cookies, mirroring the :mod:`Cookie <http.cookies>` module's "
"server-side cookie support. Cookies are stored in cookie jars; the library "
"transparently stores cookies offered by the web server in the cookie jar, "
"and fetches the cookie from the jar when connecting to the server. As in web"
" browsers, policy objects control whether cookies are accepted or not."
msgstr ""
":mod:`cookielib <http.cookiejar>` 库支持客户端处理 HTTP Cookie，与 :mod:`Cookie "
"<http.cookies>` 模块的服務器端 Cookie 支持相呼应。Cookie 存储在 Cookie 罐中；该库透明地将网页服务器提供的 "
"Cookie 存储在 Cookie 罐中，并在连接到服务器时从罐中提取 Cookie。与网页浏览器一样，策略对象控制是否接受 Cookie。"

#: ../../whatsnew/2.4.rst:1333
msgid ""
"In order to store cookies across sessions, two implementations of cookie "
"jars are provided: one that stores cookies in the Netscape format so "
"applications can use the Mozilla or Lynx cookie files, and one that stores "
"cookies in the same format as the Perl libwww library."
msgstr ""
"为了跨会话存储 Cookie，提供了两种 Cookie 罐的实现：一种以 Netscape 格式存储 Cookie，以便应用程序可以使用 Mozilla"
" 或 Lynx 的 Cookie 文件，另一种以与 Perl libwww 库相同的格式存储 Cookie。"

#: ../../whatsnew/2.4.rst:1338
msgid ""
":mod:`urllib2 <urllib.request>` has been changed to interact with "
":mod:`cookielib <http.cookiejar>`: :class:`HTTPCookieProcessor` manages a "
"cookie jar that is used when accessing URLs."
msgstr ""
":mod:`urllib2 <urllib.request>` 已更改以与 :mod:`cookielib <http.cookiejar>` "
"交互：:class:`HTTPCookieProcessor` 管理一个在访问 URL 时使用的 Cookie 罐。"

#: ../../whatsnew/2.4.rst:1342
msgid "This module was contributed by John J. Lee."
msgstr "该模块由  John J. Lee 贡献。"

#: ../../whatsnew/2.4.rst:1348
msgid "doctest"
msgstr "doctest"

#: ../../whatsnew/2.4.rst:1350
msgid ""
"The :mod:`doctest` module underwent considerable refactoring thanks to "
"Edward Loper and Tim Peters.  Testing can still be as simple as running "
":func:`doctest.testmod`, but the refactorings allow customizing the module's"
" operation in various ways"
msgstr ""
"由于 Edward Loper 和 Tim Peters 的贡献，:mod:`doctest` 模块进行了大量重构。测试仍然可以简单到只需运行 "
":func:`doctest.testmod`，但重构允许以各种方式自定义模块的操作。"

#: ../../whatsnew/2.4.rst:1355
msgid ""
"The new :class:`DocTestFinder` class extracts the tests from a given  "
"object's docstrings::"
msgstr "新的 :class:`DocTestFinder` 类从给定对象的文档字符串中提取测试："

#: ../../whatsnew/2.4.rst:1358
msgid ""
"def f (x, y):\n"
"    \"\"\">>> f(2,2)\n"
"4\n"
">>> f(3,2)\n"
"6\n"
"    \"\"\"\n"
"    return x*y\n"
"\n"
"finder = doctest.DocTestFinder()\n"
"\n"
"# Get list of DocTest instances\n"
"tests = finder.find(f)"
msgstr ""
"def f (x, y):\n"
"    \"\"\">>> f(2,2)\n"
"4\n"
">>> f(3,2)\n"
"6\n"
"    \"\"\"\n"
"    return x*y\n"
"\n"
"finder = doctest.DocTestFinder()\n"
"\n"
"# 获取 DocTest 实例列表\n"
"tests = finder.find(f)"

#: ../../whatsnew/2.4.rst:1371
msgid ""
"The new :class:`DocTestRunner` class then runs individual tests and can "
"produce a summary of the results::"
msgstr "新的 :class:`DocTestRunner` 类然后运行单个测试并可以生成结果摘要："

#: ../../whatsnew/2.4.rst:1374
msgid ""
"runner = doctest.DocTestRunner()\n"
"for t in tests:\n"
"    tried, failed = runner.run(t)\n"
"\n"
"runner.summarize(verbose=1)"
msgstr ""
"runner = doctest.DocTestRunner()\n"
"for t in tests:\n"
"    tried, failed = runner.run(t)\n"
"\n"
"runner.summarize(verbose=1)"

#: ../../whatsnew/2.4.rst:1380
msgid "The above example produces the following output::"
msgstr "上述示例生成以下输出："

#: ../../whatsnew/2.4.rst:1382
msgid ""
"1 items passed all tests:\n"
"   2 tests in f\n"
"2 tests in 1 items.\n"
"2 passed and 0 failed.\n"
"Test passed."
msgstr ""
"1 项通过了所有测试：\n"
"   2 个测试在 f 中\n"
"1 项中的 2 个测试。\n"
"2 个通过，0 个失败。\n"
"测试通过。"

#: ../../whatsnew/2.4.rst:1388
msgid ""
":class:`DocTestRunner` uses an instance of the :class:`OutputChecker` class "
"to compare the expected output with the actual output.  This class takes a "
"number of different flags that customize its behaviour; ambitious users can "
"also write a completely new subclass of :class:`OutputChecker`."
msgstr ""
":class:`DocTestRunner` 使用一个 :class:`OutputChecker` "
"类的实例来比较预期输出和实际输出。这个类接受多个不同的标志来定制其行为；有野心的用户也可以编写一个全新的 :class:`OutputChecker` "
"子类。"

#: ../../whatsnew/2.4.rst:1393
msgid ""
"The default output checker provides a number of handy features. For example,"
" with the :const:`doctest.ELLIPSIS` option flag, an ellipsis (``...``) in "
"the expected output matches any substring,  making it easier to accommodate "
"outputs that vary in minor ways::"
msgstr ""
"默认的输出检查器提供了一些方便的功能。例如，使用 :const:`doctest.ELLIPSIS` "
"选项标志，预期输出中的省略号（``...``）可以匹配任何子字符串，这使得更容易适应在细小方面有所变化的输出::"

#: ../../whatsnew/2.4.rst:1398
msgid ""
"def o (n):\n"
"    \"\"\">>> o(1)\n"
"<__main__.C instance at 0x...>\n"
">>>\n"
"\"\"\""
msgstr ""
"def o (n):\n"
"    \"\"\">>> o(1)\n"
"<__main__.C instance at 0x...>\n"
">>>\n"
"\"\"\""

#: ../../whatsnew/2.4.rst:1404
msgid "Another special string, ``<BLANKLINE>``, matches a blank line::"
msgstr "另一个特殊字符串，``<BLANKLINE>``, 匹配一个空行::"

#: ../../whatsnew/2.4.rst:1406
msgid ""
"def p (n):\n"
"    \"\"\">>> p(1)\n"
"<BLANKLINE>\n"
">>>\n"
"\"\"\""
msgstr ""
"def p (n):\n"
"    \"\"\">>> p(1)\n"
"<BLANKLINE>\n"
">>>\n"
"\"\"\""

#: ../../whatsnew/2.4.rst:1412
msgid ""
"Another new capability is producing a diff-style display of the output by "
"specifying the :const:`doctest.REPORT_UDIFF` (unified diffs), "
":const:`doctest.REPORT_CDIFF` (context diffs), or "
":const:`doctest.REPORT_NDIFF` (delta-style) option flags.  For example::"
msgstr ""
"另一个新功能是通过指定 :const:`doctest.REPORT_UDIFF` "
"(统一差异)、:const:`doctest.REPORT_CDIFF` (上下文差异) 或 :const:`doctest.REPORT_NDIFF`"
" (增量式差异) 选项标志，生成输出差异风格的显示。 例如::"

#: ../../whatsnew/2.4.rst:1417
msgid ""
"def g (n):\n"
"    \"\"\">>> g(4)\n"
"here\n"
"is\n"
"a\n"
"lengthy\n"
">>>\"\"\"\n"
"    L = 'here is a rather lengthy list of words'.split()\n"
"    for word in L[:n]:\n"
"        print word"
msgstr ""
"def g (n):\n"
"    \"\"\">>> g(4)\n"
"here\n"
"is\n"
"a\n"
"lengthy\n"
">>>\"\"\"\n"
"    L = 'here is a rather lengthy list of words'.split()\n"
"    for word in L[:n]:\n"
"        print word"

#: ../../whatsnew/2.4.rst:1428
msgid ""
"Running the above function's tests with :const:`doctest.REPORT_UDIFF` "
"specified, you get the following output:"
msgstr "在指定 :const:`doctest.REPORT_UDIFF` 的情况下运行上述函数的测试，你会得到以下输出："

#: ../../whatsnew/2.4.rst:1431
msgid ""
"**********************************************************************\n"
"File \"t.py\", line 15, in g\n"
"Failed example:\n"
"    g(4)\n"
"Differences (unified diff with -expected +actual):\n"
"    @@ -2,3 +2,3 @@\n"
"     is\n"
"     a\n"
"    -lengthy\n"
"    +rather\n"
"**********************************************************************"
msgstr ""
"**********************************************************************\n"
"File \"t.py\", line 15, in g\n"
"Failed example:\n"
"    g(4)\n"
"Differences (unified diff with -expected +actual):\n"
"    @@ -2,3 +2,3 @@\n"
"     is\n"
"     a\n"
"    -lengthy\n"
"    +rather\n"
"**********************************************************************"

#: ../../whatsnew/2.4.rst:1449
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/2.4.rst:1451
msgid "Some of the changes to Python's build process and to the C API are:"
msgstr "对于 Python 构建过程和 C API 的一些修改:"

#: ../../whatsnew/2.4.rst:1453
msgid ""
"Three new convenience macros were added for common return values from "
"extension functions: :c:macro:`Py_RETURN_NONE`, :c:macro:`Py_RETURN_TRUE`, "
"and :c:macro:`Py_RETURN_FALSE`. (Contributed by Brett Cannon.)"
msgstr ""
"为常见扩展函数返回值添加了三个新的便利宏：:c:macro:`Py_RETURN_NONE`、:c:macro:`Py_RETURN_TRUE` 和 "
":c:macro:`Py_RETURN_FALSE`。（由 Brett Cannon 贡献。）"

#: ../../whatsnew/2.4.rst:1457
msgid ""
"Another new macro, :c:macro:`Py_CLEAR`,  decreases the reference count of "
"*obj* and sets *obj* to the null pointer.  (Contributed by Jim Fulton.)"
msgstr ""
"另一个新宏，:c:macro:`Py_CLEAR`，减少 *obj* 的引用计数并将 *obj* 设置为空指针。（由 Jim Fulton 贡献。)"

#: ../../whatsnew/2.4.rst:1460
msgid ""
"A new function, ``PyTuple_Pack(N, obj1, obj2, ..., objN)``, constructs "
"tuples from a variable length argument list of Python objects.  (Contributed"
" by Raymond Hettinger.)"
msgstr ""
"一个新的函数 ``PyTuple_Pack(N, obj1, obj2, ..., "
"objN)``，可以从一个可变长度的Python对象参数列表中构造元组。（由Raymond Hettinger贡献。）"

#: ../../whatsnew/2.4.rst:1464
msgid ""
"A new function, ``PyDict_Contains(d, k)``, implements fast dictionary "
"lookups without masking exceptions raised during the look-up process. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"一个新的函数 ``PyDict_Contains(d, k)``，实现了快速的字典查找，而不会掩盖查找过程中引发的异常。（由Raymond "
"Hettinger贡献。）"

#: ../../whatsnew/2.4.rst:1468
msgid ""
"The :c:expr:`Py_IS_NAN(X)` macro returns 1 if  its float or double argument "
"*X* is a NaN.   (Contributed by Tim Peters.)"
msgstr "宏 :c:expr:`Py_IS_NAN(X)` 如果其浮点或双精度参数 *X* 是NaN，则返回1。（由Tim Peters贡献。）"

#: ../../whatsnew/2.4.rst:1471
msgid ""
"C code can avoid unnecessary locking by using the new "
":c:func:`!PyEval_ThreadsInitialized` function to tell  if any thread "
"operations have been performed.  If this function  returns false, no lock "
"operations are needed. (Contributed by Nick Coghlan.)"
msgstr ""
"C代码可以通过使用新的 :c:func:`!PyEval_ThreadsInitialized` "
"函数来避免不必要的锁定，以判断是否进行了任何线程操作。如果此函数返回false，则不需要锁定操作。（由Nick Coghlan贡献。）"

#: ../../whatsnew/2.4.rst:1476
msgid ""
"A new function, :c:func:`PyArg_VaParseTupleAndKeywords`, is the same as "
":c:func:`PyArg_ParseTupleAndKeywords` but takes a  :c:type:`va_list` instead"
" of a number of arguments. (Contributed by Greg Chapman.)"
msgstr ""
"一个新的函数 :c:func:`PyArg_VaParseTupleAndKeywords`，与 "
":c:func:`PyArg_ParseTupleAndKeywords` 相同，但接受一个 :c:type:`va_list` "
"而不是参数数量。（由Greg Chapman贡献。）"

#: ../../whatsnew/2.4.rst:1480
msgid ""
"A new method flag, :c:macro:`METH_COEXIST`, allows a function defined in "
"slots to co-exist with a :c:type:`PyCFunction` having the same name.  This "
"can halve the access time for a method such as :meth:`set.__contains__`.  "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"一个新的方法标志 :c:macro:`METH_COEXIST`，允许在槽中定义的函数与具有相同名称的 :c:type:`PyCFunction` "
"共存。这可以将诸如 :meth:`set.__contains__` 这样的方法的访问时间减半。（由Raymond Hettinger贡献。）"

#: ../../whatsnew/2.4.rst:1485
msgid ""
"Python can now be built with additional profiling for the interpreter "
"itself, intended as an aid to people developing the Python core.  Providing "
":option:`!--enable-profiling` to the :program:`configure` script will let "
"you profile the interpreter with :program:`gprof`, and providing the "
":option:`!--with-tsc` switch enables profiling using the Pentium's Time-"
"Stamp-Counter register.  Note that the :option:`!--with-tsc` switch is "
"slightly misnamed, because the profiling feature also works on the PowerPC "
"platform, though that processor architecture doesn't call that register "
"\"the TSC register\".  (Contributed by Jeremy Hylton.)"
msgstr ""
"Python现在可以内置对解释器本身的额外分析功能，旨在帮助开发Python核心的人员。向 :program:`configure` 脚本提供 "
":option:`!--enable-profiling` 选项将允许您使用 :program:`gprof` 对解释器进行分析，提供 "
":option:`!--with-tsc` 开关则启用使用Pentium的时间戳计数器寄存器进行分析。请注意，:option:`!--with-tsc`"
" 开关命名略有不当，因为该分析功能在PowerPC平台上也能工作，尽管该处理器架构不将该寄存器称为“TSC寄存器”。（由Jeremy "
"Hylton贡献。）"

#: ../../whatsnew/2.4.rst:1495
msgid ""
"The :c:type:`!tracebackobject` type has been renamed to "
":c:type:`PyTracebackObject`."
msgstr ":c:type:`!tracebackobject` 类型已被重命名为 :c:type:`PyTracebackObject`。"

#: ../../whatsnew/2.4.rst:1502
msgid "Port-Specific Changes"
msgstr "移植专属的改变"

#: ../../whatsnew/2.4.rst:1504
msgid ""
"The Windows port now builds under MSVC++ 7.1 as well as version 6. "
"(Contributed by Martin von Löwis.)"
msgstr "Windows端口现在可以在MSVC++ 7.1以及版本6下构建。（由Martin von Löwis贡献。）"

#: ../../whatsnew/2.4.rst:1511
msgid "Porting to Python 2.4"
msgstr "移植到 Python 2.4"

#: ../../whatsnew/2.4.rst:1513
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr "本节列出了先前描述的可能需要修改你的代码的改变："

#: ../../whatsnew/2.4.rst:1516
msgid ""
"Left shifts and hexadecimal/octal constants that are too  large no longer "
"trigger a :exc:`FutureWarning` and return  a value limited to 32 or 64 bits;"
" instead they return a long integer."
msgstr ""
"左移操作和过大的十六进制/八进制常量不再触发 :exc:`FutureWarning`，并且返回一个限制在32或64位的值；相反，它们返回一个长整数。"

#: ../../whatsnew/2.4.rst:1523
msgid ""
"The :func:`zip` built-in function and :func:`itertools.izip` now return  an "
"empty list instead of raising a :exc:`TypeError` exception if called with no"
" arguments."
msgstr ""
":func:`zip` 内置函数和 :func:`itertools.izip` 现在在无参数调用时返回一个空列表，而不是抛出 "
":exc:`TypeError` 异常。"

#: ../../whatsnew/2.4.rst:1527
msgid ""
"You can no longer compare the :class:`date` and :class:`~datetime.datetime` "
"instances provided by the :mod:`datetime` module.  Two  instances of "
"different classes will now always be unequal, and  relative comparisons "
"(``<``, ``>``) will raise a :exc:`TypeError`."
msgstr ""
"您不能再比较由 :mod:`datetime` 模块提供的 :class:`date` 和 :class:`~datetime.datetime` "
"实例。不同类的两个实例现在将始终不相等，并且相对比较（``<``，``>``）将抛出 :exc:`TypeError`。"

#: ../../whatsnew/2.4.rst:1532
msgid ""
":func:`!dircache.listdir` now passes exceptions to the caller instead of "
"returning empty lists."
msgstr ":func:`!dircache.listdir` 现在将异常传递给调用者，而不是返回空列表。"

#: ../../whatsnew/2.4.rst:1535
msgid ""
":func:`LexicalHandler.startDTD` used to receive the public and system IDs in"
" the wrong order.  This has been corrected; applications relying on the "
"wrong order need to be fixed."
msgstr ""
":func:`LexicalHandler.startDTD` 过去接收公共和系统 ID 的顺序错误。这已被纠正；依赖错误顺序的应用程序需要修复。"

#: ../../whatsnew/2.4.rst:1539
msgid ""
":func:`fcntl.ioctl` now warns if the *mutate*  argument is omitted and "
"relevant."
msgstr "现在 :func:`fcntl.ioctl` 会在 *mutate* 参数被省略并且将造成影响时发出警告。"

#: ../../whatsnew/2.4.rst:1542
msgid ""
"The :mod:`tarfile` module now generates GNU-format tar files by default."
msgstr "现在 :mod:`tarfile` 模块默认将生成 GNU 格式的 tar 文件。"

#: ../../whatsnew/2.4.rst:1544
msgid ""
"Encountering a failure while importing a module no longer leaves a partially"
" initialized module object in ``sys.modules``."
msgstr "在导入模块时遭遇失败不会再将部分初始化的模块对象留在 ``sys.modules`` 中。"

#: ../../whatsnew/2.4.rst:1547
msgid ""
":const:`None` is now a constant; code that binds a new value to  the name "
"``None`` is now a syntax error."
msgstr "现在 :const:`None` 是一个常量；将一个新值绑定到 ``None`` 将导致语法错误。"

#: ../../whatsnew/2.4.rst:1550
msgid ""
"The :func:`signals.signal` function now raises a :exc:`RuntimeError` "
"exception for certain illegal values; previously these errors would pass "
"silently.  For example, you can no longer set a handler on the "
":const:`SIGKILL` signal."
msgstr ""
"现在对于某些非法的值 :func:`signals.signal` 函数将引发 :exc:`RuntimeError` "
"异常；在之前版本中这些错误会静默地放过。 例如，你将不能在 :const:`SIGKILL` 信号上设置处理器。"

#: ../../whatsnew/2.4.rst:1560
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.4.rst:1562
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Koray Can, Hye-Shik Chang, Michael Dyck, Raymond Hettinger, Brian Hurt, "
"Hamish Lawson, Fredrik Lundh, Sean Reifschneider, Sadruddin Rejeb."
msgstr ""
"作者感谢以下人员对本文各种草稿给予的建议，更正和协助：Koray Can, Hye-Shik Chang, Michael Dyck, Raymond "
"Hettinger, Brian Hurt, Hamish Lawson, Fredrik Lundh, Sean Reifschneider, "
"Sadruddin Rejeb."

#: ../../whatsnew/2.4.rst:415
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../whatsnew/2.4.rst:415
msgid "What's new"
msgstr "有什么新变化"
