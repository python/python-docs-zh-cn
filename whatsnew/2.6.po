# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.6.rst:5
msgid "What's New in Python 2.6"
msgstr "Python 2.6 有什么新变化"

#: ../../whatsnew/2.6.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.6.rst:7
msgid "A.M. Kuchling (amk at amk.ca)"
msgstr "A.M. Kuchling (amk at amk.ca)"

#: ../../whatsnew/2.6.rst:50
msgid ""
"This article explains the new features in Python 2.6, released on October 1,"
" 2008.  The release schedule is described in :pep:`361`."
msgstr "本文介绍了 Python 2.6 的新特性，它发布于 2008 年 10 月 1 日。发布日程说明见 :pep:`361`。"

#: ../../whatsnew/2.6.rst:53
msgid ""
"The major theme of Python 2.6 is preparing the migration path to Python 3.0,"
" a major redesign of the language.  Whenever possible, Python 2.6 "
"incorporates new features and syntax from 3.0 while remaining compatible "
"with existing code by not removing older features or syntax.  When it's not "
"possible to do that, Python 2.6 tries to do what it can, adding "
"compatibility functions in a :mod:`future_builtins` module and a "
":option:`!-3` switch to warn about usages that will become unsupported in "
"3.0."
msgstr ""
"Python 2.6 的主题是为迁移到 Python 3.0 做准备，这是 Python 语言的一次重大重新设计。 只要有可能，Python 2.6 "
"就会纳入 3.0 的新特性和语法，同时通过不删除旧特性或语法来保持与现有代码的兼容。 当无法做到这一点时，Python 2.6 会尽力而为，在 "
":mod:`future_builtins` 模块中添加兼容性函数，并通过 :option:`!-3` 开关来警告将在 3.0 中变得不支持的用法。"

#: ../../whatsnew/2.6.rst:62
msgid ""
"Some significant new packages have been added to the standard library, such "
"as the :mod:`multiprocessing` and :mod:`json` modules, but there aren't many"
" new features that aren't related to Python 3.0 in some way."
msgstr ""
"标准库中增加了一些重要的新包，如 :mod:`multiprocessing` 和 :mod:`json` 模块等，但与 Python 3.0 "
"完全无关联的新特性并不多。"

#: ../../whatsnew/2.6.rst:67
msgid ""
"Python 2.6 also sees a number of improvements and bugfixes throughout the "
"source.  A search through the change logs finds there were 259 patches "
"applied and 612 bugs fixed between Python 2.5 and 2.6.  Both figures are "
"likely to be underestimates."
msgstr ""
"Python 2.6 还对整个源代码进行了大量改进和错误修复。 通过搜索更改日志我们发现在 Python 2.5 和 2.6 之间应用了 259 "
"个补丁并修复了 612 个错误。 这两个数字可能都被低估了。"

#: ../../whatsnew/2.6.rst:72
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you"
" should refer to the documentation for Python 2.6. If you want to understand"
" the rationale for the design and implementation, refer to the PEP for a "
"particular new feature. Whenever possible, \"What's New in Python\" links to"
" the bug/patch item for each change."
msgstr ""
"本文并不试图提供新特性的完整规范说明，而是提供一个方便的概览。 要了解完整的细节，请参阅 Python 2.6 的文档。 "
"如果你想了解有关设计和实现的具体考量，请参阅特定新特性 的 PEP。 在可能的情况下，“Python "
"有什么新变化”为每个更改的错误修正/补丁项提供链接。"

#: ../../whatsnew/2.6.rst:88
msgid "Python 3.0"
msgstr "Python 3.0"

#: ../../whatsnew/2.6.rst:90
msgid ""
"The development cycle for Python versions 2.6 and 3.0 was synchronized, with"
" the alpha and beta releases for both versions being made on the same days."
"  The development of 3.0 has influenced many features in 2.6."
msgstr ""
"Python版本2.6和3.0的开发周期是同步的，两个版本的alpha和beta版本是在同一天发布的。3.0的发展影响了2.6中的许多功能。"

#: ../../whatsnew/2.6.rst:95
msgid ""
"Python 3.0 is a far-ranging redesign of Python that breaks compatibility "
"with the 2.x series.  This means that existing Python code will need some "
"conversion in order to run on Python 3.0.  However, not all the changes in "
"3.0 necessarily break compatibility.  In cases where new features won't "
"cause existing code to break, they've been backported to 2.6 and are "
"described in this document in the appropriate place.  Some of the "
"3.0-derived features are:"
msgstr ""
"Python 3.0 是对 Python 的大范围重新设计，打破了与 2.x 系列的兼容性。  这意味着现有的 Python 代码需要进行一些转换才能在"
" Python 3.0 上运行。  不过，并非 3.0 中的所有更改都会破坏兼容性。 在新特性不会导致现有代码崩溃的情况下，它们会被回溯到 "
"2.6，并在本文档的适当位置进行描述。 部分 3.0 衍生功能包括:"

#: ../../whatsnew/2.6.rst:104
msgid ""
"A :meth:`__complex__` method for converting objects to a complex number."
msgstr "用于将对象转换为复数的 :meth:`__complex__` 方法。"

#: ../../whatsnew/2.6.rst:105
msgid "Alternate syntax for catching exceptions: ``except TypeError as exc``."
msgstr "用于捕获异常的替代语法: ``except TypeError as exc``。"

#: ../../whatsnew/2.6.rst:106
msgid ""
"The addition of :func:`functools.reduce` as a synonym for the built-in "
":func:`reduce` function."
msgstr "增加 :func:`functools.reduce` 作为内置 :func:`reduce` 函数的同义词。"

#: ../../whatsnew/2.6.rst:109
msgid ""
"Python 3.0 adds several new built-in functions and changes the semantics of "
"some existing builtins.  Functions that are new in 3.0 such as :func:`bin` "
"have simply been added to Python 2.6, but existing builtins haven't been "
"changed; instead, the :mod:`future_builtins` module has versions with the "
"new 3.0 semantics.  Code written to be compatible with 3.0 can do ``from "
"future_builtins import hex, map`` as necessary."
msgstr ""
"Python 3.0 新增了一些内置函数并对部分现有内置函数的语法进行了修改。 在 3.0 中新增的函数如 :func:`bin` 已直接添加到 "
"Python 2.6 中，但现有内置函数则未修改；替代做法是在 :mod:`future_builtins` 模块中包含具有 3.0 新语法的版本。 "
"要与 3.0 兼容的代码可以在必要时执行 ``from future_builtins import hex, map``。"

#: ../../whatsnew/2.6.rst:117
msgid ""
"A new command-line switch, :option:`!-3`, enables warnings about features "
"that will be removed in Python 3.0.  You can run code with this switch to "
"see how much work will be necessary to port code to 3.0.  The value of this "
"switch is available to Python code as the boolean variable "
":data:`sys.py3kwarning`, and to C extension code as "
":c:data:`!Py_Py3kWarningFlag`."
msgstr ""
"一个新的命令行开关 :option:`!-3` 可以对 Python 3.0 将移除的特性发出警告。 你可以使用该开关运行代码，以了解将代码移植到 "
"3.0 所需的工作量。 Python 代码可以使用布尔型变量 :data:`sys.py3kwarning` 访问该开关的值，C 扩展代码可以使用 "
":c:data:`!Py_Py3kWarningFlag` 访问该开关的值。"

#: ../../whatsnew/2.6.rst:126
msgid ""
"The 3\\ *xxx* series of PEPs, which contains proposals for Python 3.0. "
":pep:`3000` describes the development process for Python 3.0. Start with "
":pep:`3100` that describes the general goals for Python 3.0, and then "
"explore the higher-numbered PEPs that propose specific features."
msgstr ""
"3\\ *xxx* 系列 PEP 包含针对 Python 3.0 的提议。 :pep:`3000` 描述了 Python 3.0 的开发进程。 从 "
":pep:`3100` 开始描述 Python 3.0 的主要目标，然后继续列出提议具体特性的更高数字的 PEP。"

#: ../../whatsnew/2.6.rst:134
msgid "Changes to the Development Process"
msgstr "开发过程的变化"

#: ../../whatsnew/2.6.rst:136
msgid ""
"While 2.6 was being developed, the Python development process underwent two "
"significant changes: we switched from SourceForge's issue tracker to a "
"customized Roundup installation, and the documentation was converted from "
"LaTeX to reStructuredText."
msgstr ""
"在开发2.6时，Python开发过程经历了两个重大变化：我们从SourceForge的问题跟踪程序切换到定制的Roundup安装，文档从LaTeX转换为reStructuredText。"

#: ../../whatsnew/2.6.rst:143
msgid "New Issue Tracker: Roundup"
msgstr "新问题追踪：简述"

#: ../../whatsnew/2.6.rst:145
msgid ""
"For a long time, the Python developers had been growing increasingly annoyed"
" by SourceForge's bug tracker.  SourceForge's hosted solution doesn't permit"
" much customization; for example, it wasn't possible to customize the life "
"cycle of issues."
msgstr ""
"很长一段时间以来，Python开发人员对SourceForge的bug跟踪器越来越恼火。SourceForge的托管解决方案不允许进行大量定制；例如，无法定制问题的生命周期。"

#: ../../whatsnew/2.6.rst:150
msgid ""
"The infrastructure committee of the Python Software Foundation therefore "
"posted a call for issue trackers, asking volunteers to set up different "
"products and import some of the bugs and patches from SourceForge.  Four "
"different trackers were examined: `Jira "
"<https://www.atlassian.com/software/jira/>`__, `Launchpad "
"<https://launchpad.net/>`__, `Roundup <https://roundup.sourceforge.io/>`__, "
"and `Trac <https://trac.edgewall.org/>`__. The committee eventually settled "
"on Jira and Roundup as the two candidates.  Jira is a commercial product "
"that offers no-cost hosted instances to free-software projects; Roundup is "
"an open-source project that requires volunteers to administer it and a "
"server to host it."
msgstr ""
"Python软件基金会的基础设施委员会因此发布了一个问题跟踪器的征集公告，邀请志愿者设置不同的产品，并从SourceForge导入一些错误和补丁。评估了四种不同的跟踪器：`Jira"
" <https://www.atlassian.com/software/jira/>`__，`Launchpad "
"<https://launchpad.net/>`__，`Roundup "
"<https://roundup.sourceforge.io/>`__和`Trac "
"<https://trac.edgewall.org/>`__。委员会最终确定Jira和Roundup为两个候选方案。Jira是一个商业产品，为自由软件项目提供免费托管实例；Roundup是一个开源项目，需要志愿者来管理，并需要一个服务器来托管。"

#: ../../whatsnew/2.6.rst:164
msgid ""
"After posting a call for volunteers, a new Roundup installation was set up "
"at https://bugs.python.org.  One installation of Roundup can host multiple "
"trackers, and this server now also hosts issue trackers for Jython and for "
"the Python web site.  It will surely find other uses in the future.  Where "
"possible, this edition of \"What's New in Python\" links to the bug/patch "
"item for each change."
msgstr ""
"在发出志愿者号召后，在https://bugs.python.org的一个Roundup的安装可以托管多个跟踪器，现在该服务器还托管Jython和Python网站的问题跟踪器。它肯定会在未来找到其他用途。在可能的情况下，此版本的“What's"
" New in Python”链接到每个更改的bug/补丁项。"

#: ../../whatsnew/2.6.rst:172
msgid ""
"Hosting of the Python bug tracker is kindly provided by `Upfront Systems "
"<https://upfrontsoftware.co.za>`__ of Stellenbosch, South Africa.  Martin "
"von Löwis put a lot of effort into importing existing bugs and patches from "
"SourceForge; his scripts for this import operation are at "
"``https://svn.python.org/view/tracker/importer/`` and may be useful to other"
" projects wishing to move from SourceForge to Roundup."
msgstr ""
"Python错误跟踪器的托管由南非斯泰伦博斯市的 `Upfront Systems <https://upfrontsoftware.co.za>`__"
" 友好提供。Martin von Löwis 在从 SourceForge 导入现有错误和补丁方面做了大量工作；他的导入脚本位于 "
"``https://svn.python.org/view/tracker/importer/``，对于希望从 SourceForge 迁移到 "
"Roundup 的其他项目可能有所帮助。"

#: ../../whatsnew/2.6.rst:182
msgid "https://bugs.python.org"
msgstr "https://bugs.python.org"

#: ../../whatsnew/2.6.rst:183
msgid "The Python bug tracker."
msgstr "Python 的错误追踪器。"

#: ../../whatsnew/2.6.rst:185
msgid "https://bugs.jython.org:"
msgstr "https://bugs.jython.org:"

#: ../../whatsnew/2.6.rst:186
msgid "The Jython bug tracker."
msgstr "Jython 的错误追踪器。"

#: ../../whatsnew/2.6.rst:188
msgid "https://roundup.sourceforge.io/"
msgstr "https://roundup.sourceforge.io/"

#: ../../whatsnew/2.6.rst:189
msgid "Roundup downloads and documentation."
msgstr "Roundup 下载和文档。"

#: ../../whatsnew/2.6.rst:191
msgid "https://svn.python.org/view/tracker/importer/"
msgstr "https://svn.python.org/view/tracker/importer/"

#: ../../whatsnew/2.6.rst:192
msgid "Martin von Löwis's conversion scripts."
msgstr "Martin von Löwis 的转换脚本。"

#: ../../whatsnew/2.6.rst:195
msgid "New Documentation Format: reStructuredText Using Sphinx"
msgstr "新的文档格式：使用 Sphinx 的 reStructuredText"

#: ../../whatsnew/2.6.rst:197
msgid ""
"The Python documentation was written using LaTeX since the project started "
"around 1989.  In the 1980s and early 1990s, most documentation was printed "
"out for later study, not viewed online. LaTeX was widely used because it "
"provided attractive printed output while remaining straightforward to write "
"once the basic rules of the markup were learned."
msgstr ""
"自 1989 年左右项目启动以来，Python 文档一直使用 LaTeX 编写。在 1980 年代和 1990 "
"年代早期，大多数文档都是打印出来供日后学习的，而不是在网上查看。 LaTeX "
"被广泛使用，因为它既能提供美观的打印输出，又能在掌握了标记的基本规则后直接进行编写。"

#: ../../whatsnew/2.6.rst:204
msgid ""
"Today LaTeX is still used for writing publications destined for printing, "
"but the landscape for programming tools has shifted.  We no longer print out"
" reams of documentation; instead, we browse through it online and HTML has "
"become the most important format to support. Unfortunately, converting LaTeX"
" to HTML is fairly complicated and Fred L. Drake Jr., the long-time Python "
"documentation editor, spent a lot of time maintaining the conversion "
"process.  Occasionally people would suggest converting the documentation "
"into SGML and later XML, but performing a good conversion is a major task "
"and no one ever committed the time required to finish the job."
msgstr ""
"如今 LaTeX 仍被用于编写印刷出版物，但编程工具的格局已经发生了变化。 我们不再打印成堆的文档，取而代之的是在线浏览，HTML "
"已成为最重要的支持格式。 不幸的是，将 LaTeX 转换为 HTML 相当复杂，长期担任 Python 文档编辑的 Fred L. Drake Jr. "
"花了许多时间在维护转换过程上。 偶尔有人会建议将文档转换成 SGML，之后再转换成 "
"XML，但进行良好的转换是一项艰巨的任务，从来没有人投入所需的时间来完成这项工作。"

#: ../../whatsnew/2.6.rst:215
msgid ""
"During the 2.6 development cycle, Georg Brandl put a lot of effort into "
"building a new toolchain for processing the documentation.  The resulting "
"package is called Sphinx, and is available from https://www.sphinx-doc.org/."
msgstr ""
"在 2.6 开发周期中，Georg Brandl 投入了大量精力来构建一个新的工具链，用于处理文档。由此产生的软件包名为 Sphinx，可从 "
"https://www.sphinx-doc.org/ 获取。"

#: ../../whatsnew/2.6.rst:220
msgid ""
"Sphinx concentrates on HTML output, producing attractively styled and modern"
" HTML; printed output is still supported through conversion to LaTeX.  The "
"input format is reStructuredText, a markup syntax supporting custom "
"extensions and directives that is commonly used in the Python community."
msgstr ""
"Sphinx 专注于 HTML 输出，可生成吸引人风格的现代 HTML；通过转换为 LaTeX，仍可支持打印输出。输入格式是 "
"reStructuredText，这是一种支持自定义扩展和指令的标记语法，在 Python 社区很常用。"

#: ../../whatsnew/2.6.rst:226
msgid ""
"Sphinx is a standalone package that can be used for writing, and almost two "
"dozen other projects (`listed on the Sphinx web site <https://www.sphinx-"
"doc.org/en/master/examples.html>`__) have adopted Sphinx as their "
"documentation tool."
msgstr ""
"Sphinx 是一个可用于写文档的独立软件包，将近二十多个其他项目 (`列在 Sphinx 网站 <https://www.sphinx-"
"doc.org/en/master/examples.html>`__ 上) 已采用 Sphinx 作为其文档工具。"

#: ../../whatsnew/2.6.rst:233
msgid "`Documenting Python <https://devguide.python.org/documenting/>`__"
msgstr "`Documenting Python <https://devguide.python.org/documenting/>`__"

#: ../../whatsnew/2.6.rst:234
msgid "Describes how to write for Python's documentation."
msgstr "描述如何编写Python文档。"

#: ../../whatsnew/2.6.rst:236
msgid "`Sphinx <https://www.sphinx-doc.org/>`__"
msgstr "`Sphinx <https://www.sphinx-doc.org/>`__"

#: ../../whatsnew/2.6.rst:237
msgid "Documentation and code for the Sphinx toolchain."
msgstr "Sphinx工具链的文档和代码。"

#: ../../whatsnew/2.6.rst:239
msgid "`Docutils <https://docutils.sourceforge.io>`__"
msgstr "`Docutils <https://docutils.sourceforge.io>`__"

#: ../../whatsnew/2.6.rst:240
msgid "The underlying reStructuredText parser and toolset."
msgstr "reStructuredText 的基础解析器和工具集。"

#: ../../whatsnew/2.6.rst:246
msgid "PEP 343: The 'with' statement"
msgstr "PEP 343: \"with\" 语句"

#: ../../whatsnew/2.6.rst:248
msgid ""
"The previous version, Python 2.5, added the ':keyword:`with`' statement as "
"an optional feature, to be enabled by a ``from __future__ import "
"with_statement`` directive.  In 2.6 the statement no longer needs to be "
"specially enabled; this means that :keyword:`!with` is now always a keyword."
"  The rest of this section is a copy of the corresponding section from the "
"\"What's New in Python 2.5\" document; if you're familiar with the "
"':keyword:`!with`' statement from Python 2.5, you can skip this section."
msgstr ""
"在 Python 2.5 之前的版本中，\":keyword:`with`\" 语句是一个可选功能，可以通过 ``from __future__ "
"import with_statement`` 指令启用。 在 2.6 中，该语句不再需要特别启用；这意味着 :keyword:`!with` "
"现在总是一个关键字。 本节的其余部分是“Python 2.5 新特性”文档中相应部分的复制；如果你熟悉 Python 2.5 中的  "
"':keyword:`!with`' 语句，可以跳过本节。"

#: ../../whatsnew/2.6.rst:257
msgid ""
"The ':keyword:`with`' statement clarifies code that previously would use "
"``try...finally`` blocks to ensure that clean-up code is executed.  In this "
"section, I'll discuss the statement as it will commonly be used.  In the "
"next section, I'll examine the implementation details and show how to write "
"objects for use with this statement."
msgstr ""
"':keyword:`with`' 语句澄清了以前使用 ``try...finally`` "
"块来确保执行清理代码的代码。在本节中，我将讨论该语句的常见用法。在下一节中，我将探讨实现细节，并展示如何编写与该语句一起使用的对象。"

#: ../../whatsnew/2.6.rst:263
msgid ""
"The ':keyword:`with`' statement is a control-flow structure whose basic "
"structure is::"
msgstr "':keyword:`with`' 语句是一种基本结构如下所示的流程控制结构::"

#: ../../whatsnew/2.6.rst:266
msgid ""
"with expression [as variable]:\n"
"    with-block"
msgstr ""
"with expression [as variable]:\n"
"    with-block"

#: ../../whatsnew/2.6.rst:269
msgid ""
"The expression is evaluated, and it should result in an object that supports"
" the context management protocol (that is, has :meth:`~object.__enter__` and"
" :meth:`~object.__exit__` methods)."
msgstr ""
"表达式会被求值，并且其结果应为一个支持上下文协议的对象（即具有 :meth:`~object.__enter__` 和 "
":meth:`~object.__exit__` 方法）。"

#: ../../whatsnew/2.6.rst:273
msgid ""
"The object's :meth:`~object.__enter__` is called before *with-block* is "
"executed and therefore can run set-up code. It also may return a value that "
"is bound to the name *variable*, if given.  (Note carefully that *variable* "
"is *not* assigned the result of *expression*.)"
msgstr ""
"在执行 *with-block* 之前，会调用对象的 :meth:`~object.__enter__` "
"方法，因此可以运行设置代码。它还可以返回一个值，该值绑定到 *variable*（如果给出的话）。（请注意，*variable* 并不是被赋值为 "
"*expression* 的结果。）"

#: ../../whatsnew/2.6.rst:278
msgid ""
"After execution of the *with-block* is finished, the object's "
":meth:`~object.__exit__` method is called, even if the block raised an "
"exception, and can therefore run clean-up code."
msgstr ""
"在 *with-block* 执行完成后，即使块引发了异常，也会调用对象的 :meth:`~object.__exit__` "
"方法，因此可以运行清理代码。"

#: ../../whatsnew/2.6.rst:282
msgid ""
"Some standard Python objects now support the context management protocol and"
" can be used with the ':keyword:`with`' statement. File objects are one "
"example::"
msgstr "一些标准 Python 对象现在已支持上下文管理协议并可被用于 ':keyword:`with`' 语句。 文件对象就是一个例子::"

#: ../../whatsnew/2.6.rst:285
msgid ""
"with open('/etc/passwd', 'r') as f:\n"
"    for line in f:\n"
"        print line\n"
"        ... more processing code ..."
msgstr ""
"with open('/etc/passwd', 'r') as f:\n"
"    for line in f:\n"
"        print line\n"
"        ... 更多处理代码 ..."

#: ../../whatsnew/2.6.rst:290
msgid ""
"After this statement has executed, the file object in *f* will have been "
"automatically closed, even if the :keyword:`for` loop raised an exception "
"part-way through the block."
msgstr "在此语句被执行之后，文件对象 *f* 将被自动关闭，即使是当 :keyword:`for` 循环在代码块中间引发了异常的时候也是如此。"

#: ../../whatsnew/2.6.rst:296
msgid ""
"In this case, *f* is the same object created by :func:`open`, because "
":meth:`~object.__enter__` returns *self*."
msgstr ""
"在此情况下，*f* 就是由 :func:`open` 所创建的对象，因为 :meth:`~object.__enter__` 会返回 *self*。"

#: ../../whatsnew/2.6.rst:299
msgid ""
"The :mod:`threading` module's locks and condition variables  also support "
"the ':keyword:`with`' statement::"
msgstr ":mod:`threading` 模块的加锁和条件变量也支持 ':keyword:`with`' 语句::"

#: ../../whatsnew/2.6.rst:302
msgid ""
"lock = threading.Lock()\n"
"with lock:\n"
"    # Critical section of code\n"
"    ..."
msgstr ""
"lock = threading.Lock()\n"
"with lock:\n"
"    # 关键代码段\n"
"    ..."

#: ../../whatsnew/2.6.rst:307
msgid ""
"The lock is acquired before the block is executed and always released once  "
"the block is complete."
msgstr "这个锁会在代码块被执行之前锁定并总是会在代码块完成之后释放。"

#: ../../whatsnew/2.6.rst:310
msgid ""
"The :func:`localcontext` function in the :mod:`decimal` module makes it easy"
" to save and restore the current decimal context, which encapsulates the "
"desired precision and rounding characteristics for computations::"
msgstr ""
":mod:`decimal` 模块中的 :func:`localcontext` "
"函数可以轻松保存和恢复当前的十进制上下文，该上下文封装了计算所需的精度和舍入特性::"

#: ../../whatsnew/2.6.rst:314
msgid ""
"from decimal import Decimal, Context, localcontext\n"
"\n"
"# Displays with default precision of 28 digits\n"
"v = Decimal('578')\n"
"print v.sqrt()\n"
"\n"
"with localcontext(Context(prec=16)):\n"
"    # All code in this block uses a precision of 16 digits.\n"
"    # The original context is restored on exiting the block.\n"
"    print v.sqrt()"
msgstr ""
"from decimal import Decimal, Context, localcontext\n"
"\n"
"# 使用默认精度 28 位显示\n"
"v = Decimal('578')\n"
"print v.sqrt()\n"
"\n"
"with localcontext(Context(prec=16)):\n"
"    # 此代码块中的所有代码使用 16 位精度。\n"
"    # 退出代码块时恢复原始上下文。\n"
"    print v.sqrt()"

#: ../../whatsnew/2.6.rst:329
msgid "Writing Context Managers"
msgstr "编写上下文管理器"

#: ../../whatsnew/2.6.rst:331
msgid ""
"Under the hood, the ':keyword:`with`' statement is fairly complicated. Most "
"people will only use ':keyword:`!with`' in company with existing objects and"
" don't need to know these details, so you can skip the rest of this section "
"if you like.  Authors of new objects will need to understand the details of "
"the underlying implementation and should keep reading."
msgstr ""
"在底层，':keyword:`with`' 语句相当复杂。大多数人只会与现有对象一起使用 "
"':keyword:`!with`'，不需要了解这些细节，所以如果你愿意，可以跳过本节的其余部分。新对象的作者需要理解底层实现的细节，应该继续阅读。"

#: ../../whatsnew/2.6.rst:337
msgid "A high-level explanation of the context management protocol is:"
msgstr "在更高层级上对于上下文管理器协议的解释:"

#: ../../whatsnew/2.6.rst:339
msgid ""
"The expression is evaluated and should result in an object called a "
"\"context manager\".  The context manager must have "
":meth:`~object.__enter__` and :meth:`~object.__exit__` methods."
msgstr ""
"表达式被评估，并应生成一个称为“上下文管理器”的对象。上下文管理器必须具有 :meth:`~object.__enter__` 和 "
":meth:`~object.__exit__` 方法。"

#: ../../whatsnew/2.6.rst:343
msgid ""
"The context manager's :meth:`~object.__enter__` method is called.  The value"
" returned is assigned to *VAR*.  If no ``as VAR`` clause is present, the "
"value is simply discarded."
msgstr ""
"调用上下文管理器的 :meth:`~object.__enter__` 方法。返回的值被赋给 *VAR*。如果没有 ``as VAR`` "
"子句，该值将被丢弃。"

#: ../../whatsnew/2.6.rst:347
msgid "The code in *BLOCK* is executed."
msgstr "*BLOCK* 中的代码会被执行。"

#: ../../whatsnew/2.6.rst:349
msgid ""
"If *BLOCK* raises an exception, the context manager's "
":meth:`~object.__exit__` method is called with three arguments, the "
"exception details (``type, value, traceback``, the same values returned by "
":func:`sys.exc_info`, which can also be ``None`` if no exception occurred)."
"  The method's return value controls whether an exception is re-raised: any "
"false value re-raises the exception, and ``True`` will result in suppressing"
" it.  You'll only rarely want to suppress the exception, because if you do "
"the author of the code containing the ':keyword:`with`' statement will never"
" realize anything went wrong."
msgstr ""
"如果 *BLOCK* 引发异常，将使用三个参数调用上下文管理器的 :meth:`~object.__exit__` 方法，即异常详情（``type, "
"value, traceback``，与 :func:`sys.exc_info` 返回的值相同，如果没有发生异常，这些值也可以是 "
"``None``）。该方法的返回值控制是否重新引发异常：任何假值将重新引发异常，而 ``True`` "
"将导致抑制异常。你很少会想抑制异常，因为如果你这样做，包含 ':keyword:`with`' 语句的代码作者将永远不会意识到出了问题。"

#: ../../whatsnew/2.6.rst:358
msgid ""
"If *BLOCK* didn't raise an exception,  the :meth:`~object.__exit__` method "
"is still called, but *type*, *value*, and *traceback* are all ``None``."
msgstr ""
"如果 *BLOCK* 没有引发异常，仍然会调用 :meth:`~object.__exit__` 方法，但 *type*、*value* 和 "
"*traceback* 都是 ``None``。"

#: ../../whatsnew/2.6.rst:361
msgid ""
"Let's think through an example.  I won't present detailed code but will only"
" sketch the methods necessary for a database that supports transactions."
msgstr "让我们通过一个例子来思考。我不会展示详细的代码，而只会概述支持事务的数据库所需的方法。"

#: ../../whatsnew/2.6.rst:364
msgid ""
"(For people unfamiliar with database terminology: a set of changes to the "
"database are grouped into a transaction.  Transactions can be either "
"committed, meaning that all the changes are written into the database, or "
"rolled back, meaning that the changes are all discarded and the database is "
"unchanged.  See any database textbook for more information.)"
msgstr ""
"（对于不熟悉数据库术语的人来说：对数据库的一组更改被组合成一个事务。事务可以被提交，意味着所有更改都被写入数据库，或者被回滚，意味着所有更改都被丢弃，数据库保持不变。更多信息请参阅任何数据库教材。）"

#: ../../whatsnew/2.6.rst:370
msgid ""
"Let's assume there's an object representing a database connection. Our goal "
"will be to let the user write code like this::"
msgstr "假设有一个表示数据库连接的对象。我们的目标将允许用户编写如下代码："

#: ../../whatsnew/2.6.rst:373
msgid ""
"db_connection = DatabaseConnection()\n"
"with db_connection as cursor:\n"
"    cursor.execute('insert into ...')\n"
"    cursor.execute('delete from ...')\n"
"    # ... more operations ..."
msgstr ""
"db_connection = DatabaseConnection()\n"
"with db_connection as cursor:\n"
"    cursor.execute('insert into ...')\n"
"    cursor.execute('delete from ...')\n"
"    # ... 更多操作 ..."

#: ../../whatsnew/2.6.rst:379
msgid ""
"The transaction should be committed if the code in the block runs flawlessly"
" or rolled back if there's an exception. Here's the basic interface for "
":class:`DatabaseConnection` that I'll assume::"
msgstr ""
"如果块中的代码完美运行，则应提交事务；如果出现异常，则应回滚事务。以下是假设的 :class:`DatabaseConnection` 的基本接口："

#: ../../whatsnew/2.6.rst:383
msgid ""
"class DatabaseConnection:\n"
"    # Database interface\n"
"    def cursor(self):\n"
"        \"Returns a cursor object and starts a new transaction\"\n"
"    def commit(self):\n"
"        \"Commits current transaction\"\n"
"    def rollback(self):\n"
"        \"Rolls back current transaction\""
msgstr ""
"class DatabaseConnection:\n"
"    # 数据库接口\n"
"    def cursor(self):\n"
"        \"返回一个游标对象并开始一个新事务\"\n"
"    def commit(self):\n"
"        \"提交当前事务\"\n"
"    def rollback(self):\n"
"        \"回滚当前事务\""

#: ../../whatsnew/2.6.rst:392
msgid ""
"The :meth:`~object.__enter__` method is pretty easy, having only to start a "
"new transaction.  For this application the resulting cursor object would be "
"a useful result, so the method will return it.  The user can then add ``as "
"cursor`` to their ':keyword:`with`' statement to bind the cursor to a "
"variable name. ::"
msgstr ""
":meth:`~object.__enter__` "
"方法非常简单，只需开始一个新事务。对于此应用程序，生成的游标对象将是一个有用的结果，因此该方法将返回它。用户可以在他们的 "
"':keyword:`with`' 语句中添加 ``as cursor`` 来将游标绑定到一个变量名。："

#: ../../whatsnew/2.6.rst:397
msgid ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __enter__(self):\n"
"        # Code to start a new transaction\n"
"        cursor = self.cursor()\n"
"        return cursor"
msgstr ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __enter__(self):\n"
"        # 开始新事务的代码\n"
"        cursor = self.cursor()\n"
"        return cursor"

#: ../../whatsnew/2.6.rst:404
msgid ""
"The :meth:`~object.__exit__` method is the most complicated because it's "
"where most of the work has to be done.  The method has to check if an "
"exception occurred.  If there was no exception, the transaction is "
"committed.  The transaction is rolled back if there was an exception."
msgstr ""
":meth:`~object.__exit__` "
"方法是最复杂的，因为大部分工作都要在这里完成。该方法需要检查是否发生了异常。如果没有异常，事务被提交。如果发生了异常，事务被回滚。"

#: ../../whatsnew/2.6.rst:409
msgid ""
"In the code below, execution will just fall off the end of the function, "
"returning the default value of ``None``.  ``None`` is false, so the "
"exception will be re-raised automatically.  If you wished, you could be more"
" explicit and add a :keyword:`return` statement at the marked location. ::"
msgstr ""
"在下面的代码中，执行将直接从函数末尾跳出，返回默认值 ``None``。``None`` "
"为假值，因此异常将自动重新抛出。如果你希望更明确，可以在标记的位置添加一个 :keyword:`return` 语句。::"

#: ../../whatsnew/2.6.rst:414
msgid ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __exit__(self, type, value, tb):\n"
"        if tb is None:\n"
"            # No exception, so commit\n"
"            self.commit()\n"
"        else:\n"
"            # Exception occurred, so rollback.\n"
"            self.rollback()\n"
"            # return False"
msgstr ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __exit__(self, type, value, tb):\n"
"        if tb is None:\n"
"            # 没有异常，因此提交\n"
"            self.commit()\n"
"        else:\n"
"            # 发生异常，因此回滚。\n"
"            self.rollback()\n"
"            # 返回 False"

#: ../../whatsnew/2.6.rst:429
msgid "The contextlib module"
msgstr "contextlib 模块"

#: ../../whatsnew/2.6.rst:431
msgid ""
"The :mod:`contextlib` module provides some functions and a decorator that "
"are useful when writing objects for use with the ':keyword:`with`' "
"statement."
msgstr ""
":mod:`contextlib` 模块提供了一些函数和一个装饰器，这些在编写用于与':keyword:`with`'语句一起使用的对象时非常有用。"

#: ../../whatsnew/2.6.rst:434
msgid ""
"The decorator is called :func:`contextmanager`, and lets you write a single "
"generator function instead of defining a new class.  The generator should "
"yield exactly one value.  The code up to the :keyword:`yield` will be "
"executed as the :meth:`~object.__enter__` method, and the value yielded will"
" be the method's return value that will get bound to the variable in the "
"':keyword:`with`' statement's :keyword:`!as` clause, if any.  The code after"
" the :keyword:`!yield` will be executed in the :meth:`~object.__exit__` "
"method.  Any exception raised in the block will be raised by the "
":keyword:`!yield` statement."
msgstr ""
"该装饰器名为 "
":func:`contextmanager`，它允许你编写单个生成器函数，而不是定义一个新的类。生成器应该生成恰好一个值。:keyword:`yield`"
" 之前的代码将作为 :meth:`~object.__enter__` 方法执行，生成的值将作为该方法的返回值，如果有的话，将绑定到 "
"':keyword:`with`' 语句的 :keyword:`!as` 子句中的变量。:keyword:`!yield` 之后的代码将在 "
":meth:`~object.__exit__` 方法中执行。块中引发的任何异常将由 :keyword:`!yield` 语句抛出。"

#: ../../whatsnew/2.6.rst:443
msgid ""
"Using this decorator, our database example from the previous section could "
"be written as::"
msgstr "使用这个装饰器，我们上一节中的数据库示例可以写成::"

#: ../../whatsnew/2.6.rst:446
msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def db_transaction(connection):\n"
"    cursor = connection.cursor()\n"
"    try:\n"
"        yield cursor\n"
"    except:\n"
"        connection.rollback()\n"
"        raise\n"
"    else:\n"
"        connection.commit()\n"
"\n"
"db = DatabaseConnection()\n"
"with db_transaction(db) as cursor:\n"
"    ..."
msgstr ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def db_transaction(connection):\n"
"    cursor = connection.cursor()\n"
"    try:\n"
"        yield cursor\n"
"    except:\n"
"        connection.rollback()\n"
"        raise\n"
"    else:\n"
"        connection.commit()\n"
"\n"
"db = DatabaseConnection()\n"
"with db_transaction(db) as cursor:\n"
"    ..."

#: ../../whatsnew/2.6.rst:463
msgid ""
"The :mod:`contextlib` module also has a ``nested(mgr1, mgr2, ...)`` function"
" that combines a number of context managers so you don't need to write "
"nested ':keyword:`with`' statements.  In this example, the single "
"':keyword:`!with`' statement both starts a database transaction and acquires"
" a thread lock::"
msgstr ""
":mod:`contextlib` 模块还有一个``nested(mgr1, mgr2, "
"...)``函数，它可以将多个上下文管理器组合在一起，这样你就不需要编写嵌套的':keyword:`with`'语句。在这个例子中，单个':keyword:`!with`'语句既启动数据库事务又获取线程锁::"

#: ../../whatsnew/2.6.rst:468
msgid ""
"lock = threading.Lock()\n"
"with nested (db_transaction(db), lock) as (cursor, locked):\n"
"    ..."
msgstr ""
"lock = threading.Lock()\n"
"with nested (db_transaction(db), lock) as (cursor, locked):\n"
"    ..."

#: ../../whatsnew/2.6.rst:472
msgid ""
"Finally, the :func:`closing` function returns its argument so that it can be"
" bound to a variable, and calls the argument's ``.close()`` method at the "
"end of the block. ::"
msgstr "最后，:func:`closing` 函数返回其参数，以便它可以绑定到变量，并在块结束时调用参数的 ``.close()`` 方法。::"

#: ../../whatsnew/2.6.rst:476
msgid ""
"import urllib, sys\n"
"from contextlib import closing\n"
"\n"
"with closing(urllib.urlopen('http://www.yahoo.com')) as f:\n"
"    for line in f:\n"
"        sys.stdout.write(line)"
msgstr ""
"import urllib, sys\n"
"from contextlib import closing\n"
"\n"
"with closing(urllib.urlopen('http://www.yahoo.com')) as f:\n"
"    for line in f:\n"
"        sys.stdout.write(line)"

#: ../../whatsnew/2.6.rst:486
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 语句"

#: ../../whatsnew/2.6.rst:487
msgid ""
"PEP written by Guido van Rossum and Nick Coghlan; implemented by Mike Bland,"
" Guido van Rossum, and Neal Norwitz.  The PEP shows the code generated for a"
" ':keyword:`with`' statement, which can be helpful in learning how the "
"statement works."
msgstr ""
"PEP由Guido van Rossum和Nick Coghlan撰写；由Mike Bland、Guido van Rossum和Neal "
"Norwitz实现。PEP展示了为':keyword:`with`'语句生成的代码，这对于学习该语句的工作原理很有帮助。"

#: ../../whatsnew/2.6.rst:492
msgid "The documentation  for the :mod:`contextlib` module."
msgstr ":mod:`contextlib` 模块的文档。"

#: ../../whatsnew/2.6.rst:499
msgid "PEP 366: Explicit Relative Imports From a Main Module"
msgstr "PEP 366: 从主模块显式相对导入"

#: ../../whatsnew/2.6.rst:501
msgid ""
"Python's :option:`-m` switch allows running a module as a script. When you "
"ran a module that was located inside a package, relative imports didn't work"
" correctly."
msgstr "Python 的 :option:`-m` 开关允许将一个模块作为脚本来运行。 当你运行一个位于某个包内的模块时，相对导入将无法正确运作。"

#: ../../whatsnew/2.6.rst:505
msgid ""
"The fix for Python 2.6 adds a :attr:`module.__package__` attribute. When "
"this attribute is present, relative imports will be relative to the value of"
" this attribute instead of the :attr:`~module.__name__` attribute."
msgstr ""
"Python 2.6的修复增加了一个 :attr:`module.__package__` 属性。当此属性存在时，相对导入将相对于此属性的值而不是 "
":attr:`~module.__name__` 属性。"

#: ../../whatsnew/2.6.rst:510
msgid ""
"PEP 302-style importers can then set :attr:`~module.__package__` as "
"necessary. The :mod:`runpy` module that implements the :option:`-m` switch "
"now does this, so relative imports will now work correctly in scripts "
"running from inside a package."
msgstr ""
"PEP 302风格的导入器可以按需设置 :attr:`~module.__package__`。实现 :option:`-m` 开关的 "
":mod:`runpy` 模块现在就这样做，因此相对导入现在可以在从包内运行的脚本中正确工作。"

#: ../../whatsnew/2.6.rst:520
msgid "PEP 370: Per-user ``site-packages`` Directory"
msgstr "PEP 370: 分用户的 site-packages 目录"

#: ../../whatsnew/2.6.rst:522
msgid ""
"When you run Python, the module search path ``sys.path`` usually includes a "
"directory whose path ends in ``\"site-packages\"``.  This directory is "
"intended to hold locally installed packages available to all users using a "
"machine or a particular site installation."
msgstr ""
"当你运行Python时，模块搜索路径 ``sys.path`` 通常包括一个路径以 ``\"site-packages\"`` "
"结尾的目录。这个目录旨在存放本地安装的、对所有使用该机器或特定站点安装的用户可用的包。"

#: ../../whatsnew/2.6.rst:527
msgid ""
"Python 2.6 introduces a convention for user-specific site directories. The "
"directory varies depending on the platform:"
msgstr "Python 2.6 引入了一个用于用户专属站点目录的惯例。 该目录根据具体系统平台各不相同:"

#: ../../whatsnew/2.6.rst:530
msgid "Unix and Mac OS X: :file:`~/.local/`"
msgstr "Unix 和 Mac OS X: :file:`~/.local/`"

#: ../../whatsnew/2.6.rst:531
msgid "Windows: :file:`%APPDATA%/Python`"
msgstr "Windows: :file:`%APPDATA%/Python`"

#: ../../whatsnew/2.6.rst:533
msgid ""
"Within this directory, there will be version-specific subdirectories, such "
"as :file:`lib/python2.6/site-packages` on Unix/Mac OS and "
":file:`Python26/site-packages` on Windows."
msgstr ""
"在此目录中，会有特定版本的子目录，例如在Unix/Mac OS上的 :file:`lib/python2.6/site-packages` "
"和在Windows上的 :file:`Python26/site-packages`。"

#: ../../whatsnew/2.6.rst:537
msgid ""
"If you don't like the default directory, it can be overridden by an "
"environment variable.  :envvar:`PYTHONUSERBASE` sets the root directory used"
" for all Python versions supporting this feature.  On Windows, the directory"
" for application-specific data can be changed by setting the "
":envvar:`APPDATA` environment variable.  You can also modify the "
":file:`site.py` file for your Python installation."
msgstr ""
"如果你不喜欢默认目录，可以通过环境变量覆盖它。:envvar:`PYTHONUSERBASE` "
"设置支持此功能的所有Python版本使用的根目录。在Windows上，可以通过设置 :envvar:`APPDATA` "
"环境变量来更改应用程序特定数据的目录。你也可以修改你的Python安装中的 :file:`site.py` 文件。"

#: ../../whatsnew/2.6.rst:544
msgid ""
"The feature can be disabled entirely by running Python with the :option:`-s`"
" option or setting the :envvar:`PYTHONNOUSERSITE` environment variable."
msgstr ""
"此功能可以通过使用 :option:`-s` 选项运行Python或设置 :envvar:`PYTHONNOUSERSITE` 环境变量来完全禁用。"

#: ../../whatsnew/2.6.rst:550
msgid ":pep:`370` - Per-user ``site-packages`` Directory"
msgstr ":pep:`370` - 分用户的 site-packages 目录"

#: ../../whatsnew/2.6.rst:551
msgid "PEP written and implemented by Christian Heimes."
msgstr "PEP 由 Christian Heimes 撰写并实现。"

#: ../../whatsnew/2.6.rst:559
msgid "PEP 371: The ``multiprocessing`` Package"
msgstr "PEP 371: ``multiprocessing`` (多进程)包"

#: ../../whatsnew/2.6.rst:561
msgid ""
"The new :mod:`multiprocessing` package lets Python programs create new "
"processes that will perform a computation and return a result to the parent."
"  The parent and child processes can communicate using queues and pipes, "
"synchronize their operations using locks and semaphores, and can share "
"simple arrays of data."
msgstr ""
"新的 :mod:`multiprocessing` "
"包让Python程序可以创建新进程来执行计算并返回结果给父进程。父进程和子进程可以使用队列和管道进行通信，使用锁和信号量同步它们的操作，并且可以共享简单的数据数组。"

#: ../../whatsnew/2.6.rst:567
msgid ""
"The :mod:`multiprocessing` module started out as an exact emulation of the "
":mod:`threading` module using processes instead of threads.  That goal was "
"discarded along the path to Python 2.6, but the general approach of the "
"module is still similar.  The fundamental class is the :class:`Process`, "
"which is passed a callable object and a collection of arguments.  The "
":meth:`start` method sets the callable running in a subprocess, after which "
"you can call the :meth:`is_alive` method to check whether the subprocess is "
"still running and the :meth:`join` method to wait for the process to exit."
msgstr ""
":mod:`multiprocessing` 模块最初是作为 :mod:`threading` 模块的精确模拟，使用进程而不是线程。这个目标在 "
"Python 2.6 的开发过程中被放弃了，但模块的总体方法仍然相似。基本类是 "
":class:`Process`，它接收一个可调用对象和一组参数。:meth:`start` 方法在子进程中启动可调用对象，之后你可以调用 "
":meth:`is_alive` 方法来检查子进程是否仍在运行，以及调用 :meth:`join` 方法来等待进程退出。"

#: ../../whatsnew/2.6.rst:577
msgid ""
"Here's a simple example where the subprocess will calculate a factorial.  "
"The function doing the calculation is written strangely so that it takes "
"significantly longer when the input argument is a multiple of 4."
msgstr "下面是一个简单的示例，子进程将计算阶乘。执行计算的函数写得很奇怪，以便当输入参数是 4 的倍数时，它会花费更长的时间。"

#: ../../whatsnew/2.6.rst:584
msgid ""
"import time\n"
"from multiprocessing import Process, Queue\n"
"\n"
"\n"
"def factorial(queue, N):\n"
"    \"Compute a factorial.\"\n"
"    # If N is a multiple of 4, this function will take much longer.\n"
"    if (N % 4) == 0:\n"
"        time.sleep(.05 * N/4)\n"
"\n"
"    # Calculate the result\n"
"    fact = 1L\n"
"    for i in range(1, N+1):\n"
"        fact = fact * i\n"
"\n"
"    # Put the result on the queue\n"
"    queue.put(fact)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"\n"
"    N = 5\n"
"\n"
"    p = Process(target=factorial, args=(queue, N))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    result = queue.get()\n"
"    print 'Factorial', N, '=', result"
msgstr ""
"import time\n"
"from multiprocessing import Process, Queue\n"
"\n"
"\n"
"def factorial(queue, N):\n"
"    \"计算阶乘\"\n"
"    # 如果 N 是 4 的倍数，这个函数将会花费更长的时间。\n"
"    if (N % 4) == 0:\n"
"        time.sleep(.05 * N/4)\n"
"\n"
"    # 计算结果\n"
"    fact = 1L\n"
"    for i in range(1, N+1):\n"
"        fact = fact * i\n"
"\n"
"    # 将结果放入队列\n"
"    queue.put(fact)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"\n"
"    N = 5\n"
"\n"
"    p = Process(target=factorial, args=(queue, N))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    result = queue.get()\n"
"    print 'Factorial', N, '=', result"

#: ../../whatsnew/2.6.rst:614
msgid ""
"A :class:`~queue.Queue` is used to communicate the result of the factorial. "
"The :class:`~queue.Queue` object is stored in a global variable. The child "
"process will use the value of the variable when the child was created; "
"because it's a :class:`~queue.Queue`, parent and child can use the object to"
" communicate.  (If the parent were to change the value of the global "
"variable, the child's value would be unaffected, and vice versa.)"
msgstr ""
"使用 :class:`~queue.Queue` 来传递阶乘的结果。:class:`~queue.Queue` "
"对象存储在一个全局变量中。子进程将使用创建子进程时的变量值；因为它是 "
":class:`~queue.Queue`，父进程和子进程可以使用该对象进行通信。（如果父进程更改全局变量的值，子进程的值不会受影响，反之亦然。）"

#: ../../whatsnew/2.6.rst:622
msgid ""
"Two other classes, :class:`Pool` and :class:`Manager`, provide higher-level "
"interfaces.  :class:`Pool` will create a fixed number of worker processes, "
"and requests can then be distributed to the workers by calling :meth:`apply`"
" or :meth:`apply_async` to add a single request, and :meth:`map` or "
":meth:`map_async` to add a number of requests.  The following code uses a "
":class:`Pool` to spread requests across 5 worker processes and retrieve a "
"list of results::"
msgstr ""
"另外两个类，:class:`Pool` 和 :class:`Manager`，提供了更高级别的接口。:class:`Pool` "
"将创建固定数量的工作进程，然后可以通过调用 :meth:`apply` 或 :meth:`apply_async` 来添加单个请求，通过调用 "
":meth:`map` 或 :meth:`map_async` 来添加多个请求。以下代码使用 :class:`Pool` 将请求分散到 5 "
"个工作进程并获取结果列表::"

#: ../../whatsnew/2.6.rst:630
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def factorial(N, dictionary):\n"
"    \"Compute a factorial.\"\n"
"    ...\n"
"p = Pool(5)\n"
"result = p.map(factorial, range(1, 1000, 10))\n"
"for v in result:\n"
"    print v"
msgstr ""
"from multiprocessing import Pool\n"
"\n"
"def factorial(N, dictionary):\n"
"    \"Compute a factorial.\"\n"
"    ...\n"
"p = Pool(5)\n"
"result = p.map(factorial, range(1, 1000, 10))\n"
"for v in result:\n"
"    print v"

#: ../../whatsnew/2.6.rst:640
msgid "This produces the following output::"
msgstr "这会产生以下输出::"

#: ../../whatsnew/2.6.rst:642
msgid ""
"1\n"
"39916800\n"
"51090942171709440000\n"
"8222838654177922817725562880000000\n"
"33452526613163807108170062053440751665152000000000\n"
"..."
msgstr ""
"1\n"
"39916800\n"
"51090942171709440000\n"
"8222838654177922817725562880000000\n"
"33452526613163807108170062053440751665152000000000\n"
"..."

#: ../../whatsnew/2.6.rst:649
msgid ""
"The other high-level interface, the :class:`Manager` class, creates a "
"separate server process that can hold master copies of Python data "
"structures.  Other processes can then access and modify these data "
"structures using proxy objects.  The following example creates a shared "
"dictionary by calling the :meth:`dict` method; the worker processes then "
"insert values into the dictionary.  (Locking is not done for you "
"automatically, which doesn't matter in this example. :class:`Manager`'s "
"methods also include :meth:`Lock`, :meth:`RLock`, and :meth:`Semaphore` to "
"create shared locks.)"
msgstr ""
"另一个高级接口，:class:`Manager` 类，创建一个单独的服务器进程，可以持有 Python "
"数据结构的主副本。其他进程然后可以通过代理对象访问和修改这些数据结构。以下示例通过调用 :meth:`dict` "
"方法创建一个共享字典；工作进程然后将值插入到字典中。（锁定不会自动为你完成，这在示例中无关紧要。:class:`Manager` 的方法还包括 "
":meth:`Lock`、:meth:`RLock` 和 :meth:`Semaphore`，用于创建共享锁。）"

#: ../../whatsnew/2.6.rst:661
msgid ""
"import time\n"
"from multiprocessing import Pool, Manager\n"
"\n"
"def factorial(N, dictionary):\n"
"    \"Compute a factorial.\"\n"
"    # Calculate the result\n"
"    fact = 1L\n"
"    for i in range(1, N+1):\n"
"        fact = fact * i\n"
"\n"
"    # Store result in dictionary\n"
"    dictionary[N] = fact\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Pool(5)\n"
"    mgr = Manager()\n"
"    d = mgr.dict()         # Create shared dictionary\n"
"\n"
"    # Run tasks using the pool\n"
"    for N in range(1, 1000, 10):\n"
"        p.apply_async(factorial, (N, d))\n"
"\n"
"    # Mark pool as closed -- no more tasks can be added.\n"
"    p.close()\n"
"\n"
"    # Wait for tasks to exit\n"
"    p.join()\n"
"\n"
"    # Output results\n"
"    for k, v in sorted(d.items()):\n"
"        print k, v"
msgstr ""
"import time\n"
"from multiprocessing import Pool, Manager\n"
"\n"
"def factorial(N, dictionary):\n"
"    \"计算阶乘\"\n"
"    # 计算结果\n"
"    fact = 1L\n"
"    for i in range(1, N+1):\n"
"        fact = fact * i\n"
"\n"
"    # 将结果存储在字典中\n"
"    dictionary[N] = fact\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Pool(5)\n"
"    mgr = Manager()\n"
"    d = mgr.dict()         # 创建共享字典\n"
"\n"
"    # 使用池运行任务\n"
"    for N in range(1, 1000, 10):\n"
"        p.apply_async(factorial, (N, d))\n"
"\n"
"    # 标记池为关闭 -- 不能再添加任务。\n"
"    p.close()\n"
"\n"
"    # 等待任务退出\n"
"    p.join()\n"
"\n"
"    # 输出结果\n"
"    for k, v in sorted(d.items()):\n"
"        print k, v"

#: ../../whatsnew/2.6.rst:693
msgid "This will produce the output::"
msgstr "这将产生如下输出::"

#: ../../whatsnew/2.6.rst:695
msgid ""
"1 1\n"
"11 39916800\n"
"21 51090942171709440000\n"
"31 8222838654177922817725562880000000\n"
"41 33452526613163807108170062053440751665152000000000\n"
"51 15511187532873822802242430164693032110632597200169861120000..."
msgstr ""
"1 1\n"
"11 39916800\n"
"21 51090942171709440000\n"
"31 8222838654177922817725562880000000\n"
"41 33452526613163807108170062053440751665152000000000\n"
"51 15511187532873822802242430164693032110632597200169861120000..."

#: ../../whatsnew/2.6.rst:704
msgid "The documentation for the :mod:`multiprocessing` module."
msgstr ":mod:`multiprocessing` 模块的文档。"

#: ../../whatsnew/2.6.rst:706
msgid ":pep:`371` - Addition of the multiprocessing package"
msgstr ":pep:`371` - 添加多任务处理包"

#: ../../whatsnew/2.6.rst:707
msgid ""
"PEP written by Jesse Noller and Richard Oudkerk; implemented by Richard "
"Oudkerk and Jesse Noller."
msgstr ""
"PEP 由 Jesse Noller 和 Richard Oudkerk 撰写，由 Richard Oudkerk 和 Jesse Noller 实现。"

#: ../../whatsnew/2.6.rst:716
msgid "PEP 3101: Advanced String Formatting"
msgstr "PEP 3101: 高级字符串格式"

#: ../../whatsnew/2.6.rst:718
msgid ""
"In Python 3.0, the ``%`` operator is supplemented by a more powerful string "
"formatting method, :meth:`format`.  Support for the :meth:`str.format` "
"method has been backported to Python 2.6."
msgstr ""
"在 Python 3.0 中，``%`` 运算符被更强大的字符串格式化方法 :meth:`format` 所补充。对 "
":meth:`str.format` 方法的支持已经回溯到 Python 2.6。"

#: ../../whatsnew/2.6.rst:722
msgid ""
"In 2.6, both 8-bit and Unicode strings have a ``.format()`` method that "
"treats the string as a template and takes the arguments to be formatted. The"
" formatting template uses curly brackets (``{``, ``}``) as special "
"characters::"
msgstr ""
"在2.6版本中，8位字符串和Unicode字符串都有一个 ``.format()`` "
"方法，该方法将字符串视为模板，并接受要格式化的参数。格式化模板使用大括号（``{``, ``}``）作为特殊字符："

#: ../../whatsnew/2.6.rst:726
msgid ""
">>> # Substitute positional argument 0 into the string.\n"
">>> \"User ID: {0}\".format(\"root\")\n"
"'User ID: root'\n"
">>> # Use the named keyword arguments\n"
">>> \"User ID: {uid}   Last seen: {last_login}\".format(\n"
"...    uid=\"root\",\n"
"...    last_login = \"5 Mar 2008 07:20\")\n"
"'User ID: root   Last seen: 5 Mar 2008 07:20'"
msgstr ""
">>> # 将位置参数0替换到字符串中。\n"
">>> \"User ID: {0}\".format(\"root\")\n"
"'User ID: root'\n"
">>> # 使用命名关键字参数\n"
">>> \"User ID: {uid}   Last seen: {last_login}\".format(\n"
"...    uid=\"root\",\n"
"...    last_login = \"5 Mar 2008 07:20\")\n"
"'User ID: root   Last seen: 5 Mar 2008 07:20'"

#: ../../whatsnew/2.6.rst:735
msgid "Curly brackets can be escaped by doubling them::"
msgstr "大括号可以通过双写来转义："

#: ../../whatsnew/2.6.rst:737
msgid ""
">>> \"Empty dict: {{}}\".format()\n"
"\"Empty dict: {}\""
msgstr ""
">>> \"Empty dict: {{}}\".format()\n"
"\"Empty dict: {}\""

#: ../../whatsnew/2.6.rst:740
msgid ""
"Field names can be integers indicating positional arguments, such as "
"``{0}``, ``{1}``, etc. or names of keyword arguments.  You can also supply "
"compound field names that read attributes or access dictionary keys::"
msgstr ""
"字段名可以是表示位置参数的整数，如 ``{0}``、``{1}`` 等，或者是关键字参数的名称。你还可以提供复合字段名来读取属性或访问字典键："

#: ../../whatsnew/2.6.rst:744
msgid ""
">>> import sys\n"
">>> print 'Platform: {0.platform}\\nPython version: {0.version}'.format(sys)\n"
"Platform: darwin\n"
"Python version: 2.6a1+ (trunk:61261M, Mar  5 2008, 20:29:41)\n"
"[GCC 4.0.1 (Apple Computer, Inc. build 5367)]'\n"
"\n"
">>> import mimetypes\n"
">>> 'Content-type: {0[.mp4]}'.format(mimetypes.types_map)\n"
"'Content-type: video/mp4'"
msgstr ""
">>> import sys\n"
">>> print 'Platform: {0.platform}\\nPython version: {0.version}'.format(sys)\n"
"Platform: darwin\n"
"Python version: 2.6a1+ (trunk:61261M, Mar  5 2008, 20:29:41)\n"
"[GCC 4.0.1 (Apple Computer, Inc. build 5367)]'\n"
"\n"
">>> import mimetypes\n"
">>> 'Content-type: {0[.mp4]}'.format(mimetypes.types_map)\n"
"'Content-type: video/mp4'"

#: ../../whatsnew/2.6.rst:754
msgid ""
"Note that when using dictionary-style notation such as ``[.mp4]``, you don't"
" need to put any quotation marks around the string; it will look up the "
"value using ``.mp4`` as the key.  Strings beginning with a number will be "
"converted to an integer.  You can't write more complicated expressions "
"inside a format string."
msgstr ""
"请注意，当使用类似 ``[.mp4]`` 的字典样式表示法时，你不需要在字符串周围加任何引号；它将使用 ``.mp4`` "
"作为键来查找值。以数字开头的字符串将被转换为整数。你不能在格式字符串内编写更复杂的表达式。"

#: ../../whatsnew/2.6.rst:760
msgid ""
"So far we've shown how to specify which field to substitute into the "
"resulting string.  The precise formatting used is also controllable by "
"adding a colon followed by a format specifier.  For example::"
msgstr "到目前为止，我们已经展示了如何指定要替换到结果字符串中的字段。精确的格式化方式也可以通过添加一个冒号后跟一个格式说明符来控制。例如："

#: ../../whatsnew/2.6.rst:764
msgid ""
">>> # Field 0: left justify, pad to 15 characters\n"
">>> # Field 1: right justify, pad to 6 characters\n"
">>> fmt = '{0:15} ${1:>6}'\n"
">>> fmt.format('Registration', 35)\n"
"'Registration    $    35'\n"
">>> fmt.format('Tutorial', 50)\n"
"'Tutorial        $    50'\n"
">>> fmt.format('Banquet', 125)\n"
"'Banquet         $   125'"
msgstr ""
">>> # 字段 0：左对齐，填充至 15 个字符\n"
">>> # 字段 1：右对齐，填充至 6 个字符\n"
">>> fmt = '{0:15} ${1:>6}'\n"
">>> fmt.format('Registration', 35)\n"
"'Registration    $    35'\n"
">>> fmt.format('Tutorial', 50)\n"
"'Tutorial        $    50'\n"
">>> fmt.format('Banquet', 125)\n"
"'Banquet         $   125'"

#: ../../whatsnew/2.6.rst:774
msgid "Format specifiers can reference other fields through nesting::"
msgstr "格式说明符可以通过嵌套来引用其他字段::"

#: ../../whatsnew/2.6.rst:776
msgid ""
">>> fmt = '{0:{1}}'\n"
">>> width = 15\n"
">>> fmt.format('Invoice #1234', width)\n"
"'Invoice #1234  '\n"
">>> width = 35\n"
">>> fmt.format('Invoice #1234', width)\n"
"'Invoice #1234                      '"
msgstr ""
">>> fmt = '{0:{1}}'\n"
">>> width = 15\n"
">>> fmt.format('Invoice #1234', width)\n"
"'Invoice #1234  '\n"
">>> width = 35\n"
">>> fmt.format('Invoice #1234', width)\n"
"'Invoice #1234                      '"

#: ../../whatsnew/2.6.rst:784
msgid "The alignment of a field within the desired width can be specified:"
msgstr "可以指定所需宽度内的字段对齐方式："

#: ../../whatsnew/2.6.rst:787
msgid "Character"
msgstr "字符"

#: ../../whatsnew/2.6.rst:787
msgid "Effect"
msgstr "效果"

#: ../../whatsnew/2.6.rst:789
msgid "< (default)"
msgstr "< (默认)"

#: ../../whatsnew/2.6.rst:789
msgid "Left-align"
msgstr "左对齐"

#: ../../whatsnew/2.6.rst:790
msgid ">"
msgstr ">"

#: ../../whatsnew/2.6.rst:790
msgid "Right-align"
msgstr "右对齐"

#: ../../whatsnew/2.6.rst:791
msgid "^"
msgstr "^"

#: ../../whatsnew/2.6.rst:791
msgid "Center"
msgstr "居中对齐"

#: ../../whatsnew/2.6.rst:792
msgid "="
msgstr "="

#: ../../whatsnew/2.6.rst:792
msgid "(For numeric types only) Pad after the sign."
msgstr "（仅适用于数字类型）在符号后加空格。"

#: ../../whatsnew/2.6.rst:795
msgid ""
"Format specifiers can also include a presentation type, which controls how "
"the value is formatted.  For example, floating-point numbers can be "
"formatted as a general number or in exponential notation::"
msgstr "格式说明符还可以包括一个表示类型，它控制值的格式化方式。例如，浮点数可以格式化为常规数字或指数表示法："

#: ../../whatsnew/2.6.rst:799
msgid ""
">>> '{0:g}'.format(3.75)\n"
"'3.75'\n"
">>> '{0:e}'.format(3.75)\n"
"'3.750000e+00'"
msgstr ""
">>> '{0:g}'.format(3.75)\n"
"'3.75'\n"
">>> '{0:e}'.format(3.75)\n"
"'3.750000e+00'"

#: ../../whatsnew/2.6.rst:804
msgid ""
"A variety of presentation types are available.  Consult the 2.6 "
"documentation for a :ref:`complete list <formatstrings>`; here's a sample:"
msgstr "有多种展示类型可供选择。请参考2.6版文档中的 :ref:`完整列表 <formatstrings>`；以下是一个示例："

#: ../../whatsnew/2.6.rst:808
msgid "``b``"
msgstr "``b``"

#: ../../whatsnew/2.6.rst:808
msgid "Binary. Outputs the number in base 2."
msgstr "二进制。输出以2为底的数字。"

#: ../../whatsnew/2.6.rst:809
msgid "``c``"
msgstr "``c``"

#: ../../whatsnew/2.6.rst:809
msgid ""
"Character. Converts the integer to the corresponding Unicode character "
"before printing."
msgstr "字符。在打印之前将整数转换为相应的Unicode字符。"

#: ../../whatsnew/2.6.rst:811
msgid "``d``"
msgstr "``d``"

#: ../../whatsnew/2.6.rst:811
msgid "Decimal Integer. Outputs the number in base 10."
msgstr "十进制整数。 输出以 10 为基数的数字。"

#: ../../whatsnew/2.6.rst:812
msgid "``o``"
msgstr "``o``"

#: ../../whatsnew/2.6.rst:812
msgid "Octal format. Outputs the number in base 8."
msgstr "八进制格式。 输出以 8 为基数的数字。"

#: ../../whatsnew/2.6.rst:813
msgid "``x``"
msgstr "``x``"

#: ../../whatsnew/2.6.rst:813
msgid ""
"Hex format. Outputs the number in base 16, using lower-case letters for the "
"digits above 9."
msgstr "十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。"

#: ../../whatsnew/2.6.rst:815
msgid "``e``"
msgstr "``e``"

#: ../../whatsnew/2.6.rst:815
msgid ""
"Exponent notation. Prints the number in scientific notation using the letter"
" 'e' to indicate the exponent."
msgstr "指数表示法。用字母 'e' 以科学计数法打印数字以表示指数。"

#: ../../whatsnew/2.6.rst:817
msgid "``g``"
msgstr "``g``"

#: ../../whatsnew/2.6.rst:817
msgid ""
"General format. This prints the number as a fixed-point number, unless the "
"number is too large, in which case it switches to 'e' exponent notation."
msgstr "通用格式。这会将数字打印为定点数，除非数字过大，在这种情况下会切换到 'e' 指数表示法。"

#: ../../whatsnew/2.6.rst:820
msgid "``n``"
msgstr "``n``"

#: ../../whatsnew/2.6.rst:820
msgid ""
"Number. This is the same as 'g' (for floats) or 'd' (for integers), except "
"that it uses the current locale setting to insert the appropriate number "
"separator characters."
msgstr "数字。这与 'g'（对于浮点数）或 'd'（对于整数）相同，不同之处在于它使用当前区域设置来插入适当的数字分隔符字符。"

#: ../../whatsnew/2.6.rst:823
msgid "``%``"
msgstr "``%``"

#: ../../whatsnew/2.6.rst:823
msgid ""
"Percentage. Multiplies the number by 100 and displays in fixed ('f') format,"
" followed by a percent sign."
msgstr "百分比。将数字乘以100并以固定 ('f') 格式显示，后跟一个百分号。"

#: ../../whatsnew/2.6.rst:827
msgid ""
"Classes and types can define a :meth:`__format__` method to control how "
"they're formatted.  It receives a single argument, the format specifier::"
msgstr "类和类型可以定义一个 :meth:`__format__` 方法来控制它们的格式化方式。它接收一个参数，即格式说明符："

#: ../../whatsnew/2.6.rst:830
msgid ""
"def __format__(self, format_spec):\n"
"    if isinstance(format_spec, unicode):\n"
"        return unicode(str(self))\n"
"    else:\n"
"        return str(self)"
msgstr ""
"def __format__(self, format_spec):\n"
"    if isinstance(format_spec, unicode):\n"
"        return unicode(str(self))\n"
"    else:\n"
"        return str(self)"

#: ../../whatsnew/2.6.rst:836
msgid ""
"There's also a :func:`format` builtin that will format a single value.  It "
"calls the type's :meth:`__format__` method with the provided specifier::"
msgstr ""
"还有一个内置的 :func:`format` 函数，用于格式化单个值。它调用类型的 :meth:`__format__` 方法，并传入提供的说明符："

#: ../../whatsnew/2.6.rst:840
msgid ""
">>> format(75.6564, '.2f')\n"
"'75.66'"
msgstr ""
">>> format(75.6564, '.2f')\n"
"'75.66'"

#: ../../whatsnew/2.6.rst:846
msgid ":ref:`formatstrings`"
msgstr ":ref:`formatstrings`"

#: ../../whatsnew/2.6.rst:847
msgid "The reference documentation for format fields."
msgstr "格式字段的参考文档。"

#: ../../whatsnew/2.6.rst:849
msgid ":pep:`3101` - Advanced String Formatting"
msgstr ":pep:`3101` - 高级字符串格式"

#: ../../whatsnew/2.6.rst:850
msgid "PEP written by Talin. Implemented by Eric Smith."
msgstr "PEP 由 Eric V. Smith 撰写并实现。"

#: ../../whatsnew/2.6.rst:857
msgid "PEP 3105: ``print`` As a Function"
msgstr "PEP 3105: ``print`` 改为函数"

#: ../../whatsnew/2.6.rst:859
msgid ""
"The ``print`` statement becomes the :func:`print` function in Python 3.0. "
"Making :func:`print` a function makes it possible to replace the function by"
" doing ``def print(...)`` or importing a new function from somewhere else."
msgstr ""
"在 Python 3.0 中 ``print`` 语句变成了 :func:`print` 函数。 将 :func:`print` 变成函数使得可以通过 "
"``def print(...)`` 或从其他地方导入一个新函数来替换该函数。"

#: ../../whatsnew/2.6.rst:863
msgid ""
"Python 2.6 has a ``__future__`` import that removes ``print`` as language "
"syntax, letting you use the functional form instead.  For example::"
msgstr "Python 2.6 提供了 ``__future__`` 导入语句来移除 ``print`` 语法，让你可以改用函数形式。 例如::"

#: ../../whatsnew/2.6.rst:866
msgid ""
">>> from __future__ import print_function\n"
">>> print('# of entries', len(dictionary), file=sys.stderr)"
msgstr ""
">>> from __future__ import print_function\n"
">>> print('# of entries', len(dictionary), file=sys.stderr)"

#: ../../whatsnew/2.6.rst:869
msgid "The signature of the new function is::"
msgstr "新函数的签名为::"

#: ../../whatsnew/2.6.rst:871
msgid "def print(*args, sep=' ', end='\\n', file=None)"
msgstr "def print(*args, sep=' ', end='\\n', file=None)"

#: ../../whatsnew/2.6.rst:874
msgid "The parameters are:"
msgstr "形参包括:"

#: ../../whatsnew/2.6.rst:876
msgid "*args*: positional arguments whose values will be printed out."
msgstr "*args*: 相应值将会被打印的位置参数。"

#: ../../whatsnew/2.6.rst:877
msgid "*sep*: the separator, which will be printed between arguments."
msgstr "*sep*: 分隔符，它将在参数之间被打印。"

#: ../../whatsnew/2.6.rst:878
msgid ""
"*end*: the ending text, which will be printed after all of the arguments "
"have been output."
msgstr "*end*: 结束文本，它将在所有参数输出完毕之后被打印。"

#: ../../whatsnew/2.6.rst:880
msgid "*file*: the file object to which the output will be sent."
msgstr "*file*: 将被作为输出发送目标的文件对象。"

#: ../../whatsnew/2.6.rst:884
msgid ":pep:`3105` - Make print a function"
msgstr ":pep:`3105` - print 改为函数"

#: ../../whatsnew/2.6.rst:885
msgid "PEP written by Georg Brandl."
msgstr "PEP 由 Georg Brandl 撰写。"

#: ../../whatsnew/2.6.rst:892
msgid "PEP 3110: Exception-Handling Changes"
msgstr "PEP 3110: 异常处理的变更"

#: ../../whatsnew/2.6.rst:894
msgid ""
"One error that Python programmers occasionally make is writing the following"
" code::"
msgstr "Python 程序员偶尔会犯的一个错误是编写这样的代码::"

#: ../../whatsnew/2.6.rst:897
msgid ""
"try:\n"
"    ...\n"
"except TypeError, ValueError:  # Wrong!\n"
"    ..."
msgstr ""
"try:\n"
"    ...\n"
"except TypeError, ValueError:  # 错误！\n"
"    ..."

#: ../../whatsnew/2.6.rst:902
msgid ""
"The author is probably trying to catch both :exc:`TypeError` and "
":exc:`ValueError` exceptions, but this code actually does something "
"different: it will catch :exc:`TypeError` and bind the resulting exception "
"object to the local name ``\"ValueError\"``.  The :exc:`ValueError` "
"exception will not be caught at all.  The correct code specifies a tuple of "
"exceptions::"
msgstr ""
"作者可能试图捕获 :exc:`TypeError` 和 :exc:`ValueError` 异常，但这段代码实际上做了不同的事情：它会捕获 "
":exc:`TypeError` 并将生成的异常对象绑定到局部名称 ``\"ValueError\"``。 :exc:`ValueError` "
"异常根本不会被捕获。正确的代码应指定一个异常元组："

#: ../../whatsnew/2.6.rst:909
msgid ""
"try:\n"
"    ...\n"
"except (TypeError, ValueError):\n"
"    ..."
msgstr ""
"try:\n"
"    ...\n"
"except (TypeError, ValueError):\n"
"    ..."

#: ../../whatsnew/2.6.rst:914
msgid ""
"This error happens because the use of the comma here is ambiguous: does it "
"indicate two different nodes in the parse tree, or a single node that's a "
"tuple?"
msgstr "这个错误发生是因为这里逗号的使用是模糊的：它是表示解析树中的两个不同节点，还是表示一个元组节点？"

#: ../../whatsnew/2.6.rst:918
msgid ""
"Python 3.0 makes this unambiguous by replacing the comma with the word "
"\"as\".  To catch an exception and store the exception object in the "
"variable ``exc``, you must write::"
msgstr "Python 3.0 通过将逗号替换为单词 \"as\" 来使这一点明确。要捕获异常并将异常对象存储在变量 ``exc`` 中，你必须写成："

#: ../../whatsnew/2.6.rst:922
msgid ""
"try:\n"
"    ...\n"
"except TypeError as exc:\n"
"    ..."
msgstr ""
"try:\n"
"    ...\n"
"except TypeError as exc:\n"
"    ..."

#: ../../whatsnew/2.6.rst:927
msgid ""
"Python 3.0 will only support the use of \"as\", and therefore interprets the"
" first example as catching two different exceptions.  Python 2.6 supports "
"both the comma and \"as\", so existing code will continue to work.  We "
"therefore suggest using \"as\" when writing new Python code that will only "
"be executed with 2.6."
msgstr ""
"Python 3.0 将仅支持使用 \"as\"，因此将第一个示例解释为捕获两个不同的异常。Python 2.6 同时支持逗号和 "
"\"as\"，因此现有代码将继续工作。因此，我们建议在编写仅在 2.6 上执行的新的 Python 代码时使用 \"as\"。"

#: ../../whatsnew/2.6.rst:935
msgid ":pep:`3110` - Catching Exceptions in Python 3000"
msgstr ":pep:`3110` - 在 Python 3000 中捕获异常"

#: ../../whatsnew/2.6.rst:936
msgid "PEP written and implemented by Collin Winter."
msgstr "PEP 由 Collin Winter 撰写并实现。"

#: ../../whatsnew/2.6.rst:943
msgid "PEP 3112: Byte Literals"
msgstr "PEP 3112: 字节字面值"

#: ../../whatsnew/2.6.rst:945
msgid ""
"Python 3.0 adopts Unicode as the language's fundamental string type and "
"denotes 8-bit literals differently, either as ``b'string'`` or using a "
":class:`bytes` constructor.  For future compatibility, Python 2.6 adds "
":class:`bytes` as a synonym for the :class:`str` type, and it also supports "
"the ``b''`` notation."
msgstr ""
"Python 3.0 采用 Unicode 作为语言的基本字符串类型，并以不同的方式表示 8 位字面量，要么作为 ``b'string'``，要么使用 "
":class:`bytes` 构造器。为了未来的兼容性，Python 2.6 添加了 :class:`bytes` 作为 :class:`str` "
"类型的同义词，并且也支持 ``b''`` 表示法。"

#: ../../whatsnew/2.6.rst:952
msgid ""
"The 2.6 :class:`str` differs from 3.0's :class:`bytes` type in various ways;"
" most notably, the constructor is completely different.  In 3.0, "
"``bytes([65, 66, 67])`` is 3 elements long, containing the bytes "
"representing ``ABC``; in 2.6, ``bytes([65, 66, 67])`` returns the 12-byte "
"string representing the :func:`str` of the list."
msgstr ""
"2.6 的 :class:`str` 与 3.0 的 :class:`bytes` 类型在多方面存在差异；最显著的是，构造器完全不同。在 3.0 "
"中，``bytes([65, 66, 67])`` 长度为 3，包含表示 ``ABC`` 的字节；在 2.6 中，``bytes([65, 66, "
"67])`` 返回表示列表的 :func:`str` 的 12 字节字符串。"

#: ../../whatsnew/2.6.rst:958
msgid ""
"The primary use of :class:`bytes` in 2.6 will be to write tests of object "
"type such as ``isinstance(x, bytes)``.  This will help the 2to3 converter, "
"which can't tell whether 2.x code intends strings to contain either "
"characters or 8-bit bytes; you can now use either :class:`bytes` or "
":class:`str` to represent your intention exactly, and the resulting code "
"will also be correct in Python 3.0."
msgstr ""
"在 2.6 中，:class:`bytes` 的主要用途将是编写对象类型测试，例如 ``isinstance(x, bytes)``。这将有助于 "
"2to3 转换器，因为它无法判断 2.x 代码中的字符串是否意图包含字符或 8 位字节；现在你可以使用 :class:`bytes` 或 "
":class:`str` 来准确表示你的意图，并且生成的代码在 Python 3.0 中也是正确的。"

#: ../../whatsnew/2.6.rst:965
msgid ""
"There's also a ``__future__`` import that causes all string literals to "
"become Unicode strings.  This means that ``\\u`` escape sequences can be "
"used to include Unicode characters::"
msgstr ""
"还有一个 ``__future__`` 导入，它使所有字符串字面量变为 Unicode 字符串。这意味着可以使用 ``\\u`` 转义序列来包含 "
"Unicode 字符："

#: ../../whatsnew/2.6.rst:970
msgid ""
"from __future__ import unicode_literals\n"
"\n"
"s = ('\\u751f\\u3080\\u304e\\u3000\\u751f\\u3054'\n"
"     '\\u3081\\u3000\\u751f\\u305f\\u307e\\u3054')\n"
"\n"
"print len(s)               # 12 Unicode characters"
msgstr ""
"from __future__ import unicode_literals\n"
"\n"
"s = ('\\u751f\\u3080\\u304e\\u3000\\u751f\\u3054'\n"
"     '\\u3081\\u3000\\u751f\\u305f\\u307e\\u3054')\n"
"\n"
"print len(s)               # 12 个 Unicode 字符"

#: ../../whatsnew/2.6.rst:977
msgid ""
"At the C level, Python 3.0 will rename the existing 8-bit string type, "
"called :c:type:`!PyStringObject` in Python 2.x, to :c:type:`PyBytesObject`."
"  Python 2.6 uses ``#define`` to support using the names "
":c:func:`PyBytesObject`, :c:func:`PyBytes_Check`, "
":c:func:`PyBytes_FromStringAndSize`, and all the other functions and macros "
"used with strings."
msgstr ""
"在 C 层级上，Python 3.0 将重命名现有的 8 位字符串类型，从 Python 2.x 中的 "
":c:type:`!PyStringObject` 改为 :c:type:`PyBytesObject`。 Python 2.6 使用 "
"``#define`` 来支持使用 :c:func:`PyBytesObject`, :c:func:`PyBytes_Check`, "
":c:func:`PyBytes_FromStringAndSize` 等名称，以及所有用于字符串的其他函数。"

#: ../../whatsnew/2.6.rst:984
msgid ""
"Instances of the :class:`bytes` type are immutable just as strings are.  A "
"new :class:`bytearray` type stores a mutable sequence of bytes::"
msgstr ""
":class:`bytes` 类型的实例与字符串一样属于不可变对象。 新增的 :class:`bytearray` 类型则用于存储可变的字节序列::"

#: ../../whatsnew/2.6.rst:988
msgid ""
">>> bytearray([65, 66, 67])\n"
"bytearray(b'ABC')\n"
">>> b = bytearray(u'\\u21ef\\u3244', 'utf-8')\n"
">>> b\n"
"bytearray(b'\\xe2\\x87\\xaf\\xe3\\x89\\x84')\n"
">>> b[0] = '\\xe3'\n"
">>> b\n"
"bytearray(b'\\xe3\\x87\\xaf\\xe3\\x89\\x84')\n"
">>> unicode(str(b), 'utf-8')\n"
"u'\\u31ef \\u3244'"
msgstr ""
">>> bytearray([65, 66, 67])\n"
"bytearray(b'ABC')\n"
">>> b = bytearray(u'\\u21ef\\u3244', 'utf-8')\n"
">>> b\n"
"bytearray(b'\\xe2\\x87\\xaf\\xe3\\x89\\x84')\n"
">>> b[0] = '\\xe3'\n"
">>> b\n"
"bytearray(b'\\xe3\\x87\\xaf\\xe3\\x89\\x84')\n"
">>> unicode(str(b), 'utf-8')\n"
"u'\\u31ef \\u3244'"

#: ../../whatsnew/2.6.rst:999
msgid ""
"Byte arrays support most of the methods of string types, such as "
":meth:`startswith`/:meth:`endswith`, :meth:`find`/:meth:`rfind`, and some of"
" the methods of lists, such as :meth:`append`, :meth:`pop`,  and "
":meth:`reverse`."
msgstr ""
"字节数组支持大部分的字符串类型方法，如 :meth:`startswith`/:meth:`endswith`, "
":meth:`find`/:meth:`rfind`，以及列表的某些方法，如 :meth:`append`, :meth:`pop` 和 "
":meth:`reverse`。"

#: ../../whatsnew/2.6.rst:1006
msgid ""
">>> b = bytearray('ABC')\n"
">>> b.append('d')\n"
">>> b.append(ord('e'))\n"
">>> b\n"
"bytearray(b'ABCde')"
msgstr ""
">>> b = bytearray('ABC')\n"
">>> b.append('d')\n"
">>> b.append(ord('e'))\n"
">>> b\n"
"bytearray(b'ABCde')"

#: ../../whatsnew/2.6.rst:1012
msgid ""
"There's also a corresponding C API, with :c:func:`PyByteArray_FromObject`, "
":c:func:`PyByteArray_FromStringAndSize`, and various other functions."
msgstr ""
"也有一个相应的 C API，包含 :c:func:`PyByteArray_FromObject`, "
":c:func:`PyByteArray_FromStringAndSize` 以及各种其他函数。"

#: ../../whatsnew/2.6.rst:1019
msgid ":pep:`3112` - Bytes literals in Python 3000"
msgstr ":pep:`3112` - Python 3000 中的字节字面值"

#: ../../whatsnew/2.6.rst:1020
msgid "PEP written by Jason Orendorff; backported to 2.6 by Christian Heimes."
msgstr "PEP 由 Jason Orendorff 撰写， 补丁2.6 由 Christian Heimes 撰写。"

#: ../../whatsnew/2.6.rst:1027
msgid "PEP 3116: New I/O Library"
msgstr "PEP 3116: 新 I/O 库"

#: ../../whatsnew/2.6.rst:1029
msgid ""
"Python's built-in file objects support a number of methods, but file-like "
"objects don't necessarily support all of them.  Objects that imitate files "
"usually support :meth:`read` and :meth:`write`, but they may not support "
":meth:`readline`, for example.  Python 3.0 introduces a layered I/O library "
"in the :mod:`io` module that separates buffering and text-handling features "
"from the fundamental read and write operations."
msgstr ""
"Python 的内置文件对象支持多种方法，但类似文件的对象并不一定支持所有这些方法。模仿文件的对象通常支持 :meth:`read` 和 "
":meth:`write`，但它们可能不支持 :meth:`readline`，例如。Python 3.0 在 :mod:`io` "
"模块中引入了一个分层的 I/O 库，将缓冲和文本处理功能从基本的读写操作中分离出来。"

#: ../../whatsnew/2.6.rst:1037
msgid ""
"There are three levels of abstract base classes provided by the :mod:`io` "
"module:"
msgstr ":mod:`io` 模块提供了三个层次的抽象基类："

#: ../../whatsnew/2.6.rst:1040
msgid ""
":class:`RawIOBase` defines raw I/O operations: :meth:`read`, "
":meth:`readinto`, :meth:`write`, :meth:`seek`, :meth:`tell`, "
":meth:`truncate`, and :meth:`close`. Most of the methods of this class will "
"often map to a single system call. There are also :meth:`readable`, "
":meth:`writable`, and :meth:`seekable` methods for determining what "
"operations a given object will allow."
msgstr ""
":class:`RawIOBase` 定义了原始 I/O "
"操作：:meth:`read`、:meth:`readinto`、:meth:`write`、:meth:`seek`、:meth:`tell`、:meth:`truncate`"
" 和 :meth:`close`。这个类的大部分方法通常映射到单个系统调用。还有 :meth:`readable`、:meth:`writable` 和"
" :meth:`seekable` 方法，用于确定给定对象允许哪些操作。"

#: ../../whatsnew/2.6.rst:1048
msgid ""
"Python 3.0 has concrete implementations of this class for files and sockets,"
" but Python 2.6 hasn't restructured its file and socket objects in this way."
msgstr "Python 3.0 为文件和套接字提供了这个类的具体实现，但 Python 2.6 并没有以这种方式重新组织其文件和套接字对象。"

#: ../../whatsnew/2.6.rst:1052
msgid ""
":class:`BufferedIOBase` is an abstract base class that buffers data in "
"memory to reduce the number of system calls used, making I/O processing more"
" efficient. It supports all of the methods of :class:`RawIOBase`, and adds a"
" :attr:`raw` attribute holding the underlying raw object."
msgstr ""
":class:`BufferedIOBase` 是一个抽象基类，它在内存中缓冲数据，以减少使用的系统调用数量，使 I/O 处理更高效。它支持 "
":class:`RawIOBase` 的所有方法，并添加了一个 :attr:`raw` 属性，用于持有底层的原始对象。"

#: ../../whatsnew/2.6.rst:1058
msgid ""
"There are five concrete classes implementing this ABC. "
":class:`BufferedWriter` and :class:`BufferedReader` are for objects that "
"support write-only or read-only usage that have a :meth:`seek` method for "
"random access.  :class:`BufferedRandom` objects support read and write "
"access upon the same underlying stream, and :class:`BufferedRWPair` is for "
"objects such as TTYs that have both read and write operations acting upon "
"unconnected streams of data. The :class:`BytesIO` class supports reading, "
"writing, and seeking over an in-memory buffer."
msgstr ""
"有五个具体类实现了这个 ABC。:class:`BufferedWriter` 和 :class:`BufferedReader` "
"用于支持只写或只读使用的对象，这些对象具有用于随机访问的 :meth:`seek` 方法。:class:`BufferedRandom` "
"对象支持对同一底层流的读写访问，而 :class:`BufferedRWPair` 用于像 TTY "
"这样的对象，它们的读写操作作用于未连接的数据流。:class:`BytesIO` 类支持在内存缓冲区上进行读取、写入和查找。"

#: ../../whatsnew/2.6.rst:1071
msgid ""
":class:`TextIOBase`: Provides functions for reading and writing strings "
"(remember, strings will be Unicode in Python 3.0), and supporting "
":term:`universal newlines`.  :class:`TextIOBase` defines the "
":meth:`readline` method and supports iteration upon objects."
msgstr ""
":class:`TextIOBase`：提供用于读写字符串的函数（记住，在Python 3.0中字符串将是Unicode），并支持 "
":term:`universal newlines`。:class:`TextIOBase` 定义了 :meth:`readline` "
"方法，并支持对对象进行迭代。"

#: ../../whatsnew/2.6.rst:1077
msgid ""
"There are two concrete implementations.  :class:`TextIOWrapper` wraps a "
"buffered I/O object, supporting all of the methods for text I/O and adding a"
" :attr:`buffer` attribute for access to the underlying object.  "
":class:`StringIO` simply buffers everything in memory without ever writing "
"anything to disk."
msgstr ""
"有两个具体实现。:class:`TextIOWrapper` 包装了一个缓冲I/O对象，支持所有文本I/O方法，并添加了一个 "
":attr:`buffer` 属性以访问底层对象。:class:`StringIO` 简单地在内存中缓冲所有内容，而不将任何内容写入磁盘。"

#: ../../whatsnew/2.6.rst:1083
msgid ""
"(In Python 2.6, :class:`io.StringIO` is implemented in pure Python, so it's "
"pretty slow.   You should therefore stick with the existing :mod:`!StringIO`"
" module or :mod:`!cStringIO` for now.  At some point Python 3.0's :mod:`io` "
"module will be rewritten into C for speed, and perhaps the C implementation "
"will be  backported to the 2.x releases.)"
msgstr ""
"（在Python 2.6中，:class:`io.StringIO` 是用纯Python实现的，因此相当慢。因此，你应该暂时使用现有的 "
":mod:`!StringIO` 模块或 :mod:`!cStringIO`。在某个时候，Python 3.0的 :mod:`io` "
"模块将被重写为C以提高速度，并且C实现可能会向下移植到2.x版本。）"

#: ../../whatsnew/2.6.rst:1089
msgid ""
"In Python 2.6, the underlying implementations haven't been restructured to "
"build on top of the :mod:`io` module's classes.  The module is being "
"provided to make it easier to write code that's forward-compatible with 3.0,"
" and to save developers the effort of writing their own implementations of "
"buffering and text I/O."
msgstr ""
"在Python 2.6中，底层实现尚未重构以建立在 :mod:`io` "
"模块的类之上。提供该模块是为了更容易编写与3.0向前兼容的代码，并节省开发者编写自己的缓冲和文本I/O实现的努力。"

#: ../../whatsnew/2.6.rst:1097
msgid ":pep:`3116` - New I/O"
msgstr ":pep:`3116` - 新 I/O"

#: ../../whatsnew/2.6.rst:1098
msgid ""
"PEP written by Daniel Stutzbach, Mike Verdone, and Guido van Rossum. Code by"
" Guido van Rossum, Georg Brandl, Walter Doerwald, Jeremy Hylton, Martin von "
"Löwis, Tony Lownds, and others."
msgstr ""
"PEP由Daniel Stutzbach、Mike Verdone和Guido van Rossum撰写。由Guido van Rossum、Georg"
" Brandl、Walter Doerwald、Jeremy Hylton、Martin von Löwis、Tony Lownds等人编写代码。"

#: ../../whatsnew/2.6.rst:1107
msgid "PEP 3118: Revised Buffer Protocol"
msgstr "PEP 3118: 修改缓冲区协议"

#: ../../whatsnew/2.6.rst:1109
msgid ""
"The buffer protocol is a C-level API that lets Python types exchange "
"pointers into their internal representations.  A memory-mapped file can be "
"viewed as a buffer of characters, for example, and this lets another module "
"such as :mod:`re` treat memory-mapped files as a string of characters to be "
"searched."
msgstr ""
"缓冲协议是一个C级API，允许Python类型交换指向其内部表示的指针。例如，内存映射文件可以被视为字符缓冲区，这使得另一个模块如 :mod:`re` "
"可以将内存映射文件视为要搜索的字符字符串。"

#: ../../whatsnew/2.6.rst:1115
msgid ""
"The primary users of the buffer protocol are numeric-processing packages "
"such as NumPy, which expose the internal representation of arrays so that "
"callers can write data directly into an array instead of going through a "
"slower API.  This PEP updates the buffer protocol in light of experience "
"from NumPy development, adding a number of new features such as indicating "
"the shape of an array or locking a memory region."
msgstr ""
"缓冲区协议的主要用户是像NumPy这样的数值处理包，它们暴露数组的内部表示，以便调用者可以直接写入数组数据，而不是通过较慢的API。这个PEP根据NumPy开发的经验更新了缓冲区协议，增加了一些新功能，例如指示数组形状或锁定内存区域。"

#: ../../whatsnew/2.6.rst:1122
msgid ""
"The most important new C API function is ``PyObject_GetBuffer(PyObject *obj,"
" Py_buffer *view, int flags)``, which takes an object and a set of flags, "
"and fills in the ``Py_buffer`` structure with information about the object's"
" memory representation.  Objects can use this operation to lock memory in "
"place while an external caller could be modifying the contents, so there's a"
" corresponding ``PyBuffer_Release(Py_buffer *view)`` to indicate that the "
"external caller is done."
msgstr ""
"最重要的新C API函数是 ``PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int "
"flags)``，它接受一个对象和一组标志，并填充 ``Py_buffer`` "
"结构，包含对象内存表示的信息。对象可以使用此操作锁定内存，而外部调用者可能正在修改内容，因此有一个相应的 "
"``PyBuffer_Release(Py_buffer *view)`` 来指示外部调用者已完成。"

#: ../../whatsnew/2.6.rst:1132
msgid ""
"The *flags* argument to :c:func:`PyObject_GetBuffer` specifies constraints "
"upon the memory returned.  Some examples are:"
msgstr ":c:func:`PyObject_GetBuffer` 的 *flags* 参数指明了对所返回内存的约束。 示例如下:"

#: ../../whatsnew/2.6.rst:1135
msgid ":c:macro:`PyBUF_WRITABLE` indicates that the memory must be writable."
msgstr ":c:macro:`PyBUF_WRITABLE` 指明内存必须是可写的。"

#: ../../whatsnew/2.6.rst:1137
msgid ""
":c:macro:`PyBUF_LOCK` requests a read-only or exclusive lock on the memory."
msgstr ":c:macro:`PyBUF_LOCK` 请求一个内存上的只读或独占锁。"

#: ../../whatsnew/2.6.rst:1139
msgid ""
":c:macro:`PyBUF_C_CONTIGUOUS` and :c:macro:`PyBUF_F_CONTIGUOUS` requests a "
"C-contiguous (last dimension varies the fastest) or Fortran-contiguous "
"(first dimension varies the fastest) array layout."
msgstr ""
":c:macro:`PyBUF_C_CONTIGUOUS` 和 :c:macro:`PyBUF_F_CONTIGUOUS` 需要 C "
"连续（最后一个维度变动最快）或 Fortran 连续（第一个维度变动最快）的数组布局。"

#: ../../whatsnew/2.6.rst:1143
msgid ""
"Two new argument codes for :c:func:`PyArg_ParseTuple`, ``s*`` and ``z*``, "
"return locked buffer objects for a parameter."
msgstr ""
"两个用于 :c:func:`PyArg_ParseTuple` 的新参数代码 ``s*`` 和 ``z*``，将为形参返回锁定的缓冲区对象。"

#: ../../whatsnew/2.6.rst:1148
msgid ":pep:`3118` - Revising the buffer protocol"
msgstr ":pep:`3118` - 修改缓冲区协议"

#: ../../whatsnew/2.6.rst:1149
msgid ""
"PEP written by Travis Oliphant and Carl Banks; implemented by Travis "
"Oliphant."
msgstr "PEP 由 Travis Oliphant 和 Carl Banks 撰写，由 Travis Oliphant 实现。"

#: ../../whatsnew/2.6.rst:1158
msgid "PEP 3119: Abstract Base Classes"
msgstr "PEP 3119: 抽象基类"

#: ../../whatsnew/2.6.rst:1160
msgid ""
"Some object-oriented languages such as Java support interfaces, declaring "
"that a class has a given set of methods or supports a given access protocol."
"  Abstract Base Classes (or ABCs) are an equivalent feature for Python. The "
"ABC support consists of an :mod:`abc` module containing a metaclass called "
":class:`ABCMeta`, special handling of this metaclass by the "
":func:`isinstance` and :func:`issubclass` builtins, and a collection of "
"basic ABCs that the Python developers think will be widely useful.  Future "
"versions of Python will probably add more ABCs."
msgstr ""
"一些面向对象的语言，如Java，支持接口，声明一个类具有一组给定方法或支持给定的访问协议。抽象基类（Abstract Base "
"Classes，简称ABCs）是Python中的等效功能。ABC支持包括一个名为 :mod:`abc` 的模块，其中包含一个名为 "
":class:`ABCMeta` 的元类，:func:`isinstance` 和 :func:`issubclass` "
"内置函数对此元类的特殊处理，以及Python开发者认为将广泛有用的一系列基本ABCs。未来版本的Python可能会添加更多的ABCs。"

#: ../../whatsnew/2.6.rst:1170
msgid ""
"Let's say you have a particular class and wish to know whether it supports "
"dictionary-style access.  The phrase \"dictionary-style\" is vague, however."
" It probably means that accessing items with ``obj[1]`` works. Does it imply"
" that setting items with ``obj[2] = value`` works? Or that the object will "
"have :meth:`keys`, :meth:`values`, and :meth:`items` methods?  What about "
"the iterative variants  such as :meth:`iterkeys`?  :meth:`copy` and "
":meth:`update`?  Iterating over the object with :func:`iter`?"
msgstr ""
"假设你有一个特定的类，想知道它是否支持字典式访问。然而，“字典式”这个短语是模糊的。它可能意味着使用 ``obj[1]`` "
"访问项是有效的。这是否意味着使用 ``obj[2] = value`` 设置项也有效？或者对象将有 "
":meth:`keys`、:meth:`values` 和 :meth:`items` 方法？那么迭代变体如 :meth:`iterkeys` "
"呢？:meth:`copy` 和 :meth:`update` 呢？使用 :func:`iter` 迭代对象呢？"

#: ../../whatsnew/2.6.rst:1178
msgid ""
"The Python 2.6 :mod:`collections` module includes a number of different ABCs"
" that represent these distinctions.  :class:`Iterable` indicates that a "
"class defines :meth:`__iter__`, and :class:`Container` means the class "
"defines a :meth:`__contains__` method and therefore supports ``x in y`` "
"expressions.  The basic dictionary interface of getting items, setting "
"items, and :meth:`keys`, :meth:`values`, and :meth:`items`, is defined by "
"the :class:`MutableMapping` ABC."
msgstr ""
"Python 2.6 的 :mod:`collections` "
"模块包含多种不同的抽象基类（ABC），这些类代表了这些区别。:class:`Iterable` 表示一个类定义了 :meth:`__iter__` "
"方法，而 :class:`Container` 表示该类定义了 :meth:`__contains__` 方法，因此支持 ``x in y`` "
"表达式。基本的字典接口，包括获取项目、设置项目以及 :meth:`keys`、:meth:`values` 和 :meth:`items` 方法，由 "
":class:`MutableMapping` 抽象基类定义。"

#: ../../whatsnew/2.6.rst:1187
msgid ""
"You can derive your own classes from a particular ABC to indicate they "
"support that ABC's interface::"
msgstr "你可以从特定的抽象基类派生自己的类，以表明它们支持该抽象基类的接口："

#: ../../whatsnew/2.6.rst:1190
msgid ""
"import collections\n"
"\n"
"class Storage(collections.MutableMapping):\n"
"    ..."
msgstr ""
"import collections\n"
"\n"
"class Storage(collections.MutableMapping):\n"
"    ..."

#: ../../whatsnew/2.6.rst:1196
msgid ""
"Alternatively, you could write the class without deriving from the desired "
"ABC and instead register the class by calling the ABC's :meth:`register` "
"method::"
msgstr "或者，你可以不从一个期望的抽象基类派生类，而是通过调用抽象基类的 :meth:`register` 方法来注册该类："

#: ../../whatsnew/2.6.rst:1200
msgid ""
"import collections\n"
"\n"
"class Storage:\n"
"    ...\n"
"\n"
"collections.MutableMapping.register(Storage)"
msgstr ""
"import collections\n"
"\n"
"class Storage:\n"
"    ...\n"
"\n"
"collections.MutableMapping.register(Storage)"

#: ../../whatsnew/2.6.rst:1207
msgid ""
"For classes that you write, deriving from the ABC is probably clearer. The "
":meth:`register`  method is useful when you've written a new ABC that can "
"describe an existing type or class, or if you want to declare that some "
"third-party class implements an ABC. For example, if you defined a "
":class:`PrintableType` ABC, it's legal to do::"
msgstr ""
"对于你编写的类，从抽象基类派生可能更清晰。:meth:`register` "
"方法在你编写了一个新的抽象基类，可以描述一个现有类型或类，或者你想声明某个第三方类实现了抽象基类时很有用。例如，如果你定义了一个 "
":class:`PrintableType` 抽象基类，可以这样操作："

#: ../../whatsnew/2.6.rst:1214
msgid ""
"# Register Python's types\n"
"PrintableType.register(int)\n"
"PrintableType.register(float)\n"
"PrintableType.register(str)"
msgstr ""
"# 注册 Python 的类型\n"
"PrintableType.register(int)\n"
"PrintableType.register(float)\n"
"PrintableType.register(str)"

#: ../../whatsnew/2.6.rst:1219
msgid ""
"Classes should obey the semantics specified by an ABC, but Python can't "
"check this; it's up to the class author to understand the ABC's requirements"
" and to implement the code accordingly."
msgstr "类应该遵守抽象基类指定的语义，但 Python 无法检查这一点；这取决于类作者理解抽象基类的要求并相应地实现代码。"

#: ../../whatsnew/2.6.rst:1223
msgid ""
"To check whether an object supports a particular interface, you can now "
"write::"
msgstr "要检查一个对象是否支持特定接口，你现在可以编写："

#: ../../whatsnew/2.6.rst:1226
msgid ""
"def func(d):\n"
"    if not isinstance(d, collections.MutableMapping):\n"
"        raise ValueError(\"Mapping object expected, not %r\" % d)"
msgstr ""
"def func(d):\n"
"    if not isinstance(d, collections.MutableMapping):\n"
"        raise ValueError(\"期望映射对象，而不是 %r\" % d)"

#: ../../whatsnew/2.6.rst:1230
msgid ""
"Don't feel that you must now begin writing lots of checks as in the above "
"example.  Python has a strong tradition of duck-typing, where explicit type-"
"checking is never done and code simply calls methods on an object, trusting "
"that those methods will be there and raising an exception if they aren't.  "
"Be judicious in checking for ABCs and only do it where it's absolutely "
"necessary."
msgstr ""
"不要觉得你必须像上面例子那样开始编写大量检查。Python "
"有一种强烈的鸭子类型传统，在这种传统中，从不进行显式类型检查，代码只是简单地调用对象上的方法，相信这些方法会存在，如果不存在则会引发异常。在检查 ABC"
" 时要明智，并且只在绝对必要时才进行检查。"

#: ../../whatsnew/2.6.rst:1237
msgid ""
"You can write your own ABCs by using ``abc.ABCMeta`` as the metaclass in a "
"class definition::"
msgstr "你可以通过在类定义中使用 ``abc.ABCMeta`` 作为元类来编写自己的 ABC::"

#: ../../whatsnew/2.6.rst:1240
msgid ""
"from abc import ABCMeta, abstractmethod\n"
"\n"
"class Drawable():\n"
"    __metaclass__ = ABCMeta\n"
"\n"
"    @abstractmethod\n"
"    def draw(self, x, y, scale=1.0):\n"
"        pass\n"
"\n"
"    def draw_doubled(self, x, y):\n"
"        self.draw(x, y, scale=2.0)\n"
"\n"
"\n"
"class Square(Drawable):\n"
"    def draw(self, x, y, scale):\n"
"        ..."
msgstr ""
"from abc import ABCMeta, abstractmethod\n"
"\n"
"class Drawable():\n"
"    __metaclass__ = ABCMeta\n"
"\n"
"    @abstractmethod\n"
"    def draw(self, x, y, scale=1.0):\n"
"        pass\n"
"\n"
"    def draw_doubled(self, x, y):\n"
"        self.draw(x, y, scale=2.0)\n"
"\n"
"\n"
"class Square(Drawable):\n"
"    def draw(self, x, y, scale):\n"
"        ..."

#: ../../whatsnew/2.6.rst:1258
msgid ""
"In the :class:`Drawable` ABC above, the :meth:`draw_doubled` method renders "
"the object at twice its size and can be implemented in terms of other "
"methods described in :class:`Drawable`.  Classes implementing this ABC "
"therefore don't need to provide their own implementation of "
":meth:`draw_doubled`, though they can do so.  An implementation of "
":meth:`draw` is necessary, though; the ABC can't provide a useful generic "
"implementation."
msgstr ""
"在上面的 :class:`Drawable` ABC 中，:meth:`draw_doubled` 方法以两倍大小渲染对象，并且可以依据 "
":class:`Drawable` 中描述的其他方法来实现。因此，实现此 ABC 的类不需要提供自己的 :meth:`draw_doubled` "
"实现，尽管它们可以这样做。但是必须实现 :meth:`draw`；ABC 不能提供有用的通用实现。"

#: ../../whatsnew/2.6.rst:1266
msgid ""
"You can apply the ``@abstractmethod`` decorator to methods such as "
":meth:`draw` that must be implemented; Python will then raise an exception "
"for classes that don't define the method. Note that the exception is only "
"raised when you actually try to create an instance of a subclass lacking the"
" method::"
msgstr ""
"你可以将 ``@abstractmethod`` 装饰器应用于必须实现的诸如 :meth:`draw` 这样的方法；Python "
"将对未定义该方法的类引发异常。请注意，只有在实际尝试创建缺少该方法的子类实例时，才会引发异常::"

#: ../../whatsnew/2.6.rst:1272
msgid ""
">>> class Circle(Drawable):\n"
"...     pass\n"
"...\n"
">>> c = Circle()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: Can't instantiate abstract class Circle with abstract methods draw\n"
">>>"
msgstr ""
">>> class Circle(Drawable):\n"
"...     pass\n"
"...\n"
">>> c = Circle()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: Can't instantiate abstract class Circle with abstract methods draw\n"
">>>"

#: ../../whatsnew/2.6.rst:1281
msgid ""
"Abstract data attributes can be declared using the ``@abstractproperty`` "
"decorator::"
msgstr "可以使用 ``@abstractproperty`` 装饰器声明抽象数据属性::"

#: ../../whatsnew/2.6.rst:1284
msgid ""
"from abc import abstractproperty\n"
"...\n"
"\n"
"@abstractproperty\n"
"def readonly(self):\n"
"   return self._x"
msgstr ""
"from abc import abstractproperty\n"
"...\n"
"\n"
"@abstractproperty\n"
"def readonly(self):\n"
"   return self._x"

#: ../../whatsnew/2.6.rst:1291
msgid "Subclasses must then define a :meth:`readonly` property."
msgstr "子类必须定义一个 :meth:`readonly` 属性。"

#: ../../whatsnew/2.6.rst:1295
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 引入抽象基类"

#: ../../whatsnew/2.6.rst:1296
msgid ""
"PEP written by Guido van Rossum and Talin. Implemented by Guido van Rossum. "
"Backported to 2.6 by Benjamin Aranguren, with Alex Martelli."
msgstr ""
"PEP 由 Guido van Rossum 和 Talin 编写。由 Guido van Rossum 实现。由 Benjamin Aranguren"
" 回退到 2.6 版本，Alex Martelli 协助。"

#: ../../whatsnew/2.6.rst:1305
msgid "PEP 3127: Integer Literal Support and Syntax"
msgstr "PEP 3127: 整型文字支持和语法"

#: ../../whatsnew/2.6.rst:1307
msgid ""
"Python 3.0 changes the syntax for octal (base-8) integer literals, prefixing"
" them with \"0o\" or \"0O\" instead of a leading zero, and adds support for "
"binary (base-2) integer literals, signalled by a \"0b\" or \"0B\" prefix."
msgstr ""
"Python 3.0 改变了八进制（基数为8）整数的语法，使用 \"0o\" 或 \"0O\" "
"作为前缀，而不是以零开头，并增加了对二进制（基数为2）整数的支持，使用 \"0b\" 或 \"0B\" 作为前缀。"

#: ../../whatsnew/2.6.rst:1312
msgid ""
"Python 2.6 doesn't drop support for a leading 0 signalling an octal number, "
"but it does add support for \"0o\" and \"0b\"::"
msgstr "Python 2.6 并没有放弃以零开头表示八进制数的支持，但增加了对 \"0o\" 和 \"0b\" 的支持::"

#: ../../whatsnew/2.6.rst:1315
msgid ""
">>> 0o21, 2*8 + 1\n"
"(17, 17)\n"
">>> 0b101111\n"
"47"
msgstr ""
">>> 0o21, 2*8 + 1\n"
"(17, 17)\n"
">>> 0b101111\n"
"47"

#: ../../whatsnew/2.6.rst:1320
msgid ""
"The :func:`oct` builtin still returns numbers prefixed with a leading zero, "
"and a new :func:`bin` builtin returns the binary representation for a "
"number::"
msgstr "内置的 :func:`oct` 函数仍然返回以零开头的数字，而新的 :func:`bin` 函数返回数字的二进制表示::"

#: ../../whatsnew/2.6.rst:1324
msgid ""
">>> oct(42)\n"
"'052'\n"
">>> future_builtins.oct(42)\n"
"'0o52'\n"
">>> bin(173)\n"
"'0b10101101'"
msgstr ""
">>> oct(42)\n"
"'052'\n"
">>> future_builtins.oct(42)\n"
"'0o52'\n"
">>> bin(173)\n"
"'0b10101101'"

#: ../../whatsnew/2.6.rst:1331
msgid ""
"The :func:`int` and :func:`long` builtins will now accept the \"0o\" and "
"\"0b\" prefixes when base-8 or base-2 are requested, or when the *base* "
"argument is zero (signalling that the base used should be determined from "
"the string)::"
msgstr ""
"内置的 :func:`int` 和 :func:`long` 函数现在接受 \"0o\" 和 \"0b\" 前缀，当请求基数为8或2时，或者当 "
"*base* 参数为零（表示应从字符串确定使用的基数）::"

#: ../../whatsnew/2.6.rst:1336
msgid ""
">>> int ('0o52', 0)\n"
"42\n"
">>> int('1101', 2)\n"
"13\n"
">>> int('0b1101', 2)\n"
"13\n"
">>> int('0b1101', 0)\n"
"13"
msgstr ""
">>> int ('0o52', 0)\n"
"42\n"
">>> int('1101', 2)\n"
"13\n"
">>> int('0b1101', 2)\n"
"13\n"
">>> int('0b1101', 0)\n"
"13"

#: ../../whatsnew/2.6.rst:1348
msgid ":pep:`3127` - Integer Literal Support and Syntax"
msgstr ":pep:`3127` - 整型字面量支持和语法"

#: ../../whatsnew/2.6.rst:1349
msgid "PEP written by Patrick Maupin; backported to 2.6 by Eric Smith."
msgstr "PEP 由 Patrick Maupin 编写；由 Eric Smith 回退到 2.6 版本。"

#: ../../whatsnew/2.6.rst:1357
msgid "PEP 3129: Class Decorators"
msgstr "PEP 3129: 类装饰器"

#: ../../whatsnew/2.6.rst:1359
msgid ""
"Decorators have been extended from functions to classes.  It's now legal to "
"write::"
msgstr "装饰器已从函数扩展到类。 现在可以合法地编写::"

#: ../../whatsnew/2.6.rst:1362
msgid ""
"@foo\n"
"@bar\n"
"class A:\n"
"  pass"
msgstr ""
"@foo\n"
"@bar\n"
"class A:\n"
"  pass"

#: ../../whatsnew/2.6.rst:1367
msgid "This is equivalent to::"
msgstr "这相当于："

#: ../../whatsnew/2.6.rst:1369
msgid ""
"class A:\n"
"  pass\n"
"\n"
"A = foo(bar(A))"
msgstr ""
"class A:\n"
"  pass\n"
"\n"
"A = foo(bar(A))"

#: ../../whatsnew/2.6.rst:1376
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 类装饰器"

#: ../../whatsnew/2.6.rst:1377
msgid "PEP written by Collin Winter."
msgstr "PEP 由 Collin Winter 撰写。"

#: ../../whatsnew/2.6.rst:1384
msgid "PEP 3141: A Type Hierarchy for Numbers"
msgstr "PEP 3141: 数字的类型层级结构"

#: ../../whatsnew/2.6.rst:1386
msgid ""
"Python 3.0 adds several abstract base classes for numeric types inspired by "
"Scheme's numeric tower.  These classes were backported to 2.6 as the "
":mod:`numbers` module."
msgstr ""
"Python 3.0 增加了几种受 Scheme 数值塔启发的数值类型的抽象基类。这些类已回退到 2.6 版本，作为 :mod:`numbers` "
"模块。"

#: ../../whatsnew/2.6.rst:1390
msgid ""
"The most general ABC is :class:`Number`.  It defines no operations at all, "
"and only exists to allow checking if an object is a number by doing "
"``isinstance(obj, Number)``."
msgstr ""
"最通用的 ABC 是 :class:`Number`。它定义了没有任何操作，仅用于通过 ``isinstance(obj, Number)`` "
"检查对象是否为数字。"

#: ../../whatsnew/2.6.rst:1394
msgid ""
":class:`Complex` is a subclass of :class:`Number`.  Complex numbers can "
"undergo the basic operations of addition, subtraction, multiplication, "
"division, and exponentiation, and you can retrieve the real and imaginary "
"parts and obtain a number's conjugate.  Python's built-in complex type is an"
" implementation of :class:`Complex`."
msgstr ""
":class:`Complex` 是 :class:`Number` "
"的子类。复数可以进行加法、减法、乘法、除法和指数运算，并且可以检索实部和虚部以及获得一个数的共轭。Python 内置的复数类型是 "
":class:`Complex` 的实现。"

#: ../../whatsnew/2.6.rst:1400
msgid ""
":class:`Real` further derives from :class:`Complex`, and adds operations "
"that only work on real numbers: :func:`floor`, :func:`trunc`, rounding, "
"taking the remainder mod N, floor division, and comparisons."
msgstr ""
":class:`Real` 进一步从 :class:`Complex` "
"派生，并添加了仅适用于实数的操作：:func:`floor`，:func:`trunc`，四舍五入，取模 N 的余数，地板除法以及比较操作。"

#: ../../whatsnew/2.6.rst:1405
msgid ""
":class:`Rational` numbers derive from :class:`Real`, have :attr:`numerator` "
"and :attr:`denominator` properties, and can be converted to floats.  Python "
"2.6 adds a simple rational-number class, :class:`Fraction`, in the "
":mod:`fractions` module.  (It's called :class:`Fraction` instead of "
":class:`Rational` to avoid a name clash with :class:`numbers.Rational`.)"
msgstr ""
":class:`Rational` 数从 :class:`Real` 派生，具有 :attr:`numerator` 和 "
":attr:`denominator` 属性，并且可以转换为浮点数。Python 2.6 在 :mod:`fractions` "
"模块中添加了一个简单的有理数类，:class:`Fraction`。（它被称为 :class:`Fraction` 而不是 "
":class:`Rational`，以避免与 :class:`numbers.Rational` 名称冲突。）"

#: ../../whatsnew/2.6.rst:1412
msgid ""
":class:`Integral` numbers derive from :class:`Rational`, and can be shifted "
"left and right with ``<<`` and ``>>``, combined using bitwise operations "
"such as ``&`` and ``|``, and can be used as array indexes and slice "
"boundaries."
msgstr ""
":class:`Integral` 数从 :class:`Rational` 派生，可以使用 ``<<`` 和 ``>>`` "
"进行左右移位，通过按位操作（如 ``&`` 和 ``|``）进行组合，并且可以用作数组索引和切片边界。"

#: ../../whatsnew/2.6.rst:1417
msgid ""
"In Python 3.0, the PEP slightly redefines the existing builtins "
":func:`round`, :func:`math.floor`, :func:`math.ceil`, and adds a new one, "
":func:`math.trunc`, that's been backported to Python 2.6. :func:`math.trunc`"
" rounds toward zero, returning the closest :class:`Integral` that's between "
"the function's argument and zero."
msgstr ""
"在 Python 3.0 中，PEP 稍微重新定义了现有的内置函数 "
":func:`round`，:func:`math.floor`，:func:`math.ceil`，并添加了一个新的函数 "
":func:`math.trunc`，该函数已被回移植到 Python 2.6。:func:`math.trunc` "
"向零舍入，返回介于函数参数和零之间的最接近的 :class:`Integral`。"

#: ../../whatsnew/2.6.rst:1425
msgid ":pep:`3141` - A Type Hierarchy for Numbers"
msgstr ":pep:`3141` - 数字的类型层次结构"

#: ../../whatsnew/2.6.rst:1426
msgid "PEP written by Jeffrey Yasskin."
msgstr "PEP 由 Jeffrey Yasskin 撰写。"

#: ../../whatsnew/2.6.rst:1428
msgid ""
"`Scheme's numerical tower "
"<https://www.gnu.org/software/guile/manual/html_node/Numerical-"
"Tower.html#Numerical-Tower>`__, from the Guile manual."
msgstr ""
"`Scheme 的数值塔 <https://www.gnu.org/software/guile/manual/html_node/Numerical-"
"Tower.html#Numerical-Tower>`__，来自 Guile 手册。"

#: ../../whatsnew/2.6.rst:1430
msgid ""
"`Scheme's number datatypes "
"<https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs-"
"Z-H-9.html#%_sec_6.2>`__ from the R5RS Scheme specification."
msgstr ""
"`Scheme 的数字数据类型 "
"<https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs-"
"Z-H-9.html#%_sec_6.2>`__，来自 R5RS Scheme 规范。"

#: ../../whatsnew/2.6.rst:1434
msgid "The :mod:`fractions` Module"
msgstr ":mod:`fractions` 模块"

#: ../../whatsnew/2.6.rst:1436
msgid ""
"To fill out the hierarchy of numeric types, the :mod:`fractions` module "
"provides a rational-number class.  Rational numbers store their values as a "
"numerator and denominator forming a fraction, and can exactly represent "
"numbers such as ``2/3`` that floating-point numbers can only approximate."
msgstr ""
"为了完善数值类型的层次结构，:mod:`fractions` 模块提供了一个有理数类。有理数将它们的值存储为一个分数的分子和分母，可以精确表示诸如 "
"``2/3`` 这样的数，而浮点数只能近似表示。"

#: ../../whatsnew/2.6.rst:1442
msgid ""
"The :class:`Fraction` constructor takes two :class:`Integral` values that "
"will be the numerator and denominator of the resulting fraction. ::"
msgstr ":class:`Fraction` 构造函数接受两个 :class:`Integral` 值，这两个值将分别是结果分数的分子和分母。 ::"

#: ../../whatsnew/2.6.rst:1445
msgid ""
">>> from fractions import Fraction\n"
">>> a = Fraction(2, 3)\n"
">>> b = Fraction(2, 5)\n"
">>> float(a), float(b)\n"
"(0.66666666666666663, 0.40000000000000002)\n"
">>> a+b\n"
"Fraction(16, 15)\n"
">>> a/b\n"
"Fraction(5, 3)"
msgstr ""
">>> 从 fractions 导入 Fraction\n"
">>> a = Fraction(2, 3)\n"
">>> b = Fraction(2, 5)\n"
">>> float(a), float(b)\n"
"(0.66666666666666663, 0.40000000000000002)\n"
">>> a+b\n"
"Fraction(16, 15)\n"
">>> a/b\n"
"Fraction(5, 3)"

#: ../../whatsnew/2.6.rst:1455
msgid ""
"For converting floating-point numbers to rationals, the float type now has "
"an :meth:`as_integer_ratio` method that returns the numerator and "
"denominator for a fraction that evaluates to the same floating-point value::"
msgstr ""
"为了将浮点数转换为有理数，float 类型现在有一个 :meth:`as_integer_ratio` "
"方法，该方法返回一个分数的分子和分母，该分数计算结果与相同的浮点值相等::"

#: ../../whatsnew/2.6.rst:1460
msgid ""
">>> (2.5) .as_integer_ratio()\n"
"(5, 2)\n"
">>> (3.1415) .as_integer_ratio()\n"
"(7074029114692207L, 2251799813685248L)\n"
">>> (1./3) .as_integer_ratio()\n"
"(6004799503160661L, 18014398509481984L)"
msgstr ""
">>> (2.5) .as_integer_ratio()\n"
"(5, 2)\n"
">>> (3.1415) .as_integer_ratio()\n"
"(7074029114692207L, 2251799813685248L)\n"
">>> (1./3) .as_integer_ratio()\n"
"(6004799503160661L, 18014398509481984L)"

#: ../../whatsnew/2.6.rst:1467
msgid ""
"Note that values that can only be approximated by floating-point numbers, "
"such as 1./3, are not simplified to the number being approximated; the "
"fraction attempts to match the floating-point value **exactly**."
msgstr "请注意，只能由浮点数近似表示的值，例如 1./3，不会被简化为被近似的数；分数尝试**精确**匹配浮点值。"

#: ../../whatsnew/2.6.rst:1472
msgid ""
"The :mod:`fractions` module is based upon an implementation by Sjoerd "
"Mullender that was in Python's :file:`Demo/classes/` directory for a long "
"time.  This implementation was significantly updated by Jeffrey Yasskin."
msgstr ""
":mod:`fractions` 模块基于 Sjoerd Mullender 的实现，该实现曾在 Python 的 "
":file:`Demo/classes/` 目录中存在很长时间。这一实现由 Jeffrey Yasskin 进行了显著更新。"

#: ../../whatsnew/2.6.rst:1479
msgid "Other Language Changes"
msgstr "其他语言特性修改"

#: ../../whatsnew/2.6.rst:1481
msgid "Some smaller changes made to the core Python language are:"
msgstr "对Python 语言核心进行的小改动："

#: ../../whatsnew/2.6.rst:1483
msgid ""
"Directories and zip archives containing a :file:`__main__.py` file can now "
"be executed directly by passing their name to the interpreter. The directory"
" or zip archive is automatically inserted as the first entry in sys.path.  "
"(Suggestion and initial patch by Andy Chu, subsequently revised by Phillip "
"J. Eby and Nick Coghlan; :issue:`1739468`.)"
msgstr ""
"包含 :file:`__main__.py` 文件的目录和 zip 存档现在可以通过将其名称传递给解释器来直接执行。目录或 zip 存档会自动插入到 "
"sys.path 的第一个条目中。（建议和初始补丁由 Andy Chu 提出，随后由 Phillip J. Eby 和 Nick Coghlan "
"修订；:issue:`1739468`。）"

#: ../../whatsnew/2.6.rst:1490
msgid ""
"The :func:`hasattr` function was catching and ignoring all errors, under the"
" assumption that they meant a :meth:`__getattr__` method was failing somehow"
" and the return value of :func:`hasattr` would therefore be ``False``.  This"
" logic shouldn't be applied to :exc:`KeyboardInterrupt` and "
":exc:`SystemExit`, however; Python 2.6 will no longer discard such "
"exceptions when :func:`hasattr` encounters them.  (Fixed by Benjamin "
"Peterson; :issue:`2196`.)"
msgstr ""
":func:`hasattr` 函数在假设所有错误意味着 :meth:`__getattr__` 方法以某种方式失败，并且 "
":func:`hasattr` 的返回值因此为 ``False`` 的情况下，会捕获并忽略所有错误。然而，这种逻辑不应适用于 "
":exc:`KeyboardInterrupt` 和 :exc:`SystemExit`；Python 2.6 在 :func:`hasattr` "
"遇到这些异常时将不再丢弃它们。（由 Benjamin Peterson 修复；:issue:`2196`。）"

#: ../../whatsnew/2.6.rst:1498
msgid ""
"When calling a function using the ``**`` syntax to provide keyword "
"arguments, you are no longer required to use a Python dictionary; any "
"mapping will now work::"
msgstr "当使用 ``**`` 语法调用函数以提供关键字参数时，你不再需要使用 Python 字典；现在任何映射都将有效::"

#: ../../whatsnew/2.6.rst:1502
msgid ""
">>> def f(**kw):\n"
"...    print sorted(kw)\n"
"...\n"
">>> ud=UserDict.UserDict()\n"
">>> ud['a'] = 1\n"
">>> ud['b'] = 'string'\n"
">>> f(**ud)\n"
"['a', 'b']"
msgstr ""
">>> def f(**kw):\n"
"...    print sorted(kw)\n"
"...\n"
">>> ud=UserDict.UserDict()\n"
">>> ud['a'] = 1\n"
">>> ud['b'] = 'string'\n"
">>> f(**ud)\n"
"['a', 'b']"

#: ../../whatsnew/2.6.rst:1511
msgid "(Contributed by Alexander Belopolsky; :issue:`1686487`.)"
msgstr "（由 Alexander Belopolsky 在 :issue:`1686487` 中贡献。）"

#: ../../whatsnew/2.6.rst:1513
msgid ""
"It's also become legal to provide keyword arguments after a ``*args`` "
"argument to a function call. ::"
msgstr "在函数调用的 ``*args`` 参数之后提供关键字参数也是合法的。 ::"

#: ../../whatsnew/2.6.rst:1516
msgid ""
">>> def f(*args, **kw):\n"
"...     print args, kw\n"
"...\n"
">>> f(1,2,3, *(4,5,6), keyword=13)\n"
"(1, 2, 3, 4, 5, 6) {'keyword': 13}"
msgstr ""
">>> def f(*args, **kw):\n"
"...     print args, kw\n"
"...\n"
">>> f(1,2,3, *(4,5,6), keyword=13)\n"
"(1, 2, 3, 4, 5, 6) {'keyword': 13}"

#: ../../whatsnew/2.6.rst:1522
msgid ""
"Previously this would have been a syntax error. (Contributed by Amaury "
"Forgeot d'Arc; :issue:`3473`.)"
msgstr "在之前版本中这会导致语法错误。 （由 Amaury Forgeot d'Arc 贡献；:issue:`3473`。）"

#: ../../whatsnew/2.6.rst:1525
msgid ""
"A new builtin, ``next(iterator, [default])`` returns the next item from the "
"specified iterator.  If the *default* argument is supplied, it will be "
"returned if *iterator* has been exhausted; otherwise, the "
":exc:`StopIteration` exception will be raised.  (Backported in "
":issue:`2719`.)"
msgstr ""
"一个新的内置函数 ``next(iterator, [default])`` 返回指定迭代器的下一个项目。如果提供了 *default* 参数，当 "
"*iterator* 耗尽时会返回该值；否则，将引发 :exc:`StopIteration` 异常。（已在 :issue:`2719` 中回溯。）"

#: ../../whatsnew/2.6.rst:1531
msgid ""
"Tuples now have :meth:`index` and :meth:`count` methods matching the list "
"type's :meth:`index` and :meth:`count` methods::"
msgstr ""
"元组现在有了 :meth:`index` 和 :meth:`count` 方法，与列表类型的 :meth:`index` 和 :meth:`count`"
" 方法相匹配::"

#: ../../whatsnew/2.6.rst:1534
msgid ""
">>> t = (0,1,2,3,4,0,1,2)\n"
">>> t.index(3)\n"
"3\n"
">>> t.count(0)\n"
"2"
msgstr ""
">>> t = (0,1,2,3,4,0,1,2)\n"
">>> t.index(3)\n"
"3\n"
">>> t.count(0)\n"
"2"

#: ../../whatsnew/2.6.rst:1540
msgid "(Contributed by Raymond Hettinger)"
msgstr "（由 Raymond Hettinger 贡献）"

#: ../../whatsnew/2.6.rst:1542
msgid ""
"The built-in types now have improved support for extended slicing syntax, "
"accepting various combinations of ``(start, stop, step)``. Previously, the "
"support was partial and certain corner cases wouldn't work. (Implemented by "
"Thomas Wouters.)"
msgstr ""
"内置类型现在改进了对扩展切片语法的支持，接受各种 ``(start, stop, step)`` 的组合。之前，支持是部分的，某些边缘情况无法工作。（由"
" Thomas Wouters 实现。）"

#: ../../whatsnew/2.6.rst:1549
msgid ""
"Properties now have three attributes, :attr:`getter`, :attr:`setter` and "
":attr:`deleter`, that are decorators providing useful shortcuts for adding a"
" getter, setter or deleter function to an existing property. You would use "
"them like this::"
msgstr ""
"属性现在有三个属性，:attr:`getter`、:attr:`setter` 和 "
":attr:`deleter`，这些是装饰器，提供了向现有属性添加获取器、设置器或删除器函数的有用快捷方式。你可以像这样使用它们::"

#: ../../whatsnew/2.6.rst:1554
msgid ""
"class C(object):\n"
"    @property\n"
"    def x(self):\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x\n"
"\n"
"class D(C):\n"
"    @C.x.getter\n"
"    def x(self):\n"
"        return self._x * 2\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value / 2"
msgstr ""
"class C(object):\n"
"    @property\n"
"    def x(self):\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x\n"
"\n"
"class D(C):\n"
"    @C.x.getter\n"
"    def x(self):\n"
"        return self._x * 2\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value / 2"

#: ../../whatsnew/2.6.rst:1576
msgid ""
"Several methods of the built-in set types now accept multiple iterables: "
":meth:`intersection`, :meth:`intersection_update`, :meth:`union`, "
":meth:`update`, :meth:`difference` and :meth:`difference_update`."
msgstr ""
"内置集合类型的几种方法现在接受多个可迭代对象：:meth:`intersection`、:meth:`intersection_update`、:meth:`union`、:meth:`update`、:meth:`difference`"
" 和 :meth:`difference_update`。"

#: ../../whatsnew/2.6.rst:1584
msgid ""
">>> s=set('1234567890')\n"
">>> s.intersection('abc123', 'cdf246')  # Intersection between all inputs\n"
"set(['2'])\n"
">>> s.difference('246', '789')\n"
"set(['1', '0', '3', '5'])"
msgstr ""
">>> s=set('1234567890')\n"
">>> s.intersection('abc123', 'cdf246')  # 所有输入的交集\n"
"set(['2'])\n"
">>> s.difference('246', '789')\n"
"set(['1', '0', '3', '5'])"

#: ../../whatsnew/2.6.rst:1590 ../../whatsnew/2.6.rst:1875
#: ../../whatsnew/2.6.rst:1896
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:1592
msgid ""
"Many floating-point features were added.  The :func:`float` function will "
"now turn the string ``nan`` into an IEEE 754 Not A Number value, and "
"``+inf`` and ``-inf`` into positive or negative infinity.  This works on any"
" platform with IEEE 754 semantics.  (Contributed by Christian Heimes; "
":issue:`1635`.)"
msgstr ""
"添加了许多浮点特性。:func:`float` 函数现在会将字符串 ``nan`` 转换为 IEEE 754 非数值，将 ``+inf`` 和 "
"``-inf`` 转换为正无穷或负无穷。这适用于任何具有 IEEE 754 语义的平台。（由 Christian Heimes "
"贡献；:issue:`1635`。）"

#: ../../whatsnew/2.6.rst:1598
msgid ""
"Other functions in the :mod:`math` module, :func:`isinf` and :func:`isnan`, "
"return true if their floating-point argument is infinite or Not A Number.  "
"(:issue:`1640`)"
msgstr ""
":mod:`math` 模块中的其他函数，:func:`isinf` 和 "
":func:`isnan`，如果它们的浮点参数是无穷大或非数值，则返回真。（:issue:`1640`）"

#: ../../whatsnew/2.6.rst:1602
msgid ""
"Conversion functions were added to convert floating-point numbers into "
"hexadecimal strings (:issue:`3008`).  These functions convert floats to and "
"from a string representation without introducing rounding errors from the "
"conversion between decimal and binary.  Floats have a :meth:`hex` method "
"that returns a string representation, and the ``float.fromhex()`` method "
"converts a string back into a number::"
msgstr ""
"添加了转换函数，用于将浮点数转换为十六进制字符串（:issue:`3008`）。这些函数在将浮点数转换为字符串表示形式以及从字符串表示形式转换回浮点数时，不会引入十进制和二进制之间的转换误差。浮点数有一个"
" :meth:`hex` 方法，返回其字符串表示形式，而 ``float.fromhex()`` 方法将字符串转换回数字："

#: ../../whatsnew/2.6.rst:1610
msgid ""
">>> a = 3.75\n"
">>> a.hex()\n"
"'0x1.e000000000000p+1'\n"
">>> float.fromhex('0x1.e000000000000p+1')\n"
"3.75\n"
">>> b=1./3\n"
">>> b.hex()\n"
"'0x1.5555555555555p-2'"
msgstr ""
">>> a = 3.75\n"
">>> a.hex()\n"
"'0x1.e000000000000p+1'\n"
">>> float.fromhex('0x1.e000000000000p+1')\n"
"3.75\n"
">>> b=1./3\n"
">>> b.hex()\n"
"'0x1.5555555555555p-2'"

#: ../../whatsnew/2.6.rst:1619
msgid ""
"A numerical nicety: when creating a complex number from two floats on "
"systems that support signed zeros (-0 and +0), the :func:`complex` "
"constructor will now preserve the sign of the zero.  (Fixed by Mark T. "
"Dickinson; :issue:`1507`.)"
msgstr ""
"一个数值上的细节：在支持有符号零（-0 和 +0）的系统上，从两个浮点数创建复数时，:func:`complex` 构造函数现在将保留零的符号。（由 "
"Mark T. Dickinson 修复；:issue:`1507`。）"

#: ../../whatsnew/2.6.rst:1624
msgid ""
"Classes that inherit a :meth:`__hash__` method from a parent class can set "
"``__hash__ = None`` to indicate that the class isn't hashable.  This will "
"make ``hash(obj)`` raise a :exc:`TypeError` and the class will not be "
"indicated as implementing the :class:`Hashable` ABC."
msgstr ""
"从父类继承 :meth:`__hash__` 方法的类可以通过设置 ``__hash__ = None`` 来表示该类不可哈希。这将使 "
"``hash(obj)`` 抛出 :exc:`TypeError`，并且该类不会被视为实现了 :class:`Hashable` ABC。"

#: ../../whatsnew/2.6.rst:1630
msgid ""
"You should do this when you've defined a :meth:`__cmp__` or :meth:`__eq__` "
"method that compares objects by their value rather than by identity.  All "
"objects have a default hash method that uses ``id(obj)`` as the hash value."
"  There's no tidy way to remove the :meth:`__hash__` method inherited from a"
" parent class, so assigning ``None`` was implemented as an override.  At the"
" C level, extensions can set ``tp_hash`` to "
":c:func:`PyObject_HashNotImplemented`. (Fixed by Nick Coghlan and Amaury "
"Forgeot d'Arc; :issue:`2235`.)"
msgstr ""
"当你定义了 :meth:`__cmp__` 或 :meth:`__eq__` "
"方法，且这些方法通过值而不是身份比较对象时，应该这样做。所有对象都有一个默认的哈希方法，使用 ``id(obj)`` "
"作为哈希值。没有简洁的方法来移除从父类继承的 :meth:`__hash__` 方法，因此将 ``None`` 赋值作为覆盖实现。在 C "
"语言层面，扩展可以将 ``tp_hash`` 设置为 :c:func:`PyObject_HashNotImplemented`。（由 Nick "
"Coghlan 和 Amaury Forgeot d'Arc 修复；:issue:`2235`。）"

#: ../../whatsnew/2.6.rst:1640
msgid ""
"The :exc:`GeneratorExit` exception now subclasses :exc:`BaseException` "
"instead of :exc:`Exception`.  This means that an exception handler that does"
" ``except Exception:`` will not inadvertently catch :exc:`GeneratorExit`. "
"(Contributed by Chad Austin; :issue:`1537`.)"
msgstr ""
":exc:`GeneratorExit` 异常现在继承自 :exc:`BaseException` 而不是 :exc:`Exception`。这意味着 "
"``except Exception:`` 的异常处理程序不会意外捕获 :exc:`GeneratorExit`。（由 Chad Austin "
"贡献；:issue:`1537`。）"

#: ../../whatsnew/2.6.rst:1646
msgid ""
"Generator objects now have a :attr:`gi_code` attribute that refers to the "
"original code object backing the generator. (Contributed by Collin Winter; "
":issue:`1473257`.)"
msgstr ""
"生成器对象现在具有一个 :attr:`gi_code` 属性，该属性引用支持生成器的原始代码对象。（由 Collin Winter "
"贡献；:issue:`1473257`。）"

#: ../../whatsnew/2.6.rst:1650
msgid ""
"The :func:`compile` built-in function now accepts keyword arguments as well "
"as positional parameters.  (Contributed by Thomas Wouters; "
":issue:`1444529`.)"
msgstr ""
":func:`compile` 内置函数现在接受关键字参数以及位置参数。（由 Thomas Wouters 贡献；:issue:`1444529`。）"

#: ../../whatsnew/2.6.rst:1654
msgid ""
"The :func:`complex` constructor now accepts strings containing parenthesized"
" complex numbers, meaning that ``complex(repr(cplx))`` will now round-trip "
"values.  For example, ``complex('(3+4j)')`` now returns the value (3+4j).  "
"(:issue:`1491866`)"
msgstr ""
":func:`complex` 构造函数现在接受包含括号内复数的字符串，这意味着 ``complex(repr(cplx))`` "
"现在将进行往返值。例如，``complex('(3+4j)')`` 现在返回值 (3+4j)。（:issue:`1491866`）"

#: ../../whatsnew/2.6.rst:1659
msgid ""
"The string :meth:`translate` method now accepts ``None`` as the translation "
"table parameter, which is treated as the identity transformation.   This "
"makes it easier to carry out operations that only delete characters.  "
"(Contributed by Bengt Richter and implemented by Raymond Hettinger; "
":issue:`1193128`.)"
msgstr ""
"字符串 :meth:`translate` 方法现在接受 ``None`` 作为翻译表参数，这被视为身份转换。这使得仅删除字符的操作更容易进行。（由 "
"Bengt Richter 贡献并由 Raymond Hettinger 实现；:issue:`1193128`。）"

#: ../../whatsnew/2.6.rst:1665
msgid ""
"The built-in :func:`dir` function now checks for a :meth:`__dir__` method on"
" the objects it receives.  This method must return a list of strings "
"containing the names of valid attributes for the object, and lets the object"
" control the value that :func:`dir` produces. Objects that have "
":meth:`__getattr__` or :meth:`__getattribute__` methods can use this to "
"advertise pseudo-attributes they will honor. (:issue:`1591665`)"
msgstr ""
"内置的 :func:`dir` 函数现在检查其接收对象上的 :meth:`__dir__` "
"方法。该方法必须返回包含对象有效属性名称的字符串列表，并让对象控制 :func:`dir` 产生的值。具有 :meth:`__getattr__` 或 "
":meth:`__getattribute__` 方法的对象可以使用此方法来宣传它们将支持的伪属性。（:issue:`1591665`）"

#: ../../whatsnew/2.6.rst:1673
msgid ""
"Instance method objects have new attributes for the object and function "
"comprising the method; the new synonym for :attr:`!im_self` is "
":attr:`~method.__self__`, and :attr:`!im_func` is also available as "
":attr:`~method.__func__`. The old names are still supported in Python 2.6, "
"but are gone in 3.0."
msgstr ""
"实例方法对象具有新的属性，用于构成方法的对象和函数；:attr:`!im_self` 的新同义词是 "
":attr:`~method.__self__`，:attr:`!im_func` 也可作为 :attr:`~method.__func__` "
"使用。旧名称在 Python 2.6 中仍然受支持，但在 3.0 中已移除。"

#: ../../whatsnew/2.6.rst:1679
msgid ""
"An obscure change: when you use the :func:`locals` function inside a "
":keyword:`class` statement, the resulting dictionary no longer returns free "
"variables.  (Free variables, in this case, are variables referenced in the "
":keyword:`!class` statement  that aren't attributes of the class.)"
msgstr ""
"一个不为人知的变化：当你在 :keyword:`class` 语句内使用 :func:`locals` "
"函数时，生成的字典不再返回自由变量。（在这种情况下，自由变量是指在 :keyword:`!class` 语句中引用的但不是类属性的变量。）"

#: ../../whatsnew/2.6.rst:1688
msgid "Optimizations"
msgstr "性能优化"

#: ../../whatsnew/2.6.rst:1690
msgid ""
"The :mod:`warnings` module has been rewritten in C.  This makes it possible "
"to invoke warnings from the parser, and may also make the interpreter's "
"startup faster. (Contributed by Neal Norwitz and Brett Cannon; "
":issue:`1631171`.)"
msgstr ""
":mod:`warnings` 模块已用 C 语言重写。这使得从解析器中调用警告成为可能，也可能使解释器的启动更快。（由 Neal Norwitz 和 "
"Brett Cannon 贡献；:issue:`1631171`。）"

#: ../../whatsnew/2.6.rst:1695
msgid ""
"Type objects now have a cache of methods that can reduce the work required "
"to find the correct method implementation for a particular class; once "
"cached, the interpreter doesn't need to traverse base classes to figure out "
"the right method to call. The cache is cleared if a base class or the class "
"itself is modified, so the cache should remain correct even in the face of "
"Python's dynamic nature. (Original optimization implemented by Armin Rigo, "
"updated for Python 2.6 by Kevin Jacobs; :issue:`1700288`.)"
msgstr ""
"类型对象现在有一个方法缓存，可以减少查找特定类的正确方法实现所需的工作；一旦缓存，解释器无需遍历基类来确定要调用的正确方法。如果基类或类本身被修改，缓存将被清除，因此即使在"
" Python 的动态特性面前，缓存也应保持正确。（最初的优化由 Armin Rigo 实现，由 Kevin Jacobs 更新以适用于 Python "
"2.6；:issue:`1700288`。）"

#: ../../whatsnew/2.6.rst:1705
msgid ""
"By default, this change is only applied to types that are included with the "
"Python core.  Extension modules may not necessarily be compatible with this "
"cache, so they must explicitly add :c:macro:`Py_TPFLAGS_HAVE_VERSION_TAG` to"
" the module's ``tp_flags`` field to enable the method cache. (To be "
"compatible with the method cache, the extension module's code must not "
"directly access and modify the ``tp_dict`` member of any of the types it "
"implements.  Most modules don't do this, but it's impossible for the Python "
"interpreter to determine that. See :issue:`1878` for some discussion.)"
msgstr ""
"默认情况下，此更改仅应用于包含在 Python 核心中的类型。扩展模块可能不兼容此缓存，因此它们必须显式将 "
":c:macro:`Py_TPFLAGS_HAVE_VERSION_TAG` 添加到模块的 ``tp_flags`` "
"字段以启用方法缓存。（为了与方法缓存兼容，扩展模块的代码不得直接访问和修改其实现的任何类型的 ``tp_dict`` 成员。大多数模块不会这样做，但 "
"Python 解释器无法确定这一点。参见 :issue:`1878` 以了解一些讨论。）"

#: ../../whatsnew/2.6.rst:1716
msgid ""
"Function calls that use keyword arguments are significantly faster by doing "
"a quick pointer comparison, usually saving the time of a full string "
"comparison.  (Contributed by Raymond Hettinger, after an initial "
"implementation by Antoine Pitrou; :issue:`1819`.)"
msgstr ""
"使用关键字参数的函数调用通过进行快速指针比较而显著加快，通常节省了完整字符串比较的时间。（由 Raymond Hettinger 贡献，基于 "
"Antoine Pitrou 的初始实现；:issue:`1819`。）"

#: ../../whatsnew/2.6.rst:1721
msgid ""
"All of the functions in the :mod:`struct` module have been rewritten in C, "
"thanks to work at the Need For Speed sprint. (Contributed by Raymond "
"Hettinger.)"
msgstr ""
"由于在 Need For Speed sprint 中的工作，:mod:`struct` 模块中的所有函数都已用 C 语言重写。（由 Raymond "
"Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:1725
msgid ""
"Some of the standard built-in types now set a bit in their type objects.  "
"This speeds up checking whether an object is a subclass of one of these "
"types.  (Contributed by Neal Norwitz.)"
msgstr "一些标准内置类型现在在其类型对象中设置了一个位。这加快了检查对象是否为这些类型的子类的速度。（由 Neal Norwitz 贡献。）"

#: ../../whatsnew/2.6.rst:1729
msgid ""
"Unicode strings now use faster code for detecting whitespace and line "
"breaks; this speeds up the :meth:`split` method by about 25% and "
":meth:`splitlines` by 35%. (Contributed by Antoine Pitrou.)  Memory usage is"
" reduced by using pymalloc for the Unicode string's data."
msgstr ""
"Unicode 字符串现在使用更快的代码来检测空白字符和换行符；这使得 :meth:`split` 方法的速度提高了约 "
"25%，:meth:`splitlines` 方法的速度提高了约 35%。(由 Antoine Pitrou 贡献。) 通过使用 pymalloc 为 "
"Unicode 字符串的数据分配内存，减少了内存使用。"

#: ../../whatsnew/2.6.rst:1735
msgid ""
"The ``with`` statement now stores the :meth:`~object.__exit__` method on the"
" stack, producing a small speedup.  (Implemented by Jeffrey Yasskin.)"
msgstr ""
"``with`` 语句现在将 :meth:`~object.__exit__` 方法存储在堆栈上，从而产生了一小部分速度提升。(由 Jeffrey "
"Yasskin 实现)"

#: ../../whatsnew/2.6.rst:1738
msgid ""
"To reduce memory usage, the garbage collector will now clear internal free "
"lists when garbage-collecting the highest generation of objects. This may "
"return memory to the operating system sooner."
msgstr "为了减少内存使用，垃圾收集器现在在收集最高代对象的垃圾时将清除内部空闲列表。这可能会更快地将内存返回给操作系统。"

#: ../../whatsnew/2.6.rst:1747
msgid "Interpreter Changes"
msgstr "解释器改动"

#: ../../whatsnew/2.6.rst:1749
msgid ""
"Two command-line options have been reserved for use by other Python "
"implementations.  The :option:`!-J` switch has been reserved for use by "
"Jython for Jython-specific options, such as switches that are passed to the "
"underlying JVM.  :option:`-X` has been reserved for options specific to a "
"particular implementation of Python such as CPython, Jython, or IronPython."
"  If either option is used with Python 2.6, the interpreter will report that"
" the option isn't currently used."
msgstr ""
"两个命令行选项已被保留供其他 Python 实现使用。:option:`!-J` 开关已被保留供 Jython 使用，用于 Jython "
"特定的选项，例如传递给底层 JVM 的开关。:option:`-X` 已被保留用于特定 Python 实现的选项，如 CPython、Jython 或 "
"IronPython。如果使用 Python 2.6 时使用任一选项，解释器将报告该选项当前未使用。"

#: ../../whatsnew/2.6.rst:1757
msgid ""
"Python can now be prevented from writing :file:`.pyc` or :file:`.pyo` files "
"by supplying the :option:`-B` switch to the Python interpreter, or by "
"setting the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable before "
"running the interpreter.  This setting is available to Python programs as "
"the ``sys.dont_write_bytecode`` variable, and Python code can change the "
"value to modify the interpreter's behaviour.  (Contributed by Neal Norwitz "
"and Georg Brandl.)"
msgstr ""
"现在可以通过向 Python 解释器提供 :option:`-B` 开关，或在运行解释器之前设置 "
":envvar:`PYTHONDONTWRITEBYTECODE` 环境变量，来阻止 Python 写入 :file:`.pyc` 或 "
":file:`.pyo` 文件。此设置作为 ``sys.dont_write_bytecode`` 变量对 Python 程序可用，Python "
"代码可以更改该值以修改解释器的行为。(由 Neal Norwitz 和 Georg Brandl 贡献)"

#: ../../whatsnew/2.6.rst:1765
msgid ""
"The encoding used for standard input, output, and standard error can be "
"specified by setting the :envvar:`PYTHONIOENCODING` environment variable "
"before running the interpreter.  The value should be a string in the form "
"``<encoding>`` or ``<encoding>:<errorhandler>``. The *encoding* part "
"specifies the encoding's name, e.g. ``utf-8`` or ``latin-1``; the optional "
"*errorhandler* part specifies what to do with characters that can't be "
"handled by the encoding, and  should be one of \"error\", \"ignore\", or "
"\"replace\".   (Contributed by Martin von Löwis.)"
msgstr ""
"可以通过在运行解释器之前设置 :envvar:`PYTHONIOENCODING` 环境变量来指定标准输入、输出和标准错误的编码。值应为形如 "
"``<编码>`` 或 ``<编码>:<错误处理器>`` 的字符串。*编码* 部分指定编码的名称，例如 ``utf-8`` 或 "
"``latin-1``；可选的 *错误处理器* 部分指定对无法由编码处理的字符的处理方式，应为 \"error\"、\"ignore\" 或 "
"\"replace\" 之一。（由 Martin von Löwis 贡献。）"

#: ../../whatsnew/2.6.rst:1778
msgid "New and Improved Modules"
msgstr "新增和改进的模块"

#: ../../whatsnew/2.6.rst:1780
msgid ""
"As in every release, Python's standard library received a number of "
"enhancements and bug fixes.  Here's a partial list of the most notable "
"changes, sorted alphabetically by module name. Consult the :file:`Misc/NEWS`"
" file in the source tree for a more complete list of changes, or look "
"through the Subversion logs for all the details."
msgstr ""
"与每个版本一样，Python 的标准库进行了一系列增强和错误修复。以下是一些最显著变化的部分列表，按模块名称字母顺序排序。请在源树中的 "
":file:`Misc/NEWS` 文件中查阅更完整的变化列表，或通过 Subversion 日志查看所有细节。"

#: ../../whatsnew/2.6.rst:1786
msgid ""
"The :mod:`!asyncore` and :mod:`!asynchat` modules are being actively "
"maintained again, and a number of patches and bugfixes were applied.  "
"(Maintained by Josiah Carlson; see :issue:`1736190` for one patch.)"
msgstr ""
":mod:`!asyncore` 和 :mod:`!asynchat` 模块再次得到积极维护，并应用了许多补丁和错误修复。（由 Josiah "
"Carlson 维护；参见 :issue:`1736190` 了解其中一个补丁。）"

#: ../../whatsnew/2.6.rst:1791
msgid ""
"The :mod:`bsddb` module also has a new maintainer, Jesús Cea Avión, and the "
"package is now available as a standalone package.  The web page for the "
"package is `www.jcea.es/programacion/pybsddb.htm "
"<https://www.jcea.es/programacion/pybsddb.htm>`__. The plan is to remove the"
" package from the standard library in Python 3.0, because its pace of "
"releases is much more frequent than Python's."
msgstr ""
":mod:`bsddb` 模块也有了新的维护者 Jesús Cea Avión，该包现在可作为独立包使用。该包的网页为 "
"`www.jcea.es/programacion/pybsddb.htm "
"<https://www.jcea.es/programacion/pybsddb.htm>`__。计划在 Python 3.0 "
"中从标准库中移除该包，因为其发布频率远高于 Python。"

#: ../../whatsnew/2.6.rst:1799
msgid ""
"The :mod:`bsddb.dbshelve` module now uses the highest pickling protocol "
"available, instead of restricting itself to protocol 1. (Contributed by W. "
"Barnes.)"
msgstr ""
":mod:`bsddb.dbshelve` 模块现在使用最高可用的序列化协议，而不是限制自己使用协议 1。（由 W. Barnes 贡献。）"

#: ../../whatsnew/2.6.rst:1803
msgid ""
"The :mod:`!cgi` module will now read variables from the query string of an "
"HTTP POST request.  This makes it possible to use form actions with URLs "
"that include query strings such as \"/cgi-bin/add.py?category=1\".  "
"(Contributed by Alexandre Fiori and Nubis; :issue:`1817`.)"
msgstr ""
":mod:`!cgi` 模块现在可以从 HTTP POST 请求的查询字符串中读取变量。这使得可以使用包含查询字符串的表单操作，例如 \"/cgi-"
"bin/add.py?category=1\"。（由 Alexandre Fiori 和 Nubis 贡献；:issue:`1817`。）"

#: ../../whatsnew/2.6.rst:1809
msgid ""
"The :func:`parse_qs` and :func:`parse_qsl` functions have been relocated "
"from the :mod:`!cgi` module to the :mod:`urlparse <urllib.parse>` module. "
"The versions still available in the :mod:`!cgi` module will trigger "
":exc:`PendingDeprecationWarning` messages in 2.6 (:issue:`600362`)."
msgstr ""
":func:`parse_qs` 和 :func:`parse_qsl` 函数已从 :mod:`!cgi` 模块移至 :mod:`urlparse "
"<urllib.parse>` 模块。在 :mod:`!cgi` 模块中仍然可用的版本将在 2.6 版本中触发 "
":exc:`PendingDeprecationWarning` 警告消息（:issue:`600362`）。"

#: ../../whatsnew/2.6.rst:1815
msgid ""
"The :mod:`cmath` module underwent extensive revision, contributed by Mark "
"Dickinson and Christian Heimes. Five new functions were added:"
msgstr ""
":mod:`cmath` 模块经历了广泛的修订，由 Mark Dickinson 和 Christian Heimes 贡献。新增了五个函数："

#: ../../whatsnew/2.6.rst:1819
msgid ""
":func:`polar` converts a complex number to polar form, returning the modulus"
" and argument of the complex number."
msgstr ":func:`polar` 将复数转换为极坐标形式，返回复数的模和辐角。"

#: ../../whatsnew/2.6.rst:1822
msgid ""
":func:`rect` does the opposite, turning a modulus, argument pair back into "
"the corresponding complex number."
msgstr ":func:`rect` 执行相反的操作，将模和辐角对转换回相应的复数。"

#: ../../whatsnew/2.6.rst:1825
msgid ""
":func:`phase` returns the argument (also called the angle) of a complex "
"number."
msgstr ":func:`phase` 返回复数的辐角（也称为角度）。"

#: ../../whatsnew/2.6.rst:1828
msgid ""
":func:`isnan` returns True if either the real or imaginary part of its "
"argument is a NaN."
msgstr ":func:`isnan` 如果其参数的实部或虚部为 NaN，则返回 True。"

#: ../../whatsnew/2.6.rst:1831
msgid ""
":func:`isinf` returns True if either the real or imaginary part of its "
"argument is infinite."
msgstr ":func:`isinf` 如果其参数的实部或虚部为无穷大，则返回 True。"

#: ../../whatsnew/2.6.rst:1834
msgid ""
"The revisions also improved the numerical soundness of the :mod:`cmath` "
"module.  For all functions, the real and imaginary parts of the results are "
"accurate to within a few units of least precision (ulps) whenever possible."
"  See :issue:`1381` for the details.  The branch cuts for :func:`asinh`, "
":func:`atanh`: and :func:`atan` have also been corrected."
msgstr ""
"这些修订还提高了 :mod:`cmath` 模块的数值稳定性。对于所有函数，结果的实部和虚部在可能的情况下都精确到几个最小精度单位（ulps）。详情请见"
" :issue:`1381`。:func:`asinh`、:func:`atanh` 和 :func:`atan` 的分支切割也已修正。"

#: ../../whatsnew/2.6.rst:1841
msgid ""
"The tests for the module have been greatly expanded; nearly 2000 new test "
"cases exercise the algebraic functions."
msgstr "该模块的测试已大幅扩展；近 2000 个新测试用例对代数函数进行了测试。"

#: ../../whatsnew/2.6.rst:1844
msgid ""
"On IEEE 754 platforms, the :mod:`cmath` module now handles IEEE 754 special "
"values and floating-point exceptions in a manner consistent with Annex 'G' "
"of the C99 standard."
msgstr ""
"在 IEEE 754 平台上，:mod:`cmath` 模块现在以符合 C99 标准附录 'G' 的方式处理 IEEE 754 特殊值和浮点异常。"

#: ../../whatsnew/2.6.rst:1848
msgid ""
"A new data type in the :mod:`collections` module: ``namedtuple(typename, "
"fieldnames)`` is a factory function that creates subclasses of the standard "
"tuple whose fields are accessible by name as well as index.  For example::"
msgstr ""
":mod:`collections` 模块中的新数据类型：``namedtuple(typename, fieldnames)`` "
"是一个工厂函数，用于创建标准元组的子类，其字段可以通过名称和索引访问。例如："

#: ../../whatsnew/2.6.rst:1852
msgid ""
">>> var_type = collections.namedtuple('variable',\n"
"...             'id name type size')\n"
">>> # Names are separated by spaces or commas.\n"
">>> # 'id, name, type, size' would also work.\n"
">>> var_type._fields\n"
"('id', 'name', 'type', 'size')\n"
"\n"
">>> var = var_type(1, 'frequency', 'int', 4)\n"
">>> print var[0], var.id    # Equivalent\n"
"1 1\n"
">>> print var[2], var.type  # Equivalent\n"
"int int\n"
">>> var._asdict()\n"
"{'size': 4, 'type': 'int', 'id': 1, 'name': 'frequency'}\n"
">>> v2 = var._replace(name='amplitude')\n"
">>> v2\n"
"variable(id=1, name='amplitude', type='int', size=4)"
msgstr ""
">>> var_type = collections.namedtuple('variable',\n"
"...             'id name type size')\n"
">>> # 名称可以用空格或逗号分隔。\n"
">>> # 'id, name, type, size' 也是有效的。\n"
">>> var_type._fields\n"
"('id', 'name', 'type', 'size')\n"
"\n"
">>> var = var_type(1, 'frequency', 'int', 4)\n"
">>> print var[0], var.id    # 等效\n"
"1 1\n"
">>> print var[2], var.type  # 等效\n"
"int int\n"
">>> var._asdict()\n"
"{'size': 4, 'type': 'int', 'id': 1, 'name': 'frequency'}\n"
">>> v2 = var._replace(name='amplitude')\n"
">>> v2\n"
"variable(id=1, name='amplitude', type='int', size=4)"

#: ../../whatsnew/2.6.rst:1870
msgid ""
"Several places in the standard library that returned tuples have been "
"modified to return :func:`namedtuple` instances.  For example, the "
":meth:`Decimal.as_tuple` method now returns a named tuple with :attr:`sign`,"
" :attr:`digits`, and :attr:`exponent` fields."
msgstr ""
"标准库中多个返回元组的地方已被修改为返回 :func:`namedtuple` 实例。例如，:meth:`Decimal.as_tuple` "
"方法现在返回一个具有 :attr:`sign`、:attr:`digits` 和 :attr:`exponent` 字段的命名元组。"

#: ../../whatsnew/2.6.rst:1877
msgid ""
"Another change to the :mod:`collections` module is that the :class:`deque` "
"type now supports an optional *maxlen* parameter; if supplied, the deque's "
"size will be restricted to no more than *maxlen* items.  Adding more items "
"to a full deque causes old items to be discarded."
msgstr ""
":mod:`collections` 模块的另一个变化是 :class:`deque` 类型现在支持可选的 *maxlen* 参数；如果提供，deque"
" 的大小将被限制为不超过 *maxlen* 项。向已满的 deque 添加更多项会导致旧项被丢弃。"

#: ../../whatsnew/2.6.rst:1885
msgid ""
">>> from collections import deque\n"
">>> dq=deque(maxlen=3)\n"
">>> dq\n"
"deque([], maxlen=3)\n"
">>> dq.append(1); dq.append(2); dq.append(3)\n"
">>> dq\n"
"deque([1, 2, 3], maxlen=3)\n"
">>> dq.append(4)\n"
">>> dq\n"
"deque([2, 3, 4], maxlen=3)"
msgstr ""
">>> from collections import deque\n"
">>> dq=deque(maxlen=3)\n"
">>> dq\n"
"deque([], maxlen=3)\n"
">>> dq.append(1); dq.append(2); dq.append(3)\n"
">>> dq\n"
"deque([1, 2, 3], maxlen=3)\n"
">>> dq.append(4)\n"
">>> dq\n"
"deque([2, 3, 4], maxlen=3)"

#: ../../whatsnew/2.6.rst:1898
msgid ""
"The :mod:`Cookie <http.cookies>` module's :class:`~http.cookies.Morsel` "
"objects now support an :attr:`~http.cookies.Morsel.httponly` attribute.  In "
"some browsers. cookies with this attribute set cannot be accessed or "
"manipulated by JavaScript code. (Contributed by Arvin Schnell; "
":issue:`1638033`.)"
msgstr ""
":mod:`Cookie <http.cookies>` 模块的 :class:`~http.cookies.Morsel` 对象现在支持 "
":attr:`~http.cookies.Morsel.httponly` 属性。在某些浏览器中，设置了此属性的 cookie 不能被 "
"JavaScript 代码访问或操作。（由 Arvin Schnell 贡献；:issue:`1638033`。）"

#: ../../whatsnew/2.6.rst:1903
msgid ""
"A new window method in the :mod:`curses` module, :meth:`chgat`, changes the "
"display attributes for a certain number of characters on a single line.  "
"(Contributed by Fabian Kreutz.)"
msgstr ""
":mod:`curses` 模块中的一个新窗口方法 :meth:`chgat`，用于更改单行上一定数量字符的显示属性。（由 Fabian Kreutz "
"贡献。）"

#: ../../whatsnew/2.6.rst:1909
msgid ""
"# Boldface text starting at y=0,x=21\n"
"# and affecting the rest of the line.\n"
"stdscr.chgat(0, 21, curses.A_BOLD)"
msgstr ""
"# 从 y=0,x=21 开始的粗体文本\n"
"# 并影响该行的其余部分。\n"
"stdscr.chgat(0, 21, curses.A_BOLD)"

#: ../../whatsnew/2.6.rst:1913
msgid ""
"The :class:`Textbox` class in the :mod:`curses.textpad` module now supports "
"editing in insert mode as well as overwrite mode. Insert mode is enabled by "
"supplying a true value for the *insert_mode* parameter when creating the "
":class:`Textbox` instance."
msgstr ""
":mod:`curses.textpad` 模块中的 :class:`Textbox` 类现在支持在插入模式和覆盖模式下编辑。通过在创建 "
":class:`Textbox` 实例时为 *insert_mode* 参数提供真值来启用插入模式。"

#: ../../whatsnew/2.6.rst:1918
msgid ""
"The :mod:`datetime` module's :meth:`strftime` methods now support a ``%f`` "
"format code that expands to the number of microseconds in the object, zero-"
"padded on the left to six places.  (Contributed by Skip Montanaro; "
":issue:`1158`.)"
msgstr ""
":mod:`datetime` 模块的 :meth:`strftime` 方法现在支持 ``%f`` "
"格式代码，该代码扩展为对象中的微秒数，左侧用零填充至六位。 (由 Skip Montanaro 贡献; :issue:`1158`.)"

#: ../../whatsnew/2.6.rst:1923
msgid ""
"The :mod:`decimal` module was updated to version 1.66 of `the General "
"Decimal Specification <https://speleotrove.com/decimal/decarith.html>`__.  "
"New features include some methods for some basic mathematical functions such"
" as :meth:`exp` and :meth:`log10`::"
msgstr ""
":mod:`decimal` 模块已更新至 `通用小数规范 "
"<https://speleotrove.com/decimal/decarith.html>`__ 的 1.66 "
"版本。新特性包括一些基本数学函数的方法，例如 :meth:`exp` 和 :meth:`log10`::"

#: ../../whatsnew/2.6.rst:1928
msgid ""
">>> Decimal(1).exp()\n"
"Decimal(\"2.718281828459045235360287471\")\n"
">>> Decimal(\"2.7182818\").ln()\n"
"Decimal(\"0.9999999895305022877376682436\")\n"
">>> Decimal(1000).log10()\n"
"Decimal(\"3\")"
msgstr ""
">>> Decimal(1).exp()\n"
"Decimal(\"2.718281828459045235360287471\")\n"
">>> Decimal(\"2.7182818\").ln()\n"
"Decimal(\"0.9999999895305022877376682436\")\n"
">>> Decimal(1000).log10()\n"
"Decimal(\"3\")"

#: ../../whatsnew/2.6.rst:1935
msgid ""
"The :meth:`as_tuple` method of :class:`Decimal` objects now returns a named "
"tuple with :attr:`sign`, :attr:`digits`, and :attr:`exponent` fields."
msgstr ""
"现在 :class:`Decimal` 对象的 :meth:`as_tuple` 方法将返回一个由 :attr:`sign`, "
":attr:`digits` 和 :attr:`exponent` 字段组成的具名元组。"

#: ../../whatsnew/2.6.rst:1938
msgid ""
"(Implemented by Facundo Batista and Mark Dickinson.  Named tuple support "
"added by Raymond Hettinger.)"
msgstr ""
"（由 Facundo Batista 和 Mark Dickinson 实现。 具名元组支持由 Raymond Hettinger 添加。）"

#: ../../whatsnew/2.6.rst:1941
msgid ""
"The :mod:`difflib` module's :class:`SequenceMatcher` class now returns named"
" tuples representing matches, with :attr:`a`, :attr:`b`, and :attr:`size` "
"attributes. (Contributed by Raymond Hettinger.)"
msgstr ""
"现在 :mod:`difflib` 模块的 :class:`SequenceMatcher` 类将返回代表匹配结果的具名元组，包含 :attr:`a`,"
" :attr:`b` 和 :attr:`size` 等属性。 （由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:1946
msgid ""
"An optional ``timeout`` parameter, specifying a timeout measured in seconds,"
" was added to the :class:`ftplib.FTP` class constructor as well as the "
":meth:`connect` method.  (Added by Facundo Batista.) Also, the :class:`FTP` "
"class's :meth:`storbinary` and :meth:`storlines` now take an optional "
"*callback* parameter that will be called with each block of data after the "
"data has been sent. (Contributed by Phil Schwartz; :issue:`1221598`.)"
msgstr ""
"在 :class:`ftplib.FTP` 类构造函数以及 :meth:`connect` 方法中添加了一个可选的 ``timeout`` "
"参数，用于指定以秒为单位的超时时间。 (由 Facundo Batista 添加。)此外，:class:`FTP` 类的 "
":meth:`storbinary` 和 :meth:`storlines` 方法现在接受一个可选的 *callback* "
"参数，该参数在数据发送后会对每个数据块进行调用。 (由 Phil Schwartz 贡献; :issue:`1221598`.)"

#: ../../whatsnew/2.6.rst:1954
msgid ""
"The :func:`reduce` built-in function is also available in the "
":mod:`functools` module.  In Python 3.0, the builtin has been dropped and "
":func:`reduce` is only available from :mod:`functools`; currently there are "
"no plans to drop the builtin in the 2.x series. (Patched by Christian "
"Heimes; :issue:`1739906`.)"
msgstr ""
"内置函数 :func:`reduce` 也在 :mod:`functools` 模块中提供。在 Python 3.0 "
"中，内置函数已被移除，:func:`reduce` 只能从 :mod:`functools` 中获取；目前没有计划在 2.x 系列中移除该内置函数。 "
"(由 Christian Heimes 修复; :issue:`1739906`.)"

#: ../../whatsnew/2.6.rst:1960
msgid ""
"When possible, the :mod:`getpass` module will now use :file:`/dev/tty` to "
"print a prompt message and read the password, falling back to standard error"
" and standard input.  If the password may be echoed to the terminal, a "
"warning is printed before the prompt is displayed.  (Contributed by Gregory "
"P. Smith.)"
msgstr ""
"在可能的情况下，:mod:`getpass` 模块现在将使用 :file:`/dev/tty` "
"来打印提示信息并读取密码，如果无法使用则回退到标准错误和标准输入。如果密码可能在终端上回显，则在显示提示之前会打印一条警告信息。 (由 Gregory "
"P. Smith 贡献)"

#: ../../whatsnew/2.6.rst:1966
msgid ""
"The :func:`glob.glob` function can now return Unicode filenames if a Unicode"
" path was used and Unicode filenames are matched within the directory.  "
"(:issue:`1001604`)"
msgstr ""
":func:`glob.glob` 函数现在可以在使用 Unicode 路径并在目录中匹配到 Unicode 文件名时返回 Unicode 文件名。 "
"(:issue:`1001604`)"

#: ../../whatsnew/2.6.rst:1970
msgid ""
"A new function in the :mod:`heapq` module, ``merge(iter1, iter2, ...)``, "
"takes any number of iterables returning data in sorted order, and returns a "
"new generator that returns the contents of all the iterators, also in sorted"
" order.  For example::"
msgstr ""
":mod:`heapq` 模块中的新函数 ``merge(iter1, iter2, ...)`` "
"接受任意数量的返回已排序数据的可迭代对象，并返回一个新的生成器，该生成器返回所有迭代器的内容，同样按顺序排序。例如::"

#: ../../whatsnew/2.6.rst:1975
msgid ""
">>> list(heapq.merge([1, 3, 5, 9], [2, 8, 16]))\n"
"[1, 2, 3, 5, 8, 9, 16]"
msgstr ""
">>> list(heapq.merge([1, 3, 5, 9], [2, 8, 16]))\n"
"[1, 2, 3, 5, 8, 9, 16]"

#: ../../whatsnew/2.6.rst:1978
msgid ""
"Another new function, ``heappushpop(heap, item)``, pushes *item* onto "
"*heap*, then pops off and returns the smallest item. This is more efficient "
"than making a call to :func:`heappush` and then :func:`heappop`."
msgstr ""
"另一个新函数，``heappushpop(heap, item)``，将 *item* 推入 *heap*，然后弹出并返回最小的元素。这比先调用 "
":func:`heappush` 再调用 :func:`heappop` 更高效。"

#: ../../whatsnew/2.6.rst:1983
msgid ""
":mod:`heapq` is now implemented to only use less-than comparison, instead of"
" the less-than-or-equal comparison it previously used. This makes "
":mod:`heapq`'s usage of a type match the :meth:`list.sort` method. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`heapq` 现在实现为仅使用小于比较，而不是之前使用的小于或等于比较。这使得 :mod:`heapq` 对类型的用法与 "
":meth:`list.sort` 方法一致。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:1989
msgid ""
"An optional ``timeout`` parameter, specifying a timeout measured in seconds,"
" was added to the :class:`httplib.HTTPConnection "
"<http.client.HTTPConnection>` and :class:`HTTPSConnection "
"<http.client.HTTPSConnection>` class constructors.  (Added by Facundo "
"Batista.)"
msgstr ""
"可选的 ``timeout`` 参数，指定以秒为单位的超时时间，已添加到 :class:`httplib.HTTPConnection "
"<http.client.HTTPConnection>` 和 :class:`HTTPSConnection "
"<http.client.HTTPSConnection>` 类构造函数中。（由 Facundo Batista 添加。）"

#: ../../whatsnew/2.6.rst:1994
msgid ""
"Most of the :mod:`inspect` module's functions, such as :func:`getmoduleinfo`"
" and :func:`getargs`, now return named tuples. In addition to behaving like "
"tuples, the elements of the  return value can also be accessed as "
"attributes. (Contributed by Raymond Hettinger.)"
msgstr ""
"大多数 :mod:`inspect` 模块的函数，如 :func:`getmoduleinfo` 和 "
":func:`getargs`，现在返回命名元组。除了像元组一样行为，返回值的元素也可以作为属性访问。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:2000
msgid ""
"Some new functions in the module include :func:`isgenerator`, "
":func:`isgeneratorfunction`, and :func:`isabstract`."
msgstr ""
"此模块中的新增函数包括 :func:`isgenerator`、 :func:`isgeneratorfunction` 和 "
":func:`isabstract`。"

#: ../../whatsnew/2.6.rst:2004
msgid "The :mod:`itertools` module gained several new functions."
msgstr ":mod:`itertools` 模块增加了几个新函数。"

#: ../../whatsnew/2.6.rst:2006
msgid ""
"``izip_longest(iter1, iter2, ...[, fillvalue])`` makes tuples from each of "
"the elements; if some of the iterables are shorter than others, the missing "
"values are set to *fillvalue*.  For example::"
msgstr ""
"``izip_longest(iter1, iter2, ...[, fillvalue])`` "
"将基于每个元素创建元组；如果某些可迭代对象长度小于其他的，缺失的值将被设为 *fillvalue*。 例如::"

#: ../../whatsnew/2.6.rst:2010
msgid ""
">>> tuple(itertools.izip_longest([1,2,3], [1,2,3,4,5]))\n"
"((1, 1), (2, 2), (3, 3), (None, 4), (None, 5))"
msgstr ""
">>> tuple(itertools.izip_longest([1,2,3], [1,2,3,4,5]))\n"
"((1, 1), (2, 2), (3, 3), (None, 4), (None, 5))"

#: ../../whatsnew/2.6.rst:2013
msgid ""
"``product(iter1, iter2, ..., [repeat=N])`` returns the Cartesian product of "
"the supplied iterables, a set of tuples containing every possible "
"combination of the elements returned from each iterable. ::"
msgstr ""
"``product(iter1, iter2, ..., [repeat=N])`` "
"将返回所提供可迭代对象的笛卡尔积，即包含从每个可迭代对象返回的元素的每种可能组合的元组的集合。::"

#: ../../whatsnew/2.6.rst:2017
msgid ""
">>> list(itertools.product([1,2,3], [4,5,6]))\n"
"[(1, 4), (1, 5), (1, 6),\n"
" (2, 4), (2, 5), (2, 6),\n"
" (3, 4), (3, 5), (3, 6)]"
msgstr ""
">>> list(itertools.product([1,2,3], [4,5,6]))\n"
"[(1, 4), (1, 5), (1, 6),\n"
" (2, 4), (2, 5), (2, 6),\n"
" (3, 4), (3, 5), (3, 6)]"

#: ../../whatsnew/2.6.rst:2022
msgid ""
"The optional *repeat* keyword argument is used for taking the product of an "
"iterable or a set of iterables with themselves, repeated *N* times.  With a "
"single iterable argument, *N*-tuples are returned::"
msgstr ""
"可选的*repeat*关键字参数用于计算一个可迭代对象或一组可迭代对象与其自身重复*N*次后的乘积。对于单个可迭代对象参数，返回*N*-元组::"

#: ../../whatsnew/2.6.rst:2027
msgid ""
">>> list(itertools.product([1,2], repeat=3))\n"
"[(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2),\n"
" (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]"
msgstr ""
">>> list(itertools.product([1,2], repeat=3))\n"
"[(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2),\n"
" (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]"

#: ../../whatsnew/2.6.rst:2031
msgid "With two iterables, *2N*-tuples are returned. ::"
msgstr "对于两个可迭代对象，返回*2N*-元组。::"

#: ../../whatsnew/2.6.rst:2033
msgid ""
">>> list(itertools.product([1,2], [3,4], repeat=2))\n"
"[(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4),\n"
" (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4),\n"
" (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4),\n"
" (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]"
msgstr ""
">>> list(itertools.product([1,2], [3,4], repeat=2))\n"
"[(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4),\n"
" (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4),\n"
" (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4),\n"
" (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]"

#: ../../whatsnew/2.6.rst:2039
msgid ""
"``combinations(iterable, r)`` returns sub-sequences of length *r* from the "
"elements of *iterable*. ::"
msgstr "``combinations(iterable, r)`` 基于 *iterable* 的元素返回长度为 *r* 的子序列。 ::"

#: ../../whatsnew/2.6.rst:2042
msgid ""
">>> list(itertools.combinations('123', 2))\n"
"[('1', '2'), ('1', '3'), ('2', '3')]\n"
">>> list(itertools.combinations('123', 3))\n"
"[('1', '2', '3')]\n"
">>> list(itertools.combinations('1234', 3))\n"
"[('1', '2', '3'), ('1', '2', '4'),\n"
" ('1', '3', '4'), ('2', '3', '4')]"
msgstr ""
">>> list(itertools.combinations('123', 2))\n"
"[('1', '2'), ('1', '3'), ('2', '3')]\n"
">>> list(itertools.combinations('123', 3))\n"
"[('1', '2', '3')]\n"
">>> list(itertools.combinations('1234', 3))\n"
"[('1', '2', '3'), ('1', '2', '4'),\n"
" ('1', '3', '4'), ('2', '3', '4')]"

#: ../../whatsnew/2.6.rst:2050
msgid ""
"``permutations(iter[, r])`` returns all the permutations of length *r* of "
"the iterable's elements.  If *r* is not specified, it will default to the "
"number of elements produced by the iterable. ::"
msgstr ""
"``permutations(iter[, r])`` 返回可迭代对象元素长度为 *r* 的所有排列。如果未指定 "
"*r*，则默认为可迭代对象产生的元素数量。::"

#: ../../whatsnew/2.6.rst:2054
msgid ""
">>> list(itertools.permutations([1,2,3,4], 2))\n"
"[(1, 2), (1, 3), (1, 4),\n"
" (2, 1), (2, 3), (2, 4),\n"
" (3, 1), (3, 2), (3, 4),\n"
" (4, 1), (4, 2), (4, 3)]"
msgstr ""
">>> list(itertools.permutations([1,2,3,4], 2))\n"
"[(1, 2), (1, 3), (1, 4),\n"
" (2, 1), (2, 3), (2, 4),\n"
" (3, 1), (3, 2), (3, 4),\n"
" (4, 1), (4, 2), (4, 3)]"

#: ../../whatsnew/2.6.rst:2060
msgid ""
"``itertools.chain(*iterables)`` is an existing function in :mod:`itertools` "
"that gained a new constructor in Python 2.6. "
"``itertools.chain.from_iterable(iterable)`` takes a single iterable that "
"should return other iterables.  :func:`chain` will then return all the "
"elements of the first iterable, then all the elements of the second, and so "
"on. ::"
msgstr ""
"``itertools.chain(*iterables)`` 是 :mod:`itertools` 模块中已有的一个函数，在 Python 2.6 "
"中新增了一个构造器。``itertools.chain.from_iterable(iterable)`` "
"接受一个应返回其他可迭代对象的单一可迭代对象。:func:`chain` "
"将依次返回第一个可迭代对象的所有元素，然后是第二个可迭代对象的所有元素，依此类推。::"

#: ../../whatsnew/2.6.rst:2067
msgid ""
">>> list(itertools.chain.from_iterable([[1,2,3], [4,5,6]]))\n"
"[1, 2, 3, 4, 5, 6]"
msgstr ""
">>> list(itertools.chain.from_iterable([[1,2,3], [4,5,6]]))\n"
"[1, 2, 3, 4, 5, 6]"

#: ../../whatsnew/2.6.rst:2070
msgid "(All contributed by Raymond Hettinger.)"
msgstr "（全部由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:2072
msgid ""
"The :mod:`logging` module's :class:`FileHandler` class and its subclasses "
":class:`WatchedFileHandler`, :class:`RotatingFileHandler`, and "
":class:`TimedRotatingFileHandler` now have an optional *delay* parameter to "
"their constructors.  If *delay* is true, opening of the log file is deferred"
" until the first :meth:`emit` call is made.  (Contributed by Vinay Sajip.)"
msgstr ""
":mod:`logging` 模块的 :class:`FileHandler` 类及其子类 "
":class:`WatchedFileHandler`、:class:`RotatingFileHandler` 和 "
":class:`TimedRotatingFileHandler` 现在在其构造器中有一个可选的 *delay* 参数。如果 *delay* "
"为真，日志文件的打开将被延迟，直到第一次调用 :meth:`emit`。 (由 Vinay Sajip 贡献)"

#: ../../whatsnew/2.6.rst:2079
msgid ""
":class:`TimedRotatingFileHandler` also has a *utc* constructor parameter.  "
"If the argument is true, UTC time will be used in determining when midnight "
"occurs and in generating filenames; otherwise local time will be used."
msgstr ""
":class:`TimedRotatingFileHandler` 还有一个 *utc* 构造器参数。如果该参数为真，将使用 UTC "
"时间来确定午夜时刻和生成文件名；否则将使用本地时间。"

#: ../../whatsnew/2.6.rst:2084
msgid "Several new functions were added to the :mod:`math` module:"
msgstr "为 :mod:`math` 模块添加了一些新函数:"

#: ../../whatsnew/2.6.rst:2086
msgid ""
":func:`~math.isinf` and :func:`~math.isnan` determine whether a given float "
"is a (positive or negative) infinity or a NaN (Not a Number), respectively."
msgstr ""
":func:`~math.isinf` 和 :func:`~math.isnan` 分别用于判断给定浮点数是否为（正或负）无穷大或 NaN（非数字）。"

#: ../../whatsnew/2.6.rst:2089
msgid ""
":func:`~math.copysign` copies the sign bit of an IEEE 754 number, returning "
"the absolute value of *x* combined with the sign bit of *y*.  For example, "
"``math.copysign(1, -0.0)`` returns -1.0. (Contributed by Christian Heimes.)"
msgstr ""
":func:`~math.copysign` 复制 IEEE 754 数的符号位，返回 *x* 的绝对值与 *y* "
"的符号位组合的结果。例如，``math.copysign(1, -0.0)`` 返回 -1.0。 (由 Christian Heimes 贡献)"

#: ../../whatsnew/2.6.rst:2094
msgid ""
":func:`~math.factorial` computes the factorial of a number. (Contributed by "
"Raymond Hettinger; :issue:`2138`.)"
msgstr ""
":func:`~math.factorial` 计算一个数的阶乘。 (由 Raymond Hettinger 贡献；:issue:`2138`)"

#: ../../whatsnew/2.6.rst:2097
msgid ""
":func:`~math.fsum` adds up the stream of numbers from an iterable, and is "
"careful to avoid loss of precision through using partial sums. (Contributed "
"by Jean Brouwers, Raymond Hettinger, and Mark Dickinson; :issue:`2819`.)"
msgstr ""
":func:`~math.fsum` 将可迭代对象中的数字流相加，并小心避免通过使用部分和来损失精度。 (由 Jean Brouwers、Raymond"
" Hettinger 和 Mark Dickinson 贡献；:issue:`2819`)"

#: ../../whatsnew/2.6.rst:2102
msgid ""
":func:`~math.acosh`, :func:`~math.asinh` and :func:`~math.atanh` compute the"
" inverse hyperbolic functions."
msgstr ""
":func:`~math.acosh`、:func:`~math.asinh` 和 :func:`~math.atanh` 计算反双曲函数。"

#: ../../whatsnew/2.6.rst:2105
msgid ":func:`~math.log1p` returns the natural logarithm of *1+x* (base *e*)."
msgstr ":func:`~math.log1p` 返回 *1+x* (以 *e* 为底) 的自然对数。"

#: ../../whatsnew/2.6.rst:2108
msgid ""
":func:`trunc` rounds a number toward zero, returning the closest "
":class:`Integral` that's between the function's argument and zero. Added as "
"part of the backport of `PEP 3141's type hierarchy for numbers "
"<#pep-3141>`__."
msgstr ""
":func:`trunc` 将数字四舍五入至零，返回介于函数参数和零之间的最接近的 :class:`Integral`。作为 `PEP 3141 "
"数字类型层次结构 <#pep-3141>`__ 的回退部分添加。"

#: ../../whatsnew/2.6.rst:2113
msgid ""
"The :mod:`math` module has been improved to give more consistent behaviour "
"across platforms, especially with respect to handling of floating-point "
"exceptions and IEEE 754 special values."
msgstr ":mod:`math` 模块已改进，以在不同平台上提供更一致的行为，特别是在处理浮点异常和 IEEE 754 特殊值方面。"

#: ../../whatsnew/2.6.rst:2117
msgid ""
"Whenever possible, the module follows the recommendations of the C99 "
"standard about 754's special values.  For example, ``sqrt(-1.)`` should now "
"give a :exc:`ValueError` across almost all platforms, while "
"``sqrt(float('NaN'))`` should return a NaN on all IEEE 754 platforms.  Where"
" Annex 'F' of the C99 standard recommends signaling 'divide-by-zero' or "
"'invalid', Python will raise :exc:`ValueError`. Where Annex 'F' of the C99 "
"standard recommends signaling 'overflow', Python will raise "
":exc:`OverflowError`.  (See :issue:`711019` and :issue:`1640`.)"
msgstr ""
"在可能的情况下，该模块遵循 C99 标准关于 754 特殊值的建议。例如，``sqrt(-1.)`` 现在应在几乎所有平台上引发 "
":exc:`ValueError`，而 ``sqrt(float('NaN'))`` 应在所有 IEEE 754 平台上返回 NaN。在 C99 "
"标准附件 'F' 建议发出 '除以零' 或 '无效' 信号的地方，Python 将引发 :exc:`ValueError`。在 C99 标准附件 'F'"
" 建议发出 '溢出' 信号的地方，Python 将引发 :exc:`OverflowError`。（参见 :issue:`711019` 和 "
":issue:`1640`。）"

#: ../../whatsnew/2.6.rst:2127
msgid "(Contributed by Christian Heimes and Mark Dickinson.)"
msgstr "（由 Christian Heimes 和 Mark Dickinson 贡献。）"

#: ../../whatsnew/2.6.rst:2129
msgid ""
":class:`~mmap.mmap` objects now have a :meth:`rfind` method that searches "
"for a substring beginning at the end of the string and searching backwards."
"  The :meth:`find` method also gained an *end* parameter giving an index at "
"which to stop searching. (Contributed by John Lenton.)"
msgstr ""
":class:`~mmap.mmap` 对象现在有一个 :meth:`rfind` 方法，从字符串末尾开始向后搜索子字符串。:meth:`find` "
"方法还增加了一个 *end* 参数，用于指定停止搜索的索引。（由 John Lenton 贡献。）"

#: ../../whatsnew/2.6.rst:2135
msgid ""
"The :mod:`operator` module gained a :func:`methodcaller` function that takes"
" a name and an optional set of arguments, returning a callable that will "
"call the named function on any arguments passed to it.  For example::"
msgstr ""
":mod:`operator` 模块增加了一个 :func:`methodcaller` "
"函数，它接受一个名称和一组可选的参数，返回一个可调用的对象，该对象将对传递给它的任何参数调用指定的函数。例如："

#: ../../whatsnew/2.6.rst:2140
msgid ""
">>> # Equivalent to lambda s: s.replace('old', 'new')\n"
">>> replacer = operator.methodcaller('replace', 'old', 'new')\n"
">>> replacer('old wine in old bottles')\n"
"'new wine in new bottles'"
msgstr ""
">>> # 等价于 lambda s: s.replace('old', 'new')\n"
">>> replacer = operator.methodcaller('replace', 'old', 'new')\n"
">>> replacer('old wine in old bottles')\n"
"'new wine in new bottles'"

#: ../../whatsnew/2.6.rst:2145
msgid ""
"(Contributed by Georg Brandl, after a suggestion by Gregory Petrosyan.)"
msgstr "（由 Gregory Petrosyan 提供建议，之后由 Georg Brandl 贡献。）"

#: ../../whatsnew/2.6.rst:2147
msgid ""
"The :func:`attrgetter` function now accepts dotted names and performs the "
"corresponding attribute lookups::"
msgstr "现在 :func:`attrgetter` 函数可接受带点号的名称并执行相应的属性查找::"

#: ../../whatsnew/2.6.rst:2150
msgid ""
">>> inst_name = operator.attrgetter(\n"
"...        '__class__.__name__')\n"
">>> inst_name('')\n"
"'str'\n"
">>> inst_name(help)\n"
"'_Helper'"
msgstr ""
">>> inst_name = operator.attrgetter(\n"
"...        '__class__.__name__')\n"
">>> inst_name('')\n"
"'str'\n"
">>> inst_name(help)\n"
"'_Helper'"

#: ../../whatsnew/2.6.rst:2157
msgid "(Contributed by Georg Brandl, after a suggestion by Barry Warsaw.)"
msgstr "（由 Barry Warsaw 提供建议，之后由 Georg Brandl 贡献。）"

#: ../../whatsnew/2.6.rst:2159
msgid ""
"The :mod:`os` module now wraps several new system calls. ``fchmod(fd, "
"mode)`` and ``fchown(fd, uid, gid)`` change the mode and ownership of an "
"opened file, and ``lchmod(path, mode)`` changes the mode of a symlink.  "
"(Contributed by Georg Brandl and Christian Heimes.)"
msgstr ""
":mod:`os` 模块现在包装了几个新的系统调用。``fchmod(fd, mode)`` 和 ``fchown(fd, uid, gid)`` "
"更改已打开文件的模式和所有权，``lchmod(path, mode)`` 更改符号链接的模式。（由 Georg Brandl 和 Christian "
"Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:2165
msgid ""
":func:`chflags` and :func:`lchflags` are wrappers for the corresponding "
"system calls (where they're available), changing the flags set on a file.  "
"Constants for the flag values are defined in the :mod:`stat` module; some "
"possible values include :const:`UF_IMMUTABLE` to signal the file may not be "
"changed and :const:`UF_APPEND` to indicate that data can only be appended to"
" the file.  (Contributed by M. Levinson.)"
msgstr ""
":func:`chflags` 和 :func:`lchflags` 是对应系统调用（在可用的情况下）的封装，用于更改文件上的标志。标志值的常量在 "
":mod:`stat` 模块中定义；一些可能的值包括 :const:`UF_IMMUTABLE` 表示文件不可更改，以及 "
":const:`UF_APPEND` 表示数据只能追加到文件中。（由 M. Levinson 贡献。）"

#: ../../whatsnew/2.6.rst:2173
msgid ""
"``os.closerange(low, high)`` efficiently closes all file descriptors from "
"*low* to *high*, ignoring any errors and not including *high* itself. This "
"function is now used by the :mod:`subprocess` module to make starting "
"processes faster.  (Contributed by Georg Brandl; :issue:`1663329`.)"
msgstr ""
"``os.closerange(low, high)`` 高效地关闭从 *low* 到 *high* 的所有文件描述符，忽略任何错误，并且不包括 "
"*high* 本身。此函数现在被 :mod:`subprocess` 模块使用，以加快启动进程的速度。（由 Georg Brandl "
"贡献；:issue:`1663329`。）"

#: ../../whatsnew/2.6.rst:2178
msgid ""
"The ``os.environ`` object's :meth:`clear` method will now unset the "
"environment variables using :func:`os.unsetenv` in addition to clearing the "
"object's keys.  (Contributed by Martin Horcicka; :issue:`1181`.)"
msgstr ""
"``os.environ`` 对象的 :meth:`clear` 方法现在除了清除对象的键之外，还会使用 :func:`os.unsetenv` "
"来取消设置环境变量。（由 Martin Horcicka 贡献；:issue:`1181`。）"

#: ../../whatsnew/2.6.rst:2182
msgid ""
"The :func:`os.walk` function now has a ``followlinks`` parameter. If set to "
"True, it will follow symlinks pointing to directories and visit the "
"directory's contents.  For backward compatibility, the parameter's default "
"value is false.  Note that the function can fall into an infinite recursion "
"if there's a symlink that points to a parent directory.  (:issue:`1273829`)"
msgstr ""
":func:`os.walk` 函数现在有一个 ``followlinks`` 参数。如果设置为 "
"True，它将跟随指向目录的符号链接并访问目录的内容。为了向后兼容，该参数的默认值为 "
"false。请注意，如果存在指向父目录的符号链接，该函数可能会陷入无限递归。（:issue:`1273829`）"

#: ../../whatsnew/2.6.rst:2189
msgid ""
"In the :mod:`os.path` module, the :func:`splitext` function has been changed"
" to not split on leading period characters. This produces better results "
"when operating on Unix's dot-files. For example, "
"``os.path.splitext('.ipython')`` now returns ``('.ipython', '')`` instead of"
" ``('', '.ipython')``. (:issue:`1115886`)"
msgstr ""
"在 :mod:`os.path` 模块中，:func:`splitext` 函数已更改，不再在开头的句点字符处分割。这在处理 Unix "
"的点文件时会产生更好的结果。例如，``os.path.splitext('.ipython')`` 现在返回 ``('.ipython', '')`` "
"而不是 ``('', '.ipython')``。（:issue:`1115886`）"

#: ../../whatsnew/2.6.rst:2196
msgid ""
"A new function, ``os.path.relpath(path, start='.')``, returns a relative "
"path from the ``start`` path, if it's supplied, or from the current working "
"directory to the destination ``path``.  (Contributed by Richard Barran; "
":issue:`1339796`.)"
msgstr ""
"一个新的函数，``os.path.relpath(path, start='.')``，返回从 ``start`` "
"路径（如果提供）或从当前工作目录到目标 ``path`` 的相对路径。（由 Richard Barran 贡献；:issue:`1339796`。）"

#: ../../whatsnew/2.6.rst:2201
msgid ""
"On Windows, :func:`os.path.expandvars` will now expand environment variables"
" given in the form \"%var%\", and \"~user\" will be expanded into the user's"
" home directory path.  (Contributed by Josiah Carlson; :issue:`957650`.)"
msgstr ""
"在Windows上，:func:`os.path.expandvars` 现在可以展开形如 \"%var%\" 的环境变量，并且 \"~user\" "
"将被展开为用户的主目录路径。（由 Josiah Carlson 贡献；:issue:`957650`。）"

#: ../../whatsnew/2.6.rst:2206
msgid ""
"The Python debugger provided by the :mod:`pdb` module gained a new command: "
"\"run\" restarts the Python program being debugged and can optionally take "
"new command-line arguments for the program. (Contributed by Rocky Bernstein;"
" :issue:`1393667`.)"
msgstr ""
":mod:`pdb` 模块提供的 Python 调试器新增了一个命令：\"run\" 可以重新启动正在调试的 Python "
"程序，并且可以可选地接受新的命令行参数。（由 Rocky Bernstein 贡献；:issue:`1393667`。）"

#: ../../whatsnew/2.6.rst:2211
msgid ""
"The :func:`pdb.post_mortem` function, used to begin debugging a traceback, "
"will now use the traceback returned by :func:`sys.exc_info` if no traceback "
"is supplied.   (Contributed by Facundo Batista; :issue:`1106316`.)"
msgstr ""
"用于开始调试回溯的 :func:`pdb.post_mortem` 函数，现在如果没有提供回溯，将使用 :func:`sys.exc_info` "
"返回的回溯。（由 Facundo Batista 贡献；:issue:`1106316`。）"

#: ../../whatsnew/2.6.rst:2216
msgid ""
"The :mod:`pickletools` module now has an :func:`optimize` function that "
"takes a string containing a pickle and removes some unused opcodes, "
"returning a shorter pickle that contains the same data structure. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`pickletools` 模块现在有一个 :func:`optimize` 函数，它接受一个包含 pickle "
"的字符串，并移除一些未使用的操作码，返回一个包含相同数据结构的更短的 pickle。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:2221
msgid ""
"A :func:`get_data` function was added to the :mod:`pkgutil` module that "
"returns the contents of resource files included with an installed Python "
"package.  For example::"
msgstr ""
"在 :mod:`pkgutil` 模块中添加了一个 :func:`get_data` 函数，它返回随安装的 Python "
"包一起包含的资源文件的内容。例如："

#: ../../whatsnew/2.6.rst:2225
msgid ""
">>> import pkgutil\n"
">>> print pkgutil.get_data('test', 'exception_hierarchy.txt')\n"
"BaseException\n"
" +-- SystemExit\n"
" +-- KeyboardInterrupt\n"
" +-- GeneratorExit\n"
" +-- Exception\n"
"      +-- StopIteration\n"
"      +-- StandardError\n"
" ..."
msgstr ""
">>> import pkgutil\n"
">>> print pkgutil.get_data('test', 'exception_hierarchy.txt')\n"
"BaseException\n"
" +-- SystemExit\n"
" +-- KeyboardInterrupt\n"
" +-- GeneratorExit\n"
" +-- Exception\n"
"      +-- StopIteration\n"
"      +-- StandardError\n"
" ..."

#: ../../whatsnew/2.6.rst:2236
msgid "(Contributed by Paul Moore; :issue:`2439`.)"
msgstr "（由 Paul Moore 在 :issue:`2439` 中贡献。）"

#: ../../whatsnew/2.6.rst:2238
msgid ""
"The :mod:`pyexpat` module's :class:`Parser` objects now allow setting their "
":attr:`buffer_size` attribute to change the size of the buffer used to hold "
"character data. (Contributed by Achim Gaedke; :issue:`1137`.)"
msgstr ""
":mod:`pyexpat` 模块的 :class:`Parser` 对象现在允许设置它们的 :attr:`buffer_size` "
"属性，以改变用于保存字符数据的缓冲区大小。（由 Achim Gaedke 贡献；:issue:`1137`。）"

#: ../../whatsnew/2.6.rst:2243
msgid ""
"The :mod:`Queue` module now provides queue variants that retrieve entries in"
" different orders.  The :class:`PriorityQueue` class stores queued items in "
"a heap and retrieves them in priority order, and :class:`LifoQueue` "
"retrieves the most recently added entries first, meaning that it behaves "
"like a stack. (Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`Queue` 模块现在提供了不同顺序检索条目的队列变体。:class:`PriorityQueue` "
"类将排队项存储在堆中并按优先级顺序检索它们，而 :class:`LifoQueue` 首先检索最近添加的条目，这意味着它表现得像一个栈。（由 "
"Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.6.rst:2250
msgid ""
"The :mod:`random` module's :class:`Random` objects can now be pickled on a "
"32-bit system and unpickled on a 64-bit system, and vice versa.  "
"Unfortunately, this change also means that Python 2.6's :class:`Random` "
"objects can't be unpickled correctly on earlier versions of Python. "
"(Contributed by Shawn Ligocki; :issue:`1727780`.)"
msgstr ""
":mod:`random` 模块的 :class:`Random` "
"对象现在可以在32位系统上被序列化，并在64位系统上反序列化，反之亦然。不幸的是，这一变化也意味着 Python 2.6 的 "
":class:`Random` 对象无法在早期版本的 Python 上正确反序列化。（由 Shawn Ligocki "
"贡献；:issue:`1727780`。）"

#: ../../whatsnew/2.6.rst:2257
msgid ""
"The new ``triangular(low, high, mode)`` function returns random numbers "
"following a triangular distribution.   The returned values are between *low*"
" and *high*, not including *high* itself, and with *mode* as the most "
"frequently occurring value in the distribution.  (Contributed by Wladmir van"
" der Laan and Raymond Hettinger; :issue:`1681432`.)"
msgstr ""
"新的 ``triangular(low, high, mode)`` 函数返回遵循三角分布的随机数。返回值介于 *low* 和 *high* "
"之间，不包括 *high* 本身，且 *mode* 为分布中最频繁出现的值。（由 Wladmir van der Laan 和 Raymond "
"Hettinger 贡献；:issue:`1681432`。）"

#: ../../whatsnew/2.6.rst:2264
msgid ""
"Long regular expression searches carried out by the  :mod:`re` module will "
"check for signals being delivered, so time-consuming searches can now be "
"interrupted. (Contributed by Josh Hoyt and Ralf Schmitt; :issue:`846388`.)"
msgstr ""
":mod:`re` 模块执行的长正则表达式搜索将检查是否有信号传递，因此耗时搜索现在可以被中断。（由 Josh Hoyt 和 Ralf Schmitt "
"贡献；:issue:`846388`。）"

#: ../../whatsnew/2.6.rst:2269
msgid ""
"The regular expression module is implemented by compiling bytecodes for a "
"tiny regex-specific virtual machine.  Untrusted code could create malicious "
"strings of bytecode directly and cause crashes, so Python 2.6 includes a "
"verifier for the regex bytecode. (Contributed by Guido van Rossum from work "
"for Google App Engine; :issue:`3487`.)"
msgstr ""
"正则表达式模块通过为一个小型正则表达式专用虚拟机编译字节码来实现。未受信任的代码可能直接创建恶意的字节码字符串并导致崩溃，因此 Python 2.6 "
"包含了一个用于验证正则表达式字节码的验证器。（由 Guido van Rossum 基于为 Google App Engine "
"的工作贡献；:issue:`3487`。）"

#: ../../whatsnew/2.6.rst:2276
msgid ""
"The :mod:`rlcompleter` module's :meth:`Completer.complete` method will now "
"ignore exceptions triggered while evaluating a name. (Fixed by Lorenz Quack;"
" :issue:`2250`.)"
msgstr ""
":mod:`rlcompleter` 模块的 :meth:`Completer.complete` 方法现在将忽略在评估名称时触发的异常。（由 "
"Lorenz Quack 修复；:issue:`2250`。）"

#: ../../whatsnew/2.6.rst:2280
msgid ""
"The :mod:`sched` module's :class:`scheduler` instances now have a read-only "
":attr:`queue` attribute that returns the contents of the scheduler's queue, "
"represented as a list of named tuples with the fields ``(time, priority, "
"action, argument)``. (Contributed by Raymond Hettinger; :issue:`1861`.)"
msgstr ""
":mod:`sched` 模块的 :class:`scheduler` 实例现在有一个只读的 :attr:`queue` "
"属性，返回调度器队列的内容，表示为一个命名元组列表，字段为 ``(time, priority, action, argument)``。（由 "
"Raymond Hettinger 贡献；:issue:`1861`。）"

#: ../../whatsnew/2.6.rst:2286
msgid ""
"The :mod:`select` module now has wrapper functions for the Linux "
":c:func:`!epoll` and BSD :c:func:`!kqueue` system calls. :meth:`modify` "
"method was added to the existing :class:`poll` objects; ``pollobj.modify(fd,"
" eventmask)`` takes a file descriptor or file object and an event mask, "
"modifying the recorded event mask for that file. (Contributed by Christian "
"Heimes; :issue:`1657`.)"
msgstr ""
"模块 :mod:`select` 现在为 Linux 的 :c:func:`!epoll` 和 BSD 的 :c:func:`!kqueue` "
"系统调用提供了包装函数。为现有的 :class:`poll` 对象添加了 :meth:`modify` 方法；``pollobj.modify(fd, "
"eventmask)`` 接收一个文件描述符或文件对象以及一个事件掩码，修改该文件的记录事件掩码。（由 Christian Heimes "
"贡献；:issue:`1657`。）"

#: ../../whatsnew/2.6.rst:2294
msgid ""
"The :func:`shutil.copytree` function now has an optional *ignore* argument "
"that takes a callable object.  This callable will receive each directory "
"path and a list of the directory's contents, and returns a list of names "
"that will be ignored, not copied."
msgstr ""
"函数 :func:`shutil.copytree` 现在有一个可选的 *ignore* "
"参数，该参数接收一个可调用对象。这个可调用对象将接收每个目录路径和目录内容的列表，并返回一个将被忽略、不进行复制的名称列表。"

#: ../../whatsnew/2.6.rst:2299
msgid ""
"The :mod:`shutil` module also provides an :func:`ignore_patterns` function "
"for use with this new parameter.  :func:`ignore_patterns` takes an arbitrary"
" number of glob-style patterns and returns a callable that will ignore any "
"files and directories that match any of these patterns.  The following "
"example copies a directory tree, but skips both :file:`.svn` directories and"
" Emacs backup files, which have names ending with '~'::"
msgstr ""
"模块 :mod:`shutil` 还提供了一个 :func:`ignore_patterns` "
"函数，用于与这个新参数一起使用。:func:`ignore_patterns` 接收任意数量的 glob-style "
"模式，并返回一个可调用对象，该对象将忽略匹配这些模式中的任何一个的文件和目录。以下示例复制一个目录树，但跳过 :file:`.svn` 目录和以 '~'"
" 结尾的 Emacs 备份文件："

#: ../../whatsnew/2.6.rst:2307
msgid ""
"shutil.copytree('Doc/library', '/tmp/library',\n"
"                ignore=shutil.ignore_patterns('*~', '.svn'))"
msgstr ""
"shutil.copytree('Doc/library', '/tmp/library',\n"
"                ignore=shutil.ignore_patterns('*~', '.svn'))"

#: ../../whatsnew/2.6.rst:2310
msgid "(Contributed by Tarek Ziadé; :issue:`2663`.)"
msgstr "（由 Tarek Ziadé 在 :issue:`2663` 中贡献。）"

#: ../../whatsnew/2.6.rst:2312
msgid ""
"Integrating signal handling with GUI handling event loops like those used by"
" Tkinter or GTk+ has long been a problem; most software ends up polling, "
"waking up every fraction of a second to check if any GUI events have "
"occurred. The :mod:`signal` module can now make this more efficient. Calling"
" ``signal.set_wakeup_fd(fd)`` sets a file descriptor to be used; when a "
"signal is received, a byte is written to that file descriptor.  There's also"
" a C-level function, :c:func:`PySignal_SetWakeupFd`, for setting the "
"descriptor."
msgstr ""
"将信号处理与 Tkinter 或 GTk+ 使用的 GUI "
"事件循环集成长期以来一直是一个问题；大多数软件最终采用轮询方式，每隔一小段时间唤醒一次以检查是否有任何 GUI 事件发生。模块 "
":mod:`signal` 现在可以使这更高效。调用 ``signal.set_wakeup_fd(fd)`` "
"设置一个文件描述符；当接收到信号时，向该文件描述符写入一个字节。还有一个 C 级函数 "
":c:func:`PySignal_SetWakeupFd`，用于设置描述符。"

#: ../../whatsnew/2.6.rst:2322
msgid ""
"Event loops will use this by opening a pipe to create two descriptors, one "
"for reading and one for writing.  The writable descriptor will be passed to "
":func:`set_wakeup_fd`, and the readable descriptor will be added to the list"
" of descriptors monitored by the event loop via :c:func:`!select` or "
":c:func:`!poll`. On receiving a signal, a byte will be written and the main "
"event loop will be woken up, avoiding the need to poll."
msgstr ""
"事件循环将使用此方法通过打开管道来创建两个描述符，一个用于读取，一个用于写入。可写描述符将传递给 "
":func:`set_wakeup_fd`，可读描述符将通过 :c:func:`!select` 或 :c:func:`!poll` "
"添加到事件循环监视的描述符列表中。接收到信号时，将写入一个字节，唤醒主事件循环，避免需要轮询。"

#: ../../whatsnew/2.6.rst:2330
msgid "(Contributed by Adam Olsen; :issue:`1583`.)"
msgstr "（由 Adam Olsen 在 :issue:`1583` 中贡献。）"

#: ../../whatsnew/2.6.rst:2332
msgid ""
"The :func:`siginterrupt` function is now available from Python code, and "
"allows changing whether signals can interrupt system calls or not. "
"(Contributed by Ralf Schmitt.)"
msgstr ""
":func:`siginterrupt` 函数现在可以从 Python 代码中使用，允许更改信号是否可以中断系统调用。（由 Ralf Schmitt "
"贡献。）"

#: ../../whatsnew/2.6.rst:2336
msgid ""
"The :func:`setitimer` and :func:`getitimer` functions have also been added "
"(where they're available).  :func:`setitimer` allows setting interval timers"
" that will cause a signal to be delivered to the process after a specified "
"time, measured in wall-clock time, consumed process time, or combined "
"process+system time.  (Contributed by Guilherme Polo; :issue:`2240`.)"
msgstr ""
"还添加了 :func:`setitimer` 和 :func:`getitimer` 函数（在可用的情况下）。:func:`setitimer` "
"允许设置间隔定时器，该定时器将在指定时间后向进程发送信号，时间测量可以是墙钟时间、消耗的进程时间或进程+系统时间之和。（由 Guilherme Polo"
" 贡献；:issue:`2240`。）"

#: ../../whatsnew/2.6.rst:2343
msgid ""
"The :mod:`smtplib` module now supports SMTP over SSL thanks to the addition "
"of the :class:`SMTP_SSL` class. This class supports an interface identical "
"to the existing :class:`SMTP` class. (Contributed by Monty Taylor.)  Both "
"class constructors also have an optional ``timeout`` parameter that "
"specifies a timeout for the initial connection attempt, measured in seconds."
"  (Contributed by Facundo Batista.)"
msgstr ""
":mod:`smtplib` 模块现在支持通过 SSL 的 SMTP，这得益于 :class:`SMTP_SSL` 类的添加。这个类支持与现有 "
":class:`SMTP` 类相同的接口。（由 Monty Taylor 贡献。）这两个类构造函数还有一个可选的 ``timeout`` "
"参数，用于指定初始连接尝试的超时时间，以秒为单位。（由 Facundo Batista 贡献。）"

#: ../../whatsnew/2.6.rst:2351
msgid ""
"An implementation of the LMTP protocol (:rfc:`2033`) was also added to the "
"module.  LMTP is used in place of SMTP when transferring e-mail between "
"agents that don't manage a mail queue.  (LMTP implemented by Leif Hedstrom; "
":issue:`957003`.)"
msgstr ""
"模块中还添加了 LMTP 协议（:rfc:`2033`）的实现。当在不需要管理邮件队列的代理之间传输电子邮件时，使用 LMTP 代替 "
"SMTP。（LMTP 由 Leif Hedstrom 实现；:issue:`957003`。）"

#: ../../whatsnew/2.6.rst:2356
msgid ""
":meth:`SMTP.starttls` now complies with :rfc:`3207` and forgets any "
"knowledge obtained from the server not obtained from the TLS negotiation "
"itself.  (Patch contributed by Bill Fenner; :issue:`829951`.)"
msgstr ""
":meth:`SMTP.starttls` 现在符合 :rfc:`3207` 标准，并忘记从服务器获得的任何非 TLS 协商本身获得的知识。（补丁由 "
"Bill Fenner 贡献；:issue:`829951`。）"

#: ../../whatsnew/2.6.rst:2361
msgid ""
"The :mod:`socket` module now supports TIPC (https://tipc.sourceforge.net/), "
"a high-performance non-IP-based protocol designed for use in clustered "
"environments.  TIPC addresses are 4- or 5-tuples. (Contributed by Alberto "
"Bertogli; :issue:`1646`.)"
msgstr ""
":mod:`socket` 模块现在支持 TIPC "
"(https://tipc.sourceforge.net/)，这是一种为集群环境设计的高性能非IP协议。TIPC 地址为 4- 或 5- 元组。（由 "
"Alberto Bertogli 贡献；:issue:`1646`。）"

#: ../../whatsnew/2.6.rst:2366
msgid ""
"A new function, :func:`create_connection`, takes an address and connects to "
"it using an optional timeout value, returning the connected socket object.  "
"This function also looks up the address's type and connects to it using IPv4"
" or IPv6 as appropriate.  Changing your code to use "
":func:`create_connection` instead of ``socket(socket.AF_INET, ...)`` may be "
"all that's required to make your code work with IPv6."
msgstr ""
"新函数 :func:`create_connection` "
"接收一个地址并使用可选的超时值进行连接，返回已连接的套接字对象。此函数还会查找地址的类型，并使用 IPv4 或 IPv6 适当地进行连接。将代码改为使用"
" :func:`create_connection` 而不是 ``socket(socket.AF_INET, ...)`` 可能是使代码支持 IPv6"
" 所需的全部工作。"

#: ../../whatsnew/2.6.rst:2374
msgid ""
"The base classes in the :mod:`SocketServer <socketserver>` module now "
"support calling a :meth:`~socketserver.BaseServer.handle_timeout` method "
"after a span of inactivity specified by the server's "
":attr:`~socketserver.BaseServer.timeout` attribute.  (Contributed by Michael"
" Pomraning.)  The :meth:`~socketserver.BaseServer.serve_forever` method now "
"takes an optional poll interval measured in seconds, controlling how often "
"the server will check for a shutdown request. (Contributed by Pedro Werneck "
"and Jeffrey Yasskin; :issue:`742598`, :issue:`1193577`.)"
msgstr ""
":mod:`SocketServer <socketserver>` 模块中的基类现在支持在服务器 "
":attr:`~socketserver.BaseServer.timeout` 属性指定的不活动时间后调用 "
":meth:`~socketserver.BaseServer.handle_timeout` 方法。(由 Michael Pomraning 贡献。)"
" :meth:`~socketserver.BaseServer.serve_forever` "
"方法现在接受一个可选的轮询间隔（以秒为单位），控制服务器检查关闭请求的频率。（由 Pedro Werneck 和 Jeffrey Yasskin "
"贡献；:issue:`742598`, :issue:`1193577`。）"

#: ../../whatsnew/2.6.rst:2383
msgid ""
"The :mod:`sqlite3` module, maintained by Gerhard Häring, has been updated "
"from version 2.3.2 in Python 2.5 to version 2.4.1."
msgstr ""
"由 Gerhard Häring 维护的 :mod:`sqlite3` 模块已从 Python 2.5 中的版本 2.3.2 更新到版本 2.4.1。"

#: ../../whatsnew/2.6.rst:2387
msgid ""
"The :mod:`struct` module now supports the C99 :c:expr:`_Bool` type, using "
"the format character ``'?'``. (Contributed by David Remahl.)"
msgstr ""
":mod:`struct` 模块现在支持 C99 的 :c:expr:`_Bool` 类型，使用格式字符 ``'?'``。（由 David Remahl"
" 贡献。）"

#: ../../whatsnew/2.6.rst:2391
msgid ""
"The :class:`~subprocess.Popen` objects provided by the :mod:`subprocess` "
"module now have :meth:`~subprocess.Popen.terminate`, "
":meth:`~subprocess.Popen.kill`, and :meth:`~subprocess.Popen.send_signal` "
"methods. On Windows, :meth:`!send_signal` only supports the "
":py:const:`~signal.SIGTERM` signal, and all these methods are aliases for "
"the Win32 API function :c:func:`!TerminateProcess`. (Contributed by "
"Christian Heimes.)"
msgstr ""
":mod:`subprocess` 模块提供的 :class:`~subprocess.Popen` 对象现在具有 "
":meth:`~subprocess.Popen.terminate`、:meth:`~subprocess.Popen.kill` 和 "
":meth:`~subprocess.Popen.send_signal` 方法。在 Windows 上，:meth:`!send_signal` "
"仅支持 :py:const:`~signal.SIGTERM` 信号，所有这些方法都是 Win32 API 函数 "
":c:func:`!TerminateProcess` 的别名。（由 Christian Heimes 贡献。)"

#: ../../whatsnew/2.6.rst:2398
msgid ""
"A new variable in the :mod:`sys` module, :attr:`float_info`, is an object "
"containing information derived from the :file:`float.h` file about the "
"platform's floating-point support.  Attributes of this object include "
":attr:`mant_dig` (number of digits in the mantissa), :attr:`epsilon` "
"(smallest difference between 1.0 and the next largest value representable), "
"and several others.  (Contributed by Christian Heimes; :issue:`1534`.)"
msgstr ""
"在 :mod:`sys` 模块中新增了一个变量 :attr:`float_info`，它是一个包含从 :file:`float.h` "
"文件中获取的关于平台浮点支持信息的对象。该对象的属性包括 :attr:`mant_dig` (尾数的位数) 、:attr:`epsilon` (1.0 "
"与下一个可表示的最大值之间的最小差值) 以及其他几个属性。（由 Christian Heimes 贡献；:issue:`1534`。）"

#: ../../whatsnew/2.6.rst:2406
msgid ""
"Another new variable, :attr:`dont_write_bytecode`, controls whether Python "
"writes any :file:`.pyc` or :file:`.pyo` files on importing a module. If this"
" variable is true, the compiled files are not written.  The variable is "
"initially set on start-up by supplying the :option:`-B` switch to the Python"
" interpreter, or by setting the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable before running the interpreter.  Python code can "
"subsequently change the value of this variable to control whether bytecode "
"files are written or not. (Contributed by Neal Norwitz and Georg Brandl.)"
msgstr ""
"另一个新变量 :attr:`dont_write_bytecode` 控制着 Python 在导入模块时是否写入任何 :file:`.pyc` 或 "
":file:`.pyo` 文件。如果该变量为真，则不写入编译文件。该变量在启动时通过向 Python 解释器提供 :option:`-B` "
"开关或通过在运行解释器之前设置 :envvar:`PYTHONDONTWRITEBYTECODE` 环境变量来初始设置。Python "
"代码随后可以更改此变量的值，以控制是否写入字节码文件。（由 Neal Norwitz 和 Georg Brandl 贡献。）"

#: ../../whatsnew/2.6.rst:2417
msgid ""
"Information about the command-line arguments supplied to the Python "
"interpreter is available by reading attributes of a named tuple available as"
" ``sys.flags``.  For example, the :attr:`verbose` attribute is true if "
"Python was executed in verbose mode, :attr:`debug` is true in debugging "
"mode, etc. These attributes are all read-only. (Contributed by Christian "
"Heimes.)"
msgstr ""
"通过读取名为 ``sys.flags`` 的命名元组的属性，可以获取提供给 Python 解释器的命令行参数信息。例如，如果 Python "
"以详细模式执行，则 :attr:`verbose` 属性为真，:attr:`debug` 在调试模式下为真，等等。这些属性都是只读的。（由 "
"Christian Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:2425
msgid ""
"A new function, :func:`getsizeof`, takes a Python object and returns the "
"amount of memory used by the object, measured in bytes.  Built-in objects "
"return correct results; third-party extensions may not, but can define a "
":meth:`__sizeof__` method to return the object's size. (Contributed by "
"Robert Schuppenies; :issue:`2898`.)"
msgstr ""
"新增了一个函数 :func:`getsizeof`，它接受一个 Python "
"对象并返回该对象使用的内存量，以字节为单位。内置对象返回正确结果；第三方扩展可能不会，但可以定义一个 :meth:`__sizeof__` "
"方法来返回对象的大小。（由 Robert Schuppenies 贡献；:issue:`2898`。）"

#: ../../whatsnew/2.6.rst:2432
msgid ""
"It's now possible to determine the current profiler and tracer functions by "
"calling :func:`sys.getprofile` and :func:`sys.gettrace`. (Contributed by "
"Georg Brandl; :issue:`1648`.)"
msgstr ""
"现在可以通过调用 :func:`sys.getprofile` 和 :func:`sys.gettrace` 来确定当前的剖析器和跟踪器函数。（由 "
"Georg Brandl 贡献；:issue:`1648`。）"

#: ../../whatsnew/2.6.rst:2436
msgid ""
"The :mod:`tarfile` module now supports POSIX.1-2001 (pax) tarfiles in "
"addition to the POSIX.1-1988 (ustar) and GNU tar formats that were already "
"supported.  The default format is GNU tar; specify the ``format`` parameter "
"to open a file using a different format::"
msgstr ""
"模块 :mod:`tarfile` 现在除了已支持的 POSIX.1-1988 (ustar) 和 GNU tar 格式外，还支持 "
"POSIX.1-2001 (pax) tar文件。默认格式为 GNU tar；可以通过指定 ``format`` 参数来使用不同的格式打开文件::"

#: ../../whatsnew/2.6.rst:2441
msgid ""
"tar = tarfile.open(\"output.tar\", \"w\",\n"
"                   format=tarfile.PAX_FORMAT)"
msgstr ""
"tar = tarfile.open(\"output.tar\", \"w\",\n"
"                   format=tarfile.PAX_FORMAT)"

#: ../../whatsnew/2.6.rst:2444
msgid ""
"The new ``encoding`` and ``errors`` parameters specify an encoding and an "
"error handling scheme for character conversions.  ``'strict'``, "
"``'ignore'``, and ``'replace'`` are the three standard ways Python can "
"handle errors,; ``'utf-8'`` is a special value that replaces bad characters "
"with their UTF-8 representation.  (Character conversions occur because the "
"PAX format supports Unicode filenames, defaulting to UTF-8 encoding.)"
msgstr ""
"新的 ``encoding`` 和 ``errors`` 参数用于指定字符转换的编码和错误处理方案。``'strict'``、``'ignore'`` "
"和 ``'replace'`` 是 Python 处理错误的三个标准方式；``'utf-8'`` 是一个特殊值，它会将错误的字符替换为它们的 UTF-8"
" 表示形式。（字符转换是因为 PAX 格式支持 Unicode 文件名，默认使用 UTF-8 编码。）"

#: ../../whatsnew/2.6.rst:2452
msgid ""
"The :meth:`TarFile.add` method now accepts an ``exclude`` argument that's a "
"function that can be used to exclude certain filenames from an archive. The "
"function must take a filename and return true if the file should be excluded"
" or false if it should be archived. The function is applied to both the name"
" initially passed to :meth:`add` and to the names of files in recursively "
"added directories."
msgstr ""
"方法 :meth:`TarFile.add` 现在接受一个 ``exclude`` "
"参数，该参数是一个函数，用于排除某些文件名不存入归档。该函数必须接受一个文件名，并在文件应被排除时返回 true，在文件应被归档时返回 "
"false。该函数应用于最初传递给 :meth:`add` 的名称以及递归添加的目录中的文件名。"

#: ../../whatsnew/2.6.rst:2460
msgid "(All changes contributed by Lars Gustäbel)."
msgstr "（所有改变均由 Lars Gustäbel 贡献）。"

#: ../../whatsnew/2.6.rst:2462
msgid ""
"An optional ``timeout`` parameter was added to the "
":class:`!telnetlib.Telnet` class constructor, specifying a timeout measured "
"in seconds.  (Added by Facundo Batista.)"
msgstr ""
"在类 :class:`!telnetlib.Telnet` 的构造函数中添加了一个可选的 ``timeout`` "
"参数，用于指定以秒为单位的超时时间。（由 Facundo Batista 添加。）"

#: ../../whatsnew/2.6.rst:2466
msgid ""
"The :class:`tempfile.NamedTemporaryFile` class usually deletes the temporary"
" file it created when the file is closed.  This behaviour can now be changed"
" by passing ``delete=False`` to the constructor.  (Contributed by Damien "
"Miller; :issue:`1537850`.)"
msgstr ""
"类 :class:`tempfile.NamedTemporaryFile` 通常在文件关闭时删除其创建的临时文件。现在可以通过向构造函数传递 "
"``delete=False`` 来改变此行为。（由 Damien Miller 贡献；:issue:`1537850`。）"

#: ../../whatsnew/2.6.rst:2471
msgid ""
"A new class, :class:`SpooledTemporaryFile`, behaves like a temporary file "
"but stores its data in memory until a maximum size is exceeded.  On reaching"
" that limit, the contents will be written to an on-disk temporary file.  "
"(Contributed by Dustin J. Mitchell.)"
msgstr ""
"新增类 "
":class:`SpooledTemporaryFile`，其行为类似于临时文件，但会在内存中存储数据，直到超过最大大小。达到该限制后，内容将被写入磁盘上的临时文件。（由"
" Dustin J. Mitchell 贡献。）"

#: ../../whatsnew/2.6.rst:2476
msgid ""
"The :class:`NamedTemporaryFile` and :class:`SpooledTemporaryFile` classes "
"both work as context managers, so you can write ``with "
"tempfile.NamedTemporaryFile() as tmp: ...``. (Contributed by Alexander "
"Belopolsky; :issue:`2021`.)"
msgstr ""
":class:`NamedTemporaryFile` 和 :class:`SpooledTemporaryFile` "
"类都可作为上下文管理器使用，因此你可以编写 ``with tempfile.NamedTemporaryFile() as tmp: ...``。 (由"
" Alexander Belopolsky 贡献; :issue:`2021`.)"

#: ../../whatsnew/2.6.rst:2481
msgid ""
"The :mod:`test.test_support <test.support>` module gained a number of "
"context managers useful for writing tests. "
":func:`~test.support.os_helper.EnvironmentVarGuard` is a context manager "
"that temporarily changes environment variables and automatically restores "
"them to their old values."
msgstr ""
":mod:`test.test_support <test.support>` "
"模块增加了一些用于编写测试的上下文管理器。:func:`~test.support.os_helper.EnvironmentVarGuard` "
"是一个上下文管理器，它可以临时更改环境变量并自动将其恢复为旧值。"

#: ../../whatsnew/2.6.rst:2487
msgid ""
"Another context manager, :class:`TransientResource`, can surround calls to "
"resources that may or may not be available; it will catch and ignore a "
"specified list of exceptions.  For example, a network test may ignore "
"certain failures when connecting to an external web site::"
msgstr ""
"另一个上下文管理器 :class:`TransientResource` "
"可以围绕对可能可用或不可用的资源的调用；它将捕获并忽略指定的异常列表。例如，网络测试在连接到外部网站时可能会忽略某些失败情况::"

#: ../../whatsnew/2.6.rst:2493
msgid ""
"with test_support.TransientResource(IOError,\n"
"                                errno=errno.ETIMEDOUT):\n"
"    f = urllib.urlopen('https://sf.net')\n"
"    ..."
msgstr ""
"with test_support.TransientResource(IOError,\n"
"                                errno=errno.ETIMEDOUT):\n"
"    f = urllib.urlopen('https://sf.net')\n"
"    ..."

#: ../../whatsnew/2.6.rst:2498
msgid ""
"Finally, :func:`check_warnings` resets the :mod:`warning` module's warning "
"filters and returns an object that will record all warning messages "
"triggered (:issue:`3781`)::"
msgstr ""
"最后，:func:`check_warnings` 重置 :mod:`warning` 模块的警告过滤器，并返回一个将记录所有触发的警告消息的对象 "
"(:issue:`3781`)::"

#: ../../whatsnew/2.6.rst:2502
msgid ""
"with test_support.check_warnings() as wrec:\n"
"    warnings.simplefilter(\"always\")\n"
"    # ... code that triggers a warning ...\n"
"    assert str(wrec.message) == \"function is outdated\"\n"
"    assert len(wrec.warnings) == 1, \"Multiple warnings raised\""
msgstr ""
"with test_support.check_warnings() as wrec:\n"
"    warnings.simplefilter(\"always\")\n"
"    # ... 触发警告的代码 ...\n"
"    assert str(wrec.message) == \"function is outdated\"\n"
"    assert len(wrec.warnings) == 1, \"Multiple warnings raised\""

#: ../../whatsnew/2.6.rst:2508
msgid "(Contributed by Brett Cannon.)"
msgstr "（由 Brett Cannon 贡献。）"

#: ../../whatsnew/2.6.rst:2510
msgid ""
"The :mod:`textwrap` module can now preserve existing whitespace at the "
"beginnings and ends of the newly created lines by specifying "
"``drop_whitespace=False`` as an argument::"
msgstr ""
":mod:`textwrap` 模块现在可以通过指定 ``drop_whitespace=False`` 作为参数来保留新创建行首尾的现有空白::"

#: ../../whatsnew/2.6.rst:2515
msgid ""
">>> S = \"\"\"This  sentence  has a bunch   of\n"
"...   extra   whitespace.\"\"\"\n"
">>> print textwrap.fill(S, width=15)\n"
"This  sentence\n"
"has a bunch\n"
"of    extra\n"
"whitespace.\n"
">>> print textwrap.fill(S, drop_whitespace=False, width=15)\n"
"This  sentence\n"
"  has a bunch\n"
"   of    extra\n"
"   whitespace.\n"
">>>"
msgstr ""
">>> S = \"\"\"This  sentence  has a bunch   of\n"
"...   extra   whitespace.\"\"\"\n"
">>> print textwrap.fill(S, width=15)\n"
"This  sentence\n"
"has a bunch\n"
"of    extra\n"
"whitespace.\n"
">>> print textwrap.fill(S, drop_whitespace=False, width=15)\n"
"This  sentence\n"
"  has a bunch\n"
"   of    extra\n"
"   whitespace.\n"
">>>"

#: ../../whatsnew/2.6.rst:2529
msgid "(Contributed by Dwayne Bailey; :issue:`1581073`.)"
msgstr "（由 Dwayne Bailey 在 :issue:`1581073` 中贡献。）"

#: ../../whatsnew/2.6.rst:2531
msgid ""
"The :mod:`threading` module API is being changed to use properties such as "
":attr:`daemon` instead of :meth:`setDaemon` and :meth:`isDaemon` methods, "
"and some methods have been renamed to use underscores instead of camel-case;"
" for example, the :meth:`activeCount` method is renamed to "
":meth:`active_count`.  Both the 2.6 and 3.0 versions of the module support "
"the same properties and renamed methods, but don't remove the old methods.  "
"No date has been set for the deprecation of the old APIs in Python 3.x; the "
"old APIs won't be removed in any 2.x version. (Carried out by several "
"people, most notably Benjamin Peterson.)"
msgstr ""
"模块 :mod:`threading` 的 API 正在被修改，以使用属性如 :attr:`daemon` 而不是 :meth:`setDaemon` "
"和 :meth:`isDaemon` 方法，并且一些方法已被重命名，使用下划线而不是驼峰命名法；例如，:meth:`activeCount` "
"方法被重命名为 :meth:`active_count`。模块的 2.6 和 3.0 版本都支持相同的属性和重命名的方法，但不删除旧方法。Python "
"3.x 中旧 API 的弃用日期尚未确定；旧 API 不会在任何 2.x 版本中被移除。（由多人执行，最著名的是 Benjamin Peterson。）"

#: ../../whatsnew/2.6.rst:2542
msgid ""
"The :mod:`threading` module's :class:`Thread` objects gained an "
":attr:`ident` property that returns the thread's identifier, a nonzero "
"integer.  (Contributed by Gregory P. Smith; :issue:`2871`.)"
msgstr ""
"模块 :mod:`threading` 的 :class:`Thread` 对象获得了一个 :attr:`ident` "
"属性，该属性返回线程的标识符，一个非零整数。（由 Gregory P. Smith 贡献；:issue:`2871`。）"

#: ../../whatsnew/2.6.rst:2547
msgid ""
"The :mod:`timeit` module now accepts callables as well as strings for the "
"statement being timed and for the setup code. Two convenience functions were"
" added for creating :class:`Timer` instances: ``repeat(stmt, setup, time, "
"repeat, number)`` and ``timeit(stmt, setup, time, number)`` create an "
"instance and call the corresponding method. (Contributed by Erik Demaine; "
":issue:`1533909`.)"
msgstr ""
"模块 :mod:`timeit` 现在接受可调用对象以及字符串作为被计时的语句和设置代码。添加了两个便捷函数用于创建 :class:`Timer` "
"实例：``repeat(stmt, setup, time, repeat, number)`` 和 ``timeit(stmt, setup, "
"time, number)`` 创建一个实例并调用相应的方法。（由 Erik Demaine 贡献；:issue:`1533909`。）"

#: ../../whatsnew/2.6.rst:2556
msgid ""
"The :mod:`Tkinter` module now accepts lists and tuples for options, "
"separating the elements by spaces before passing the resulting value to "
"Tcl/Tk. (Contributed by Guilherme Polo; :issue:`2906`.)"
msgstr ""
"模块 :mod:`Tkinter` 现在接受列表和元组作为选项，在将结果值传递给 Tcl/Tk 之前用空格分隔元素。（由 Guilherme Polo "
"贡献；:issue:`2906`。）"

#: ../../whatsnew/2.6.rst:2561
msgid ""
"The :mod:`turtle` module for turtle graphics was greatly enhanced by Gregor "
"Lingl.  New features in the module include:"
msgstr "模块 :mod:`turtle` 用于海龟图形，由 Gregor Lingl 大大增强。模块中的新功能包括："

#: ../../whatsnew/2.6.rst:2564
msgid "Better animation of turtle movement and rotation."
msgstr "改进了海龟移动和旋转的动画。"

#: ../../whatsnew/2.6.rst:2565
msgid ""
"Control over turtle movement using the new :meth:`delay`, :meth:`tracer`, "
"and :meth:`speed` methods."
msgstr "使用新的 :meth:`delay`、:meth:`tracer` 和 :meth:`speed` 方法控制海龟移动。"

#: ../../whatsnew/2.6.rst:2567
msgid ""
"The ability to set new shapes for the turtle, and to define a new coordinate"
" system."
msgstr "能够为海龟设置新形状，并定义新的坐标系。"

#: ../../whatsnew/2.6.rst:2569
msgid "Turtles now have an :meth:`undo` method that can roll back actions."
msgstr "海龟现在有一个 :meth:`undo` 方法，可以回滚操作。"

#: ../../whatsnew/2.6.rst:2570
msgid ""
"Simple support for reacting to input events such as mouse and keyboard "
"activity, making it possible to write simple games."
msgstr "简单支持对鼠标和键盘活动等输入事件做出反应，使得编写简单游戏成为可能。"

#: ../../whatsnew/2.6.rst:2572
msgid ""
"A :file:`turtle.cfg` file can be used to customize the starting appearance "
"of the turtle's screen."
msgstr ":file:`turtle.cfg` 文件可被用来定制海龟绘图屏幕的初始外观。"

#: ../../whatsnew/2.6.rst:2574
msgid ""
"The module's docstrings can be replaced by new docstrings that have been "
"translated into another language."
msgstr "模块的文档字符串可以被替换为已翻译成另一种语言的新文档字符串。"

#: ../../whatsnew/2.6.rst:2577
msgid "(:issue:`1513695`)"
msgstr "(:issue:`1513695`)"

#: ../../whatsnew/2.6.rst:2579
msgid ""
"An optional ``timeout`` parameter was added to the :func:`urllib.urlopen "
"<urllib.request.urlopen>` function and the :class:`urllib.ftpwrapper` class "
"constructor, as well as the :func:`urllib2.urlopen <urllib.request.urlopen>`"
" function.  The parameter specifies a timeout measured in seconds.   For "
"example::"
msgstr ""
"在 :func:`urllib.urlopen <urllib.request.urlopen>` 函数和 "
":class:`urllib.ftpwrapper` 类构造器以及 :func:`urllib2.urlopen "
"<urllib.request.urlopen>` 函数中添加了一个可选的 ``timeout`` 参数。该参数指定以秒为单位的超时时间。例如::"

#: ../../whatsnew/2.6.rst:2585
msgid ""
">>> u = urllib2.urlopen(\"http://slow.example.com\",\n"
"                        timeout=3)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"urllib2.URLError: <urlopen error timed out>\n"
">>>"
msgstr ""
">>> u = urllib2.urlopen(\"http://slow.example.com\",\n"
"                        timeout=3)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"urllib2.URLError: <urlopen error timed out>\n"
">>>"

#: ../../whatsnew/2.6.rst:2592
msgid "(Added by Facundo Batista.)"
msgstr "（由 Facundo Batista 添加。）"

#: ../../whatsnew/2.6.rst:2594
msgid ""
"The Unicode database provided by the :mod:`unicodedata` module has been "
"updated to version 5.1.0.  (Updated by Martin von Löwis; :issue:`3811`.)"
msgstr ""
":mod:`unicodedata` 模块提供的Unicode数据库已更新至版本5.1.0。（由Martin von "
"Löwis更新；:issue:`3811`。）"

#: ../../whatsnew/2.6.rst:2598
msgid ""
"The :mod:`warnings` module's :func:`formatwarning` and :func:`showwarning` "
"gained an optional *line* argument that can be used to supply the line of "
"source code.  (Added as part of :issue:`1631171`, which re-implemented part "
"of the :mod:`warnings` module in C code.)"
msgstr ""
":mod:`warnings` 模块的 :func:`formatwarning` 和 :func:`showwarning` 增加了一个可选的 "
"*line* 参数，用于提供源代码行。（作为 :issue:`1631171` 的一部分添加，该问题重新实现了 :mod:`warnings` "
"模块的C代码部分。）"

#: ../../whatsnew/2.6.rst:2603
msgid ""
"A new function, :func:`catch_warnings`, is a context manager intended for "
"testing purposes that lets you temporarily modify the warning filters and "
"then restore their original values (:issue:`3781`)."
msgstr ""
"新增函数 :func:`catch_warnings` "
"是一个用于测试目的的上下文管理器，允许你临时修改警告过滤器，然后恢复其原始值（:issue:`3781`）。"

#: ../../whatsnew/2.6.rst:2607
msgid ""
"The XML-RPC :class:`SimpleXMLRPCServer <xmlrpc.server>` and "
":class:`DocXMLRPCServer <xmlrpc.server>` classes can now be prevented from "
"immediately opening and binding to their socket by passing ``False`` as the "
"*bind_and_activate* constructor parameter.  This can be used to modify the "
"instance's :attr:`allow_reuse_address` attribute before calling the "
":meth:`server_bind` and :meth:`server_activate` methods to open the socket "
"and begin listening for connections. (Contributed by Peter Parente; "
":issue:`1599845`.)"
msgstr ""
"XML-RPC的 :class:`SimpleXMLRPCServer <xmlrpc.server>` 和 "
":class:`DocXMLRPCServer <xmlrpc.server>` 类现在可以通过将 ``False`` 作为 "
"*bind_and_activate* 构造器参数传递来防止立即打开并绑定到其套接字。这可用于在调用 :meth:`server_bind` 和 "
":meth:`server_activate` 方法打开套接字并开始监听连接之前修改实例的 :attr:`allow_reuse_address` "
"属性。（由Peter Parente贡献；:issue:`1599845`。）"

#: ../../whatsnew/2.6.rst:2616
msgid ""
":class:`SimpleXMLRPCServer` also has a :attr:`_send_traceback_header` "
"attribute; if true, the exception and formatted traceback are returned as "
"HTTP headers \"X-Exception\" and \"X-Traceback\".  This feature is for "
"debugging purposes only and should not be used on production servers because"
" the tracebacks might reveal passwords or other sensitive information.  "
"(Contributed by Alan McIntyre as part of his project for Google's Summer of "
"Code 2007.)"
msgstr ""
":class:`SimpleXMLRPCServer` 还有一个 :attr:`_send_traceback_header` "
"属性；如果为真，异常和格式化的回溯将作为 HTTP 头部 \"X-Exception\" 和 \"X-Traceback\" "
"返回。此功能仅用于调试目的，不应在生产服务器上使用，因为回溯可能会泄露密码或其他敏感信息。（由 Alan McIntyre 作为其 Google "
"2007 年夏季代码项目的一部分贡献。）"

#: ../../whatsnew/2.6.rst:2624
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module no longer automatically converts"
" :class:`datetime.date` and :class:`datetime.time` to the "
":class:`xmlrpclib.DateTime <xmlrpc.client.DateTime>` type; the conversion "
"semantics were not necessarily correct for all applications.  Code using "
":mod:`!xmlrpclib` should convert :class:`date` and :class:`~datetime.time` "
"instances. (:issue:`1330538`)  The code can also handle dates before 1900 "
"(contributed by Ralf Schmitt; :issue:`2014`) and 64-bit integers represented"
" by using ``<i8>`` in XML-RPC responses (contributed by Riku Lindblad; "
":issue:`2985`)."
msgstr ""
":mod:`xmlrpclib <xmlrpc.client>` 模块不再自动将 :class:`datetime.date` 和 "
":class:`datetime.time` 转换为 :class:`xmlrpclib.DateTime "
"<xmlrpc.client.DateTime>` 类型；转换语义并不一定适用于所有应用程序。使用 :mod:`!xmlrpclib` 的代码应转换 "
":class:`date` 和 :class:`~datetime.time` 实例。（:issue:`1330538`）代码还可以处理 1900 "
"年之前的日期（由 Ralf Schmitt 贡献；:issue:`2014`）以及使用 ``<i8>`` 在 XML-RPC 响应中表示的 64 "
"位整数（由 Riku Lindblad 贡献；:issue:`2985`）。"

#: ../../whatsnew/2.6.rst:2634
msgid ""
"The :mod:`zipfile` module's :class:`ZipFile` class now has :meth:`extract` "
"and :meth:`extractall` methods that will unpack a single file or all the "
"files in the archive to the current directory, or to a specified directory::"
msgstr ""
":mod:`zipfile` 模块的 :class:`ZipFile` 类现在有 :meth:`extract` 和 "
":meth:`extractall` 方法，可以将单个文件或存档中的所有文件解压到当前目录，或指定目录::"

#: ../../whatsnew/2.6.rst:2639
msgid ""
"z = zipfile.ZipFile('python-251.zip')\n"
"\n"
"# Unpack a single file, writing it relative\n"
"# to the /tmp directory.\n"
"z.extract('Python/sysmodule.c', '/tmp')\n"
"\n"
"# Unpack all the files in the archive.\n"
"z.extractall()"
msgstr ""
"z = zipfile.ZipFile('python-251.zip')\n"
"\n"
"# 解压单个文件，将其写入\n"
"# 相对于 /tmp 目录。\n"
"z.extract('Python/sysmodule.c', '/tmp')\n"
"\n"
"# 解压存档中的所有文件。\n"
"z.extractall()"

#: ../../whatsnew/2.6.rst:2648
msgid "(Contributed by Alan McIntyre; :issue:`467924`.)"
msgstr "（由 Alan McIntyre 在 :issue:`467924` 中贡献。）"

#: ../../whatsnew/2.6.rst:2650
msgid ""
"The :meth:`open`, :meth:`read` and :meth:`extract` methods can now take "
"either a filename or a :class:`ZipInfo` object.  This is useful when an "
"archive accidentally contains a duplicated filename. (Contributed by Graham "
"Horler; :issue:`1775025`.)"
msgstr ""
":meth:`open`、:meth:`read` 和 :meth:`extract` 方法现在可以接受文件名或 :class:`ZipInfo` "
"对象。这在存档意外包含重复文件名时很有用。（由 Graham Horler 贡献；:issue:`1775025`。）"

#: ../../whatsnew/2.6.rst:2655
msgid ""
"Finally, :mod:`zipfile` now supports using Unicode filenames for archived "
"files.  (Contributed by Alexey Borzenkov; :issue:`1734346`.)"
msgstr ""
"最后，:mod:`zipfile` 现在支持使用 Unicode 文件名存档文件。（由 Alexey Borzenkov "
"贡献；:issue:`1734346`。）"

#: ../../whatsnew/2.6.rst:2662
msgid "The :mod:`ast` module"
msgstr ":mod:`ast` 模块"

#: ../../whatsnew/2.6.rst:2664
msgid ""
"The :mod:`ast` module provides an Abstract Syntax Tree representation of "
"Python code, and Armin Ronacher contributed a set of helper functions that "
"perform a variety of common tasks.  These will be useful for HTML templating"
" packages, code analyzers, and similar tools that process Python code."
msgstr ""
":mod:`ast` 模块提供了 Python 代码的抽象语法树（Abstract Syntax Tree）表示，Armin Ronacher "
"贡献了一组辅助函数，用于执行各种常见任务。这些函数对于 HTML 模板包、代码分析器以及处理 Python 代码的类似工具将非常有用。"

#: ../../whatsnew/2.6.rst:2671
msgid ""
"The :func:`parse` function takes an expression and returns an AST. The "
":func:`dump` function outputs a representation of a tree, suitable for "
"debugging::"
msgstr ":func:`parse` 函数接受一个表达式并返回一个 AST。:func:`dump` 函数输出树的表示，适用于调试::"

#: ../../whatsnew/2.6.rst:2675
msgid ""
"import ast\n"
"\n"
"t = ast.parse(\"\"\"\n"
"d = {}\n"
"for i in 'abcdefghijklm':\n"
"    d[i + i] = ord(i) - ord('a') + 1\n"
"print d\n"
"\"\"\")\n"
"print ast.dump(t)"
msgstr ""
"import ast\n"
"\n"
"t = ast.parse(\"\"\"\n"
"d = {}\n"
"for i in 'abcdefghijklm':\n"
"    d[i + i] = ord(i) - ord('a') + 1\n"
"print d\n"
"\"\"\")\n"
"print ast.dump(t)"

#: ../../whatsnew/2.6.rst:2685
msgid "This outputs a deeply nested tree::"
msgstr "输出是一棵深度嵌套的树::"

#: ../../whatsnew/2.6.rst:2687
msgid ""
"Module(body=[\n"
"  Assign(targets=[\n"
"    Name(id='d', ctx=Store())\n"
"   ], value=Dict(keys=[], values=[]))\n"
"  For(target=Name(id='i', ctx=Store()),\n"
"      iter=Str(s='abcdefghijklm'), body=[\n"
"    Assign(targets=[\n"
"      Subscript(value=\n"
"        Name(id='d', ctx=Load()),\n"
"          slice=\n"
"          Index(value=\n"
"            BinOp(left=Name(id='i', ctx=Load()), op=Add(),\n"
"             right=Name(id='i', ctx=Load()))), ctx=Store())\n"
"     ], value=\n"
"     BinOp(left=\n"
"      BinOp(left=\n"
"       Call(func=\n"
"        Name(id='ord', ctx=Load()), args=[\n"
"          Name(id='i', ctx=Load())\n"
"         ], keywords=[], starargs=None, kwargs=None),\n"
"       op=Sub(), right=Call(func=\n"
"        Name(id='ord', ctx=Load()), args=[\n"
"          Str(s='a')\n"
"         ], keywords=[], starargs=None, kwargs=None)),\n"
"       op=Add(), right=Num(n=1)))\n"
"    ], orelse=[])\n"
"   Print(dest=None, values=[\n"
"     Name(id='d', ctx=Load())\n"
"   ], nl=True)\n"
" ])"
msgstr ""
"Module(body=[\n"
"  Assign(targets=[\n"
"    Name(id='d', ctx=Store())\n"
"   ], value=Dict(keys=[], values=[]))\n"
"  For(target=Name(id='i', ctx=Store()),\n"
"      iter=Str(s='abcdefghijklm'), body=[\n"
"    Assign(targets=[\n"
"      Subscript(value=\n"
"        Name(id='d', ctx=Load()),\n"
"          slice=\n"
"          Index(value=\n"
"            BinOp(left=Name(id='i', ctx=Load()), op=Add(),\n"
"             right=Name(id='i', ctx=Load()))), ctx=Store())\n"
"     ], value=\n"
"     BinOp(left=\n"
"      BinOp(left=\n"
"       Call(func=\n"
"        Name(id='ord', ctx=Load()), args=[\n"
"          Name(id='i', ctx=Load())\n"
"         ], keywords=[], starargs=None, kwargs=None),\n"
"       op=Sub(), right=Call(func=\n"
"        Name(id='ord', ctx=Load()), args=[\n"
"          Str(s='a')\n"
"         ], keywords=[], starargs=None, kwargs=None)),\n"
"       op=Add(), right=Num(n=1)))\n"
"    ], orelse=[])\n"
"   Print(dest=None, values=[\n"
"     Name(id='d', ctx=Load())\n"
"   ], nl=True)\n"
" ])"

#: ../../whatsnew/2.6.rst:2718
msgid ""
"The :func:`literal_eval` method takes a string or an AST representing a "
"literal expression, parses and evaluates it, and returns the resulting "
"value.  A literal expression is a Python expression containing only strings,"
" numbers, dictionaries, etc. but no statements or function calls.  If you "
"need to evaluate an expression but cannot accept the security risk of using "
"an :func:`eval` call, :func:`literal_eval` will handle it safely::"
msgstr ""
":func:`literal_eval` 方法接受一个字符串或表示字面量表达式的 "
"AST，解析并评估它，并返回结果值。字面量表达式是只包含字符串、数字、字典等，但不包含语句或函数调用的 Python "
"表达式。如果你需要评估一个表达式，但不能接受使用 :func:`eval` 调用的安全风险，:func:`literal_eval` 将安全地处理它::"

#: ../../whatsnew/2.6.rst:2726
msgid ""
">>> literal = '(\"a\", \"b\", {2:4, 3:8, 1:2})'\n"
">>> print ast.literal_eval(literal)\n"
"('a', 'b', {1: 2, 2: 4, 3: 8})\n"
">>> print ast.literal_eval('\"a\" + \"b\"')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: malformed string"
msgstr ""
">>> literal = '(\"a\", \"b\", {2:4, 3:8, 1:2})'\n"
">>> print ast.literal_eval(literal)\n"
"('a', 'b', {1: 2, 2: 4, 3: 8})\n"
">>> print ast.literal_eval('\"a\" + \"b\"')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: malformed string"

#: ../../whatsnew/2.6.rst:2734
msgid ""
"The module also includes :class:`NodeVisitor` and :class:`NodeTransformer` "
"classes for traversing and modifying an AST, and functions for common "
"transformations such as changing line numbers."
msgstr ""
"该模块还包括 :class:`NodeVisitor` 和 :class:`NodeTransformer` 类，用于遍历和修改 "
"AST，以及用于常见转换（如更改行号）的函数。"

#: ../../whatsnew/2.6.rst:2742
msgid "The :mod:`future_builtins` module"
msgstr ":mod:`future_builtins` 模块"

#: ../../whatsnew/2.6.rst:2744
msgid ""
"Python 3.0 makes many changes to the repertoire of built-in functions, and "
"most of the changes can't be introduced in the Python 2.x series because "
"they would break compatibility. The :mod:`future_builtins` module provides "
"versions of these built-in functions that can be imported when writing "
"3.0-compatible code."
msgstr ""
"Python 3.0 对内置函数库进行了许多更改，大多数更改无法在 Python 2.x "
"系列中引入，因为它们会破坏兼容性。:mod:`future_builtins` 模块提供了这些内置函数的版本，可以在编写 3.0 兼容代码时导入。"

#: ../../whatsnew/2.6.rst:2751
msgid "The functions in this module currently include:"
msgstr "目前此模块中的函数包括:"

#: ../../whatsnew/2.6.rst:2753
msgid ""
"``ascii(obj)``: equivalent to :func:`repr`.  In Python 3.0, :func:`repr` "
"will return a Unicode string, while :func:`ascii` will return a pure ASCII "
"bytestring."
msgstr ""
"``ascii(obj)``: 等同于 :func:`repr`。在 Python 3.0 中，:func:`repr` 将返回一个 Unicode "
"字符串，而 :func:`ascii` 将返回一个纯 ASCII 字节串。"

#: ../../whatsnew/2.6.rst:2757
msgid ""
"``filter(predicate, iterable)``, ``map(func, iterable1, ...)``: the 3.0 "
"versions return iterators, unlike the 2.x builtins which return lists."
msgstr ""
"``filter(predicate, iterable)``, ``map(func, iterable1, ...)``: 3.0 "
"版本返回迭代器，与返回列表的 2.x 内置函数不同。"

#: ../../whatsnew/2.6.rst:2761
msgid ""
"``hex(value)``, ``oct(value)``: instead of calling the :meth:`__hex__` or "
":meth:`__oct__` methods, these versions will call the :meth:`__index__` "
"method and convert the result to hexadecimal or octal.  :func:`oct` will use"
" the new ``0o`` notation for its result."
msgstr ""
"``hex(value)``, ``oct(value)``: 这些版本将调用 :meth:`__index__` 方法而不是 "
":meth:`__hex__` 或 :meth:`__oct__` 方法，并将结果转换为十六进制或八进制。:func:`oct` 将使用新的 "
"``0o`` 表示法来表示其结果。"

#: ../../whatsnew/2.6.rst:2770
msgid "The :mod:`json` module: JavaScript Object Notation"
msgstr ":mod:`json` 模块: JavaScript Object Notation"

#: ../../whatsnew/2.6.rst:2772
msgid ""
"The new :mod:`json` module supports the encoding and decoding of Python "
"types in JSON (Javascript Object Notation). JSON is a lightweight "
"interchange format often used in web applications. For more information "
"about JSON, see http://www.json.org."
msgstr ""
"新的 :mod:`json` 模块支持将 Python 类型编码和解码为 JSON（JavaScript 对象表示法）。JSON "
"是一种轻量级的数据交换格式，常用于 Web 应用程序。有关 JSON 的更多信息，请参见 http://www.json.org。"

#: ../../whatsnew/2.6.rst:2777
msgid ""
":mod:`json` comes with support for decoding and encoding most built-in "
"Python types. The following example encodes and decodes a dictionary::"
msgstr ":mod:`json` 模块支持对大多数内置 Python 类型进行解码和编码。以下示例展示了如何编码和解码字典::"

#: ../../whatsnew/2.6.rst:2780
msgid ""
">>> import json\n"
">>> data = {\"spam\": \"foo\", \"parrot\": 42}\n"
">>> in_json = json.dumps(data) # Encode the data\n"
">>> in_json\n"
"'{\"parrot\": 42, \"spam\": \"foo\"}'\n"
">>> json.loads(in_json) # Decode into a Python object\n"
"{\"spam\": \"foo\", \"parrot\": 42}"
msgstr ""
">>> import json\n"
">>> data = {\"spam\": \"foo\", \"parrot\": 42}\n"
">>> in_json = json.dumps(data) # 编码数据\n"
">>> in_json\n"
"'{\"parrot\": 42, \"spam\": \"foo\"}'\n"
">>> json.loads(in_json) # 解码到一个 Python 对象\n"
"{\"spam\": \"foo\", \"parrot\": 42}"

#: ../../whatsnew/2.6.rst:2788
msgid ""
"It's also possible to write your own decoders and encoders to support more "
"types. Pretty-printing of the JSON strings is also supported."
msgstr "你还可以编写自己的解码器和编码器以支持更多类型。还支持对 JSON 字符串进行美化打印。"

#: ../../whatsnew/2.6.rst:2791
msgid ""
":mod:`json` (originally called simplejson) was written by Bob Ippolito."
msgstr ":mod:`json` (最初称为 simplejson) 由 Bob Ippolito 编写。"

#: ../../whatsnew/2.6.rst:2798
msgid "The :mod:`plistlib` module: A Property-List Parser"
msgstr ":mod:`plistlib` 模块：属性列表解析器"

#: ../../whatsnew/2.6.rst:2800
msgid ""
"The ``.plist`` format is commonly used on Mac OS X to store basic data types"
" (numbers, strings, lists, and dictionaries) by serializing them into an "
"XML-based format. It resembles the XML-RPC serialization of data types."
msgstr ""
"``.plist`` 格式通常在 Mac OS X 上用于存储基本数据类型（数字、字符串、列表和字典），通过将它们序列化成基于 XML 的格式。它类似于"
" XML-RPC 数据类型的序列化。"

#: ../../whatsnew/2.6.rst:2805
msgid ""
"Despite being primarily used on Mac OS X, the format has nothing Mac-"
"specific about it and the Python implementation works on any platform that "
"Python supports, so the :mod:`plistlib` module has been promoted to the "
"standard library."
msgstr ""
"尽管该格式主要在 Mac OS X 上使用，但它本身并没有特定于 Mac 的内容，Python 实现在任何支持 Python 的平台上都能工作，因此 "
":mod:`plistlib` 模块已被提升到标准库中。"

#: ../../whatsnew/2.6.rst:2810
msgid "Using the module is simple::"
msgstr "此模块的用法很简单::"

#: ../../whatsnew/2.6.rst:2812
msgid ""
"import sys\n"
"import plistlib\n"
"import datetime\n"
"\n"
"# Create data structure\n"
"data_struct = dict(lastAccessed=datetime.datetime.now(),\n"
"                   version=1,\n"
"                   categories=('Personal','Shared','Private'))\n"
"\n"
"# Create string containing XML.\n"
"plist_str = plistlib.writePlistToString(data_struct)\n"
"new_struct = plistlib.readPlistFromString(plist_str)\n"
"print data_struct\n"
"print new_struct\n"
"\n"
"# Write data structure to a file and read it back.\n"
"plistlib.writePlist(data_struct, '/tmp/customizations.plist')\n"
"new_struct = plistlib.readPlist('/tmp/customizations.plist')\n"
"\n"
"# read/writePlist accepts file-like objects as well as paths.\n"
"plistlib.writePlist(data_struct, sys.stdout)"
msgstr ""
"import sys\n"
"import plistlib\n"
"import datetime\n"
"\n"
"# 创建数据结构\n"
"data_struct = dict(lastAccessed=datetime.datetime.now(),\n"
"                   version=1,\n"
"                   categories=('Personal','Shared','Private'))\n"
"\n"
"# 创建包含 XML 的字符串。\n"
"plist_str = plistlib.writePlistToString(data_struct)\n"
"new_struct = plistlib.readPlistFromString(plist_str)\n"
"print data_struct\n"
"print new_struct\n"
"\n"
"# 将数据结构写入文件并重新读取。\n"
"plistlib.writePlist(data_struct, '/tmp/customizations.plist')\n"
"new_struct = plistlib.readPlist('/tmp/customizations.plist')\n"
"\n"
"# read/writePlist 接受文件类对象以及路径。\n"
"plistlib.writePlist(data_struct, sys.stdout)"

#: ../../whatsnew/2.6.rst:2837
msgid "ctypes Enhancements"
msgstr "ctypes 增强"

#: ../../whatsnew/2.6.rst:2839
msgid ""
"Thomas Heller continued to maintain and enhance the :mod:`ctypes` module."
msgstr "Thomas Heller 继续维护和增强 :mod:`ctypes` 模块。"

#: ../../whatsnew/2.6.rst:2842
msgid ""
":mod:`ctypes` now supports a :class:`c_bool` datatype that represents the "
"C99 ``bool`` type.  (Contributed by David Remahl; :issue:`1649190`.)"
msgstr ""
":mod:`ctypes` 现在支持 :class:`c_bool` 数据类型，它表示 C99 的 ``bool`` 类型。（由 David "
"Remahl 贡献；:issue:`1649190`。）"

#: ../../whatsnew/2.6.rst:2846
msgid ""
"The :mod:`ctypes` string, buffer and array types have improved support for "
"extended slicing syntax, where various combinations of ``(start, stop, "
"step)`` are supplied. (Implemented by Thomas Wouters.)"
msgstr ""
":mod:`ctypes` 模块的字符串、缓冲区和数组类型已改进对扩展切片语法的支持，可以提供各种 ``(start, stop, step)`` "
"组合。（由 Thomas Wouters 实现。）"

#: ../../whatsnew/2.6.rst:2853
msgid ""
"All :mod:`ctypes` data types now support :meth:`from_buffer` and "
":meth:`from_buffer_copy` methods that create a ctypes instance based on a "
"provided buffer object.  :meth:`from_buffer_copy` copies the contents of the"
" object, while :meth:`from_buffer` will share the same memory area."
msgstr ""
"所有 :mod:`ctypes` 数据类型现在支持 :meth:`from_buffer` 和 :meth:`from_buffer_copy` "
"方法，这些方法基于提供的缓冲区对象创建 ctypes 实例。:meth:`from_buffer_copy` 方法复制对象的内容，而 "
":meth:`from_buffer` 方法将共享同一内存区域。"

#: ../../whatsnew/2.6.rst:2860
msgid ""
"A new calling convention tells :mod:`ctypes` to clear the ``errno`` or Win32"
" LastError variables at the outset of each wrapped call. (Implemented by "
"Thomas Heller; :issue:`1798`.)"
msgstr ""
"新的调用约定指示 :mod:`ctypes` 在每次包装调用的开始清除 ``errno`` 或 Win32 LastError 变量。（由 Thomas"
" Heller 实现；:issue:`1798`。）"

#: ../../whatsnew/2.6.rst:2864
msgid ""
"You can now retrieve the Unix ``errno`` variable after a function call.  "
"When creating a wrapped function, you can supply ``use_errno=True`` as a "
"keyword parameter to the :func:`DLL` function and then call the module-level"
" methods :meth:`set_errno` and :meth:`get_errno` to set and retrieve the "
"error value."
msgstr ""
"现在可以在函数调用后检索 Unix ``errno`` 变量。在创建包装函数时，可以将 ``use_errno=True`` 作为关键字参数提供给 "
":func:`DLL` 函数，然后调用模块级方法 :meth:`set_errno` 和 :meth:`get_errno` 来设置和检索错误值。"

#: ../../whatsnew/2.6.rst:2870
msgid ""
"The Win32 LastError variable is similarly supported by the :func:`DLL`, "
":func:`OleDLL`, and :func:`WinDLL` functions. You supply "
"``use_last_error=True`` as a keyword parameter and then call the module-"
"level methods :meth:`set_last_error` and :meth:`get_last_error`."
msgstr ""
"Win32 LastError 变量同样由 :func:`DLL`、:func:`OleDLL` 和 :func:`WinDLL` 函数支持。提供 "
"``use_last_error=True`` 作为关键字参数，然后调用模块级方法 :meth:`set_last_error` 和 "
":meth:`get_last_error`。"

#: ../../whatsnew/2.6.rst:2876
msgid ""
"The :func:`byref` function, used to retrieve a pointer to a ctypes instance,"
" now has an optional *offset* parameter that is a byte count that will be "
"added to the returned pointer."
msgstr ""
":func:`byref` 函数用于检索指向 ctypes 实例的指针，现在有一个可选的 *offset* "
"参数，该参数是一个字节计数，将添加到返回的指针中。"

#: ../../whatsnew/2.6.rst:2883
msgid "Improved SSL Support"
msgstr "改进的 SSL 支持"

#: ../../whatsnew/2.6.rst:2885
msgid ""
"Bill Janssen made extensive improvements to Python 2.6's support for the "
"Secure Sockets Layer by adding a new module, :mod:`ssl`, that's built atop "
"the `OpenSSL <https://www.openssl.org/>`__ library. This new module provides"
" more control over the protocol negotiated, the X.509 certificates used, and"
" has better support for writing SSL servers (as opposed to clients) in "
"Python.  The existing SSL support in the :mod:`socket` module hasn't been "
"removed and continues to work, though it will be removed in Python 3.0."
msgstr ""
"Bill Janssen 对 Python 2.6 的安全套接字层（SSL）支持进行了大量改进，通过添加一个新的模块 :mod:`ssl`，该模块构建在"
" `OpenSSL <https://www.openssl.org/>`__ 库之上。这个新模块提供了对协商协议、使用的 X.509 "
"证书的更多控制，并更好地支持在 Python 中编写 SSL 服务器（而不是客户端）。:mod:`socket` 模块中现有的 SSL "
"支持没有被移除，继续有效，但将在 Python 3.0 中被移除。"

#: ../../whatsnew/2.6.rst:2894
msgid ""
"To use the new module, you must first create a TCP connection in the usual "
"way and then pass it to the :func:`ssl.wrap_socket` function. It's possible "
"to specify whether a certificate is required, and to obtain certificate info"
" by calling the :meth:`getpeercert` method."
msgstr ""
"要使用新模块，你必须首先以常规方式创建一个TCP连接，然后将其传递给 :func:`ssl.wrap_socket` "
"函数。可以指定是否需要证书，并通过调用 :meth:`getpeercert` 方法获取证书信息。"

#: ../../whatsnew/2.6.rst:2901
msgid "The documentation for the :mod:`ssl` module."
msgstr ":mod:`ssl` 模块的文档。"

#: ../../whatsnew/2.6.rst:2906
msgid "Deprecations and Removals"
msgstr "弃用和移除"

#: ../../whatsnew/2.6.rst:2908 ../../whatsnew/2.6.rst:3262
msgid ""
"String exceptions have been removed.  Attempting to use them raises a "
":exc:`TypeError`."
msgstr "字符串异常已被移除。尝试使用它们将引发 :exc:`TypeError`。"

#: ../../whatsnew/2.6.rst:2911
msgid ""
"Changes to the :class:`Exception` interface as dictated by :pep:`352` "
"continue to be made.  For 2.6, the :attr:`!message` attribute is being "
"deprecated in favor of the :attr:`~BaseException.args` attribute."
msgstr ""
"根据 :pep:`352` 的要求，对 :class:`Exception` 接口的更改仍在进行中。对于2.6版本，:attr:`!message` "
"属性已被弃用，转而使用 :attr:`~BaseException.args` 属性。"

#: ../../whatsnew/2.6.rst:2916
msgid ""
"(3.0-warning mode) Python 3.0 will feature a reorganized standard library "
"that will drop many outdated modules and rename others. Python 2.6 running "
"in 3.0-warning mode will warn about these modules when they are imported."
msgstr ""
"（3.0警告模式）Python 3.0将提供一个重新组织的标准库，该库将删除许多过时的模块并重命名其他模块。在3.0警告模式下运行的Python "
"2.6将在导入这些模块时发出警告。"

#: ../../whatsnew/2.6.rst:2921
msgid ""
"The list of deprecated modules is: :mod:`!audiodev`, :mod:`!bgenlocations`, "
":mod:`!buildtools`, :mod:`!bundlebuilder`, :mod:`!Canvas`, :mod:`!compiler`,"
" :mod:`!dircache`, :mod:`!dl`, :mod:`!fpformat`, :mod:`!gensuitemodule`, "
":mod:`!ihooks`, :mod:`!imageop`, :mod:`!imgfile`, :mod:`!linuxaudiodev`, "
":mod:`!mhlib`, :mod:`!mimetools`, :mod:`!multifile`, :mod:`!new`, "
":mod:`!pure`, :mod:`!statvfs`, :mod:`!sunaudiodev`, :mod:`!test.testall`, "
"and :mod:`!toaiff`."
msgstr ""
"已弃用的模块列表如下：:mod:`!audiodev`，:mod:`!bgenlocations`，:mod:`!buildtools`，:mod:`!bundlebuilder`，:mod:`!Canvas`，:mod:`!compiler`，:mod:`!dircache`，:mod:`!dl`，:mod:`!fpformat`，:mod:`!gensuitemodule`，:mod:`!ihooks`，:mod:`!imageop`，:mod:`!imgfile`，:mod:`!linuxaudiodev`，:mod:`!mhlib`，:mod:`!mimetools`，:mod:`!multifile`，:mod:`!new`，:mod:`!pure`，:mod:`!statvfs`，:mod:`!sunaudiodev`，:mod:`!test.testall`"
" 和 :mod:`!toaiff`。"

#: ../../whatsnew/2.6.rst:2946
msgid "The :mod:`!gopherlib` module has been removed."
msgstr ":mod:`!gopherlib` 模块已被移除。"

#: ../../whatsnew/2.6.rst:2948
msgid ""
"The :mod:`!MimeWriter` module and :mod:`!mimify` module have been "
"deprecated; use the :mod:`email` package instead."
msgstr ":mod:`!MimeWriter` 模块和 :mod:`!mimify` 模块已被弃用；请改用 :mod:`email` 包。"

#: ../../whatsnew/2.6.rst:2952
msgid ""
"The :mod:`!md5` module has been deprecated; use the :mod:`hashlib` module "
"instead."
msgstr ":mod:`!md5` 模块已被弃用；请改用 :mod:`hashlib` 模块。"

#: ../../whatsnew/2.6.rst:2955
msgid ""
"The :mod:`!posixfile` module has been deprecated; :func:`fcntl.lockf` "
"provides better locking."
msgstr ":mod:`!posixfile` 模块已被弃用；:func:`fcntl.lockf` 可提供更好的锁机制。"

#: ../../whatsnew/2.6.rst:2958
msgid ""
"The :mod:`!popen2` module has been deprecated; use the :mod:`subprocess` "
"module."
msgstr ":mod:`!popen2` 模块已被弃用；请使用 :mod:`subprocess` 模块。"

#: ../../whatsnew/2.6.rst:2961
msgid "The :mod:`!rgbimg` module has been removed."
msgstr ":mod:`!rgbimg` 模块已被移除。"

#: ../../whatsnew/2.6.rst:2963
msgid ""
"The :mod:`!sets` module has been deprecated; it's better to use the built-in"
" :class:`set` and :class:`frozenset` types."
msgstr ":mod:`!sets` 模块已被弃用；最好使用内置的 :class:`set` 和 :class:`frozenset` 类型。"

#: ../../whatsnew/2.6.rst:2966
msgid ""
"The :mod:`!sha` module has been deprecated; use the :mod:`hashlib` module "
"instead."
msgstr ":mod:`!sha` 模块已被弃用；请使用 :mod:`hashlib` 模块。"

#: ../../whatsnew/2.6.rst:2974
msgid "Build and C API Changes"
msgstr "构建和 C API 的变更"

#: ../../whatsnew/2.6.rst:2976
msgid "Changes to Python's build process and to the C API include:"
msgstr "针对 Python 构建过程和 C API 的变更包括:"

#: ../../whatsnew/2.6.rst:2978
msgid ""
"Python now must be compiled with C89 compilers (after 19 years!).  This "
"means that the Python source tree has dropped its own implementations of "
":c:func:`!memmove` and :c:func:`!strerror`, which are in the C89 standard "
"library."
msgstr ""
"Python现在必须使用C89编译器进行编译（19年后！）。这意味着Python源代码树已删除其自身的 :c:func:`!memmove` 和 "
":c:func:`!strerror` 实现，这些功能在C89标准库中。"

#: ../../whatsnew/2.6.rst:2983
msgid ""
"Python 2.6 can be built with Microsoft Visual Studio 2008 (version 9.0), and"
" this is the new default compiler.  See the :file:`PCbuild` directory for "
"the build files.  (Implemented by Christian Heimes.)"
msgstr ""
"Python 2.6可以使用Microsoft Visual Studio 2008（版本9.0）构建，这也是新的默认编译器。请查看 "
":file:`PCbuild` 目录以获取构建文件。（由Christian Heimes实现。）"

#: ../../whatsnew/2.6.rst:2988
msgid ""
"On Mac OS X, Python 2.6 can be compiled as a 4-way universal build. The "
":program:`configure` script can take a :option:`!--with-universal-"
"archs=[32-bit|64-bit|all]` switch, controlling whether the binaries are "
"built for 32-bit architectures (x86, PowerPC), 64-bit (x86-64 and PPC-64), "
"or both. (Contributed by Ronald Oussoren.)"
msgstr ""
"在Mac OS X上，Python 2.6可以编译为四路通用构建。:program:`configure` 脚本可以接受一个 :option:`!--"
"with-universal-archs=[32-bit|64-bit|all]` "
"开关，控制生成的二进制文件是为32位架构（x86，PowerPC）、64位（x86-64和PPC-64）还是两者都支持。（由Ronald "
"Oussoren贡献。）"

#: ../../whatsnew/2.6.rst:2995
msgid ""
"A new function added in Python 2.6.6, :c:func:`!PySys_SetArgvEx`, sets the "
"value of ``sys.argv`` and can optionally update ``sys.path`` to include the "
"directory containing the script named by ``sys.argv[0]`` depending on the "
"value of an *updatepath* parameter."
msgstr ""
"在Python 2.6.6中新增的函数 :c:func:`!PySys_SetArgvEx`，设置 ``sys.argv`` 的值，并且可以可选地根据 "
"*updatepath* 参数的值更新 ``sys.path`` 以包括包含由 ``sys.argv[0]`` 指定的脚本的目录。"

#: ../../whatsnew/2.6.rst:3000
msgid ""
"This function was added to close a security hole for applications that embed"
" Python.  The old function, :c:func:`!PySys_SetArgv`, would always update "
"``sys.path``, and sometimes it would add the current directory.  This meant "
"that, if you ran an application embedding Python in a directory controlled "
"by someone else, attackers could put a Trojan-horse module in the directory "
"(say, a file named :file:`os.py`) that your application would then import "
"and run."
msgstr ""
"此函数的添加是为了关闭嵌入Python的应用程序的安全漏洞。旧的函数 :c:func:`!PySys_SetArgv` 总是更新 "
"``sys.path``，有时还会添加当前目录。这意味着，如果你在一个由其他人控制的目录中运行嵌入Python的应用程序，攻击者可以在该目录中放置一个木马模块（例如，一个名为"
" :file:`os.py` 的文件），你的应用程序将会导入并运行它。"

#: ../../whatsnew/2.6.rst:3008
msgid ""
"If you maintain a C/C++ application that embeds Python, check whether you're"
" calling :c:func:`!PySys_SetArgv` and carefully consider whether the "
"application should be using :c:func:`!PySys_SetArgvEx` with *updatepath* set"
" to false.  Note that using this function will break compatibility with "
"Python versions 2.6.5 and earlier; if you have to continue working with "
"earlier versions, you can leave the call to :c:func:`!PySys_SetArgv` alone "
"and call ``PyRun_SimpleString(\"sys.path.pop(0)\\n\")`` afterwards to "
"discard the first ``sys.path`` component."
msgstr ""
"如果你维护一个嵌入Python的C/C++应用程序，检查你是否调用了 :c:func:`!PySys_SetArgv` 并仔细考虑应用程序是否应该使用 "
"*updatepath* 设置为false的 :c:func:`!PySys_SetArgvEx`。请注意，使用此函数将破坏与Python "
"2.6.5及更早版本兼容性；如果你必须继续使用早期版本，你可以保留对 :c:func:`!PySys_SetArgv` 的调用，并在之后调用 "
"``PyRun_SimpleString(\"sys.path.pop(0)\\n\")`` 来丢弃 ``sys.path`` 的第一个组件。"

#: ../../whatsnew/2.6.rst:3018
msgid ""
"Security issue reported as :cve:`2008-5983`; discussed in :gh:`50003`, and "
"fixed by Antoine Pitrou."
msgstr "安全问题报告为 :cve:`2008-5983`；在 :gh:`50003` 中讨论，并由Antoine Pitrou修复。"

#: ../../whatsnew/2.6.rst:3021
msgid ""
"The BerkeleyDB module now has a C API object, available as ``bsddb.db.api``."
"   This object can be used by other C extensions that wish to use the "
":mod:`bsddb` module for their own purposes. (Contributed by Duncan Grisby.)"
msgstr ""
"BerkeleyDB模块现在有一个C API对象，作为 ``bsddb.db.api`` 提供。这个对象可以被其他希望使用 :mod:`bsddb` "
"模块实现自己目的的C扩展使用。（由Duncan Grisby贡献。）"

#: ../../whatsnew/2.6.rst:3026
msgid ""
"The new buffer interface, previously described in `the PEP 3118 section "
"<#pep-3118-revised-buffer-protocol>`__, adds :c:func:`PyObject_GetBuffer` "
"and :c:func:`PyBuffer_Release`, as well as a few other functions."
msgstr ""
"新的缓冲区接口，之前在 `PEP 3118 部分 <#pep-3118-revised-buffer-protocol>`__ 中描述，增加了 "
":c:func:`PyObject_GetBuffer` 和 :c:func:`PyBuffer_Release`，以及其他一些函数。"

#: ../../whatsnew/2.6.rst:3031
msgid ""
"Python's use of the C stdio library is now thread-safe, or at least as "
"thread-safe as the underlying library is.  A long-standing potential bug "
"occurred if one thread closed a file object while another thread was reading"
" from or writing to the object.  In 2.6 file objects have a reference count,"
" manipulated by the :c:func:`!PyFile_IncUseCount` and "
":c:func:`!PyFile_DecUseCount` functions.  File objects can't be closed "
"unless the reference count is zero.  :c:func:`!PyFile_IncUseCount` should be"
" called while the GIL is still held, before carrying out an I/O operation "
"using the ``FILE *`` pointer, and :c:func:`!PyFile_DecUseCount` should be "
"called immediately after the GIL is re-acquired. (Contributed by Antoine "
"Pitrou and Gregory P. Smith.)"
msgstr ""
"Python 对 C "
"标准输入输出库的使用现在是线程安全的，或者至少与底层库一样线程安全。一个长期存在的潜在错误是，如果一个线程在另一个线程正在读取或写入文件对象时关闭该文件对象。在"
" 2.6 版本中，文件对象具有引用计数，由 :c:func:`!PyFile_IncUseCount` 和 "
":c:func:`!PyFile_DecUseCount` "
"函数操作。文件对象只有在引用计数为零时才能被关闭。:c:func:`!PyFile_IncUseCount` 应在仍持有 GIL 时调用，在进行使用 "
"``FILE *`` 指针的 I/O 操作之前，而 :c:func:`!PyFile_DecUseCount` 应在重新获取 GIL 后立即调用。（由 "
"Antoine Pitrou 和 Gregory P. Smith 贡献。）"

#: ../../whatsnew/2.6.rst:3044
msgid ""
"Importing modules simultaneously in two different threads no longer "
"deadlocks; it will now raise an :exc:`ImportError`.  A new API function, "
":c:func:`PyImport_ImportModuleNoBlock`, will look for a module in "
"``sys.modules`` first, then try to import it after acquiring an import lock."
"  If the import lock is held by another thread, an :exc:`ImportError` is "
"raised. (Contributed by Christian Heimes.)"
msgstr ""
"在两个不同线程中同时导入模块不再会导致死锁；现在会引发一个 :exc:`ImportError`。一个新的 API 函数 "
":c:func:`PyImport_ImportModuleNoBlock`，首先会在 ``sys.modules`` "
"中查找模块，然后在获取导入锁后尝试导入它。如果导入锁被另一个线程持有，则会引发 :exc:`ImportError`。（由 Christian "
"Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:3052
msgid ""
"Several functions return information about the platform's floating-point "
"support.  :c:func:`PyFloat_GetMax` returns the maximum representable "
"floating-point value, and :c:func:`PyFloat_GetMin` returns the minimum "
"positive value.  :c:func:`PyFloat_GetInfo` returns an object containing more"
" information from the :file:`float.h` file, such as ``\"mant_dig\"`` (number"
" of digits in the mantissa), ``\"epsilon\"`` (smallest difference between "
"1.0 and the next largest value representable), and several others. "
"(Contributed by Christian Heimes; :issue:`1534`.)"
msgstr ""
"有几个函数返回有关平台浮点支持的信息。:c:func:`PyFloat_GetMax` 返回最大可表示的浮点值，而 "
":c:func:`PyFloat_GetMin` 返回最小正值。:c:func:`PyFloat_GetInfo` 返回一个对象，其中包含来自 "
":file:`float.h` 文件的更多信息，例如 ``\"mant_dig\"`` (尾数中的数字位数) 、``\"epsilon\"`` (1.0"
" 与下一个最大可表示值之间的最小差异) 以及其他几个信息。（由 Christian Heimes 贡献；:issue:`1534`。）"

#: ../../whatsnew/2.6.rst:3063
msgid ""
"C functions and methods that use :c:func:`PyComplex_AsCComplex` will now "
"accept arguments that have a :meth:`__complex__` method.  In particular, the"
" functions in the :mod:`cmath` module will now accept objects with this "
"method. This is a backport of a Python 3.0 change. (Contributed by Mark "
"Dickinson; :issue:`1675423`.)"
msgstr ""
"使用 :c:func:`PyComplex_AsCComplex` 的 C 函数和方法现在将接受具有 :meth:`__complex__` "
"方法的参数。特别是，:mod:`cmath` 模块中的函数现在将接受具有此方法的对象。这是 Python 3.0 变更的一个回退版本。（由 Mark "
"Dickinson 贡献；:issue:`1675423`。）"

#: ../../whatsnew/2.6.rst:3070
msgid ""
"Python's C API now includes two functions for case-insensitive string "
"comparisons, ``PyOS_stricmp(char*, char*)`` and ``PyOS_strnicmp(char*, "
"char*, Py_ssize_t)``. (Contributed by Christian Heimes; :issue:`1635`.)"
msgstr ""
"Python 的 C API 现在包括两个用于不区分大小写的字符串比较函数，``PyOS_stricmp(char*, char*)`` 和 "
"``PyOS_strnicmp(char*, char*, Py_ssize_t)``。（由 Christian Heimes "
"贡献；:issue:`1635`。）"

#: ../../whatsnew/2.6.rst:3075
msgid ""
"Many C extensions define their own little macro for adding integers and "
"strings to the module's dictionary in the ``init*`` function.  Python 2.6 "
"finally defines standard macros for adding values to a module, "
":c:macro:`PyModule_AddStringMacro` and :c:macro:`PyModule_AddIntMacro()`.  "
"(Contributed by Christian Heimes.)"
msgstr ""
"许多 C 扩展在 ``init*`` 函数中定义了自己的小宏，用于将整数和字符串添加到模块的字典中。Python 2.6 "
"终于定义了用于向模块添加值的标准宏，:c:macro:`PyModule_AddStringMacro` 和 "
":c:macro:`PyModule_AddIntMacro()`。（由 Christian Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:3082
msgid ""
"Some macros were renamed in both 3.0 and 2.6 to make it clearer that they "
"are macros, not functions.  :c:macro:`!Py_Size()` became "
":c:macro:`Py_SIZE()`, :c:macro:`!Py_Type()` became :c:macro:`Py_TYPE()`, and"
" :c:macro:`!Py_Refcnt()` became :c:macro:`Py_REFCNT()`. The mixed-case "
"macros are still available in Python 2.6 for backward compatibility. "
"(:issue:`1629`)"
msgstr ""
"一些宏在 3.0 和 2.6 中都被重命名，以更清楚地表明它们是宏，而不是函数。:c:macro:`!Py_Size()` 变为 "
":c:macro:`Py_SIZE()`，:c:macro:`!Py_Type()` 变为 "
":c:macro:`Py_TYPE()`，:c:macro:`!Py_Refcnt()` 变为 "
":c:macro:`Py_REFCNT()`。混合大小写的宏在 Python 2.6 中仍然可用，以保持向后兼容。(:issue:`1629`)"

#: ../../whatsnew/2.6.rst:3091
msgid ""
"Distutils now places C extensions it builds in a different directory when "
"running on a debug version of Python. (Contributed by Collin Winter; "
":issue:`1530959`.)"
msgstr ""
"Distutils 在运行调试版本的 Python 时，现在将构建的 C 扩展放置在不同的目录中。（由 Collin Winter "
"贡献；:issue:`1530959`。）"

#: ../../whatsnew/2.6.rst:3095
msgid ""
"Several basic data types, such as integers and strings, maintain internal "
"free lists of objects that can be re-used.  The data structures for these "
"free lists now follow a naming convention: the variable is always named "
"``free_list``, the counter is always named ``numfree``, and a macro "
"``Py<typename>_MAXFREELIST`` is always defined."
msgstr ""
"几种基本数据类型，如整数和字符串，维护内部的对象自由列表，这些对象可以重复使用。这些自由列表的数据结构现在遵循命名约定：变量始终命名为 "
"``free_list``，计数器始终命名为 ``numfree``，并且始终定义一个宏 ``Py<typename>_MAXFREELIST``。"

#: ../../whatsnew/2.6.rst:3102
msgid ""
"A new Makefile target, \"make patchcheck\", prepares the Python source tree "
"for making a patch: it fixes trailing whitespace in all modified ``.py`` "
"files, checks whether the documentation has been changed, and reports "
"whether the :file:`Misc/ACKS` and :file:`Misc/NEWS` files have been updated."
" (Contributed by Brett Cannon.)"
msgstr ""
"一个新的Makefile目标，\"make "
"patchcheck\"，用于准备Python源代码树以生成补丁：它会修复所有修改过的\".py\"文件中的尾部空白，检查文档是否已更改，并报告 "
":file:`Misc/ACKS` 和 :file:`Misc/NEWS` 文件是否已更新。（由 Brett Cannon 贡献。）"

#: ../../whatsnew/2.6.rst:3109
msgid ""
"Another new target, \"make profile-opt\", compiles a Python binary using "
"GCC's profile-guided optimization.  It compiles Python with profiling "
"enabled, runs the test suite to obtain a set of profiling results, and then "
"compiles using these results for optimization. (Contributed by Gregory P. "
"Smith.)"
msgstr ""
"另一个新目标，\"make profile-"
"opt\"，使用GCC的基于配置的优化来编译Python二进制文件。它会启用配置编译Python，运行测试套件以获取一组配置结果，然后使用这些结果进行优化编译。（由"
" Gregory P. Smith 贡献。）"

#: ../../whatsnew/2.6.rst:3118
msgid "Port-Specific Changes: Windows"
msgstr "特定于 Windows 的更改："

#: ../../whatsnew/2.6.rst:3120
msgid ""
"The support for Windows 95, 98, ME and NT4 has been dropped. Python 2.6 "
"requires at least Windows 2000 SP4."
msgstr "对Windows 95、98、ME和NT4的支持已被放弃。Python 2.6至少需要Windows 2000 SP4。"

#: ../../whatsnew/2.6.rst:3123
msgid ""
"The new default compiler on Windows is Visual Studio 2008 (version 9.0). The"
" build directories for Visual Studio 2003 (version 7.1) and 2005 (version "
"8.0) were moved into the PC/ directory. The new :file:`PCbuild` directory "
"supports cross compilation for X64, debug builds and Profile Guided "
"Optimization (PGO). PGO builds are roughly 10% faster than normal builds.  "
"(Contributed by Christian Heimes with help from Amaury Forgeot d'Arc and "
"Martin von Löwis.)"
msgstr ""
"Windows上的新默认编译器是Visual Studio 2008（版本9.0）。Visual Studio "
"2003（版本7.1）和2005（版本8.0）的构建目录已被移至PC/目录。新的 :file:`PCbuild` "
"目录支持X64的交叉编译、调试构建和配置引导优化（PGO）。PGO构建比普通构建大约快10%。 （由 Christian Heimes "
"贡献，Amaury Forgeot d'Arc 和 Martin von Löwis 提供帮助。）"

#: ../../whatsnew/2.6.rst:3131
msgid ""
"The :mod:`msvcrt` module now supports both the normal and wide char variants"
" of the console I/O API.  The :func:`~msvcrt.getwch` function reads a "
"keypress and returns a Unicode value, as does the :func:`~msvcrt.getwche` "
"function.  The :func:`~msvcrt.putwch` function takes a Unicode character and"
" writes it to the console. (Contributed by Christian Heimes.)"
msgstr ""
":mod:`msvcrt` 模块现在支持控制台 I/O API 的普通和宽字符变体。:func:`~msvcrt.getwch` 函数读取按键并返回一个"
" Unicode 值，:func:`~msvcrt.getwche` 函数也是如此。:func:`~msvcrt.putwch` "
"函数接受一个Unicode字符并将其写入控制台。（由 Christian Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:3138
msgid ""
":func:`os.path.expandvars` will now expand environment variables in the form"
" \"%var%\", and \"~user\" will be expanded into the user's home directory "
"path.  (Contributed by Josiah Carlson; :issue:`957650`.)"
msgstr ""
":func:`os.path.expandvars` 现在将展开形式为  \"%var%\"的环境变量，而 \"~user\" "
"将被展开为用户的主目录路径。（由 Josiah Carlson 贡献；:issue:`957650`。）"

#: ../../whatsnew/2.6.rst:3142
msgid ""
"The :mod:`socket` module's socket objects now have an "
":meth:`~socket.socket.ioctl` method that provides a limited interface to the"
" :c:func:`WSAIoctl` system interface."
msgstr ""
":mod:`socket` 模块的套接字对象现在有一个 :meth:`~socket.socket.ioctl` 方法，它提供了一个有限的接口到 "
":c:func:`WSAIoctl` 系统接口。"

#: ../../whatsnew/2.6.rst:3146
msgid ""
"The :mod:`_winreg <winreg>` module now has a function, "
":func:`~winreg.ExpandEnvironmentStrings`, that expands environment variable "
"references such as ``%NAME%`` in an input string.  The handle objects "
"provided by this module now support the context protocol, so they can be "
"used in :keyword:`with` statements. (Contributed by Christian Heimes.)"
msgstr ""
":mod:`_winreg <winreg>` "
"模块现在有一个函数，:func:`~winreg.ExpandEnvironmentStrings`，用于扩展输入字符串中的环境变量引用，如 "
"``%NAME%``。该模块提供的句柄对象现在支持上下文协议，因此可以在 :keyword:`with` 语句中使用。（由 Christian "
"Heimes 贡献。）"

#: ../../whatsnew/2.6.rst:3153
msgid ""
":mod:`_winreg <winreg>` also has better support for x64 systems, exposing "
"the :func:`~winreg.DisableReflectionKey`, "
":func:`~winreg.EnableReflectionKey`, and :func:`~winreg.QueryReflectionKey` "
"functions, which enable and disable registry reflection for 32-bit processes"
" running on 64-bit systems. (:issue:`1753245`)"
msgstr ""
":mod:`_winreg <winreg>` 还对 x64 系统提供了更好的支持，公开了 "
":func:`~winreg.DisableReflectionKey`、:func:`~winreg.EnableReflectionKey` 和 "
":func:`~winreg.QueryReflectionKey` 函数，这些函数用于启用和禁用在 64 位系统上运行的 32 "
"位进程的注册表反射。(:issue:`1753245`)"

#: ../../whatsnew/2.6.rst:3159
msgid ""
"The :mod:`!msilib` module's :class:`!Record` object gained "
":meth:`!GetInteger` and :meth:`!GetString` methods that return field values "
"as an integer or a string. (Contributed by Floris Bruynooghe; "
":issue:`2125`.)"
msgstr ""
":mod:`!msilib` 模块的 :class:`!Record` 对象增加了 :meth:`!GetInteger` 和 "
":meth:`!GetString` 方法，分别返回字段值作为整数或字符串。（由 Floris Bruynooghe "
"贡献；:issue:`2125`。）"

#: ../../whatsnew/2.6.rst:3167
msgid "Port-Specific Changes: Mac OS X"
msgstr "特定于 Mac OS X 的更改："

#: ../../whatsnew/2.6.rst:3169
msgid ""
"When compiling a framework build of Python, you can now specify the "
"framework name to be used by providing the :option:`!--with-framework-name=`"
" option to the :program:`configure` script."
msgstr ""
"现在，在编译Python的框架版本时，可以为 :program:`configure` 脚本添加 :option:`!--with-framework-"
"name=` 选项来指定要使用的框架名称。"

#: ../../whatsnew/2.6.rst:3174
msgid ""
"The :mod:`!macfs` module has been removed.  This in turn required the "
":func:`!macostools.touched` function to be removed because it depended on "
"the :mod:`!macfs` module.  (:issue:`1490190`)"
msgstr ""
":mod:`!macfs` 模块已被移除。这也导致 :func:`!macostools.touched` 函数被移除，因为它依赖于 "
":mod:`!macfs` 模块。(:issue:`1490190`)"

#: ../../whatsnew/2.6.rst:3178
msgid ""
"Many other Mac OS modules have been deprecated and will be removed in Python"
" 3.0: :mod:`!_builtinSuites`, :mod:`!aepack`, :mod:`!aetools`, "
":mod:`!aetypes`, :mod:`!applesingle`, :mod:`!appletrawmain`, "
":mod:`!appletrunner`, :mod:`!argvemulator`, :mod:`!Audio_mac`, "
":mod:`!autoGIL`, :mod:`!Carbon`, :mod:`!cfmfile`, :mod:`!CodeWarrior`, "
":mod:`!ColorPicker`, :mod:`!EasyDialogs`, :mod:`!Explorer`, :mod:`!Finder`, "
":mod:`!FrameWork`, :mod:`!findertools`, :mod:`!ic`, :mod:`!icglue`, "
":mod:`!icopen`, :mod:`!macerrors`, :mod:`!MacOS`, :mod:`!macfs`, "
":mod:`!macostools`, :mod:`!macresource`, :mod:`!MiniAEFrame`, :mod:`!Nav`, "
":mod:`!Netscape`, :mod:`!OSATerminology`, :mod:`!pimp`, "
":mod:`!PixMapWrapper`, :mod:`!StdSuites`, :mod:`!SystemEvents`, "
":mod:`!Terminal`, and :mod:`!terminalcommand`."
msgstr ""
"许多其他 Mac OS 模块已被弃用，并将在 Python 3.0 "
"中移除：:mod:`!_builtinSuites`、:mod:`!aepack`、:mod:`!aetools`、:mod:`!aetypes`、:mod:`!applesingle`、:mod:`!appletrawmain`、:mod:`!appletrunner`、:mod:`!argvemulator`、:mod:`!Audio_mac`、:mod:`!autoGIL`、:mod:`!Carbon`、:mod:`!cfmfile`、:mod:`!CodeWarrior`、:mod:`!ColorPicker`、:mod:`!EasyDialogs`、:mod:`!Explorer`、:mod:`!Finder`、:mod:`!FrameWork`、:mod:`!findertools`、:mod:`!ic`、:mod:`!icglue`、:mod:`!icopen`、:mod:`!macerrors`、:mod:`!MacOS`、:mod:`!macfs`、:mod:`!macostools`、:mod:`!macresource`、:mod:`!MiniAEFrame`、:mod:`!Nav`、:mod:`!Netscape`、:mod:`!OSATerminology`、:mod:`!pimp`、:mod:`!PixMapWrapper`、:mod:`!StdSuites`、:mod:`!SystemEvents`、:mod:`!Terminal`"
" 和 :mod:`!terminalcommand`。"

#: ../../whatsnew/2.6.rst:3221
msgid "Port-Specific Changes: IRIX"
msgstr "特定于 IRIX 的更改："

#: ../../whatsnew/2.6.rst:3223
msgid ""
"A number of old IRIX-specific modules were deprecated and will be removed in"
" Python 3.0: :mod:`!al` and :mod:`!AL`, :mod:`!cd`, :mod:`!cddb`, "
":mod:`!cdplayer`, :mod:`!CL` and :mod:`!cl`, :mod:`!DEVICE`, :mod:`!ERRNO`, "
":mod:`!FILE`, :mod:`!FL` and :mod:`!fl`, :mod:`!flp`, :mod:`!fm`, "
":mod:`!GET`, :mod:`!GLWS`, :mod:`!GL` and :mod:`!gl`, :mod:`!IN`, "
":mod:`!IOCTL`, :mod:`!jpeg`, :mod:`!panelparser`, :mod:`!readcd`, :mod:`!SV`"
" and :mod:`!sv`, :mod:`!torgb`, :mod:`!videoreader`, and :mod:`!WAIT`."
msgstr ""
"一些旧的IRIX特定模块已被弃用，并将在Python 3.0中移除：:mod:`!al` 和 "
":mod:`!AL`，:mod:`!cd`，:mod:`!cddb`，:mod:`!cdplayer`，:mod:`!CL` 和 "
":mod:`!cl`，:mod:`!DEVICE`，:mod:`!ERRNO`，:mod:`!FILE`，:mod:`!FL` 和 "
":mod:`!fl`，:mod:`!flp`，:mod:`!fm`，:mod:`!GET`，:mod:`!GLWS`，:mod:`!GL` 和 "
":mod:`!gl`，:mod:`!IN`，:mod:`!IOCTL`，:mod:`!jpeg`，:mod:`!panelparser`，:mod:`!readcd`，:mod:`!SV`"
" 和 :mod:`!sv`，:mod:`!torgb`，:mod:`!videoreader`，以及 :mod:`!WAIT`。"

#: ../../whatsnew/2.6.rst:3253
msgid "Porting to Python 2.6"
msgstr "移植到Python 2.6"

#: ../../whatsnew/2.6.rst:3255
msgid ""
"This section lists previously described changes and other bugfixes that may "
"require changes to your code:"
msgstr "本节列出了先前描述的改变以及可能需要修改你的代码的其他问题修正:"

#: ../../whatsnew/2.6.rst:3258
msgid ""
"Classes that aren't supposed to be hashable should set ``__hash__ = None`` "
"in their definitions to indicate the fact."
msgstr "预期为不可哈希的类应当在其定义中设置 ``__hash__ = None`` 来指明这一点。"

#: ../../whatsnew/2.6.rst:3265
msgid ""
"The :meth:`__init__` method of :class:`collections.deque` now clears any "
"existing contents of the deque before adding elements from the iterable.  "
"This change makes the behavior match ``list.__init__()``."
msgstr ""
":class:`collections.deque` 的 :meth:`__init__` "
"方法现在会在从可迭代对象添加元素之前清空deque中的任何现有内容。这一改变使得其行为与 ``list.__init__()`` 相匹配。"

#: ../../whatsnew/2.6.rst:3270
msgid ""
":meth:`object.__init__` previously accepted arbitrary arguments and keyword "
"arguments, ignoring them.  In Python 2.6, this is no longer allowed and will"
" result in a :exc:`TypeError`.  This will affect :meth:`__init__` methods "
"that end up calling the corresponding method on :class:`object` (perhaps "
"through using :func:`super`). See :issue:`1683368` for discussion."
msgstr ""
"以前 :meth:`object.__init__` 接受任意参数和关键字参数，并忽略它们。在Python 2.6中，这不再被允许，并将导致 "
":exc:`TypeError`。这将影响最终调用 :class:`object` 上相应方法（可能通过使用 :func:`super`）的 "
":meth:`__init__` 方法。参见 :issue:`1683368` 进行讨论。"

#: ../../whatsnew/2.6.rst:3277
msgid ""
"The :class:`Decimal` constructor now accepts leading and trailing whitespace"
" when passed a string.  Previously it would raise an :exc:`InvalidOperation`"
" exception.  On the other hand, the :meth:`create_decimal` method of "
":class:`Context` objects now explicitly disallows extra whitespace, raising "
"a :exc:`ConversionSyntax` exception."
msgstr ""
":class:`Decimal` 构造函数现在在接受字符串时允许前导和尾随空格。以前它会引发 :exc:`InvalidOperation` "
"异常。另一方面，:class:`Context` 对象的 :meth:`create_decimal` 方法现在明确禁止额外空格，并引发 "
":exc:`ConversionSyntax` 异常。"

#: ../../whatsnew/2.6.rst:3284
msgid ""
"Due to an implementation accident, if you passed a file path to the built-in"
"  :func:`__import__` function, it would actually import the specified file."
"  This was never intended to work, however, and the implementation now "
"explicitly checks for this case and raises an :exc:`ImportError`."
msgstr ""
"由于实现上的意外，如果你将文件路径传递给内置的 :func:`__import__` "
"函数，它实际上会导入指定的文件。这从未打算工作，然而，现在的实现明确检查这种情况并引发 :exc:`ImportError`。"

#: ../../whatsnew/2.6.rst:3290
msgid ""
"C API: the :c:func:`PyImport_Import` and :c:func:`PyImport_ImportModule` "
"functions now default to absolute imports, not relative imports. This will "
"affect C extensions that import other modules."
msgstr ""
"C API：:c:func:`PyImport_Import` 和 :c:func:`PyImport_ImportModule` "
"函数现在默认为绝对导入，而不是相对导入。这将影响导入其他模块的C扩展。"

#: ../../whatsnew/2.6.rst:3294
msgid ""
"C API: extension data types that shouldn't be hashable should define their "
"``tp_hash`` slot to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"C API：不应可哈希的扩展数据类型应将其 ``tp_hash`` 插槽定义为 "
":c:func:`PyObject_HashNotImplemented`。"

#: ../../whatsnew/2.6.rst:3298
msgid ""
"The :mod:`socket` module exception :exc:`socket.error` now inherits from "
":exc:`IOError`.  Previously it wasn't a subclass of :exc:`StandardError` but"
" now it is, through :exc:`IOError`. (Implemented by Gregory P. Smith; "
":issue:`1706815`.)"
msgstr ""
":mod:`socket` 模块的异常 :exc:`socket.error` 现在继承自 :exc:`IOError`。以前它不是 "
":exc:`StandardError` 的子类，但现在通过 :exc:`IOError` 继承了。（由 Gregory P. Smith "
"实现；:issue:`1706815`。）"

#: ../../whatsnew/2.6.rst:3303
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module no longer automatically converts"
" :class:`datetime.date` and :class:`datetime.time` to the "
":class:`xmlrpclib.DateTime <xmlrpc.client.DateTime>` type; the conversion "
"semantics were not necessarily correct for all applications.  Code using "
":mod:`!xmlrpclib` should convert :class:`date` and :class:`~datetime.time` "
"instances. (:issue:`1330538`)"
msgstr ""
":mod:`xmlrpclib <xmlrpc.client>` 模块不再自动将 :class:`datetime.date` 和 "
":class:`datetime.time` 转换为 :class:`xmlrpclib.DateTime "
"<xmlrpc.client.DateTime>` 类型；转换语义并不一定适用于所有应用。使用 :mod:`!xmlrpclib` 的代码应转换 "
":class:`date` 和 :class:`~datetime.time` 实例。（:issue:`1330538`）"

#: ../../whatsnew/2.6.rst:3310
msgid ""
"(3.0-warning mode) The :class:`Exception` class now warns when accessed "
"using slicing or index access; having :class:`Exception` behave like a tuple"
" is being phased out."
msgstr ""
"(3.0 警告模式) :class:`Exception` 类在被切片或索引访问时会产生警告。:class:`Exception` "
"像元组一样的行为正在被逐步淘汰。"

#: ../../whatsnew/2.6.rst:3314
msgid ""
"(3.0-warning mode) inequality comparisons between two dictionaries or two "
"objects that don't implement comparison methods are reported as warnings.  "
"``dict1 == dict2`` still works, but ``dict1 < dict2`` is being phased out."
msgstr ""
"（3.0 警告模式）两个字典或两个未实现比较方法的对象之间的不等比较会被报告为警告。``dict1 == dict2`` 仍然有效，但 ``dict1 "
"< dict2`` 正在被逐步淘汰。"

#: ../../whatsnew/2.6.rst:3319
msgid ""
"Comparisons between cells, which are an implementation detail of Python's "
"scoping rules, also cause warnings because such comparisons are forbidden "
"entirely in 3.0."
msgstr "单元格之间的比较，这是 Python 作用域规则的实现细节，也会导致警告，因为在 3.0 中完全禁止此类比较。"

#: ../../whatsnew/2.6.rst:3323
msgid "For applications that embed Python:"
msgstr "对于嵌入Python的应用程序："

#: ../../whatsnew/2.6.rst:3325
msgid ""
"The :c:func:`!PySys_SetArgvEx` function was added in Python 2.6.6, letting "
"applications close a security hole when the existing "
":c:func:`!PySys_SetArgv` function was used.  Check whether you're calling "
":c:func:`!PySys_SetArgv` and carefully consider whether the application "
"should be using :c:func:`!PySys_SetArgvEx` with *updatepath* set to false."
msgstr ""
"Python 2.6.6 中增加了 :c:func:`!PySys_SetArgvEx` 函数，这让应用可以弥补一个在使用现有 "
":c:func:`!PySys_SetArgv` 函数时会存在的安全漏洞。 请检查你是否有调用 :c:func:`!PySys_SetArgv` "
"并仔细考虑应用是否应当改用 :c:func:`!PySys_SetArgvEx` 并将 *updatepath* 设为假值。"

#: ../../whatsnew/2.6.rst:3338
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.6.rst:3340
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Georg Brandl, Steve Brown, Nick Coghlan, Ralph Corderoy, Jim Jewett, Kent "
"Johnson, Chris Lambacher,  Martin Michlmayr, Antoine Pitrou, Brian Warner."
msgstr ""
"作者感谢以下人员对本文各种草稿给予的建议，更正和协助： Georg Brandl、Steve Brown、Nick Coghlan、Ralph "
"Corderoy、Jim Jewett、Kent Johnson、Chris Lambacher、 Martin Michlmayr、Antoine "
"Pitrou、Brian Warner。"

#: ../../whatsnew/2.6.rst:1068
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../whatsnew/2.6.rst:1068
msgid "What's new"
msgstr "有什么新变化"
