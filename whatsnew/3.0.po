# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/3.0.rst:3
msgid "What's New In Python 3.0"
msgstr "Python 3.0 有什么新变化"

#: ../../whatsnew/3.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/3.0.rst:7
msgid "Guido van Rossum"
msgstr "Guido van Rossum"

#: ../../whatsnew/3.0.rst:54
msgid ""
"This article explains the new features in Python 3.0, compared to 2.6. "
"Python 3.0, also known as \"Python 3000\" or \"Py3K\", is the first ever "
"*intentionally backwards incompatible* Python release. Python 3.0 was "
"released on December 3, 2008. There are more changes than in a typical "
"release, and more that are important for all Python users. Nevertheless, "
"after digesting the changes, you'll find that Python really hasn't changed "
"all that much -- by and large, we're mostly fixing well-known annoyances and"
" warts, and removing a lot of old cruft."
msgstr ""
"本文介绍 Python 3.0 与 2.6 相比的新特性。 Python 3.0 也被称为 \"Python 3000\" 或 "
"\"Py3K\"，是有史以来第一个 *有意向下不兼容* 的 Python 版本。 Python 3.0 于 2008 年 12 月 3 日发布。 "
"与一般的发布版本相比，Python 3.0 有更多的变化，而且对所有 Python 用户都很重要。 不过，在理解了这些改动之后，您会发现 Python "
"其实并没有太大的变化 -- 总的来说，我们主要是修复了一些众所周知的问题和缺陷，并删除了许多旧的垃圾。"

#: ../../whatsnew/3.0.rst:63
msgid ""
"This article doesn't attempt to provide a complete specification of all new "
"features, but instead tries to give a convenient overview. For full details,"
" you should refer to the documentation for Python 3.0, and/or the many PEPs "
"referenced in the text. If you want to understand the complete "
"implementation and design rationale for a particular feature, PEPs usually "
"have more details than the regular documentation; but note that PEPs usually"
" are not kept up-to-date once a feature has been fully implemented."
msgstr ""
"本文并不试图提供所有新特性的完整规范，而是试图提供一个方便的概述。 要了解完整的细节，您应该参考 Python 3.0 的文档和/或文中引用的许多 "
"PEP。 如果您想了解某个特性的完整实现和设计原理，PEP 通常比常规文档有更多的细节；但要注意的是，一旦某个特性被完全实现，PEP 通常不会保持更新。"

#: ../../whatsnew/3.0.rst:72
msgid ""
"Due to time constraints this document is not as complete as it should have "
"been.  As always for a new release, the ``Misc/NEWS`` file in the source "
"distribution contains a wealth of detailed information about every small "
"thing that was changed."
msgstr ""
"由于时间有限，本文档不够完整。 对于新发布的版本，源代码发行版中的 ``Misc/NEWS`` 文件总是包含大量关于每一个细小改动的详细信息。"

#: ../../whatsnew/3.0.rst:89
msgid "Common Stumbling Blocks"
msgstr "常见的绊脚石"

#: ../../whatsnew/3.0.rst:91
msgid ""
"This section lists those few changes that are most likely to trip you up if "
"you're used to Python 2.5."
msgstr "本节列出了在你已习惯了 Python 2.5 的情况下最有可能让您感到困惑的几处更改。"

#: ../../whatsnew/3.0.rst:95
msgid "Print Is A Function"
msgstr "Print 是函数"

#: ../../whatsnew/3.0.rst:97
msgid ""
"The ``print`` statement has been replaced with a :func:`print` function, "
"with keyword arguments to replace most of the special syntax of the old "
"``print`` statement (:pep:`3105`).  Examples::"
msgstr ""
"``print`` 语句已被 :func:`print` 函数取代，其关键字参数取代了旧 ``print`` 语句 (:pep:`3105`) "
"的大部分特殊语法。 示例::"

#: ../../whatsnew/3.0.rst:101
msgid ""
"Old: print \"The answer is\", 2*2\n"
"New: print(\"The answer is\", 2*2)\n"
"\n"
"Old: print x,           # Trailing comma suppresses newline\n"
"New: print(x, end=\" \")  # Appends a space instead of a newline\n"
"\n"
"Old: print              # Prints a newline\n"
"New: print()            # You must call the function!\n"
"\n"
"Old: print >>sys.stderr, \"fatal error\"\n"
"New: print(\"fatal error\", file=sys.stderr)\n"
"\n"
"Old: print (x, y)       # prints repr((x, y))\n"
"New: print((x, y))      # Not the same as print(x, y)!"
msgstr ""
"旧: print \"The answer is\", 2*2\n"
"新: print(\"The answer is\", 2*2)\n"
"\n"
"旧: print x,           # 末尾逗号将抑制换行符\n"
"新: print(x, end=\" \")  # 添加一个空格代替换行符\n"
"\n"
"旧: print              # 打印一个换行符\n"
"新: print()            # 你必须调用函数！\n"
"\n"
"旧: print >>sys.stderr, \"fatal error\"\n"
"新: print(\"fatal error\", file=sys.stderr)\n"
"\n"
"旧: print (x, y)       # 打印 repr((x, y))\n"
"新: print((x, y))      # 不同于 print(x, y)！"

#: ../../whatsnew/3.0.rst:116
msgid "You can also customize the separator between items, e.g.::"
msgstr "你还可以自定义条目间的分隔符，例如 ::"

#: ../../whatsnew/3.0.rst:118
msgid "print(\"There are <\", 2**32, \"> possibilities!\", sep=\"\")"
msgstr "print(\"There are <\", 2**32, \"> possibilities!\", sep=\"\")"

#: ../../whatsnew/3.0.rst:120
msgid "which produces:"
msgstr "这将产生如下结果:"

#: ../../whatsnew/3.0.rst:122
msgid "There are <4294967296> possibilities!"
msgstr "There are <4294967296> possibilities!"

#: ../../whatsnew/3.0.rst:126
msgid "Note:"
msgstr "注意"

#: ../../whatsnew/3.0.rst:128
msgid ""
"The :func:`print` function doesn't support the \"softspace\" feature of the "
"old ``print`` statement.  For example, in Python 2.x, ``print \"A\\n\", "
"\"B\"`` would write ``\"A\\nB\\n\"``; but in Python 3.0, ``print(\"A\\n\", "
"\"B\")`` writes ``\"A\\n B\\n\"``."
msgstr ""
":func:`print` 函数不支持旧 ``print`` 语句的 \"softspace\" 功能。例如，在 Python 2.x "
"中，``print \"A\\n\", \"B\"`` 会写入 ``\"A\\nB\\n\"``；但在 Python 3.0 "
"中，``print(\"A\\n\", \"B\")`` 会写入 ``\"A\\n B\\n\"``。"

#: ../../whatsnew/3.0.rst:133
msgid ""
"Initially, you'll be finding yourself typing the old ``print x`` a lot in "
"interactive mode.  Time to retrain your fingers to type ``print(x)`` "
"instead!"
msgstr "最初，您会发现自己在交互模式下经常输入旧的 ``print x`` 。是时候重新训练你的手指以输入 ``print(x)`` 了！"

#: ../../whatsnew/3.0.rst:137
msgid ""
"When using the ``2to3`` source-to-source conversion tool, all ``print`` "
"statements are automatically converted to :func:`print` function calls, so "
"this is mostly a non-issue for larger projects."
msgstr ""
"使用 ``2to3`` 源代码到源代码转换工具时，所有 ``print`` 语句都会自动转换为 :func:`print` "
"函数调用，因此对于大型项目来说，这基本上不是问题。"

#: ../../whatsnew/3.0.rst:143
msgid "Views And Iterators Instead Of Lists"
msgstr "用视图和迭代器取代列表"

#: ../../whatsnew/3.0.rst:145
msgid "Some well-known APIs no longer return lists:"
msgstr "某些知名的 API 将不再返回列表:"

#: ../../whatsnew/3.0.rst:147
msgid ""
":class:`dict` methods :meth:`dict.keys`, :meth:`dict.items` and "
":meth:`dict.values` return \"views\" instead of lists.  For example, this no"
" longer works: ``k = d.keys(); k.sort()``.  Use ``k = sorted(d)`` instead "
"(this works in Python 2.5 too and is just as efficient)."
msgstr ""
":class:`dict` 方法 :meth:`dict.keys`、:meth:`dict.items` 和 :meth:`dict.values` "
"返回 “视图” 而不是列表。 例如，这个写法不再有效: ``k = d.keys(); k.sort()``。 请使用 ``k = "
"sorted(d)`` 代替（这在 Python 2.5 中也有效，而且同样高效）。"

#: ../../whatsnew/3.0.rst:153
msgid ""
"Also, the :meth:`!dict.iterkeys`, :meth:`!dict.iteritems` and "
":meth:`!dict.itervalues` methods are no longer supported."
msgstr ""
"此外，:meth:`!dict.iterkeys`, :meth:`!dict.iteritems` 和 "
":meth:`!dict.itervalues` 等方法将不再被支持。"

#: ../../whatsnew/3.0.rst:156
msgid ""
":func:`map` and :func:`filter` return iterators.  If you really need a list "
"and the input sequences are all of equal length, a quick fix is to wrap "
":func:`map` in :func:`list`, e.g. ``list(map(...))``, but a better fix is "
"often to use a list comprehension (especially when the original code uses "
":keyword:`lambda`), or rewriting the code so it doesn't need a list at all."
"  Particularly tricky is :func:`map` invoked for the side effects of the "
"function; the correct transformation is to use a regular :keyword:`for` loop"
" (since creating a list would just be wasteful)."
msgstr ""
":func:`map` 和 :func:`filter` 均返回迭代器。 如果你确实需要一个列表并且所有输入序列的长度相等，简单的解决办法是将 "
":func:`map` 包装在 :func:`list` 中，例如 "
"``list(map(...))``，但更好的办法通常是使用列表推导式（特别是当原始代码使用了 :keyword:`lambda` "
"的时候），或是重写代码使得它完全不需要列表。 还有一种特殊技巧是将 :func:`map` 作为函数的附带影响被唤起；正确的转换方式是使用一个常规的 "
":keyword:`for` 循环（因为创建列表会浪费资源）。"

#: ../../whatsnew/3.0.rst:167
msgid ""
"If the input sequences are not of equal length, :func:`map` will stop at the"
" termination of the shortest of the sequences. For full compatibility with "
":func:`map` from Python 2.x, also wrap the sequences in "
":func:`itertools.zip_longest`, e.g. ``map(func, *sequences)`` becomes "
"``list(map(func, itertools.zip_longest(*sequences)))``."
msgstr ""
"如果输入序列的长度不相等，:func:`map` 将在最短序列的终点停止。 为了与 Python 2.x 中的 :func:`map` "
"完全兼容，也可将序列包装在 :func:`itertools.zip_longest` 中，例如将 ``map(func, *sequences)`` "
"变成 ``list(map(func, itertools.zip_longest(*sequences)))``。"

#: ../../whatsnew/3.0.rst:173
msgid ""
":func:`range` now behaves like :func:`!xrange` used to behave, except it "
"works with values of arbitrary size.  The latter no longer exists."
msgstr ""
"现在 :func:`range` 的行为与过去 :func:`!xrange` 的行为类似，区别在于它能处理任意大小的值。 后者已不复存在。"

#: ../../whatsnew/3.0.rst:177
msgid ":func:`zip` now returns an iterator."
msgstr ":func:`zip` 现在将返回一个迭代器。"

#: ../../whatsnew/3.0.rst:180
msgid "Ordering Comparisons"
msgstr "排序比较"

#: ../../whatsnew/3.0.rst:182
msgid "Python 3.0 has simplified the rules for ordering comparisons:"
msgstr "Python 3.0 简化了排序比较的规则："

#: ../../whatsnew/3.0.rst:184
msgid ""
"The ordering comparison operators (``<``, ``<=``, ``>=``, ``>``) raise a "
"TypeError exception when the operands don't have a meaningful natural "
"ordering.  Thus, expressions like ``1 < ''``, ``0 > None`` or ``len <= len``"
" are no longer valid, and e.g. ``None < None`` raises :exc:`TypeError` "
"instead of returning ``False``.  A corollary is that sorting a heterogeneous"
" list no longer makes sense -- all the elements must be comparable to each "
"other.  Note that this does not apply to the ``==`` and ``!=`` operators: "
"objects of different incomparable types always compare unequal to each "
"other."
msgstr ""
"当操作数不存在有意义的自然排序时，排序比较操作符 (``<``, ``<=``, ``>=``, ``>``) 会引发 TypeError 异常。 "
"因此，像 ``1 < ''``, ``0 > None`` 或 ``len <= len`` 这样的表达式不再有效，例如 ``None < None``"
" 会引发 :exc:`TypeError` 而不是返回 ``False``。 由此推论，对异构列表进行排序不再有意义 —— 所有元素必须相互可比。 "
"请注意，这不适用于 ``==`` 和 ``!=`` 操作符：不同的不可比类型的对象总是互不相等的。"

#: ../../whatsnew/3.0.rst:195
msgid ""
":meth:`sorted` and :meth:`list.sort` no longer accept the *cmp* argument "
"providing a comparison function.  Use the *key* argument instead. N.B. the "
"*key* and *reverse* arguments are now \"keyword-only\"."
msgstr ""
":meth:`sorted` 和 :meth:`list.sort` 不再接受提供比较函数的 *cmp* 参数。 请改用 *key* 参数。 注意 "
"*key* 和 *reverse* 参数现在都是“仅限关键字”参数。"

#: ../../whatsnew/3.0.rst:200
msgid ""
"The :func:`!cmp` function should be treated as gone, and the "
":meth:`!__cmp__` special method is no longer supported.  Use "
":meth:`~object.__lt__` for sorting, :meth:`~object.__eq__` with "
":meth:`~object.__hash__`, and other rich comparisons as needed. (If you "
"really need the :func:`!cmp` functionality, you could use the expression "
"``(a > b) - (a < b)`` as the equivalent for ``cmp(a, b)``.)"
msgstr ""
":func:`!cmp` 函数应视为已不复存在，而 :meth:`!__cmp__` 特殊方法再不再受支持。 请使用 "
":meth:`~object.__lt__` 进行排序，并根据需要使用 :meth:`~object.__eq__` 与 "
":meth:`~object.__hash__`，以及其他富比较操作。 （如果你确实需要 :func:`!cmp` 的功能，你可以使用表达式 ``(a "
"> b) - (a < b)`` 作为 ``cmp(a, b)`` 的等价形式。）"

#: ../../whatsnew/3.0.rst:207
msgid "Integers"
msgstr "整数"

#: ../../whatsnew/3.0.rst:209
msgid ""
":pep:`237`: Essentially, :class:`!long` renamed to :class:`int`. That is, "
"there is only one built-in integral type, named :class:`int`; but it behaves"
" mostly like the old :class:`!long` type."
msgstr ""
":pep:`237`: 在实质上，:class:`!long` 已改名为 :class:`int`。 也就是说，只存在一种内置整数类型，即 "
":class:`int`；但其行为与旧的 :class:`!long` 类型极其相似。"

#: ../../whatsnew/3.0.rst:213
msgid ""
":pep:`238`: An expression like ``1/2`` returns a float.  Use ``1//2`` to get"
" the truncating behavior.  (The latter syntax has existed for years, at "
"least since Python 2.2.)"
msgstr ""
":pep:`238`: 像 ``1/2`` 这样的表达式将返回一个浮点数。 请使用 ``1//2`` 来得到取整的行为。 "
"（后面这种语法已存在多年，至少从 Python 2.2 起就有了。）"

#: ../../whatsnew/3.0.rst:217
msgid ""
"The :data:`!sys.maxint` constant was removed, since there is no longer a "
"limit to the value of integers.  However, :data:`sys.maxsize` can be used as"
" an integer larger than any practical list or string index.  It conforms to "
"the implementation's \"natural\" integer size and is typically the same as "
":data:`!sys.maxint` in previous releases on the same platform (assuming the "
"same build options)."
msgstr ""
":data:`!sys.maxint` 常量已被移除，因为整数的值不再有任何限制。 不过，:data:`sys.maxsize` "
"也可被用作大于任何实际列表或字符串索引的整数。 它与具体实现的“自然”整数大小保持一致并且通常与同一平台上之前发布版中的 "
":data:`!sys.maxint` 相同（假定使用相同的构建选项）。"

#: ../../whatsnew/3.0.rst:224
msgid ""
"The :func:`repr` of a long integer doesn't include the trailing ``L`` "
"anymore, so code that unconditionally strips that character will chop off "
"the last digit instead.  (Use :func:`str` instead.)"
msgstr ""
"长整数的 :func:`repr` 不再包括尾部的 ``L``，因此无条件地删除该字符的代码会删除最后一位数字。 （请使用 :func:`str` "
"代替。）"

#: ../../whatsnew/3.0.rst:228
msgid ""
"Octal literals are no longer of the form ``0720``; use ``0o720`` instead."
msgstr "八进制数字面值不再是 ``0720`` 的形式；而是改用 ``0o720`` 的形式。"

#: ../../whatsnew/3.0.rst:232
msgid "Text Vs. Data Instead Of Unicode Vs. 8-bit"
msgstr "文本与数据而不是 Unicode 与 8 比特位"

#: ../../whatsnew/3.0.rst:234
msgid ""
"Everything you thought you knew about binary data and Unicode has changed."
msgstr "你对二进制数据和 Unicode 的所有认知都已改变。"

#: ../../whatsnew/3.0.rst:237
msgid ""
"Python 3.0 uses the concepts of *text* and (binary) *data* instead of "
"Unicode strings and 8-bit strings.  All text is Unicode; however *encoded* "
"Unicode is represented as binary data.  The type used to hold text is "
":class:`str`, the type used to hold data is :class:`bytes`.  The biggest "
"difference with the 2.x situation is that any attempt to mix text and data "
"in Python 3.0 raises :exc:`TypeError`, whereas if you were to mix Unicode "
"and 8-bit strings in Python 2.x, it would work if the 8-bit string happened "
"to contain only 7-bit (ASCII) bytes, but you would get "
":exc:`UnicodeDecodeError` if it contained non-ASCII values.  This value-"
"specific behavior has caused numerous sad faces over the years."
msgstr ""
"Python 3.0 使用 *文本* 和 (二进制) *数据* 等概念来替代 Unicode 字符串和 8 位字符串。 所有文本均使用 "
"Unicode；不过 *已编码* Unicode 是以二进制数据来表示的。 用于存放文本的类型是 :class:`str`，用于存放数据的类型是 "
":class:`bytes`。 与 2.x 场景的最大区别是在 Python 3.0 中任何混用文本和数据的尝试都将引发 "
":exc:`TypeError`，而当你在 Python 2.x 中混用 Unicode 和 8 位字符串时，如果 8 位字符串恰好仅包含 7 位 "
"(ASCII) 字节数据那就没有问题，但是如果包含非 ASCII 值则将引发 :exc:`UnicodeDecodeError`。 "
"这种依赖于特定值的行为多年来造成了无数的苦恼。"

#: ../../whatsnew/3.0.rst:250
msgid ""
"As a consequence of this change in philosophy, pretty much all code that "
"uses Unicode, encodings or binary data most likely has to change.  The "
"change is for the better, as in the 2.x world there were numerous bugs "
"having to do with mixing encoded and unencoded text.  To be prepared in "
"Python 2.x, start using :class:`!unicode` for all unencoded text, and "
":class:`str` for binary or encoded data only.  Then the ``2to3`` tool will "
"do most of the work for you."
msgstr ""
"作为此项设计哲学方面的修改造成的影响，几乎所有使用 Unicode、编码格式或二进制数据的代码都很有可能必须被修改。 这项改变是有益的，因为在 2.x "
"世界中存在着无数涉及混用已编码和未编码文本的程序缺陷。 要在 Python 2.x 中做好准备，请使用 :class:`!unicode` "
"表示所有未编码文本，只对二进制或已编码数据使用 :class:`str`。 这样 ``2to3`` 工具将为你完成大部分工作。"

#: ../../whatsnew/3.0.rst:258
msgid ""
"You can no longer use ``u\"...\"`` literals for Unicode text. However, you "
"must use ``b\"...\"`` literals for binary data."
msgstr "你不能再使用 ``u\"...\"`` 字面值来表示 Unicode 文本。 不过，你必须使用 ``b\"...\"`` 字面值来表示二进制数据。"

#: ../../whatsnew/3.0.rst:261
msgid ""
"As the :class:`str` and :class:`bytes` types cannot be mixed, you must "
"always explicitly convert between them.  Use :meth:`str.encode` to go from "
":class:`str` to :class:`bytes`, and :meth:`bytes.decode` to go from "
":class:`bytes` to :class:`str`.  You can also use ``bytes(s, encoding=...)``"
" and ``str(b, encoding=...)``, respectively."
msgstr ""
"由于 :class:`str` 和 :class:`bytes` 类型无法混用，你必须始终在它们之间执行显式转换。 使用 "
":meth:`str.encode` 将 :class:`str` 转为 :class:`bytes`，并使用 :meth:`bytes.decode`"
" 将 :class:`bytes` 转为 :class:`str`。 你也可以分别使用 ``bytes(s, encoding=...)`` 和 "
"``str(b, encoding=...)``。"

#: ../../whatsnew/3.0.rst:268
msgid ""
"Like :class:`str`, the :class:`bytes` type is immutable.  There is a "
"separate *mutable* type to hold buffered binary data, :class:`bytearray`.  "
"Nearly all APIs that accept :class:`bytes` also accept :class:`bytearray`.  "
"The mutable API is based on :class:`collections.MutableSequence "
"<collections.abc.MutableSequence>`."
msgstr ""
"与 :class:`str` 一样，:class:`bytes` 类型是不可变的。 还有一个单独的 *可变* 类型用于保存带缓冲的二进制数据，即 "
":class:`bytearray`。 几乎所有接受 :class:`bytes` 的 API 也都接受 :class:`bytearray`。 "
"这个可变 API 是基于 :class:`collections.MutableSequence "
"<collections.abc.MutableSequence>`。"

#: ../../whatsnew/3.0.rst:274
msgid ""
"All backslashes in raw string literals are interpreted literally. This means"
" that ``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated "
"specially.  For example, ``r'\\u20ac'`` is a string of 6 characters in "
"Python 3.0, whereas in 2.6, ``ur'\\u20ac'`` was the single \"euro\" "
"character.  (Of course, this change only affects raw string literals; the "
"euro character is ``'\\u20ac'`` in Python 3.0.)"
msgstr ""
"原始字符串字面中的所有反斜线均按字面解释。 这意味着原始字符串中的 ``'\\U'`` 和 ``'\\u'`` 转义符不会被特殊处理。 例如，在 "
"Python 3.0 中，``r'\\u20ac'`` 是一个包含 6 个字符的字符串，而在 2.6 中，``ur'\\u20ac'`` 是一个 "
"“欧元” 字符。 （当然，这种变化只影响原始字符串的字面意义；在 Python 3.0 中，欧元字符是 ``'\\u20ac'``。）"

#: ../../whatsnew/3.0.rst:281
msgid ""
"The built-in :class:`!basestring` abstract type was removed.  Use "
":class:`str` instead.  The :class:`str` and :class:`bytes` types don't have "
"functionality enough in common to warrant a shared base class.  The ``2to3``"
" tool (see below) replaces every occurrence of :class:`!basestring` with "
":class:`str`."
msgstr ""
"内置的 :class:`!basestring` 抽象类型已被移除。 请改用 :class:`str`。 :class:`str` 和 "
":class:`bytes` 类型在功能上没有足够的共通性因此不需要有共享的基类。 ``2to3`` 工具（见下文）会将所有 "
":class:`!basestring` 都替换为 :class:`str`。"

#: ../../whatsnew/3.0.rst:287
msgid ""
"Files opened as text files (still the default mode for :func:`open`) always "
"use an encoding to map between strings (in memory) and bytes (on disk).  "
"Binary files (opened with a ``b`` in the mode argument) always use bytes in "
"memory.  This means that if a file is opened using an incorrect mode or "
"encoding, I/O will likely fail loudly, instead of silently producing "
"incorrect data.  It also means that even Unix users will have to specify the"
" correct mode (text or binary) when opening a file.  There is a platform-"
"dependent default encoding, which on Unixy platforms can be set with the "
"``LANG`` environment variable (and sometimes also with some other platform-"
"specific locale-related environment variables).  In many cases, but not all,"
" the system default is UTF-8; you should never count on this default.  Any "
"application reading or writing more than pure ASCII text should probably "
"have a way to override the encoding. There is no longer any need for using "
"the encoding-aware streams in the :mod:`codecs` module."
msgstr ""
"作为文本文件打开的文件（仍然是 :func:`open` 的默认模式）总是会使用一个编码格式在（内存中的）字符串和（磁盘中的）字节串之间建立映射。 "
"二进制文件（将 mode 参数设为 ``b`` 来打开）在内存中总是会使用数字串。 这意味着如果一个文件是使用不正确的模式或编码格式打开的，I/O "
"操作很可能会报告失败，而不是静默地产生不正确的数据。 这也意味着即使是 Unix 用户在打开文件时也必须指定正确的模式（文本或二进制）。 "
"存在一个依赖于具体平台的默认编码格式，在类 Unix 平台上可以通过 ``LANG`` "
"环境变量来设置（有时也会使用其他一些平台专属的语言区域相关的环境变量）。 在多数情况下，系统默认使用 "
"UTF-8，但并非全都如此；你绝不应该依赖这个默认值。 任何读写超出纯 ASCII 文本范围的内容的应用程序都应该提供重写编码格式的选项。 "
"现在已不再需要使用 :mod:`codecs` 模块中可感知编码格式的流。"

#: ../../whatsnew/3.0.rst:304
msgid ""
"The initial values of :data:`sys.stdin`, :data:`sys.stdout` and "
":data:`sys.stderr` are now unicode-only text files (i.e., they are instances"
" of :class:`io.TextIOBase`).  To read and write bytes data with these "
"streams, you need to use their :data:`io.TextIOBase.buffer` attribute."
msgstr ""
":data:`sys.stdin`、:data:`sys.stdout` 和 :data:`sys.stderr` 的初始值现在是仅 Unicode "
"的文本文件（即它们是 :class:`io.TextIOBase` 的实例）。 要使用这些数据流读写字节数据，需要使用它们的 "
":data:`io.TextIOBase.buffer` 属性。"

#: ../../whatsnew/3.0.rst:310
msgid ""
"Filenames are passed to and returned from APIs as (Unicode) strings. This "
"can present platform-specific problems because on some platforms filenames "
"are arbitrary byte strings.  (On the other hand, on Windows filenames are "
"natively stored as Unicode.)  As a work-around, most APIs (e.g. :func:`open`"
" and many functions in the :mod:`os` module) that take filenames accept "
":class:`bytes` objects as well as strings, and a few APIs have a way to ask "
"for a :class:`bytes` return value.  Thus, :func:`os.listdir` returns a list "
"of :class:`bytes` instances if the argument is a :class:`bytes` instance, "
"and :func:`os.getcwdb` returns the current working directory as a "
":class:`bytes` instance.  Note that when :func:`os.listdir` returns a list "
"of strings, filenames that cannot be decoded properly are omitted rather "
"than raising :exc:`UnicodeError`."
msgstr ""
"文件名是以（Unicode）字符串的形式传给 API 并返回的。 这可能产生特定平台专属的问题因为在某些平台上文件名强制使用字节串。 （另一方面，在 "
"Windows 上文件名则原生存储为 Unicode。） 为绕过此问题，多数接受文件名的 API（例如 :func:`open` 和 :mod:`os`"
" 模块中的许多函数）都同时接受 :class:`bytes` 对象和字符串，而少数 API 会发出要求 :class:`bytes` 返回值的提示。 "
"因而，当参数为 :class:`bytes` 的实例时 :func:`os.listdir` 会返回由 :class:`bytes` "
"实例组成的列表，:func:`os.getcwdb` 则会将当前工作目录作为 :class:`bytes` 实例返回。 请注意当 "
":func:`os.listdir` 返回字符串的列表时，无法被正确解码的文件名会被忽略而不是引发 :exc:`UnicodeError`。"

#: ../../whatsnew/3.0.rst:325
msgid ""
"Some system APIs like :data:`os.environ` and :data:`sys.argv` can also "
"present problems when the bytes made available by the system is not "
"interpretable using the default encoding.  Setting the ``LANG`` variable and"
" rerunning the program is probably the best approach."
msgstr ""
"当系统提供的字节无法使用默认编码进行解释时，一些系统 API，如 :data:`os.environ` 和 "
":data:`sys.argv`，也会出现问题。 最好的办法可能是设置 ``LANG`` 变量并重新运行程序。"

#: ../../whatsnew/3.0.rst:330
msgid ""
":pep:`3138`: The :func:`repr` of a string no longer escapes non-ASCII "
"characters.  It still escapes control characters and code points with non-"
"printable status in the Unicode standard, however."
msgstr ""
":pep:`3138`: 字符串的 :func:`repr` 将不再转义非 ASCII 字符。 不过，它仍然会转义控制字符和在 Unicode "
"标准中具有不可打印状态的码位。"

#: ../../whatsnew/3.0.rst:334
msgid ":pep:`3120`: The default source encoding is now UTF-8."
msgstr ":pep:`3120`：现在默认的源码编码格式是UTF-8。"

#: ../../whatsnew/3.0.rst:336
msgid ""
":pep:`3131`: Non-ASCII letters are now allowed in identifiers. (However, the"
" standard library remains ASCII-only with the exception of contributor names"
" in comments.)"
msgstr ""
":pep:`3131`: 现在允许在标识符中使用非 ASCII 字符（不过，标准库中的异常和注释中的贡献者名字仍然只使用 ASCII 字符）。"

#: ../../whatsnew/3.0.rst:340
msgid ""
"The :mod:`!StringIO` and :mod:`!cStringIO` modules are gone.  Instead, "
"import the :mod:`io` module and use :class:`io.StringIO` or "
":class:`io.BytesIO` for text and data respectively."
msgstr ""
":mod:`!StringIO` 和 :mod:`!cStringIO` 模块已被去除。 作为替代，请导入 :mod:`io` "
"模块并分别为文本和数据使用 :class:`io.StringIO` 或 :class:`io.BytesIO`。"

#: ../../whatsnew/3.0.rst:344
msgid "See also the :ref:`unicode-howto`, which was updated for Python 3.0."
msgstr "另请参阅 :ref:`unicode-howto`，其内容已针对 Python 3.0 进行更新。"

#: ../../whatsnew/3.0.rst:348
msgid "Overview Of Syntax Changes"
msgstr "语法变化概述"

#: ../../whatsnew/3.0.rst:350
msgid ""
"This section gives a brief overview of every *syntactic* change in Python "
"3.0."
msgstr "本节提供了 Python 3.0 中每个 *语法* 变化的简要说明。"

#: ../../whatsnew/3.0.rst:354
msgid "New Syntax"
msgstr "新语法"

#: ../../whatsnew/3.0.rst:356
msgid ""
":pep:`3107`: Function argument and return value annotations.  This provides "
"a standardized way of annotating a function's parameters and return value.  "
"There are no semantics attached to such annotations except that they can be "
"introspected at runtime using the :attr:`!__annotations__` attribute.  The "
"intent is to encourage experimentation through metaclasses, decorators or "
"frameworks."
msgstr ""
":pep:`3107`: 函数参数和返回值标注。 这提供了一种标注函数形参和返回值的标准方式。 并没有与这种标注相关联的特殊语法而只是可以使用 "
":attr:`!__annotations__` 属性在运行时对它们进行内省。 其目的是鼓励在元类、装饰器和框架中尝试应用标注。"

#: ../../whatsnew/3.0.rst:363
msgid ""
":pep:`3102`: Keyword-only arguments.  Named parameters occurring after "
"``*args`` in the parameter list *must* be specified using keyword syntax in "
"the call.  You can also use a bare ``*`` in the parameter list to indicate "
"that you don't accept a variable-length argument list, but you do have "
"keyword-only arguments."
msgstr ""
":pep:`3102`：仅限关键字参数。在参数列表``*args`` 之后出现的命名参数 *必须* "
"在调用中使用关键字语法指定。也可以在参数列表中使用``*``来表示不接受长度可变的参数列表，但可以使用只包含关键字的参数。"

#: ../../whatsnew/3.0.rst:369
msgid ""
"Keyword arguments are allowed after the list of base classes in a class "
"definition.  This is used by the new convention for specifying a metaclass "
"(see next section), but can be used for other purposes as well, as long as "
"the metaclass supports it."
msgstr "类定义中的基类列表后允许使用关键字参数。  这是用于指定元类的新约定（见下一节），但也可用于其他目的，只要元类支持它。"

#: ../../whatsnew/3.0.rst:374
msgid ""
":pep:`3104`: :keyword:`nonlocal` statement.  Using ``nonlocal x`` you can "
"now assign directly to a variable in an outer (but non-global) scope.  "
":keyword:`!nonlocal` is a new reserved word."
msgstr ""
":pep:`3104`: :keyword:`nonlocal` 语句。 现在你可以使用 ``nonlocal x`` "
"来允许直接赋值到一个外层（但非全局）作用域。 :keyword:`!nonlocal` 是新的保留字。"

#: ../../whatsnew/3.0.rst:378
msgid ""
":pep:`3132`: Extended Iterable Unpacking.  You can now write things like "
"``a, b, *rest = some_sequence``.  And even ``*rest, a = stuff``.  The "
"``rest`` object is always a (possibly empty) list; the right-hand side may "
"be any iterable.  Example::"
msgstr ""
":pep:`3132`: 扩展可迭代对象解包。 你现在可以编写像 ``a, b, *rest = some_sequence`` 这样的代码。 甚至 "
"``*rest, a = stuff``。 ``rest`` 对象将总是为一个（可能为空的）列表；右侧的对象可以是任意可迭代对象。 例如::"

#: ../../whatsnew/3.0.rst:383
msgid "(a, *rest, b) = range(5)"
msgstr "(a, *rest, b) = range(5)"

#: ../../whatsnew/3.0.rst:385
msgid "This sets *a* to ``0``, *b* to ``4``, and *rest* to ``[1, 2, 3]``."
msgstr "这会将 *a* 设为 ``0``，*b* 设为 ``4``，而将 *rest* 设为 ``[1, 2, 3]``。"

#: ../../whatsnew/3.0.rst:387
msgid ""
"Dictionary comprehensions: ``{k: v for k, v in stuff}`` means the same thing"
" as ``dict(stuff)`` but is more flexible.  (This is :pep:`274` vindicated. "
":-)"
msgstr ""
"新增字典推导式: ``{k: v for k, v in stuff}`` 的含义与 ``dict(stuff)`` 相同但是更为灵活。 "
"(对此特性的解释见 :pep:`274`。 :-)"

#: ../../whatsnew/3.0.rst:391
msgid ""
"Set literals, e.g. ``{1, 2}``.  Note that ``{}`` is an empty dictionary; use"
" ``set()`` for an empty set.  Set comprehensions are also supported; e.g., "
"``{x for x in stuff}`` means the same thing as ``set(stuff)`` but is more "
"flexible."
msgstr ""
"新增集合字面值，例如 ``{1, 2}``。 请注意 ``{}`` 是空字典；要用 ``set()`` 表示空集合。 集合推导式也受到支持；例如 "
"``{x for x in stuff}`` 的含义与 ``set(stuff)`` 相同但是更为灵活。"

#: ../../whatsnew/3.0.rst:396
msgid ""
"New octal literals, e.g. ``0o720`` (already in 2.6).  The old octal literals"
" (``0720``) are gone."
msgstr "新增八进制字面值，例如 ``0o720`` (已存在于 2.6 中)。 旧的八进制字面值 (``0720``) 已不复存在。"

#: ../../whatsnew/3.0.rst:399
msgid ""
"New binary literals, e.g. ``0b1010`` (already in 2.6), and there is a new "
"corresponding built-in function, :func:`bin`."
msgstr "新增二进制字面值，例如 ``0b1010`` (已存在于 2.6 中)，还有对应的新增内置函数 :func:`bin`。"

#: ../../whatsnew/3.0.rst:402
msgid ""
"Bytes literals are introduced with a leading ``b`` or ``B``, and there is a "
"new corresponding built-in function, :func:`bytes`."
msgstr "引入了带有 ``b`` 或 ``B`` 前缀的字节串字面值，还有对应的新增内置函数 :func:`bytes`。"

#: ../../whatsnew/3.0.rst:406
msgid "Changed Syntax"
msgstr "语法变化"

#: ../../whatsnew/3.0.rst:408
msgid ""
":pep:`3109` and :pep:`3134`: new :keyword:`raise` statement syntax: "
":samp:`raise [{expr} [from {expr}]]`.  See below."
msgstr ""
":pep:`3109` 和 :pep:`3134`: 新增 :keyword:`raise` 语句的语法: :samp:`raise [{expr} "
"[from {expr}]]`。 见下文。"

#: ../../whatsnew/3.0.rst:411
msgid ""
":keyword:`!as` and :keyword:`with` are now reserved words.  (Since 2.6, "
"actually.)"
msgstr "现在 :keyword:`!as` 和 :keyword:`with` 是保留关键字。 （实际是从 2.6 开始。）"

#: ../../whatsnew/3.0.rst:414
msgid ""
"``True``, ``False``, and ``None`` are reserved words.  (2.6 partially "
"enforced the restrictions on ``None`` already.)"
msgstr "``True``, ``False`` 和 ``None`` 已成为保留关键字。 （2.6 已经对 ``None`` 部分强制应用限制。）"

#: ../../whatsnew/3.0.rst:417
msgid ""
"Change from :keyword:`except` *exc*, *var* to :keyword:`!except` *exc* "
":keyword:`!as` *var*.  See :pep:`3110`."
msgstr ""
"将 :keyword:`except` *exc*, *var* 改为 :keyword:`!except` *exc* :keyword:`!as` "
"*var*。 参见 :pep:`3110`。"

#: ../../whatsnew/3.0.rst:420
msgid ":pep:`3115`: New Metaclass Syntax.  Instead of::"
msgstr ":pep:`3115`: 新的元类语法。 替换::"

#: ../../whatsnew/3.0.rst:422
msgid ""
"class C:\n"
"    __metaclass__ = M\n"
"    ..."
msgstr ""
"class C:\n"
"    __metaclass__ = M\n"
"    ..."

#: ../../whatsnew/3.0.rst:426
msgid "you must now use::"
msgstr "你现在需要使用::"

#: ../../whatsnew/3.0.rst:428
msgid ""
"class C(metaclass=M):\n"
"    ..."
msgstr ""
"class C(metaclass=M):\n"
"    ..."

#: ../../whatsnew/3.0.rst:431
msgid ""
"The module-global :data:`!__metaclass__` variable is no longer supported.  "
"(It was a crutch to make it easier to default to new-style classes without "
"deriving every class from :class:`object`.)"
msgstr ""
"模块级全局变量 :data:`!__metaclass__` 已不再受支持。 （它是一个令默认使用新式类而无需从 :class:`object` "
"派生每一个类的辅助工具。）"

#: ../../whatsnew/3.0.rst:436
msgid ""
"List comprehensions no longer support the syntactic form :samp:`[... for "
"{var} in {item1}, {item2}, ...]`.  Use :samp:`[... for {var} in ({item1}, "
"{item2}, ...)]` instead. Also note that list comprehensions have different "
"semantics: they are closer to syntactic sugar for a generator expression "
"inside a :func:`list` constructor, and in particular the loop control "
"variables are no longer leaked into the surrounding scope."
msgstr ""
"列表推导式不再支持 :samp:`[... for {var} in {item1}, {item2}, ...]` 这样的语法形式。 请改用 "
":samp:`[... for {var} in ({item1}, {item2}, ...)]`。 还要注意列表推导式具有不同的句法：它们更像是 "
":func:`list` 构造器内部用于生成器表达式的语法糖，具体来说就是循环控制变量将不会再泄漏到外层作用域中。"

#: ../../whatsnew/3.0.rst:444
msgid ""
"The *ellipsis* (``...``) can be used as an atomic expression anywhere.  "
"(Previously it was only allowed in slices.)  Also, it *must* now be spelled "
"as ``...``.  (Previously it could also be spelled as ``. . .``, by a mere "
"accident of the grammar.)"
msgstr ""
"*ellipsis* (``...``) 可以在任何地方作为原子表达式使用。（以前只允许在片段中使用。）另外，现在 *必须* 拼写为``...`` "
"。（以前也可以拼写为``. . .`` ，这只是一个偶然的语法。）"

#: ../../whatsnew/3.0.rst:450
msgid "Removed Syntax"
msgstr "移除的语法"

#: ../../whatsnew/3.0.rst:452
msgid ""
":pep:`3113`: Tuple parameter unpacking removed.  You can no longer write "
"``def foo(a, (b, c)): ...``. Use ``def foo(a, b_c): b, c = b_c`` instead."
msgstr ""
":pep:`3113`: 元组形参解包已被移除。 你不能再使用 ``def foo(a, (b, c)): ...`` 的写法。 请改用 ``def "
"foo(a, b_c): b, c = b_c``。"

#: ../../whatsnew/3.0.rst:456
msgid "Removed backticks (use :func:`repr` instead)."
msgstr "移除了反引号 (请改用 :func:`repr`)。"

#: ../../whatsnew/3.0.rst:458
msgid "Removed ``<>`` (use ``!=`` instead)."
msgstr "移除了 ``<>`` (请改用 ``!=``)。"

#: ../../whatsnew/3.0.rst:460
msgid ""
"Removed keyword: :func:`exec` is no longer a keyword; it remains as a "
"function.  (Fortunately the function syntax was also accepted in 2.x.)  Also"
" note that :func:`exec` no longer takes a stream argument; instead of "
"``exec(f)`` you can use ``exec(f.read())``."
msgstr ""
"移除的关键字: :func:`exec` 不再是一个关键字；它仍是一个函数。 （幸运的是该函数语法也在 2.x 中被接受。） 还要注意 "
":func:`exec` 将不再接受流作为参数；你可以将原来的 ``exec(f)`` 改为使用 ``exec(f.read())``。"

#: ../../whatsnew/3.0.rst:465
msgid "Integer literals no longer support a trailing ``l`` or ``L``."
msgstr "整数字面值不再支持 ``l`` 或 ``L`` 后缀。"

#: ../../whatsnew/3.0.rst:467
msgid "String literals no longer support a leading ``u`` or ``U``."
msgstr "字符串字面值不再支持 ``u`` 或 ``U`` 前缀。"

#: ../../whatsnew/3.0.rst:469
msgid ""
"The :keyword:`from` *module* :keyword:`import` ``*`` syntax is only allowed "
"at the module level, no longer inside functions."
msgstr ""
":keyword:`from` *module* :keyword:`import` ``*`` 语法仅允许在模块层级使用，不再允许出现于函数内部。"

#: ../../whatsnew/3.0.rst:472
msgid ""
"The only acceptable syntax for relative imports is :samp:`from .[{module}] "
"import {name}`.  All :keyword:`import` forms not starting with ``.`` are "
"interpreted as absolute imports.  (:pep:`328`)"
msgstr ""
"唯一可接受的相对导入语法为 :samp:`from .[{module}] import {name}`。 所有不以 ``.`` 开头的 "
":keyword:`import` 形式都将被解读为绝对导入。 (:pep:`328`)"

#: ../../whatsnew/3.0.rst:476
msgid "Classic classes are gone."
msgstr "经典类已不复存在。"

#: ../../whatsnew/3.0.rst:480
msgid "Changes Already Present In Python 2.6"
msgstr "已存在于 Python 2.6 中的改变"

#: ../../whatsnew/3.0.rst:482
msgid ""
"Since many users presumably make the jump straight from Python 2.5 to Python"
" 3.0, this section reminds the reader of new features that were originally "
"designed for Python 3.0 but that were back-ported to Python 2.6.  The "
"corresponding sections in :ref:`whats-new-in-2.6` should be consulted for "
"longer descriptions."
msgstr ""
"由于许多用户可能会直接从 Python 2.5 跳到 Python 3.0，因此本节提醒读者注意最初为 Python 3.0 设计但后来移植到 "
"Python 2.6 的新特性。 如需更详细的说明请参阅 :ref:`whats-new-in-2.6` 中的相应章节。"

#: ../../whatsnew/3.0.rst:488
msgid ""
":ref:`pep-0343`.  The :keyword:`with` statement is now a standard feature "
"and no longer needs to be imported from the :mod:`__future__`. Also check "
"out :ref:`new-26-context-managers` and :ref:`new-module-contextlib`."
msgstr ""
":ref:`pep-0343`。 现在 :keyword:`with` 语句已是一个标准特性而不再需要从 :mod:`__future__` 导入。 "
"另请参阅 :ref:`new-26-context-managers` 和 :ref:`new-module-contextlib`。"

#: ../../whatsnew/3.0.rst:493
msgid ""
":ref:`pep-0366`.  This enhances the usefulness of the :option:`-m` option "
"when the referenced module lives in a package."
msgstr ":ref:`pep-0366`。 这增强了 :option:`-m` 选项在被引用的模块位于包中时的实用性。"

#: ../../whatsnew/3.0.rst:496
msgid ":ref:`pep-0370`."
msgstr ":ref:`pep-0370`."

#: ../../whatsnew/3.0.rst:498
msgid ":ref:`pep-0371`."
msgstr ":ref:`pep-0371`."

#: ../../whatsnew/3.0.rst:500
msgid ""
":ref:`pep-3101`.  Note: the 2.6 description mentions the :meth:`format` "
"method for both 8-bit and Unicode strings.  In 3.0, only the :class:`str` "
"type (text strings with Unicode support) supports this method; the "
":class:`bytes` type does not.  The plan is to eventually make this the only "
"API for string formatting, and to start deprecating the ``%`` operator in "
"Python 3.1."
msgstr ""
":ref:`pep-3101`。 注意：2.6 说明文档提到 :meth:`format` 方法同时适用于 8 位和 Unicode 字符串。 在 "
"3.0 中，只有 :class:`str` 类型（带有 Unicode 支持的文本字符串）才支持此方法；:class:`bytes` 类型并不支持。 "
"最终的计划是使其成为仅针对字符串格式化的 API，并在 Python 3.1 中开始弃用 ``%`` 字符串运算符。"

#: ../../whatsnew/3.0.rst:507
msgid ""
":ref:`pep-3105`.  This is now a standard feature and no longer needs to be "
"imported from :mod:`__future__`.  More details were given above."
msgstr ":ref:`pep-3105`。 现在这已是一个标准特性而不再需要从 :mod:`__future__` 导入。 更多详情见上文。"

#: ../../whatsnew/3.0.rst:510
msgid ""
":ref:`pep-3110`.  The :keyword:`except` *exc* :keyword:`!as` *var* syntax is"
" now standard and :keyword:`!except` *exc*, *var* is no longer supported.  "
"(Of course, the :keyword:`!as` *var* part is still optional.)"
msgstr ""
":ref:`pep-3110`。 现在 :keyword:`except` *exc* :keyword:`!as` *var* 语法已成为标准而 "
":keyword:`!except` *exc*, *var* 不再受到支持。 （当然，:keyword:`!as` *var* 部分仍为可选项。）"

#: ../../whatsnew/3.0.rst:515
msgid ""
":ref:`pep-3112`.  The ``b\"...\"`` string literal notation (and its variants"
" like ``b'...'``, ``b\"\"\"...\"\"\"``, and ``br\"...\"``) now produces a "
"literal of type :class:`bytes`."
msgstr ""
":ref:`pep-3112`。 现在 ``b\"...\"`` 字节串字面值标记法（及其变化形式如 ``b'...'``, "
"``b\"\"\"...\"\"\"`` 和 ``br\"...\"`` 等将产生 :class:`bytes` 类型的字面值。"

#: ../../whatsnew/3.0.rst:519
msgid ""
":ref:`pep-3116`.  The :mod:`io` module is now the standard way of doing file"
" I/O.  The built-in :func:`open` function is now an alias for "
":func:`io.open` and has additional keyword arguments *encoding*, *errors*, "
"*newline* and *closefd*.  Also note that an invalid *mode* argument now "
"raises :exc:`ValueError`, not :exc:`IOError`.  The binary file object "
"underlying a text file object can be accessed as :attr:`!f.buffer` (but "
"beware that the text object maintains a buffer of itself in order to speed "
"up the encoding and decoding operations)."
msgstr ""
":ref:`pep-3116`。 :mod:`io` 模块现在是执行文件 I/O 的标准方式。 内置的 :func:`open` 函数现在是 "
":func:`io.open` 的别名并增加了额外的关键字参数 *encoding*, *errors*, *newline* 和 *closefd*。"
" 还请注意无效的 *mode* 参数现在会引发 :exc:`ValueError`，而不是 :exc:`IOError`。 "
"在文本文件对象之下的二进制文件对象可作为 :attr:`!f.buffer` "
"来访问（但要记住文本对象会为自己保留一个缓冲区以加快编码和解码操作的速度）。"

#: ../../whatsnew/3.0.rst:529
msgid ""
":ref:`pep-3118`.  The old builtin :func:`!buffer` is now really gone; the "
"new builtin :func:`memoryview` provides (mostly) similar functionality."
msgstr ""
":ref:`pep-3118`。 旧的内置 :func:`!buffer` 现已完全不复存在；新的内置 :func:`memoryview` "
"提供了（基本）类似的功能。"

#: ../../whatsnew/3.0.rst:533
msgid ""
":ref:`pep-3119`.  The :mod:`abc` module and the ABCs defined in the "
":mod:`collections` module plays a somewhat more prominent role in the "
"language now, and built-in collection types like :class:`dict` and "
":class:`list` conform to the :class:`collections.MutableMapping "
"<collections.abc.MutableMapping>` and :class:`collections.MutableSequence "
"<collections.abc.MutableSequence>` ABCs, respectively."
msgstr ""
":ref:`pep-3119`。 现在 :mod:`abc` 模块以及在 :mod:`collections` 模块中定义的 ABC "
"在本语言中扮演了更为重要的角色，而内置的多项集类型如 :class:`dict` 和 :class:`list` 分别与 "
":class:`collections.MutableMapping <collections.abc.MutableMapping>` 和 "
":class:`collections.MutableSequence <collections.abc.MutableSequence>` ABC "
"保持对应。"

#: ../../whatsnew/3.0.rst:539
msgid ""
":ref:`pep-3127`.  As mentioned above, the new octal literal notation is the "
"only one supported, and binary literals have been added."
msgstr ":ref:`pep-3127`。 如上文所述，新的八进制字面值标记法是唯一受支持的形式，并增加了二进制字面值。"

#: ../../whatsnew/3.0.rst:543
msgid ":ref:`pep-3129`."
msgstr ":ref:`pep-3129`."

#: ../../whatsnew/3.0.rst:545
msgid ""
":ref:`pep-3141`.  The :mod:`numbers` module is another new use of ABCs, "
"defining Python's \"numeric tower\".  Also note the new :mod:`fractions` "
"module which implements :class:`numbers.Rational`."
msgstr ""
":ref:`pep-3141`。 :mod:`numbers` 模块是 ABC 的另一个新用例，它定义了 Python 的“数字层级塔”。 另请注意新的"
" :mod:`fractions` 模块，它实现了 :class:`numbers.Rational`。"

#: ../../whatsnew/3.0.rst:551
msgid "Library Changes"
msgstr "库的修改"

#: ../../whatsnew/3.0.rst:553
msgid ""
"Due to time constraints, this document does not exhaustively cover the very "
"extensive changes to the standard library.  :pep:`3108` is the reference for"
" the major changes to the library.  Here's a capsule review:"
msgstr "由于时间有限，本文档并未完全覆盖标准库的所有变化内容。 :pep:`3108` 引用了对标准库的主要修改。 以下是精简版的预览："

#: ../../whatsnew/3.0.rst:558
msgid ""
"Many old modules were removed.  Some, like :mod:`!gopherlib` (no longer "
"used) and :mod:`!md5` (replaced by :mod:`hashlib`), were already deprecated "
"by :pep:`4`.  Others were removed as a result of the removal of support for "
"various platforms such as Irix, BeOS and Mac OS 9 (see :pep:`11`).  Some "
"modules were also selected for removal in Python 3.0 due to lack of use or "
"because a better replacement exists.  See :pep:`3108` for an exhaustive "
"list."
msgstr ""
"许多旧模块已被移除。 其中一些，如 :mod:`!gopherlib` (不再有用) 和 :mod:`!md5` (被 :mod:`hashlib` "
"替代)，已根据 :pep:`4` 被弃用。 其他一些是作为移除对几种平台如 Irix, BeOS 和 Mac OS 9 支持的结果而被移除的 (参见 "
":pep:`11`)。 某些模块则由于缺少使用或因为存在更好的替代而被选入 Python 3.0 的移除计划。 完整列表参见 :pep:`3108`。"

#: ../../whatsnew/3.0.rst:566
msgid ""
"The :mod:`!bsddb3` package was removed because its presence in the core "
"standard library has proved over time to be a particular burden for the core"
" developers due to testing instability and Berkeley DB's release schedule.  "
"However, the package is alive and well, externally maintained at "
"https://www.jcea.es/programacion/pybsddb.htm."
msgstr ""
":mod:`!bsddb3` 软件包被移除是因为随着时间的推移它存在于核心标准库已被证明由于测试的不稳定性和 Berkeley DB "
"的发布计划是对核心开发者的重大负担。 不过，这个软件包仍在 https://www.jcea.es/programacion/pybsddb.htm "
"获得外部维护并继续存活。"

#: ../../whatsnew/3.0.rst:572
msgid ""
"Some modules were renamed because their old name disobeyed :pep:`8`, or for "
"various other reasons.  Here's the list:"
msgstr "一些模块名称已被修改因为它们的旧名称不符合 :pep:`8`，或是出于各种其他理由。 具体列表如下："

#: ../../whatsnew/3.0.rst:576
msgid "Old Name"
msgstr "旧名称"

#: ../../whatsnew/3.0.rst:576
msgid "New Name"
msgstr "新名称"

#: ../../whatsnew/3.0.rst:578
msgid "_winreg"
msgstr "_winreg"

#: ../../whatsnew/3.0.rst:578
msgid "winreg"
msgstr "winreg"

#: ../../whatsnew/3.0.rst:579
msgid "ConfigParser"
msgstr "ConfigParser"

#: ../../whatsnew/3.0.rst:579
msgid "configparser"
msgstr "configparser"

#: ../../whatsnew/3.0.rst:580
msgid "copy_reg"
msgstr "copy_reg"

#: ../../whatsnew/3.0.rst:580
msgid "copyreg"
msgstr "copyreg"

#: ../../whatsnew/3.0.rst:581
msgid "Queue"
msgstr "Queue"

#: ../../whatsnew/3.0.rst:581
msgid "queue"
msgstr "queue"

#: ../../whatsnew/3.0.rst:582
msgid "SocketServer"
msgstr "SocketServer"

#: ../../whatsnew/3.0.rst:582
msgid "socketserver"
msgstr "socketserver"

#: ../../whatsnew/3.0.rst:583
msgid "markupbase"
msgstr "markupbase"

#: ../../whatsnew/3.0.rst:583
msgid "_markupbase"
msgstr "_markupbase"

#: ../../whatsnew/3.0.rst:584
msgid "repr"
msgstr "repr"

#: ../../whatsnew/3.0.rst:584
msgid "reprlib"
msgstr "reprlib"

#: ../../whatsnew/3.0.rst:585
msgid "test.test_support"
msgstr "test.test_support"

#: ../../whatsnew/3.0.rst:585
msgid "test.support"
msgstr "test.support"

#: ../../whatsnew/3.0.rst:588
msgid ""
"A common pattern in Python 2.x is to have one version of a module "
"implemented in pure Python, with an optional accelerated version implemented"
" as a C extension; for example, :mod:`pickle` and :mod:`!cPickle`.  This "
"places the burden of importing the accelerated version and falling back on "
"the pure Python version on each user of these modules.  In Python 3.0, the "
"accelerated versions are considered implementation details of the pure "
"Python versions. Users should always import the standard version, which "
"attempts to import the accelerated version and falls back to the pure Python"
" version.  The :mod:`pickle` / :mod:`!cPickle` pair received this treatment."
"  The :mod:`profile` module is on the list for 3.1.  The :mod:`!StringIO` "
"module has been turned into a class in the :mod:`io` module."
msgstr ""
"在 Python 2.x 中的常见模式是某个模块有一个以纯 Python 实现的版本，并有一个作为 C "
"扩展实现的加速版本；例如，:mod:`pickle` 和 :mod:`!cPickle`。 这造成每个此类模块的用户存在导入加速版本并在必要时回退到纯 "
"Python 版本的负担。 在 Python 3.0 中，加速版本将被视为纯 Python 版本的实现细节。 "
"用户应当总是导入标准版本，该版本会尝试导入加速版本并在必要时回退到纯 Python 版本。 :mod:`pickle` / "
":mod:`!cPickle` 对就获得了这样的处置。 :mod:`profile` 模块被加入了 3.1 版的处置计划。 "
":mod:`!StringIO` 模块已被转为 :mod:`io` 模块中的一个类。"

#: ../../whatsnew/3.0.rst:602
msgid ""
"Some related modules have been grouped into packages, and usually the "
"submodule names have been simplified.  The resulting new packages are:"
msgstr "一些有关联的模块已被组织为包，通常其子模块名也得到了简化。 这样产生的新包有："

#: ../../whatsnew/3.0.rst:606
msgid ""
":mod:`dbm` (:mod:`!anydbm`, :mod:`!dbhash`, :mod:`!dbm`, :mod:`!dumbdbm`, "
":mod:`!gdbm`, :mod:`!whichdb`)."
msgstr ""
":mod:`dbm` (:mod:`!anydbm`, :mod:`!dbhash`, :mod:`!dbm`, :mod:`!dumbdbm`, "
":mod:`!gdbm`, :mod:`!whichdb`)。"

#: ../../whatsnew/3.0.rst:609
msgid ":mod:`html` (:mod:`!HTMLParser`, :mod:`!htmlentitydefs`)."
msgstr ":mod:`html` (:mod:`!HTMLParser`, :mod:`!htmlentitydefs`)。"

#: ../../whatsnew/3.0.rst:611
msgid ""
":mod:`http` (:mod:`!httplib`, :mod:`!BaseHTTPServer`, :mod:`!CGIHTTPServer`,"
" :mod:`!SimpleHTTPServer`, :mod:`!Cookie`, :mod:`!cookielib`)."
msgstr ""
":mod:`http` (:mod:`!httplib`, :mod:`!BaseHTTPServer`, :mod:`!CGIHTTPServer`,"
" :mod:`!SimpleHTTPServer`, :mod:`!Cookie`, :mod:`!cookielib`)。"

#: ../../whatsnew/3.0.rst:615
msgid ""
":mod:`tkinter` (all ``Tkinter``-related modules except :mod:`turtle`).  The "
"target audience of :mod:`turtle` doesn't really care about :mod:`tkinter`.  "
"Also note that as of Python 2.6, the functionality of :mod:`turtle` has been"
" greatly enhanced."
msgstr ""
":mod:`tkinter` (所有 ``Tkinter`` 相关的模块但 :mod:`turtle` 除外)。 :mod:`turtle` "
"的目标用户通常并不真的关心 :mod:`tkinter`。 还要注意在 Python 2.6 中，:mod:`turtle` 的功能得到了大幅增强。"

#: ../../whatsnew/3.0.rst:620
msgid ""
":mod:`urllib` (:mod:`!urllib`, :mod:`!urllib2`, :mod:`!urlparse`, "
":mod:`!robotparse`)."
msgstr ""
":mod:`urllib` (:mod:`!urllib`, :mod:`!urllib2`, :mod:`!urlparse`, "
":mod:`!robotparse`)。"

#: ../../whatsnew/3.0.rst:623
msgid ""
":mod:`xmlrpc` (:mod:`!xmlrpclib`, :mod:`!DocXMLRPCServer`, "
":mod:`!SimpleXMLRPCServer`)."
msgstr ""
":mod:`xmlrpc` (:mod:`!xmlrpclib`, :mod:`!DocXMLRPCServer`, "
":mod:`!SimpleXMLRPCServer`)。"

#: ../../whatsnew/3.0.rst:626
msgid ""
"Some other changes to standard library modules, not covered by :pep:`3108`:"
msgstr "其他一些针对标准库模块的改变，未被 :pep:`3108` 覆盖："

#: ../../whatsnew/3.0.rst:629
msgid "Killed :mod:`!sets`.  Use the built-in :func:`set` class."
msgstr "去除了 :mod:`!sets`。 请改用内置 :func:`set` 类。"

#: ../../whatsnew/3.0.rst:631
msgid ""
"Cleanup of the :mod:`sys` module: removed :func:`!sys.exitfunc`, "
":func:`!sys.exc_clear`, :data:`!sys.exc_type`, :data:`!sys.exc_value`, "
":data:`!sys.exc_traceback`.  (Note that :data:`sys.last_type` etc. remain.)"
msgstr ""
"清理了 :mod:`sys` 模块：移除 :func:`!sys.exitfunc`, :func:`!sys.exc_clear`, "
":data:`!sys.exc_type`, :data:`!sys.exc_value`, :data:`!sys.exc_traceback`。 "
"（请注意 :data:`sys.last_type` 等仍然保留。）"

#: ../../whatsnew/3.0.rst:636
msgid ""
"Cleanup of the :class:`array.array` type: the :meth:`!read` and "
":meth:`!write` methods are gone; use :meth:`~array.array.fromfile` and "
":meth:`~array.array.tofile` instead.  Also, the ``'c'`` typecode for array "
"is gone -- use either ``'b'`` for bytes or ``'u'`` for Unicode characters."
msgstr ""
"清理了 :class:`array.array` 类型：去除 :meth:`!read` 和 :meth:`!write` 方法；改用 "
":meth:`~array.array.fromfile` 和 :meth:`~array.array.tofile`。 此外，数组的 ``'c'`` "
"类型代码已去除 -- 请使用 ``'b'`` 表示字节数据或使用 ``'u'`` 表示 Unicode 字符。"

#: ../../whatsnew/3.0.rst:642
msgid ""
"Cleanup of the :mod:`operator` module: removed :func:`!sequenceIncludes` and"
" :func:`!isCallable`."
msgstr ""
"清理了 :mod:`operator` 模块：移除 :func:`!sequenceIncludes` 和 :func:`!isCallable`。"

#: ../../whatsnew/3.0.rst:645
msgid ""
"Cleanup of the :mod:`!thread` module: :func:`!acquire_lock` and "
":func:`!release_lock` are gone; use :meth:`~threading.Lock.acquire` and "
":meth:`~threading.Lock.release` instead."
msgstr ""
"清理了 :mod:`!thread` 模块：去除 :func:`!acquire_lock` 和 :func:`!release_lock`；改用 "
":meth:`~threading.Lock.acquire` 和 :meth:`~threading.Lock.release`。"

#: ../../whatsnew/3.0.rst:649
msgid ""
"Cleanup of the :mod:`random` module: removed the :func:`!jumpahead` API."
msgstr "清理了 :mod:`random` 模块：移除 :func:`!jumpahead` API。"

#: ../../whatsnew/3.0.rst:651
msgid "The :mod:`!new` module is gone."
msgstr ":mod:`!new` 模块已不复存在。"

#: ../../whatsnew/3.0.rst:653
msgid ""
"The functions :func:`!os.tmpnam`, :func:`!os.tempnam` and "
":func:`!os.tmpfile` have been removed in favor of the :mod:`tempfile` "
"module."
msgstr ""
":func:`!os.tmpnam`, :func:`!os.tempnam` 和 :func:`!os.tmpfile` 等函数已被移除并应改用 "
":mod:`tempfile` 模块。"

#: ../../whatsnew/3.0.rst:657
msgid ""
"The :mod:`tokenize` module has been changed to work with bytes.  The main "
"entry point is now :func:`tokenize.tokenize`, instead of generate_tokens."
msgstr ""
":mod:`tokenize` 模块已被修改以适用于字节串。 主入口点现在是 :func:`tokenize.tokenize`，而不是 "
"generate_tokens。"

#: ../../whatsnew/3.0.rst:661
msgid ""
":data:`!string.letters` and its friends (:data:`!string.lowercase` and "
":data:`!string.uppercase`) are gone.  Use :data:`string.ascii_letters` etc. "
"instead.  (The reason for the removal is that :data:`!string.letters` and "
"friends had locale-specific behavior, which is a bad idea for such "
"attractively named global \"constants\".)"
msgstr ""
":data:`!string.letters` 及其同类 (:data:`!string.lowercase` 和 "
":data:`!string.uppercase`) 已不复存在。 请改用 :data:`string.ascii_letters` 等。 （移除 "
":data:`!string.letters` 及其同类的原因在于它们具有语言区域专属的行为，对于这些被称为全局“常量”的对象来说不是好主意。）"

#: ../../whatsnew/3.0.rst:668
msgid ""
"Renamed module :mod:`!__builtin__` to :mod:`builtins` (removing the "
"underscores, adding an 's').  The :data:`!__builtins__` variable found in "
"most global namespaces is unchanged.  To modify a builtin, you should use "
":mod:`builtins`, not :data:`!__builtins__`!"
msgstr ""
"模块 :mod:`!__builtin__` 被重命名为 :mod:`builtins` (移除了下划线，添加了 's')。 大多数全局命名空间中的 "
":data:`!__builtins__` 变量保持不变。 要修改内置对象，你应当使用 :mod:`builtins`，而不是 "
":data:`!__builtins__`!"

#: ../../whatsnew/3.0.rst:675
msgid ":pep:`3101`: A New Approach To String Formatting"
msgstr ":pep:`3101`: 字符串格式化的新方式"

#: ../../whatsnew/3.0.rst:677
msgid ""
"A new system for  built-in string formatting operations replaces the ``%`` "
"string  formatting operator.   (However, the ``%``  operator is still "
"supported;  it will  be deprecated in  Python 3.1  and removed from the "
"language at some later time.)  Read :pep:`3101` for the full scoop."
msgstr ""
"一种针对内置字符串格式化操作的新系统替代了 ``%`` 字符串格式化运算符。 （不过，``%``  运算符仍然受到支持；它将在 Python 3.1 "
"中被弃用并在今后某一时刻从语言特性中移除。） 请参阅 :pep:`3101` 了解详情。"

#: ../../whatsnew/3.0.rst:685
msgid "Changes To Exceptions"
msgstr "对异常的修改"

#: ../../whatsnew/3.0.rst:687
msgid ""
"The APIs for raising and catching exception have been cleaned up and new "
"powerful features added:"
msgstr "用于引发和捕获异常的 API 已经过清理并增加了强大的新特性："

#: ../../whatsnew/3.0.rst:690
msgid ""
":pep:`352`: All exceptions must be derived (directly or indirectly) from "
":exc:`BaseException`.  This is the root of the exception hierarchy.  This is"
" not new as a recommendation, but the *requirement* to inherit from "
":exc:`BaseException` is new.  (Python 2.6 still allowed classic classes to "
"be raised, and placed no restriction on what you can catch.)  As a "
"consequence, string exceptions are finally truly and utterly dead."
msgstr ""
":pep:`352`: 所有异常都必须（直接或间接地）派生自 :exc:`BaseException`。 这是异常层级结构的根对象。 "
"作为推荐方式这并不是新的变化，但 *必须* 从 :exc:`BaseException` 继承是新的变化。 （Python 2.6 "
"仍然允许引发经典类，并且不限制你能捕获的异常。） 作为此变化的结果，字符串异常终于真正彻底地死亡了。"

#: ../../whatsnew/3.0.rst:698
msgid ""
"Almost all exceptions should actually derive from :exc:`Exception`; "
":exc:`BaseException` should only be used as a base class for exceptions that"
" should only be handled at the top level, such as :exc:`SystemExit` or "
":exc:`KeyboardInterrupt`.  The recommended idiom for handling all exceptions"
" except for this latter category is to use :keyword:`except` "
":exc:`Exception`."
msgstr ""
"几乎所有异常实际上都应当派生自 :exc:`Exception`；:exc:`BaseException` "
"仅应当被用作那些仅应当在最高层级中处理的异常的基类，如 :exc:`SystemExit` 或 :exc:`KeyboardInterrupt`。 "
"处理除了后面这一类之外的所有异常的推荐写法是使用 :keyword:`except` :exc:`Exception`。"

#: ../../whatsnew/3.0.rst:705
msgid ":exc:`!StandardError` was removed."
msgstr ":exc:`!StandardError` 已被移除。"

#: ../../whatsnew/3.0.rst:707
msgid ""
"Exceptions no longer behave as sequences.  Use the "
":attr:`~BaseException.args` attribute instead."
msgstr "异常已不再被当作序列来处理。 而应改用 :attr:`~BaseException.args` 属性。"

#: ../../whatsnew/3.0.rst:710
msgid ""
":pep:`3109`: Raising exceptions.  You must now use :samp:`raise "
"{Exception}({args})` instead of :samp:`raise {Exception}, {args}`. "
"Additionally, you can no longer explicitly specify a traceback; instead, if "
"you *have* to do this, you can assign directly to the "
":attr:`~BaseException.__traceback__` attribute (see below)."
msgstr ""
":pep:`3109`: 引发异常。 你现在必须使用 :samp:`raise {Exception}({args})` 而不是 "
":samp:`raise {Exception}, {args}`。 此外，你不再可以显式地指定回溯；作为替代，如果你 *必须* "
"这样做，你可以直接赋值给 :attr:`~BaseException.__traceback__` 属性（见下文）。"

#: ../../whatsnew/3.0.rst:716
msgid ""
":pep:`3110`: Catching exceptions.  You must now use :samp:`except "
"{SomeException} as {variable}` instead of :samp:`except {SomeException}, "
"{variable}`.  Moreover, the *variable* is explicitly deleted when the "
":keyword:`except` block is left."
msgstr ""
":pep:`3110`: 捕获异常。 你现在必须使用 :samp:`except {SomeException} as {variable}` 而不是 "
":samp:`except {SomeException}, {variable}`。 此外，*variable* 会在离开 "
":keyword:`except` 代码块时被显式地删除。"

#: ../../whatsnew/3.0.rst:722
msgid ""
":pep:`3134`: Exception chaining.  There are two cases: implicit chaining and"
" explicit chaining.  Implicit chaining happens when an exception is raised "
"in an :keyword:`except` or :keyword:`finally` handler block.  This usually "
"happens due to a bug in the handler block; we call this a *secondary* "
"exception.  In this case, the original exception (that was being handled) is"
" saved as the :attr:`~BaseException.__context__` attribute of the secondary "
"exception. Explicit chaining is invoked with this syntax::"
msgstr ""
":pep:`3134`: 异常串连。 存在两种情况：隐式串连和显式串连。 当异常在 :keyword:`except` 或 "
":keyword:`finally` 处理器代码块中被引发时将发生隐式串连。 通常发生这种情况是由于处理器代码块中存在程序缺陷；我们将其称为 *二级* "
"异常。 在这种情况下，（正在处理的）原始异常将被保存为该二级异常的 :attr:`~BaseException.__context__` 属性。 "
"显式串连则是由以下语法来唤起::"

#: ../../whatsnew/3.0.rst:731
msgid "raise SecondaryException() from primary_exception"
msgstr "raise SecondaryException() from primary_exception"

#: ../../whatsnew/3.0.rst:733
msgid ""
"(where *primary_exception* is any expression that produces an exception "
"object, probably an exception that was previously caught). In this case, the"
" primary exception is stored on the :attr:`~BaseException.__cause__` "
"attribute of the secondary exception.  The traceback printed when an "
"unhandled exception occurs walks the chain of :attr:`!__cause__` and "
":attr:`~BaseException.__context__` attributes and prints a separate "
"traceback for each component of the chain, with the primary exception at the"
" top.  (Java users may recognize this behavior.)"
msgstr ""
"（这里 *primary_exception* 是产生一个异常对象的任何异常，它可能是在之前被捕获的异常）。 在这种情况下，该原始异常将存储在二级异常的"
" :attr:`~BaseException.__cause__` 属性中。 如果遍历 :attr:`!__cause__` 和 "
":attr:`~BaseException.__context__` "
"属性链时发生了未被处理的异常则会打印回溯信息并为属性链中的每个部分打印单独的回溯信息，原始异常将位于最上面。 （Java 用户可能很了解这样的行为。）"

#: ../../whatsnew/3.0.rst:743
msgid ""
":pep:`3134`: Exception objects now store their traceback as the "
":attr:`~BaseException.__traceback__` attribute.  This means that an "
"exception object now contains all the information pertaining to an "
"exception, and there are fewer reasons to use :func:`sys.exc_info` (though "
"the latter is not removed)."
msgstr ""
":pep:`3134`: 异常对象现在会将其回溯信息保存为 :attr:`~BaseException.__traceback__` 属性。 "
"这意味着一个异常对象现在将包含从属于异常的所有信息，没有什么理由再使用 :func:`sys.exc_info` (不过后者并未被移除)。"

#: ../../whatsnew/3.0.rst:749
msgid ""
"A few exception messages are improved when Windows fails to load an "
"extension module.  For example, ``error code 193`` is now ``%1 is not a "
"valid Win32 application``.  Strings now deal with non-English locales."
msgstr ""
"一些提示 Windows 载入扩展模块失败的异常消息得到了改进。 例如，``error code 193`` 现在是 ``%1 is not a "
"valid Win32 application``。 字符串现在可处理非英语的语言区域。"

#: ../../whatsnew/3.0.rst:756
msgid "Miscellaneous Other Changes"
msgstr "其他杂项修改"

#: ../../whatsnew/3.0.rst:759
msgid "Operators And Special Methods"
msgstr "运算符与特殊方法"

#: ../../whatsnew/3.0.rst:761
msgid ""
"``!=`` now returns the opposite of ``==``, unless ``==`` returns "
":data:`NotImplemented`."
msgstr "现在 ``!=`` 将返回与 ``==`` 相反的结果，除非 ``==`` 是返回 :data:`NotImplemented`。"

#: ../../whatsnew/3.0.rst:764
msgid ""
"The concept of \"unbound methods\" has been removed from the language. When "
"referencing a method as a class attribute, you now get a plain function "
"object."
msgstr "“未绑定方法”的概念已从语言中移除。 现在当把一个方法作为类属性来引用时，你将得到一个普通函数对象。"

#: ../../whatsnew/3.0.rst:768
msgid ""
":meth:`!__getslice__`, :meth:`!__setslice__` and :meth:`!__delslice__` were "
"killed.  The syntax ``a[i:j]`` now translates to ``a.__getitem__(slice(i, "
"j))`` (or :meth:`~object.__setitem__` or :meth:`~object.__delitem__`, when "
"used as an assignment or deletion target, respectively)."
msgstr ""
":meth:`!__getslice__`, :meth:`!__setslice__` 和 :meth:`!__delslice__` 已被去除。 "
"现在 ``a[i:j]`` 语法形式将被转为 ``a.__getitem__(slice(i, j))`` (或者当用作赋值或删除的目标时，分别被转为 "
":meth:`~object.__setitem__` 或 :meth:`~object.__delitem__`)。"

#: ../../whatsnew/3.0.rst:774
msgid ""
":pep:`3114`: the standard :meth:`next` method has been renamed to "
":meth:`~iterator.__next__`."
msgstr ":pep:`3114`: 标准的 :meth:`next` 方法已被重命名为 :meth:`~iterator.__next__`。"

#: ../../whatsnew/3.0.rst:777
msgid ""
"The :meth:`!__oct__` and :meth:`!__hex__` special methods are removed -- "
":func:`oct` and :func:`hex` use :meth:`~object.__index__` now to convert the"
" argument to an integer."
msgstr ""
":meth:`!__oct__` 和 :meth:`!__hex__` 特殊方法已被移除 -- 现在 :func:`oct` 和 :func:`hex`"
" 将使用 :meth:`~object.__index__` 来将参数转换为整数。"

#: ../../whatsnew/3.0.rst:781
msgid "Removed support for :attr:`!__members__` and :attr:`!__methods__`."
msgstr "移除了对 :attr:`!__members__` 和 :attr:`!__methods__` 的支持。"

#: ../../whatsnew/3.0.rst:783
msgid ""
"The function attributes named :attr:`!func_X` have been renamed to use the "
":attr:`!__X__` form, freeing up these names in the function attribute "
"namespace for user-defined attributes.  To wit, :attr:`!func_closure`, "
":attr:`!func_code`, :attr:`!func_defaults`, :attr:`!func_dict`, "
":attr:`!func_doc`, :attr:`!func_globals`, :attr:`!func_name` were renamed to"
" :attr:`~function.__closure__`, :attr:`~function.__code__`, "
":attr:`~function.__defaults__`, :attr:`~function.__dict__`, "
":attr:`~function.__doc__`, :attr:`~function.__globals__`, "
":attr:`~function.__name__`, respectively."
msgstr ""
"名为 :attr:`!func_X` 的函数属性已被重命名为使用 :attr:`!__X__` "
"的形式，在函数属性命名空间中释放这些名称以便作为用户自定义属性。 也就是说，:attr:`!func_closure`, "
":attr:`!func_code`, :attr:`!func_defaults`, :attr:`!func_dict`, "
":attr:`!func_doc`, :attr:`!func_globals`, :attr:`!func_name` 分别被重命名为 "
":attr:`~function.__closure__`, :attr:`~function.__code__`, "
":attr:`~function.__defaults__`, :attr:`~function.__dict__`, "
":attr:`~function.__doc__`, :attr:`~function.__globals__`, "
":attr:`~function.__name__`。"

#: ../../whatsnew/3.0.rst:794
msgid ":meth:`!__nonzero__` is now :meth:`~object.__bool__`."
msgstr ":meth:`!__nonzero__` 现在为 :meth:`~object.__bool__`。"

#: ../../whatsnew/3.0.rst:797
msgid "Builtins"
msgstr "内置对象"

#: ../../whatsnew/3.0.rst:799
msgid ""
":pep:`3135`: New :func:`super`.  You can now invoke :func:`super` without "
"arguments and (assuming this is in a regular instance method defined inside "
"a :keyword:`class` statement) the right class and instance will "
"automatically be chosen.  With arguments, the behavior of :func:`super` is "
"unchanged."
msgstr ""
":pep:`3135`: 新的 :func:`super`。 现在你可以不带参数地唤起 :func:`super` 这样（假定这发生在定义于 "
":keyword:`class` 语句内部的常规实例方法中）将会自动选择正确的类和实例。 附带参数时，:func:`super` 的行为保持不变。"

#: ../../whatsnew/3.0.rst:805
msgid ""
":pep:`3111`: :func:`!raw_input` was renamed to :func:`input`.  That is, the "
"new :func:`input` function reads a line from :data:`sys.stdin` and returns "
"it with the trailing newline stripped. It raises :exc:`EOFError` if the "
"input is terminated prematurely. To get the old behavior of :func:`input`, "
"use ``eval(input())``."
msgstr ""
":pep:`3111`: :func:`!raw_input` 已改名为 :func:`input`。 也就是说，新的 :func:`input` "
"函数会从 :data:`sys.stdin` 读取一行并去除末尾换行符再将其返回。 如果输入提前终结则会引发 :exc:`EOFError`。 "
"要获取原来 :func:`input` 的行为，请使用 ``eval(input())``。"

#: ../../whatsnew/3.0.rst:811
msgid ""
"A new built-in function :func:`next` was added to call the "
":meth:`~iterator.__next__` method on an object."
msgstr "新增内置函数 :func:`next` 用于在对象上调用 :meth:`~iterator.__next__` 方法。"

#: ../../whatsnew/3.0.rst:814
msgid ""
"The :func:`round` function rounding strategy and return type have changed.  "
"Exact halfway cases are now rounded to the nearest even result instead of "
"away from zero.  (For example, ``round(2.5)`` now returns ``2`` rather than "
"``3``.)  ``round(x[, n])`` now delegates to ``x.__round__([n])`` instead of "
"always returning a float.  It generally returns an integer when called with "
"a single argument and a value of the same type as ``x`` when called with two"
" arguments."
msgstr ""
":func:`round` 函数的舍入策略和返回类型已有改变。 对于两边差值相同的情况现在将会舍入到最接近的偶数结果而不是远离零值的结果。 "
"（例如，``round(2.5)`` 现在将返回 ``2`` 而不是 ``3``。） 现在 ``round(x[, n])`` 将委托给 "
"``x.__round__([n])`` 而不是始终返回一个浮点数。 它通常会在附带一个参数调用时返回整数而在附带两个参数调用时返回与 ``x`` "
"相同类型的值。"

#: ../../whatsnew/3.0.rst:823
msgid "Moved :func:`!intern` to :func:`sys.intern`."
msgstr "将 :func:`!intern` 移至 :func:`sys.intern`。"

#: ../../whatsnew/3.0.rst:825
msgid ""
"Removed: :func:`!apply`.  Instead of ``apply(f, args)`` use ``f(*args)``."
msgstr "移除: :func:`!apply`。 原 ``apply(f, args)`` 请改用 ``f(*args)``。"

#: ../../whatsnew/3.0.rst:828
msgid ""
"Removed :func:`callable`.  Instead of ``callable(f)`` you can use "
"``isinstance(f, collections.Callable)``.  The :func:`!operator.isCallable` "
"function is also gone."
msgstr ""
"移除了 :func:`callable`。 原 ``callable(f)`` 可以改用 ``isinstance(f, "
"collections.Callable)``。 :func:`!operator.isCallable` 函数也已不复存在。"

#: ../../whatsnew/3.0.rst:832
msgid ""
"Removed :func:`!coerce`.  This function no longer serves a purpose now that "
"classic classes are gone."
msgstr "移除了 :func:`!coerce`。 由于经典类已不复存在此函数也不再有用处。"

#: ../../whatsnew/3.0.rst:835
msgid ""
"Removed :func:`!execfile`.  Instead of ``execfile(fn)`` use "
"``exec(open(fn).read())``."
msgstr ""
"移除了 :func:`!execfile`。 原 ``execfile(fn)`` 请改用 ``exec(open(fn).read())``。"

#: ../../whatsnew/3.0.rst:838
msgid ""
"Removed the :class:`!file` type.  Use :func:`open`.  There are now several "
"different kinds of streams that open can return in the :mod:`io` module."
msgstr ""
"移除了 :class:`!file` 类型。 请使用 :func:`open`。 当前在 :mod:`io` 模块中有多种不同类别的流可由 open "
"函数返回。"

#: ../../whatsnew/3.0.rst:841
msgid ""
"Removed :func:`!reduce`.  Use :func:`functools.reduce` if you really need "
"it; however, 99 percent of the time an explicit :keyword:`for` loop is more "
"readable."
msgstr ""
"移除了 :func:`!reduce`。 如果你确实需要它可使用 :func:`functools.reduce`；不过，在百分之 99 "
"的情况下用显式的 :keyword:`for` 循环会有更好的可读性。"

#: ../../whatsnew/3.0.rst:845
msgid "Removed :func:`!reload`.  Use :func:`!imp.reload`."
msgstr "移除了 :func:`!reload`。 请使用 :func:`!imp.reload`。"

#: ../../whatsnew/3.0.rst:847
msgid ""
"Removed. :meth:`!dict.has_key` -- use the :keyword:`in` operator instead."
msgstr "移除了 :meth:`!dict.has_key` -- 请改用 :keyword:`in` 运算符。"

#: ../../whatsnew/3.0.rst:854
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/3.0.rst:856
msgid ""
"Due to time constraints, here is a *very* incomplete list of changes to the "
"C API."
msgstr "由于时间约束，下面 C API 的变化列表 *非常* 不完整。"

#: ../../whatsnew/3.0.rst:859
msgid ""
"Support for several platforms was dropped, including but not limited to Mac "
"OS 9, BeOS, RISCOS, Irix, and Tru64."
msgstr "已放弃对某些平台的支持，包括但不限于 Mac OS 9, BeOS, RISCOS, Irix 和 Tru64。"

#: ../../whatsnew/3.0.rst:862
msgid ":pep:`3118`: New Buffer API."
msgstr ":pep:`3118`: 新的缓冲区 API。"

#: ../../whatsnew/3.0.rst:864
msgid ":pep:`3121`: Extension Module Initialization & Finalization."
msgstr ":pep:`3121`: 扩展模块初始化与最终化。"

#: ../../whatsnew/3.0.rst:866
msgid ":pep:`3123`: Making :c:macro:`PyObject_HEAD` conform to standard C."
msgstr ":pep:`3123`: 使 :c:macro:`PyObject_HEAD` 与标准 C 一致。"

#: ../../whatsnew/3.0.rst:868
msgid "No more C API support for restricted execution."
msgstr "已去除对受限执行的 C API 支持。"

#: ../../whatsnew/3.0.rst:870
msgid ""
":c:func:`!PyNumber_Coerce`, :c:func:`!PyNumber_CoerceEx`, "
":c:func:`!PyMember_Get`, and :c:func:`!PyMember_Set` C APIs are removed."
msgstr ""
":c:func:`!PyNumber_Coerce`, :c:func:`!PyNumber_CoerceEx`, "
":c:func:`!PyMember_Get` 和 :c:func:`!PyMember_Set` C API 已被移除。"

#: ../../whatsnew/3.0.rst:873
msgid ""
"New C API :c:func:`PyImport_ImportModuleNoBlock`, works like "
":c:func:`PyImport_ImportModule` but won't block on the import lock "
"(returning an error instead)."
msgstr ""
"新的 C API :c:func:`PyImport_ImportModuleNoBlock`，类似于 "
":c:func:`PyImport_ImportModule` 但不会因导入锁而阻塞（改为返回错误）。"

#: ../../whatsnew/3.0.rst:877
msgid ""
"Renamed the boolean conversion C-level slot and method: ``nb_nonzero`` is "
"now ``nb_bool``."
msgstr "重命名布尔转换的 C 层级槽位和方法: ``nb_nonzero`` 现在改为 ``nb_bool``。"

#: ../../whatsnew/3.0.rst:880
msgid ""
"Removed :c:macro:`!METH_OLDARGS` and :c:macro:`!WITH_CYCLE_GC` from the C "
"API."
msgstr "从 C API 中移除了 :c:macro:`!METH_OLDARGS` 和 :c:macro:`!WITH_CYCLE_GC`。"

#: ../../whatsnew/3.0.rst:886
msgid "Performance"
msgstr "性能"

#: ../../whatsnew/3.0.rst:888
msgid ""
"The net result of the 3.0 generalizations is that Python 3.0 runs the "
"pystone benchmark around 10% slower than Python 2.5.  Most likely the "
"biggest cause is the removal of special-casing for small integers. There's "
"room for improvement, but it will happen after 3.0 is released!"
msgstr ""
"综合而言 3.0 的改变使得 Python 3.0 运行 pystone 基准测试的速度比 Python 2.5 慢了约 10%。 "
"其中最大的原因可能是移除了针对小整数的特别场景的处理。 虽然存在改进空间，但这将在 3.0 发布之后再进行！"

#: ../../whatsnew/3.0.rst:898
msgid "Porting To Python 3.0"
msgstr "移植到 Python 3.0"

#: ../../whatsnew/3.0.rst:900
msgid ""
"For porting existing Python 2.5 or 2.6 source code to Python 3.0, the best "
"strategy is the following:"
msgstr "对于将现有 Python 2.5 或 2.6 源代码移植到 Python 3.0，最佳的策略如下："

#: ../../whatsnew/3.0.rst:903
msgid "(Prerequisite:) Start with excellent test coverage."
msgstr "（必要前提：）启动良好的测试覆盖。"

#: ../../whatsnew/3.0.rst:905
msgid ""
"Port to Python 2.6.  This should be no more work than the average port from "
"Python 2.x to Python 2.(x+1).  Make sure all your tests pass."
msgstr ""
"移植到 Python 2.6。 这应该不会比从 Python 2.x 到 Python 2.(x+1) 的正常移植更麻烦。 请确保所有的测试均能通过。"

#: ../../whatsnew/3.0.rst:909
msgid ""
"(Still using 2.6:) Turn on the :option:`!-3` command line switch. This "
"enables warnings about features that will be removed (or change) in 3.0.  "
"Run your test suite again, and fix code that you get warnings about until "
"there are no warnings left, and all your tests still pass."
msgstr ""
"（仍然使用 2.6：） 打开 :option:`!-3` 命令行开关。 这将启用针对将在 3.0 中被移除（或修改）的特性的警告。 "
"再次运行你的测试套件，并修复你收到相关警告的代码直至不再有任何警告，并且所有的测试仍然能通过。"

#: ../../whatsnew/3.0.rst:915
msgid ""
"Run the ``2to3`` source-to-source translator over your source code tree.  "
"Run the result of the translation under Python 3.0.  Manually fix up any "
"remaining issues, fixing problems until all tests pass again."
msgstr ""
"对你的源代码树运行 ``2to3`` 源代码翻译器。 在 Python 3.0 中运行翻译后的结果。 "
"手动修复任何剩余的问题，一至修复到所有的测试再度通过。"

#: ../../whatsnew/3.0.rst:920
msgid ""
"It is not recommended to try to write source code that runs unchanged under "
"both Python 2.6 and 3.0; you'd have to use a very contorted coding style, "
"e.g. avoiding ``print`` statements, metaclasses, and much more.  If you are "
"maintaining a library that needs to support both Python 2.6 and Python 3.0, "
"the best approach is to modify step 3 above by editing the 2.6 version of "
"the source code and running the ``2to3`` translator again, rather than "
"editing the 3.0 version of the source code."
msgstr ""
"不建议尝试编写可不加修改地同时运行于 Python 2.6 和 3.0 的源代码；你将不得不使用一种非常扭曲的代码风格，例如避免 ``print`` "
"语句、元类和许多其他特性。 如果你正在维护需要同时支持 Python 2.6 和 Python 3.0 的库，最佳做法是将上述的步骤 3 "
"修改为编辑源代码的 2.6 版本并再次运行 ``2to3`` 翻译器，而不是修改源代码的 3.0 版本。"

#: ../../whatsnew/3.0.rst:929
msgid ""
"For porting C extensions to Python 3.0, please see :ref:`cporting-howto`."
msgstr "有关如何将 C 扩展移植到 Python 3.0，请参阅 :ref:`cporting-howto`。"
