# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 18:10+0000\n"
"PO-Revision-Date: 2025-07-18 20:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/3.0.rst:3
msgid "What's New In Python 3.0"
msgstr "Python 3.0 有什么新变化"

#: ../../whatsnew/3.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/3.0.rst:7
msgid "Guido van Rossum"
msgstr "Guido van Rossum"

#: ../../whatsnew/3.0.rst:54
msgid ""
"This article explains the new features in Python 3.0, compared to 2.6. "
"Python 3.0, also known as \"Python 3000\" or \"Py3K\", is the first ever "
"*intentionally backwards incompatible* Python release. Python 3.0 was "
"released on December 3, 2008. There are more changes than in a typical "
"release, and more that are important for all Python users. Nevertheless, "
"after digesting the changes, you'll find that Python really hasn't changed "
"all that much -- by and large, we're mostly fixing well-known annoyances and"
" warts, and removing a lot of old cruft."
msgstr ""
"本文介绍 Python 3.0 与 2.6 相比的新特性。 Python 3.0 也被称为 \"Python 3000\" 或 "
"\"Py3K\"，是有史以来第一个 *有意向下不兼容* 的 Python 版本。 Python 3.0 于 2008 年 12 月 3 日发布。 "
"与一般的发布版本相比，Python 3.0 有更多的变化，而且对所有 Python 用户都很重要。 不过，在理解了这些改动之后，您会发现 Python "
"其实并没有太大的变化 -- 总的来说，我们主要是修复了一些众所周知的问题和缺陷，并删除了许多旧的垃圾。"

#: ../../whatsnew/3.0.rst:63
msgid ""
"This article doesn't attempt to provide a complete specification of all new "
"features, but instead tries to give a convenient overview. For full details,"
" you should refer to the documentation for Python 3.0, and/or the many PEPs "
"referenced in the text. If you want to understand the complete "
"implementation and design rationale for a particular feature, PEPs usually "
"have more details than the regular documentation; but note that PEPs usually"
" are not kept up-to-date once a feature has been fully implemented."
msgstr ""
"本文并不试图提供所有新特性的完整规范，而是试图提供一个方便的概述。 要了解完整的细节，您应该参考 Python 3.0 的文档和/或文中引用的许多 "
"PEP。 如果您想了解某个特性的完整实现和设计原理，PEP 通常比常规文档有更多的细节；但要注意的是，一旦某个特性被完全实现，PEP 通常不会保持更新。"

#: ../../whatsnew/3.0.rst:72
msgid ""
"Due to time constraints this document is not as complete as it should have "
"been.  As always for a new release, the ``Misc/NEWS`` file in the source "
"distribution contains a wealth of detailed information about every small "
"thing that was changed."
msgstr ""
"由于时间有限，本文档不够完整。 对于新发布的版本，源代码发行版中的 ``Misc/NEWS`` 文件总是包含大量关于每一个细小改动的详细信息。"

#: ../../whatsnew/3.0.rst:89
msgid "Common Stumbling Blocks"
msgstr "常见的绊脚石"

#: ../../whatsnew/3.0.rst:91
msgid ""
"This section lists those few changes that are most likely to trip you up if "
"you're used to Python 2.5."
msgstr "本节列出了在你已习惯了 Python 2.5 的情况下最有可能让您感到困惑的几处更改。"

#: ../../whatsnew/3.0.rst:95
msgid "Print Is A Function"
msgstr "Print 是函数"

#: ../../whatsnew/3.0.rst:97
msgid ""
"The ``print`` statement has been replaced with a :func:`print` function, "
"with keyword arguments to replace most of the special syntax of the old "
"``print`` statement (:pep:`3105`).  Examples::"
msgstr ""
"``print`` 语句已被 :func:`print` 函数取代，其关键字参数取代了旧 ``print`` 语句 (:pep:`3105`) "
"的大部分特殊语法。 示例::"

#: ../../whatsnew/3.0.rst:116
msgid "You can also customize the separator between items, e.g.::"
msgstr "你还可以自定义条目间的分隔符，例如 ::"

#: ../../whatsnew/3.0.rst:120
msgid "which produces:"
msgstr "这将产生如下结果:"

#: ../../whatsnew/3.0.rst:126
msgid "Note:"
msgstr "注意"

#: ../../whatsnew/3.0.rst:128
msgid ""
"The :func:`print` function doesn't support the \"softspace\" feature of the "
"old ``print`` statement.  For example, in Python 2.x, ``print \"A\\n\", "
"\"B\"`` would write ``\"A\\nB\\n\"``; but in Python 3.0, ``print(\"A\\n\", "
"\"B\")`` writes ``\"A\\n B\\n\"``."
msgstr ""
":func:`print` 函数不支持旧 ``print`` 语句的 \"softspace\" 功能。例如，在 Python 2.x "
"中，``print \"A\\n\", \"B\"`` 会写入 ``\"A\\nB\\n\"``；但在 Python 3.0 "
"中，``print(\"A\\n\", \"B\")`` 会写入 ``\"A\\n B\\n\"``。"

#: ../../whatsnew/3.0.rst:133
msgid ""
"Initially, you'll be finding yourself typing the old ``print x`` a lot in "
"interactive mode.  Time to retrain your fingers to type ``print(x)`` "
"instead!"
msgstr "最初，您会发现自己在交互模式下经常输入旧的 ``print x`` 。是时候重新训练你的手指以输入 ``print(x)`` 了！"

#: ../../whatsnew/3.0.rst:137
msgid ""
"When using the ``2to3`` source-to-source conversion tool, all ``print`` "
"statements are automatically converted to :func:`print` function calls, so "
"this is mostly a non-issue for larger projects."
msgstr ""
"使用 ``2to3`` 源代码到源代码转换工具时，所有 ``print`` 语句都会自动转换为 :func:`print` "
"函数调用，因此对于大型项目来说，这基本上不是问题。"

#: ../../whatsnew/3.0.rst:143
msgid "Views And Iterators Instead Of Lists"
msgstr "用视图和迭代器取代列表"

#: ../../whatsnew/3.0.rst:145
msgid "Some well-known APIs no longer return lists:"
msgstr "某些知名的 API 将不再返回列表:"

#: ../../whatsnew/3.0.rst:147
msgid ""
":class:`dict` methods :meth:`dict.keys`, :meth:`dict.items` and "
":meth:`dict.values` return \"views\" instead of lists.  For example, this no"
" longer works: ``k = d.keys(); k.sort()``.  Use ``k = sorted(d)`` instead "
"(this works in Python 2.5 too and is just as efficient)."
msgstr ""
":class:`dict` 方法 :meth:`dict.keys`、:meth:`dict.items` 和 :meth:`dict.values` "
"返回 “视图” 而不是列表。 例如，这个写法不再有效: ``k = d.keys(); k.sort()``。 请使用 ``k = "
"sorted(d)`` 代替（这在 Python 2.5 中也有效，而且同样高效）。"

#: ../../whatsnew/3.0.rst:153
msgid ""
"Also, the :meth:`dict.iterkeys`, :meth:`dict.iteritems` and "
":meth:`dict.itervalues` methods are no longer supported."
msgstr ""
"此外，不再支持 :meth:`dict.iterkeys`、:meth:`dict.iteritems` 和 "
":meth:`dict.itervalues` 方法。"

#: ../../whatsnew/3.0.rst:156
msgid ""
":func:`map` and :func:`filter` return iterators.  If you really need a list "
"and the input sequences are all of equal length, a quick fix is to wrap "
":func:`map` in :func:`list`, e.g. ``list(map(...))``, but a better fix is "
"often to use a list comprehension (especially when the original code uses "
":keyword:`lambda`), or rewriting the code so it doesn't need a list at all."
"  Particularly tricky is :func:`map` invoked for the side effects of the "
"function; the correct transformation is to use a regular :keyword:`for` loop"
" (since creating a list would just be wasteful)."
msgstr ""
":func:`map` 和 :func:`filter` 均返回迭代器。 如果你确实需要一个列表并且所有输入序列的长度相等，简单的解决办法是将 "
":func:`map` 包装在 :func:`list` 中，例如 "
"``list(map(...))``，但更好的办法通常是使用列表推导式（特别是当原始代码使用了 :keyword:`lambda` "
"的时候），或是重写代码使得它完全不需要列表。 还有一种特殊技巧是将 :func:`map` 作为函数的附带影响被唤起；正确的转换方式是使用一个常规的 "
":keyword:`for` 循环（因为创建列表会浪费资源）。"

#: ../../whatsnew/3.0.rst:167
msgid ""
"If the input sequences are not of equal length, :func:`map` will stop at the"
" termination of the shortest of the sequences. For full compatibility with "
":func:`map` from Python 2.x, also wrap the sequences in "
":func:`itertools.zip_longest`, e.g. ``map(func, *sequences)`` becomes "
"``list(map(func, itertools.zip_longest(*sequences)))``."
msgstr ""
"如果输入序列的长度不相等，:func:`map` 将在最短序列的终点停止。 为了与 Python 2.x 中的 :func:`map` "
"完全兼容，也可将序列包装在 :func:`itertools.zip_longest` 中，例如将 ``map(func, *sequences)`` "
"变成 ``list(map(func, itertools.zip_longest(*sequences)))``。"

#: ../../whatsnew/3.0.rst:173
msgid ""
":func:`range` now behaves like :func:`xrange` used to behave, except it "
"works with values of arbitrary size.  The latter no longer exists."
msgstr ""
"现在 :func:`range` 的行为与过去 :func:`xrange` 的行为类似，区别在于它可以处理任意大小的值。   后者已不复存在。"

#: ../../whatsnew/3.0.rst:177
msgid ":func:`zip` now returns an iterator."
msgstr ":func:`zip` 现在将返回一个迭代器。"

#: ../../whatsnew/3.0.rst:180
msgid "Ordering Comparisons"
msgstr "排序比较"

#: ../../whatsnew/3.0.rst:182
msgid "Python 3.0 has simplified the rules for ordering comparisons:"
msgstr "Python 3.0 简化了排序比较的规则："

#: ../../whatsnew/3.0.rst:184
msgid ""
"The ordering comparison operators (``<``, ``<=``, ``>=``, ``>``) raise a "
"TypeError exception when the operands don't have a meaningful natural "
"ordering.  Thus, expressions like ``1 < ''``, ``0 > None`` or ``len <= len``"
" are no longer valid, and e.g. ``None < None`` raises :exc:`TypeError` "
"instead of returning ``False``.  A corollary is that sorting a heterogeneous"
" list no longer makes sense -- all the elements must be comparable to each "
"other.  Note that this does not apply to the ``==`` and ``!=`` operators: "
"objects of different incomparable types always compare unequal to each "
"other."
msgstr ""
"当操作数不存在有意义的自然排序时，排序比较操作符 (``<``, ``<=``, ``>=``, ``>``) 会引发 TypeError 异常。 "
"因此，像 ``1 < ''``, ``0 > None`` 或 ``len <= len`` 这样的表达式不再有效，例如 ``None < None``"
" 会引发 :exc:`TypeError` 而不是返回 ``False``。 由此推论，对异构列表进行排序不再有意义 —— 所有元素必须相互可比。 "
"请注意，这不适用于 ``==`` 和 ``!=`` 操作符：不同的不可比类型的对象总是互不相等的。"

#: ../../whatsnew/3.0.rst:195
msgid ""
":meth:`builtin.sorted` and :meth:`list.sort` no longer accept the *cmp* "
"argument providing a comparison function.  Use the *key* argument instead. "
"N.B. the *key* and *reverse* arguments are now \"keyword-only\"."
msgstr ""
":meth:`builtin.sorted` 和 :meth:`list.sort` 不再接受提供比较函数的 *cmp* 参数。 请使用 *key* "
"参数。 注意 *key* 和 *reverse* 参数现在是“仅限关键字”参数。 "

#: ../../whatsnew/3.0.rst:200
msgid ""
"The :func:`cmp` function should be treated as gone, and the :meth:`__cmp__` "
"special method is no longer supported.  Use :meth:`__lt__` for sorting, "
":meth:`__eq__` with :meth:`__hash__`, and other rich comparisons as needed. "
"(If you really need the :func:`cmp` functionality, you could use the "
"expression ``(a > b) - (a < b)`` as the equivalent for ``cmp(a, b)``.)"
msgstr ""
":func:`cmp` 函数应视为已不复存在，而 :meth:`__cmp__` 特殊方法也不再支持。 请使用 :meth:`__lt__` "
"进行排序，使用 :meth:`__eq__` 与 :meth:`__hash__` 进行比较，并根据需要使用其他的丰富比较方法。 （如果确实需要 "
":func:`cmp` 功能，可以使用表达式 ``(a > b) - (a < b)`` 以实现 ``cmp(a, b)``。）"

#: ../../whatsnew/3.0.rst:207
msgid "Integers"
msgstr "整数"

#: ../../whatsnew/3.0.rst:209
msgid ""
":pep:`237`: Essentially, :class:`long` renamed to :class:`int`. That is, "
"there is only one built-in integral type, named :class:`int`; but it behaves"
" mostly like the old :class:`long` type."
msgstr ""
":pep:`237`: 在实质上，:class:`long` 已被重命名为 :class:`int`。 也就是说，现在只有一种内置整数类型，叫做 "
":class:`int`；但其行为更像是旧的 :class:`long` 类型。"

#: ../../whatsnew/3.0.rst:213
msgid ""
":pep:`238`: An expression like ``1/2`` returns a float.  Use ``1//2`` to get"
" the truncating behavior.  (The latter syntax has existed for years, at "
"least since Python 2.2.)"
msgstr ""
":pep:`238`: 像 ``1/2`` 这样的表达式将返回一个浮点数。 请使用 ``1//2`` 来得到取整的行为。 "
"（后面这种语法已存在多年，至少从 Python 2.2 起就有了。）"

#: ../../whatsnew/3.0.rst:217
msgid ""
"The :data:`sys.maxint` constant was removed, since there is no longer a "
"limit to the value of integers.  However, :data:`sys.maxsize` can be used as"
" an integer larger than any practical list or string index.  It conforms to "
"the implementation's \"natural\" integer size and is typically the same as "
":data:`sys.maxint` in previous releases on the same platform (assuming the "
"same build options)."
msgstr ""
":data:`sys.maxint` 常量已被删除，因为整数值不再有限制。 不过，:data:`sys.maxsize` "
"仍可用作大于任何实际列表或字符串索引的整数。 它符合实现的“自然”整数大小，通常与同一平台上以前版本中的 :data:`sys.maxint` "
"相同（假设使用相同的构建选项）。"

#: ../../whatsnew/3.0.rst:224
msgid ""
"The :func:`repr` of a long integer doesn't include the trailing ``L`` "
"anymore, so code that unconditionally strips that character will chop off "
"the last digit instead.  (Use :func:`str` instead.)"
msgstr ""
"长整数的 :func:`repr` 不再包括尾部的 ``L``，因此无条件地删除该字符的代码会删除最后一位数字。 （请使用 :func:`str` "
"代替。）"

#: ../../whatsnew/3.0.rst:228
msgid ""
"Octal literals are no longer of the form ``0720``; use ``0o720`` instead."
msgstr "八进制数字面值不再是 ``0720`` 的形式；而是改用 ``0o720`` 的形式。"

#: ../../whatsnew/3.0.rst:232
msgid "Text Vs. Data Instead Of Unicode Vs. 8-bit"
msgstr "文本与数据而不是 Unicode 与 8 比特位"

#: ../../whatsnew/3.0.rst:234
msgid ""
"Everything you thought you knew about binary data and Unicode has changed."
msgstr "你对二进制数据和 Unicode 的所有认知都已改变。"

#: ../../whatsnew/3.0.rst:237
msgid ""
"Python 3.0 uses the concepts of *text* and (binary) *data* instead of "
"Unicode strings and 8-bit strings.  All text is Unicode; however *encoded* "
"Unicode is represented as binary data.  The type used to hold text is "
":class:`str`, the type used to hold data is :class:`bytes`.  The biggest "
"difference with the 2.x situation is that any attempt to mix text and data "
"in Python 3.0 raises :exc:`TypeError`, whereas if you were to mix Unicode "
"and 8-bit strings in Python 2.x, it would work if the 8-bit string happened "
"to contain only 7-bit (ASCII) bytes, but you would get "
":exc:`UnicodeDecodeError` if it contained non-ASCII values.  This value-"
"specific behavior has caused numerous sad faces over the years."
msgstr ""
"Python 3.0 використовує поняття *текст* і (двійкові) *дані* замість рядків "
"Unicode і 8-бітних рядків. Весь текст є Unicode; однак *закодований* Unicode"
" представлений як двійкові дані. Для зберігання тексту використовується тип "
":class:`str`, а для зберігання даних — :class:`bytes`. Найбільша відмінність"
" із ситуацією 2.x полягає в тому, що будь-яка спроба змішати текст і дані в "
"Python 3.0 викликає :exc:`TypeError`, тоді як якби ви змішали Unicode та "
"8-бітні рядки в Python 2.x, це спрацювало б якщо 8-бітний рядок містив лише "
"7-бітні (ASCII) байти, але ви отримаєте :exc:`UnicodeDecodeError`, якщо він "
"містив значення, відмінні від ASCII. Ця ціннісна поведінка викликала багато "
"сумних облич протягом багатьох років."

#: ../../whatsnew/3.0.rst:250
msgid ""
"As a consequence of this change in philosophy, pretty much all code that "
"uses Unicode, encodings or binary data most likely has to change.  The "
"change is for the better, as in the 2.x world there were numerous bugs "
"having to do with mixing encoded and unencoded text.  To be prepared in "
"Python 2.x, start using :class:`unicode` for all unencoded text, and "
":class:`str` for binary or encoded data only.  Then the ``2to3`` tool will "
"do most of the work for you."
msgstr ""
"Як наслідок цієї зміни у філософії, майже весь код, який використовує "
"Unicode, кодування або двійкові дані, швидше за все, має змінитися. Зміна на"
" краще, оскільки у світі 2.x було багато помилок, пов’язаних зі змішуванням "
"кодованого та незакодованого тексту. Щоб підготуватися до Python 2.x, "
"почніть використовувати :class:`unicode` для всього незакодованого тексту та"
" :class:`str` лише для двійкових або закодованих даних. Тоді інструмент "
"``2to3`` зробить більшу частину роботи за вас."

#: ../../whatsnew/3.0.rst:258
msgid ""
"You can no longer use ``u\"...\"`` literals for Unicode text. However, you "
"must use ``b\"...\"`` literals for binary data."
msgstr "你不能再使用 ``u\"...\"`` 字面值来表示 Unicode 文本。 不过，你必须使用 ``b\"...\"`` 字面值来表示二进制数据。"

#: ../../whatsnew/3.0.rst:261
msgid ""
"As the :class:`str` and :class:`bytes` types cannot be mixed, you must "
"always explicitly convert between them.  Use :meth:`str.encode` to go from "
":class:`str` to :class:`bytes`, and :meth:`bytes.decode` to go from "
":class:`bytes` to :class:`str`.  You can also use ``bytes(s, encoding=...)``"
" and ``str(b, encoding=...)``, respectively."
msgstr ""
"Оскільки типи :class:`str` і :class:`bytes` не можна змішувати, ви завжди "
"повинні явно конвертувати між ними. Використовуйте :meth:`str.encode` для "
"переходу від :class:`str` до :class:`bytes` і :meth:`bytes.decode` для "
"переходу від :class:`bytes` до :class:`str`. Ви також можете використовувати"
" ``bytes(s, encoding=...)`` та ``str(b, encoding=...)`` відповідно."

#: ../../whatsnew/3.0.rst:268
msgid ""
"Like :class:`str`, the :class:`bytes` type is immutable.  There is a "
"separate *mutable* type to hold buffered binary data, :class:`bytearray`.  "
"Nearly all APIs that accept :class:`bytes` also accept :class:`bytearray`.  "
"The mutable API is based on :class:`collections.MutableSequence`."
msgstr ""
"与 :class:`str` 一样，:class:`bytes` 类型是不可变的。 还有一个单独的 *mutable* 类型用于保存缓冲二进制数据，即 "
":class:`bytearray`。 几乎所有接受 :class:`bytes` 的应用程序接口也接受 :class:`bytearray`。 可变 "
"API 基于 :class:`collections.MutableSequence`。"

#: ../../whatsnew/3.0.rst:274
msgid ""
"All backslashes in raw string literals are interpreted literally. This means"
" that ``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated "
"specially.  For example, ``r'\\u20ac'`` is a string of 6 characters in "
"Python 3.0, whereas in 2.6, ``ur'\\u20ac'`` was the single \"euro\" "
"character.  (Of course, this change only affects raw string literals; the "
"euro character is ``'\\u20ac'`` in Python 3.0.)"
msgstr ""
"原始字符串字面中的所有反斜线均按字面解释。 这意味着原始字符串中的 ``'\\U'`` 和 ``'\\u'`` 转义符不会被特殊处理。 例如，在 "
"Python 3.0 中，``r'\\u20ac'`` 是一个包含 6 个字符的字符串，而在 2.6 中，``ur'\\u20ac'`` 是一个 "
"“欧元” 字符。 （当然，这种变化只影响原始字符串的字面意义；在 Python 3.0 中，欧元字符是 ``'\\u20ac'``。）"

#: ../../whatsnew/3.0.rst:281
msgid ""
"The built-in :class:`basestring` abstract type was removed.  Use "
":class:`str` instead.  The :class:`str` and :class:`bytes` types don't have "
"functionality enough in common to warrant a shared base class.  The ``2to3``"
" tool (see below) replaces every occurrence of :class:`basestring` with "
":class:`str`."
msgstr ""
"内置的 :class:`basestring` 抽象类型已被移除，请使用 :class:`str` 代替。 :class:`str` 和 "
":class:`bytes` 类型在功能上没有足够的共通性，因此不需要共享基类。 ``2to3`` 工具（见下文）用 :class:`str` "
"替换了每一个 :class:`basestring`。"

#: ../../whatsnew/3.0.rst:287
msgid ""
"Files opened as text files (still the default mode for :func:`open`) always "
"use an encoding to map between strings (in memory) and bytes (on disk).  "
"Binary files (opened with a ``b`` in the mode argument) always use bytes in "
"memory.  This means that if a file is opened using an incorrect mode or "
"encoding, I/O will likely fail loudly, instead of silently producing "
"incorrect data.  It also means that even Unix users will have to specify the"
" correct mode (text or binary) when opening a file.  There is a platform-"
"dependent default encoding, which on Unixy platforms can be set with the "
"``LANG`` environment variable (and sometimes also with some other platform-"
"specific locale-related environment variables).  In many cases, but not all,"
" the system default is UTF-8; you should never count on this default.  Any "
"application reading or writing more than pure ASCII text should probably "
"have a way to override the encoding. There is no longer any need for using "
"the encoding-aware streams in the :mod:`codecs` module."
msgstr ""
"Файли, відкриті як текстові файли (досі стандартний режим для :func:`open`),"
" завжди використовують кодування для відображення між рядками (у пам’яті) та"
" байтами (на диску). Двійкові файли (відкриті за допомогою ``b`` в аргументі"
" mode) завжди використовують байти в пам’яті. Це означає, що якщо файл "
"відкрито з використанням неправильного режиму або кодування, введення-"
"виведення, ймовірно, голосно завершиться помилкою, замість того, щоб мовчки "
"видати неправильні дані. Це також означає, що навіть користувачі Unix "
"повинні будуть вказати правильний режим (текстовий або двійковий) під час "
"відкриття файлу. Існує залежне від платформи кодування за замовчуванням, яке"
" на платформах Unixy можна встановити за допомогою змінної середовища "
"``LANG`` (і іноді також за допомогою деяких інших змінних середовища, "
"пов’язаних із місцевими стандартами). У багатьох випадках, але не у всіх, "
"системою за замовчуванням є UTF-8; ви ніколи не повинні розраховувати на це "
"замовчування. Будь-яка програма, яка читає або записує більше ніж чистий "
"текст ASCII, ймовірно, повинна мати спосіб заміни кодування. Більше немає "
"необхідності використовувати потоки з урахуванням кодування в модулі "
":mod:`codecs`."

#: ../../whatsnew/3.0.rst:304
msgid ""
"The initial values of :data:`sys.stdin`, :data:`sys.stdout` and "
":data:`sys.stderr` are now unicode-only text files (i.e., they are instances"
" of :class:`io.TextIOBase`).  To read and write bytes data with these "
"streams, you need to use their :data:`io.TextIOBase.buffer` attribute."
msgstr ""
":data:`sys.stdin`、:data:`sys.stdout` 和 :data:`sys.stderr` 的初始值现在是仅 Unicode "
"的文本文件（即它们是 :class:`io.TextIOBase` 的实例）。 要使用这些数据流读写字节数据，需要使用它们的 "
":data:`io.TextIOBase.buffer` 属性。"

#: ../../whatsnew/3.0.rst:310
msgid ""
"Filenames are passed to and returned from APIs as (Unicode) strings. This "
"can present platform-specific problems because on some platforms filenames "
"are arbitrary byte strings.  (On the other hand, on Windows filenames are "
"natively stored as Unicode.)  As a work-around, most APIs (e.g. :func:`open`"
" and many functions in the :mod:`os` module) that take filenames accept "
":class:`bytes` objects as well as strings, and a few APIs have a way to ask "
"for a :class:`bytes` return value.  Thus, :func:`os.listdir` returns a list "
"of :class:`bytes` instances if the argument is a :class:`bytes` instance, "
"and :func:`os.getcwdb` returns the current working directory as a "
":class:`bytes` instance.  Note that when :func:`os.listdir` returns a list "
"of strings, filenames that cannot be decoded properly are omitted rather "
"than raising :exc:`UnicodeError`."
msgstr ""
"Імена файлів передаються та повертаються з API як рядки (Unicode). Це може "
"спричинити проблеми, пов’язані з певною платформою, оскільки на деяких "
"платформах імена файлів є довільними рядками байтів. (З іншого боку, у "
"Windows імена файлів зберігаються у форматі Юнікод.) Як обхідний шлях, "
"більшість API (наприклад, :func:`open` і багато функцій у модулі :mod:`os`),"
" які приймають імена файлів, приймають: об’єкти :class:`bytes`, а також "
"рядки, а кілька API мають спосіб запитувати значення, що повертається "
":class:`bytes`. Таким чином, :func:`os.listdir` повертає список екземплярів "
":class:`bytes`, якщо аргумент є екземпляром :class:`bytes`, а "
":func:`os.getcwdb` повертає поточний робочий каталог як екземпляр "
":class:`bytes`. Зауважте, що коли :func:`os.listdir` повертає список рядків,"
" імена файлів, які не можна правильно розшифрувати, пропускаються, а не "
"викликають :exc:`UnicodeError`."

#: ../../whatsnew/3.0.rst:325
msgid ""
"Some system APIs like :data:`os.environ` and :data:`sys.argv` can also "
"present problems when the bytes made available by the system is not "
"interpretable using the default encoding.  Setting the ``LANG`` variable and"
" rerunning the program is probably the best approach."
msgstr ""
"当系统提供的字节无法使用默认编码进行解释时，一些系统 API，如 :data:`os.environ` 和 "
":data:`sys.argv`，也会出现问题。 最好的办法可能是设置 ``LANG`` 变量并重新运行程序。"

#: ../../whatsnew/3.0.rst:330
msgid ""
":pep:`3138`: The :func:`repr` of a string no longer escapes non-ASCII "
"characters.  It still escapes control characters and code points with non-"
"printable status in the Unicode standard, however."
msgstr ""
":pep:`3138`: 字符串的 :func:`repr` 将不再转义非 ASCII 字符。 不过，它仍然会转义控制字符和在 Unicode "
"标准中具有不可打印状态的码位。"

#: ../../whatsnew/3.0.rst:334
msgid ":pep:`3120`: The default source encoding is now UTF-8."
msgstr ":pep:`3120`：现在默认的源码编码格式是UTF-8。"

#: ../../whatsnew/3.0.rst:336
msgid ""
":pep:`3131`: Non-ASCII letters are now allowed in identifiers. (However, the"
" standard library remains ASCII-only with the exception of contributor names"
" in comments.)"
msgstr ""
":pep:`3131`: 现在允许在标识符中使用非 ASCII 字符（不过，标准库中的异常和注释中的贡献者名字仍然只使用 ASCII 字符）。"

#: ../../whatsnew/3.0.rst:340
msgid ""
"The :mod:`StringIO` and :mod:`cStringIO` modules are gone.  Instead, import "
"the :mod:`io` module and use :class:`io.StringIO` or :class:`io.BytesIO` for"
" text and data respectively."
msgstr ""

#: ../../whatsnew/3.0.rst:344
msgid "See also the :ref:`unicode-howto`, which was updated for Python 3.0."
msgstr "另请参阅 :ref:`unicode-howto`，其内容已针对 Python 3.0 进行更新。"

#: ../../whatsnew/3.0.rst:348
msgid "Overview Of Syntax Changes"
msgstr "语法变化概述"

#: ../../whatsnew/3.0.rst:350
msgid ""
"This section gives a brief overview of every *syntactic* change in Python "
"3.0."
msgstr "本节提供了 Python 3.0 中每个 *语法* 变化的简要说明。"

#: ../../whatsnew/3.0.rst:354
msgid "New Syntax"
msgstr "新语法"

#: ../../whatsnew/3.0.rst:356
msgid ""
":pep:`3107`: Function argument and return value annotations.  This provides "
"a standardized way of annotating a function's parameters and return value.  "
"There are no semantics attached to such annotations except that they can be "
"introspected at runtime using the :attr:`__annotations__` attribute.  The "
"intent is to encourage experimentation through metaclasses, decorators or "
"frameworks."
msgstr ""
":pep:`3107`: Аргумент функції та анотації значення, що повертається. Це "
"забезпечує стандартизований спосіб анотування параметрів функції та "
"значення, що повертається. Немає жодної семантики, пов’язаної з такими "
"анотаціями, за винятком того, що їх можна перевірити під час виконання за "
"допомогою атрибута :attr:`__annotations__`. Мета полягає в тому, щоб "
"заохотити експериментувати за допомогою метакласів, декораторів або "
"фреймворків."

#: ../../whatsnew/3.0.rst:363
msgid ""
":pep:`3102`: Keyword-only arguments.  Named parameters occurring after "
"``*args`` in the parameter list *must* be specified using keyword syntax in "
"the call.  You can also use a bare ``*`` in the parameter list to indicate "
"that you don't accept a variable-length argument list, but you do have "
"keyword-only arguments."
msgstr ""
":pep:`3102`：仅限关键字参数。在参数列表``*args`` 之后出现的命名参数 *必须* "
"在调用中使用关键字语法指定。也可以在参数列表中使用``*``来表示不接受长度可变的参数列表，但可以使用只包含关键字的参数。"

#: ../../whatsnew/3.0.rst:369
msgid ""
"Keyword arguments are allowed after the list of base classes in a class "
"definition.  This is used by the new convention for specifying a metaclass "
"(see next section), but can be used for other purposes as well, as long as "
"the metaclass supports it."
msgstr "类定义中的基类列表后允许使用关键字参数。  这是用于指定元类的新约定（见下一节），但也可用于其他目的，只要元类支持它。"

#: ../../whatsnew/3.0.rst:374
msgid ""
":pep:`3104`: :keyword:`nonlocal` statement.  Using ``nonlocal x`` you can "
"now assign directly to a variable in an outer (but non-global) scope.  "
":keyword:`!nonlocal` is a new reserved word."
msgstr ""
":pep:`3104`: :keyword:`nonlocal` оператор. Використовуючи ``nonlocal x``, "
"тепер ви можете призначати безпосередньо змінній у зовнішній (але не "
"глобальній) області. :keyword:`!nonlocal` — нове зарезервоване слово."

#: ../../whatsnew/3.0.rst:378
msgid ""
":pep:`3132`: Extended Iterable Unpacking.  You can now write things like "
"``a, b, *rest = some_sequence``.  And even ``*rest, a = stuff``.  The "
"``rest`` object is always a (possibly empty) list; the right-hand side may "
"be any iterable.  Example::"
msgstr ""
":pep:`3132`: Розширене ітераційне розпакування. Тепер ви можете писати такі "
"речі, як ``a, b, *rest = some_sequence``. І навіть ``*rest, a = stuff``. "
"Об'єкт ``rest`` завжди є (можливо, порожнім) списком; права частина може "
"бути будь-якою ітерованою. Приклад::"

#: ../../whatsnew/3.0.rst:385
msgid "This sets *a* to ``0``, *b* to ``4``, and *rest* to ``[1, 2, 3]``."
msgstr "Це встановлює *a* на ``0``, *b* на ``4``, а *rest* на ``[1, 2, 3]``."

#: ../../whatsnew/3.0.rst:387
msgid ""
"Dictionary comprehensions: ``{k: v for k, v in stuff}`` means the same thing"
" as ``dict(stuff)`` but is more flexible.  (This is :pep:`274` vindicated. "
":-)"
msgstr ""
"Розуміння словника: ``{k: v for k, v in stuff}`` означає те саме, що "
"``dict(stuff)``, але є більш гнучким. (Це :pep:`274` підтверджено. :-)"

#: ../../whatsnew/3.0.rst:391
msgid ""
"Set literals, e.g. ``{1, 2}``.  Note that ``{}`` is an empty dictionary; use"
" ``set()`` for an empty set.  Set comprehensions are also supported; e.g., "
"``{x for x in stuff}`` means the same thing as ``set(stuff)`` but is more "
"flexible."
msgstr ""
"Встановіть літерали, напр. ``{1, 2}``. Зауважте, що ``{}`` є порожнім "
"словником; використовуйте ``set()`` для порожнього набору. Також "
"підтримується розуміння набору; наприклад, ``{x for x in stuff}`` означає те"
" саме, що ``set(stuff)``, але є більш гнучким."

#: ../../whatsnew/3.0.rst:396
msgid ""
"New octal literals, e.g. ``0o720`` (already in 2.6).  The old octal literals"
" (``0720``) are gone."
msgstr ""
"Нові вісімкові літерали, напр. ``0o720`` (вже у 2.6). Старі вісімкові "
"літерали (``0720``) зникли."

#: ../../whatsnew/3.0.rst:399
msgid ""
"New binary literals, e.g. ``0b1010`` (already in 2.6), and there is a new "
"corresponding built-in function, :func:`bin`."
msgstr ""
"Нові бінарні літерали, напр. ``0b1010`` (вже у 2.6), і є нова відповідна "
"вбудована функція, :func:`bin`."

#: ../../whatsnew/3.0.rst:402
msgid ""
"Bytes literals are introduced with a leading ``b`` or ``B``, and there is a "
"new corresponding built-in function, :func:`bytes`."
msgstr ""
"Байтові літерали представлено з ``b`` або ``B`` на початку, і є нова "
"відповідна вбудована функція, :func:`bytes`."

#: ../../whatsnew/3.0.rst:406
msgid "Changed Syntax"
msgstr "语法变化"

#: ../../whatsnew/3.0.rst:408
msgid ""
":pep:`3109` and :pep:`3134`: new :keyword:`raise` statement syntax: "
":samp:`raise [{expr} [from {expr}]]`.  See below."
msgstr ""
":pep:`3109` 和 :pep:`3134`: 新增 :keyword:`raise` 语句的语法: :samp:`raise [{expr} "
"[from {expr}]]`。 见下文。"

#: ../../whatsnew/3.0.rst:411
msgid ""
":keyword:`!as` and :keyword:`with` are now reserved words.  (Since 2.6, "
"actually.)"
msgstr "现在 :keyword:`!as` 和 :keyword:`with` 是保留关键字。 （实际是从 2.6 开始。）"

#: ../../whatsnew/3.0.rst:414
msgid ""
"``True``, ``False``, and ``None`` are reserved words.  (2.6 partially "
"enforced the restrictions on ``None`` already.)"
msgstr "``True``, ``False`` 和 ``None`` 已成为保留关键字。 （2.6 已经对 ``None`` 部分强制应用限制。）"

#: ../../whatsnew/3.0.rst:417
msgid ""
"Change from :keyword:`except` *exc*, *var* to :keyword:`!except` *exc* "
":keyword:`!as` *var*.  See :pep:`3110`."
msgstr ""
"将 :keyword:`except` *exc*, *var* 改为 :keyword:`!except` *exc* :keyword:`!as` "
"*var*。 参见 :pep:`3110`。"

#: ../../whatsnew/3.0.rst:420
msgid ":pep:`3115`: New Metaclass Syntax.  Instead of::"
msgstr ":pep:`3115`: 新的元类语法。 替换::"

#: ../../whatsnew/3.0.rst:426
msgid "you must now use::"
msgstr "你现在需要使用::"

#: ../../whatsnew/3.0.rst:431
msgid ""
"The module-global :data:`__metaclass__` variable is no longer supported.  "
"(It was a crutch to make it easier to default to new-style classes without "
"deriving every class from :class:`object`.)"
msgstr ""
"不再支持全局模块变量 :data:`__metaclass__`。  (它是一个“拐杖”，可以使默认使用新风格类变得更容易，而无需从 "
":class:`object` 派生每个类。）"

#: ../../whatsnew/3.0.rst:436
msgid ""
"List comprehensions no longer support the syntactic form :samp:`[... for "
"{var} in {item1}, {item2}, ...]`.  Use :samp:`[... for {var} in ({item1}, "
"{item2}, ...)]` instead. Also note that list comprehensions have different "
"semantics: they are closer to syntactic sugar for a generator expression "
"inside a :func:`list` constructor, and in particular the loop control "
"variables are no longer leaked into the surrounding scope."
msgstr ""
"Розуміння списків більше не підтримує синтаксичну форму :samp:`[... для "
"{var} в {item1}, {item2}, ...]`. Замість цього використовуйте :samp:`[... "
"для {var} в ({item1}, {item2}, ...)]`. Також зауважте, що розуміння списків "
"має іншу семантику: вони ближчі до синтаксичного цукру для виразу генератора"
" всередині конструктора :func:`list`, і, зокрема, керуючі змінні циклу "
"більше не просочуються в навколишню область."

#: ../../whatsnew/3.0.rst:444
msgid ""
"The *ellipsis* (``...``) can be used as an atomic expression anywhere.  "
"(Previously it was only allowed in slices.)  Also, it *must* now be spelled "
"as ``...``.  (Previously it could also be spelled as ``. . .``, by a mere "
"accident of the grammar.)"
msgstr ""
"*ellipsis* (``...``) 可以在任何地方作为原子表达式使用。（以前只允许在片段中使用。）另外，现在 *必须* 拼写为``...`` "
"。（以前也可以拼写为``. . .`` ，这只是一个偶然的语法。）"

#: ../../whatsnew/3.0.rst:450
msgid "Removed Syntax"
msgstr "移除的语法"

#: ../../whatsnew/3.0.rst:452
msgid ""
":pep:`3113`: Tuple parameter unpacking removed.  You can no longer write "
"``def foo(a, (b, c)): ...``. Use ``def foo(a, b_c): b, c = b_c`` instead."
msgstr ""
":pep:`3113`: вилучено розпакування параметрів кортежу. Ви більше не можете "
"писати ``def foo(a, (b, c)): ...``. Замість цього використовуйте ``def "
"foo(a, b_c): b, c = b_c``."

#: ../../whatsnew/3.0.rst:456
msgid "Removed backticks (use :func:`repr` instead)."
msgstr ""
"Видалено зворотні галочки (замість цього використовуйте :func:`repr`)."

#: ../../whatsnew/3.0.rst:458
msgid "Removed ``<>`` (use ``!=`` instead)."
msgstr "Видалено ``<>`` (замість цього використовуйте ``!=``)."

#: ../../whatsnew/3.0.rst:460
msgid ""
"Removed keyword: :func:`exec` is no longer a keyword; it remains as a "
"function.  (Fortunately the function syntax was also accepted in 2.x.)  Also"
" note that :func:`exec` no longer takes a stream argument; instead of "
"``exec(f)`` you can use ``exec(f.read())``."
msgstr ""
"Видалено ключове слово: :func:`exec` більше не є ключовим словом; воно "
"залишається як функція. (На щастя, синтаксис функції також був прийнятий у "
"2.x.) Також зауважте, що :func:`exec` більше не приймає аргумент потоку; "
"замість ``exec(f)`` ви можете використовувати ``exec(f.read())``."

#: ../../whatsnew/3.0.rst:465
msgid "Integer literals no longer support a trailing ``l`` or ``L``."
msgstr "Цілі літерали більше не підтримують кінцеві ``l`` або ``L``."

#: ../../whatsnew/3.0.rst:467
msgid "String literals no longer support a leading ``u`` or ``U``."
msgstr "Рядкові літерали більше не підтримують початок ``u`` або ``U``."

#: ../../whatsnew/3.0.rst:469
msgid ""
"The :keyword:`from` *module* :keyword:`import` ``*`` syntax is only allowed "
"at the module level, no longer inside functions."
msgstr ""
"Синтаксис :keyword:`from` *module* :keyword:`import` ``*`` дозволений лише "
"на рівні модуля, більше не всередині функцій."

#: ../../whatsnew/3.0.rst:472
msgid ""
"The only acceptable syntax for relative imports is :samp:`from .[{module}] "
"import {name}`.  All :keyword:`import` forms not starting with ``.`` are "
"interpreted as absolute imports.  (:pep:`328`)"
msgstr ""
"Єдиним прийнятним синтаксисом для відносного імпорту є :samp:`from "
".[{module}] import {name}`. Усі форми :keyword:`import`, які не починаються "
"з ``.``, інтерпретуються як абсолютні імпорти. (:pep:`328`)"

#: ../../whatsnew/3.0.rst:476
msgid "Classic classes are gone."
msgstr "Класичні заняття зникли."

#: ../../whatsnew/3.0.rst:480
msgid "Changes Already Present In Python 2.6"
msgstr "Зміни вже присутні в Python 2.6"

#: ../../whatsnew/3.0.rst:482
msgid ""
"Since many users presumably make the jump straight from Python 2.5 to Python"
" 3.0, this section reminds the reader of new features that were originally "
"designed for Python 3.0 but that were back-ported to Python 2.6.  The "
"corresponding sections in :ref:`whats-new-in-2.6` should be consulted for "
"longer descriptions."
msgstr ""
"Оскільки багато користувачів, ймовірно, переходять прямо з Python 2.5 на "
"Python 3.0, цей розділ нагадує читачеві про нові функції, які спочатку були "
"розроблені для Python 3.0, але які були перенесені на Python 2.6. Додаткові "
"описи можна знайти у відповідних розділах :ref:`whats-new-in-2.6`."

#: ../../whatsnew/3.0.rst:488
msgid ""
":ref:`pep-0343`.  The :keyword:`with` statement is now a standard feature "
"and no longer needs to be imported from the :mod:`__future__`. Also check "
"out :ref:`new-26-context-managers` and :ref:`new-module-contextlib`."
msgstr ""
":ref:`pep-0343`. Оператор :keyword:`with` тепер є стандартною функцією, і "
"його більше не потрібно імпортувати з :mod:`__future__`. Також перегляньте "
":ref:`new-26-context-managers` і :ref:`new-module-contextlib`."

#: ../../whatsnew/3.0.rst:493
msgid ""
":ref:`pep-0366`.  This enhances the usefulness of the :option:`-m` option "
"when the referenced module lives in a package."
msgstr ""
":ref:`pep-0366`. Це підвищує корисність опції :option:`-m`, коли модуль, на "
"який посилається, живе в пакеті."

#: ../../whatsnew/3.0.rst:496
msgid ":ref:`pep-0370`."
msgstr ":ref:`pep-0370`."

#: ../../whatsnew/3.0.rst:498
msgid ":ref:`pep-0371`."
msgstr ":ref:`pep-0371`."

#: ../../whatsnew/3.0.rst:500
msgid ""
":ref:`pep-3101`.  Note: the 2.6 description mentions the :meth:`format` "
"method for both 8-bit and Unicode strings.  In 3.0, only the :class:`str` "
"type (text strings with Unicode support) supports this method; the "
":class:`bytes` type does not.  The plan is to eventually make this the only "
"API for string formatting, and to start deprecating the ``%`` operator in "
"Python 3.1."
msgstr ""
":ref:`pep-3101`. Примітка: в описі 2.6 згадується метод :meth:`format` як "
"для 8-бітних рядків, так і для рядків Unicode. У версії 3.0 тільки тип "
":class:`str` (текстові рядки з підтримкою Unicode) підтримує цей метод; тип "
":class:`bytes` не має. План полягає в тому, щоб згодом зробити це єдиним API"
" для форматування рядків і почати не підтримувати оператор ``%`` у Python "
"3.1."

#: ../../whatsnew/3.0.rst:507
msgid ""
":ref:`pep-3105`.  This is now a standard feature and no longer needs to be "
"imported from :mod:`__future__`.  More details were given above."
msgstr ""
":ref:`pep-3105`. Тепер це стандартна функція, і її більше не потрібно "
"імпортувати з :mod:`__future__`. Детальніше було наведено вище."

#: ../../whatsnew/3.0.rst:510
msgid ""
":ref:`pep-3110`.  The :keyword:`except` *exc* :keyword:`!as` *var* syntax is"
" now standard and :keyword:`!except` *exc*, *var* is no longer supported.  "
"(Of course, the :keyword:`!as` *var* part is still optional.)"
msgstr ""
":ref:`pep-3110`. Синтаксис :keyword:`except` *exc* :keyword:`!as` *var* "
"тепер є стандартним, а :keyword:`!except` *exc*, *var* більше не "
"підтримується. (Звичайно, частина :keyword:`!as` *var* все ще "
"необов’язкова.)"

#: ../../whatsnew/3.0.rst:515
msgid ""
":ref:`pep-3112`.  The ``b\"...\"`` string literal notation (and its variants"
" like ``b'...'``, ``b\"\"\"...\"\"\"``, and ``br\"...\"``) now produces a "
"literal of type :class:`bytes`."
msgstr ""
":ref:`pep-3112`. Нотація рядкового літералу ``b\"...\"`` (і його варіанти, "
"такі як ``b'...'``, ``b\"\"\"...\"\"\"`` і ``br\" ...\"``) тепер створює "
"літерал типу :class:`bytes`."

#: ../../whatsnew/3.0.rst:519
msgid ""
":ref:`pep-3116`.  The :mod:`io` module is now the standard way of doing file"
" I/O.  The built-in :func:`open` function is now an alias for "
":func:`io.open` and has additional keyword arguments *encoding*, *errors*, "
"*newline* and *closefd*.  Also note that an invalid *mode* argument now "
"raises :exc:`ValueError`, not :exc:`IOError`.  The binary file object "
"underlying a text file object can be accessed as :attr:`f.buffer` (but "
"beware that the text object maintains a buffer of itself in order to speed "
"up the encoding and decoding operations)."
msgstr ""
":ref:`pep-3116`: :mod:`io` 模块现在是进行文件输入/输出的标准方法。 内置的 :func:`open` 函数现在是 "
":func:`io.open` 的别名，并增加了 *encoding*、*errors*、*newline* 和 *closefd* 等关键字参数。 "
"还要注意的是，无效的 *mode* 参数现在会引发 :exc:`ValueError`，而不是 :exc:`IOError`。 "
"文本文件对象底层的二进制文件对象可以像 :attr:`f.buffer` 一样访问（但要注意，文本对象会为自己保留一个缓冲区，以加快编码和解码操作。）"

#: ../../whatsnew/3.0.rst:529
msgid ""
":ref:`pep-3118`.  The old builtin :func:`buffer` is now really gone; the new"
" builtin :func:`memoryview` provides (mostly) similar functionality."
msgstr ""
":ref:`pep-3118`. Старий вбудований :func:`buffer` тепер справді зник; новий "
"вбудований :func:`memoryview` забезпечує (в основному) подібну "
"функціональність."

#: ../../whatsnew/3.0.rst:533
msgid ""
":ref:`pep-3119`.  The :mod:`abc` module and the ABCs defined in the "
":mod:`collections` module plays a somewhat more prominent role in the "
"language now, and built-in collection types like :class:`dict` and "
":class:`list` conform to the :class:`collections.MutableMapping` and "
":class:`collections.MutableSequence` ABCs, respectively."
msgstr ""
":ref:`pep-3119`. Модуль :mod:`abc` і ABC, визначені в модулі "
":mod:`collections`, тепер відіграють дещо помітнішу роль у мові, а також "
"такі вбудовані типи колекцій, як :class:`dict` і :class:`list` відповідає "
"ABC :class:`collections.MutableMapping` і "
":class:`collections.MutableSequence` відповідно."

#: ../../whatsnew/3.0.rst:539
msgid ""
":ref:`pep-3127`.  As mentioned above, the new octal literal notation is the "
"only one supported, and binary literals have been added."
msgstr ""
":ref:`pep-3127`. Як згадувалося вище, нова нотація вісімкових літералів є "
"єдиною, що підтримується, і додано двійкові літерали."

#: ../../whatsnew/3.0.rst:543
msgid ":ref:`pep-3129`."
msgstr ":ref:`pep-3129`."

#: ../../whatsnew/3.0.rst:545
msgid ""
":ref:`pep-3141`.  The :mod:`numbers` module is another new use of ABCs, "
"defining Python's \"numeric tower\".  Also note the new :mod:`fractions` "
"module which implements :class:`numbers.Rational`."
msgstr ""
":ref:`pep-3141`. Модуль :mod:`numbers` є ще одним новим використанням ABC, "
"що визначає \"числову вежу\" Python. Також зверніть увагу на новий модуль "
":mod:`fractions`, який реалізує :class:`numbers.Rational`."

#: ../../whatsnew/3.0.rst:551
msgid "Library Changes"
msgstr "库的修改"

#: ../../whatsnew/3.0.rst:553
msgid ""
"Due to time constraints, this document does not exhaustively cover the very "
"extensive changes to the standard library.  :pep:`3108` is the reference for"
" the major changes to the library.  Here's a capsule review:"
msgstr ""
"Через обмеження часу цей документ не вичерпно охоплює дуже великі зміни "
"стандартної бібліотеки. :pep:`3108` є посиланням на основні зміни в "
"бібліотеці. Ось огляд капсули:"

#: ../../whatsnew/3.0.rst:558
msgid ""
"Many old modules were removed.  Some, like :mod:`gopherlib` (no longer used)"
" and :mod:`md5` (replaced by :mod:`hashlib`), were already deprecated by "
":pep:`4`.  Others were removed as a result of the removal of support for "
"various platforms such as Irix, BeOS and Mac OS 9 (see :pep:`11`).  Some "
"modules were also selected for removal in Python 3.0 due to lack of use or "
"because a better replacement exists.  See :pep:`3108` for an exhaustive "
"list."
msgstr ""

#: ../../whatsnew/3.0.rst:566
msgid ""
"The :mod:`bsddb3` package was removed because its presence in the core "
"standard library has proved over time to be a particular burden for the core"
" developers due to testing instability and Berkeley DB's release schedule.  "
"However, the package is alive and well, externally maintained at "
"https://www.jcea.es/programacion/pybsddb.htm."
msgstr ""

#: ../../whatsnew/3.0.rst:572
msgid ""
"Some modules were renamed because their old name disobeyed :pep:`8`, or for "
"various other reasons.  Here's the list:"
msgstr ""
"Деякі модулі були перейменовані через те, що їхня стара назва не відповідала"
" :pep:`8`, або з інших причин. Ось список:"

#: ../../whatsnew/3.0.rst:576
msgid "Old Name"
msgstr "旧名称"

#: ../../whatsnew/3.0.rst:576
msgid "New Name"
msgstr "新名称"

#: ../../whatsnew/3.0.rst:578
msgid "_winreg"
msgstr "_winreg"

#: ../../whatsnew/3.0.rst:578
msgid "winreg"
msgstr "winreg"

#: ../../whatsnew/3.0.rst:579
msgid "ConfigParser"
msgstr "ConfigParser"

#: ../../whatsnew/3.0.rst:579
msgid "configparser"
msgstr "configparser"

#: ../../whatsnew/3.0.rst:580
msgid "copy_reg"
msgstr "copy_reg"

#: ../../whatsnew/3.0.rst:580
msgid "copyreg"
msgstr "copyreg"

#: ../../whatsnew/3.0.rst:581
msgid "Queue"
msgstr "Queue"

#: ../../whatsnew/3.0.rst:581
msgid "queue"
msgstr "queue"

#: ../../whatsnew/3.0.rst:582
msgid "SocketServer"
msgstr "SocketServer"

#: ../../whatsnew/3.0.rst:582
msgid "socketserver"
msgstr "socketserver"

#: ../../whatsnew/3.0.rst:583
msgid "markupbase"
msgstr "markupbase"

#: ../../whatsnew/3.0.rst:583
msgid "_markupbase"
msgstr "_markupbase"

#: ../../whatsnew/3.0.rst:584
msgid "repr"
msgstr "repr"

#: ../../whatsnew/3.0.rst:584
msgid "reprlib"
msgstr "reprlib"

#: ../../whatsnew/3.0.rst:585
msgid "test.test_support"
msgstr "test.test_support"

#: ../../whatsnew/3.0.rst:585
msgid "test.support"
msgstr "test.support"

#: ../../whatsnew/3.0.rst:588
msgid ""
"A common pattern in Python 2.x is to have one version of a module "
"implemented in pure Python, with an optional accelerated version implemented"
" as a C extension; for example, :mod:`pickle` and :mod:`cPickle`.  This "
"places the burden of importing the accelerated version and falling back on "
"the pure Python version on each user of these modules.  In Python 3.0, the "
"accelerated versions are considered implementation details of the pure "
"Python versions. Users should always import the standard version, which "
"attempts to import the accelerated version and falls back to the pure Python"
" version.  The :mod:`pickle` / :mod:`cPickle` pair received this treatment."
"  The :mod:`profile` module is on the list for 3.1.  The :mod:`StringIO` "
"module has been turned into a class in the :mod:`io` module."
msgstr ""

#: ../../whatsnew/3.0.rst:602
msgid ""
"Some related modules have been grouped into packages, and usually the "
"submodule names have been simplified.  The resulting new packages are:"
msgstr ""
"Деякі пов’язані модулі були згруповані в пакети, і зазвичай назви підмодулів"
" були спрощені. Отримані нові пакети:"

#: ../../whatsnew/3.0.rst:606
msgid ""
":mod:`dbm` (:mod:`anydbm`, :mod:`dbhash`, :mod:`dbm`, :mod:`dumbdbm`, "
":mod:`gdbm`, :mod:`whichdb`)."
msgstr ""

#: ../../whatsnew/3.0.rst:609
msgid ":mod:`html` (:mod:`HTMLParser`, :mod:`htmlentitydefs`)."
msgstr ""

#: ../../whatsnew/3.0.rst:611
msgid ""
":mod:`http` (:mod:`httplib`, :mod:`BaseHTTPServer`, :mod:`CGIHTTPServer`, "
":mod:`SimpleHTTPServer`, :mod:`Cookie`, :mod:`cookielib`)."
msgstr ""

#: ../../whatsnew/3.0.rst:615
msgid ""
":mod:`tkinter` (all :mod:`Tkinter`-related modules except :mod:`turtle`).  "
"The target audience of :mod:`turtle` doesn't really care about "
":mod:`tkinter`.  Also note that as of Python 2.6, the functionality of "
":mod:`turtle` has been greatly enhanced."
msgstr ""
":mod:`tkinter` (усі пов’язані з :mod:`Tkinter` модулі, крім :mod:`turtle`). "
"Цільова аудиторія :mod:`turtle` не дуже дбає про :mod:`tkinter`. Також "
"зауважте, що починаючи з Python 2.6, функціональність :mod:`turtle` була "
"значно розширена."

#: ../../whatsnew/3.0.rst:620
msgid ""
":mod:`urllib` (:mod:`urllib`, :mod:`urllib2`, :mod:`urlparse`, "
":mod:`robotparse`)."
msgstr ""

#: ../../whatsnew/3.0.rst:623
msgid ""
":mod:`xmlrpc` (:mod:`xmlrpclib`, :mod:`DocXMLRPCServer`, "
":mod:`SimpleXMLRPCServer`)."
msgstr ""

#: ../../whatsnew/3.0.rst:626
msgid ""
"Some other changes to standard library modules, not covered by :pep:`3108`:"
msgstr ""
"Деякі інші зміни до модулів стандартної бібліотеки, не охоплені :pep:`3108`:"

#: ../../whatsnew/3.0.rst:629
msgid "Killed :mod:`sets`.  Use the built-in :func:`set` class."
msgstr ""

#: ../../whatsnew/3.0.rst:631
msgid ""
"Cleanup of the :mod:`sys` module: removed :func:`sys.exitfunc`, "
":func:`sys.exc_clear`, :data:`sys.exc_type`, :data:`sys.exc_value`, "
":data:`sys.exc_traceback`.  (Note that :data:`sys.last_type` etc. remain.)"
msgstr ""
"Очищення модуля :mod:`sys`: видалено :func:`sys.exitfunc`, "
":func:`sys.exc_clear`, :data:`sys.exc_type`, :data:`sys.exc_value`, "
":data:`sys.exc_traceback`. (Зверніть увагу, що :data:`sys.last_type` тощо "
"залишаються.)"

#: ../../whatsnew/3.0.rst:636
msgid ""
"Cleanup of the :class:`array.array` type: the :meth:`read` and :meth:`write`"
" methods are gone; use :meth:`fromfile` and :meth:`tofile` instead.  Also, "
"the ``'c'`` typecode for array is gone -- use either ``'b'`` for bytes or "
"``'u'`` for Unicode characters."
msgstr ""
"Очищення типу :class:`array.array`: методи :meth:`read` і :meth:`write` "
"зникли; замість цього використовуйте :meth:`fromfile` і :meth:`tofile`. Крім"
" того, код типу ``'c'`` для масиву зник — використовуйте ``'b'`` для байтів "
"або ``'u'`` для символів Unicode."

#: ../../whatsnew/3.0.rst:642
msgid ""
"Cleanup of the :mod:`operator` module: removed :func:`sequenceIncludes` and "
":func:`isCallable`."
msgstr ""
"Очищення модуля :mod:`operator`: видалено :func:`sequenceIncludes` і "
":func:`isCallable`."

#: ../../whatsnew/3.0.rst:645
msgid ""
"Cleanup of the :mod:`thread` module: :func:`acquire_lock` and "
":func:`release_lock` are gone; use :func:`acquire` and :func:`release` "
"instead."
msgstr ""

#: ../../whatsnew/3.0.rst:649
msgid ""
"Cleanup of the :mod:`random` module: removed the :func:`jumpahead` API."
msgstr "Очищення модуля :mod:`random`: видалено API :func:`jumpahead`."

#: ../../whatsnew/3.0.rst:651
msgid "The :mod:`new` module is gone."
msgstr ""

#: ../../whatsnew/3.0.rst:653
msgid ""
"The functions :func:`os.tmpnam`, :func:`os.tempnam` and :func:`os.tmpfile` "
"have been removed in favor of the :mod:`tempfile` module."
msgstr ""
"Функції :func:`os.tmpnam`, :func:`os.tempnam` і :func:`os.tmpfile` було "
"видалено на користь модуля :mod:`tempfile`."

#: ../../whatsnew/3.0.rst:657
msgid ""
"The :mod:`tokenize` module has been changed to work with bytes.  The main "
"entry point is now :func:`tokenize.tokenize`, instead of generate_tokens."
msgstr ""
"Модуль :mod:`tokenize` змінено для роботи з байтами. Головною точкою входу "
"тепер є :func:`tokenize.tokenize` замість generate_tokens."

#: ../../whatsnew/3.0.rst:661
msgid ""
":data:`string.letters` and its friends (:data:`string.lowercase` and "
":data:`string.uppercase`) are gone.  Use :data:`string.ascii_letters` etc. "
"instead.  (The reason for the removal is that :data:`string.letters` and "
"friends had locale-specific behavior, which is a bad idea for such "
"attractively named global \"constants\".)"
msgstr ""
":data:`string.letters` и его друзья (:data:`string.lowercase` и "
":data:`string.uppercase`) исчезли. Вместо этого используйте "
":data:`string.ascii_letters` и т.д. (Причина удаления заключается в том, что"
" :data:`string.letters` и его друзья имели поведение, специфичное для "
"локали, что является плохой идеей для таких глобальных «констант» с "
"привлекательными именами.)"

#: ../../whatsnew/3.0.rst:668
msgid ""
"Renamed module :mod:`__builtin__` to :mod:`builtins` (removing the "
"underscores, adding an 's').  The :data:`__builtins__` variable found in "
"most global namespaces is unchanged.  To modify a builtin, you should use "
":mod:`builtins`, not :data:`__builtins__`!"
msgstr ""
"Змінено назву модуля :mod:`__builtin__` на :mod:`builtins` (видалення "
"підкреслення, додавання 's'). Змінна :data:`__builtins__`, що міститься в "
"більшості глобальних просторів імен, не змінюється. Щоб змінити вбудований "
"модуль, ви повинні використовувати :mod:`builtins`, а не "
":data:`__builtins__`!"

#: ../../whatsnew/3.0.rst:675
msgid ":pep:`3101`: A New Approach To String Formatting"
msgstr ":pep:`3101`: Новий підхід до форматування рядків"

#: ../../whatsnew/3.0.rst:677
msgid ""
"A new system for  built-in string formatting operations replaces the ``%`` "
"string  formatting operator.   (However, the ``%``  operator is still "
"supported;  it will  be deprecated in  Python 3.1  and removed from the "
"language at some later time.)  Read :pep:`3101` for the full scoop."
msgstr ""
"Нова система для вбудованих операцій форматування рядка замінює оператор "
"форматування рядка ``%``. (Однак оператор ``%`` все ще підтримується; він "
"буде застарілим у Python 3.1 і пізніше буде видалено з мови.) Прочитайте "
":pep:`3101`, щоб отримати повну інформацію."

#: ../../whatsnew/3.0.rst:685
msgid "Changes To Exceptions"
msgstr "Зміни винятків"

#: ../../whatsnew/3.0.rst:687
msgid ""
"The APIs for raising and catching exception have been cleaned up and new "
"powerful features added:"
msgstr ""
"Було очищено API для виклику та перехоплення винятків і додано нові потужні "
"функції:"

#: ../../whatsnew/3.0.rst:690
msgid ""
":pep:`352`: All exceptions must be derived (directly or indirectly) from "
":exc:`BaseException`.  This is the root of the exception hierarchy.  This is"
" not new as a recommendation, but the *requirement* to inherit from "
":exc:`BaseException` is new.  (Python 2.6 still allowed classic classes to "
"be raised, and placed no restriction on what you can catch.)  As a "
"consequence, string exceptions are finally truly and utterly dead."
msgstr ""
":pep:`352`: усі винятки мають бути отримані (прямо чи опосередковано) з "
":exc:`BaseException`. Це корінь ієрархії винятків. Це не нова рекомендація, "
"але *вимога* для успадкування від :exc:`BaseException` є новою. (Python 2.6 "
"все ще дозволяв створювати класичні класи та не накладав обмежень на те, що "
"ви можете перехопити.) Як наслідок, виключення рядків остаточно по-"
"справжньому й повністю мертві."

#: ../../whatsnew/3.0.rst:698
msgid ""
"Almost all exceptions should actually derive from :exc:`Exception`; "
":exc:`BaseException` should only be used as a base class for exceptions that"
" should only be handled at the top level, such as :exc:`SystemExit` or "
":exc:`KeyboardInterrupt`.  The recommended idiom for handling all exceptions"
" except for this latter category is to use :keyword:`except` "
":exc:`Exception`."
msgstr ""
"Майже всі винятки насправді мають походити від :exc:`Exception`; "
":exc:`BaseException` слід використовувати лише як базовий клас для винятків,"
" які слід обробляти лише на верхньому рівні, наприклад :exc:`SystemExit` або"
" :exc:`KeyboardInterrupt`. Рекомендована ідіома для обробки всіх винятків, "
"крім цієї останньої категорії, полягає в використанні :keyword:`except` "
":exc:`Exception`."

#: ../../whatsnew/3.0.rst:705
msgid ":exc:`StandardError` was removed."
msgstr ":exc:`StandardError` видалено."

#: ../../whatsnew/3.0.rst:707
msgid ""
"Exceptions no longer behave as sequences.  Use the :attr:`args` attribute "
"instead."
msgstr ""
"Винятки більше не діють як послідовності. Натомість використовуйте атрибут "
":attr:`args`."

#: ../../whatsnew/3.0.rst:710
msgid ""
":pep:`3109`: Raising exceptions.  You must now use :samp:`raise "
"{Exception}({args})` instead of :samp:`raise {Exception}, {args}`. "
"Additionally, you can no longer explicitly specify a traceback; instead, if "
"you *have* to do this, you can assign directly to the :attr:`__traceback__` "
"attribute (see below)."
msgstr ""

#: ../../whatsnew/3.0.rst:716
msgid ""
":pep:`3110`: Catching exceptions.  You must now use :samp:`except "
"{SomeException} as {variable}` instead of :samp:`except {SomeException}, "
"{variable}`.  Moreover, the *variable* is explicitly deleted when the "
":keyword:`except` block is left."
msgstr ""
":pep:`3110`: Перехоплення винятків. Тепер ви повинні використовувати "
":samp:`крім {SomeException} як {variable}` замість :samp:`крім "
"{SomeException}, {variable}`. Крім того, *змінна* явно видаляється, коли "
"залишається блок :keyword:`except`."

#: ../../whatsnew/3.0.rst:722
msgid ""
":pep:`3134`: Exception chaining.  There are two cases: implicit chaining and"
" explicit chaining.  Implicit chaining happens when an exception is raised "
"in an :keyword:`except` or :keyword:`finally` handler block.  This usually "
"happens due to a bug in the handler block; we call this a *secondary* "
"exception.  In this case, the original exception (that was being handled) is"
" saved as the :attr:`__context__` attribute of the secondary exception. "
"Explicit chaining is invoked with this syntax::"
msgstr ""

#: ../../whatsnew/3.0.rst:733
msgid ""
"(where *primary_exception* is any expression that produces an exception "
"object, probably an exception that was previously caught). In this case, the"
" primary exception is stored on the :attr:`__cause__` attribute of the "
"secondary exception.  The traceback printed when an unhandled exception "
"occurs walks the chain of :attr:`__cause__` and :attr:`__context__` "
"attributes and prints a separate traceback for each component of the chain, "
"with the primary exception at the top.  (Java users may recognize this "
"behavior.)"
msgstr ""

#: ../../whatsnew/3.0.rst:742
msgid ""
":pep:`3134`: Exception objects now store their traceback as the "
":attr:`__traceback__` attribute.  This means that an exception object now "
"contains all the information pertaining to an exception, and there are fewer"
" reasons to use :func:`sys.exc_info` (though the latter is not removed)."
msgstr ""

#: ../../whatsnew/3.0.rst:748
msgid ""
"A few exception messages are improved when Windows fails to load an "
"extension module.  For example, ``error code 193`` is now ``%1 is not a "
"valid Win32 application``.  Strings now deal with non-English locales."
msgstr ""
"Покращено кілька повідомлень про винятки, коли Windows не вдається "
"завантажити модуль розширення. Наприклад, ``код помилки 193`` тепер ``%1 не "
"є дійсною програмою Win32``. Рядки тепер мають справу з неанглійськими "
"локалями."

#: ../../whatsnew/3.0.rst:755
msgid "Miscellaneous Other Changes"
msgstr "Інші інші зміни"

#: ../../whatsnew/3.0.rst:758
msgid "Operators And Special Methods"
msgstr "Оператори та спеціальні методи"

#: ../../whatsnew/3.0.rst:760
msgid ""
"``!=`` now returns the opposite of ``==``, unless ``==`` returns "
":data:`NotImplemented`."
msgstr ""
"``!=`` тепер повертає протилежність ``==``, якщо ``==`` не повертає "
":data:`NotImplemented`."

#: ../../whatsnew/3.0.rst:763
msgid ""
"The concept of \"unbound methods\" has been removed from the language. When "
"referencing a method as a class attribute, you now get a plain function "
"object."
msgstr ""
"Поняття \"незв'язаних методів\" було видалено з мови. Посилаючись на метод "
"як на атрибут класу, тепер ви отримуєте звичайний об’єкт функції."

#: ../../whatsnew/3.0.rst:767
msgid ""
":meth:`__getslice__`, :meth:`__setslice__` and :meth:`__delslice__` were "
"killed.  The syntax ``a[i:j]`` now translates to ``a.__getitem__(slice(i, "
"j))`` (or :meth:`__setitem__` or :meth:`__delitem__`, when used as an "
"assignment or deletion target, respectively)."
msgstr ""
":meth:`__getslice__`, :meth:`__setslice__` і :meth:`__delslice__` були "
"вбиті. Синтаксис ``a[i:j]`` тепер перекладається на ``a.__getitem__(slice(i,"
" j))`` (або :meth:`__setitem__` або :meth:`__delitem__`, коли "
"використовується як ціль призначення або видалення відповідно)."

#: ../../whatsnew/3.0.rst:773
msgid ""
":pep:`3114`: the standard :meth:`next` method has been renamed to "
":meth:`~iterator.__next__`."
msgstr ""
":pep:`3114`: стандартний метод :meth:`next` було перейменовано на "
":meth:`~iterator.__next__`."

#: ../../whatsnew/3.0.rst:776
msgid ""
"The :meth:`__oct__` and :meth:`__hex__` special methods are removed -- "
":func:`oct` and :func:`hex` use :meth:`__index__` now to convert the "
"argument to an integer."
msgstr ""
"Спеціальні методи :meth:`__oct__` і :meth:`__hex__` видалено -- :func:`oct` "
"і :func:`hex` тепер використовують :meth:`__index__` для перетворення "
"аргументу в ціле число."

#: ../../whatsnew/3.0.rst:780
msgid "Removed support for :attr:`__members__` and :attr:`__methods__`."
msgstr "Видалено підтримку :attr:`__members__` і :attr:`__methods__`."

#: ../../whatsnew/3.0.rst:782
msgid ""
"The function attributes named :attr:`func_X` have been renamed to use the "
":data:`__X__` form, freeing up these names in the function attribute "
"namespace for user-defined attributes.  To wit, :attr:`func_closure`, "
":attr:`func_code`, :attr:`func_defaults`, :attr:`func_dict`, "
":attr:`func_doc`, :attr:`func_globals`, :attr:`func_name` were renamed to "
":attr:`__closure__`, :attr:`__code__`, :attr:`__defaults__`, "
":attr:`~object.__dict__`, :attr:`__doc__`, :attr:`__globals__`, "
":attr:`~definition.__name__`, respectively."
msgstr ""

#: ../../whatsnew/3.0.rst:792
msgid ":meth:`__nonzero__` is now :meth:`__bool__`."
msgstr ""

#: ../../whatsnew/3.0.rst:795
msgid "Builtins"
msgstr "Вбудовані"

#: ../../whatsnew/3.0.rst:797
msgid ""
":pep:`3135`: New :func:`super`.  You can now invoke :func:`super` without "
"arguments and (assuming this is in a regular instance method defined inside "
"a :keyword:`class` statement) the right class and instance will "
"automatically be chosen.  With arguments, the behavior of :func:`super` is "
"unchanged."
msgstr ""
":pep:`3135`: Нове :func:`super`. Тепер ви можете викликати :func:`super` без"
" аргументів і (припускаючи, що це в звичайному методі екземпляра, "
"визначеному всередині оператора :keyword:`class`) правильний клас і "
"екземпляр будуть вибрані автоматично. З аргументами поведінка :func:`super` "
"не змінюється."

#: ../../whatsnew/3.0.rst:803
msgid ""
":pep:`3111`: :func:`raw_input` was renamed to :func:`input`.  That is, the "
"new :func:`input` function reads a line from :data:`sys.stdin` and returns "
"it with the trailing newline stripped. It raises :exc:`EOFError` if the "
"input is terminated prematurely. To get the old behavior of :func:`input`, "
"use ``eval(input())``."
msgstr ""
":pep:`3111`: :func:`raw_input` було перейменовано на :func:`input`. Тобто "
"нова функція :func:`input` зчитує рядок із :data:`sys.stdin` і повертає його"
" без кінцевого символу нового рядка. Він викликає :exc:`EOFError`, якщо "
"введення завершується передчасно. Щоб отримати стару поведінку "
":func:`input`, використовуйте ``eval(input())``."

#: ../../whatsnew/3.0.rst:809
msgid ""
"A new built-in function :func:`next` was added to call the "
":meth:`~iterator.__next__` method on an object."
msgstr ""
"Додано нову вбудовану функцію :func:`next` для виклику методу "
":meth:`~iterator.__next__` для об’єкта."

#: ../../whatsnew/3.0.rst:812
msgid ""
"The :func:`round` function rounding strategy and return type have changed.  "
"Exact halfway cases are now rounded to the nearest even result instead of "
"away from zero.  (For example, ``round(2.5)`` now returns ``2`` rather than "
"``3``.)  ``round(x[, n])`` now delegates to ``x.__round__([n])`` instead of "
"always returning a float.  It generally returns an integer when called with "
"a single argument and a value of the same type as ``x`` when called with two"
" arguments."
msgstr ""
"Змінено стратегію округлення функції :func:`round` і тип повернення. Точні "
"половинні випадки тепер округлюються до найближчого парного результату "
"замість нуля. (Наприклад, ``round(2.5)`` тепер повертає ``2``, а не ``3``.) "
"``round(x[, n])`` тепер делегує ``x.__round__([ n])`` замість того, щоб "
"завжди повертати число з плаваючою точкою. Зазвичай він повертає ціле число,"
" якщо викликається з одним аргументом, і значення того самого типу, що й "
"``x``, коли викликається з двома аргументами."

#: ../../whatsnew/3.0.rst:821
msgid "Moved :func:`intern` to :func:`sys.intern`."
msgstr "Переміщено :func:`intern` до :func:`sys.intern`."

#: ../../whatsnew/3.0.rst:823
msgid ""
"Removed: :func:`apply`.  Instead of ``apply(f, args)`` use ``f(*args)``."
msgstr ""
"Видалено: :func:`apply`. Замість ``apply(f, args)`` використовуйте "
"``f(*args)``."

#: ../../whatsnew/3.0.rst:826
msgid ""
"Removed :func:`callable`.  Instead of ``callable(f)`` you can use "
"``isinstance(f, collections.Callable)``.  The :func:`operator.isCallable` "
"function is also gone."
msgstr ""
"Видалено :func:`callable`. Замість ``callable(f)`` ви можете використовувати"
" ``isinstance(f, collections.Callable)``. Функція "
":func:`operator.isCallable` також зникла."

#: ../../whatsnew/3.0.rst:830
msgid ""
"Removed :func:`coerce`.  This function no longer serves a purpose now that "
"classic classes are gone."
msgstr ""
"Видалено :func:`coerce`. Ця функція більше не служить меті, оскільки "
"класичні класи зникли."

#: ../../whatsnew/3.0.rst:833
msgid ""
"Removed :func:`execfile`.  Instead of ``execfile(fn)`` use "
"``exec(open(fn).read())``."
msgstr ""
"Видалено :func:`execfile`. Замість ``execfile(fn)`` використовуйте "
"``exec(open(fn).read())``."

#: ../../whatsnew/3.0.rst:836
msgid ""
"Removed the :class:`file` type.  Use :func:`open`.  There are now several "
"different kinds of streams that open can return in the :mod:`io` module."
msgstr ""
"Видалено тип :class:`file`. Використовуйте :func:`open`. Зараз існує кілька "
"різних типів потоків, які відкриваються і можуть повертатися в модулі "
":mod:`io`."

#: ../../whatsnew/3.0.rst:839
msgid ""
"Removed :func:`reduce`.  Use :func:`functools.reduce` if you really need it;"
" however, 99 percent of the time an explicit :keyword:`for` loop is more "
"readable."
msgstr ""
"Видалено :func:`reduce`. Використовуйте :func:`functools.reduce`, якщо вам "
"це дійсно потрібно; однак у 99% випадків явний цикл :keyword:`for` "
"читабельніший."

#: ../../whatsnew/3.0.rst:843
msgid "Removed :func:`reload`.  Use :func:`imp.reload`."
msgstr ""

#: ../../whatsnew/3.0.rst:845
msgid ""
"Removed. :meth:`dict.has_key` -- use the :keyword:`in` operator instead."
msgstr ""
"Видалено. :meth:`dict.has_key` -- замість цього використовуйте оператор "
":keyword:`in`."

#: ../../whatsnew/3.0.rst:852
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/3.0.rst:854
msgid ""
"Due to time constraints, here is a *very* incomplete list of changes to the "
"C API."
msgstr "Через обмеження часу ось *дуже* неповний список змін до C API."

#: ../../whatsnew/3.0.rst:857
msgid ""
"Support for several platforms was dropped, including but not limited to Mac "
"OS 9, BeOS, RISCOS, Irix, and Tru64."
msgstr ""
"Було припинено підтримку кількох платформ, зокрема Mac OS 9, BeOS, RISCOS, "
"Irix і Tru64."

#: ../../whatsnew/3.0.rst:860
msgid ":pep:`3118`: New Buffer API."
msgstr ":pep:`3118`: 新的缓冲区 API。"

#: ../../whatsnew/3.0.rst:862
msgid ":pep:`3121`: Extension Module Initialization & Finalization."
msgstr ":pep:`3121`: Ініціалізація та завершення модуля розширення."

#: ../../whatsnew/3.0.rst:864
msgid ":pep:`3123`: Making :c:macro:`PyObject_HEAD` conform to standard C."
msgstr ":pep:`3123`: Приведення :c:macro:`PyObject_HEAD` до стандарту C."

#: ../../whatsnew/3.0.rst:866
msgid "No more C API support for restricted execution."
msgstr "Більше немає підтримки C API для обмеженого виконання."

#: ../../whatsnew/3.0.rst:868
msgid ""
":c:func:`PyNumber_Coerce`, :c:func:`PyNumber_CoerceEx`, "
":c:func:`PyMember_Get`, and :c:func:`PyMember_Set` C APIs are removed."
msgstr ""
":c:func:`PyNumber_Coerce`, :c:func:`PyNumber_CoerceEx`, "
":c:func:`PyMember_Get`, and :c:func:`PyMember_Set` C API 已被移除。"

#: ../../whatsnew/3.0.rst:871
msgid ""
"New C API :c:func:`PyImport_ImportModuleNoBlock`, works like "
":c:func:`PyImport_ImportModule` but won't block on the import lock "
"(returning an error instead)."
msgstr ""
"Новий C API :c:func:`PyImport_ImportModuleNoBlock`, працює як "
":c:func:`PyImport_ImportModule`, але не блокує блокування імпорту (натомість"
" повертає помилку)."

#: ../../whatsnew/3.0.rst:875
msgid ""
"Renamed the boolean conversion C-level slot and method: ``nb_nonzero`` is "
"now ``nb_bool``."
msgstr ""
"Перейменовано слот і метод логічного перетворення C-рівня: ``nb_nonzero`` "
"тепер ``nb_bool``."

#: ../../whatsnew/3.0.rst:878
msgid ""
"Removed :c:macro:`METH_OLDARGS` and :c:macro:`WITH_CYCLE_GC` from the C API."
msgstr "从 C API 中移除 :c:macro:`METH_OLDARGS` 和 :c:macro:`WITH_CYCLE_GC`。"

#: ../../whatsnew/3.0.rst:884
msgid "Performance"
msgstr "性能"

#: ../../whatsnew/3.0.rst:886
msgid ""
"The net result of the 3.0 generalizations is that Python 3.0 runs the "
"pystone benchmark around 10% slower than Python 2.5.  Most likely the "
"biggest cause is the removal of special-casing for small integers. There's "
"room for improvement, but it will happen after 3.0 is released!"
msgstr ""
"Кінцевим результатом узагальнень 3.0 є те, що Python 3.0 виконує тест "
"pystone приблизно на 10% повільніше, ніж Python 2.5. Швидше за все, "
"найбільшою причиною є видалення спеціального регістра для малих цілих чисел."
" Є місце для вдосконалення, але це станеться після випуску 3.0!"

#: ../../whatsnew/3.0.rst:896
msgid "Porting To Python 3.0"
msgstr "移植到 Python 3.0"

#: ../../whatsnew/3.0.rst:898
msgid ""
"For porting existing Python 2.5 or 2.6 source code to Python 3.0, the best "
"strategy is the following:"
msgstr ""
"Для перенесення існуючого вихідного коду Python 2.5 або 2.6 на Python 3.0 "
"найкраща стратегія така:"

#: ../../whatsnew/3.0.rst:901
msgid "(Prerequisite:) Start with excellent test coverage."
msgstr "(Обов’язкова умова:) Почніть із чудового тестового покриття."

#: ../../whatsnew/3.0.rst:903
msgid ""
"Port to Python 2.6.  This should be no more work than the average port from "
"Python 2.x to Python 2.(x+1).  Make sure all your tests pass."
msgstr ""
"Порт на Python 2.6. Це повинно бути не більше роботи, ніж середнє "
"перенесення з Python 2.x на Python 2. (x+1). Переконайтеся, що всі ваші "
"тести пройдені."

#: ../../whatsnew/3.0.rst:907
msgid ""
"(Still using 2.6:) Turn on the :option:`!-3` command line switch. This "
"enables warnings about features that will be removed (or change) in 3.0.  "
"Run your test suite again, and fix code that you get warnings about until "
"there are no warnings left, and all your tests still pass."
msgstr ""
"(Досі використовується 2.6:) Увімкніть перемикач командного рядка "
":option:`!-3`. Це вмикає попередження про функції, які буде видалено (або "
"змінено) у версії 3.0. Знову запустіть набір тестів і виправте код, про який"
" ви отримуєте попередження, доки попередження не зникнуть, і всі ваші тести "
"все одно пройдуть."

#: ../../whatsnew/3.0.rst:913
msgid ""
"Run the ``2to3`` source-to-source translator over your source code tree.  "
"(See :ref:`2to3-reference` for more on this tool.)  Run the result of the "
"translation under Python 3.0.  Manually fix up any remaining issues, fixing "
"problems until all tests pass again."
msgstr ""
"Запустіть перекладач ``2to3`` з джерела в джерело над вашим деревом "
"вихідного коду. (Див. :ref:`2to3-reference`, щоб дізнатися більше про цей "
"інструмент.) Запустіть результат перекладу під Python 3.0. Вручну вирішуйте "
"проблеми, що залишилися, виправляючи проблеми, доки всі тести не пройдуть "
"знову."

#: ../../whatsnew/3.0.rst:918
msgid ""
"It is not recommended to try to write source code that runs unchanged under "
"both Python 2.6 and 3.0; you'd have to use a very contorted coding style, "
"e.g. avoiding ``print`` statements, metaclasses, and much more.  If you are "
"maintaining a library that needs to support both Python 2.6 and Python 3.0, "
"the best approach is to modify step 3 above by editing the 2.6 version of "
"the source code and running the ``2to3`` translator again, rather than "
"editing the 3.0 version of the source code."
msgstr ""
"Не рекомендується намагатися написати вихідний код, який працює без змін під"
" Python 2.6 і 3.0; вам доведеться використовувати дуже спотворений стиль "
"кодування, напр. уникнення операторів ``print``, метакласів і багато іншого."
" Якщо ви підтримуєте бібліотеку, яка має підтримувати як Python 2.6, так і "
"Python 3.0, найкращим підходом є змінити крок 3 вище, відредагувавши версію "
"вихідного коду 2.6 і знову запустивши перекладач ``2to3`` замість "
"редагування Версія вихідного коду 3.0."

#: ../../whatsnew/3.0.rst:927
msgid ""
"For porting C extensions to Python 3.0, please see :ref:`cporting-howto`."
msgstr "Для перенесення розширень C на Python 3.0 див. :ref:`cporting-howto`."
