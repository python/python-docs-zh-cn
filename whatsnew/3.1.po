# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/3.1.rst:3
msgid "What's New In Python 3.1"
msgstr "Python 3.1 有什么新变化"

#: ../../whatsnew/3.1.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/3.1.rst:5
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger（译者：wh2099 at outlook dot com）"

#: ../../whatsnew/3.1.rst:49
msgid ""
"This article explains the new features in Python 3.1, compared to 3.0. "
"Python 3.1 was released on June 27, 2009."
msgstr "本文介绍了 Python 3.1 相比 3.0 的新特性。 Python 3.1 发布于 2009 年 6 月 27 日。"

#: ../../whatsnew/3.1.rst:54
msgid "PEP 372: Ordered Dictionaries"
msgstr "PEP 372: 有序字典"

#: ../../whatsnew/3.1.rst:56
msgid ""
"Regular Python dictionaries iterate over key/value pairs in arbitrary order."
" Over the years, a number of authors have written alternative "
"implementations that remember the order that the keys were originally "
"inserted.  Based on the experiences from those implementations, a new "
":class:`collections.OrderedDict` class has been introduced."
msgstr ""
"常规的 Python 字典会以任意顺序迭代键/值对。 多年以来，有好几位作者编写了可以记住键的初始插入顺序的替代实现。 "
"基于这些实现的经验，现在引入了新的 :class:`collections.OrderedDict` 类。"

#: ../../whatsnew/3.1.rst:62
msgid ""
"The OrderedDict API is substantially the same as regular dictionaries but "
"will iterate over keys and values in a guaranteed order depending on when a "
"key was first inserted.  If a new entry overwrites an existing entry, the "
"original insertion position is left unchanged.  Deleting an entry and "
"reinserting it will move it to the end."
msgstr ""
"OrderedDict API 与常规字典基本相同，但将根据每个键首次插入的时间以有保证的顺序来迭代键和值。 "
"如果一个新条目覆盖了现有的条目，则原始插入位置会保持不变。 删除条目并重新插入则会将其移至末尾。"

#: ../../whatsnew/3.1.rst:68
msgid ""
"The standard library now supports use of ordered dictionaries in several "
"modules.  The :mod:`configparser` module uses them by default.  This lets "
"configuration files be read, modified, and then written back in their "
"original order.  The *_asdict()* method for :func:`collections.namedtuple` "
"now returns an ordered dictionary with the values appearing in the same "
"order as the underlying tuple indices.  The :mod:`json` module is being "
"built-out with an *object_pairs_hook* to allow OrderedDicts to be built by "
"the decoder. Support was also added for third-party tools like `PyYAML "
"<https://pyyaml.org/>`_."
msgstr ""
"标准库现在支持在某些模块中使用有序字典。 :mod:`configparser` 模块会默认使用它们。 "
"这使得配置文件将以其原始顺序被读取、修改和重新写入。 :func:`collections.namedtuple` 的 *_asdict()* "
"方法现在会返回一个值的出现顺序与下层的元组索引号相同的有序字典。 :mod:`json` 模块已使用 *object_pairs_hook* "
"来构建以允许由解码器生成有序字典。 还添加了对第三方工具的支持如 `PyYAML <https://pyyaml.org/>`_。"

#: ../../whatsnew/3.1.rst:79
msgid ":pep:`372` - Ordered Dictionaries"
msgstr ":pep:`372` - 有序字典"

#: ../../whatsnew/3.1.rst:80
msgid ""
"PEP written by Armin Ronacher and Raymond Hettinger.  Implementation written"
" by Raymond Hettinger."
msgstr "PEP 由 Armin Ronacher 和 Raymond Hettinger 撰写，由 Raymond Hettinger 实现。"

#: ../../whatsnew/3.1.rst:83
msgid ""
"Since an ordered dictionary remembers its insertion order, it can be used in"
" conjunction with sorting to make a sorted dictionary::"
msgstr "因为一个有序字典记住它的顺序，他可以用于连接排序字典 ::"

#: ../../whatsnew/3.1.rst:86
msgid ""
">>> # regular unsorted dictionary\n"
">>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}\n"
"\n"
">>> # dictionary sorted by key\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))\n"
"OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])\n"
"\n"
">>> # dictionary sorted by value\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))\n"
"OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])\n"
"\n"
">>> # dictionary sorted by length of the key string\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))\n"
"OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])"
msgstr ""
">>> # 常规的无序字典\n"
">>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}\n"
"\n"
">>> # 按键排序的字典\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))\n"
"OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])\n"
"\n"
">>> # 按值排序的字典\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))\n"
"OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])\n"
"\n"
">>> # 按键字符串长度排序的字典\n"
">>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))\n"
"OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])"

#: ../../whatsnew/3.1.rst:101
msgid ""
"The new sorted dictionaries maintain their sort order when entries are "
"deleted.  But when new keys are added, the keys are appended to the end and "
"the sort is not maintained."
msgstr "当条目删除时，新的排序字典会维护它的顺序。但如果有新的条目添加进来，键就被加入到末端，顺序就不再维护。"

#: ../../whatsnew/3.1.rst:107
msgid "PEP 378: Format Specifier for Thousands Separator"
msgstr "PEP 378: 千位分隔符的格式说明符"

#: ../../whatsnew/3.1.rst:109
msgid ""
"The built-in :func:`format` function and the :meth:`str.format` method use a"
" mini-language that now includes a simple, non-locale aware way to format a "
"number with a thousands separator.  That provides a way to humanize a "
"program's output, improving its professional appearance and readability::"
msgstr ""
"内置的 :func:`format` 函数和 :meth:`str.format` "
"方法使用的迷你语言现在包括一种以千位分隔符格式化数字的简单、不可感知语言区域的方式。 这提供了更为人性化的程序输出，提升了外观专业程度与可读性::"

#: ../../whatsnew/3.1.rst:114
msgid ""
">>> format(1234567, ',d')\n"
"'1,234,567'\n"
">>> format(1234567.89, ',.2f')\n"
"'1,234,567.89'\n"
">>> format(12345.6 + 8901234.12j, ',f')\n"
"'12,345.600000+8,901,234.120000j'\n"
">>> format(Decimal('1234567.89'), ',f')\n"
"'1,234,567.89'"
msgstr ""
">>> format(1234567, ',d')\n"
"'1,234,567'\n"
">>> format(1234567.89, ',.2f')\n"
"'1,234,567.89'\n"
">>> format(12345.6 + 8901234.12j, ',f')\n"
"'12,345.600000+8,901,234.120000j'\n"
">>> format(Decimal('1234567.89'), ',f')\n"
"'1,234,567.89'"

#: ../../whatsnew/3.1.rst:123
msgid ""
"The supported types are :class:`int`, :class:`float`, :class:`complex` and "
":class:`decimal.Decimal`."
msgstr ""
"支持的类型有 :class:`int`, :class:`float`, :class:`complex` 和 "
":class:`decimal.Decimal`。"

#: ../../whatsnew/3.1.rst:126
msgid ""
"Discussions are underway about how to specify alternative separators like "
"dots, spaces, apostrophes, or underscores.  Locale-aware applications should"
" use the existing *n* format specifier which already has some support for "
"thousands separators."
msgstr ""
"目前还在讨论要如何指定替代分隔符如点号、空格、撇号或下划线等。 可感知语言区域的应用程序应当使用现有的支持千位分隔符的 *n* 格式说明符。"

#: ../../whatsnew/3.1.rst:133
msgid ":pep:`378` - Format Specifier for Thousands Separator"
msgstr ":pep:`378` - 千位分隔符的格式说明符"

#: ../../whatsnew/3.1.rst:134
msgid ""
"PEP written by Raymond Hettinger and implemented by Eric Smith and Mark "
"Dickinson."
msgstr "PEP 由 Raymond Hettinger 撰写，并由 Eric Smith 和 Mark Dickinson 实现"

#: ../../whatsnew/3.1.rst:139
msgid "Other Language Changes"
msgstr "其他语言特性修改"

#: ../../whatsnew/3.1.rst:141
msgid "Some smaller changes made to the core Python language are:"
msgstr "对Python 语言核心进行的小改动："

#: ../../whatsnew/3.1.rst:143
msgid ""
"Directories and zip archives containing a :file:`__main__.py` file can now "
"be executed directly by passing their name to the interpreter. The "
"directory/zipfile is automatically inserted as the first entry in sys.path."
"  (Suggestion and initial patch by Andy Chu; revised patch by Phillip J. Eby"
" and Nick Coghlan; :issue:`1739468`.)"
msgstr ""
"包括 :file:`__main__.py` 文件的目录和 zip 归档文件现在可通过将其名称传给解释器来直接执行。 这样的目录/zip 文件会自动作为"
" sys.path 的第一个条目插入。 （由 Andy Chu 提议并编写初始补丁；由 Phillip J. Eby 和 Nick Coghlan "
"改进补丁；:issue:`1739468`。）"

#: ../../whatsnew/3.1.rst:149
msgid ""
"The :func:`int` type gained a ``bit_length`` method that returns the number "
"of bits necessary to represent its argument in binary::"
msgstr ":func:`int` 类型增加了一个 ``bit_length`` 方法用来返回以二进制代表其参数值所需的比特位数量::"

#: ../../whatsnew/3.1.rst:152
msgid ""
">>> n = 37\n"
">>> bin(37)\n"
"'0b100101'\n"
">>> n.bit_length()\n"
"6\n"
">>> n = 2**123-1\n"
">>> n.bit_length()\n"
"123\n"
">>> (n+1).bit_length()\n"
"124"
msgstr ""
">>> n = 37\n"
">>> bin(37)\n"
"'0b100101'\n"
">>> n.bit_length()\n"
"6\n"
">>> n = 2**123-1\n"
">>> n.bit_length()\n"
"123\n"
">>> (n+1).bit_length()\n"
"124"

#: ../../whatsnew/3.1.rst:163
msgid ""
"(Contributed by Fredrik Johansson, Victor Stinner, Raymond Hettinger, and "
"Mark Dickinson; :issue:`3439`.)"
msgstr ""
"（由 Fredrik Johansson, Victor Stinner, Raymond Hettinger 和 Mark Dickinson 在 "
":issue:`3439` 中贡献。）"

#: ../../whatsnew/3.1.rst:166
msgid ""
"The fields in :func:`format` strings can now be automatically numbered::"
msgstr ":func:`format` 字符串中的字段现在可被自动编号::"

#: ../../whatsnew/3.1.rst:169
msgid ""
">>> 'Sir {} of {}'.format('Gallahad', 'Camelot')\n"
"'Sir Gallahad of Camelot'"
msgstr ""
">>> 'Sir {} of {}'.format('Gallahad', 'Camelot')\n"
"'Sir Gallahad of Camelot'"

#: ../../whatsnew/3.1.rst:172
msgid ""
"Formerly, the string would have required numbered fields such as: ``'Sir {0}"
" of {1}'``."
msgstr "之前，字符串应当具有所需的编号字段例如: ``'Sir {0} of {1}'``。"

#: ../../whatsnew/3.1.rst:175
msgid "(Contributed by Eric Smith; :issue:`5237`.)"
msgstr "（由 Eric Smith在 :issue:`5237` 中贡献）"

#: ../../whatsnew/3.1.rst:177
msgid ""
"The :func:`!string.maketrans` function is deprecated and is replaced by new "
"static methods, :meth:`bytes.maketrans` and :meth:`bytearray.maketrans`. "
"This change solves the confusion around which types were supported by the "
":mod:`string` module. Now, :class:`str`, :class:`bytes`, and "
":class:`bytearray` each have their own **maketrans** and **translate** "
"methods with intermediate translation tables of the appropriate type."
msgstr ""
":func:`!string.maketrans` 函数已被弃用并由新的静态方法 :meth:`bytes.maketrans` 和 "
":meth:`bytearray.maketrans` 所取代。 这项更改解决了对于 :mod:`string` 模块所支持的类型的困惑。 "
"现在，:class:`str`, :class:`bytes` 和 :class:`bytearray` 分别拥有它们自己的具有适当类型的中间转译表的 "
"**maketrans** 和 **translate** 方法。"

#: ../../whatsnew/3.1.rst:184
msgid "(Contributed by Georg Brandl; :issue:`5675`.)"
msgstr "（由Georg Brandl在 :issue:`5675` 中贡献）"

#: ../../whatsnew/3.1.rst:186
msgid ""
"The syntax of the :keyword:`with` statement now allows multiple context "
"managers in a single statement::"
msgstr "The syntax of the :keyword:`with` 语句的语法现在允许单个语句中存在多个上下文管理器::"

#: ../../whatsnew/3.1.rst:189
msgid ""
">>> with open('mylog.txt') as infile, open('a.out', 'w') as outfile:\n"
"...     for line in infile:\n"
"...         if '<critical>' in line:\n"
"...             outfile.write(line)"
msgstr ""
">>> with open('mylog.txt') as infile, open('a.out', 'w') as outfile:\n"
"...     for line in infile:\n"
"...         if '<critical>' in line:\n"
"...             outfile.write(line)"

#: ../../whatsnew/3.1.rst:194
msgid ""
"With the new syntax, the :func:`!contextlib.nested` function is no longer "
"needed and is now deprecated."
msgstr "有了这个新语法，:func:`!contextlib.nested` 函数已不再必要因而现在已被弃用。"

#: ../../whatsnew/3.1.rst:197
msgid ""
"(Contributed by Georg Brandl and Mattias Brändström; `appspot issue 53094 "
"<https://codereview.appspot.com/53094>`_.)"
msgstr ""
"（由 Georg Brandl 和 Mattias Brändström 贡献; `appspot issue 53094 "
"<https://codereview.appspot.com/53094>`_。）"

#: ../../whatsnew/3.1.rst:200
msgid ""
"``round(x, n)`` now returns an integer if *x* is an integer. Previously it "
"returned a float::"
msgstr "现在 ``round(x, n)`` 当 *x* 为整数时将返回整数。 之前是返回浮点数::"

#: ../../whatsnew/3.1.rst:203
msgid ""
">>> round(1123, -2)\n"
"1100"
msgstr ""
">>> round(1123, -2)\n"
"1100"

#: ../../whatsnew/3.1.rst:206
msgid "(Contributed by Mark Dickinson; :issue:`4707`.)"
msgstr "（由 Mark Dickinson在 :issue:`4707` 贡献）"

#: ../../whatsnew/3.1.rst:208
msgid ""
"Python now uses David Gay's algorithm for finding the shortest floating-"
"point representation that doesn't change its value.  This should help "
"mitigate some of the confusion surrounding binary floating-point numbers."
msgstr "Python 现在使用 David Gay 的算法来查找不会改变实际值的最短浮点表示形式。 这应当有助于缓解某些对于二进制浮点数的困惑。"

#: ../../whatsnew/3.1.rst:213
msgid ""
"The significance is easily seen with a number like ``1.1`` which does not "
"have an exact equivalent in binary floating point.  Since there is no exact "
"equivalent, an expression like ``float('1.1')`` evaluates to the nearest "
"representable value which is ``0x1.199999999999ap+0`` in hex or "
"``1.100000000000000088817841970012523233890533447265625`` in decimal. That "
"nearest value was and still is used in subsequent floating-point "
"calculations."
msgstr ""
"这项改进的优点对于 ``1.1`` 这样无法用二进制浮点精确表示的数来说是很明显的。 由于没有完全等价的表示，``float('1.1')`` "
"这样的表达式会被求解为最接近的可表示值即十六进制的 ``0x1.199999999999ap+0`` 或十进制的 "
"``1.100000000000000088817841970012523233890533447265625``。 "
"这个最接近的值过去和现在仍然会在后续的浮点运算中被使用。"

#: ../../whatsnew/3.1.rst:221
msgid ""
"What is new is how the number gets displayed.  Formerly, Python used a "
"simple approach.  The value of ``repr(1.1)`` was computed as ``format(1.1, "
"'.17g')`` which evaluated to ``'1.1000000000000001'``. The advantage of "
"using 17 digits was that it relied on IEEE-754 guarantees to assure that "
"``eval(repr(1.1))`` would round-trip exactly to its original value.  The "
"disadvantage is that many people found the output to be confusing (mistaking"
" intrinsic limitations of binary floating-point representation as being a "
"problem with Python itself)."
msgstr ""
"新的改变针对的是如何显示数字。 在之前，Python 使用了一种简单的方式。 ``repr(1.1)`` 的值会被计算为 ``format(1.1, "
"'.17g')`` 并将被求解为 ``'1.1000000000000001'``。 使用 17 个数位的优点是它将凭借 IEEE-754 标准来确保 "
"``eval(repr(1.1))`` 将恰好被舍入到其原始值。 缺点则是会让许多人感觉这样的输出令人困惑（将二进制浮点表示形式的内在局限性误认为是 "
"Python 本身的问题）。"

#: ../../whatsnew/3.1.rst:230
msgid ""
"The new algorithm for ``repr(1.1)`` is smarter and returns ``'1.1'``. "
"Effectively, it searches all equivalent string representations (ones that "
"get stored with the same underlying float value) and returns the shortest "
"representation."
msgstr ""
"用于 ``repr(1.1)`` 的新算法更为智能并将返回 ``'1.1'``。 "
"在实际上，它会搜索所有等价的字符串表示形式（使用相同的下层浮点值进行排序）并返回其中最短的表示形式。"

#: ../../whatsnew/3.1.rst:235
msgid ""
"The new algorithm tends to emit cleaner representations when possible, but "
"it does not change the underlying values.  So, it is still the case that "
"``1.1 + 2.2 != 3.3`` even though the representations may suggest otherwise."
msgstr ""
"新算法倾向于尽可能放出更为清晰的表示形式，但它并不改变下层的值。 因此仍然会是 ``1.1 + 2.2 != 3.3`` "
"虽然从表示形式上看情况不是这样。"

#: ../../whatsnew/3.1.rst:239
msgid ""
"The new algorithm depends on certain features in the underlying floating-"
"point implementation.  If the required features are not found, the old "
"algorithm will continue to be used.  Also, the text pickle protocols assure "
"cross-platform portability by using the old algorithm."
msgstr ""
"这个新算法依赖于下层浮点实现的某些特性。 如果未找到所需的特性，则将继续使用旧算法。 此外，文本 pickle "
"协议也会通过使用旧算法来保证跨平台的可移植性。"

#: ../../whatsnew/3.1.rst:244
msgid "(Contributed by Eric Smith and Mark Dickinson; :issue:`1580`)"
msgstr "（由 Eric Smith 和 Mark Dickinson 在 :issue:`1580` 贡献）"

#: ../../whatsnew/3.1.rst:247
msgid "New, Improved, and Deprecated Modules"
msgstr "新增，改进和弃用的模块"

#: ../../whatsnew/3.1.rst:249
msgid ""
"Added a :class:`collections.Counter` class to support convenient counting of"
" unique items in a sequence or iterable::"
msgstr "增加了一个 :class:`collections.Counter` 类以支持方便地统计一个序列或可迭代对象中的唯一条目数量。::"

#: ../../whatsnew/3.1.rst:252
msgid ""
">>> Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})"
msgstr ""
">>> Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})"

#: ../../whatsnew/3.1.rst:255
msgid "(Contributed by Raymond Hettinger; :issue:`1696199`.)"
msgstr "（由 Raymond Hettinger 在 :issue:`1696199` 中贡献。）"

#: ../../whatsnew/3.1.rst:257
msgid ""
"Added a new module, :mod:`tkinter.ttk` for access to the Tk themed widget "
"set. The basic idea of ttk is to separate, to the extent possible, the code "
"implementing a widget's behavior from the code implementing its appearance."
msgstr ""
"半圆了一个新模块 :mod:`tkinter.ttk` 用于访问带主题的 Tk 部件集。 ttk "
"的基本设计思路，就是尽可能地把实现部件行为的代码与实现其外观的代码分离开来。"

#: ../../whatsnew/3.1.rst:261
msgid "(Contributed by Guilherme Polo; :issue:`2983`.)"
msgstr "（由 Guilherme Polo 在 :issue:`2983` 中贡献。）"

#: ../../whatsnew/3.1.rst:263
msgid ""
"The :class:`gzip.GzipFile` and :class:`bz2.BZ2File` classes now support the "
"context management protocol::"
msgstr ":class:`gzip.GzipFile` 和 :class:`bz2.BZ2File` 类现在已支持上下文管理协议::"

#: ../../whatsnew/3.1.rst:266
msgid ""
">>> # Automatically close file after writing\n"
">>> with gzip.GzipFile(filename, \"wb\") as f:\n"
"...     f.write(b\"xxx\")"
msgstr ""
">>> # 写入后自动关闭文件\n"
">>> with gzip.GzipFile(filename, \"wb\") as f:\n"
"...     f.write(b\"xxx\")"

#: ../../whatsnew/3.1.rst:270
msgid "(Contributed by Antoine Pitrou.)"
msgstr "（由 Antoine Pitrou 贡献。）"

#: ../../whatsnew/3.1.rst:272
msgid ""
"The :mod:`decimal` module now supports methods for creating a decimal object"
" from a binary :class:`float`.  The conversion is exact but can sometimes be"
" surprising::"
msgstr ""
":mod:`decimal` 模块现在支持基于一个二进制 :class:`float` 来创建 decimal 对象。 "
"转换是准确的但有时也会令人吃惊::"

#: ../../whatsnew/3.1.rst:276
msgid ""
">>> Decimal.from_float(1.1)\n"
"Decimal('1.100000000000000088817841970012523233890533447265625')"
msgstr ""
">>> Decimal.from_float(1.1)\n"
"Decimal('1.100000000000000088817841970012523233890533447265625')"

#: ../../whatsnew/3.1.rst:279
msgid ""
"The long decimal result shows the actual binary fraction being stored for "
"*1.1*.  The fraction has many digits because *1.1* cannot be exactly "
"represented in binary."
msgstr "这个长长的 decimal 结果值显示了 *1.1* 所保存的实际二进制分数。 这个分数有许多位因为 *1.1* 无法用二进制来精确表示。"

#: ../../whatsnew/3.1.rst:283
msgid "(Contributed by Raymond Hettinger and Mark Dickinson.)"
msgstr "（由Raymond Hettinger 和 Mark Dickinson贡献。）"

#: ../../whatsnew/3.1.rst:285
msgid ""
"The :mod:`itertools` module grew two new functions.  The "
":func:`itertools.combinations_with_replacement` function is one of four for "
"generating combinatorics including permutations and Cartesian products.  The"
" :func:`itertools.compress` function mimics its namesake from APL.  Also, "
"the existing :func:`itertools.count` function now has an optional *step* "
"argument and can accept any type of counting sequence including "
":class:`fractions.Fraction` and :class:`decimal.Decimal`::"
msgstr ""
":mod:`itertools` 模块增加了两个新函数。 :func:`itertools.combinations_with_replacement`"
" 函数是生成组合数学结果包括排列与笛卡尔积的四个函数之一。 :func:`itertools.compress` 函数模仿了 APL 中的同名函数。 "
"此外，现有的 :func:`itertools.count` 函数现在有一个可选的 *step* 参数并可接受任意类型的计数序列包括 "
":class:`fractions.Fraction` 和 :class:`decimal.Decimal`::"

#: ../../whatsnew/3.1.rst:294
msgid ""
">>> [p+q for p,q in combinations_with_replacement('LOVE', 2)]\n"
"['LL', 'LO', 'LV', 'LE', 'OO', 'OV', 'OE', 'VV', 'VE', 'EE']\n"
"\n"
">>> list(compress(data=range(10), selectors=[0,0,1,1,0,1,0,1,0,0]))\n"
"[2, 3, 5, 7]\n"
"\n"
">>> c = count(start=Fraction(1,2), step=Fraction(1,6))\n"
">>> [next(c), next(c), next(c), next(c)]\n"
"[Fraction(1, 2), Fraction(2, 3), Fraction(5, 6), Fraction(1, 1)]"
msgstr ""
">>> [p+q for p,q in combinations_with_replacement('LOVE', 2)]\n"
"['LL', 'LO', 'LV', 'LE', 'OO', 'OV', 'OE', 'VV', 'VE', 'EE']\n"
"\n"
">>> list(compress(data=range(10), selectors=[0,0,1,1,0,1,0,1,0,0]))\n"
"[2, 3, 5, 7]\n"
"\n"
">>> c = count(start=Fraction(1,2), step=Fraction(1,6))\n"
">>> [next(c), next(c), next(c), next(c)]\n"
"[Fraction(1, 2), Fraction(2, 3), Fraction(5, 6), Fraction(1, 1)]"

#: ../../whatsnew/3.1.rst:304
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/3.1.rst:306
msgid ""
":func:`collections.namedtuple` now supports a keyword argument *rename* "
"which lets invalid fieldnames be automatically converted to positional names"
" in the form _0, _1, etc.  This is useful when the field names are being "
"created by an external source such as a CSV header, SQL field list, or user "
"input::"
msgstr ""
":func:`collections.namedtuple` 现在支持关键字参数 *rename*，它允许将无效的字段名自动转换为 _0, _1 "
"等形式的位置名称。 这在字段名是由外部源如 CSV 标头、SQL 字段列表或用户输入创建的时候会很有用处::"

#: ../../whatsnew/3.1.rst:312
msgid ""
">>> query = input()\n"
"SELECT region, dept, count(*) FROM main GROUPBY region, dept\n"
"\n"
">>> cursor.execute(query)\n"
">>> query_fields = [desc[0] for desc in cursor.description]\n"
">>> UserQuery = namedtuple('UserQuery', query_fields, rename=True)\n"
">>> pprint.pprint([UserQuery(*row) for row in cursor])\n"
"[UserQuery(region='South', dept='Shipping', _2=185),\n"
" UserQuery(region='North', dept='Accounting', _2=37),\n"
" UserQuery(region='West', dept='Sales', _2=419)]"
msgstr ""
">>> query = input()\n"
"SELECT region, dept, count(*) FROM main GROUPBY region, dept\n"
"\n"
">>> cursor.execute(query)\n"
">>> query_fields = [desc[0] for desc in cursor.description]\n"
">>> UserQuery = namedtuple('UserQuery', query_fields, rename=True)\n"
">>> pprint.pprint([UserQuery(*row) for row in cursor])\n"
"[UserQuery(region='South', dept='Shipping', _2=185),\n"
" UserQuery(region='North', dept='Accounting', _2=37),\n"
" UserQuery(region='West', dept='Sales', _2=419)]"

#: ../../whatsnew/3.1.rst:323
msgid "(Contributed by Raymond Hettinger; :issue:`1818`.)"
msgstr "（由 Raymond Hettinger 在 :issue:`1818` 中贡献。）"

#: ../../whatsnew/3.1.rst:325
msgid ""
"The :func:`re.sub`, :func:`re.subn` and :func:`re.split` functions now "
"accept a flags parameter."
msgstr ""
":func:`re.sub`, :func:`re.subn` 和 :func:`re.split` 函数现在可接受一个 flags 形参。"

#: ../../whatsnew/3.1.rst:328
msgid "(Contributed by Gregory Smith.)"
msgstr "（由 Gregory Smith 贡献）"

#: ../../whatsnew/3.1.rst:330
msgid ""
"The :mod:`logging` module now implements a simple "
":class:`logging.NullHandler` class for applications that are not using "
"logging but are calling library code that does.  Setting-up a null handler "
"will suppress spurious warnings such as \"No handlers could be found for "
"logger foo\"::"
msgstr ""
":mod:`logging` 模块现在为不使用 logging 但是调用了使用它的库代码的应用程序实现了一个简单的 "
":class:`logging.NullHandler` 类。 设置一个空处理器将会屏蔽诸如 \"找不到日志记录器 foo 的处理器\" "
"这样的虚假警告::"

#: ../../whatsnew/3.1.rst:335
msgid ""
">>> h = logging.NullHandler()\n"
">>> logging.getLogger(\"foo\").addHandler(h)"
msgstr ""
">>> h = logging.NullHandler()\n"
">>> logging.getLogger(\"foo\").addHandler(h)"

#: ../../whatsnew/3.1.rst:338
msgid "(Contributed by Vinay Sajip; :issue:`4384`)."
msgstr "（由 Vinay Sajip 在 :issue:`4384` 中贡献。）"

#: ../../whatsnew/3.1.rst:340
msgid ""
"The :mod:`runpy` module which supports the ``-m`` command line switch now "
"supports the execution of packages by looking for and executing a "
"``__main__`` submodule when a package name is supplied."
msgstr ""
"支持 ``-m`` 命令行开关的 :mod:`runpy` 模块现在也支持当提供包名称时通过查找并执行 ``__main__`` 子模块来执行包。"

#: ../../whatsnew/3.1.rst:344
msgid "(Contributed by Andi Vajda; :issue:`4195`.)"
msgstr "（由 Andi Vajda 在 :issue:`4195` 中贡献。）"

#: ../../whatsnew/3.1.rst:346
msgid ""
"The :mod:`pdb` module can now access and display source code loaded via "
":mod:`zipimport` (or any other conformant :pep:`302` loader)."
msgstr ""
":mod:`pdb` 模块现在可以访问并显示通过 :mod:`zipimport` (或其他符合规范的 :pep:`302` 加载器) 加载的源代码。"

#: ../../whatsnew/3.1.rst:349
msgid "(Contributed by Alexander Belopolsky; :issue:`4201`.)"
msgstr "（由 Alexander Belopolsky 在 :issue:`4201` 中贡献。）"

#: ../../whatsnew/3.1.rst:351
msgid ":class:`functools.partial` objects can now be pickled."
msgstr ":class:`functools.partial` 对象现在可以被封存。"

#: ../../whatsnew/3.1.rst:353
msgid ""
"(Suggested by Antoine Pitrou and Jesse Noller.  Implemented by Jack "
"Diederich; :issue:`5228`.)"
msgstr ""
"（由 Antoine Pitrou 和 Jesse Noller 提议，由 Jack Diederich 实现; :issue:`5228`。）"

#: ../../whatsnew/3.1.rst:356
msgid ""
"Add :mod:`pydoc` help topics for symbols so that ``help('@')`` works as "
"expected in the interactive environment."
msgstr "为符号增加 :mod:`pydoc` 帮助主题以使得在交互环境下 ``help('@')`` 能符合预期的效果。"

#: ../../whatsnew/3.1.rst:359
msgid "(Contributed by David Laban; :issue:`4739`.)"
msgstr "（由 David Laban 在 :issue:`4739` 中贡献。）"

#: ../../whatsnew/3.1.rst:361
msgid ""
"The :mod:`unittest` module now supports skipping individual tests or classes"
" of tests. And it supports marking a test as an expected failure, a test "
"that is known to be broken, but shouldn't be counted as a failure on a "
"TestResult::"
msgstr ""
":mod:`unittest` 模块现在支持跳过单个测试或测试类。 并且它还支持将一个测试标记为已预期会失败，即已经知道不可用，但不应在 "
"TestResult 上被计为一次失败::"

#: ../../whatsnew/3.1.rst:366
msgid ""
"class TestGizmo(unittest.TestCase):\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires Windows\")\n"
"    def test_gizmo_on_windows(self):\n"
"        ...\n"
"\n"
"    @unittest.expectedFailure\n"
"    def test_gimzo_without_required_library(self):\n"
"        ..."
msgstr ""
"class TestGizmo(unittest.TestCase):\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires Windows\")\n"
"    def test_gizmo_on_windows(self):\n"
"        ...\n"
"\n"
"    @unittest.expectedFailure\n"
"    def test_gimzo_without_required_library(self):\n"
"        ..."

#: ../../whatsnew/3.1.rst:376
msgid ""
"Also, tests for exceptions have been builtout to work with context managers "
"using the :keyword:`with` statement::"
msgstr "此外，还创建了一些针对异常的测试以便与使用 :keyword:`with` 语句的上下文管理器一起工作::"

#: ../../whatsnew/3.1.rst:379
msgid ""
"def test_division_by_zero(self):\n"
"    with self.assertRaises(ZeroDivisionError):\n"
"        x / 0"
msgstr ""
"def test_division_by_zero(self):\n"
"    with self.assertRaises(ZeroDivisionError):\n"
"        x / 0"

#: ../../whatsnew/3.1.rst:383
msgid ""
"In addition, several new assertion methods were added including "
":meth:`~unittest.TestCase.assertSetEqual`, "
":meth:`~unittest.TestCase.assertDictEqual`, "
":meth:`!assertDictContainsSubset`, "
":meth:`~unittest.TestCase.assertListEqual`, "
":meth:`~unittest.TestCase.assertTupleEqual`, "
":meth:`~unittest.TestCase.assertSequenceEqual`, :meth:`assertRaisesRegexp() "
"<unittest.TestCase.assertRaisesRegex>`, "
":meth:`~unittest.TestCase.assertIsNone`, and "
":meth:`~unittest.TestCase.assertIsNotNone`."
msgstr ""
"此外，还新增了一些断言方法包括 :meth:`~unittest.TestCase.assertSetEqual`, "
":meth:`~unittest.TestCase.assertDictEqual`, "
":meth:`!assertDictContainsSubset`, "
":meth:`~unittest.TestCase.assertListEqual`, "
":meth:`~unittest.TestCase.assertTupleEqual`, "
":meth:`~unittest.TestCase.assertSequenceEqual`, :meth:`assertRaisesRegexp() "
"<unittest.TestCase.assertRaisesRegex>`, "
":meth:`~unittest.TestCase.assertIsNone` 和 "
":meth:`~unittest.TestCase.assertIsNotNone`。"

#: ../../whatsnew/3.1.rst:394
msgid "(Contributed by Benjamin Peterson and Antoine Pitrou.)"
msgstr "（由Benjamin Peterson 和 Antoine Pitrou 贡献。）"

#: ../../whatsnew/3.1.rst:396
msgid ""
"The :mod:`io` module has three new constants for the :meth:`~io.IOBase.seek`"
" method: :data:`~os.SEEK_SET`, :data:`~os.SEEK_CUR`, and "
":data:`~os.SEEK_END`."
msgstr ""
":mod:`io` 模块新增了三个常量用于 :meth:`~io.IOBase.seek` 方法: :data:`~os.SEEK_SET`, "
":data:`~os.SEEK_CUR` 和 :data:`~os.SEEK_END`。"

#: ../../whatsnew/3.1.rst:399
msgid "The :data:`sys.version_info` tuple is now a named tuple::"
msgstr ":data:`sys.version_info` 元组现在是一个具名元组::"

#: ../../whatsnew/3.1.rst:401
msgid ""
">>> sys.version_info\n"
"sys.version_info(major=3, minor=1, micro=0, releaselevel='alpha', serial=2)"
msgstr ""
">>> sys.version_info\n"
"sys.version_info(major=3, minor=1, micro=0, releaselevel='alpha', serial=2)"

#: ../../whatsnew/3.1.rst:404
msgid "(Contributed by Ross Light; :issue:`4285`.)"
msgstr "（由 Ross Light 在 :issue:`4285` 中贡献。）"

#: ../../whatsnew/3.1.rst:406
msgid "The :mod:`!nntplib` and :mod:`imaplib` modules now support IPv6."
msgstr "现在 :mod:`!nntplib` 和 :mod:`imaplib` 模块已支持 IPv6。"

#: ../../whatsnew/3.1.rst:408
msgid "(Contributed by Derek Morr; :issue:`1655` and :issue:`1664`.)"
msgstr "（由 Derek Morr 在 :issue:`1655` 和 :issue:`1664` 中贡献。）"

#: ../../whatsnew/3.1.rst:410
msgid ""
"The :mod:`pickle` module has been adapted for better interoperability with "
"Python 2.x when used with protocol 2 or lower.  The reorganization of the "
"standard library changed the formal reference for many objects.  For "
"example, ``__builtin__.set`` in Python 2 is called ``builtins.set`` in "
"Python 3. This change confounded efforts to share data between different "
"versions of Python.  But now when protocol 2 or lower is selected, the "
"pickler will automatically use the old Python 2 names for both loading and "
"dumping. This remapping is turned-on by default but can be disabled with the"
" *fix_imports* option::"
msgstr ""
"当使用协议 2 或更低的版本时，:mod:`pickle` 模块已被调适以获得与 Python 2.x 更好的互操作性。 "
"标准库的重组改变了对于许多对象的正式引用。 例如，Python 2 中的 ``__builtin__.set`` 在 Python 3 中称为 "
"``builtins.set``。 这一改变使得在不同版本的 Python 之间共享数据的努力陷入混乱。 但是现在当选择协议 2 "
"或更低的版本时，封存器将自动使用旧的 Python 2 名称进行加载和转储。 这样的重映射将默认启用但可以通过 *fix_imports* "
"选项来禁用::"

#: ../../whatsnew/3.1.rst:420
msgid ""
">>> s = {1, 2, 3}\n"
">>> pickle.dumps(s, protocol=0)\n"
"b'c__builtin__\\nset\\np0\\n((lp1\\nL1L\\naL2L\\naL3L\\natp2\\nRp3\\n.'\n"
">>> pickle.dumps(s, protocol=0, fix_imports=False)\n"
"b'cbuiltins\\nset\\np0\\n((lp1\\nL1L\\naL2L\\naL3L\\natp2\\nRp3\\n.'"
msgstr ""
">>> s = {1, 2, 3}\n"
">>> pickle.dumps(s, protocol=0)\n"
"b'c__builtin__\\nset\\np0\\n((lp1\\nL1L\\naL2L\\naL3L\\natp2\\nRp3\\n.'\n"
">>> pickle.dumps(s, protocol=0, fix_imports=False)\n"
"b'cbuiltins\\nset\\np0\\n((lp1\\nL1L\\naL2L\\naL3L\\natp2\\nRp3\\n.'"

#: ../../whatsnew/3.1.rst:426
msgid ""
"An unfortunate but unavoidable side-effect of this change is that protocol 2"
" pickles produced by Python 3.1 won't be readable with Python 3.0. The "
"latest pickle protocol, protocol 3, should be used when migrating data "
"between Python 3.x implementations, as it doesn't attempt to remain "
"compatible with Python 2.x."
msgstr ""
"这项改变的一个不幸但无可避免的副作用是由 Python 3.1 所产生的协议 2 版本的 pickle 对象对于 Python 3.0 将不可读。 当在"
" Python 3.x 实现之间迁移数据时，应当使用最新的协议 3 版本的 pickle 协议，因为它不会试图与 Python 2.x 保持兼容。"

#: ../../whatsnew/3.1.rst:432
msgid ""
"(Contributed by Alexandre Vassalotti and Antoine Pitrou, :issue:`6137`.)"
msgstr "（由 Alexandre Vassalotti 和 Antoine Pitrou 在 :issue:`6137` 中贡献。）"

#: ../../whatsnew/3.1.rst:434
msgid ""
"A new module, :mod:`importlib` was added.  It provides a complete, portable,"
" pure Python reference implementation of the :keyword:`import` statement and"
" its counterpart, the :func:`__import__` function.  It represents a "
"substantial step forward in documenting and defining the actions that take "
"place during imports."
msgstr ""
"增加了一个新模块 :mod:`importlib`。 它提供了针对 :keyword:`import` 语句及其对应物 "
":func:`__import__` 函数的完整、可移植的纯 Python 引用实现。 它代表了在记录和定义导入期间所发生的行动中实质性的一步。"

#: ../../whatsnew/3.1.rst:440
msgid "(Contributed by Brett Cannon.)"
msgstr "（由 Brett Cannon 贡献。）"

#: ../../whatsnew/3.1.rst:443
msgid "Optimizations"
msgstr "性能优化"

#: ../../whatsnew/3.1.rst:445
msgid "Major performance enhancements have been added:"
msgstr "已增加的主要性能改善:"

#: ../../whatsnew/3.1.rst:447
msgid ""
"The new I/O library (as defined in :pep:`3116`) was mostly written in Python"
" and quickly proved to be a problematic bottleneck in Python 3.0. In Python "
"3.1, the I/O library has been entirely rewritten in C and is 2 to 20 times "
"faster depending on the task at hand. The pure Python version is still "
"available for experimentation purposes through the ``_pyio`` module."
msgstr ""
"新的 I/O 库（如 :pep:`3116` 所定义的）主要是用 Python 编写并很快被证明是 Python 3.0 中的一个问题瓶颈。 在 "
"Python 3.1 中，I/O 库已完全用 C 重写并根据具体任务的不同有 2 到 20 倍的速度提升。 纯 Python 版本仍然可通过 "
"``_pyio`` 模块访问以用于实验性目的。"

#: ../../whatsnew/3.1.rst:454
msgid "(Contributed by Amaury Forgeot d'Arc and Antoine Pitrou.)"
msgstr "（由 Amaury Forgeot d'Arc 和 Antoine Pitrou 贡献。）"

#: ../../whatsnew/3.1.rst:456
msgid ""
"Added a heuristic so that tuples and dicts containing only untrackable "
"objects are not tracked by the garbage collector. This can reduce the size "
"of collections and therefore the garbage collection overhead on long-running"
" programs, depending on their particular use of datatypes."
msgstr ""
"添加了一个启发式的工具以使仅包含不可追踪对象的元组和字典不会被垃圾回收器所追踪。 "
"这可以减少收集数据的大小从而减少长时间运行的程序的垃圾收集开销，具体取决于它们对类型类型的使用方式。"

#: ../../whatsnew/3.1.rst:461
msgid "(Contributed by Antoine Pitrou, :issue:`4688`.)"
msgstr "（由 Antoine Pitrou 在 :issue:`4688` 中贡献。）"

#: ../../whatsnew/3.1.rst:463
msgid ""
"Enabling a configure option named ``--with-computed-gotos`` on compilers "
"that support it (notably: gcc, SunPro, icc), the bytecode evaluation loop is"
" compiled with a new dispatch mechanism which gives speedups of up to 20%, "
"depending on the system, the compiler, and the benchmark."
msgstr ""
"通过在受支持的编译器（主要有: gcc, SunPro, icc）上启用名为 ``--with-computed-gotos`` "
"的配置选项，字节码求值循环会使用新的分派机制进行编译，根据系统、编译器和基准测试工具的不同，该机制可获得至多 20% 的速度提升。"

#: ../../whatsnew/3.1.rst:469
msgid ""
"(Contributed by Antoine Pitrou along with a number of other participants, "
":issue:`4753`)."
msgstr "（由 Antoine Pitrou 以及其他一些参与者在 :issue:`4753` 中贡献。）"

#: ../../whatsnew/3.1.rst:472
msgid ""
"The decoding of UTF-8, UTF-16 and LATIN-1 is now two to four times faster."
msgstr "UTF-8, UTF-16 和 LATIN-1 的解码速度现已提升了二至四倍。"

#: ../../whatsnew/3.1.rst:475
msgid ""
"(Contributed by Antoine Pitrou and Amaury Forgeot d'Arc, :issue:`4868`.)"
msgstr "（由 Antoine Pitrou 和 Amaury Forgeot d'Arc 在 :issue:`4868` 中贡献。）"

#: ../../whatsnew/3.1.rst:477
msgid ""
"The :mod:`json` module now has a C extension to substantially improve its "
"performance.  In addition, the API was modified so that json works only with"
" :class:`str`, not with :class:`bytes`.  That change makes the module "
"closely match the `JSON specification <https://json.org/>`_ which is defined"
" in terms of Unicode."
msgstr ""
":mod:`json` 模块现在有了一个可显著提升其性能的 C 扩展。 此外，还对 API 进行了修改以使 json 只适用于 "
":class:`str`，而不再适用于 :class:`bytes`。 这一修改使得该模块能与基于 Unicode 的 `JSON 规范 "
"<https://json.org/>`_ 紧密匹配。"

#: ../../whatsnew/3.1.rst:483
msgid ""
"(Contributed by Bob Ippolito and converted to Py3.1 by Antoine Pitrou and "
"Benjamin Peterson; :issue:`4136`.)"
msgstr ""
"（由 Bob Ippolito 在 :issue:`4136` 中贡献。并由 Antoine Pitrou 和 Benjamin Peterson "
"转换为Py3.1）"

#: ../../whatsnew/3.1.rst:486
msgid ""
"Unpickling now interns the attribute names of pickled objects.  This saves "
"memory and allows pickles to be smaller."
msgstr "解封操作现在将固定已封存对象的属性名称。 这可以节省内存并让封存对象变得更小。"

#: ../../whatsnew/3.1.rst:489
msgid "(Contributed by Jake McGuire and Antoine Pitrou; :issue:`5084`.)"
msgstr "（由 Jake McGuire 和 Antoine Pitrou 在 :issue:`5084` 中贡献。）"

#: ../../whatsnew/3.1.rst:492
msgid "IDLE"
msgstr "IDLE"

#: ../../whatsnew/3.1.rst:494
msgid ""
"IDLE's format menu now provides an option to strip trailing whitespace from "
"a source file."
msgstr "IDLE 的格式菜单现在提供了一个从源文件中去除尾部空格的选项。"

#: ../../whatsnew/3.1.rst:497
msgid "(Contributed by Roger D. Serwy; :issue:`5150`.)"
msgstr "（由 Roger D. Serwy 在 :issue:`5150` 中贡献。）"

#: ../../whatsnew/3.1.rst:500
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/3.1.rst:502
msgid "Changes to Python's build process and to the C API include:"
msgstr "针对 Python 构建过程和 C API 的改变包括:"

#: ../../whatsnew/3.1.rst:504
msgid ""
"Integers are now stored internally either in base ``2**15`` or in base "
"``2**30``, the base being determined at build time.  Previously, they were "
"always stored in base ``2**15``.  Using base ``2**30`` gives significant "
"performance improvements on 64-bit machines, but benchmark results on 32-bit"
" machines have been mixed.  Therefore, the default is to use base ``2**30`` "
"on 64-bit machines and base ``2**15`` on 32-bit machines; on Unix, there's a"
" new configure option ``--enable-big-digits`` that can be used to override "
"this default."
msgstr ""
"现在整数在内部是以 ``2**15`` 为基数或以 ``2**30`` 为基数来存储的，这个基数会在构建时被确定。 在之前版本中，它们总是以 "
"``2**15`` 为基数来存储。 在 64 位机器上使用 ``2**30`` 为基数可显著提升性能，但在 32 位机器上的基准测试结果则好坏参半。 "
"因此，默认会在 64 位机器上使用 ``2**30`` 为基数而在 32 位机器上使用 ``2**15`` 为基数；在 Unix 上，有一个新的配置选项"
" ``--enable-big-digits`` 可被用于覆盖此默认值。"

#: ../../whatsnew/3.1.rst:513
msgid ""
"Apart from the performance improvements this change should be invisible to "
"end users, with one exception: for testing and debugging purposes there's a "
"new :data:`sys.int_info` that provides information about the internal "
"format, giving the number of bits per digit and the size in bytes of the C "
"type used to store each digit::"
msgstr ""
"除了性能提升之外这项改变对于最终用户来说应当是不可见的，只有一个例外：出于测试和调试目的有一个新的提供相关内部格式信息的 "
":data:`sys.int_info`，它给出了每个数位对应的比特位数和用户存储每个数位的以字节数表示的 C 类型大小::"

#: ../../whatsnew/3.1.rst:519
msgid ""
">>> import sys\n"
">>> sys.int_info\n"
"sys.int_info(bits_per_digit=30, sizeof_digit=4)"
msgstr ""
">>> import sys\n"
">>> sys.int_info\n"
"sys.int_info(bits_per_digit=30, sizeof_digit=4)"

#: ../../whatsnew/3.1.rst:523
msgid "(Contributed by Mark Dickinson; :issue:`4258`.)"
msgstr "（由 Mark Dickinson在 :issue:`4258` 贡献）"

#: ../../whatsnew/3.1.rst:525
msgid ""
"The :c:func:`PyLong_AsUnsignedLongLong()` function now handles a negative "
"*pylong* by raising :exc:`OverflowError` instead of :exc:`TypeError`."
msgstr ""
":c:func:`PyLong_AsUnsignedLongLong()` 函数现在将通过引发 :exc:`OverflowError` 而不是 "
":exc:`TypeError` 来处理负的 *pylong*。"

#: ../../whatsnew/3.1.rst:528
msgid "(Contributed by Mark Dickinson and Lisandro Dalcrin; :issue:`5175`.)"
msgstr "（由 Mark Dickinson 和 Lisandro Dalcrin 在 :issue:`5175` 中贡献。）"

#: ../../whatsnew/3.1.rst:530
msgid ""
"Deprecated :c:func:`!PyNumber_Int`.  Use :c:func:`PyNumber_Long` instead."
msgstr "已弃用 :c:func:`!PyNumber_Int`。 请改用 :c:func:`PyNumber_Long`。"

#: ../../whatsnew/3.1.rst:532
msgid "(Contributed by Mark Dickinson; :issue:`4910`.)"
msgstr "（由 Mark Dickinson在 :issue:`4910` 贡献）"

#: ../../whatsnew/3.1.rst:534
msgid ""
"Added a new :c:func:`PyOS_string_to_double` function to replace the "
"deprecated functions :c:func:`!PyOS_ascii_strtod` and "
":c:func:`!PyOS_ascii_atof`."
msgstr ""
"新增了 :c:func:`PyOS_string_to_double` 函数以取代已弃用的函数 :c:func:`!PyOS_ascii_strtod`"
" 和 :c:func:`!PyOS_ascii_atof`。"

#: ../../whatsnew/3.1.rst:537
msgid "(Contributed by Mark Dickinson; :issue:`5914`.)"
msgstr "（由 Mark Dickinson 在 :issue:`5914` 贡献）"

#: ../../whatsnew/3.1.rst:539
msgid ""
"Added :c:type:`PyCapsule` as a replacement for the :c:type:`!PyCObject` API."
" The principal difference is that the new type has a well defined interface "
"for passing typing safety information and a less complicated signature for "
"calling a destructor.  The old type had a problematic API and is now "
"deprecated."
msgstr ""
"增加了 :c:type:`PyCapsule` 作为 :c:type:`!PyCObject` API 的替代。 "
"主要区别在于新类型拥有一个定义良好的接口用来传递类型安全信息以及一个较低复杂度的签名用来调用析构器。 旧类型的 API 存在问题且现已被弃用。"

#: ../../whatsnew/3.1.rst:545
msgid "(Contributed by Larry Hastings; :issue:`5630`.)"
msgstr "（由 Larry Hastings 在 :issue:`5630` 中贡献。）"

#: ../../whatsnew/3.1.rst:548
msgid "Porting to Python 3.1"
msgstr "移植到 Python 3.1"

#: ../../whatsnew/3.1.rst:550
msgid ""
"This section lists previously described changes and other bugfixes that may "
"require changes to your code:"
msgstr "本节列出了先前描述的改变以及可能需要修改你的代码的其他问题修正:"

#: ../../whatsnew/3.1.rst:553
msgid ""
"The new floating-point string representations can break existing doctests. "
"For example::"
msgstr "新的浮点字符串表示形式可能会破坏现有的 doctest。 例如::"

#: ../../whatsnew/3.1.rst:556
msgid ""
"def e():\n"
"    '''Compute the base of natural logarithms.\n"
"\n"
"    >>> e()\n"
"    2.7182818284590451\n"
"\n"
"    '''\n"
"    return sum(1/math.factorial(x) for x in reversed(range(30)))\n"
"\n"
"doctest.testmod()\n"
"\n"
"**********************************************************************\n"
"Failed example:\n"
"    e()\n"
"Expected:\n"
"    2.7182818284590451\n"
"Got:\n"
"    2.718281828459045\n"
"**********************************************************************"
msgstr ""
"def e():\n"
"    '''计算自然对数的底数。\n"
"\n"
"    >>> e()\n"
"    2.7182818284590451\n"
"\n"
"    '''\n"
"    return sum(1/math.factorial(x) for x in reversed(range(30)))\n"
"\n"
"doctest.testmod()\n"
"\n"
"**********************************************************************\n"
"Failed example:\n"
"    e()\n"
"Expected:\n"
"    2.7182818284590451\n"
"Got:\n"
"    2.718281828459045\n"
"**********************************************************************"

#: ../../whatsnew/3.1.rst:576
msgid ""
"The automatic name remapping in the pickle module for protocol 2 or lower "
"can make Python 3.1 pickles unreadable in Python 3.0.  One solution is to "
"use protocol 3.  Another solution is to set the *fix_imports* option to "
"``False``. See the discussion above for more details."
msgstr ""
"在 pickle 模块中用于协议 2 或更低版本的自动名称重映射会使得 Python 3.1 的 pickle 在 Python 3.0 中无法读取。 "
"一种解决方案是使用协议 3。 另一种解决方案是将 *fix_imports* 选项设为 ``False``。 请参阅上面的讨论来了解更多细节。"
