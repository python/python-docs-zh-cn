# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-31 16:19+0000\n"
"PO-Revision-Date: 2025-07-18 20:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.5.rst:3
msgid "What's New in Python 2.5"
msgstr "Python 2.5 有什么新变化"

#: ../../whatsnew/2.5.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.5.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.5.rst:12
msgid ""
"This article explains the new features in Python 2.5.  The final release of "
"Python 2.5 is scheduled for August 2006; :pep:`356` describes the planned "
"release schedule.  Python 2.5 was released on September 19, 2006."
msgstr ""
"本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月；:pep:`356` "
"描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。"

#: ../../whatsnew/2.5.rst:16
msgid ""
"The changes in Python 2.5 are an interesting mix of language and library "
"improvements. The library enhancements will be more important to Python's "
"user community, I think, because several widely useful packages were added."
"  New modules include ElementTree for XML processing (:mod:`xml.etree`), the"
" SQLite database module (:mod:`sqlite`), and the :mod:`ctypes` module for "
"calling C functions."
msgstr ""
"Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python "
"的用户社区来说会更重要一些，因为增加了多个被广泛应用的包。 新增模块包括用于 XML 处理的 ElementTree "
"(:mod:`xml.etree`)，SQLite 数据库模块 (:mod:`sqlite`)，以及用于调用 C 函数的 :mod:`ctypes` "
"模块。"

#: ../../whatsnew/2.5.rst:23
msgid ""
"The language changes are of middling significance.  Some pleasant new "
"features were added, but most of them aren't features that you'll use every "
"day. Conditional expressions were finally added to the language using a "
"novel syntax; see section :ref:`pep-308`.  The new ':keyword:`with`' "
"statement will make writing cleanup code easier (section :ref:`pep-343`).  "
"Values can now be passed into generators (section :ref:`pep-342`).  Imports "
"are now visible as either absolute or relative (section :ref:`pep-328`).  "
"Some corner cases of exception handling are handled better (section "
":ref:`pep-341`).  All these improvements are worthwhile, but they're "
"improvements to one specific language feature or another; none of them are "
"broad modifications to Python's semantics."
msgstr ""
"Мовні зміни мають середнє значення. Було додано кілька приємних нових "
"функцій, але більшість із них не є функціями, якими ви будете користуватися "
"щодня. Умовні вирази нарешті були додані до мови за допомогою нового "
"синтаксису; див. розділ :ref:`pep-308`. Новий оператор ':keyword:`with`' "
"полегшить написання коду очищення (розділ :ref:`pep-343`). Тепер значення "
"можна передавати в генератори (розділ :ref:`pep-342`). Імпорт тепер "
"відображається як абсолютний або відносний (розділ :ref:`pep-328`). Деякі "
"кутові випадки обробки винятків обробляються краще (розділ :ref:`pep-341`). "
"Усі ці вдосконалення варті уваги, але це вдосконалення тієї чи іншої функції"
" мови; жодна з них не є широкою модифікацією семантики Python."

#: ../../whatsnew/2.5.rst:34
msgid ""
"As well as the language and library additions, other improvements and "
"bugfixes were made throughout the source tree.  A search through the SVN "
"change logs finds there were 353 patches applied and 458 bugs fixed between "
"Python 2.4 and 2.5.  (Both figures are likely to be underestimates.)"
msgstr ""
"Окрім мовних і бібліотечних доповнень, у всьому дереві вихідних кодів було "
"зроблено інші покращення та виправлення помилок. Пошук у журналах змін SVN "
"виявив, що між Python 2.4 і 2.5 було застосовано 353 виправлення та 458 "
"виправлених помилок. (Обидві цифри, ймовірно, занижені.)"

#: ../../whatsnew/2.5.rst:39
msgid ""
"This article doesn't try to be a complete specification of the new features;"
" instead changes are briefly introduced using helpful examples.  For full "
"details, you should always refer to the documentation for Python 2.5 at "
"https://docs.python.org. If you want to understand the complete "
"implementation and design rationale, refer to the PEP for a particular new "
"feature."
msgstr ""
"Ця стаття не намагається бути повною специфікацією нових функцій; натомість "
"зміни коротко представлені з використанням корисних прикладів. Щоб отримати "
"повну інформацію, завжди звертайтеся до документації для Python 2.5 на "
"https://docs.python.org. Якщо ви хочете зрозуміти повну реалізацію та "
"обґрунтування дизайну, зверніться до PEP для конкретної нової функції."

#: ../../whatsnew/2.5.rst:45
msgid ""
"Comments, suggestions, and error reports for this document are welcome; "
"please e-mail them to the author or open a bug in the Python bug tracker."
msgstr ""
"Коментарі, пропозиції та звіти про помилки щодо цього документа вітаються; "
"будь ласка, надішліть їх електронною поштою автору або відкрийте помилку в "
"системі відстеження помилок Python."

#: ../../whatsnew/2.5.rst:54
msgid "PEP 308: Conditional Expressions"
msgstr "PEP 308: 条件表达式"

#: ../../whatsnew/2.5.rst:56
msgid ""
"For a long time, people have been requesting a way to write conditional "
"expressions, which are expressions that return value A or value B depending "
"on whether a Boolean value is true or false.  A conditional expression lets "
"you write a single assignment statement that has the same effect as the "
"following::"
msgstr ""
"Протягом тривалого часу люди запитували спосіб написання умовних виразів, "
"які є виразами, які повертають значення A або значення B залежно від того, "
"чи є логічне значення true або false. Умовний вираз дає змогу написати один "
"оператор присвоєння, який має той самий ефект, що й наступний:"

#: ../../whatsnew/2.5.rst:66
msgid ""
"There have been endless tedious discussions of syntax on both python-dev and"
" comp.lang.python.  A vote was even held that found the majority of voters "
"wanted conditional expressions in some form, but there was no syntax that "
"was preferred by a clear majority. Candidates included C's ``cond ? true_v :"
" false_v``, ``if cond then true_v else false_v``, and 16 other variations."
msgstr ""
"Були нескінченні нудні дискусії щодо синтаксису як на python-dev, так і на "
"comp.lang.python. Навіть було проведено голосування, яке виявило, що "
"більшість виборців бажали використовувати умовні вирази в тій чи іншій "
"формі, але не було жодного синтаксису, якому віддала б перевагу явна "
"більшість. Серед кандидатів C ``cond ? true_v : false_v``, ``if cond then "
"true_v else false_v`` та 16 інших варіантів."

#: ../../whatsnew/2.5.rst:72
msgid "Guido van Rossum eventually chose a surprising syntax::"
msgstr "Guido van Rossum 最终选择了一种令人惊讶的语法："

#: ../../whatsnew/2.5.rst:76
msgid ""
"Evaluation is still lazy as in existing Boolean expressions, so the order of"
" evaluation jumps around a bit.  The *condition* expression in the middle is"
" evaluated first, and the *true_value* expression is evaluated only if the "
"condition was true.  Similarly, the *false_value* expression is only "
"evaluated when the condition is false."
msgstr ""
"Обчислення, як і в існуючих булевих виразах, все ще є ледачим, тому порядок "
"обчислення трохи змінюється. Вираз *умова* в середині обчислюється спочатку,"
" а вираз *істинне_значення* обчислюється, лише якщо умова була істинною. "
"Подібним чином вираз *false_value* обчислюється лише тоді, коли умова false."

#: ../../whatsnew/2.5.rst:82
msgid ""
"This syntax may seem strange and backwards; why does the condition go in the"
" *middle* of the expression, and not in the front as in C's ``c ? x : y``?  "
"The decision was checked by applying the new syntax to the modules in the "
"standard library and seeing how the resulting code read.  In many cases "
"where a conditional expression is used, one value seems to be the 'common "
"case' and one value is an 'exceptional case', used only on rarer occasions "
"when the condition isn't met.  The conditional syntax makes this pattern a "
"bit more obvious::"
msgstr ""
"Цей синтаксис може здатися дивним і зворотним; чому умова стоїть у "
"*середині* виразу, а не в передній частині, як у C ``c ? x : y``? Рішення "
"було перевірено шляхом застосування нового синтаксису до модулів у "
"стандартній бібліотеці та перегляду того, як читається отриманий код. У "
"багатьох випадках, коли використовується умовний вираз, одне значення "
"здається \"звичайним випадком\", а одне — \"винятковим випадком\", яке "
"використовується лише в рідкісних випадках, коли умова не виконується. "
"Умовний синтаксис робить цей шаблон трохи очевиднішим:"

#: ../../whatsnew/2.5.rst:92
msgid ""
"I read the above statement as meaning \"here *contents* is  usually assigned"
" a value of ``doc+'\\n'``; sometimes  *doc* is empty, in which special case "
"an empty string is returned.\"   I doubt I will use conditional expressions "
"very often where there  isn't a clear common and uncommon case."
msgstr ""
"Я прочитав наведене вище твердження як значення \"тут *contents* зазвичай "
"присвоюється значення ``doc+'\\n'``; іноді *doc* є порожнім, у цьому "
"особливому випадку повертається порожній рядок\". Я сумніваюся, що буду дуже"
" часто використовувати умовні вирази, де немає чіткого загального та "
"незвичайного випадків."

#: ../../whatsnew/2.5.rst:97
msgid ""
"There was some discussion of whether the language should require surrounding"
" conditional expressions with parentheses.  The decision was made to *not* "
"require parentheses in the Python language's grammar, but as a matter of "
"style I think you should always use them. Consider these two statements::"
msgstr ""
"Була деяка дискусія щодо того, чи повинна мова вимагати оточувати умовні "
"вирази дужками. Було прийнято рішення *не* вимагати дужок у граматиці мови "
"Python, але з точки зору стилю я вважаю, що ви повинні завжди "
"використовувати їх. Розглянемо ці два твердження:"

#: ../../whatsnew/2.5.rst:108
msgid ""
"In the first version, I think a reader's eye might group the statement into "
"'level = 1', 'if logging', 'else 0', and think that the condition decides "
"whether the assignment to *level* is performed.  The second version reads "
"better, in my opinion, because it makes it clear that the assignment is "
"always performed and the choice is being made between two values."
msgstr ""
"Я вважаю, що в першій версії око читача може згрупувати оператор у \"level ="
" 1\", \"if logging\", \"else 0\" і вважати, що умова вирішує, чи виконується"
" призначення *level*. Друга версія, на мій погляд, читається краще, оскільки"
" в ній чітко видно, що призначення завжди виконується, а вибір здійснюється "
"між двома значеннями."

#: ../../whatsnew/2.5.rst:114
msgid ""
"Another reason for including the brackets: a few odd combinations of list "
"comprehensions and lambdas could look like incorrect conditional "
"expressions. See :pep:`308` for some examples.  If you put parentheses "
"around your conditional expressions, you won't run into this case."
msgstr ""
"Ще одна причина включення дужок: кілька дивних комбінацій списків і лямбда-"
"виразів можуть виглядати як неправильні умовні вирази. Перегляньте "
":pep:`308` для деяких прикладів. Якщо ви поставите круглі дужки навколо "
"своїх умовних виразів, ви не зіткнетеся з цим випадком."

#: ../../whatsnew/2.5.rst:123
msgid ":pep:`308` - Conditional Expressions"
msgstr ":pep:`308` - 条件表达式"

#: ../../whatsnew/2.5.rst:123
msgid ""
"PEP written by Guido van Rossum and Raymond D. Hettinger; implemented by "
"Thomas Wouters."
msgstr "PEP 由 Guido van Rossum 和 Raymond D 撰写，由 Thomas Wouters 实现。"

#: ../../whatsnew/2.5.rst:132
msgid "PEP 309: Partial Function Application"
msgstr "PEP 309: 部分功能应用"

#: ../../whatsnew/2.5.rst:134
msgid ""
"The :mod:`functools` module is intended to contain tools for functional-"
"style programming."
msgstr ":mod:`functools` 模块旨在包含用于函数式编程风格的工具。"

#: ../../whatsnew/2.5.rst:137
msgid ""
"One useful tool in this module is the :func:`partial` function. For programs"
" written in a functional style, you'll sometimes want to construct variants "
"of existing functions that have some of the parameters filled in.  Consider "
"a Python function ``f(a, b, c)``; you could create a new function ``g(b, "
"c)`` that was equivalent to ``f(1, b, c)``.  This is called \"partial "
"function application\"."
msgstr ""
"Одним з корисних інструментів у цьому модулі є функція :func:`partial`. Для "
"програм, написаних у функціональному стилі, ви іноді захочете побудувати "
"варіанти існуючих функцій із заповненими деякими параметрами. Розглянемо "
"функцію Python ``f(a, b, c)``; ви можете створити нову функцію ``g(b, c)``, "
"яка була б еквівалентною ``f(1, b, c)``. Це називається \"часткове "
"застосування функції\"."

#: ../../whatsnew/2.5.rst:144
msgid ""
":func:`partial` takes the arguments ``(function, arg1, arg2, ... "
"kwarg1=value1, kwarg2=value2)``.  The resulting object is callable, so you "
"can just call it to invoke *function* with the filled-in arguments."
msgstr ""
":func:`partial` приймає аргументи ``(function, arg1, arg2, ... "
"kwarg1=value1, kwarg2=value2)``. Отриманий об’єкт можна викликати, тому ви "
"можете просто викликати його, щоб викликати *функцію* із заповненими "
"аргументами."

#: ../../whatsnew/2.5.rst:148
msgid "Here's a small but realistic example::"
msgstr "这里有一个很小但很现实的例子::"

#: ../../whatsnew/2.5.rst:160
msgid ""
"Here's another example, from a program that uses PyGTK.  Here a context-"
"sensitive pop-up menu is being constructed dynamically.  The callback "
"provided for the menu option is a partially applied version of the "
":meth:`open_item` method, where the first argument has been provided. ::"
msgstr ""
"Ось ще один приклад із програми, яка використовує PyGTK. Тут динамічно "
"створюється контекстно-залежне спливаюче меню. Зворотний виклик, наданий для"
" опції меню, є частково застосованою версією методу :meth:`open_item`, де "
"надано перший аргумент. ::"

#: ../../whatsnew/2.5.rst:173
msgid ""
"Another function in the :mod:`functools` module is the "
"``update_wrapper(wrapper, wrapped)`` function that helps you write well-"
"behaved decorators.  :func:`update_wrapper` copies the name, module, and "
"docstring attribute to a wrapper function so that tracebacks inside the "
"wrapped function are easier to understand.  For example, you might write::"
msgstr ""
"Іншою функцією в модулі :mod:`functools` є функція ``update_wrapper(wrapper,"
" wrapped)``, яка допомагає вам писати добре поведені декоратори. "
":func:`update_wrapper` копіює ім’я, модуль і атрибут рядка документів у "
"функцію-огортку, щоб легше було зрозуміти відстеження всередині обгорнутої "
"функції. Наприклад, ви можете написати::"

#: ../../whatsnew/2.5.rst:186
msgid ""
":func:`wraps` is a decorator that can be used inside your own decorators to "
"copy the wrapped function's information.  An alternate  version of the "
"previous example would be::"
msgstr ""
":func:`wraps` — це декоратор, який можна використовувати у ваших власних "
"декораторах для копіювання інформації обгорнутої функції. Альтернативною "
"версією попереднього прикладу буде::"

#: ../../whatsnew/2.5.rst:201
msgid ":pep:`309` - Partial Function Application"
msgstr ":pep:`309` - 部分函数应用"

#: ../../whatsnew/2.5.rst:201
msgid ""
"PEP proposed and written by Peter Harris; implemented by Hye-Shik Chang and "
"Nick Coghlan, with adaptations by Raymond Hettinger."
msgstr ""
"PEP由 Peter Harris 提出并撰写；由 Hye-Shik Chang 和 Nick Coghlan 实现，并由 Raymond "
"Hettinger 适配。"

#: ../../whatsnew/2.5.rst:210
msgid "PEP 314: Metadata for Python Software Packages v1.1"
msgstr "PEP 314: Python软件包的元数据 v1.1"

#: ../../whatsnew/2.5.rst:212
msgid ""
"Some simple dependency support was added to Distutils.  The :func:`setup` "
"function now has ``requires``, ``provides``, and ``obsoletes`` keyword "
"parameters.  When you build a source distribution using the ``sdist`` "
"command, the dependency information will be recorded in the :file:`PKG-INFO`"
" file."
msgstr ""
"У Distutils додано підтримку простих залежностей. Функція :func:`setup` "
"тепер має ключові параметри ``requires``, ``provides`` і ``obsoletes``. Коли"
" ви створюєте вихідний дистрибутив за допомогою команди ``sdist``, "
"інформація про залежності буде записана у файл :file:`PKG-INFO`."

#: ../../whatsnew/2.5.rst:217
msgid ""
"Another new keyword parameter is ``download_url``, which should be set to a "
"URL for the package's source code.  This means it's now possible to look up "
"an entry in the package index, determine the dependencies for a package, and"
" download the required packages. ::"
msgstr ""
"Іншим новим параметром ключового слова є ``download_url``, який має бути "
"встановлено на URL-адресу вихідного коду пакета. Це означає, що тепер можна "
"шукати запис в індексі пакетів, визначати залежності для пакета та "
"завантажувати необхідні пакети. ::"

#: ../../whatsnew/2.5.rst:231
msgid ""
"Another new enhancement to the Python package index at https://pypi.org is "
"storing source and binary archives for a package.  The new :command:`upload`"
" Distutils command will upload a package to the repository."
msgstr ""
"Інше нове вдосконалення індексу пакетів Python на https://pypi.org — це "
"зберігання вихідних і двійкових архівів для пакета. Нова команда "
":command:`upload` Distutils завантажить пакет до репозиторію."

#: ../../whatsnew/2.5.rst:236
msgid ""
"Before a package can be uploaded, you must be able to build a distribution "
"using the :command:`sdist` Distutils command.  Once that works, you can run "
"``python setup.py upload`` to add your package to the PyPI archive.  "
"Optionally you can GPG-sign the package by supplying the :option:`!--sign` "
"and :option:`!--identity` options."
msgstr ""
"Перш ніж можна буде завантажити пакет, ви повинні мати можливість створити "
"дистрибутив за допомогою команди :command:`sdist` Distutils. Коли це "
"запрацює, ви можете запустити ``python setup.py upload``, щоб додати свій "
"пакет до архіву PyPI. За бажанням ви можете підписати пакет GPG, вказавши "
"параметри :option:`!--sign` і :option:`!--identity`."

#: ../../whatsnew/2.5.rst:242
msgid ""
"Package uploading was implemented by Martin von Löwis and Richard Jones."
msgstr "包上传操作由 Martin von Löwis 和 Richard Jones 实现。"

#: ../../whatsnew/2.5.rst:248
msgid ":pep:`314` - Metadata for Python Software Packages v1.1"
msgstr ":pep:`314` - Python软件包的元数据 v1.1"

#: ../../whatsnew/2.5.rst:248
msgid ""
"PEP proposed and written by A.M. Kuchling, Richard Jones, and Fred Drake; "
"implemented by Richard Jones and Fred Drake."
msgstr ""
"PEP 由 A.M. Kuchling, Richard Jones 和 Fred Drake 提出并撰写，由 Richard Jones 和 Fred"
" Drake 实现"

#: ../../whatsnew/2.5.rst:257
msgid "PEP 328: Absolute and Relative Imports"
msgstr "PEP 328: 绝对导入和相对导入"

#: ../../whatsnew/2.5.rst:259
msgid ""
"The simpler part of :pep:`328` was implemented in Python 2.4: parentheses "
"could now be used to enclose the names imported from a module using the "
"``from ... import ...`` statement, making it easier to import many different"
" names."
msgstr ""
":pep:`328` 的较简单部分已在 Python 2.4 中实现：现在可以用圆括号将使用 ``from ... import ...`` "
"语句导入的名称括起来，以便能够更容易地导入大量不同的名称。"

#: ../../whatsnew/2.5.rst:263
msgid ""
"The more complicated part has been implemented in Python 2.5: importing a "
"module can be specified to use absolute or package-relative imports.  The "
"plan is to move toward making absolute imports the default in future "
"versions of Python."
msgstr ""
"更复杂的部分已在 Python 2.5 中实现：可以指定使用绝对的或相对于包的导入方式来导入模块。 计划在未来的 Python "
"版本中将绝对导入方式设为默认。"

#: ../../whatsnew/2.5.rst:267
msgid "Let's say you have a package directory like this::"
msgstr "比如说你有这样一个包目录::"

#: ../../whatsnew/2.5.rst:274
msgid ""
"This defines a package named :mod:`pkg` containing the :mod:`pkg.main` and "
":mod:`pkg.string` submodules."
msgstr "这定义了一个名为 :mod:`pkg` 的包，其中包含 :mod:`pkg.main` 和 :mod:`pkg.string` 子模块。"

#: ../../whatsnew/2.5.rst:277
msgid ""
"Consider the code in the :file:`main.py` module.  What happens if it "
"executes the statement ``import string``?  In Python 2.4 and earlier, it "
"will first look in the package's directory to perform a relative import, "
"finds :file:`pkg/string.py`, imports the contents of that file as the "
":mod:`pkg.string` module, and that module is bound to the name ``string`` in"
" the :mod:`pkg.main` module's namespace."
msgstr ""
"Розглянемо код у модулі :file:`main.py`. Що станеться, якщо він виконає "
"оператор ``import string``? У Python 2.4 і раніших версіях він спочатку "
"шукає каталог пакета, щоб виконати відносний імпорт, знаходить "
":file:`pkg/string.py`, імпортує вміст цього файлу як модуль "
":mod:`pkg.string`, і цей модуль прив’язаний до імені ``string`` у просторі "
"імен модуля :mod:`pkg.main`."

#: ../../whatsnew/2.5.rst:284
msgid ""
"That's fine if :mod:`pkg.string` was what you wanted.  But what if you "
"wanted Python's standard :mod:`string` module?  There's no clean way to "
"ignore :mod:`pkg.string` and look for the standard module; generally you had"
" to look at the contents of ``sys.modules``, which is slightly unclean.    "
"Holger Krekel's :mod:`py.std` package provides a tidier way to perform "
"imports from the standard library, ``import py; py.std.string.join()``, but "
"that package isn't available on all Python installations."
msgstr ""
"Це добре, якщо :mod:`pkg.string` був тим, що ви хотіли. Але що, якщо вам "
"потрібен стандартний модуль Python :mod:`string`? Немає чистого способу "
"ігнорувати :mod:`pkg.string` і шукати стандартний модуль; загалом вам "
"доводилося дивитися на вміст ``sys.modules``, який є трохи нечистим. Пакунок"
" Хольгера Крекеля :mod:`py.std` забезпечує більш акуратний спосіб виконання "
"імпорту зі стандартної бібліотеки, ``import py; py.std.string.join()``, але "
"цей пакет доступний не для всіх установок Python."

#: ../../whatsnew/2.5.rst:292
msgid ""
"Reading code which relies on relative imports is also less clear, because a "
"reader may be confused about which module, :mod:`string` or "
":mod:`pkg.string`, is intended to be used.  Python users soon learned not to"
" duplicate the names of standard library modules in the names of their "
"packages' submodules, but you can't protect against having your submodule's "
"name being used for a new module added in a future version of Python."
msgstr ""
"Читання коду, який покладається на відносний імпорт, також менш зрозуміле, "
"тому що читач може заплутатися щодо того, який модуль, :mod:`string` або "
":mod:`pkg.string`, призначений для використання. Користувачі Python "
"незабаром навчилися не дублювати назви модулів стандартної бібліотеки в "
"назвах підмодулів своїх пакунків, але ви не можете захиститися від "
"використання назви вашого підмодуля для нового модуля, доданого в майбутній "
"версії Python."

#: ../../whatsnew/2.5.rst:299
msgid ""
"In Python 2.5, you can switch :keyword:`import`'s behaviour to  absolute "
"imports using a ``from __future__ import absolute_import`` directive.  This "
"absolute-import behaviour will become the default in a future version "
"(probably Python 2.7).  Once absolute imports  are the default, ``import "
"string`` will always find the standard library's version. It's suggested "
"that users should begin using absolute imports as much as possible, so it's "
"preferable to begin writing ``from pkg import string`` in your code."
msgstr ""
"У Python 2.5 ви можете змінити поведінку :keyword:`import` на абсолютний "
"імпорт за допомогою директиви ``from __future__ import absolute_import``. Ця"
" поведінка абсолютного імпорту стане типовою в майбутніх версіях (ймовірно, "
"Python 2.7). Якщо абсолютний імпорт встановлено за замовчуванням, ``import "
"string`` завжди знаходитиме версію стандартної бібліотеки. Рекомендується, "
"щоб користувачі якомога частіше використовували абсолютний імпорт, тому "
"краще починати писати ``from pkg import string`` у вашому коді."

#: ../../whatsnew/2.5.rst:307
msgid ""
"Relative imports are still possible by adding a leading period  to the "
"module name when using the ``from ... import`` form::"
msgstr ""
"Відносний імпорт все ще можливий, додавши початкову крапку до імені модуля "
"під час використання форми ``from ... import``::"

#: ../../whatsnew/2.5.rst:315
msgid ""
"This imports the :mod:`string` module relative to the current package, so in"
" :mod:`pkg.main` this will import *name1* and *name2* from "
":mod:`pkg.string`. Additional leading periods perform the relative import "
"starting from the parent of the current package.  For example, code in the "
":mod:`A.B.C` module can do::"
msgstr ""
"Це імпортує модуль :mod:`string` відносно поточного пакета, тому в "
":mod:`pkg.main` буде імпортовано *name1* і *name2* з :mod:`pkg.string`. "
"Додаткові початкові періоди виконують відносний імпорт, починаючи з "
"батьківського пакета поточного пакета. Наприклад, код у модулі :mod:`A.B.C` "
"може робити:"

#: ../../whatsnew/2.5.rst:324
msgid ""
"Leading periods cannot be used with the ``import modname``  form of the "
"import statement, only the ``from ... import`` form."
msgstr ""
"开头的句点不可用于 import 语句的 ``import modname`` 形式，只能用于 ``from ... import`` 形式。"

#: ../../whatsnew/2.5.rst:331
msgid ":pep:`328` - Imports: Multi-Line and Absolute/Relative"
msgstr ":pep:`328` - 导入：多行和绝对/相对导入"

#: ../../whatsnew/2.5.rst:331
msgid "PEP written by Aahz; implemented by Thomas Wouters."
msgstr "PEP 由 Aahz 撰写，由 Thomas Wouters 实现。"

#: ../../whatsnew/2.5.rst:333
msgid "https://pylib.readthedocs.io/"
msgstr "https://pylib.readthedocs.io/"

#: ../../whatsnew/2.5.rst:334
msgid ""
"The py library by Holger Krekel, which contains the :mod:`py.std` package."
msgstr "由 Holger Krekel 编写 py 库，其中包含 :mod:`py.std` 包。"

#: ../../whatsnew/2.5.rst:342
msgid "PEP 338: Executing Modules as Scripts"
msgstr "PEP 338: 将模块作为脚本执行"

#: ../../whatsnew/2.5.rst:344
msgid ""
"The :option:`-m` switch added in Python 2.4 to execute a module as a script "
"gained a few more abilities.  Instead of being implemented in C code inside "
"the Python interpreter, the switch now uses an implementation in a new "
"module, :mod:`runpy`."
msgstr ""
"Перемикач :option:`-m`, доданий у Python 2.4 для виконання модуля як "
"сценарію, отримав кілька додаткових можливостей. Замість того, щоб бути "
"реалізованим у коді C всередині інтерпретатора Python, комутатор тепер "
"використовує реалізацію в новому модулі, :mod:`runpy`."

#: ../../whatsnew/2.5.rst:349
msgid ""
"The :mod:`runpy` module implements a more sophisticated import mechanism so "
"that it's now possible to run modules in a package such as "
":mod:`pychecker.checker`. The module also supports alternative import "
"mechanisms such as the :mod:`zipimport` module.  This means you can add a "
".zip archive's path to ``sys.path`` and then use the :option:`-m` switch to "
"execute code from the archive."
msgstr ""
"Модуль :mod:`runpy` реалізує більш досконалий механізм імпорту, тому тепер "
"можна запускати модулі в пакеті, наприклад :mod:`pychecker.checker`. Модуль "
"також підтримує альтернативні механізми імпорту, такі як модуль "
":mod:`zipimport`. Це означає, що ви можете додати шлях архіву .zip до "
"``sys.path``, а потім використовувати перемикач :option:`-m` для виконання "
"коду з архіву."

#: ../../whatsnew/2.5.rst:359
msgid ":pep:`338` - Executing modules as scripts"
msgstr ":pep:`338` - 将模块作为脚本执行"

#: ../../whatsnew/2.5.rst:360
msgid "PEP written and  implemented by Nick Coghlan."
msgstr "PEP 由 Nick Coghlan 撰写并实现。"

#: ../../whatsnew/2.5.rst:368
msgid "PEP 341: Unified try/except/finally"
msgstr "PEP 341: 统一 try/except/finally"

#: ../../whatsnew/2.5.rst:370
msgid ""
"Until Python 2.5, the :keyword:`try` statement came in two flavours. You "
"could use a :keyword:`finally` block to ensure that code is always executed,"
" or one or more :keyword:`except` blocks to catch  specific exceptions.  You"
" couldn't combine both :keyword:`!except` blocks and a :keyword:`!finally` "
"block, because generating the right bytecode for the combined version was "
"complicated and it wasn't clear what the semantics of the combined statement"
" should be."
msgstr ""
"До Python 2.5 оператор :keyword:`try` був у двох варіантах. Ви можете "
"використовувати блок :keyword:`finally`, щоб гарантувати, що код завжди "
"виконується, або один чи більше блоків :keyword:`except`, щоб перехоплювати "
"певні винятки. Ви не могли поєднати обидва блоки :keyword:`!except` і блок "
":keyword:`!finally`, оскільки генерація правильного байт-коду для "
"комбінованої версії була складною, і було незрозуміло, якою має бути "
"семантика комбінованого оператора бути."

#: ../../whatsnew/2.5.rst:377
msgid ""
"Guido van Rossum spent some time working with Java, which does support the "
"equivalent of combining :keyword:`except` blocks and a :keyword:`finally` "
"block, and this clarified what the statement should mean.  In Python 2.5, "
"you can now write::"
msgstr ""
"Гвідо ван Россум провів деякий час, працюючи з Java, яка підтримує "
"еквівалент поєднання блоків :keyword:`except` і блоку :keyword:`finally`, і "
"це прояснило, що має означати цей оператор. У Python 2.5 тепер можна "
"писати::"

#: ../../whatsnew/2.5.rst:393
msgid ""
"The code in *block-1* is executed.  If the code raises an exception, the "
"various :keyword:`except` blocks are tested: if the exception is of class "
":class:`Exception1`, *handler-1* is executed; otherwise if it's of class "
":class:`Exception2`, *handler-2* is executed, and so forth.  If no exception"
" is raised, the *else-block* is executed."
msgstr ""
"Код у *block-1* виконується. Якщо код викликає виняток, перевіряються різні "
"блоки :keyword:`except`: якщо виняток належить до класу :class:`Exception1`,"
" виконується *handler-1*; інакше, якщо він належить до класу "
":class:`Exception2`, виконується *обробник-2* і так далі. Якщо жодного "
"винятку не виникає, виконується *else-block*."

#: ../../whatsnew/2.5.rst:399
msgid ""
"No matter what happened previously, the *final-block* is executed once the "
"code block is complete and any raised exceptions handled. Even if there's an"
" error in an exception handler or the *else-block* and a new exception is "
"raised, the code in the *final-block* is still run."
msgstr ""
"Незалежно від того, що сталося раніше, *final-block* виконується після "
"завершення блоку коду та обробки будь-яких викликаних винятків. Навіть якщо "
"сталася помилка в обробнику винятків або *else-block* і виникає новий "
"виняток, код у *final-block* все одно виконується."

#: ../../whatsnew/2.5.rst:407
msgid ":pep:`341` - Unifying try-except and try-finally"
msgstr ":pep:`341` - 统一 try-except 和 try-finally"

#: ../../whatsnew/2.5.rst:408
msgid "PEP written by Georg Brandl;  implementation by Thomas Lee."
msgstr "PEP 由 Georg Brandl 撰写，由 Thomas Lee 实现。"

#: ../../whatsnew/2.5.rst:416
msgid "PEP 342: New Generator Features"
msgstr "PEP 342: 生成器的新特性"

#: ../../whatsnew/2.5.rst:418
msgid ""
"Python 2.5 adds a simple way to pass values *into* a generator. As "
"introduced in Python 2.3, generators only produce output; once a generator's"
" code was invoked to create an iterator, there was no way to pass any new "
"information into the function when its execution is resumed.  Sometimes the "
"ability to pass in some information would be useful.  Hackish solutions to "
"this include making the generator's code look at a global variable and then "
"changing the global variable's value, or passing in some mutable object that"
" callers then modify."
msgstr ""
"Python 2.5 додає простий спосіб передачі значень *у* генератор. Як було "
"введено в Python 2.3, генератори створюють лише вихід; як тільки код "
"генератора був викликаний для створення ітератора, не було можливості "
"передати будь-яку нову інформацію у функцію, коли її виконання відновилося. "
"Іноді можливість передати певну інформацію буде корисною. Хакерські рішення "
"для цього включають змусити код генератора переглядати глобальну змінну, а "
"потім змінювати значення глобальної змінної або передавати якийсь змінний "
"об’єкт, який потім змінюють абоненти."

#: ../../whatsnew/2.5.rst:426
msgid "To refresh your memory of basic generators, here's a simple example::"
msgstr "Щоб оновити вашу пам'ять про основні генератори, ось простий приклад:"

#: ../../whatsnew/2.5.rst:434
msgid ""
"When you call ``counter(10)``, the result is an iterator that returns the "
"values from 0 up to 9.  On encountering the :keyword:`yield` statement, the "
"iterator returns the provided value and suspends the function's execution, "
"preserving the local variables. Execution resumes on the following call to "
"the iterator's :meth:`next` method, picking up after the :keyword:`!yield` "
"statement."
msgstr ""
"Коли ви викликаєте ``counter(10)``, результатом є ітератор, який повертає "
"значення від 0 до 9. Коли зустрічається оператор :keyword:`yield`, ітератор "
"повертає надане значення та призупиняє виконання функції, збереження "
"локальних змінних. Виконання поновлюється після наступного виклику методу "
":meth:`next` ітератора, який починається після оператора :keyword:`!yield`."

#: ../../whatsnew/2.5.rst:440
msgid ""
"In Python 2.3, :keyword:`yield` was a statement; it didn't return any value."
"  In 2.5, :keyword:`!yield` is now an expression, returning a value that can"
" be assigned to a variable or otherwise operated on::"
msgstr ""
"У Python 2.3 :keyword:`yield` був оператором; він не повернув жодного "
"значення. У версії 2.5 :keyword:`!yield` тепер є виразом, що повертає "
"значення, яке можна призначити змінній або іншим чином оперувати:"

#: ../../whatsnew/2.5.rst:446
msgid ""
"I recommend that you always put parentheses around a :keyword:`yield` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Я рекомендую вам завжди брати дужки навколо виразу :keyword:`yield`, коли ви"
" щось робите з повернутим значенням, як у прикладі вище. Дужки не завжди "
"потрібні, але простіше завжди додавати їх замість того, щоб запам’ятовувати,"
" коли вони потрібні."

#: ../../whatsnew/2.5.rst:451
msgid ""
"(:pep:`342` explains the exact rules, which are that a :keyword:`yield`\\ "
"-expression must always be parenthesized except when it occurs at the top-"
"level expression on the right-hand side of an assignment.  This means you "
"can write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` пояснює точні правила, які полягають у тому, що "
":keyword:`yield`\\ -вираз завжди повинен бути взятий у дужки, за винятком "
"випадків, коли він зустрічається у виразі верхнього рівня в правій частині "
"призначення. Це означає, що ви можете написати ``val = yield i``, але "
"повинні використовувати круглі дужки, коли є операція, як у ``val = (yield "
"i) + 12``.)"

#: ../../whatsnew/2.5.rst:458
msgid ""
"Values are sent into a generator by calling its ``send(value)`` method.  The"
" generator's code is then resumed and the :keyword:`yield` expression "
"returns the specified *value*.  If the regular :meth:`next` method is "
"called, the :keyword:`!yield` returns :const:`None`."
msgstr ""
"Значення надсилаються в генератор шляхом виклику його методу "
"``send(value)``. Потім код генератора відновлюється, і вираз "
":keyword:`yield` повертає вказане *значення*. Якщо викликається звичайний "
"метод :meth:`next`, :keyword:`!yield` повертає :const:`None`."

#: ../../whatsnew/2.5.rst:463
msgid ""
"Here's the previous example, modified to allow changing the value of the "
"internal counter. ::"
msgstr ""
"Ось попередній приклад, змінений, щоб дозволити змінювати значення "
"внутрішнього лічильника. ::"

#: ../../whatsnew/2.5.rst:476
msgid "And here's an example of changing the counter::"
msgstr "А ось приклад зміни лічильника::"

#: ../../whatsnew/2.5.rst:493
msgid ""
":keyword:`yield` will usually return :const:`None`, so you should always "
"check for this case.  Don't just use its value in expressions unless you're "
"sure that the :meth:`send` method will be the only method used to resume "
"your generator function."
msgstr ""
":keyword:`yield` зазвичай повертає :const:`None`, тому ви завжди повинні "
"перевіряти цей випадок. Не просто використовуйте його значення у виразах, "
"якщо ви не впевнені, що метод :meth:`send` буде єдиним методом, використаним"
" для відновлення вашої функції генератора."

#: ../../whatsnew/2.5.rst:498
msgid ""
"In addition to :meth:`send`, there are two other new methods on generators:"
msgstr "Крім :meth:`send`, є ще два нові методи генераторів:"

#: ../../whatsnew/2.5.rst:500
msgid ""
"``throw(type, value=None, traceback=None)`` is used to raise an exception "
"inside the generator; the exception is raised by the :keyword:`yield` "
"expression where the generator's execution is paused."
msgstr ""
"``throw(type, value=None, traceback=None)`` використовується для створення "
"винятку всередині генератора; виняток викликає вираз :keyword:`yield`, де "
"виконання генератора призупинено."

#: ../../whatsnew/2.5.rst:504
msgid ""
":meth:`close` raises a new :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`.  Catching the :exc:`GeneratorExit` exception and "
"returning a value is illegal and will trigger a :exc:`RuntimeError`; if the "
"function raises some other exception, that exception is propagated to the "
"caller.  :meth:`close` will also be called by Python's garbage collector "
"when the generator is garbage-collected."
msgstr ""
":meth:`close` створює новий виняток :exc:`GeneratorExit` всередині "
"генератора, щоб завершити ітерацію. Отримавши цей виняток, код генератора "
"повинен викликати :exc:`GeneratorExit` або :exc:`StopIteration`. "
"Перехоплення винятку :exc:`GeneratorExit` і повернення значення є незаконним"
" і викличе :exc:`RuntimeError`; якщо функція викликає якийсь інший виняток, "
"цей виняток поширюється на виклик. :meth:`close` також буде викликано "
"збирачем сміття Python, коли генератор збирає сміття."

#: ../../whatsnew/2.5.rst:512
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of  catching "
":exc:`GeneratorExit`."
msgstr ""
"如果你需要在 :exc:`GeneratorExit` 发生的时候运行清理代码，我建议使用 ``try: ... finally:`` 组合来代替捕获 "
":exc:`GeneratorExit`。"

#: ../../whatsnew/2.5.rst:515
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "这些改变的累积效应是，让生成器从单向的信息生产者变成了既是生产者，又是消费者。"

#: ../../whatsnew/2.5.rst:518
msgid ""
"Generators also become *coroutines*, a more generalized form of subroutines."
" Subroutines are entered at one point and exited at another point (the top "
"of the function, and a :keyword:`return` statement), but coroutines can be "
"entered, exited, and resumed at many different points (the :keyword:`yield` "
"statements). We'll have to figure out patterns for using coroutines "
"effectively in Python."
msgstr ""
"Генератори також стають *сопрограмами*, більш узагальненою формою "
"підпрограм. Підпрограми вводяться в одній точці та виходять з іншої точки "
"(верхня частина функції та оператор :keyword:`return`), але до підпрограм "
"можна ввійти, вийти з них і відновити їх у багатьох різних точках ( "
":keyword:`yield` заяви). Нам доведеться з’ясувати шаблони для ефективного "
"використання співпрограм у Python."

#: ../../whatsnew/2.5.rst:524
msgid ""
"The addition of the :meth:`close` method has one side effect that isn't "
"obvious. :meth:`close` is called when a generator is garbage-collected, so "
"this means the generator's code gets one last chance to run before the "
"generator is destroyed. This last chance means that ``try...finally`` "
"statements in generators can now be guaranteed to work; the "
":keyword:`finally` clause will now always get a chance to run.  The "
"syntactic restriction that you couldn't mix :keyword:`yield` statements with"
" a ``try...finally`` suite has therefore been removed.  This seems like a "
"minor bit of language trivia, but using generators and ``try...finally`` is "
"actually necessary in order to implement the :keyword:`with` statement "
"described by :pep:`343`.  I'll look at this new statement in the following  "
"section."
msgstr ""
"Додавання методу :meth:`close` має один побічний ефект, який не є очевидним."
" :meth:`close` викликається, коли генератор збирає сміття, тому це означає, "
"що код генератора отримує останній шанс запуститися, перш ніж генератор буде"
" знищено. Цей останній шанс означає, що оператори ``try...finally`` у "
"генераторах тепер можуть гарантовано працювати; речення :keyword:`finally` "
"тепер завжди матиме шанс запуститися. Синтаксичне обмеження, згідно з яким "
"ви не можете змішувати оператори :keyword:`yield` із пакетом "
"``try...finally``, було видалено. Це виглядає як незначна мовна дрібниця, "
"але використання генераторів і ``try...finally`` насправді є необхідним для "
"реалізації оператора :keyword:`with`, описаного :pep:`343`. Я розгляну цю "
"нову заяву в наступному розділі."

#: ../../whatsnew/2.5.rst:536
msgid ""
"Another even more esoteric effect of this change: previously, the "
":attr:`gi_frame` attribute of a generator was always a frame object. It's "
"now possible for :attr:`gi_frame` to be ``None`` once the generator has been"
" exhausted."
msgstr ""
"Інший ще більш езотеричний ефект цієї зміни: раніше атрибут :attr:`gi_frame`"
" генератора завжди був об’єктом фрейму. Тепер :attr:`gi_frame` може мати "
"значення ``None``, коли генератор вичерпано."

#: ../../whatsnew/2.5.rst:549
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 通过增强型生成器实现协程"

#: ../../whatsnew/2.5.rst:545
msgid ""
"PEP written by  Guido van Rossum and Phillip J. Eby; implemented by Phillip "
"J. Eby.  Includes examples of  some fancier uses of generators as "
"coroutines."
msgstr ""
"PEP 由 Guido van Rossum 和 Phillip J. Eby 撰写，由 Phillip J. Eby "
"实现。包括一些更高级的使用生成器作为协程的示例。"

#: ../../whatsnew/2.5.rst:548
msgid ""
"Earlier versions of these features were proposed in  :pep:`288` by Raymond "
"Hettinger and :pep:`325` by Samuele Pedroni."
msgstr ""
"这些功能的早期版本在 :pep:`288` （由 Raymond Hettinger 撰写） 和 :pep:`325` （由 Samuele "
"Pedroni 撰写）中提出。"

#: ../../whatsnew/2.5.rst:552
msgid "https://en.wikipedia.org/wiki/Coroutine"
msgstr "https://en.wikipedia.org/wiki/Coroutine"

#: ../../whatsnew/2.5.rst:552
msgid "The Wikipedia entry for  coroutines."
msgstr "协程的Wikipedia条目。"

#: ../../whatsnew/2.5.rst:554
msgid ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html"
msgstr ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html"

#: ../../whatsnew/2.5.rst:555
msgid ""
"An explanation of coroutines from a Perl point of view, written by Dan "
"Sugalski."
msgstr "基于 Perl 视角对协程的介绍，由 Dan Sugalski 撰写。"

#: ../../whatsnew/2.5.rst:563
msgid "PEP 343: The 'with' statement"
msgstr "PEP 343: \"with\" 语句"

#: ../../whatsnew/2.5.rst:565
msgid ""
"The ':keyword:`with`' statement clarifies code that previously would use "
"``try...finally`` blocks to ensure that clean-up code is executed.  In this "
"section, I'll discuss the statement as it will commonly be used.  In the "
"next section, I'll examine the implementation details and show how to write "
"objects for use with this statement."
msgstr ""
"Інструкція ':keyword:`with`' уточнює код, який раніше використовував блоки "
"``try...finally``, щоб забезпечити виконання коду очищення. У цьому розділі "
"я обговорю твердження, як воно буде зазвичай використовуватися. У наступному"
" розділі я розгляну деталі реалізації та покажу, як писати об’єкти для "
"використання з цим оператором."

#: ../../whatsnew/2.5.rst:571
msgid ""
"The ':keyword:`with`' statement is a new control-flow structure whose basic "
"structure is::"
msgstr ""
"Оператор ':keyword:`with`' — це нова структура потоку керування, основна "
"структура якої:"

#: ../../whatsnew/2.5.rst:577
msgid ""
"The expression is evaluated, and it should result in an object that supports"
" the context management protocol (that is, has :meth:`__enter__` and "
":meth:`__exit__` methods."
msgstr ""

#: ../../whatsnew/2.5.rst:581
msgid ""
"The object's :meth:`__enter__` is called before *with-block* is executed and"
" therefore can run set-up code. It also may return a value that is bound to "
"the name *variable*, if given.  (Note carefully that *variable* is *not* "
"assigned the result of *expression*.)"
msgstr ""

#: ../../whatsnew/2.5.rst:586
msgid ""
"After execution of the *with-block* is finished, the object's "
":meth:`__exit__` method is called, even if the block raised an exception, "
"and can therefore run clean-up code."
msgstr ""

#: ../../whatsnew/2.5.rst:590
msgid ""
"To enable the statement in Python 2.5, you need to add the following "
"directive to your module::"
msgstr "要在 Python 2.5 中启用该语句，你需要向你的模块添加以下指令::"

#: ../../whatsnew/2.5.rst:595
msgid "The statement will always be enabled in Python 2.6."
msgstr "该语句在Python 2.6 中始终启用。"

#: ../../whatsnew/2.5.rst:597
msgid ""
"Some standard Python objects now support the context management protocol and"
" can be used with the ':keyword:`with`' statement. File objects are one "
"example::"
msgstr "一些标准 Python 对象现在已支持上下文管理协议并可被用于 ':keyword:`with`' 语句。 文件对象就是一个例子::"

#: ../../whatsnew/2.5.rst:605
msgid ""
"After this statement has executed, the file object in *f* will have been "
"automatically closed, even if the :keyword:`for` loop raised an exception "
"part-way through the block."
msgstr "在此语句被执行之后，文件对象 *f* 将被自动关闭，即使是当 :keyword:`for` 循环在代码块中间引发了异常的时候也是如此。"

#: ../../whatsnew/2.5.rst:611
msgid ""
"In this case, *f* is the same object created by :func:`open`, because "
":meth:`file.__enter__` returns *self*."
msgstr ""

#: ../../whatsnew/2.5.rst:614
msgid ""
"The :mod:`threading` module's locks and condition variables  also support "
"the ':keyword:`with`' statement::"
msgstr ":mod:`threading` 模块的加锁和条件变量也支持 ':keyword:`with`' 语句::"

#: ../../whatsnew/2.5.rst:622
msgid ""
"The lock is acquired before the block is executed and always released once  "
"the block is complete."
msgstr "这个锁会在代码块被执行之前锁定并总是会在代码块完成之后释放。"

#: ../../whatsnew/2.5.rst:625
msgid ""
"The new :func:`localcontext` function in the :mod:`decimal` module makes it "
"easy to save and restore the current decimal context, which encapsulates the"
" desired precision and rounding characteristics for computations::"
msgstr ""
"Нова функція :func:`localcontext` у модулі :mod:`decimal` дозволяє легко "
"зберігати та відновлювати поточний десятковий контекст, який інкапсулює "
"бажану точність і характеристики округлення для обчислень:"

#: ../../whatsnew/2.5.rst:644
msgid "Writing Context Managers"
msgstr "编写上下文管理器"

#: ../../whatsnew/2.5.rst:646
msgid ""
"Under the hood, the ':keyword:`with`' statement is fairly complicated. Most "
"people will only use ':keyword:`!with`' in company with existing objects and"
" don't need to know these details, so you can skip the rest of this section "
"if you like.  Authors of new objects will need to understand the details of "
"the underlying implementation and should keep reading."
msgstr ""
"Під капотом оператор ':keyword:`with`' досить складний. Більшість людей "
"використовуватимуть ':keyword:`!with`' тільки в компанії з існуючими "
"об'єктами, і їм не потрібно знати ці деталі, тому ви можете пропустити решту"
" цього розділу, якщо хочете. Авторам нових об’єктів потрібно буде зрозуміти "
"деталі базової реалізації та продовжувати читати."

#: ../../whatsnew/2.5.rst:652
msgid "A high-level explanation of the context management protocol is:"
msgstr "在更高层级上对于上下文管理器协议的解释:"

#: ../../whatsnew/2.5.rst:654
msgid ""
"The expression is evaluated and should result in an object called a "
"\"context manager\".  The context manager must have :meth:`__enter__` and "
":meth:`__exit__` methods."
msgstr ""

#: ../../whatsnew/2.5.rst:658
msgid ""
"The context manager's :meth:`__enter__` method is called.  The value "
"returned is assigned to *VAR*.  If no ``'as VAR'`` clause is present, the "
"value is simply discarded."
msgstr ""

#: ../../whatsnew/2.5.rst:662
msgid "The code in *BLOCK* is executed."
msgstr "*BLOCK* 中的代码会被执行。"

#: ../../whatsnew/2.5.rst:664
msgid ""
"If *BLOCK* raises an exception, the ``__exit__(type, value, traceback)`` is "
"called with the exception details, the same values returned by "
":func:`sys.exc_info`.  The method's return value controls whether the "
"exception is re-raised: any false value re-raises the exception, and "
"``True`` will result in suppressing it.  You'll only rarely want to suppress"
" the exception, because if you do the author of the code containing the "
"':keyword:`with`' statement will never realize anything went wrong."
msgstr ""
"Якщо *BLOCK* викликає виняток, викликається ``__exit__(type, value, "
"traceback)`` з деталями винятку, ті самі значення, які повертає "
":func:`sys.exc_info`. Повернене значення методу контролює, чи буде виняток "
"повторно викликаний: будь-яке значення false повторно викликає виняток, а "
"``True`` призведе до його придушення. Ви рідко захочете придушити виняток, "
"тому що, якщо ви це зробите, автор коду, що містить оператор "
"':keyword:`with`', ніколи не зрозуміє, що щось пішло не так."

#: ../../whatsnew/2.5.rst:672
msgid ""
"If *BLOCK* didn't raise an exception,  the :meth:`__exit__` method is still "
"called, but *type*, *value*, and *traceback* are all ``None``."
msgstr ""

#: ../../whatsnew/2.5.rst:675
msgid ""
"Let's think through an example.  I won't present detailed code but will only"
" sketch the methods necessary for a database that supports transactions."
msgstr ""
"Давайте поміркуємо на прикладі. Я не буду представляти детальний код, а лише"
" накидаю методи, необхідні для бази даних, яка підтримує транзакції."

#: ../../whatsnew/2.5.rst:678
msgid ""
"(For people unfamiliar with database terminology: a set of changes to the "
"database are grouped into a transaction.  Transactions can be either "
"committed, meaning that all the changes are written into the database, or "
"rolled back, meaning that the changes are all discarded and the database is "
"unchanged.  See any database textbook for more information.)"
msgstr ""
"(Для людей, які не знайомі з термінологією бази даних: набір змін до бази "
"даних групується в транзакцію. Транзакції можуть бути або зафіксованими, "
"тобто всі зміни записуються в базу даних, або відкоченими, тобто всі зміни "
"скасовуються та база даних не змінена. Для отримання додаткової інформації "
"зверніться до будь-якого підручника з баз даних.)"

#: ../../whatsnew/2.5.rst:684
msgid ""
"Let's assume there's an object representing a database connection. Our goal "
"will be to let the user write code like this::"
msgstr ""
"Припустімо, що існує об’єкт, що представляє з’єднання з базою даних. Нашою "
"метою буде дозволити користувачеві писати такий код:"

#: ../../whatsnew/2.5.rst:693
msgid ""
"The transaction should be committed if the code in the block runs flawlessly"
" or rolled back if there's an exception. Here's the basic interface for "
":class:`DatabaseConnection` that I'll assume::"
msgstr ""
"Транзакцію слід зафіксувати, якщо код у блоці працює бездоганно, або "
"відкотити, якщо є виняткова ситуація. Ось базовий інтерфейс для "
":class:`DatabaseConnection`, який я припускаю:"

#: ../../whatsnew/2.5.rst:706
msgid ""
"The :meth:`__enter__` method is pretty easy, having only to start a new "
"transaction.  For this application the resulting cursor object would be a "
"useful result, so the method will return it.  The user can then add ``as "
"cursor`` to their ':keyword:`with`' statement to bind the cursor to a "
"variable name. ::"
msgstr ""

#: ../../whatsnew/2.5.rst:718
msgid ""
"The :meth:`__exit__` method is the most complicated because it's where most "
"of the work has to be done.  The method has to check if an exception "
"occurred.  If there was no exception, the transaction is committed.  The "
"transaction is rolled back if there was an exception."
msgstr ""

#: ../../whatsnew/2.5.rst:723
msgid ""
"In the code below, execution will just fall off the end of the function, "
"returning the default value of ``None``.  ``None`` is false, so the "
"exception will be re-raised automatically.  If you wished, you could be more"
" explicit and add a :keyword:`return` statement at the marked location. ::"
msgstr ""
"У наведеному нижче коді виконання просто припиниться в кінці функції, "
"повертаючи значення за замовчуванням ``None``. ``None`` є хибним, тому "
"виняток буде знову створено автоматично. Якщо ви бажаєте, ви можете бути "
"більш чіткими та додати оператор :keyword:`return` у позначене місце. ::"

#: ../../whatsnew/2.5.rst:743
msgid "The contextlib module"
msgstr "contextlib 模块"

#: ../../whatsnew/2.5.rst:745
msgid ""
"The new :mod:`contextlib` module provides some functions and a decorator "
"that are useful for writing objects for use with the ':keyword:`with`' "
"statement."
msgstr ""
"Новий модуль :mod:`contextlib` надає деякі функції та декоратор, корисні для"
" написання об’єктів для використання з оператором ':keyword:`with`'."

#: ../../whatsnew/2.5.rst:748
msgid ""
"The decorator is called :func:`contextmanager`, and lets you write a single "
"generator function instead of defining a new class.  The generator should "
"yield exactly one value.  The code up to the :keyword:`yield` will be "
"executed as the :meth:`__enter__` method, and the value yielded will be the "
"method's return value that will get bound to the variable in the "
"':keyword:`with`' statement's :keyword:`!as` clause, if any.  The code after"
" the :keyword:`yield` will be executed in the :meth:`__exit__` method.  Any "
"exception raised in the block will be raised by the :keyword:`!yield` "
"statement."
msgstr ""

#: ../../whatsnew/2.5.rst:757
msgid ""
"Our database example from the previous section could be written  using this "
"decorator as::"
msgstr ""
"Наш приклад бази даних із попереднього розділу можна записати за допомогою "
"цього декоратора як:"

#: ../../whatsnew/2.5.rst:777
msgid ""
"The :mod:`contextlib` module also has a ``nested(mgr1, mgr2, ...)`` function"
" that combines a number of context managers so you don't need to write "
"nested ':keyword:`with`' statements.  In this example, the single "
"':keyword:`!with`' statement both starts a database transaction and acquires"
" a thread lock::"
msgstr ""
"Модуль :mod:`contextlib` також має функцію ``nested(mgr1, mgr2, ...)``, яка "
"об’єднує кілька контекстних менеджерів, тому вам не потрібно писати "
"вкладений ':keyword:`with`' заяви. У цьому прикладі один оператор "
"':keyword:`!with`' запускає транзакцію бази даних і отримує блокування "
"потоку::"

#: ../../whatsnew/2.5.rst:786
msgid ""
"Finally, the ``closing(object)`` function returns *object* so that it can be"
" bound to a variable, and calls ``object.close`` at the end of the block. ::"
msgstr ""
"Нарешті, функція ``closing(object)`` повертає *object*, щоб його можна було "
"прив’язати до змінної, і викликає ``object.close`` у кінці блоку. ::"

#: ../../whatsnew/2.5.rst:803
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 语句"

#: ../../whatsnew/2.5.rst:800
msgid ""
"PEP written by Guido van Rossum and Nick Coghlan; implemented by Mike Bland,"
" Guido van Rossum, and Neal Norwitz.  The PEP shows the code generated for a"
" ':keyword:`with`' statement, which can be helpful in learning how the "
"statement works."
msgstr ""
"PEP, написаний Гвідо ван Россумом і Ніком Когланом; реалізований Майком "
"Блендом, Гвідо ван Россумом і Нілом Норвітцем. PEP показує код, згенерований"
" для оператора ':keyword:`with`', який може бути корисним для вивчення того,"
" як працює оператор."

#: ../../whatsnew/2.5.rst:805
msgid "The documentation  for the :mod:`contextlib` module."
msgstr ":mod:`contextlib` 模块的文档。"

#: ../../whatsnew/2.5.rst:813
msgid "PEP 352: Exceptions as New-Style Classes"
msgstr "PEP 352: 异常作为新型的类"

#: ../../whatsnew/2.5.rst:815
msgid ""
"Exception classes can now be new-style classes, not just classic classes, "
"and the built-in :exc:`Exception` class and all the standard built-in "
"exceptions (:exc:`NameError`, :exc:`ValueError`, etc.) are now new-style "
"classes."
msgstr ""
"Класи винятків тепер можуть бути класами нового стилю, а не лише класичними "
"класами, а також вбудованим класом :exc:`Exception` і всіма стандартними "
"вбудованими винятками (:exc:`NameError`, :exc:`ValueError`, і т.д.) тепер є "
"класами нового стилю."

#: ../../whatsnew/2.5.rst:819
msgid ""
"The inheritance hierarchy for exceptions has been rearranged a bit. In 2.5, "
"the inheritance relationships are::"
msgstr ""
"Ієрархію успадкування для винятків було дещо змінено. У 2.5 відносини "
"успадкування такі:"

#: ../../whatsnew/2.5.rst:828
msgid ""
"This rearrangement was done because people often want to catch all "
"exceptions that indicate program errors.  :exc:`KeyboardInterrupt` and "
":exc:`SystemExit` aren't errors, though, and usually represent an explicit "
"action such as the user hitting :kbd:`Control-C` or code calling "
":func:`sys.exit`.  A bare ``except:`` will catch all exceptions, so you "
"commonly need to list :exc:`KeyboardInterrupt` and :exc:`SystemExit` in "
"order to re-raise them.  The usual pattern is::"
msgstr ""
"Це перевпорядкування було зроблено, оскільки люди часто хочуть перехопити "
"всі винятки, які вказують на помилки програми. :exc:`KeyboardInterrupt` і "
":exc:`SystemExit` не є помилками, однак, і зазвичай представляють явну дію, "
"наприклад натискання користувачем :kbd:`Control-C` або виклик коду "
":func:`sys.exit` . Голе ``except:`` перехопить усі винятки, тому вам "
"зазвичай потрібно перерахувати :exc:`KeyboardInterrupt` і :exc:`SystemExit`,"
" щоб повторно викликати їх. Звичайний шаблон такий::"

#: ../../whatsnew/2.5.rst:843
msgid ""
"In Python 2.5, you can now write ``except Exception`` to achieve the same "
"result, catching all the exceptions that usually indicate errors  but "
"leaving :exc:`KeyboardInterrupt` and :exc:`SystemExit` alone.  As in "
"previous versions, a bare ``except:`` still catches all exceptions."
msgstr ""
"У Python 2.5 тепер ви можете написати ``except Exception``, щоб досягти того"
" самого результату, перехоплюючи всі винятки, які зазвичай вказують на "
"помилки, але залишаючи :exc:`KeyboardInterrupt` і :exc:`SystemExit` окремо. "
"Як і в попередніх версіях, голе ``except:`` усе ще перехоплює всі винятки."

#: ../../whatsnew/2.5.rst:848
msgid ""
"The goal for Python 3.0 is to require any class raised as an exception to "
"derive from :exc:`BaseException` or some descendant of :exc:`BaseException`,"
" and future releases in the Python 2.x series may begin to enforce this "
"constraint. Therefore, I suggest you begin making all your exception classes"
" derive from :exc:`Exception` now.  It's been suggested that the bare "
"``except:`` form should be removed in Python 3.0, but Guido van Rossum "
"hasn't decided whether to do this or not."
msgstr ""
"Мета для Python 3.0 полягає в тому, щоб вимагати, щоб будь-який клас, "
"створений як виняток, походив від :exc:`BaseException` або якогось нащадка "
":exc:`BaseException`, і в майбутніх випусках серії Python 2.x це обмеження "
"може почати застосовуватися. . Тому я пропоную вам почати робити всі ваші "
"класи винятків похідними від :exc:`Exception` зараз. Було запропоновано, що "
"чисту форму ``except:`` слід видалити в Python 3.0, але Гвідо ван Россум не "
"вирішив, робити це чи ні."

#: ../../whatsnew/2.5.rst:856
msgid ""
"Raising of strings as exceptions, as in the statement ``raise \"Error "
"occurred\"``, is deprecated in Python 2.5 and will trigger a warning.  The "
"aim is to be able to remove the string-exception feature in a few releases."
msgstr ""
"Викликання рядків як винятків, як у виразі ``raise \"Сталася помилка\"``, "
"застаріло в Python 2.5 і викличе попередження. Мета полягає в тому, щоб мати"
" можливість видалити функцію виключення рядків у кількох випусках."

#: ../../whatsnew/2.5.rst:863
msgid ":pep:`352` - Required Superclass for Exceptions"
msgstr ":pep:`352` - 异常所需的超类"

#: ../../whatsnew/2.5.rst:864
msgid ""
"PEP written by  Brett Cannon and Guido van Rossum; implemented by Brett "
"Cannon."
msgstr "PEP 由 Brett Cannon 和 Guido van Rossum 撰写，由 Brett Cannon 实现"

#: ../../whatsnew/2.5.rst:872
msgid "PEP 353: Using ssize_t as the index type"
msgstr "PEP 353: 使用ssize_t作为索引类型"

#: ../../whatsnew/2.5.rst:874
msgid ""
"A wide-ranging change to Python's C API, using a new  :c:type:`Py_ssize_t` "
"type definition instead of :c:expr:`int`,  will permit the interpreter to "
"handle more data on 64-bit platforms. This change doesn't affect Python's "
"capacity on 32-bit platforms."
msgstr ""
"Широкомасштабное изменение API C Python с использованием нового определения "
"типа :c:type:`Py_ssize_t` вместо :c:expr:`int` позволит интерпретатору "
"обрабатывать больше данных на 64-битных платформах. Это изменение не влияет "
"на возможности Python на 32-битных платформах."

#: ../../whatsnew/2.5.rst:879
msgid ""
"Various pieces of the Python interpreter used C's :c:expr:`int` type to "
"store sizes or counts; for example, the number of items in a list or tuple "
"were stored in an :c:expr:`int`.  The C compilers for most 64-bit platforms "
"still define :c:expr:`int` as a 32-bit type, so that meant that lists could "
"only hold up to ``2**31 - 1`` = 2147483647 items. (There are actually a few "
"different programming models that 64-bit C compilers can use -- see "
"https://unix.org/version2/whatsnew/lp64_wp.html for a discussion -- but the "
"most commonly available model leaves :c:expr:`int` as 32 bits.)"
msgstr ""
"Различные части интерпретатора Python использовали тип C :c:expr:`int` для "
"хранения размеров или счетчиков; например, количество элементов в списке или"
" кортеже хранилось в :c:expr:`int`. Компиляторы C для большинства 64-битных "
"платформ по-прежнему определяют :c:expr:`int` как 32-битный тип, а это "
"означает, что списки могут содержать только до ``2**31 - 1`` = 2147483647 "
"элементов. (На самом деле существует несколько различных моделей "
"программирования, которые могут использовать 64-битные компиляторы C — "
"обсуждение см. на https://unix.org/version2/whatsnew/lp64_wp.html — но "
"наиболее распространенная модель оставляет :c: expr:`int` как 32 бита.)"

#: ../../whatsnew/2.5.rst:888
msgid ""
"A limit of 2147483647 items doesn't really matter on a 32-bit platform "
"because you'll run out of memory before hitting the length limit. Each list "
"item requires space for a pointer, which is 4 bytes, plus space for a "
":c:type:`PyObject` representing the item.  2147483647\\*4 is already more "
"bytes than a 32-bit address space can contain."
msgstr ""
"Обмеження в 2147483647 елементів насправді не має значення на 32-розрядній "
"платформі, тому що у вас закінчиться пам’ять, перш ніж досягнеться обмеження"
" довжини. Кожен елемент списку потребує місця для вказівника, який становить"
" 4 байти, плюс місце для :c:type:`PyObject`, що представляє елемент. "
"2147483647\\*4 — це вже більше байтів, ніж може вмістити 32-розрядний "
"адресний простір."

#: ../../whatsnew/2.5.rst:894
msgid ""
"It's possible to address that much memory on a 64-bit platform, however.  "
"The pointers for a list that size would only require 16 GiB of space, so "
"it's not unreasonable that Python programmers might construct lists that "
"large. Therefore, the Python interpreter had to be changed to use some type "
"other than :c:expr:`int`, and this will be a 64-bit type on 64-bit "
"platforms.  The change will cause incompatibilities on 64-bit machines, so "
"it was deemed worth making the transition now, while the number of 64-bit "
"users is still relatively small. (In 5 or 10 years, we may *all* be on "
"64-bit machines, and the transition would be more painful then.)"
msgstr ""
"Однако можно адресовать такой объем памяти на 64-битной платформе. Указатели"
" на список такого размера потребуют всего 16 ГиБ пространства, поэтому "
"вполне разумно, что программисты Python могут создавать списки такого "
"размера. Поэтому интерпретатор Python пришлось изменить, чтобы использовать "
"какой-либо тип, отличный от :c:expr:`int`, и на 64-битных платформах это "
"будет 64-битный тип. Это изменение приведет к несовместимости на 64-битных "
"машинах, поэтому было сочтено целесообразным осуществить переход сейчас, "
"пока число 64-битных пользователей все еще относительно невелико. (Через 5 "
"или 10 лет мы, возможно, *все* будем использовать 64-битные машины, и тогда "
"переход будет более болезненным.)"

#: ../../whatsnew/2.5.rst:904
msgid ""
"This change most strongly affects authors of C extension modules.   Python "
"strings and container types such as lists and tuples  now use "
":c:type:`Py_ssize_t` to store their size.   Functions such as "
":c:func:`PyList_Size`  now return :c:type:`Py_ssize_t`.  Code in extension "
"modules may therefore need to have some variables changed to "
":c:type:`Py_ssize_t`."
msgstr ""
"Ця зміна найбільше впливає на авторів модулів розширення C. Рядки Python і "
"типи контейнерів, такі як списки та кортежі, тепер використовують "
":c:type:`Py_ssize_t` для зберігання свого розміру. Такі функції, як "
":c:func:`PyList_Size` тепер повертають :c:type:`Py_ssize_t`. Тому в коді "
"модулів розширення може знадобитися змінити деякі змінні на "
":c:type:`Py_ssize_t`."

#: ../../whatsnew/2.5.rst:910
msgid ""
"The :c:func:`PyArg_ParseTuple` and :c:func:`Py_BuildValue` functions have a "
"new conversion code, ``n``, for :c:type:`Py_ssize_t`.   "
":c:func:`PyArg_ParseTuple`'s ``s#`` and ``t#`` still output :c:expr:`int` by"
" default, but you can define the macro  :c:macro:`PY_SSIZE_T_CLEAN` before "
"including :file:`Python.h`  to make them return :c:type:`Py_ssize_t`."
msgstr ""

#: ../../whatsnew/2.5.rst:916
msgid ""
":pep:`353` has a section on conversion guidelines that  extension authors "
"should read to learn about supporting 64-bit platforms."
msgstr ""
":pep:`353` містить розділ про вказівки щодо перетворення, який слід "
"прочитати авторам розширень, щоб дізнатися про підтримку 64-розрядних "
"платформ."

#: ../../whatsnew/2.5.rst:922
msgid ":pep:`353` - Using ssize_t as the index type"
msgstr ":pep:`353` - 使用ssize_t作为索引类型"

#: ../../whatsnew/2.5.rst:923
msgid "PEP written and implemented by Martin von Löwis."
msgstr "PEP 由 Martin von Löwis 撰写并实现。"

#: ../../whatsnew/2.5.rst:931
msgid "PEP 357: The '__index__' method"
msgstr "PEP 357: '__index__' 方法"

#: ../../whatsnew/2.5.rst:933
msgid ""
"The NumPy developers had a problem that could only be solved by adding a new"
" special method, :meth:`__index__`.  When using slice notation, as in "
"``[start:stop:step]``, the values of the *start*, *stop*, and *step* indexes"
" must all be either integers or long integers.  NumPy defines a variety of "
"specialized integer types corresponding to unsigned and signed integers of "
"8, 16, 32, and 64 bits, but there was no way to signal that these types "
"could be used as slice indexes."
msgstr ""
"У розробників NumPy була проблема, яку можна було вирішити, лише додавши "
"новий спеціальний метод :meth:`__index__`. При використанні нотації "
"фрагментів, як у ``[start:stop:step]``, значення індексів *start*, *stop* і "
"*step* мають бути цілими або довгими цілими числами. NumPy визначає "
"різноманітність спеціалізованих типів цілих чисел, що відповідають цілим "
"числам без знаку та знаку 8, 16, 32 та 64 біт, але не було жодного способу "
"вказати, що ці типи можна використовувати як індекси зрізів."

#: ../../whatsnew/2.5.rst:941
msgid ""
"Slicing can't just use the existing :meth:`__int__` method because that "
"method is also used to implement coercion to integers.  If slicing used "
":meth:`__int__`, floating-point numbers would also become legal slice "
"indexes and that's clearly an undesirable behaviour."
msgstr ""
"Зрізання не може використовувати лише існуючий метод :meth:`__int__`, "
"оскільки цей метод також використовується для реалізації приведення до цілих"
" чисел. Якщо використати секцію :meth:`__int__`, числа з плаваючою комою "
"також стануть законними індексами фрагментів, і це явно небажана поведінка."

#: ../../whatsnew/2.5.rst:946
msgid ""
"Instead, a new special method called :meth:`__index__` was added.  It takes "
"no arguments and returns an integer giving the slice index to use.  For "
"example::"
msgstr ""
"Замість цього було додано новий спеціальний метод під назвою "
":meth:`__index__`. Він не приймає аргументів і повертає ціле число, що дає "
"індекс фрагмента для використання. Наприклад::"

#: ../../whatsnew/2.5.rst:953
msgid ""
"The return value must be either a Python integer or long integer. The "
"interpreter will check that the type returned is correct, and raises a "
":exc:`TypeError` if this requirement isn't met."
msgstr ""
"Повернене значення має бути або цілим числом Python, або довгим цілим "
"числом. Інтерпретатор перевірить, чи повернутий тип правильний, і викличе "
":exc:`TypeError`, якщо ця вимога не виконується."

#: ../../whatsnew/2.5.rst:957
msgid ""
"A corresponding :attr:`nb_index` slot was added to the C-level "
":c:type:`PyNumberMethods` structure to let C extensions implement this "
"protocol. ``PyNumber_Index(obj)`` can be used in extension code to call the "
":meth:`__index__` function and retrieve its result."
msgstr ""

#: ../../whatsnew/2.5.rst:965
msgid ":pep:`357` - Allowing Any Object to be Used for Slicing"
msgstr ":pep:`357` - 允许将任何对象用于切片"

#: ../../whatsnew/2.5.rst:966
msgid "PEP written  and implemented by Travis Oliphant."
msgstr "PEP 由 Travis Oliphant 撰写并实现。"

#: ../../whatsnew/2.5.rst:974
msgid "Other Language Changes"
msgstr "其他语言特性修改"

#: ../../whatsnew/2.5.rst:976
msgid ""
"Here are all of the changes that Python 2.5 makes to the core Python "
"language."
msgstr "以下是 Python 2.5 针对核心 Python 语言的所有改变。"

#: ../../whatsnew/2.5.rst:978
msgid ""
"The :class:`dict` type has a new hook for letting subclasses provide a "
"default value when a key isn't contained in the dictionary. When a key isn't"
" found, the dictionary's ``__missing__(key)`` method will be called.  This "
"hook is used to implement the new :class:`defaultdict` class in the "
":mod:`collections` module.  The following example defines a dictionary  that"
" returns zero for any missing key::"
msgstr ""
"Тип :class:`dict` має новий хук, який дозволяє підкласам надавати значення "
"за замовчуванням, коли ключ не міститься в словнику. Якщо ключ не знайдено, "
"буде викликано метод ``__missing__(key)`` словника. Цей хук використовується"
" для реалізації нового класу :class:`defaultdict` в модулі "
":mod:`collections`. У наступному прикладі визначено словник, який повертає "
"нуль для будь-якого відсутнього ключа:"

#: ../../whatsnew/2.5.rst:993
msgid ""
"Both 8-bit and Unicode strings have new ``partition(sep)``  and "
"``rpartition(sep)`` methods that simplify a common use case."
msgstr ""
"І 8-бітні рядки, і рядки Unicode мають нові методи ``partition(sep)`` і "
"``rpartition(sep)``, які спрощують загальний варіант використання."

#: ../../whatsnew/2.5.rst:996
msgid ""
"The ``find(S)`` method is often used to get an index which is then used to "
"slice the string and obtain the pieces that are before and after the "
"separator. ``partition(sep)`` condenses this pattern into a single method "
"call that returns a 3-tuple containing the substring before the separator, "
"the separator itself, and the substring after the separator.  If the "
"separator isn't found, the first element of the tuple is the entire string "
"and the other two elements are empty.  ``rpartition(sep)`` also returns a "
"3-tuple but starts searching from the end of the string; the ``r`` stands "
"for 'reverse'."
msgstr ""
"Метод ``find(S)`` часто використовується для отримання індексу, який потім "
"використовується для розрізання рядка та отримання частин, які знаходяться "
"перед і після роздільника. ``partition(sep)`` зводить цей шаблон до одного "
"виклику методу, який повертає 3-кортеж, що містить підрядок перед "
"роздільником, сам роздільник і підрядок після роздільника. Якщо роздільник "
"не знайдено, перший елемент кортежу є цілим рядком, а інші два елементи "
"порожні. ``rpartition(sep)`` також повертає 3-кортеж, але починає пошук з "
"кінця рядка; ``r`` означає 'зворотний'."

#: ../../whatsnew/2.5.rst:1005
msgid "Some examples::"
msgstr "示例如下："

#: ../../whatsnew/2.5.rst:1018
msgid ""
"(Implemented by Fredrik Lundh following a suggestion by Raymond Hettinger.)"
msgstr "（由 Fredrik Lundh 在 Raymond Hettinger 的建议下实现。）"

#: ../../whatsnew/2.5.rst:1020
msgid ""
"The :meth:`startswith` and :meth:`endswith` methods of string types now "
"accept tuples of strings to check for. ::"
msgstr "现在字符串类型的 :meth:`startswith` 和 :meth:`endswith` 方法可接受字符串元组供检查。 ::"

#: ../../whatsnew/2.5.rst:1026
msgid "(Implemented by Georg Brandl following a suggestion by Tom Lynn.)"
msgstr "(Реалізовано Георгом Брандлом за пропозицією Тома Лінна.)"

#: ../../whatsnew/2.5.rst:1030
msgid ""
"The :func:`min` and :func:`max` built-in functions gained a ``key`` keyword "
"parameter analogous to the ``key`` argument for :meth:`sort`.  This "
"parameter supplies a function that takes a single argument and is called for"
" every value in the list; :func:`min`/:func:`max` will return the element "
"with the smallest/largest return value from this function. For example, to "
"find the longest string in a list, you can do::"
msgstr ""
"Вбудовані функції :func:`min` і :func:`max` отримали параметр ключового "
"слова ``key``, аналогічний аргументу ``key`` для :meth:`sort`. Цей параметр "
"надає функцію, яка приймає один аргумент і викликається для кожного значення"
" в списку; :func:`min`/:func:`max` поверне елемент із найменшим/найбільшим "
"значенням, що повертається цією функцією. Наприклад, щоб знайти найдовший "
"рядок у списку, ви можете зробити:"

#: ../../whatsnew/2.5.rst:1043
msgid "(Contributed by Steven Bethard and Raymond Hettinger.)"
msgstr "（由 Steven Bethard 和 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1045
msgid ""
"Two new built-in functions, :func:`any` and :func:`all`, evaluate whether an"
" iterator contains any true or false values.  :func:`any` returns "
":const:`True` if any value returned by the iterator is true; otherwise it "
"will return :const:`False`.  :func:`all` returns :const:`True` only if all "
"of the values returned by the iterator evaluate as true. (Suggested by Guido"
" van Rossum, and implemented by Raymond Hettinger.)"
msgstr ""
"Дві нові вбудовані функції, :func:`any` і :func:`all`, оцінюють, чи містить "
"ітератор значення true або false. :func:`any` повертає :const:`True`, якщо "
"будь-яке значення, яке повертає ітератор, є істинним; інакше він поверне "
":const:`False`. :func:`all` повертає :const:`True` тільки якщо всі значення,"
" повернуті ітератором, оцінюються як істинні. (Запропоновано Гвідо ван "
"Россумом і реалізовано Раймондом Геттінгером.)"

#: ../../whatsnew/2.5.rst:1052
msgid ""
"The result of a class's :meth:`__hash__` method can now be either a long "
"integer or a regular integer.  If a long integer is returned, the hash of "
"that value is taken.  In earlier versions the hash value was required to be "
"a regular integer, but in 2.5 the :func:`id` built-in was changed to always "
"return non-negative numbers, and users often seem to use ``id(self)`` in "
":meth:`__hash__` methods (though this is discouraged)."
msgstr ""
"Результатом методу :meth:`__hash__` класу тепер може бути або довге ціле, "
"або звичайне ціле число. Якщо повертається довге ціле число, береться хеш "
"цього значення. У попередніх версіях хеш-значення повинно було бути "
"звичайним цілим числом, але у 2.5 вбудований :func:`id` було змінено, щоб "
"завжди повертати невід’ємні числа, і користувачі часто використовують "
"``id(self)`` в методах :meth:`__hash__` (хоча це не рекомендується)."

#: ../../whatsnew/2.5.rst:1061
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error.  See :pep:`263`  for how to declare a module's encoding; for example,"
" you might add  a line like this near the top of the source file::"
msgstr ""
"ASCII тепер є стандартним кодуванням для модулів. Тепер це синтаксична "
"помилка, якщо модуль містить рядкові літерали з 8-бітовими символами, але не"
" має оголошення кодування. У Python 2.4 це викликало попередження, а не "
"синтаксичну помилку. Перегляньте :pep:`263`, щоб дізнатися, як оголосити "
"кодування модуля; наприклад, ви можете додати такий рядок у верхній частині "
"вихідного файлу::"

#: ../../whatsnew/2.5.rst:1069
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string  that can't be converted to "
"Unicode using the default ASCII encoding.   The result of the comparison is "
"false::"
msgstr ""
"Нове попередження, :class:`UnicodeWarning`, спрацьовує, коли ви намагаєтеся "
"порівняти рядок Unicode з 8-бітним рядком, який не можна перетворити на "
"Unicode за допомогою стандартного кодування ASCII. Результат порівняння "
"false::"

#: ../../whatsnew/2.5.rst:1081
msgid ""
"Previously this would raise a :class:`UnicodeDecodeError` exception, but in "
"2.5 this could result in puzzling problems when accessing a dictionary.  If "
"you looked up ``unichr(128)`` and ``chr(128)`` was being used as a key, "
"you'd get a :class:`UnicodeDecodeError` exception.  Other changes in 2.5 "
"resulted in this exception being raised instead of suppressed by the code in"
" :file:`dictobject.c` that implements dictionaries."
msgstr ""
"Раніше це викликало виняток :class:`UnicodeDecodeError`, але у версії 2.5 це"
" могло призвести до загадкових проблем під час доступу до словника. Якщо ви "
"шукали ``unichr(128)`` і ``chr(128)`` використовувався як ключ, ви отримали "
"б виняток :class:`UnicodeDecodeError`. Інші зміни у 2.5 призвели до того, що"
" цей виняток було викликано замість придушення кодом у :file:`dictobject.c`,"
" який реалізує словники."

#: ../../whatsnew/2.5.rst:1088
msgid ""
"Raising an exception for such a comparison is strictly correct, but the "
"change might have broken code, so instead  :class:`UnicodeWarning` was "
"introduced."
msgstr ""
"Створення винятку для такого порівняння є абсолютно правильним, але зміна "
"могла порушити код, тому замість цього було введено :class:`UnicodeWarning`."

#: ../../whatsnew/2.5.rst:1091
msgid "(Implemented by Marc-André Lemburg.)"
msgstr "（由 Marc-André Lemburg 实现。）"

#: ../../whatsnew/2.5.rst:1093
msgid ""
"One error that Python programmers sometimes make is forgetting to include an"
" :file:`__init__.py` module in a package directory. Debugging this mistake "
"can be confusing, and usually requires running Python with the :option:`-v` "
"switch to log all the paths searched. In Python 2.5, a new "
":exc:`ImportWarning` warning is triggered when an import would have picked "
"up a directory as a package but no :file:`__init__.py` was found.  This "
"warning is silently ignored by default; provide the :option:`-Wd <-W>` "
"option when running the Python executable to display the warning message. "
"(Implemented by Thomas Wouters.)"
msgstr ""
"Одна з помилок, яку інколи допускають програмісти на Python, полягає в тому,"
" що вони забувають включити модуль :file:`__init__.py` в каталог пакунків. "
"Налагодження цієї помилки може заплутати, і зазвичай вимагає запуску Python "
"з перемикачем :option:`-v`, щоб реєструвати всі шукані шляхи. У Python 2.5 "
"нове попередження :exc:`ImportWarning` спрацьовує, коли імпорт мав би "
"отримати каталог як пакет, але не було знайдено :file:`__init__.py`. За "
"замовчуванням це попередження мовчки ігнорується; надайте параметр "
":option:`-Wd <-W>` під час запуску виконуваного файлу Python для "
"відображення попереджувального повідомлення. (Реалізовано Томасом "
"Воутерсом.)"

#: ../../whatsnew/2.5.rst:1102
msgid ""
"The list of base classes in a class definition can now be empty.   As an "
"example, this is now legal::"
msgstr ""
"Список базових класів у визначенні класу тепер може бути порожнім. Як "
"приклад, це зараз законно::"

#: ../../whatsnew/2.5.rst:1108
msgid "(Implemented by Brett Cannon.)"
msgstr "（由 Brett Cannon 实现。）"

#: ../../whatsnew/2.5.rst:1116
msgid "Interactive Interpreter Changes"
msgstr "交互解释器变更"

#: ../../whatsnew/2.5.rst:1118
msgid ""
"In the interactive interpreter, ``quit`` and ``exit``  have long been "
"strings so that new users get a somewhat helpful message when they try to "
"quit::"
msgstr ""
"В інтерактивному інтерпретаторі ``quit`` і ``exit`` вже давно є рядками, "
"тому нові користувачі отримують дещо корисне повідомлення, коли вони "
"намагаються вийти:"

#: ../../whatsnew/2.5.rst:1124
msgid ""
"In Python 2.5, ``quit`` and ``exit`` are now objects that still produce "
"string representations of themselves, but are also callable. Newbies who try"
" ``quit()`` or ``exit()`` will now exit the interpreter as they expect.  "
"(Implemented by Georg Brandl.)"
msgstr ""
"У Python 2.5 ``quit`` і ``exit`` тепер є об'єктами, які все ще створюють "
"рядкові представлення самих себе, але також можуть викликатися. Новачки, які"
" спробують ``quit()`` або ``exit()`` тепер вийдуть з інтерпретатора, як вони"
" очікують. (Реалізовано Георгом Брандлом.)"

#: ../../whatsnew/2.5.rst:1129
msgid ""
"The Python executable now accepts the standard long options  "
":option:`--help` and :option:`--version`; on Windows,  it also accepts the "
":option:`/? <-?>` option for displaying a help message. (Implemented by "
"Georg Brandl.)"
msgstr ""
"Виконуваний файл Python тепер приймає стандартні довгі параметри "
":option:`--help` і :option:`--version`; у Windows він також приймає "
":option:`/? <-?>` параметр для відображення довідкового повідомлення. "
"(Реалізовано Георгом Брандлом.)"

#: ../../whatsnew/2.5.rst:1139
msgid "Optimizations"
msgstr "性能优化"

#: ../../whatsnew/2.5.rst:1141
msgid ""
"Several of the optimizations were developed at the NeedForSpeed sprint, an "
"event held in Reykjavik, Iceland, from May 21--28 2006. The sprint focused "
"on speed enhancements to the CPython implementation and was funded by EWT "
"LLC with local support from CCP Games.  Those optimizations added at this "
"sprint are specially marked in the following list."
msgstr ""
"Декілька оптимізацій було розроблено під час спринту NeedForSpeed, заходу, "
"який проходив у Рейк’явіку, Ісландія, 21--28 травня 2006 року. Спринт був "
"зосереджений на підвищенні швидкості реалізації CPython і фінансувався EWT "
"LLC за місцевої підтримки від CCP Games. Ці оптимізації, додані під час "
"цього спринту, спеціально позначені в наступному списку."

#: ../../whatsnew/2.5.rst:1147
msgid ""
"When they were introduced  in Python 2.4, the built-in :class:`set` and "
":class:`frozenset` types were built on top of Python's dictionary type.   In"
" 2.5 the internal data structure has been customized for implementing sets, "
"and as a result sets will use a third less memory and are somewhat faster. "
"(Implemented by Raymond Hettinger.)"
msgstr ""
"Коли вони були представлені в Python 2.4, вбудовані типи :class:`set` і "
":class:`frozenset` були створені поверх типу словника Python. У 2.5 "
"внутрішню структуру даних було налаштовано для реалізації наборів, і в "
"результаті набори використовуватимуть на третину менше пам’яті та будуть "
"дещо швидшими. (Реалізовано Раймондом Хеттінгером.)"

#: ../../whatsnew/2.5.rst:1153
msgid ""
"The speed of some Unicode operations, such as finding substrings, string "
"splitting, and character map encoding and decoding, has been improved. "
"(Substring search and splitting improvements were added by Fredrik Lundh and"
" Andrew Dalke at the NeedForSpeed sprint. Character maps were improved by "
"Walter Dörwald and Martin von Löwis.)"
msgstr ""
"Швидкість деяких операцій Unicode, таких як пошук підрядків, поділ рядків і "
"кодування та декодування карти символів, покращено. (Фредрік Лунд і Ендрю "
"Далке під час спринту NeedForSpeed удосконалили пошук підрядків і "
"розділення. Карти символів покращили Вальтер Дьорвальд і Мартін фон Льовіс.)"

#: ../../whatsnew/2.5.rst:1161
msgid ""
"The ``long(str, base)`` function is now faster on long digit strings because"
" fewer intermediate results are calculated.  The peak is for strings of "
"around 800--1000 digits where  the function is 6 times faster. (Contributed "
"by Alan McIntyre and committed at the NeedForSpeed sprint.)"
msgstr ""
"Функція long(str, base) тепер працює швидше з довгими рядками цифр, оскільки"
" обчислюється менше проміжних результатів. Пік припадає на рядки приблизно з"
" 800--1000 цифр, де функція працює в 6 разів швидше. (Надано Аланом "
"Макінтайром і зроблено під час спринту NeedForSpeed.)"

#: ../../whatsnew/2.5.rst:1168
msgid ""
"It's now illegal to mix iterating over a file  with ``for line in file`` and"
" calling  the file object's :meth:`read`/:meth:`readline`/:meth:`readlines` "
"methods.  Iteration uses an internal buffer and the  :meth:`read\\*` methods"
" don't use that buffer.   Instead they would return the data following the "
"buffer, causing the data to appear out of order.  Mixing iteration and these"
" methods will now trigger a :exc:`ValueError` from the :meth:`read\\*` "
"method. (Implemented by Thomas Wouters.)"
msgstr ""

#: ../../whatsnew/2.5.rst:1178
msgid ""
"The :mod:`struct` module now compiles structure format  strings into an "
"internal representation and caches this representation, yielding a 20% "
"speedup. (Contributed by Bob Ippolito at the NeedForSpeed sprint.)"
msgstr ""
"Модуль :mod:`struct` тепер компілює рядки формату структури у внутрішнє "
"представлення та кешує це представлення, що забезпечує 20% прискорення. "
"(Надано Бобом Іполіто під час спринту NeedForSpeed.)"

#: ../../whatsnew/2.5.rst:1182
msgid ""
"The :mod:`re` module got a 1 or 2% speedup by switching to  Python's "
"allocator functions instead of the system's  :c:func:`malloc` and "
":c:func:`free`. (Contributed by Jack Diederich at the NeedForSpeed sprint.)"
msgstr ""
"Модуль :mod:`re` отримав прискорення на 1 або 2% завдяки переключенню на "
"функції виділення Python замість системних :c:func:`malloc` і "
":c:func:`free`. (Надано Джеком Дідеріхом під час спринту NeedForSpeed.)"

#: ../../whatsnew/2.5.rst:1186
msgid ""
"The code generator's peephole optimizer now performs simple constant folding"
" in expressions.  If you write something like ``a = 2+3``, the code "
"generator will do the arithmetic and produce code corresponding to ``a = "
"5``.  (Proposed and implemented  by Raymond Hettinger.)"
msgstr ""
"Оптимізатор peephole генератора коду тепер виконує просту постійну згортання"
" виразів. Якщо ви напишете щось на кшталт ``a = 2+3``, генератор коду "
"виконає арифметику та створить код, що відповідає ``a = 5``. (Запропоновано "
"та реалізовано Раймондом Хеттінгером.)"

#: ../../whatsnew/2.5.rst:1191
msgid ""
"Function calls are now faster because code objects now keep  the most "
"recently finished frame (a \"zombie frame\") in an internal field of the "
"code object, reusing it the next time the code object is invoked.  (Original"
" patch by Michael Hudson, modified by Armin Rigo and Richard Jones; "
"committed at the NeedForSpeed sprint.)  Frame objects are also slightly "
"smaller, which may improve cache locality and reduce memory usage a bit.  "
"(Contributed by Neal Norwitz.)"
msgstr ""
"Виклики функцій тепер швидші, оскільки об’єкти коду тепер зберігають "
"останній готовий кадр (\"зомбі-кадр\") у внутрішньому полі об’єкта коду, "
"повторно використовуючи його під час наступного виклику об’єкта коду. "
"(Оригінальний патч Майкла Хадсона, модифікований Арміном Ріго та Річардом "
"Джонсом; зроблено під час спринту NeedForSpeed.) Об’єкти фрейму також трохи "
"менші, що може покращити локальність кешу та трохи зменшити використання "
"пам’яті. (Надав Ніл Норвіц.)"

#: ../../whatsnew/2.5.rst:1201
msgid ""
"Python's built-in exceptions are now new-style classes, a change that speeds"
" up instantiation considerably.  Exception handling in Python 2.5 is "
"therefore about 30% faster than in 2.4. (Contributed by Richard Jones, Georg"
" Brandl and Sean Reifschneider at the NeedForSpeed sprint.)"
msgstr ""
"Вбудовані винятки Python тепер є класами нового стилю, зміна, яка значно "
"прискорює створення екземплярів. Тому обробка винятків у Python 2.5 "
"приблизно на 30% швидша, ніж у 2.4. (Річард Джонс, Георг Брандл і Шон "
"Райфшнайдер на спринті NeedForSpeed.)"

#: ../../whatsnew/2.5.rst:1206
msgid ""
"Importing now caches the paths tried, recording whether  they exist or not "
"so that the interpreter makes fewer  :c:func:`open` and :c:func:`stat` calls"
" on startup. (Contributed by Martin von Löwis and Georg Brandl.)"
msgstr ""
"Імпорт тепер кешує спробовані шляхи, записуючи їх існування чи ні, щоб "
"інтерпретатор здійснював менше викликів :c:func:`open` і :c:func:`stat` під "
"час запуску. (Надано Мартіном фон Льовісом і Георгом Брандлом.)"

#: ../../whatsnew/2.5.rst:1218
msgid "New, Improved, and Removed Modules"
msgstr "新增，改进和删除的模块"

#: ../../whatsnew/2.5.rst:1220
msgid ""
"The standard library received many enhancements and bug fixes in Python 2.5."
" Here's a partial list of the most notable changes, sorted alphabetically by"
" module name. Consult the :file:`Misc/NEWS` file in the source tree for a "
"more complete list of changes, or look through the SVN logs for all the "
"details."
msgstr ""
"Стандартна бібліотека отримала багато вдосконалень і виправлень помилок у "
"Python 2.5. Ось неповний список найбільш помітних змін, відсортованих за "
"алфавітом назв модулів. Зверніться до файлу :file:`Misc/NEWS` у дереві "
"вихідних кодів, щоб отримати більш повний список змін, або перегляньте "
"журнали SVN, щоб отримати всі деталі."

#: ../../whatsnew/2.5.rst:1225
msgid ""
"The :mod:`audioop` module now supports the a-LAW encoding, and the code for "
"u-LAW encoding has been improved.  (Contributed by Lars Immisch.)"
msgstr ""
"Модуль :mod:`audioop` тепер підтримує кодування a-LAW, а код для кодування "
"u-LAW було вдосконалено. (Надав Ларс Імміш.)"

#: ../../whatsnew/2.5.rst:1228
msgid ""
"The :mod:`codecs` module gained support for incremental codecs.  The "
":func:`codec.lookup` function now returns a :class:`CodecInfo` instance "
"instead of a tuple. :class:`CodecInfo` instances behave like a 4-tuple to "
"preserve backward compatibility but also have the attributes :attr:`encode`,"
" :attr:`decode`, :attr:`incrementalencoder`, :attr:`incrementaldecoder`, "
":attr:`streamwriter`, and :attr:`streamreader`.  Incremental codecs  can "
"receive input and produce output in multiple chunks; the output is the same "
"as if the entire input was fed to the non-incremental codec. See the "
":mod:`codecs` module documentation for details. (Designed and implemented by"
" Walter Dörwald.)"
msgstr ""
"Модуль :mod:`codecs` отримав підтримку інкрементних кодеків. Функція "
":func:`codec.lookup` тепер повертає екземпляр :class:`CodecInfo` замість "
"кортежу. Екземпляри :class:`CodecInfo` поводяться як 4-кортеж, щоб зберегти "
"зворотну сумісність, але також мають атрибути :attr:`encode`, "
":attr:`decode`, :attr:`incrementalencoder`, :attr:`incrementaldecoder`, "
":attr:`streamwriter` і :attr:`streamreader`. Інкрементні кодеки можуть "
"отримувати вхідні дані та виводити їх кількома порціями; вихідний сигнал "
"такий самий, як якби весь вхід був поданий до неінкрементного кодека. "
"Подробиці дивіться в документації модуля :mod:`codecs`. (Розроблено та "
"реалізовано Вальтером Дьорвальдом.)"

#: ../../whatsnew/2.5.rst:1240
msgid ""
"The :mod:`collections` module gained a new type, :class:`defaultdict`, that "
"subclasses the standard :class:`dict` type.  The new type mostly behaves "
"like a dictionary but constructs a default value when a key isn't present, "
"automatically adding it to the dictionary for the requested key value."
msgstr ""
"Модуль :mod:`collections` отримав новий тип, :class:`defaultdict`, який є "
"підкласами стандартного типу :class:`dict`. Новий тип здебільшого веде себе "
"як словник, але створює значення за замовчуванням, коли ключ відсутній, "
"автоматично додаючи його до словника для запитуваного значення ключа."

#: ../../whatsnew/2.5.rst:1245
msgid ""
"The first argument to :class:`defaultdict`'s constructor is a factory "
"function that gets called whenever a key is requested but not found. This "
"factory function receives no arguments, so you can use built-in type "
"constructors such as :func:`list` or :func:`int`.  For example,  you can "
"make an index of words based on their initial letter like this::"
msgstr ""
"Першим аргументом конструктора :class:`defaultdict` є фабрична функція, яка "
"викликається щоразу, коли запитується ключ, але він не знайдений. Ця "
"фабрична функція не отримує аргументів, тому ви можете використовувати "
"вбудовані конструктори типу, такі як :func:`list` або :func:`int`. "
"Наприклад, ви можете скласти покажчик слів на основі їх початкової літери "
"так:"

#: ../../whatsnew/2.5.rst:1261
msgid "Printing ``index`` results in the following output::"
msgstr "打印 ``index`` 导致以下输出::"

#: ../../whatsnew/2.5.rst:1269
msgid "(Contributed by Guido van Rossum.)"
msgstr "（由 Guido van Rossum 贡献。）"

#: ../../whatsnew/2.5.rst:1271
msgid ""
"The :class:`deque` double-ended queue type supplied by the "
":mod:`collections` module now has a ``remove(value)`` method that removes "
"the first occurrence of *value* in the queue, raising :exc:`ValueError` if "
"the value isn't found. (Contributed by Raymond Hettinger.)"
msgstr ""
"Тип двосторонньої черги :class:`deque`, наданий модулем :mod:`collections`, "
"тепер має метод ``remove(value)``, який видаляє перше входження *value* у "
"черзі, викликаючи :exc:`ValueError`, якщо значення не знайдено. (Надав "
"Реймонд Геттінгер.)"

#: ../../whatsnew/2.5.rst:1276
msgid ""
"New module: The :mod:`contextlib` module contains helper functions for use "
"with the new ':keyword:`with`' statement.  See section :ref:`contextlibmod` "
"for more about this module."
msgstr ""
"Новий модуль: Модуль :mod:`contextlib` містить допоміжні функції для "
"використання з новим оператором ':keyword:`with`'. Перегляньте розділ "
":ref:`contextlibmod`, щоб дізнатися більше про цей модуль."

#: ../../whatsnew/2.5.rst:1280
msgid ""
"New module: The :mod:`cProfile` module is a C implementation of  the "
"existing :mod:`profile` module that has much lower overhead. The module's "
"interface is the same as :mod:`profile`: you run ``cProfile.run('main()')`` "
"to profile a function, can save profile data to a file, etc.  It's not yet "
"known if the Hotshot profiler, which is also written in C but doesn't match "
"the :mod:`profile` module's interface, will continue to be maintained in "
"future versions of Python.  (Contributed by Armin Rigo.)"
msgstr ""
"Новий модуль: Модуль :mod:`cProfile` — це реалізація існуючого модуля "
":mod:`profile` на C, яка має значно менші витрати. Інтерфейс модуля такий "
"самий, як і :mod:`profile`: ви запускаєте ``cProfile.run('main()')`` для "
"профілювання функції, можете зберегти дані профілю у файл тощо. Поки що "
"невідомо, чи профайлер Hotshot, який також написаний мовою C, але не "
"відповідає інтерфейсу модуля :mod:`profile`, буде продовжувати "
"підтримуватися в майбутніх версіях Python. (Надав Армін Ріго.)"

#: ../../whatsnew/2.5.rst:1288
msgid ""
"Also, the :mod:`pstats` module for analyzing the data measured by the "
"profiler now supports directing the output to any file object by supplying a"
" *stream* argument to the :class:`Stats` constructor. (Contributed by Skip "
"Montanaro.)"
msgstr ""
"Крім того, модуль :mod:`pstats` для аналізу даних, виміряних профайлером, "
"тепер підтримує спрямування виводу до будь-якого файлового об’єкта, надаючи "
"аргумент *stream* конструктору :class:`Stats`. (Надав Скіп Монтанаро.)"

#: ../../whatsnew/2.5.rst:1292
msgid ""
"The :mod:`csv` module, which parses files in comma-separated value format, "
"received several enhancements and a number of bugfixes.  You can now set the"
" maximum size in bytes of a field by calling the "
"``csv.field_size_limit(new_limit)`` function; omitting the *new_limit* "
"argument will return the currently set limit.  The :class:`reader` class now"
" has a :attr:`line_num` attribute that counts the number of physical lines "
"read from the source; records can span multiple physical lines, so "
":attr:`line_num` is not the same as the number of records read."
msgstr ""
"Модуль :mod:`csv`, который анализирует файлы в формате значений, разделенных"
" запятыми, получил несколько улучшений и ряд исправлений. Теперь вы можете "
"установить максимальный размер поля в байтах, вызвав функцию "
"``csv.field_size_limit(new_limit)``; опущение аргумента *new_limit* вернет "
"текущий установленный предел. Класс :class:`reader` теперь имеет атрибут "
":attr:`line_num`, который подсчитывает количество физических строк, "
"прочитанных из источника; записи могут занимать несколько физических строк, "
"поэтому :attr:`line_num` не совпадает с количеством прочитанных записей."

#: ../../whatsnew/2.5.rst:1301
msgid ""
"The CSV parser is now stricter about multi-line quoted fields. Previously, "
"if a line ended within a quoted field without a terminating newline "
"character, a newline would be inserted into the returned field. This "
"behavior caused problems when reading files that contained carriage return "
"characters within fields, so the code was changed to return the field "
"without inserting newlines. As a consequence, if newlines embedded within "
"fields are important, the input should be split into lines in a manner that "
"preserves the newline characters."
msgstr ""
"Синтаксичний аналізатор CSV тепер суворіший щодо багаторядкових полів у "
"лапках. Раніше, якщо рядок закінчувався в полі в лапках без кінцевого "
"символу нового рядка, новий рядок вставлявся у поле, що поверталося. Така "
"поведінка викликала проблеми під час читання файлів, які містили символи "
"повернення каретки в межах полів, тому код було змінено, щоб повертати поле "
"без вставки нового рядка. Як наслідок, якщо нові рядки, вбудовані в поля, є "
"важливими, вхідні дані слід розділити на рядки таким чином, щоб зберегти "
"символи нового рядка."

#: ../../whatsnew/2.5.rst:1309
msgid "(Contributed by Skip Montanaro and Andrew McNamara.)"
msgstr "（由Skip Montanaro 和 Andrew McNamara 贡献。）"

#: ../../whatsnew/2.5.rst:1311
msgid ""
"The :class:`~datetime.datetime` class in the :mod:`datetime`  module now has"
" a ``strptime(string, format)``  method for parsing date strings, "
"contributed by Josh Spoerri. It uses the same format characters as "
":func:`time.strptime` and :func:`time.strftime`::"
msgstr ""
"Клас :class:`~datetime.datetime` в модулі :mod:`datetime` тепер має метод "
"``strptime(string, format)`` для аналізу рядків дат, наданий Джошем Споеррі."
" Він використовує символи того самого формату, що й :func:`time.strptime` і "
":func:`time.strftime`::"

#: ../../whatsnew/2.5.rst:1321
msgid ""
"The :meth:`SequenceMatcher.get_matching_blocks` method in the :mod:`difflib`"
" module now guarantees to return a minimal list of blocks describing "
"matching subsequences.  Previously, the algorithm would occasionally break a"
" block of matching elements into two list entries. (Enhancement by Tim "
"Peters.)"
msgstr ""
"Метод :meth:`SequenceMatcher.get_matching_blocks` у модулі :mod:`difflib` "
"тепер гарантує повернення мінімального списку блоків, що описують відповідні"
" підпослідовності. Раніше алгоритм час від часу розбивав блок відповідних "
"елементів на два записи списку. (Покращення Тім Пітерс.)"

#: ../../whatsnew/2.5.rst:1326
msgid ""
"The :mod:`doctest` module gained a ``SKIP`` option that keeps an example "
"from being executed at all.  This is intended for code snippets that are "
"usage examples intended for the reader and aren't actually test cases."
msgstr ""
"Модуль :mod:`doctest` отримав параметр ``SKIP``, який утримує приклад від "
"виконання взагалі. Це призначено для фрагментів коду, які є прикладами "
"використання, призначеними для читача, а насправді не є тестовими випадками."

#: ../../whatsnew/2.5.rst:1330
msgid ""
"An *encoding* parameter was added to the :func:`testfile` function and the "
":class:`DocFileSuite` class to specify the file's encoding.  This makes it "
"easier to use non-ASCII characters in  tests contained within a docstring. "
"(Contributed by Bjorn Tillenius.)"
msgstr ""
"Параметр *encoding* додано до функції :func:`testfile` і класу "
":class:`DocFileSuite` для визначення кодування файлу. Це полегшує "
"використання символів, відмінних від ASCII, у тестах, що містяться в рядку "
"документації. (Надав Бьорн Тілленіус.)"

#: ../../whatsnew/2.5.rst:1337
msgid ""
"The :mod:`email` package has been updated to version 4.0. (Contributed by "
"Barry Warsaw.)"
msgstr ":mod:`email` 包已经升级到 4.0版 （由 Barry Warsaw 贡献）"

#: ../../whatsnew/2.5.rst:1345
msgid ""
"The :mod:`fileinput` module was made more flexible. Unicode filenames are "
"now supported, and a *mode* parameter that defaults to ``\"r\"`` was added "
"to the :func:`input` function to allow opening files in binary or "
":term:`universal newlines` mode.  Another new parameter, *openhook*, lets "
"you use a function other than :func:`open`  to open the input files.  Once "
"you're iterating over the set of files, the :class:`FileInput` object's new "
":meth:`fileno` returns the file descriptor for the currently opened file. "
"(Contributed by Georg Brandl.)"
msgstr ""

#: ../../whatsnew/2.5.rst:1354
msgid ""
"In the :mod:`gc` module, the new :func:`get_count` function returns a "
"3-tuple containing the current collection counts for the three GC "
"generations.  This is accounting information for the garbage collector; when"
" these counts reach a specified threshold, a garbage collection sweep will "
"be made.  The existing :func:`gc.collect` function now takes an optional "
"*generation* argument of 0, 1, or 2 to specify which generation to collect. "
"(Contributed by Barry Warsaw.)"
msgstr ""
"У модулі :mod:`gc` нова функція :func:`get_count` повертає 3-кортеж, що "
"містить поточну кількість колекцій для трьох поколінь GC. Це облікова "
"інформація для збирача сміття; коли ці підрахунки досягнуть заданого порогу,"
" буде виконано підмітання сміття. Існуюча функція :func:`gc.collect` тепер "
"приймає необов’язковий аргумент *generation* 0, 1 або 2, щоб вказати, яке "
"покоління збирати. (Надав Баррі Варшау.)"

#: ../../whatsnew/2.5.rst:1361
msgid ""
"The :func:`nsmallest` and  :func:`nlargest` functions in the :mod:`heapq` "
"module  now support a ``key`` keyword parameter similar to the one provided "
"by the :func:`min`/:func:`max` functions and the :meth:`sort` methods.  For "
"example::"
msgstr ""
"Функції :func:`nsmallest` і :func:`nlargest` у модулі :mod:`heapq` тепер "
"підтримують параметр ключового слова ``key``, подібний до того, який надає "
"функції :func:`min`/:func:`max` і методи :meth:`sort`. Наприклад::"

#: ../../whatsnew/2.5.rst:1373 ../../whatsnew/2.5.rst:1382
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1375
msgid ""
"The :func:`itertools.islice` function now accepts ``None`` for the start and"
" step arguments.  This makes it more compatible with the attributes of slice"
" objects, so that you can now write the following::"
msgstr ""
"Функція :func:`itertools.islice` тепер приймає ``None`` для аргументів start"
" і step. Це робить його більш сумісним з атрибутами об’єктів фрагмента, тож "
"тепер ви можете написати наступне::"

#: ../../whatsnew/2.5.rst:1384
msgid ""
"The :func:`format` function in the :mod:`locale` module has been modified "
"and two new functions were added, :func:`format_string` and "
":func:`currency`."
msgstr ""
"Функцію :func:`format` в модулі :mod:`locale` було змінено та додано дві "
"нові функції, :func:`format_string` і :func:`currency`."

#: ../../whatsnew/2.5.rst:1387
msgid ""
"The :func:`format` function's *val* parameter could previously be a string "
"as long as no more than one %char specifier appeared; now the parameter must"
" be exactly one %char specifier with no surrounding text.  An optional "
"*monetary* parameter was also added which, if ``True``, will use the "
"locale's rules for formatting currency in placing a separator between groups"
" of three digits."
msgstr ""
"Параметр *val* функції :func:`format` раніше міг бути рядком, якщо "
"з’являлося не більше одного специфікатора %char; тепер параметр має бути "
"точно одним специфікатором %char без навколишнього тексту. Також було додано"
" необов’язковий параметр *monetary*, який, якщо ``True``, використовуватиме "
"правила локалі для форматування валюти під час розміщення розділювача між "
"групами з трьох цифр."

#: ../../whatsnew/2.5.rst:1393
msgid ""
"To format strings with multiple %char specifiers, use the new "
":func:`format_string` function that works like :func:`format` but also "
"supports mixing %char specifiers with arbitrary text."
msgstr ""
"Щоб відформатувати рядки з кількома специфікаторами %char, використовуйте "
"нову функцію :func:`format_string`, яка працює як :func:`format`, але також "
"підтримує змішування специфікаторів %char з довільним текстом."

#: ../../whatsnew/2.5.rst:1397
msgid ""
"A new :func:`currency` function was also added that formats a number "
"according to the current locale's settings."
msgstr ""
"Також додано нову функцію :func:`currency`, яка форматує число відповідно до"
" поточних налаштувань мови."

#: ../../whatsnew/2.5.rst:1400
msgid "(Contributed by Georg Brandl.)"
msgstr "（由Georg Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:1404
msgid ""
"The :mod:`mailbox` module underwent a massive rewrite to add the capability "
"to modify mailboxes in addition to reading them.  A new set of classes that "
"include :class:`mbox`, :class:`MH`, and :class:`Maildir` are used to read "
"mailboxes, and have an ``add(message)`` method to add messages, "
"``remove(key)`` to remove messages, and :meth:`lock`/:meth:`unlock` to "
"lock/unlock the mailbox. The following example converts a maildir-format "
"mailbox into an mbox-format one::"
msgstr ""
"Модуль :mod:`mailbox` зазнав масштабного перепису, щоб додати можливість "
"змінювати поштові скриньки на додаток до їх читання. Новий набір класів, "
"який включає :class:`mbox`, :class:`MH` і :class:`Maildir`, використовуються"
" для читання поштових скриньок і мають метод ``add(message)`` для додавання "
"повідомлень, ``remove(key)``, щоб видалити повідомлення, і "
":meth:`lock`/:meth:`unlock`, щоб заблокувати/розблокувати поштову скриньку. "
"Наступний приклад перетворює поштову скриньку у форматі maildir на скриньку "
"у форматі mbox:"

#: ../../whatsnew/2.5.rst:1422
msgid ""
"(Contributed by Gregory K. Johnson.  Funding was provided by Google's 2005 "
"Summer of Code.)"
msgstr ""
"(Надано Грегорі К. Джонсоном. Фінансування надано Google Summer of Code 2005"
" року.)"

#: ../../whatsnew/2.5.rst:1425
msgid ""
"New module: the :mod:`msilib` module allows creating Microsoft Installer "
":file:`.msi` files and CAB files.  Some support for reading the :file:`.msi`"
" database is also included. (Contributed by Martin von Löwis.)"
msgstr ""
"Новий модуль: модуль :mod:`msilib` дозволяє створювати файли Microsoft "
"Installer :file:`.msi` і файли CAB. Також включено певну підтримку для "
"читання бази даних :file:`.msi`. (Надав Мартін фон Льовіс.)"

#: ../../whatsnew/2.5.rst:1429
msgid ""
"The :mod:`nis` module now supports accessing domains other than the system "
"default domain by supplying a *domain* argument to the :func:`nis.match` and"
" :func:`nis.maps` functions. (Contributed by Ben Bell.)"
msgstr ""
"Модуль :mod:`nis` тепер підтримує доступ до доменів, відмінних від "
"системного домену за замовчуванням, надаючи аргумент *domain* функціям "
":func:`nis.match` і :func:`nis.maps`. (Надав Бен Белл.)"

#: ../../whatsnew/2.5.rst:1433
msgid ""
"The :mod:`operator` module's :func:`itemgetter`  and :func:`attrgetter` "
"functions now support multiple fields.   A call such as "
"``operator.attrgetter('a', 'b')`` will return a function  that retrieves the"
" :attr:`a` and :attr:`b` attributes.  Combining  this new feature with the "
":meth:`sort` method's ``key`` parameter  lets you easily sort lists using "
"multiple fields. (Contributed by Raymond Hettinger.)"
msgstr ""
"Функції :func:`itemgetter` і :func:`attrgetter` модуля :mod:`operator` тепер"
" підтримують кілька полів. Такий виклик, як ``operator.attrgetter('a', "
"'b')`` поверне функцію, яка отримує атрибути :attr:`a` і :attr:`b`. "
"Поєднання цієї нової функції з параметром ``key`` методу :meth:`sort` "
"дозволяє легко сортувати списки за допомогою кількох полів. (Надав Реймонд "
"Геттінгер.)"

#: ../../whatsnew/2.5.rst:1440
msgid ""
"The :mod:`optparse` module was updated to version 1.5.1 of the Optik "
"library. The :class:`OptionParser` class gained an :attr:`epilog` attribute,"
" a string that will be printed after the help message, and a :meth:`destroy`"
" method to break reference cycles created by the object. (Contributed by "
"Greg Ward.)"
msgstr ""
"Модуль :mod:`optparse` оновлено до версії 1.5.1 бібліотеки Optik. Клас "
":class:`OptionParser` отримав атрибут :attr:`epilog`, рядок, який "
"друкуватиметься після повідомлення довідки, і метод :meth:`destroy` для "
"розриву посилальних циклів, створених об’єктом. (Надав Грег Ворд.)"

#: ../../whatsnew/2.5.rst:1445
msgid ""
"The :mod:`os` module underwent several changes.  The "
":attr:`stat_float_times` variable now defaults to true, meaning that "
":func:`os.stat` will now return time values as floats.  (This doesn't "
"necessarily mean that :func:`os.stat` will return times that are precise to "
"fractions of a second; not all systems support such precision.)"
msgstr ""
"Модуль :mod:`os` зазнав кількох змін. Змінна :attr:`stat_float_times` тепер "
"має значення true, що означає, що :func:`os.stat` тепер повертатиме значення"
" часу як числа з плаваючою точкою. (Це не обов’язково означає, що "
":func:`os.stat` повертатиме час із точністю до часток секунди; не всі "
"системи підтримують таку точність.)"

#: ../../whatsnew/2.5.rst:1451
msgid ""
"Constants named :attr:`os.SEEK_SET`, :attr:`os.SEEK_CUR`, and "
":attr:`os.SEEK_END` have been added; these are the parameters to the "
":func:`os.lseek` function.  Two new constants for locking are "
":attr:`os.O_SHLOCK` and :attr:`os.O_EXLOCK`."
msgstr ""

#: ../../whatsnew/2.5.rst:1456
msgid ""
"Two new functions, :func:`wait3` and :func:`wait4`, were added.  They're "
"similar the :func:`waitpid` function which waits for a child process to exit"
" and returns a tuple of the process ID and its exit status, but "
":func:`wait3` and :func:`wait4` return additional information.  "
":func:`wait3` doesn't take a process ID as input, so it waits for any child "
"process to exit and returns a 3-tuple of *process-id*, *exit-status*, "
"*resource-usage* as returned from the :func:`resource.getrusage` function. "
"``wait4(pid)`` does take a process ID. (Contributed by Chad J. Schroeder.)"
msgstr ""
"Було додано дві нові функції :func:`wait3` і :func:`wait4`. Вони схожі на "
"функцію :func:`waitpid`, яка очікує на вихід дочірнього процесу та повертає "
"кортеж ідентифікатора процесу та його статус виходу, але :func:`wait3` і "
":func:`wait4` повертають додаткову інформацію . :func:`wait3` не приймає "
"ідентифікатор процесу як вхідні дані, тому він очікує на вихід будь-якого "
"дочірнього процесу та повертає 3-кортеж *process-id*, *exit-status*, "
"*resource-usage* як повертається з функції :func:`resource.getrusage`. "
"``wait4(pid)`` приймає ідентифікатор процесу. (Надав Чад Дж. Шредер.)"

#: ../../whatsnew/2.5.rst:1465
msgid ""
"On FreeBSD, the :func:`os.stat` function now returns  times with nanosecond "
"resolution, and the returned object now has :attr:`st_gen` and "
":attr:`st_birthtime`. The :attr:`st_flags` attribute is also available, if "
"the platform supports it. (Contributed by Antti Louko and  Diego Pettenò.)"
msgstr ""
"У FreeBSD функція :func:`os.stat` тепер повертає час із наносекундною "
"роздільною здатністю, а повернутий об’єкт тепер має :attr:`st_gen` і "
":attr:`st_birthtime`. Атрибут :attr:`st_flags` також доступний, якщо "
"платформа його підтримує. (Надано Антті Луко та Дієго Петтено.)"

#: ../../whatsnew/2.5.rst:1472
msgid ""
"The Python debugger provided by the :mod:`pdb` module can now store lists of"
" commands to execute when a breakpoint is reached and execution stops.  Once"
" breakpoint #1 has been created, enter ``commands 1`` and enter a series of "
"commands to be executed, finishing the list with ``end``.  The command list "
"can include commands that resume execution, such as ``continue`` or "
"``next``. (Contributed by Grégoire Dooms.)"
msgstr ""
"Налагоджувач Python, наданий модулем :mod:`pdb`, тепер може зберігати списки"
" команд, які потрібно виконати, коли досягнуто точки зупинки та припинено "
"виконання. Після створення точки зупину №1 введіть ``команди 1`` та введіть "
"ряд команд, які потрібно виконати, завершивши список ``кінець``. Список "
"команд може включати команди, які відновлюють виконання, такі як "
"``продовжити`` або ``далі``. (Надано Грегуаром Думсом.)"

#: ../../whatsnew/2.5.rst:1481
msgid ""
"The :mod:`pickle` and :mod:`cPickle` modules no longer accept a return value"
" of ``None`` from the :meth:`__reduce__` method; the method must return a "
"tuple of arguments instead.  The ability to return ``None`` was deprecated "
"in Python 2.4, so this completes the removal of the feature."
msgstr ""

#: ../../whatsnew/2.5.rst:1486
msgid ""
"The :mod:`pkgutil` module, containing various utility functions for finding "
"packages, was enhanced to support :pep:`302`'s import hooks and now also "
"works for packages stored in ZIP-format archives. (Contributed by Phillip J."
" Eby.)"
msgstr ""
"Модуль :mod:`pkgutil`, який містить різноманітні службові функції для пошуку"
" пакунків, було покращено для підтримки перехоплювачів імпорту :pep:`302` і "
"тепер також працює для пакунків, що зберігаються в архівах ZIP-формату. "
"(Надав Філіп Дж. Ебі.)"

#: ../../whatsnew/2.5.rst:1490
msgid ""
"The pybench benchmark suite by Marc-André Lemburg is now included in the "
":file:`Tools/pybench` directory.  The pybench suite is an improvement on the"
" commonly used :file:`pystone.py` program because pybench provides a more "
"detailed measurement of the interpreter's speed.  It times particular "
"operations such as function calls, tuple slicing, method lookups, and "
"numeric operations, instead of performing many different operations and "
"reducing the result to a single number as :file:`pystone.py` does."
msgstr ""
"Набір тестів pybench від Марка-Андре Лембурга тепер включено до каталогу "
":file:`Tools/pybench`. Набір pybench є вдосконаленням загальновживаної "
"програми :file:`pystone.py`, оскільки pybench забезпечує більш детальне "
"вимірювання швидкості інтерпретатора. Замість того, щоб виконувати багато "
"різних операцій і зводити результат до одного числа, як це робить "
":file:`pystone.py`, він відраховує певні операції, такі як виклики функцій, "
"нарізка кортежів, пошук методів і числові операції."

#: ../../whatsnew/2.5.rst:1498
msgid ""
"The :mod:`pyexpat` module now uses version 2.0 of the Expat parser. "
"(Contributed by Trent Mick.)"
msgstr ":mod:`pyexpat` 模块现在使用 Expat 解析器的 2.0 版。 （由 Trent Mick 贡献。）"

#: ../../whatsnew/2.5.rst:1501
msgid ""
"The :class:`~queue.Queue` class provided by the :mod:`Queue` module gained "
"two new methods.  :meth:`join` blocks until all items in the queue have been"
" retrieved and all processing work on the items  have been completed.  "
"Worker threads call the other new method,  :meth:`task_done`, to signal that"
" processing for an item has been completed.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
"Клас :class:`~queue.Queue`, наданий модулем :mod:`Queue`, отримав два нові "
"методи. :meth:`join` блокує, доки всі елементи в черзі не будуть отримані та"
" вся робота з обробки елементів не буде завершена. Робочі потоки викликають "
"інший новий метод, :meth:`task_done`, щоб повідомити, що обробку елемента "
"завершено. (Надав Реймонд Геттінгер.)"

#: ../../whatsnew/2.5.rst:1507
msgid ""
"The old :mod:`regex` and :mod:`regsub` modules, which have been  deprecated "
"ever since Python 2.0, have finally been deleted.   Other deleted modules: "
":mod:`statcache`, :mod:`tzparse`, :mod:`whrandom`."
msgstr ""
"Старі модулі :mod:`regex` і :mod:`regsub`, які були застарілими ще з Python "
"2.0, нарешті були видалені. Інші видалені модулі: :mod:`statcache`, "
":mod:`tzparse`, :mod:`whrandom`."

#: ../../whatsnew/2.5.rst:1511
msgid ""
"Also deleted: the :file:`lib-old` directory, which includes ancient modules "
"such as :mod:`dircmp` and :mod:`ni`, was removed.  :file:`lib-old` wasn't on"
" the default ``sys.path``, so unless your programs explicitly added the "
"directory to ``sys.path``, this removal shouldn't affect your code."
msgstr ""
"Також видалено: каталог :file:`lib-old`, який містить старі модулі, такі як "
":mod:`dircmp` і :mod:`ni`, було видалено. :file:`lib-old` не було в "
"``sys.path`` за замовчуванням, тому, якщо ваші програми явно не додали "
"каталог до ``sys.path``, це видалення не повинно вплинути на ваш код."

#: ../../whatsnew/2.5.rst:1516
msgid ""
"The :mod:`rlcompleter` module is no longer  dependent on importing the "
":mod:`readline` module and therefore now works on non-Unix platforms. (Patch"
" from Robert Kiendl.)"
msgstr ""
"Модуль :mod:`rlcompleter` більше не залежить від імпорту модуля "
":mod:`readline` і тому тепер працює на платформах, відмінних від Unix. (Патч"
" від Роберта Кіндла.)"

#: ../../whatsnew/2.5.rst:1522
msgid ""
"The :mod:`SimpleXMLRPCServer` and :mod:`DocXMLRPCServer`  classes now have a"
" :attr:`rpc_paths` attribute that constrains XML-RPC operations to a limited"
" set of URL paths; the default is to allow only ``'/'`` and ``'/RPC2'``.  "
"Setting :attr:`rpc_paths` to ``None`` or an empty tuple disables  this path "
"checking."
msgstr ""

#: ../../whatsnew/2.5.rst:1529
msgid ""
"The :mod:`socket` module now supports :const:`AF_NETLINK` sockets on Linux, "
"thanks to a patch from Philippe Biondi.   Netlink sockets are a Linux-"
"specific mechanism for communications between a user-space process and "
"kernel code; an introductory  article about them is at "
"https://www.linuxjournal.com/article/7356. In Python code, netlink addresses"
" are represented as a tuple of 2 integers, ``(pid, group_mask)``."
msgstr ""
"Модуль :mod:`socket` тепер підтримує :const:`AF_NETLINK` сокети в Linux "
"завдяки патчу від Філіпа Біонді. Сокети Netlink — це специфічний для Linux "
"механізм зв’язку між процесом простору користувача та кодом ядра; вступну "
"статтю про них можна знайти на https://www.linuxjournal.com/article/7356. У "
"коді Python адреси мережевих посилань представлені у вигляді кортежу з 2 "
"цілих чисел, ``(pid, group_mask)``."

#: ../../whatsnew/2.5.rst:1536
msgid ""
"Two new methods on socket objects, ``recv_into(buffer)`` and "
"``recvfrom_into(buffer)``, store the received data in an object  that "
"supports the buffer protocol instead of returning the data as a string.  "
"This means you can put the data directly into an array or a memory-mapped "
"file."
msgstr ""
"Два нові методи для об’єктів сокетів, ``recv_into(buffer)`` і "
"``recvfrom_into(buffer)``, зберігають отримані дані в об’єкті, який "
"підтримує протокол буфера, замість того, щоб повертати дані як рядок. Це "
"означає, що ви можете помістити дані безпосередньо в масив або файл із "
"відображенням пам’яті."

#: ../../whatsnew/2.5.rst:1541
msgid ""
"Socket objects also gained :meth:`getfamily`, :meth:`gettype`, and "
":meth:`getproto` accessor methods to retrieve the family, type, and protocol"
" values for the socket."
msgstr ""
"Об’єкти сокетів також отримали методи доступу :meth:`getfamily`, "
":meth:`gettype` і :meth:`getproto` для отримання значень сімейства, типу та "
"протоколу для сокета."

#: ../../whatsnew/2.5.rst:1545
msgid ""
"New module: the :mod:`spwd` module provides functions for accessing the "
"shadow password database on systems that support  shadow passwords."
msgstr ""
"Новий модуль: модуль :mod:`spwd` надає функції для доступу до бази даних "
"тіньових паролів у системах, які підтримують тіньові паролі."

#: ../../whatsnew/2.5.rst:1548
msgid ""
"The :mod:`struct` is now faster because it  compiles format strings into "
":class:`Struct` objects with :meth:`pack` and :meth:`unpack` methods.  This "
"is similar to how the :mod:`re` module lets you create compiled regular "
"expression objects.  You can still use the module-level  :func:`pack` and "
":func:`unpack` functions; they'll create  :class:`Struct` objects and cache "
"them.  Or you can use  :class:`Struct` instances directly::"
msgstr ""
":mod:`struct` тепер працює швидше, оскільки він компілює рядки формату в "
"об’єкти :class:`Struct` за допомогою методів :meth:`pack` і :meth:`unpack`. "
"Це подібно до того, як модуль :mod:`re` дозволяє створювати скомпільовані "
"об’єкти регулярного виразу. Ви все ще можете використовувати функції "
":func:`pack` і :func:`unpack` на рівні модуля; вони створять об’єкти "
":class:`Struct` і кешуватимуть їх. Або ви можете безпосередньо "
"використовувати екземпляри :class:`Struct`::"

#: ../../whatsnew/2.5.rst:1560
msgid ""
"You can also pack and unpack data to and from buffer objects directly using "
"the ``pack_into(buffer, offset, v1, v2, ...)`` and ``unpack_from(buffer, "
"offset)`` methods.  This lets you store data directly into an array or a "
"memory-mapped file."
msgstr ""
"Ви також можете пакувати та розпаковувати дані в буферні об’єкти та з них "
"безпосередньо за допомогою методів ``pack_into(buffer, offset, v1, v2, "
"...)`` і ``unpack_from(buffer, offset)``. Це дає змогу зберігати дані "
"безпосередньо в масиві або файлі, відображеному в пам’яті."

#: ../../whatsnew/2.5.rst:1565
msgid ""
"(:class:`Struct` objects were implemented by Bob Ippolito at the "
"NeedForSpeed sprint.  Support for buffer objects was added by Martin Blais, "
"also at the NeedForSpeed sprint.)"
msgstr ""
"(:class:`Struct` об’єкти реалізував Боб Іпполіто під час спринту "
"NeedForSpeed. Підтримку об’єктів буфера додав Мартін Блейс, також під час "
"спринту NeedForSpeed.)"

#: ../../whatsnew/2.5.rst:1569
msgid ""
"The Python developers switched from CVS to Subversion during the 2.5 "
"development process.  Information about the exact build version is available"
" as the ``sys.subversion`` variable, a 3-tuple of ``(interpreter-name, "
"branch-name, revision-range)``.  For example, at the time of writing my copy"
" of 2.5 was reporting ``('CPython', 'trunk', '45313:45315')``."
msgstr ""
"Розробники Python перейшли від CVS до Subversion під час процесу розробки "
"2.5. Інформація про точну версію збірки доступна як змінна "
"``sys.subversion``, 3-кортеж ``(ім'я-інтерпретатора, ім'я-гілки, діапазон-"
"версій)``. Наприклад, на момент написання моя копія 2.5 повідомляла про "
"``('CPython', 'trunk', '45313:45315')``."

#: ../../whatsnew/2.5.rst:1575
msgid ""
"This information is also available to C extensions via the "
":c:func:`Py_GetBuildInfo` function that returns a  string of build "
"information like this: ``\"trunk:45355:45356M, Apr 13 2006, 07:42:19\"``.   "
"(Contributed by Barry Warsaw.)"
msgstr ""
"Ця інформація також доступна для розширень C через функцію "
":c:func:`Py_GetBuildInfo`, яка повертає рядок інформації про збірку, як це: "
"``\"trunk:45355:45356M, Apr 13 2006, 07:42:19\"`` . (Надав Баррі Варшау.)"

#: ../../whatsnew/2.5.rst:1580
msgid ""
"Another new function, :func:`sys._current_frames`, returns the current stack"
" frames for all running threads as a dictionary mapping thread identifiers "
"to the topmost stack frame currently active in that thread at the time the "
"function is called.  (Contributed by Tim Peters.)"
msgstr ""
"Інша нова функція, :func:`sys._current_frames`, повертає поточні фрейми "
"стека для всіх запущених потоків як словник, що зіставляє ідентифікатори "
"потоку з найвищим фреймом стека, який зараз активний у цьому потоці на "
"момент виклику функції. (Надав Тім Пітерс.)"

#: ../../whatsnew/2.5.rst:1585
msgid ""
"The :class:`TarFile` class in the :mod:`tarfile` module now has an "
":meth:`extractall` method that extracts all members from the archive into "
"the current working directory.  It's also possible to set a different "
"directory as the extraction target, and to unpack only a subset of the "
"archive's members."
msgstr ""
"Клас :class:`TarFile` в модулі :mod:`tarfile` тепер має метод "
":meth:`extractall`, який витягує всі члени з архіву в поточний робочий "
"каталог. Також можна встановити інший каталог як ціль видобування та "
"розпакувати лише частину членів архіву."

#: ../../whatsnew/2.5.rst:1590
msgid ""
"The compression used for a tarfile opened in stream mode can now be "
"autodetected using the mode ``'r|*'``. (Contributed by Lars Gustäbel.)"
msgstr ""
"Стиснення, яке використовується для tar-файлу, відкритого в режимі потоку, "
"тепер можна автоматично визначити за допомогою режиму ``'r|*'``. (Надав Ларс"
" Густебель.)"

#: ../../whatsnew/2.5.rst:1595
msgid ""
"The :mod:`threading` module now lets you set the stack size used when new "
"threads are created. The ``stack_size([*size*])`` function returns the "
"currently configured stack size, and supplying the optional *size* parameter"
" sets a new value.  Not all platforms support changing the stack size, but "
"Windows, POSIX threading, and OS/2 all do. (Contributed by Andrew "
"MacIntyre.)"
msgstr ""
"Модуль :mod:`threading` тепер дозволяє встановлювати розмір стеку, який "
"використовується під час створення нових потоків. Функція "
"``stack_size([*size*])`` повертає поточний налаштований розмір стека, а "
"надання додаткового параметра *size* встановлює нове значення. Не всі "
"платформи підтримують зміну розміру стека, але Windows, потоки POSIX і OS/2 "
"підтримують. (Надав Ендрю Макінтайр.)"

#: ../../whatsnew/2.5.rst:1603
msgid ""
"The :mod:`unicodedata` module has been updated to use version 4.1.0 of the "
"Unicode character database.  Version 3.2.0 is required  by some "
"specifications, so it's still available as  :attr:`unicodedata.ucd_3_2_0`."
msgstr ""

#: ../../whatsnew/2.5.rst:1607
msgid ""
"New module: the  :mod:`uuid` module generates  universally unique "
"identifiers (UUIDs) according to :rfc:`4122`.  The RFC defines several "
"different UUID versions that are generated from a starting string, from "
"system properties, or purely randomly.  This module contains a :class:`UUID`"
" class and  functions named :func:`uuid1`, :func:`uuid3`, :func:`uuid4`,  "
"and  :func:`uuid5` to generate different versions of UUID.  (Version 2 UUIDs"
"  are not specified in :rfc:`4122` and are not supported by this module.) ::"
msgstr ""
"Новий модуль: модуль :mod:`uuid` генерує універсальні унікальні "
"ідентифікатори (UUID) відповідно до :rfc:`4122`. RFC визначає кілька різних "
"версій UUID, які генеруються з початкового рядка, властивостей системи або "
"абсолютно випадковим чином. Цей модуль містить клас :class:`UUID` і функції "
"з іменами :func:`uuid1`, :func:`uuid3`, :func:`uuid4` і :func:`uuid5` для "
"створення різних версій UUID. (UUID версії 2 не вказано в :rfc:`4122` і не "
"підтримується цим модулем.) ::"

#: ../../whatsnew/2.5.rst:1632
msgid "(Contributed by Ka-Ping Yee.)"
msgstr "（由 Ka-Ping Yee 贡献。）"

#: ../../whatsnew/2.5.rst:1634
msgid ""
"The :mod:`weakref` module's :class:`WeakKeyDictionary` and "
":class:`WeakValueDictionary` types gained new methods for iterating over the"
" weak references contained in the dictionary.  :meth:`iterkeyrefs` and "
":meth:`keyrefs` methods were added to :class:`WeakKeyDictionary`, and "
":meth:`itervaluerefs` and :meth:`valuerefs` were added to "
":class:`WeakValueDictionary`.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Типи :class:`WeakKeyDictionary` і :class:`WeakValueDictionary` модуля "
":mod:`weakref` отримали нові методи для повторення слабких посилань, що "
"містяться в словнику. Методи :meth:`iterkeyrefs` і :meth:`keyrefs` додано до"
" :class:`WeakKeyDictionary`, а :meth:`itervaluerefs` і :meth:`valuerefs` "
"додано до :class:`WeakValueDictionary`. (Надав Фред Л. Дрейк-молодший)"

#: ../../whatsnew/2.5.rst:1641
msgid ""
"The :mod:`webbrowser` module received a number of enhancements. It's now "
"usable as a script with ``python -m webbrowser``, taking a URL as the "
"argument; there are a number of switches  to control the behaviour "
"(:option:`!-n` for a new browser window,  :option:`!-t` for a new tab).  New"
" module-level functions, :func:`open_new` and :func:`open_new_tab`, were "
"added  to support this.  The module's :func:`open` function supports an "
"additional feature, an *autoraise* parameter that signals whether to raise "
"the open window when possible. A number of additional browsers were added to"
" the supported list such as Firefox, Opera, Konqueror, and elinks.  "
"(Contributed by Oleg Broytmann and Georg Brandl.)"
msgstr ""
"Модуль :mod:`webbrowser` отримав низку вдосконалень. Тепер його можна "
"використовувати як сценарій з ``python -m webbrowser``, приймаючи URL як "
"аргумент; є кілька перемикачів для керування поведінкою (:option:`!-n` для "
"нового вікна браузера, :option:`!-t` для нової вкладки). Для підтримки цього"
" додано нові функції на рівні модуля, :func:`open_new` і "
":func:`open_new_tab`. Функція модуля :func:`open` підтримує додаткову "
"функцію, параметр *autoraise*, який сигналізує, чи піднімати відкрите вікно,"
" коли це можливо. До списку підтримуваних було додано низку додаткових "
"браузерів, таких як Firefox, Opera, Konqueror та elinks. (Надано Олегом "
"Бройтманном і Георгом Брандлом.)"

#: ../../whatsnew/2.5.rst:1653
msgid ""
"The :mod:`xmlrpclib` module now supports returning  "
":class:`~datetime.datetime` objects for the XML-RPC date type.  Supply  "
"``use_datetime=True`` to the :func:`loads` function or the "
":class:`Unmarshaller` class to enable this feature. (Contributed by Skip "
"Montanaro.)"
msgstr ""

#: ../../whatsnew/2.5.rst:1660
msgid ""
"The :mod:`zipfile` module now supports the ZIP64 version of the  format, "
"meaning that a .zip archive can now be larger than 4 GiB and can contain "
"individual files larger than 4 GiB.  (Contributed by Ronald Oussoren.)"
msgstr ""
"Модуль :mod:`zipfile` тепер підтримує версію формату ZIP64, тобто архів .zip"
" тепер може бути більшим за 4 ГіБ і містити окремі файли розміром понад 4 "
"ГіБ. (Надав Рональд Уссорен.)"

#: ../../whatsnew/2.5.rst:1666
msgid ""
"The :mod:`zlib` module's :class:`Compress` and :class:`Decompress` objects "
"now support a :meth:`copy` method that makes a copy of the  object's "
"internal state and returns a new  :class:`Compress` or :class:`Decompress` "
"object. (Contributed by Chris AtLee.)"
msgstr ""
"Об’єкти :class:`Compress` і :class:`Decompress` модуля :mod:`zlib` тепер "
"підтримують метод :meth:`copy`, який створює копію внутрішнього стану "
"об’єкта та повертає новий :class:`Compress` або :class:`Decompress` об’єкт. "
"(Надав Кріс Етлі.)"

#: ../../whatsnew/2.5.rst:1679
msgid "The ctypes package"
msgstr "ctypes 包"

#: ../../whatsnew/2.5.rst:1681
msgid ""
"The :mod:`ctypes` package, written by Thomas Heller, has been added  to the "
"standard library.  :mod:`ctypes` lets you call arbitrary functions  in "
"shared libraries or DLLs.  Long-time users may remember the :mod:`dl` "
"module, which provides functions for loading shared libraries and calling "
"functions in them. The :mod:`ctypes` package is much fancier."
msgstr ""

#: ../../whatsnew/2.5.rst:1687
msgid ""
"To load a shared library or DLL, you must create an instance of the "
":class:`CDLL` class and provide the name or path of the shared library or "
"DLL. Once that's done, you can call arbitrary functions by accessing them as"
" attributes of the :class:`CDLL` object.   ::"
msgstr ""
"Щоб завантажити спільну бібліотеку або DLL, ви повинні створити екземпляр "
"класу :class:`CDLL` і вказати назву або шлях до спільної бібліотеки або DLL."
" Коли це буде зроблено, ви можете викликати довільні функції, звертаючись до"
" них як до атрибутів об’єкта :class:`CDLL`. ::"

#: ../../whatsnew/2.5.rst:1697
msgid ""
"Type constructors for the various C types are provided: :func:`c_int`, "
":func:`c_float`, :func:`c_double`, :func:`c_char_p` (equivalent to "
":c:expr:`char \\*`), and so forth.  Unlike Python's types, the C versions "
"are all mutable; you can assign to their :attr:`value` attribute to change "
"the wrapped value.  Python integers and strings will be automatically "
"converted to the corresponding C types, but for other types you  must call "
"the correct type constructor.  (And I mean *must*;  getting it wrong will "
"often result in the interpreter crashing with a segmentation fault.)"
msgstr ""
"Предоставляются конструкторы типов для различных типов C: :func:`c_int`, "
":func:`c_float`, :func:`c_double`, :func:`c_char_p` (эквивалентно "
":c:expr:`char \\*` ) и так далее. В отличие от типов Python, все версии C "
"изменяемы; вы можете назначить их атрибуту :attr:`value`, чтобы изменить "
"завернутое значение. Целые числа и строки Python будут автоматически "
"преобразованы в соответствующие типы C, но для других типов необходимо "
"вызвать правильный конструктор типов. (И я имею в виду *должен*; ошибка "
"часто приводит к сбою интерпретатора из-за ошибки сегментации.)"

#: ../../whatsnew/2.5.rst:1706
msgid ""
"You shouldn't use :func:`c_char_p` with a Python string when the C function "
"will be modifying the memory area, because Python strings are  supposed to "
"be immutable; breaking this rule will cause puzzling bugs.  When you need a "
"modifiable memory area, use :func:`create_string_buffer`::"
msgstr ""
"Ви не повинні використовувати :func:`c_char_p` із рядком Python, коли "
"функція C буде змінювати область пам’яті, тому що рядки Python мають бути "
"незмінними; порушення цього правила призведе до загадкових помилок. Якщо вам"
" потрібна область пам’яті, яку можна змінювати, використовуйте "
":func:`create_string_buffer`::"

#: ../../whatsnew/2.5.rst:1715
msgid ""
"C functions are assumed to return integers, but you can set the "
":attr:`restype` attribute of the function object to  change this::"
msgstr ""
"Передбачається, що функції C повертають цілі числа, але ви можете встановити"
" атрибут :attr:`restype` об’єкта функції, щоб змінити це:"

#: ../../whatsnew/2.5.rst:1724
msgid ""
":mod:`ctypes` also provides a wrapper for Python's C API  as the "
"``ctypes.pythonapi`` object.  This object does *not*  release the global "
"interpreter lock before calling a function, because the lock must be held "
"when calling into the interpreter's code.   There's a :class:`py_object()` "
"type constructor that will create a  :c:expr:`PyObject *` pointer.  A simple"
" usage::"
msgstr ""

#: ../../whatsnew/2.5.rst:1737
msgid ""
"Don't forget to use :class:`py_object()`; if it's omitted you end  up with a"
" segmentation fault."
msgstr ""
"Не забудьте використати :class:`py_object()`; якщо його пропустити, ви "
"отримаєте помилку сегментації."

#: ../../whatsnew/2.5.rst:1740
msgid ""
":mod:`ctypes` has been around for a while, but people still write  and "
"distribution hand-coded extension modules because you can't rely on "
":mod:`ctypes` being present. Perhaps developers will begin to write  Python "
"wrappers atop a library accessed through :mod:`ctypes` instead of extension "
"modules, now that :mod:`ctypes` is included with core Python."
msgstr ""
":mod:`ctypes` існує вже деякий час, але люди все ще пишуть і розповсюджують "
"модулі розширення, створені вручну, тому що ви не можете покладатися на "
"наявність :mod:`ctypes`. Можливо, розробники почнуть писати оболонки Python "
"поверх бібліотеки, доступ до якої здійснюється через :mod:`ctypes` замість "
"модулів розширення, тепер, коли :mod:`ctypes` включено до ядра Python."

#: ../../whatsnew/2.5.rst:1750
msgid ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/"
msgstr ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/"

#: ../../whatsnew/2.5.rst:1750
msgid "The pre-stdlib ctypes web page, with a tutorial, reference, and FAQ."
msgstr "pre-stdlib ctypes 网页，包括教程、参考资料和常见问题。"

#: ../../whatsnew/2.5.rst:1752
msgid "The documentation  for the :mod:`ctypes` module."
msgstr ":mod:`ctypes` 模块的文档。"

#: ../../whatsnew/2.5.rst:1760
msgid "The ElementTree package"
msgstr "ElementTree 包"

#: ../../whatsnew/2.5.rst:1762
msgid ""
"A subset of Fredrik Lundh's ElementTree library for processing XML has been "
"added to the standard library as :mod:`xml.etree`.  The available modules "
"are :mod:`ElementTree`, :mod:`ElementPath`, and :mod:`ElementInclude` from "
"ElementTree 1.2.6.    The :mod:`cElementTree` accelerator module is also "
"included."
msgstr ""
"Підмножину бібліотеки ElementTree Фредріка Лунда для обробки XML було додано"
" до стандартної бібліотеки як :mod:`xml.etree`. Доступні модулі "
":mod:`ElementTree`, :mod:`ElementPath` і :mod:`ElementInclude` з ElementTree"
" 1.2.6. Також включено модуль прискорення :mod:`cElementTree`."

#: ../../whatsnew/2.5.rst:1768
msgid ""
"The rest of this section will provide a brief overview of using ElementTree."
" Full documentation for ElementTree is available at "
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm."
msgstr ""
"本节的剩余部分将提供使用 ElementTree 的简要说明。 要获取 ElementTree 的完整文档可访问 "
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm。"

#: ../../whatsnew/2.5.rst:1772
msgid ""
"ElementTree represents an XML document as a tree of element nodes. The text "
"content of the document is stored as the :attr:`text` and :attr:`tail` "
"attributes of  (This is one of the major differences between ElementTree and"
" the Document Object Model; in the DOM there are many different types of "
"node, including :class:`TextNode`.)"
msgstr ""
"ElementTree представляє XML-документ як дерево вузлів елементів. Текстовий "
"вміст документа зберігається як атрибути :attr:`text` і :attr:`tail` (Це "
"одна з головних відмінностей між ElementTree та об’єктною моделлю документа;"
" у DOM є багато різних типів вузол, включаючи :class:`TextNode`.)"

#: ../../whatsnew/2.5.rst:1778
msgid ""
"The most commonly used parsing function is :func:`parse`, that takes either "
"a string (assumed to contain a filename) or a file-like object and returns "
"an :class:`ElementTree` instance::"
msgstr ""
"Найпоширенішою функцією синтаксичного аналізу є :func:`parse`, яка приймає "
"або рядок (передбачається, що містить ім’я файлу), або файлоподібний об’єкт "
"і повертає екземпляр :class:`ElementTree`::"

#: ../../whatsnew/2.5.rst:1790
msgid ""
"Once you have an :class:`ElementTree` instance, you can call its "
":meth:`getroot` method to get the root :class:`Element` node."
msgstr ""
"Коли у вас є екземпляр :class:`ElementTree`, ви можете викликати його метод "
":meth:`getroot`, щоб отримати кореневий вузол :class:`Element`."

#: ../../whatsnew/2.5.rst:1793
msgid ""
"There's also an :func:`XML` function that takes a string literal and returns"
" an :class:`Element` node (not an :class:`ElementTree`).   This function "
"provides a tidy way to incorporate XML fragments, approaching the "
"convenience of an XML literal::"
msgstr ""
"Існує також функція :func:`XML`, яка приймає рядковий літерал і повертає "
"вузол :class:`Element` (а не :class:`ElementTree`). Ця функція забезпечує "
"зручний спосіб об’єднання фрагментів XML, наближаючись до зручності літералу"
" XML:"

#: ../../whatsnew/2.5.rst:1803
msgid ""
"Each XML element supports some dictionary-like and some list-like access "
"methods.  Dictionary-like operations are used to access attribute values, "
"and list-like operations are used to access child nodes."
msgstr ""
"Кожен елемент XML підтримує деякі методи доступу, подібні до словника, і "
"деякі, подібні до списку. Операції, подібні до словника, використовуються "
"для доступу до значень атрибутів, а операції, подібні до списку, "
"використовуються для доступу до дочірніх вузлів."

#: ../../whatsnew/2.5.rst:1808
msgid "Operation"
msgstr "运算"

#: ../../whatsnew/2.5.rst:1808
msgid "Result"
msgstr "结果："

#: ../../whatsnew/2.5.rst:1810
msgid "``elem[n]``"
msgstr "``elem[n]``"

#: ../../whatsnew/2.5.rst:1810
msgid "Returns n'th child element."
msgstr "返回第n个子元素"

#: ../../whatsnew/2.5.rst:1812
msgid "``elem[m:n]``"
msgstr "``elem[m:n]``"

#: ../../whatsnew/2.5.rst:1812
msgid "Returns list of m'th through n'th child elements."
msgstr "返回第m至第n个子元素的列表。"

#: ../../whatsnew/2.5.rst:1815
msgid "``len(elem)``"
msgstr "``len(elem)``"

#: ../../whatsnew/2.5.rst:1815
msgid "Returns number of child elements."
msgstr "返回子元素的个数"

#: ../../whatsnew/2.5.rst:1817
msgid "``list(elem)``"
msgstr "``list(elem)``"

#: ../../whatsnew/2.5.rst:1817
msgid "Returns list of child elements."
msgstr "返回子元素的列表"

#: ../../whatsnew/2.5.rst:1819
msgid "``elem.append(elem2)``"
msgstr "``elem.append(elem2)``"

#: ../../whatsnew/2.5.rst:1819
msgid "Adds *elem2* as a child."
msgstr "将 *elem2* 添加为子级。"

#: ../../whatsnew/2.5.rst:1821
msgid "``elem.insert(index, elem2)``"
msgstr "``elem.insert(index, elem2)``"

#: ../../whatsnew/2.5.rst:1821
msgid "Inserts *elem2* at the specified location."
msgstr "在指定位置插入 *elem2* 。"

#: ../../whatsnew/2.5.rst:1823
msgid "``del elem[n]``"
msgstr "``del elem[n]``"

#: ../../whatsnew/2.5.rst:1823
msgid "Deletes n'th child element."
msgstr "删除第n个子元素"

#: ../../whatsnew/2.5.rst:1825
msgid "``elem.keys()``"
msgstr "``elem.keys()``"

#: ../../whatsnew/2.5.rst:1825
msgid "Returns list of attribute names."
msgstr "返回属性名称的列表。"

#: ../../whatsnew/2.5.rst:1827
msgid "``elem.get(name)``"
msgstr "``elem.get(name)``"

#: ../../whatsnew/2.5.rst:1827
msgid "Returns value of attribute *name*."
msgstr "返回 *name* 属性的值。"

#: ../../whatsnew/2.5.rst:1829
msgid "``elem.set(name, value)``"
msgstr "``elem.set(name, value)``"

#: ../../whatsnew/2.5.rst:1829
msgid "Sets new value for attribute *name*."
msgstr "为 *name* 属性设置新值"

#: ../../whatsnew/2.5.rst:1831
msgid "``elem.attrib``"
msgstr "``elem.attrib``"

#: ../../whatsnew/2.5.rst:1831
msgid "Retrieves the dictionary containing attributes."
msgstr "检索包含属性的字典。"

#: ../../whatsnew/2.5.rst:1834
msgid "``del elem.attrib[name]``"
msgstr "``del elem.attrib[name]``"

#: ../../whatsnew/2.5.rst:1834
msgid "Deletes attribute *name*."
msgstr "删除 元素 *name* 的属性"

#: ../../whatsnew/2.5.rst:1837
msgid ""
"Comments and processing instructions are also represented as "
":class:`Element` nodes.  To check if a node is a comment or processing "
"instructions::"
msgstr ""
"Коментарі та інструкції з обробки також представлені у вигляді вузлів "
":class:`Element`. Щоб перевірити, чи є вузол коментарем або інструкцією з "
"обробки:"

#: ../../whatsnew/2.5.rst:1845
msgid ""
"To generate XML output, you should call the :meth:`ElementTree.write` "
"method. Like :func:`parse`, it can take either a string or a file-like "
"object::"
msgstr ""
"Щоб згенерувати вивід XML, вам слід викликати метод "
":meth:`ElementTree.write`. Як і :func:`parse`, він може приймати або рядок, "
"або файлоподібний об’єкт::"

#: ../../whatsnew/2.5.rst:1855
msgid ""
"(Caution: the default encoding used for output is ASCII.  For general XML "
"work, where an element's name may contain arbitrary Unicode characters, "
"ASCII isn't a very useful encoding because it will raise an exception if an "
"element's name contains any characters with values greater than 127.  "
"Therefore, it's best to specify a different encoding such as UTF-8 that can "
"handle any Unicode character.)"
msgstr ""
"(Увага: кодування за замовчуванням, яке використовується для виводу, — "
"ASCII. Для загальної роботи з XML, де ім’я елемента може містити довільні "
"символи Unicode, ASCII не є дуже корисним кодуванням, оскільки воно "
"спричинить виключення, якщо ім’я елемента містить будь-які символи зі "
"значеннями більше 127. Тому найкраще вказати інше кодування, наприклад "
"UTF-8, яке може обробляти будь-який символ Unicode.)"

#: ../../whatsnew/2.5.rst:1862
msgid ""
"This section is only a partial description of the ElementTree interfaces. "
"Please read the package's official documentation for more details."
msgstr ""
"Цей розділ є лише частковим описом інтерфейсів ElementTree. Щоб дізнатися "
"більше, прочитайте офіційну документацію пакета."

#: ../../whatsnew/2.5.rst:1868
msgid ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"
msgstr ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"

#: ../../whatsnew/2.5.rst:1869
msgid "Official documentation for ElementTree."
msgstr "ElementTree 的官方文档"

#: ../../whatsnew/2.5.rst:1877
msgid "The hashlib package"
msgstr "hashlib 包"

#: ../../whatsnew/2.5.rst:1879
msgid ""
"A new :mod:`hashlib` module, written by Gregory P. Smith,  has been added to"
" replace the :mod:`md5` and :mod:`sha` modules.  :mod:`hashlib` adds support"
" for additional secure hashes (SHA-224, SHA-256, SHA-384, and SHA-512). When"
" available, the module uses OpenSSL for fast platform optimized "
"implementations of algorithms."
msgstr ""

#: ../../whatsnew/2.5.rst:1885
msgid ""
"The old :mod:`md5` and :mod:`sha` modules still exist as wrappers around "
"hashlib to preserve backwards compatibility.  The new module's interface is "
"very close to that of the old modules, but not identical. The most "
"significant difference is that the constructor functions for creating new "
"hashing objects are named differently. ::"
msgstr ""

#: ../../whatsnew/2.5.rst:1914
msgid ""
"Once a hash object has been created, its methods are the same as before: "
"``update(string)`` hashes the specified string into the  current digest "
"state, :meth:`digest` and :meth:`hexdigest` return the digest value as a "
"binary string or a string of hex digits, and :meth:`copy` returns a new "
"hashing object with the same digest state."
msgstr ""
"Після створення хеш-об’єкта його методи залишаються такими ж, як і раніше: "
"``update(string)`` хешує вказаний рядок у поточний стан дайджесту, "
":meth:`digest` і :meth:`hexdigest` повертають дайджест значення у вигляді "
"двійкового рядка або рядка шістнадцяткових цифр, а :meth:`copy` повертає "
"новий об’єкт хешування з тим самим станом дайджесту."

#: ../../whatsnew/2.5.rst:1923
msgid "The documentation  for the :mod:`hashlib` module."
msgstr ":mod:`hashlib` 模块的文档。"

#: ../../whatsnew/2.5.rst:1931
msgid "The sqlite3 package"
msgstr "sqlite3 包"

#: ../../whatsnew/2.5.rst:1933
msgid ""
"The pysqlite module (https://www.pysqlite.org), a wrapper for the SQLite "
"embedded database, has been added to the standard library under the package "
"name :mod:`sqlite3`."
msgstr ""
"pysqlite 模块 (https://www.pysqlite.org) 是 SQLite 嵌入式数据库的封装器，已添加到标准库中，软件包名称为 "
":mod:`sqlite3`。"

#: ../../whatsnew/2.5.rst:1937
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../whatsnew/2.5.rst:1944
msgid ""
"pysqlite was written by Gerhard Häring and provides a SQL interface "
"compliant with the DB-API 2.0 specification described by :pep:`249`."
msgstr ""
"pysqlite був написаний Герхардом Херінгом і забезпечує інтерфейс SQL, "
"сумісний зі специфікацією DB-API 2.0, описаною :pep:`249`."

#: ../../whatsnew/2.5.rst:1947
msgid ""
"If you're compiling the Python source yourself, note that the source tree "
"doesn't include the SQLite code, only the wrapper module. You'll need to "
"have the SQLite libraries and headers installed before compiling Python, and"
" the build process will compile the module when the necessary headers are "
"available."
msgstr ""
"如果您自己编译 Python 源代码，请注意源代码树不包含 SQLite 代码，只包含封装模块。在编译 Python 之前，您需要安装 SQLite "
"库和头文件，当必要的头文件可用时，编译过程将编译模块。"

#: ../../whatsnew/2.5.rst:1952
msgid ""
"To use the module, you must first create a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the "
":file:`/tmp/example` file::"
msgstr ""
"Щоб використовувати модуль, ви повинні спочатку створити об’єкт "
":class:`Connection`, який представлятиме базу даних. Тут дані "
"зберігатимуться у файлі :file:`/tmp/example`::"

#: ../../whatsnew/2.5.rst:1958
msgid ""
"You can also supply the special name ``:memory:`` to create a database in "
"RAM."
msgstr "你也可以使用 ``:memory:`` 来创建一个内存中的数据库"

#: ../../whatsnew/2.5.rst:1960
msgid ""
"Once you have a :class:`Connection`, you can create a :class:`Cursor`  "
"object and call its :meth:`execute` method to perform SQL commands::"
msgstr ""
"Коли у вас є :class:`Connection`, ви можете створити об’єкт :class:`Cursor` "
"і викликати його метод :meth:`execute` для виконання команд SQL::"

#: ../../whatsnew/2.5.rst:1974
msgid ""
"Usually your SQL operations will need to use values from Python variables.  "
"You shouldn't assemble your query using Python's string operations because "
"doing so is insecure; it makes your program vulnerable to an SQL injection "
"attack."
msgstr ""
"通常，您的 SQL 操作需要使用来自 Python 变量的值。  您不应该使用 Python "
"的字符串操作来组装您的查询，因为这样做是不安全的，它会使您的程序容易受到 SQL 注入攻击。"

#: ../../whatsnew/2.5.rst:1978
msgid ""
"Instead, use the DB-API's parameter substitution.  Put ``?`` as a "
"placeholder wherever you want to use a value, and then provide a tuple of "
"values as the second argument to the cursor's :meth:`execute` method.  "
"(Other database modules may use a different placeholder, such as ``%s`` or "
"``:1``.) For example::"
msgstr ""
"Замість цього використовуйте підстановку параметрів DB-API. Помістіть ``?`` "
"як покажчик місця заповнення, де ви хочете використовувати значення, а потім"
" надайте кортеж значень як другий аргумент для методу :meth:`execute` "
"курсора. (Інші модулі бази даних можуть використовувати інший заповнювач, "
"наприклад ``%s`` або ``:1``.) Наприклад::"

#: ../../whatsnew/2.5.rst:1998
msgid ""
"To retrieve data after executing a SELECT statement, you can either  treat "
"the cursor as an iterator, call the cursor's :meth:`fetchone` method to "
"retrieve a single matching row,  or call :meth:`fetchall` to get a list of "
"the matching rows."
msgstr ""
"Щоб отримати дані після виконання оператора SELECT, ви можете розглядати "
"курсор як ітератор, викликати метод курсора :meth:`fetchone`, щоб отримати "
"один відповідний рядок, або викликати :meth:`fetchall`, щоб отримати список "
"відповідні рядки."

#: ../../whatsnew/2.5.rst:2003
msgid "This example uses the iterator form::"
msgstr "下面是一个使用迭代器形式的例子："

#: ../../whatsnew/2.5.rst:2016
msgid ""
"For more information about the SQL dialect supported by SQLite, see "
"https://www.sqlite.org."
msgstr "有关 SQLite 所支持的 SQL 方法的更多信息，请参阅 https://www.sqlite.org。"

#: ../../whatsnew/2.5.rst:2023
msgid "https://www.pysqlite.org"
msgstr "https://www.pysqlite.org"

#: ../../whatsnew/2.5.rst:2023
msgid "The pysqlite web page."
msgstr "pysqlite 的主页"

#: ../../whatsnew/2.5.rst:2027
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../whatsnew/2.5.rst:2026
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../whatsnew/2.5.rst:2029
msgid "The documentation  for the :mod:`sqlite3` module."
msgstr ":mod:`sqlite3` 模块的文档。"

#: ../../whatsnew/2.5.rst:2031
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../whatsnew/2.5.rst:2032
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰写。"

#: ../../whatsnew/2.5.rst:2040
msgid "The wsgiref package"
msgstr "wsgiref 包"

#: ../../whatsnew/2.5.rst:2042
msgid ""
"The Web Server Gateway Interface (WSGI) v1.0 defines a standard interface "
"between web servers and Python web applications and is described in "
":pep:`333`. The :mod:`wsgiref` package is a reference implementation of the "
"WSGI specification."
msgstr ""
"Інтерфейс шлюзу веб-сервера (WSGI) v1.0 визначає стандартний інтерфейс між "
"веб-серверами та веб-додатками Python і описаний у :pep:`333`. Пакет "
":mod:`wsgiref` є еталонною реалізацією специфікації WSGI."

#: ../../whatsnew/2.5.rst:2049
msgid ""
"The package includes a basic HTTP server that will run a WSGI application; "
"this server is useful for debugging but isn't intended for  production use."
"  Setting up a server takes only a few lines of code::"
msgstr "该软件包包含一个基本 HTTP 服务器，可运行 WSGI 应用程序；该服务器可用于调试，但不打算用于生产环境。设置服务器只需几行代码："

#: ../../whatsnew/2.5.rst:2069
msgid ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/"
msgstr ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/"

#: ../../whatsnew/2.5.rst:2069
msgid "A central web site for WSGI-related resources."
msgstr "WSGI相关资源的核心网站。"

#: ../../whatsnew/2.5.rst:2071
msgid ":pep:`333` - Python Web Server Gateway Interface v1.0"
msgstr ":pep:`333` - Python Web服务器网关接口 v1.0"

#: ../../whatsnew/2.5.rst:2072
msgid "PEP written by Phillip J. Eby."
msgstr "PEP 由 Phillip J. Eby 撰写"

#: ../../whatsnew/2.5.rst:2080
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/2.5.rst:2082
msgid "Changes to Python's build process and to the C API include:"
msgstr "针对 Python 构建过程和 C API 的改变包括:"

#: ../../whatsnew/2.5.rst:2084
msgid ""
"The Python source tree was converted from CVS to Subversion,  in a complex "
"migration procedure that was supervised and flawlessly carried out by Martin"
" von Löwis.  The procedure was developed as :pep:`347`."
msgstr ""
"Дерево вихідних кодів Python було перетворено з CVS на Subversion у складній"
" процедурі міграції, яка контролювалася та бездоганно виконана Мартіном фон "
"Льовісом. Процедура була розроблена як :pep:`347`."

#: ../../whatsnew/2.5.rst:2088
msgid ""
"Coverity, a company that markets a source code analysis tool called Prevent,"
" provided the results of their examination of the Python source code.  The "
"analysis found about 60 bugs that  were quickly fixed.  Many of the bugs "
"were refcounting problems, often occurring in error-handling code.  See "
"https://scan.coverity.com for the statistics."
msgstr ""
"Coverity, компанія, яка продає інструмент аналізу вихідного коду під назвою "
"Prevent, надала результати свого дослідження вихідного коду Python. Аналіз "
"виявив близько 60 помилок, які були швидко виправлені. Багато помилок були "
"проблемами повторного підрахунку, які часто траплялися в коді обробки "
"помилок. Перегляньте статистику https://scan.coverity.com."

#: ../../whatsnew/2.5.rst:2094
msgid ""
"The largest change to the C API came from :pep:`353`, which modifies the "
"interpreter to use a :c:type:`Py_ssize_t` type definition instead of "
":c:expr:`int`.  See the earlier section :ref:`pep-353` for a discussion of "
"this change."
msgstr ""
"Самое большое изменение в C API произошло благодаря :pep:`353`, который "
"модифицирует интерпретатор, чтобы использовать определение типа "
":c:type:`Py_ssize_t` вместо :c:expr:`int`. См. предыдущий раздел "
":ref:`pep-353` для обсуждения этого изменения."

#: ../../whatsnew/2.5.rst:2099
msgid ""
"The design of the bytecode compiler has changed a great deal,  no longer "
"generating bytecode by traversing the parse tree.  Instead the parse tree is"
" converted to an abstract syntax tree (or AST), and it is  the abstract "
"syntax tree that's traversed to produce the bytecode."
msgstr ""
"Дизайн компілятора байт-коду значно змінився, більше не генеруючи байт-код "
"шляхом обходу дерева аналізу. Замість цього дерево синтаксичного аналізу "
"перетворюється на абстрактне синтаксичне дерево (або AST), і це абстрактне "
"синтаксичне дерево обходиться для отримання байт-коду."

#: ../../whatsnew/2.5.rst:2104
msgid ""
"It's possible for Python code to obtain AST objects by using the "
":func:`compile` built-in and specifying ``_ast.PyCF_ONLY_AST`` as the value "
"of the  *flags* parameter::"
msgstr ""
"Код Python може отримати об’єкти AST, використовуючи вбудований "
":func:`compile` і вказавши ``_ast.PyCF_ONLY_AST`` як значення параметра "
"*flags*::"

#: ../../whatsnew/2.5.rst:2117
msgid ""
"No official documentation has been written for the AST code yet, but "
":pep:`339` discusses the design.  To start learning about the code, read the"
" definition of the various AST nodes in :file:`Parser/Python.asdl`.  A "
"Python script reads this file and generates a set of C structure definitions"
" in :file:`Include/Python-ast.h`.  The :c:func:`PyParser_ASTFromString` and "
":c:func:`PyParser_ASTFromFile`, defined in :file:`Include/pythonrun.h`, take"
" Python source as input and return the root of an AST representing the "
"contents. This AST can then be turned into a code object by "
":c:func:`PyAST_Compile`.  For more information, read the source code, and "
"then ask questions on python-dev."
msgstr ""

#: ../../whatsnew/2.5.rst:2127
msgid ""
"The AST code was developed under Jeremy Hylton's management, and implemented"
" by (in alphabetical order) Brett Cannon, Nick Coghlan, Grant Edwards, John "
"Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo, and Neil "
"Schemenauer, plus the participants in a number of AST sprints at conferences"
" such as PyCon."
msgstr ""
"Код AST був розроблений під керівництвом Джеремі Гілтона та впроваджений (в "
"алфавітному порядку) Бреттом Кенноном, Ніком Когланом, Грантом Едвардсом, "
"Джоном Ересманом, Куртом Кайзером, Нілом Норвітцем, Тімом Пітерсом, Арміном "
"Ріго та Нілом Шеменауером, а також учасниками ряд спринтів AST на "
"конференціях, таких як PyCon."

#: ../../whatsnew/2.5.rst:2136
msgid ""
"Evan Jones's patch to obmalloc, first described in a talk at PyCon DC 2005, "
"was applied.  Python 2.4 allocated small objects in 256K-sized arenas, but "
"never freed arenas.  With this patch, Python will free arenas when they're "
"empty.  The net effect is that on some platforms, when you allocate many "
"objects, Python's memory usage may actually drop when you delete them and "
"the memory may be returned to the operating system.  (Implemented by Evan "
"Jones, and reworked by Tim Peters.)"
msgstr ""
"Було застосовано патч Евана Джонса для obmalloc, вперше описаний у виступі "
"на PyCon DC 2005. Python 2.4 розподіляв невеликі об’єкти на аренах розміром "
"256 КБ, але ніколи не звільняв арен. За допомогою цього патча Python "
"звільнить арени, коли вони порожні. Чистий ефект полягає в тому, що на "
"деяких платформах, коли ви виділяєте багато об’єктів, використання пам’яті "
"Python може фактично зменшитися, коли ви їх видаляєте, і пам’ять може "
"повертатися до операційної системи. (Реалізовано Еваном Джонсом і "
"перероблено Тімом Пітерсом.)"

#: ../../whatsnew/2.5.rst:2144
msgid ""
"Note that this change means extension modules must be more careful when "
"allocating memory.  Python's API has many different functions for allocating"
" memory that are grouped into families.  For example, "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc`, and :c:func:`PyMem_Free` "
"are one family that allocates raw memory, while :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc`, and :c:func:`PyObject_Free` are another family "
"that's supposed to be used for creating Python objects."
msgstr ""
"Зауважте, що ця зміна означає, що модулі розширення повинні бути більш "
"обережними під час розподілу пам’яті. API Python має багато різних функцій "
"для розподілу пам’яті, згрупованих у родини. Наприклад, "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` і :c:func:`PyMem_Free` є "
"однією сім’єю, яка виділяє необроблену пам’ять, тоді як "
":c:func:`PyObject_Malloc`, :c :func:`PyObject_Realloc` і "
":c:func:`PyObject_Free` — ще одне сімейство, яке має використовуватися для "
"створення об’єктів Python."

#: ../../whatsnew/2.5.rst:2152
msgid ""
"Previously these different families all reduced to the platform's "
":c:func:`malloc` and :c:func:`free` functions.  This meant  it didn't matter"
" if you got things wrong and allocated memory with the :c:func:`PyMem` "
"function but freed it with the :c:func:`PyObject` function.  With 2.5's "
"changes to obmalloc, these families now do different things and mismatches "
"will probably result in a segfault.  You should carefully test your C "
"extension modules with Python 2.5."
msgstr ""

#: ../../whatsnew/2.5.rst:2159
msgid ""
"The built-in set types now have an official C API.  Call :c:func:`PySet_New`"
" and :c:func:`PyFrozenSet_New` to create a new set, :c:func:`PySet_Add` and "
":c:func:`PySet_Discard` to add and remove elements, and "
":c:func:`PySet_Contains` and :c:func:`PySet_Size` to examine the set's "
"state. (Contributed by Raymond Hettinger.)"
msgstr ""
"Вбудовані типи наборів тепер мають офіційний C API. Викличте "
":c:func:`PySet_New` і :c:func:`PyFrozenSet_New`, щоб створити новий набір, "
":c:func:`PySet_Add` і :c:func:`PySet_Discard`, щоб додати та видалити "
"елементи, і :c :func:`PySet_Contains` і :c:func:`PySet_Size` для перевірки "
"стану набору. (Надав Реймонд Геттінгер.)"

#: ../../whatsnew/2.5.rst:2165
msgid ""
"C code can now obtain information about the exact revision of the Python "
"interpreter by calling the  :c:func:`Py_GetBuildInfo` function that returns "
"a string of build information like this: ``\"trunk:45355:45356M, Apr 13 "
"2006, 07:42:19\"``.   (Contributed by Barry Warsaw.)"
msgstr ""
"Код C тепер може отримати інформацію про точну версію інтерпретатора Python,"
" викликавши функцію :c:func:`Py_GetBuildInfo`, яка повертає рядок інформації"
" про збірку, як це: ``\"trunk:45355:45356M, 13 квітня 2006 р., 07 "
":42:19\"``. (Надав Баррі Варшау.)"

#: ../../whatsnew/2.5.rst:2170
msgid ""
"Two new macros can be used to indicate C functions that are local to the "
"current file so that a faster calling convention can be used. "
"``Py_LOCAL(type)`` declares the function as returning a value of the "
"specified *type* and uses a fast-calling qualifier. "
"``Py_LOCAL_INLINE(type)`` does the same thing and also requests the function"
" be inlined.  If :c:func:`PY_LOCAL_AGGRESSIVE` is defined before "
":file:`python.h` is included, a set of more aggressive optimizations are "
"enabled for the module; you should benchmark the results to find out if "
"these optimizations actually make the code faster.  (Contributed by Fredrik "
"Lundh at the NeedForSpeed sprint.)"
msgstr ""

#: ../../whatsnew/2.5.rst:2181
msgid ""
"``PyErr_NewException(name, base, dict)`` can now accept a tuple of base "
"classes as its *base* argument.  (Contributed by Georg Brandl.)"
msgstr ""
"``PyErr_NewException(name, base, dict)`` тепер може приймати кортеж базових "
"класів як свій аргумент *base*. (Надав Георг Брандл.)"

#: ../../whatsnew/2.5.rst:2184
msgid ""
"The :c:func:`PyErr_Warn` function for issuing warnings is now deprecated in "
"favour of ``PyErr_WarnEx(category, message, stacklevel)`` which lets you "
"specify the number of stack frames separating this function and the caller."
"  A *stacklevel* of 1 is the function calling :c:func:`PyErr_WarnEx`, 2 is "
"the function above that, and so forth.  (Added by Neal Norwitz.)"
msgstr ""

#: ../../whatsnew/2.5.rst:2190
msgid ""
"The CPython interpreter is still written in C, but  the code can now be "
"compiled with a C++ compiler without errors.   (Implemented by Anthony "
"Baxter, Martin von Löwis, Skip Montanaro.)"
msgstr ""
"Інтерпретатор CPython все ще написаний на C, але тепер код можна "
"скомпілювати за допомогою компілятора C++ без помилок. (Реалізовано Ентоні "
"Бакстером, Мартіном фон Льовісом, Скіпом Монтанаро.)"

#: ../../whatsnew/2.5.rst:2194
msgid ""
"The :c:func:`PyRange_New` function was removed.  It was never documented, "
"never used in the core code, and had dangerously lax error checking.  In the"
" unlikely case that your extensions were using it, you can replace it by "
"something like the following::"
msgstr ""

#: ../../whatsnew/2.5.rst:2208
msgid "Port-Specific Changes"
msgstr "移植专属的改变"

#: ../../whatsnew/2.5.rst:2210
msgid ""
"MacOS X (10.3 and higher): dynamic loading of modules now uses the "
":c:func:`dlopen` function instead of MacOS-specific functions."
msgstr ""
"MacOS X (10.3 及更高版本): 模块的动态加载现在会使用 :c:func:`dlopen` 函数而不是 MacOS 专属的函数。"

#: ../../whatsnew/2.5.rst:2213
msgid ""
"MacOS X: an :option:`!--enable-universalsdk` switch was added to the "
":program:`configure` script that compiles the interpreter as a universal "
"binary able to run on both PowerPC and Intel processors. (Contributed by "
"Ronald Oussoren; :issue:`2573`.)"
msgstr ""
"MacOS X: перемикач :option:`!--enable-universalsdk` додано до сценарію "
":program:`configure`, який компілює інтерпретатор як універсальний двійковий"
" файл, здатний працювати на процесорах PowerPC і Intel. (Надав Рональд "
"Оуссорен; :issue:`2573`.)"

#: ../../whatsnew/2.5.rst:2218
msgid ""
"Windows: :file:`.dll` is no longer supported as a filename extension for "
"extension modules.  :file:`.pyd` is now the only filename extension that "
"will be searched for."
msgstr ""
"Windows: :file:`.dll` більше не підтримується як розширення імені файлу для "
"модулів розширення. :file:`.pyd` тепер є єдиним розширенням імені файлу, яке"
" шукатиметься."

#: ../../whatsnew/2.5.rst:2228
msgid "Porting to Python 2.5"
msgstr "移植到Python 2.5"

#: ../../whatsnew/2.5.rst:2230
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr "本节列出了先前描述的可能需要修改你的代码的改变："

#: ../../whatsnew/2.5.rst:2233
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error."
msgstr ""
"ASCII тепер є стандартним кодуванням для модулів. Тепер це синтаксична "
"помилка, якщо модуль містить рядкові літерали з 8-бітовими символами, але не"
" має оголошення кодування. У Python 2.4 це викликало попередження, а не "
"синтаксичну помилку."

#: ../../whatsnew/2.5.rst:2238
msgid ""
"Previously, the :attr:`gi_frame` attribute of a generator was always a frame"
" object.  Because of the :pep:`342` changes described in section "
":ref:`pep-342`, it's now possible for :attr:`gi_frame` to be ``None``."
msgstr ""
"Раніше атрибут :attr:`gi_frame` генератора завжди був об’єктом фрейму. Через"
" зміни :pep:`342`, описані в розділі :ref:`pep-342`, тепер :attr:`gi_frame` "
"може мати значення ``None``."

#: ../../whatsnew/2.5.rst:2242
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string that can't be converted to "
"Unicode using the default ASCII encoding.  Previously such comparisons would"
" raise a :class:`UnicodeDecodeError` exception."
msgstr ""
"Нове попередження, :class:`UnicodeWarning`, спрацьовує, коли ви намагаєтеся "
"порівняти рядок Unicode з 8-бітним рядком, який не можна перетворити на "
"Unicode за допомогою стандартного кодування ASCII. Раніше такі порівняння "
"викликали виняток :class:`UnicodeDecodeError`."

#: ../../whatsnew/2.5.rst:2247
msgid ""
"Library: the :mod:`csv` module is now stricter about multi-line quoted "
"fields. If your files contain newlines embedded within fields, the input "
"should be split into lines in a manner which preserves the newline "
"characters."
msgstr ""
"Бібліотека: модуль :mod:`csv` тепер суворіше щодо багаторядкових полів у "
"лапках. Якщо ваші файли містять символи нового рядка, вбудовані в поля, "
"вхідні дані слід розділити на рядки таким чином, щоб символи нового рядка "
"зберігалися."

#: ../../whatsnew/2.5.rst:2251
msgid ""
"Library: the :mod:`locale` module's  :func:`format` function's would "
"previously  accept any string as long as no more than one %char specifier "
"appeared.  In Python 2.5, the argument must be exactly one %char specifier "
"with no surrounding text."
msgstr ""
"Бібліотека: функція :func:`format` модуля :mod:`locale` раніше приймала "
"будь-який рядок, якщо з’являлося не більше одного специфікатора %char. У "
"Python 2.5 аргумент має бути точно одним специфікатором %char без "
"навколишнього тексту."

#: ../../whatsnew/2.5.rst:2256
msgid ""
"Library: The :mod:`pickle` and :mod:`cPickle` modules no longer accept a "
"return value of ``None`` from the :meth:`__reduce__` method; the method must"
" return a tuple of arguments instead.  The modules also no longer accept the"
" deprecated *bin* keyword parameter."
msgstr ""

#: ../../whatsnew/2.5.rst:2261
msgid ""
"Library: The :mod:`SimpleXMLRPCServer` and :mod:`DocXMLRPCServer`  classes "
"now have a :attr:`rpc_paths` attribute that constrains XML-RPC operations to"
" a limited set of URL paths; the default is to allow only ``'/'`` and "
"``'/RPC2'``. Setting  :attr:`rpc_paths` to ``None`` or an empty tuple "
"disables  this path checking."
msgstr ""

#: ../../whatsnew/2.5.rst:2267
msgid ""
"C API: Many functions now use :c:type:`Py_ssize_t`  instead of :c:expr:`int`"
" to allow processing more data on 64-bit machines.  Extension code may need "
"to make the same change to avoid warnings and to support 64-bit machines.  "
"See the earlier section :ref:`pep-353` for a discussion of this change."
msgstr ""
"C API: многие функции теперь используют :c:type:`Py_ssize_t` вместо "
":c:expr:`int`, чтобы позволить обрабатывать больше данных на 64-битных "
"машинах. В код расширения может потребоваться внести такие же изменения, "
"чтобы избежать предупреждений и обеспечить поддержку 64-разрядных "
"компьютеров. См. предыдущий раздел :ref:`pep-353` для обсуждения этого "
"изменения."

#: ../../whatsnew/2.5.rst:2272
msgid ""
"C API:  The obmalloc changes mean that  you must be careful to not mix usage"
" of the ``PyMem_*`` and ``PyObject_*`` families of functions. Memory "
"allocated with  one family's ``*_Malloc`` must be  freed with the "
"corresponding family's ``*_Free`` function."
msgstr ""
"C API: Изменения obmalloc означают, что вы должны быть осторожны, чтобы не "
"смешивать использование семейств функций ``PyMem_*`` и `` PyObj ect_*``. "
"Память, выделенная с помощью ``*_Malloc`` одного семейства, должна быть "
"освобождена с помощью функции ``*_Free`` соответствующего семейства."

#: ../../whatsnew/2.5.rst:2281
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.5.rst:2283
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars Gustäbel, Raymond "
"Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain Lowe, Martin von "
"Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, Gustavo Niemeyer, "
"Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, Barry Warsaw, Thomas "
"Wouters."
msgstr ""
"作者感谢以下人员对本文各种草稿给予的建议，更正和协助： Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars"
" Gustäbel, Raymond Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain "
"Lowe, Martin von Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, "
"Gustavo Niemeyer, Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, "
"Barry Warsaw, Thomas Wouters."
