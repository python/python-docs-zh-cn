# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-27 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.5.rst:3
msgid "What's New in Python 2.5"
msgstr "Python 2.5 有什么新变化"

#: ../../whatsnew/2.5.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.5.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.5.rst:12
msgid ""
"This article explains the new features in Python 2.5.  The final release of "
"Python 2.5 is scheduled for August 2006; :pep:`356` describes the planned "
"release schedule.  Python 2.5 was released on September 19, 2006."
msgstr ""
"本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月；:pep:`356` "
"描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。"

#: ../../whatsnew/2.5.rst:16
msgid ""
"The changes in Python 2.5 are an interesting mix of language and library "
"improvements. The library enhancements will be more important to Python's "
"user community, I think, because several widely useful packages were added."
"  New modules include ElementTree for XML processing (:mod:`xml.etree`), the"
" SQLite database module (:mod:`sqlite`), and the :mod:`ctypes` module for "
"calling C functions."
msgstr ""
"Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python "
"的用户社区来说会更重要一些，因为增加了多个被广泛应用的包。 新增模块包括用于 XML 处理的 ElementTree "
"(:mod:`xml.etree`)，SQLite 数据库模块 (:mod:`sqlite`)，以及用于调用 C 函数的 :mod:`ctypes` "
"模块。"

#: ../../whatsnew/2.5.rst:23
msgid ""
"The language changes are of middling significance.  Some pleasant new "
"features were added, but most of them aren't features that you'll use every "
"day. Conditional expressions were finally added to the language using a "
"novel syntax; see section :ref:`pep-308`.  The new ':keyword:`with`' "
"statement will make writing cleanup code easier (section :ref:`pep-343`).  "
"Values can now be passed into generators (section :ref:`pep-342`).  Imports "
"are now visible as either absolute or relative (section :ref:`pep-328`).  "
"Some corner cases of exception handling are handled better (section "
":ref:`pep-341`).  All these improvements are worthwhile, but they're "
"improvements to one specific language feature or another; none of them are "
"broad modifications to Python's semantics."
msgstr ""
"语言变更具有中等重要性。一些令人愉悦的新特性被添加，但其中大部分并非每天都会使用的特性。条件表达式终于被添加到语言中，使用了新颖的语法；参见章节 "
":ref:`pep-308`。新的 ':keyword:`with`' 语句将使编写清理代码变得更加容易（章节 "
":ref:`pep-343`）。现在可以将值传递给生成器（章节 :ref:`pep-342`）。导入现在可以显示为绝对或相对（章节 "
":ref:`pep-328`）。一些异常处理的边缘情况得到了更好的处理（章节 "
":ref:`pep-341`）。所有这些改进都是有价值的，但它们都是对特定语言特性的改进；没有一个是对 Python 语义的广泛修改。"

#: ../../whatsnew/2.5.rst:34
msgid ""
"As well as the language and library additions, other improvements and "
"bugfixes were made throughout the source tree.  A search through the SVN "
"change logs finds there were 353 patches applied and 458 bugs fixed between "
"Python 2.4 and 2.5.  (Both figures are likely to be underestimates.)"
msgstr ""
"除了语言和库的添加之外，整个源代码树中还进行了其他改进和错误修复。通过搜索 SVN 更改日志发现，在 Python 2.4 到 2.5 之间应用了 "
"353 个补丁并修复了 458 个错误。（这两个数字都可能被低估了。）"

#: ../../whatsnew/2.5.rst:39
msgid ""
"This article doesn't try to be a complete specification of the new features;"
" instead changes are briefly introduced using helpful examples.  For full "
"details, you should always refer to the documentation for Python 2.5 at "
"https://docs.python.org. If you want to understand the complete "
"implementation and design rationale, refer to the PEP for a particular new "
"feature."
msgstr ""
"本文并不试图成为新特性的完整规范；相反，通过有用的示例简要介绍了这些变更。有关完整细节，你应始终参考 Python 2.5 的文档，网址为 "
"https://docs.python.org。如果你想了解完整的实现和设计依据，请参考特定新特性的 PEP。"

#: ../../whatsnew/2.5.rst:45
msgid ""
"Comments, suggestions, and error reports for this document are welcome; "
"please e-mail them to the author or open a bug in the Python bug tracker."
msgstr "欢迎对本文档提出评论、建议和错误报告；请通过电子邮件发送给作者或在 Python 错误跟踪器中打开一个错误报告。"

#: ../../whatsnew/2.5.rst:54
msgid "PEP 308: Conditional Expressions"
msgstr "PEP 308: 条件表达式"

#: ../../whatsnew/2.5.rst:56
msgid ""
"For a long time, people have been requesting a way to write conditional "
"expressions, which are expressions that return value A or value B depending "
"on whether a Boolean value is true or false.  A conditional expression lets "
"you write a single assignment statement that has the same effect as the "
"following::"
msgstr ""
"长期以来，人们一直要求提供一种编写条件表达式的方法，这种表达式根据布尔值的真或假返回值 A 或值 "
"B。条件表达式允许你编写一个赋值语句，其效果与以下相同::"

#: ../../whatsnew/2.5.rst:61
msgid ""
"if condition:\n"
"    x = true_value\n"
"else:\n"
"    x = false_value"
msgstr ""
"if condition:\n"
"    x = true_value\n"
"else:\n"
"    x = false_value"

#: ../../whatsnew/2.5.rst:66
msgid ""
"There have been endless tedious discussions of syntax on both python-dev and"
" comp.lang.python.  A vote was even held that found the majority of voters "
"wanted conditional expressions in some form, but there was no syntax that "
"was preferred by a clear majority. Candidates included C's ``cond ? true_v :"
" false_v``, ``if cond then true_v else false_v``, and 16 other variations."
msgstr ""
"在 python-dev 和 comp.lang.python "
"上已经进行了无数冗长的语法讨论。甚至进行了一次投票，发现大多数投票者希望以某种形式引入条件表达式，但没有一种语法得到了明显多数的青睐。候选语法包括C语言的"
" ``cond ? true_v : false_v``，``if cond then true_v else false_v``，以及其他16种变体。"

#: ../../whatsnew/2.5.rst:72
msgid "Guido van Rossum eventually chose a surprising syntax::"
msgstr "Guido van Rossum 最终选择了一种令人惊讶的语法："

#: ../../whatsnew/2.5.rst:74
msgid "x = true_value if condition else false_value"
msgstr "x = true_value if condition else false_value"

#: ../../whatsnew/2.5.rst:76
msgid ""
"Evaluation is still lazy as in existing Boolean expressions, so the order of"
" evaluation jumps around a bit.  The *condition* expression in the middle is"
" evaluated first, and the *true_value* expression is evaluated only if the "
"condition was true.  Similarly, the *false_value* expression is only "
"evaluated when the condition is false."
msgstr ""
"求值过程仍保持与现有布尔表达式相同的惰性特性，因此求值顺序会有所调整。中间的 *condition* 表达式会首先被求值，而 *true_value* "
"表达式仅在条件为真时才会被求值。同理，*false_value* 表达式仅在条件为假时才会被求值。"

#: ../../whatsnew/2.5.rst:82
msgid ""
"This syntax may seem strange and backwards; why does the condition go in the"
" *middle* of the expression, and not in the front as in C's ``c ? x : y``?  "
"The decision was checked by applying the new syntax to the modules in the "
"standard library and seeing how the resulting code read.  In many cases "
"where a conditional expression is used, one value seems to be the 'common "
"case' and one value is an 'exceptional case', used only on rarer occasions "
"when the condition isn't met.  The conditional syntax makes this pattern a "
"bit more obvious::"
msgstr ""
"这种语法可能看起来奇怪且不合常理；为什么条件要放在表达式的 *中间*，而不是像C语言的 ``c ? x : y`` "
"那样放在前面？这一决定是通过将新语法应用于标准库中的模块，并查看生成的代码的可读性来验证的。在许多使用条件表达式的情况下，一个值似乎是“常见情况”，而另一个值是“特殊情况”，仅在条件不满足的罕见情况下使用。条件语法使这种模式更加明显::"

#: ../../whatsnew/2.5.rst:90
msgid "contents = ((doc + '\\n') if doc else '')"
msgstr "contents = ((doc + '\\n') if doc else '')"

#: ../../whatsnew/2.5.rst:92
msgid ""
"I read the above statement as meaning \"here *contents* is  usually assigned"
" a value of ``doc+'\\n'``; sometimes  *doc* is empty, in which special case "
"an empty string is returned.\"   I doubt I will use conditional expressions "
"very often where there  isn't a clear common and uncommon case."
msgstr ""
"我将上述声明理解为“通常 *contents* 被赋值为 ``doc+'\\n'``；有时 *doc* "
"为空，在这种情况下返回空字符串。”我怀疑在不存在明确常见和罕见情况的地方，我很少会使用条件表达式。"

#: ../../whatsnew/2.5.rst:97
msgid ""
"There was some discussion of whether the language should require surrounding"
" conditional expressions with parentheses.  The decision was made to *not* "
"require parentheses in the Python language's grammar, but as a matter of "
"style I think you should always use them. Consider these two statements::"
msgstr ""
"曾经有一些讨论，关于语言是否应该要求在条件表达式周围加上括号。决定是不在Python语言的语法中要求括号，但出于风格考虑，我认为你应该总是使用它们。考虑以下两个语句::"

#: ../../whatsnew/2.5.rst:102
msgid ""
"# First version -- no parens\n"
"level = 1 if logging else 0\n"
"\n"
"# Second version -- with parens\n"
"level = (1 if logging else 0)"
msgstr ""
"# 第一版 -- 无括号\n"
"level = 1 if logging else 0\n"
"\n"
"# 第二版 -- 有括号\n"
"level = (1 if logging else 0)"

#: ../../whatsnew/2.5.rst:108
msgid ""
"In the first version, I think a reader's eye might group the statement into "
"'level = 1', 'if logging', 'else 0', and think that the condition decides "
"whether the assignment to *level* is performed.  The second version reads "
"better, in my opinion, because it makes it clear that the assignment is "
"always performed and the choice is being made between two values."
msgstr ""
"在第一个版本中，我认为读者的视线可能会将语句分组为 'level = 1'、'if logging'、'else 0'，并认为条件决定了是否对 "
"*level* 进行赋值。在我看来，第二个版本读起来更好，因为它清楚地表明赋值总是被执行，选择是在两个值之间进行的。"

#: ../../whatsnew/2.5.rst:114
msgid ""
"Another reason for including the brackets: a few odd combinations of list "
"comprehensions and lambdas could look like incorrect conditional "
"expressions. See :pep:`308` for some examples.  If you put parentheses "
"around your conditional expressions, you won't run into this case."
msgstr ""
"包含括号另一个原因：一些列表推导和lambda函数的奇怪组合可能看起来像错误的条件表达式。参见 :pep:`308` "
"了解一些示例。如果你在条件表达式周围加上括号，就不会遇到这种情况。"

#: ../../whatsnew/2.5.rst:122
msgid ":pep:`308` - Conditional Expressions"
msgstr ":pep:`308` - 条件表达式"

#: ../../whatsnew/2.5.rst:123
msgid ""
"PEP written by Guido van Rossum and Raymond D. Hettinger; implemented by "
"Thomas Wouters."
msgstr "PEP 由 Guido van Rossum 和 Raymond D. Hettinger 撰写，由 Thomas Wouters 实现。"

#: ../../whatsnew/2.5.rst:132
msgid "PEP 309: Partial Function Application"
msgstr "PEP 309: 部分函数应用"

#: ../../whatsnew/2.5.rst:134
msgid ""
"The :mod:`functools` module is intended to contain tools for functional-"
"style programming."
msgstr ":mod:`functools` 模块旨在包含用于函数式编程风格的工具。"

#: ../../whatsnew/2.5.rst:137
msgid ""
"One useful tool in this module is the :func:`partial` function. For programs"
" written in a functional style, you'll sometimes want to construct variants "
"of existing functions that have some of the parameters filled in.  Consider "
"a Python function ``f(a, b, c)``; you could create a new function ``g(b, "
"c)`` that was equivalent to ``f(1, b, c)``.  This is called \"partial "
"function application\"."
msgstr ""
"这个模块中的一个有用工具是 :func:`partial` "
"函数。对于用函数式风格编写的程序，有时你会想构造一些已有函数的变体，其中部分参数已被填充。考虑一个Python函数 ``f(a, b, "
"c)``；你可以创建一个新函数 ``g(b, c)``，它等同于 ``f(1, b, c)``。这称为“部分函数应用”。"

#: ../../whatsnew/2.5.rst:144
msgid ""
":func:`partial` takes the arguments ``(function, arg1, arg2, ... "
"kwarg1=value1, kwarg2=value2)``.  The resulting object is callable, so you "
"can just call it to invoke *function* with the filled-in arguments."
msgstr ""
":func:`partial` 接受参数 ``(function, arg1, arg2, ... kwarg1=value1, "
"kwarg2=value2)``。生成的对象是可调用的，因此你可以直接调用它以使用填充的参数来调用 *function*。"

#: ../../whatsnew/2.5.rst:148
msgid "Here's a small but realistic example::"
msgstr "这里有一个很小但很现实的例子::"

#: ../../whatsnew/2.5.rst:150
msgid ""
"import functools\n"
"\n"
"def log (message, subsystem):\n"
"    \"Write the contents of 'message' to the specified subsystem.\"\n"
"    print '%s: %s' % (subsystem, message)\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""
"import functools\n"
"\n"
"def log (message, subsystem):\n"
"    \"将 'message' 的内容写到指定的子系统。\"\n"
"    print '%s: %s' % (subsystem, message)\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('不能打开套接字')"

#: ../../whatsnew/2.5.rst:160
msgid ""
"Here's another example, from a program that uses PyGTK.  Here a context-"
"sensitive pop-up menu is being constructed dynamically.  The callback "
"provided for the menu option is a partially applied version of the "
":meth:`open_item` method, where the first argument has been provided. ::"
msgstr ""
"这里再举一个例子，来自一个使用PyGTK的程序。这里动态构建了一个上下文敏感的弹出菜单。为菜单选项提供的回调是一个部分应用的 "
":meth:`open_item` 方法版本，其中第一个参数已提供。 ::"

#: ../../whatsnew/2.5.rst:165
msgid ""
"...\n"
"class Application:\n"
"    def open_item(self, path):\n"
"       ...\n"
"    def init (self):\n"
"        open_func = functools.partial(self.open_item, item_path)\n"
"        popup_menu.append( (\"Open\", open_func, 1) )"
msgstr ""
"...\n"
"class Application:\n"
"    def open_item(self, path):\n"
"       ...\n"
"    def init (self):\n"
"        open_func = functools.partial(self.open_item, item_path)\n"
"        popup_menu.append( (\"Open\", open_func, 1) )"

#: ../../whatsnew/2.5.rst:173
msgid ""
"Another function in the :mod:`functools` module is the "
"``update_wrapper(wrapper, wrapped)`` function that helps you write well-"
"behaved decorators.  :func:`update_wrapper` copies the name, module, and "
"docstring attribute to a wrapper function so that tracebacks inside the "
"wrapped function are easier to understand.  For example, you might write::"
msgstr ""
"在 :mod:`functools` 模块中的另一个函数是 ``update_wrapper(wrapper, wrapped)`` "
"函数，它可以帮助你编写行为良好的装饰器。:func:`update_wrapper` "
"将名称、模块和文档字符串属性复制到包装函数中，以便更容易理解包装函数内的追踪信息。例如，你可以这样写::"

#: ../../whatsnew/2.5.rst:179
msgid ""
"def my_decorator(f):\n"
"    def wrapper(*args, **kwds):\n"
"        print 'Calling decorated function'\n"
"        return f(*args, **kwds)\n"
"    functools.update_wrapper(wrapper, f)\n"
"    return wrapper"
msgstr ""
"def my_decorator(f):\n"
"    def wrapper(*args, **kwds):\n"
"        print 'Calling decorated function'\n"
"        return f(*args, **kwds)\n"
"    functools.update_wrapper(wrapper, f)\n"
"    return wrapper"

#: ../../whatsnew/2.5.rst:186
msgid ""
":func:`wraps` is a decorator that can be used inside your own decorators to "
"copy the wrapped function's information.  An alternate  version of the "
"previous example would be::"
msgstr ":func:`wraps` 是一个装饰器，可以在你自己的装饰器中使用，以复制被包装函数的信息。前一个示例的另一种版本是::"

#: ../../whatsnew/2.5.rst:190
msgid ""
"def my_decorator(f):\n"
"    @functools.wraps(f)\n"
"    def wrapper(*args, **kwds):\n"
"        print 'Calling decorated function'\n"
"        return f(*args, **kwds)\n"
"    return wrapper"
msgstr ""
"def my_decorator(f):\n"
"    @functools.wraps(f)\n"
"    def wrapper(*args, **kwds):\n"
"        print 'Calling decorated function'\n"
"        return f(*args, **kwds)\n"
"    return wrapper"

#: ../../whatsnew/2.5.rst:200
msgid ":pep:`309` - Partial Function Application"
msgstr ":pep:`309` - 部分函数应用"

#: ../../whatsnew/2.5.rst:201
msgid ""
"PEP proposed and written by Peter Harris; implemented by Hye-Shik Chang and "
"Nick Coghlan, with adaptations by Raymond Hettinger."
msgstr ""
"PEP由 Peter Harris 提出并撰写；由 Hye-Shik Chang 和 Nick Coghlan 实现，并由 Raymond "
"Hettinger 适配。"

#: ../../whatsnew/2.5.rst:210
msgid "PEP 314: Metadata for Python Software Packages v1.1"
msgstr "PEP 314: Python软件包的元数据 v1.1"

#: ../../whatsnew/2.5.rst:212
msgid ""
"Some simple dependency support was added to Distutils.  The :func:`setup` "
"function now has ``requires``, ``provides``, and ``obsoletes`` keyword "
"parameters.  When you build a source distribution using the ``sdist`` "
"command, the dependency information will be recorded in the :file:`PKG-INFO`"
" file."
msgstr ""
"Distutils 中添加了一些简单的依赖支持。:func:`setup` 函数现在有了 ``requires``、``provides`` 和 "
"``obsoletes`` 关键字参数。当你使用 ``sdist`` 命令构建源代码分发时，依赖信息将被记录在 :file:`PKG-INFO` "
"文件中。"

#: ../../whatsnew/2.5.rst:217
msgid ""
"Another new keyword parameter is ``download_url``, which should be set to a "
"URL for the package's source code.  This means it's now possible to look up "
"an entry in the package index, determine the dependencies for a package, and"
" download the required packages. ::"
msgstr ""
"另一个新的关键字形参是 ``download_url``，它应该被设置为包源代码的 "
"URL。这意味着现在可以查找包索引中的条目，确定包的依赖项，并下载所需的包。::"

#: ../../whatsnew/2.5.rst:222
msgid ""
"VERSION = '1.0'\n"
"setup(name='PyPackage',\n"
"      version=VERSION,\n"
"      requires=['numarray', 'zlib (>=1.1.4)'],\n"
"      obsoletes=['OldPackage']\n"
"      download_url=('http://www.example.com/pypackage/dist/pkg-%s.tar.gz'\n"
"                    % VERSION),\n"
"     )"
msgstr ""
"VERSION = '1.0'\n"
"setup(name='PyPackage',\n"
"      version=VERSION,\n"
"      requires=['numarray', 'zlib (>=1.1.4)'],\n"
"      obsoletes=['OldPackage']\n"
"      download_url=('http://www.example.com/pypackage/dist/pkg-%s.tar.gz'\n"
"                    % VERSION),\n"
"     )"

#: ../../whatsnew/2.5.rst:231
msgid ""
"Another new enhancement to the Python package index at https://pypi.org is "
"storing source and binary archives for a package.  The new :command:`upload`"
" Distutils command will upload a package to the repository."
msgstr ""
"Python 包索引 https://pypi.org 的另一个新增强功能是存储包的源代码和二进制归档。新的 :command:`upload` "
"Distutils 命令将上传包到仓库。"

#: ../../whatsnew/2.5.rst:236
msgid ""
"Before a package can be uploaded, you must be able to build a distribution "
"using the :command:`sdist` Distutils command.  Once that works, you can run "
"``python setup.py upload`` to add your package to the PyPI archive.  "
"Optionally you can GPG-sign the package by supplying the :option:`!--sign` "
"and :option:`!--identity` options."
msgstr ""
"在上传包之前，你必须能够使用 :command:`sdist` Distutils 命令构建分发。一旦这个工作完成，你可以运行 ``python "
"setup.py upload`` 将你的包添加到 PyPI 归档中。可选地，你可以通过提供 :option:`!--sign` 和 "
":option:`!--identity` 选项来对包进行 GPG 签名。"

#: ../../whatsnew/2.5.rst:242
msgid ""
"Package uploading was implemented by Martin von Löwis and Richard Jones."
msgstr "包上传操作由 Martin von Löwis 和 Richard Jones 实现。"

#: ../../whatsnew/2.5.rst:247
msgid ":pep:`314` - Metadata for Python Software Packages v1.1"
msgstr ":pep:`314` - Python软件包的元数据 v1.1"

#: ../../whatsnew/2.5.rst:248
msgid ""
"PEP proposed and written by A.M. Kuchling, Richard Jones, and Fred Drake; "
"implemented by Richard Jones and Fred Drake."
msgstr ""
"PEP 由 A.M. Kuchling、 Richard Jones 和 Fred Drake 提出并撰写，由 Richard Jones 和 Fred"
" Drake 实现。"

#: ../../whatsnew/2.5.rst:257
msgid "PEP 328: Absolute and Relative Imports"
msgstr "PEP 328: 绝对导入和相对导入"

#: ../../whatsnew/2.5.rst:259
msgid ""
"The simpler part of :pep:`328` was implemented in Python 2.4: parentheses "
"could now be used to enclose the names imported from a module using the "
"``from ... import ...`` statement, making it easier to import many different"
" names."
msgstr ""
":pep:`328` 的较简单部分已在 Python 2.4 中实现：现在可以用圆括号将使用 ``from ... import ...`` "
"语句导入的名称括起来，以便能够更容易地导入大量不同的名称。"

#: ../../whatsnew/2.5.rst:263
msgid ""
"The more complicated part has been implemented in Python 2.5: importing a "
"module can be specified to use absolute or package-relative imports.  The "
"plan is to move toward making absolute imports the default in future "
"versions of Python."
msgstr ""
"更复杂的部分已在 Python 2.5 中实现：可以指定使用绝对的或相对于包的导入方式来导入模块。 计划在未来的 Python "
"版本中将绝对导入方式设为默认。"

#: ../../whatsnew/2.5.rst:267
msgid "Let's say you have a package directory like this::"
msgstr "比如说你有这样一个包目录::"

#: ../../whatsnew/2.5.rst:269
msgid ""
"pkg/\n"
"pkg/__init__.py\n"
"pkg/main.py\n"
"pkg/string.py"
msgstr ""
"pkg/\n"
"pkg/__init__.py\n"
"pkg/main.py\n"
"pkg/string.py"

#: ../../whatsnew/2.5.rst:274
msgid ""
"This defines a package named :mod:`pkg` containing the :mod:`pkg.main` and "
":mod:`pkg.string` submodules."
msgstr "这定义了一个名为 :mod:`pkg` 的包，其中包含 :mod:`pkg.main` 和 :mod:`pkg.string` 子模块。"

#: ../../whatsnew/2.5.rst:277
msgid ""
"Consider the code in the :file:`main.py` module.  What happens if it "
"executes the statement ``import string``?  In Python 2.4 and earlier, it "
"will first look in the package's directory to perform a relative import, "
"finds :file:`pkg/string.py`, imports the contents of that file as the "
":mod:`pkg.string` module, and that module is bound to the name ``string`` in"
" the :mod:`pkg.main` module's namespace."
msgstr ""
"考虑 :file:`main.py` 模块中的代码。如果它执行了语句 ``import string`` 会发生什么？在 Python 2.4 "
"及更早版本中，它首先会在包的目录中查找以进行相对导入，找到 :file:`pkg/string.py`，将该文件的内容导入为 "
":mod:`pkg.string` 模块，并将该模块绑定到 :mod:`pkg.main` 模块命名空间中的名称 ``string``。"

#: ../../whatsnew/2.5.rst:284
msgid ""
"That's fine if :mod:`pkg.string` was what you wanted.  But what if you "
"wanted Python's standard :mod:`string` module?  There's no clean way to "
"ignore :mod:`pkg.string` and look for the standard module; generally you had"
" to look at the contents of ``sys.modules``, which is slightly unclean.    "
"Holger Krekel's :mod:`py.std` package provides a tidier way to perform "
"imports from the standard library, ``import py; py.std.string.join()``, but "
"that package isn't available on all Python installations."
msgstr ""
"如果这正是你想要的 :mod:`pkg.string` 模块，那自然没问题。但如果你实际需要的是 Python 标准库中的 :mod:`string` "
"模块呢？目前没有优雅的方式可以忽略 :mod:`pkg.string` 而直接查找标准模块——通常你不得不检查 ``sys.modules`` "
"的内容，这种做法稍显不够优雅。Holger Krekel 开发的 :mod:`py.std` 包提供了一种更整洁的标准库导入方式：``import "
"py; py.std.string.join()``，但该包并非所有 Python 环境都默认安装。"

#: ../../whatsnew/2.5.rst:292
msgid ""
"Reading code which relies on relative imports is also less clear, because a "
"reader may be confused about which module, :mod:`string` or "
":mod:`pkg.string`, is intended to be used.  Python users soon learned not to"
" duplicate the names of standard library modules in the names of their "
"packages' submodules, but you can't protect against having your submodule's "
"name being used for a new module added in a future version of Python."
msgstr ""
"阅读依赖相对导入的代码时清晰度也会降低，因为读者可能会困惑于实际使用的是哪个模块——是 :mod:`string` 还是 "
":mod:`pkg.string`。Python 用户很快意识到不应在包的子模块命名时重复标准库模块的名称，但你无法避免未来 Python "
"版本新增模块时恰好与你的子模块同名。"

#: ../../whatsnew/2.5.rst:299
msgid ""
"In Python 2.5, you can switch :keyword:`import`'s behaviour to  absolute "
"imports using a ``from __future__ import absolute_import`` directive.  This "
"absolute-import behaviour will become the default in a future version "
"(probably Python 2.7).  Once absolute imports  are the default, ``import "
"string`` will always find the standard library's version. It's suggested "
"that users should begin using absolute imports as much as possible, so it's "
"preferable to begin writing ``from pkg import string`` in your code."
msgstr ""
"在 Python 2.5 中，你可以通过使用 ``from __future__ import absolute_import`` 指令将 "
":keyword:`import` 的行为切换为绝对导入。这种绝对导入行为将在未来版本（可能是 Python "
"2.7）中成为默认行为。一旦绝对导入成为默认行为，``import string`` "
"将始终找到标准库的版本。建议用户尽可能开始使用绝对导入，因此最好在代码中开始写 ``from pkg import string``。"

#: ../../whatsnew/2.5.rst:307
msgid ""
"Relative imports are still possible by adding a leading period  to the "
"module name when using the ``from ... import`` form::"
msgstr "通过在使用 ``from ... import`` 形式时在模块名称前添加一个前导句点，仍然可以进行相对导入："

#: ../../whatsnew/2.5.rst:310
msgid ""
"# Import names from pkg.string\n"
"from .string import name1, name2\n"
"# Import pkg.string\n"
"from . import string"
msgstr ""
"# 从 pkg.string 导入名称\n"
"from .string import name1, name2\n"
"# 导入 pkg.string\n"
"from . import string"

#: ../../whatsnew/2.5.rst:315
msgid ""
"This imports the :mod:`string` module relative to the current package, so in"
" :mod:`pkg.main` this will import *name1* and *name2* from "
":mod:`pkg.string`. Additional leading periods perform the relative import "
"starting from the parent of the current package.  For example, code in the "
":mod:`A.B.C` module can do::"
msgstr ""
"这会相对当前包导入 :mod:`string` 模块，所以在 :mod:`pkg.main` 中这将导入 *name1* 和 *name2* 来自 "
":mod:`pkg.string`。额外的前置点号从当前包的父包开始执行相对导入。例如，在 :mod:`A.B.C` 模块中的代码可以这样做::"

#: ../../whatsnew/2.5.rst:320
msgid ""
"from . import D                 # Imports A.B.D\n"
"from .. import E                # Imports A.E\n"
"from ..F import G               # Imports A.F.G"
msgstr ""
"from . import D                 # 导入 A.B.D\n"
"from .. import E                # 导入 A.E\n"
"from ..F import G               # 导入 A.F.G"

#: ../../whatsnew/2.5.rst:324
msgid ""
"Leading periods cannot be used with the ``import modname``  form of the "
"import statement, only the ``from ... import`` form."
msgstr ""
"开头的句点不可用于 import 语句的 ``import modname`` 形式，只能用于 ``from ... import`` 形式。"

#: ../../whatsnew/2.5.rst:330
msgid ":pep:`328` - Imports: Multi-Line and Absolute/Relative"
msgstr ":pep:`328` - 导入：多行和绝对/相对导入"

#: ../../whatsnew/2.5.rst:331
msgid "PEP written by Aahz; implemented by Thomas Wouters."
msgstr "PEP 由 Aahz 撰写，由 Thomas Wouters 实现。"

#: ../../whatsnew/2.5.rst:333
msgid "https://pylib.readthedocs.io/"
msgstr "https://pylib.readthedocs.io/"

#: ../../whatsnew/2.5.rst:334
msgid ""
"The py library by Holger Krekel, which contains the :mod:`py.std` package."
msgstr "由 Holger Krekel 编写 py 库，其中包含 :mod:`py.std` 包。"

#: ../../whatsnew/2.5.rst:342
msgid "PEP 338: Executing Modules as Scripts"
msgstr "PEP 338: 将模块作为脚本执行"

#: ../../whatsnew/2.5.rst:344
msgid ""
"The :option:`-m` switch added in Python 2.4 to execute a module as a script "
"gained a few more abilities.  Instead of being implemented in C code inside "
"the Python interpreter, the switch now uses an implementation in a new "
"module, :mod:`runpy`."
msgstr ""
"Python 2.4 中添加的 :option:`-m` 开关用于将模块作为脚本执行，获得了一些新能力。该开关现在不再使用 Python 解释器内部的 "
"C 代码实现，而是使用一个新模块 :mod:`runpy` 中的实现。"

#: ../../whatsnew/2.5.rst:349
msgid ""
"The :mod:`runpy` module implements a more sophisticated import mechanism so "
"that it's now possible to run modules in a package such as "
":mod:`pychecker.checker`. The module also supports alternative import "
"mechanisms such as the :mod:`zipimport` module.  This means you can add a "
".zip archive's path to ``sys.path`` and then use the :option:`-m` switch to "
"execute code from the archive."
msgstr ""
":mod:`runpy` 模块实现了一个更复杂的导入机制，因此现在可以运行包中的模块，例如 "
":mod:`pychecker.checker`。该模块还支持其他导入机制，例如 :mod:`zipimport` 模块。这意味着你可以将 .zip "
"归档的路径添加到 ``sys.path`` 中，然后使用 :option:`-m` 开关来执行归档中的代码。"

#: ../../whatsnew/2.5.rst:359
msgid ":pep:`338` - Executing modules as scripts"
msgstr ":pep:`338` - 将模块作为脚本执行"

#: ../../whatsnew/2.5.rst:360
msgid "PEP written and  implemented by Nick Coghlan."
msgstr "PEP 由 Nick Coghlan 撰写并实现。"

#: ../../whatsnew/2.5.rst:368
msgid "PEP 341: Unified try/except/finally"
msgstr "PEP 341: 统一 try/except/finally"

#: ../../whatsnew/2.5.rst:370
msgid ""
"Until Python 2.5, the :keyword:`try` statement came in two flavours. You "
"could use a :keyword:`finally` block to ensure that code is always executed,"
" or one or more :keyword:`except` blocks to catch  specific exceptions.  You"
" couldn't combine both :keyword:`!except` blocks and a :keyword:`!finally` "
"block, because generating the right bytecode for the combined version was "
"complicated and it wasn't clear what the semantics of the combined statement"
" should be."
msgstr ""
"直到 Python 2.5，:keyword:`try` 语句有两种形式。你可以使用 :keyword:`finally` "
"块来确保代码总是被执行，或者使用一个或多个 :keyword:`except` 块来捕获特定异常。你不能同时组合 :keyword:`!except` "
"块和 :keyword:`!finally` 块，因为生成正确字节码的组合版本很复杂，而且不清楚组合语句的语义应该是什么。"

#: ../../whatsnew/2.5.rst:377
msgid ""
"Guido van Rossum spent some time working with Java, which does support the "
"equivalent of combining :keyword:`except` blocks and a :keyword:`finally` "
"block, and this clarified what the statement should mean.  In Python 2.5, "
"you can now write::"
msgstr ""
"Guido van Rossum 花了一些时间研究 Java，Java 支持相当于组合 :keyword:`except` 块和 "
":keyword:`finally` 块的功能，这澄清了该语句应该是什么意思。在 Python 2.5 中，你现在可以写::"

#: ../../whatsnew/2.5.rst:382
msgid ""
"try:\n"
"    block-1 ...\n"
"except Exception1:\n"
"    handler-1 ...\n"
"except Exception2:\n"
"    handler-2 ...\n"
"else:\n"
"    else-block\n"
"finally:\n"
"    final-block"
msgstr ""
"try:\n"
"    block-1 ...\n"
"except Exception1:\n"
"    handler-1 ...\n"
"except Exception2:\n"
"    handler-2 ...\n"
"else:\n"
"    else-block\n"
"finally:\n"
"    final-block"

#: ../../whatsnew/2.5.rst:393
msgid ""
"The code in *block-1* is executed.  If the code raises an exception, the "
"various :keyword:`except` blocks are tested: if the exception is of class "
":class:`Exception1`, *handler-1* is executed; otherwise if it's of class "
":class:`Exception2`, *handler-2* is executed, and so forth.  If no exception"
" is raised, the *else-block* is executed."
msgstr ""
"执行 *block-1* 中的代码。如果代码引发异常，将测试各种 :keyword:`except` 块：如果异常属于 "
":class:`Exception1` 类，则执行 *handler-1*；否则，如果它属于 :class:`Exception2` 类，则执行 "
"*handler-2*，依此类推。如果没有引发异常，则执行 *else-block*。"

#: ../../whatsnew/2.5.rst:399
msgid ""
"No matter what happened previously, the *final-block* is executed once the "
"code block is complete and any raised exceptions handled. Even if there's an"
" error in an exception handler or the *else-block* and a new exception is "
"raised, the code in the *final-block* is still run."
msgstr ""
"无论之前发生了什么，一旦代码块完成并且处理了任何引发的异常，*final-block* 都会被执行一次。即使异常处理程序或 *else-block* "
"中出现错误并引发了新的异常，*final-block* 中的代码仍然会运行。"

#: ../../whatsnew/2.5.rst:407
msgid ":pep:`341` - Unifying try-except and try-finally"
msgstr ":pep:`341` - 统一 try-except 和 try-finally"

#: ../../whatsnew/2.5.rst:408
msgid "PEP written by Georg Brandl;  implementation by Thomas Lee."
msgstr "PEP 由 Georg Brandl 撰写，由 Thomas Lee 实现。"

#: ../../whatsnew/2.5.rst:416
msgid "PEP 342: New Generator Features"
msgstr "PEP 342: 生成器的新特性"

#: ../../whatsnew/2.5.rst:418
msgid ""
"Python 2.5 adds a simple way to pass values *into* a generator. As "
"introduced in Python 2.3, generators only produce output; once a generator's"
" code was invoked to create an iterator, there was no way to pass any new "
"information into the function when its execution is resumed.  Sometimes the "
"ability to pass in some information would be useful.  Hackish solutions to "
"this include making the generator's code look at a global variable and then "
"changing the global variable's value, or passing in some mutable object that"
" callers then modify."
msgstr ""
"Python 2.5 添加了一种简单的方法来将值 *传入* 生成器。如 Python 2.3 "
"中所引入的，生成器仅产生输出；一旦生成器的代码被调用以创建迭代器，当其执行恢复时，无法将任何新信息传入函数。有时能够传入一些信息会很有用。对此的权宜之计包括让生成器的代码查看全局变量，然后更改全局变量的值，或者传入一些可变对象，然后调用者修改它。"

#: ../../whatsnew/2.5.rst:426
msgid "To refresh your memory of basic generators, here's a simple example::"
msgstr "为了刷新你对基本生成器的记忆，这里有一个简单的示例："

#: ../../whatsnew/2.5.rst:428
msgid ""
"def counter (maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        yield i\n"
"        i += 1"
msgstr ""
"def counter (maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        yield i\n"
"        i += 1"

#: ../../whatsnew/2.5.rst:434
msgid ""
"When you call ``counter(10)``, the result is an iterator that returns the "
"values from 0 up to 9.  On encountering the :keyword:`yield` statement, the "
"iterator returns the provided value and suspends the function's execution, "
"preserving the local variables. Execution resumes on the following call to "
"the iterator's :meth:`next` method, picking up after the :keyword:`!yield` "
"statement."
msgstr ""
"当你调用 ``counter(10)`` 时，结果是返回从 0 到 9 的值的迭代器。在遇到 :keyword:`yield` "
"语句时，迭代器返回提供的值并挂起函数的执行，保留局部变量。执行在下次调用迭代器的 :meth:`next` 方法时恢复，从 "
":keyword:`!yield` 语句之后开始。"

#: ../../whatsnew/2.5.rst:440
msgid ""
"In Python 2.3, :keyword:`yield` was a statement; it didn't return any value."
"  In 2.5, :keyword:`!yield` is now an expression, returning a value that can"
" be assigned to a variable or otherwise operated on::"
msgstr ""
"在 Python 2.3 中，:keyword:`yield` 是一个语句；它不返回任何值。在 2.5 中，:keyword:`!yield` "
"现在是一个表达式，返回一个可以赋值给变量或进行其他操作的值："

#: ../../whatsnew/2.5.rst:444
msgid "val = (yield i)"
msgstr "val = (yield i)"

#: ../../whatsnew/2.5.rst:446
msgid ""
"I recommend that you always put parentheses around a :keyword:`yield` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"我建议在处理返回值时，始终在 :keyword:`yield` "
"表达式周围加上括号，如上例所示。虽然括号并非总是必要，但总是添加它们比记住何时需要它们更容易。"

#: ../../whatsnew/2.5.rst:451
msgid ""
"(:pep:`342` explains the exact rules, which are that a :keyword:`yield`\\ "
"-expression must always be parenthesized except when it occurs at the top-"
"level expression on the right-hand side of an assignment.  This means you "
"can write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 解释了确切规则，即 :keyword:`yield`\\ "
"-表达式必须始终加括号，除非它出现在赋值右侧的顶层表达式。这意味着你可以写 ``val = yield i``，但在有操作时必须使用括号，如 ``val"
" = (yield i) + 12``。）"

#: ../../whatsnew/2.5.rst:458
msgid ""
"Values are sent into a generator by calling its ``send(value)`` method.  The"
" generator's code is then resumed and the :keyword:`yield` expression "
"returns the specified *value*.  If the regular :meth:`next` method is "
"called, the :keyword:`!yield` returns :const:`None`."
msgstr ""
"通过调用生成器的 ``send(value)`` 方法，可以将值发送到生成器中。然后生成器的代码会继续执行，:keyword:`yield` "
"表达式返回指定的 *value*。如果调用常规的 :meth:`next` 方法，:keyword:`!yield` 返回 :const:`None`。"

#: ../../whatsnew/2.5.rst:463
msgid ""
"Here's the previous example, modified to allow changing the value of the "
"internal counter. ::"
msgstr "以下是修改后的示例，允许更改内部计数器的值。 ::"

#: ../../whatsnew/2.5.rst:466
msgid ""
"def counter (maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""
"def counter (maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # 如果提供了值，更改计数器\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"

#: ../../whatsnew/2.5.rst:476
msgid "And here's an example of changing the counter::"
msgstr "以下是更改计数器的示例::"

#: ../../whatsnew/2.5.rst:478
msgid ""
">>> it = counter(10)\n"
">>> print it.next()\n"
"0\n"
">>> print it.next()\n"
"1\n"
">>> print it.send(8)\n"
"8\n"
">>> print it.next()\n"
"9\n"
">>> print it.next()\n"
"Traceback (most recent call last):\n"
"  File \"t.py\", line 15, in ?\n"
"    print it.next()\n"
"StopIteration"
msgstr ""
">>> it = counter(10)\n"
">>> print it.next()\n"
"0\n"
">>> print it.next()\n"
"1\n"
">>> print it.send(8)\n"
"8\n"
">>> print it.next()\n"
"9\n"
">>> print it.next()\n"
"Traceback (most recent call last):\n"
"  File \"t.py\", line 15, in ?\n"
"    print it.next()\n"
"StopIteration"

#: ../../whatsnew/2.5.rst:493
msgid ""
":keyword:`yield` will usually return :const:`None`, so you should always "
"check for this case.  Don't just use its value in expressions unless you're "
"sure that the :meth:`send` method will be the only method used to resume "
"your generator function."
msgstr ""
":keyword:`yield` 通常会返回 :const:`None`，因此你应该始终检查这种情况。不要仅在表达式中使用它的值，除非你确定 "
":meth:`send` 方法将是唯一用于恢复生成器函数的方法。"

#: ../../whatsnew/2.5.rst:498
msgid ""
"In addition to :meth:`send`, there are two other new methods on generators:"
msgstr "除了 :meth:`send` 之外，生成器上还有两个新方法："

#: ../../whatsnew/2.5.rst:500
msgid ""
"``throw(type, value=None, traceback=None)`` is used to raise an exception "
"inside the generator; the exception is raised by the :keyword:`yield` "
"expression where the generator's execution is paused."
msgstr ""
"``throw(type, value=None, traceback=None)`` 用于在生成器内部引发异常；异常由 "
":keyword:`yield` 表达式在生成器执行暂停处引发。"

#: ../../whatsnew/2.5.rst:504
msgid ""
":meth:`close` raises a new :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`.  Catching the :exc:`GeneratorExit` exception and "
"returning a value is illegal and will trigger a :exc:`RuntimeError`; if the "
"function raises some other exception, that exception is propagated to the "
"caller.  :meth:`close` will also be called by Python's garbage collector "
"when the generator is garbage-collected."
msgstr ""
":meth:`close` 在生成器内部引发一个新的 :exc:`GeneratorExit` "
"异常以终止迭代。在接收到此异常时，生成器的代码必须要么引发 :exc:`GeneratorExit`，要么引发 "
":exc:`StopIteration`。捕获 :exc:`GeneratorExit` 异常并返回一个值是非法的，将会触发一个 "
":exc:`RuntimeError`；如果函数引发其他异常，该异常会传播给调用者。:meth:`close` 也会在生成器被垃圾回收时由 Python"
" 的垃圾回收器调用。"

#: ../../whatsnew/2.5.rst:512
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of  catching "
":exc:`GeneratorExit`."
msgstr ""
"如果你需要在 :exc:`GeneratorExit` 发生的时候运行清理代码，我建议使用 ``try: ... finally:`` 组合来代替捕获 "
":exc:`GeneratorExit`。"

#: ../../whatsnew/2.5.rst:515
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "这些改变的累积效应是，让生成器从单向的信息生产者变成了既是生产者，又是消费者。"

#: ../../whatsnew/2.5.rst:518
msgid ""
"Generators also become *coroutines*, a more generalized form of subroutines."
" Subroutines are entered at one point and exited at another point (the top "
"of the function, and a :keyword:`return` statement), but coroutines can be "
"entered, exited, and resumed at many different points (the :keyword:`yield` "
"statements). We'll have to figure out patterns for using coroutines "
"effectively in Python."
msgstr ""
"生成器还可以成为 *协程*，这是子例程的一种更通用的形式。子例程在一点进入，在另一点退出（函数顶部和 :keyword:`return` "
"语句），但协程可以在多个不同的点进入、退出和恢复（:keyword:`yield` 语句）。我们需要找出在 Python 中有效使用协程的模式。"

#: ../../whatsnew/2.5.rst:524
msgid ""
"The addition of the :meth:`close` method has one side effect that isn't "
"obvious. :meth:`close` is called when a generator is garbage-collected, so "
"this means the generator's code gets one last chance to run before the "
"generator is destroyed. This last chance means that ``try...finally`` "
"statements in generators can now be guaranteed to work; the "
":keyword:`finally` clause will now always get a chance to run.  The "
"syntactic restriction that you couldn't mix :keyword:`yield` statements with"
" a ``try...finally`` suite has therefore been removed.  This seems like a "
"minor bit of language trivia, but using generators and ``try...finally`` is "
"actually necessary in order to implement the :keyword:`with` statement "
"described by :pep:`343`.  I'll look at this new statement in the following  "
"section."
msgstr ""
"添加 :meth:`close` 方法有一个不明显的影响。:meth:`close` "
"在生成器被垃圾回收时调用，这意味着生成器的代码在生成器被销毁前有最后一次运行的机会。这最后一次机会意味着生成器中的 ``try...finally`` "
"语句现在可以保证工作；:keyword:`finally` 子句现在总是会得到运行的机会。因此，之前不能将 :keyword:`yield` 语句与 "
"``try...finally`` 套件混合使用的语法限制已经被移除。这看似是语言的小细节，但实际上使用生成器和 ``try...finally`` "
"对于实现 :pep:`343` 描述的 :keyword:`with` 语句是必要的。我将在下一节中探讨这个新语句。"

#: ../../whatsnew/2.5.rst:536
msgid ""
"Another even more esoteric effect of this change: previously, the "
":attr:`gi_frame` attribute of a generator was always a frame object. It's "
"now possible for :attr:`gi_frame` to be ``None`` once the generator has been"
" exhausted."
msgstr ""
"这一变化的另一个更玄妙的影响：之前，生成器的 :attr:`gi_frame` 属性总是一个帧对象。现在，生成器耗尽后，:attr:`gi_frame`"
" 有可能为 ``None``。"

#: ../../whatsnew/2.5.rst:544
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 通过增强型生成器实现协程"

#: ../../whatsnew/2.5.rst:545
msgid ""
"PEP written by  Guido van Rossum and Phillip J. Eby; implemented by Phillip "
"J. Eby.  Includes examples of  some fancier uses of generators as "
"coroutines."
msgstr ""
"PEP 由 Guido van Rossum 和 Phillip J. Eby 撰写，由 Phillip J. Eby "
"实现。包括一些更高级的使用生成器作为协程的示例。"

#: ../../whatsnew/2.5.rst:548
msgid ""
"Earlier versions of these features were proposed in  :pep:`288` by Raymond "
"Hettinger and :pep:`325` by Samuele Pedroni."
msgstr ""
"这些功能的早期版本在 :pep:`288` （由 Raymond Hettinger 撰写） 和 :pep:`325` （由 Samuele "
"Pedroni 撰写）中提出。"

#: ../../whatsnew/2.5.rst:551
msgid "https://en.wikipedia.org/wiki/Coroutine"
msgstr "https://en.wikipedia.org/wiki/Coroutine"

#: ../../whatsnew/2.5.rst:552
msgid "The Wikipedia entry for  coroutines."
msgstr "协程的Wikipedia条目。"

#: ../../whatsnew/2.5.rst:554
msgid ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html"
msgstr ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html"

#: ../../whatsnew/2.5.rst:555
msgid ""
"An explanation of coroutines from a Perl point of view, written by Dan "
"Sugalski."
msgstr "基于 Perl 视角对协程的介绍，由 Dan Sugalski 撰写。"

#: ../../whatsnew/2.5.rst:563
msgid "PEP 343: The 'with' statement"
msgstr "PEP 343: \"with\" 语句"

#: ../../whatsnew/2.5.rst:565
msgid ""
"The ':keyword:`with`' statement clarifies code that previously would use "
"``try...finally`` blocks to ensure that clean-up code is executed.  In this "
"section, I'll discuss the statement as it will commonly be used.  In the "
"next section, I'll examine the implementation details and show how to write "
"objects for use with this statement."
msgstr ""
"':keyword:`with`' 语句澄清了之前使用 ``try...finally`` "
"块以确保执行清理代码的代码。在本节中，我将讨论该语句的常见用法。在下一节中，我将探讨实现细节，并展示如何编写与该语句一起使用的对象。"

#: ../../whatsnew/2.5.rst:571
msgid ""
"The ':keyword:`with`' statement is a new control-flow structure whose basic "
"structure is::"
msgstr "':keyword:`with`' 语句是一种新的控制流结构，其基本结构如下："

#: ../../whatsnew/2.5.rst:574
msgid ""
"with expression [as variable]:\n"
"    with-block"
msgstr ""
"with expression [as variable]:\n"
"    with-block"

#: ../../whatsnew/2.5.rst:577
msgid ""
"The expression is evaluated, and it should result in an object that supports"
" the context management protocol (that is, has :meth:`~object.__enter__` and"
" :meth:`~object.__exit__` methods."
msgstr ""
"表达式被求值，并且它应该生成一个支持上下文管理协议的对象（即具有 :meth:`~object.__enter__` 和 "
":meth:`~object.__exit__` 方法的对象）。"

#: ../../whatsnew/2.5.rst:581
msgid ""
"The object's :meth:`~object.__enter__` is called before *with-block* is "
"executed and therefore can run set-up code. It also may return a value that "
"is bound to the name *variable*, if given.  (Note carefully that *variable* "
"is *not* assigned the result of *expression*.)"
msgstr ""
"在执行 *with-block* 之前，调用对象的 :meth:`~object.__enter__` "
"方法，因此可以运行设置代码。如果给定，它还可以返回一个绑定到 *variable* 名称的值。（请注意，*variable* 并不是被赋值为 "
"*expression* 的结果。）"

#: ../../whatsnew/2.5.rst:586
msgid ""
"After execution of the *with-block* is finished, the object's "
":meth:`~object.__exit__` method is called, even if the block raised an "
"exception, and can therefore run clean-up code."
msgstr ""
"在 *with-block* 执行完成后，调用对象的 :meth:`~object.__exit__` 方法，即使块引发了异常，因此可以运行清理代码。"

#: ../../whatsnew/2.5.rst:590
msgid ""
"To enable the statement in Python 2.5, you need to add the following "
"directive to your module::"
msgstr "要在 Python 2.5 中启用该语句，你需要向你的模块添加以下指令::"

#: ../../whatsnew/2.5.rst:593
msgid "from __future__ import with_statement"
msgstr "from __future__ import with_statement"

#: ../../whatsnew/2.5.rst:595
msgid "The statement will always be enabled in Python 2.6."
msgstr "该语句在Python 2.6 中始终启用。"

#: ../../whatsnew/2.5.rst:597
msgid ""
"Some standard Python objects now support the context management protocol and"
" can be used with the ':keyword:`with`' statement. File objects are one "
"example::"
msgstr "一些标准 Python 对象现在已支持上下文管理协议并可被用于 ':keyword:`with`' 语句。 文件对象就是一个例子::"

#: ../../whatsnew/2.5.rst:600
msgid ""
"with open('/etc/passwd', 'r') as f:\n"
"    for line in f:\n"
"        print line\n"
"        ... more processing code ..."
msgstr ""
"with open('/etc/passwd', 'r') as f:\n"
"    for line in f:\n"
"        print line\n"
"        ... 更多处理代码 ..."

#: ../../whatsnew/2.5.rst:605
msgid ""
"After this statement has executed, the file object in *f* will have been "
"automatically closed, even if the :keyword:`for` loop raised an exception "
"part-way through the block."
msgstr "在此语句被执行之后，文件对象 *f* 将被自动关闭，即使是当 :keyword:`for` 循环在代码块中间位置引发了异常的时候也是如此。"

#: ../../whatsnew/2.5.rst:611
msgid ""
"In this case, *f* is the same object created by :func:`open`, because "
":meth:`~object.__enter__` returns *self*."
msgstr ""
"在此情况下，*f* 就是由 :func:`open` 所创建的对象，因为 :meth:`~object.__enter__` 会返回 *self*。"

#: ../../whatsnew/2.5.rst:614
msgid ""
"The :mod:`threading` module's locks and condition variables  also support "
"the ':keyword:`with`' statement::"
msgstr ":mod:`threading` 模块的加锁和条件变量也支持 ':keyword:`with`' 语句::"

#: ../../whatsnew/2.5.rst:617
msgid ""
"lock = threading.Lock()\n"
"with lock:\n"
"    # Critical section of code\n"
"    ..."
msgstr ""
"lock = threading.Lock()\n"
"with lock:\n"
"    # 关键代码段\n"
"    ..."

#: ../../whatsnew/2.5.rst:622
msgid ""
"The lock is acquired before the block is executed and always released once  "
"the block is complete."
msgstr "这个锁会在代码块被执行之前锁定并总是会在代码块完成之后释放。"

#: ../../whatsnew/2.5.rst:625
msgid ""
"The new :func:`localcontext` function in the :mod:`decimal` module makes it "
"easy to save and restore the current decimal context, which encapsulates the"
" desired precision and rounding characteristics for computations::"
msgstr ""
"在 :mod:`decimal` 模块中的新 :func:`localcontext` "
"函数可以轻松保存和恢复当前小数上下文，该上下文封装了计算所需的精度和舍入特性："

#: ../../whatsnew/2.5.rst:629
msgid ""
"from decimal import Decimal, Context, localcontext\n"
"\n"
"# Displays with default precision of 28 digits\n"
"v = Decimal('578')\n"
"print v.sqrt()\n"
"\n"
"with localcontext(Context(prec=16)):\n"
"    # All code in this block uses a precision of 16 digits.\n"
"    # The original context is restored on exiting the block.\n"
"    print v.sqrt()"
msgstr ""
"from decimal import Decimal, Context, localcontext\n"
"\n"
"# 使用默认精度 28 位显示\n"
"v = Decimal('578')\n"
"print v.sqrt()\n"
"\n"
"with localcontext(Context(prec=16)):\n"
"    # 此块中的所有代码使用 16 位精度。\n"
"    # 退出块时恢复原始上下文。\n"
"    print v.sqrt()"

#: ../../whatsnew/2.5.rst:644
msgid "Writing Context Managers"
msgstr "编写上下文管理器"

#: ../../whatsnew/2.5.rst:646
msgid ""
"Under the hood, the ':keyword:`with`' statement is fairly complicated. Most "
"people will only use ':keyword:`!with`' in company with existing objects and"
" don't need to know these details, so you can skip the rest of this section "
"if you like.  Authors of new objects will need to understand the details of "
"the underlying implementation and should keep reading."
msgstr ""
"在底层，':keyword:`with`' 语句相当复杂。大多数人只会与现有对象一起使用 "
"':keyword:`!with`'，不需要了解这些细节，所以如果你愿意，可以跳过本节的其余部分。新对象的作者需要理解底层实现的细节，应该继续阅读。"

#: ../../whatsnew/2.5.rst:652
msgid "A high-level explanation of the context management protocol is:"
msgstr "在更高层级上对于上下文管理器协议的解释:"

#: ../../whatsnew/2.5.rst:654
msgid ""
"The expression is evaluated and should result in an object called a "
"\"context manager\".  The context manager must have "
":meth:`~object.__enter__` and :meth:`~object.__exit__` methods."
msgstr ""
"表达式被求值，并应生成一个称为“上下文管理器”的对象。上下文管理器必须具有 :meth:`~object.__enter__` 和 "
":meth:`~object.__exit__` 方法。"

#: ../../whatsnew/2.5.rst:658
msgid ""
"The context manager's :meth:`~object.__enter__` method is called.  The value"
" returned is assigned to *VAR*.  If no ``'as VAR'`` clause is present, the "
"value is simply discarded."
msgstr ""
"调用上下文管理器的 :meth:`~object.__enter__` 方法。返回的值被赋给 *VAR*。如果没有 ``'as VAR'`` "
"子句，该值将被丢弃。"

#: ../../whatsnew/2.5.rst:662
msgid "The code in *BLOCK* is executed."
msgstr "*BLOCK* 中的代码会被执行。"

#: ../../whatsnew/2.5.rst:664
msgid ""
"If *BLOCK* raises an exception, the ``__exit__(type, value, traceback)`` is "
"called with the exception details, the same values returned by "
":func:`sys.exc_info`.  The method's return value controls whether the "
"exception is re-raised: any false value re-raises the exception, and "
"``True`` will result in suppressing it.  You'll only rarely want to suppress"
" the exception, because if you do the author of the code containing the "
"':keyword:`with`' statement will never realize anything went wrong."
msgstr ""
"如果 *BLOCK* 引发异常，将调用 ``__exit__(type, value, traceback)`` 方法，并传入异常详细信息，这些值与 "
":func:`sys.exc_info` 返回的值相同。该方法的返回值控制是否重新抛出异常：任何假值将重新抛出异常，而 ``True`` "
"将导致异常被抑制。通常情况下，你很少会想要抑制异常，因为如果你这么做，包含 ':keyword:`with`' 语句的代码作者将永远不会意识到出了问题。"

#: ../../whatsnew/2.5.rst:672
msgid ""
"If *BLOCK* didn't raise an exception,  the :meth:`~object.__exit__` method "
"is still called, but *type*, *value*, and *traceback* are all ``None``."
msgstr ""
"如果 *BLOCK* 没有引发异常，仍会调用 :meth:`~object.__exit__` 方法，但 *type*、*value* 和 "
"*traceback* 都为 ``None``。"

#: ../../whatsnew/2.5.rst:675
msgid ""
"Let's think through an example.  I won't present detailed code but will only"
" sketch the methods necessary for a database that supports transactions."
msgstr "让我们通过一个例子来思考。我不会展示详细的代码，只会概述支持事务的数据库所需的方法。"

#: ../../whatsnew/2.5.rst:678
msgid ""
"(For people unfamiliar with database terminology: a set of changes to the "
"database are grouped into a transaction.  Transactions can be either "
"committed, meaning that all the changes are written into the database, or "
"rolled back, meaning that the changes are all discarded and the database is "
"unchanged.  See any database textbook for more information.)"
msgstr ""
"（对于不熟悉数据库术语的人：对数据库的一组更改被分组为一个事务。事务可以被提交，意味着所有更改都被写入数据库，或者回滚，意味着所有更改都被丢弃，数据库保持不变。更多信息请参见任何数据库教材。）"

#: ../../whatsnew/2.5.rst:684
msgid ""
"Let's assume there's an object representing a database connection. Our goal "
"will be to let the user write code like this::"
msgstr "假设有一个表示数据库连接的对象。我们的目标将是可以让用户编写如下代码："

#: ../../whatsnew/2.5.rst:687
msgid ""
"db_connection = DatabaseConnection()\n"
"with db_connection as cursor:\n"
"    cursor.execute('insert into ...')\n"
"    cursor.execute('delete from ...')\n"
"    # ... more operations ..."
msgstr ""
"db_connection = DatabaseConnection()\n"
"with db_connection as cursor:\n"
"    cursor.execute('insert into ...')\n"
"    cursor.execute('delete from ...')\n"
"    # ... 更多操作 ..."

#: ../../whatsnew/2.5.rst:693
msgid ""
"The transaction should be committed if the code in the block runs flawlessly"
" or rolled back if there's an exception. Here's the basic interface for "
":class:`DatabaseConnection` that I'll assume::"
msgstr ""
"如果块中的代码无异常运行，事务应被提交；如果出现异常，应回滚。以下是我假设的 :class:`DatabaseConnection` 的基本接口："

#: ../../whatsnew/2.5.rst:697
msgid ""
"class DatabaseConnection:\n"
"    # Database interface\n"
"    def cursor (self):\n"
"        \"Returns a cursor object and starts a new transaction\"\n"
"    def commit (self):\n"
"        \"Commits current transaction\"\n"
"    def rollback (self):\n"
"        \"Rolls back current transaction\""
msgstr ""
"class DatabaseConnection:\n"
"    # 数据库接口\n"
"    def cursor(self):\n"
"        \"返回一个游标对象并开始一个新的事务\"\n"
"    def commit(self):\n"
"        \"提交当前事务\"\n"
"    def rollback(self):\n"
"        \"回滚当前事务\""

#: ../../whatsnew/2.5.rst:706
msgid ""
"The :meth:`~object.__enter__` method is pretty easy, having only to start a "
"new transaction.  For this application the resulting cursor object would be "
"a useful result, so the method will return it.  The user can then add ``as "
"cursor`` to their ':keyword:`with`' statement to bind the cursor to a "
"variable name. ::"
msgstr ""
":meth:`~object.__enter__` "
"方法非常简单，只需要开始一个新的事务。对于这个应用程序，生成的游标对象将是一个有用的结果，因此该方法将返回它。用户可以在他们的 "
"':keyword:`with`' 语句中添加 ``as cursor`` 来将游标绑定到一个变量名。 ::"

#: ../../whatsnew/2.5.rst:711
msgid ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __enter__ (self):\n"
"        # Code to start a new transaction\n"
"        cursor = self.cursor()\n"
"        return cursor"
msgstr ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __enter__(self):\n"
"        # 开始一个新事务的代码\n"
"        cursor = self.cursor()\n"
"        return cursor"

#: ../../whatsnew/2.5.rst:718
msgid ""
"The :meth:`~object.__exit__` method is the most complicated because it's "
"where most of the work has to be done.  The method has to check if an "
"exception occurred.  If there was no exception, the transaction is "
"committed.  The transaction is rolled back if there was an exception."
msgstr ""
":meth:`~object.__exit__` "
"方法是最复杂的，因为大部分工作都需要在这里完成。该方法需要检查是否发生了异常。如果没有异常，事务将被提交。如果有异常，事务将被回滚。"

#: ../../whatsnew/2.5.rst:723
msgid ""
"In the code below, execution will just fall off the end of the function, "
"returning the default value of ``None``.  ``None`` is false, so the "
"exception will be re-raised automatically.  If you wished, you could be more"
" explicit and add a :keyword:`return` statement at the marked location. ::"
msgstr ""
"在下面的代码中，执行将直接从函数末尾掉落，返回默认值 ``None``。``None`` "
"是假的，所以异常将自动重新抛出。如果你希望更明确，你可以在标记的位置添加一个 :keyword:`return` 语句。 ::"

#: ../../whatsnew/2.5.rst:728
msgid ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __exit__ (self, type, value, tb):\n"
"        if tb is None:\n"
"            # No exception, so commit\n"
"            self.commit()\n"
"        else:\n"
"            # Exception occurred, so rollback.\n"
"            self.rollback()\n"
"            # return False"
msgstr ""
"class DatabaseConnection:\n"
"    ...\n"
"    def __exit__ (self, type, value, tb):\n"
"        if tb is None:\n"
"            # 没有异常，因此提交\n"
"            self.commit()\n"
"        else:\n"
"            # 发生异常，因此回滚。\n"
"            self.rollback()\n"
"            # 返回 False"

#: ../../whatsnew/2.5.rst:743
msgid "The contextlib module"
msgstr "contextlib 模块"

#: ../../whatsnew/2.5.rst:745
msgid ""
"The new :mod:`contextlib` module provides some functions and a decorator "
"that are useful for writing objects for use with the ':keyword:`with`' "
"statement."
msgstr ""
"新的 :mod:`contextlib` 模块提供了一些函数和一个装饰器，这些对于编写用于 ':keyword:`with`' 语句的对象非常有用。"

#: ../../whatsnew/2.5.rst:748
msgid ""
"The decorator is called :func:`contextmanager`, and lets you write a single "
"generator function instead of defining a new class.  The generator should "
"yield exactly one value.  The code up to the :keyword:`yield` will be "
"executed as the :meth:`~object.__enter__` method, and the value yielded will"
" be the method's return value that will get bound to the variable in the "
"':keyword:`with`' statement's :keyword:`!as` clause, if any.  The code after"
" the :keyword:`yield` will be executed in the :meth:`~object.__exit__` "
"method.  Any exception raised in the block will be raised by the "
":keyword:`!yield` statement."
msgstr ""
"装饰器称为 :func:`contextmanager`，它允许你编写单个生成器函数，而不需要定义一个新的类。生成器应该产生正好一个值。在 "
":keyword:`yield` 之前的代码将作为 :meth:`~object.__enter__` 方法执行，产生的值将作为该方法的返回值，绑定到 "
"':keyword:`with`' 语句的 :keyword:`!as` 子句中的变量（如果有的话）。在 :keyword:`yield` "
"之后的代码将在 :meth:`~object.__exit__` 方法中执行。块中引发的任何异常将由 :keyword:`!yield` 语句引发。"

#: ../../whatsnew/2.5.rst:757
msgid ""
"Our database example from the previous section could be written  using this "
"decorator as::"
msgstr "上一节中的数据库示例可以使用这个装饰器编写为::"

#: ../../whatsnew/2.5.rst:760
msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def db_transaction (connection):\n"
"    cursor = connection.cursor()\n"
"    try:\n"
"        yield cursor\n"
"    except:\n"
"        connection.rollback()\n"
"        raise\n"
"    else:\n"
"        connection.commit()\n"
"\n"
"db = DatabaseConnection()\n"
"with db_transaction(db) as cursor:\n"
"    ..."
msgstr ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def db_transaction (connection):\n"
"    cursor = connection.cursor()\n"
"    try:\n"
"        yield cursor\n"
"    except:\n"
"        connection.rollback()\n"
"        raise\n"
"    else:\n"
"        connection.commit()\n"
"\n"
"db = DatabaseConnection()\n"
"with db_transaction(db) as cursor:\n"
"    ..."

#: ../../whatsnew/2.5.rst:777
msgid ""
"The :mod:`contextlib` module also has a ``nested(mgr1, mgr2, ...)`` function"
" that combines a number of context managers so you don't need to write "
"nested ':keyword:`with`' statements.  In this example, the single "
"':keyword:`!with`' statement both starts a database transaction and acquires"
" a thread lock::"
msgstr ""
":mod:`contextlib` 模块还有一个 ``nested(mgr1, mgr2, ...)`` "
"函数，它组合了多个上下文管理器，因此你不需要编写嵌套的 ':keyword:`with`' 语句。在这个示例中，单个 "
"':keyword:`!with`' 语句既启动数据库事务又获取线程锁::"

#: ../../whatsnew/2.5.rst:782
msgid ""
"lock = threading.Lock()\n"
"with nested (db_transaction(db), lock) as (cursor, locked):\n"
"    ..."
msgstr ""
"lock = threading.Lock()\n"
"with nested (db_transaction(db), lock) as (cursor, locked):\n"
"    ..."

#: ../../whatsnew/2.5.rst:786
msgid ""
"Finally, the ``closing(object)`` function returns *object* so that it can be"
" bound to a variable, and calls ``object.close`` at the end of the block. ::"
msgstr ""
"最后，``closing(object)`` 函数返回 *object*，以便它可以绑定到变量，并在块的末尾调用 ``object.close``。::"

#: ../../whatsnew/2.5.rst:789
msgid ""
"import urllib, sys\n"
"from contextlib import closing\n"
"\n"
"with closing(urllib.urlopen('http://www.yahoo.com')) as f:\n"
"    for line in f:\n"
"        sys.stdout.write(line)"
msgstr ""
"import urllib, sys\n"
"from contextlib import closing\n"
"\n"
"with closing(urllib.urlopen('http://www.yahoo.com')) as f:\n"
"    for line in f:\n"
"        sys.stdout.write(line)"

#: ../../whatsnew/2.5.rst:799
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 语句"

#: ../../whatsnew/2.5.rst:800
msgid ""
"PEP written by Guido van Rossum and Nick Coghlan; implemented by Mike Bland,"
" Guido van Rossum, and Neal Norwitz.  The PEP shows the code generated for a"
" ':keyword:`with`' statement, which can be helpful in learning how the "
"statement works."
msgstr ""
"PEP 由 Guido van Rossum 和 Nick Coghlan 撰写；由 Mike Bland、Guido van Rossum 和 "
"Neal Norwitz 实现。PEP 展示了为 ':keyword:`with`' 语句生成的代码，这有助于了解该语句的工作原理。"

#: ../../whatsnew/2.5.rst:805
msgid "The documentation  for the :mod:`contextlib` module."
msgstr ":mod:`contextlib` 模块的文档。"

#: ../../whatsnew/2.5.rst:813
msgid "PEP 352: Exceptions as New-Style Classes"
msgstr "PEP 352: 异常作为新型的类"

#: ../../whatsnew/2.5.rst:815
msgid ""
"Exception classes can now be new-style classes, not just classic classes, "
"and the built-in :exc:`Exception` class and all the standard built-in "
"exceptions (:exc:`NameError`, :exc:`ValueError`, etc.) are now new-style "
"classes."
msgstr ""
"异常类现在可以是新式类，而不仅仅是经典类，内置的 :exc:`Exception` "
"类和所有标准内置异常（:exc:`NameError`、:exc:`ValueError` 等）现在都是新式类。"

#: ../../whatsnew/2.5.rst:819
msgid ""
"The inheritance hierarchy for exceptions has been rearranged a bit. In 2.5, "
"the inheritance relationships are::"
msgstr "异常的继承层次结构已经稍作调整。在 2.5 中，继承关系如下::"

#: ../../whatsnew/2.5.rst:822
msgid ""
"BaseException       # New in Python 2.5\n"
"|- KeyboardInterrupt\n"
"|- SystemExit\n"
"|- Exception\n"
"   |- (all other current built-in exceptions)"
msgstr ""
"BaseException       # Python 2.5 中新增\n"
"|- KeyboardInterrupt\n"
"|- SystemExit\n"
"|- Exception\n"
"   |- （所有其他当前内置异常）"

#: ../../whatsnew/2.5.rst:828
msgid ""
"This rearrangement was done because people often want to catch all "
"exceptions that indicate program errors.  :exc:`KeyboardInterrupt` and "
":exc:`SystemExit` aren't errors, though, and usually represent an explicit "
"action such as the user hitting :kbd:`Control-C` or code calling "
":func:`sys.exit`.  A bare ``except:`` will catch all exceptions, so you "
"commonly need to list :exc:`KeyboardInterrupt` and :exc:`SystemExit` in "
"order to re-raise them.  The usual pattern is::"
msgstr ""
"进行此重新排列是因为人们通常希望捕获所有指示程序错误的异常。然而，:exc:`KeyboardInterrupt` 和 "
":exc:`SystemExit` 并不是错误，它们通常表示明确的操作，例如用户按下 :kbd:`Control-C` 或代码调用 "
":func:`sys.exit`。一个裸露的 ``except:`` 会捕获所有异常，因此通常需要列出 :exc:`KeyboardInterrupt`"
" 和 :exc:`SystemExit` 以重新抛出它们。通常的模式是::"

#: ../../whatsnew/2.5.rst:835
msgid ""
"try:\n"
"    ...\n"
"except (KeyboardInterrupt, SystemExit):\n"
"    raise\n"
"except:\n"
"    # Log error...\n"
"    # Continue running program..."
msgstr ""
"try:\n"
"    ...\n"
"except (KeyboardInterrupt, SystemExit):\n"
"    raise\n"
"except:\n"
"    # 记录错误...\n"
"    # 继续运行程序..."

#: ../../whatsnew/2.5.rst:843
msgid ""
"In Python 2.5, you can now write ``except Exception`` to achieve the same "
"result, catching all the exceptions that usually indicate errors  but "
"leaving :exc:`KeyboardInterrupt` and :exc:`SystemExit` alone.  As in "
"previous versions, a bare ``except:`` still catches all exceptions."
msgstr ""
"在 Python 2.5 中，你现在可以写 ``except Exception`` 来达到同样的效果，捕获所有通常指示错误的异常，但不包括 "
":exc:`KeyboardInterrupt` 和 :exc:`SystemExit`。与之前的版本一样，裸露的 ``except:`` "
"仍然会捕获所有异常。"

#: ../../whatsnew/2.5.rst:848
msgid ""
"The goal for Python 3.0 is to require any class raised as an exception to "
"derive from :exc:`BaseException` or some descendant of :exc:`BaseException`,"
" and future releases in the Python 2.x series may begin to enforce this "
"constraint. Therefore, I suggest you begin making all your exception classes"
" derive from :exc:`Exception` now.  It's been suggested that the bare "
"``except:`` form should be removed in Python 3.0, but Guido van Rossum "
"hasn't decided whether to do this or not."
msgstr ""
"Python 3.0 的目标是要求任何作为异常被引发的类都必须派生自 :exc:`BaseException` 或 "
":exc:`BaseException` 的某个子类，未来 Python 2.x 系列的发布版可能会开始强制执行这一约束。 "
"因此，我建议你现在就开始让你的所有异常类都从 :exc:`Exception` 派生。 有建议称裸露的 ``except:`` 形式应在 Python "
"3.0 中移除，但 Guido van Rossum 尚未决定是否要这样做。"

#: ../../whatsnew/2.5.rst:856
msgid ""
"Raising of strings as exceptions, as in the statement ``raise \"Error "
"occurred\"``, is deprecated in Python 2.5 and will trigger a warning.  The "
"aim is to be able to remove the string-exception feature in a few releases."
msgstr ""
"在 Python 2.5 中，如 ``raise \"Error occurred\"`` "
"这样的将字符串作为异常抛出的做法已被弃用，并会触发警告。目标是能够在几个版本后移除字符串异常功能。"

#: ../../whatsnew/2.5.rst:863
msgid ":pep:`352` - Required Superclass for Exceptions"
msgstr ":pep:`352` - 异常所需的超类"

#: ../../whatsnew/2.5.rst:864
msgid ""
"PEP written by  Brett Cannon and Guido van Rossum; implemented by Brett "
"Cannon."
msgstr "PEP 由 Brett Cannon 和 Guido van Rossum 撰写，由 Brett Cannon 实现。"

#: ../../whatsnew/2.5.rst:872
msgid "PEP 353: Using ssize_t as the index type"
msgstr "PEP 353: 使用ssize_t作为索引类型"

#: ../../whatsnew/2.5.rst:874
msgid ""
"A wide-ranging change to Python's C API, using a new  :c:type:`Py_ssize_t` "
"type definition instead of :c:expr:`int`,  will permit the interpreter to "
"handle more data on 64-bit platforms. This change doesn't affect Python's "
"capacity on 32-bit platforms."
msgstr ""
"对 Python 的 C API 进行了广泛更改，使用新的 :c:type:`Py_ssize_t` 类型定义代替 "
":c:expr:`int`，这将允许解释器在 64 位平台上处理更多数据。这一变化不影响 Python 在 32 位平台上的能力。"

#: ../../whatsnew/2.5.rst:879
msgid ""
"Various pieces of the Python interpreter used C's :c:expr:`int` type to "
"store sizes or counts; for example, the number of items in a list or tuple "
"were stored in an :c:expr:`int`.  The C compilers for most 64-bit platforms "
"still define :c:expr:`int` as a 32-bit type, so that meant that lists could "
"only hold up to ``2**31 - 1`` = 2147483647 items. (There are actually a few "
"different programming models that 64-bit C compilers can use -- see "
"https://unix.org/version2/whatsnew/lp64_wp.html for a discussion -- but the "
"most commonly available model leaves :c:expr:`int` as 32 bits.)"
msgstr ""
"Python 解释器的各个部分使用 C 语言的 :c:expr:`int` 类型来存储大小或计数；例如，列表或元组中的项数就存储在 "
":c:expr:`int` 中。 大多数 64 位平台的 C 编译器仍然将 :c:expr:`int` 定义为 32 位类型，这意味着列表最多只能容纳 "
"``2**31 - 1`` = 2147483647 项。 （实际上，64 位 C 编译器可以使用几种不同的编程模型 —— 参见 "
"https://unix.org/version2/whatsnew/lp64_wp.html 进行讨论 —— 但最常用的模型将 "
":c:expr:`int` 保留为 32 位。）"

#: ../../whatsnew/2.5.rst:888
msgid ""
"A limit of 2147483647 items doesn't really matter on a 32-bit platform "
"because you'll run out of memory before hitting the length limit. Each list "
"item requires space for a pointer, which is 4 bytes, plus space for a "
":c:type:`PyObject` representing the item.  2147483647\\*4 is already more "
"bytes than a 32-bit address space can contain."
msgstr ""
"在 32 位平台上，2147483647 项的限制实际上并不重要，因为在达到长度限制之前你就会耗尽内存。 每个列表项需要为指针预留空间，指针占 4 "
"字节，再加上表示该项的 :c:type:`PyObject` 所需的空间。 2147483647\\*4 已经超过了 32 位地址空间所能容纳的字节数。"

#: ../../whatsnew/2.5.rst:894
msgid ""
"It's possible to address that much memory on a 64-bit platform, however.  "
"The pointers for a list that size would only require 16 GiB of space, so "
"it's not unreasonable that Python programmers might construct lists that "
"large. Therefore, the Python interpreter had to be changed to use some type "
"other than :c:expr:`int`, and this will be a 64-bit type on 64-bit "
"platforms.  The change will cause incompatibilities on 64-bit machines, so "
"it was deemed worth making the transition now, while the number of 64-bit "
"users is still relatively small. (In 5 or 10 years, we may *all* be on "
"64-bit machines, and the transition would be more painful then.)"
msgstr ""
"然而，在 64 位平台上可以寻址那么多的内存。 那样大小的列表的指针只需要 16 GiB 的空间，因此 Python 程序员构建如此大的列表并非不合理。"
" 因此，Python 解释器必须改用某种不同于 :c:expr:`int` 的类型，而在 64 位平台上这将是一个 64 位类型。这一更改会导致 64 "
"位机器上的不兼容，因此被认为现在进行过渡是值得的，因为 64 位用户数量仍然相对较少。 （在 5 年或 10 年后，我们可能 *都* 在使用 64 "
"位机器，那时过渡会更加痛苦。）"

#: ../../whatsnew/2.5.rst:904
msgid ""
"This change most strongly affects authors of C extension modules.   Python "
"strings and container types such as lists and tuples  now use "
":c:type:`Py_ssize_t` to store their size.   Functions such as "
":c:func:`PyList_Size`  now return :c:type:`Py_ssize_t`.  Code in extension "
"modules may therefore need to have some variables changed to "
":c:type:`Py_ssize_t`."
msgstr ""
"这一更改对 C 扩展模块的作者影响最大。 Python 字符串和容器类型（如列表和元组）现在使用 :c:type:`Py_ssize_t` "
"来存储其大小。 诸如 :c:func:`PyList_Size` 之类的函数现在返回 :c:type:`Py_ssize_t`。 "
"因此，扩展模块中的代码可能需要将一些变量更改为 :c:type:`Py_ssize_t`。"

#: ../../whatsnew/2.5.rst:910
msgid ""
"The :c:func:`PyArg_ParseTuple` and :c:func:`Py_BuildValue` functions have a "
"new conversion code, ``n``, for :c:type:`Py_ssize_t`.   "
":c:func:`PyArg_ParseTuple`'s ``s#`` and ``t#`` still output :c:expr:`int` by"
" default, but you can define the macro  :c:macro:`PY_SSIZE_T_CLEAN` before "
"including :file:`Python.h`  to make them return :c:type:`Py_ssize_t`."
msgstr ""
":c:func:`PyArg_ParseTuple` 和 :c:func:`Py_BuildValue` 函数新增了一个转换代码 ``n``，用于 "
":c:type:`Py_ssize_t`。:c:func:`PyArg_ParseTuple` 的 ``s#`` 和 ``t#`` 默认仍输出 "
":c:expr:`int`，但你可以在包含 :file:`Python.h` 之前定义宏 "
":c:macro:`PY_SSIZE_T_CLEAN`，以使它们返回 :c:type:`Py_ssize_t`。"

#: ../../whatsnew/2.5.rst:916
msgid ""
":pep:`353` has a section on conversion guidelines that  extension authors "
"should read to learn about supporting 64-bit platforms."
msgstr ":pep:`353` 有一个关于转换指南的章节，扩展作者应阅读以了解如何支持64位平台。"

#: ../../whatsnew/2.5.rst:922
msgid ":pep:`353` - Using ssize_t as the index type"
msgstr ":pep:`353` - 使用ssize_t作为索引类型"

#: ../../whatsnew/2.5.rst:923
msgid "PEP written and implemented by Martin von Löwis."
msgstr "PEP 由 Martin von Löwis 撰写并实现。"

#: ../../whatsnew/2.5.rst:931
msgid "PEP 357: The '__index__' method"
msgstr "PEP 357: '__index__' 方法"

#: ../../whatsnew/2.5.rst:933
msgid ""
"The NumPy developers had a problem that could only be solved by adding a new"
" special method, :meth:`__index__`.  When using slice notation, as in "
"``[start:stop:step]``, the values of the *start*, *stop*, and *step* indexes"
" must all be either integers or long integers.  NumPy defines a variety of "
"specialized integer types corresponding to unsigned and signed integers of "
"8, 16, 32, and 64 bits, but there was no way to signal that these types "
"could be used as slice indexes."
msgstr ""
"NumPy 开发者遇到了一个问题，只能通过添加一个新的特殊方法 :meth:`__index__` 来解决。在使用切片表示法，如 "
"``[start:stop:step]`` 时，*start*、*stop* 和 *step* 索引的值必须都是整数或长整数。NumPy "
"定义了多种专门的整数类型，对应于8、16、32和64位的无符号和有符号整数，但没有办法表示这些类型可以用作切片索引。"

#: ../../whatsnew/2.5.rst:941
msgid ""
"Slicing can't just use the existing :meth:`__int__` method because that "
"method is also used to implement coercion to integers.  If slicing used "
":meth:`__int__`, floating-point numbers would also become legal slice "
"indexes and that's clearly an undesirable behaviour."
msgstr ""
"切片不能仅使用现有的 :meth:`__int__` 方法，因为该方法还用于实现强制转换为整数。如果切片使用 "
":meth:`__int__`，浮点数也会成为合法的切片索引，这显然是不希望的行为。"

#: ../../whatsnew/2.5.rst:946
msgid ""
"Instead, a new special method called :meth:`__index__` was added.  It takes "
"no arguments and returns an integer giving the slice index to use.  For "
"example::"
msgstr "相反，添加了一个新的特殊方法 :meth:`__index__`。它不接受任何参数，返回一个整数，给出要使用的切片索引。例如："

#: ../../whatsnew/2.5.rst:949
msgid ""
"class C:\n"
"    def __index__ (self):\n"
"        return self.value"
msgstr ""
"class C:\n"
"    def __index__ (self):\n"
"        return self.value"

#: ../../whatsnew/2.5.rst:953
msgid ""
"The return value must be either a Python integer or long integer. The "
"interpreter will check that the type returned is correct, and raises a "
":exc:`TypeError` if this requirement isn't met."
msgstr "返回值必须是 Python 整数或长整数。解释器将检查返回的类型是否正确，如果不满足此要求，将引发 :exc:`TypeError`。"

#: ../../whatsnew/2.5.rst:957
msgid ""
"A corresponding :c:member:`~PyNumberMethods.nb_index` slot was added to the "
"C-level :c:type:`PyNumberMethods` structure to let C extensions implement "
"this protocol. ``PyNumber_Index(obj)`` can be used in extension code to call"
" the :meth:`__index__` function and retrieve its result."
msgstr ""
"在 C 级的 :c:type:`PyNumberMethods` 结构中添加了相应的 "
":c:member:`~PyNumberMethods.nb_index` 插槽，以便 C "
"扩展实现此协议。``PyNumber_Index(obj)`` 可用于扩展代码中调用 :meth:`__index__` 函数并获取其结果。"

#: ../../whatsnew/2.5.rst:965
msgid ":pep:`357` - Allowing Any Object to be Used for Slicing"
msgstr ":pep:`357` - 允许将任何对象用于切片"

#: ../../whatsnew/2.5.rst:966
msgid "PEP written  and implemented by Travis Oliphant."
msgstr "PEP 由 Travis Oliphant 撰写并实现。"

#: ../../whatsnew/2.5.rst:974
msgid "Other Language Changes"
msgstr "其他语言特性修改"

#: ../../whatsnew/2.5.rst:976
msgid ""
"Here are all of the changes that Python 2.5 makes to the core Python "
"language."
msgstr "以下是 Python 2.5 针对核心 Python 语言的所有改变。"

#: ../../whatsnew/2.5.rst:978
msgid ""
"The :class:`dict` type has a new hook for letting subclasses provide a "
"default value when a key isn't contained in the dictionary. When a key isn't"
" found, the dictionary's ``__missing__(key)`` method will be called.  This "
"hook is used to implement the new :class:`defaultdict` class in the "
":mod:`collections` module.  The following example defines a dictionary  that"
" returns zero for any missing key::"
msgstr ""
":class:`dict` 类型新增了一个钩子，允许子类在字典中不包含某个键时提供默认值。当找不到键时，将调用字典的 "
"``__missing__(key)`` 方法。这个钩子用于在 :mod:`collections` 模块中实现新的 "
":class:`defaultdict` 类。以下示例定义了一个字典，对于任何缺失的键返回零::"

#: ../../whatsnew/2.5.rst:985
msgid ""
"class zerodict (dict):\n"
"    def __missing__ (self, key):\n"
"        return 0\n"
"\n"
"d = zerodict({1:1, 2:2})\n"
"print d[1], d[2]   # Prints 1, 2\n"
"print d[3], d[4]   # Prints 0, 0"
msgstr ""
"class zerodict (dict):\n"
"    def __missing__ (self, key):\n"
"        return 0\n"
"\n"
"d = zerodict({1:1, 2:2})\n"
"print d[1], d[2]   # 输出 1, 2\n"
"print d[3], d[4]   # 输出 0, 0"

#: ../../whatsnew/2.5.rst:993
msgid ""
"Both 8-bit and Unicode strings have new ``partition(sep)``  and "
"``rpartition(sep)`` methods that simplify a common use case."
msgstr ""
"8位字符串和Unicode字符串都新增了 ``partition(sep)`` 和 ``rpartition(sep)`` 方法，简化了常见的用例。"

#: ../../whatsnew/2.5.rst:996
msgid ""
"The ``find(S)`` method is often used to get an index which is then used to "
"slice the string and obtain the pieces that are before and after the "
"separator. ``partition(sep)`` condenses this pattern into a single method "
"call that returns a 3-tuple containing the substring before the separator, "
"the separator itself, and the substring after the separator.  If the "
"separator isn't found, the first element of the tuple is the entire string "
"and the other two elements are empty.  ``rpartition(sep)`` also returns a "
"3-tuple but starts searching from the end of the string; the ``r`` stands "
"for 'reverse'."
msgstr ""
"``find(S)`` 方法通常用于获取一个索引，然后使用该索引来切片字符串，获得分隔符之前和之后的部分。``partition(sep)`` "
"将这种模式浓缩为单个方法调用，返回一个包含分隔符之前子字符串、分隔符本身和分隔符之后子字符串的3元组。如果找不到分隔符，元组的第一个元素是整个字符串，其他两个元素为空。``rpartition(sep)``"
" 也返回一个3元组，但从字符串末尾开始搜索；``r`` 代表 'reverse'（反向）。"

#: ../../whatsnew/2.5.rst:1005
msgid "Some examples::"
msgstr "示例如下："

#: ../../whatsnew/2.5.rst:1007
msgid ""
">>> ('http://www.python.org').partition('://')\n"
"('http', '://', 'www.python.org')\n"
">>> ('file:/usr/share/doc/index.html').partition('://')\n"
"('file:/usr/share/doc/index.html', '', '')\n"
">>> (u'Subject: a quick question').partition(':')\n"
"(u'Subject', u':', u' a quick question')\n"
">>> 'www.python.org'.rpartition('.')\n"
"('www.python', '.', 'org')\n"
">>> 'www.python.org'.rpartition(':')\n"
"('', '', 'www.python.org')"
msgstr ""
">>> ('http://www.python.org').partition('://')\n"
"('http', '://', 'www.python.org')\n"
">>> ('file:/usr/share/doc/index.html').partition('://')\n"
"('file:/usr/share/doc/index.html', '', '')\n"
">>> (u'Subject: a quick question').partition(':')\n"
"(u'Subject', u':', u' a quick question')\n"
">>> 'www.python.org'.rpartition('.')\n"
"('www.python', '.', 'org')\n"
">>> 'www.python.org'.rpartition(':')\n"
"('', '', 'www.python.org')"

#: ../../whatsnew/2.5.rst:1018
msgid ""
"(Implemented by Fredrik Lundh following a suggestion by Raymond Hettinger.)"
msgstr "（由 Fredrik Lundh 在 Raymond Hettinger 的建议下实现。）"

#: ../../whatsnew/2.5.rst:1020
msgid ""
"The :meth:`startswith` and :meth:`endswith` methods of string types now "
"accept tuples of strings to check for. ::"
msgstr "现在字符串类型的 :meth:`startswith` 和 :meth:`endswith` 方法可接受字符串元组供检查。 ::"

#: ../../whatsnew/2.5.rst:1023
msgid ""
"def is_image_file (filename):\n"
"    return filename.endswith(('.gif', '.jpg', '.tiff'))"
msgstr ""
"def is_image_file (filename):\n"
"    return filename.endswith(('.gif', '.jpg', '.tiff'))"

#: ../../whatsnew/2.5.rst:1026
msgid "(Implemented by Georg Brandl following a suggestion by Tom Lynn.)"
msgstr "（由 Georg Brandl 实现，基于 Tom Lynn 的建议。）"

#: ../../whatsnew/2.5.rst:1030
msgid ""
"The :func:`min` and :func:`max` built-in functions gained a ``key`` keyword "
"parameter analogous to the ``key`` argument for :meth:`sort`.  This "
"parameter supplies a function that takes a single argument and is called for"
" every value in the list; :func:`min`/:func:`max` will return the element "
"with the smallest/largest return value from this function. For example, to "
"find the longest string in a list, you can do::"
msgstr ""
":func:`min` 和 :func:`max` 内置函数新增了一个 ``key`` 关键字参数，类似于 :meth:`sort` 的 ``key``"
" 参数。这个参数提供一个函数，该函数接受单个参数，并对列表中的每个值调用；:func:`min`/:func:`max` "
"将返回此函数返回值最小/最大的元素。例如，要找到列表中最长的字符串，可以这样做::"

#: ../../whatsnew/2.5.rst:1037
msgid ""
"L = ['medium', 'longest', 'short']\n"
"# Prints 'longest'\n"
"print max(L, key=len)\n"
"# Prints 'short', because lexicographically 'short' has the largest value\n"
"print max(L)"
msgstr ""
"L = ['medium', 'longest', 'short']\n"
"# 输出 'longest'\n"
"print max(L, key=len)\n"
"# 输出 'short'，因为在字典序上 'short' 具有最大值\n"
"print max(L)"

#: ../../whatsnew/2.5.rst:1043
msgid "(Contributed by Steven Bethard and Raymond Hettinger.)"
msgstr "（由 Steven Bethard 和 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1045
msgid ""
"Two new built-in functions, :func:`any` and :func:`all`, evaluate whether an"
" iterator contains any true or false values.  :func:`any` returns "
":const:`True` if any value returned by the iterator is true; otherwise it "
"will return :const:`False`.  :func:`all` returns :const:`True` only if all "
"of the values returned by the iterator evaluate as true. (Suggested by Guido"
" van Rossum, and implemented by Raymond Hettinger.)"
msgstr ""
"两个新的内置函数，:func:`any` 和 :func:`all`，用于求值迭代器中是否包含任何真值或假值。:func:`any` "
"如果迭代器返回的任何值为真，则返回 :const:`True`；否则返回 :const:`False`。:func:`all` "
"只有当迭代器返回的所有值都为真时，才返回 :const:`True`。（由 Guido van Rossum 建议，Raymond Hettinger "
"实现。）"

#: ../../whatsnew/2.5.rst:1052
msgid ""
"The result of a class's :meth:`__hash__` method can now be either a long "
"integer or a regular integer.  If a long integer is returned, the hash of "
"that value is taken.  In earlier versions the hash value was required to be "
"a regular integer, but in 2.5 the :func:`id` built-in was changed to always "
"return non-negative numbers, and users often seem to use ``id(self)`` in "
":meth:`__hash__` methods (though this is discouraged)."
msgstr ""
"类的 :meth:`__hash__` 方法的返回结果现在可以是长整数或普通整数。 如果返回的是长整数，则取该值的哈希值。 "
"在早期版本中，哈希值必须为普通整数，但在 2.5 版本中，内置的 :func:`id` 函数被改为总是返回非负数，用户通常在 "
":meth:`__hash__` 方法中使用 ``id(self)`` (尽管不推荐这样做)。"

#: ../../whatsnew/2.5.rst:1061
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error.  See :pep:`263`  for how to declare a module's encoding; for example,"
" you might add  a line like this near the top of the source file::"
msgstr ""
"ASCII 现在是模块的默认编码。如果模块包含带有 8 位字符的字符串字面量但没有编码声明，则会引发语法错误。在 Python 2.4 "
"中，这会触发警告，而不是语法错误。参见 :pep:`263` 了解如何声明模块的编码；例如，你可以在源文件顶部附近添加如下行："

#: ../../whatsnew/2.5.rst:1067
msgid "# -*- coding: latin1 -*-"
msgstr "# -*- coding: latin1 -*-"

#: ../../whatsnew/2.5.rst:1069
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string  that can't be converted to "
"Unicode using the default ASCII encoding.   The result of the comparison is "
"false::"
msgstr ""
"一个新的警告，:class:`UnicodeWarning`，在你尝试比较一个 Unicode 字符串和一个无法使用默认 ASCII 编码转换为 "
"Unicode 的 8 位字符串时触发。比较的结果为假："

#: ../../whatsnew/2.5.rst:1073
msgid ""
">>> chr(128) == unichr(128)   # Can't convert chr(128) to Unicode\n"
"__main__:1: UnicodeWarning: Unicode equal comparison failed\n"
"  to convert both arguments to Unicode - interpreting them\n"
"  as being unequal\n"
"False\n"
">>> chr(127) == unichr(127)   # chr(127) can be converted\n"
"True"
msgstr ""
">>> chr(128) == unichr(128)   # 无法将 chr(128) 转换为 Unicode\n"
"__main__:1: UnicodeWarning: Unicode 等值比较失败\n"
"  无法将两个参数都转换为 Unicode - 将它们解释为不等\n"
"False\n"
">>> chr(127) == unichr(127)   # chr(127) 可以转换\n"
"True"

#: ../../whatsnew/2.5.rst:1081
msgid ""
"Previously this would raise a :class:`UnicodeDecodeError` exception, but in "
"2.5 this could result in puzzling problems when accessing a dictionary.  If "
"you looked up ``unichr(128)`` and ``chr(128)`` was being used as a key, "
"you'd get a :class:`UnicodeDecodeError` exception.  Other changes in 2.5 "
"resulted in this exception being raised instead of suppressed by the code in"
" :file:`dictobject.c` that implements dictionaries."
msgstr ""
"以前这会引发一个 :class:`UnicodeDecodeError` 异常，但在2.5版本中，这可能导致在访问字典时出现令人困惑的问题。如果你查找 "
"``unichr(128)`` 而 ``chr(128)`` 正在被用作键，你会得到一个 :class:`UnicodeDecodeError` "
"异常。2.5版本中的其他更改导致这个异常被引发，而不是被 :file:`dictobject.c` 中实现字典的代码所抑制。"

#: ../../whatsnew/2.5.rst:1088
msgid ""
"Raising an exception for such a comparison is strictly correct, but the "
"change might have broken code, so instead  :class:`UnicodeWarning` was "
"introduced."
msgstr "对于这样的比较引发异常是严格正确的，但这个更改可能会破坏代码，因此引入了 :class:`UnicodeWarning`。"

#: ../../whatsnew/2.5.rst:1091
msgid "(Implemented by Marc-André Lemburg.)"
msgstr "（由 Marc-André Lemburg 实现。）"

#: ../../whatsnew/2.5.rst:1093
msgid ""
"One error that Python programmers sometimes make is forgetting to include an"
" :file:`__init__.py` module in a package directory. Debugging this mistake "
"can be confusing, and usually requires running Python with the :option:`-v` "
"switch to log all the paths searched. In Python 2.5, a new "
":exc:`ImportWarning` warning is triggered when an import would have picked "
"up a directory as a package but no :file:`__init__.py` was found.  This "
"warning is silently ignored by default; provide the :option:`-Wd <-W>` "
"option when running the Python executable to display the warning message. "
"(Implemented by Thomas Wouters.)"
msgstr ""
"Python程序员有时会犯的一个错误是忘记在包目录中包含一个 :file:`__init__.py` 模块。调试这个错误可能会令人困惑，通常需要使用 "
":option:`-v` 开关运行Python来记录所有搜索的路径。在Python 2.5中，当导入会选取一个目录作为包但没有找到 "
":file:`__init__.py` 时，会触发新的 :exc:`ImportWarning` "
"警告。默认情况下，这个警告会被默默忽略；在运行Python可执行文件时提供 :option:`-Wd <-W>` 选项来显示警告消息。（由Thomas "
"Wouters实现。）"

#: ../../whatsnew/2.5.rst:1102
msgid ""
"The list of base classes in a class definition can now be empty.   As an "
"example, this is now legal::"
msgstr "类定义中的基类列表现在可以为空。例如，以下现在是合法的::"

#: ../../whatsnew/2.5.rst:1105
msgid ""
"class C():\n"
"    pass"
msgstr ""
"class C():\n"
"    pass"

#: ../../whatsnew/2.5.rst:1108
msgid "(Implemented by Brett Cannon.)"
msgstr "（由 Brett Cannon 实现。）"

#: ../../whatsnew/2.5.rst:1116
msgid "Interactive Interpreter Changes"
msgstr "交互解释器变更"

#: ../../whatsnew/2.5.rst:1118
msgid ""
"In the interactive interpreter, ``quit`` and ``exit``  have long been "
"strings so that new users get a somewhat helpful message when they try to "
"quit::"
msgstr "在交互式解释器中，``quit`` 和 ``exit`` 长期以来一直是字符串，以便新用户在尝试退出时得到一些有帮助的消息::"

#: ../../whatsnew/2.5.rst:1121
msgid ""
">>> quit\n"
"'Use Ctrl-D (i.e. EOF) to exit.'"
msgstr ""
">>> quit\n"
"'使用 Ctrl-D（即 EOF）退出。'"

#: ../../whatsnew/2.5.rst:1124
msgid ""
"In Python 2.5, ``quit`` and ``exit`` are now objects that still produce "
"string representations of themselves, but are also callable. Newbies who try"
" ``quit()`` or ``exit()`` will now exit the interpreter as they expect.  "
"(Implemented by Georg Brandl.)"
msgstr ""
"在Python 2.5中，``quit`` 和 ``exit`` 现在是对象，它们仍然产生自己的字符串表示，但也是可调用的。新手尝试 "
"``quit()`` 或 ``exit()`` 现在会如他们所期望的那样退出解释器。（由Georg Brandl实现。）"

#: ../../whatsnew/2.5.rst:1129
msgid ""
"The Python executable now accepts the standard long options  "
":option:`--help` and :option:`--version`; on Windows,  it also accepts the "
":option:`/? <-?>` option for displaying a help message. (Implemented by "
"Georg Brandl.)"
msgstr ""
"Python可执行文件现在接受标准的长选项 :option:`--help` 和 :option:`--version`；在Windows上，它还接受 "
":option:`/? <-?>` 选项来显示帮助消息。（由Georg Brandl实现。)"

#: ../../whatsnew/2.5.rst:1139
msgid "Optimizations"
msgstr "性能优化"

#: ../../whatsnew/2.5.rst:1141
msgid ""
"Several of the optimizations were developed at the NeedForSpeed sprint, an "
"event held in Reykjavik, Iceland, from May 21--28 2006. The sprint focused "
"on speed enhancements to the CPython implementation and was funded by EWT "
"LLC with local support from CCP Games.  Those optimizations added at this "
"sprint are specially marked in the following list."
msgstr ""
"多项优化是在2006年5月21日至28日在冰岛雷克雅未克举行的NeedForSpeed冲刺活动中开发的。该冲刺活动专注于提升CPython实现的运行速度，由EWT"
" LLC资助，并得到了CCP Games的本地支持。在此冲刺活动中添加的优化在以下列表中特别标注。"

#: ../../whatsnew/2.5.rst:1147
msgid ""
"When they were introduced  in Python 2.4, the built-in :class:`set` and "
":class:`frozenset` types were built on top of Python's dictionary type.   In"
" 2.5 the internal data structure has been customized for implementing sets, "
"and as a result sets will use a third less memory and are somewhat faster. "
"(Implemented by Raymond Hettinger.)"
msgstr ""
"当内置的 :class:`set` 和 :class:`frozenset` 类型在 Python 2.4 中引入时，它们是建立在 Python "
"字典类型之上的。 在 2.5 版本中，内部数据结构已为集合的实现进行了定制，因此集合将使用少三分之一的内存，并且速度也有所提升。 （由 Raymond "
"Hettinger 实现。）"

#: ../../whatsnew/2.5.rst:1153
msgid ""
"The speed of some Unicode operations, such as finding substrings, string "
"splitting, and character map encoding and decoding, has been improved. "
"(Substring search and splitting improvements were added by Fredrik Lundh and"
" Andrew Dalke at the NeedForSpeed sprint. Character maps were improved by "
"Walter Dörwald and Martin von Löwis.)"
msgstr ""
"一些Unicode操作的速度得到了提升，例如查找子字符串、字符串分割以及字符映射的编码和解码。（子字符串搜索和分割改进由Fredrik "
"Lundh和Andrew Dalke在NeedForSpeed冲刺活动中添加。字符映射由Walter Dörwald和Martin von "
"Löwis改进。）"

#: ../../whatsnew/2.5.rst:1161
msgid ""
"The ``long(str, base)`` function is now faster on long digit strings because"
" fewer intermediate results are calculated.  The peak is for strings of "
"around 800--1000 digits where  the function is 6 times faster. (Contributed "
"by Alan McIntyre and committed at the NeedForSpeed sprint.)"
msgstr ""
"``long(str, base)`` 函数在处理长数字字符串时现在更快，因为计算了更少的中间结果。 峰值出现在大约 800 到 1000 "
"位数字的字符串上，此时函数速度提升了 6 倍。 （由 Alan McIntyre 贡献，并在 NeedForSpeed 冲刺活动中提交。）"

#: ../../whatsnew/2.5.rst:1168
msgid ""
"It's now illegal to mix iterating over a file  with ``for line in file`` and"
" calling  the file object's :meth:`read`/:meth:`readline`/:meth:`readlines` "
"methods.  Iteration uses an internal buffer and the  :meth:`!read\\*` "
"methods don't use that buffer.   Instead they would return the data "
"following the buffer, causing the data to appear out of order.  Mixing "
"iteration and these methods will now trigger a :exc:`ValueError` from the "
":meth:`!read\\*` method. (Implemented by Thomas Wouters.)"
msgstr ""
"现在禁止在用 ``for line in file`` 迭代文件的同时调用文件对象的 "
":meth:`read`/:meth:`readline`/:meth:`readlines` 方法。 迭代使用内部缓冲区，而 "
":meth:`!read\\*` 方法不使用该缓冲区。 相反，它们会返回缓冲区后面的数据，导致数据顺序混乱。 混合使用迭代和这些方法现在会从 "
":meth:`!read\\*` 方法触发一个 :exc:`ValueError`。 （由 Thomas Wouters 实现。）"

#: ../../whatsnew/2.5.rst:1178
msgid ""
"The :mod:`struct` module now compiles structure format  strings into an "
"internal representation and caches this representation, yielding a 20% "
"speedup. (Contributed by Bob Ippolito at the NeedForSpeed sprint.)"
msgstr ""
":mod:`struct` 模块现在将结构格式字符串编译成内部表示并缓存该表示，从而提升了 20% 的速度。 （由 Bob Ippolito 在 "
"NeedForSpeed 冲刺活动中贡献。）"

#: ../../whatsnew/2.5.rst:1182
msgid ""
"The :mod:`re` module got a 1 or 2% speedup by switching to  Python's "
"allocator functions instead of the system's  :c:func:`malloc` and "
":c:func:`free`. (Contributed by Jack Diederich at the NeedForSpeed sprint.)"
msgstr ""
":mod:`re` 模块通过切换到 Python 的分配器函数，而不是系统的 :c:func:`malloc` 和 :c:func:`free`，获得了"
" 1% 到 2% 的速度提升。（由 Jack Diederich 在 NeedForSpeed sprint 中贡献。）"

#: ../../whatsnew/2.5.rst:1186
msgid ""
"The code generator's peephole optimizer now performs simple constant folding"
" in expressions.  If you write something like ``a = 2+3``, the code "
"generator will do the arithmetic and produce code corresponding to ``a = "
"5``.  (Proposed and implemented  by Raymond Hettinger.)"
msgstr ""
"代码生成器的窥孔优化器现在可以在表达式中执行简单的常量折叠。如果你写类似 ``a = 2+3`` 的代码，代码生成器将进行算术运算并生成对应于 ``a "
"= 5`` 的代码。（由 Raymond Hettinger 提议并实现。）"

#: ../../whatsnew/2.5.rst:1191
msgid ""
"Function calls are now faster because code objects now keep  the most "
"recently finished frame (a \"zombie frame\") in an internal field of the "
"code object, reusing it the next time the code object is invoked.  (Original"
" patch by Michael Hudson, modified by Armin Rigo and Richard Jones; "
"committed at the NeedForSpeed sprint.)  Frame objects are also slightly "
"smaller, which may improve cache locality and reduce memory usage a bit.  "
"(Contributed by Neal Norwitz.)"
msgstr ""
"函数调用现在更快了，因为代码对象现在会在其内部字段中保留最近完成的帧（一个“僵尸帧”），在下一次调用代码对象时重用它。（原始补丁由 Michael "
"Hudson 提交，由 Armin Rigo 和 Richard Jones 修改；在 NeedForSpeed sprint "
"中提交。）帧对象也略微变小，这可能会改善缓存局部性并稍微减少内存使用。（由 Neal Norwitz 贡献。）"

#: ../../whatsnew/2.5.rst:1201
msgid ""
"Python's built-in exceptions are now new-style classes, a change that speeds"
" up instantiation considerably.  Exception handling in Python 2.5 is "
"therefore about 30% faster than in 2.4. (Contributed by Richard Jones, Georg"
" Brandl and Sean Reifschneider at the NeedForSpeed sprint.)"
msgstr ""
"Python 的内置异常现在是新式类，这一改变显著加快了实例化速度。因此，Python 2.5 中的异常处理比 2.4 快约 30%。（由 "
"Richard Jones、Georg Brandl 和 Sean Reifschneider 在 NeedForSpeed sprint 中贡献。）"

#: ../../whatsnew/2.5.rst:1206
msgid ""
"Importing now caches the paths tried, recording whether  they exist or not "
"so that the interpreter makes fewer  :c:func:`open` and :c:func:`stat` calls"
" on startup. (Contributed by Martin von Löwis and Georg Brandl.)"
msgstr ""
"导入现在会缓存尝试的路径，记录它们是否存在，以便解释器在启动时进行更少的 :c:func:`open` 和 :c:func:`stat` 调用。（由 "
"Martin von Löwis 和 Georg Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:1218
msgid "New, Improved, and Removed Modules"
msgstr "新增，改进和删除的模块"

#: ../../whatsnew/2.5.rst:1220
msgid ""
"The standard library received many enhancements and bug fixes in Python 2.5."
" Here's a partial list of the most notable changes, sorted alphabetically by"
" module name. Consult the :file:`Misc/NEWS` file in the source tree for a "
"more complete list of changes, or look through the SVN logs for all the "
"details."
msgstr ""
"Python 2.5 中的标准库收到了许多增强和错误修复。以下是按模块名称字母顺序排列的部分最显著变化的列表。查阅源树中的 "
":file:`Misc/NEWS` 文件以获取更完整的变化列表，或通过 SVN 日志查看所有细节。"

#: ../../whatsnew/2.5.rst:1225
msgid ""
"The :mod:`!audioop` module now supports the a-LAW encoding, and the code for"
" u-LAW encoding has been improved.  (Contributed by Lars Immisch.)"
msgstr ""
":mod:`!audioop` 模块现在支持 a-LAW 编码，并且 u-LAW 编码的代码已得到改进。（由 Lars Immisch 贡献。）"

#: ../../whatsnew/2.5.rst:1228
msgid ""
"The :mod:`codecs` module gained support for incremental codecs.  The "
":func:`codec.lookup` function now returns a :class:`CodecInfo` instance "
"instead of a tuple. :class:`CodecInfo` instances behave like a 4-tuple to "
"preserve backward compatibility but also have the attributes :attr:`encode`,"
" :attr:`decode`, :attr:`incrementalencoder`, :attr:`incrementaldecoder`, "
":attr:`streamwriter`, and :attr:`streamreader`.  Incremental codecs  can "
"receive input and produce output in multiple chunks; the output is the same "
"as if the entire input was fed to the non-incremental codec. See the "
":mod:`codecs` module documentation for details. (Designed and implemented by"
" Walter Dörwald.)"
msgstr ""
":mod:`codecs` 模块增加了对增量编解码器的支持。:func:`codec.lookup` 函数现在返回一个 "
":class:`CodecInfo` 实例，而不是一个元组。:class:`CodecInfo` 实例表现得像一个4元组以保持向后兼容性，但也具有属性 "
":attr:`encode`、:attr:`decode`、:attr:`incrementalencoder`、:attr:`incrementaldecoder`、:attr:`streamwriter`"
" 和 "
":attr:`streamreader`。增量编解码器可以分多个块接收输入并生成输出；输出与将整个输入提供给非增量编解码器的输出相同。有关详细信息，请参阅"
" :mod:`codecs` 模块文档。（由 Walter Dörwald 设计并实现。）"

#: ../../whatsnew/2.5.rst:1240
msgid ""
"The :mod:`collections` module gained a new type, :class:`defaultdict`, that "
"subclasses the standard :class:`dict` type.  The new type mostly behaves "
"like a dictionary but constructs a default value when a key isn't present, "
"automatically adding it to the dictionary for the requested key value."
msgstr ""
":mod:`collections` 模块新增了一个类型 :class:`defaultdict`，它是标准 :class:`dict` "
"类型的子类。这个新类型在大多数情况下表现得像字典，但当键不存在时，会构造一个默认值，并自动将其添加到字典中，对应请求的键值。"

#: ../../whatsnew/2.5.rst:1245
msgid ""
"The first argument to :class:`defaultdict`'s constructor is a factory "
"function that gets called whenever a key is requested but not found. This "
"factory function receives no arguments, so you can use built-in type "
"constructors such as :func:`list` or :func:`int`.  For example,  you can "
"make an index of words based on their initial letter like this::"
msgstr ""
":class:`defaultdict` "
"构造函数的第一个参数是一个工厂函数，当请求的键未找到时，会调用这个工厂函数。这个工厂函数不接受任何参数，因此你可以使用内置类型构造器，如 "
":func:`list` 或 :func:`int`。例如，你可以基于单词的首字母创建一个索引，如下所示："

#: ../../whatsnew/2.5.rst:1251
msgid ""
"words = \"\"\"Nel mezzo del cammin di nostra vita\n"
"mi ritrovai per una selva oscura\n"
"che la diritta via era smarrita\"\"\".lower().split()\n"
"\n"
"index = defaultdict(list)\n"
"\n"
"for w in words:\n"
"    init_letter = w[0]\n"
"    index[init_letter].append(w)"
msgstr ""
"words = \"\"\"Nel mezzo del cammin di nostra vita\n"
"mi ritrovai per una selva oscura\n"
"che la diritta via era smarrita\"\"\".lower().split()\n"
"\n"
"index = defaultdict(list)\n"
"\n"
"for w in words:\n"
"    init_letter = w[0]\n"
"    index[init_letter].append(w)"

#: ../../whatsnew/2.5.rst:1261
msgid "Printing ``index`` results in the following output::"
msgstr "打印 ``index`` 导致以下输出::"

#: ../../whatsnew/2.5.rst:1263
msgid ""
"defaultdict(<type 'list'>, {'c': ['cammin', 'che'], 'e': ['era'],\n"
"        'd': ['del', 'di', 'diritta'], 'm': ['mezzo', 'mi'],\n"
"        'l': ['la'], 'o': ['oscura'], 'n': ['nel', 'nostra'],\n"
"        'p': ['per'], 's': ['selva', 'smarrita'],\n"
"        'r': ['ritrovai'], 'u': ['una'], 'v': ['vita', 'via']}"
msgstr ""
"defaultdict(<type 'list'>, {'c': ['cammin', 'che'], 'e': ['era'],\n"
"        'd': ['del', 'di', 'diritta'], 'm': ['mezzo', 'mi'],\n"
"        'l': ['la'], 'o': ['oscura'], 'n': ['nel', 'nostra'],\n"
"        'p': ['per'], 's': ['selva', 'smarrita'],\n"
"        'r': ['ritrovai'], 'u': ['una'], 'v': ['vita', 'via']})"

#: ../../whatsnew/2.5.rst:1269
msgid "(Contributed by Guido van Rossum.)"
msgstr "（由 Guido van Rossum 贡献。）"

#: ../../whatsnew/2.5.rst:1271
msgid ""
"The :class:`deque` double-ended queue type supplied by the "
":mod:`collections` module now has a ``remove(value)`` method that removes "
"the first occurrence of *value* in the queue, raising :exc:`ValueError` if "
"the value isn't found. (Contributed by Raymond Hettinger.)"
msgstr ""
":class:`deque` 双端队列类型由 :mod:`collections` 模块提供，现在新增了 ``remove(value)`` "
"方法，用于移除队列中第一个出现的 *value*，如果未找到该值则抛出 :exc:`ValueError`。（由 Raymond Hettinger "
"贡献。）"

#: ../../whatsnew/2.5.rst:1276
msgid ""
"New module: The :mod:`contextlib` module contains helper functions for use "
"with the new ':keyword:`with`' statement.  See section :ref:`contextlibmod` "
"for more about this module."
msgstr ""
"新模块：:mod:`contextlib` 模块包含用于新 ':keyword:`with`' 语句的辅助函数。请参阅 "
":ref:`contextlibmod` 部分了解更多关于此模块的信息。"

#: ../../whatsnew/2.5.rst:1280
msgid ""
"New module: The :mod:`cProfile` module is a C implementation of  the "
"existing :mod:`profile` module that has much lower overhead. The module's "
"interface is the same as :mod:`profile`: you run ``cProfile.run('main()')`` "
"to profile a function, can save profile data to a file, etc.  It's not yet "
"known if the Hotshot profiler, which is also written in C but doesn't match "
"the :mod:`profile` module's interface, will continue to be maintained in "
"future versions of Python.  (Contributed by Armin Rigo.)"
msgstr ""
"新模块：:mod:`cProfile` 模块是现有 :mod:`profile` 模块的 C 语言实现，具有更低的开销。该模块的接口与 "
":mod:`profile` 相同：你可以通过运行 ``cProfile.run('main()')`` "
"来分析函数，还可以将分析数据保存到文件等。目前尚不清楚 Hotshot 分析器（同样用 C 语言编写，但接口与 :mod:`profile` "
"模块不匹配）是否会在 Python 的未来版本中继续维护。（由 Armin Rigo 贡献。）"

#: ../../whatsnew/2.5.rst:1288
msgid ""
"Also, the :mod:`pstats` module for analyzing the data measured by the "
"profiler now supports directing the output to any file object by supplying a"
" *stream* argument to the :class:`Stats` constructor. (Contributed by Skip "
"Montanaro.)"
msgstr ""
"此外，用于分析分析器测量数据的 :mod:`pstats` 模块现在支持通过向 :class:`Stats` 构造函数提供 *stream* "
"参数来将输出定向到任何文件对象。（由 Skip Montanaro 贡献。）"

#: ../../whatsnew/2.5.rst:1292
msgid ""
"The :mod:`csv` module, which parses files in comma-separated value format, "
"received several enhancements and a number of bugfixes.  You can now set the"
" maximum size in bytes of a field by calling the "
"``csv.field_size_limit(new_limit)`` function; omitting the *new_limit* "
"argument will return the currently set limit.  The :class:`reader` class now"
" has a :attr:`line_num` attribute that counts the number of physical lines "
"read from the source; records can span multiple physical lines, so "
":attr:`line_num` is not the same as the number of records read."
msgstr ""
":mod:`csv` 模块用于解析逗号分隔值格式的文件，获得了多项增强和多个 bug 修复。你现在可以通过调用 "
"``csv.field_size_limit(new_limit)`` 函数来设置字段的最大字节数；省略 *new_limit* "
"参数将返回当前设置的限值。:class:`reader` 类现在具有 :attr:`line_num` "
"属性，用于计算从源读取的物理行数；记录可以跨越多个物理行，因此 :attr:`line_num` 与读取的记录数不相同。"

#: ../../whatsnew/2.5.rst:1301
msgid ""
"The CSV parser is now stricter about multi-line quoted fields. Previously, "
"if a line ended within a quoted field without a terminating newline "
"character, a newline would be inserted into the returned field. This "
"behavior caused problems when reading files that contained carriage return "
"characters within fields, so the code was changed to return the field "
"without inserting newlines. As a consequence, if newlines embedded within "
"fields are important, the input should be split into lines in a manner that "
"preserves the newline characters."
msgstr ""
"CSV解析器现在对多行引用字段更为严格。以前，如果一行在引用字段内结束且没有终止换行符，会在返回的字段中插入一个换行符。这种行为在读取包含字段内回车符的文件时会导致问题，因此代码已更改，以返回不插入换行符的字段。因此，如果字段内嵌入的换行符很重要，输入应该以保留换行符的方式拆分成行。"

#: ../../whatsnew/2.5.rst:1309
msgid "(Contributed by Skip Montanaro and Andrew McNamara.)"
msgstr "（由Skip Montanaro 和 Andrew McNamara 贡献。）"

#: ../../whatsnew/2.5.rst:1311
msgid ""
"The :class:`~datetime.datetime` class in the :mod:`datetime`  module now has"
" a ``strptime(string, format)``  method for parsing date strings, "
"contributed by Josh Spoerri. It uses the same format characters as "
":func:`time.strptime` and :func:`time.strftime`::"
msgstr ""
":mod:`datetime` 模块中的 :class:`~datetime.datetime` 类现在有一个 ``strptime(string, "
"format)`` 方法用于解析日期字符串，由Josh Spoerri贡献。它使用与 :func:`time.strptime` 和 "
":func:`time.strftime` 相同的格式字符："

#: ../../whatsnew/2.5.rst:1316
msgid ""
"from datetime import datetime\n"
"\n"
"ts = datetime.strptime('10:13:15 2006-03-07',\n"
"                       '%H:%M:%S %Y-%m-%d')"
msgstr ""
"from datetime import datetime\n"
"\n"
"ts = datetime.strptime('10:13:15 2006-03-07',\n"
"                       '%H:%M:%S %Y-%m-%d')"

#: ../../whatsnew/2.5.rst:1321
msgid ""
"The :meth:`SequenceMatcher.get_matching_blocks` method in the :mod:`difflib`"
" module now guarantees to return a minimal list of blocks describing "
"matching subsequences.  Previously, the algorithm would occasionally break a"
" block of matching elements into two list entries. (Enhancement by Tim "
"Peters.)"
msgstr ""
":mod:`difflib` 模块中的 :meth:`SequenceMatcher.get_matching_blocks` "
"方法现在保证返回描述匹配子序列的最小块列表。以前，算法偶尔会将一个匹配元素块分成两个列表条目。（由Tim Peters增强。）"

#: ../../whatsnew/2.5.rst:1326
msgid ""
"The :mod:`doctest` module gained a ``SKIP`` option that keeps an example "
"from being executed at all.  This is intended for code snippets that are "
"usage examples intended for the reader and aren't actually test cases."
msgstr ""
":mod:`doctest` 模块增加了一个 ``SKIP`` "
"选项，用于完全跳过示例的执行。这是为了那些作为读者使用示例的代码片段，而不是实际的测试用例。"

#: ../../whatsnew/2.5.rst:1330
msgid ""
"An *encoding* parameter was added to the :func:`testfile` function and the "
":class:`DocFileSuite` class to specify the file's encoding.  This makes it "
"easier to use non-ASCII characters in  tests contained within a docstring. "
"(Contributed by Bjorn Tillenius.)"
msgstr ""
"在 :func:`testfile` 函数和 :class:`DocFileSuite` 类中添加了 *encoding* "
"参数，用于指定文件的编码。这使得在文档字符串中包含的测试中使用非ASCII字符变得更加容易。（由Bjorn Tillenius贡献。)"

#: ../../whatsnew/2.5.rst:1337
msgid ""
"The :mod:`email` package has been updated to version 4.0. (Contributed by "
"Barry Warsaw.)"
msgstr ":mod:`email` 包已经升级到 4.0版 （由 Barry Warsaw 贡献）"

#: ../../whatsnew/2.5.rst:1345
msgid ""
"The :mod:`fileinput` module was made more flexible. Unicode filenames are "
"now supported, and a *mode* parameter that defaults to ``\"r\"`` was added "
"to the :func:`input` function to allow opening files in binary or "
":term:`universal newlines` mode.  Another new parameter, *openhook*, lets "
"you use a function other than :func:`open`  to open the input files.  Once "
"you're iterating over the set of files, the :class:`FileInput` object's new "
":meth:`~fileinput.fileno` returns the file descriptor for the currently "
"opened file. (Contributed by Georg Brandl.)"
msgstr ""
":mod:`fileinput` 模块变得更加灵活。 现在支持 Unicode 文件名，并且在 :func:`input` 函数中添加了一个默认值为 "
"``\"r\"`` 的 *mode* 参数，以便以二进制或 :term:`universal newlines` 模式打开文件。 另一个新参数 "
"*openhook* 允许使用除 :func:`open` 之外的其他函数来打开输入文件。 在迭代文件集合时，:class:`FileInput` "
"对象的新 :meth:`~fileinput.fileno` 方法返回当前打开文件的文件描述符。 （由 Georg Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:1354
msgid ""
"In the :mod:`gc` module, the new :func:`get_count` function returns a "
"3-tuple containing the current collection counts for the three GC "
"generations.  This is accounting information for the garbage collector; when"
" these counts reach a specified threshold, a garbage collection sweep will "
"be made.  The existing :func:`gc.collect` function now takes an optional "
"*generation* argument of 0, 1, or 2 to specify which generation to collect. "
"(Contributed by Barry Warsaw.)"
msgstr ""
"在 :mod:`gc` 模块中，新的 :func:`get_count` 函数返回一个包含三个 GC 世代当前收集计数的 3 "
"元组。这是垃圾收集器的统计信息；当这些计数达到指定阈值时，将进行垃圾收集扫描。现有的 :func:`gc.collect` 函数现在接受一个可选的 "
"*generation* 参数，其值为 0、1 或 2，以指定要收集的世代。（由 Barry Warsaw 贡献。）"

#: ../../whatsnew/2.5.rst:1361
msgid ""
"The :func:`nsmallest` and  :func:`nlargest` functions in the :mod:`heapq` "
"module  now support a ``key`` keyword parameter similar to the one provided "
"by the :func:`min`/:func:`max` functions and the :meth:`sort` methods.  For "
"example::"
msgstr ""
":mod:`heapq` 模块中的 :func:`nsmallest` 和 :func:`nlargest` 函数现在支持一个类似于 "
":func:`min`/:func:`max` 函数和 :meth:`sort` 方法提供的 ``key`` 关键字参数。例如::"

#: ../../whatsnew/2.5.rst:1366
msgid ""
">>> import heapq\n"
">>> L = [\"short\", 'medium', 'longest', 'longer still']\n"
">>> heapq.nsmallest(2, L)  # Return two lowest elements, lexicographically\n"
"['longer still', 'longest']\n"
">>> heapq.nsmallest(2, L, key=len)   # Return two shortest elements\n"
"['short', 'medium']"
msgstr ""
">>> import heapq\n"
">>> L = [\"short\", 'medium', 'longest', 'longer still']\n"
">>> heapq.nsmallest(2, L)  # 按字典序返回两个最低的元素\n"
"['longer still', 'longest']\n"
">>> heapq.nsmallest(2, L, key=len)   # 返回两个最短的元素\n"
"['short', 'medium']"

#: ../../whatsnew/2.5.rst:1373 ../../whatsnew/2.5.rst:1382
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1375
msgid ""
"The :func:`itertools.islice` function now accepts ``None`` for the start and"
" step arguments.  This makes it more compatible with the attributes of slice"
" objects, so that you can now write the following::"
msgstr ""
":func:`itertools.islice` 函数现在接受 ``None`` 作为 start 和 step "
"参数。这使得它与切片对象的属性更加兼容，因此你现在可以编写以下代码::"

#: ../../whatsnew/2.5.rst:1379
msgid ""
"s = slice(5)     # Create slice object\n"
"itertools.islice(iterable, s.start, s.stop, s.step)"
msgstr ""
"s = slice(5)     # 创建切片对象\n"
"itertools.islice(iterable, s.start, s.stop, s.step)"

#: ../../whatsnew/2.5.rst:1384
msgid ""
"The :func:`format` function in the :mod:`locale` module has been modified "
"and two new functions were added, :func:`format_string` and "
":func:`currency`."
msgstr ""
":mod:`locale` 模块中的 :func:`format` 函数已被修改，并添加了两个新函数 :func:`format_string` 和 "
":func:`currency`。"

#: ../../whatsnew/2.5.rst:1387
msgid ""
"The :func:`format` function's *val* parameter could previously be a string "
"as long as no more than one %char specifier appeared; now the parameter must"
" be exactly one %char specifier with no surrounding text.  An optional "
"*monetary* parameter was also added which, if ``True``, will use the "
"locale's rules for formatting currency in placing a separator between groups"
" of three digits."
msgstr ""
":func:`format` 函数的 *val* 参数之前可以是字符串，只要不超过一个 %char 指定符；现在该参数必须正好是一个 %char "
"指定符，且周围没有文本。还添加了一个可选的 *monetary* 参数，如果为 "
"``True``，将使用区域设置的规则来格式化货币，在每三位数字之间放置分隔符。"

#: ../../whatsnew/2.5.rst:1393
msgid ""
"To format strings with multiple %char specifiers, use the new "
":func:`format_string` function that works like :func:`format` but also "
"supports mixing %char specifiers with arbitrary text."
msgstr ""
"要格式化带有多个 %char 指定符的字符串，请使用新的 :func:`format_string` 函数，它类似于 "
":func:`format`，但还支持将 %char 指定符与任意文本混合。"

#: ../../whatsnew/2.5.rst:1397
msgid ""
"A new :func:`currency` function was also added that formats a number "
"according to the current locale's settings."
msgstr "还添加了一个新的 :func:`currency` 函数，用于根据当前区域设置的规则格式化数字。"

#: ../../whatsnew/2.5.rst:1400
msgid "(Contributed by Georg Brandl.)"
msgstr "（由Georg Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:1404
msgid ""
"The :mod:`mailbox` module underwent a massive rewrite to add the capability "
"to modify mailboxes in addition to reading them.  A new set of classes that "
"include :class:`mbox`, :class:`MH`, and :class:`Maildir` are used to read "
"mailboxes, and have an ``add(message)`` method to add messages, "
"``remove(key)`` to remove messages, and :meth:`lock`/:meth:`unlock` to "
"lock/unlock the mailbox. The following example converts a maildir-format "
"mailbox into an mbox-format one::"
msgstr ""
":mod:`mailbox` 模块进行了大规模重写，以增加修改邮箱的能力，除了读取邮箱。一组新的类，包括 "
":class:`mbox`、:class:`MH` 和 :class:`Maildir`，用于读取邮箱，并具有 ``add(message)`` "
"方法来添加消息，``remove(key)`` 来删除消息，以及 :meth:`lock`/:meth:`unlock` 来锁定/解锁邮箱。以下示例将 "
"maildir 格式的邮箱转换为 mbox 格式的一个::"

#: ../../whatsnew/2.5.rst:1412
msgid ""
"import mailbox\n"
"\n"
"# 'factory=None' uses email.Message.Message as the class representing\n"
"# individual messages.\n"
"src = mailbox.Maildir('maildir', factory=None)\n"
"dest = mailbox.mbox('/tmp/mbox')\n"
"\n"
"for msg in src:\n"
"    dest.add(msg)"
msgstr ""
"import mailbox\n"
"\n"
"# 'factory=None' 使用 email.Message.Message 作为表示\n"
"# 单个消息的类。\n"
"src = mailbox.Maildir('maildir', factory=None)\n"
"dest = mailbox.mbox('/tmp/mbox')\n"
"\n"
"for msg in src:\n"
"    dest.add(msg)"

#: ../../whatsnew/2.5.rst:1422
msgid ""
"(Contributed by Gregory K. Johnson.  Funding was provided by Google's 2005 "
"Summer of Code.)"
msgstr "（由 Gregory K. Johnson 贡献。资金由 Google 的 2005 年夏季代码计划提供。）"

#: ../../whatsnew/2.5.rst:1425
msgid ""
"New module: the :mod:`!msilib` module allows creating Microsoft Installer "
":file:`.msi` files and CAB files.  Some support for reading the :file:`.msi`"
" database is also included. (Contributed by Martin von Löwis.)"
msgstr ""
"新模块：:mod:`!msilib` 模块允许创建 Microsoft Installer :file:`.msi` 文件和 CAB "
"文件。还包括一些对读取 :file:`.msi` 数据库的支持。（由 Martin von Löwis 贡献。）"

#: ../../whatsnew/2.5.rst:1429
msgid ""
"The :mod:`!nis` module now supports accessing domains other than the system "
"default domain by supplying a *domain* argument to the :func:`!nis.match` "
"and :func:`!nis.maps` functions. (Contributed by Ben Bell.)"
msgstr ""
":mod:`!nis` 模块现在支持通过向 :func:`!nis.match` 和 :func:`!nis.maps` 函数提供 *domain* "
"参数来访问除系统默认域之外的其他域。（由 Ben Bell 贡献。）"

#: ../../whatsnew/2.5.rst:1433
msgid ""
"The :mod:`operator` module's :func:`itemgetter`  and :func:`attrgetter` "
"functions now support multiple fields.   A call such as "
"``operator.attrgetter('a', 'b')`` will return a function  that retrieves the"
" :attr:`a` and :attr:`b` attributes.  Combining  this new feature with the "
":meth:`sort` method's ``key`` parameter  lets you easily sort lists using "
"multiple fields. (Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`operator` 模块的 :func:`itemgetter` 和 :func:`attrgetter` 函数现在支持多个字段。例如，调用"
" ``operator.attrgetter('a', 'b')`` 将返回一个函数，该函数检索 :attr:`a` 和 :attr:`b` "
"属性。结合这一新特性与 :meth:`sort` 方法的 ``key`` 参数，可以轻松地使用多个字段对列表进行排序。（由 Raymond "
"Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1440
msgid ""
"The :mod:`optparse` module was updated to version 1.5.1 of the Optik "
"library. The :class:`OptionParser` class gained an :attr:`epilog` attribute,"
" a string that will be printed after the help message, and a :meth:`destroy`"
" method to break reference cycles created by the object. (Contributed by "
"Greg Ward.)"
msgstr ""
":mod:`optparse` 模块已更新至 Optik 库的 1.5.1 版本。:class:`OptionParser` 类新增了 "
":attr:`epilog` 属性，该字符串将在帮助信息后打印，并添加了 :meth:`destroy` 方法以打破对象创建的引用循环。（由 Greg "
"Ward 贡献。）"

#: ../../whatsnew/2.5.rst:1445
msgid ""
"The :mod:`os` module underwent several changes.  The "
":attr:`stat_float_times` variable now defaults to true, meaning that "
":func:`os.stat` will now return time values as floats.  (This doesn't "
"necessarily mean that :func:`os.stat` will return times that are precise to "
"fractions of a second; not all systems support such precision.)"
msgstr ""
":mod:`os` 模块进行了多项更改。:attr:`stat_float_times` 变量现在默认为 true，意味着 "
":func:`os.stat` 现在将返回浮点数的时间值。（这并不一定意味着 :func:`os.stat` "
"返回的时间精确到秒的小数部分；并非所有系统都支持这种精度。）"

#: ../../whatsnew/2.5.rst:1451
msgid ""
"Constants named :const:`os.SEEK_SET`, :const:`os.SEEK_CUR`, and "
":const:`os.SEEK_END` have been added; these are the parameters to the "
":func:`os.lseek` function.  Two new constants for locking are "
":const:`os.O_SHLOCK` and :const:`os.O_EXLOCK`."
msgstr ""
"已添加名为 :const:`os.SEEK_SET`、:const:`os.SEEK_CUR` 和 :const:`os.SEEK_END` "
"的常量；这些是 :func:`os.lseek` 函数的参数。用于锁定的两个新常量是 :const:`os.O_SHLOCK` 和 "
":const:`os.O_EXLOCK`。"

#: ../../whatsnew/2.5.rst:1456
msgid ""
"Two new functions, :func:`wait3` and :func:`wait4`, were added.  They're "
"similar the :func:`waitpid` function which waits for a child process to exit"
" and returns a tuple of the process ID and its exit status, but "
":func:`wait3` and :func:`wait4` return additional information.  "
":func:`wait3` doesn't take a process ID as input, so it waits for any child "
"process to exit and returns a 3-tuple of *process-id*, *exit-status*, "
"*resource-usage* as returned from the :func:`resource.getrusage` function. "
"``wait4(pid)`` does take a process ID. (Contributed by Chad J. Schroeder.)"
msgstr ""
"新增了两个函数 :func:`wait3` 和 :func:`wait4`。它们类似于 :func:`waitpid` "
"函数，该函数等待子进程退出并返回进程 ID 和其退出状态的元组，但 :func:`wait3` 和 :func:`wait4` "
"返回额外的信息。:func:`wait3` 不接受进程 ID 作为输入，因此它等待任何子进程退出并返回一个 3 元组，包括 *process-"
"id*、*exit-status* 和 *resource-usage*，这些信息由 :func:`resource.getrusage` "
"函数返回。``wait4(pid)`` 接受进程 ID。（由 Chad J. Schroeder 贡献。）"

#: ../../whatsnew/2.5.rst:1465
msgid ""
"On FreeBSD, the :func:`os.stat` function now returns  times with nanosecond "
"resolution, and the returned object now has :attr:`st_gen` and "
":attr:`st_birthtime`. The :attr:`st_flags` attribute is also available, if "
"the platform supports it. (Contributed by Antti Louko and  Diego Pettenò.)"
msgstr ""
"在FreeBSD上，:func:`os.stat` 函数现在返回具有纳秒分辨率的时间，并且返回的对象现在具有 :attr:`st_gen` 和 "
":attr:`st_birthtime`。如果平台支持，:attr:`st_flags` 属性也可用。（由 Antti Louko 和 Diego "
"Pettenò 贡献。）"

#: ../../whatsnew/2.5.rst:1472
msgid ""
"The Python debugger provided by the :mod:`pdb` module can now store lists of"
" commands to execute when a breakpoint is reached and execution stops.  Once"
" breakpoint #1 has been created, enter ``commands 1`` and enter a series of "
"commands to be executed, finishing the list with ``end``.  The command list "
"can include commands that resume execution, such as ``continue`` or "
"``next``. (Contributed by Grégoire Dooms.)"
msgstr ""
":mod:`pdb` 模块提供的 Python 调试器现在可以存储一系列命令，当达到断点并停止执行时执行这些命令。一旦创建了断点 #1，输入 "
"``commands 1`` 并输入一系列要执行的命令，最后用 ``end`` 结束列表。命令列表可以包括恢复执行的命令，例如 ``continue``"
" 或 ``next``。（由 Grégoire Dooms 贡献。）"

#: ../../whatsnew/2.5.rst:1481
msgid ""
"The :mod:`pickle` and :mod:`!cPickle` modules no longer accept a return "
"value of ``None`` from the :meth:`~object.__reduce__` method; the method "
"must return a tuple of arguments instead.  The ability to return ``None`` "
"was deprecated in Python 2.4, so this completes the removal of the feature."
msgstr ""
":mod:`pickle` 和 :mod:`!cPickle` 模块不再接受 :meth:`~object.__reduce__` 方法返回的 "
"``None`` 值；该方法必须返回一个参数元组。在 Python 2.4 中已经弃用了返回 ``None`` 的能力，因此这完成了该特性的移除。"

#: ../../whatsnew/2.5.rst:1486
msgid ""
"The :mod:`pkgutil` module, containing various utility functions for finding "
"packages, was enhanced to support :pep:`302`'s import hooks and now also "
"works for packages stored in ZIP-format archives. (Contributed by Phillip J."
" Eby.)"
msgstr ""
"包含用于查找包的各种实用函数的 :mod:`pkgutil` 模块得到了增强，现在支持 :pep:`302` 的导入钩子，并且也适用于存储在 ZIP "
"格式存档中的包。（由 Phillip J. Eby 贡献。）"

#: ../../whatsnew/2.5.rst:1490
msgid ""
"The pybench benchmark suite by Marc-André Lemburg is now included in the "
":file:`Tools/pybench` directory.  The pybench suite is an improvement on the"
" commonly used :file:`pystone.py` program because pybench provides a more "
"detailed measurement of the interpreter's speed.  It times particular "
"operations such as function calls, tuple slicing, method lookups, and "
"numeric operations, instead of performing many different operations and "
"reducing the result to a single number as :file:`pystone.py` does."
msgstr ""
"Marc-André Lemburg 的 pybench 基准测试套件现在包含在 :file:`Tools/pybench` 目录中。pybench "
"套件是对常用 :file:`pystone.py` 程序的改进，因为 pybench "
"提供了对解释器速度的更详细测量。它计时特定操作，如函数调用、元组切片、方法查找和数值操作，而不是执行许多不同操作并将结果简化为一个数字，就像 "
":file:`pystone.py` 所做的那样。"

#: ../../whatsnew/2.5.rst:1498
msgid ""
"The :mod:`pyexpat` module now uses version 2.0 of the Expat parser. "
"(Contributed by Trent Mick.)"
msgstr ":mod:`pyexpat` 模块现在使用 Expat 解析器的 2.0 版。 （由 Trent Mick 贡献。）"

#: ../../whatsnew/2.5.rst:1501
msgid ""
"The :class:`~queue.Queue` class provided by the :mod:`Queue` module gained "
"two new methods.  :meth:`join` blocks until all items in the queue have been"
" retrieved and all processing work on the items  have been completed.  "
"Worker threads call the other new method,  :meth:`task_done`, to signal that"
" processing for an item has been completed.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":class:`~queue.Queue` 类由 :mod:`Queue` 模块提供，新增了两个方法。:meth:`join` "
"方法会阻塞，直到队列中的所有项都被检索并且所有项的处理工作都已完成。工作线程调用另一个新方法 "
":meth:`task_done`，以表示某个项的处理已完成。（由 Raymond Hettinger 贡献。）"

#: ../../whatsnew/2.5.rst:1507
msgid ""
"The old :mod:`regex` and :mod:`regsub` modules, which have been  deprecated "
"ever since Python 2.0, have finally been deleted.   Other deleted modules: "
":mod:`statcache`, :mod:`tzparse`, :mod:`whrandom`."
msgstr ""
"自 Python 2.0 以来已被弃用的旧 :mod:`regex` 和 :mod:`regsub` "
"模块终于被删除。其他被删除的模块包括：:mod:`statcache`、:mod:`tzparse`、:mod:`whrandom`。"

#: ../../whatsnew/2.5.rst:1511
msgid ""
"Also deleted: the :file:`lib-old` directory, which includes ancient modules "
"such as :mod:`dircmp` and :mod:`ni`, was removed.  :file:`lib-old` wasn't on"
" the default ``sys.path``, so unless your programs explicitly added the "
"directory to ``sys.path``, this removal shouldn't affect your code."
msgstr ""
"同样被删除的还有 :file:`lib-old` 目录，该目录包含古老的模块如 :mod:`dircmp` 和 "
":mod:`ni`，已被移除。:file:`lib-old` 不在默认的 ``sys.path`` 中，因此除非你的程序显式将该目录添加到 "
"``sys.path``，否则此移除不应影响你的代码。"

#: ../../whatsnew/2.5.rst:1516
msgid ""
"The :mod:`rlcompleter` module is no longer  dependent on importing the "
":mod:`readline` module and therefore now works on non-Unix platforms. (Patch"
" from Robert Kiendl.)"
msgstr ""
":mod:`rlcompleter` 模块不再依赖于导入 :mod:`readline` 模块，因此现在可以在非 Unix 平台上工作。（由 "
"Robert Kiendl 提供的补丁。）"

#: ../../whatsnew/2.5.rst:1522
msgid ""
"The :mod:`SimpleXMLRPCServer <xmlrpc.server>` and :mod:`DocXMLRPCServer "
"<xmlrpc.server>`  classes now have a :attr:`rpc_paths` attribute that "
"constrains XML-RPC operations to a limited set of URL paths; the default is "
"to allow only ``'/'`` and ``'/RPC2'``.  Setting :attr:`rpc_paths` to "
"``None`` or an empty tuple disables  this path checking."
msgstr ""
":mod:`SimpleXMLRPCServer <xmlrpc.server>` 和 :mod:`DocXMLRPCServer "
"<xmlrpc.server>` 类现在有一个 :attr:`rpc_paths` 属性，该属性将 XML-RPC 操作限制在一组有限的 URL "
"路径上；默认情况下只允许 ``'/'`` 和 ``'/RPC2'``。将 :attr:`rpc_paths` 设置为 ``None`` "
"或一个空元组将禁用此路径检查。"

#: ../../whatsnew/2.5.rst:1529
msgid ""
"The :mod:`socket` module now supports :const:`AF_NETLINK` sockets on Linux, "
"thanks to a patch from Philippe Biondi.   Netlink sockets are a Linux-"
"specific mechanism for communications between a user-space process and "
"kernel code; an introductory  article about them is at "
"https://www.linuxjournal.com/article/7356. In Python code, netlink addresses"
" are represented as a tuple of 2 integers, ``(pid, group_mask)``."
msgstr ""
"由于 Philippe Biondi 提供的补丁，:mod:`socket` 模块现在在 Linux 上支持 :const:`AF_NETLINK` "
"套接字。Netlink 套接字是 Linux 特有的用户空间进程与内核代码之间的通信机制；关于它们的入门文章位于 "
"https://www.linuxjournal.com/article/7356。在 Python 代码中，netlink 地址表示为两个整数的元组 "
"``(pid, group_mask)``。"

#: ../../whatsnew/2.5.rst:1536
msgid ""
"Two new methods on socket objects, ``recv_into(buffer)`` and "
"``recvfrom_into(buffer)``, store the received data in an object  that "
"supports the buffer protocol instead of returning the data as a string.  "
"This means you can put the data directly into an array or a memory-mapped "
"file."
msgstr ""
"套接字对象上的两个新方法 ``recv_into(buffer)`` 和 ``recvfrom_into(buffer)`` "
"将接收到的数据存储在支持缓冲区协议的对象中，而不是将数据作为字符串返回。这意味着你可以直接将数据放入数组或内存映射文件中。"

#: ../../whatsnew/2.5.rst:1541
msgid ""
"Socket objects also gained :meth:`getfamily`, :meth:`gettype`, and "
":meth:`getproto` accessor methods to retrieve the family, type, and protocol"
" values for the socket."
msgstr ""
"套接字对象还增加了 :meth:`getfamily`、:meth:`gettype` 和 :meth:`getproto` "
"访问器方法，用于检索套接字的族、类型和协议值。"

#: ../../whatsnew/2.5.rst:1545
msgid ""
"New module: the :mod:`!spwd` module provides functions for accessing the "
"shadow password database on systems that support  shadow passwords."
msgstr "新模块：:mod:`!spwd` 模块提供了在支持阴影密码的系统上访问阴影密码数据库的函数。"

#: ../../whatsnew/2.5.rst:1548
msgid ""
"The :mod:`struct` is now faster because it  compiles format strings into "
":class:`Struct` objects with :meth:`pack` and :meth:`unpack` methods.  This "
"is similar to how the :mod:`re` module lets you create compiled regular "
"expression objects.  You can still use the module-level  :func:`pack` and "
":func:`unpack` functions; they'll create  :class:`Struct` objects and cache "
"them.  Or you can use  :class:`Struct` instances directly::"
msgstr ""
":mod:`struct` 模块现在更快了，因为它将格式字符串编译成带有 :meth:`pack` 和 :meth:`unpack` 方法的 "
":class:`Struct` 对象。这类似于 :mod:`re` 模块允许你创建编译后的正则表达式对象。你仍然可以使用模块级的 "
":func:`pack` 和 :func:`unpack` 函数；它们会创建并缓存 :class:`Struct` 对象。或者你可以直接使用 "
":class:`Struct` 实例::"

#: ../../whatsnew/2.5.rst:1555
msgid ""
"s = struct.Struct('ih3s')\n"
"\n"
"data = s.pack(1972, 187, 'abc')\n"
"year, number, name = s.unpack(data)"
msgstr ""
"s = struct.Struct('ih3s')\n"
"\n"
"data = s.pack(1972, 187, 'abc')\n"
"year, number, name = s.unpack(data)"

#: ../../whatsnew/2.5.rst:1560
msgid ""
"You can also pack and unpack data to and from buffer objects directly using "
"the ``pack_into(buffer, offset, v1, v2, ...)`` and ``unpack_from(buffer, "
"offset)`` methods.  This lets you store data directly into an array or a "
"memory-mapped file."
msgstr ""
"你还可以使用 ``pack_into(buffer, offset, v1, v2, ...)`` 和 ``unpack_from(buffer, "
"offset)`` 方法直接将数据打包和解包到缓冲区对象。这允许你直接将数据存储到数组或内存映射文件中。"

#: ../../whatsnew/2.5.rst:1565
msgid ""
"(:class:`Struct` objects were implemented by Bob Ippolito at the "
"NeedForSpeed sprint.  Support for buffer objects was added by Martin Blais, "
"also at the NeedForSpeed sprint.)"
msgstr ""
"(:class:`Struct` 对象由 Bob Ippolito 在 NeedForSpeed sprint 中实现。缓冲区对象的支持由 Martin"
" Blais 在同一 sprint 中添加)"

#: ../../whatsnew/2.5.rst:1569
msgid ""
"The Python developers switched from CVS to Subversion during the 2.5 "
"development process.  Information about the exact build version is available"
" as the ``sys.subversion`` variable, a 3-tuple of ``(interpreter-name, "
"branch-name, revision-range)``.  For example, at the time of writing my copy"
" of 2.5 was reporting ``('CPython', 'trunk', '45313:45315')``."
msgstr ""
"Python 开发者在 2.5 开发过程中从 CVS 切换到了 Subversion。关于确切构建版本的信息可通过 ``sys.subversion``"
" 变量获取，这是一个包含 ``(解释器名称, 分支名称, 修订范围)`` 的 3 元组。例如，在撰写本文时，我的 2.5 版本报告为 "
"``('CPython', 'trunk', '45313:45315')``。"

#: ../../whatsnew/2.5.rst:1575
msgid ""
"This information is also available to C extensions via the "
":c:func:`Py_GetBuildInfo` function that returns a  string of build "
"information like this: ``\"trunk:45355:45356M, Apr 13 2006, 07:42:19\"``.   "
"(Contributed by Barry Warsaw.)"
msgstr ""
"此信息也可通过 :c:func:`Py_GetBuildInfo` 函数供 C "
"扩展使用，该函数返回一个构建信息字符串，例如：``\"trunk:45355:45356M, Apr 13 2006, 07:42:19\"``。 (由"
" Barry Warsaw 贡献)"

#: ../../whatsnew/2.5.rst:1580
msgid ""
"Another new function, :func:`sys._current_frames`, returns the current stack"
" frames for all running threads as a dictionary mapping thread identifiers "
"to the topmost stack frame currently active in that thread at the time the "
"function is called.  (Contributed by Tim Peters.)"
msgstr ""
"另一个新函数 :func:`sys._current_frames` "
"返回所有运行线程的当前堆栈帧，作为一个字典，将线程标识符映射到在函数调用时该线程中当前活动的最顶层堆栈帧。 (由 Tim Peters 贡献)"

#: ../../whatsnew/2.5.rst:1585
msgid ""
"The :class:`TarFile` class in the :mod:`tarfile` module now has an "
":meth:`extractall` method that extracts all members from the archive into "
"the current working directory.  It's also possible to set a different "
"directory as the extraction target, and to unpack only a subset of the "
"archive's members."
msgstr ""
":mod:`tarfile` 模块中的 :class:`TarFile` 类现在有一个 :meth:`extractall` "
"方法，用于将存档中的所有成员提取到当前工作目录。还可以设置不同的目录作为提取目标，并且可以仅解包存档的一部分成员。"

#: ../../whatsnew/2.5.rst:1590
msgid ""
"The compression used for a tarfile opened in stream mode can now be "
"autodetected using the mode ``'r|*'``. (Contributed by Lars Gustäbel.)"
msgstr "以流模式打开的 tarfile 的压缩方式现在可以通过模式 ``'r|*'`` 自动检测。 (由 Lars Gustäbel 贡献)"

#: ../../whatsnew/2.5.rst:1595
msgid ""
"The :mod:`threading` module now lets you set the stack size used when new "
"threads are created. The ``stack_size([*size*])`` function returns the "
"currently configured stack size, and supplying the optional *size* parameter"
" sets a new value.  Not all platforms support changing the stack size, but "
"Windows, POSIX threading, and OS/2 all do. (Contributed by Andrew "
"MacIntyre.)"
msgstr ""
":mod:`threading` 模块现在允许你设置创建新线程时使用的堆栈大小。``stack_size([*size*])`` "
"函数返回当前配置的堆栈大小，提供可选的 *size* 参数设置新值。并非所有平台都支持更改堆栈大小，但 Windows、POSIX 线程和 OS/2 "
"都支持。 (由 Andrew MacIntyre 贡献)"

#: ../../whatsnew/2.5.rst:1603
msgid ""
"The :mod:`unicodedata` module has been updated to use version 4.1.0 of the "
"Unicode character database.  Version 3.2.0 is required  by some "
"specifications, so it's still available as  :data:`unicodedata.ucd_3_2_0`."
msgstr ""
":mod:`unicodedata` 模块已更新为使用 Unicode 字符数据库的 4.1.0 版本。某些规范需要 3.2.0 版本，因此它仍然作为 "
":data:`unicodedata.ucd_3_2_0` 可用。"

#: ../../whatsnew/2.5.rst:1607
msgid ""
"New module: the  :mod:`uuid` module generates  universally unique "
"identifiers (UUIDs) according to :rfc:`4122`.  The RFC defines several "
"different UUID versions that are generated from a starting string, from "
"system properties, or purely randomly.  This module contains a :class:`UUID`"
" class and  functions named :func:`uuid1`, :func:`uuid3`, :func:`uuid4`,  "
"and  :func:`uuid5` to generate different versions of UUID.  (Version 2 UUIDs"
"  are not specified in :rfc:`4122` and are not supported by this module.) ::"
msgstr ""
"新模块：:mod:`uuid` 模块根据 :rfc:`4122` "
"生成通用唯一标识符（UUID）。该RFC定义了从起始字符串、系统属性或纯随机生成的几种不同版本的UUID。此模块包含一个 :class:`UUID` "
"类和名为 :func:`uuid1`、:func:`uuid3`、:func:`uuid4` 和 :func:`uuid5` "
"的函数，用于生成不同版本的UUID。（版本2的UUID在 :rfc:`4122` 中未指定，此模块也不支持。）::"

#: ../../whatsnew/2.5.rst:1615
msgid ""
">>> import uuid\n"
">>> # make a UUID based on the host ID and current time\n"
">>> uuid.uuid1()\n"
"UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')\n"
"\n"
">>> # make a UUID using an MD5 hash of a namespace UUID and a name\n"
">>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')\n"
"UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')\n"
"\n"
">>> # make a random UUID\n"
">>> uuid.uuid4()\n"
"UUID('16fd2706-8baf-433b-82eb-8c7fada847da')\n"
"\n"
">>> # make a UUID using a SHA-1 hash of a namespace UUID and a name\n"
">>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')\n"
"UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')"
msgstr ""
">>> import uuid\n"
">>> # 基于主机ID和当前时间生成一个UUID\n"
">>> uuid.uuid1()\n"
"UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')\n"
"\n"
">>> # 使用命名空间UUID和名称的MD5哈希生成一个UUID\n"
">>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')\n"
"UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')\n"
"\n"
">>> # 生成一个随机UUID\n"
">>> uuid.uuid4()\n"
"UUID('16fd2706-8baf-433b-82eb-8c7fada847da')\n"
"\n"
">>> # 使用命名空间UUID和名称的SHA-1哈希生成一个UUID\n"
">>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')\n"
"UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')"

#: ../../whatsnew/2.5.rst:1632
msgid "(Contributed by Ka-Ping Yee.)"
msgstr "（由 Ka-Ping Yee 贡献。）"

#: ../../whatsnew/2.5.rst:1634
msgid ""
"The :mod:`weakref` module's :class:`WeakKeyDictionary` and "
":class:`WeakValueDictionary` types gained new methods for iterating over the"
" weak references contained in the dictionary.  :meth:`iterkeyrefs` and "
":meth:`keyrefs` methods were added to :class:`WeakKeyDictionary`, and "
":meth:`itervaluerefs` and :meth:`valuerefs` were added to "
":class:`WeakValueDictionary`.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
":mod:`weakref` 模块的 :class:`WeakKeyDictionary` 和 :class:`WeakValueDictionary`"
" 类型新增了用于迭代字典中包含的弱引用的方法。:class:`WeakKeyDictionary` 添加了 :meth:`iterkeyrefs` 和 "
":meth:`keyrefs` 方法，:class:`WeakValueDictionary` 添加了 :meth:`itervaluerefs` 和 "
":meth:`valuerefs` 方法。（由Fred L. Drake, Jr.贡献）"

#: ../../whatsnew/2.5.rst:1641
msgid ""
"The :mod:`webbrowser` module received a number of enhancements. It's now "
"usable as a script with ``python -m webbrowser``, taking a URL as the "
"argument; there are a number of switches  to control the behaviour "
"(:option:`!-n` for a new browser window,  :option:`!-t` for a new tab).  New"
" module-level functions, :func:`open_new` and :func:`open_new_tab`, were "
"added  to support this.  The module's :func:`open` function supports an "
"additional feature, an *autoraise* parameter that signals whether to raise "
"the open window when possible. A number of additional browsers were added to"
" the supported list such as Firefox, Opera, Konqueror, and elinks.  "
"(Contributed by Oleg Broytmann and Georg Brandl.)"
msgstr ""
":mod:`webbrowser` 模块获得了一系列增强。现在可以作为脚本使用，通过 ``python -m webbrowser`` 命令，并接受一个"
" URL 作为参数；还有多个开关用于控制行为（:option:`!-n` 用于新浏览器窗口，:option:`!-t` 用于新标签页）。新增了模块级函数"
" :func:`open_new` 和 :func:`open_new_tab` 以支持这些功能。模块的 :func:`open` "
"函数支持一个额外特性，即 *autoraise* 参数，用于指示是否在可能的情况下提升打开的窗口。支持列表中新增了多种浏览器，如 "
"Firefox、Opera、Konqueror 和 elinks。（由 Oleg Broytmann 和 Georg Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:1653
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module now supports returning  "
":class:`~datetime.datetime` objects for the XML-RPC date type.  Supply  "
"``use_datetime=True`` to the :func:`~xmlrpc.client.loads` function or the "
":class:`!Unmarshaller` class to enable this feature. (Contributed by Skip "
"Montanaro.)"
msgstr ""
":mod:`xmlrpclib <xmlrpc.client>` 模块现在支持将 XML-RPC 日期类型返回为 "
":class:`~datetime.datetime` 对象。在 :func:`~xmlrpc.client.loads` 函数或 "
":class:`!Unmarshaller` 类中提供 ``use_datetime=True`` 以启用此功能。（由 Skip Montanaro "
"贡献。）"

#: ../../whatsnew/2.5.rst:1660
msgid ""
"The :mod:`zipfile` module now supports the ZIP64 version of the  format, "
"meaning that a .zip archive can now be larger than 4 GiB and can contain "
"individual files larger than 4 GiB.  (Contributed by Ronald Oussoren.)"
msgstr ""
":mod:`zipfile` 模块现在支持 ZIP64 版本的格式，意味着 .zip 归档文件现在可以大于 4 GiB，并且可以包含大于 4 GiB "
"的单个文件。（由 Ronald Oussoren 贡献。）"

#: ../../whatsnew/2.5.rst:1666
msgid ""
"The :mod:`zlib` module's :class:`Compress` and :class:`Decompress` objects "
"now support a :meth:`copy` method that makes a copy of the  object's "
"internal state and returns a new  :class:`Compress` or :class:`Decompress` "
"object. (Contributed by Chris AtLee.)"
msgstr ""
":mod:`zlib` 模块的 :class:`Compress` 和 :class:`Decompress` 对象现在支持 :meth:`copy` "
"方法，该方法复制对象的内部状态并返回一个新的 :class:`Compress` 或 :class:`Decompress` 对象。（由 Chris "
"AtLee 贡献。）"

#: ../../whatsnew/2.5.rst:1679
msgid "The ctypes package"
msgstr "ctypes 包"

#: ../../whatsnew/2.5.rst:1681
msgid ""
"The :mod:`ctypes` package, written by Thomas Heller, has been added  to the "
"standard library.  :mod:`ctypes` lets you call arbitrary functions  in "
"shared libraries or DLLs.  Long-time users may remember the :mod:`!dl` "
"module, which provides functions for loading shared libraries and calling "
"functions in them. The :mod:`ctypes` package is much fancier."
msgstr ""
"由 Thomas Heller 编写的 :mod:`ctypes` 包已被添加到标准库中。:mod:`ctypes` 允许你调用共享库或 DLL "
"中的任意函数。长期用户可能还记得 :mod:`!dl` 模块，它提供了加载共享库和调用其中函数的功能。:mod:`ctypes` 包则更为高级。"

#: ../../whatsnew/2.5.rst:1687
msgid ""
"To load a shared library or DLL, you must create an instance of the "
":class:`CDLL` class and provide the name or path of the shared library or "
"DLL. Once that's done, you can call arbitrary functions by accessing them as"
" attributes of the :class:`CDLL` object.   ::"
msgstr ""
"要加载共享库或 DLL，你必须创建一个 :class:`CDLL` 类的实例，并提供共享库或 DLL 的名称或路径。 一旦完成这一步，你可以通过将其作为"
" :class:`CDLL` 对象的属性来调用任意函数。 ::"

#: ../../whatsnew/2.5.rst:1692
msgid ""
"import ctypes\n"
"\n"
"libc = ctypes.CDLL('libc.so.6')\n"
"result = libc.printf(\"Line of output\\n\")"
msgstr ""
"import ctypes\n"
"\n"
"libc = ctypes.CDLL('libc.so.6')\n"
"result = libc.printf(\"Line of output\\n\")"

#: ../../whatsnew/2.5.rst:1697
msgid ""
"Type constructors for the various C types are provided: :func:`c_int`, "
":func:`c_float`, :func:`c_double`, :func:`c_char_p` (equivalent to "
":c:expr:`char \\*`), and so forth.  Unlike Python's types, the C versions "
"are all mutable; you can assign to their :attr:`value` attribute to change "
"the wrapped value.  Python integers and strings will be automatically "
"converted to the corresponding C types, but for other types you  must call "
"the correct type constructor.  (And I mean *must*;  getting it wrong will "
"often result in the interpreter crashing with a segmentation fault.)"
msgstr ""
"为各种 C 类型提供了类型构造器: "
":func:`c_int`，:func:`c_float`，:func:`c_double`，:func:`c_char_p` (等同于 "
":c:expr:`char \\*`)，等等。 与 Python 的类型不同，C 版本的类型都是可变的；你可以通过赋值给它们的 "
":attr:`value` 属性来改变包装的值。 Python 整数和字符串将自动转换为相应的 C 类型，但对于其他类型，你必须调用正确的类型构造器。 "
"（我强调的是 *必须*；弄错了通常会导致解释器崩溃，出现段错误。）"

#: ../../whatsnew/2.5.rst:1706
msgid ""
"You shouldn't use :func:`c_char_p` with a Python string when the C function "
"will be modifying the memory area, because Python strings are  supposed to "
"be immutable; breaking this rule will cause puzzling bugs.  When you need a "
"modifiable memory area, use :func:`create_string_buffer`::"
msgstr ""
"当 C 函数将修改内存区域时，你不应使用 :func:`c_char_p` 与 Python 字符串，因为 Python "
"字符串应该是不可变的；违反这一规则将导致令人困惑的 bug。 当你需要一个可修改的内存区域时，请使用 "
":func:`create_string_buffer`::"

#: ../../whatsnew/2.5.rst:1711
msgid ""
"s = \"this is a string\"\n"
"buf = ctypes.create_string_buffer(s)\n"
"libc.strfry(buf)"
msgstr ""
"s = \"this is a string\"\n"
"buf = ctypes.create_string_buffer(s)\n"
"libc.strfry(buf)"

#: ../../whatsnew/2.5.rst:1715
msgid ""
"C functions are assumed to return integers, but you can set the "
":attr:`restype` attribute of the function object to  change this::"
msgstr "C 函数默认返回整数，但你可以通过设置函数对象的 :attr:`restype` 属性来改变这一点::"

#: ../../whatsnew/2.5.rst:1718
msgid ""
">>> libc.atof('2.71828')\n"
"-1783957616\n"
">>> libc.atof.restype = ctypes.c_double\n"
">>> libc.atof('2.71828')\n"
"2.71828"
msgstr ""
">>> libc.atof('2.71828')\n"
"-1783957616\n"
">>> libc.atof.restype = ctypes.c_double\n"
">>> libc.atof('2.71828')\n"
"2.71828"

#: ../../whatsnew/2.5.rst:1724
msgid ""
":mod:`ctypes` also provides a wrapper for Python's C API  as the "
"``ctypes.pythonapi`` object.  This object does *not*  release the global "
"interpreter lock before calling a function, because the lock must be held "
"when calling into the interpreter's code.   There's a "
":class:`~ctypes.py_object` type constructor that will create a  "
":c:expr:`PyObject *` pointer.  A simple usage::"
msgstr ""
":mod:`ctypes` 还提供了一个 Python C API 的包装器，即 ``ctypes.pythonapi`` 对象。 "
"这个对象在调用函数之前 *不* 释放全局解释器锁，因为调用解释器代码时必须持有该锁。 有一个 :class:`~ctypes.py_object` "
"类型构造器，它将创建一个 :c:expr:`PyObject *` 指针。 一个简单的用法::"

#: ../../whatsnew/2.5.rst:1730
msgid ""
"import ctypes\n"
"\n"
"d = {}\n"
"ctypes.pythonapi.PyObject_SetItem(ctypes.py_object(d),\n"
"          ctypes.py_object(\"abc\"),  ctypes.py_object(1))\n"
"# d is now {'abc', 1}."
msgstr ""
"import ctypes\n"
"\n"
"d = {}\n"
"ctypes.pythonapi.PyObject_SetItem(ctypes.py_object(d),\n"
"          ctypes.py_object(\"abc\"),  ctypes.py_object(1))\n"
"# d 现在是 {'abc', 1}。"

#: ../../whatsnew/2.5.rst:1737
msgid ""
"Don't forget to use :func:`~ctypes.py_object`; if it's omitted you end  up "
"with a segmentation fault."
msgstr "不要忘记使用 :func:`~ctypes.py_object`；如果省略它，你最终会遇到段错误。"

#: ../../whatsnew/2.5.rst:1740
msgid ""
":mod:`ctypes` has been around for a while, but people still write  and "
"distribution hand-coded extension modules because you can't rely on "
":mod:`ctypes` being present. Perhaps developers will begin to write  Python "
"wrappers atop a library accessed through :mod:`ctypes` instead of extension "
"modules, now that :mod:`ctypes` is included with core Python."
msgstr ""
":mod:`ctypes` 已经存在一段时间了，但人们仍然编写和分发手工编码的扩展模块，因为不能依赖 :mod:`ctypes` "
"的存在。也许开发者们现在会开始编写基于通过 :mod:`ctypes` 访问的库的 Python 包装器，而不是扩展模块，因为 "
":mod:`ctypes` 已经包含在核心 Python 中。"

#: ../../whatsnew/2.5.rst:1749
msgid ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/"
msgstr ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/"

#: ../../whatsnew/2.5.rst:1750
msgid "The pre-stdlib ctypes web page, with a tutorial, reference, and FAQ."
msgstr "预标准库 ctypes 的网页，包含教程、参考和常见问题解答。"

#: ../../whatsnew/2.5.rst:1752
msgid "The documentation  for the :mod:`ctypes` module."
msgstr ":mod:`ctypes` 模块的文档。"

#: ../../whatsnew/2.5.rst:1760
msgid "The ElementTree package"
msgstr "ElementTree 包"

#: ../../whatsnew/2.5.rst:1762
msgid ""
"A subset of Fredrik Lundh's ElementTree library for processing XML has been "
"added to the standard library as :mod:`xml.etree`.  The available modules "
"are :mod:`ElementTree`, :mod:`ElementPath`, and :mod:`ElementInclude` from "
"ElementTree 1.2.6.    The :mod:`cElementTree` accelerator module is also "
"included."
msgstr ""
"Fredrik Lundh 的 ElementTree 库的一个子集，用于处理 XML，已被添加到标准库中作为 "
":mod:`xml.etree`。可用的模块包括从 ElementTree 1.2.6 中的 "
":mod:`ElementTree`、:mod:`ElementPath` 和 "
":mod:`ElementInclude`。:mod:`cElementTree` 加速模块也包括在内。"

#: ../../whatsnew/2.5.rst:1768
msgid ""
"The rest of this section will provide a brief overview of using ElementTree."
" Full documentation for ElementTree is available at "
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm."
msgstr ""
"本节的剩余部分将提供使用 ElementTree 的简要说明。 要获取 ElementTree 的完整文档可访问 "
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm。"

#: ../../whatsnew/2.5.rst:1772
msgid ""
"ElementTree represents an XML document as a tree of element nodes. The text "
"content of the document is stored as the :attr:`text` and :attr:`tail` "
"attributes of  (This is one of the major differences between ElementTree and"
" the Document Object Model; in the DOM there are many different types of "
"node, including :class:`TextNode`.)"
msgstr ""
"ElementTree 将 XML 文档表示为元素节点的树。文档的文本内容存储为 (这是 ElementTree 和文档对象模型之间的主要区别之一；在 "
"DOM 中有许多不同类型的节点，包括 :class:`TextNode`。) 的 :attr:`text` 和 :attr:`tail` 属性。"

#: ../../whatsnew/2.5.rst:1778
msgid ""
"The most commonly used parsing function is :func:`parse`, that takes either "
"a string (assumed to contain a filename) or a file-like object and returns "
"an :class:`ElementTree` instance::"
msgstr ""
"最常用的解析函数是 :func:`parse`，它接受一个字符串（假设包含文件名）或文件类对象，并返回一个 :class:`ElementTree` "
"实例::"

#: ../../whatsnew/2.5.rst:1782
msgid ""
"from xml.etree import ElementTree as ET\n"
"\n"
"tree = ET.parse('ex-1.xml')\n"
"\n"
"feed = urllib.urlopen(\n"
"          'http://planet.python.org/rss10.xml')\n"
"tree = ET.parse(feed)"
msgstr ""
"from xml.etree import ElementTree as ET\n"
"\n"
"tree = ET.parse('ex-1.xml')\n"
"\n"
"feed = urllib.urlopen(\n"
"          'http://planet.python.org/rss10.xml')\n"
"tree = ET.parse(feed)"

#: ../../whatsnew/2.5.rst:1790
msgid ""
"Once you have an :class:`ElementTree` instance, you can call its "
":meth:`getroot` method to get the root :class:`Element` node."
msgstr ""
"一旦你有一个 :class:`ElementTree` 实例，你可以调用它的 :meth:`getroot` 方法来获取根 "
":class:`Element` 节点。"

#: ../../whatsnew/2.5.rst:1793
msgid ""
"There's also an :func:`XML` function that takes a string literal and returns"
" an :class:`Element` node (not an :class:`ElementTree`).   This function "
"provides a tidy way to incorporate XML fragments, approaching the "
"convenience of an XML literal::"
msgstr ""
"还有一个 :func:`XML` 函数，它接受一个字符串字面量并返回一个 :class:`Element` 节点（而不是 "
":class:`ElementTree`）。这个函数提供了一种整洁的方式来整合 XML 片段，接近于 XML 字面量的便利性::"

#: ../../whatsnew/2.5.rst:1798
msgid ""
"svg = ET.XML(\"\"\"<svg width=\"10px\" version=\"1.0\">\n"
"             </svg>\"\"\")\n"
"svg.set('height', '320px')\n"
"svg.append(elem1)"
msgstr ""
"svg = ET.XML(\"\"\"<svg width=\"10px\" version=\"1.0\">\n"
"             </svg>\"\"\")\n"
"svg.set('height', '320px')\n"
"svg.append(elem1)"

#: ../../whatsnew/2.5.rst:1803
msgid ""
"Each XML element supports some dictionary-like and some list-like access "
"methods.  Dictionary-like operations are used to access attribute values, "
"and list-like operations are used to access child nodes."
msgstr "每个 XML 元素都支持一些类似字典和类似列表的访问方法。类似字典的操作用于访问属性值，而类似列表的操作用于访问子节点。"

#: ../../whatsnew/2.5.rst:1808
msgid "Operation"
msgstr "运算"

#: ../../whatsnew/2.5.rst:1808
msgid "Result"
msgstr "结果："

#: ../../whatsnew/2.5.rst:1810
msgid "``elem[n]``"
msgstr "``elem[n]``"

#: ../../whatsnew/2.5.rst:1810
msgid "Returns n'th child element."
msgstr "返回第n个子元素。"

#: ../../whatsnew/2.5.rst:1812
msgid "``elem[m:n]``"
msgstr "``elem[m:n]``"

#: ../../whatsnew/2.5.rst:1812
msgid "Returns list of m'th through n'th child elements."
msgstr "返回第m至第n个子元素的列表。"

#: ../../whatsnew/2.5.rst:1815
msgid "``len(elem)``"
msgstr "``len(elem)``"

#: ../../whatsnew/2.5.rst:1815
msgid "Returns number of child elements."
msgstr "返回子元素的个数。"

#: ../../whatsnew/2.5.rst:1817
msgid "``list(elem)``"
msgstr "``list(elem)``"

#: ../../whatsnew/2.5.rst:1817
msgid "Returns list of child elements."
msgstr "返回子元素的列表。"

#: ../../whatsnew/2.5.rst:1819
msgid "``elem.append(elem2)``"
msgstr "``elem.append(elem2)``"

#: ../../whatsnew/2.5.rst:1819
msgid "Adds *elem2* as a child."
msgstr "将 *elem2* 添加为子级。"

#: ../../whatsnew/2.5.rst:1821
msgid "``elem.insert(index, elem2)``"
msgstr "``elem.insert(index, elem2)``"

#: ../../whatsnew/2.5.rst:1821
msgid "Inserts *elem2* at the specified location."
msgstr "在指定位置插入 *elem2* 。"

#: ../../whatsnew/2.5.rst:1823
msgid "``del elem[n]``"
msgstr "``del elem[n]``"

#: ../../whatsnew/2.5.rst:1823
msgid "Deletes n'th child element."
msgstr "删除第n个子元素。"

#: ../../whatsnew/2.5.rst:1825
msgid "``elem.keys()``"
msgstr "``elem.keys()``"

#: ../../whatsnew/2.5.rst:1825
msgid "Returns list of attribute names."
msgstr "返回属性名称的列表。"

#: ../../whatsnew/2.5.rst:1827
msgid "``elem.get(name)``"
msgstr "``elem.get(name)``"

#: ../../whatsnew/2.5.rst:1827
msgid "Returns value of attribute *name*."
msgstr "返回 *name* 属性的值。"

#: ../../whatsnew/2.5.rst:1829
msgid "``elem.set(name, value)``"
msgstr "``elem.set(name, value)``"

#: ../../whatsnew/2.5.rst:1829
msgid "Sets new value for attribute *name*."
msgstr "为 *name* 属性设置新值。"

#: ../../whatsnew/2.5.rst:1831
msgid "``elem.attrib``"
msgstr "``elem.attrib``"

#: ../../whatsnew/2.5.rst:1831
msgid "Retrieves the dictionary containing attributes."
msgstr "检索包含属性的字典。"

#: ../../whatsnew/2.5.rst:1834
msgid "``del elem.attrib[name]``"
msgstr "``del elem.attrib[name]``"

#: ../../whatsnew/2.5.rst:1834
msgid "Deletes attribute *name*."
msgstr "删除 *name* 属性。"

#: ../../whatsnew/2.5.rst:1837
msgid ""
"Comments and processing instructions are also represented as "
":class:`Element` nodes.  To check if a node is a comment or processing "
"instructions::"
msgstr "注释和处理指令也被表示为 :class:`Element` 节点。要检查一个节点是否是注释或处理指令::"

#: ../../whatsnew/2.5.rst:1840
msgid ""
"if elem.tag is ET.Comment:\n"
"    ...\n"
"elif elem.tag is ET.ProcessingInstruction:\n"
"    ..."
msgstr ""
"if elem.tag is ET.Comment:\n"
"    ...\n"
"elif elem.tag is ET.ProcessingInstruction:\n"
"    ..."

#: ../../whatsnew/2.5.rst:1845
msgid ""
"To generate XML output, you should call the :meth:`ElementTree.write` "
"method. Like :func:`parse`, it can take either a string or a file-like "
"object::"
msgstr ""
"要生成 XML 输出，你应该调用 :meth:`ElementTree.write` 方法。与 :func:`parse` "
"类似，它可以接受一个字符串或类文件对象::"

#: ../../whatsnew/2.5.rst:1848
msgid ""
"# Encoding is US-ASCII\n"
"tree.write('output.xml')\n"
"\n"
"# Encoding is UTF-8\n"
"f = open('output.xml', 'w')\n"
"tree.write(f, encoding='utf-8')"
msgstr ""
"# 编码为 US-ASCII\n"
"tree.write('output.xml')\n"
"\n"
"# 编码为 UTF-8\n"
"f = open('output.xml', 'w')\n"
"tree.write(f, encoding='utf-8')"

#: ../../whatsnew/2.5.rst:1855
msgid ""
"(Caution: the default encoding used for output is ASCII.  For general XML "
"work, where an element's name may contain arbitrary Unicode characters, "
"ASCII isn't a very useful encoding because it will raise an exception if an "
"element's name contains any characters with values greater than 127.  "
"Therefore, it's best to specify a different encoding such as UTF-8 that can "
"handle any Unicode character.)"
msgstr ""
"（注意：输出使用的默认编码是 ASCII。对于一般的 XML 工作，元素的名称可能包含任意 Unicode 字符，ASCII "
"不是一个很有用的编码，因为它会在元素的名称包含任何值大于 127 的字符时引发异常。因此，最好指定一个不同的编码，如 UTF-8，它可以处理任何 "
"Unicode 字符。）"

#: ../../whatsnew/2.5.rst:1862
msgid ""
"This section is only a partial description of the ElementTree interfaces. "
"Please read the package's official documentation for more details."
msgstr "本节仅是对 ElementTree 接口的部分描述。请阅读包的官方文档以获取更多详细信息。"

#: ../../whatsnew/2.5.rst:1868
msgid ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"
msgstr ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"

#: ../../whatsnew/2.5.rst:1869
msgid "Official documentation for ElementTree."
msgstr "ElementTree 的官方文档。"

#: ../../whatsnew/2.5.rst:1877
msgid "The hashlib package"
msgstr "hashlib 包"

#: ../../whatsnew/2.5.rst:1879
msgid ""
"A new :mod:`hashlib` module, written by Gregory P. Smith,  has been added to"
" replace the :mod:`!md5` and :mod:`!sha` modules.  :mod:`hashlib` adds "
"support for additional secure hashes (SHA-224, SHA-256, SHA-384, and "
"SHA-512). When available, the module uses OpenSSL for fast platform "
"optimized implementations of algorithms."
msgstr ""
"由 Gregory P. Smith 编写的一个新的 :mod:`hashlib` 模块已被添加，以取代 :mod:`!md5` 和 "
":mod:`!sha` 模块。:mod:`hashlib` 添加了对额外安全哈希（SHA-224、SHA-256、SHA-384 和 "
"SHA-512）的支持。当可用时，该模块使用 OpenSSL 以实现算法的快速平台优化实现。"

#: ../../whatsnew/2.5.rst:1885
msgid ""
"The old :mod:`!md5` and :mod:`!sha` modules still exist as wrappers around "
"hashlib to preserve backwards compatibility.  The new module's interface is "
"very close to that of the old modules, but not identical. The most "
"significant difference is that the constructor functions for creating new "
"hashing objects are named differently. ::"
msgstr ""
"旧的 :mod:`!md5` 和 :mod:`!sha` 模块仍然存在，作为 hashlib "
"的包装器以保持向后兼容性。新模块的接口与旧模块非常接近，但不完全相同。最显著的区别是用于创建新哈希对象的构造函数命名不同。::"

#: ../../whatsnew/2.5.rst:1891
msgid ""
"# Old versions\n"
"h = md5.md5()\n"
"h = md5.new()\n"
"\n"
"# New version\n"
"h = hashlib.md5()\n"
"\n"
"# Old versions\n"
"h = sha.sha()\n"
"h = sha.new()\n"
"\n"
"# New version\n"
"h = hashlib.sha1()\n"
"\n"
"# Hash that weren't previously available\n"
"h = hashlib.sha224()\n"
"h = hashlib.sha256()\n"
"h = hashlib.sha384()\n"
"h = hashlib.sha512()\n"
"\n"
"# Alternative form\n"
"h = hashlib.new('md5')          # Provide algorithm as a string"
msgstr ""
"# 旧版本\n"
"h = md5.md5()\n"
"h = md5.new()\n"
"\n"
"# 新版本\n"
"h = hashlib.md5()\n"
"\n"
"# 旧版本\n"
"h = sha.sha()\n"
"h = sha.new()\n"
"\n"
"# 新版本\n"
"h = hashlib.sha1()\n"
"\n"
"# 以前不可用的哈希\n"
"h = hashlib.sha224()\n"
"h = hashlib.sha256()\n"
"h = hashlib.sha384()\n"
"h = hashlib.sha512()\n"
"\n"
"# 备选形式\n"
"h = hashlib.new('md5')          # 以字符串形式提供算法"

#: ../../whatsnew/2.5.rst:1914
msgid ""
"Once a hash object has been created, its methods are the same as before: "
"``update(string)`` hashes the specified string into the  current digest "
"state, :meth:`digest` and :meth:`hexdigest` return the digest value as a "
"binary string or a string of hex digits, and :meth:`copy` returns a new "
"hashing object with the same digest state."
msgstr ""
"一旦创建了哈希对象，其方法与之前相同：``update(string)`` 将指定的字符串哈希到当前摘要状态，:meth:`digest` 和 "
":meth:`hexdigest` 分别以二进制字符串或十六进制数字字符串返回摘要值，:meth:`copy` 返回一个具有相同摘要状态的新哈希对象。"

#: ../../whatsnew/2.5.rst:1923
msgid "The documentation  for the :mod:`hashlib` module."
msgstr ":mod:`hashlib` 模块的文档。"

#: ../../whatsnew/2.5.rst:1931
msgid "The sqlite3 package"
msgstr "sqlite3 包"

#: ../../whatsnew/2.5.rst:1933
msgid ""
"The pysqlite module (https://www.pysqlite.org), a wrapper for the SQLite "
"embedded database, has been added to the standard library under the package "
"name :mod:`sqlite3`."
msgstr ""
"pysqlite 模块（https://www.pysqlite.org），作为 SQLite 嵌入式数据库的包装器，已被添加到标准库中，包名为 "
":mod:`sqlite3`。"

#: ../../whatsnew/2.5.rst:1937
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../whatsnew/2.5.rst:1944
msgid ""
"pysqlite was written by Gerhard Häring and provides a SQL interface "
"compliant with the DB-API 2.0 specification described by :pep:`249`."
msgstr ""
"pysqlite 由 Gerhard Häßling 编写，提供了一个符合 :pep:`249` 描述的 DB-API 2.0 规范的 SQL 接口。"

#: ../../whatsnew/2.5.rst:1947
msgid ""
"If you're compiling the Python source yourself, note that the source tree "
"doesn't include the SQLite code, only the wrapper module. You'll need to "
"have the SQLite libraries and headers installed before compiling Python, and"
" the build process will compile the module when the necessary headers are "
"available."
msgstr ""
"如果你自己编译 Python 源代码，请注意源代码树不包含 SQLite 代码，只包含封装模块。在编译 Python 之前，你需要安装 SQLite "
"库和头文件，当必要的头文件可用时，编译过程将编译模块。"

#: ../../whatsnew/2.5.rst:1952
msgid ""
"To use the module, you must first create a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the "
":file:`/tmp/example` file::"
msgstr ""
"要使用该模块，你必须首先创建一个表示数据库的 :class:`Connection` 对象。这里数据将存储在 :file:`/tmp/example` "
"文件中::"

#: ../../whatsnew/2.5.rst:1956
msgid "conn = sqlite3.connect('/tmp/example')"
msgstr "conn = sqlite3.connect('/tmp/example')"

#: ../../whatsnew/2.5.rst:1958
msgid ""
"You can also supply the special name ``:memory:`` to create a database in "
"RAM."
msgstr "你也可以使用 ``:memory:`` 来创建一个内存中的数据库。"

#: ../../whatsnew/2.5.rst:1960
msgid ""
"Once you have a :class:`Connection`, you can create a :class:`Cursor`  "
"object and call its :meth:`execute` method to perform SQL commands::"
msgstr ""
"一旦你有了 :class:`Connection`，你可以创建一个 :class:`Cursor` 对象并调用其 :meth:`execute` "
"方法来执行 SQL 命令::"

#: ../../whatsnew/2.5.rst:1963
msgid ""
"c = conn.cursor()\n"
"\n"
"# Create table\n"
"c.execute('''create table stocks\n"
"(date text, trans text, symbol text,\n"
" qty real, price real)''')\n"
"\n"
"# Insert a row of data\n"
"c.execute(\"\"\"insert into stocks\n"
"          values ('2006-01-05','BUY','RHAT',100,35.14)\"\"\")"
msgstr ""
"c = conn.cursor()\n"
"\n"
"# 创建表\n"
"c.execute('''create table stocks\n"
"(date text, trans text, symbol text,\n"
" qty real, price real)''')\n"
"\n"
"# 插入一行数据\n"
"c.execute(\"\"\"insert into stocks\n"
"          values ('2006-01-05','BUY','RHAT',100,35.14)\"\"\")"

#: ../../whatsnew/2.5.rst:1974
msgid ""
"Usually your SQL operations will need to use values from Python variables.  "
"You shouldn't assemble your query using Python's string operations because "
"doing so is insecure; it makes your program vulnerable to an SQL injection "
"attack."
msgstr ""
"通常，你的 SQL 操作需要使用来自 Python 变量的值。  你不应该使用 Python "
"的字符串操作来组装你的查询，因为这样做是不安全的，它会使你的程序容易受到 SQL 注入攻击。"

#: ../../whatsnew/2.5.rst:1978
msgid ""
"Instead, use the DB-API's parameter substitution.  Put ``?`` as a "
"placeholder wherever you want to use a value, and then provide a tuple of "
"values as the second argument to the cursor's :meth:`execute` method.  "
"(Other database modules may use a different placeholder, such as ``%s`` or "
"``:1``.) For example::"
msgstr ""
"Instead, use the DB-API's parameter substitution. Put ``?`` as a placeholder"
" wherever you want to use a value, and then provide a tuple of values as the"
" second argument to the cursor's :meth:`execute` method. (Other database "
"modules may use a different placeholder, such as ``%s`` or ``:1``.) For "
"example::"

#: ../../whatsnew/2.5.rst:1983
msgid ""
"# Never do this -- insecure!\n"
"symbol = 'IBM'\n"
"c.execute(\"... where symbol = '%s'\" % symbol)\n"
"\n"
"# Do this instead\n"
"t = (symbol,)\n"
"c.execute('select * from stocks where symbol=?', t)\n"
"\n"
"# Larger example\n"
"for t in (('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n"
"          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n"
"          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n"
"         ):\n"
"    c.execute('insert into stocks values (?,?,?,?,?)', t)"
msgstr ""
"# Never do this -- insecure!\n"
"symbol = 'IBM'\n"
"c.execute(\"... where symbol = '%s'\" % symbol)\n"
"\n"
"# Do this instead\n"
"t = (symbol,)\n"
"c.execute('select * from stocks where symbol=?', t)\n"
"\n"
"# Larger example\n"
"for t in (('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n"
"          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n"
"          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n"
"         ):\n"
"    c.execute('insert into stocks values (?,?,?,?,?)', t)"

#: ../../whatsnew/2.5.rst:1998
msgid ""
"To retrieve data after executing a SELECT statement, you can either  treat "
"the cursor as an iterator, call the cursor's :meth:`fetchone` method to "
"retrieve a single matching row,  or call :meth:`fetchall` to get a list of "
"the matching rows."
msgstr ""
"To retrieve data after executing a SELECT statement, you can either treat "
"the cursor as an iterator, call the cursor's :meth:`fetchone` method to "
"retrieve a single matching row, or call :meth:`fetchall` to get a list of "
"the matching rows."

#: ../../whatsnew/2.5.rst:2003
msgid "This example uses the iterator form::"
msgstr "下面是一个使用迭代器形式的例子："

#: ../../whatsnew/2.5.rst:2005
msgid ""
">>> c = conn.cursor()\n"
">>> c.execute('select * from stocks order by price')\n"
">>> for row in c:\n"
"...    print row\n"
"...\n"
"(u'2006-01-05', u'BUY', u'RHAT', 100, 35.140000000000001)\n"
"(u'2006-03-28', u'BUY', u'IBM', 1000, 45.0)\n"
"(u'2006-04-06', u'SELL', u'IBM', 500, 53.0)\n"
"(u'2006-04-05', u'BUY', u'MSOFT', 1000, 72.0)\n"
">>>"
msgstr ""
">>> c = conn.cursor()\n"
">>> c.execute('select * from stocks order by price')\n"
">>> for row in c:\n"
"...    print row\n"
"...\n"
"(u'2006-01-05', u'BUY', u'RHAT', 100, 35.140000000000001)\n"
"(u'2006-03-28', u'BUY', u'IBM', 1000, 45.0)\n"
"(u'2006-04-06', u'SELL', u'IBM', 500, 53.0)\n"
"(u'2006-04-05', u'BUY', u'MSOFT', 1000, 72.0)\n"
">>>"

#: ../../whatsnew/2.5.rst:2016
msgid ""
"For more information about the SQL dialect supported by SQLite, see "
"https://www.sqlite.org."
msgstr "有关 SQLite 所支持的 SQL 方法的更多信息，请参阅 https://www.sqlite.org。"

#: ../../whatsnew/2.5.rst:2022
msgid "https://www.pysqlite.org"
msgstr "https://www.pysqlite.org"

#: ../../whatsnew/2.5.rst:2023
msgid "The pysqlite web page."
msgstr "pysqlite 的主页。"

#: ../../whatsnew/2.5.rst:2025
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../whatsnew/2.5.rst:2026
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../whatsnew/2.5.rst:2029
msgid "The documentation  for the :mod:`sqlite3` module."
msgstr ":mod:`sqlite3` 模块的文档。"

#: ../../whatsnew/2.5.rst:2031
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../whatsnew/2.5.rst:2032
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰写。"

#: ../../whatsnew/2.5.rst:2040
msgid "The wsgiref package"
msgstr "wsgiref 包"

#: ../../whatsnew/2.5.rst:2042
msgid ""
"The Web Server Gateway Interface (WSGI) v1.0 defines a standard interface "
"between web servers and Python web applications and is described in "
":pep:`333`. The :mod:`wsgiref` package is a reference implementation of the "
"WSGI specification."
msgstr ""
"The Web Server Gateway Interface (WSGI) v1.0 defines a standard interface "
"between web servers and Python web applications and is described in "
":pep:`333`. The :mod:`wsgiref` package is a reference implementation of the "
"WSGI specification."

#: ../../whatsnew/2.5.rst:2049
msgid ""
"The package includes a basic HTTP server that will run a WSGI application; "
"this server is useful for debugging but isn't intended for  production use."
"  Setting up a server takes only a few lines of code::"
msgstr "该软件包包含一个基本 HTTP 服务器，可运行 WSGI 应用程序；该服务器可用于调试，但不打算用于生产环境。设置服务器只需几行代码："

#: ../../whatsnew/2.5.rst:2053
msgid ""
"from wsgiref import simple_server\n"
"\n"
"wsgi_app = ...\n"
"\n"
"host = ''\n"
"port = 8000\n"
"httpd = simple_server.make_server(host, port, wsgi_app)\n"
"httpd.serve_forever()"
msgstr ""
"from wsgiref import simple_server\n"
"\n"
"wsgi_app = ...\n"
"\n"
"host = ''\n"
"port = 8000\n"
"httpd = simple_server.make_server(host, port, wsgi_app)\n"
"httpd.serve_forever()"

#: ../../whatsnew/2.5.rst:2068
msgid ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/"
msgstr ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/"

#: ../../whatsnew/2.5.rst:2069
msgid "A central web site for WSGI-related resources."
msgstr "WSGI相关资源的核心网站。"

#: ../../whatsnew/2.5.rst:2071
msgid ":pep:`333` - Python Web Server Gateway Interface v1.0"
msgstr ":pep:`333` - Python Web服务器网关接口 v1.0"

#: ../../whatsnew/2.5.rst:2072
msgid "PEP written by Phillip J. Eby."
msgstr "PEP 由 Phillip J. Eby 撰写。"

#: ../../whatsnew/2.5.rst:2080
msgid "Build and C API Changes"
msgstr "构建和 C API 的改变"

#: ../../whatsnew/2.5.rst:2082
msgid "Changes to Python's build process and to the C API include:"
msgstr "针对 Python 构建过程和 C API 的改变包括:"

#: ../../whatsnew/2.5.rst:2084
msgid ""
"The Python source tree was converted from CVS to Subversion,  in a complex "
"migration procedure that was supervised and flawlessly carried out by Martin"
" von Löwis.  The procedure was developed as :pep:`347`."
msgstr ""
"The Python source tree was converted from CVS to Subversion, in a complex "
"migration procedure that was supervised and flawlessly carried out by Martin"
" von Löwis. The procedure was developed as :pep:`347`."

#: ../../whatsnew/2.5.rst:2088
msgid ""
"Coverity, a company that markets a source code analysis tool called Prevent,"
" provided the results of their examination of the Python source code.  The "
"analysis found about 60 bugs that  were quickly fixed.  Many of the bugs "
"were refcounting problems, often occurring in error-handling code.  See "
"https://scan.coverity.com for the statistics."
msgstr ""
"Coverity 公司，一家销售名为 Prevent 的源代码分析工具的公司，提供了他们对 Python 源代码的检查结果。分析发现了大约 60 个 "
"bug，这些 bug 很快就被修复了。许多 bug 是引用计数问题，通常出现在错误处理代码中。请参阅 https://scan.coverity.com"
" 了解统计数据。"

#: ../../whatsnew/2.5.rst:2094
msgid ""
"The largest change to the C API came from :pep:`353`, which modifies the "
"interpreter to use a :c:type:`Py_ssize_t` type definition instead of "
":c:expr:`int`.  See the earlier section :ref:`pep-353` for a discussion of "
"this change."
msgstr ""
"C API 最大的变化来自 :pep:`353`，该提案修改了解释器，使其使用 :c:type:`Py_ssize_t` 类型定义而不是 "
":c:expr:`int`。请参阅之前的章节 :ref:`pep-353` 了解对此变化的讨论。"

#: ../../whatsnew/2.5.rst:2099
msgid ""
"The design of the bytecode compiler has changed a great deal,  no longer "
"generating bytecode by traversing the parse tree.  Instead the parse tree is"
" converted to an abstract syntax tree (or AST), and it is  the abstract "
"syntax tree that's traversed to produce the bytecode."
msgstr ""
"字节码编译器的设计发生了很大变化，不再通过遍历解析树来生成字节码。相反，解析树被转换为抽象语法树（AST），然后遍历抽象语法树来生成字节码。"

#: ../../whatsnew/2.5.rst:2104
msgid ""
"It's possible for Python code to obtain AST objects by using the "
":func:`compile` built-in and specifying ``_ast.PyCF_ONLY_AST`` as the value "
"of the  *flags* parameter::"
msgstr ""
"Python 代码可以通过使用内置的 :func:`compile` 函数并指定 ``_ast.PyCF_ONLY_AST`` 作为 *flags* "
"参数的值来获取 AST 对象::"

#: ../../whatsnew/2.5.rst:2108
msgid ""
"from _ast import PyCF_ONLY_AST\n"
"ast = compile(\"\"\"a=0\n"
"for i in range(10):\n"
"    a += i\n"
"\"\"\", \"<string>\", 'exec', PyCF_ONLY_AST)\n"
"\n"
"assignment = ast.body[0]\n"
"for_loop = ast.body[1]"
msgstr ""
"from _ast import PyCF_ONLY_AST\n"
"ast = compile(\"\"\"a=0\n"
"for i in range(10):\n"
"    a += i\n"
"\"\"\", \"<string>\", 'exec', PyCF_ONLY_AST)\n"
"\n"
"assignment = ast.body[0]\n"
"for_loop = ast.body[1]"

#: ../../whatsnew/2.5.rst:2117
msgid ""
"No official documentation has been written for the AST code yet, but "
":pep:`339` discusses the design.  To start learning about the code, read the"
" definition of the various AST nodes in :file:`Parser/Python.asdl`.  A "
"Python script reads this file and generates a set of C structure definitions"
" in :file:`Include/Python-ast.h`.  The :c:func:`PyParser_ASTFromString` and "
":c:func:`!PyParser_ASTFromFile`, defined in :file:`Include/pythonrun.h`, "
"take Python source as input and return the root of an AST representing the "
"contents. This AST can then be turned into a code object by "
":c:func:`!PyAST_Compile`.  For more information, read the source code, and "
"then ask questions on python-dev."
msgstr ""
"目前还没有为 AST 代码编写官方文档，但 :pep:`339` 讨论了其设计。要开始了解代码，请阅读 "
":file:`Parser/Python.asdl` 中各种 AST 节点的定义。一个 Python 脚本读取此文件并在 "
":file:`Include/Python-ast.h` 中生成一组 C 结构定义。在 :file:`Include/pythonrun.h` 中定义的"
" :c:func:`PyParser_ASTFromString` 和 :c:func:`!PyParser_ASTFromFile` 函数以 "
"Python 源代码作为输入，返回表示内容的 AST 的根节点。这个 AST 可以通过 :c:func:`!PyAST_Compile` "
"转换为代码对象。更多信息请阅读源代码，然后在 python-dev 上提问。"

#: ../../whatsnew/2.5.rst:2127
msgid ""
"The AST code was developed under Jeremy Hylton's management, and implemented"
" by (in alphabetical order) Brett Cannon, Nick Coghlan, Grant Edwards, John "
"Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo, and Neil "
"Schemenauer, plus the participants in a number of AST sprints at conferences"
" such as PyCon."
msgstr ""
"AST 代码在 Jeremy Hylton 的管理下开发，并由（按字母顺序）Brett Cannon、Nick Coghlan、Grant "
"Edwards、John Ehresman、Kurt Kaiser、Neal Norwitz、Tim Peters、Armin Rigo 和 Neil "
"Schemenauer 实现，此外还有在 PyCon 等会议上多次 AST 短暂冲刺的参与者。"

#: ../../whatsnew/2.5.rst:2136
msgid ""
"Evan Jones's patch to obmalloc, first described in a talk at PyCon DC 2005, "
"was applied.  Python 2.4 allocated small objects in 256K-sized arenas, but "
"never freed arenas.  With this patch, Python will free arenas when they're "
"empty.  The net effect is that on some platforms, when you allocate many "
"objects, Python's memory usage may actually drop when you delete them and "
"the memory may be returned to the operating system.  (Implemented by Evan "
"Jones, and reworked by Tim Peters.)"
msgstr ""
"Evan Jones 的 obmalloc 补丁，最初在 PyCon DC 2005 的演讲中描述，已被应用。Python 2.4 在 256K "
"大小的区域中分配小对象，但不释放这些区域。有了这个补丁，Python 将在区域为空时释放它们。净效果是，在某些平台上，当你分配许多对象时，删除这些对象后"
" Python 的内存使用量实际上可能会下降，并且内存可能会返回给操作系统。（由 Evan Jones 实现，Tim Peters 重构。）"

#: ../../whatsnew/2.5.rst:2144
msgid ""
"Note that this change means extension modules must be more careful when "
"allocating memory.  Python's API has many different functions for allocating"
" memory that are grouped into families.  For example, "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc`, and :c:func:`PyMem_Free` "
"are one family that allocates raw memory, while :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc`, and :c:func:`PyObject_Free` are another family "
"that's supposed to be used for creating Python objects."
msgstr ""
"请注意，这一变化意味着扩展模块在分配内存时必须更加小心。Python 的 API "
"有许多不同的内存分配函数，这些函数被分组到不同的家族中。例如，:c:func:`PyMem_Malloc`、:c:func:`PyMem_Realloc`"
" 和 :c:func:`PyMem_Free` 是一个家族，用于分配原始内存，而 "
":c:func:`PyObject_Malloc`、:c:func:`PyObject_Realloc` 和 "
":c:func:`PyObject_Free` 是另一个家族，用于创建 Python 对象。"

#: ../../whatsnew/2.5.rst:2152
msgid ""
"Previously these different families all reduced to the platform's "
":c:func:`malloc` and :c:func:`free` functions.  This meant  it didn't matter"
" if you got things wrong and allocated memory with the ``PyMem`` function "
"but freed it with the ``PyObject`` function.  With 2.5's changes to "
"obmalloc, these families now do different things and mismatches will "
"probably result in a segfault.  You should carefully test your C extension "
"modules with Python 2.5."
msgstr ""
"以前这些不同的家族都归结为平台的 :c:func:`malloc` 和 :c:func:`free` 函数。这意味着如果你弄错了，用 ``PyMem``"
" 函数分配内存但用 ``PyObject`` 函数释放它，也没关系。随着 2.5 对 obmalloc "
"的更改，这些家族现在执行不同的操作，不匹配可能会导致段错误。你应该仔细测试你的 C 扩展模块与 Python 2.5 的兼容性。"

#: ../../whatsnew/2.5.rst:2159
msgid ""
"The built-in set types now have an official C API.  Call :c:func:`PySet_New`"
" and :c:func:`PyFrozenSet_New` to create a new set, :c:func:`PySet_Add` and "
":c:func:`PySet_Discard` to add and remove elements, and "
":c:func:`PySet_Contains` and :c:func:`PySet_Size` to examine the set's "
"state. (Contributed by Raymond Hettinger.)"
msgstr ""
"内置集合类型现在拥有官方的C API。调用 :c:func:`PySet_New` 和 :c:func:`PyFrozenSet_New` "
"创建新集合，使用 :c:func:`PySet_Add` 和 :c:func:`PySet_Discard` 添加和移除元素，以及使用 "
":c:func:`PySet_Contains` 和 :c:func:`PySet_Size` 检查集合的状态。（由 Raymond Hettinger"
" 贡献。）"

#: ../../whatsnew/2.5.rst:2165
msgid ""
"C code can now obtain information about the exact revision of the Python "
"interpreter by calling the  :c:func:`Py_GetBuildInfo` function that returns "
"a string of build information like this: ``\"trunk:45355:45356M, Apr 13 "
"2006, 07:42:19\"``.   (Contributed by Barry Warsaw.)"
msgstr ""
"C代码现在可以通过调用 :c:func:`Py_GetBuildInfo` "
"函数获取关于Python解释器确切修订版的信息，该函数返回一个包含构建信息的字符串，例如：``\"trunk:45355:45356M, Apr 13 "
"2006, 07:42:19\"``。（由 Barry Warsaw 贡献。）"

#: ../../whatsnew/2.5.rst:2170
msgid ""
"Two new macros can be used to indicate C functions that are local to the "
"current file so that a faster calling convention can be used. "
"``Py_LOCAL(type)`` declares the function as returning a value of the "
"specified *type* and uses a fast-calling qualifier. "
"``Py_LOCAL_INLINE(type)`` does the same thing and also requests the function"
" be inlined.  If macro :c:macro:`!PY_LOCAL_AGGRESSIVE` is defined before "
":file:`python.h` is included, a set of more aggressive optimizations are "
"enabled for the module; you should benchmark the results to find out if "
"these optimizations actually make the code faster.  (Contributed by Fredrik "
"Lundh at the NeedForSpeed sprint.)"
msgstr ""
"两个新宏可用于指示当前文件局部的C函数，以便使用更快的调用约定。``Py_LOCAL(type)`` 声明函数返回指定 *type* "
"类型的值并使用快速调用限定符。``Py_LOCAL_INLINE(type)`` 执行相同操作并请求函数内联。如果在包含 "
":file:`python.h` 之前定义了宏 "
":c:macro:`!PY_LOCAL_AGGRESSIVE`，将为模块启用一组更激进的优化；你应通过基准测试结果来确定这些优化是否确实使代码更快。（由"
" Fredrik Lundh 在 NeedForSpeed sprint 中贡献。）"

#: ../../whatsnew/2.5.rst:2181
msgid ""
"``PyErr_NewException(name, base, dict)`` can now accept a tuple of base "
"classes as its *base* argument.  (Contributed by Georg Brandl.)"
msgstr ""
"``PyErr_NewException(name, base, dict)`` 现在接受一个基类的元组作为其 *base* 参数。（由 Georg "
"Brandl 贡献。）"

#: ../../whatsnew/2.5.rst:2184
msgid ""
"The :c:func:`!PyErr_Warn` function for issuing warnings is now deprecated in"
" favour of ``PyErr_WarnEx(category, message, stacklevel)`` which lets you "
"specify the number of stack frames separating this function and the caller."
"  A *stacklevel* of 1 is the function calling :c:func:`PyErr_WarnEx`, 2 is "
"the function above that, and so forth.  (Added by Neal Norwitz.)"
msgstr ""
"用于发出警告的 :c:func:`!PyErr_Warn` 函数现在已弃用，推荐使用 ``PyErr_WarnEx(category, message,"
" stacklevel)``，它允许你指定此函数与调用者之间的堆栈帧数。*stacklevel* 为1是调用 "
":c:func:`PyErr_WarnEx` 的函数，2是上面的函数，依此类推。（由 Neal Norwitz 添加。）"

#: ../../whatsnew/2.5.rst:2190
msgid ""
"The CPython interpreter is still written in C, but  the code can now be "
"compiled with a C++ compiler without errors.   (Implemented by Anthony "
"Baxter, Martin von Löwis, Skip Montanaro.)"
msgstr ""
"CPython解释器仍然用C编写，但现在代码可以用C++编译器编译而不会出错。（由 Anthony Baxter, Martin von Löwis, "
"Skip Montanaro 实现。）"

#: ../../whatsnew/2.5.rst:2194
msgid ""
"The :c:func:`!PyRange_New` function was removed.  It was never documented, "
"never used in the core code, and had dangerously lax error checking.  In the"
" unlikely case that your extensions were using it, you can replace it by "
"something like the following::"
msgstr ""
":c:func:`!PyRange_New` "
"函数已被移除。该函数从未被文档化，从未在核心代码中使用，且错误检查过于宽松。如果你的不太可能使用的扩展中使用了它，你可以用类似以下代码替换："

#: ../../whatsnew/2.5.rst:2199
msgid ""
"range = PyObject_CallFunction((PyObject*) &PyRange_Type, \"lll\",\n"
"                              start, stop, step);"
msgstr ""
"range = PyObject_CallFunction((PyObject*) &PyRange_Type, \"lll\",\n"
"                              start, stop, step);"

#: ../../whatsnew/2.5.rst:2208
msgid "Port-Specific Changes"
msgstr "移植专属的改变"

#: ../../whatsnew/2.5.rst:2210
msgid ""
"MacOS X (10.3 and higher): dynamic loading of modules now uses the "
":c:func:`dlopen` function instead of MacOS-specific functions."
msgstr ""
"MacOS X (10.3 及更高版本): 模块的动态加载现在会使用 :c:func:`dlopen` 函数而不是 MacOS 专属的函数。"

#: ../../whatsnew/2.5.rst:2213
msgid ""
"MacOS X: an :option:`!--enable-universalsdk` switch was added to the "
":program:`configure` script that compiles the interpreter as a universal "
"binary able to run on both PowerPC and Intel processors. (Contributed by "
"Ronald Oussoren; :issue:`2573`.)"
msgstr ""
"MacOS X：在 :program:`configure` 脚本中添加了 :option:`!--enable-universalsdk` "
"开关，用于编译可在 PowerPC 和 Intel 处理器上运行的通用二进制解释器。（由 Ronald Oussoren "
"贡献；:issue:`2573`。）"

#: ../../whatsnew/2.5.rst:2218
msgid ""
"Windows: :file:`.dll` is no longer supported as a filename extension for "
"extension modules.  :file:`.pyd` is now the only filename extension that "
"will be searched for."
msgstr "Windows：:file:`.dll` 已不再作为扩展模块的文件名扩展支持。现在只搜索 :file:`.pyd` 作为文件名扩展。"

#: ../../whatsnew/2.5.rst:2228
msgid "Porting to Python 2.5"
msgstr "移植到Python 2.5"

#: ../../whatsnew/2.5.rst:2230
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr "本节列出了先前描述的可能需要修改你的代码的改变："

#: ../../whatsnew/2.5.rst:2233
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error."
msgstr ""
"ASCII 现在是模块的默认编码。如果模块包含带有 8 位字符的字符串字面量但没有编码声明，现在会引发语法错误。在 Python 2.4 "
"中，这只会触发警告，而不是语法错误。"

#: ../../whatsnew/2.5.rst:2238
msgid ""
"Previously, the :attr:`gi_frame` attribute of a generator was always a frame"
" object.  Because of the :pep:`342` changes described in section "
":ref:`pep-342`, it's now possible for :attr:`gi_frame` to be ``None``."
msgstr ""
"之前，生成器的 :attr:`gi_frame` 属性总是一个帧对象。由于 :pep:`342` 中描述的变更（见 :ref:`pep-342` "
"部分），现在 :attr:`gi_frame` 有可能为 ``None``。"

#: ../../whatsnew/2.5.rst:2242
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string that can't be converted to "
"Unicode using the default ASCII encoding.  Previously such comparisons would"
" raise a :class:`UnicodeDecodeError` exception."
msgstr ""
"新增警告 :class:`UnicodeWarning`，当你尝试比较一个 Unicode 字符串和一个无法使用默认 ASCII 编码转换为 "
"Unicode 的 8 位字符串时触发。之前这样的比较会引发 :class:`UnicodeDecodeError` 异常。"

#: ../../whatsnew/2.5.rst:2247
msgid ""
"Library: the :mod:`csv` module is now stricter about multi-line quoted "
"fields. If your files contain newlines embedded within fields, the input "
"should be split into lines in a manner which preserves the newline "
"characters."
msgstr "库：:mod:`csv` 模块现在对多行引用字段更为严格。如果你的文件中包含嵌入字段的新行，输入应该以保留新行字符的方式进行拆分。"

#: ../../whatsnew/2.5.rst:2251
msgid ""
"Library: the :mod:`locale` module's  :func:`format` function's would "
"previously  accept any string as long as no more than one %char specifier "
"appeared.  In Python 2.5, the argument must be exactly one %char specifier "
"with no surrounding text."
msgstr ""
"库：:mod:`locale` 模块的 :func:`format` 函数之前会接受任何字符串，只要其中不超过一个 %char 指定符。在 Python"
" 2.5 中，参数必须恰好是一个 %char 指定符，且周围没有文本。"

#: ../../whatsnew/2.5.rst:2256
msgid ""
"Library: The :mod:`pickle` and :mod:`!cPickle` modules no longer accept a "
"return value of ``None`` from the :meth:`~object.__reduce__` method; the "
"method must return a tuple of arguments instead.  The modules also no longer"
" accept the deprecated *bin* keyword parameter."
msgstr ""
"库：:mod:`pickle` 和 :mod:`!cPickle` 模块不再接受 :meth:`~object.__reduce__` 方法返回值为 "
"``None``；该方法必须返回一个参数元组。这些模块也不再接受已弃用的 *bin* 关键字参数。"

#: ../../whatsnew/2.5.rst:2261
msgid ""
"Library: The :mod:`SimpleXMLRPCServer <xmlrpc.server>` and "
":mod:`DocXMLRPCServer <xmlrpc.server>`  classes now have a :attr:`rpc_paths`"
" attribute that constrains XML-RPC operations to a limited set of URL paths;"
" the default is to allow only ``'/'`` and ``'/RPC2'``. Setting  "
":attr:`rpc_paths` to ``None`` or an empty tuple disables  this path "
"checking."
msgstr ""
"库：:mod:`SimpleXMLRPCServer <xmlrpc.server>` 和 :mod:`DocXMLRPCServer "
"<xmlrpc.server>` 类现在有一个 :attr:`rpc_paths` 属性，该属性将 XML-RPC 操作限制在一组有限的 URL "
"路径上；默认情况下只允许 ``'/'`` 和 ``'/RPC2'``。将 :attr:`rpc_paths` 设置为 ``None`` "
"或一个空元组将禁用此路径检查。"

#: ../../whatsnew/2.5.rst:2267
msgid ""
"C API: Many functions now use :c:type:`Py_ssize_t`  instead of :c:expr:`int`"
" to allow processing more data on 64-bit machines.  Extension code may need "
"to make the same change to avoid warnings and to support 64-bit machines.  "
"See the earlier section :ref:`pep-353` for a discussion of this change."
msgstr ""
"C API：许多函数现在使用 :c:type:`Py_ssize_t` 而不是 :c:expr:`int`，以允许在 64 "
"位机器上处理更多数据。扩展代码可能需要做同样的更改，以避免警告并支持 64 位机器。请参阅之前的章节 :ref:`pep-353` "
"了解有关此更改的讨论。"

#: ../../whatsnew/2.5.rst:2272
msgid ""
"C API:  The obmalloc changes mean that  you must be careful to not mix usage"
" of the ``PyMem_*`` and ``PyObject_*`` families of functions. Memory "
"allocated with  one family's ``*_Malloc`` must be  freed with the "
"corresponding family's ``*_Free`` function."
msgstr ""
"C API：obmalloc 的更改意味着你必须小心，不要混合使用 ``PyMem_*`` 和 ``PyObject_*`` 系列函数。使用一个系列的 "
"``*_Malloc`` 分配的内存必须使用相应系列的 ``*_Free`` 函数释放。"

#: ../../whatsnew/2.5.rst:2281
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.5.rst:2283
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars Gustäbel, Raymond "
"Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain Lowe, Martin von "
"Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, Gustavo Niemeyer, "
"Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, Barry Warsaw, Thomas "
"Wouters."
msgstr ""
"作者感谢以下人员对本文各种草稿给予的建议，更正和协助： Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars"
" Gustäbel, Raymond Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain "
"Lowe, Martin von Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, "
"Gustavo Niemeyer, Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, "
"Barry Warsaw, Thomas Wouters."

#: ../../whatsnew/2.5.rst:1342
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../whatsnew/2.5.rst:1342
msgid "What's new"
msgstr "新变化"
