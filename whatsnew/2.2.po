# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "Python 2.2 有什么新变化"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "概述"

#: ../../whatsnew/2.2.rst:15
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 "
"的问题修正发布版，最初发布于 2001 年 12 月 21 日。"

#: ../../whatsnew/2.2.rst:19
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 可以被看作是 \"清理发布版\"。 "
"有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的，都是为了清理语言设计中的不规范和阴暗角落。"

#: ../../whatsnew/2.2.rst:24
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you"
" should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"本文并不试图提供对新特性的完整规范说明，而是提供一个便捷的概览。 要获取全部细节，你应该参阅 Python 2.2 的文档，比如 `Python 库参考"
" <https://docs.python.org/2.2/lib/lib.html>`_ 和 `Python 参考指南 "
"<https://docs.python.org/2.2/ref/ref.html>`_。 "
"如果你想要了解某项更改的完整实现和设计理念，请参阅特定新特性的 PEP。"

#: ../../whatsnew/2.2.rst:43
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 和 253：类型和类的修改"

#: ../../whatsnew/2.2.rst:45
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so"
" it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"Python 2.2 中最大且影响最深远的改变是针对 Python 的对象和类模型。 "
"这些变化应该是向下兼容的，因此你的代码将能继续运行而无需修改，但这些变化提供了一些很棒的新功能。 "
"在开始本文最长和最复杂的部分之前，我提供对这些变化的概览并附带一些注释。"

#: ../../whatsnew/2.2.rst:52
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of"
" the most significant flaws was that it's impossible to subclass Python "
"types implemented in C.  In particular, it's not possible to subclass built-"
"in types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`!UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but"
" there's lots of C code that expects a regular Python list and won't accept "
"a :class:`~collections.UserList` instance."
msgstr ""
"很久以前我写过一个网页来列出 Python 设计中的一些缺陷。 其中一个最明显的缺陷是无法子类化用 C 实现的 Python 类型。 "
"具体来说，内置类型是无法子类化的，例如你不能简单地子类化列表以便向其添加一个有用的方法。 虽然 :mod:`!UserList` "
"模块提供了一个支持所有列表方法的类并且可以进一步子类化，但有很多 C 代码都期望一个常规的 Python 列表而不能接受 "
":class:`~collections.UserList` 实例。"

#: ../../whatsnew/2.2.rst:61
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr "Python 2.2 修正了此问题，并在此过程中添加了一些令人激动的新功能。 简明概述如下:"

#: ../../whatsnew/2.2.rst:64
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr "你可以继承内置类型，例如列表和整数，并且你的子类应该在任何需要原始类型的地方正常工作。这使得 Python 的面向对象编程更加灵活和强大。"

#: ../../whatsnew/2.2.rst:67
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr "现在，除了之前版本的 Python 中可用的实例方法外，还可以定义静态方法和类方法。这使得你可以更灵活地组织类的行为。"

#: ../../whatsnew/2.2.rst:70
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`~object.__getattr__` can be rewritten to use properties "
"instead, making the resulting code simpler and faster.  As a small side "
"benefit, attributes can now have docstrings, too."
msgstr ""
"另一种可能的做法是通过使用名为 :dfn:`特征属性` 的机制在访问或设置实例属性时自动调用方法。 许多 "
":meth:`~object.__getattr__` 的用法可以被重写为改用特征属性，使得结果代码更简单且更快速。 "
"作为一个小小的附带好处，现在属性也可以带有文档字符串。"

#: ../../whatsnew/2.2.rst:76
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr "可以使用 __slots__ 限制实例的合法属性列表，从而防止拼写错误，并且在未来的 Python 版本中可能进行更多的优化。"

#: ../../whatsnew/2.2.rst:80
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the"
" new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being"
" lost."
msgstr ""
"一些用户对这些变化表示担忧。确实，他们说，新功能很棒，可以实现以前版本的 Python "
"无法做到的各种技巧，但它们也使语言变得更加复杂。一些人表示，他们一直推荐 Python 是因为它的简单性，现在感觉这种简单性正在丧失。"

#: ../../whatsnew/2.2.rst:86
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"个人而言，我认为没有必要担心。许多新功能相当深奥，你可以编写大量 Python "
"代码而不需要了解它们。编写一个简单的类并不比以前更难，因此除非确实需要，否则你不必费心去学习或教授这些新功能。一些以前只有在 C "
"语言中才能实现的非常复杂的任务，现在可以用纯 Python 实现，在我看来，这一切都更好了。"

#: ../../whatsnew/2.2.rst:93
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will"
" paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"我不会尝试涵盖所有为了使新功能生效而需要的每一个边缘情况和小改动。相反，本节将只勾勒出大致的轮廓。有关 Python 2.2 "
"新对象模型的更多信息，请参见 :ref:`sect-rellinks` 的“相关链接”部分。"

#: ../../whatsnew/2.2.rst:100
msgid "Old and New Classes"
msgstr "旧式类和新式类"

#: ../../whatsnew/2.2.rst:102
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python."
"  All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"首先，你应该知道 Python 2.2 实际上有两种类型的类：经典类（或旧式类）和新式类。旧式类模型与早期版本的 Python "
"中的类模型完全相同。本节描述的所有新功能仅适用于新式类。这种分歧并不是永久的；最终，旧式类将被淘汰，可能在 Python 3.0 中被移除。"

#: ../../whatsnew/2.2.rst:109
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A"
" new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"那么如何定义一个新式类呢？你可以通过继承一个现有的新式类来实现。大多数 Python "
"内置类型，如整数、列表、字典，甚至文件，现在都是新式类。此外，还添加了一个名为 :class:`object` "
"的新式类，它是所有内置类型的基类，因此如果没有合适的内置类型，你可以直接继承 :class:`object` 类："

#: ../../whatsnew/2.2.rst:116
msgid ""
"class C(object):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."
msgstr ""
"class C(object):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."

#: ../../whatsnew/2.2.rst:121
msgid ""
"This means that :keyword:`class` statements that don't have any base classes"
" are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`!__metaclass__` --- see"
" :pep:`253` for the details --- but it's easier to just subclass "
":class:`object`.)"
msgstr ""
"这意味着在 Python 2.2 中不带任何基类的 :keyword:`class` 语句总是属于经典类。 （实际上你也可以通过设置一个名为 "
":attr:`!__metaclass__` 的模块级变量来改变这一点 —— 详见 :pep:`253` —— 但更简单的做法是直接子类化 "
":class:`object`。）"

#: ../../whatsnew/2.2.rst:126
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named "
":func:`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions "
"any more, but type objects that behave as factories when called. ::"
msgstr ""
"内置类型的类型对象在 Python 2.2 中作为内置对象提供，使用了一种巧妙的技巧命名。Python 一直有名为 "
":func:`int`、:func:`float` 和 :func:`str` 的内置函数。在 Python 2.2 "
"中，它们不再是函数，而是作为被调用时表现为工厂的类型对象。"

#: ../../whatsnew/2.2.rst:131
msgid ""
">>> int\n"
"<type 'int'>\n"
">>> int('123')\n"
"123"
msgstr ""
">>> int\n"
"<type 'int'>\n"
">>> int('123')\n"
"123"

#: ../../whatsnew/2.2.rst:136
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` and"
" :func:`!file` have been added.  Here's a more interesting example, adding a"
" :meth:`!lock` method to file objects::"
msgstr ""
"为了使类型集合更为完备，增加了新的类型对象如 :func:`dict` 和 :func:`!file`。 下面是一个更有趣的示例，向文件对象添加一个 "
":meth:`!lock` 方法::"

#: ../../whatsnew/2.2.rst:140
msgid ""
"class LockableFile(file):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           length, start, whence)"
msgstr ""
"class LockableFile(file):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           length, start, whence)"

#: ../../whatsnew/2.2.rst:146
msgid ""
"The now-obsolete :mod:`!posixfile` module contained a class that emulated "
"all of a file object's methods and also added a :meth:`!lock` method, but "
"this class couldn't be passed to internal functions that expected a built-in"
" file, something which is possible with our new :class:`!LockableFile`."
msgstr ""
"现在已经过时的 :mod:`!posixfile` 模块包含一个类，该类模仿了文件对象的所有方法，并添加了一个 :meth:`!lock` "
"方法，但这个类不能传递给期望内置文件对象的内部函数，而这在我们的新 :class:`!LockableFile` 实现中是可能的。"

#: ../../whatsnew/2.2.rst:153
msgid "Descriptors"
msgstr "描述器"

#: ../../whatsnew/2.2.rst:155
msgid ""
"In previous versions of Python, there was no consistent way to discover what"
" attributes and methods were supported by an object. There were some "
"informal conventions, such as defining :attr:`!__members__` and "
":attr:`!__methods__` attributes that were lists of names, but often the "
"author of an extension type or a class wouldn't bother to define them.  You "
"could fall back on inspecting the :attr:`~object.__dict__` of an object, but"
" when class inheritance or an arbitrary :meth:`!__getattr__` hook were in "
"use this could still be inaccurate."
msgstr ""
"在以前的 Python 版本中，没有一致的方式来发现对象支持的属性和方法。 有一些非正式的约定，例如定义 :attr:`!__members__` 和 "
":attr:`!__methods__` 属性，这些属性是名称列表，但扩展类型或类的作者往往不会去定义它们。 你可以回退到检查对象的 "
":attr:`~object.__dict__` 属性，但在使用类继承或任意的 :meth:`!__getattr__` 钩子时，这仍然可能是不准确的。"

#: ../../whatsnew/2.2.rst:163
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class"
" methods become possible, as well as more exotic constructs."
msgstr ""
"新类模型的一个核心理念是正式化了使用描述符来描述对象属性的 API。描述符指定属性的值，说明它是方法还是字段。通过描述符 "
"API，静态方法和类方法成为可能，以及其他更复杂的构造。"

#: ../../whatsnew/2.2.rst:169
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a"
" few attributes of their own:"
msgstr "属性描述符是存在于类对象内部的对象，它们自身具有一些属性。描述符协议由三个主要方法组成："

#: ../../whatsnew/2.2.rst:172
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` 是属性的名称。"

#: ../../whatsnew/2.2.rst:174
msgid ":attr:`~definition.__doc__` is the attribute's docstring."
msgstr ":attr:`~definition.__doc__` 是属性的文档字符串。"

#: ../../whatsnew/2.2.rst:176
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr "``__get__(object)`` 是一个从 *object* 中提取属性值的方法。"

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` 将 *object* 上的属性设为 *value*。"

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` 将删除 *object* 的 *value* 属性。"

#: ../../whatsnew/2.2.rst:183
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr "例如，当你写下 ``obj.x``，Python 实际要执行的步骤是::"

#: ../../whatsnew/2.2.rst:186
msgid ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"
msgstr ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"

#: ../../whatsnew/2.2.rst:189
msgid ""
"For methods, :meth:`descriptor.__get__ <object.__get__>` returns a temporary"
" object that's callable, and wraps up the instance and the method to be "
"called on it. This is also why static methods and class methods are now "
"possible; they have descriptors that wrap up just the method, or the method "
"and the class.  As a brief explanation of these new kinds of methods, static"
" methods aren't passed the instance, and therefore resemble regular "
"functions.  Class methods are passed the class of the object, but not the "
"object itself.  Static and class methods are defined like this::"
msgstr ""
"对于方法，:meth:`descriptor.__get__ <object.__get__>` "
"返回一个可调用的临时对象，它将实例和要调用的方法包装在一起。 这也是为什么现在可以实现静态方法和类方法的原因；它们有只包装方法或者类的描述器。 "
"作为对这些新方法类别的简要说明，静态方法不传递实例，因此类似于常规函数。 类方法将传递对象的类，但不是对象本身。 静态方法和类方法是这样定义的::"

#: ../../whatsnew/2.2.rst:199
msgid ""
"class C(object):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = classmethod(g)"
msgstr ""
"class C(object):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = classmethod(g)"

#: ../../whatsnew/2.2.rst:208
msgid ""
"The :func:`staticmethod` function takes the function :func:`!f`, and returns"
" it wrapped up in a descriptor so it can be stored in the class object.  You"
" might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
":func:`staticmethod` 函数接收函数 :func:`!f`，并将其封装在描述符中返回，这样它就可以存储在类对象中。 "
"您可能希望有特殊的语法来创建这样的方法 (``def static f`` , ``defstatic f()`` "
"或类似的东西)，但目前还没有定义这样的语法；这要留待 Python 的未来版本去解决。"

#: ../../whatsnew/2.2.rst:214
msgid ""
"More new features, such as slots and properties, are also implemented as new"
" kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"更多的新功能，如 __slots__ "
"和属性，也作为新类型的描述符实现。编写一个实现新功能的描述符类并不困难。例如，可以编写一个描述符类，使其能够为方法编写类似 Eiffel "
"风格的前置条件和后置条件。使用该功能的类可能定义如下："

#: ../../whatsnew/2.2.rst:221
msgid ""
"from eiffel import eiffelmethod\n"
"\n"
"class C(object):\n"
"    def f(self, arg1, arg2):\n"
"        # The actual function\n"
"        ...\n"
"    def pre_f(self):\n"
"        # Check preconditions\n"
"        ...\n"
"    def post_f(self):\n"
"        # Check postconditions\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"
msgstr ""
"from eiffel import eiffelmethod\n"
"\n"
"class C(object):\n"
"    def f(self, arg1, arg2):\n"
"        # 实际的函数\n"
"        ...\n"
"    def pre_f(self):\n"
"        # 检查先决条件\n"
"        ...\n"
"    def post_f(self):\n"
"        # 检查后置条件\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"

#: ../../whatsnew/2.2.rst:236
msgid ""
"Note that a person using the new :func:`!eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features"
" don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`!eiffelmethod` or"
" the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"请注意，使用新 :func:`!eiffelmethod` 的人不必了解任何关于描述器的知识。 这就是我认为新功能不会增加语言基本复杂性的原因。 "
"会有一些向导需要了解它，以便编写 :func:`!eiffelmethod` 或 ZODB "
"或其他内容，但大多数用户只会在生成的库之上编写代码，而会忽略其实现细节。"

#: ../../whatsnew/2.2.rst:245
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "多重继承：钻石规则"

#: ../../whatsnew/2.2.rst:247
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram"
" taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"通过改变名称解析规则，多重继承也变得更加有用。  请看下面这组类（图表摘自 :pep:`253` ，作者 Guido van Rossum）："

#: ../../whatsnew/2.2.rst:251
msgid ""
"      class A:\n"
"        ^ ^  def save(self): ...\n"
"       /   \\\n"
"      /     \\\n"
"     /       \\\n"
"    /         \\\n"
"class B     class C:\n"
"    ^         ^  def save(self): ...\n"
"     \\       /\n"
"      \\     /\n"
"       \\   /\n"
"        \\ /\n"
"      class D"
msgstr ""
"      class A:\n"
"        ^ ^  def save(self): ...\n"
"       /   \\\n"
"      /     \\\n"
"     /       \\\n"
"    /         \\\n"
"class B     class C:\n"
"    ^         ^  def save(self): ...\n"
"     \\       /\n"
"      \\     /\n"
"       \\   /\n"
"        \\ /\n"
"      class D"

#: ../../whatsnew/2.2.rst:265
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to "
":meth:`!D.save` will search the classes :class:`!D`, :class:`!B`, and then "
":class:`!A`, where :meth:`!save` would be found and returned.  "
":meth:`!C.save` would never be found at all.  This is bad, because if "
":class:`!C`'s :meth:`!save` method is saving some internal state specific to"
" :class:`!C`, not calling it will result in that state never getting saved."
msgstr ""
"经典类的查找规则很简单，但并不高明；基类的查找是深度优先的，从左到右依次查找。 对 :meth:`!D.save` 的引用将搜索类 "
":class:`!D`、:class:`!B`，然后是 :class:`!A`，其中 :meth:`!save` 将被找到并返回。 "
":meth:`!C.save` 根本不会被找到。 这很糟糕，因为如果 :class:`!C` 的 :meth:`!save` 方法正在保存 "
":class:`!C` 特有的某些内部状态，不调用该方法将导致该状态永远不会被保存。"

#: ../../whatsnew/2.2.rst:273
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated"
" to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"新式类遵循一种不同的算法，虽然解释起来有点复杂，但在这种情况下能做正确的事情。（请注意，Python 2.3 "
"改变了这个算法，在大多数情况下会产生相同的结果，但对于非常复杂的继承图会产生更有用的结果。）"

#: ../../whatsnew/2.2.rst:278
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`!D`, :class:`!B`, :class:`!A`, "
":class:`!C`, :class:`!A`]."
msgstr ""
"按照经典的查找规则列出所有基类，如果一个类被重复访问，则将其包含多次。 在上例中，已访问过的类列表为 [:class:`!D`, "
":class:`!B`, :class:`!A`, :class:`!C`, :class:`!A`]。"

#: ../../whatsnew/2.2.rst:283
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!A`] after "
"dropping duplicates."
msgstr ""
"扫描列表来查找重复的类。 如果发现有重复的类，则删除所有重复的类，只留下列表中*后一个。 在上例中，删除重复后的列表变成 [:class:`!D`, "
":class:`!B`, :class:`!C`, :class:`!A`]。"

#: ../../whatsnew/2.2.rst:288
msgid ""
"Following this rule, referring to :meth:`!D.save` will return "
":meth:`!C.save`, which is the behaviour we're after.  This lookup rule is "
"the same as the one followed by Common Lisp.  A new built-in function, "
":func:`super`, provides a way to get at a class's superclasses without "
"having to reimplement Python's algorithm. The most commonly used form will "
"be  ``super(class, obj)``, which returns  a bound superclass object (not the"
" actual class object).  This form will be used in methods to call a method "
"in the superclass; for example, :class:`!D`'s :meth:`!save` method would "
"look like this::"
msgstr ""
"根据这条规则，引用 :meth:`!D.save` 将返回 :meth:`!C.save`，这正是我们想要的行为。 这一查找规则与 Common "
"Lisp 遵循的规则相同。 新的内置函数 :func:`super` 提供了一种无需重新实现 Python 算法就能获取类的超类的方法。 最常用的形式是"
" ``super(class, obj)`` ，它返回一个绑定的超类对象（而不是实际的类对象）。 "
"这种形式将用于调用超类中的方法；例如，:class:`!D` 的 :meth:`!save` 方法看起来像这样::"

#: ../../whatsnew/2.2.rst:297
msgid ""
"class D (B,C):\n"
"    def save (self):\n"
"        # Call superclass .save()\n"
"        super(D, self).save()\n"
"        # Save D's private information here\n"
"        ..."
msgstr ""
"class D (B,C):\n"
"    def save (self):\n"
"        # 调用超类的 .save()\n"
"        super(D, self).save()\n"
"        # 在此保存 D 的私有信息\n"
"        ..."

#: ../../whatsnew/2.2.rst:304
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often"
" be useful."
msgstr ""
":func:`super` 在以 ``super(class)`` 或 ``super(class1, class2)`` "
"形式调用时也可以返回未绑定的超类对象，但这可能并不常用。"

#: ../../whatsnew/2.2.rst:310
msgid "Attribute Access"
msgstr "属性访问"

#: ../../whatsnew/2.2.rst:312
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`~object.__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as "
"``obj.get_parent``.  Python 2.2 adds some new ways of controlling attribute "
"access."
msgstr ""
"许多高级的 Python 类通过 :meth:`~object.__getattr__` 定义属性访问钩子；通常这样做是为了方便，通过自动将诸如 "
"``obj.parent`` 这样的属性访问映射到诸如 ``obj.get_parent`` 这样的方法调用，使代码更具可读性。 Python 2.2 "
"添加了一些新的方法来控制属性访问。"

#: ../../whatsnew/2.2.rst:318
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"首先，新式类仍然支持 ``__getattr__(attr_name)``，关于它的任何内容都没有改变。  和以前一样，当试图访问 "
"``obj.foo`` 时，如果在实例的字典中找不到名为 ``foo`` 的属性，就会调用它。"

#: ../../whatsnew/2.2.rst:323
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`~object.__getattribute__` is *always* called whenever any "
"attribute is accessed, while the old :meth:`~object.__getattr__` is only "
"called if ``foo`` isn't found in the instance's dictionary."
msgstr ""
"新式类还支持一种新方法 ``__getattribute__(attr_name)``。 这两个方法的区别在于 "
":meth:`~object.__getattribute__` 在访问任何属性时 *总是* 被调用，而旧的 "
":meth:`~object.__getattr__` 仅在 ``foo`` 未在实例的字典中找到时才被调用。"

#: ../../whatsnew/2.2.rst:329
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`!__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of "
":attr:`~object.__dict__`. :meth:`~object.__getattr__` methods also end up "
"being called by Python when it checks for other methods such as "
":meth:`~object.__repr__` or :meth:`!__coerce__`, and so have to be written "
"with this in mind. Finally, calling a function on every attribute access "
"results in a sizable performance loss."
msgstr ""
"然而，Python 2.2 对 :dfn:`properties` 的支持通常是捕获属性引用的更简单方法。 编写 "
":meth:`!__getattr__` 方法非常复杂，因为为了避免递归，你不能在其中使用常规的属性访问，而是不得不处理 "
":attr:`~object.__dict__` 的内容。 此外，:meth:`~object.__getattr__` 方法在 Python "
"检查其他例如 :meth:`~object.__repr__` 或 :meth:`!__coerce__` "
"等方法时也会被调用，因此在编写时需要考虑这些情况。最后，每次属性访问都调用一个函数会导致显著的性能损失。"

#: ../../whatsnew/2.2.rst:338
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you"
" want to define a :attr:`!size` attribute that's computed, but also "
"settable, you could write::"
msgstr ""
":class:`property` "
"是一种新的内置类型，它打包了三个用于获取、设置或删除属性的函数，以及一个文档字符串。例如，如果你想定义一个计算得出的属性 "
":attr:`!size`，同时又希望这个属性是可设置的，你可以这样写::"

#: ../../whatsnew/2.2.rst:343
msgid ""
"class C(object):\n"
"    def get_size (self):\n"
"        result = ... computation ...\n"
"        return result\n"
"    def set_size (self, size):\n"
"        ... compute something based on the size\n"
"        and set internal state appropriately ...\n"
"\n"
"    # Define a property.  The 'delete this attribute'\n"
"    # method is defined as None, so the attribute\n"
"    # can't be deleted.\n"
"    size = property(get_size, set_size,\n"
"                    None,\n"
"                    \"Storage size of this instance\")"
msgstr ""
"class C(object):\n"
"    def get_size (self):\n"
"        result = ... 执行计算 ...\n"
"        return result\n"
"    def set_size (self, size):\n"
"        ... 基于 size 进行计算\n"
"        并相应地设置内部状态 ...\n"
"\n"
"    # 定义一个 property。\n"
"    # 其中 'delete this attribute' 被定义为 None，\n"
"    # 因此该属性不可被删除。\n"
"    size = property(get_size, set_size,\n"
"                    None,\n"
"                    \"Storage size of this instance\")"

#: ../../whatsnew/2.2.rst:358
msgid ""
"That is certainly clearer and easier to write than a pair of "
":meth:`!__getattr__`/:meth:`!__setattr__` methods that check for the "
":attr:`!size` attribute and handle it specially while retrieving all other "
"attributes from the instance's :attr:`~object.__dict__`.  Accesses to "
":attr:`!size` are also the only ones which have to perform the work of "
"calling a function, so references to other attributes run at their usual "
"speed."
msgstr ""
"这确实比编写一对 :meth:`!__getattr__` / :meth:`!__setattr__` 方法要清晰和容易得多，后者需要检查 "
":attr:`!size` 属性并在检索 :attr:`~object.__dict__` 的所有其他属性时进行特殊处理。 对 "
":attr:`!size` 属性的访问是唯一需要执行调用函数工作的访问，因此对其他属性的引用仍然以通常的速度运行。"

#: ../../whatsnew/2.2.rst:365
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing "
"``obj.new_attr=1``.   A new-style class can define a class attribute named "
":attr:`~object.__slots__` to limit the legal attributes  to a particular set"
" of names.  An example will make this clear::"
msgstr ""
"最后，可以使用新的类属性 :attr:`~object.__slots__` 来限制对象上可以引用的属性列表。Python "
"对象通常非常动态，可以随时通过简单地 ``obj.new_attr=1`` 来定义一个新属性。新式类可以定义一个名为 "
":attr:`~object.__slots__` 的类属性，以将合法属性限制为特定的一组名称。一个例子可以更清楚地说明这一点："

#: ../../whatsnew/2.2.rst:372
msgid ""
">>> class C(object):\n"
"...     __slots__ = ('template', 'name')\n"
"...\n"
">>> obj = C()\n"
">>> print obj.template\n"
"None\n"
">>> obj.template = 'Test'\n"
">>> print obj.template\n"
"Test\n"
">>> obj.newattr = None\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"AttributeError: 'C' object has no attribute 'newattr'"
msgstr ""
">>> class C(object):\n"
"...     __slots__ = ('template', 'name')\n"
"...\n"
">>> obj = C()\n"
">>> print obj.template\n"
"None\n"
">>> obj.template = 'Test'\n"
">>> print obj.template\n"
"Test\n"
">>> obj.newattr = None\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"AttributeError: 'C' object has no attribute 'newattr'"

#: ../../whatsnew/2.2.rst:386
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"注意，当尝试为未列在 :attr:`~object.__slots__` 中的属性赋值时，会引发 :exc:`AttributeError`。"

#: ../../whatsnew/2.2.rst:393
msgid "Related Links"
msgstr "相关链接"

#: ../../whatsnew/2.2.rst:395
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr "本节只是对新特性进行了简要概述，提供了足够的解释以帮助你开始编程，但许多细节已被简化或忽略。想要获得更全面的了解，你可以去哪里呢？"

#: ../../whatsnew/2.2.rst:399
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much"
" more detail about the new features while still remaining quite easy to "
"read."
msgstr ""
":ref:`descriptorhowto` 是由 Guido van Rossum 编写的一篇介绍描述器特性详细教程。 "
"如果我的描述激起了你的兴趣，请继续阅读这篇教程，因为它更加详细地介绍了这些新功能，同时仍然保持了相当的易读性。"

#: ../../whatsnew/2.2.rst:404
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is"
" titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  "
":pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"接下来，有两个相关的 PEP，即 :pep:`252` 和 :pep:`253`。:pep:`252` 标题为“使类型更像类”，涵盖了描述符 "
"API。:pep:`253` 标题为“内置类型的子类型化”，描述了使内置对象可以进行子类型化的类型对象的更改。:pep:`253` 是这两个 PEP "
"中更复杂的一个，在某些点上，必要的类型和元类型解释可能会让人感到头疼。两个 PEP 都由 Guido van Rossum 编写和实现，并得到了 "
"Zope Corp. 团队其他成员的实质性协助。"

#: ../../whatsnew/2.2.rst:413
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"最后，还有最终的权威来源：源代码。大部分类型处理的机制都在 :file:`Objects/typeobject.c` "
"中，但只有在所有其他途径都用尽之后，包括在 python-list 或 python-dev 上发布问题后，才应求助于源代码。"

#: ../../whatsnew/2.2.rst:422
msgid "PEP 234: Iterators"
msgstr "PEP 234: 迭代器"

#: ../../whatsnew/2.2.rst:424
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr "Python 2.2 的另一个重要新增功能是在 C 和 Python 两个层面上引入了迭代接口。对象可以定义如何被调用者循环遍历。"

#: ../../whatsnew/2.2.rst:427
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work"
" is to define a :meth:`~object.__getitem__` method that looks something like"
" this::"
msgstr ""
"在 Python 2.1 及之前的版本中，使 ``for item in obj`` 语句生效的常用方法是定义一个类似于下面的 "
":meth:`~object.__getitem__` 方法："

#: ../../whatsnew/2.2.rst:430
msgid ""
"def __getitem__(self, index):\n"
"    return <next item>"
msgstr ""
"def __getitem__(self, index):\n"
"    return <next item>"

#: ../../whatsnew/2.2.rst:433
msgid ""
":meth:`~object.__getitem__` is more properly used to define an indexing "
"operation on an object so that you can write ``obj[5]`` to retrieve the "
"sixth element.  It's a bit misleading when you're using this only to support"
" :keyword:`for` loops. Consider some file-like object that wants to be "
"looped over; the *index* parameter is essentially meaningless, as the class "
"probably assumes that a series of :meth:`~object.__getitem__` calls will be "
"made with *index* incrementing by one each time.  In other words, the "
"presence of the :meth:`~object.__getitem__` method doesn't mean that using "
"``file[5]``  to randomly access the sixth element will work, though it "
"really should."
msgstr ""
":meth:`~object.__getitem__` 更适用于在对象上定义索引操作，以便你可以编写 ``obj[5]`` 来检索第六个元素。 "
"如果仅仅为了支持 :keyword:`for` 循环而使用它，会有些误导。 考虑一个类文件对象，它希望被循环遍历；*index* "
"参数基本上是没有意义的，因为类可能假定会有一系列的 :meth:`~object.__getitem__` 调用，每次 *index* "
"增加一。换句话说，:meth:`~object.__getitem__` 方法的存在并不意味着使用 ``file[5]`` "
"随机访问第六个元素是可行的，尽管实际上它应该是可行的。"

#: ../../whatsnew/2.2.rst:443
msgid ""
"In Python 2.2, iteration can be implemented separately, and "
":meth:`~object.__getitem__` methods can be limited to classes that really do"
" support random access.  The basic idea of iterators is  simple.  A new "
"built-in function, ``iter(obj)`` or ``iter(C, sentinel)``, is used to get an"
" iterator. ``iter(obj)`` returns an iterator for the object *obj*, while "
"``iter(C, sentinel)`` returns an iterator that will invoke the callable "
"object *C* until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"在 Python 2.2 中，可以单独实现迭代，而 :meth:`~object.__getitem__` 方法可以仅限于真正支持随机访问的类。 "
"迭代器的基本概念很简单。 一个新的内置函数 ``iter(obj)`` 或 ``iter(C, sentinel)`` 被引入，用于获取迭代器。 "
"``iter(obj)`` 返回对象 *obj* 的迭代器，而 ``iter(C, sentinel)`` 返回一个迭代器，该迭代器将调用可调用对象 "
"*C*，直到它返回 *sentinel*，以此表示迭代结束。"

#: ../../whatsnew/2.2.rst:451
msgid ""
"Python classes can define an :meth:`!__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator,"
" this method can just return ``self``.  In particular, iterators will "
"usually be their own iterators.  Extension types implemented in C can "
"implement a :c:member:`~PyTypeObject.tp_iter` function in order to return an"
" iterator, and extension types that want to behave as iterators can define a"
" :c:member:`~PyTypeObject.tp_iternext` function."
msgstr ""
"Python 类可以定义一个 :meth:`!__iter__` "
"方法，该方法应该创建并返回一个对象的新迭代器；如果对象本身就是它自己的迭代器，这个方法可以简单地返回 ``self``。 "
"特别地，迭代器通常会是它们自己的迭代器。 用 C 实现的扩展类型可以实现一个 :c:member:`~PyTypeObject.tp_iter` "
"函数来返回一个迭代器，想要表现为迭代器的扩展类型可以定义一个 :c:member:`~PyTypeObject.tp_iternext` 函数。"

#: ../../whatsnew/2.2.rst:458
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"总结一下，迭代器实际上做什么？它们有一个必需的方法 :meth:`next`，该方法不接受任何参数并返回下一个值。当没有更多的值可以返回时，调用 "
":meth:`next` 应该引发 :exc:`StopIteration` 异常。以下是一个简单的例子来说明迭代器的工作原理："

#: ../../whatsnew/2.2.rst:463
msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> print i\n"
"<iterator object at 0x8116870>\n"
">>> i.next()\n"
"1\n"
">>> i.next()\n"
"2\n"
">>> i.next()\n"
"3\n"
">>> i.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"StopIteration\n"
">>>"
msgstr ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> print i\n"
"<iterator object at 0x8116870>\n"
">>> i.next()\n"
"1\n"
">>> i.next()\n"
"2\n"
">>> i.next()\n"
"3\n"
">>> i.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"StopIteration\n"
">>>"

#: ../../whatsnew/2.2.rst:479
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`!__iter__` or a "
":c:member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"在 Python 2.2 中，:keyword:`for` 语句不再期望一个序列；它期望的是一个可以返回迭代器的 :func:`iter` 对象。 "
"为了向下兼容和方便，对于那些没有实现 :meth:`!__iter__` 或 :c:member:`~PyTypeObject.tp_iter` "
"方法的序列，会自动构造一个迭代器，因此 ``for i in [1,2,3]`` 仍然可以正常工作。 Python "
"解释器在循环遍历序列时，已经改为使用迭代器协议。 这意味着你可以做类似这样的事情："

#: ../../whatsnew/2.2.rst:487
msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"
msgstr ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"

#: ../../whatsnew/2.2.rst:493
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling "
":func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr "迭代器支持已被添加到Python的一些基本类型中。对字典调用 :func:`iter` 会返回一个迭代器，该迭代器遍历字典的键，如下所示："

#: ../../whatsnew/2.2.rst:496
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"Mar 3\n"
"Feb 2\n"
"Aug 8\n"
"Sep 9\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Jan 1\n"
"Apr 4\n"
"Nov 11\n"
"Dec 12\n"
"Oct 10"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"Mar 3\n"
"Feb 2\n"
"Aug 8\n"
"Sep 9\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Jan 1\n"
"Apr 4\n"
"Nov 11\n"
"Dec 12\n"
"Oct 10"

#: ../../whatsnew/2.2.rst:513
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`!iterkeys`, "
":meth:`!itervalues`, or :meth:`!iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on"
" dictionaries, so ``key in dict`` is now equivalent to "
"``dict.has_key(key)``."
msgstr ""
"这只是默认行为。如果你想迭代键、值或键/值对，可以显式调用 :meth:`!iterkeys`、:meth:`!itervalues` 或 "
":meth:`!iteritems` 方法来获取适当的迭代器。 在一个相关的小改动中，成员运算符 :keyword:`in` 现在可以用于字典，因此 "
"``key in dict`` 现在等价于 ``dict.has_key(key)``。"

#: ../../whatsnew/2.2.rst:519
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each"
" line of a file using code like this::"
msgstr ""
"文件也提供了一个迭代器，它会调用 :meth:`readline` "
"方法，直到文件中没有更多的行。这意味着你现在可以使用类似这样的代码来读取文件的每一行："

#: ../../whatsnew/2.2.rst:523
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"for line in file:\n"
"    # 对每一行执行某些操作\n"
"    ..."

#: ../../whatsnew/2.2.rst:527
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol"
" only requires a :meth:`next` method."
msgstr ""
"请注意，你只能在迭代器中向前移动；没有办法获取前一个元素、重置迭代器或复制迭代器。一个迭代器对象可以提供这些额外的功能，但迭代器协议只要求有一个 "
":meth:`next` 方法。"

#: ../../whatsnew/2.2.rst:535
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - 迭代器"

#: ../../whatsnew/2.2.rst:536
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly"
" by GvR and Tim Peters."
msgstr "由 Ka-Ping Yee 和 GvR 撰写；由 Python Labs 小组（主要由 GvR 和 Tim Peters）实现。"

#: ../../whatsnew/2.2.rst:543
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: 简单的生成器"

#: ../../whatsnew/2.2.rst:545
msgid ""
"Generators are another new feature, one that interacts with the introduction"
" of iterators."
msgstr "生成器是另一个新增特性，它是与迭代器的引入相互关联的。"

#: ../../whatsnew/2.2.rst:548
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When"
" you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local"
" variables. But, what if the local variables weren't thrown away on exiting "
"a function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"你一定熟悉在Python或C语言中函数调用的工作方式。当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。当函数执行到 "
":keyword:`return` "
"语句时，这些局部变量会被销毁，并将结果值返回给调用者。稍后对同一个函数的调用将获得一套全新的局部变量。但，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。"

#: ../../whatsnew/2.2.rst:557
msgid "Here's the simplest example of a generator function::"
msgstr "这里是一个生成器函数的最简示例::"

#: ../../whatsnew/2.2.rst:559
msgid ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"
msgstr ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"

#: ../../whatsnew/2.2.rst:563
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"一个新的关键字 :keyword:`yield` 被引入用于生成器。任何包含 :keyword:`!yield` "
"语句的函数都是生成器函数；这由Python的字节码编译器检测到，并因此对函数进行特殊编译。由于引入了一个新的关键字，生成器必须通过在模块的源代码顶部附近包含一条"
" ``from __future__ import generators`` 语句来显式启用。在Python 2.3中，这条语句将变得不再必要。"

#: ../../whatsnew/2.2.rst:571
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value"
" of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended"
" and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the "
":keyword:`!yield` statement.  (For complicated reasons, the "
":keyword:`!yield` statement isn't allowed inside the :keyword:`!try` block "
"of a :keyword:`try`...\\ :keyword:`finally` statement; read :pep:`255` for a"
" full explanation of the interaction between :keyword:`!yield` and "
"exceptions.)"
msgstr ""
"当你调用一个生成器函数时，它不会返回单个值；相反，它返回一个支持迭代器协议的生成器对象。在执行 :keyword:`yield` 语句时，生成器输出 "
"``i`` 的值，类似于 :keyword:`return` 语句。:keyword:`!yield` 和 :keyword:`!return` "
"语句之间的重大区别在于，当到达 :keyword:`!yield` 时，生成器的执行状态被挂起，并且局部变量被保留。在下一次调用生成器的 "
"``next()`` 方法时，函数将立即在 :keyword:`!yield` 语句之后恢复执行。（由于复杂的原因，:keyword:`!yield` "
"语句不允许在 :keyword:`try` ... :keyword:`finally` 语句的 :keyword:`!try` 块中使用；请阅读 "
":pep:`255` 以获得关于 :keyword:`!yield` 和异常交互的详细解释。）"

#: ../../whatsnew/2.2.rst:584
msgid "Here's a sample usage of the :func:`!generate_ints` generator::"
msgstr "下面是 :func:`!generate_ints` 生成器的用法示例::"

#: ../../whatsnew/2.2.rst:586
msgid ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in generate_ints\n"
"StopIteration"
msgstr ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in generate_ints\n"
"StopIteration"

#: ../../whatsnew/2.2.rst:601
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"你可以等价地写成 ``for i in generate_ints(5)`` 或 ``a,b,c = generate_ints(3)``。"

#: ../../whatsnew/2.2.rst:604
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. "
":keyword:`!return` with a value, such as ``return 5``, is a syntax error "
"inside a generator function.  The end of the generator's results can also be"
" indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"在生成器函数内部， :keyword:`return` "
"语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 :keyword:`!return`，例如 "
"``return 5``，是语法错误。生成器结果的结束也可以通过手动引发 :exc:`StopIteration` "
"异常来指示，或者只是让执行流自然地从函数底部流出。"

#: ../../whatsnew/2.2.rst:612
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. "
":file:`Lib/test/test_generators.py` contains a number of more interesting "
"examples.  The simplest one implements an in-order traversal of a tree using"
" generators recursively. ::"
msgstr ""
"你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 ``self.count`` "
"设置为0，并让 :meth:`next` 方法递增 ``self.count`` "
"并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。:file:`Lib/test/test_generators.py` "
"包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历："

#: ../../whatsnew/2.2.rst:621
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# 一个递归地按顺序生成 Tree 叶子节点的生成器。\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"

#: ../../whatsnew/2.2.rst:630
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that"
" no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"在 :file:`Lib/test/test_generators.py` "
"中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。"

#: ../../whatsnew/2.2.rst:635
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www2.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www2.cs.arizona.edu/icon/docs/ipd266.htm gives an idea"
" of what this looks like::"
msgstr ""
"生成器的概念源自其他编程语言，尤其是 Icon（https://www2.cs.arizona.edu/icon/ ），在 Icon "
"语言中，生成器的概念是核心。在 Icon 中，每个表达式和函数调用生成器的概念源自其他编程语言，尤其是 Icon。 在 Icon "
"中，每个表达式和函数调用都可以表现得像一个生成器。 以下是来自“Icon 编程语言概述”中的一个示例，展示了生成器的用法 "
"https://www2.cs.arizona.edu/icon/docs/ipd266.htm ："

#: ../../whatsnew/2.2.rst:642
msgid ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"
msgstr ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"

#: ../../whatsnew/2.2.rst:645
msgid ""
"In Icon the :func:`!find` function returns the indexes at which the "
"substring \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i``"
" is first assigned a value of 3, but 3 is less than 5, so the comparison "
"fails, and Icon retries it with the second value of 23.  23 is greater than "
"5, so the comparison now succeeds, and the code prints the value 23 to the "
"screen."
msgstr ""
"在Icon中，:func:`!find` 函数返回子字符串\"or\"所在的索引：3、23、33。在 :keyword:`if` 语句中，``i`` "
"首先被赋值为 3，但 3 小于 5，因此比较失败，Icon 会使用第二个值 23 进行重试。 23 大于 5，因此比较成功，代码将值 23 "
"打印到屏幕上。"

#: ../../whatsnew/2.2.rst:651
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to"
" other functions or stored in a data structure."
msgstr ""
"Python 并没有像 Icon 那样将生成器作为核心概念来采纳。生成器被认为是 Python "
"核心语言的一部分，但学习或使用它们并不是强制性的；如果它们不能解决你的问题，可以完全忽略它们。与 Icon 相比，Python "
"的一个新颖特性是生成器的状态表示为一个具体对象（迭代器），该对象可以传递给其他函数或存储在数据结构中。"

#: ../../whatsnew/2.2.rst:662
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 简单生成器"

#: ../../whatsnew/2.2.rst:663
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer "
"和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。"

#: ../../whatsnew/2.2.rst:670
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: 统一长整数和整数"

#: ../../whatsnew/2.2.rst:672
msgid ""
"In recent versions, the distinction between regular integers, which are "
"32-bit values on most machines, and long integers, which can be of arbitrary"
" size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`!tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"在最近的版本中，普通整数（在大多数机器上是 32 位值）和长整数（可以是任意大小）的区别变得令人烦恼。 例如，在支持大于 ``2**32`` "
"比特的文件的平台上，文件对象的 :meth:`!tell` 方法必须返回一个长整数。 然而，Python "
"的各个部分期望普通整数，如果提供了长整数，则会引发错误。 例如，在 Python 1.5 中，只有普通整数可以用作切片索引，而 "
"``'abc'[1L:]`` 会引发一个 :exc:`TypeError` 异常，并显示消息“slice index must be int”。"

#: ../../whatsnew/2.2.rst:682
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 将根据需要将数值从短整数转换为长整数。'L' 后缀不再需要用于表示长整数字面量，因为现在编译器会自动选择适当的类型。（在未来的 "
"2.x 版本的 Python 中，使用 'L' 后缀将被不鼓励，并在 Python 2.4 中触发警告，可能在 Python 3.0 "
"中被移除。）许多以前会引发 :exc:`OverflowError` 的操作现在会返回一个长整数作为结果。例如："

#: ../../whatsnew/2.2.rst:690
msgid ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"
msgstr ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"

#: ../../whatsnew/2.2.rst:695
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr "在大多数情况下，整数和长整数现在将被视为相同。你仍然可以使用内置的 :func:`type` 函数区分它们，但这很少需要。"

#: ../../whatsnew/2.2.rst:702
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - 统一长整数和整数"

#: ../../whatsnew/2.2.rst:703
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰写 ; 大部分由 Guido van Rossum 实现。"

#: ../../whatsnew/2.2.rst:710
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238：修改除法运算符"

#: ../../whatsnew/2.2.rst:712
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Python 2.2中最具争议的变化预示着修复一个自Python诞生以来的旧设计缺陷的努力的开始。目前，Python的除法操作符 ``/`` "
"在接收两个整数参数时表现得像C语言的除法操作符：它返回一个被截断为整数的结果。例如，``3/2`` 是1，而不是1.5，``(-1)/2`` "
"是-1，而不是-0.5。这意味着除法的结果可能会根据两个操作数的类型而意外变化，并且由于Python是动态类型的，确定操作数的可能类型可能会很困难。"

#: ../../whatsnew/2.2.rst:722
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether"
" it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"（争议在于这是否*真的*算是一个设计缺陷，以及是否值得为了修复它而破坏现有代码。这在python-"
"dev上引发了无休止的讨论，并在2001年7月爆发成一场在 :newsgroup:`comp.lang.python` "
"的充满讽刺性言辞的风暴。我不会在这里为任何一方辩护，只会描述在2.2中实现的内容。请阅读 :pep:`238` 以获取争论和反驳的摘要。）"

#: ../../whatsnew/2.2.rst:729
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"由于这一变化可能会破坏现有代码，因此它正在非常逐步地引入。Python 2.2 开始了这一过渡，但直到 Python 3.0 这一转换才会完全完成。"

#: ../../whatsnew/2.2.rst:733
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is"
" 0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"首先，我将借用一些来自 :pep:`238` "
"的术语。“真除法”是大多数非程序员所熟悉的除法：3/2是1.5，1/4是0.25，等等。“地板除法”是Python的 ``/`` "
"操作符在给定整数操作数时当前执行的操作；其结果是真除法返回值的地板值。“经典除法”是当前 ``/`` "
"操作符的混合行为；当操作数是整数时，它返回地板除法的结果，而当其中一个操作数是浮点数时，它返回真除法的结果。"

#: ../../whatsnew/2.2.rst:741
msgid "Here are the changes 2.2 introduces:"
msgstr "Python 2.2 引入了以下变化："

#: ../../whatsnew/2.2.rst:743
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and ``1.0 "
"// 2.0`` is also 0.0."
msgstr ""
"一个新的操作符，``//`` 是地板除法操作符。 （是的，我们知道它看起来像 C++ 的注释符号。） ``//`` *始终* "
"执行地板除法，无论其操作数的类型是什么，因此 ``1 // 2`` 是 0，``1.0 // 2.0`` 也是0.0。"

#: ../../whatsnew/2.2.rst:748
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr "``//`` 操作符在Python 2.2中始终可用；你不需要通过 ``__future__`` 语句来启用它。"

#: ../../whatsnew/2.2.rst:751
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"通过在模块中包含 ``from __future__ import division``，``/`` 运算符将被更改为返回真除法的结果，因此 "
"``1/2`` 是 0.5。 如果没有这条 ``__future__`` 语句，``/`` 仍然表示经典除法。``/`` 的默认含义在 Python "
"3.0 之前不会改变。"

#: ../../whatsnew/2.2.rst:756
msgid ""
"Classes can define methods called :meth:`~object.__truediv__` and "
":meth:`~object.__floordiv__` to overload the two division operators.  At the"
" C level, there are also slots in the :c:type:`PyNumberMethods` structure so"
" extension types can define the two operators."
msgstr ""
"类可以定义名为 :meth:`~object.__truediv__` 和 :meth:`~object.__floordiv__` "
"的方法来重载这两个除法操作符。 在 C 语言层面，:c:type:`PyNumberMethods` 结构中也有槽位，因此扩展类型可以定义这两个操作符。"

#: ../../whatsnew/2.2.rst:761
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with "
":option:`!-Q warn` will cause a warning to be issued whenever division is "
"applied to two integers.  You can use this to find code that's affected by "
"the change and fix it.  By default, Python 2.2 will simply perform classic "
"division without a warning; the warning will be turned on by default in "
"Python 2.3."
msgstr ""
"Python 2.2 支持一些命令行参数，用于测试代码是否能在除法语义改变的情况下正常工作。运行 Python 并使用 -Q warn "
"选项时，当对两个整数应用除法时会发出警告。你可以利用这个功能找到受影响的代码并进行修复。默认情况下，Python 2.2 "
"会执行经典除法而不会发出警告；在 Python 2.3 中，警告将默认开启。"

#: ../../whatsnew/2.2.rst:771
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238`：改变除法运算符"

#: ../../whatsnew/2.2.rst:772
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰写 ; 由 Guido van Rossum 实现。"

#: ../../whatsnew/2.2.rst:778
msgid "Unicode Changes"
msgstr "Unicode 的改变"

#: ../../whatsnew/2.2.rst:780
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Python的Unicode支持在2.2版本中有所增强。Unicode字符串通常以UCS-2形式存储，即16位无符号整数。通过向配置脚本提供 "
":option:`!--enable-unicode=ucs4` 选项，Python "
"2.2也可以编译为使用UCS-4（32位无符号整数）作为其内部编码。（也可以指定 :option:`!--disable-unicode` "
"选项来完全禁用Unicode支持。）"

#: ../../whatsnew/2.2.rst:787
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`!unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than"
" 65535 will still cause :func:`!unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode"
" characters\"; consult it for further details."
msgstr ""
"当构建为使用 UCS-4（称为“宽Python”）时，解释器可以原生处理从 U+000000 到 U+110000 的 Unicode 字符，因此 "
":func:`!unichr` 函数的合法值范围也相应扩大。 使用编译为 UCS-2（称为“窄Python”）的解释器时，值大于 65535 仍将导致 "
":func:`!unichr` 函数引发 :exc:`ValueError` 异常。 所有这些内容在 :pep:`261` "
"“支持‘宽’Unicode字符”中有详细描述；请查阅以获取更多细节。"

#: ../../whatsnew/2.2.rst:795
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`!encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`!decode` assumes that the string is in "
"the specified encoding and decodes it, returning whatever is returned by the"
" codec."
msgstr ""
"另一个变化的解释更为简单。 自引入以来，Unicode 字符串支持一个 :meth:`!encode` 方法，可以将字符串转换为选定的编码，如 "
"UTF-8 或 Latin-1。 在 2.2 版本中，为 8 位字符串（但不是Unicode字符串）添加了一个对称的 "
"``decode([*encoding*])`` 方法。 :meth:`!decode` "
"方法假定字符串使用指定的编码，并对其进行解码，返回由编解码器返回的内容。"

#: ../../whatsnew/2.2.rst:802
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"利用这一新特性，编解码器被添加用于与Unicode不直接相关的任务。例如，已经添加了用于uu编码、MIME的base64编码以及使用 "
":mod:`zlib` 模块进行压缩的编解码器："

#: ../../whatsnew/2.2.rst:806
msgid ""
">>> s = \"\"\"Here is a lengthy piece of redundant, overly verbose,\n"
"... and repetitive text.\n"
"... \"\"\"\n"
">>> data = s.encode('zlib')\n"
">>> data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
">>> data.decode('zlib')\n"
"'Here is a lengthy piece of redundant, overly verbose,\\nand repetitive text.\\n'\n"
">>> print s.encode('uu')\n"
"begin 666 <data>\n"
"M2&5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E<&5T:71I=F4@=&5X=\"X*\n"
"\n"
"end\n"
">>> \"sheesh\".encode('rot-13')\n"
"'furrfu'"
msgstr ""
">>> s = \"\"\"Here is a lengthy piece of redundant, overly verbose,\n"
"... and repetitive text.\n"
"... \"\"\"\n"
">>> data = s.encode('zlib')\n"
">>> data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
">>> data.decode('zlib')\n"
"'Here is a lengthy piece of redundant, overly verbose,\\nand repetitive text.\\n'\n"
">>> print s.encode('uu')\n"
"begin 666 <data>\n"
"M2&5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E<&5T:71I=F4@=&5X=\"X*\n"
"\n"
"end\n"
">>> \"sheesh\".encode('rot-13')\n"
"'furrfu'"

#: ../../whatsnew/2.2.rst:823
msgid ""
"To convert a class instance to Unicode, a :meth:`!__unicode__` method can be"
" defined by a class, analogous to :meth:`!__str__`."
msgstr ""
"要将类实例转换为Unicode，类可以定义一个 :meth:`!__unicode__` 方法，类似于 :meth:`!__str__` 方法。"

#: ../../whatsnew/2.2.rst:826
msgid ""
":meth:`!encode`, :meth:`!decode`, and :meth:`!__unicode__` were implemented "
"by Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`!encode`、:meth:`!decode` 和 :meth:`!__unicode__` 方法由 Marc-André "
"Lemburg 实现。 支持内部使用 UCS-4 的更改由 Fredrik Lundh 和 Martin von Löwis 实现。"

#: ../../whatsnew/2.2.rst:833
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - 对 '宽' Unicode 字符的支持"

#: ../../whatsnew/2.2.rst:834
msgid "Written by Paul Prescod."
msgstr "由 Paul Prescod 编写。"

#: ../../whatsnew/2.2.rst:840
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: 嵌套的作用域"

#: ../../whatsnew/2.2.rst:842
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always"
" present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"在Python 2.1中，静态嵌套作用域作为一个可选特性被添加，需要通过 ``from __future__ import "
"nested_scopes`` 指令来启用。在2.2版本中，嵌套作用域不再需要特别启用，现在总是存在。本节的其余部分是从我的《Python "
"2.1的新特性》文档中复制的嵌套作用域描述；如果你在2.1发布时已经阅读过，可以跳过本节的其余部分。"

#: ../../whatsnew/2.2.rst:849
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to"
" Python's scoping rules.  In Python 2.0, at any given time there are at most"
" three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match"
" their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Python 2.1 中的最大改变是 Python 的作用域规则，在Python 2.2中得到完善。 在 Python 2.0 "
"中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 "
"例如，一个嵌套的递归函数将不起作用::"

#: ../../whatsnew/2.2.rst:856
msgid ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."
msgstr ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."

#: ../../whatsnew/2.2.rst:863
msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or"
" in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was"
" a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"函数 :func:`!g` 将始终引发 :exc:`NameError` 异常，因为名称 ``g`` "
"的绑定既不在其局部命名空间中，也不在模块级命名空间中。这在实际中并不是什么大问题（你有多常递归地定义这样的内部函数？），但这也使得使用 "
":keyword:`lambda` 表达式变得笨拙，这在实践中确实是个问题。在使用 :keyword:`!lambda` "
"的代码中，你经常可以看到局部变量通过将它们作为参数的默认值传递来进行复制。 ::"

#: ../../whatsnew/2.2.rst:871
msgid ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"
msgstr ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"

#: ../../whatsnew/2.2.rst:877
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。"

#: ../../whatsnew/2.2.rst:880
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put"
" simply, when a given variable name is not assigned a value within a "
"function (by an assignment, or the :keyword:`def`, :keyword:`class`, or "
":keyword:`import` statements), references to the variable will be looked up "
"in the local namespace of the enclosing scope.  A more detailed explanation "
"of the rules, and a dissection of the implementation, can be found in the "
"PEP."
msgstr ""
"Python 2.2 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 ``name=name`` "
"默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 :keyword:`def`, "
":keyword:`class` 或 :keyword:`import` 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 "
"对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。"

#: ../../whatsnew/2.2.rst:889
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 "
"不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。"

#: ../../whatsnew/2.2.rst:895
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the"
" CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into"
" bytecodes has to generate different code to access variables in a "
"containing scope.  ``from module import *`` and ``exec`` make it impossible "
"for the compiler to figure this out, because they add names to the local "
"namespace that are unknowable at compile time. Therefore, if a function "
"contains function definitions or :keyword:`lambda` expressions with free "
"variables, the compiler will flag this by raising a :exc:`SyntaxError` "
"exception."
msgstr ""
"此项改变的一个附带影响是在特定条件下函数作用域内部 ``from module import *`` 和 ``exec`` 语句将不允许使用。 "
"Python 参考手册已经写明 ``from module import *`` 仅在模块最高层级上是可用的，但此前 CPython "
"解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 "
"``from module import *`` 和 ``exec`` 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 "
"为此，如果一个函数包含带有自由变量的函数定义或 :keyword:`lambda` 表达式，编译器将通过引发 :exc:`SyntaxError` "
"异常来提示。"

#: ../../whatsnew/2.2.rst:908
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "为了使前面的解释更清楚，下面是一个例子::"

#: ../../whatsnew/2.2.rst:910
msgid ""
"x = 1\n"
"def f():\n"
"    # The next line is a syntax error\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"
msgstr ""
"x = 1\n"
"def f():\n"
"    # 下一行有语法错误\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"

#: ../../whatsnew/2.2.rst:917
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed"
" by :func:`!g`."
msgstr ""
"包含 ``exec`` 语句的第 4 行有语法错误，因为 ``exec`` 会定义一个名为 ``x`` 的新局部变量，它的值应当被 :func:`!g`"
" 所访问。"

#: ../../whatsnew/2.2.rst:921
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr "这应该不会是太大的限制，因为 ``exec`` 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。"

#: ../../whatsnew/2.2.rst:928
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 静态嵌套作用域"

#: ../../whatsnew/2.2.rst:929
msgid "Written and implemented by Jeremy Hylton."
msgstr "由 Jeremy Hylton 撰写并实现。"

#: ../../whatsnew/2.2.rst:935
msgid "New and Improved Modules"
msgstr "新增和改进的模块"

#: ../../whatsnew/2.2.rst:937
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module was contributed to the standard "
"library by Fredrik Lundh, providing support for writing XML-RPC clients.  "
"XML-RPC is a simple remote procedure call protocol built on top of HTTP and "
"XML. For example, the following snippet retrieves a list of RSS channels "
"from the O'Reilly Network, and then  lists the recent headlines for one "
"channel::"
msgstr ""
":mod:`xmlrpclib <xmlrpc.client>` 模块由 Fredrik Lundh 贡献给标准库，提供了编写 XML-RPC "
"客户端的支持。 XML-RPC 是一种建立在 HTTP 和 XML 之上的简单远程过程调用协议。 例如，以下代码片段从 O'Reilly Network"
" 检索 RSS 频道列表，然后列出一个频道的最新头条新闻："

#: ../../whatsnew/2.2.rst:943
msgid ""
"import xmlrpclib\n"
"s = xmlrpclib.Server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"channels = s.meerkat.getChannels()\n"
"# channels is a list of dictionaries, like this:\n"
"# [{'id': 4, 'title': 'Freshmeat Daily News'}\n"
"#  {'id': 190, 'title': '32Bits Online'},\n"
"#  {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# Get the items for one channel\n"
"items = s.meerkat.getItems( {'channel': 4} )\n"
"\n"
"# 'items' is another list of dictionaries, like this:\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"#   'description': 'A utility which converts HTML to XSL FO.',\n"
"#   'title': 'html2fo 0.3 (Default)'}, ... ]"
msgstr ""
"import xmlrpclib\n"
"s = xmlrpclib.Server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"channels = s.meerkat.getChannels()\n"
"# channels 是由字典组成的列表，就像这样：\n"
"# [{'id': 4, 'title': 'Freshmeat Daily News'}\n"
"#  {'id': 190, 'title': '32Bits Online'},\n"
"#  {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# 从获取一个 channel 的条目\n"
"items = s.meerkat.getItems( {'channel': 4} )\n"
"\n"
"# 'items' 是另一个由字典组成的列表，就像这样：\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"#   'description': 'A utility which converts HTML to XSL FO.',\n"
"#   'title': 'html2fo 0.3 (Default)'}, ... ]"

#: ../../whatsnew/2.2.rst:960
msgid ""
"The :mod:`SimpleXMLRPCServer <xmlrpc.server>` module makes it easy to create"
" straightforward XML-RPC servers.  See http://xmlrpc.scripting.com/ for more"
" information about XML-RPC."
msgstr ""
":mod:`SimpleXMLRPCServer <xmlrpc.server>` 模块使创建简单的 XML-RPC 服务器变得容易。 有关 XML-"
"RPC 的更多信息，请参见 http://xmlrpc.scripting.com/。"

#: ../../whatsnew/2.2.rst:963
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by "
":rfc:`2104`. (Contributed by Gerhard Häring.)"
msgstr "新的 :mod:`hmac` 模块实现了由 :rfc:`2104` 描述的HMAC算法。（由Gerhard Häring贡献。）"

#: ../../whatsnew/2.2.rst:966
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as :attr:`!memberst_mtime` or :attr:`~time.struct_time.tm_year`. The "
"enhanced functions include :func:`~os.stat`, :func:`~os.fstat`, "
":func:`~os.statvfs`, and :func:`~os.fstatvfs` in the :mod:`os` module, and "
":func:`~time.localtime`, :func:`~time.gmtime`, and :func:`~time.strptime` in"
" the :mod:`time` module."
msgstr ""
"几个最初返回长元组的函数现在返回伪序列，这些伪序列仍然像元组一样工作，但也具有助记属性，例如 :attr:`!memberst_mtime` 或 "
":attr:`~time.struct_time.tm_year`。增强的函数包括 :mod:`os` 模块中的 "
":func:`~os.stat`、:func:`~os.fstat`、:func:`~os.statvfs` 和 "
":func:`~os.fstatvfs`，以及 :mod:`time` 模块中的 "
":func:`~time.localtime`、:func:`~time.gmtime` 和 :func:`~time.strptime`。"

#: ../../whatsnew/2.2.rst:973
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = "
"os.stat(filename).st_size``."
msgstr ""
"例如，使用旧的元组来获取文件的大小时，你可能会写成 ``file_size = os.stat(filename)[stat.ST_SIZE]`` "
"，但现在可以更清晰地写成 ``file_size = os.stat(filename).st_size``。"

#: ../../whatsnew/2.2.rst:977
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "此特性的初始补丁由 Nick Mathewson 贡献。"

#: ../../whatsnew/2.2.rst:979
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Python 的分析器进行了大量的重构，并纠正了其输出中的各种错误。（由 Fred L. Drake, Jr. 和 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:982
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the "
":option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
":mod:`socket` 模块可以编译为支持IPv6；为Python的配置脚本指定 :option:`!--enable-ipv6` "
"选项。（由Jun-ichiro \"itojun\" Hagino贡献。）"

#: ../../whatsnew/2.2.rst:986
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is"
" for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value "
"is returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"在支持 C 语言 long long 类型的平台上，为 64 位整数添加了两个新的格式字符到 :mod:`struct` 模块。 ``q`` 用于有符号"
" 64 位整数，``Q`` 用于无符号 64 位整数。返回的值是 Python 的长整数类型。（由 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:991
msgid ""
"In the interpreter's interactive mode, there's a new built-in function "
":func:`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to "
"provide interactive help. ``help(object)`` displays any available help text "
"about *object*.  :func:`help` with no argument puts you in an online help "
"utility, where you can enter the names of functions, classes, or modules to "
"read their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's "
":mod:`pydoc` module.)"
msgstr ""
"在解释器的交互模式下，有一个新的内置函数 :func:`help`，它使用在Python 2.1 中引入的 :mod:`pydoc` "
"模块来提供交互式帮助。 ``help(object)`` 显示关于*object*的任何可用帮助文本。不带参数调用 :func:`help` "
"会进入一个在线帮助工具，在那里你可以输入函数、类或模块的名称来阅读它们的帮助文本。（由Guido van Rossum贡献，使用Ka-Ping Yee的"
" :mod:`pydoc` 模块。）"

#: ../../whatsnew/2.2.rst:999
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` and"
" :func:`re.split` functions have been rewritten in C.  Another contributed "
"patch speeds up certain Unicode character ranges by a factor of two, and a "
"new :meth:`~re.finditer`  method that returns an iterator over all the non-"
"overlapping matches in  a given string.  (SRE is maintained by Fredrik "
"Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"对 :mod:`re` 模块底层的 SRE 引擎进行了各种错误修复和性能改进。例如，:func:`re.sub` 和 :func:`re.split` "
"函数已用 C 语言重写。 另一个贡献的补丁将某些 Unicode 字符范围的速度提高了两倍，并新增了一个 :meth:`~re.finditer` "
"方法，该方法返回给定字符串中所有不重叠匹配的迭代器。（SRE 由 Fredrik Lundh 维护。 BIGCHARSET 补丁由 Martin von"
" Löwis 贡献。）"

#: ../../whatsnew/2.2.rst:1007
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib`"
" also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
":mod:`smtplib` 模块现在支持 :rfc:`2487`：\"Secure SMTP over "
"TLS\"，因此现在可以加密Python程序与接收消息的邮件传输代理之间的SMTP流量。:mod:`smtplib` "
"还支持SMTP身份验证。（由Gerhard Häring贡献。）"

#: ../../whatsnew/2.2.rst:1012
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
":mod:`imaplib` 模块由 Piers Lauder 维护，支持几个新扩展: :rfc:`2342` 中定义的 NAMESPACE "
"扩展、SORT、GETACL和SETACL。（由 Anthony Baxter 和 Michel Pelletier 贡献。）"

#: ../../whatsnew/2.2.rst:1016
msgid ""
"The :mod:`!rfc822` module's parsing of email addresses is now compliant with"
" :rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* going to"
" be changed to ``rfc2822``.)  A new package, :mod:`email`, has also been "
"added for parsing and generating e-mail messages.  (Contributed by Barry "
"Warsaw, and arising out of his work on Mailman.)"
msgstr ""
":mod:`!rfc822` 模块对电子邮件地址的解析现在符合 :rfc:`2822`，这是对 :rfc:`822` 的更新。（模块名称 *不会* "
"更改为 ``rfc2822``。） 新增了一个包 :mod:`email`，用于解析和生成电子邮件消息。（由 Barry Warsaw 贡献，并源于他在"
" Mailman 上的工作。）"

#: ../../whatsnew/2.2.rst:1022
msgid ""
"The :mod:`difflib` module now contains a new :class:`!Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, "
":func:`!ndiff` and :func:`!restore`, which respectively return a delta from "
"two sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
":mod:`difflib` 模块现在包含一个新的 :class:`!Differ` "
"类，用于生成两个文本行序列之间的可读性高的变更列表（“delta”）。 还有两个生成器函数，:func:`!ndiff` 和 "
":func:`!restore`，分别从两个序列返回一个 delta，或从一个 delta 返回其中一个原始序列。 （基础工作由 David "
"Goodger 贡献，基于 Tim Peters 的 ndiff.py 代码，后者进行了生成器化。）"

#: ../../whatsnew/2.2.rst:1029
msgid ""
"New constants :const:`!ascii_letters`, :const:`!ascii_lowercase`, and "
":const:`!ascii_uppercase` were added to the :mod:`string` module.  There "
"were several modules in the standard library that used "
":const:`!string.letters` to mean the ranges A-Za-z, but that assumption is "
"incorrect when locales are in use, because :const:`!string.letters` varies "
"depending on the set of legal characters defined by the current locale.  The"
" buggy modules have all been fixed to use :const:`!ascii_letters` instead. "
"(Reported by an unknown person; fixed by Fred L. Drake, Jr.)"
msgstr ""
"为 :mod:`string` 模块增加了新的常量 :const:`!ascii_letters`, :const:`!ascii_lowercase`"
" 和 :const:`!ascii_uppercase`。 标准库中有一些模块使用 :const:`!string.letters` 来表示 "
"A-Za-z，但当使用不同语言区域时其含义并不正确，因为 :const:`!string.letters` "
"会根据当前语言区域所定义的合法字符集而发生变化。 这些有问题的模块已全部被修正为改用 :const:`!ascii_letters`。 "
"（由未知人士报告；由 Fred L. Drake, Jr. 修正）。"

#: ../../whatsnew/2.2.rst:1038
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type"
" databases by the addition of a :class:`~mimetypes.MimeTypes` class, which "
"takes a list of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"现在 :mod:`mimetypes` 模块通过添加 :class:`~mimetypes.MimeTypes` 类让使用不同的 MIME "
"类型数据库更为容易，该类接受一个文件名列表供解析。 （由 Fred L. Drake, Jr. 贡献。）"

#: ../../whatsnew/2.2.rst:1042
msgid ""
"A :class:`~threading.Timer` class was added to the :mod:`threading` module "
"that allows scheduling an activity to happen at some future time.  "
"(Contributed by Itamar Shtull-Trauring.)"
msgstr ""
":class:`~threading.Timer` 模块中新增了一个 :mod:`threading` 类，可以调度某个活动在未来某个时间发生。 （由 "
"Itamar Shtull-Trauring 贡献。）"

#: ../../whatsnew/2.2.rst:1050
msgid "Interpreter Changes and Fixes"
msgstr "解释器的改变和修正"

#: ../../whatsnew/2.2.rst:1052
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"有些变化只会影响那些在 C 级别处理 Python 解释器的人，因为他们正在编写 Python "
"扩展模块、嵌入解释器或仅仅是在修改解释器本身。如果你只编写 Python 代码，这里描述的变化对你几乎没有影响。"

#: ../../whatsnew/2.2.rst:1057
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors"
" of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The"
" existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"性能分析和追踪函数现在可以用 C 语言来实现，相比基于 Python 的函数能够显著提高运行速度并能够减少性能分析和追踪的资源开销。 Python "
"开发环境的编写者对此将会很感兴趣。 Python 的 API 增加了两个新的 C 函数，:c:func:`PyEval_SetProfile` 和 "
":c:func:`PyEval_SetTrace`。 现有的 :func:`sys.setprofile` 和 :func:`sys.settrace`"
" 函数仍然存在，并已简单地更改为使用新的 C 层级接口。 （由 Fred L. Drake, Jr. 贡献。）"

#: ../../whatsnew/2.2.rst:1066
msgid ""
"Another low-level API, primarily of interest to implementers of Python "
"debuggers and development tools, was added. "
":c:func:`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let "
"a caller walk through all the existing interpreter objects; "
":c:func:`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` "
"allow looping over all the thread states for a given interpreter.  "
"(Contributed by David Beazley.)"
msgstr ""
"增加了另一套低层级 API，它主要面向 Python 调试器和开发工具的实现者。 :c:func:`PyInterpreterState_Head` 和"
" :c:func:`PyInterpreterState_Next` "
"可让调用方访问所有现存的解释器对象；:c:func:`PyInterpreterState_ThreadHead` 和 "
":c:func:`PyThreadState_Next` 允许对某个解释器的所有线程状态执行循环。 （由 David Beazley 贡献。）"

#: ../../whatsnew/2.2.rst:1073
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug"
" misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"垃圾收集器的 C 级接口已经发生了变化，使得编写支持垃圾收集的扩展类型和调试函数误用变得更容易。各种函数的语义略有不同，因此需要重命名一系列函数。使用旧"
" API 的扩展仍然可以编译，但不会参与垃圾收集，因此应优先考虑将它们更新为 2.2 版本。"

#: ../../whatsnew/2.2.rst:1080
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr "要将一个扩展模块升级至新 API，请执行下列步骤:"

#: ../../whatsnew/2.2.rst:1082
msgid "Rename :c:macro:`!Py_TPFLAGS_GC` to :c:macro:`Py_TPFLAGS_HAVE_GC`."
msgstr "将 :c:macro:`!Py_TPFLAGS_GC` 重命名为 :c:macro:`Py_TPFLAGS_HAVE_GC`。"

#: ../../whatsnew/2.2.rst:1084
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr "使用 :c:func:`PyObject_GC_New` 或 :c:func:`PyObject_GC_NewVar` 来分配"

#: ../../whatsnew/2.2.rst:1085
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "对象，并使用 :c:func:`PyObject_GC_Del` 来释放它们。"

#: ../../whatsnew/2.2.rst:1087
msgid ""
"Rename :c:func:`!PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and "
":c:func:`!PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ""
"将 :c:func:`!PyObject_GC_Init` 重命名为 :c:func:`PyObject_GC_Track` 并将 "
":c:func:`!PyObject_GC_Fini` 重命名为 :c:func:`PyObject_GC_UnTrack`。"

#: ../../whatsnew/2.2.rst:1090
msgid "Remove :c:macro:`!PyGC_HEAD_SIZE` from object size calculations."
msgstr "从对象大小计算中移除 :c:macro:`!PyGC_HEAD_SIZE`。"

#: ../../whatsnew/2.2.rst:1092
msgid ""
"Remove calls to :c:func:`!PyObject_AS_GC` and :c:func:`!PyObject_FROM_GC`."
msgstr "移除对 :c:func:`!PyObject_AS_GC` 和 :c:func:`!PyObject_FROM_GC` 的调用。"

#: ../../whatsnew/2.2.rst:1094
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et``"
" takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following "
"section.)"
msgstr ""
"向 :c:func:`PyArg_ParseTuple` 添加了一个新的 ``et`` 格式序列；``et`` "
"接受一个形参和一个编码格式名称，如果该形参值是一个 Unicode 字符串则将其转换为给定的编码格式，或者如果它是一个 8 "
"比特位字符串则让其保持原样，即假定它已经使用了适当的编码格式。 这不同于 ``es`` 格式字符，它假定该 8 比特位字符串是使用 Python 默认的"
" ASCII 编码格式并将其转换为指定的新编码格式。 （由 M.-A. Lemburg 贡献，用于下一节所描述的 Windows 上的 MBCS "
"支持。）"

#: ../../whatsnew/2.2.rst:1103
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been"
" added that's simpler and presumably faster.  Instead of specifying a format"
" string, the caller simply gives the minimum and maximum number of arguments"
" expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"增加了一个不同的解析函数 :c:func:`PyArg_UnpackTuple`，它更为简单并且应该也更为快速。 "
"调用方不必再指定格式字符串，而是简单地给出所预期参数的最小和最大数量，以及一组指向将以这些参数值来填充的 :c:expr:`PyObject*` "
"变量的指针。"

#: ../../whatsnew/2.2.rst:1109
msgid ""
"Two new flags :c:macro:`METH_NOARGS` and :c:macro:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses "
":c:macro:`METH_VARARGS`.  Also, the old :c:macro:`!METH_OLDARGS` style of "
"writing C methods is  now officially deprecated."
msgstr ""
"在方法定义表中可使用两个新的旗标 :c:macro:`METH_NOARGS` 和 :c:macro:`METH_O` "
"来简化无参数或只有单个未定类型参数的方法的实现。 调用这样的方法比调用使用 :c:macro:`METH_VARARGS` 的相应方法更高效。 "
"此外，编写 C 方法的旧风格 :c:macro:`!METH_OLDARGS` 现已正式被弃用。"

#: ../../whatsnew/2.2.rst:1115
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and "
":c:func:`PyOS_vsnprintf` were added to provide  cross-platform "
"implementations for the relatively new :c:func:`snprintf` and "
":c:func:`vsnprintf` C lib APIs. In contrast to the standard "
":c:func:`sprintf` and :c:func:`!vsprintf` functions, the Python versions "
"check the bounds of the buffer used to protect against buffer overruns. "
"(Contributed by M.-A. Lemburg.)"
msgstr ""
"新增了两个包装器函数 :c:func:`PyOS_snprintf` 和 :c:func:`PyOS_vsnprintf` 以提供相对较新的 "
":c:func:`snprintf` 和 :c:func:`vsnprintf` C 库 API 的跨平台实现。 与标准的 "
":c:func:`sprintf` 和 :c:func:`!vsprintf` 函数相比，Python 版本会检查缓冲区边界用以防止缓冲区溢出。 （由 "
"M.-A. Lemburg 贡献。）"

#: ../../whatsnew/2.2.rst:1122
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
":c:func:`_PyTuple_Resize` 函数去掉了一个未使用的形参，因此现在它接受 2 个形参而不是 3 个。 "
"第三个参数从未被使用，在将代码从较早的版本移植到 Python 2.2 时可以简单地丢弃它。"

#: ../../whatsnew/2.2.rst:1130
msgid "Other Changes and Fixes"
msgstr "其他的改变和修正"

#: ../../whatsnew/2.2.rst:1132
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches"
" and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"像往常一样，源代码树中散布着许多其他改进和错误修复。通过搜索 CVS 更改日志，可以发现 Python 2.1 到 2.2 之间应用了 527 "
"个补丁并修复了 683 个错误；2.2.1 应用了 139 个补丁并修复了 143 个错误；2.2.2 应用了 106 个补丁并修复了 82 "
"个错误。这些数字可能是低估的。"

#: ../../whatsnew/2.2.rst:1138
msgid "Some of the more notable changes are:"
msgstr "一些较为重要的改变:"

#: ../../whatsnew/2.2.rst:1140
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support"
" MacOS X."
msgstr ""
"适用于 MacOS 的 Python 移植代码现在保存在主 Python CVS 树中，由 Jack Jansen 维护，并且为了支持 MacOS "
"X，进行了许多更改。"

#: ../../whatsnew/2.2.rst:1143
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this"
" (actually, there is the disadvantage that you have to change your PATH to "
"be able to find Python), but it is the basis for creating a full-blown "
"Python application, porting the MacPython IDE, possibly using Python as a "
"standard OSA scripting language and much more.\""
msgstr ""
"最重要的变化是能够将 Python 作为框架来进行构建，这可以通过在编译 Python 时向配置脚本提供 :option:`!--enable-"
"framework` 选项来启用。 根据 Jack Jansen 的说法，“这会将一个独立的 Python 安装版加上 OS X 框架‘粘合起来’放到 "
":file:`/Library/Frameworks/Python.framework` 中（或者其他选定的位置）。 "
"就目前而言这样做并没有什么直接的额外好处（实际上，这样做还存在必须更改 PATH 才能找到Python 的坏处），但它是创建完整的 Python "
"应用程序、移植 MacPython IDE、并可能使用 Python 作为标准 OSA 脚本语言及其他更多功能的基础。”"

#: ../../whatsnew/2.2.rst:1154
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as"
" windowing, QuickTime, scripting, etc. have been ported to OS X, but they've"
" been left commented out in :file:`setup.py`.  People who want to experiment"
" with these modules can uncomment them manually."
msgstr ""
"作为 MacOS API 如 windowing, QuickTime, scripting 等的接口的许多 MacPython 工具箱模块已被移植到 "
"OS X，但它们在 :file:`setup.py` 中被注释掉了。 希望尝试这些模块的人可以手动取消注释它们。"

#: ../../whatsnew/2.2.rst:1177
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"现在将关键字参数传给不接受它们的内置函数会导致引发 :exc:`TypeError` 异常，并附带消息 \"*function* takes no "
"keyword arguments\"。"

#: ../../whatsnew/2.2.rst:1181
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of"
" the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the "
":mod:`weakref` module to become a built-in exception."
msgstr ""
"在 Python 2.1 中作为扩展模块加入的弱引用现在已成为核心组成部分，因为它们被用于新式类的实现。 为此 "
":exc:`ReferenceError` 异常也已从 :mod:`weakref` 模块移出成为一个内置异常。"

#: ../../whatsnew/2.2.rst:1186
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"由 Tim Peters 编写的新脚本 :file:`Tools/scripts/cleanfuture.py` 可自动从 Python "
"源代码移除过时的 ``__future__`` 语句。"

#: ../../whatsnew/2.2.rst:1190
msgid ""
"An additional *flags* argument has been added to the built-in function "
":func:`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"向内置函数 :func:`compile` 添加了一个额外的 *flags* 参数，以便现在 ``__future__`` 语句的行为能在模拟的 "
"shell，例如由 IDLE 和其他开发环境所提供的此类工具中被正确地观察。 此特性的描述参见 :pep:`264`。 （由 Michael "
"Hudson 贡献。）"

#: ../../whatsnew/2.2.rst:1196
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to"
" embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Python 1.6 引入的新许可证与 GPL 不兼容。通过对 2.2 许可证进行一些小的文本修改，这个问题得以解决，因此现在可以合法地将 Python"
" 嵌入到 GPL 授权的程序中。请注意，Python 本身并不是在 GPL 授权下，而是采用一个与 BSD "
"许可证本质上等效的许可证，这与之前的情况一样。这些许可证更改也应用到了 Python 2.0.1 和 2.1.1 版本中。"

#: ../../whatsnew/2.2.rst:1203
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default"
" encoding turns out to be an annoyance.  On Unix, the locale's character set"
" is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"在 Windows 上，当 Python 遇到一个 Unicode 文件名时，现在会将其转换为 MBCS 编码的字符串，这种编码由 Microsoft "
"文件 API 使用。由于文件 API 明确使用 MBCS 编码，Python 默认选择 ASCII 作为编码方式显得很不方便。在 Unix 上，如果 "
"``locale.nl_langinfo(CODESET)`` 可用，Python 将使用本地字符集。（Windows 支持由 Mark Hammond"
" 提供，Marc-André Lemburg 提供协助。Unix 支持由 Martin von Löwis 添加。）"

#: ../../whatsnew/2.2.rst:1211
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr "大文件支持目前已在 Windows 上启用。 （由 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:1213
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
":file:`Tools/scripts/ftpmirror.py` 脚本现在会解析 :file:`.netrc` 文件，如果存在的话。 （由 Mike"
" Romberg 贡献。）"

#: ../../whatsnew/2.2.rst:1216
msgid ""
"Some features of the object returned by the :func:`!xrange` function are now"
" deprecated, and trigger warnings when they're accessed; they'll disappear "
"in Python 2.3. :class:`!xrange` objects tried to pretend they were full "
"sequence types by supporting slicing, sequence multiplication, and the "
":keyword:`in` operator, but these features were rarely used and therefore "
"buggy.  The :meth:`!tolist` method and the :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` attributes are also being deprecated.  At the C level, the"
" fourth argument to the :c:func:`!PyRange_New` function, ``repeat``, has "
"also been deprecated."
msgstr ""
"由 :func:`!xrange` 函数所返回的对象的某些特性现在已被弃用，当它们被访问时将会触发警告；它们将在 Python 2.3 中被去除。 "
":class:`!xrange` 对象曾试图伪装成完全的序列类型，支持切片、序列乘法以及 :keyword:`in` "
"运算符等，但这些特性很少被使用因而存在许多缺陷。 :meth:`!tolist` 方法以及 :attr:`!start`, :attr:`!stop` "
"和 :attr:`!step` 属性也已被弃用。 在 C 层级上，传给 :c:func:`!PyRange_New` 函数的第四个参数 "
"``repeat`` 也已被弃用。"

#: ../../whatsnew/2.2.rst:1225
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a"
" case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"字典实现中有一堆补丁，主要是为了修复潜在的核心转储问题，这些问题发生在字典中包含的对象悄悄改变其哈希值，或者在它们所包含的字典中发生突变时。那段时间，python-"
"dev 邮件列表进入了一个微妙的节奏：Michael Hudson 发现一个导致核心转储的案例，Tim Peters 修复这个 bug，接着 "
"Michael 又发现另一个案例，如此反复循环。"

#: ../../whatsnew/2.2.rst:1232
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"在 Windows 上，Python 现在可以使用 Borland C 编译，这要归功于 Stephen Hansen "
"提供的多个补丁，尽管结果还不完全可用。（但这*确实*是一个进步……）"

#: ../../whatsnew/2.2.rst:1236
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"另一个 Windows 改进：Wise Solutions 慷慨地向 PythonLabs 提供了他们的 InstallerMaster 8.1 "
"系统。早期的 PythonLabs Windows 安装程序使用的是 Wise 5.0a，已经开始显得过时。（由 Tim Peters 打包。）"

#: ../../whatsnew/2.2.rst:1240
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David"
" Bolen.)"
msgstr ""
"在 Windows 上现在将会导入以 ``.pyw`` 结尾的文件。 ``.pyw`` 是 Windows 专属的，用来指明一个脚本需要使用 "
"PYTHONW.EXE 而不是 PYTHON.EXE 来运行以避免弹出 DOS 控制台来显示输出。 "
"该补丁使得导入这样的脚本成为可能，让它们也可以作为模块来使用。 （由 David Bolen 实现。）"

#: ../../whatsnew/2.2.rst:1246
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by "
":c:func:`dlopen` using the :func:`sys.getdlopenflags` and "
":func:`sys.setdlopenflags` functions. (Contributed by Bram Stolk.)"
msgstr ""
"在 Python 会使用 C :c:func:`dlopen` 函数来加载扩展模块的平台上，现在可以使用 "
":func:`sys.getdlopenflags` 和 :func:`sys.setdlopenflags` 等函数来设置 "
":c:func:`dlopen` 所使用的旗标。 （由 Bram Stolk 贡献。）"

#: ../../whatsnew/2.2.rst:1251
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating-point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"当传入浮点数时 :func:`pow` 内置函数已不再支持 3 个参数。 ``pow(x, y, z)`` 将返回 ``(x**y) % "
"z``，但这对于浮点数来说没有用处，并且其最终结果会因具体平台的不同而产生不可预料的变化。 现在 ``pow(2.0, 8.0, 7.0)`` "
"这样的调用将会引发 :exc:`TypeError` 异常。"

#: ../../whatsnew/2.2.rst:1261
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.2.rst:1263
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack"
" Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay,"
" Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van"
" Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"作者感谢以下人员为本文的各种草案提供建议、更正和帮助： Fred Bremmer、Keith Briggs、Andrew Dalke、Fred L. "
"Drake、Jr.、Carel Fellinger、David Goodger、Mark Hammond、Stephen Hansen、Michael "
"Hudson、Jack Jansen、Marc-André Lemburg、Martin von Löwis、Fredrik Lundh、Michael"
" McLay、Nick Mathewson、Paul Moore、Gustavo Niemeyer、Don O'Donnell、Joonas "
"Paalasma、Tim Peters、Jens Quade、Tom Reinhardt、Neil Schemenauer、Guido van "
"Rossum、Greg Ward、Edward Welbourne。"
