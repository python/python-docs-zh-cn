# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 18:10+0000\n"
"PO-Revision-Date: 2025-07-18 20:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "Python 2.2 有什么新变化"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "概述"

#: ../../whatsnew/2.2.rst:15
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 "
"的问题修正发布版，最初发布于 2001 年 12 月 21 日。"

#: ../../whatsnew/2.2.rst:19
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 可以被看作是 \"清理发布版\"。 "
"有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的，都是为了清理语言设计中的不规范和阴暗角落。"

#: ../../whatsnew/2.2.rst:24
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you"
" should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"本文并不试图提供对新特性的完整规范说明，而是提供一个便捷的概览。 要获取全部细节，你应该参阅 Python 2.2 的文档，比如 `Python 库参考"
" <https://docs.python.org/2.2/lib/lib.html>`_ 和 `Python 参考指南 "
"<https://docs.python.org/2.2/ref/ref.html>`_。 "
"如果你想要了解某项更改的完整实现和设计理念，请参阅特定新特性的 PEP。"

#: ../../whatsnew/2.2.rst:43
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 和 253：类型和类的修改"

#: ../../whatsnew/2.2.rst:45
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so"
" it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"Python 2.2 中最大且影响最深远的改变是针对 Python 的对象和类模型。 "
"这些变化应该是向下兼容的，因此你的代码将能继续运行而无需修改，但这些变化提供了一些很棒的新功能。 "
"在开始本文最长和最复杂的部分之前，我提供对这些变化的概览并附带一些注释。"

#: ../../whatsnew/2.2.rst:52
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of"
" the most significant flaws was that it's impossible to subclass Python "
"types implemented in C.  In particular, it's not possible to subclass built-"
"in types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but"
" there's lots of C code that expects a regular Python list and won't accept "
"a :class:`UserList` instance."
msgstr ""

#: ../../whatsnew/2.2.rst:61
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr "Python 2.2 修正了此问题，并在此过程中添加了一些令人激动的新功能。 简明概述如下:"

#: ../../whatsnew/2.2.rst:64
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr "你可以继承内置类型，例如列表和整数，并且你的子类应该在任何需要原始类型的地方正常工作。这使得 Python 的面向对象编程更加灵活和强大。"

#: ../../whatsnew/2.2.rst:67
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr "现在，除了之前版本的 Python 中可用的实例方法外，还可以定义静态方法和类方法。这使得你可以更灵活地组织类的行为。"

#: ../../whatsnew/2.2.rst:70
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`__getattr__` can be rewritten to use properties instead, "
"making the resulting code simpler and faster.  As a small side benefit, "
"attributes can now have docstrings, too."
msgstr ""

#: ../../whatsnew/2.2.rst:76
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr "可以使用 __slots__ 限制实例的合法属性列表，从而防止拼写错误，并且在未来的 Python 版本中可能进行更多的优化。"

#: ../../whatsnew/2.2.rst:80
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the"
" new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being"
" lost."
msgstr ""
"一些用户对这些变化表示担忧。确实，他们说，新功能很棒，可以实现以前版本的 Python "
"无法做到的各种技巧，但它们也使语言变得更加复杂。一些人表示，他们一直推荐 Python 是因为它的简单性，现在感觉这种简单性正在丧失。"

#: ../../whatsnew/2.2.rst:86
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"个人而言，我认为没有必要担心。许多新功能相当深奥，你可以编写大量 Python "
"代码而不需要了解它们。编写一个简单的类并不比以前更难，因此除非确实需要，否则你不必费心去学习或教授这些新功能。一些以前只有在 C "
"语言中才能实现的非常复杂的任务，现在可以用纯 Python 实现，在我看来，这一切都更好了。"

#: ../../whatsnew/2.2.rst:93
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will"
" paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"我不会尝试涵盖所有为了使新功能生效而需要的每一个边缘情况和小改动。相反，本节将只勾勒出大致的轮廓。有关 Python 2.2 "
"新对象模型的更多信息，请参见 :ref:`sect-rellinks` 的“相关链接”部分。"

#: ../../whatsnew/2.2.rst:100
msgid "Old and New Classes"
msgstr "旧式类和新式类"

#: ../../whatsnew/2.2.rst:102
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python."
"  All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"首先，你应该知道 Python 2.2 实际上有两种类型的类：经典类（或旧式类）和新式类。旧式类模型与早期版本的 Python "
"中的类模型完全相同。本节描述的所有新功能仅适用于新式类。这种分歧并不是永久的；最终，旧式类将被淘汰，可能在 Python 3.0 中被移除。"

#: ../../whatsnew/2.2.rst:109
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A"
" new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"那么如何定义一个新式类呢？你可以通过继承一个现有的新式类来实现。大多数 Python "
"内置类型，如整数、列表、字典，甚至文件，现在都是新式类。此外，还添加了一个名为 :class:`object` "
"的新式类，它是所有内置类型的基类，因此如果没有合适的内置类型，你可以直接继承 :class:`object` 类："

#: ../../whatsnew/2.2.rst:121
msgid ""
"This means that :keyword:`class` statements that don't have any base classes"
" are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`__metaclass__` --- see "
":pep:`253` for the details --- but it's easier to just subclass "
":class:`object`.)"
msgstr ""

#: ../../whatsnew/2.2.rst:126
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named "
":func:`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions "
"any more, but type objects that behave as factories when called. ::"
msgstr ""
"内置类型的类型对象在 Python 2.2 中作为内置对象提供，使用了一种巧妙的技巧命名。Python 一直有名为 "
":func:`int`、:func:`float` 和 :func:`str` 的内置函数。在 Python 2.2 "
"中，它们不再是函数，而是作为被调用时表现为工厂的类型对象。"

#: ../../whatsnew/2.2.rst:136
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` and"
" :func:`file` have been added.  Here's a more interesting example, adding a "
":meth:`lock` method to file objects::"
msgstr ""

#: ../../whatsnew/2.2.rst:146
msgid ""
"The now-obsolete :mod:`posixfile` module contained a class that emulated all"
" of a file object's methods and also added a :meth:`lock` method, but this "
"class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`LockableFile`."
msgstr ""

#: ../../whatsnew/2.2.rst:153
msgid "Descriptors"
msgstr "描述器"

#: ../../whatsnew/2.2.rst:155
msgid ""
"In previous versions of Python, there was no consistent way to discover what"
" attributes and methods were supported by an object. There were some "
"informal conventions, such as defining :attr:`__members__` and "
":attr:`__methods__` attributes that were lists of names, but often the "
"author of an extension type or a class wouldn't bother to define them.  You "
"could fall back on inspecting the :attr:`~object.__dict__` of an object, but"
" when class inheritance or an arbitrary :meth:`__getattr__` hook were in use"
" this could still be inaccurate."
msgstr ""

#: ../../whatsnew/2.2.rst:163
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class"
" methods become possible, as well as more exotic constructs."
msgstr ""
"新类模型的一个核心理念是正式化了使用描述符来描述对象属性的 API。描述符指定属性的值，说明它是方法还是字段。通过描述符 "
"API，静态方法和类方法成为可能，以及其他更复杂的构造。"

#: ../../whatsnew/2.2.rst:169
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a"
" few attributes of their own:"
msgstr "属性描述符是存在于类对象内部的对象，它们自身具有一些属性。描述符协议由三个主要方法组成："

#: ../../whatsnew/2.2.rst:172
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` 是属性的名称。"

#: ../../whatsnew/2.2.rst:174
msgid ":attr:`__doc__` is the attribute's docstring."
msgstr ":attr:`__doc__` 是属性的文档字符串。"

#: ../../whatsnew/2.2.rst:176
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr "``__get__(object)`` 是一个从 *object* 中提取属性值的方法。"

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` 将 *object* 上的属性设为 *value*。"

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` 将删除 *object* 的 *value* 属性。"

#: ../../whatsnew/2.2.rst:183
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr "例如，当你写下 ``obj.x``，Python 实际要执行的步骤是::"

#: ../../whatsnew/2.2.rst:189
msgid ""
"For methods, :meth:`descriptor.__get__` returns a temporary object that's "
"callable, and wraps up the instance and the method to be called on it. This "
"is also why static methods and class methods are now possible; they have "
"descriptors that wrap up just the method, or the method and the class.  As a"
" brief explanation of these new kinds of methods, static methods aren't "
"passed the instance, and therefore resemble regular functions.  Class "
"methods are passed the class of the object, but not the object itself.  "
"Static and class methods are defined like this::"
msgstr ""

#: ../../whatsnew/2.2.rst:207
msgid ""
"The :func:`staticmethod` function takes the function :func:`f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""

#: ../../whatsnew/2.2.rst:213
msgid ""
"More new features, such as slots and properties, are also implemented as new"
" kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"更多的新功能，如 __slots__ "
"和属性，也作为新类型的描述符实现。编写一个实现新功能的描述符类并不困难。例如，可以编写一个描述符类，使其能够为方法编写类似 Eiffel "
"风格的前置条件和后置条件。使用该功能的类可能定义如下："

#: ../../whatsnew/2.2.rst:235
msgid ""
"Note that a person using the new :func:`eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features"
" don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""

#: ../../whatsnew/2.2.rst:244
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "多重继承：钻石规则"

#: ../../whatsnew/2.2.rst:246
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram"
" taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"通过改变名称解析规则，多重继承也变得更加有用。  请看下面这组类（图表摘自 :pep:`253` ，作者 Guido van Rossum）："

#: ../../whatsnew/2.2.rst:264
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to "
":meth:`D.save` will search the classes :class:`D`, :class:`B`, and then "
":class:`A`, where :meth:`save` would be found and returned.  :meth:`C.save` "
"would never be found at all.  This is bad, because if :class:`C`'s "
":meth:`save` method is saving some internal state specific to :class:`C`, "
"not calling it will result in that state never getting saved."
msgstr ""

#: ../../whatsnew/2.2.rst:272
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated"
" to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"新式类遵循一种不同的算法，虽然解释起来有点复杂，但在这种情况下能做正确的事情。（请注意，Python 2.3 "
"改变了这个算法，在大多数情况下会产生相同的结果，但对于非常复杂的继承图会产生更有用的结果。）"

#: ../../whatsnew/2.2.rst:277
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`D`, :class:`B`, :class:`A`, :class:`C`, "
":class:`A`]."
msgstr ""

#: ../../whatsnew/2.2.rst:282
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`D`, :class:`B`, :class:`C`, :class:`A`] after dropping"
" duplicates."
msgstr ""

#: ../../whatsnew/2.2.rst:287
msgid ""
"Following this rule, referring to :meth:`D.save` will return :meth:`C.save`,"
" which is the behaviour we're after.  This lookup rule is the same as the "
"one followed by Common Lisp.  A new built-in function, :func:`super`, "
"provides a way to get at a class's superclasses without having to "
"reimplement Python's algorithm. The most commonly used form will be  "
"``super(class, obj)``, which returns  a bound superclass object (not the "
"actual class object).  This form will be used in methods to call a method in"
" the superclass; for example, :class:`D`'s :meth:`save` method would look "
"like this::"
msgstr ""

#: ../../whatsnew/2.2.rst:303
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often"
" be useful."
msgstr ""
":func:`super` 在以 ``super(class)`` 或 ``super(class1, class2)`` "
"形式调用时也可以返回未绑定的超类对象，但这可能并不常用。"

#: ../../whatsnew/2.2.rst:309
msgid "Attribute Access"
msgstr "属性访问"

#: ../../whatsnew/2.2.rst:311
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as "
"``obj.get_parent``.  Python 2.2 adds some new ways of controlling attribute "
"access."
msgstr ""

#: ../../whatsnew/2.2.rst:317
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"首先，新式类仍然支持 ``__getattr__(attr_name)``，关于它的任何内容都没有改变。  和以前一样，当试图访问 "
"``obj.foo`` 时，如果在实例的字典中找不到名为 ``foo`` 的属性，就会调用它。"

#: ../../whatsnew/2.2.rst:322
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`__getattribute__` is *always* called whenever any attribute is "
"accessed, while the old :meth:`__getattr__` is only called if ``foo`` isn't "
"found in the instance's dictionary."
msgstr ""

#: ../../whatsnew/2.2.rst:328
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of "
":attr:`~object.__dict__`. :meth:`__getattr__` methods also end up being "
"called by Python when it checks for other methods such as :meth:`__repr__` "
"or :meth:`__coerce__`, and so have to be written with this in mind. Finally,"
" calling a function on every attribute access results in a sizable "
"performance loss."
msgstr ""

#: ../../whatsnew/2.2.rst:337
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you"
" want to define a :attr:`size` attribute that's computed, but also settable,"
" you could write::"
msgstr ""

#: ../../whatsnew/2.2.rst:357
msgid ""
"That is certainly clearer and easier to write than a pair of "
":meth:`__getattr__`/:meth:`__setattr__` methods that check for the "
":attr:`size` attribute and handle it specially while retrieving all other "
"attributes from the instance's :attr:`~object.__dict__`.  Accesses to "
":attr:`size` are also the only ones which have to perform the work of "
"calling a function, so references to other attributes run at their usual "
"speed."
msgstr ""

#: ../../whatsnew/2.2.rst:364
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing "
"``obj.new_attr=1``.   A new-style class can define a class attribute named "
":attr:`~object.__slots__` to limit the legal attributes  to a particular set"
" of names.  An example will make this clear::"
msgstr ""
"最后，可以使用新的类属性 :attr:`~object.__slots__` 来限制对象上可以引用的属性列表。Python "
"对象通常非常动态，可以随时通过简单地 ``obj.new_attr=1`` 来定义一个新属性。新式类可以定义一个名为 "
":attr:`~object.__slots__` 的类属性，以将合法属性限制为特定的一组名称。一个例子可以更清楚地说明这一点："

#: ../../whatsnew/2.2.rst:385
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"注意，当尝试为未列在 :attr:`~object.__slots__` 中的属性赋值时，会引发 :exc:`AttributeError`。"

#: ../../whatsnew/2.2.rst:392
msgid "Related Links"
msgstr "相关链接"

#: ../../whatsnew/2.2.rst:394
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr "本节只是对新特性进行了简要概述，提供了足够的解释以帮助你开始编程，但许多细节已被简化或忽略。想要获得更全面的了解，你可以去哪里呢？"

#: ../../whatsnew/2.2.rst:398
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much"
" more detail about the new features while still remaining quite easy to "
"read."
msgstr ""
":ref:`descriptorhowto` 是由 Guido van Rossum 编写的一篇介绍描述器特性详细教程。 "
"如果我的描述激起了你的兴趣，请继续阅读这篇教程，因为它更加详细地介绍了这些新功能，同时仍然保持了相当的易读性。"

#: ../../whatsnew/2.2.rst:403
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is"
" titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  "
":pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"接下来，有两个相关的 PEP，即 :pep:`252` 和 :pep:`253`。:pep:`252` 标题为“使类型更像类”，涵盖了描述符 "
"API。:pep:`253` 标题为“内置类型的子类型化”，描述了使内置对象可以进行子类型化的类型对象的更改。:pep:`253` 是这两个 PEP "
"中更复杂的一个，在某些点上，必要的类型和元类型解释可能会让人感到头疼。两个 PEP 都由 Guido van Rossum 编写和实现，并得到了 "
"Zope Corp. 团队其他成员的实质性协助。"

#: ../../whatsnew/2.2.rst:412
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"最后，还有最终的权威来源：源代码。大部分类型处理的机制都在 :file:`Objects/typeobject.c` "
"中，但只有在所有其他途径都用尽之后，包括在 python-list 或 python-dev 上发布问题后，才应求助于源代码。"

#: ../../whatsnew/2.2.rst:421
msgid "PEP 234: Iterators"
msgstr "PEP 234: 迭代器"

#: ../../whatsnew/2.2.rst:423
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr "Python 2.2 的另一个重要新增功能是在 C 和 Python 两个层面上引入了迭代接口。对象可以定义如何被调用者循环遍历。"

#: ../../whatsnew/2.2.rst:426
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work"
" is to define a :meth:`__getitem__` method that looks something like this::"
msgstr ""

#: ../../whatsnew/2.2.rst:432
msgid ""
":meth:`__getitem__` is more properly used to define an indexing operation on"
" an object so that you can write ``obj[5]`` to retrieve the sixth element.  "
"It's a bit misleading when you're using this only to support :keyword:`for` "
"loops. Consider some file-like object that wants to be looped over; the "
"*index* parameter is essentially meaningless, as the class probably assumes "
"that a series of :meth:`__getitem__` calls will be made with *index* "
"incrementing by one each time.  In other words, the presence of the "
":meth:`__getitem__` method doesn't mean that using ``file[5]``  to randomly "
"access the sixth element will work, though it really should."
msgstr ""

#: ../../whatsnew/2.2.rst:442
msgid ""
"In Python 2.2, iteration can be implemented separately, and "
":meth:`__getitem__` methods can be limited to classes that really do support"
" random access.  The basic idea of iterators is  simple.  A new built-in "
"function, ``iter(obj)`` or ``iter(C, sentinel)``, is used to get an "
"iterator. ``iter(obj)`` returns an iterator for the object *obj*, while "
"``iter(C, sentinel)`` returns an iterator that will invoke the callable "
"object *C* until it returns *sentinel* to signal that the iterator is done."
msgstr ""

#: ../../whatsnew/2.2.rst:450
msgid ""
"Python classes can define an :meth:`__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator,"
" this method can just return ``self``.  In particular, iterators will "
"usually be their own iterators.  Extension types implemented in C can "
"implement a :c:member:`~PyTypeObject.tp_iter` function in order to return an"
" iterator, and extension types that want to behave as iterators can define a"
" :c:member:`~PyTypeObject.tp_iternext` function."
msgstr ""

#: ../../whatsnew/2.2.rst:457
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"总结一下，迭代器实际上做什么？它们有一个必需的方法 :meth:`next`，该方法不接受任何参数并返回下一个值。当没有更多的值可以返回时，调用 "
":meth:`next` 应该引发 :exc:`StopIteration` 异常。以下是一个简单的例子来说明迭代器的工作原理："

#: ../../whatsnew/2.2.rst:478
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`__iter__` or a "
":c:member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""

#: ../../whatsnew/2.2.rst:492
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling "
":func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr "迭代器支持已被添加到Python的一些基本类型中。对字典调用 :func:`iter` 会返回一个迭代器，该迭代器遍历字典的键，如下所示："

#: ../../whatsnew/2.2.rst:512
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`iterkeys`, "
":meth:`itervalues`, or :meth:`iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on"
" dictionaries, so ``key in dict`` is now equivalent to "
"``dict.has_key(key)``."
msgstr ""

#: ../../whatsnew/2.2.rst:518
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each"
" line of a file using code like this::"
msgstr ""
"文件也提供了一个迭代器，它会调用 :meth:`readline` "
"方法，直到文件中没有更多的行。这意味着你现在可以使用类似这样的代码来读取文件的每一行："

#: ../../whatsnew/2.2.rst:526
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol"
" only requires a :meth:`next` method."
msgstr ""
"请注意，你只能在迭代器中向前移动；没有办法获取前一个元素、重置迭代器或复制迭代器。一个迭代器对象可以提供这些额外的功能，但迭代器协议只要求有一个 "
":meth:`next` 方法。"

#: ../../whatsnew/2.2.rst:535
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - 迭代器"

#: ../../whatsnew/2.2.rst:535
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly"
" by GvR and Tim Peters."
msgstr "由 Ka-Ping Yee 和 GvR 撰写；由 Python Labs 小组（主要由 GvR 和 Tim Peters）实现。"

#: ../../whatsnew/2.2.rst:542
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: 简单的生成器"

#: ../../whatsnew/2.2.rst:544
msgid ""
"Generators are another new feature, one that interacts with the introduction"
" of iterators."
msgstr "生成器是另一个新增特性，它是与迭代器的引入相互关联的。"

#: ../../whatsnew/2.2.rst:547
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When"
" you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local"
" variables. But, what if the local variables weren't thrown away on exiting "
"a function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"你一定熟悉在Python或C语言中函数调用的工作方式。当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。当函数执行到 "
":keyword:`return` "
"语句时，这些局部变量会被销毁，并将结果值返回给调用者。稍后对同一个函数的调用将获得一套全新的局部变量。但，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。"

#: ../../whatsnew/2.2.rst:556
msgid "Here's the simplest example of a generator function::"
msgstr "这里是一个生成器函数的最简示例::"

#: ../../whatsnew/2.2.rst:562
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"一个新的关键字 :keyword:`yield` 被引入用于生成器。任何包含 :keyword:`!yield` "
"语句的函数都是生成器函数；这由Python的字节码编译器检测到，并因此对函数进行特殊编译。由于引入了一个新的关键字，生成器必须通过在模块的源代码顶部附近包含一条"
" ``from __future__ import generators`` 语句来显式启用。在Python 2.3中，这条语句将变得不再必要。"

#: ../../whatsnew/2.2.rst:570
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value"
" of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended"
" and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the "
":keyword:`!yield` statement.  (For complicated reasons, the "
":keyword:`!yield` statement isn't allowed inside the :keyword:`!try` block "
"of a :keyword:`try`...\\ :keyword:`finally` statement; read :pep:`255` for a"
" full explanation of the interaction between :keyword:`!yield` and "
"exceptions.)"
msgstr ""
"当你调用一个生成器函数时，它不会返回单个值；相反，它返回一个支持迭代器协议的生成器对象。在执行 :keyword:`yield` 语句时，生成器输出 "
"``i`` 的值，类似于 :keyword:`return` 语句。:keyword:`!yield` 和 :keyword:`!return` "
"语句之间的重大区别在于，当到达 :keyword:`!yield` 时，生成器的执行状态被挂起，并且局部变量被保留。在下一次调用生成器的 "
"``next()`` 方法时，函数将立即在 :keyword:`!yield` 语句之后恢复执行。（由于复杂的原因，:keyword:`!yield` "
"语句不允许在 :keyword:`try` ... :keyword:`finally` 语句的 :keyword:`!try` 块中使用；请阅读 "
":pep:`255` 以获得关于 :keyword:`!yield` 和异常交互的详细解释。）"

#: ../../whatsnew/2.2.rst:583
msgid "Here's a sample usage of the :func:`generate_ints` generator::"
msgstr "这里是 :func:`generate_ints` 生成器的用法示例::"

#: ../../whatsnew/2.2.rst:600
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"你可以等价地写成 ``for i in generate_ints(5)`` 或 ``a,b,c = generate_ints(3)``。"

#: ../../whatsnew/2.2.rst:603
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. "
":keyword:`!return` with a value, such as ``return 5``, is a syntax error "
"inside a generator function.  The end of the generator's results can also be"
" indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"在生成器函数内部， :keyword:`return` "
"语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 :keyword:`!return`，例如 "
"``return 5``，是语法错误。生成器结果的结束也可以通过手动引发 :exc:`StopIteration` "
"异常来指示，或者只是让执行流自然地从函数底部流出。"

#: ../../whatsnew/2.2.rst:611
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. "
":file:`Lib/test/test_generators.py` contains a number of more interesting "
"examples.  The simplest one implements an in-order traversal of a tree using"
" generators recursively. ::"
msgstr ""
"你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 ``self.count`` "
"设置为0，并让 :meth:`next` 方法递增 ``self.count`` "
"并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。:file:`Lib/test/test_generators.py` "
"包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历："

#: ../../whatsnew/2.2.rst:629
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that"
" no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"在 :file:`Lib/test/test_generators.py` "
"中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。"

#: ../../whatsnew/2.2.rst:634
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""

#: ../../whatsnew/2.2.rst:644
msgid ""
"In Icon the :func:`find` function returns the indexes at which the substring"
" \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` is first"
" assigned a value of 3, but 3 is less than 5, so the comparison fails, and "
"Icon retries it with the second value of 23.  23 is greater than 5, so the "
"comparison now succeeds, and the code prints the value 23 to the screen."
msgstr ""

#: ../../whatsnew/2.2.rst:650
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to"
" other functions or stored in a data structure."
msgstr ""
"Python 并没有像 Icon 那样将生成器作为核心概念来采纳。生成器被认为是 Python "
"核心语言的一部分，但学习或使用它们并不是强制性的；如果它们不能解决你的问题，可以完全忽略它们。与 Icon 相比，Python "
"的一个新颖特性是生成器的状态表示为一个具体对象（迭代器），该对象可以传递给其他函数或存储在数据结构中。"

#: ../../whatsnew/2.2.rst:662
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 简单生成器"

#: ../../whatsnew/2.2.rst:662
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer "
"和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。"

#: ../../whatsnew/2.2.rst:669
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: 统一长整数和整数"

#: ../../whatsnew/2.2.rst:671
msgid ""
"In recent versions, the distinction between regular integers, which are "
"32-bit values on most machines, and long integers, which can be of arbitrary"
" size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""

#: ../../whatsnew/2.2.rst:681
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 将根据需要将数值从短整数转换为长整数。'L' 后缀不再需要用于表示长整数字面量，因为现在编译器会自动选择适当的类型。（在未来的 "
"2.x 版本的 Python 中，使用 'L' 后缀将被不鼓励，并在 Python 2.4 中触发警告，可能在 Python 3.0 "
"中被移除。）许多以前会引发 :exc:`OverflowError` 的操作现在会返回一个长整数作为结果。例如："

#: ../../whatsnew/2.2.rst:694
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr "在大多数情况下，整数和长整数现在将被视为相同。你仍然可以使用内置的 :func:`type` 函数区分它们，但这很少需要。"

#: ../../whatsnew/2.2.rst:702
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - 统一长整数和整数"

#: ../../whatsnew/2.2.rst:702
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰写 ; 大部分由 Guido van Rossum 实现。"

#: ../../whatsnew/2.2.rst:709
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238：修改除法运算符"

#: ../../whatsnew/2.2.rst:711
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Python 2.2中最具争议的变化预示着修复一个自Python诞生以来的旧设计缺陷的努力的开始。目前，Python的除法操作符 ``/`` "
"在接收两个整数参数时表现得像C语言的除法操作符：它返回一个被截断为整数的结果。例如，``3/2`` 是1，而不是1.5，``(-1)/2`` "
"是-1，而不是-0.5。这意味着除法的结果可能会根据两个操作数的类型而意外变化，并且由于Python是动态类型的，确定操作数的可能类型可能会很困难。"

#: ../../whatsnew/2.2.rst:721
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether"
" it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"（争议在于这是否*真的*算是一个设计缺陷，以及是否值得为了修复它而破坏现有代码。这在python-"
"dev上引发了无休止的讨论，并在2001年7月爆发成一场在 :newsgroup:`comp.lang.python` "
"的充满讽刺性言辞的风暴。我不会在这里为任何一方辩护，只会描述在2.2中实现的内容。请阅读 :pep:`238` 以获取争论和反驳的摘要。）"

#: ../../whatsnew/2.2.rst:728
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"由于这一变化可能会破坏现有代码，因此它正在非常逐步地引入。Python 2.2 开始了这一过渡，但直到 Python 3.0 这一转换才会完全完成。"

#: ../../whatsnew/2.2.rst:732
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is"
" 0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"首先，我将借用一些来自 :pep:`238` "
"的术语。“真除法”是大多数非程序员所熟悉的除法：3/2是1.5，1/4是0.25，等等。“地板除法”是Python的 ``/`` "
"操作符在给定整数操作数时当前执行的操作；其结果是真除法返回值的地板值。“经典除法”是当前 ``/`` "
"操作符的混合行为；当操作数是整数时，它返回地板除法的结果，而当其中一个操作数是浮点数时，它返回真除法的结果。"

#: ../../whatsnew/2.2.rst:740
msgid "Here are the changes 2.2 introduces:"
msgstr "Python 2.2 引入了以下变化："

#: ../../whatsnew/2.2.rst:742
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and ``1.0 "
"// 2.0`` is also 0.0."
msgstr ""
"一个新的操作符，``//`` 是地板除法操作符。 （是的，我们知道它看起来像 C++ 的注释符号。） ``//`` *始终* "
"执行地板除法，无论其操作数的类型是什么，因此 ``1 // 2`` 是 0，``1.0 // 2.0`` 也是0.0。"

#: ../../whatsnew/2.2.rst:747
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr "``//`` 操作符在Python 2.2中始终可用；你不需要通过 ``__future__`` 语句来启用它。"

#: ../../whatsnew/2.2.rst:750
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"通过在模块中包含 ``from __future__ import division``，``/``操作符将被更改为返回真除法的结果，因此 "
"``1/2`` 是0.5。如果没有这条 ``__future__`` 语句，``/`` 仍然表示经典除法。``/`` 的默认含义在Python "
"3.0之前不会改变。"

#: ../../whatsnew/2.2.rst:755
msgid ""
"Classes can define methods called :meth:`__truediv__` and "
":meth:`__floordiv__` to overload the two division operators.  At the C "
"level, there are also slots in the :c:type:`PyNumberMethods` structure so "
"extension types can define the two operators."
msgstr ""

#: ../../whatsnew/2.2.rst:760
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with "
":option:`!-Q warn` will cause a warning to be issued whenever division is "
"applied to two integers.  You can use this to find code that's affected by "
"the change and fix it.  By default, Python 2.2 will simply perform classic "
"division without a warning; the warning will be turned on by default in "
"Python 2.3."
msgstr ""
"Python 2.2 支持一些命令行参数，用于测试代码是否能在除法语义改变的情况下正常工作。运行 Python 并使用 -Q warn "
"选项时，当对两个整数应用除法时会发出警告。你可以利用这个功能找到受影响的代码并进行修复。默认情况下，Python 2.2 "
"会执行经典除法而不会发出警告；在 Python 2.3 中，警告将默认开启。"

#: ../../whatsnew/2.2.rst:770
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238`：改变除法运算符"

#: ../../whatsnew/2.2.rst:771
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰写 ; 由 Guido van Rossum 实现。"

#: ../../whatsnew/2.2.rst:777
msgid "Unicode Changes"
msgstr "Unicode 的改变"

#: ../../whatsnew/2.2.rst:779
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Python的Unicode支持在2.2版本中有所增强。Unicode字符串通常以UCS-2形式存储，即16位无符号整数。通过向配置脚本提供 "
":option:`!--enable-unicode=ucs4` 选项，Python "
"2.2也可以编译为使用UCS-4（32位无符号整数）作为其内部编码。（也可以指定 :option:`!--disable-unicode` "
"选项来完全禁用Unicode支持。）"

#: ../../whatsnew/2.2.rst:786
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than"
" 65535 will still cause :func:`unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode"
" characters\"; consult it for further details."
msgstr ""

#: ../../whatsnew/2.2.rst:794
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`decode` assumes that the string is in the"
" specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""

#: ../../whatsnew/2.2.rst:801
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"利用这一新特性，编解码器被添加用于与Unicode不直接相关的任务。例如，已经添加了用于uu编码、MIME的base64编码以及使用 "
":mod:`zlib` 模块进行压缩的编解码器："

#: ../../whatsnew/2.2.rst:822
msgid ""
"To convert a class instance to Unicode, a :meth:`__unicode__` method can be "
"defined by a class, analogous to :meth:`__str__`."
msgstr ""

#: ../../whatsnew/2.2.rst:825
msgid ""
":meth:`encode`, :meth:`decode`, and :meth:`__unicode__` were implemented by "
"Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""

#: ../../whatsnew/2.2.rst:832
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - 对 '宽' Unicode 字符的支持"

#: ../../whatsnew/2.2.rst:833
msgid "Written by Paul Prescod."
msgstr "由 Paul Prescod 编写。"

#: ../../whatsnew/2.2.rst:839
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: 嵌套的作用域"

#: ../../whatsnew/2.2.rst:841
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always"
" present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"在Python 2.1中，静态嵌套作用域作为一个可选特性被添加，需要通过 ``from __future__ import "
"nested_scopes`` 指令来启用。在2.2版本中，嵌套作用域不再需要特别启用，现在总是存在。本节的其余部分是从我的《Python "
"2.1的新特性》文档中复制的嵌套作用域描述；如果你在2.1发布时已经阅读过，可以跳过本节的其余部分。"

#: ../../whatsnew/2.2.rst:848
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to"
" Python's scoping rules.  In Python 2.0, at any given time there are at most"
" three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match"
" their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Python 2.1 中的最大改变是 Python 的作用域规则，在Python 2.2中得到完善。 在 Python 2.0 "
"中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 "
"例如，一个嵌套的递归函数将不起作用::"

#: ../../whatsnew/2.2.rst:862
msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or"
" in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was"
" a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""

#: ../../whatsnew/2.2.rst:876
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。"

#: ../../whatsnew/2.2.rst:879
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put"
" simply, when a given variable name is not assigned a value within a "
"function (by an assignment, or the :keyword:`def`, :keyword:`class`, or "
":keyword:`import` statements), references to the variable will be looked up "
"in the local namespace of the enclosing scope.  A more detailed explanation "
"of the rules, and a dissection of the implementation, can be found in the "
"PEP."
msgstr ""
"Python 2.2 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 ``name=name`` "
"默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 :keyword:`def`, "
":keyword:`class` 或 :keyword:`import` 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 "
"对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。"

#: ../../whatsnew/2.2.rst:888
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 "
"不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。"

#: ../../whatsnew/2.2.rst:894
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the"
" CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into"
" bytecodes has to generate different code to access variables in a "
"containing scope.  ``from module import *`` and ``exec`` make it impossible "
"for the compiler to figure this out, because they add names to the local "
"namespace that are unknowable at compile time. Therefore, if a function "
"contains function definitions or :keyword:`lambda` expressions with free "
"variables, the compiler will flag this by raising a :exc:`SyntaxError` "
"exception."
msgstr ""
"此项改变的一个附带影响是在特定条件下函数作用域内部 ``from module import *`` 和 ``exec`` 语句将不允许使用。 "
"Python 参考手册已经写明 ``from module import *`` 仅在模块最高层级上是可用的，但此前 CPython "
"解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 "
"``from module import *`` 和 ``exec`` 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 "
"为此，如果一个函数包含带有自由变量的函数定义或 :keyword:`lambda` 表达式，编译器将通过引发 :exc:`SyntaxError` "
"异常来提示。"

#: ../../whatsnew/2.2.rst:907
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "为了使前面的解释更清楚，下面是一个例子::"

#: ../../whatsnew/2.2.rst:916
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed"
" by :func:`g`."
msgstr ""
"包含 ``exec`` 语句的第 4 行有语法错误，因为 ``exec`` 将定义一个名为 ``x`` 的新局部变量，它的值应当被 :func:`g` "
"访问。"

#: ../../whatsnew/2.2.rst:920
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr "这应该不会是太大的限制，因为 ``exec`` 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。"

#: ../../whatsnew/2.2.rst:927
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 静态嵌套作用域"

#: ../../whatsnew/2.2.rst:928
msgid "Written and implemented by Jeremy Hylton."
msgstr "由 Jeremy Hylton 撰写并实现。"

#: ../../whatsnew/2.2.rst:934
msgid "New and Improved Modules"
msgstr "新增和改进的模块"

#: ../../whatsnew/2.2.rst:936
msgid ""
"The :mod:`xmlrpclib` module was contributed to the standard library by "
"Fredrik Lundh, providing support for writing XML-RPC clients.  XML-RPC is a "
"simple remote procedure call protocol built on top of HTTP and XML. For "
"example, the following snippet retrieves a list of RSS channels from the "
"O'Reilly Network, and then  lists the recent headlines for one channel::"
msgstr ""

#: ../../whatsnew/2.2.rst:959
msgid ""
"The :mod:`SimpleXMLRPCServer` module makes it easy to create straightforward"
" XML-RPC servers.  See http://xmlrpc.scripting.com/ for more information "
"about XML-RPC."
msgstr ""

#: ../../whatsnew/2.2.rst:962
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by "
":rfc:`2104`. (Contributed by Gerhard Häring.)"
msgstr "新的 :mod:`hmac` 模块实现了由 :rfc:`2104` 描述的HMAC算法。（由Gerhard Häring贡献。）"

#: ../../whatsnew/2.2.rst:965
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as memberst_mtime or :attr:`tm_year`. The enhanced functions include "
":func:`stat`, :func:`fstat`, :func:`statvfs`, and :func:`fstatvfs` in the "
":mod:`os` module, and :func:`localtime`, :func:`gmtime`, and "
":func:`strptime` in the :mod:`time` module."
msgstr ""

#: ../../whatsnew/2.2.rst:972
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = "
"os.stat(filename).st_size``."
msgstr ""
"例如，使用旧的元组来获取文件的大小时，你可能会写成 ``file_size = os.stat(filename)[stat.ST_SIZE]`` "
"，但现在可以更清晰地写成 ``file_size = os.stat(filename).st_size``。"

#: ../../whatsnew/2.2.rst:976
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "此特性的初始补丁由 Nick Mathewson 贡献。"

#: ../../whatsnew/2.2.rst:978
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Python 的分析器进行了大量的重构，并纠正了其输出中的各种错误。（由 Fred L. Drake, Jr. 和 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:981
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the "
":option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
":mod:`socket` 模块可以编译为支持IPv6；为Python的配置脚本指定 :option:`!--enable-ipv6` "
"选项。（由Jun-ichiro \"itojun\" Hagino贡献。）"

#: ../../whatsnew/2.2.rst:985
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is"
" for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value "
"is returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"在支持 C 语言 long long 类型的平台上，为 64 位整数添加了两个新的格式字符到 :mod:`struct` 模块。 ``q`` 用于有符号"
" 64 位整数，``Q`` 用于无符号 64 位整数。返回的值是 Python 的长整数类型。（由 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:990
msgid ""
"In the interpreter's interactive mode, there's a new built-in function "
":func:`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to "
"provide interactive help. ``help(object)`` displays any available help text "
"about *object*.  :func:`help` with no argument puts you in an online help "
"utility, where you can enter the names of functions, classes, or modules to "
"read their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's "
":mod:`pydoc` module.)"
msgstr ""
"在解释器的交互模式下，有一个新的内置函数 :func:`help`，它使用在Python 2.1 中引入的 :mod:`pydoc` "
"模块来提供交互式帮助。 ``help(object)`` 显示关于*object*的任何可用帮助文本。不带参数调用 :func:`help` "
"会进入一个在线帮助工具，在那里你可以输入函数、类或模块的名称来阅读它们的帮助文本。（由Guido van Rossum贡献，使用Ka-Ping Yee的"
" :mod:`pydoc` 模块。）"

#: ../../whatsnew/2.2.rst:998
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` and"
" :func:`re.split` functions have been rewritten in C.  Another contributed "
"patch speeds up certain Unicode character ranges by a factor of two, and a "
"new :meth:`finditer`  method that returns an iterator over all the non-"
"overlapping matches in  a given string.  (SRE is maintained by Fredrik "
"Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1006
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib`"
" also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
":mod:`smtplib` 模块现在支持 :rfc:`2487`：\"Secure SMTP over "
"TLS\"，因此现在可以加密Python程序与接收消息的邮件传输代理之间的SMTP流量。:mod:`smtplib` "
"还支持SMTP身份验证。（由Gerhard Häring贡献。）"

#: ../../whatsnew/2.2.rst:1011
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
":mod:`imaplib` 模块由 Piers Lauder 维护，支持几个新扩展: :rfc:`2342` 中定义的 NAMESPACE "
"扩展、SORT、GETACL和SETACL。（由 Anthony Baxter 和 Michel Pelletier 贡献。）"

#: ../../whatsnew/2.2.rst:1015
msgid ""
"The :mod:`rfc822` module's parsing of email addresses is now compliant with "
":rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* going to "
"be changed to ``rfc2822``.)  A new package, :mod:`email`, has also been "
"added for parsing and generating e-mail messages.  (Contributed by Barry "
"Warsaw, and arising out of his work on Mailman.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1021
msgid ""
"The :mod:`difflib` module now contains a new :class:`Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, "
":func:`ndiff` and :func:`restore`, which respectively return a delta from "
"two sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1028
msgid ""
"New constants :const:`ascii_letters`, :const:`ascii_lowercase`, and "
":const:`ascii_uppercase` were added to the :mod:`string` module.  There were"
" several modules in the standard library that used :const:`string.letters` "
"to mean the ranges A-Za-z, but that assumption is incorrect when locales are"
" in use, because :const:`string.letters` varies depending on the set of "
"legal characters defined by the current locale.  The buggy modules have all "
"been fixed to use :const:`ascii_letters` instead. (Reported by an unknown "
"person; fixed by Fred L. Drake, Jr.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1037
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type"
" databases by the addition of a :class:`MimeTypes` class, which takes a list"
" of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1041
msgid ""
"A :class:`Timer` class was added to the :mod:`threading` module that allows "
"scheduling an activity to happen at some future time.  (Contributed by "
"Itamar Shtull-Trauring.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1049
msgid "Interpreter Changes and Fixes"
msgstr "解释器的改变和修正"

#: ../../whatsnew/2.2.rst:1051
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"有些变化只会影响那些在 C 级别处理 Python 解释器的人，因为他们正在编写 Python "
"扩展模块、嵌入解释器或仅仅是在修改解释器本身。如果你只编写 Python 代码，这里描述的变化对你几乎没有影响。"

#: ../../whatsnew/2.2.rst:1056
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors"
" of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The"
" existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"性能分析和追踪函数现在可以用 C 语言来实现，相比基于 Python 的函数能够显著提高运行速度并能够减少性能分析和追踪的资源开销。 Python "
"开发环境的编写者对此将会很感兴趣。 Python 的 API 增加了两个新的 C 函数，:c:func:`PyEval_SetProfile` 和 "
":c:func:`PyEval_SetTrace`。 现有的 :func:`sys.setprofile` 和 :func:`sys.settrace`"
" 函数仍然存在，并已简单地更改为使用新的 C 层级接口。 （由 Fred L. Drake, Jr. 贡献。）"

#: ../../whatsnew/2.2.rst:1065
msgid ""
"Another low-level API, primarily of interest to implementors of Python "
"debuggers and development tools, was added. "
":c:func:`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let "
"a caller walk through all the existing interpreter objects; "
":c:func:`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` "
"allow looping over all the thread states for a given interpreter.  "
"(Contributed by David Beazley.)"
msgstr ""
"Було додано ще один низькорівневий API, який в першу чергу цікавить "
"розробників налагоджувачів Python та інструментів розробки. "
":c:func:`PyInterpreterState_Head` і :c:func:`PyInterpreterState_Next` "
"дозволяють абоненту пройти через усі існуючі об’єкти інтерпретатора; "
":c:func:`PyInterpreterState_ThreadHead` і :c:func:`PyThreadState_Next` "
"дозволяють циклічно переглядати всі стани потоку для певного інтерпретатора."
" (Надав Девід Бізлі.)"

#: ../../whatsnew/2.2.rst:1072
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug"
" misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"垃圾收集器的 C 级接口已经发生了变化，使得编写支持垃圾收集的扩展类型和调试函数误用变得更容易。各种函数的语义略有不同，因此需要重命名一系列函数。使用旧"
" API 的扩展仍然可以编译，但不会参与垃圾收集，因此应优先考虑将它们更新为 2.2 版本。"

#: ../../whatsnew/2.2.rst:1079
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr "要将一个扩展模块升级至新 API，请执行下列步骤:"

#: ../../whatsnew/2.2.rst:1081
msgid "Rename :c:func:`Py_TPFLAGS_GC` to :c:func:`PyTPFLAGS_HAVE_GC`."
msgstr "将 :c:func:`Py_TPFLAGS_GC` 重命名为 :c:func:`PyTPFLAGS_HAVE_GC`。"

#: ../../whatsnew/2.2.rst:1084
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr "使用 :c:func:`PyObject_GC_New` 或 :c:func:`PyObject_GC_NewVar` 来分配"

#: ../../whatsnew/2.2.rst:1084
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "对象，并使用 :c:func:`PyObject_GC_Del` 来释放它们。"

#: ../../whatsnew/2.2.rst:1087
msgid "Rename :c:func:`PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and"
msgstr "将 :c:func:`PyObject_GC_Init` 重命名为 :c:func:`PyObject_GC_Track` 并"

#: ../../whatsnew/2.2.rst:1087
msgid ":c:func:`PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr "将 :c:func:`PyObject_GC_Fini` 重命名为 :c:func:`PyObject_GC_UnTrack`。"

#: ../../whatsnew/2.2.rst:1089
msgid "Remove :c:func:`PyGC_HEAD_SIZE` from object size calculations."
msgstr "将 :c:func:`PyGC_HEAD_SIZE` 从对象大小计算中移除。"

#: ../../whatsnew/2.2.rst:1091
msgid ""
"Remove calls to :c:func:`PyObject_AS_GC` and :c:func:`PyObject_FROM_GC`."
msgstr "移除对 :c:func:`PyObject_AS_GC` 和 :c:func:`PyObject_FROM_GC` 的调用。"

#: ../../whatsnew/2.2.rst:1093
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et``"
" takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following "
"section.)"
msgstr ""
"向 :c:func:`PyArg_ParseTuple` 添加了一个新的 ``et`` 格式序列；``et`` "
"接受一个形参和一个编码格式名称，如果该形参值是一个 Unicode 字符串则将其转换为给定的编码格式，或者如果它是一个 8 "
"比特位字符串则让其保持原样，即假定它已经使用了适当的编码格式。 这不同于 ``es`` 格式字符，它假定该 8 比特位字符串是使用 Python 默认的"
" ASCII 编码格式并将其转换为指定的新编码格式。 （由 M.-A. Lemburg 贡献，用于下一节所描述的 Windows 上的 MBCS "
"支持。）"

#: ../../whatsnew/2.2.rst:1102
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been"
" added that's simpler and presumably faster.  Instead of specifying a format"
" string, the caller simply gives the minimum and maximum number of arguments"
" expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"增加了一个不同的解析函数 :c:func:`PyArg_UnpackTuple`，它更为简单并且应该也更为快速。 "
"调用方不必再指定格式字符串，而是简单地给出所预期参数的最小和最大数量，以及一组指向将以这些参数值来填充的 :c:expr:`PyObject*` "
"变量的指针。"

#: ../../whatsnew/2.2.rst:1108
msgid ""
"Two new flags :const:`METH_NOARGS` and :const:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses "
":const:`METH_VARARGS`.  Also, the old :const:`METH_OLDARGS` style of writing"
" C methods is  now officially deprecated."
msgstr ""

#: ../../whatsnew/2.2.rst:1114
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and "
":c:func:`PyOS_vsnprintf` were added to provide  cross-platform "
"implementations for the relatively new :c:func:`snprintf` and "
":c:func:`vsnprintf` C lib APIs. In contrast to the standard "
":c:func:`sprintf` and :c:func:`vsprintf` functions, the Python versions "
"check the bounds of the buffer used to protect against buffer overruns. "
"(Contributed by M.-A. Lemburg.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1121
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
":c:func:`_PyTuple_Resize` 函数去掉了一个未使用的形参，因此现在它接受 2 个形参而不是 3 个。 "
"第三个参数从未被使用，在将代码从较早的版本移植到 Python 2.2 时可以简单地丢弃它。"

#: ../../whatsnew/2.2.rst:1129
msgid "Other Changes and Fixes"
msgstr "其他的改变和修正"

#: ../../whatsnew/2.2.rst:1131
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches"
" and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"像往常一样，源代码树中散布着许多其他改进和错误修复。通过搜索 CVS 更改日志，可以发现 Python 2.1 到 2.2 之间应用了 527 "
"个补丁并修复了 683 个错误；2.2.1 应用了 139 个补丁并修复了 143 个错误；2.2.2 应用了 106 个补丁并修复了 82 "
"个错误。这些数字可能是低估的。"

#: ../../whatsnew/2.2.rst:1137
msgid "Some of the more notable changes are:"
msgstr "一些较为重要的改变:"

#: ../../whatsnew/2.2.rst:1139
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support"
" MacOS X."
msgstr ""
"适用于 MacOS 的 Python 移植代码现在保存在主 Python CVS 树中，由 Jack Jansen 维护，并且为了支持 MacOS "
"X，进行了许多更改。"

#: ../../whatsnew/2.2.rst:1142
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this"
" (actually, there is the disadvantage that you have to change your PATH to "
"be able to find Python), but it is the basis for creating a full-blown "
"Python application, porting the MacPython IDE, possibly using Python as a "
"standard OSA scripting language and much more.\""
msgstr ""
"最重要的变化是能够将 Python 作为框架来进行构建，这可以通过在编译 Python 时向配置脚本提供 :option:`!--enable-"
"framework` 选项来启用。 根据 Jack Jansen 的说法，“这会将一个独立的 Python 安装版加上 OS X 框架‘粘合起来’放到 "
":file:`/Library/Frameworks/Python.framework` 中（或者其他选定的位置）。 "
"就目前而言这样做并没有什么直接的额外好处（实际上，这样做还存在必须更改 PATH 才能找到Python 的坏处），但它是创建完整的 Python "
"应用程序、移植 MacPython IDE、并可能使用 Python 作为标准 OSA 脚本语言及其他更多功能的基础。”"

#: ../../whatsnew/2.2.rst:1153
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as"
" windowing, QuickTime, scripting, etc. have been ported to OS X, but they've"
" been left commented out in :file:`setup.py`.  People who want to experiment"
" with these modules can uncomment them manually."
msgstr ""
"作为 MacOS API 如 windowing, QuickTime, scripting 等的接口的许多 MacPython 工具箱模块已被移植到 "
"OS X，但它们在 :file:`setup.py` 中被注释掉了。 希望尝试这些模块的人可以手动取消注释它们。"

#: ../../whatsnew/2.2.rst:1176
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"现在将关键字参数传给不接受它们的内置函数会导致引发 :exc:`TypeError` 异常，并附带消息 \"*function* takes no "
"keyword arguments\"。"

#: ../../whatsnew/2.2.rst:1180
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of"
" the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the "
":mod:`weakref` module to become a built-in exception."
msgstr ""
"在 Python 2.1 中作为扩展模块加入的弱引用现在已成为核心组成部分，因为它们被用于新式类的实现。 为此 "
":exc:`ReferenceError` 异常也已从 :mod:`weakref` 模块移出成为一个内置异常。"

#: ../../whatsnew/2.2.rst:1185
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"由 Tim Peters 编写的新脚本 :file:`Tools/scripts/cleanfuture.py` 可自动从 Python "
"源代码移除过时的 ``__future__`` 语句。"

#: ../../whatsnew/2.2.rst:1189
msgid ""
"An additional *flags* argument has been added to the built-in function "
":func:`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"向内置函数 :func:`compile` 添加了一个额外的 *flags* 参数，以便现在 ``__future__`` 语句的行为能在模拟的 "
"shell，例如由 IDLE 和其他开发环境所提供的此类工具中被正确地观察。 此特性的描述参见 :pep:`264`。 （由 Michael "
"Hudson 贡献。）"

#: ../../whatsnew/2.2.rst:1195
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to"
" embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Python 1.6 引入的新许可证与 GPL 不兼容。通过对 2.2 许可证进行一些小的文本修改，这个问题得以解决，因此现在可以合法地将 Python"
" 嵌入到 GPL 授权的程序中。请注意，Python 本身并不是在 GPL 授权下，而是采用一个与 BSD "
"许可证本质上等效的许可证，这与之前的情况一样。这些许可证更改也应用到了 Python 2.0.1 和 2.1.1 版本中。"

#: ../../whatsnew/2.2.rst:1202
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default"
" encoding turns out to be an annoyance.  On Unix, the locale's character set"
" is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"在 Windows 上，当 Python 遇到一个 Unicode 文件名时，现在会将其转换为 MBCS 编码的字符串，这种编码由 Microsoft "
"文件 API 使用。由于文件 API 明确使用 MBCS 编码，Python 默认选择 ASCII 作为编码方式显得很不方便。在 Unix 上，如果 "
"``locale.nl_langinfo(CODESET)`` 可用，Python 将使用本地字符集。（Windows 支持由 Mark Hammond"
" 提供，Marc-André Lemburg 提供协助。Unix 支持由 Martin von Löwis 添加。）"

#: ../../whatsnew/2.2.rst:1210
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr "大文件支持目前已在 Windows 上启用。 （由 Tim Peters 贡献。）"

#: ../../whatsnew/2.2.rst:1212
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
":file:`Tools/scripts/ftpmirror.py` 脚本现在会解析 :file:`.netrc` 文件，如果存在的话。 （由 Mike"
" Romberg 贡献。）"

#: ../../whatsnew/2.2.rst:1215
msgid ""
"Some features of the object returned by the :func:`xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in"
" Python 2.3. :class:`xrange` objects tried to pretend they were full "
"sequence types by supporting slicing, sequence multiplication, and the "
":keyword:`in` operator, but these features were rarely used and therefore "
"buggy.  The :meth:`tolist` method and the :attr:`start`, :attr:`stop`, and "
":attr:`step` attributes are also being deprecated.  At the C level, the "
"fourth argument to the :c:func:`PyRange_New` function, ``repeat``, has also "
"been deprecated."
msgstr ""

#: ../../whatsnew/2.2.rst:1224
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a"
" case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"字典实现中有一堆补丁，主要是为了修复潜在的核心转储问题，这些问题发生在字典中包含的对象悄悄改变其哈希值，或者在它们所包含的字典中发生突变时。那段时间，python-"
"dev 邮件列表进入了一个微妙的节奏：Michael Hudson 发现一个导致核心转储的案例，Tim Peters 修复这个 bug，接着 "
"Michael 又发现另一个案例，如此反复循环。"

#: ../../whatsnew/2.2.rst:1231
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"在 Windows 上，Python 现在可以使用 Borland C 编译，这要归功于 Stephen Hansen "
"提供的多个补丁，尽管结果还不完全可用。（但这*确实*是一个进步……）"

#: ../../whatsnew/2.2.rst:1235
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"另一个 Windows 改进：Wise Solutions 慷慨地向 PythonLabs 提供了他们的 InstallerMaster 8.1 "
"系统。早期的 PythonLabs Windows 安装程序使用的是 Wise 5.0a，已经开始显得过时。（由 Tim Peters 打包。）"

#: ../../whatsnew/2.2.rst:1239
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David"
" Bolen.)"
msgstr ""
"在 Windows 上现在将会导入以 ``.pyw`` 结尾的文件。 ``.pyw`` 是 Windows 专属的，用来指明一个脚本需要使用 "
"PYTHONW.EXE 而不是 PYTHON.EXE 来运行以避免弹出 DOS 控制台来显示输出。 "
"该补丁使得导入这样的脚本成为可能，让它们也可以作为模块来使用。 （由 David Bolen 实现。）"

#: ../../whatsnew/2.2.rst:1245
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by "
":c:func:`dlopen` using the :func:`sys.getdlopenflags` and "
":func:`sys.setdlopenflags` functions. (Contributed by Bram Stolk.)"
msgstr ""
"在 Python 会使用 C :c:func:`dlopen` 函数来加载扩展模块的平台上，现在可以使用 "
":func:`sys.getdlopenflags` 和 :func:`sys.setdlopenflags` 等函数来设置 "
":c:func:`dlopen` 所使用的旗标。 （由 Bram Stolk 贡献。）"

#: ../../whatsnew/2.2.rst:1250
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"Вбудована функція :func:`pow` більше не підтримує 3 аргументи, коли "
"надаються числа з плаваючою комою. ``pow(x, y, z)`` повертає ``(x**y) % z``,"
" але це ніколи не корисно для чисел з плаваючою комою, і кінцевий результат "
"непередбачувано змінюється залежно від платформи. Такий виклик, як "
"``pow(2.0, 8.0, 7.0)``, тепер викличе виняток :exc:`TypeError`."

#: ../../whatsnew/2.2.rst:1260
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.2.rst:1262
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack"
" Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay,"
" Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van"
" Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"作者感谢以下人员为本文的各种草案提供建议，更正和帮助： Fred Bremmer, Keith Briggs, Andrew Dalke, Fred "
"L. Drake, Jr., Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen,"
" Michael Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik "
"Lundh, Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don "
"O'Donnell, Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil "
"Schemenauer, Guido van Rossum, Greg Ward, Edward Welbourne."
