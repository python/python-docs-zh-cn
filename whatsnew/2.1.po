# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.1.rst:3
msgid "What's New in Python 2.1"
msgstr "Python 2.1 有什么新变化"

#: ../../whatsnew/2.1.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.1.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.1.rst:13
msgid "Introduction"
msgstr "概述"

#: ../../whatsnew/2.1.rst:15
msgid ""
"This article explains the new features in Python 2.1.  While there aren't as"
" many changes in 2.1 as there were in Python 2.0, there are still some "
"pleasant surprises in store.  2.1 is the first release to be steered through"
" the use of Python Enhancement Proposals, or PEPs, so most of the sizable "
"changes have accompanying PEPs that provide more complete documentation and "
"a design rationale for the change.  This article doesn't attempt to document"
" the new features completely, but simply provides an overview of the new "
"features for Python programmers. Refer to the Python 2.1 documentation, or "
"to the specific PEP, for more details about any new feature that "
"particularly interests you."
msgstr ""
"本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 "
"是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 "
"本文并未试图完整记录所有的新特性，而是为 Python 程序员提供新特性的简单概览。 请参阅 Python 2.1 文档，或特定的 "
"PEP，获取针对你感兴趣的任何新特性的更多细节。"

#: ../../whatsnew/2.1.rst:25
msgid ""
"One recent goal of the Python development team has been to accelerate the "
"pace of new releases, with a new release coming every 6 to 9 months. 2.1 is "
"the first release to come out at this faster pace, with the first alpha "
"appearing in January, 3 months after the final version of 2.0 was released."
msgstr ""
"Python 开发团队的一个近期目标是加速新发行版的步调，使得每 6 到 9 个月就有一个新发行版。 2.1 "
"是基于这个新步调推出的第一个发行版，第一个内测版将于一月发布，即 2.0 最终版发布 3 个月之后。"

#: ../../whatsnew/2.1.rst:30
msgid "The final release of Python 2.1 was made on April 17, 2001."
msgstr "Python 2.1 的最终版本于2001年4月17日发布。"

#: ../../whatsnew/2.1.rst:36
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: 嵌套的作用域"

#: ../../whatsnew/2.1.rst:38
msgid ""
"The largest change in Python 2.1 is to Python's scoping rules.  In Python "
"2.0, at any given time there are at most three namespaces used to look up "
"variable names: local, module-level, and the built-in namespace.  This often"
" surprised people because it didn't match their intuitive expectations.  For"
" example, a nested recursive function definition doesn't work::"
msgstr ""
"Python 2.1 中的最大改变是 Python 的作用域规则。 在 Python 2.0 "
"中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 "
"例如，一个嵌套的递归函数将不起作用::"

#: ../../whatsnew/2.1.rst:44
msgid ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."
msgstr ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."

#: ../../whatsnew/2.1.rst:51
msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or"
" in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was"
" a problem in practice. In code which uses :keyword:`lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"函数 :func:`!g` 总是会引发 :exc:`NameError` 异常，因为名称 ``g`` 的绑定既不在局部命名空间中也不在模块级命名空间中。"
" 这在实践中不会有太大问题（你会经常这样递归地定义内部函数吗？），但是这也会让 :keyword:`lambda` "
"表达式的使用更为笨拙，这在实践中是有问题的。 在使用了 :keyword:`lambda` 的代码中你经常能发现局部变量通过作为参数的默认值被拷贝。 "
"::"

#: ../../whatsnew/2.1.rst:59
msgid ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"
msgstr ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"

#: ../../whatsnew/2.1.rst:65
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。"

#: ../../whatsnew/2.1.rst:68
msgid ""
"The most significant change to Python 2.1 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put"
" simply, when a given variable name is not assigned a value within a "
"function (by an assignment, or the :keyword:`def`, :keyword:`class`, or "
":keyword:`import` statements), references to the variable will be looked up "
"in the local namespace of the enclosing scope.  A more detailed explanation "
"of the rules, and a dissection of the implementation, can be found in the "
"PEP."
msgstr ""
"Python 2.1 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 ``name=name`` "
"默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 :keyword:`def`, "
":keyword:`class` 或 :keyword:`import` 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 "
"对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。"

#: ../../whatsnew/2.1.rst:77
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 "
"不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。"

#: ../../whatsnew/2.1.rst:83
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the"
" CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into"
" bytecodes has to generate different code to access variables in a "
"containing scope.  ``from module import *`` and ``exec`` make it impossible "
"for the compiler to figure this out, because they add names to the local "
"namespace that are unknowable at compile time. Therefore, if a function "
"contains function definitions or :keyword:`lambda` expressions with free "
"variables, the compiler will flag this by raising a :exc:`SyntaxError` "
"exception."
msgstr ""
"此项改变的一个附带影响是在特定条件下函数作用域内部 ``from module import *`` 和 ``exec`` 语句将不允许使用。 "
"Python 参考手册已经写明 ``from module import *`` 仅在模块最高层级上是可用的，但此前 CPython "
"解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 "
"``from module import *`` 和 ``exec`` 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 "
"为此，如果一个函数包含带有自由变量的函数定义或 :keyword:`lambda` 表达式，编译器将通过引发 :exc:`SyntaxError` "
"异常来提示。"

#: ../../whatsnew/2.1.rst:96
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "为了使前面的解释更清楚，下面是一个例子::"

#: ../../whatsnew/2.1.rst:98
msgid ""
"x = 1\n"
"def f():\n"
"    # The next line is a syntax error\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"
msgstr ""
"x = 1\n"
"def f():\n"
"    # 下一行有语法错误\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"

#: ../../whatsnew/2.1.rst:105
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed"
" by :func:`!g`."
msgstr ""
"包含 ``exec`` 语句的第 4 行有语法错误，因为 ``exec`` 会定义一个名为 ``x`` 的新局部变量，它的值应当被 :func:`!g`"
" 所访问。"

#: ../../whatsnew/2.1.rst:109
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr "这应该不会是太大的限制，因为 ``exec`` 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。"

#: ../../whatsnew/2.1.rst:113
msgid ""
"Compatibility concerns have led to nested scopes being introduced gradually;"
" in Python 2.1, they aren't enabled by default, but can be turned on within "
"a module by using a future statement as described in :pep:`236`.  (See the "
"following section for further discussion of :pep:`236`.)  In Python 2.2, "
"nested scopes will become the default and there will be no way to turn them "
"off, but users will have had all of 2.1's lifetime to fix any breakage "
"resulting from their introduction."
msgstr ""
"由于兼容性问题，嵌套作用域被逐步引入；在 Python 2.1 中，它们默认未启用，但可以通过在模块中使用 future 语句来开启，如 "
":pep:`236` 所述。 （参见下一节对 :pep:`236` 的进一步讨论。） 在 Python 2.2 "
"中，嵌套作用域将成为默认设置，并且无法关闭，但用户将有整个 2.1 版本的生命周期来修复因引入嵌套作用域而导致的任何问题。"

#: ../../whatsnew/2.1.rst:123
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 静态嵌套作用域"

#: ../../whatsnew/2.1.rst:124
msgid "Written and implemented by Jeremy Hylton."
msgstr "由 Jeremy Hylton 撰写并实现。"

#: ../../whatsnew/2.1.rst:130
msgid "PEP 236: __future__ Directives"
msgstr "PEP 236: __future__ 指令"

#: ../../whatsnew/2.1.rst:132
msgid ""
"The reaction to nested scopes was widespread concern about the dangers of "
"breaking code with the 2.1 release, and it was strong enough to make the "
"Pythoneers take a more conservative approach.  This approach consists of "
"introducing a convention for enabling optional functionality in release N "
"that will become compulsory in release N+1."
msgstr ""
"对嵌套作用域的反应引起了广泛关注，人们担心在 Python 2.1 版本发布时会破坏现有代码，强烈的反应促使 Python "
"开发者采取了更保守的策略。这个策略包括引入一种约定，在版本 N 中启用可选功能，该功能将在版本 N+1 中成为强制功能。"

#: ../../whatsnew/2.1.rst:138
msgid ""
"The syntax uses a ``from...import`` statement using the reserved module name"
" :mod:`__future__`.  Nested scopes can be enabled by the following "
"statement::"
msgstr "语法使用 ``from...import`` 语句，使用保留模块名 :mod:`__future__`。可以通过以下语句启用嵌套作用域::"

#: ../../whatsnew/2.1.rst:141
msgid "from __future__ import nested_scopes"
msgstr "from __future__ import nested_scopes"

#: ../../whatsnew/2.1.rst:143
msgid ""
"While it looks like a normal :keyword:`import` statement, it's not; there "
"are strict rules on where such a future statement can be put. They can only "
"be at the top of a module, and must precede any Python code or regular "
":keyword:`!import` statements.  This is because such statements can affect "
"how the Python bytecode compiler parses code and generates bytecode, so they"
" must precede any statement that will result in bytecodes being produced."
msgstr ""
"虽然它看起来像一个普通的 :keyword:`import` 语句，但实际上并不是；关于此类 future "
"语句的位置有严格的规定。它们只能放在模块的顶部，必须位于任何 Python 代码或常规 :keyword:`!import` "
"语句之前。这是因为这样的语句会影响 Python 字节码编译器解析代码和生成字节码的方式，因此它们必须在任何会生成字节码的语句之前出现。"

#: ../../whatsnew/2.1.rst:153
msgid ":pep:`236` - Back to the :mod:`__future__`"
msgstr ":pep:`236` - 回到 :mod:`__future__`"

#: ../../whatsnew/2.1.rst:154
msgid "Written by Tim Peters, and primarily implemented by Jeremy Hylton."
msgstr "由 Tim Peters 撰写，主要由 Jeremy Hylton 实现。"

#: ../../whatsnew/2.1.rst:160
msgid "PEP 207: Rich Comparisons"
msgstr "PEP 207: 富比较"

#: ../../whatsnew/2.1.rst:162
msgid ""
"In earlier versions, Python's support for implementing comparisons on user-"
"defined classes and extension types was quite simple. Classes could "
"implement a :meth:`!__cmp__` method that was given two instances of a class,"
" and could only return 0 if they were equal or +1 or -1 if they weren't; the"
" method couldn't raise an exception or return anything other than a Boolean "
"value.  Users of Numeric Python often found this model too weak and "
"restrictive, because in the number-crunching programs that numeric Python is"
" used for, it would be more useful to be able to perform elementwise "
"comparisons of two matrices, returning a matrix containing the results of a "
"given comparison for each element.  If the two matrices are of different "
"sizes, then the compare has to be able to raise an exception to signal the "
"error."
msgstr ""
"在早期版本中，Python 对用户定义类和扩展类型的比较操作支持相当简单。类可以实现一个 :meth:`!__cmp__` "
"方法，该方法接收两个类实例，并且只能返回 0 表示相等，或 +1 或 -1 表示不相等；该方法不能引发异常或返回布尔值以外的任何内容。Numeric "
"Python 的用户经常发现这种模型太弱且受限，因为在 Numeric Python "
"所用的数字运算程序中，能够对两个矩阵进行逐元素比较更为有用，返回一个包含每个元素比较结果的矩阵。如果两个矩阵的大小不同，则比较必须能够引发异常以表示错误。"

#: ../../whatsnew/2.1.rst:174
msgid ""
"In Python 2.1, rich comparisons were added in order to support this need. "
"Python classes can now individually overload each of the ``<``, ``<=``, "
"``>``, ``>=``, ``==``, and ``!=`` operations.  The new magic method names "
"are:"
msgstr ""
"在 Python 2.1 中增加了富比较操作以支持这一需求。 Python 类现在可以单独重载 ``<``, ``<=``, ``>``, "
"``>=``, ``==`` 和 ``!=`` 中的每个操作。 新的魔术方法名称如下："

#: ../../whatsnew/2.1.rst:179
msgid "Operation"
msgstr "运算"

#: ../../whatsnew/2.1.rst:179
msgid "Method name"
msgstr "方法名称"

#: ../../whatsnew/2.1.rst:181
msgid "``<``"
msgstr "``<``"

#: ../../whatsnew/2.1.rst:181
msgid ":meth:`~object.__lt__`"
msgstr ":meth:`~object.__lt__`"

#: ../../whatsnew/2.1.rst:183
msgid "``<=``"
msgstr "``<=``"

#: ../../whatsnew/2.1.rst:183
msgid ":meth:`~object.__le__`"
msgstr ":meth:`~object.__le__`"

#: ../../whatsnew/2.1.rst:185
msgid "``>``"
msgstr "``>``"

#: ../../whatsnew/2.1.rst:185
msgid ":meth:`~object.__gt__`"
msgstr ":meth:`~object.__gt__`"

#: ../../whatsnew/2.1.rst:187
msgid "``>=``"
msgstr "``>=``"

#: ../../whatsnew/2.1.rst:187
msgid ":meth:`~object.__ge__`"
msgstr ":meth:`~object.__ge__`"

#: ../../whatsnew/2.1.rst:189
msgid "``==``"
msgstr "``==``"

#: ../../whatsnew/2.1.rst:189
msgid ":meth:`~object.__eq__`"
msgstr ":meth:`~object.__eq__`"

#: ../../whatsnew/2.1.rst:191
msgid "``!=``"
msgstr "``!=``"

#: ../../whatsnew/2.1.rst:191
msgid ":meth:`~object.__ne__`"
msgstr ":meth:`~object.__ne__`"

#: ../../whatsnew/2.1.rst:194
msgid ""
"(The magic methods are named after the corresponding Fortran operators "
"``.LT.``. ``.LE.``, &c.  Numeric programmers are almost certainly quite "
"familiar with these names and will find them easy to remember.)"
msgstr ""
"（这些魔术方法是以对应的 Fortran 操作符命名的，如 ``.LT.``、``.LE.`` 等。 "
"数值程序员几乎肯定对这些名称非常熟悉，并且会发现它们易于记忆。）"

#: ../../whatsnew/2.1.rst:198
msgid ""
"Each of these magic methods is of the form ``method(self, other)``, where "
"``self`` will be the object on the left-hand side of the operator, while "
"``other`` will be the object on the right-hand side.  For example, the "
"expression ``A < B`` will cause ``A.__lt__(B)`` to be called."
msgstr ""
"每个这样的魔术方法的形式都是 ``method(self, other)``，其中 ``self`` 是操作符左侧的对象，而 ``other`` "
"是操作符右侧的对象。 例如，表达式 ``A < B`` 会调用 ``A.__lt__(B)``。"

#: ../../whatsnew/2.1.rst:203
msgid ""
"Each of these magic methods can return anything at all: a Boolean, a matrix,"
" a list, or any other Python object.  Alternatively they can raise an "
"exception if the comparison is impossible, inconsistent, or otherwise "
"meaningless."
msgstr ""
"这些魔术方法可以返回任何类型的值：布尔值、矩阵、列表或任何其他 Python 对象。或者，如果比较是不可能的、不一致的或没有意义的，它们也可以引发异常。"

#: ../../whatsnew/2.1.rst:207
msgid ""
"The built-in ``cmp(A,B)`` function can use the rich comparison machinery, "
"and now accepts an optional argument specifying which comparison operation "
"to use; this is given as one of the strings ``\"<\"``, ``\"<=\"``, "
"``\">\"``, ``\">=\"``, ``\"==\"``, or ``\"!=\"``.  If called without the "
"optional third argument, :func:`!cmp` will only return -1, 0, or +1 as in "
"previous versions of Python; otherwise it will call the appropriate method "
"and can return any Python object."
msgstr ""
"内置的 ``cmp(A,B)`` 函数可以使用富比较机制，现在接受一个可选参数来指定要使用的比较操作；该参数可以是字符串 "
"``\"<\"``、``\"<=\"``、``\">\"``、``\">=\"``、``\"==\"`` 或 ``\"!=\"`` 之一。 "
"如果不带可选的第三个参数调用，:func:`!cmp` 函数将只返回 -1、0 或 +1，就像以前的 Python "
"版本一样；否则，它将调用适当的方法并可以返回任何 Python 对象。"

#: ../../whatsnew/2.1.rst:214
msgid ""
"There are also corresponding changes of interest to C programmers; there's a"
" new slot ``tp_richcmp`` in type objects and an API for performing a given "
"rich comparison.  I won't cover the C API here, but will refer you to "
":pep:`207`, or to 2.1's C API documentation, for the full list of related "
"functions."
msgstr ""
"对于 C 程序员来说，也有相应的变更；类型对象中有一个新的槽位 ``tp_richcmp`` 以及一个用于执行指定富比较的 API。 这里我不会涉及 C"
" API 的具体内容，完整的相关函数列表请参阅 :pep:`207` 或 2.1 的 C API 文档。"

#: ../../whatsnew/2.1.rst:222
msgid ":pep:`207` - Rich Comparisons"
msgstr ":pep:`207` - 富比较"

#: ../../whatsnew/2.1.rst:223
msgid ""
"Written by Guido van Rossum, heavily based on earlier work by David Ascher, "
"and implemented by Guido van Rossum."
msgstr "由 Guido van Rossum 编写，大量参考 David Ascher 的先期工作，并由 Guido van Rossum 实现。"

#: ../../whatsnew/2.1.rst:230
msgid "PEP 230: Warning Framework"
msgstr "PEP 230: 警告框架"

#: ../../whatsnew/2.1.rst:232
msgid ""
"Over its 10 years of existence, Python has accumulated a certain number of "
"obsolete modules and features along the way.  It's difficult to know when a "
"feature is safe to remove, since there's no way of knowing how much code "
"uses it --- perhaps no programs depend on the feature, or perhaps many do.  "
"To enable removing old features in a more structured way, a warning "
"framework was added. When the Python developers want to get rid of a "
"feature, it will first trigger a warning in the next version of Python.  The"
" following Python version can then drop the feature, and users will have had"
" a full release cycle to remove uses of the old feature."
msgstr ""
"在过去的 10 年中，Python 积累了一定数量的过时模块和功能。 "
"由于无法确切知道某个功能被使用的程度：可能没有程序依赖该功能，也可能有很多程序依赖，因此很难确定何时可以安全地移除某个功能，为了以更结构化的方式移除旧功能，添加了一个警告框架。"
" 当 Python 开发者想要废弃某个功能时，它会在下一个 Python 版本中首先触发一个警告。 "
"然后，在随后的Python版本中可以移除该功能，这样用户将有一个完整的发布周期来删除对旧功能的使用。"

#: ../../whatsnew/2.1.rst:242
msgid ""
"Python 2.1 adds the warning framework to be used in this scheme.  It adds a "
":mod:`warnings` module that provide functions to issue warnings, and to "
"filter out warnings that you don't want to be displayed. Third-party modules"
" can also use this framework to deprecate old features that they no longer "
"wish to support."
msgstr ""
"Python 2.1 增加了警告框架以用于此方案。 它增加了一个 :mod:`warnings` "
"模块，该模块提供了发出警告的函数，以及过滤掉不想显示的警告的功能。 第三方模块也可以使用这个框架来弃用它们不再希望支持的旧功能。"

#: ../../whatsnew/2.1.rst:248
msgid ""
"For example, in Python 2.1 the :mod:`!regex` module is deprecated, so "
"importing it causes a warning to be printed::"
msgstr "例如，在 Python 2.1 中，:mod:`!regex` 模块已被弃用，因此导入它会打印出一个警告::"

#: ../../whatsnew/2.1.rst:251
msgid ""
">>> import regex\n"
"__main__:1: DeprecationWarning: the regex module\n"
"         is deprecated; please use the re module\n"
">>>"
msgstr ""
">>> import regex\n"
"__main__:1: DeprecationWarning: the regex module\n"
"         is deprecated; please use the re module\n"
">>>"

#: ../../whatsnew/2.1.rst:256
msgid "Warnings can be issued by calling the :func:`warnings.warn` function::"
msgstr "警告可以通过调用 :func:`warnings.warn` 函数来发出::"

#: ../../whatsnew/2.1.rst:258
msgid "warnings.warn(\"feature X no longer supported\")"
msgstr "warnings.warn(\"feature X no longer supported\")"

#: ../../whatsnew/2.1.rst:260
msgid ""
"The first parameter is the warning message; an additional optional "
"parameters can be used to specify a particular warning category."
msgstr "第一个形参是警告消息；额外的可选形参可被用来指定一个专门的警告类别。"

#: ../../whatsnew/2.1.rst:263
msgid ""
"Filters can be added to disable certain warnings; a regular expression "
"pattern can be applied to the message or to the module name in order to "
"suppress a warning.  For example, you may have a program that uses the "
":mod:`!regex` module and not want to spare the time to convert it to use the"
" :mod:`re` module right now.  The warning can be suppressed by calling ::"
msgstr ""
"可以添加过滤器来禁用特定的警告；可以将某个正则表达式模式应用于消息或模块名称以抑制警告。 例如，你可能有一个使用 :mod:`!regex` "
"模块的程序但现在不想花时间将其转换为使用 :mod:`re` 模块。 可以通过以下调用来抑制警告消息 ::"

#: ../../whatsnew/2.1.rst:269
msgid ""
"import warnings\n"
"warnings.filterwarnings(action = 'ignore',\n"
"                        message='.*regex module is deprecated',\n"
"                        category=DeprecationWarning,\n"
"                        module = '__main__')"
msgstr ""
"import warnings\n"
"warnings.filterwarnings(action = 'ignore',\n"
"                        message='.*regex module is deprecated',\n"
"                        category=DeprecationWarning,\n"
"                        module = '__main__')"

#: ../../whatsnew/2.1.rst:275
msgid ""
"This adds a filter that will apply only to warnings of the class "
":class:`DeprecationWarning` triggered in the :mod:`__main__` module, and "
"applies a regular expression to only match the message about the "
":mod:`!regex` module being deprecated, and will cause such warnings to be "
"ignored.  Warnings can also be printed only once, printed every time the "
"offending code is executed, or turned into exceptions that will cause the "
"program to stop (unless the exceptions are caught in the usual way, of "
"course)."
msgstr ""
"这添加了一个过滤器，该过滤器仅适用于在 :mod:`__main__` 模块中触发的 :class:`DeprecationWarning` "
"类警告，并应用一个正则表达式来仅匹配有关 :mod:`!regex` "
"模块已被弃用的消息，这将导致忽略此类警告。警告还可以仅打印一次，每次执行违规代码时打印，或者转换为异常，从而导致程序停止（当然，除非以常规方式捕获这些异常）。"

#: ../../whatsnew/2.1.rst:283
msgid ""
"Functions were also added to Python's C API for issuing warnings; refer to "
"PEP 230 or to Python's API documentation for the details."
msgstr "Python 的 C API 也增加了用于发出警告的函数；详情请参阅 PEP 230 或 Python 的 API 文档。"

#: ../../whatsnew/2.1.rst:289
msgid ":pep:`5` - Guidelines for Language Evolution"
msgstr ":pep:`5` - 语言演化的准则"

#: ../../whatsnew/2.1.rst:290
msgid ""
"Written by Paul Prescod, to specify procedures to be followed when removing "
"old features from Python.  The policy described in this PEP hasn't been "
"officially adopted, but the eventual policy probably won't be too different "
"from Prescod's proposal."
msgstr ""
"该文档由 Paul Prescod 撰写，旨在规定移除 Python 旧功能时应遵循的程序。 尽管本文描述的政策尚未被正式采纳，但最终的政策可能不会与 "
"Prescod 的提议有太大不同。"

#: ../../whatsnew/2.1.rst:295
msgid ":pep:`230` - Warning Framework"
msgstr ":pep:`230` - 警告框架"

#: ../../whatsnew/2.1.rst:296
msgid "Written and implemented by Guido van Rossum."
msgstr "由 Guido van Rossum 撰写并实现。"

#: ../../whatsnew/2.1.rst:302
msgid "PEP 229: New Build System"
msgstr "PEP 229: 新的构建系统"

#: ../../whatsnew/2.1.rst:304
msgid ""
"When compiling Python, the user had to go in and edit the "
":file:`Modules/Setup` file in order to enable various additional modules; "
"the default set is relatively small and limited to modules that compile on "
"most Unix platforms. This means that on Unix platforms with many more "
"features, most notably Linux, Python installations often don't contain all "
"useful modules they could."
msgstr ""
"在编译 Python 时，用户必须进入并编辑 :file:`Modules/Setup` 文件以启用各种附加模块；默认集相对较小，并且仅限于在大多数 "
"Unix 平台上编译的模块。这意味着在具有更多功能的 Unix 平台上，特别是 Linux，Python 安装通常不包含所有可能有用的模块。"

#: ../../whatsnew/2.1.rst:310
msgid ""
"Python 2.0 added the Distutils, a set of modules for distributing and "
"installing extensions.  In Python 2.1, the Distutils are used to compile "
"much of the standard library of extension modules, autodetecting which ones "
"are supported on the current machine.  It's hoped that this will make Python"
" installations easier and more featureful."
msgstr ""
"Python 2.0 添加了 Distutils，一组用于分发和安装扩展模块的模块。在 Python 2.1 中，Distutils "
"被用于编译大部分标准库扩展模块，自动检测当前机器上支持哪些模块。希望这将使 Python 的安装更加容易并具有更多功能。"

#: ../../whatsnew/2.1.rst:316
msgid ""
"Instead of having to edit the :file:`Modules/Setup` file in order to enable "
"modules, a :file:`setup.py` script in the top directory of the Python source"
" distribution is run at build time, and attempts to discover which modules "
"can be enabled by examining the modules and header files on the system.  If "
"a module is configured in :file:`Modules/Setup`, the :file:`setup.py` script"
" won't attempt to compile that module and will defer to the "
":file:`Modules/Setup` file's contents.  This provides a way to specific any "
"strange command-line flags or libraries that are required for a specific "
"platform."
msgstr ""
"不再需要编辑 :file:`Modules/Setup` 文件来启用模块，而是在 Python 源代码分发包的顶层目录运行一个 "
":file:`setup.py` 脚本，该脚本在构建时尝试通过检查系统上的模块和头文件来发现可以启用那些模块。 如果某个模块已在 "
":file:`Modules/Setup` 中配置，则 :file:`setup.py` 脚本不会尝试编译该模块，并会遵从 "
":file:`Modules/Setup` 文件中的内容。 这提供了一种方式来指定特定平台所需的任何奇怪的命令行旗标或库。"

#: ../../whatsnew/2.1.rst:325
msgid ""
"In another far-reaching change to the build mechanism, Neil Schemenauer "
"restructured things so Python now uses a single makefile that isn't "
"recursive, instead of makefiles in the top directory and in each of the "
":file:`Python/`, :file:`Parser/`, :file:`Objects/`, and :file:`Modules/` "
"subdirectories.  This makes building Python faster and also makes hacking "
"the Makefiles clearer and simpler."
msgstr ""
"在对构建机制的另一项重大更改中，Neil Schemenauer 对其进行了重组，现在 Python 使用单一的非递归 "
"makefile，而不是在顶层目录和 :file:`Python/`、:file:`Parser/`、:file:`Objects/`和 "
":file:`Modules/` 子目录中的多个 makefile。这使得构建 Python 更快，同时也使修改 Makefile 更加清晰和简单。"

#: ../../whatsnew/2.1.rst:335
msgid ":pep:`229` - Using Distutils to Build Python"
msgstr ":pep:`229` - 使用 Distutils 来构建 Python"

#: ../../whatsnew/2.1.rst:336 ../../whatsnew/2.1.rst:575
msgid "Written and implemented by A.M. Kuchling."
msgstr "由 A.M. Kuchling 撰写并实现。"

#: ../../whatsnew/2.1.rst:342
msgid "PEP 205: Weak References"
msgstr "PEP 205: 弱引用"

#: ../../whatsnew/2.1.rst:344
msgid ""
"Weak references, available through the :mod:`weakref` module, are a minor "
"but useful new data type in the Python programmer's toolbox."
msgstr "弱引用，通过 :mod:`weakref` 模块提供，是 Python 程序员工具箱中一种较小但有用的新数据类型。"

#: ../../whatsnew/2.1.rst:347
msgid ""
"Storing a reference to an object (say, in a dictionary or a list) has the "
"side effect of keeping that object alive forever.  There are a few specific "
"cases where this behaviour is undesirable, object caches being the most "
"common one, and another being circular references in data structures such as"
" trees."
msgstr ""
"存储一个指向对象的引用（例如，在字典或列表中）会导致该对象永久存活。 "
"在某些特定情况下，这种行为是不符合需要的，最常见的是对象缓存，另一个是像树这样的数据结构中的循环引用。"

#: ../../whatsnew/2.1.rst:352
msgid ""
"For example, consider a memoizing function that caches the results of "
"another function ``f(x)`` by storing the function's argument and its result "
"in a dictionary::"
msgstr "例如，考虑一个记忆化函数，它通过将函数的参数及其结果存储在字典中来缓存另一个函数 ``f(x)`` 的结果::"

#: ../../whatsnew/2.1.rst:356
msgid ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        return _cache[x]\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # Cache the returned object\n"
"    _cache[x] = retval\n"
"\n"
"    return retval"
msgstr ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        return _cache[x]\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # 缓存返回的对象\n"
"    _cache[x] = retval\n"
"\n"
"    return retval"

#: ../../whatsnew/2.1.rst:368
msgid ""
"This version works for simple things such as integers, but it has a side "
"effect; the ``_cache`` dictionary holds a reference to the return values, so"
" they'll never be deallocated until the Python process exits and cleans up. "
"This isn't very noticeable for integers, but if :func:`!f` returns an "
"object, or a data structure that takes up a lot of memory, this can be a "
"problem."
msgstr ""
"这个版本适用于诸如整数之类的简单对象，但它有一个副作用；``_cache`` 字典持有返回值的引用，因此这些值在 Python "
"进程退出并清理之前永远不会被释放。 对于整数来说这不是很明显，但如果 :func:`!f` 返回一个对象或占用大量内存的数据结构，这可能会成为一个问题。"

#: ../../whatsnew/2.1.rst:374
msgid ""
"Weak references provide a way to implement a cache that won't keep objects "
"alive beyond their time.  If an object is only accessible through weak "
"references, the object will be deallocated and the weak references will now "
"indicate that the object it referred to no longer exists.  A weak reference "
"to an object *obj* is created by calling ``wr = weakref.ref(obj)``.  The "
"object being referred to is returned by calling the weak reference as if it "
"were a function: ``wr()``.  It will return the referenced object, or "
"``None`` if the object no longer exists."
msgstr ""
"弱引用提供了一种实现缓存的方法，不会让对象在其生命周期结束后仍然存活。 "
"如果一个对象仅通过弱引用访问，该对象将被释放，并且弱引用将指示它所引用的对象不再存在。 通过调用 ``wr = weakref.ref(obj)`` "
"来创建对对象 *obj* 的弱引用。 通过调用弱引用，就像调用函数一样，可以返回被引用的对象: ``wr()``。 "
"如果对象仍然存在，它将返回被引用的对象；如果对象不再存在，则返回 ``None``。"

#: ../../whatsnew/2.1.rst:382
msgid ""
"This makes it possible to write a :func:`!memoize` function whose cache "
"doesn't keep objects alive, by storing weak references in the cache. ::"
msgstr "这使得可以编写一个 :func:`!memoize` 函数，其缓存不会使对象保持存活状态，因为缓存中存储的是弱引用。 ::"

#: ../../whatsnew/2.1.rst:385
msgid ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        obj = _cache[x]()\n"
"        # If weak reference object still exists,\n"
"        # return it\n"
"        if obj is not None: return obj\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # Cache a weak reference\n"
"    _cache[x] = weakref.ref(retval)\n"
"\n"
"    return retval"
msgstr ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        obj = _cache[x]()\n"
"        # 如果弱引用对象仍然存在，\n"
"        # 则返回它\n"
"        if obj is not None: return obj\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # 缓存一个弱引用\n"
"    _cache[x] = weakref.ref(retval)\n"
"\n"
"    return retval"

#: ../../whatsnew/2.1.rst:400
msgid ""
"The :mod:`weakref` module also allows creating proxy objects which behave "
"like weak references --- an object referenced only by proxy objects is "
"deallocated -- but instead of requiring an explicit call to retrieve the "
"object, the proxy transparently forwards all operations to the object as "
"long as the object still exists.  If the object is deallocated, attempting "
"to use a proxy will cause a :exc:`!weakref.ReferenceError` exception to be "
"raised. ::"
msgstr ""
":mod:`weakref` 模块还允许创建代理对象，代理对象的行为类似于弱引用 -- "
"仅被代理对象引用的对象会被解分配，但只要对象仍然存在，代理就会透明地将所有操作转发给对象，而不需要显式调用来检索对象。 "
"如果对象已被解分配，尝试使用代理将引发 :exc:`!weakref.ReferenceError` 异常。 ::"

#: ../../whatsnew/2.1.rst:407
msgid ""
"proxy = weakref.proxy(obj)\n"
"proxy.attr   # Equivalent to obj.attr\n"
"proxy.meth() # Equivalent to obj.meth()\n"
"del obj\n"
"proxy.attr   # raises weakref.ReferenceError"
msgstr ""
"proxy = weakref.proxy(obj)\n"
"proxy.attr   # 等同于 obj.attr\n"
"proxy.meth() # 等同于 obj.meth()\n"
"del obj\n"
"proxy.attr   # 引发 weakref.ReferenceError"

#: ../../whatsnew/2.1.rst:416
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱引用"

#: ../../whatsnew/2.1.rst:417
msgid "Written and implemented by Fred L. Drake, Jr."
msgstr "由 Fred L. Drake, Jr 撰写并实现。"

#: ../../whatsnew/2.1.rst:423
msgid "PEP 232: Function Attributes"
msgstr "PEP 232: 函数属性"

#: ../../whatsnew/2.1.rst:425
msgid ""
"In Python 2.1, functions can now have arbitrary information attached to "
"them. People were often using docstrings to hold information about functions"
" and methods, because the :attr:`~function.__doc__` attribute was the only "
"way of attaching any information to a function.  For example, in the Zope "
"web application server, functions are marked as safe for public access by "
"having a docstring, and in John Aycock's SPARK parsing framework, docstrings"
" hold parts of the BNF grammar to be parsed.  This overloading is "
"unfortunate, since docstrings are really intended to hold a function's "
"documentation; for example, it means you can't properly document functions "
"intended for private use in Zope."
msgstr ""
"在 Python 2.1 中，函数现在可以附加任意信息。人们经常使用文档字符串来保存有关函数和方法的信息，因为 "
":attr:`~function.__doc__` 属性是唯一可以将任何信息附加到函数上的方式。例如，在 Zope "
"网络应用服务器中，函数通过拥有文档字符串来标记为公共访问安全，在 John Aycock 的 SPARK 解析框架中，文档字符串包含要解析的 BNF "
"语法的部分。这种过载是不幸的，因为文档字符串实际上是用来保存函数文档的；例如，这意味着你不能正确地为 Zope 中预期用于私有用途的函数编写文档。"

#: ../../whatsnew/2.1.rst:436
msgid ""
"Arbitrary attributes can now be set and retrieved on functions using the "
"regular Python syntax::"
msgstr "现在可以使用常规的 Python 语法在函数上设置和检索任意属性::"

#: ../../whatsnew/2.1.rst:439
msgid ""
"def f(): pass\n"
"\n"
"f.publish = 1\n"
"f.secure = 1\n"
"f.grammar = \"A ::= B (C D)*\""
msgstr ""
"def f(): pass\n"
"\n"
"f.publish = 1\n"
"f.secure = 1\n"
"f.grammar = \"A ::= B (C D)*\""

#: ../../whatsnew/2.1.rst:445
msgid ""
"The dictionary containing attributes can be accessed as the function's "
":attr:`~function.__dict__`. Unlike the :attr:`~type.__dict__` attribute of "
"class instances, in functions you can actually assign a new dictionary to "
":attr:`~function.__dict__`, though the new value is restricted to a regular "
"Python dictionary; you *can't* be tricky and set it to a :class:`!UserDict` "
"instance, or any other random object that behaves like a mapping."
msgstr ""
"包含属性的字典可以作为函数的 :attr:`~function.__dict__` 来访问。 与类实例的 :attr:`~type.__dict__` "
"属性不同，在函数中你实际上可以为 :attr:`~function.__dict__` 分配一个新的字典，尽管新值仅限于常规的 Python 字典；你 "
"*不能* 狡猾地将其设为 :class:`!UserDict` 实例，或任何其他行为类似映射的随机对象。"

#: ../../whatsnew/2.1.rst:455
msgid ":pep:`232` - Function Attributes"
msgstr ":pep:`232` - 函数属性"

#: ../../whatsnew/2.1.rst:456
msgid "Written and implemented by Barry Warsaw."
msgstr "由 Barry Warsaw 撰写并实现"

#: ../../whatsnew/2.1.rst:462
msgid "PEP 235: Importing Modules on Case-Insensitive Platforms"
msgstr "PEP 235: 在大小写不敏感的平台上导入模块"

#: ../../whatsnew/2.1.rst:464
msgid ""
"Some operating systems have filesystems that are case-insensitive, MacOS and"
" Windows being the primary examples; on these systems, it's impossible to "
"distinguish the filenames ``FILE.PY`` and ``file.py``, even though they do "
"store the file's name  in its original case (they're case-preserving, too)."
msgstr ""
"一些操作系统的文件系统是大小写不敏感的，MacOS 和 Windows 是主要的例子；在这些系统上，无法区分文件名 ``FILE.PY`` 和 "
"``file.py``，尽管它们确实以原始大小写存储文件名（它们也是保留大小写的）。"

#: ../../whatsnew/2.1.rst:469
msgid ""
"In Python 2.1, the :keyword:`import` statement will work to simulate case-"
"sensitivity on case-insensitive platforms.  Python will now search for the "
"first case-sensitive match by default, raising an :exc:`ImportError` if no "
"such file is found, so ``import file`` will not import a module named "
"``FILE.PY``. Case-insensitive matching can be requested by setting the "
":envvar:`PYTHONCASEOK` environment variable before starting the Python "
"interpreter."
msgstr ""
"在 Python 2.1 中，:keyword:`import` 语句可以在不区分大小写的平台上模拟大小写敏感性。 现在，Python "
"默认搜索第一个大小写敏感匹配的文件，如果找不到这样的文件，就会引发 :exc:`ImportError`，因此 ``import file`` "
"不会导入名为 ``FILE.PY`` 的模块。 在启动 Python 解释器之前，可以通过设置 :envvar:`PYTHONCASEOK` "
"环境变量来请求大小写不敏感匹配。"

#: ../../whatsnew/2.1.rst:480
msgid "PEP 217: Interactive Display Hook"
msgstr "PEP 217: 交互模式显示钩子"

#: ../../whatsnew/2.1.rst:482
msgid ""
"When using the Python interpreter interactively, the output of commands is "
"displayed using the built-in :func:`repr` function. In Python 2.1, the "
"variable :func:`sys.displayhook` can be set to a callable object which will "
"be called instead of :func:`repr`. For example, you can set it to a special "
"pretty-printing function::"
msgstr ""
"在交互模式下使用 Python 解释器时，命令的输出是通过内置的 :func:`repr` 函数显示的。 在 Python 2.1 中，可以将变量 "
":func:`sys.displayhook` 设置为一个可调用对象，该对象将在代替 :func:`repr` 函数被调用。 "
"例如，你可以将其设置为一个特殊的美化打印函数::"

#: ../../whatsnew/2.1.rst:488
msgid ""
">>> # Create a recursive data structure\n"
"... L = [1,2,3]\n"
">>> L.append(L)\n"
">>> L # Show Python's default output\n"
"[1, 2, 3, [...]]\n"
">>> # Use pprint.pprint() as the display function\n"
"... import sys, pprint\n"
">>> sys.displayhook = pprint.pprint\n"
">>> L\n"
"[1, 2, 3,  <Recursion on list with id=135143996>]\n"
">>>"
msgstr ""
">>> # 创建一个递归的数据结构\n"
"... L = [1,2,3]\n"
">>> L.append(L)\n"
">>> L # 显示 Python 的默认输出\n"
"[1, 2, 3, [...]]\n"
">>> # 使用 pprint.pprint() 作为显示函数\n"
"... import sys, pprint\n"
">>> sys.displayhook = pprint.pprint\n"
">>> L\n"
"[1, 2, 3,  <Recursion on list with id=135143996>]\n"
">>>"

#: ../../whatsnew/2.1.rst:503
msgid ":pep:`217` - Display Hook for Interactive Use"
msgstr ":pep:`217` - 用于交互模式的显示钩子"

#: ../../whatsnew/2.1.rst:504
msgid "Written and implemented by Moshe Zadka."
msgstr "由 Moshe Zadka 撰写并实现"

#: ../../whatsnew/2.1.rst:510
msgid "PEP 208: New Coercion Model"
msgstr "PEP 208: 新的强制转换模型"

#: ../../whatsnew/2.1.rst:512
msgid ""
"How numeric coercion is done at the C level was significantly modified.  "
"This will only affect the authors of C extensions to Python, allowing them "
"more flexibility in writing extension types that support numeric operations."
msgstr ""
"在 C 级别上的数值类型转换方法进行了重大修改。 这只会影响编写 Python C 扩展的作者，使他们在编写支持数值运算的扩展类型时有更多的灵活性。"

#: ../../whatsnew/2.1.rst:516
msgid ""
"Extension types can now set the type flag ``Py_TPFLAGS_CHECKTYPES`` in their"
" ``PyTypeObject`` structure to indicate that they support the new coercion "
"model. In such extension types, the numeric slot functions can no longer "
"assume that they'll be passed two arguments of the same type; instead they "
"may be passed two arguments of differing types, and can then perform their "
"own internal coercion. If the slot function is passed a type it can't "
"handle, it can indicate the failure by returning a reference to the "
"``Py_NotImplemented`` singleton value. The numeric functions of the other "
"type will then be tried, and perhaps they can handle the operation; if the "
"other type also returns ``Py_NotImplemented``, then a :exc:`TypeError` will "
"be raised.  Numeric methods written in Python can also return "
"``Py_NotImplemented``, causing the interpreter to act as if the method did "
"not exist (perhaps raising a :exc:`TypeError`, perhaps trying another "
"object's numeric methods)."
msgstr ""
"扩展类型现在可以在其 ``PyTypeObject`` 结构中设置类型标志 "
"``Py_TPFLAGS_CHECKTYPES``，以表明它们支持新的强制模型。 "
"在此类扩展类型中，数字槽函数不再假定它们将得到两个相同类型的参数；相反，它们可能会得到两个不同类型的参数，然后可以执行自己的内部强制。如果槽函数传递给它一个无法处理的类型，它可以通过返回一个指向"
" ``Py_NotImplemented`` 单一值的引用来表示失败。 然后将尝试其他类型的数值函数，也许它们可以处理该操作；如果其他类型也返回 "
"``Py_NotImplemented``，那么将引发 :exc:`TypeError`。 用 Python 写的数值方法也可以返回 "
"``Py_NotImplemented``，导致解释器当作该方法不存在（也许会引发 :exc:`TypeError`，也许会尝试另一个对象的数值方法）。"

#: ../../whatsnew/2.1.rst:533
msgid ":pep:`208` - Reworking the Coercion Model"
msgstr ":pep:`208` - 改写强制转换模型"

#: ../../whatsnew/2.1.rst:534
msgid ""
"Written and implemented by Neil Schemenauer, heavily based upon earlier work"
" by Marc-André Lemburg.  Read this to understand the fine points of how "
"numeric operations will now be processed at the C level."
msgstr ""
"由 Neil Schemenauer 编写和实现，基于 Marc-André Lemburg 的早期工作。阅读这部分内容可以了解数值运算在 C "
"级别上现在如何处理的细节。"

#: ../../whatsnew/2.1.rst:542
msgid "PEP 241: Metadata in Python Packages"
msgstr "PEP 241: Python 包中的元数据"

#: ../../whatsnew/2.1.rst:544
msgid ""
"A common complaint from Python users is that there's no single catalog of "
"all the Python modules in existence.  T. Middleton's Vaults of Parnassus at "
"``www.vex.net/parnassus/`` (retired in February 2009, `available in the "
"Internet Archive Wayback Machine "
"<https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/>`_)"
" was the largest catalog of Python modules, but registering software at the "
"Vaults is optional, and many people did not bother."
msgstr ""
"Python 用户经常抱怨的一个问题是不存在包含所有 Python 模块的单一类目。 位于 ``www.vex.net/parnassus/`` 上 "
"T. Middleton 的 Vaults of Parnassus (2009 年 2 月已停用，`可在 Internet Archive "
"Wayback Machine "
"<https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/>`_"
" 上查阅) 是最大的 Python 模块类目，但在 Vaults 上注册软件只是个可选项，很多人都懒得这样做。"

#: ../../whatsnew/2.1.rst:552
msgid ""
"As a first small step toward fixing the problem, Python software packaged "
"using the Distutils :command:`sdist` command will include a file named "
":file:`PKG-INFO` containing information about the package such as its name, "
"version, and author (metadata, in cataloguing terminology).  :pep:`241` "
"contains the full list of fields that can be present in the :file:`PKG-INFO`"
" file.  As people began to package their software using Python 2.1, more and"
" more packages will include metadata, making it possible to build automated "
"cataloguing systems and experiment with them.  With the result experience, "
"perhaps it'll be possible to design a really good catalog and then build "
"support for it into Python 2.2. For example, the Distutils :command:`sdist` "
"and :command:`bdist_\\*` commands could support an ``upload`` option that "
"would automatically upload your package to a catalog server."
msgstr ""
"作为解决这个问题的第一步，使用 Distutils :command:`sdist` 命令打包的 Python 软件将包含一个名为 "
":file:`PKG-INFO` 的文件，其中包含有关包的信息，如名称、版本和作者（在目录编制术语中称为元数据）。:file:`PKG-INFO` "
"文件可以包含的字段的完整列表见 :pep:`241`。随着人们开始使用 Python 2.1 "
"打包他们的软件，越来越多的包将包含元数据，从而使得构建自动化目录系统并进行实验成为可能。通过积累经验，也许有可能设计一个真正好的目录系统，然后在 "
"Python 2.2 中支持它。例如，Distutils 的 :command:`sdist` 和 :command:`bdist_\\*` "
"命令可以支持一个 ``upload`` 选项，自动将你的包上传到目录服务器。"

#: ../../whatsnew/2.1.rst:565
msgid ""
"You can start creating packages containing :file:`PKG-INFO` even if you're "
"not using Python 2.1, since a new release of the Distutils will be made for "
"users of earlier Python versions.  Version 1.0.2 of the Distutils includes "
"the changes described in :pep:`241`, as well as various bugfixes and "
"enhancements.  It will be available from the Distutils SIG at "
"https://www.python.org/community/sigs/current/distutils-sig/."
msgstr ""
"即使你不使用 Python 2.1，你也可以开始创建包含 :file:`PKG-INFO` 的包，因为 Distutils 的新版本将为早期 "
"Python 版本的用户发布。Distutils 1.0.2 版本包含了 :pep:`241` 所描述的更改，以及各种错误修复和增强功能。可以从 "
"Distutils SIG 上获取该版本 "
"https://www.python.org/community/sigs/current/distutils-sig/ 。"

#: ../../whatsnew/2.1.rst:574
msgid ":pep:`241` - Metadata for Python Software Packages"
msgstr ":pep:`241` - 针对 Python 软件包的元数据"

#: ../../whatsnew/2.1.rst:577
msgid ":pep:`243` - Module Repository Upload Mechanism"
msgstr ":pep:`243` - 模块仓库上传机制"

#: ../../whatsnew/2.1.rst:578
msgid ""
"Written by Sean Reifschneider, this draft PEP describes a proposed mechanism"
" for uploading  Python packages to a central server."
msgstr "由 Sean Reifschneider 撰写，这个 PEP 草案描述了用于将 Python 软件包上传到一个中心服务器的建议机制。"

#: ../../whatsnew/2.1.rst:585
msgid "New and Improved Modules"
msgstr "新增和改进的模块"

#: ../../whatsnew/2.1.rst:587
msgid ""
"Ka-Ping Yee contributed two new modules: :mod:`!inspect.py`, a module for "
"getting information about live Python code, and :mod:`!pydoc.py`, a module "
"for interactively converting docstrings to HTML or text.  As a bonus, "
":file:`Tools/scripts/pydoc`, which is now automatically installed, uses "
":mod:`!pydoc.py` to display documentation given a Python module, package, or"
" class name.  For example, ``pydoc xml.dom`` displays the following::"
msgstr ""
"Ka-Ping Yee 贡献了两个新模块: :mod:`!inspect.py`，用于获取有关正在运行的 Python 代码的信息，以及 "
":mod:`!pydoc.py`，用于交互式地将文档字符串转换为 HTML 或文本。 "
"此外，作为一个额外的功能，:file:`Tools/scripts/pydoc` 现在会自动安装，并使用 :mod:`!pydoc.py` 来显示给定 "
"Python 模块、包或类名的文档。例如，``pydoc xml.dom`` 会显示如下内容::"

#: ../../whatsnew/2.1.rst:594
msgid ""
"Python Library Documentation: package xml.dom in xml\n"
"\n"
"NAME\n"
"    xml.dom - W3C Document Object Model implementation for Python.\n"
"\n"
"FILE\n"
"    /usr/local/lib/python2.1/xml/dom/__init__.pyc\n"
"\n"
"DESCRIPTION\n"
"    The Python mapping of the Document Object Model is documented in the\n"
"    Python Library Reference in the section on the xml.dom package.\n"
"\n"
"    This package contains the following modules:\n"
"      ..."
msgstr ""
"Python Library Documentation: package xml.dom in xml\n"
"\n"
"NAME\n"
"    xml.dom - W3C Document Object Model implementation for Python.\n"
"\n"
"FILE\n"
"    /usr/local/lib/python2.1/xml/dom/__init__.pyc\n"
"\n"
"DESCRIPTION\n"
"    The Python mapping of the Document Object Model is documented in the\n"
"    Python Library Reference in the section on the xml.dom package.\n"
"\n"
"    This package contains the following modules:\n"
"      ..."

#: ../../whatsnew/2.1.rst:609
msgid ""
":file:`pydoc` also includes a Tk-based interactive help browser.   "
":file:`pydoc` quickly becomes addictive; try it out!"
msgstr ":file:`pydoc` 还包括一个基于 Tk 的交互式帮助浏览器。:file:`pydoc` 很快会让人上瘾；试试看！"

#: ../../whatsnew/2.1.rst:612
msgid ""
"Two different modules for unit testing were added to the standard library. "
"The :mod:`doctest` module, contributed by Tim Peters, provides a testing "
"framework based on running embedded examples in docstrings and comparing the"
" results against the expected output.  PyUnit, contributed by Steve Purcell,"
" is a unit testing framework inspired by JUnit, which was in turn an "
"adaptation of Kent Beck's Smalltalk testing framework.  See "
"https://pyunit.sourceforge.net/ for more information about PyUnit."
msgstr ""
"两个不同的单元测试模块被添加到标准库中。:mod:`doctest` 模块，由 Tim Peters "
"贡献，提供了一个基于运行嵌入在文档字符串中的示例并将结果与预期输出进行比较的测试框架。PyUnit，由 Steve Purcell 贡献，是一个受到 "
"JUnit 启发的单元测试框架，而 JUnit 则是对 Kent Beck 的 Smalltalk 测试框架的改编。更多关于 PyUnit "
"的信息，请参阅 https://pyunit.sourceforge.net/ 。"

#: ../../whatsnew/2.1.rst:620
msgid ""
"The :mod:`difflib` module contains a class, "
":class:`~difflib.SequenceMatcher`, which compares two sequences and computes"
" the changes required to transform one sequence into the other.  For "
"example, this module can be used to write a tool similar to the Unix "
":program:`diff` program, and in fact the sample program "
":file:`Tools/scripts/ndiff.py` demonstrates how to write such a script."
msgstr ""
":mod:`difflib` 模块包含一个类，即 "
":class:`~difflib.SequenceMatcher`，用于比较两个序列，并计算将一个序列转换为另一个序列所需的变化。 "
"例如，该模块可用于编写与 Unix :program:`diff` 程序类似的工具，事实上，示例程序 "
":file:`Tools/scripts/ndiff.py` 演示了如何编写这样的脚本。"

#: ../../whatsnew/2.1.rst:626
msgid ""
":mod:`curses.panel`, a wrapper for the panel library, part of ncurses and of"
" SYSV curses, was contributed by Thomas Gellekum.  The panel library "
"provides windows with the additional feature of depth. Windows can be moved "
"higher or lower in the depth ordering, and the panel library figures out "
"where panels overlap and which sections are visible."
msgstr ""
":mod:`curses.panel`，是 ncurses 和 SYSV curses 一部分的 panel 库的包装器，由 Thomas "
"Gellekum 贡献。panel 库为窗口提供了深度特性。窗口可以在深度顺序中向上或向下移动，panel 库会计算出面板的重叠位置和哪些部分是可见的。"

#: ../../whatsnew/2.1.rst:632
msgid ""
"The PyXML package has gone through a few releases since Python 2.0, and "
"Python 2.1 includes an updated version of the :mod:`xml` package.  Some of "
"the noteworthy changes include support for Expat 1.2 and later versions, the"
" ability for Expat parsers to handle files in any encoding supported by "
"Python, and various bugfixes for SAX, DOM, and the :mod:`!minidom` module."
msgstr ""
"PyXML 包自 Python 2.0 以来经历了几次发布，Python 2.1 包含了更新版本的 :mod:`xml` 包。一些值得注意的更改包括支持"
" Expat 1.2 及更高版本，Expat 解析器能够处理 Python 支持的任何编码的文件，以及对 SAX、DOM 和 "
":mod:`!minidom` 模块的各种错误修复。"

#: ../../whatsnew/2.1.rst:638
msgid ""
"Ping also contributed another hook for handling uncaught exceptions. "
":func:`sys.excepthook` can be set to a callable object.  When an exception "
"isn't caught by any :keyword:`try`...\\ :keyword:`except` blocks, the "
"exception will be passed to :func:`sys.excepthook`, which can then do "
"whatever it likes.  At the Ninth Python Conference, Ping demonstrated an "
"application for this hook: printing an extended traceback that not only "
"lists the stack frames, but also lists the function arguments and the local "
"variables for each frame."
msgstr ""
"Ka-Ping Yee 还贡献了另一个用于处理未捕获异常的钩子。:func:`sys.excepthook` 可以设置为一个可调用对象。当异常未被任何 "
":keyword:`try`...\\ :keyword:`except` 块捕获时，异常将传递给 "
":func:`sys.excepthook`，它可以执行任何需要的操作。在第九届 Python "
"会议上，他演示了这个钩子的一个应用：打印扩展的回溯信息，不仅列出堆栈帧，还列出每个帧的函数参数和局部变量。"

#: ../../whatsnew/2.1.rst:646
msgid ""
"Various functions in the :mod:`time` module, such as :func:`~time.asctime` "
"and :func:`~time.localtime`, require a floating-point argument containing "
"the time in seconds since the epoch.  The most common use of these functions"
" is to work with the current time, so the floating-point argument has been "
"made optional; when a value isn't provided, the current time will be used.  "
"For example, log file entries usually need a string containing the current "
"time; in Python 2.1, ``time.asctime()`` can be used, instead of the "
"lengthier ``time.asctime(time.localtime(time.time()))`` that was previously "
"required."
msgstr ""
":mod:`time` 模块中的各种函数，如 :func:`~time.asctime` 和 "
":func:`~time.localtime`，需要一个包含自纪元以来的时间以秒为单位的浮点参数。这些函数最常见的用途是处理当前时间，因此浮点参数现在是可选的；当没有提供值时，将使用当前时间。例如，日志文件条目通常需要一个包含当前时间的字符串；在"
" Python 2.1 中，可以使用 ``time.asctime()``，而不是之前需要的较长的 "
"``time.asctime(time.localtime(time.time()))``。"

#: ../../whatsnew/2.1.rst:655
msgid "This change was proposed and implemented by Thomas Wouters."
msgstr "此更改由 Thomas Wouters 提出并实现。"

#: ../../whatsnew/2.1.rst:657
msgid ""
"The :mod:`ftplib` module now defaults to retrieving files in passive mode, "
"because passive mode is more likely to work from behind a firewall.  This "
"request came from the Debian bug tracking system, since other Debian "
"packages use :mod:`ftplib` to retrieve files and then don't work from behind"
" a firewall. It's deemed unlikely that this will cause problems for anyone, "
"because Netscape defaults to passive mode and few people complain, but if "
"passive mode is unsuitable for your application or network setup, call "
"``set_pasv(0)`` on FTP objects to disable passive mode."
msgstr ""
":mod:`ftplib` 模块现在默认以被动模式检索文件，因为被动模式在防火墙后面更可能正常工作。这一请求来自 Debian 错误跟踪系统，因为其他 "
"Debian 包使用 :mod:`ftplib` 来检索文件，但在防火墙后面无法正常工作。由于 Netscape "
"默认使用被动模式且几乎没有人抱怨，因此认为这不太可能会对任何人造成问题。但如果被动模式不适合你的应用程序或网络设置，可以调用 FTP 对象的 "
"``set_pasv(0)`` 来禁用被动模式。"

#: ../../whatsnew/2.1.rst:666
msgid ""
"Support for raw socket access has been added to the :mod:`socket` module, "
"contributed by Grant Edwards."
msgstr "对原始套接字访问的支持已添加到 :mod:`socket` 模块中，由 Grant Edwards 贡献。"

#: ../../whatsnew/2.1.rst:669
msgid ""
"The :mod:`pstats` module now contains a simple interactive statistics "
"browser for displaying timing profiles for Python programs, invoked when the"
" module is run as a script.  Contributed by  Eric S. Raymond."
msgstr ""
":mod:`pstats` 模块现在包含一个简单的交互式统计浏览器，用于显示 Python 程序的时间分析结果，当该模块作为脚本运行时调用。此功能由 "
"Eric S. Raymond 贡献。"

#: ../../whatsnew/2.1.rst:673
msgid ""
"A new implementation-dependent function, ``sys._getframe([depth])``, has "
"been added to return a given frame object from the current call stack. "
":func:`sys._getframe` returns the frame at the top of the call stack;  if "
"the optional integer argument *depth* is supplied, the function returns the "
"frame that is *depth* calls below the top of the stack.  For example, "
"``sys._getframe(1)`` returns the caller's frame object."
msgstr ""
"新增了一个依赖于实现的函数 "
"``sys._getframe([depth])``，用于从当前调用堆栈中返回给定的帧对象。:func:`sys._getframe`返回调用堆栈顶部的帧对象；如果提供了可选的整数参数"
" depth，则该函数返回堆栈顶部以下 depth 层的帧。例如，``sys._getframe(1)`` 返回调用者的帧对象。"

#: ../../whatsnew/2.1.rst:680
msgid ""
"This function is only present in CPython, not in Jython or the .NET "
"implementation.  Use it for debugging, and resist the temptation to put it "
"into production code."
msgstr "这个函数仅存在于 CPython 中，不存在于 Jython 或 .NET 实现中。请将其用于调试，并避免将其放入生产代码中。"

#: ../../whatsnew/2.1.rst:688
msgid "Other Changes and Fixes"
msgstr "其他的改变和修正"

#: ../../whatsnew/2.1.rst:690
msgid ""
"There were relatively few smaller changes made in Python 2.1 due to the "
"shorter release cycle.  A search through the CVS change logs turns up 117 "
"patches applied, and 136 bugs fixed; both figures are likely to be "
"underestimates.  Some of the more notable changes are:"
msgstr ""
"由于较短的发布周期，Python 2.1 中的较小更改相对较少。通过搜索 CVS 更改日志，发现应用了 117 个补丁并修复了 136 "
"个错误；这两个数字都可能是低估的。一些较为显著的更改包括："

#: ../../whatsnew/2.1.rst:695
msgid ""
"A specialized object allocator is now optionally available, that should be "
"faster than the system :c:func:`malloc` and have less memory overhead.  The "
"allocator uses C's :c:func:`!malloc` function to get large pools of memory, "
"and then fulfills smaller memory requests from these pools.  It can be "
"enabled by providing the :option:`!--with-pymalloc` option to the "
":program:`configure` script; see :file:`Objects/obmalloc.c` for the "
"implementation details."
msgstr ""
"现在可以选择使用一个专门的对象分配器，该分配器应比系统的 :c:func:`malloc` 更快且具有更少的内存开销。该分配器使用 C 语言的 "
":c:func:`!malloc` 函数来获取大型内存池，然后从这些池中满足较小的内存请求。可以通过向 :program:`configure` "
"脚本提供 :option:`!--with-pymalloc` 选项来启用该分配器；有关实现细节，请参阅 "
":file:`Objects/obmalloc.c`。"

#: ../../whatsnew/2.1.rst:702
msgid ""
"Authors of C extension modules should test their code with the object "
"allocator enabled, because some incorrect code may break, causing core dumps"
" at runtime. There are a bunch of memory allocation functions in Python's C "
"API that have previously been just aliases for the C library's "
":c:func:`malloc` and :c:func:`free`, meaning that if you accidentally called"
" mismatched functions, the error wouldn't be noticeable.  When the object "
"allocator is enabled, these functions aren't aliases of :c:func:`!malloc` "
"and :c:func:`!free` any more, and calling the wrong function to free memory "
"will get you a core dump.  For example, if memory was allocated using "
":c:macro:`PyMem_New`, it has to be freed using :c:func:`PyMem_Del`, not "
":c:func:`!free`.  A few modules included with Python fell afoul of this and "
"had to be fixed; doubtless there are more third-party modules that will have"
" the same problem."
msgstr ""
"C 扩展模块的作者应该在启用对象分配器的情况下测试他们的代码，因为一些不正确的代码可能会被破坏，导致运行时的核心转储。 在 Python 的 C API"
" 中有许多内存分配函数，它们以前只是 C 库的 :c:func:`malloc` 和 :c:func:`free` "
"的别名，这意味着如果您不小心调用了不匹配的函数，错误是不会被注意到的。 启用对象分配器后，这些函数不再是 :c:func:`!malloc` 和 "
":c:func:`!free` 的别名，调用错误的函数释放内存将导致核心转储。 例如，如果使用 :c:macro:`PyMem_New` "
"分配了内存，就必须使用 :c:func:`PyMem_Del` 而不是 :c:func:`!free` 释放内存。 Python "
"附带的一些模块就有这样的问题，必须进行修复；毫无疑问，还有更多的第三方模块会有同样的问题。"

#: ../../whatsnew/2.1.rst:715
msgid "The object allocator was contributed by Vladimir Marangozov."
msgstr "对象分配器由 Vladimir Marangozov 贡献。"

#: ../../whatsnew/2.1.rst:717
msgid ""
"The speed of line-oriented file I/O has been improved because people often "
"complain about its lack of speed, and because it's often been used as a "
"naïve benchmark.  The :meth:`readline` method of file objects has therefore "
"been rewritten to be much faster.  The exact amount of the speedup will vary"
" from platform to platform depending on how slow the C library's "
":c:func:`!getc` was, but is around 66%, and potentially much faster on some "
"particular operating systems. Tim Peters did much of the benchmarking and "
"coding for this change, motivated by a discussion in comp.lang.python."
msgstr ""
"由于人们经常抱怨面向行的文件 I/O 速度缓慢，并且它经常被用作一个简单的基准测试，其速度已经得到了改进。 因此，文件对象的 "
":meth:`readline` 方法被重写，以实现更快的速度。 具体的速度提升因平台而异，取决于 C 库的 :c:func:`!getc` "
"有多慢，但大约提升了66%，在某些特定的操作系统上可能更快。 Tim Peters 在 comp.lang.python "
"的讨论中受到了启发，进行了许多基准测试和编码修改。"

#: ../../whatsnew/2.1.rst:726
msgid ""
"A new module and method for file objects was also added, contributed by Jeff"
" Epler. The new method, :meth:`!xreadlines`, is similar to the existing "
":func:`!xrange` built-in.  :func:`!xreadlines` returns an opaque sequence "
"object that only supports being iterated over, reading a line on every "
"iteration but not reading the entire file into memory as the existing "
":meth:`!readlines` method does. You'd use it like this::"
msgstr ""
"新增了一个模块和文件对象的方法，由 Jeff Epler 贡献。 新方法 :meth:`!xreadlines` 类似于现有的内置方法 "
":func:`!xrange`。 :func:`!xreadlines` 返回一个不透明的序列对象，该对象仅支持迭代，每次迭代读取一行，而不像现有的 "
":meth:`!readlines` 方法那样将整个文件读入内存。 你可以像这样使用它::"

#: ../../whatsnew/2.1.rst:733
msgid ""
"for line in sys.stdin.xreadlines():\n"
"    # ... do something for each line ...\n"
"    ..."
msgstr ""
"for line in sys.stdin.xreadlines():\n"
"    # ... 对每一行执行某些操作 ...\n"
"    ..."

#: ../../whatsnew/2.1.rst:737
msgid ""
"For a fuller discussion of the line I/O changes, see the python-dev summary "
"for January 1--15, 2001 at https://mail.python.org/pipermail/python-"
"dev/2001-January/."
msgstr ""
"有关行 I/O 更改的更详细讨论，请参阅 2001 年 1 月 1 日至 15 日的 python-dev 摘要 "
"https://mail.python.org/pipermail/python-dev/2001-January/ 。"

#: ../../whatsnew/2.1.rst:740
msgid ""
"A new method, :meth:`~dict.popitem`, was added to dictionaries to enable "
"destructively iterating through the contents of a dictionary; this can be "
"faster for large dictionaries because there's no need to construct a list "
"containing all the keys or values. ``D.popitem()`` removes a random ``(key, "
"value)`` pair from the dictionary ``D`` and returns it as a 2-tuple.  This "
"was implemented mostly by Tim Peters and Guido van Rossum, after a "
"suggestion and preliminary patch by Moshe Zadka."
msgstr ""
"给字典添加了一个新方法 "
":meth:`~dict.popitem`，用于破坏性地迭代字典的内容；这对于大字典来说可能更快，因为不需要构建包含所有键或值的列表。 "
"``D.popitem()`` 从字典 ``D`` 中移除一个随机的 ``(key, value)`` 键值对，并将其作为一个 2 元组返回。 "
"此功能主要由 Tim Peters 和 Guido van Rossum 实现，基于 Moshe Zadka 的建议和初步补丁。"

#: ../../whatsnew/2.1.rst:748
msgid ""
"Modules can now control which names are imported when ``from module import "
"*`` is used, by defining an ``__all__`` attribute containing a list of names"
" that will be imported.  One common complaint is that if the module imports "
"other modules such as :mod:`sys` or :mod:`string`, ``from module import *`` "
"will add them to the importing module's namespace.  To fix this, simply list"
" the public names in ``__all__``::"
msgstr ""
"模块现在可以通过定义一个 ``__all__`` 属性来控制使用 ``from module import *`` 时导入的名称。 "
"一个常见的抱怨是，如果模块导入了其他模块，例如 :mod:`sys` 或 :mod:`string`，使用 ``from module import "
"*`` 会将它们添加到导入模块的命名空间中。 为了解决这个问题，只需在 ``__all__`` 模块中列出公共名称即可::"

#: ../../whatsnew/2.1.rst:755
msgid ""
"# List public names\n"
"__all__ = ['Database', 'open']"
msgstr ""
"# 列出公有名称\n"
"__all__ = ['Database', 'open']"

#: ../../whatsnew/2.1.rst:758
msgid ""
"A stricter version of this patch was first suggested and implemented by Ben "
"Wolfson, but after some python-dev discussion, a weaker final version was "
"checked in."
msgstr ""
"此补丁的更严格版本最初由 Ben Wolfson 提出并实现，但在经过一些 python-dev 讨论后，最终版本被修改为较弱的版本并提交。"

#: ../../whatsnew/2.1.rst:762
msgid ""
"Applying :func:`repr` to strings previously used octal escapes for non-"
"printable characters; for example, a newline was ``'\\012'``.  This was a "
"vestigial trace of Python's C ancestry, but today octal is of very little "
"practical use.  Ka-Ping Yee suggested using hex escapes instead of octal "
"ones, and using the ``\\n``, ``\\t``, ``\\r`` escapes for the appropriate "
"characters, and implemented this new formatting."
msgstr ""
"以前对字符串应用 :func:`repr` 时，对于不可打印字符使用八进制转义符；例如，换行符表示为 ``'\\012'``。这是 Python 从 C"
" 语言继承而来的遗留特性，但如今八进制的实际用途非常有限。Ka-Ping Yee 建议使用十六进制转义符代替八进制，并使用 "
"``\\n``、``\\t``、``\\r`` 等转义符表示适当的字符，并实现了这种新的格式。"

#: ../../whatsnew/2.1.rst:769
msgid ""
"Syntax errors detected at compile-time can now raise exceptions containing "
"the filename and line number of the error, a pleasant side effect of the "
"compiler reorganization done by Jeremy Hylton."
msgstr "在编译时检测到的语法错误现在可以引发包含错误文件名和行号的异常，这是 Jeremy Hylton 进行的编译器重组的一个令人愉快的副作用。"

#: ../../whatsnew/2.1.rst:773
msgid ""
"C extensions which import other modules have been changed to use "
":c:func:`PyImport_ImportModule`, which means that they will use any import "
"hooks that have been installed.  This is also encouraged for third-party "
"extensions that need to import some other module from C code."
msgstr ""
"导入其他模块的 C 扩展已更改为使用 "
":c:func:`PyImport_ImportModule`，这意味着它们将使用已安装的任何导入钩子。这对于需要从 C "
"代码导入其他模块的第三方扩展也同样鼓励使用。"

#: ../../whatsnew/2.1.rst:778
msgid ""
"The size of the Unicode character database was shrunk by another 340K thanks"
" to Fredrik Lundh."
msgstr "由于 Fredrik Lundh 的努力，Unicode 字符数据库的大小又减少了 340K。"

#: ../../whatsnew/2.1.rst:781
msgid ""
"Some new ports were contributed: MacOS X (by Steven Majewski), Cygwin (by "
"Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. "
"Allie)."
msgstr ""
"一些新移植版本被贡献：MacOS X（由 Steven Majewski 贡献），Cygwin（由 Jason Tishler 贡献），RISCOS（由"
" Dietmar Schwertberger 贡献），以及 Unixware 7（由 Billy G. Allie 贡献）。"

#: ../../whatsnew/2.1.rst:785
msgid ""
"And there's the usual list of minor bugfixes, minor memory leaks, docstring "
"edits, and other tweaks, too lengthy to be worth itemizing; see the CVS logs"
" for the full details if you want them."
msgstr ""
"此外还有一份由次要的程序错误修复、次要的内存泄漏、文档字符串编辑和其他调整组成的常规清单，因过于冗长而不值得逐项列出；如果你想了解完整细节请参阅 CVS"
" 日志。"

#: ../../whatsnew/2.1.rst:793
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.1.rst:795
msgid ""
"The author would like to thank the following people for offering suggestions"
" on various drafts of this article: Graeme Cross, David Goodger, Jay Graves,"
" Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas"
" Wouters."
msgstr ""
"作者感谢以下人员对本文的各种草案提出建议： Graeme Cross, David Goodger, Jay Graves, Michael "
"Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters."
