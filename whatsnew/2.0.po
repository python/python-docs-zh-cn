# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-31 15:21+0000\n"
"PO-Revision-Date: 2023-05-24 02:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.0.rst:3
msgid "What's New in Python 2.0"
msgstr "Python 2.0 有什么新变化"

#: ../../whatsnew/2.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.0.rst:5
msgid "A.M. Kuchling and Moshe Zadka"
msgstr "A.M. Kuchling 和 Moshe Zadka"

#: ../../whatsnew/2.0.rst:13
msgid "Introduction"
msgstr "概述"

#: ../../whatsnew/2.0.rst:15
msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This"
" article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Python "
"2.0的新版本于2000年10月16日发布。本文将介绍2.0版本中的一些令人兴奋的新功能，重点介绍一些其他有用的更改，并指出一些可能需要重写代码的不兼容更改。"

#: ../../whatsnew/2.0.rst:20
msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to "
"SourceForge."
msgstr ""
"Python 的开发工作在版本发布之间绝不会完全停止，总是会有错误修复和改进被持续地提交。 2.0 "
"中包含了大量的小问题修正、一些性能优化、额外的文档字符串和更完善的错误消息；要列出所有这些是不可能的，但它们确实带来了明显的变化。 "
"如果你想查看完整清单可以参阅公开的 CVS 日志。 这些进展归功于为 PythonLabs "
"工作的五位开发者，他们现在可以付出时间修复问题并获得报酬，同时也归功于迁移到 SourceForge 后在沟通方面的改善。"

#: ../../whatsnew/2.0.rst:33
msgid "What About Python 1.6?"
msgstr "Python 1.6 将会怎样？"

#: ../../whatsnew/2.0.rst:35
msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a"
" 1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python 2.0."
"  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 可以被视为继续履行合同义务的 Python 发布版。 在核心开发团队于 2000 年 5 月离开 CNRI 之后，CNRI "
"要求创建一个 1.6 发布版，其中包含 CNRI 在 Python 项目上已完成的所有工作。 因此 Python 1.6 代表了截至 2000 年 5 "
"月的 CVS 树的状态，其中最重要的新特性是 Unicode 支持。 当然，5 月之后开发工作仍在继续，因此 1.6 树接受了一些修正以确保它对 "
"Python 2.0 向上兼容。 所以 1.6 仍是 Python 演化过程的组成部分，而不是一个旁支。"

#: ../../whatsnew/2.0.rst:44
msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are"
" only in 2.0, because a lot of work was done between May and September."
msgstr ""
"那么，你应该对 Python 1.6 保持更多关注吗？也许不必。 1.6final 和 2.0beta1 是在同一天（2000 年 9 月 5 "
"日）发布的，计划在一个月左右的时间内完成 Python 2.0 正式版。 如果你有应用程序需要维护，那么迁移到 1.6 "
"破坏兼容性，修复它们，然后在一个月内又迁移到 2.0 再进行新一轮的兼容性修复的做法似乎没有什么意义；你最好直接迁移到 2.0。 "
"本文档中介绍的大多数真正值得关注的特性都只出现在 2.0 中，因为很多工作都是在 5 月到 9 月之间完成的。"

#: ../../whatsnew/2.0.rst:57
msgid "New Development Process"
msgstr "新开发流程"

#: ../../whatsnew/2.0.rst:59
msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or"
" submit patches for Python 2.0, use the bug tracking and patch manager tools"
" available from Python's project page, located at "
"https://sourceforge.net/projects/python/."
msgstr ""
"Python 2.0 中最重要的变化可能根本不是代码，而是 Python 的开发方式：在 2000 年 5 月，Python 开发者开始使用 "
"SourceForge 提供的工具来存储源代码、跟踪错误报告以及管理补丁提交队列。 要报告 Python 2.0 的错误或提交补丁，请使用位于 "
"https://sourceforge.net/projects/python/ 的 Python项目页上的错误跟踪和补丁管理器工具。"

#: ../../whatsnew/2.0.rst:66
msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access"
" to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"现在托管在SourceForge的最重要的服务是Python "
"CVS树，这是一个包含Python源代码的版本控制库。以前，大约有7个左右的人可以写入CVS树，所有的补丁都必须由这个短名单上的一个人检查和签到。很明显，这并不是非常可扩展的。通过将CVS树转移到SourceForge，有可能向更多的人授予写访问权；截至2000年9月，有27人能够检查变化，增加了4倍。这使得大规模的改变成为可能，如果它们必须通过一小群核心开发者来过滤，就不会被尝试。例如，有一天Peter"
" Schneider-Kamp想到了放弃K&R C的兼容性，将Python的C源转换为ANSI C。在获得python-"
"dev邮件列表的批准后，他发起了一连串的签到，持续了大约一周，其他开发人员加入了进来帮忙，工作就完成了。如果只有5个人可以接触到写作，那么这项任务可能会被视为"
" \"不错，但不值得花费时间和精力，而且它永远不会完成。"

#: ../../whatsnew/2.0.rst:83
msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person"
" for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"转向使用SourceForge的服务显著提高了开发速度。补丁现在由原提交者以外的人提交、评论、修改，并在不同人员之间来回传递，直到补丁被认为值得检查。错误在一个中央位置被跟踪，并可以分配给特定人员进行修复，我们还可以统计未解决错误的数量来衡量进度。这并不是没有代价的：开发人员现在需要处理更多的电子邮件，关注更多的邮件列表，并且为新环境编写了专门的工具。例如，SourceForge发送的默认补丁和错误通知电子邮件完全无用，所以Ka-"
"Ping Yee编写了一个HTML屏幕抓取器，以发送更有用的信息"

#: ../../whatsnew/2.0.rst:95
msgid ""
"The ease of adding code caused a few initial growing pains, such as code was"
" checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a"
" patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive"
" or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"添加代码的便利性引发了一些初期的成长痛苦，比如代码在准备好之前或未经开发者团队明确同意就被检入。现在形成的审批流程有点类似于Apache集团使用的流程。开发者可以对补丁投票：+1、+0、-0"
" 或 "
"-1；+1和-1表示接受或拒绝，而+0和-0则表示开发者对变更大多持无所谓的态度，但略有正面或负面的倾向。与Apache模型最显著的变化是投票本质上是咨询性的，让拥有终身仁慈独裁者地位的Guido"
" van Rossum了解总体意见。他仍然可以忽略投票结果，并批准或拒绝变更，即使社区不同意他的决定。"

#: ../../whatsnew/2.0.rst:106
msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature,"
" and are continually revised until the community reaches a consensus, either"
" accepting or rejecting the proposal.  Quoting from the introduction to "
":pep:`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"实际产生补丁是添加新功能的最后一步，与之前指定一个号的设计相比，这通常比较容易。对于新功能的讨论往往会变成冗长的邮件列表线程，使讨论难以跟踪，并且没有人能够阅读每一条发给python-"
"dev的帖子。因此，建议了一个相对正式的流程来编写Python增强提案（PEP），该流程借鉴了互联网RFC流程。PEP是描述拟议新功能的草案文件，并不断修改，知道社区达成共识，接受或拒绝该提案。引用自"
" :pep:`1` 的介绍部分，\"PEP目的和指南\"："

#: ../../whatsnew/2.0.rst:120
msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the"
" feature and a rationale for the feature."
msgstr ""
"PEP代表Python增强提案。PEP是一份设计文档，为Python社区提供信息，或描述Python的新功能。PEP应提供该功能的简明技术规范和该功能的理由。"

#: ../../whatsnew/2.0.rst:125
msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"我们打算将PEP作为提出新功能、收集社区对某个问题的反馈以及记录Python设计决策的主要机制。PEP的作者负责在社区内建立公式并记录不同意见。"

#: ../../whatsnew/2.0.rst:130
msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://peps.python.org/.  As of September 2000,"
" there are 25 PEPs, ranging from :pep:`201`, \"Lockstep Iteration\", to PEP "
"225, \"Elementwise/Objectwise Operators\"."
msgstr ""
"请阅读:pep:`1`剩下的部分，以了解PEP编辑流程、风格和格式的详细信息。PEP储存在SourceForge的Python "
"CVS树中，尽管它们不是Python 2.0发行版的一部分，但也可以从 https://peps.python.org/ "
"以HTML格式获取。截至2000年9月，已有25个PEP，从:pep:`201` \"同步迭代\"到PEP225 \"逐元素/逐对象运算符\"。"

#: ../../whatsnew/2.0.rst:141
msgid "Unicode"
msgstr "Unicode"

#: ../../whatsnew/2.0.rst:143
msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Python 2.0 "
"中最大的新增功能是引入了一种新的基础数据类型：Unicode字符串。Unicode使用16位数字表示字符，而不是ASCII使用的8位数字，这意味着可以支持65,536个不同的字符。"

#: ../../whatsnew/2.0.rst:148
msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Unicode支持的最终接口是通过在python-dev邮件列表上无数次激烈的讨论达成的，主要由Marc-André Lemburg基于Fredrik "
"Lundh的Unicode字符串类型实现来完成。详细的接口被写成了文档 :pep:`100` \"Python中Unicode的整合\"。 "
"这篇文章只涵盖关于Unicode接口的最重要的要点。"

#: ../../whatsnew/2.0.rst:155
msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, "
":samp:`\\\\u{HHHH}`, where *HHHH* is a 4-digit hexadecimal number from 0000 "
"to FFFF.  The existing :samp:`\\\\x{HH}` escape sequence can also be used, "
"and octal escapes can be used for characters up to U+01FF, which is "
"represented by ``\\777``."
msgstr ""
"在 Python 源代码中，Unicode 字符串被写成 ``u\"string\"``。 任意的 Unicode 字符可以使用新的转义序列 "
":samp:`\\\\u{HHHH}` 来表示，其中 *HHHH* 是一个从 0000 到 FFFF 的 4 位 十六进制数字。 现有的 "
":samp:`\\\\x{HH}` 转义序列也可以使用。 并且八进制转义序列可以用于表示字符最多到 U+01FF，即 ``\\777``。"

#: ../../whatsnew/2.0.rst:161
msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in"
" a customized version of :file:`site.py`."
msgstr ""
"Unicode字符串和普通字符串一样，是一种不可变的序列类型。它们可以被索引和切片，但不能原地修改。Unicode字符串有一个 ``encode( "
"[encoding] )`` 方法，该方法返回一个以所需编码表示的8位字符串。编码通过字符串命名，如 "
"``'ascii'``、``'utf-8'``、``'iso-8859-1'`` "
"或其他。为实现和注册新的编码定义了一个编解码器API，这些编码随后可在整个Python程序中使用。如果未指定编码，默认编码通常是7位ASCII码，不过可以通过在自定义版本的"
" :file:`site.py` 模块中调用 ``sys.setdefaultencoding(encoding)`` 函数来更改默认编码。"

#: ../../whatsnew/2.0.rst:172
msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"将 8 比特位和 Unicode 的字符串结合使用时将总是会使用默认 ASCII 编码格式强制转换到 Unicode；``'a' + u'bc'`` "
"的结果将为 ``u'abc'``。"

#: ../../whatsnew/2.0.rst:175
msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr "新增了一批内置函数，现有的内置函数也被修改为支持 Unicode："

#: ../../whatsnew/2.0.rst:178
msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr "``unichr(ch)`` 将返回长度为 1 个字符的 Unicode 字符串，其中包含字符 *ch*。"

#: ../../whatsnew/2.0.rst:181
msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr "``ord(u)``，其中 *u* 是长度为 1 个字符的常规或 Unicode 字符串，将以整数形式返回该字符的码位值。"

#: ../../whatsnew/2.0.rst:184
msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"函数 ``unicode(string [, encoding]  [, errors] )`` "
"从8位字符串创建一个Unicode字符串。``encoding`` 是一个指定使用编码的字符串。``errors`` "
"参数指定如何处理当前编码中无效的字符；将 ``'strict'`` 作为值传递会在任何编码错误时引发异常，而 ``'ignore'`` "
"会静默忽略错误，``'replace'`` 则在出现问题时使用U+FFFD，即官方的替换字符。"

#: ../../whatsnew/2.0.rst:192
msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as"
" regular strings.  (It's possible that the process of fixing this missed "
"some built-ins; if you find a built-in function that accepts strings but "
"doesn't accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"``exec`` 语句，以及各种内置函数如 ``eval()``，``getattr()`` 和 ``setattr()`` 也会接受 Unicode "
"字符串和普通字符串。 （修复过程中可能会遗漏一些内置函数；如果你发现一个接受字符串但完全不接受 Unicode 字符串的内置函数，请报告此错误。）"

#: ../../whatsnew/2.0.rst:198
msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character"
" properties.  For example, ``unicodedata.category(u'A')`` returns the "
"2-character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning "
"that it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN',"
" meaning that U+0660 is an Arabic number."
msgstr ""
"一个新的模块 :mod:`unicodedata` 提供了对 Unicode 字符属性的接口。 "
"例如，``unicodedata.category(u'A')`` 返回 2 个字符的字符串 'Lu'，其中 'L' 表示这是一个字母，'u' "
"表示这是一个大写字母。 ``unicodedata.bidirectional(u'\\u0660')`` 返回 'AN'，表示 U+0660 "
"是一个阿拉伯数字。"

#: ../../whatsnew/2.0.rst:204
msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a "
"4-element tuple: ``(encode_func, decode_func, stream_reader, "
"stream_writer)``."
msgstr ""
":mod:`codecs` 模块包含查找现有编码和注册新编码的函数。除非你想实现一个新的编码，否则你最常使用的是 "
"``codecs.lookup(encoding)`` 函数，它返回一个 4 元素的元组: ``(encode_func, decode_func, "
"stream_reader, stream_writer)``。"

#: ../../whatsnew/2.0.rst:209
msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a "
"2-tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* 是一个接受 Unicode 字符串的函数，并返回一个 2 元组 ``(string, length)``。 *string*"
" 是一个包含部分（可能是全部） Unicode 字符串转换为指定编码的 8 位字符串，*length* 告诉你转换了多少 Unicode 字符串。"

#: ../../whatsnew/2.0.rst:214
msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the "
"8-bit string was consumed."
msgstr ""
"*decode_func* 与 *encode_func* 相反，它接受一个 8 位字符串并返回一个 2 元组 ``(ustring, "
"length)``，其中 *ustring* 是转换得到的 Unicode 字符串，*length* 是一个整数，表示消耗了多少 8 位的字符串。"

#: ../../whatsnew/2.0.rst:219
msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`!read`,"
" :meth:`!readline`, and :meth:`!readlines` methods.  These methods will all "
"translate from the given encoding and return Unicode strings."
msgstr ""
"*stream_reader* 是一个支持从流中解码输入的类。 *stream_reader(file_obj)* 返回一个支持 "
":meth:`!read`，:meth:`!readline` 和 :meth:`!readlines` 方法的对象。 这些方法都会从指定编码转换并返回"
" Unicode 字符串。"

#: ../../whatsnew/2.0.rst:224
msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the "
":meth:`!write` and :meth:`!writelines` methods.  These methods expect "
"Unicode strings, translating them to the given encoding on output."
msgstr ""
"*stream_writer* 同样是一个支持将输出编码到流中的类。 *stream_writer(file_obj)* 返回一个支持 "
":meth:`!write` 和 :meth:`!writelines` 方法的对象。 这些方法期望接收 Unicode "
"字符串，并在输出时将使用指定的编码格式来转换它们。"

#: ../../whatsnew/2.0.rst:229
msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr "例如，以下的代码将 Unicode 字符串写入一个 UTF-8 编码的文件::"

#: ../../whatsnew/2.0.rst:243
msgid "The following code would then read UTF-8 input from the file::"
msgstr "以下的代码则可以从文件中读取 UTF-8 输入::"

#: ../../whatsnew/2.0.rst:249
msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"支持 Unicode 的正则表达式可以通过 :mod:`re` 模块使用，该模块有一个新的底层实现称为 SRE，由 Secret Labs AB 的 "
"Fredrik Lundh 编写。"

#: ../../whatsnew/2.0.rst:253
msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only"
" Unicode strings."
msgstr ""
"添加了一个 ``-U`` 命令行选项，使 Python 编译器将所有字符串字面量解释为 Unicode 字符串字面量。 这用于测试和为你的 Python"
" 代码提供未来保障，因为未来某个版本的 Python 可能会取消对 8 位字符串的支持，只提供 Unicode 字符串。"

#: ../../whatsnew/2.0.rst:262
msgid "List Comprehensions"
msgstr "列表推导式"

#: ../../whatsnew/2.0.rst:264
msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"列表是 Python 中的一种主力数据类型，许多程序在某个时候都会处理列表。 "
"对列表的两种常见操作是遍历它们，并筛选出符合某个条件的元素，或对每个元素应用某个函数。 "
"例如，给定一个字符串列表，你可能想要提取出所有包含特定子字符串的字符串，或去掉每行的尾随空白。"

#: ../../whatsnew/2.0.rst:271
msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function"
" needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given substring."
"  You could write the following to do it::"
msgstr ""
"现有的 :func:`map` 和 :func:`filter` 函数可以用于此目的，但它们需要一个函数作为参数之一。 "
"如果有一个现有的内置函数可以直接传递，这是很好的，但如果没有，你必须创建一个小函数来完成所需的工作。 而 Python "
"的作用域规则会使结果变得丑陋，特别是如果这个小函数需要额外的信息。 以上一段中的第一个例子为例，找到列表中所有包含给定子字符串的字符串。 "
"你可以写如下代码来实现::"

#: ../../whatsnew/2.0.rst:286
msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"由于 Python 的作用域规则，将会使用默认参数以使由 :keyword:`lambda` 表达式创建的匿名函数知道正在搜索哪个子字符串。 "
"列表推导能使这个过程更简洁::"

#: ../../whatsnew/2.0.rst:292
msgid "List comprehensions have the form::"
msgstr "列表推导式有如下的格式："

#: ../../whatsnew/2.0.rst:299
msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final "
":keyword:`!if` clause is optional; if present, *expression* is only "
"evaluated and added to the result if *condition* is true."
msgstr ""
":keyword:`!for`...:keyword:`!in` 子句包含要迭代的序列。 这些序列不必具有相同的长度，因为它们 *不是* "
"并行迭代的，而是从左到右依次迭代；这一点将在以下段落中更清楚地解释。 生成列表的元素将是 *表达式* 的连续值。 最后的 :keyword:`!if` "
"子句是可选的；如果存在，只有当 *condition* 为真时，*表达式* 才会被求值并添加到结果中。"

#: ../../whatsnew/2.0.rst:307
msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr "为了使语义更为清晰，列表推导相当于以下 Python 代码::"

#: ../../whatsnew/2.0.rst:319
msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"这意味着当有多个 :keyword:`!for`...:keyword:`!in` 子句时，生成的列表将等于所有序列长的的乘积。 如果你有两个长度为 3"
" 的列表，输出列表将有 9 个元素::"

#: ../../whatsnew/2.0.rst:330
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"为了避免在 Python 的语法中引入歧义，如果 *表达式* 创建的是一个元组，它必须用括号括起来。 "
"下面的第一个列表推导式有语法错误，而第二个则是正确的::"

#: ../../whatsnew/2.0.rst:339
msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"列表推导的概念最初来自函数式编程语言 Haskell (https://www.haskell.org)。 Greg Ewing "
"最有力地提出了将其添加到 Python 中的建议，并编写了最初的列表推导式补丁，然后在 python-dev 邮件列表上进行了看似无休止的讨论，并由 "
"Skip Montanaro 保持更新。"

#: ../../whatsnew/2.0.rst:349
msgid "Augmented Assignment"
msgstr "增强赋值"

#: ../../whatsnew/2.0.rst:351
msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``,"
" ``*=``, and so forth.  For example, the statement ``a += 2`` increments the"
" value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a"
" = a + 2``."
msgstr ""
"增强赋值运算符，另一个长期以来要求添加的功能，已经被加入到 Python 2.0 中。 增强赋值运算符包括 ``+=``，``-=``，``*=`` "
"等。例如，语句 ``a += 2`` 将变量 ``a`` 的值增加 2，等同于稍长一些的 ``a = a + 2``。"

#: ../../whatsnew/2.0.rst:356
msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`!__iadd__`, :meth:`!__isub__`, etc.  For example, the "
"following :class:`!Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""
"支持的完整赋值运算符列表包括 "
"``+=``，``-=``，``*=``，``/=``，``%=``，``**=``，``&=``，``|=``，``^=``，``>>=`` 和 "
"``<<=``。 Python 类可以通过定义名为 :meth:`!__iadd__`、:meth:`!__isub__` 等方法来重载增强赋值运算符。"
" 例如，以下的 :class:`!Number` 类储存一个数字，并支持使用 += 来创建一个递增值的新实例。"

#: ../../whatsnew/2.0.rst:377
msgid ""
"The :meth:`!__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ":meth:`!__iadd__` 特殊方法使用增量值调用，并应返回一个具有适当修改值的新实例；这个返回值将作为左侧变量的新值绑定。"

#: ../../whatsnew/2.0.rst:381
msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"增强赋值运算符最早在 C 编程语言中引入，大多数 C 派生语言，如 :program:`awk`，C++，Java 和 PHP 也支持它们。 "
"增强赋值补丁由 Thomas Wouters 实现。"

#: ../../whatsnew/2.0.rst:390
msgid "String Methods"
msgstr "字符串的方法"

#: ../../whatsnew/2.0.rst:392
msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module,"
" which was usually a front-end for the :mod:`!strop` module written in C.  "
"The addition of Unicode posed a difficulty for the :mod:`!strop` module, "
"because the functions would all need to be rewritten in order to accept "
"either 8-bit or Unicode strings.  For functions such as "
":func:`!string.replace`, which takes 3 string arguments, that means eight "
"possible permutations, and correspondingly complicated code."
msgstr ""
"直到现在，字符串操作功能都在 :mod:`string` 模块中，它通常是用 C 编写的 :mod:`!strop` 模块的前端。 Unicode "
"的添加为 :mod:`!strop` 模块带来困难，因为所有函数都需要重写，以接受 8 位或 Unicode 字符串，对于像 "
":func:`!string.replace` 这样的函数，它需要 3 个字符串参数，这意味着有 8 种可能的排列方式，相应的代码也会变得复杂。"

#: ../../whatsnew/2.0.rst:400
msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr "相反，Python 2.0 将这个问题推给了字符串类型，使字符串操作功能通过 8 位字符串和 Unicode 字符串上的方法来实现。"

#: ../../whatsnew/2.0.rst:411
msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr ""
"有一件事没有改变，即使是值得注意的愚人节玩笑，Python 字符串仍然是不可变的。 因此，字符串方法返回的是新的字符串，而不是修改他们操作的原字符串。"

#: ../../whatsnew/2.0.rst:415
msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr "旧的 :mod:`string` 模块仍然存在以保持向向兼容，但它主要作为新字符串方法的前端。"

#: ../../whatsnew/2.0.rst:418
msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`!startswith` and "
":meth:`!endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``,"
" while ``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""
"在 2.0 之前的版本中没有对应方法的两个方法是 :meth:`!startswith` 和 :meth:`!endswith`，尽管它们在 "
"JPython 中存在了相当长的时间。 ``s.startswith(t)`` 等同于 ``s[:len(t)] == t``，而 "
"``s.endswith(t)`` 等同于 ``s[-len(t):] == t``。"

#: ../../whatsnew/2.0.rst:423
msgid ""
"One other method which deserves special mention is :meth:`!join`.  The "
":meth:`!join` method of a string receives one parameter, a sequence of "
"strings, and is equivalent to the :func:`!string.join` function from the old"
" :mod:`string` module, with the arguments reversed. In other words, "
"``s.join(seq)`` is equivalent to the old ``string.join(seq, s)``."
msgstr ""
"另一个值得特别提及的方法是 :meth:`!join`。 字符串的 :meth:`!join` 方法接收一个参数，即字符串序列，并且等同于来自旧的 "
":mod:`string` 模块的 :func:`!string.join` 函数，但参数顺序相反。 换句话说，``s.join(seq)`` "
"等同于旧的 ``string.join(seq, s)``。"

#: ../../whatsnew/2.0.rst:433
msgid "Garbage Collection of Cycles"
msgstr "循环的垃圾回收"

#: ../../whatsnew/2.0.rst:435
msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Python 的 C 实现使用引用技术来实现垃圾回收。 每个 Python 对象维护一个指向自身的引用数量，并在引用创建或销毁时调整该计数。 "
"一旦引用计数达到零，对象就不再可访问，因为访问对象需要一个引用，然后如果计数为零，就不再存在任何引用。"

#: ../../whatsnew/2.0.rst:442
msgid ""
"Reference counting has some pleasant properties: it's easy to understand and"
" implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory"
" leak.  This happens when there are cycles of references."
msgstr ""
"引用计数有一些令人愉快的特性：它易于理解和实现，结果实现是可移植的，相当快，并且与其他实现自己内存处理方案的库良好互动。引用计数的主要问题是有时它无法识别对象不再可访问，从而导致内存泄露，这发生在存在引用循环时。"

#: ../../whatsnew/2.0.rst:449
msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr "考虑最简单的循环，一个类实例引用自身::"

#: ../../whatsnew/2.0.rst:455
msgid ""
"After the above two lines of code have been executed, the reference count of"
" ``instance`` is 2; one reference is from the variable named ``'instance'``,"
" and the other is from the ``myself`` attribute of the instance."
msgstr ""
"在执行完上述两行代码后，``instance`` 的引用计数是 2；一个引用来自名为 ``'instance'`` 的变量，另一个引用来自该实例的 "
"``myself`` 属性。"

#: ../../whatsnew/2.0.rst:459
msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is"
" no longer accessible through Python code, and it could be deleted.  Several"
" objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"如果下一行代码是 ``del instance``，会发生什么？ ``instance`` 的引用计数会减少 1，所以它的引用计数变为 "
"1；``myself`` 属性中的引用仍然存在。 然而，该实例不能再通过 Python 代码访问，并且它可以被删除。 "
"如果多个对象相互引用，它们可以参与一个循环，导致所有对象都无法被垃圾回收，从而导致内存泄漏。"

#: ../../whatsnew/2.0.rst:466
msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 通过周期性的执行一个循环检测算法来解决这个问题，该算法查找不可访问的循环并删除涉及的对象。 一个新的 :mod:`gc` "
"模块提供了执行垃圾回收、获取调试统计信息和调整回收器参数的功能。"

#: ../../whatsnew/2.0.rst:471
msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able"
" to minimize the overhead with careful tuning.  It's not yet obvious how "
"much performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"运行循环检测算法需要一些时间，因此会带来一些额外的开销，希望在使用 2.0 版本的循环收集经验之后，Python 2.1 "
"可以通过精细调整来尽量减少开销。 目前还不清楚性能损失有多大，因为对此进行精准测试很棘手，而且关键在于程序创建和销毁对象的频率。 "
"如果你不能接受哪怕是微小的速度损失，或者怀疑循环收集存在问题，可以在编译 Python 时禁用循环检测，通过在运行 "
":program:`configure` 脚本时指定 :option:`!--without-cycle-gc` 开关来实现。"

#: ../../whatsnew/2.0.rst:482
msgid ""
"Several people tackled this problem and contributed to a solution.  An early"
" implementation of the cycle detection approach was written by Toby Kelsey."
"  The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev"
" mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"有几个人解决了这个问题并为解决方案做出了贡献。循环检测方法的早期实现由 Toby Kelsey 编写。 当前的算法是在 Eric Tiedemann "
"访问 CNRI 期间提出的，Guido van Rossum 和 Neil Schemenauer 分别编写了两个不同的实现，后来由 Neil "
"将它们整合。 许多其他人也在过程中提出了建议；python-dev 邮件列表 2000 年 3 月的存档包含了大部分相关讨论，尤其是在标题为 "
"“Reference cycle collection for Python” 和 “Finalization again” 的帖子中。"

#: ../../whatsnew/2.0.rst:495
msgid "Other Core Changes"
msgstr "其他核心变化"

#: ../../whatsnew/2.0.rst:497
msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr "Python 的语法和内置函数进行了各种小改动。 虽然这些改动都不是非常深远，但它们都是很方便的改进。"

#: ../../whatsnew/2.0.rst:502
msgid "Minor Language Changes"
msgstr "细微的语言特性修改"

#: ../../whatsnew/2.0.rst:504
msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`!apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`!f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`!apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with"
" the syntax for defining functions::"
msgstr ""
"一种新的语法是的使用元组和/或字典作为参数来调用函数更加方便。在 Python 1.5 及更早版本中，你会使用 :func:`!apply` 内置函数:"
" ``apply(f, args, kw)`` 调用函数 :func:`!f`，附带参数元组 *args* 和关键字参数字典 *kw*。 在 "
"Python 2.0 中，:func:`!apply` 的使用方式是相同的。 但由于 Greg Ewing 的补丁，``f(*args, **kw)``"
" 是一种更简洁明了的方式来实现相同的效果。 这种语法与定义函数的语法是对称的。"

#: ../../whatsnew/2.0.rst:518
msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use the"
" :meth:`!write` method of the file-like object, which lacks the convenience "
"and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""
"``print`` 语句现在可以通过在 ``print`` 后面加上 ``>> file`` 来将其输出定向到文件型对象，这类似于 Unix shell"
" 中的重定向操作符。 以前，你要么必须使用文件对象的 :meth:`!write` 方法，这缺乏 ``print`` 的方便和简单，要么你可以为 "
"``sys.stdout`` 分配一个新值，然后恢复旧值。 为了将输出发送到标准错误，现在可以更简单地写成这样::"

#: ../../whatsnew/2.0.rst:528
msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was"
" submitted by Thomas Wouters."
msgstr ""
"模块现在可以在导入时重命名，使用语法 ``import module as name`` 或 ``from module import name as "
"othername``。这个补丁是由 Thomas Wouters 提交的。"

#: ../../whatsnew/2.0.rst:532
msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"当使用 ``%`` 操作符时有一种新的格式样式可用；'%r' 将插入其参数的 :func:`repr` 表示。 这也是为了对称性，这次是为了与现有的 "
"%s 格式样式对称，后者插入其参数的 :func:`str` 表示。例如，``'%r %s' % ('abc', 'abc')`` 返回一个包含 "
"``'abc' abc`` 的字符串。"

#: ../../whatsnew/2.0.rst:538
msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`!__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""
"以前没有办法实现一个类来重载 Python 的内置 :keyword:`in` 操作符并实现自定义版本。``obj in seq`` 返回真如果 "
"*obj* 存在于序列 *seq* 之中；Python 通过简单地尝试索引来计算这个结果，直到找到 *obj* 或遇到 "
":exc:`IndexError`。 Moshe Zadka 提供了一个补丁，增加了一个 :meth:`!__contains__` 魔术方法，用于为 "
":keyword:`!in` 提供自定义实现。 此外，用 C 编写的新内置对象可以通过序列协议中的新槽定义 :keyword:`!in` 对它们的含义。"

#: ../../whatsnew/2.0.rst:547
msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely"
" and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a"
" useful result instead.  For example, after this code::"
msgstr ""
"早期版本的 Python 使用递归算法来删除对象。深度嵌套的数据结构可能导致解释器填满 C 栈并崩溃。 Christian Tismer "
"重写了删除逻辑来解决这个问题。 相关地，比较递归对象时会导致无线递归并崩溃。Jeremy Hylton 重写了代码，使其不再崩溃，而是产生有用的结果。 "
"例如，在以下代码之后::"

#: ../../whatsnew/2.0.rst:559
msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April"
" 2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`!__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""
"比较 ``a==b`` 将返回真值，因为这两个递归数据结构是同构的。 请参阅 python-dev 邮件列表 2000 年 4 月的存档中的 "
"\"trashcan and PR#7\" 帖子，以了解导致此实现的讨论和一些相关的有用链接。 请注意，现在的比较操作也可以引发异常。 在早期版本的 "
"Python 中，即使用户定义的 :meth:`!__cmp__` 方法遇到错误，譬如 ``cmp(a,b)`` "
"的比较操作也总会产生一个答案，因为结果异常会被静默处理掉。"

#: ../../whatsnew/2.0.rst:571
msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, "
"``sys.platform`` is still ``'win32'`` on Win64 because it seems that for "
"ease of porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin "
"also supports Windows CE; see the Python CE page at "
"https://pythonce.sourceforge.net/ for more information."
msgstr ""
"来自 ActiveState 的 Trent Mick 主要负责将 Python 移植到 Itanium 处理器上的 64 位 Windows 上。 "
"（令人困惑的是，在 Win64 上，``sys.platform`` 类型仍然是 ``'win32'`` 的，因为为了便于移植，MS Visual "
"C++ 在 Itanium 上将代码视为 32 位。） PythonWin 还支持 Windows CE；更多信息请参见 "
"https://pythonce.sourceforge.net/ 的 Python CE 页面。"

#: ../../whatsnew/2.0.rst:577
msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"另一个新的平台是 Darwin/MacOS X；Python 2.0 中提供了初步支持。如果你指定 \"configure --with-dyld "
"--with-suffix=.x\"，动态加载是可行的。 有关更多说明，请参阅 Python 源代码分发中的 README 文件。"

#: ../../whatsnew/2.0.rst:581
msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new "
":exc:`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass "
"of :exc:`NameError`, so any existing code that expects :exc:`NameError` to "
"be raised should still work. ::"
msgstr ""
"已经尝试解决Python的一个问题，即当代码在局部变量赋值之前引用该变量时，会引发经常令人困惑的 :exc:`NameError` "
"异常。例如，以下代码在1.5.2和2.0中都会在 ``print`` 语句上引发异常；在1.5.2中，会引发 :exc:`NameError` "
"异常，而在2.0中，会引发一个新的 :exc:`UnboundLocalError` 异常。:exc:`UnboundLocalError` 是 "
":exc:`NameError` 的子类，因此任何期望引发 :exc:`NameError` 的现有代码应该仍然可以正常工作。"

#: ../../whatsnew/2.0.rst:595
msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"新引入了两个异常 :exc:`TabError` 和 :exc:`IndentationError`。 它们均为 :exc:`SyntaxError` "
"的子类，并会在发现 Python 代码缩进不正确时被引发。"

#: ../../whatsnew/2.0.rst:601
msgid "Changes to Built-in Functions"
msgstr "对于内置函数的修改"

#: ../../whatsnew/2.0.rst:603
msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"添加了一个新的内置函数 ``zip(seq1, seq2, ...)``。:func:`zip` "
"返回一个包含元组的列表，每个元组包含每个参数序列的第i个元素。:func:`zip` 和 ``map(None, seq1, seq2)`` "
"的区别在于，如果序列长度不一致，:func:`map` 会用 ``None`` 填充序列，而 :func:`zip` "
"会将返回的列表截短到最短的参数序列的长度。"

#: ../../whatsnew/2.0.rst:610
msgid ""
"The :func:`int` and :func:`!long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a "
":exc:`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""
":func:`int` 和 :func:`!long` 函数现在在第一个参数是字符串时接受一个可选的“base”参数。``int('123', "
"10)`` 返回 123，而 ``int('123', 16)`` 返回 291。``int(123, 16)`` 会引发一个 "
":exc:`TypeError` 异常，消息为 \"can't convert non-string with explicit base\"。"

#: ../../whatsnew/2.0.rst:616
msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, "
"``sys.version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string "
"such as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"在 :mod:`sys` 模块中添加了一个新变量，用于保存更详细的版本信息。 ``sys.version_info`` 是一个包含五个元素的元组 "
"``(major, minor, micro, level, serial)``。 例如，在假设的 2.0.1beta1 "
"版本中，``sys.version_info`` 将是 ``(2, 0, 1, 'beta', 1)``。 *level* 是一个字符串，如 "
"``\"alpha\"``、``\"beta\"`` 或代表最终发布版本的 ``\"final\"``。"

#: ../../whatsnew/2.0.rst:622
msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`!get` method.  However, if the key "
"is missing, :meth:`!setdefault` both returns the value of *default* as "
":meth:`!get` would do, and also inserts it into the dictionary as the value "
"for *key*.  Thus, the following lines of code::"
msgstr ""
"字典有一个特别的新方法 ``setdefault(key, default)``，其行为与现有的 :meth:`!get` 方法类似。 "
"但是，如果键找不到，:meth:`!setdefault` 既会像 :meth:`!get` 一样返回 *default* 的值，也会将其插入字典作为 "
"*key* 的值。 因此，下面的代码行::"

#: ../../whatsnew/2.0.rst:633
msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "可以简化为单个``return dict.setdefault(key, [])``语句。"

#: ../../whatsnew/2.0.rst:635
msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using "
":func:`sys.getrecursionlimit` and :func:`sys.setrecursionlimit`. The default"
" value is 1000, and a rough maximum value for a given platform can be found "
"by running a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"解释器设置了一个最大递归深度，以便在填满 C 栈并导致核心储存或 GPF 之前捕获失控递归。以前这个限制是在编译 Python 时固定的，但在 2.0 "
"中最大递归深度可以使用 :func:`sys.getrecursionlimit` 和 :func:`sys.setrecursionlimit` "
"读取和修改。 默认值是 1000，可以通过运行一个新脚本 :file:`Misc/find_recursionlimit.py` "
"来找到给定平台的大致的最大值。"

#: ../../whatsnew/2.0.rst:647
msgid "Porting to 2.0"
msgstr "移植 Python 2.0"

#: ../../whatsnew/2.0.rst:649
msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned"
" out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"新的 Python 版本尽力与之前的版本兼容，而且兼容性记录相当不错。 "
"然而，有些变化被认为足够有用，通常是因为他们修正了最终设计中的错误决定，因此有时无法避免打破向后兼容性。 本节列出了 Python 2.0 中可能导致旧"
" Python 代码中断的更改。"

#: ../../whatsnew/2.0.rst:656
msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`!append` and :meth:`!insert`. In earlier versions of Python, if "
"``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` to the "
"list.  In Python 2.0 this causes a :exc:`TypeError` exception to be raised, "
"with the message: 'append requires exactly 1 argument; 2 given'.  The fix is"
" to simply add an extra set of parentheses to pass both values as a tuple:  "
"``L.append( (1,2) )``."
msgstr ""
"可能会导致最多代码中断的更改是对某些方法接受的参数进行了严格限制。一些方法会接受多个参数并将它们视为一个元组，特别是各种列表方法，如 "
":meth:`!append` 和 :meth:`!insert`。在早期版本的Python中，如果 ``L`` 是一个列表，``L.append( "
"1,2 )`` 会将元组 ``(1,2)`` 附加到列表中。在Python 2.0中，这会引发一个 :exc:`TypeError` "
"异常，消息为：“append requires exactly 1 argument; 2 "
"given”。解决方法是简单地添加一组括号，将两个值作为一个元组传递：``L.append( (1,2) )``。"

#: ../../whatsnew/2.0.rst:665
msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :c:func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour;"
" this isn't recommended."
msgstr ""
"这些方法的早期版本更加宽容，因为它们使用了 Python C 接口中的一个旧函数来解析它们的参数；2.0 版本将它们现代化，使用 "
":c:func:`PyArg_ParseTuple`，这是当前的参数解析函数，它提供了更有用的错误消息，并将多参数调用视为错误。如果你必须使用 2.0 "
"但无法修复你的代码，可以编辑 :file:`Objects/listobject.c` 并定义预处理符号 "
"``NO_STRICT_LIST_APPEND`` 以保留旧的行为；但这并不推荐。"

#: ../../whatsnew/2.0.rst:673
msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, ``socket.connect( ('hostname', 25) )`` is the "
"correct form, passing a tuple representing an IP address, but "
"``socket.connect('hostname', 25)`` also works. :meth:`socket.connect_ex "
"<socket.socket.connect_ex>` and :meth:`socket.bind <socket.socket.bind>` are"
" similarly easy-going.  2.0alpha1 tightened these functions up, but because "
"the documentation actually used the erroneous multiple argument form, many "
"people wrote code which would break with the stricter checking.  GvR backed "
"out the changes in the face of public reaction, so for the :mod:`socket` "
"module, the documentation was fixed and the multiple argument form is simply"
" marked as deprecated; it *will* be tightened up again in a future Python "
"version."
msgstr ""
":mod:`socket` 模块中的某些函数仍然是宽容的。 例如，``socket.connect( ('hostname', 25) )`` "
"是正确的形式，传递一个表示 IP 地址的元组，但 ``socket.connect('hostname', 25)`` 也可以工作。 "
":meth:`socket.connect_ex <socket.socket.connect_ex>` 和 :meth:`socket.bind "
"<socket.socket.bind>` 也是类似的宽松方式。 2.0alpha1 "
"会更严格地检查这些函数，但是由于文档实际上使用了错误的多参数形式，许多人编写的代码在更严格的检查下会出错。 面对公众的反应 GvR "
"撤销了这些理性，因此对于 :mod:`socket` 模块，文档已被修正，多参数形式只是被标记为已弃用；在未来的 Python 版本中它 *将会* "
"再次变得严格。"

#: ../../whatsnew/2.0.rst:684
msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to "
"``\\x56``."
msgstr ""
"字符串字面量中的 ``\\x`` 转义现在必须精确地使用2个十六进制数字。之前它会消耗 x 后面的所有十六进制数字，并取结果的最低8位，所以 "
"``\\x123456`` 等同于 ``\\x56``。"

#: ../../whatsnew/2.0.rst:688
msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the"
" error message was just the missing attribute name ``eggs``, and code "
"written to take advantage of this fact will break in 2.0."
msgstr ""
":exc:`AttributeError` 和 :exc:`NameError` 异常现在有了更友好的错误消息，其文本内容类似于 ``'Spam' "
"instance has no attribute 'eggs'`` 或 ``name 'eggs' is not defined``。 "
"之前的错误消息只是缺少的属性名称，如 ``eggs``，因此利用这一事实编写的代码在 2.0 中会中断。"

#: ../../whatsnew/2.0.rst:694
msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`!tell` method of"
" file objects return a long integer instead of a regular integer.  Some code"
" would subtract two file offsets and attempt to use the result to multiply a"
" sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`!seek` method of file objects, and in the formats supported by "
"the ``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""
"在 Python 2.0 中，做了一些工作使得整数和长整数更加可互换。 在 1.5.2 中，为 Solaris 添加了大文件支持，允许读取大于 2 "
"GiB 的文件；这使得文件对象的 :meth:`!tell` 方法返回长整数而不是常规整数。 "
"一些代码会减去两个文件偏移量，并尝试使用结果来乘以一个序列或切片一个字符串，但这会引发 :exc:`TypeError`。 在 2.0 "
"中，长整数可以用于乘以或切片一个序列，并且会按直觉行为；例如，``3L * 'abc'``' 生成 "
"'abcabcabc'，``(0,1,2,3)[2L:4L]`` 生成 (2,3)。 长整数也可以在以前只接受整数的各种上下文中使用，例如文件对象的 "
":meth:`!seek` 方法，以及 ``%`` 操作符支持的格式（如 ``%d``、``%i``、``%x`` 等）。 例如，``\"%d\" % "
"2L**64`` 将生成字符串 ``18446744073709551616``。"

#: ../../whatsnew/2.0.rst:708
msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code"
" which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now "
"lose the final digit."
msgstr ""
"最微妙的长整数变化是，长整数的 :func:`str` 表示不再有尾随的 'L' 字符，尽管 :func:`repr` "
"表示仍然包含它。许多人在打印长整数时不希望看到 'L' 字符，因为他们不得不专门去掉这个字符。在2.0中，这不再是一个问题，但那些使用 "
"``str(longval)[:-1]`` 并假设存在 'L' 的代码，现在将丢失最后一个数字。"

#: ../../whatsnew/2.0.rst:716
msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision"
" than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's "
":func:`!sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is"
" that :func:`repr` may occasionally show more decimal places than  "
":func:`str`, for certain numbers.  For example, the number 8.1 can't be "
"represented exactly in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``,"
" while str(8.1) is ``'8.1'``."
msgstr ""
"对浮点数执行 :func:`repr` 现在会使用不同的格式化精度，而不是 :func:`str`。 :func:`repr` 使用 ``%.17g``"
" 格式字符串来调用 C 的 :func:`!sprintf`，而 :func:`str` 仍然使用 "
"``%.12g``。其效果是，对于某些数字，:func:`repr` 可能比 :func:`str` 显示更多的小数位。 例如，数字 8.1 "
"无法精确地用二进制表示，所以 ``repr(8.1)`` 是 ``'8.0999999999999996'``，而 str(8.1) 是 "
"``'8.1'``。"

#: ../../whatsnew/2.0.rst:724
msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`!exceptions` module containing the "
"standard exceptions was translated from Python to a built-in C module, "
"written by Barry Warsaw and Fredrik Lundh."
msgstr ""
"``-X`` 命令行选项已被移除，该选项会将所有标准异常转换为字符串而不是类；现在标准异常将始终是类。包含标准异常的 "
":mod:`!exceptions` 模块已从Python翻译为内置C模块，由Barry Warsaw和Fredrik Lundh编写。"

#: ../../whatsnew/2.0.rst:740
msgid "Extending/Embedding Changes"
msgstr "扩展/嵌入更改"

#: ../../whatsnew/2.0.rst:742
msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"有些更改是在底层进行的，仅对编写 C 扩展模块或在更大的应用中嵌入 Python 解释器的人有价值。 如果你不处理 Python 的 C "
"API，可以安全地跳过这一节。"

#: ../../whatsnew/2.0.rst:747
msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an"
" exception and the import will fail."
msgstr ""
" Python C API 的版本号已增加，因此为 1.5.2 编译的 C 扩展必须重新编译才能与 2.0 一起工作。 在 Windows 上，由于 "
"Windows DLL 的工作方式，Python 2.0 无法导入为 Python 1.5.x 构建的第三方扩展，因此 Python "
"会引发异常并造成导入失败。"

#: ../../whatsnew/2.0.rst:753
msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that"
" hooks have been added so that ExtensionClasses are now supported by "
":func:`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can"
" use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"使用 Jim Fulton 的 ExtensionClass 模块的用户将很高兴地发现，已经添加了钩子以支持 "
"ExtensionClasses，因此现在支持 :func:`isinstance` 和 :func:`issubclass`。 "
"这意味着你不再需要记住编写类似 ``if type(obj) == myExtensionClass`` 这样的代码，而可以使用更自然的 ``if "
"isinstance(obj, myExtensionClass)``。"

#: ../../whatsnew/2.0.rst:759
msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific"
" code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
":file:`Python/importdl.c` 文件，它充满了用于支持在许多不同平台上动态加载的 #ifdef，已被 Greg Stein "
"清理和重组。现在 :file:`importdl.c` 非常小，平台特定的代码已被移入一组特定的 "
":file:`Python/dynload_\\*.c` 文件中。 另一个清理工作是：Include/ 目录中有许多包含各种可移植性修改的 "
":file:`my\\*.h` 文件；它们已被合并到一个文件中，即 :file:`Include/pyport.h`。"

#: ../../whatsnew/2.0.rst:767
msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :c:func:`malloc`.  For documentation, read the comments in "
":file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""
"Vladimir Marangozov 期待已久的 malloc 重组已经完成，使得Python解释器可以轻松使用自定义分配器，而不是C的标准 "
":c:func:`malloc`。 有关文档，请阅读 :file:`Include/pymem.h` 和 "
":file:`Include/objimpl.h` 中的注释。 有关界面敲定期间的详细讨论，请参阅 python.org 上的 'patches' 和 "
"'python-dev' 列表的网络存档。"

#: ../../whatsnew/2.0.rst:774
msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"最新版本的 MacOS GUSI 开发环境支持 POSIX 线程。 因此，现在 Python 的 POSIX 线程支持在 Macintosh "
"上也可以使用。 还贡献了使用用户空间 GNU ``pth`` 库的线程支持。"

#: ../../whatsnew/2.0.rst:779
msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case"
" when there's no contention, they use simpler functions which are an order "
"of magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as "
"slow as an unthreaded version; with the 2.0 changes, the difference is only "
"10%.  These improvements were contributed by Yakov Markovitch."
msgstr ""
"Windows 上的线程支持也得到了增强。 Windows "
"支持的线程锁在发生争用时才使用内核对象；在常见的没有争用的情况下，他们使用简单得多的函数，这些函数快一个数量级。Python 1.5.2 在 NT "
"上的线程版本比无线程版本慢两倍；有了 2.0 的改进，差异仅为 10%。 这些改进由 Yakov Markovitch 提供。"

#: ../../whatsnew/2.0.rst:786
msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now"
" requires an ANSI C compiler, and can no longer be done using a compiler "
"that only supports K&R C."
msgstr ""
"Python 2.0 的源代码目前只用 ANSI C 原型，所以现在编译 Python 需要一个 ANSI C 的编译器，而不能通过仅使用支持 K&R "
"C 的编译器完成。"

#: ../../whatsnew/2.0.rst:790
msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum"
" size of literal lists and dictionaries in Python source; occasionally "
"people who are generating Python code would run into this limit.  A patch by"
" Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"之前，Python 虚拟机在其字节码中使用 16 位数字，限制了源文件的大小。 特别是，这影响了 Python "
"源代码中字面量列表和字典的最大大小；偶尔会有人在生成 Python 代码时遇到这个限制。 Charles G. Waldman 的补丁将这个限制从 "
"``2**16`` 提高到 ``2**32``。"

#: ../../whatsnew/2.0.rst:796
msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: "
":c:func:`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant`, and "
":c:func:`PyModule_AddStringConstant`.  Each of these functions takes a "
"module object, a null-terminated C string containing the name to be added, "
"and a third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""
"添加了三个新的便捷函数，旨在模块初始化时将常量添加到模块的字典中: "
":c:func:`PyModule_AddObject`、:c:func:`PyModule_AddIntConstant` 和 "
":c:func:`PyModule_AddStringConstant`。 "
"每个函数都接收一个模块对象、一个以空字符结尾的包含要添加的名称的C字符串，以及一个第三个参数用于指定要赋值的值。 第三个参数分别是一个 Python "
"对象、一个 C 长整型或一个 C 字符串。"

#: ../../whatsnew/2.0.rst:804
msgid ""
"A wrapper API was added for Unix-style signal handlers. "
":c:func:`PyOS_getsig` gets a signal handler and :c:func:`PyOS_setsig` will "
"set a new handler."
msgstr ""
"为 Unix 风格的信号处理程序添加了一个包装API。 :c:func:`PyOS_getsig` "
"获取信号处理程序，:c:func:`PyOS_setsig` 设置新的处理程序。"

#: ../../whatsnew/2.0.rst:811
msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils：使模块易于安装"

#: ../../whatsnew/2.0.rst:813
msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an"
" arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation"
" something of  a chore."
msgstr ""
"在 Python 2.0 之前，安装模块是一件繁琐的事情 —— 没有办法自动确定 Python 的安装位置，或者用于扩展模块的编译器选项。 "
"软件作者不得不经历一套繁琐的程序来编辑 Makefile 和配置文件，这些只在 Unix 上真正有效，而 Windows 和 Mac OS 不受支持。 "
"Python 用户面对不同扩展包之间大相径庭的安装说明，这使得管理 Python 成了一件麻烦事。"

#: ../../whatsnew/2.0.rst:821
msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the"
" Distutils, a system to make package installation much easier.  They form "
"the :mod:`distutils` package, a new part of Python's standard library. In "
"the best case, installing a Python module from source will require the same "
"steps: first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default"
" directories, and more."
msgstr ""

#: ../../whatsnew/2.0.rst:833
msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script."
"  For the simple case, when the software contains only .py files, a minimal "
":file:`setup.py` can be just a few lines long::"
msgstr ""
"为了使用 Distutils，你需要编写一个 :file:`setup.py` 脚本。 在简单场景下，当软件仅包含 .py 文件时，最小化的 "
":file:`setup.py` 可以只有几行代码::"

#: ../../whatsnew/2.0.rst:841
msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr "如果软件是由几个包组成的 :file:`setup.py` 文件也不会太过复杂::"

#: ../../whatsnew/2.0.rst:848
msgid ""
"A C extension can be the most complicated case; here's an example taken from"
" the PyXML package::"
msgstr "最复杂的情况可能是 C 扩展；下面是一个来自 PyXML 包的示例::"

#: ../../whatsnew/2.0.rst:864
msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils 还可以负责创建源代码和二进制分发包。运行 ``python setup.py sdist`` 的 \"sdist\" "
"命令构建一个源代码分发包，如 :file:`foo-1.0.tar.gz`。添加新命令并不困难，已经有 \"bdist_rpm\" 和 "
"\"bdist_wininst\" 命令，分别用于创建软件的 RPM 分发包和 Windows 安装程序。创建其他分发格式的命令，如 Debian 包和"
" Solaris :file:`.pkg` 文件，也在开发的不同阶段。"

#: ../../whatsnew/2.0.rst:873
msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr "所有这些都记录在一个新手册中，*Distributing Python Modules*，它加入了Python文档的基本集合中。"

#: ../../whatsnew/2.0.rst:880
msgid "XML Modules"
msgstr "XML 模块"

#: ../../whatsnew/2.0.rst:882
msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`!xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`!xmllib`, and the DOM (Document Object Model) provides"
" a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we"
" will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is"
" also working on improved documentation."
msgstr ""
"Python 1.5.2 包含了一个简单的 XML 解析器，以 :mod:`!xmllib` 模块的形式提供，由 Sjoerd Mullender "
"贡献。自1.5.2发布以来，处理 XML 的两种不同接口已经变得常见：SAX2（Simple API for XML "
"的第2版）提供了一个事件驱动的接口，与 :mod:`!xmllib` 有一些相似之处；而 DOM（Document Object "
"Model）提供了一个基于树的接口，将 XML 文档转换为一个可遍历和修改的节点树。Python 2.0 包含了 SAX2 接口和简化的 DOM "
"接口，作为 :mod:`xml` 包的一部分。下面是这些新接口的简要概述；完整的详细信息请参阅 Python 文档或源代码。Python XML SIG"
" 也在致力于改进文档。"

#: ../../whatsnew/2.0.rst:896
msgid "SAX2 Support"
msgstr "SAX2 支持"

#: ../../whatsnew/2.0.rst:898
msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must"
" write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the "
":meth:`~xml.sax.handler.ContentHandler.startElement` and "
":meth:`~xml.sax.handler.ContentHandler.endElement` methods are called for "
"every starting and end tag encountered by the parser, the "
":meth:`~xml.sax.handler.ContentHandler.characters` method is called for "
"every chunk of character data, and so forth."
msgstr ""
"SAX 定义了一个事件驱动的接口来解析 XML。要使用 SAX，你必须编写一个 SAX 处理器类。处理器类继承自 SAX "
"提供的各种类，并覆盖各种方法，这些方法会在 XML "
"解析器遇到相应事件时被调用。例如，:meth:`~xml.sax.handler.ContentHandler.startElement` 和 "
":meth:`~xml.sax.handler.ContentHandler.endElement` "
"方法会在解析器遇到每个开始和结束标签时被调用，:meth:`~xml.sax.handler.ContentHandler.characters` "
"方法会在解析器遇到每个字符数据块时被调用，等等。"

#: ../../whatsnew/2.0.rst:906
msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"事件驱动方法的优点是整个文档不必同时驻留在内存中，这在处理非常大的文档时尤其重要。然而，如果你试图以某种复杂的方式修改文档结构，编写 SAX "
"处理程序类可能会变得非常复杂。"

#: ../../whatsnew/2.0.rst:912
msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file "
":file:`hamlet.xml` using it::"
msgstr "例如，这个小示例程序定义了一个处理器，它为每个开始和结束标签打印一条消息，然后使用它来解析文件 :file:`hamlet.xml`::"

#: ../../whatsnew/2.0.rst:935
msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"https://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""
"欲了解更多信息，请查阅 Python 文档，或 https://pyxml.sourceforge.net/topics/howto/xml-"
"howto.html 上的 XML HOWTO。"

#: ../../whatsnew/2.0.rst:940
msgid "DOM Support"
msgstr "DOM 支持"

#: ../../whatsnew/2.0.rst:942
msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`!Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`!Element` instance. "
"This :class:`!Element` has children nodes representing character data and "
"any sub-elements, which may have further children of their own, and so "
"forth.  Using the DOM you can traverse the resulting tree any way you like, "
"access element and attribute values, insert and delete nodes, and convert "
"the tree back into XML."
msgstr ""
"文档对象模型是一种基于树的表示法，用于表示 XML 文档。一个顶级 :class:`!Document` 实例是树的根节点，并且有一个子节点，它是顶级 "
":class:`!Element`实例。这个 :class:`!Element` "
"具有表示字符数据和任何子元素的子节点，这些子节点可以有进一步的子节点，依此类推。使用 "
"DOM，你可以以任何方式遍历生成的树，访问元素和属性值，插入和删除节点，并将树转换回 XML。"

#: ../../whatsnew/2.0.rst:950
msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM 在修改 XML 文档方面非常有用，因为你可以创建一个 DOM 树，通过添加新节点或重新排列子树来修改它，然后生成一个新的 XML "
"文档作为输出。你还可以手动构建一个 DOM 树并将其转换为 XML，这比简单地将``<tag1>``...\\``</tag1>``写入文件更灵活。"

#: ../../whatsnew/2.0.rst:956
msgid ""
"The DOM implementation included with Python lives in the "
":mod:`xml.dom.minidom` module.  It's a lightweight implementation of the "
"Level 1 DOM with support for XML namespaces.  The  :func:`!parse` and "
":func:`!parseString` convenience functions are provided for generating a DOM"
" tree::"
msgstr ""
"Python 附带的 DOM 实现在 :mod:`xml.dom.minidom` 模块中。它是一个轻量级的 Level 1 DOM 实现，支持 XML"
" 命名空间。提供了 :func:`!parse` 和 :func:`!parseString` 便捷函数用于生成 DOM 树::"

#: ../../whatsnew/2.0.rst:964
msgid ""
"``doc`` is a :class:`!Document` instance.  :class:`!Document`, like all the "
"other DOM classes such as :class:`!Element` and :class:`Text`, is a subclass"
" of the :class:`!Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`!toxml` which returns a "
"string containing the XML representation of the node and its children.  Each"
" class also has special methods of its own; for example, :class:`!Element` "
"and :class:`!Document` instances have a method to find all child elements "
"with a given tag name. Continuing from the previous 2-line example::"
msgstr ""
"``doc`` 是一个 :class:`!Document` 实例。:class:`!Document`，和其他所有 DOM "
"类如:class:`!Element` 和 :class:`Text`一样，都是:class:`!Node` 基类的子类。因此，DOM "
"树中的所有节点都支持某些通用方法，例如 :meth:`!toxml` 方法，该方法返回一个包含节点及其子节点的 XML "
"表示的字符串。每个类也有自己的特定方法；例如，:class:`!Element` 和 :class:`!Document` "
"实例有一个方法可以找到具有给定标签名的所有子元素。继续前面 2 行代码的例子："

#: ../../whatsnew/2.0.rst:977
msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "对于 *Hamlet* XML 文件，上面几行代码输出::"

#: ../../whatsnew/2.0.rst:982
msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr ""
"文件的根元素可以通过 ``doc.documentElement`` 访问，并且可以通过删除、添加或一处节点来听松修改节点来轻松修改其子元素::"

#: ../../whatsnew/2.0.rst:997
msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`!Node` classes and their various methods."
msgstr "再次，我建议你查阅 Python 文档，以获取不同 :class:`!Node` 类及各种方法的完整列表。"

#: ../../whatsnew/2.0.rst:1002
msgid "Relationship to PyXML"
msgstr "与 PyXML 的关系"

#: ../../whatsnew/2.0.rst:1004
msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"XML 特别兴趣小组已经致力于与 XML 相关的 Python 代码有一段时间了。 其代码分发包称为 PyXML，可以从 SIG 的网页 "
"https://www.python.org/community/sigs/current/xml-sig 获取。 PyXML 分发包也使用了 "
"``xml`` 作为包名。 如果你编写了使用 PyXML 的程序，可能会担心它与 Python 2.0 的 :mod:`xml` 包的兼容性。"

#: ../../whatsnew/2.0.rst:1010
msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be"
" a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"答案是 Python 2.0 的 :mod:`xml` 包与 PyXML 不兼容，但可以通过安装最新版本的 PyXML 来使其兼容。 "
"许多应用程序可以依赖 Python 2.0 中包含的 XML 支持，但更复杂的应用程序需要安装完整的 PyXML 包。 安装后，版本为 0.6.0 "
"或更高的 PyXML 将替换随 Python 一起发布的 :mod:`xml` 包，并且将是标准包的严格超集，添加许多额外的功能。 PyXML "
"中的一些附加功能包括："

#: ../../whatsnew/2.0.rst:1019
msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM，一个来自 FourThought, Inc. 的完整 DOM 实现。"

#: ../../whatsnew/2.0.rst:1021
msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "xmlproc 验证解析器，由 Lars Marius Garshol 编写。"

#: ../../whatsnew/2.0.rst:1023
msgid ""
"The :mod:`!sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr ":mod:`!sgmlop` 解析器加速模块，由 Fredrik Lundh 编写。"

#: ../../whatsnew/2.0.rst:1029
msgid "Module changes"
msgstr "模块更改"

#: ../../whatsnew/2.0.rst:1031
msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, "
":mod:`ConfigParser <configparser>`, :mod:`cgi`, :mod:`calendar`, "
":mod:`posix`, :mod:`readline`, :mod:`!xmllib`, :mod:`aifc`, :mod:`chunk`, "
":mod:`wave`, :mod:`random`, :mod:`shelve`, and :mod:`nntplib`.  Consult the "
"CVS logs for the exact patch-by-patch details."
msgstr ""

#: ../../whatsnew/2.0.rst:1037
msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit "
":file:`Modules/Setup` to include SSL support, which adds an additional "
"function to the :mod:`socket` module: ``socket.ssl(socket, keyfile, "
"certfile)``, which takes a socket object and returns an SSL socket.  The "
":mod:`httplib <http>` and :mod:`urllib` modules were also changed to support"
" ``https://`` URLs, though no one has implemented FTP or SMTP over SSL."
msgstr ""
"Brian Gallew 贡献了 :mod:`socket` 模块的 OpenSSL 支持。OpenSSL "
"是一个安全套接字层实现，用于加密通过套接字发送的数据。在编译 Python 时，你可以编辑 :file:`Modules/Setup` 文件以包含 "
"SSL 支持，这会为 :mod:`socket` 模块添加一个额外的函数：``socket.ssl(socket, keyfile, "
"certfile)``，它接收一个套接字对象并返回一个 SSL 套接字。:mod:`httplib <http>`  和 :mod:`urllib` "
"模块也进行了更改，以支持``https://`` 的URL，但目前还没有人实现通过 SSL 的 FTP 或 SMTP。"

#: ../../whatsnew/2.0.rst:1046
msgid ""
"The :mod:`httplib <http>` module has been rewritten by Greg Stein to support"
" HTTP/1.1."
msgstr ":mod:`httplib <http>` 模块已由 Greg Stein 重写以支持 HTTP/1.1。"

#: ../../whatsnew/2.0.rst:1048
msgid ""
"Backward compatibility with the 1.5 version of :mod:`!httplib` is provided, "
"though using HTTP/1.1 features such as pipelining will require rewriting "
"code to use a different set of interfaces."
msgstr ""
"对 1.5 版本的 :mod:`!httplib` 提供了向下兼容性，尽管使用 HTTP/1.1 特性如流水线将需要重写代码以使用不同的一组接口。"

#: ../../whatsnew/2.0.rst:1052
msgid ""
"The :mod:`!Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and"
" support for the older 7.x versions has been dropped.  The Tkinter module "
"now supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""
":mod:`!Tkinter` 模块现在支持 Tcl/Tk 版本 8.1、8.2 或 8.3，并且不再支持旧的 7.x 版本。Tkinter "
"模块现在支持在 Tk 小部件中显示 Unicode 字符串。此外，Fredrik Lundh 贡献了一项优化，使得诸如 ``create_line`` "
"和 ``create_polygon`` 等操作速度更快，尤其是在使用大量坐标时。"

#: ../../whatsnew/2.0.rst:1058
msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with"
" operating systems that only have BSD curses, but there don't seem to be any"
" currently maintained OSes that fall into this category."
msgstr ""
":mod:`curses` 模块在 Oliver Andrich 增强版本的基础上得到了极大的扩展，提供了许多来自 ncurses 和 SYSV "
"curses 的附加功能，如颜色、替代字符集支持、手写板和鼠标支持等。 这意味着该模块不再兼容仅有 BSD curses "
"的操作系统，但目前似乎没有任何属于这一类别的操作系统正在维护中。"

#: ../../whatsnew/2.0.rst:1065
msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the "
":mod:`re` module has been changed.  SRE, a new regular expression engine "
"written by Fredrik Lundh and partially funded by Hewlett Packard, supports "
"matching against both 8-bit strings and Unicode strings."
msgstr ""
"如前面讨论的 Python 2.0 对 Unicode 的支持所提到的，:mod:`re` 模块提供的正则表达式的底层实现已经更改。 "
"SRE，一个新的正则表达式引擎，由 Ferdrik Lundh 编写，部分由惠普资助，支持匹配 8 位字符串和 Unicode 字符串。"

#: ../../whatsnew/2.0.rst:1075
msgid "New modules"
msgstr "新增模块"

#: ../../whatsnew/2.0.rst:1077
msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr "添加了许多新模块，我们将简单列出它们并附上简要概述；有关特定模块的详细信息，请查阅2.0文档。"

#: ../../whatsnew/2.0.rst:1081
msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should"
" be changed to  use the :mod:`atexit` module instead, importing "
":mod:`atexit` and calling :func:`atexit.register` with  the function to be "
"called on exit. (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit` 模块用于注册在 Python 解释器退出之前调用的函数。当前直接设置 ``sys.exitfunc`` 的代码应改为使用 "
":mod:`atexit` 模块，导入 :mod:`atexit` 并使用 :func:`atexit.register` 调用要在退出时调用的函数。 "
"（由 Skip Montanaro 贡献。）"

#: ../../whatsnew/2.0.rst:1087
msgid ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`: 作为新的Unicode支持的一部分添加。"

#: ../../whatsnew/2.0.rst:1090
msgid ""
":mod:`filecmp`: Supersedes the old :mod:`!cmp`, :mod:`!cmpcache` and "
":mod:`!dircmp` modules, which have now become deprecated. (Contributed by "
"Gordon MacMillan and Moshe Zadka.)"
msgstr ""
":mod:`filecmp` 模块取代了旧的 :mod:`!cmp`, :mod:`!cmpcache`, 和 :mod:`!dircmp` "
"模块，这些模块现在已经被废弃。（由 Gordon MacMillan 和 Moshe Zadka 贡献。）"

#: ../../whatsnew/2.0.rst:1094
msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to"
" the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`: 这个模块通过提供 GNU gettext 消息目录库的接口，为 Python "
"程序提供国际化（I18N）和本地化（L10N）支持。 （由 Barry Warsaw 整合，来自 Martin von Löwis, Peter "
"Funk 和 James Henstridge 的独立贡献。）"

#: ../../whatsnew/2.0.rst:1099
msgid ""
":mod:`!linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a"
" twin to the existing :mod:`!sunaudiodev` module. (Contributed by Peter "
"Bosch, with fixes by Jeremy Hylton.)"
msgstr ""
":mod:`!linuxaudiodev`: 支持 Linux 上的 :file:`/dev/audio` 设备，与现有的 "
":mod:`!sunaudiodev` 模块相对应。（由 Peter Bosch 贡献，Jeremy Hylton 提供修复。）"

#: ../../whatsnew/2.0.rst:1103
msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by "
"A.M. Kuchling.)"
msgstr ""
":mod:`mmap`: 提供对内存映射文件的接口，支持 Windows 和 "
"Unix。文件的内容可以直接映射到内存中，此时它表现得像一个可变字符串，因此可以读取和修改其内容。它们甚至可以传递给期望普通字符串的函数，例如 "
":mod:`re` 模块。（由 Sam Rushing 贡献，并由 A.M. Kuchling 提供一些扩展。）"

#: ../../whatsnew/2.0.rst:1109
msgid ""
":mod:`!pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ":mod:`!pyexpat`: Expat XML解析器的接口。 （由 Paul Prescod 贡献。）"

#: ../../whatsnew/2.0.rst:1112
msgid ""
":mod:`robotparser <urllib.robotparser>`: Parse a :file:`robots.txt` file, "
"which is used for writing web spiders that politely avoid certain areas of a"
" web site.  The parser accepts the contents of a :file:`robots.txt` file, "
"builds a set of rules from it, and can then answer questions about the "
"fetchability of a given URL.  (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`robotparser <urllib.robotparser>`: 解析 :file:`robots.txt` "
"文件，这个文件用于编写礼貌地避开网站某些区域的网络爬虫。 解析器接受 :file:`robots.txt` "
"文件的内容，从中构建一组规则，然后可以回答有关给定 URL 是否可以被抓取的问题。 （由 Skip Montanaro 贡献。）"

#: ../../whatsnew/2.0.rst:1118
msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ":mod:`tabnanny`: 一个模块/脚本，用于检查 Python 源代码中不歧义的缩进。 （由 Tim Peters 贡献。）"

#: ../../whatsnew/2.0.rst:1121
msgid ""
":mod:`!UserString`: A base class useful for deriving objects that behave "
"like strings."
msgstr ":mod:`!UserString`: 一个基类，用于派生行为类似于字符串的对象。"

#: ../../whatsnew/2.0.rst:1124
msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric"
" S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as "
":file:`Tools/idle/BrowserControl.py`, and adapted for the standard library "
"by Fred.)"
msgstr ""
":mod:`webbrowser` 模块提供了一种平台独立的方式来在特定 URL 上启动 web "
"浏览器。对于每个平台，模块会按特定顺序尝试各种浏览器。用户可以通过设置 *BROWSER* 环境变量来更改启动的浏览器。（最初的灵感来自 Eric S."
" Raymond 对 :mod:`urllib` 的补丁，该补丁增加了类似的功能，但最终的模块来自 Fred Drake 最初实现的代码 "
":file:`Tools/idle/BrowserControl.py`，并由 Fred 适配到标准库中。）"

#: ../../whatsnew/2.0.rst:1133
msgid ""
":mod:`_winreg <winreg>`: An interface to the Windows registry.  "
":mod:`!_winreg` is an adaptation of functions that have been part of "
"PythonWin since 1995, but has now been added to the core  distribution, and "
"enhanced to support Unicode. :mod:`!_winreg` was written by Bill Tutt and "
"Mark Hammond."
msgstr ""
":mod:`_winreg <winreg>` 模块：提供了一个用于访问 Windows 注册表的接口。:mod:`!_winreg` 是对自 1995"
" 年以来一直是 PythonWin 一部分的函数的改编，现在已被添加到核心分发版中，并增强了对 Unicode 的支持。 :mod:`!_winreg`"
" 由 Bill Tutt 和 Mark Hammond 编写。"

#: ../../whatsnew/2.0.rst:1138
msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These"
" are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile` 模块：用于读取和写入 ZIP 格式的归档文件。 这些归档文件是由 DOS/Windows 上的 "
":program:`PKZIP` 或 Unix 上的 :program:`zip` 生成的，不要与 :program:`gzip` 格式文件（由  "
":mod:`gzip` 支持）混淆。 （由 James C. Ahlstrom 贡献。）"

#: ../../whatsnew/2.0.rst:1143
msgid ""
":mod:`!imputil`: A module that provides a simpler way for writing customized"
" import hooks, in comparison to the existing :mod:`!ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""
":mod:`!imputil`模块：提供了一种比现有的 :mod:`!ihooks` 模块更简单的方式来编写自定义导入钩子。（由 Greg Stein "
"实现，并在实现过程中在 python-dev 进行了大量讨论。）"

#: ../../whatsnew/2.0.rst:1151
msgid "IDLE Improvements"
msgstr "IDLE 改进"

#: ../../whatsnew/2.0.rst:1153
msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE 是官方的 Python 跨平台 IDE，使用 Tkinter 编写。 Python 2.0 包括了 IDLE "
"0.6，它增加了许多新特性和改进。 部分新内容列表："

#: ../../whatsnew/2.0.rst:1157
msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr "界面改进和优化，特别是在语法高亮和自动缩进方面。"

#: ../../whatsnew/2.0.rst:1160
msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr "类浏览器现在将显示更多信息，例如一个模块中最高层级的函数。"

#: ../../whatsnew/2.0.rst:1163
msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr "制表符宽度现在是一个用户可设置的选项。在打开现有的 Python 文件时，IDLE 会自动检测缩进约定并进行适应。"

#: ../../whatsnew/2.0.rst:1166
msgid ""
"There is now support for calling browsers on various platforms, used to open"
" the Python documentation in a browser."
msgstr "现在支持在各种平台上调用浏览器，用于在浏览器中打开 Python 文档。"

#: ../../whatsnew/2.0.rst:1169
msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python"
" interpreter."
msgstr "IDLE 现在有一个命令行，它与原版 Python 解释器大致相同。"

#: ../../whatsnew/2.0.rst:1172
msgid "Call tips were added in many places."
msgstr "在许多地方添加了调用提示。"

#: ../../whatsnew/2.0.rst:1174
msgid "IDLE can now be installed as a package."
msgstr "IDLE 现在可以作为一个包被安装。"

#: ../../whatsnew/2.0.rst:1176
msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "在编辑器窗口中，目前在底部位置增加了一个行/列显示栏。"

#: ../../whatsnew/2.0.rst:1178
msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module "
"(:kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr ""
"三个新的键盘快捷键：检查模块 (:kbd:`Alt-F5`)，导入模块 (:kbd:`F5`) 和执行脚本 (:kbd:`Ctrl-F5`)。"

#: ../../whatsnew/2.0.rst:1185
msgid "Deleted and Deprecated Modules"
msgstr "删除和弃用的模块"

#: ../../whatsnew/2.0.rst:1187
msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`!stdwin` module is "
"gone; it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""
"有几个模块因为已经过时，或者因为现在有更好的方法来实现相同的功能而被删除。 :mod:`!stdwin` "
"模块已被移除；它是一个不再开发的跨平台窗口工具包。"

#: ../../whatsnew/2.0.rst:1191
msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: "
":mod:`!cmp`, :mod:`!cmpcache`, :mod:`!dircmp`, :mod:`!dump`,  :mod:`!find`, "
":mod:`!grep`, :mod:`!packmail`,  :mod:`!poly`, :mod:`!util`, "
":mod:`!whatsound`, :mod:`!zmod`.  If you have code which relies on a module"
"  that's been moved to :file:`lib-old`, you can simply add that directory to"
" ``sys.path``   to get them back, but you're encouraged to update any code "
"that uses these modules."
msgstr ""
"许多模块已经移动到了 :file:`lib-old` 子目录: "
":mod:`!cmp`，:mod:`!cmpcache`，:mod:`!dircmp`，:mod:`!dump`，:mod:`!find`，:mod:`!grep`，:mod:`!packmail`，:mod:`!poly`，:mod:`!util`，:mod:`!whatsound`，:mod:`!zmod`。"
" 如果你的代码依赖于已移动到 :file:`lib-old` 的模块，你可以简单地将该目录添加到 ``sys.path`` "
"中来找回它们，但建议你更新任何使用这些模块的代码。"

#: ../../whatsnew/2.0.rst:1200
msgid "Acknowledgements"
msgstr "致谢"

#: ../../whatsnew/2.0.rst:1202
msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"作者感谢以下人士对本文的各种草稿提出建议： David Bolen, Mark Hammond, Gregg Hauser, Jeremy "
"Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir"
" Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer, and Russ "
"Schmidt."
