# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# Menghua Xiao <arieshout@gmail.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# nick <2330458484@qq.com>, 2021
# ChenYuan <github@qiushi.ac.cn>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Xu Siyuan, 2021
# Naisen Xu <723648649@qq.com>, 2021
# Arisaka97 <solitaire2312@gmail.com>, 2021
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`!pickle` --- Python object serialization"
msgstr ":mod:`!pickle` --- Python 对象序列化"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**源代码：** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a "
":term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"模块 :mod:`pickle` 实现了对一个 Python 对象结构的二进制序列化和反序列化。 *\"pickling\"* 是将 Python "
"对象及其所拥有的层次结构转化为一个字节流的过程，而 *\"unpickling\"* 是相反的操作，会将（来自一个 :term:`binary "
"file` 或者 :term:`bytes-like object` 的）字节流转化回一个对象层次结构。 pickling（和 "
"unpickling）也被称为“序列化”, “编组” [#]_ 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 "
"“解封 (unpickling)”。"

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr "``pickle`` 模块 **并不安全**。 你只应该对你信任的数据进行 unpickle 操作。"

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come"
" from an untrusted source, or that could have been tampered with."
msgstr "构建恶意的 pickle 数据来 **在解封时执行任意代码** 是可能的。 绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。"

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not"
" been tampered with."
msgstr "请考虑使用 :mod:`hmac` 来对数据进行签名，确保数据没有被篡改。"

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"在你处理不信任数据时，更安全的序列化格式如 :mod:`json` 可能更为适合。参见  :ref:`comparison-with-json` 。"

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "与其他 Python 模块间的关系"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "与 ``marshal`` 间的关系"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's "
":file:`.pyc` files."
msgstr ""
"Python 有一个更原始的序列化模块称为 :mod:`marshal`，但一般地 :mod:`pickle` 应该是序列化 Python "
"对象时的首选。:mod:`marshal` 存在主要是为了支持 Python 的 :file:`.pyc` 文件."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` 模块与 :mod:`marshal` 在如下几方面显著地不同："

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。:mod:`marshal` 不会这么做。"

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 "
"Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。:mod:`pickle` "
"只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。"

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` 不能被用于序列化用户定义类及其实例。:mod:`pickle` "
"能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。"

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise."
" The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type"
" differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"同样用于序列化的 :mod:`marshal` 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 :file:`.pyc` "
"文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。:mod:`pickle` "
"序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python "
"3 之间跨越传递，封存和解封的代码在 2 和 3 之间也是不同的。"

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "与 ``json`` 模块的比较"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"在 pickle 协议和 `JSON (JavaScript Object Notation) <https://json.org>`_ "
"之间有着本质上的差异:"

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 ``utf-8`` 编码），而 pickle "
"是一个二进制序列化格式；"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON 是我们可以直观阅读的，而 pickle 不是；"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while"
" pickle is Python-specific;"
msgstr "JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing "
":ref:`specific object APIs <pickle-inst>`);"
msgstr ""
"默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用"
" Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 :ref:`specific object APIs <pickle-"
"inst>` 来解决）。"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr "不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。"

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 模块:一个允许JSON序列化和反序列化的标准库模块"

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "数据流格式"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""
":mod:`pickle` 所使用的数据格式是 Python 专属的。 这样做的好处是没有外部标准如 "
"JSON（它无法表示指针共享）给该格式施加限制；但这也意味着非 Python 程序可能无法重新构建已封存的 Python 对象。"

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"默认情况下，:mod:`pickle` 格式使用相对紧凑的二进制来存储。如果需要让文件更小，可以高效地 :doc:`压缩 <archiving>` 由 "
"pickle 封存的数据。"

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
":mod:`pickletools` 模块包含了相应的工具用于分析 :mod:`pickle` 生成的数据流。:mod:`pickletools` "
"源码中包含了对 pickle 协议使用的操作码的大量注释。"

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr "当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。"

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。"

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。"

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer to"
" :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"第 2 版协议是在 Python 2.3 中引入的。 它为 :term:`新式类 <new-style class>` 提供了更高效的封存机制。 请参考"
" :pep:`307` 了解第 2 版协议带来的改进的相关信息。"

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
":class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"v3 版协议是在 Python 3.0 中引入的。 它显式地支持 :class:`bytes` 字节对象，不能使用 Python 2.x 解封。这是 "
"Python 3.0-3.7 的默认协议。"

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format optimizations."
"  This was the default protocol in Python 3.8--3.13. Refer to :pep:`3154` "
"for information about improvements brought by protocol 4."
msgstr ""
"v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。这是Python 3.8--"
"3.13中使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 :pep:`3154`。"

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band"
" data and speedup for in-band data.  It is the default protocol starting "
"with Python 3.14.  Refer to :pep:`574` for information about improvements "
"brought by protocol 5."
msgstr ""
"第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 它是自Python 3.14起的默认协议。请参阅"
" :pep:`574` 了解第 5 版协议所带来的改进的详情。"

#: ../../library/pickle.rst:169
msgid ""
"Serialization is a more primitive notion than persistence; although "
":mod:`pickle` reads and writes file objects, it does not handle the issue of"
" naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"序列化是一种比持久化更底层的概念，虽然 :mod:`pickle` "
"读取和写入的是文件对象，但它不处理持久对象的命名问题，也不处理对持久对象的并发访问（甚至更复杂）的问题。:mod:`pickle` "
"模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。处理这些字节流最常见的做法是将它们写入文件，但它们也可以通过网络发送或存储在数据库中。:mod:`shelve`"
" 模块提供了一个简单的接口，用于在 DBM 类型的数据库文件上封存和解封对象。"

#: ../../library/pickle.rst:182
msgid "Module Interface"
msgstr "模块接口"

#: ../../library/pickle.rst:184
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the "
":func:`loads` function. However, if you want more control over serialization"
" and de-serialization, you can create a :class:`Pickler` or an "
":class:`Unpickler` object, respectively."
msgstr ""
"要序列化某个包含层次结构的对象，只需调用 :func:`dumps` 函数即可。同样，要反序列化数据流，可以调用 :func:`loads` "
"函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 :class:`Pickler` 或 :class:`Unpickler` 对象。"

#: ../../library/pickle.rst:189
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 模块包含了以下常量："

#: ../../library/pickle.rst:194
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions "
":func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"整数，可用的最高 :ref:`协议版本 <pickle-protocols>`。此值可以作为 *协议* 值传递给 :func:`dump` 和 "
":func:`dumps` 函数，以及 :class:`Pickler` 的构造函数。"

#: ../../library/pickle.rst:201
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default"
" protocol is 5, introduced in Python 3.8 and incompatible with previous "
"versions. This version introduces support for out-of-band buffers, where "
":pep:`3118`-compatible data can be transmitted separately from the main "
"pickle stream."
msgstr ""
"整数，用于 pickle 数据的默认 :ref:`协议版本 <pickle-protocols>`。 它可能小于 "
":data:`HIGHEST_PROTOCOL`。当前默认协议版本是 5，它在 Python 3.8 "
"中引入，与之前的版本不兼容。此版本引入了对带外缓冲区的支持，其中 :pep:`3118` 兼容的数据可以与主 pickle 流分开传输。"

#: ../../library/pickle.rst:210
msgid "The default protocol is 3."
msgstr "默认协议版本是 3。"

#: ../../library/pickle.rst:214
msgid "The default protocol is 4."
msgstr "默认协议版本是 4。"

#: ../../library/pickle.rst:218
msgid "The default protocol is 5."
msgstr "默认的协议版本是 5。"

#: ../../library/pickle.rst:220
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 模块提供了以下方法，让封存过程更加方便："

#: ../../library/pickle.rst:225
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file"
" object` *file*.  This is equivalent to ``Pickler(file, "
"protocol).dump(obj)``."
msgstr ""
"将对象 *obj* 封存以后的对象写入已打开的 :term:`file object` *file*。它等同于 ``Pickler(file, "
"protocol).dump(obj)``。"

#: ../../library/pickle.rst:229
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"参数 *file*、*protocol*、*fix_imports* 和 *buffer_callback* 的含义与它们在 "
":class:`Pickler` 的构造函数中的含义相同。"

#: ../../library/pickle.rst:232 ../../library/pickle.rst:243
#: ../../library/pickle.rst:335
msgid "The *buffer_callback* argument was added."
msgstr "加入了 *buffer_callback* 参数。"

#: ../../library/pickle.rst:237
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr "将 *obj* 封存以后的对象作为 :class:`bytes` 类型直接返回，而不是将其写入到文件。"

#: ../../library/pickle.rst:240
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"参数 *protocol*、*fix_imports* 和 *buffer_callback* 的含义与它们在 :class:`Pickler` "
"的构造函数中的含义相同。"

#: ../../library/pickle.rst:248
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"从已打开的 :term:`file object` *文件* 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 "
"``Unpickler(file).load()``。"

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed.  Bytes past the pickled representation of the object "
"are ignored."
msgstr "Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。"

#: ../../library/pickle.rst:256
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"参数 *file*、*fix_imports*、*encoding*、*errors*、*strict* 和 *buffers* 的含义与它们在 "
":class:`Unpickler` 的构造函数中的含义相同。"

#: ../../library/pickle.rst:259 ../../library/pickle.rst:274
#: ../../library/pickle.rst:449
msgid "The *buffers* argument was added."
msgstr "加入了 *buffers* 参数。"

#: ../../library/pickle.rst:264
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"重建并返回一个对象的封存表示形式 *data* 的对象层级结构。 *data* 必须为 :term:`bytes-like object`。"

#: ../../library/pickle.rst:271
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"参数 *fix_imports*, *encoding*, *errors*, *strict* 和 *buffers* 的含义与在 "
":class:`Unpickler` 构造器中的含义相同。"

#: ../../library/pickle.rst:278
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` 模块定义了以下 3 个异常："

#: ../../library/pickle.rst:282
msgid ""
"Common base class for the other pickling exceptions.  It inherits from "
":exc:`Exception`."
msgstr "其他 pickle 异常的共同基类。 它继承自 :exc:`Exception`。"

#: ../../library/pickle.rst:287
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits from :exc:`PickleError`."
msgstr "当 :class:`Pickler` 遇到无法解封的对象时将引发的错误。 它继承自 :exc:`PickleError`。"

#: ../../library/pickle.rst:290
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "参考 :ref:`pickle-picklable` 来了解哪些对象可以被封存。"

#: ../../library/pickle.rst:295
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits from :exc:`PickleError`."
msgstr "当解封对象出现问题时将引发的错误，例如数据损坏或违反安全规则。 它继承自 :exc:`PickleError`。"

#: ../../library/pickle.rst:298
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。"

#: ../../library/pickle.rst:303
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, "
":class:`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
":mod:`pickle` 模块包含了 3 个类，:class:`Pickler`、:class:`Unpickler` 和 "
":class:`PickleBuffer`："

#: ../../library/pickle.rst:308
msgid "This takes a binary file for writing a pickle data stream."
msgstr "它接受一个二进制文件用于写入 pickle 数据流。"

#: ../../library/pickle.rst:310
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"可选参数 *protocol* 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 "
":data:`HIGHEST_PROTOCOL`。如果没有指定，这一参数默认值为 "
":data:`DEFAULT_PROTOCOL`。指定一个负数就相当于指定 :data:`HIGHEST_PROTOCOL`。"

#: ../../library/pickle.rst:315
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an "
":class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"参数 *file* 必须有一个 write() 方法，该 write() "
"方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 :class:`io.BytesIO` "
"实例，也可以是满足这一接口的其他任何自定义对象。"

#: ../../library/pickle.rst:320
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that"
" the pickle data stream is readable with Python 2."
msgstr ""
"如果 *fix_imports* 为 True 且 *protocol* 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 "
"Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。"

#: ../../library/pickle.rst:324
msgid ""
"If *buffer_callback* is ``None`` (the default), buffer views are serialized "
"into *file* as part of the pickle stream."
msgstr ""
"如果 *buffer_callback* 为 ``None`` (默认值)，缓冲区视图将作为 pickle 流的一部分被序列化到 *file* 中。"

#: ../../library/pickle.rst:327
msgid ""
"If *buffer_callback* is not ``None``, then it can be called any number of "
"times with a buffer view.  If the callback returns a false value (such as "
"``None``), the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise "
"the buffer is serialized in-band, i.e. inside the pickle stream."
msgstr ""
"如果 *buffer_callback* 不为 ``None``，那它可以用缓冲区视图调用任意次。 如果某次调用返回了假值 (例如 "
"``None``)，则给定的缓冲区是 :ref:`带外的 <pickle-oob>`；在其他情况下缓冲区是带内的，例如在 pickle 流内部。"

#: ../../library/pickle.rst:332
msgid ""
"It is an error if *buffer_callback* is not ``None`` and *protocol* is "
"``None`` or smaller than 5."
msgstr "如果 *buffer_callback* 不为 ``None`` 且 *protocol* 为 ``None`` 或小于 5 则将出错。"

#: ../../library/pickle.rst:340
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr "将 *obj* 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。"

#: ../../library/pickle.rst:345
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "默认无动作，该方法可被子类重写。"

#: ../../library/pickle.rst:347
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"如果 :meth:`persistent_id` 返回 ``None``，*obj* 会被照常 "
"pickle。如果返回其他值，:class:`Pickler` 会将这个函数的返回值作为 *obj* 的持久化 ID（Pickler "
"本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 "
":meth:`Unpickler.persistent_load` "
"中（该方法定义还原对象的过程，并返回得到的对象）。注意，:meth:`persistent_id` 的返回值本身不能拥有持久化 ID。"

#: ../../library/pickle.rst:353 ../../library/pickle.rst:467
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "参阅 :ref:`pickle-persistent` 获取详情和使用示例。"

#: ../../library/pickle.rst:355
msgid ""
"Add the default implementation of this method in the C implementation of "
":class:`!Pickler`."
msgstr "在 :class:`!Pickler` 的 C 实现中添加此方法的默认实现。"

#: ../../library/pickle.rst:361
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`~object.__reduce__` method."
msgstr ""
"pickler 对象的 dispatch 表是对 *reduction 函数* 的注册，其类别可使用 :func:`copyreg.pickle` "
"来声明。 它本身是一个以类为键并以 reduction 函数为值的映射。 一个 reduction 函数接受单个参数即其所关联的类并应当遵循与 "
":meth:`~object.__reduce__` 方法相同的接口。"

#: ../../library/pickle.rst:369
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the "
":mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a "
":attr:`dispatch_table` attribute then this will be used as the default "
"dispatch table for instances of that class."
msgstr ""
"Pickler 对象默认并没有 :attr:`dispatch_table` 属性，该对象默认使用 :mod:`copyreg` 模块中定义的全局 "
"dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 :attr:`dispatch_table` "
"属性设置为类字典对象（dict-like object）。另外，如果 :class:`Pickler` 的子类设置了 "
":attr:`dispatch_table` 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。"

#: ../../library/pickle.rst:378
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "参阅 :ref:`pickle-dispatch` 获取使用示例。"

#: ../../library/pickle.rst:384
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`~object.__reduce__` method,"
" and can optionally return :data:`NotImplemented` to fallback on "
":attr:`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""
"可以在 :class:`Pickler` 子类中定义的特殊 reducer。 该方法的优先级高于 :attr:`dispatch_table` 中的任何"
" reducer。 它应当遵循与 :meth:`~object.__reduce__` 方法相同的接口，也可以选择返回 "
":data:`NotImplemented` 以回退到使用 :attr:`dispatch_table` 注册的 reducer 来封存 "
"``obj``。"

#: ../../library/pickle.rst:390
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "参阅 :ref:`reducer_override` 获取详细的示例。"

#: ../../library/pickle.rst:396
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables"
" the usage of memo, therefore speeding the pickling process by not "
"generating superfluous PUT opcodes.  It should not be used with self-"
"referential objects, doing otherwise will cause :class:`Pickler` to recurse "
"infinitely."
msgstr ""
"已弃用。设为 True 则启用快速模式。快速模式禁用了“备忘录” (memo) 的使用，即不生成多余的 PUT 操作码来加快封存过程。不应将其与自指 "
"(self-referential) 对象一起使用，否则将导致 :class:`Pickler` 无限递归。"

#: ../../library/pickle.rst:402
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "如果需要进一步提高 pickle 的压缩率，请使用 :func:`pickletools.optimize`。"

#: ../../library/pickle.rst:406
msgid "Clears the pickler's \"memo\"."
msgstr "清空 pickler 的 \"memo\"。"

#: ../../library/pickle.rst:408
msgid ""
"The memo is the data structure that remembers which objects the pickler has "
"already seen, so that shared or recursive objects are pickled by reference "
"and not by value.  This method is useful when re-using picklers."
msgstr ""
"memo 是一种数据结构，用来记忆 pickler 已看过的对象，这样共享的或递归的对象将按引用而不是按值被 pickle。 此方法在重用 "
"pickler 时很有用处。"

#: ../../library/pickle.rst:416
msgid "This takes a binary file for reading a pickle data stream."
msgstr "它接受一个二进制文件用于读取 pickle 数据流。"

#: ../../library/pickle.rst:418
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed."
msgstr "Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。"

#: ../../library/pickle.rst:421
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the "
":class:`io.BufferedIOBase` interface.  Thus *file* can be an on-disk file "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"参数 *file* 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() "
"方法不需要参数，这与 :class:`io.BufferedIOBase` 里定义的接口是相同的。因此 *file* "
"可以是一个磁盘上用于二进制读取的文件，也可以是一个 :class:`io.BytesIO` 实例，也可以是满足这一接口的其他任何自定义对象。"

#: ../../library/pickle.rst:428
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these "
"8-bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of "
":class:`~datetime.datetime`, :class:`~datetime.date` and "
":class:`~datetime.time` pickled by Python 2."
msgstr ""
"可选的参数是 *fix_imports*, *encoding* 和 *errors*，用于控制由Python 2 生成的 pickle "
"流的兼容性。如果 *fix_imports* 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 "
"中对应的新名称。*encoding* 和 *errors* 参数告诉 pickle 如何解码 Python 2 存储的 8 "
"位字符串实例；这两个参数默认分别为 'ASCII' 和 'strict'。*encoding* 参数可置为 'bytes' 来将这些 8 "
"位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 "
":class:`~datetime.datetime`、:class:`~datetime.date` 和 "
":class:`~datetime.time` 实例时，请使用 ``encoding='latin1'``。"

#: ../../library/pickle.rst:439
msgid ""
"If *buffers* is ``None`` (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the"
" *buffer_callback* argument was ``None`` when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"如果 *buffers* 为 ``None`` (默认值)，则反序列化所需的所有数据都必须包含在 pickle 流中。 这意味着当 "
":class:`Pickler` 被实例化 (或当 :func:`dump` 或 :func:`dumps` 被调用) 时 "
"*buffer_callback* 参数为 ``None``。"

#: ../../library/pickle.rst:444
msgid ""
"If *buffers* is not ``None``, it should be an iterable of buffer-enabled "
"objects that is consumed each time the pickle stream references an "
":ref:`out-of-band <pickle-oob>` buffer view.  Such buffers have been given "
"in order to the *buffer_callback* of a Pickler object."
msgstr ""
"如果 *buffers* 不为 ``None``，则每次 pickle 流引用一个 :ref:`带外的 <pickle-oob>` "
"缓冲区视图时，消耗的对象都应该是一个启用缓冲区的对象的可迭代对象。 这样的缓冲区将按顺序提供给 Pickler 对象的 "
"*buffer_callback*。"

#: ../../library/pickle.rst:454
msgid ""
"Read the pickled representation of an object from the open file object given"
" in the constructor, and return the reconstituted object hierarchy specified"
" therein.  Bytes past the pickled representation of the object are ignored."
msgstr "从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。"

#: ../../library/pickle.rst:461
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "默认抛出 :exc:`UnpicklingError` 异常。"

#: ../../library/pickle.rst:463
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an "
":exc:`UnpicklingError` should be raised."
msgstr ""
"如果定义了此方法，:meth:`persistent_load` 应当返回持久化 ID *pid* 所指定的对象。 如果遇到无效的持久化 "
"ID，则应当引发 :exc:`UnpicklingError`。"

#: ../../library/pickle.rst:469
msgid ""
"Add the default implementation of this method in the C implementation of "
":class:`!Unpickler`."
msgstr "在 :class:`!Unpickler` 的 C 实现中添加了此方法的默认实现。"

#: ../../library/pickle.rst:475
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"如有必要，导入 *module* 模块并返回其中名叫 *name* 的对象，其中 *module* 和 *name* 参数都是 :class:`str`"
" 对象。注意，不要被这个函数的名字迷惑， :meth:`find_class` 同样可以用来导入函数。"

#: ../../library/pickle.rst:480
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to "
":ref:`pickle-restrict` for details."
msgstr ""
"子类可以重写此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。参阅 :ref:`pickle-restrict` 获取更详细的信息。"

#: ../../library/pickle.rst:484
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``pickle.find_class`` 并附带参数 ``module``, "
"``name``。"

#: ../../library/pickle.rst:488
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a "
":ref:`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。*buffer* 必须是一个 :ref:`buffer-providing "
"<bufferobjects>` 对象，比如 :term:`bytes-like object` 或多维数组。"

#: ../../library/pickle.rst:492
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as "
":class:`memoryview`."
msgstr ""
":class:`PickleBuffer` 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 "
":class:`memoryview`。"

#: ../../library/pickle.rst:496
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5"
" or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
":class:`PickleBuffer` 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 :ref:`带外序列化 <pickle-"
"oob>` 的条件。"

#: ../../library/pickle.rst:504
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"返回该缓冲区底层内存区域的 :class:`memoryview`。 返回的对象是一维的、C 连续布局的 memoryview，格式为 ``B`` "
"(无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 :exc:`BufferError` 异常。"

#: ../../library/pickle.rst:511
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "释放由 PickleBuffer 占用的底层缓冲区。"

#: ../../library/pickle.rst:517
msgid "What can be pickled and unpickled?"
msgstr "可以被封存/解封的对象"

#: ../../library/pickle.rst:519
msgid "The following types can be pickled:"
msgstr "下列类型可以被封存："

#: ../../library/pickle.rst:521
msgid ""
"built-in constants (``None``, ``True``, ``False``, ``Ellipsis``, and "
":data:`NotImplemented`);"
msgstr ""
"内置常量 (``None``, ``True``, ``False``, ``Ellipsis`` 和 :data:`NotImplemented`)；"

#: ../../library/pickle.rst:524
msgid "integers, floating-point numbers, complex numbers;"
msgstr "整数、浮点数、复数;"

#: ../../library/pickle.rst:526
msgid "strings, bytes, bytearrays;"
msgstr "字符串、字节串、字节数组;"

#: ../../library/pickle.rst:528
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr "只包含可封存对象的元组、列表、集合和字典;"

#: ../../library/pickle.rst:530
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"可在模块最高层级上访问的（内置与用户自定义的）函数（使用 :keyword:`def`，而不是使用 :keyword:`lambda` 定义）;"

#: ../../library/pickle.rst:533
msgid "classes accessible from the top level of a module;"
msgstr "可在模块最高层级上访问的类;"

#: ../../library/pickle.rst:535
msgid ""
"instances of such classes whose the result of calling "
":meth:`~object.__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
"这种类的实例调用 :meth:`~object.__getstate__` 的结果是可 pickle 的（请参阅 :ref:`pickle-inst` "
"一节了解详情）。"

#: ../../library/pickle.rst:538
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a "
":exc:`RecursionError` will be raised in this case.  You can carefully raise "
"this limit with :func:`sys.setrecursionlimit`."
msgstr ""
"尝试封存不能被封存的对象会抛出 :exc:`PicklingError` "
"异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 "
":exc:`RecursionError` 异常，可以通过 :func:`sys.setrecursionlimit` "
"调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。"

#: ../../library/pickle.rst:545
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully "
":term:`qualified name`, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the containing module and "
"classes.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"请注意（内置与用户自定义的）函数是按完整 :term:`qualified name`，而不是按值来封存的。 [#]_  "
"这意味着只会封存函数名称，以及包含它的模块和类名称。 函数的代码，以及函数的属性都不会被封存。 "
"因而定义它的模块在解封环境中必须可以被导入，并且模块必须包含所命名的对象，否则将会引发异常。 [#]_"

#: ../../library/pickle.rst:552
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"类似地，类也是按完整限定名称来封存的，因此在解封环境中也会应用相同的限制。 请注意类的代码或数据都不会被封存，因此在下面的示例中类属性 ``attr``"
" 不会在解封环境中被恢复::"

#: ../../library/pickle.rst:557
msgid ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"
msgstr ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"

#: ../../library/pickle.rst:562
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr "这些限制决定了为什么可封存的函数和类必须在一个模块的最高层级上定义。"

#: ../../library/pickle.rst:565
msgid ""
"Similarly, when class instances are pickled, their class's code and data are"
" not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's "
":meth:`~object.__setstate__` method."
msgstr ""
"类似的，在封存类的实例时，类的代码和数据不会随它们一起被封存，只有实际数据会被封存。 "
"这样设计有其目的，在将来修复类中的错误或给类增加方法之后仍然可以载入较早版本创建的对象。 "
"如果你打算长期使用某些可能有许多版本的类的对象，那么在对象中设置一个版本号以便通过类的 :meth:`~object.__setstate__` "
"方法进行适当的转换就是值得做的事情。"

#: ../../library/pickle.rst:577
msgid "Pickling Class Instances"
msgstr "封存类实例"

#: ../../library/pickle.rst:581
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and "
"unpickled."
msgstr "在本节中，我们描述了可用于定义、自定义和控制如何封存和解封类实例的通用流程。"

#: ../../library/pickle.rst:584
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By"
" default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its "
":meth:`~object.__init__` method is usually *not* invoked.  The default "
"behaviour first creates an uninitialized instance and then restores the "
"saved attributes.  The following code shows an implementation of this "
"behaviour::"
msgstr ""
"在大多数情况下，使一个实例可被封存不需要任何额外的代码。 根据默认设置，pickle 将通过内省来获取实例的类及属性。 当一个类实例被解封时，它的 "
":meth:`~object.__init__` 方法通常 *不会* 被唤起。 默认的行为会先创建一个未初始化的实例然后恢复已保存的属性。 "
"下面的代码展示了这种行为的具体实现::"

#: ../../library/pickle.rst:591
msgid ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"
msgstr ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"

#: ../../library/pickle.rst:599
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr "类可以改变默认行为，只需定义以下一种或几种特殊方法："

#: ../../library/pickle.rst:604
msgid ""
"In protocols 2 and newer, classes that implements the "
":meth:`__getnewargs_ex__` method can dictate the values passed to the "
":meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  Those"
" will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"对于使用第 2 版或更高版协议的 pickle，实现了 :meth:`__getnewargs_ex__` 方法的类可以控制在解封时传给 "
":meth:`__new__` 方法的参数。本方法必须返回一对 ``(args, kwargs)`` 用于构建对象，其中 *args* 是表示位置参数的"
" tuple，而 *kwargs* 是表示命名参数的 dict。它们会在解封时传递给 :meth:`__new__` 方法。"

#: ../../library/pickle.rst:612
msgid ""
"You should implement this method if the :meth:`__new__` method of your class"
" requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"如果类的 :meth:`__new__` 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 "
":meth:`__getnewargs__` 方法。"

#: ../../library/pickle.rst:616
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` 现在可用于第 2 和第 3 版协议。"

#: ../../library/pickle.rst:622
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"这个方法与上一个 :meth:`__getnewargs_ex__` 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 "
"``args``，用于解封时传递给 :meth:`__new__` 方法。"

#: ../../library/pickle.rst:626
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr "如果定义了 :meth:`__getnewargs_ex__`，那么 :meth:`__getnewargs__` 就不会被调用。"

#: ../../library/pickle.rst:629
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of "
":meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"在 Python 3.6 前，第 2、3 版协议会调用 :meth:`__getnewargs__`，更高版本协议会调用 "
":meth:`__getnewargs_ex__`。"

#: ../../library/pickle.rst:636
msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""
"类还可以通过重写方法 :meth:`__getstate__` 来进一步影响它们的实例要如何被封存。 "
"该方法将被调用并且其返回的对象会被当作实例的内容来封存，而不是使用默认状态。 这有几种情况:"

#: ../../library/pickle.rst:641
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no "
":attr:`~object.__slots__`, the default state is ``None``."
msgstr ""
"对于没有实例 :attr:`~object.__dict__` 以及没有 :attr:`~object.__slots__` 的类，默认状态为 "
"``None``。"

#: ../../library/pickle.rst:644
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no "
":attr:`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""
"对于具有实例 :attr:`~object.__dict__` 而没有 :attr:`~object.__slots__` 的类，默认状态为 "
"``self.__dict__``。"

#: ../../library/pickle.rst:647
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and "
":attr:`~object.__slots__`, the default state is a tuple consisting of two "
"dictionaries:  ``self.__dict__``, and a dictionary mapping slot names to "
"slot values.  Only slots that have a value are included in the latter."
msgstr ""
"对于具有实例 :attr:`~object.__dict__` 和 :attr:`~object.__slots__` 的类，默认状态为一个由两个字典:"
"  ``self.__dict__``、以及将槽位名称映射到槽位值的字典所组成的元组。 只有包含具体值的槽位才会被包括在后一个字典当中。"

#: ../../library/pickle.rst:653
msgid ""
"For a class that has :attr:`~object.__slots__` and no instance "
":attr:`~object.__dict__`, the default state is a tuple whose first item is "
"``None`` and whose second item is a dictionary mapping slot names to slot "
"values described in the previous bullet."
msgstr ""
"对于具有 :attr:`~object.__slots__` 而没有实例 :attr:`~object.__dict__` 的类，默认状态为一个第一项是"
" ``None`` 而第二项是上述将槽位名称映射到槽位值的字典的元组。"

#: ../../library/pickle.rst:658
msgid ""
"Added the default implementation of the ``__getstate__()`` method in the "
":class:`object` class."
msgstr "将 ``__getstate__()`` 方法的默认实现添加到 :class:`object` 类中。"

#: ../../library/pickle.rst:665
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"当解封时，如果类定义了 :meth:`__setstate__`，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 "
"dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 __dict__。"

#: ../../library/pickle.rst:672
msgid ""
"If :meth:`__reduce__` returns a state with value ``None`` at pickling, the "
":meth:`__setstate__` method will not be called upon unpickling."
msgstr ""
"如果 :meth:`__reduce__` 在封存时返回一个 ``None`` 值状态，那么在解封时将不会调用 :meth:`__setstate__`"
" 方法。"

#: ../../library/pickle.rst:676
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`~object.__getstate__` and "
":meth:`~object.__setstate__`."
msgstr ""
"请参阅 :ref:`pickle-state` 一节如何使用 :meth:`~object.__getstate__` 和 "
":meth:`~object.__setstate__` 方法的更多信息。"

#: ../../library/pickle.rst:681
msgid ""
"At unpickling time, some methods like :meth:`~object.__getattr__`, "
":meth:`~object.__getattribute__`, or :meth:`~object.__setattr__` may be "
"called upon the instance.  In case those methods rely on some internal "
"invariant being true, the type should implement :meth:`~object.__new__` to "
"establish such an invariant, as :meth:`~object.__init__` is not called when "
"unpickling an instance."
msgstr ""
"在解封时，某些方法比如 :meth:`~object.__getattr__`, :meth:`~object.__getattribute__` 或 "
":meth:`~object.__setattr__` 可能会在实例上被调用。 对于这些方法依赖于某些内部的不变量为真值的情况，类型应当实现 "
":meth:`~object.__new__` 以建立这样的不变量，因为当解封一个实例时 :meth:`~object.__init__` "
"并不会被调用。"

#: ../../library/pickle.rst:690
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the "
":meth:`~object.__reduce__` special method.  The copy protocol provides a "
"unified interface for retrieving the data necessary for pickling and copying"
" objects. [#]_"
msgstr ""
"正如我们会看到的，pickle 并不会直接使用上述的方法。 实际上，这些方法是拷贝协议的一部分，它实现了 "
":meth:`~object.__reduce__` 特殊方法。 拷贝协议提供了统一的接口用于在封存和拷贝对象时获取所需的数据。 [#]_"

#: ../../library/pickle.rst:696
msgid ""
"Although powerful, implementing :meth:`~object.__reduce__` directly in your "
"classes is error prone.  For this reason, class designers should use the "
"high-level interface (i.e., :meth:`~object.__getnewargs_ex__`, "
":meth:`~object.__getstate__` and :meth:`~object.__setstate__`) whenever "
"possible.  We will show, however, cases where using :meth:`!__reduce__` is "
"the only option or leads to more efficient pickling or both."
msgstr ""
"在你的类中直接实现 :meth:`~object.__reduce__` 虽然功能很强但也容易出错。 因此，类的设计者应当尽可能使用高层级的接口 (即 "
":meth:`~object.__getnewargs_ex__`, :meth:`~object.__getstate__` 和 "
":meth:`~object.__setstate__`)。 不过，我们仍然会演示使用 :meth:`!__reduce__` "
"是唯一选项或是更高效的封存或是两者兼有的场景。"

#: ../../library/pickle.rst:705
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"该接口当前定义如下。:meth:`__reduce__` 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce "
"值”）。"

#: ../../library/pickle.rst:709
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle "
"模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。"

#: ../../library/pickle.rst:714
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr "如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 ``None``。每个元素代表的意义如下："

#: ../../library/pickle.rst:720
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr "一个可调用对象，该对象会在创建对象的最初版本时调用。"

#: ../../library/pickle.rst:723
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr "可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。"

#: ../../library/pickle.rst:726
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as previously described.  If the object has no "
"such method then, the value must be a dictionary and it will be added to the"
" object's :attr:`~object.__dict__` attribute."
msgstr ""
"可选元素，用于表示对象的状态，将被传给前述的 :meth:`__setstate__` 方法。 "
"如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 :attr:`~object.__dict__` 属性中。"

#: ../../library/pickle.rst:731
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)``"
" or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have "
":ref:`append and extend methods <typesseq-common>` with the appropriate "
"signature.  (Whether :meth:`!append` or :meth:`!extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr ""
"可选项，一个返回连续条目的迭代器（而不是序列）。 这些条目将使用 ``obj.append(item)`` 或是使用 "
"``obj.extend(list_of_items)`` 批量地添加到对象中。 这主要用于列表的子类，但也可以用于其他类，只要它们具有使用相应签名的 "
":ref:`append 和 extend 方法 <typesseq-common>`。 （具体是使用 :meth:`!append` 还是 "
":meth:`!extend` 取决于所使用的 pickle 协议版本以及要插入的条目数量，所以这两个方法都必须被支持。）"

#: ../../library/pickle.rst:741
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = value``."
"  This is primarily used for dictionary subclasses, but may be used by other"
" classes as long as they implement :meth:`__setitem__`."
msgstr ""
"可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 ``obj[key] = value`` 的方式存储于对象中。该元素主要用于 "
"dict 子类，也可以用于那些实现了 :meth:`__setitem__` 的类。"

#: ../../library/pickle.rst:746
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a"
" specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s "
":meth:`__setstate__`."
msgstr ""
"可选元素，一个带有 ``(obj, state)`` 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 "
"``obj`` 的静态 :meth:`__setstate__` 方法。如果此处不是 ``None``，则此可调用对象的优先级高于 ``obj`` 的 "
":meth:`__setstate__`。"

#: ../../library/pickle.rst:752
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "新增了元组的第 6 项，可选元素 ``(obj, state)``。"

#: ../../library/pickle.rst:758
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the "
":meth:`__reduce__` method.  In addition, :meth:`__reduce__` automatically "
"becomes a synonym for the extended version.  The main use for this method is"
" to provide backwards-compatible reduce values for older Python releases."
msgstr ""
"作为替代选项，也可以实现 :meth:`__reduce_ex__` 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 "
"如果定义了这个函数，则会覆盖 :meth:`__reduce__` 的行为。 此外，:meth:`__reduce__` "
"方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。"

#: ../../library/pickle.rst:770
msgid "Persistence of External Objects"
msgstr "持久化外部对象"

#: ../../library/pickle.rst:776
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the"
" notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object"
" (for any newer protocol)."
msgstr ""
"为了获取对象持久化的利益， :mod:`pickle` 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID "
"来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) [#]_ 或是一个任意对象 (用于任意新版协议)。"

#: ../../library/pickle.rst:782
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and "
":meth:`~Unpickler.persistent_load` respectively."
msgstr ""
":mod:`pickle` 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 "
":meth:`~Pickler.persistent_id` 方法和 unpickler 中的 "
":meth:`~Unpickler.persistent_load` 方法。"

#: ../../library/pickle.rst:787
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have"
" a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 :meth:`~Pickler.persistent_id` "
"方法，该方法接受需要被封存的对象作为参数，返回一个 ``None`` 或返回该对象的持久化 ID。如果返回 "
"``None``，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler "
"才能将其识别为持久化 ID。"

#: ../../library/pickle.rst:794
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":meth:`~Unpickler.persistent_load` method that takes a persistent ID object "
"and returns the referenced object."
msgstr ""
"要解封外部对象，Unpickler 必须实现 :meth:`~Unpickler.persistent_load` 方法，接受一个持久化 ID "
"对象作为参数并返回一个引用的对象。"

#: ../../library/pickle.rst:798
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr "下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。"

#: ../../library/pickle.rst:801
msgid ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", (str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct object.\n"
"            # Otherwise, the unpickler will think None is the object referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"# 介绍如何使用持久性 ID 基于引用\n"
"# 对外部对象进行 pickle 的简单示例。\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# 代表数据库中一条记录的简单类。\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # 我们不是将 MemoRecord 作为常规类实例进行 pickle，\n"
"        # 而是发出一个持久性 ID。\n"
"        if isinstance(obj, MemoRecord):\n"
"            # 这里，我们的持久性 ID 就是一个元组，包含标签和键，\n"
"            # 它指向数据库中的特定记录。\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # 如果 obj 没有持久性 ID，则返回 None。 这意味着 obj\n"
"            # 需要被正常地 pickle。\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # 此方法会在遇到一个持久性 ID 时被唤起。\n"
"        # 在这里，pid 是 DBPickler 所返回的元组。\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # 从数据库提取被引用的记录并将其返回。\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", (str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # 如果你无法返回正确的对象则总是引发一个错误。\n"
"            # 否则，反 pickle 操作将认为持久性 ID 所引用的对象\n"
"            # 为 None。\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # 初始化并填充我们的数据库。\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # 提取要进行 pickle 的记录。\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # 使用我们自定义的 DBPickler 保存记录。\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # 更新一条记录，以确保有效。\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # 从 pickle 数据流加载记录。\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/pickle.rst:806
msgid "Dispatch Tables"
msgstr "Dispatch 表"

#: ../../library/pickle.rst:808
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr "如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。"

#: ../../library/pickle.rst:812
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`!copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`!copyreg.dispatch_table` as a private dispatch "
"table."
msgstr ""
":mod:`copyreg` 模块所管理的全局 dispatch 表可通过 :data:`!copyreg.dispatch_table` 来访问。 "
"因此，可以选择使用经过修改的 :data:`!copyreg.dispatch_table` 副本作为私有 dispatch 表。"

#: ../../library/pickle.rst:817
msgid "For example ::"
msgstr "例如 ::"

#: ../../library/pickle.rst:819
msgid ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"
msgstr ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"

#: ../../library/pickle.rst:824
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table"
" which handles the ``SomeClass`` class specially.  Alternatively, the code "
"::"
msgstr ""
"创建了一个带有自有 dispatch 表的 :class:`pickle.Pickler` 实例，它可以对 ``SomeClass`` "
"类进行特殊处理。另外，下列代码 ::"

#: ../../library/pickle.rst:828
msgid ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"
msgstr ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"

#: ../../library/pickle.rst:834
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr "完成同样的操作，但所有 ``MyPickler`` 的实例都会共享一个私有分发表。 另一方面，代码 ::"

#: ../../library/pickle.rst:837
msgid ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"
msgstr ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"

#: ../../library/pickle.rst:841
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg`"
" module."
msgstr "会修改由 :mod:`copyreg` 模块的所有用户共享的全局分发表。"

#: ../../library/pickle.rst:846
msgid "Handling Stateful Objects"
msgstr "处理有状态的对象"

#: ../../library/pickle.rst:852
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`!TextReader` class below opens a text file, and returns the line"
" number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`!TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The "
":meth:`!__setstate__` and :meth:`!__getstate__` methods are used to "
"implement this behavior. ::"
msgstr ""
"下面的例子展示了如何修改类的封存行为。 下面的 :class:`!TextReader` 类会打开一个文本文件，每次调用其 "
":meth:`!readline` 方法时将返回行号和该行的内容。 如果一个 :class:`!TextReader` 实例被封存，则 *除了* "
"文件对象以外的所有属性都会被保存。 当实际被解封时，该文件将被重新打开，并从最后的位置开始恢复读取。 实现此行为需要使用 "
":meth:`!__setstate__` 和 :meth:`!__getstate__` 方法。 ::"

#: ../../library/pickle.rst:860
msgid ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"
msgstr ""
"class TextReader:\n"
"    \"\"\"打印文本文件的行内容和行号。\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # 从 self.__dict__ 拷贝对象的状态，其中包含\n"
"        # 所有的实例属性。 总是使用 dict.copy() 方法\n"
"        # 以避免修改原始状态。\n"
"        state = self.__dict__.copy()\n"
"        # 移除不可 pickle 的条目。\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # 恢复实例属性 (即 filename 和 lineno)。\n"
"        self.__dict__.update(state)\n"
"        # 恢复之前所打开文件的状态。 为做到这点，我们需要\n"
"        # 重新打开它并从其中读取直到恢复行计数。\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # 最后，保存该文件。\n"
"        self.file = file"

#: ../../library/pickle.rst:898
msgid "A sample usage might be something like this::"
msgstr "使用方法如下所示："

#: ../../library/pickle.rst:900
msgid ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"
msgstr ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"

#: ../../library/pickle.rst:912
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "类型，函数和其他对象的自定义归约"

#: ../../library/pickle.rst:916
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than"
" the object's type, or we may want to customize the pickling of functions "
"and classes."
msgstr ""
"有时，:attr:`~Pickler.dispatch_table` 可能不够灵活。 "
"特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。"

#: ../../library/pickle.rst:921
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`~object.__reduce__`). It can"
" alternatively return :data:`NotImplemented` to fallback to the traditional "
"behavior."
msgstr ""
"对于那些情况，可以子类化 :class:`Pickler` 类并实现 :meth:`~Pickler.reducer_override` 方法。 "
"此方法可返回任意 reduction 元组 (参见 :meth:`~object.__reduce__`)。 它也可以选择返回 "
":data:`NotImplemented` 以回退至传统的行为。"

#: ../../library/pickle.rst:926
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and "
":meth:`~Pickler.reducer_override` are defined, then "
":meth:`~Pickler.reducer_override` method takes priority."
msgstr ""
"如果同时定义了 :attr:`~Pickler.dispatch_table` 和 "
":meth:`~Pickler.reducer_override`，则 :meth:`~Pickler.reducer_override` "
"方法具有优先权。"

#: ../../library/pickle.rst:931
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called"
" for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, "
":class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and "
":class:`tuple`."
msgstr ""
"出于性能理由，可能不会为以下对象调用 :meth:`~Pickler.reducer_override`: ``None``, ``True``, "
"``False``, 以及 :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, "
":class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` 和 "
":class:`tuple` 的具体实例。"

#: ../../library/pickle.rst:937
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr "以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类::"

#: ../../library/pickle.rst:940
msgid ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"
msgstr ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"针对 MyClass 的自定义缩减器。\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # 对于任何其他对象，回退为正常缩减操作\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"

#: ../../library/pickle.rst:972
msgid "Out-of-band Buffers"
msgstr "外部缓冲区"

#: ../../library/pickle.rst:976
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"在某些场景中，:mod:`pickle` 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 "
":mod:`pickle` 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。"

#: ../../library/pickle.rst:983
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"如果 *provider* (待传输对象类型的实现) 和 *consumer* (通信系统的实现) 都支持 pickle 第 5 "
"版或更高版本所提供的外部传输功能，则此约束可以被撤销。"

#: ../../library/pickle.rst:989
msgid "Provider API"
msgstr "提供方 API"

#: ../../library/pickle.rst:991
msgid ""
"The large data objects to be pickled must implement a "
":meth:`~object.__reduce_ex__` method specialized for protocol 5 and higher, "
"which returns a :class:`PickleBuffer` instance (instead of e.g. a "
":class:`bytes` object) for any large data."
msgstr ""
"需要 pickle 的大型数据对象必须实现专门用于协议 5 以上版本的 :meth:`~object.__reduce_ex__` "
"方法，该方法将为任何大型数据返回一个 :class:`PickleBuffer` 实例（而不是 :class:`bytes` 对象）。"

#: ../../library/pickle.rst:996
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
":class:`PickleBuffer` 对象会 *表明* 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 :mod:`pickle` "
"模块的正常用法兼容。 但是，使用方也可以选择告知 :mod:`pickle` 它们将自行处理那些缓冲区。"

#: ../../library/pickle.rst:1003
msgid "Consumer API"
msgstr "使用方 API"

#: ../../library/pickle.rst:1005
msgid ""
"A communications system can enable custom handling of the "
":class:`PickleBuffer` objects generated when serializing an object graph."
msgstr "当序列化一个对象图时，通信系统可以启用对所生成 :class:`PickleBuffer` 对象的定制处理。"

#: ../../library/pickle.rst:1008
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to "
":class:`Pickler` (or to the :func:`dump` or :func:`dumps` function), which "
"will be called with each :class:`PickleBuffer` generated while pickling the "
"object graph.  Buffers accumulated by the *buffer_callback* will not see "
"their data copied into the pickle stream, only a cheap marker will be "
"inserted."
msgstr ""
"发送端需要传递 *buffer_callback* 参数到 :class:`Pickler` (或是到 :func:`dump` 或 "
":func:`dumps` 函数)，该回调函数将在封存对象图时附带每个所生成的 :class:`PickleBuffer` 被调用。 由 "
"*buffer_callback* 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。"

#: ../../library/pickle.rst:1015
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to "
":class:`Unpickler` (or to the :func:`load` or :func:`loads` function), which"
" is an iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original "
":class:`PickleBuffer` objects."
msgstr ""
"接收端需要传递 *buffers* 参数到 :class:`Unpickler` (或是到 :func:`load` 或 :func:`loads` "
"函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 *buffer_callback*。 该可迭代对象应当按其被传递给 "
"*buffer_callback* 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 "
":class:`PickleBuffer` 对象。"

#: ../../library/pickle.rst:1023
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr "在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。"

#: ../../library/pickle.rst:1029
msgid "Example"
msgstr "示例"

#: ../../library/pickle.rst:1031
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr "下面是一个小例子，在其中我们实现了一个 :class:`bytearray` 的子类，能够用于外部缓冲区封存::"

#: ../../library/pickle.rst:1034
msgid ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"
msgstr ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer 当 pickle 协议 <= 4 时是禁用的。\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # 获取原始缓冲区对象的句柄\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # 原始缓冲区对象是一个 ZeroCopyByteArray，\n"
"                # 则将其原样返回。\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"

#: ../../library/pickle.rst:1055
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"重构造器 (``_reconstruct`` 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。"

#: ../../library/pickle.rst:1059
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr "在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本::"

#: ../../library/pickle.rst:1062
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: 生成了副本"

#: ../../library/pickle.rst:1068
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr "但是如果我们传入 *buffer_callback* 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象::"

#: ../../library/pickle.rst:1071
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: 没有生成副本"

#: ../../library/pickle.rst:1078
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"这个例子受限于 :class:`bytearray` 会自行分配内存这一事实：你无法基于另一个对象的内存创建 :class:`bytearray` "
"的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。"

#: ../../library/pickle.rst:1085
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- 带有外部数据缓冲区的 pickle 协议 5"

#: ../../library/pickle.rst:1091
msgid "Restricting Globals"
msgstr "限制全局变量"

#: ../../library/pickle.rst:1096
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider"
" what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并唤起任意代码。 "
"只须考虑当这个手工构建的 pickle 数据流被加载时会做什么::"

#: ../../library/pickle.rst:1101
msgid ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"
msgstr ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"

#: ../../library/pickle.rst:1106
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"在这个例子里，解封器导入 :func:`os.system` 函数然后应用字符串参数 \"echo hello world\"。 "
"虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。"

#: ../../library/pickle.rst:1110
msgid ""
"For this reason, you may want to control what gets unpickled by customizing "
":meth:`Unpickler.find_class`.  Unlike its name suggests, "
":meth:`Unpickler.find_class` is called whenever a global (i.e., a class or a"
" function) is requested.  Thus it is possible to either completely forbid "
"globals or restrict them to a safe subset."
msgstr ""
"出于这样的理由，你可能会希望通过定制 :meth:`Unpickler.find_class` 来控制要解封的对象。 "
"与其名称所提示的不同，:meth:`Unpickler.find_class` 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 "
"因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。"

#: ../../library/pickle.rst:1116
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the "
":mod:`builtins` module to be loaded::"
msgstr "下面的例子是一个解封器，它只允许某一些安全的来自 :mod:`builtins` 模块的类被加载::"

#: ../../library/pickle.rst:1119
msgid ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"
msgstr ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # 只允许来自 builtins 的安全的类。\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # 禁止任何其他的类。\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"类似于 pickle.loads() 的辅助函数。\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"

#: ../../library/pickle.rst:1145
msgid "A sample usage of our unpickler working as intended::"
msgstr "我们这个解封器完成其功能的一个示例用法::"

#: ../../library/pickle.rst:1147
msgid ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"
msgstr ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"

#: ../../library/pickle.rst:1164
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 :mod:`xmlrpc.client` "
"中的编组 API 或是第三方解决方案。"

#: ../../library/pickle.rst:1171
msgid "Performance"
msgstr "性能"

#: ../../library/pickle.rst:1173
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature"
" efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，:mod:`pickle` "
"模块还拥有一个以 C 编写的透明优化器。"

#: ../../library/pickle.rst:1181
msgid "Examples"
msgstr "例子"

#: ../../library/pickle.rst:1183
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "对于最简单的代码，请使用 :func:`dump` 和 :func:`load` 函数。 ::"

#: ../../library/pickle.rst:1185
msgid ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"
msgstr ""
"import pickle\n"
"\n"
"# pickle 所支持的任意对象集。\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # 使用最高版本可用协议对 'data' 字典进行 pickle。\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"

#: ../../library/pickle.rst:1199
msgid "The following example reads the resulting pickled data. ::"
msgstr "以下示例读取之前封存的数据。 ::"

#: ../../library/pickle.rst:1201
msgid ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"
msgstr ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # 将自动检测所使用的协议版本，因此我们\n"
"    # 不需要指定它。\n"
"    data = pickle.load(f)"

#: ../../library/pickle.rst:1216
msgid "Command-line interface"
msgstr "命令行接口"

#: ../../library/pickle.rst:1218
msgid ""
"The :mod:`pickle` module can be invoked as a script from the command line, "
"it will display contents of the pickle files. However, when the pickle file "
"that you want to examine comes from an untrusted source, ``-m pickletools`` "
"is a safer option because it does not execute pickle bytecode, see "
":ref:`pickletools CLI usage <pickletools-cli>`."
msgstr ""
":mod:`pickle`模块可以作为脚本从命令行调用，它将显示pickle文件的内容。但是，当您要检查的pickle文件来自不受信任的来源时，``-m"
" pickletools``是一个更安全的选择，因为它不执行pickle字节码，请参阅 :ref:`pickletools "
"CLI用法<pickletools-cli>`。"

#: ../../library/pickle.rst:1224
msgid "python -m pickle pickle_file [pickle_file ...]"
msgstr "python -m pickle pickle_file [pickle_file ...]"

#: ../../library/pickle.rst:1228
msgid "The following option is accepted:"
msgstr "可以接受以下选项："

#: ../../library/pickle.rst:1234
msgid ""
"A pickle file to read, or ``-`` to indicate reading from standard input."
msgstr "一个要读取的 pickle 文件，或者为 ``-`` 表示从标准输入读取。"

#: ../../library/pickle.rst:1239
msgid "Module :mod:`copyreg`"
msgstr "模块 :mod:`copyreg`"

#: ../../library/pickle.rst:1240
msgid "Pickle interface constructor registration for extension types."
msgstr "为扩展类型提供 pickle 接口所需的构造函数。"

#: ../../library/pickle.rst:1242
msgid "Module :mod:`pickletools`"
msgstr "模块 :mod:`pickletools`"

#: ../../library/pickle.rst:1243
msgid "Tools for working with and analyzing pickled data."
msgstr "用于处理和分析已封存数据的工具。"

#: ../../library/pickle.rst:1245
msgid "Module :mod:`shelve`"
msgstr "模块 :mod:`shelve`"

#: ../../library/pickle.rst:1246
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "带索引的数据库，用于存放对象，使用了 :mod:`pickle` 模块。"

#: ../../library/pickle.rst:1248
msgid "Module :mod:`copy`"
msgstr "模块 :mod:`copy`"

#: ../../library/pickle.rst:1249
msgid "Shallow and deep object copying."
msgstr "浅层 (shallow) 和深层 (deep) 复制对象操作"

#: ../../library/pickle.rst:1251
msgid "Module :mod:`marshal`"
msgstr "模块 :mod:`marshal`"

#: ../../library/pickle.rst:1252
msgid "High-performance serialization of built-in types."
msgstr "高效地序列化内置类型的数据。"

#: ../../library/pickle.rst:1256
msgid "Footnotes"
msgstr "备注"

#: ../../library/pickle.rst:1257
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "不要把它与 :mod:`marshal` 模块混淆。"

#: ../../library/pickle.rst:1259
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all "
":keyword:`!lambda` functions share the same name:  ``<lambda>``."
msgstr "这就是为什么 :keyword:`lambda` 函数不可以被封存：所有的匿名函数都有同一个名字：``<lambda>``。"

#: ../../library/pickle.rst:1262
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr "抛出的异常有可能是 :exc:`ImportError` 或 :exc:`AttributeError`，也可能是其他异常。"

#: ../../library/pickle.rst:1265
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ":mod:`copy` 模块使用这一协议实现浅层 (shallow) 和深层 (deep) 复制操作。"

#: ../../library/pickle.rst:1268
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent"
" IDs in protocol 0 are delimited by the newline character.  Therefore if any"
" kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"对于字符数字类字符的限制是由于持久化 ID 在协议版本 0 中是由分行符来分隔的。 因此如果持久化 ID "
"中出现了任何形式的分行符，封存结果就将变得无法读取。"

#: ../../library/pickle.rst:12
msgid "persistence"
msgstr "persistence"

#: ../../library/pickle.rst:12
msgid "persistent"
msgstr "persistent"

#: ../../library/pickle.rst:12
msgid "objects"
msgstr "objects"

#: ../../library/pickle.rst:12
msgid "serializing"
msgstr "serializing"

#: ../../library/pickle.rst:12
msgid "marshalling"
msgstr "marshalling"

#: ../../library/pickle.rst:12
msgid "flattening"
msgstr "flattening"

#: ../../library/pickle.rst:12
msgid "pickling"
msgstr "pickling"

#: ../../library/pickle.rst:123
msgid "External Data Representation"
msgstr "External Data Representation"

#: ../../library/pickle.rst:688
msgid "copy"
msgstr "copy"

#: ../../library/pickle.rst:688
msgid "protocol"
msgstr "协议"

#: ../../library/pickle.rst:772
msgid "persistent_id (pickle protocol)"
msgstr "persistent_id (pickle 协议)"

#: ../../library/pickle.rst:772
msgid "persistent_load (pickle protocol)"
msgstr "persistent_load (pickle 协议)"

#: ../../library/pickle.rst:848
msgid "__getstate__() (copy protocol)"
msgstr "__getstate__() (copy 协议)"

#: ../../library/pickle.rst:848
msgid "__setstate__() (copy protocol)"
msgstr "__setstate__() (copy 协议)"

#: ../../library/pickle.rst:1093
msgid "find_class() (pickle protocol)"
msgstr "find_class() (pickle 协议)"
