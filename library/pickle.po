# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# Fred <fred.wei@foxmail.com>, 2018
# walkinrain <walkinrain2008@163.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# Siyuan Xu <mf20070535@126.com>, 2019
# nick <2330458484@qq.com>, 2019
# Menghua Xiao <arieshout@gmail.com>, 2019
# ChenYuan <github@qiushi.ac.cn>, 2019
# Arisaka97 <solitaire2312@gmail.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-12 11:28+0000\n"
"PO-Revision-Date: 2017-02-16 23:22+0000\n"
"Last-Translator: Arisaka97 <solitaire2312@gmail.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` —— Python 对象序列化"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**源代码：** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a "
":term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"模块 :mod:`pickle` 实现了对一个 Python 对象结构的二进制序列化和反序列化。 *\"Pickling\"* 是将 Python "
"对象及其所拥有的层次结构转化为一个字节流的过程，而 *\"unpickling\"* 是相反的操作，会将（来自一个 :term:`binary "
"file` 或者 :term:`bytes-like object` 的）字节流转化回一个对象层次结构。Pickling（和 "
"unpickling）也被称为“序列化”, “编组” [#]_ 或者 “平面化”。而为了避免混乱，此处采用术语 “pickling” 和 "
"“unpickling”。"

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr "``pickle`` 模块**并不安全**。你只应该对你信任的数据进行unpickle操作。"

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come"
" from an untrusted source, or that could have been tampered with."
msgstr "构建恶意的pickle数据来**在解封时执行任意代码**是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行unpickle。"

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not"
" been tampered with."
msgstr "请考虑使用 :mod:`hmac` 来对数据进行签名，确保数据没有被篡改。"

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"在你处理不信任数据时，更安全的序列化格式如 :mod:`json` 可能更为适合。参见  :ref:`comparison-with-json` 。"

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "与其他 Python 模块间的关系"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "与 ``marshal`` 间的关系"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's "
":file:`.pyc` files."
msgstr ""
"Python 有一个更原始的序列化模块称为 :mod:`marshal`，但一般地 :mod:`pickle` 应该是序列化 Python "
"对象时的首选。:mod:`marshal` 存在主要是为了支持 Python 的 :file:`.pyc` 文件."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` 模块与 :mod:`marshal` 在如下几方面显著地不同："

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。:mod:`marshal` 不会这么做。"

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 "
"Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。:mod:`pickle` "
"只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。"

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` 不能被用于序列化用户定义类及其实例。:mod:`pickle` "
"能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。"

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise."
" The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type"
" differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"同样用于序列化的 :mod:`marshal` 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 :file:`.pyc` "
"文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。:mod:`pickle` "
"序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python "
"3 之间跨越传递，Pickling 和 Unpickling 的代码在 2 和 3 之间也是不同的。"

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "与 ``json`` 模块的比较"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"Pickle 协议和 `JSON (JavaScript Object Notation) <http://json.org>`_ 间有着本质的不同："

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 ``utf-8`` 编码），而 pickle "
"是一个二进制序列化格式；"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON 是我们可以直观阅读的，而 pickle 不是；"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while"
" pickle is Python-specific;"
msgstr "JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing "
":ref:`specific object APIs <pickle-inst>`);"
msgstr ""
"默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用"
" Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 :ref:`specific object APIs <pickle-"
"inst>` 来解决）。"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr "不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。"

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 模块:一个允许JSON序列化和反序列化的标准库模块"

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "数据流格式"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` 所使用的数据格式仅可用于 Python。这样做的好处是没有外部标准给该格式强加限制，比如 JSON 或 "
"XDR（不能表示共享指针）标准；但这也意味着非 Python 程序可能无法重新读取 pickle 打包的 Python 对象。"

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"默认情况下，:mod:`pickle` 格式使用相对紧凑的二进制来存储。如果需要让文件更小，可以高效地 :doc:`压缩 <archiving>` 由 "
"pickle 打包的数据。"

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
":mod:`pickletools` 模块包含了相应的工具用于分析 :mod:`pickle` 生成的数据流。:mod:`pickletools` "
"源码中包含了对 pickle 协议使用的操作码的大量注释。"

#: ../../library/pickle.rst:139
msgid ""
"There are currently 5 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr "当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。"

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。"

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。"

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""
"v2 版协议是在 Python 2.3 中引入的。它为存储 :term:`new-style class` 提供了更高效的机制。欲了解有关第 2 "
"版协议带来的改进，请参阅 :pep:`307`。"

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
":class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"v3 版协议是在 Python 3.0 中引入的。 它显式地支持 :class:`bytes` 字节对象，不能使用Python 2.x "
"unpickle。这是Python 3.0-3.7的默认协议。"

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format optimizations."
"  It is the default protocol starting with Python 3.8. Refer to :pep:`3154` "
"for information about improvements brought by protocol 4."
msgstr ""
"v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python "
"3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 :pep:`3154`。"

#: ../../library/pickle.rst:164
msgid ""
"Serialization is a more primitive notion than persistence; although "
":mod:`pickle` reads and writes file objects, it does not handle the issue of"
" naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"序列化是一种比持久化更底层的概念，虽然 :mod:`pickle` "
"读取和写入的是文件对象，但它不处理持久对象的命名问题，也不处理对持久对象的并发访问（甚至更复杂）的问题。:mod:`pickle` "
"模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。处理这些字节流最常见的做法是将它们写入文件，但它们也可以通过网络发送或存储在数据库中。:mod:`shelve`"
" 模块提供了一个简单的接口，用于在 DBM 类型的数据库文件上 pickle 和 unpickle 对象。"

#: ../../library/pickle.rst:177
msgid "Module Interface"
msgstr "模块接口"

#: ../../library/pickle.rst:179
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the "
":func:`loads` function. However, if you want more control over serialization"
" and de-serialization, you can create a :class:`Pickler` or an "
":class:`Unpickler` object, respectively."
msgstr ""
"要序列化某个包含层次结构的对象，只需调用 :func:`dumps` 函数即可。同样，要反序列化数据流，可以调用 :func:`loads` "
"函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 :class:`Pickler` 或 :class:`Unpickler` 对象。"

#: ../../library/pickle.rst:184
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 模块包含了以下常量："

#: ../../library/pickle.rst:189
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions "
":func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"整数，可用的最高 :ref:`协议版本 <pickle-protocols>`。此值可以作为 *协议* 值传递给 :func:`dump` 和 "
":func:`dumps` 函数，以及 :class:`Pickler` 的构造函数。"

#: ../../library/pickle.rst:196
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default"
" protocol is 4, first introduced in Python 3.4 and incompatible with "
"previous versions."
msgstr ""
"整数，用于 pickle 数据的默认 :ref:`协议版本 <pickle-protocols>`。它可能小于 "
":data:`HIGHEST_PROTOCOL`。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。"

#: ../../library/pickle.rst:203
msgid "The default protocol is 3."
msgstr "默认协议版本是 3。"

#: ../../library/pickle.rst:207
msgid "The default protocol is 4."
msgstr "默认协议版本是 4。"

#: ../../library/pickle.rst:209
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 模块提供了以下方法，让打包过程更加方便："

#: ../../library/pickle.rst:214
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file"
" object` *file*.  This is equivalent to ``Pickler(file, "
"protocol).dump(obj)``."
msgstr ""
"将打包好的对象 *obj* 写入已打开的 :term:`file object` *file*。它等同于 ``Pickler(file, "
"protocol).dump(obj)``。"

#: ../../library/pickle.rst:218
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"参数 *file*、*protocol*、*fix_imports* 和 *buffer_callback* 的含义与它们在 "
":class:`Pickler` 的构造函数中的含义相同。"

#: ../../library/pickle.rst:221 ../../library/pickle.rst:232
#: ../../library/pickle.rst:324
msgid "The *buffer_callback* argument was added."
msgstr "加入了 *buffer_callback* 参数。"

#: ../../library/pickle.rst:226
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""

#: ../../library/pickle.rst:229
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""

#: ../../library/pickle.rst:237
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""

#: ../../library/pickle.rst:241 ../../library/pickle.rst:256
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed.  Bytes past the pickled representation of the object "
"are ignored."
msgstr ""

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""

#: ../../library/pickle.rst:248 ../../library/pickle.rst:263
#: ../../library/pickle.rst:425
msgid "The *buffers* argument was added."
msgstr ""

#: ../../library/pickle.rst:253
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*bytes_object* of an object."
msgstr ""

#: ../../library/pickle.rst:267
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ""

#: ../../library/pickle.rst:271
msgid ""
"Common base class for the other pickling exceptions.  It inherits "
":exc:`Exception`."
msgstr ""

#: ../../library/pickle.rst:276
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""

#: ../../library/pickle.rst:279
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""

#: ../../library/pickle.rst:284
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""

#: ../../library/pickle.rst:287
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""

#: ../../library/pickle.rst:292
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, "
":class:`Unpickler` and :class:`PickleBuffer`:"
msgstr ""

#: ../../library/pickle.rst:297
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""

#: ../../library/pickle.rst:299
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""

#: ../../library/pickle.rst:304
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an "
":class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""

#: ../../library/pickle.rst:309
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that"
" the pickle data stream is readable with Python 2."
msgstr ""

#: ../../library/pickle.rst:313
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into"
" *file* as part of the pickle stream."
msgstr ""

#: ../../library/pickle.rst:316
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is"
" serialized in-band, i.e. inside the pickle stream."
msgstr ""

#: ../../library/pickle.rst:321
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""

#: ../../library/pickle.rst:329
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""

#: ../../library/pickle.rst:334
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""

#: ../../library/pickle.rst:336
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""

#: ../../library/pickle.rst:342 ../../library/pickle.rst:443
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""

#: ../../library/pickle.rst:346
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""

#: ../../library/pickle.rst:354
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the "
":mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a "
":attr:`dispatch_table` attribute then this will be used as the default "
"dispatch table for instances of that class."
msgstr ""

#: ../../library/pickle.rst:363
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr ""

#: ../../library/pickle.rst:369
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can"
" optionally return ``NotImplemented`` to fallback on "
":attr:`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""

#: ../../library/pickle.rst:375
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr ""

#: ../../library/pickle.rst:381
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables"
" the usage of memo, therefore speeding the pickling process by not "
"generating superfluous PUT opcodes.  It should not be used with self-"
"referential objects, doing otherwise will cause :class:`Pickler` to recurse "
"infinitely."
msgstr ""

#: ../../library/pickle.rst:387
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""

#: ../../library/pickle.rst:392
msgid "This takes a binary file for reading a pickle data stream."
msgstr ""

#: ../../library/pickle.rst:394
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed."
msgstr ""

#: ../../library/pickle.rst:397
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the "
":class:`io.BufferedIOBase` interface.  Thus *file* can be an on-disk file "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""

#: ../../library/pickle.rst:404
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these "
"8-bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of "
":class:`~datetime.datetime`, :class:`~datetime.date` and "
":class:`~datetime.time` pickled by Python 2."
msgstr ""

#: ../../library/pickle.rst:415
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the"
" *buffer_callback* argument was None when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""

#: ../../library/pickle.rst:420
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects"
" that is consumed each time the pickle stream references an :ref:`out-of-"
"band <pickle-oob>` buffer view.  Such buffers have been given in order to "
"the *buffer_callback* of a Pickler object."
msgstr ""

#: ../../library/pickle.rst:430
msgid ""
"Read the pickled representation of an object from the open file object given"
" in the constructor, and return the reconstituted object hierarchy specified"
" therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""

#: ../../library/pickle.rst:437
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr ""

#: ../../library/pickle.rst:439
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an "
":exc:`UnpicklingError` should be raised."
msgstr ""

#: ../../library/pickle.rst:447
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""

#: ../../library/pickle.rst:452
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref"
":`pickle-restrict` for details."
msgstr ""

#: ../../library/pickle.rst:456
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""

#: ../../library/pickle.rst:460
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref"
":`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""

#: ../../library/pickle.rst:464
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as "
":class:`memoryview`."
msgstr ""

#: ../../library/pickle.rst:468
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5"
" or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""

#: ../../library/pickle.rst:476
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""

#: ../../library/pickle.rst:483
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""

#: ../../library/pickle.rst:489
msgid "What can be pickled and unpickled?"
msgstr ""

#: ../../library/pickle.rst:491
msgid "The following types can be pickled:"
msgstr ""

#: ../../library/pickle.rst:493
msgid "``None``, ``True``, and ``False``"
msgstr ""

#: ../../library/pickle.rst:495
msgid "integers, floating point numbers, complex numbers"
msgstr ""

#: ../../library/pickle.rst:497
msgid "strings, bytes, bytearrays"
msgstr ""

#: ../../library/pickle.rst:499
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr ""

#: ../../library/pickle.rst:501
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not "
":keyword:`lambda`)"
msgstr ""

#: ../../library/pickle.rst:504
msgid "built-in functions defined at the top level of a module"
msgstr ""

#: ../../library/pickle.rst:506
msgid "classes that are defined at the top level of a module"
msgstr ""

#: ../../library/pickle.rst:508
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""

#: ../../library/pickle.rst:512
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a "
":exc:`RecursionError` will be raised in this case.  You can carefully raise "
"this limit with :func:`sys.setrecursionlimit`."
msgstr ""

#: ../../library/pickle.rst:519
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes"
" are pickled.  Thus the defining module must be importable in the unpickling"
" environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""

#: ../../library/pickle.rst:526
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is"
" not restored in the unpickling environment::"
msgstr ""

#: ../../library/pickle.rst:536
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""

#: ../../library/pickle.rst:539
msgid ""
"Similarly, when class instances are pickled, their class's code and data are"
" not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""

#: ../../library/pickle.rst:551
msgid "Pickling Class Instances"
msgstr ""

#: ../../library/pickle.rst:555
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and "
"unpickled."
msgstr ""

#: ../../library/pickle.rst:558
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By"
" default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""

#: ../../library/pickle.rst:573
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""

#: ../../library/pickle.rst:578
msgid ""
"In protocols 2 and newer, classes that implements the "
":meth:`__getnewargs_ex__` method can dictate the values passed to the "
":meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  Those"
" will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../../library/pickle.rst:586
msgid ""
"You should implement this method if the :meth:`__new__` method of your class"
" requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""

#: ../../library/pickle.rst:590
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ""

#: ../../library/pickle.rst:596
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../../library/pickle.rst:600
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""

#: ../../library/pickle.rst:603
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of "
":meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""

#: ../../library/pickle.rst:610
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent,"
" the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""

#: ../../library/pickle.rst:619
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""

#: ../../library/pickle.rst:626
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""

#: ../../library/pickle.rst:630
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""

#: ../../library/pickle.rst:635
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, "
":meth:`__getattribute__`, or :meth:`__setattr__` may be called upon the "
"instance.  In case those methods rely on some internal invariant being true,"
" the type should implement :meth:`__getnewargs__` or "
":meth:`__getnewargs_ex__` to establish such an invariant; otherwise, neither"
" :meth:`__new__` nor :meth:`__init__` will be called."
msgstr ""

#: ../../library/pickle.rst:644
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the "
":meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""

#: ../../library/pickle.rst:650
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and "
":meth:`__setstate__`) whenever possible.  We will show, however, cases where"
" using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""

#: ../../library/pickle.rst:659
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""

#: ../../library/pickle.rst:663
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""

#: ../../library/pickle.rst:668
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""

#: ../../library/pickle.rst:674
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""

#: ../../library/pickle.rst:677
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""

#: ../../library/pickle.rst:680
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as previously described.  If the object has no "
"such method then, the value must be a dictionary and it will be added to the"
" object's :attr:`~object.__dict__` attribute."
msgstr ""

#: ../../library/pickle.rst:685
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)``"
" or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have "
":meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""

#: ../../library/pickle.rst:694
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = value``."
"  This is primarily used for dictionary subclasses, but may be used by other"
" classes as long as they implement :meth:`__setitem__`."
msgstr ""

#: ../../library/pickle.rst:699
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a"
" specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s "
":meth:`__setstate__`."
msgstr ""

#: ../../library/pickle.rst:705
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr ""

#: ../../library/pickle.rst:711
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the "
":meth:`__reduce__` method.  In addition, :meth:`__reduce__` automatically "
"becomes a synonym for the extended version.  The main use for this method is"
" to provide backwards-compatible reduce values for older Python releases."
msgstr ""

#: ../../library/pickle.rst:723
msgid "Persistence of External Objects"
msgstr ""

#: ../../library/pickle.rst:729
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the"
" notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object"
" (for any newer protocol)."
msgstr ""

#: ../../library/pickle.rst:735
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and "
":meth:`~Unpickler.persistent_load` respectively."
msgstr ""

#: ../../library/pickle.rst:740
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have"
" a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""

#: ../../library/pickle.rst:747
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":meth:`~Unpickler.persistent_load` method that takes a persistent ID object "
"and returns the referenced object."
msgstr ""

#: ../../library/pickle.rst:751
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""

#: ../../library/pickle.rst:759
msgid "Dispatch Tables"
msgstr ""

#: ../../library/pickle.rst:761
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""

#: ../../library/pickle.rst:765
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""

#: ../../library/pickle.rst:770
msgid "For example ::"
msgstr ""

#: ../../library/pickle.rst:777
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table"
" which handles the ``SomeClass`` class specially.  Alternatively, the code "
"::"
msgstr ""

#: ../../library/pickle.rst:787
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module is"
" ::"
msgstr ""

#: ../../library/pickle.rst:798
msgid "Handling Stateful Objects"
msgstr ""

#: ../../library/pickle.rst:804
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number"
" and line contents each time its :meth:`!readline` method is called. If a "
":class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The "
":meth:`__setstate__` and :meth:`__getstate__` methods are used to implement "
"this behavior. ::"
msgstr ""

#: ../../library/pickle.rst:850
msgid "A sample usage might be something like this::"
msgstr ""

#: ../../library/pickle.rst:864
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr ""

#: ../../library/pickle.rst:868
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than"
" the object's type, or we may want to customize the pickling of functions "
"and classes."
msgstr ""

#: ../../library/pickle.rst:873
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""

#: ../../library/pickle.rst:878
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and "
":meth:`~Pickler.reducer_override` are defined, then "
":meth:`~Pickler.reducer_override` method takes priority."
msgstr ""

#: ../../library/pickle.rst:883
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called"
" for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, "
":class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and "
":class:`tuple`."
msgstr ""

#: ../../library/pickle.rst:889
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""

#: ../../library/pickle.rst:924
msgid "Out-of-band Buffers"
msgstr ""

#: ../../library/pickle.rst:928
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""

#: ../../library/pickle.rst:935
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""

#: ../../library/pickle.rst:941
msgid "Provider API"
msgstr ""

#: ../../library/pickle.rst:943
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a "
":class:`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for"
" any large data."
msgstr ""

#: ../../library/pickle.rst:948
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""

#: ../../library/pickle.rst:955
msgid "Consumer API"
msgstr ""

#: ../../library/pickle.rst:957
msgid ""
"A communications system can enable custom handling of the "
":class:`PickleBuffer` objects generated when serializing an object graph."
msgstr ""

#: ../../library/pickle.rst:960
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to "
":class:`Pickler` (or to the :func:`dump` or :func:`dumps` function), which "
"will be called with each :class:`PickleBuffer` generated while pickling the "
"object graph.  Buffers accumulated by the *buffer_callback* will not see "
"their data copied into the pickle stream, only a cheap marker will be "
"inserted."
msgstr ""

#: ../../library/pickle.rst:967
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to "
":class:`Unpickler` (or to the :func:`load` or :func:`loads` function), which"
" is an iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original "
":class:`PickleBuffer` objects."
msgstr ""

#: ../../library/pickle.rst:975
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""

#: ../../library/pickle.rst:981
msgid "Example"
msgstr "示例"

#: ../../library/pickle.rst:983
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""

#: ../../library/pickle.rst:1007
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""

#: ../../library/pickle.rst:1011
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""

#: ../../library/pickle.rst:1020
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""

#: ../../library/pickle.rst:1030
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""

#: ../../library/pickle.rst:1037
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ""

#: ../../library/pickle.rst:1043
msgid "Restricting Globals"
msgstr ""

#: ../../library/pickle.rst:1048
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider"
" what this hand-crafted pickle data stream does when loaded::"
msgstr ""

#: ../../library/pickle.rst:1058
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""

#: ../../library/pickle.rst:1062
msgid ""
"For this reason, you may want to control what gets unpickled by customizing "
":meth:`Unpickler.find_class`.  Unlike its name suggests, "
":meth:`Unpickler.find_class` is called whenever a global (i.e., a class or a"
" function) is requested.  Thus it is possible to either completely forbid "
"globals or restrict them to a safe subset."
msgstr ""

#: ../../library/pickle.rst:1068
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the "
":mod:`builtins` module to be loaded::"
msgstr ""

#: ../../library/pickle.rst:1097
msgid "A sample usage of our unpickler working has intended::"
msgstr ""

#: ../../library/pickle.rst:1116
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""

#: ../../library/pickle.rst:1123
msgid "Performance"
msgstr "性能"

#: ../../library/pickle.rst:1125
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature"
" efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""

#: ../../library/pickle.rst:1133
msgid "Examples"
msgstr "示例"

#: ../../library/pickle.rst:1135
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""

#: ../../library/pickle.rst:1151
msgid "The following example reads the resulting pickled data. ::"
msgstr ""

#: ../../library/pickle.rst:1168
msgid "Module :mod:`copyreg`"
msgstr ""

#: ../../library/pickle.rst:1168
msgid "Pickle interface constructor registration for extension types."
msgstr ""

#: ../../library/pickle.rst:1171
msgid "Module :mod:`pickletools`"
msgstr ""

#: ../../library/pickle.rst:1171
msgid "Tools for working with and analyzing pickled data."
msgstr ""

#: ../../library/pickle.rst:1174
msgid "Module :mod:`shelve`"
msgstr "模块 :mod:`shelve`"

#: ../../library/pickle.rst:1174
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr ""

#: ../../library/pickle.rst:1177
msgid "Module :mod:`copy`"
msgstr ""

#: ../../library/pickle.rst:1177
msgid "Shallow and deep object copying."
msgstr ""

#: ../../library/pickle.rst:1179
msgid "Module :mod:`marshal`"
msgstr ""

#: ../../library/pickle.rst:1180
msgid "High-performance serialization of built-in types."
msgstr ""

#: ../../library/pickle.rst:1184
msgid "Footnotes"
msgstr "脚注"

#: ../../library/pickle.rst:1185
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ""

#: ../../library/pickle.rst:1187
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all "
":keyword:`!lambda` functions share the same name:  ``<lambda>``."
msgstr ""

#: ../../library/pickle.rst:1190
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr ""

#: ../../library/pickle.rst:1193
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""

#: ../../library/pickle.rst:1196
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
