# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# stone jing <stonejing1817@gmail.com>, 2021
# Menghua Xiao <arieshout@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# ProgramRipper, 2023
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-02 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/xml.etree.elementtree.rst:2
msgid ":mod:`!xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`!xml.etree.ElementTree` --- ElementTree XML API"

#: ../../library/xml.etree.elementtree.rst:9
msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**源代码：** :source:`Lib/xml/etree/ElementTree.py`"

#: ../../library/xml.etree.elementtree.rst:13
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ":mod:`xml.etree.ElementTree` 模块实现了一个简单高效的API，用于解析和创建XML数据。"

#: ../../library/xml.etree.elementtree.rst:16
msgid "This module will use a fast implementation whenever available."
msgstr "此模块将在可能的情况下使用快速实现。"

#: ../../library/xml.etree.elementtree.rst:19
msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr ":mod:`!xml.etree.cElementTree` 模块已被弃用。"

#: ../../library/xml.etree.elementtree.rst:25
msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
":mod:`xml.etree.ElementTree` 模块对于恶意构建的数据是不安全的。如果需要解析不可信或未经身份验证的数据，请参见 "
":ref:`xml-vulnerabilities` 。"

#: ../../library/xml.etree.elementtree.rst:30
msgid "Tutorial"
msgstr "教程"

#: ../../library/xml.etree.elementtree.rst:32
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"这是一个使用 :mod:`xml.etree.ElementTree` （简称 ``ET`` ）的简短教程。目标是演示模块的一些构建块和基本概念。"

#: ../../library/xml.etree.elementtree.rst:37
msgid "XML tree and elements"
msgstr "XML 树和元素"

#: ../../library/xml.etree.elementtree.rst:39
msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - "
":class:`ElementTree` represents the whole XML document as a tree, and "
":class:`Element` represents a single node in this tree.  Interactions with "
"the whole document (reading and writing to/from files) are usually done on "
"the :class:`ElementTree` level.  Interactions with a single XML element and "
"its sub-elements are done on the :class:`Element` level."
msgstr ""
"XML 是一种继承性的分层数据格式，最自然的表示方法是使用树。 为此， ``ET`` 有两个类 -- :class:`ElementTree` "
"将整个XML文档表示为一个树， :class:`Element` 表示该树中的单个节点。 与整个文档的交互（读写文件）通常在 "
":class:`ElementTree` 级别完成。 与单个 XML 元素及其子元素的交互是在 :class:`Element` 级别完成的。"

#: ../../library/xml.etree.elementtree.rst:50
msgid "Parsing XML"
msgstr "解析 XML"

#: ../../library/xml.etree.elementtree.rst:52
msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr "我们将使用虚构的 :file:`country_data.xml` XML 文档作为本节的示例数据："

#: ../../library/xml.etree.elementtree.rst:54
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:80
msgid "We can import this data by reading from a file::"
msgstr "可以通过从文件中读取来导入此数据："

#: ../../library/xml.etree.elementtree.rst:82
msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"

#: ../../library/xml.etree.elementtree.rst:86
msgid "Or directly from a string::"
msgstr "或直接从字符串中解析："

#: ../../library/xml.etree.elementtree.rst:88
msgid "root = ET.fromstring(country_data_as_string)"
msgstr "root = ET.fromstring(country_data_as_string)"

#: ../../library/xml.etree.elementtree.rst:90
msgid ""
":func:`fromstring` parses XML from a string directly into an "
":class:`Element`, which is the root element of the parsed tree.  Other "
"parsing functions may create an :class:`ElementTree`.  Check the "
"documentation to be sure."
msgstr ""
":func:`fromstring` 将 XML 从字符串直接解析为 :class:`Element` ，该元素是已解析树的根元素。 "
"其他解析函数可能会创建一个 :class:`ElementTree` 。 确切信息请查阅文档。"

#: ../../library/xml.etree.elementtree.rst:94
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr "作为 :class:`Element` ， ``root`` 具有标签和属性字典::"

#: ../../library/xml.etree.elementtree.rst:96
msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"

#: ../../library/xml.etree.elementtree.rst:101
msgid "It also has children nodes over which we can iterate::"
msgstr "还有可以迭代的子节点："

#: ../../library/xml.etree.elementtree.rst:103
msgid ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"

#: ../../library/xml.etree.elementtree.rst:110
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr "子级是可以嵌套的，我们可以通过索引访问特定的子级节点："

#: ../../library/xml.etree.elementtree.rst:112
msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""
">>> root[0][1].text\n"
"'2008'"

#: ../../library/xml.etree.elementtree.rst:118
msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"并非 XML 输入的所有元素都将作为解析树的元素结束。 目前，此模块跳过输入中的任何 XML 注释、处理指令和文档类型声明。 然而，使用这个模块的 "
"API 而不是从 XML 文本解析构建的树可以包含注释和处理指令，生成 XML 输出时同样包含这些注释和处理指令。 可以通过将自定义 "
":class:`TreeBuilder` 实例传递给 :class:`XMLParser` 构造器来访问文档类型声明。"

#: ../../library/xml.etree.elementtree.rst:132
msgid "Pull API for non-blocking parsing"
msgstr "用于非阻塞解析的拉取 API"

#: ../../library/xml.etree.elementtree.rst:134
msgid ""
"Most parsing functions provided by this module require the whole document to"
" be read at once before returning any result.  It is possible to use an "
":class:`XMLParser` and feed data into it incrementally, but it is a push API"
" that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying"
" the convenience of fully constructed :class:`Element` objects."
msgstr ""
"此模块所提供了大多数解析函数都要求在返回任何结果之前一次性读取整个文档。 可以使用 :class:`XMLParser` "
"并以增量方式添加数据，但这是在回调目标上调用方法的推送式 API。 有时用户真正想要的是能够以增量方式解析 XML 而无需阻塞操作，同时享受完整的已构造"
" :class:`Element` 对象。"

#: ../../library/xml.etree.elementtree.rst:142
msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed"
" XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"针对此需求的最强大工具是 :class:`XMLPullParser`。 它不要求通过阻塞式读取来获得 XML 数据，而是通过执行 "
":meth:`XMLPullParser.feed` 调用来增量式地添加数据。  要获得已解析的 XML 元素，应调用 "
":meth:`XMLPullParser.read_events`。 下面是一个示例::"

#: ../../library/xml.etree.elementtree.rst:147
msgid ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"
msgstr ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"

#: ../../library/xml.etree.elementtree.rst:159
msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"常见的用例是针对以非阻塞方式进行的应用程序，其中 XML 是从套接字接收或从某些存储设备增量式读取的。 在这些用例中，阻塞式读取是不可接受的。"

#: ../../library/xml.etree.elementtree.rst:163
msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"因为其非常灵活，:class:`XMLPullParser` 在更简单的用例中使用起来可能并不方便。 如果你不介意你的应用程序在读取 XML "
"数据时造成阻塞但仍希望具有增量解析能力，可以考虑 :func:`iterparse`。 它在你读取大型 XML "
"文档并且不希望将它完全放去内存时会很适用。"

#: ../../library/xml.etree.elementtree.rst:169
msgid ""
"Where *immediate* feedback through events is wanted, calling method "
":meth:`XMLPullParser.flush` can help reduce delay; please make sure to study"
" the related security notes."
msgstr ""
"在需要通过事件获得 *即时* 反馈的场合中，调用方法 :meth:`XMLPullParser.flush` "
"将有助于减少延迟；请注意研究相关的安全说明。"

#: ../../library/xml.etree.elementtree.rst:175
msgid "Finding interesting elements"
msgstr "查找感兴趣的元素"

#: ../../library/xml.etree.elementtree.rst:177
msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` 有一些很有效的方法，可帮助递归遍历其下的所有子树（包括子级，子级的子级，等等）。例如 "
":meth:`Element.iter`::"

#: ../../library/xml.etree.elementtree.rst:181
msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"

#: ../../library/xml.etree.elementtree.rst:190
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's"
" text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` 仅查找当前元素的直接子元素中带有指定标签的元素。 :meth:`Element.find` "
"找带有特定标签的 *第一个* 子级，然后可以用 :attr:`Element.text` 访问元素的文本内容。 :attr:`Element.get` "
"访问元素的属性::"

#: ../../library/xml.etree.elementtree.rst:195
msgid ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"

#: ../../library/xml.etree.elementtree.rst:204
msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr "通过使用 :ref:`XPath <elementtree-xpath>` ，可以更精确地指定要查找的元素。"

#: ../../library/xml.etree.elementtree.rst:208
msgid "Modifying an XML File"
msgstr "修改XML文件"

#: ../../library/xml.etree.elementtree.rst:210
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` 提供了一种构建XML文档并将其写入文件的简单方法。调用 :meth:`ElementTree.write` "
"方法就可以实现。"

#: ../../library/xml.etree.elementtree.rst:213
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for"
" example with :meth:`Element.append`)."
msgstr ""
"创建后可以直接操作 :class:`Element` 对象。例如：使用 :attr:`Element.text` 修改文本字段，使用 "
":meth:`Element.set` 方法添加和修改属性，以及使用  :meth:`Element.append` 添加新的子元素。"

#: ../../library/xml.etree.elementtree.rst:218
msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr "假设我们要为每个国家/地区的中添加一个排名，并在排名元素中添加一个 ``updated`` 属性："

#: ../../library/xml.etree.elementtree.rst:221
msgid ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"

#: ../../library/xml.etree.elementtree.rst:228
#: ../../library/xml.etree.elementtree.rst:272
msgid "Our XML now looks like this:"
msgstr "生成的XML现在看起来像这样："

#: ../../library/xml.etree.elementtree.rst:230
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:256
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr "可以使用 :meth:`Element.remove` 删除元素。假设我们要删除排名高于50的所有国家/地区::"

#: ../../library/xml.etree.elementtree.rst:259
msgid ""
">>> for country in root.findall('country'):\n"
"...     # using root.findall() to avoid removal during traversal\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> for country in root.findall('country'):\n"
"...     # 使用 root.findall() 以避免在遍历期间执行移除\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"

#: ../../library/xml.etree.elementtree.rst:267
msgid ""
"Note that concurrent modification while iterating can lead to problems, just"
" like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"请注意在迭代时进行并发修改可能会导致问题，就像在迭代并修改 Python 列表或字典时那样。 因此，这个示例先通过 ``root.findall()``"
" 收集了所有匹配的元素，在此之后再对匹配项列表进行迭代。"

#: ../../library/xml.etree.elementtree.rst:274
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:294
msgid "Building XML documents"
msgstr "构建 XML 文档"

#: ../../library/xml.etree.elementtree.rst:296
msgid ""
"The :func:`SubElement` function also provides a convenient way to create new"
" sub-elements for a given element::"
msgstr ":func:`SubElement` 函数还提供了一种便捷方法来为给定元素创建新的子元素::"

#: ../../library/xml.etree.elementtree.rst:299
msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"

#: ../../library/xml.etree.elementtree.rst:307
msgid "Parsing XML with Namespaces"
msgstr "解析带有命名空间的 XML"

#: ../../library/xml.etree.elementtree.rst:309
msgid ""
"If the XML input has `namespaces "
"<https://en.wikipedia.org/wiki/XML_namespace>`__, tags and attributes with "
"prefixes in the form ``prefix:sometag`` get expanded to ``{uri}sometag`` "
"where the *prefix* is replaced by the full *URI*. Also, if there is a "
"`default namespace <https://www.w3.org/TR/xml-names/#defaulting>`__, that "
"full URI gets prepended to all of the non-prefixed tags."
msgstr ""
"如果 XML 输入带有 `命名空间 <https://en.wikipedia.org/wiki/XML_namespace>`__，则具有前缀的 "
"``prefix:sometag`` 形式的标记和属性将被扩展为 ``{uri}sometag``，其中 *prefix* 会被完整 *URI* "
"所替换。 并且，如果存在 `默认命名空间 <https://www.w3.org/TR/xml-names/#defaulting>`__，则完整 "
"URI 会被添加到所有未加前缀的标记之前。"

#: ../../library/xml.etree.elementtree.rst:317
msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix"
" \"fictional\" and the other serving as the default namespace:"
msgstr "下面的 XML 示例包含两个命名空间，一个具有前缀 \"fictional\" 而另一个则作为默认命名空间:"

#: ../../library/xml.etree.elementtree.rst:320
msgid ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"

#: ../../library/xml.etree.elementtree.rst:338
msgid ""
"One way to search and explore this XML example is to manually add the URI to"
" every tag or attribute in the xpath of a :meth:`~Element.find` or "
":meth:`~Element.findall`::"
msgstr ""
"搜索和探查这个 XML 示例的一种方式是手动为 :meth:`~Element.find` 或 :meth:`~Element.findall` 的 "
"xpath 中的每个标记或属性添加 URI::"

#: ../../library/xml.etree.elementtree.rst:342
msgid ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"
msgstr ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"

#: ../../library/xml.etree.elementtree.rst:349
msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr "一种更好的方式是搜索带命名空间的 XML 示例创建一个字典来存放你自己的前缀并在搜索函数中使用它们::"

#: ../../library/xml.etree.elementtree.rst:352
msgid ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"
msgstr ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"

#: ../../library/xml.etree.elementtree.rst:361
msgid "These two approaches both output::"
msgstr "这两种方式都会输出::"

#: ../../library/xml.etree.elementtree.rst:363
msgid ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"
msgstr ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"

#: ../../library/xml.etree.elementtree.rst:375
msgid "XPath support"
msgstr "XPath支持"

#: ../../library/xml.etree.elementtree.rst:377
msgid ""
"This module provides limited support for `XPath expressions "
"<https://www.w3.org/TR/xpath>`_ for locating elements in a tree.  The goal "
"is to support a small subset of the abbreviated syntax; a full XPath engine "
"is outside the scope of the module."
msgstr ""
"此模块提供了对 `XPath 表达式 <https://www.w3.org/TR/xpath>`_ 的有限支持用于在树中定位元素。 "
"其目标是支持一个简化语法的较小子集；完整的 XPath 引擎超出了此模块的适用范围。"

#: ../../library/xml.etree.elementtree.rst:383
#: ../../library/xml.etree.elementtree.rst:782
msgid "Example"
msgstr "示例"

#: ../../library/xml.etree.elementtree.rst:385
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the "
":ref:`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"下面是一个演示此模块的部分 XPath 功能的例子。 我们将使用来自 :ref:`解析 XML <elementtree-parsing-xml>` "
"小节的 ``countrydata`` XML 文档::"

#: ../../library/xml.etree.elementtree.rst:389
msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# 最高层级的元素\n"
"root.findall(\".\")\n"
"\n"
"# 最高层级下的 'country' 子元素的所有 'neighbor' 孙子元素\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# 有一个 'year' 子元素的包含 name='Singapore' 的节点\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 是包含 name='Singapore' 的节点的子元素的 'year' 节点\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# 是其父元素的第二个子元素的所有 'neighbor' 节点\n"
"root.findall(\".//neighbor[2]\")"

#: ../../library/xml.etree.elementtree.rst:409
msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr "对于带有命名空间的 XML，应使用通常的限定 ``{namespace}tag`` 标记法::"

#: ../../library/xml.etree.elementtree.rst:411
msgid ""
"# All dublin-core \"title\" tags in the document\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"
msgstr ""
"# 文档中所有的 dublin-core \"title\" 标签\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"

#: ../../library/xml.etree.elementtree.rst:416
msgid "Supported XPath syntax"
msgstr "支持的XPath语法"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Syntax"
msgstr "语法"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Meaning"
msgstr "含意"

#: ../../library/xml.etree.elementtree.rst:423
msgid "``tag``"
msgstr "``tag``"

#: ../../library/xml.etree.elementtree.rst:423
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects"
" all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  "
"``{namespace}*`` selects all tags in the given namespace, ``{*}spam`` "
"selects tags named ``spam`` in any (or no) namespace, and ``{}*`` only "
"selects tags that are not in a namespace."
msgstr ""
"选择具有给定标记的所有子元素。 例如，``spam`` 是选择名为 ``spam`` 的所有子元素，而 ``spam/egg`` 是在名为 "
"``spam`` 的子元素中选择所有名为 ``egg`` 的孙元素，``{*}spam`` 是在任意（或无）命名空间中选择名为 ``spam`` "
"的标记，而 ``{}*`` 是只选择不在一个命名空间中的标记。"

#: ../../library/xml.etree.elementtree.rst:432
msgid "Support for star-wildcards was added."
msgstr "增加了对星号通配符的支持。"

#: ../../library/xml.etree.elementtree.rst:435
msgid "``*``"
msgstr "``*``"

#: ../../library/xml.etree.elementtree.rst:435
msgid ""
"Selects all child elements, including comments and processing instructions."
"  For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr "选择所有子元素，包括注释和处理说明。例如 ``*/egg`` 选择所有名为 ``egg`` 的孙元素。"

#: ../../library/xml.etree.elementtree.rst:439
msgid "``.``"
msgstr "``.``"

#: ../../library/xml.etree.elementtree.rst:439
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr "选择当前节点。这在路径的开头非常有用，用于指示它是相对路径。"

#: ../../library/xml.etree.elementtree.rst:443
msgid "``//``"
msgstr "``//``"

#: ../../library/xml.etree.elementtree.rst:443
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr "选择所有子元素 在当前元素的所有下级中选择所有下级元素。 例如，``.//egg`` 是在整个树中选择所有 ``egg`` 元素。"

#: ../../library/xml.etree.elementtree.rst:447
msgid "``..``"
msgstr "``..``"

#: ../../library/xml.etree.elementtree.rst:447
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr "选择父元素。 如果路径试图前往起始元素的上级（元素的 ``find`` 被调用）则返回 ``None``。"

#: ../../library/xml.etree.elementtree.rst:451
msgid "``[@attrib]``"
msgstr "``[@attrib]``"

#: ../../library/xml.etree.elementtree.rst:451
msgid "Selects all elements that have the given attribute."
msgstr "选择具有给定属性的所有元素。"

#: ../../library/xml.etree.elementtree.rst:453
msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

#: ../../library/xml.etree.elementtree.rst:453
msgid ""
"Selects all elements for which the given attribute has the given value.  The"
" value cannot contain quotes."
msgstr "选择给定属性具有给定值的所有元素。该值不能包含引号。"

#: ../../library/xml.etree.elementtree.rst:457
msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='value']``"

#: ../../library/xml.etree.elementtree.rst:457
msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr "选择给定属性不具有给定值的所有元素。 该值不能包含引号。"

#: ../../library/xml.etree.elementtree.rst:463
msgid "``[tag]``"
msgstr "``[tag]``"

#: ../../library/xml.etree.elementtree.rst:463
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr "选择所有包含 ``tag`` 子元素的元素。只支持直系子元素。"

#: ../../library/xml.etree.elementtree.rst:466
msgid "``[.='text']``"
msgstr "``[.='text']``"

#: ../../library/xml.etree.elementtree.rst:466
msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr "选择完整文本内容等于 ``text`` 的所有元素（包括后代）。"

#: ../../library/xml.etree.elementtree.rst:471
msgid "``[.!='text']``"
msgstr "``[.!='text']``"

#: ../../library/xml.etree.elementtree.rst:471
msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr "选择完整文本内容包括其下级内容不等于给定的 ``text`` 的所有元素。"

#: ../../library/xml.etree.elementtree.rst:477
msgid "``[tag='text']``"
msgstr "``[tag='text']``"

#: ../../library/xml.etree.elementtree.rst:477
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr "选择所有包含名为 ``tag`` 的子元素的元素，这些子元素（包括后代）的完整文本内容等于给定的 ``text`` 。"

#: ../../library/xml.etree.elementtree.rst:481
msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

#: ../../library/xml.etree.elementtree.rst:481
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr "选择具有名为 ``tag`` 的子元素的所有元素，这些子元素包括其下级元素的完整文本内容不等于给定的 ``text``。"

#: ../../library/xml.etree.elementtree.rst:487
msgid "``[position]``"
msgstr "``[position]``"

#: ../../library/xml.etree.elementtree.rst:487
msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"选择位于给定位置的所有元素。 位置可以是一个整数 (1 表示首位)，表达式 ``last()`` (表示末位)，或者相对于末位的位置 (例如 "
"``last()-1``)。"

#: ../../library/xml.etree.elementtree.rst:494
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr "谓词（方括号内的表达式）之前必须带有标签名称，星号或其他谓词。``position`` 谓词前必须有标签名称。"

#: ../../library/xml.etree.elementtree.rst:499
#: ../../library/xml.etree.elementtree.rst:834
msgid "Reference"
msgstr "参考"

#: ../../library/xml.etree.elementtree.rst:504
#: ../../library/xml.etree.elementtree.rst:839
msgid "Functions"
msgstr "函数"

#: ../../library/xml.etree.elementtree.rst:508
msgid ""
"`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_  转换功能。."

#: ../../library/xml.etree.elementtree.rst:510
msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduces the freedom that XML"
" serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"规整化是标准化 XML 输出的一种方式，它允许按字节比较和使用数字签名。 它降低了 XML 序列化器所具有的自由度并改为生成更受约束的 XML "
"表示形式。 主要限制涉及命名空间声明的位置、属性的顺序和可忽略的空白符等。"

#: ../../library/xml.etree.elementtree.rst:516
msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it"
" as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"此函数接受一个 XML 数字字符串 (*xml_data*) 或文件路径或者文件型对象 (*from_file*) "
"作为输入，将其转换为规整形式，并在提供了 *out* 文件（类）对象的情况下将其写到该对象的话，或者如果未提供则将其作为文本字符串返回。 "
"输出文件接受文本而非字节数据。  因此它应当以使用 ``utf-8`` 编码格式的文本模式来打开。"

#: ../../library/xml.etree.elementtree.rst:523
msgid "Typical uses::"
msgstr "典型使用::"

#: ../../library/xml.etree.elementtree.rst:525
msgid ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"
msgstr ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"

#: ../../library/xml.etree.elementtree.rst:534
msgid "The configuration *options* are as follows:"
msgstr "配置选项 *options* 如下:"

#: ../../library/xml.etree.elementtree.rst:536
msgid "*with_comments*: set to true to include comments (default: false)"
msgstr "*with_comments*: 设为真值以包括注释 (默认为假值)"

#: ../../library/xml.etree.elementtree.rst:537
msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr "*strip_text*: 设为真值以去除文本内容前后的空白符"

#: ../../library/xml.etree.elementtree.rst:538
#: ../../library/xml.etree.elementtree.rst:540
msgid "(default: false)"
msgstr "（默认值：否）"

#: ../../library/xml.etree.elementtree.rst:539
msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr "*rewrite_prefixes*: 设为真值以替换带有 \"n{number}\" 前缀的命名空间"

#: ../../library/xml.etree.elementtree.rst:541
msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr "*qname_aware_tags*: 一组可感知限定名称的标记名称，其中的前缀"

#: ../../library/xml.etree.elementtree.rst:542
#: ../../library/xml.etree.elementtree.rst:544
msgid "should be replaced in text content (default: empty)"
msgstr "应当在文本内容中被替换 (默认为空值)"

#: ../../library/xml.etree.elementtree.rst:543
msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr "*qname_aware_attrs*: 一组可感知限定名称的属性名称，其中的前缀"

#: ../../library/xml.etree.elementtree.rst:545
msgid ""
"*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr "*exclude_attrs*: 一组不应当被序列化的属性名称"

#: ../../library/xml.etree.elementtree.rst:546
msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr "*exclude_tags*: 一组不应当被序列化的标记名称"

#: ../../library/xml.etree.elementtree.rst:548
msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr "在上面的选项列表中，\"一组\" 是指任意多项集或包含字符串的可迭代对象，排序是不必要的。"

#: ../../library/xml.etree.elementtree.rst:556
msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"注释元素工厂函数。 这个工厂函数可创建一个特殊元素，它将被标准序列化器当作 XML 注释来进行序列化。 注释字串可以是字节串或是 Unicode "
"字符串。 *text* 是包含注释字串的字符串。 返回一个表示注释的元素实例。"

#: ../../library/xml.etree.elementtree.rst:562
msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain"
" comment nodes if they have been inserted into to the tree using one of the "
":class:`Element` methods."
msgstr ""
"请注意 :class:`XMLParser` 会跳过输入中的注释而不会为其创建注释对象。 :class:`ElementTree` 将只在当使用某个 "
":class:`Element` 方法向树插入了注释节点时才会包含注释节点。"

#: ../../library/xml.etree.elementtree.rst:569
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr "将一个元素树或元素结构体写入到 sys.stdout。 此函数应当只被用于调试。"

#: ../../library/xml.etree.elementtree.rst:572
msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr "实际输出格式是依赖于具体实现的。 在这个版本中，它将以普通 XML 文件的格式写入。"

#: ../../library/xml.etree.elementtree.rst:575
msgid "*elem* is an element tree or an individual element."
msgstr "*elem* 是一个元素树或单独元素。"

#: ../../library/xml.etree.elementtree.rst:577
msgid ""
"The :func:`dump` function now preserves the attribute order specified by the"
" user."
msgstr ":func:`dump` 函数现在会保留用户指定的属性顺序。"

#: ../../library/xml.etree.elementtree.rst:584
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an "
":class:`Element` instance."
msgstr ""
"根据一个字符串常量解析 XML 的节。 与 :func:`XML` 类似。 *text* 是包含 XML 数据的字符串。 *parser* "
"是可选的解析器实例。 如果未给出，则会使用标准 :class:`XMLParser` 解析器。 返回一个 :class:`Element` 实例。"

#: ../../library/xml.etree.elementtree.rst:592
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a"
" list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"根据一个字符串片段序列解析 XML 文档。 *sequence* 是包含 XML 数据片段的列表或其他序列对象。 *parser* 是可选的解析器实例。"
" 如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 返回一个 :class:`Element` 实例。"

#: ../../library/xml.etree.elementtree.rst:602
msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"添加空格到子树来实现树的缩进效果。 这可以被用来生成美化打印的 XML 输出。 *tree* 可以为 Element 或 ElementTree。 "
"*space* 是对应将被插入的每个缩进层级的空格字符串，默认为两个空格符。 要对已缩进的树的部分子树进行缩进，请传入初始缩进层级作为 *level*。"

#: ../../library/xml.etree.elementtree.rst:614
msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr "检测一个对象是否为有效的元素对象。 *element* 是一个元素实例。 如果对象是一个元素对象则返回 ``True``。"

#: ../../library/xml.etree.elementtree.rst:620
msgid ""
"Parses an XML section into an element tree incrementally, and reports what's"
" going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\""
" events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target. Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs; it has a ``root`` attribute that "
"references the root element of the resulting XML tree once *source* is fully"
" read. The iterator has the :meth:`!close` method that closes the internal "
"file object if *source* is a filename."
msgstr ""
"增量式地将一个 XML 节解析为元素树，并向用户报告执行情况。 *source* 是包含 XML 数据的文件名或 :term:`file "
"object`。 *events* 是要往回报告的事件序列。 受支持的事件对应字符串有 ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` 和 ``\"end-ns\"`` (\"ns\" "
"事件用于获取详细的命名空间信息)。 如果省略了 *events*，则只有 ``\"end\"`` 事件会被报告。 *parser* 是可选的解析器实例。"
" 如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 *parser* 必须为 :class:`XMLParser` "
"的子类并且只能使用默认的 :class:`TreeBuilder` 作为目标。 返回一个提供 ``(event, elem)`` 对的 "
":term:`iterator`；它有一个 ``root`` 属性将在 *source* 被完整读取后指向结果 XML 树的根元素。 该迭代器具有 "
":meth:`!close` 方法，可在 *source* 为文件名时关闭内部文件对象。"

#: ../../library/xml.etree.elementtree.rst:636
msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable"
" for applications where blocking reads can't be made.  For fully non-"
"blocking parsing, see :class:`XMLPullParser`."
msgstr ""
"请注意虽然 :func:`iterparse` 是以增量方式构建树，但它会对 *source* (或其所指定的文件) 发出阻塞式读取。 "
"因此，它不适用于不可执行阻塞式读取的应用。 对于完全非阻塞式的解析，请参看 :class:`XMLPullParser`。"

#: ../../library/xml.etree.elementtree.rst:643
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined,"
" but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` 只会确保当发出 \"start\" 事件时看到了开始标记的 \">\" "
"字符，因而在这个点上属性已被定义，但文本容和末尾属性还未被定义。 这同样适用于元素的下级；它们可能存在也可能不存在。"

#: ../../library/xml.etree.elementtree.rst:649
#: ../../library/xml.etree.elementtree.rst:1522
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr "如果你需要已完全填充的元素，请改为查找 \"end\" 事件。"

#: ../../library/xml.etree.elementtree.rst:651
msgid "The *parser* argument."
msgstr "*parser* 参数。"

#: ../../library/xml.etree.elementtree.rst:654
#: ../../library/xml.etree.elementtree.rst:1526
msgid "The ``comment`` and ``pi`` events were added."
msgstr "增加了 ``comment`` 和 ``pi`` 事件。"

#: ../../library/xml.etree.elementtree.rst:657
msgid "Added the :meth:`!close` method."
msgstr "增加了 :meth:`!close` 方法。"

#: ../../library/xml.etree.elementtree.rst:663
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an "
":class:`ElementTree` instance."
msgstr ""
"将一个 XML 的节解析为元素树。 *source* 是包含 XML 数据的文件名或文件对象。 *parser* 是可选的解析器实例。 "
"如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 返回一个 :class:`ElementTree` 实例。"

#: ../../library/xml.etree.elementtree.rst:671
msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if"
" given.  Returns an element instance, representing a processing instruction."
msgstr ""
"PI 元素工厂函数。 这个工厂函数可创建一个特殊元素，它将被当作 XML 处理指令来进行序列化。 *target* 是包含 PI 目标的字符串。 "
"*text* 如果给出则是包含 PI 内容的字符串。 返回一个表示处理指令的元素实例。"

#: ../../library/xml.etree.elementtree.rst:676
msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input"
" instead of creating PI objects for them. An :class:`ElementTree` will only "
"contain processing instruction nodes if they have been inserted into to the "
"tree using one of the :class:`Element` methods."
msgstr ""
"请注意 :class:`XMLParser` 会跳过输入中的处理指令而不会为其创建 PI 对象。 :class:`ElementTree` "
"将只在当使用某个 :class:`Element` 方法向树插入了处理指令节点时才会包含它们。"

#: ../../library/xml.etree.elementtree.rst:684
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at"
" all possible."
msgstr ""
"注册一个命名空间前缀。 这个注册表是全局的，并且任何对应给定前缀或命名空间 URI 的现有映射都会被移除。 *prefix* 是命名空间前缀。 "
"*uri* 是命名空间 URI。 如果可能的话，这个命名空间中的标记和属性将附带给定的前缀来进行序列化。"

#: ../../library/xml.etree.elementtree.rst:695
msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr "子元素工厂函数。 这个函数会创建一个元素实例，并将其添加到现有的元素。"

#: ../../library/xml.etree.elementtree.rst:698
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element"
" attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"元素名、属性名和属性值可以是字节串或 Unicode 字符串。 *parent* 是父元素。 *tag* 是子元素名。 *attrib* "
"是一个可选的字典，其中包含元素属性。  *extra* 包含额外的属性，以关键字参数形式给出。 返回一个元素实例。"

#: ../../library/xml.etree.elementtree.rst:709
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is"
" the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to"
" generate a Unicode string (otherwise, a bytestring is generated).  *method*"
" is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`."
" Returns an (optionally) encoded string containing the XML data."
msgstr ""
"生成一个 XML 元素的字符串表示形式，包括所有子元素。 *element* 是一个 :class:`Element` 实例。 *encoding* "
"[1]_ 是输出编码格式（默认为 US-ASCII）。 请使用 ``encoding=\"unicode\"`` 来生成 Unicode "
"字符串（否则生成字节串）。 *method* 是 ``\"xml\"``, ``\"html\"`` 或 ``\"text\"`` (默认为 "
"``\"xml\"``)。 *xml_declaration*, *default_namespace* 和 "
"*short_empty_elements* 具有与 :meth:`ElementTree.write` 中一致的含义。 返回一个包含 XML "
"数据（可选）已编码的字符串。"

#: ../../library/xml.etree.elementtree.rst:718
#: ../../library/xml.etree.elementtree.rst:745
#: ../../library/xml.etree.elementtree.rst:1199
msgid "Added the *short_empty_elements* parameter."
msgstr "增加了 *short_empty_elements* 形参。"

#: ../../library/xml.etree.elementtree.rst:721
#: ../../library/xml.etree.elementtree.rst:748
msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "增加了 *xml_declaration* 和 *default_namespace* 形参。"

#: ../../library/xml.etree.elementtree.rst:724
msgid ""
"The :func:`tostring` function now preserves the attribute order specified by"
" the user."
msgstr ":func:`tostring` 函数现在会保留用户指定的属性顺序。"

#: ../../library/xml.etree.elementtree.rst:733
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is"
" the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to"
" generate a Unicode string (otherwise, a bytestring is generated).  *method*"
" is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`."
" Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that "
"``b\"\".join(tostringlist(element)) == tostring(element)``."
msgstr ""
"生成一个 XML 元素的字符串表示形式，包括所有子元素。 *element* 是一个 :class:`Element` 实例。 *encoding* "
"[1]_ 是输出编码格式（默认为 US-ASCII）。 请使用 ``encoding=\"unicode\"`` 来生成 Unicode "
"字符串（否则生成字节串）。 *method* 是 ``\"xml\"``, ``\"html\"`` 或 ``\"text\"`` (默认为 "
"``\"xml\"``)。 *xml_declaration*, *default_namespace* 和 "
"*short_empty_elements* 具有与 :meth:`ElementTree.write` 中一致的含义。 返回一个包含 XML "
"数据（可选）已编码字符串的列表。 它并不保证任何特定的序列，除了 ``b\"\".join(tostringlist(element)) == "
"tostring(element)``。"

#: ../../library/xml.etree.elementtree.rst:751
msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ":func:`tostringlist` 函数现在会保留用户指定的属性顺序。"

#: ../../library/xml.etree.elementtree.rst:758
msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard "
":class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"根据一个字符串常量解析 XML 的节。 此函数可被用于在 Python 代码中嵌入“XML 字面值”。 *text* 是包含 XML 数据的字符串。 "
"*parser* 是可选的解析器实例。 如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 返回一个 "
":class:`Element` 实例。"

#: ../../library/xml.etree.elementtree.rst:766
msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML"
" data.  *parser* is an optional parser instance.  If not given, the standard"
" :class:`XMLParser` parser is used.  Returns a tuple containing an "
":class:`Element` instance and a dictionary."
msgstr ""
"根据一个字符串常量解析 XML 的节，并且还将返回一个将元素的 id:s 映射到元素的字典。 *text* 是包含 XML 数据的字符串。 "
"*parser* 是可选的解析器实例。 如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 返回一个包含 "
":class:`Element` 实例和字典的元组。"

#: ../../library/xml.etree.elementtree.rst:776
msgid "XInclude support"
msgstr "XInclude 支持"

#: ../../library/xml.etree.elementtree.rst:778
msgid ""
"This module provides limited support for `XInclude directives "
"<https://www.w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude`"
" helper module.  This module can be used to insert subtrees and text strings"
" into element trees, based on information in the tree."
msgstr ""
"此模块通过 :mod:`xml.etree.ElementInclude` 辅助模块提供了对 `XInclude 指令 "
"<https://www.w3.org/TR/xinclude/>`_ 的有限支持，这个模块可被用来根据元素树的信息在其中插入子树和文本字符串。"

#: ../../library/xml.etree.elementtree.rst:784
msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the "
"``{http://www.w3.org/2001/XInclude}include`` element and set the **parse** "
"attribute to ``\"xml\"``, and use the **href** attribute to specify the "
"document to include."
msgstr ""
"以下是一个演示 XInclude 模块用法的例子。 要在当前文本中包括一个 XML 文档，请使用 "
"``{http://www.w3.org/2001/XInclude}include`` 元素并将 **parse** 属性设为 "
"``\"xml\"``，并使用 **href** 属性来指定要包括的文档。"

#: ../../library/xml.etree.elementtree.rst:786
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:793
msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"默认情况下，**href** 属性会被当作文件名来处理。 你可以使用自定义加载器来覆盖此行为。 还要注意标准辅助器不支持 XPointer 语法。"

#: ../../library/xml.etree.elementtree.rst:795
msgid ""
"To process this file, load it as usual, and pass the root element to the "
":mod:`xml.etree.ElementTree` module:"
msgstr "要处理这个文件，请正常加载它，并将根元素传给 :mod:`xml.etree.ElementTree` 模块:"

#: ../../library/xml.etree.elementtree.rst:797
msgid ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"
msgstr ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"

#: ../../library/xml.etree.elementtree.rst:806
msgid ""
"The ElementInclude module replaces the "
"``{http://www.w3.org/2001/XInclude}include`` element with the root element "
"from the **source.xml** document. The result might look something like this:"
msgstr ""
"ElementInclude 模块使用来自 **source.xml** 文档的根元素替代 "
"``{http://www.w3.org/2001/XInclude}include`` 元素。 结果看起来大概是这样:"

#: ../../library/xml.etree.elementtree.rst:808
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:814
msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr "如果省略了 **parse** 属性，它会取默认的 \"xml\"。 要求有 href 属性。"

#: ../../library/xml.etree.elementtree.rst:816
msgid ""
"To include a text document, use the "
"``{http://www.w3.org/2001/XInclude}include`` element, and set the **parse** "
"attribute to \"text\":"
msgstr ""
"要包括文本文档，请使用 ``{http://www.w3.org/2001/XInclude}include`` 元素，并将 **parse** "
"属性设为 \"text\":"

#: ../../library/xml.etree.elementtree.rst:818
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:825
msgid "The result might look something like:"
msgstr "结果可能如下所示："

#: ../../library/xml.etree.elementtree.rst:827
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:845
msgid ""
"Default loader. This default loader reads an included resource from disk. "
"*href* is a URL.  *parse* is for parse mode either \"xml\" or \"text\". "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``. Returns the expanded resource. If the parse mode is ``\"xml\"``, "
"this is an :class:`~xml.etree.ElementTree.Element` instance. If the parse "
"mode is ``\"text\"``, this is a string. If the loader fails, it can return "
"``None`` or raise an exception."
msgstr ""
"默认的加载器。 这个默认的加载器会从磁盘读取所包括的资源。 *href* 是一个 URL。 *parse* 是取值为 \"xml\" 或 "
"\"text\" 的解析模式。 *encoding* 是可选的文本编码格式。 如果未给出，则编码格式为 ``utf-8``。 返回已扩展的资源。 "
"如果解析模式为 ``\"xml\"``，则它是一个 :class:`~xml.etree.ElementTree.Element` 实例。 "
"如果解析模式为 ``\"text\"``，则它是一个字符串。 如果加载器失败，它可以返回 ``None`` 或者引发异常。"

#: ../../library/xml.etree.elementtree.rst:856
msgid ""
"This function expands XInclude directives in-place in tree pointed by "
"*elem*. *elem* is either the root :class:`~xml.etree.ElementTree.Element` or"
" an :class:`~xml.etree.ElementTree.ElementTree` instance to find such "
"element. *loader* is an optional resource loader.  If omitted, it defaults "
"to :func:`default_loader`. If given, it should be a callable that implements"
" the same interface as :func:`default_loader`.  *base_url* is base URL of "
"the original file, to resolve relative include file references.  *max_depth*"
" is the maximum number of recursive inclusions.  Limited to reduce the risk "
"of malicious content explosion. Pass ``None`` to disable the limitation."
msgstr ""
"这个函数会在 *elem* 指向的树上原地扩展 XInclude 指令。 *elem* 是根 "
":class:`~xml.etree.ElementTree.Element` 或用于查找相应元素的 "
":class:`~xml.etree.ElementTree.ElementTree` 实例。 *loader* 是可选的资源加载器。 "
"如果省略，则它默认为 :func:`default_loader`。 如果给出，则它应当是一个实现了与 :func:`default_loader` "
"相同接口的可调用对象。 *base_url* 是原始文件的基准 URL,用于求解相对的包括文件引用。 *max_depth* 是递归包括的最大数量。 "
"此限制是为了减少恶意内容爆破的风险。 传入 ``None`` 可禁用此限制。"

#: ../../library/xml.etree.elementtree.rst:866
msgid "Added the *base_url* and *max_depth* parameters."
msgstr "增加了 *base_url* 和 *max_depth* 形参。"

#: ../../library/xml.etree.elementtree.rst:873
msgid "Element Objects"
msgstr "元素对象"

#: ../../library/xml.etree.elementtree.rst:881
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr "元素类。 这个类定义了 Element 接口，并提供了这个接口的引用实现。"

#: ../../library/xml.etree.elementtree.rst:884
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"元素名、属性名和属性值可以是字节串或 Unicode 字符串。 *tag* 是元素名。 *attrib* 是一个可选的字典，其中包含元素属性。 "
"*extra* 包含额外的属性，以关键字参数形式给出。"

#: ../../library/xml.etree.elementtree.rst:892
msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr "一个标识此元素意味着何种数据的字符串(换句话说，元素类型)。"

#: ../../library/xml.etree.elementtree.rst:899
msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"这些属性可被用于存放与元素相关联的额外数据。 它们的值通常为字符串但也可以是任何应用专属的对象。 如果元素是基于 XML 文件创建的，*text* "
"属性会存放元素的开始标记及其第一个子元素或结束标记之间的文本，或者为 ``None``，而 *tail* "
"属性会存放元素的结束标记及下一个标记之间的文本，或者为 ``None``。 对于 XML 数据"

#: ../../library/xml.etree.elementtree.rst:907
msgid "<a><b>1<c>2<d/>3</c></b>4</a>"
msgstr "<a><b>1<c>2<d/>3</c></b>4</a>"

#: ../../library/xml.etree.elementtree.rst:911
msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"*a* 元素的 *text* 和 *tail* 属性均为 ``None``，*b* 元素的 *text* 为 ``\"1\"`` 而 *tail* 为 "
"``\"4\"``，*c* 元素的 *text* 为 ``\"2\"`` 而 *tail* 为 ``None``，*d* 元素的 *text* 为 "
"``None`` 而 *tail* 为 ``\"3\"``。"

#: ../../library/xml.etree.elementtree.rst:916
msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr "要获取一个元素的内部文本，请参阅 :meth:`itertext`，例如 ``\"\".join(element.itertext())``。"

#: ../../library/xml.etree.elementtree.rst:919
msgid "Applications may store arbitrary objects in these attributes."
msgstr "应用程序可以将任意对象存入这些属性。"

#: ../../library/xml.etree.elementtree.rst:924
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create"
" the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"一个包含元素属性的字典。 请注意虽然 *attrib* 值总是一个真正可变的 Python 字典，但 ElementTree "
"实现可以选择其他内部表示形式，并只在有需要时才创建字典。 为了发挥这种实现的优势，请在任何可能情况下使用下列字典方法。"

#: ../../library/xml.etree.elementtree.rst:930
msgid "The following dictionary-like methods work on the element attributes."
msgstr "以下字典类方法作用于元素属性。"

#: ../../library/xml.etree.elementtree.rst:935
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr "重设一个元素。 此方法会移除所有子元素，清空所有属性，并将 text 和 tail 属性设为 ``None``。"

#: ../../library/xml.etree.elementtree.rst:941
msgid "Gets the element attribute named *key*."
msgstr "获取名为 *key* 的元素属性。"

#: ../../library/xml.etree.elementtree.rst:943
msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr "返回属性的值，或者如果属性未找到则返回 *default*。"

#: ../../library/xml.etree.elementtree.rst:948
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr "将元素属性以 (name, value) 对序列的形式返回。 所返回属性的顺序任意。"

#: ../../library/xml.etree.elementtree.rst:954
msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr "将元素属性名称以列表的形式返回。 所返回名称的顺序任意。"

#: ../../library/xml.etree.elementtree.rst:960
msgid "Set the attribute *key* on the element to *value*."
msgstr "将元素的 *key* 属性设为 *value*。"

#: ../../library/xml.etree.elementtree.rst:962
msgid "The following methods work on the element's children (subelements)."
msgstr "以下方法作用于元素的下级（子元素）。"

#: ../../library/xml.etree.elementtree.rst:967
msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an "
":class:`Element`."
msgstr ""
"将元素 *subelement* 添加到此元素的子元素内部列表。 如果 *subelement* 不是一个 :class:`Element` 则会引发 "
":exc:`TypeError`。"

#: ../../library/xml.etree.elementtree.rst:974
msgid ""
"Appends *subelements* from an iterable of elements. Raises :exc:`TypeError` "
"if a subelement is not an :class:`Element`."
msgstr ""
"基于一个包含多个元素的可迭代对象添加 *subelements*。 如果某个子元素不是 :class:`Element` 则会引发 "
":exc:`TypeError`。"

#: ../../library/xml.etree.elementtree.rst:982
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or a"
" :ref:`path <elementtree-xpath>`.  Returns an element instance or ``None``."
"  *namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"查找第一个匹配 *match* 的子元素。 *match* 可以是一个标记名称或者 :ref:`路径 <elementtree-xpath>`。 "
"返回一个元素实例或 ``None``。 *namespaces* 是可选的从命名空间前缀到完整名称的映射。 传入 ``''`` "
"作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。"

#: ../../library/xml.etree.elementtree.rst:991
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document order."
"  *namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"根据标记名称或者 :ref:`路径 <elementtree-xpath>` 查找所有匹配的子元素。 返回一个包含所有匹配元素按文档顺序排序的列表。 "
"*namespaces* 是可选的从命名空间前缀到完整名称的映射。 传入 ``''`` 作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。"

#: ../../library/xml.etree.elementtree.rst:1000
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"查找第一个匹配 *match* 的子元素的文本。 *match* 可以是一个标记名称或者 :ref:`路径 <elementtree-xpath>`。 "
"反回第一个匹配的元素的文本内容，或者如果元素未找到则返回 *default*。 请注意如果匹配的元素没有文本内容则会返回一个空字符串。 "
"*namespaces* 是可选的从命名空间前缀到完整名称的映射。 传入 ``''`` 作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。"

#: ../../library/xml.etree.elementtree.rst:1011
msgid ""
"Inserts *subelement* at the given position in this element.  Raises "
":exc:`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"将 *subelement* 插入到此元素的给定位置中。 如果 *subelement* 不是一个 :class:`Element` 则会引发 "
":exc:`TypeError`。"

#: ../../library/xml.etree.elementtree.rst:1017
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"创建一个以当前元素为根元素的树的 :term:`iterator`。 该迭代器将以文档（深度优先）顺序迭代此元素及其所有下级元素。 如果 *tag* "
"不为 ``None`` 或 ``'*'``，则迭代器只返回标记为 *tag* 的元素。 如果树结构在迭代期间被修改，则结果是未定义的。"

#: ../../library/xml.etree.elementtree.rst:1028
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"根据标记名称或者 :ref:`路径 <elementtree-xpath>` 查找所有匹配的子元素。 返回一个按文档顺序产生所有匹配元素的可迭代对象。 "
"*namespaces* 是可选的从命名空间前缀到完整名称的映射。"

#: ../../library/xml.etree.elementtree.rst:1039
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr "创建一个文本迭代器。 该迭代器将按文档顺序遍历此元素及其所有子元素，并返回所有内部文本。"

#: ../../library/xml.etree.elementtree.rst:1047
msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr "创建一个与此元素类型相同的新元素对象。 请不要调用此方法，而应改用 :func:`SubElement` 工厂函数。"

#: ../../library/xml.etree.elementtree.rst:1053
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or"
" contents."
msgstr "从元素中移除 *subelement*。 与 find\\* 方法不同的是此方法会基于实例的标识来比较元素，而不是基于标记的值或内容。"

#: ../../library/xml.etree.elementtree.rst:1057
msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, "
":meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__len__`."
msgstr ""
":class:`Element` 对象还支持下列序列类型方法以配合子元素使用: :meth:`~object.__delitem__`, "
":meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__len__`。"

#: ../../library/xml.etree.elementtree.rst:1062
msgid ""
"Caution: Elements with no subelements will test as ``False``.  In a future "
"release of Python, all elements will test as ``True`` regardless of whether "
"subelements exist.  Instead, prefer explicit ``len(elem)`` or ``elem is not "
"None`` tests.::"
msgstr ""
"注意：没有子元素的元素测试结果将为 ``False``。 在未来的 Python 发布版中，所有元素不论是否存在子元素测试结果都将为 ``True``。"
" 建议改用显式的 ``len(elem)`` 或 ``elem is not None`` 测试。::"

#: ../../library/xml.etree.elementtree.rst:1067
msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"

#: ../../library/xml.etree.elementtree.rst:1075
msgid "Testing the truth value of an Element emits :exc:`DeprecationWarning`."
msgstr "检测元素真值将引发 :exc:`DeprecationWarning`。"

#: ../../library/xml.etree.elementtree.rst:1078
msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"在 Python 3.8 之前，元素的 XML 属性的序列化顺序会通过按其名称排序来强制使其可被预期。 由于现在字典已保证是有序的，这个强制重排序在 "
"Python 3.8 中已被移除以保留原本由用户代码解析或创建的属性顺序。"

#: ../../library/xml.etree.elementtree.rst:1084
msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the "
":func:`canonicalize` function."
msgstr ""
"通常，用户代码应当尽量不依赖于特定的属性顺序，因为 `XML 信息设定 <https://www.w3.org/TR/xml-infoset/>`_ "
"明确地排除了用属性顺序转递信息的做法。 代码应当准备好处理任何输入顺序。 对于要求确定性的 XML "
"输出的情况，例如加密签名或检测数据集等，可以通过规范化 :func:`canonicalize` 函数来进行传统的序列化。"

#: ../../library/xml.etree.elementtree.rst:1092
msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for"
" readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order"
" independently from the Element creation::"
msgstr ""
"对于规范化输出不可用但仍然要求输出特定属性顺序的情况，代码应当设法直接按要求的顺序来创建属性，以避免代码阅读者产生不匹配的感觉。 "
"如果这一点是难以做到的，可以在序列化之前应用以下写法来强制实现顺序不依赖于元素的创建::"

#: ../../library/xml.etree.elementtree.rst:1099
msgid ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # adjust attribute order, e.g. by sorting\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"
msgstr ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # 调整属性顺序，例如通过排序操作\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"

#: ../../library/xml.etree.elementtree.rst:1112
msgid "ElementTree Objects"
msgstr "ElementTree 对象"

#: ../../library/xml.etree.elementtree.rst:1117
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr "ElementTree 包装器类。 这个类表示一个完整的元素层级结构，并添加了一些对于标准 XML 序列化的额外支持。"

#: ../../library/xml.etree.elementtree.rst:1121
msgid ""
"*element* is the root element.  The tree is initialized with the contents of"
" the XML *file* if given."
msgstr "*element* 是根元素。 如果给出 XML *file* 则将使用其内容来初始化树结构。"

#: ../../library/xml.etree.elementtree.rst:1127
msgid ""
"Replaces the root element for this tree.  This discards the current contents"
" of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr "替换该树结构的根元素。 这将丢弃该树结构的当前内容，并将其替换为给定的元素。 请小心使用。  *element* 是一个元素实例。"

#: ../../library/xml.etree.elementtree.rst:1134
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "与 :meth:`Element.find` 类似，从树的根节点开始。"

#: ../../library/xml.etree.elementtree.rst:1139
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr "与 :meth:`Element.findall` 类似，从树的根节点开始。"

#: ../../library/xml.etree.elementtree.rst:1144
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr "与 :meth:`Element.findtext` 类似，从树的根节点开始。"

#: ../../library/xml.etree.elementtree.rst:1149
msgid "Returns the root element for this tree."
msgstr "返回这个树的根元素。"

#: ../../library/xml.etree.elementtree.rst:1154
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to"
" look for (default is to return all elements)."
msgstr "创建并返回根元素的树结构迭代器。 该迭代器会以节顺序遍历这个树的所有元素。 *tag* 是要查找的标记（默认返回所有元素）。"

#: ../../library/xml.etree.elementtree.rst:1161
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr "与 :meth:`Element.iterfind` 类似，从树的根节点开始。"

#: ../../library/xml.etree.elementtree.rst:1168
msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"将一个外部 XML 节载入到此元素树。 *source* 是一个文件名或 :term:`file object`。 *parser* "
"是可选的解析器实例。 如果未给出，则会使用标准的 :class:`XMLParser` 解析器。 返回该节的根元素。"

#: ../../library/xml.etree.elementtree.rst:1178
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a "
":term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"将元素树以 XML 格式写入到文件。 *file* 为文件名，或是以写入模式打开的 :term:`file object`。 *encoding* "
"[1]_ 为输出编码格式 (默认为 US-ASCII)。 *xml_declaration* 控制是否要将 XML 声明添加到文件中。 使用 "
"``False`` 表示从不添加，``True`` 表示总是添加，``None`` 表示仅在非 US-ASCII 或 UTF-8 或 Unicode "
"时添加 (默认为 ``None``)。 *default_namespace* 设置默认 XML 命名空间 (用于 \"xmlns\")。 "
"*method* 为 ``\"xml\"``, ``\"html\"`` 或 ``\"text\"`` (默认为 ``\"xml\"``)。 "
"仅限关键字形参 *short_empty_elements* 控制不包含内容的元素的格式。 如为 ``True`` "
"(默认值)，它们会被输出为单个自结束标记，否则它们会被输出为一对开始/结束标记。"

#: ../../library/xml.etree.elementtree.rst:1192
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"输出是一个字符串 (:class:`str`) 或字节串 (:class:`bytes`)。 由*encoding* 参数来控制。 如果 "
"*encoding* 为 ``\"unicode\"``，则输出是一个字符串；否则为字节串；请注意这可能与 *file* "
"的类型相冲突，如果它是一个打开的 :term:`file object` 的话；请确保你不会试图写入字符串到二进制流或者反向操作。"

#: ../../library/xml.etree.elementtree.rst:1202
msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ":meth:`write` 方法现在会保留用户指定的属性顺序。"

#: ../../library/xml.etree.elementtree.rst:1207
msgid "This is the XML file that is going to be manipulated::"
msgstr "这是将要被操作的 XML 文件::"

#: ../../library/xml.etree.elementtree.rst:1209
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"

#: ../../library/xml.etree.elementtree.rst:1219
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr "修改第一段中的每个链接的 \"target\"  属性的示例::"

#: ../../library/xml.etree.elementtree.rst:1221
msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # 在 body 中找到首次出现的标签 p\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # 返回所有链接的列表\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # 迭代所有已找到的链接\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"

#: ../../library/xml.etree.elementtree.rst:1239
msgid "QName Objects"
msgstr "QName 对象"

#: ../../library/xml.etree.elementtree.rst:1244
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is"
" interpreted as a URI, and this argument is interpreted as a local name. "
":class:`QName` instances are opaque."
msgstr ""
"QName 包装器。 这可被用来包装 QName 属性值，以便在输出中获得适当的命名空间处理。 *text_or_uri* 是一个包含 QName "
"值的字符串，其形式为 {uri}local，或者如果给出了 tag 参数，则为 QName 的 URI 部分。 如果给出了 "
"*tag*，则第一个参数会被解读为 URI，而这个参数会被解读为本地名称。 :class:`QName` 实例是不透明的。"

#: ../../library/xml.etree.elementtree.rst:1256
msgid "TreeBuilder Objects"
msgstr "TreeBuilder 对象"

#: ../../library/xml.etree.elementtree.rst:1262
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"通用元素结构构建器。  此构建器会将包含 start, data, end, comment 和 pi 方法调用的序列转换为格式良好的元素结构。 "
"你可以通过这个类使用一个自定义 XML 解析器或其他 XML 类格式的解析器来构建元素结构。"

#: ../../library/xml.etree.elementtree.rst:1267
msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"如果给出 *element_factory*，它必须为接受两个位置参数的可调用对象：一个标记和一个属性字典。  它预期会返回一个新的元素实例。"

#: ../../library/xml.etree.elementtree.rst:1271
msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true,"
" comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"如果给出 *comment_factory* 和 *pi_factory* 函数，它们的行为应当像 :func:`Comment` 和 "
":func:`ProcessingInstruction` 函数一样创建注释和处理指令。 如果未给出，则将使用默认工厂函数。 当 "
"*insert_comments* 和/或 *insert_pis* 为真值时，如果 comments/pis "
"在根元素之中（但不在其之外）出现则它们将被插入到树中。"

#: ../../library/xml.etree.elementtree.rst:1280
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr "刷新构建器缓存，并返回最高层级的文档元素。 返回一个 :class:`Element` 实例。"

#: ../../library/xml.etree.elementtree.rst:1286
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr "将文本添加到当前元素。 *data* 为要添加的文本。 这应当是一个字节串或 Unicode 字符串。"

#: ../../library/xml.etree.elementtree.rst:1292
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr "关闭当前元素。 *tag* 是元素名称。 返回已关闭的元素。"

#: ../../library/xml.etree.elementtree.rst:1298
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr "打开一个新元素。 *tag* 是元素名称。 *attrs* 是包含元素属性的字典。 返回打开的元素。"

#: ../../library/xml.etree.elementtree.rst:1304
msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr "使用给定的 *text* 创建一条注释。 如果 ``insert_comments`` 为真值，这还会将其添加到树结构中。"

#: ../../library/xml.etree.elementtree.rst:1312
msgid ""
"Creates a process instruction with the given *target* name and *text*. If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr "使用给定的 *target* 名称和 *text* 创建一条处理指令。 如果 ``insert_pis`` 为真值，这还会将其添加到树中。"

#: ../../library/xml.etree.elementtree.rst:1318
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr "此外，自定义的 :class:`TreeBuilder` 对象还提供了以下方法:"

#: ../../library/xml.etree.elementtree.rst:1323
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not"
" exist on the default :class:`TreeBuilder` class."
msgstr ""
"处理一条 doctype 声明。 *name* 为 doctype 名称。 *pubid* 为公有标识。 *system* 为系统标识。 "
"此方法不存在于默认的 :class:`TreeBuilder` 类中。"

#: ../../library/xml.etree.elementtree.rst:1331
msgid ""
"Is called whenever the parser encounters a new namespace declaration, before"
" the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"在定义了 ``start()`` 回调的打开元素的该回调被调用之前，当解析器遇到新的命名空间声明时都会被调用。 *prefix* 对于默认命名空间为 "
"``''`` 或者在其他情况下为被声明的命名空间前缀名称。 *uri* 是命名空间 URI。"

#: ../../library/xml.etree.elementtree.rst:1340
msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr "在声明了命名空间前缀映射的元素的 ``end()`` 回调之后被调用，附带超出作用域的 *prefix* 的名称。"

#: ../../library/xml.etree.elementtree.rst:1352
msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ 写入器。 其参数与 "
":func:`canonicalize` 函数的相同。 这个类并不会构建树结构而是使用 *write* 函数将回调事件直接转换为序列化形式。"

#: ../../library/xml.etree.elementtree.rst:1363
msgid "XMLParser Objects"
msgstr "XMLParser对象"

#: ../../library/xml.etree.elementtree.rst:1368
msgid ""
"This class is the low-level building block of the module.  It uses "
":mod:`xml.parsers.expat` for efficient, event-based parsing of XML.  It can "
"be fed XML data incrementally with the :meth:`feed` method, and parsing "
"events are translated to a push API - by invoking callbacks on the *target* "
"object.  If *target* is omitted, the standard :class:`TreeBuilder` is used. "
"If *encoding* [1]_ is given, the value overrides the encoding specified in "
"the XML file."
msgstr ""
"这个类是此模块的低层级构建单元。 它使用 :mod:`xml.parsers.expat` 来实现高效、基于事件的 XML 解析。  它可以通过 "
":meth:`feed` 方法增量式地收受 XML 数据，并且解析事件会被转换为推送式 API —— 通过在 *target* 对象上发起对回调的调用。"
" 如果省略 *target*，则会使用标准的 :class:`TreeBuilder`。 如果给出了 *encoding* [1]_ ，该值将覆盖在 "
"XML 文件中指定的编码格式。"

#: ../../library/xml.etree.elementtree.rst:1376
msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument is no longer supported."
msgstr ""
"形参现在都是 :ref:`仅限关键字形参 <keyword-only_parameter>`。 *html* 参数不再受支持。argument is "
"no longer supported."

#: ../../library/xml.etree.elementtree.rst:1383
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"结束向解析器提供数据。 返回调用在构造期间传入的 *target* 的 ``close()`` 方法的结果；在默认情况下，这是最高层级的文档元素。"

#: ../../library/xml.etree.elementtree.rst:1390
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "将数据送入解析器。 *data* 是编码后的数据。"

#: ../../library/xml.etree.elementtree.rst:1395
#: ../../library/xml.etree.elementtree.rst:1473
msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used to "
"ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral with "
"Expat (if currently enabled) and triggers a reparse. Disabling reparse "
"deferral has security consequences; please see "
":meth:`xml.parsers.expat.xmlparser.SetReparseDeferralEnabled` for details."
msgstr ""
"触发对之前送入的未解析数据的解析，这可被用于确保更为实时的反馈，尤其是对于 Expat >=2.6.0 的情况。 :meth:`flush` "
"的实现会暂时禁用 Expat 的重新解析延迟（如果当前已启用）并触发重新解析。 禁用重新解析延迟会带来安全性的影响；请参阅 "
":meth:`xml.parsers.expat.xmlparser.SetReparseDeferralEnabled` 了解详情。"

#: ../../library/xml.etree.elementtree.rst:1402
#: ../../library/xml.etree.elementtree.rst:1480
msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using "
":func:`hasattr` if used in code running across a variety of Python versions."
msgstr ""
"请注意 :meth:`flush` 已作为安全修正被向下移植到一些较早的 CPython 发布版。 如果在运行于多个 Python 版本的代码中要用到 "
":meth:`flush` 请使用 :func:`hasattr` 来检查其可用性。"

#: ../../library/xml.etree.elementtree.rst:1410
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data"
" is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for"
" building a tree structure. This is an example of counting the maximum depth"
" of an XML file::"
msgstr ""
":meth:`XMLParser.feed` 会为每个打开的标记调用 *target* 的 ``start(tag, attrs_dict)`` "
"方法，为每个关闭的标记调用它的 ``end(tag)`` 方法，并通过 ``data(data)`` 方法来处理数据。 有关更多受支持的回调方法，请参阅"
" :class:`TreeBuilder` 类。  :meth:`XMLParser.close` 会调用 *target* 的 ``close()``"
" 方法。 :class:`XMLParser` 不仅仅可被用来构建树结构。 下面是一个统计 XML 文件最大深度的示例::"

#: ../../library/xml.etree.elementtree.rst:1418
msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # 解析器的目标对象\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # 针对每个开启标签执行调用。\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # 针对每个关闭标签执行调用。\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # 我们不需要对 data 做任何操作。\n"
"...     def close(self):    # 当所有数据都已被解析时执行调用。\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"

#: ../../library/xml.etree.elementtree.rst:1454
msgid "XMLPullParser Objects"
msgstr "XMLPullParser对象"

#: ../../library/xml.etree.elementtree.rst:1458
msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is"
" similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing"
" events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"适用于非阻塞应用程序的拉取式解析器。 它的输入侧 API 与 :class:`XMLParser` "
"的类似，但不是向回调目标推送调用，:class:`XMLPullParser` 会收集一个解析事件的内部列表并让用户来读取它。 *events* "
"是要报告的事件序列。 受支持的事件字符串有 ``\"start\"``, ``\"end\"``, ``\"comment\"``, "
"``\"pi\"``, ``\"start-ns\"`` 和 ``\"end-ns\"`` (\"ns\" 事件被用于获取详细的命名空间信息)。 如果 "
"*events* 被省略，则只报告 ``\"end\"`` 事件。"

#: ../../library/xml.etree.elementtree.rst:1469
msgid "Feed the given bytes data to the parser."
msgstr "将给定的字节数据送入解析器。"

#: ../../library/xml.etree.elementtree.rst:1489
msgid ""
"Signal the parser that the data stream is terminated. Unlike "
":meth:`XMLParser.close`, this method always returns :const:`None`. Any "
"events not yet retrieved when the parser is closed can still be read with "
":meth:`read_events`."
msgstr ""
"通知解析器数据流已终结。 不同于 :meth:`XMLParser.close`，此方法总是返回 :const:`None`。 "
"当解析器被关闭时任何还未被获取的事件仍可通过 :meth:`read_events` 被读取。"

#: ../../library/xml.etree.elementtree.rst:1496
msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as"
" follows."
msgstr ""
"返回包含在送入解析器的数据中遇到的事件的迭代器。 此迭代器会产生 ``(event, elem)`` 对，其中 *event* 是代表事件类型的字符串 "
"(例如 ``\"end\"``) 而 *elem* 是遇到的 :class:`Element` 对象，或者以下的其他上下文值。"

#: ../../library/xml.etree.elementtree.rst:1502
msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end``: 当前元素。"

#: ../../library/xml.etree.elementtree.rst:1503
msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr "``comment``, ``pi``: 当前注释 / 处理指令"

#: ../../library/xml.etree.elementtree.rst:1504
msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr "``start-ns``: 一个指定所声明命名空间映射的元组 ``(prefix, uri)``。"

#: ../../library/xml.etree.elementtree.rst:1506
msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (这可能在未来版本中改变)"

#: ../../library/xml.etree.elementtree.rst:1508
msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"在之前对 :meth:`read_events` 的调用中提供的事件将不会被再次产生。 "
"事件仅当它们从迭代器中被取出时才会在内部队列中被消费，因此多个读取方对获取自 :meth:`read_events` "
"的迭代器进行平行迭代将产生无法预料的结果。"

#: ../../library/xml.etree.elementtree.rst:1516
msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` 只会确保当发出 \"start\" 事件时看到了开始标记的 \">\" "
"字符，因而在这个点上属性已被定义，但文本内容和末尾属性还未被定义。 这同样适用于元素的下级；它们可能存在也可能不存在。"

#: ../../library/xml.etree.elementtree.rst:1531
msgid "Exceptions"
msgstr "异常"

#: ../../library/xml.etree.elementtree.rst:1535
msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"XML 解析器错误，由此模块中的多个解析方法在解析失败时引发。 此异常的实例的字符串表示将包含用户友好的错误消息。 此外，它将具有下列可用属性:"

#: ../../library/xml.etree.elementtree.rst:1542
msgid ""
"A numeric error code from the expat parser. See the documentation of "
":mod:`xml.parsers.expat` for the list of error codes and their meanings."
msgstr "来自外部解析器的数字错误代码。 请参阅 :mod:`xml.parsers.expat` 的文档查看错误代码列表及它们的含义。"

#: ../../library/xml.etree.elementtree.rst:1547
msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr "一个包含 *line*, *column* 数值的元组，指明错误发生的位置。"

#: ../../library/xml.etree.elementtree.rst:1550
msgid "Footnotes"
msgstr "备注"

#: ../../library/xml.etree.elementtree.rst:1551
msgid ""
"The encoding string included in XML output should conform to the appropriate"
" standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and "
"https://www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"包括在 XML 输出中的编码格式字符串应当符合适当的标准。 例如 \"UTF-8\" 是有效的，但 \"UTF8\" 是无效的。 请参阅 "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl 和 "
"https://www.iana.org/assignments/character-sets/character-sets.xhtml。"
