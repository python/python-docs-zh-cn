# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 05:02+0000\n"
"PO-Revision-Date: 2017-02-16 23:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.mime.rst:2
msgid ":mod:`email.mime`: Creating email and MIME objects from scratch"
msgstr ":mod:`email.mime`: 从头创建电子邮件和 MIME 对象"

#: ../../library/email.mime.rst:7
msgid "**Source code:** :source:`Lib/email/mime/`"
msgstr "**源代码:** :source:`Lib/email/mime/`"

#: ../../library/email.mime.rst:11
msgid ""
"This module is part of the legacy (``Compat32``) email API.  Its "
"functionality is partially replaced by the :mod:`~email.contentmanager` in "
"the new API, but in certain applications these classes may still be useful, "
"even in non-legacy code."
msgstr ""
"此模块是旧版 (``Compat32``) 电子邮件 API 的组成部分。 它的功能在新版 API 中被 "
":mod:`~email.contentmanager` 部分替代，但在某些应用中这些类仍可能有用，即使是在非旧版代码中。"

#: ../../library/email.mime.rst:16
msgid ""
"Ordinarily, you get a message object structure by passing a file or some "
"text to a parser, which parses the text and returns the root message object."
"  However you can also build a complete message structure from scratch, or "
"even individual :class:`~email.message.Message` objects by hand.  In fact, "
"you can also take an existing structure and add new "
":class:`~email.message.Message` objects, move them around, etc.  This makes "
"a very convenient interface for slicing-and-dicing MIME messages."
msgstr ""
"通常，你是通过传递一个文件或一些文本到解析器来获得消息对象结构体的，解析器会解析文本并返回根消息对象。 "
"不过你也可以从头开始构建一个完整的消息结构体，甚至是手动构建单独的 :class:`~email.message.Message` 对象。 "
"实际上，你也可以接受一个现有的结构体并添加新的 :class:`~email.message.Message` 对象并移动它们。 这为切片和分割 "
"MIME 消息提供了非常方便的接口。"

#: ../../library/email.mime.rst:24
msgid ""
"You can create a new object structure by creating "
":class:`~email.message.Message` instances, adding attachments and all the "
"appropriate headers manually.  For MIME messages though, the :mod:`email` "
"package provides some convenient subclasses to make things easier."
msgstr ""
"你可以通过创建 :class:`~email.message.Message` 实例并手动添加附件和所有适当的标头来创建一个新的对象结构体。  不过对于"
" MIME 消息来说，:mod:`email` 包提供了一些便捷子类来让事情变得更容易。"

#: ../../library/email.mime.rst:29
msgid "Here are the classes:"
msgstr "这些类列示如下:"

#: ../../library/email.mime.rst:35
msgid "Module: :mod:`email.mime.base`"
msgstr "模块: :mod:`email.mime.base`"

#: ../../library/email.mime.rst:37
msgid ""
"This is the base class for all the MIME-specific subclasses of "
":class:`~email.message.Message`.  Ordinarily you won't create instances "
"specifically of :class:`MIMEBase`, although you could.  :class:`MIMEBase` is"
" provided primarily as a convenient base class for more specific MIME-aware "
"subclasses."
msgstr ""
"这是 :class:`~email.message.Message` 的所有 MIME 专属子类。 通常你不会创建专门的 "
":class:`MIMEBase` 实例，尽管你可以这样做。 :class:`MIMEBase` 主要被提供用来作为更具体的 MIME "
"感知子类的便捷基类。"

#: ../../library/email.mime.rst:43
msgid ""
"*_maintype* is the :mailheader:`Content-Type` major type (e.g. "
":mimetype:`text` or :mimetype:`image`), and *_subtype* is the :mailheader"
":`Content-Type` minor type  (e.g. :mimetype:`plain` or :mimetype:`gif`).  "
"*_params* is a parameter key/value dictionary and is passed directly to "
":meth:`Message.add_header <email.message.Message.add_header>`."
msgstr ""
"*_maintype* 是 :mailheader:`Content-Type` 的主类型 (例如 :mimetype:`text` 或 "
":mimetype:`image`)，而 *_subtype* 是 :mailheader:`Content-Type` 的次类型 (例如 "
":mimetype:`plain` 或 :mimetype:`gif`)。 *_params* 是一个形参键/值字典并会被直接传递给 "
":meth:`Message.add_header <email.message.Message.add_header>`。"

#: ../../library/email.mime.rst:49
msgid ""
"If *policy* is specified, (defaults to the :class:`compat32 "
"<email.policy.Compat32>` policy) it will be passed to "
":class:`~email.message.Message`."
msgstr ""
"如果指定了 *policy* (默认为 :class:`compat32 <email.policy.Compat32>` 策略)，它将被传递给 "
":class:`~email.message.Message`。"

#: ../../library/email.mime.rst:53
msgid ""
"The :class:`MIMEBase` class always adds a :mailheader:`Content-Type` header "
"(based on *_maintype*, *_subtype*, and *_params*), and a :mailheader:`MIME-"
"Version` header (always set to ``1.0``)."
msgstr ""
":class:`MIMEBase` 类总是会添加一个 :mailheader:`Content-Type` 标头 (基于 *_maintype*, "
"*_subtype* 和 *_params*)，以及一个 :mailheader:`MIME-Version` 标头 (总是设为 ``1.0``)。"

#: ../../library/email.mime.rst:57 ../../library/email.mime.rst:104
#: ../../library/email.mime.rst:135 ../../library/email.mime.rst:169
#: ../../library/email.mime.rst:204 ../../library/email.mime.rst:224
#: ../../library/email.mime.rst:258
msgid "Added *policy* keyword-only parameter."
msgstr "添加了 *policy* 仅限关键字形参。"

#: ../../library/email.mime.rst:65
msgid "Module: :mod:`email.mime.nonmultipart`"
msgstr "模块: :mod:`email.mime.nonmultipart`"

#: ../../library/email.mime.rst:67
msgid ""
"A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate "
"base class for MIME messages that are not :mimetype:`multipart`.  The "
"primary purpose of this class is to prevent the use of the "
":meth:`~email.message.Message.attach` method, which only makes sense for "
":mimetype:`multipart` messages.  If :meth:`~email.message.Message.attach` is"
" called, a :exc:`~email.errors.MultipartConversionError` exception is "
"raised."
msgstr ""
":class:`~email.mime.base.MIMEBase` 的子类，这是用于非 :mimetype:`multipart` MIME "
"消息的中间基类。 这个类的主要目标是避免使用 :meth:`~email.message.Message.attach` 方法，该方法仅对 "
":mimetype:`multipart` 消息有意义。 如果 :meth:`~email.message.Message.attach` "
"被调用，则会引发 :exc:`~email.errors.MultipartConversionError` 异常。"

#: ../../library/email.mime.rst:80
msgid "Module: :mod:`email.mime.multipart`"
msgstr "模块: :mod:`email.mime.multipart`"

#: ../../library/email.mime.rst:82
msgid ""
"A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate "
"base class for MIME messages that are :mimetype:`multipart`.  Optional "
"*_subtype* defaults to :mimetype:`mixed`, but can be used to specify the "
"subtype of the message.  A :mailheader:`Content-Type` header of "
":mimetype:`multipart/_subtype` will be added to the message object.  A "
":mailheader:`MIME-Version` header will also be added."
msgstr ""
":class:`~email.mime.base.MIMEBase` 的子类，这是用于 :mimetype:`multipart` MIME "
"消息的中间基类。 可选的 *_subtype* 默认为 :mimetype:`mixed`，但可被用来指定消息的子类型。 "
"将会在消息对象中添加一个:mimetype:`multipart/_subtype` 的 :mailheader:`Content-Type` 标头。 "
"并还将添加一个 :mailheader:`MIME-Version` 标头。"

#: ../../library/email.mime.rst:89
msgid ""
"Optional *boundary* is the multipart boundary string.  When ``None`` (the "
"default), the boundary is calculated when needed (for example, when the "
"message is serialized)."
msgstr "可选的 *boundary* 是多部分边界字符串。 当为 ``None`` (默认值) 时，则会在必要时（例如当消息被序列化时）计算边界。"

#: ../../library/email.mime.rst:93
msgid ""
"*_subparts* is a sequence of initial subparts for the payload.  It must be "
"possible to convert this sequence to a list.  You can always attach new "
"subparts to the message by using the :meth:`Message.attach "
"<email.message.Message.attach>` method."
msgstr ""
"*_subparts* 是载荷初始子部分的序列。 此序列必须可以被转换为列表。 你总是可以使用 :meth:`Message.attach "
"<email.message.Message.attach>` 方法将新的子部分附加到消息中。"

#: ../../library/email.mime.rst:98 ../../library/email.mime.rst:131
#: ../../library/email.mime.rst:165 ../../library/email.mime.rst:199
#: ../../library/email.mime.rst:222 ../../library/email.mime.rst:253
msgid ""
"Optional *policy* argument defaults to :class:`compat32 "
"<email.policy.Compat32>`."
msgstr "可选的 *policy* 参数默认为 :class:`compat32 <email.policy.Compat32>`。"

#: ../../library/email.mime.rst:100
msgid ""
"Additional parameters for the :mailheader:`Content-Type` header are taken "
"from the keyword arguments, or passed into the *_params* argument, which is "
"a keyword dictionary."
msgstr ""
"用于 :mailheader:`Content-Type` 标头的附加形参会从关键字参数中获取，或者传入到 *_params* "
"参数，该参数是一个关键字的字典。"

#: ../../library/email.mime.rst:113
msgid "Module: :mod:`email.mime.application`"
msgstr "模块: :mod:`email.mime.application`"

#: ../../library/email.mime.rst:115
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the "
":class:`MIMEApplication` class is used to represent MIME message objects of "
"major type :mimetype:`application`.  *_data* is a string containing the raw "
"byte data.  Optional *_subtype* specifies the MIME subtype and defaults to "
":mimetype:`octet-stream`."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子类，:class:`MIMEApplication` 类被用来表示主类型为 :mimetype:`application` 的 MIME 消息。 "
"*_data* 是包含原始字节数据的字符串。 可选的 *_subtype* 指定 MIME 子类型并默认为 :mimetype:`octet-"
"stream`。"

#: ../../library/email.mime.rst:121
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the data for transport.  This callable takes one "
"argument, which is the :class:`MIMEApplication` instance. It should use "
":meth:`~email.message.Message.get_payload` and "
":meth:`~email.message.Message.set_payload` to change the payload to encoded "
"form.  It should also add any :mailheader:`Content-Transfer-Encoding` or "
"other headers to the message object as necessary.  The default encoding is "
"base64.  See the :mod:`email.encoders` module for a list of the built-in "
"encoders."
msgstr ""
"可选的 *_encoder* 是一个可调用对象（即函数），它将执行实际的数据编码以便传输。 这个可调用对象接受一个参数，该参数是 "
":class:`MIMEApplication` 的实例。 它应当使用 "
":meth:`~email.message.Message.get_payload` 和 "
":meth:`~email.message.Message.set_payload` 来将载荷改为已编码形式。 它还应根据需要将任何 "
":mailheader:`Content-Transfer-Encoding` 或其他标头添加到消息对象中。 默认编码格式为 base64。 请参阅 "
":mod:`email.encoders` 模块来查看内置编码器列表。"

#: ../../library/email.mime.rst:133 ../../library/email.mime.rst:167
msgid "*_params* are passed straight through to the base class constructor."
msgstr "*_params* 会被直接传递给基类的构造器。"

#: ../../library/email.mime.rst:144
msgid "Module: :mod:`email.mime.audio`"
msgstr "模块: :mod:`email.mime.audio`"

#: ../../library/email.mime.rst:146
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the "
":class:`MIMEAudio` class is used to create MIME message objects of major "
"type :mimetype:`audio`. *_audiodata* is a string containing the raw audio "
"data.  If this data can be decoded by the standard Python module "
":mod:`sndhdr`, then the subtype will be automatically included in the "
":mailheader:`Content-Type` header. Otherwise you can explicitly specify the "
"audio subtype via the *_subtype* argument.  If the minor type could not be "
"guessed and *_subtype* was not given, then :exc:`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` 的子类，:class:`MIMEAudio` "
"类被用来创建主类型为 :mimetype:`audio` 的 MIME 消息。 *_audiodata* 是包含原始音频数据的字符串。 "
"如果此数据可由标准 Python 模块 :mod:`sndhdr` 来解码，则其子类型将被自动包括在 :mailheader:`Content-"
"Type` 标头中。 在其他情况下你可以通过 *_subtype* 参数显式地指定音频子类型 。 如果无法猜测出主类型并且未给出 "
"*_subtype*，则会引发 :exc:`TypeError`。"

#: ../../library/email.mime.rst:155
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the audio data for transport.  This callable takes one "
"argument, which is the :class:`MIMEAudio` instance. It should use "
":meth:`~email.message.Message.get_payload` and "
":meth:`~email.message.Message.set_payload` to change the payload to encoded "
"form.  It should also add any :mailheader:`Content-Transfer-Encoding` or "
"other headers to the message object as necessary.  The default encoding is "
"base64.  See the :mod:`email.encoders` module for a list of the built-in "
"encoders."
msgstr ""
"可选的 *_encoder* 是一个可调用对象（即函数），它将执行实际的音频数据编码以便传输。  这个可调用对象接受一个参数，该参数是 "
":class:`MIMEAudio` 的实例。 它应当使用 :meth:`~email.message.Message.get_payload` 和 "
":meth:`~email.message.Message.set_payload` 来将载荷改为已编码形式。 它还应根据需要将任何 "
":mailheader:`Content-Transfer-Encoding` 或其他标头添加到消息对象中。 默认编码格式为 base64。 请参阅 "
":mod:`email.encoders` 模块来查看内置编码器列表。"

#: ../../library/email.mime.rst:178
msgid "Module: :mod:`email.mime.image`"
msgstr "模块: :mod:`email.mime.image`"

#: ../../library/email.mime.rst:180
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the "
":class:`MIMEImage` class is used to create MIME message objects of major "
"type :mimetype:`image`. *_imagedata* is a string containing the raw image "
"data.  If this data can be decoded by the standard Python module "
":mod:`imghdr`, then the subtype will be automatically included in the "
":mailheader:`Content-Type` header. Otherwise you can explicitly specify the "
"image subtype via the *_subtype* argument.  If the minor type could not be "
"guessed and *_subtype* was not given, then :exc:`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` 的子类，:class:`MIMEImage` "
"类被用来创建主类型为 :mimetype:`image` 的 MIME 消息对象。 *_imagedata* 是包含原始图像数据的字符串。 "
"如果此数据可由标准 Python 模块 :mod:`imghdr` 来解码，则其子类型将被自动包括在 :mailheader:`Content-"
"Type` 标头中。 在其他情况下你可以通过 *_subtype* 参数显式地指定图像子类型。 如果无法猜测出主类型并且未给出 "
"*_subtype*，则会引发 :exc:`TypeError`。"

#: ../../library/email.mime.rst:189
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the image data for transport.  This callable takes one "
"argument, which is the :class:`MIMEImage` instance. It should use "
":meth:`~email.message.Message.get_payload` and "
":meth:`~email.message.Message.set_payload` to change the payload to encoded "
"form.  It should also add any :mailheader:`Content-Transfer-Encoding` or "
"other headers to the message object as necessary.  The default encoding is "
"base64.  See the :mod:`email.encoders` module for a list of the built-in "
"encoders."
msgstr ""
"可选的 *_encoder* 是一个可调用对象（即函数），它将执行实际的图像数据编码以便传输。 这个可调用对象接受一个参数，该参数是 "
":class:`MIMEImage` 的实例。 它应当使用 :meth:`~email.message.Message.get_payload` 和 "
":meth:`~email.message.Message.set_payload` 来将载荷改为已编码形式。 它还应根据需要将任何 "
":mailheader:`Content-Transfer-Encoding` 或其他标头添加到消息对象中。 默认编码格式为 base64。 请参阅 "
":mod:`email.encoders` 模块来查看内置编码器列表。"

#: ../../library/email.mime.rst:201
msgid ""
"*_params* are passed straight through to the "
":class:`~email.mime.base.MIMEBase` constructor."
msgstr "*_params* 会被直接传递给 :class:`~email.mime.base.MIMEBase` 构造器。"

#: ../../library/email.mime.rst:211
msgid "Module: :mod:`email.mime.message`"
msgstr "模块: :mod:`email.mime.message`"

#: ../../library/email.mime.rst:213
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the "
":class:`MIMEMessage` class is used to create MIME objects of main type "
":mimetype:`message`. *_msg* is used as the payload, and must be an instance "
"of class :class:`~email.message.Message` (or a subclass thereof), otherwise "
"a :exc:`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` 的子类，:class:`MIMEMessage` "
"类被用来创建主类型为 :mimetype:`message` 的 MIME 对象。 *_msg* 将被用作载荷，并且必须为 "
":class:`~email.message.Message` 类（或其子类）的实例，否则会引发 :exc:`TypeError`。"

#: ../../library/email.mime.rst:219
msgid ""
"Optional *_subtype* sets the subtype of the message; it defaults to "
":mimetype:`rfc822`."
msgstr "可选的 *_subtype* 设置消息的子类型；它的默认值为 :mimetype:`rfc822`。"

#: ../../library/email.mime.rst:231
msgid "Module: :mod:`email.mime.text`"
msgstr "模块: :mod:`email.mime.text`"

#: ../../library/email.mime.rst:233
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the "
":class:`MIMEText` class is used to create MIME objects of major type "
":mimetype:`text`. *_text* is the string for the payload.  *_subtype* is the "
"minor type and defaults to :mimetype:`plain`.  *_charset* is the character "
"set of the text and is passed as an argument to the "
":class:`~email.mime.nonmultipart.MIMENonMultipart` constructor; it defaults "
"to ``us-ascii`` if the string contains only ``ascii`` code points, and "
"``utf-8`` otherwise.  The *_charset* parameter accepts either a string or a "
":class:`~email.charset.Charset` instance."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` 的子类，:class:`MIMEText` "
"类被用来创建主类型为 :mimetype:`text` 的 MIME 对象。 *_text* 是用作载荷的字符串。  *_subtype* "
"指定子类型并且默认为 :mimetype:`plain`。 *_charset* 是文本的字符集并会作为参数传递给 "
":class:`~email.mime.nonmultipart.MIMENonMultipart` 构造器；如果该字符串仅包含 ``ascii`` "
"码位则其默认值为 ``us-ascii``，否则为 ``utf-8``。 *_charset* 形参接受一个字符串或是一个 "
":class:`~email.charset.Charset` 实例。"

#: ../../library/email.mime.rst:243
msgid ""
"Unless the *_charset* argument is explicitly set to ``None``, the MIMEText "
"object created will have both a :mailheader:`Content-Type` header with a "
"``charset`` parameter, and a :mailheader:`Content-Transfer-Encoding` header."
"  This means that a subsequent ``set_payload`` call will not result in an "
"encoded payload, even if a charset is passed in the ``set_payload`` command."
"  You can \"reset\" this behavior by deleting the ``Content-Transfer-"
"Encoding`` header, after which a ``set_payload`` call will automatically "
"encode the new payload (and add a new :mailheader:`Content-Transfer-"
"Encoding` header)."
msgstr ""
"除非 *_charset* 参数被显式地设为 ``None``，否则所创建的 MIMEText 对象将同时具有附带 ``charset`` 形参的 "
":mailheader:`Content-Type` 标头，以及 :mailheader:`Content-Transfer-Encoding` 标头。"
" 这意味着后续的 ``set_payload`` 调用将不再产生已编码的载荷，即使它在 ``set_payload`` 命令中被传入。 你可以通过删除 "
"``Content-Transfer-Encoding`` 标头来“重置”此行为，在此之后的 ``set_payload`` "
"调用将自动编码新的载荷（并添加新的 :mailheader:`Content-Transfer-Encoding` 标头）。"

#: ../../library/email.mime.rst:255
msgid "*_charset* also accepts :class:`~email.charset.Charset` instances."
msgstr "*_charset* 也可接受 :class:`~email.charset.Charset` 实例。"
