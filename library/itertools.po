# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Menghua Xiao <arieshout@gmail.com>, 2021
# nick <2330458484@qq.com>, 2021
# ProgramRipper, 2023
# Alpha Du <alphanow@gmail.com>, 2024
# Wulian233 <xiguawulian@gmail.com>, 2024
# zc Jin <zhengcao.jin@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/itertools.rst:2
msgid ""
":mod:`!itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`!itertools` --- 为高效循环创建迭代器的函数"

#: ../../library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired"
" by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"本模块实现一系列 :term:`iterator` ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。"

#: ../../library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。"

#: ../../library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces"
" a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"例如，SML有一个制表工具： ``tabulate(f)``，它可产生一个序列 ``f(0), f(1), ...``。在Python中可以组合 "
":func:`map` 和 :func:`count` 实现： ``map(f, count())``。"

#: ../../library/itertools.rst:34
msgid "**Infinite iterators:**"
msgstr "**无穷迭代器：**"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68
msgid "Iterator"
msgstr "迭代器"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68
msgid "Arguments"
msgstr "实参"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68 ../../library/itertools.rst:77
msgid "Results"
msgstr "结果"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
msgid "Example"
msgstr "示例"

#: ../../library/itertools.rst:39
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:39
msgid "[start[, step]]"
msgstr "[start[, step]]"

#: ../../library/itertools.rst:39
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../../library/itertools.rst:39
msgid "``count(10) → 10 11 12 13 14 ...``"
msgstr "``count(10) → 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:40
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:40
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:40
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:40
msgid "``cycle('ABCD') → A B C D A B C D ...``"
msgstr "``cycle('ABCD') → A B C D A B C D ...``"

#: ../../library/itertools.rst:41
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:41
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:41
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 重复无限次或n次"

#: ../../library/itertools.rst:41
msgid "``repeat(10, 3) → 10 10 10``"
msgstr "``repeat(10, 3) → 10 10 10``"

#: ../../library/itertools.rst:44
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**根据最短输入序列长度停止的迭代器：**"

#: ../../library/itertools.rst:49
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../../library/itertools.rst:49
msgid "p [,func]"
msgstr "p [,func]"

#: ../../library/itertools.rst:49
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../../library/itertools.rst:49
msgid "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"

#: ../../library/itertools.rst:50
msgid ":func:`batched`"
msgstr ":func:`batched`"

#: ../../library/itertools.rst:50
msgid "p, n"
msgstr "p, n"

#: ../../library/itertools.rst:50
msgid "(p0, p1, ..., p_n-1), ..."
msgstr "(p0, p1, ..., p_n-1), ..."

#: ../../library/itertools.rst:50
msgid "``batched('ABCDEFG', n=3) → ABC DEF G``"
msgstr "``batched('ABCDEFG', n=3) → ABC DEF G``"

#: ../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:51 ../../library/itertools.rst:62
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:51 ../../library/itertools.rst:52
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:51
msgid "``chain('ABC', 'DEF') → A B C D E F``"
msgstr "``chain('ABC', 'DEF') → A B C D E F``"

#: ../../library/itertools.rst:52
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../../library/itertools.rst:52 ../../library/itertools.rst:58
msgid "iterable"
msgstr "iterable -- 可迭代对象"

#: ../../library/itertools.rst:52
msgid "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"

#: ../../library/itertools.rst:53
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:53
msgid "data, selectors"
msgstr "data, selectors"

#: ../../library/itertools.rst:53
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:53
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"

#: ../../library/itertools.rst:54
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:54 ../../library/itertools.rst:55
#: ../../library/itertools.rst:60
msgid "predicate, seq"
msgstr "predicate, seq"

#: ../../library/itertools.rst:54
msgid "seq[n], seq[n+1], starting when predicate fails"
msgstr "seq[n], seq[n+1], 从 predicate 未通过时开始"

#: ../../library/itertools.rst:54
msgid "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"

#: ../../library/itertools.rst:55
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../../library/itertools.rst:55
msgid "elements of seq where predicate(elem) fails"
msgstr "predicate(elem) 未通过的 seq 元素"

#: ../../library/itertools.rst:55
msgid "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"
msgstr "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"

#: ../../library/itertools.rst:56
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:56
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: ../../library/itertools.rst:56
msgid "sub-iterators grouped by value of key(v)"
msgstr "根据key(v)值分组的迭代器"

#: ../../library/itertools.rst:56
msgid "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"
msgstr "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"

#: ../../library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]中的元素"

#: ../../library/itertools.rst:57
msgid "``islice('ABCDEFG', 2, None) → C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) → C D E F G``"

#: ../../library/itertools.rst:58
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: ../../library/itertools.rst:58
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: ../../library/itertools.rst:58
msgid "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"

#: ../../library/itertools.rst:59
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:59
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:59
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:59
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"

#: ../../library/itertools.rst:60
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:60
msgid "seq[0], seq[1], until predicate fails"
msgstr "seq[0], seq[1], 直到 predicate 未通过"

#: ../../library/itertools.rst:60
msgid "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"

#: ../../library/itertools.rst:61
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:61
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:61
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn 将一个迭代器拆分为n个迭代器"

#: ../../library/itertools.rst:61
msgid "``tee('ABC', 2) → A B C, A B C``"
msgstr "``tee('ABC', 2) → A B C, A B C``"

#: ../../library/itertools.rst:62
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../../library/itertools.rst:62
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:62
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"

#: ../../library/itertools.rst:65
msgid "**Combinatoric iterators:**"
msgstr "**排列组合迭代器：**"

#: ../../library/itertools.rst:70
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:70
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:70
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "笛卡尔积，相当于嵌套的for循环"

#: ../../library/itertools.rst:71
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:71
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:71
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "长度r元组，所有可能的排列，无重复元素"

#: ../../library/itertools.rst:72
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:72 ../../library/itertools.rst:73
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:72
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "长度r元组，有序，无重复元素"

#: ../../library/itertools.rst:73
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:73
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "长度r元组，有序，元素可重复"

#: ../../library/itertools.rst:77
msgid "Examples"
msgstr "例子"

#: ../../library/itertools.rst:79
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:79
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:80
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:80
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:81
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:81
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:82
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:82
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:89
msgid "Itertool Functions"
msgstr "Itertool 函数"

#: ../../library/itertools.rst:91
msgid ""
"The following functions all construct and return iterators. Some provide "
"streams of infinite length, so they should only be accessed by functions or "
"loops that truncate the stream."
msgstr "下列函数都是构造并返回迭代器。 有些会提供无限长度的流，所以它们应当只通过能截断流的函数或循环来访问。"

#: ../../library/itertools.rst:98
msgid ""
"Make an iterator that returns accumulated sums or accumulated results from "
"other binary functions."
msgstr "创建一个返回累积汇总值或来自其他双目运算函数的累积结果的迭代器。"

#: ../../library/itertools.rst:101
msgid ""
"The *function* defaults to addition.  The *function* should accept two "
"arguments, an accumulated total and a value from the *iterable*."
msgstr "*function* 默认为加法运算。 *function* 应当接受两个参数，即一个累积汇总值和一个来自 *iterable* 的值。"

#: ../../library/itertools.rst:104
msgid ""
"If an *initial* value is provided, the accumulation will start with that "
"value and the output will have one more element than the input iterable."
msgstr "如果提供了 *initial* 值，将从该值开始累积并且输出将比输入可迭代对象多一个元素。"

#: ../../library/itertools.rst:108 ../../library/itertools.rst:181
#: ../../library/itertools.rst:240 ../../library/itertools.rst:283
#: ../../library/itertools.rst:484 ../../library/itertools.rst:519
#: ../../library/itertools.rst:556 ../../library/itertools.rst:632
#: ../../library/itertools.rst:693 ../../library/itertools.rst:774
msgid "Roughly equivalent to::"
msgstr "大致相当于："

#: ../../library/itertools.rst:110
msgid ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"
msgstr ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"

#: ../../library/itertools.rst:129
msgid ""
"To compute a running minimum, set *function* to :func:`min`. For a running "
"maximum, set *function* to :func:`max`. Or for a running product, set "
"*function* to :func:`operator.mul`. To build an `amortization table "
"<https://www.ramseysolutions.com/real-estate/amortization-schedule>`_, "
"accumulate the interest and apply payments:"
msgstr ""
"要计算运行最小值，则将 *function* 设为 :func:`min`。 对于运行最大值，则将 *function* 设为 :func:`max`。"
" 或者对于运行乘积，则将 *function* 设为 :func:`operator.mul`。 对于构建 `分期表 "
"<https://www.ramseysolutions.com/real-estate/amortization-"
"schedule>`_，即累计利息并应用还款额："

#: ../../library/itertools.rst:136
msgid ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# Amortize a 5% loan of 1000 with 10 annual payments of 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"
msgstr ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # 运行最大值\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # 运行乘积\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# 分期偿还利率 5% 总额 1000 的货款，每年还款 10 次，每次 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"

#: ../../library/itertools.rst:149
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr "参考一个类似函数  :func:`functools.reduce`  ，它只返回一个最终累积值。"

#: ../../library/itertools.rst:154
msgid "Added the optional *function* parameter."
msgstr "添加了可选的 *function* 形参。"

#: ../../library/itertools.rst:157
msgid "Added the optional *initial* parameter."
msgstr "添加了可选的 *initial* 形参。"

#: ../../library/itertools.rst:163
msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch may"
" be shorter than *n*."
msgstr "来自 *iterable* 的长度为 *n* 元组形式的批次数据。 最后一个批次可能短于 *n*。"

#: ../../library/itertools.rst:166
msgid ""
"If *strict* is true, will raise a :exc:`ValueError` if the final batch is "
"shorter than *n*."
msgstr "如果 *strict* 为真值，将在最终的批次短于 *n* 时引发 :exc:`ValueError`。"

#: ../../library/itertools.rst:169
msgid ""
"Loops over the input iterable and accumulates data into tuples up to size "
"*n*.  The input is consumed lazily, just enough to fill a batch. The result "
"is yielded as soon as the batch is full or when the input iterable is "
"exhausted:"
msgstr ""
"循环处理输入可迭代对象并将数据积累为长度至多为 *n* 的元组。 输入将被惰性地消耗，能填满一个批次即可。 "
"结果将在批次填满或输入可迭代对象被耗尽时产生:"

#: ../../library/itertools.rst:174
msgid ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"
msgstr ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"

#: ../../library/itertools.rst:183
msgid ""
"def batched(iterable, n, *, strict=False):\n"
"    # batched('ABCDEFG', 3) → ABC DEF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    iterator = iter(iterable)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        if strict and len(batch) != n:\n"
"            raise ValueError('batched(): incomplete batch')\n"
"        yield batch"
msgstr ""
"def batched(iterable, n, *, strict=False):\n"
"    # batched('ABCDEFG', 3) → ABC DEF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    iterator = iter(iterable)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        if strict and len(batch) != n:\n"
"            raise ValueError('batched(): incomplete batch')\n"
"        yield batch"

#: ../../library/itertools.rst:195
msgid "Added the *strict* option."
msgstr "增加了 *strict* 选项。"

#: ../../library/itertools.rst:201
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  This combines multiple data sources into a single iterator."
"  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它会从第一个可迭代对象返回元素直到将其耗尽，接着转到下一个可迭代对象，直到将所有可迭代对象都耗尽为止。 "
"这是将多个数据源合并为单个可迭代器。 大致等价于::"

#: ../../library/itertools.rst:206
msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

#: ../../library/itertools.rst:214
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr "构建类似 :func:`chain` 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于："

#: ../../library/itertools.rst:217
msgid ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

#: ../../library/itertools.rst:225
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "返回由输入 *iterable* 中元素组成长度为 *r* 的子序列。"

#: ../../library/itertools.rst:227
msgid ""
"The output is a subsequence of :func:`product` keeping only entries that are"
" subsequences of the *iterable*.  The length of the output is given by "
":func:`math.comb` which computes ``n! / r! / (n - r)!`` when ``0 ≤ r ≤ n`` "
"or zero when ``r > n``."
msgstr ""
"输出结果是 :func:`product` 的子序列其中只保留属于 *iterable* 的子序列的条目。 输出的长度由 "
":func:`math.comb` 给出，该函数在 ``0 ≤ r ≤ n`` 时为计算 ``n! / r! / (n - r)!`` 而在 ``r >"
" n`` 时为 0。"

#: ../../library/itertools.rst:232
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. If the input *iterable* is sorted, the output"
" tuples will be produced in sorted order."
msgstr ""
"组合元组是根据输入的 *iterable* 的顺序以词典排序方式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按排序后的顺序产生。"

#: ../../library/itertools.rst:236
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, there will be no repeated values within "
"each combination."
msgstr "元素是的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则将每个组合中将不会有重复的值。"

#: ../../library/itertools.rst:242
msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"

#: ../../library/itertools.rst:267
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "返回由输入 *iterable* 中元素组成的长度为 *r* 的子序列，允许每个元素可重复出现。"

#: ../../library/itertools.rst:270
msgid ""
"The output is a subsequence of :func:`product` that keeps only entries that "
"are subsequences (with possible repeated elements) of the *iterable*.  The "
"number of subsequence returned is ``(n + r - 1)! / r! / (n - 1)!`` when ``n "
"> 0``."
msgstr ""
"输出是 :func:`product` 的子序列，其中仅保留也属于 *iterable* 的子序列的条目（可能有重复的元素）。 当 ``n > 0`` "
"时返回的子序列数量为 ``(n + r - 1)! / r! / (n - 1)!``。"

#: ../../library/itertools.rst:275
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. if the input *iterable* is sorted, the output"
" tuples will be produced in sorted order."
msgstr ""
"组合元组是根据输入的 *iterable* 的顺序以词典排序方式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按已排序的顺序产生。"

#: ../../library/itertools.rst:279
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, the generated combinations will also be "
"unique."
msgstr "元素的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则生成的组合也将是唯一的。"

#: ../../library/itertools.rst:285
msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"

#: ../../library/itertools.rst:309
msgid ""
"Make an iterator that returns elements from *data* where the corresponding "
"element in *selectors* is true.  Stops when either the *data* or *selectors*"
" iterables have been exhausted.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回来自 *data* 在 *selectors* 中对应元素为真值的元素。 当 *data* 或 *selectors* "
"可迭代对象被耗尽时将停止。 大致相当于::"

#: ../../library/itertools.rst:314
msgid ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"
msgstr ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"

#: ../../library/itertools.rst:323
msgid ""
"Make an iterator that returns evenly spaced values beginning with *start*. "
"Can be used with :func:`map` to generate consecutive data points or with "
":func:`zip` to add sequence numbers.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回从 *start* 开始的均匀间隔的值。 可与 :func:`map` 配合使用以生成连续的数据点或与 :func:`zip` "
"配合使用以添加序列数字。 大致相当于::"

#: ../../library/itertools.rst:328
msgid ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"
msgstr ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"

#: ../../library/itertools.rst:336
msgid ""
"When counting with floating-point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"当对浮点数计数时，替换为乘法代码有时会有更高的精度，例如: ``(start + step * i for i in count())``。"

#: ../../library/itertools.rst:340
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "增加参数 *step* ，允许非整型。"

#: ../../library/itertools.rst:346
msgid ""
"Make an iterator returning elements from the *iterable* and saving a copy of"
" each.  When the iterable is exhausted, return elements from the saved copy."
"  Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回来自 *iterable* 中的元素并保存每个元素的拷贝。 当 iterable 耗尽时，返回来自已保存拷贝中的元素。 "
"将无限重复进行。 大致相当于::"

#: ../../library/itertools.rst:350
msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"
msgstr ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"

#: ../../library/itertools.rst:362
msgid ""
"This itertool may require significant auxiliary storage (depending on the "
"length of the iterable)."
msgstr "这个迭代工具可能需要很大的辅助存储（取决于 iterable 的长度）。"

#: ../../library/itertools.rst:368
msgid ""
"Make an iterator that drops elements from the *iterable* while the "
"*predicate* is true and afterwards returns every element.  Roughly "
"equivalent to::"
msgstr "创建一个迭代器，它将丢弃来自 *iterable* 中 *predicate* 为真值的元素然后返回每个元素。 大致相当于::"

#: ../../library/itertools.rst:372
msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"
msgstr ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"

#: ../../library/itertools.rst:384
msgid ""
"Note this does not produce *any* output until the predicate first becomes "
"false, so this itertool may have a lengthy start-up time."
msgstr "请注意它将不产生 *任何* 输出直到 predicate 首次变为假值，所以此迭代工具可能具有很长的启动时间。"

#: ../../library/itertools.rst:390
msgid ""
"Make an iterator that filters elements from the *iterable* returning only "
"those for which the *predicate* returns a false value.  If *predicate* is "
"``None``, returns the items that are false.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它过滤来自 *iterable* 的元素从而只返回其中 *predicate* 返回假值的元素。 如果 *predicate* 为 "
"``None``，则返回本身为假值的条目。 大致相当于::"

#: ../../library/itertools.rst:395
msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"

#: ../../library/itertools.rst:408
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element."
"  If not specified or is ``None``, *key* defaults to an identity function "
"and returns the element unchanged.  Generally, the iterable needs to already"
" be sorted on the same key function."
msgstr ""
"创建一个迭代器，返回 *iterable* 中连续的键和组。*key* 是一个计算元素键值函数。如果未指定或为 ``None``，*key* "
"缺省为恒等函数（identity function），返回元素不变。一般来说，*iterable* 需用同一个键值函数预先排序。"

#: ../../library/itertools.rst:414
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix."
"  It generates a break or new group every time the value of the key function"
" changes (which is why it is usually necessary to have sorted the data using"
" the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
":func:`groupby` 操作类似于Unix中的 ``uniq``。当每次 *key* "
"函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP "
"BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。"

#: ../../library/itertools.rst:420
msgid ""
"The returned group is itself an iterator that shares the underlying iterable"
" with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer visible."
"  So, if that data is needed later, it should be stored as a list::"
msgstr ""
"返回的组本身也是一个迭代器，它与 :func:`groupby` 共享底层的可迭代对象。因为源是共享的，当 :func:`groupby` "
"对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表："

#: ../../library/itertools.rst:425
msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # 将 group 迭代器以列表形式保存\n"
"    uniquekeys.append(k)"

#: ../../library/itertools.rst:432
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` 大致相当于："

#: ../../library/itertools.rst:434
msgid ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"
msgstr ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"

#: ../../library/itertools.rst:470
msgid ""
"Make an iterator that returns selected elements from the iterable. Works "
"like sequence slicing but does not support negative values for *start*, "
"*stop*, or *step*."
msgstr ""
"创建一个迭代器，它返回 iterable 的选定元素。 效果与序列切片类似但不支持负的 *start*, *stop* 或 *step* 值。"

#: ../../library/itertools.rst:474
msgid ""
"If *start* is zero or ``None``, iteration starts at zero.  Otherwise, "
"elements from the iterable are skipped until *start* is reached."
msgstr ""
"如果 *start* 为零或为 ``None``，迭代将从零开始。 在其他情况下，iterable 中的元素将被跳过直至到达 *start*。"

#: ../../library/itertools.rst:477
msgid ""
"If *stop* is ``None``, iteration continues until the input is exhausted, if "
"at all.  Otherwise, it stops at the specified position."
msgstr "如果 *stop* 为 ``None``，迭代将持续进行直到输入被耗尽，如果能耗尽的话。 在其他情况下，它将在指定位置停止。"

#: ../../library/itertools.rst:480
msgid ""
"If *step* is ``None``, the step defaults to one.  Elements are returned "
"consecutively unless *step* is set higher than one which results in items "
"being skipped."
msgstr ""
"如果 *step* 为 ``None``，则步长默认为一。 元素将被逐一返回除非 *step* 被设为大于一的数，此情况将导致部分条目被跳过。"

#: ../../library/itertools.rst:486
msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"
msgstr ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"

#: ../../library/itertools.rst:506
msgid ""
"If the input is an iterator, then fully consuming the *islice* advances the "
"input iterator by ``max(start, stop)`` steps regardless of the *step* value."
msgstr ""
"如果输入是一个迭代器，则完全消耗 *islice* 将使输入的迭代器向前执行 ``max(start, stop)`` 步而不管 *step* "
"值是多少。"

#: ../../library/itertools.rst:513
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "返回从输入 *iterable* 中获取的连续重叠对。"

#: ../../library/itertools.rst:515
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two"
" values."
msgstr "输出迭代器中 2 元组的数量将比输入的数量少一个。 如果输入可迭代对象中少于两个值则它将为空。"

#: ../../library/itertools.rst:521
msgid ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"
msgstr ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"

#: ../../library/itertools.rst:536
msgid ""
"Return successive *r* length `permutations of elements "
"<https://www.britannica.com/science/permutation>`_ from the *iterable*."
msgstr ""
"根据 *iterable* 返回连续的 *r* 长度 `元素的排列 "
"<https://www.britannica.com/science/permutation>`_。"

#: ../../library/itertools.rst:539
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr "如果 *r* 未指定或为 ``None`` ，*r* 默认设置为 *iterable* 的长度，这种情况下，生成所有全长排列。"

#: ../../library/itertools.rst:543
msgid ""
"The output is a subsequence of :func:`product` where entries with repeated "
"elements have been filtered out.  The length of the output is given by "
":func:`math.perm` which computes ``n! / (n - r)!`` when ``0 ≤ r ≤ n`` or "
"zero when ``r > n``."
msgstr ""
"输出结果是 :func:`product` 的子序列并已过滤掉其中的重复元素。 输出的长度由 :func:`math.perm` 给出，它在 ``0 ≤"
" r ≤ n`` 时为计算 ``n! / (n - r)!`` 而在 ``r > n`` 时则为零。"

#: ../../library/itertools.rst:548
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*.  If the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""
"排列元组是根据输入的 *iterable* 的顺序以词典排序的形式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按已排序的顺序产生。"

#: ../../library/itertools.rst:552
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, there will be no repeated values within "
"a permutation."
msgstr "元素的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则在排列中就不会有重复的元素。"

#: ../../library/itertools.rst:558
msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"

#: ../../library/itertools.rst:589
msgid ""
"`Cartesian product <https://en.wikipedia.org/wiki/Cartesian_product>`_ of "
"the input iterables."
msgstr "输入可迭代对象的 `笛卡尔乘积 <https://en.wikipedia.org/wiki/Cartesian_product>`_。"

#: ../../library/itertools.rst:592
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"大致相当于生成器表达式中的嵌套循环。例如， ``product(A, B)`` 和 ``((x,y) for x in A for y in B)`` "
"返回结果一样。"

#: ../../library/itertools.rst:595
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing"
" on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。"

#: ../../library/itertools.rst:600
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"要计算可迭代对象自身的笛卡尔积，将可选参数 *repeat* 设定为要重复的次数。例如，``product(A, repeat=4)`` 和 "
"``product(A, A, A, A)`` 是一样的。"

#: ../../library/itertools.rst:604
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr "该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。"

#: ../../library/itertools.rst:607
msgid ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    if repeat < 0:\n"
"        raise ValueError('repeat argument cannot be negative')\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    if repeat < 0:\n"
"        raise ValueError('repeat argument cannot be negative')\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"

#: ../../library/itertools.rst:622
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it"
" is only useful with finite inputs."
msgstr ""
"在 :func:`product` 运行之前，它会完全耗尽输入的可迭代对象，在内存中保留值的临时池以生成结果积。 相应地，它只适用于有限的输入。"

#: ../../library/itertools.rst:629
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr "创建一个持续地返回 *object* 的迭代器。 将会无限期地运行除非指定了 *times* 参数。"

#: ../../library/itertools.rst:634
msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"

#: ../../library/itertools.rst:643
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr "*repeat* 的一个常见用途是向 *map* 或 *zip* 提供一个常量值的流:"

#: ../../library/itertools.rst:646
msgid ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../library/itertools.rst:654
msgid ""
"Make an iterator that computes the *function* using arguments obtained from "
"the *iterable*.  Used instead of :func:`map` when argument parameters have "
"already been \"pre-zipped\" into tuples."
msgstr ""
"创建一个迭代器，它使用从 *iterable* 获取的参数来计算 *function*。 当参数形参已被“预先 zip”为元组时可代替 "
":func:`map` 来使用。"

#: ../../library/itertools.rst:658
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
":func:`map` 和 :func:`starmap` 之间的区别类似于 ``function(a,b)`` 和 ``function(*c)`` "
"之间的差异。 大致相当于::"

#: ../../library/itertools.rst:662
msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"

#: ../../library/itertools.rst:670
msgid ""
"Make an iterator that returns elements from the *iterable* as long as the "
"*predicate* is true.  Roughly equivalent to::"
msgstr "创建一个迭代器，它返回来自 *iterable* 的 *predicate* 为真值的元素。 大致相当于::"

#: ../../library/itertools.rst:673
msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"
msgstr ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"

#: ../../library/itertools.rst:680
msgid ""
"Note, the element that first fails the predicate condition is consumed from "
"the input iterator and there is no way to access it. This could be an issue "
"if an application wants to further consume the input iterator after "
"*takewhile* has been run to exhaustion.  To work around this problem, "
"consider using `more-itertools before_and_after() <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_"
" instead."
msgstr ""
"请注意，第一个未能满足 predicate 条件的元素将从输入迭代器中消耗掉并且没有办法访问它。 当应用程序想在 *takewhile* "
"运行到耗尽后进一步消耗输入迭代器时这可能会导致问题。 要绕过这个问题，可以考虑改用 `more-itertools before_and_after()"
" <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_。"

#: ../../library/itertools.rst:691
msgid "Return *n* independent iterators from a single iterable."
msgstr "从一个可迭代对象中返回 *n* 个独立的迭代器。"

#: ../../library/itertools.rst:695
msgid ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"
msgstr ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"

#: ../../library/itertools.rst:728
msgid ""
"When the input *iterable* is already a tee iterator object, all members of "
"the return tuple are constructed as if they had been produced by the "
"upstream :func:`tee` call.  This \"flattening step\" allows nested "
":func:`tee` calls to share the same underlying data chain and to have a "
"single update step rather than a chain of calls."
msgstr ""
"当输入的 *iterable* 已经是一个 tee 迭代器对象时，将会构造返回元组的所有成员就像它们已被上游的 :func:`tee` 调用所产生那样。"
" 这个“展平步骤”允许嵌套的 :func:`tee` 调用共享相同的下层数据链并仅使用一个更新步骤而非一个调用链。"

#: ../../library/itertools.rst:734
msgid "The flattening property makes tee iterators efficiently peekable:"
msgstr "展平的特征属性使得 tee 迭代器可被高效地查看："

#: ../../library/itertools.rst:736
msgid ""
"def lookahead(tee_iterator):\n"
"     \"Return the next value without moving the input forward\"\n"
"     [forked_iterator] = tee(tee_iterator, 1)\n"
"     return next(forked_iterator)"
msgstr ""
"def lookahead(tee_iterator):\n"
"     \"返回下一个值而不向前获取输入\"\n"
"     [forked_iterator] = tee(tee_iterator, 1)\n"
"     return next(forked_iterator)"

#: ../../library/itertools.rst:743
msgid ""
">>> iterator = iter('abcdef')\n"
">>> [iterator] = tee(iterator, 1)   # Make the input peekable\n"
">>> next(iterator)                  # Move the iterator forward\n"
"'a'\n"
">>> lookahead(iterator)             # Check next value\n"
"'b'\n"
">>> next(iterator)                  # Continue moving forward\n"
"'b'"
msgstr ""
">>> iterator = iter('abcdef')\n"
">>> [iterator] = tee(iterator, 1)   # 使输入可被查看\n"
">>> next(iterator)                  # 向前执行迭代器\n"
"'a'\n"
">>> lookahead(iterator)             # 检查下一个值\n"
"'b'\n"
">>> next(iterator)                  # 继续向前执行\n"
"'b'"

#: ../../library/itertools.rst:754
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when simultaneously using iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` 迭代器不是线程安全的。 当同时使用由同一个 :func:`tee` 调用所返回的迭代器时可能引发 "
":exc:`RuntimeError`，即使原本的 *iterable* 是线程安全的。is threadsafe."

#: ../../library/itertools.rst:758
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use "
":func:`list` instead of :func:`tee`."
msgstr ""
"该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 "
":func:`list` 会比 :func:`tee` 更快。"

#: ../../library/itertools.rst:766
msgid ""
"Make an iterator that aggregates elements from each of the *iterables*."
msgstr "创建一个迭代器，它聚合了来自 *iterables* 中每一项的对应元素。"

#: ../../library/itertools.rst:769
msgid ""
"If the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*.  If not specified, *fillvalue* defaults to ``None``."
msgstr ""
"如果 iterables 中每一项的长度不同，则缺失的值将以 *fillvalue* 填充。 如果未指定，则 *fillvalue* 默认为 "
"``None``。"

#: ../../library/itertools.rst:772
msgid "Iteration continues until the longest iterable is exhausted."
msgstr "迭代将持续进行直至其中最长的可迭代对象被耗尽。"

#: ../../library/itertools.rst:776
msgid ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"
msgstr ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"

#: ../../library/itertools.rst:798
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`zip_longest` function should be wrapped with something that limits "
"the number of calls (for example :func:`islice` or :func:`takewhile`)."
msgstr ""
"如果 iterables 中的每一项可能有无限长度，则 :func:`zip_longest` 函数应当用限制调用次数的代码进行包装（例如 "
":func:`islice` 或 :func:`takewhile` 等）。"

#: ../../library/itertools.rst:806
msgid "Itertools Recipes"
msgstr "itertools 配方"

#: ../../library/itertools.rst:808
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。"

#: ../../library/itertools.rst:811
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``starmap()`` and ``repeat()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and "
":mod:`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""
"这些 itertools 专题的主要目的是教学。 各个专题显示了对单个工具的各种思维方式 — 例如，``chain.from_iterable`` "
"被关联到展平的概念。 这些专题还给出了有关这些工具的组合方式的想法 — 例如，``starmap()`` 和 ``repeat()`` "
"应当如何一起工作。 这些专题还显示了 itertools 与 :mod:`operator` 和 :mod:`collections` "
"模块以及内置迭代工具如 ``map()``, ``filter()``, ``reversed()`` 和 ``enumerate()`` "
"相互配合的使用模式。"

#: ../../library/itertools.rst:820
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``sliding_window()``, ``iter_index()``, and "
"``sieve()`` recipes are being tested to see whether they prove their worth."
msgstr ""
"这些例程的次要目的是作为一个孵化器使用。 ``accumulate()``, ``compress()`` 和 ``pairwise()`` "
"等迭代工具最初就是作为例程引入的。 目前，``sliding_window()``, ``iter_index()`` 和 ``sieve()`` "
"例程正在被测试以确定它们是否堪当大任。"

#: ../../library/itertools.rst:825
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the :pypi:`more-itertools` project found on the Python Package Index::"
msgstr ""
"基本上所有这些配方和许许多多其他配方都可以通过 Python Package Index 上的 :pypi:`more-itertools` "
"项目来安装::"

#: ../../library/itertools.rst:829
msgid "python -m pip install more-itertools"
msgstr "python -m pip install more-itertools"

#: ../../library/itertools.rst:831
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a"
" time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a `functional style "
"<https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_.  High "
"speed is retained by preferring \"vectorized\" building blocks over the use "
"of for-loops and :term:`generators <generator>` which incur interpreter "
"overhead."
msgstr ""
"许多例程提供了与底层工具集相当的高性能。 更好的内存效率是通过每次只处理一个元素而不是将整个可迭代对象放入内存来保证的。 代码量的精简是通过以 "
"`函数式风格 <https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_ "
"来链接工具来实现的。 运行的早速度是通过选择使用“矢量化”构件来取代会导致较大解释器开销的 for 循环和 :term:`生成器 "
"<generator>` 来达成的。"

#: ../../library/itertools.rst:839
msgid ""
"from collections import Counter, deque\n"
"from contextlib import suppress\n"
"from functools import reduce\n"
"from math import comb, prod, sumprod, isqrt\n"
"from operator import itemgetter, getitem, mul, neg\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(function, times=None, *args):\n"
"    \"Repeat calls to a function with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(function, repeat(args))\n"
"    return starmap(function, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True results.\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(itemgetter(0), groupby(iterable))\n"
"    return map(next, map(itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   sequenced = sorted(iterable, key=key, reverse=reverse)\n"
"   return unique_justseen(sequenced, key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # Algorithm credited to George Sakkis\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(function, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator interface.\"\n"
"    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator\n"
"    with suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield function()"
msgstr ""
"from collections import Counter, deque\n"
"from contextlib import suppress\n"
"from functools import reduce\n"
"from math import comb, prod, sumprod, isqrt\n"
"from operator import itemgetter, getitem, mul, neg\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(function, times=None, *args):\n"
"    \"Repeat calls to a function with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(function, repeat(args))\n"
"    return starmap(function, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # 使用以速度 C 消耗迭代器的函数。\n"
"    if n is None:\n"
"        deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True results.\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(itemgetter(0), groupby(iterable))\n"
"    return map(next, map(itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   sequenced = sorted(iterable, key=key, reverse=reverse)\n"
"   return unique_justseen(sequenced, key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # 此算法由 George Sakkis 首创\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(function, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator interface.\"\n"
"    # iter_except(d.popitem, KeyError) → 非阻塞的字典迭代器\n"
"    with suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield function()"

#: ../../library/itertools.rst:1008
msgid "The following recipes have a more mathematical flavor:"
msgstr "下面的例程具有更数学化的风格:"

#: ../../library/itertools.rst:1010
msgid ""
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() → 5 2 2 1 1\n"
"    # multinomial(5, 2, 2, 1, 1) → 83160\n"
"    return prod(map(comb, accumulate(counts), counts))\n"
"\n"
"def powerset(iterable):\n"
"    \"Subsequences of the iterable from shortest to longest.\"\n"
"    # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, columns):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), columns, strict=True)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin.\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(neg, roots))\n"
"    return list(reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and next(factor(n)) == n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n"
msgstr ""
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() → 5 2 2 1 1\n"
"    # multinomial(5, 2, 2, 1, 1) → 83160\n"
"    return prod(map(comb, accumulate(counts), counts))\n"
"\n"
"def powerset(iterable):\n"
"    \"Subsequences of the iterable from shortest to longest.\"\n"
"    # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, columns):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), columns, strict=True)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin.\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(neg, roots))\n"
"    return list(reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and next(factor(n)) == n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n"
