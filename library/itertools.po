# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/itertools.rst:2
msgid ""
":mod:`!itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`!itertools` --- 为高效循环创建迭代器的函数"

#: ../../library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired"
" by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"本模块实现一系列 :term:`iterator` ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。"

#: ../../library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。"

#: ../../library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces"
" a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"例如，SML有一个制表工具： ``tabulate(f)``，它可产生一个序列 ``f(0), f(1), ...``。在Python中可以组合 "
":func:`map` 和 :func:`count` 实现： ``map(f, count())``。"

#: ../../library/itertools.rst:33
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(starmap(operator.mul, zip(vec1, vec2, "
"strict=True)))``."
msgstr ""
"这些工具及其内置对应物也能很好地配合 :mod:`operator` 模块中的快速函数来使用。 例如，乘法运算符可以被映射到两个向量之间执行高效的点积:"
" ``sum(starmap(operator.mul, zip(vec1, vec2, strict=True)))``。"

#: ../../library/itertools.rst:39
msgid "**Infinite iterators:**"
msgstr "**无穷迭代器：**"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:73
msgid "Iterator"
msgstr "迭代器"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:73
msgid "Arguments"
msgstr "实参"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:73 ../../library/itertools.rst:82
msgid "Results"
msgstr "结果"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
msgid "Example"
msgstr "示例"

#: ../../library/itertools.rst:44
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:44
msgid "[start[, step]]"
msgstr "[start[, step]]"

#: ../../library/itertools.rst:44
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../../library/itertools.rst:44
msgid "``count(10) → 10 11 12 13 14 ...``"
msgstr "``count(10) → 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:45
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:45
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:45
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:45
msgid "``cycle('ABCD') → A B C D A B C D ...``"
msgstr "``cycle('ABCD') → A B C D A B C D ...``"

#: ../../library/itertools.rst:46
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:46
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:46
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 重复无限次或n次"

#: ../../library/itertools.rst:46
msgid "``repeat(10, 3) → 10 10 10``"
msgstr "``repeat(10, 3) → 10 10 10``"

#: ../../library/itertools.rst:49
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**根据最短输入序列长度停止的迭代器：**"

#: ../../library/itertools.rst:54
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../../library/itertools.rst:54
msgid "p [,func]"
msgstr "p [,func]"

#: ../../library/itertools.rst:54
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../../library/itertools.rst:54
msgid "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"

#: ../../library/itertools.rst:55
msgid ":func:`batched`"
msgstr ":func:`batched`"

#: ../../library/itertools.rst:55
msgid "p, n"
msgstr "p, n"

#: ../../library/itertools.rst:55
msgid "(p0, p1, ..., p_n-1), ..."
msgstr "(p0, p1, ..., p_n-1), ..."

#: ../../library/itertools.rst:55
msgid "``batched('ABCDEFG', n=3) → ABC DEF G``"
msgstr "``batched('ABCDEFG', n=3) → ABC DEF G``"

#: ../../library/itertools.rst:56
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:56 ../../library/itertools.rst:67
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:56 ../../library/itertools.rst:57
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:56
msgid "``chain('ABC', 'DEF') → A B C D E F``"
msgstr "``chain('ABC', 'DEF') → A B C D E F``"

#: ../../library/itertools.rst:57
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../../library/itertools.rst:57 ../../library/itertools.rst:63
msgid "iterable"
msgstr "iterable -- 可迭代对象"

#: ../../library/itertools.rst:57
msgid "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"

#: ../../library/itertools.rst:58
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:58
msgid "data, selectors"
msgstr "data, selectors"

#: ../../library/itertools.rst:58
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:58
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"

#: ../../library/itertools.rst:59
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:59 ../../library/itertools.rst:60
#: ../../library/itertools.rst:65
msgid "predicate, seq"
msgstr "predicate, seq"

#: ../../library/itertools.rst:59
msgid "seq[n], seq[n+1], starting when predicate fails"
msgstr "seq[n], seq[n+1], 从 predicate 未通过时开始"

#: ../../library/itertools.rst:59
msgid "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"

#: ../../library/itertools.rst:60
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../../library/itertools.rst:60
msgid "elements of seq where predicate(elem) fails"
msgstr "predicate(elem) 未通过的 seq 元素"

#: ../../library/itertools.rst:60
msgid "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"
msgstr "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"

#: ../../library/itertools.rst:61
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:61
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: ../../library/itertools.rst:61
msgid "sub-iterators grouped by value of key(v)"
msgstr "根据key(v)值分组的迭代器"

#: ../../library/itertools.rst:62
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:62
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:62
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]中的元素"

#: ../../library/itertools.rst:62
msgid "``islice('ABCDEFG', 2, None) → C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) → C D E F G``"

#: ../../library/itertools.rst:63
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: ../../library/itertools.rst:63
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: ../../library/itertools.rst:63
msgid "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"

#: ../../library/itertools.rst:64
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:64
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:64
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:64
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"

#: ../../library/itertools.rst:65
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:65
msgid "seq[0], seq[1], until predicate fails"
msgstr "seq[0], seq[1], 直到 predicate 未通过"

#: ../../library/itertools.rst:65
msgid "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"

#: ../../library/itertools.rst:66
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:66
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:66
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn 将一个迭代器拆分为n个迭代器"

#: ../../library/itertools.rst:67
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../../library/itertools.rst:67
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:67
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"

#: ../../library/itertools.rst:70
msgid "**Combinatoric iterators:**"
msgstr "**排列组合迭代器：**"

#: ../../library/itertools.rst:75
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:75
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:75
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "笛卡尔积，相当于嵌套的for循环"

#: ../../library/itertools.rst:76
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:76
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:76
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "长度r元组，所有可能的排列，无重复元素"

#: ../../library/itertools.rst:77
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:77 ../../library/itertools.rst:78
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:77
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "长度r元组，有序，无重复元素"

#: ../../library/itertools.rst:78
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:78
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "长度r元组，有序，元素可重复"

#: ../../library/itertools.rst:82
msgid "Examples"
msgstr "例子"

#: ../../library/itertools.rst:84
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:84
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:85
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:85
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:86
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:86
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:87
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:87
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:94
msgid "Itertool Functions"
msgstr "Itertool 函数"

#: ../../library/itertools.rst:96
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr "下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。"

#: ../../library/itertools.rst:103
msgid ""
"Make an iterator that returns accumulated sums or accumulated results from "
"other binary functions."
msgstr "创建一个返回累积汇总值或来自其他双目运算函数的累积结果的迭代器。"

#: ../../library/itertools.rst:106
msgid ""
"The *function* defaults to addition.  The *function* should accept two "
"arguments, an accumulated total and a value from the *iterable*."
msgstr "*function* 默认为加法运算。 *function* 应当接受两个参数，即一个累积汇总值和一个来自 *iterable* 的值。"

#: ../../library/itertools.rst:109
msgid ""
"If an *initial* value is provided, the accumulation will start with that "
"value and the output will have one more element than the input iterable."
msgstr "如果提供了 *initial* 值，将从该值开始累积并且输出将比输入可迭代对象多一个元素。"

#: ../../library/itertools.rst:113 ../../library/itertools.rst:182
#: ../../library/itertools.rst:236 ../../library/itertools.rst:279
#: ../../library/itertools.rst:476 ../../library/itertools.rst:507
#: ../../library/itertools.rst:542 ../../library/itertools.rst:615
#: ../../library/itertools.rst:676 ../../library/itertools.rst:731
msgid "Roughly equivalent to::"
msgstr "大致相当于："

#: ../../library/itertools.rst:115
msgid ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"
msgstr ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"

#: ../../library/itertools.rst:134
msgid ""
"The *function* argument can be set to :func:`min` for a running minimum, "
":func:`max` for a running maximum, or :func:`operator.mul` for a running "
"product.  `Amortization tables <https://www.ramseysolutions.com/real-"
"estate/amortization-schedule>`_ can be built by accumulating interest and "
"applying payments:"
msgstr ""
"*function* 参数可设为 :func:`min` 表示运行中的最小值，:func:`max` 表示运行中的最大值，或者 "
":func:`operator.mul` 表示运行中的积。 可以通过累积利息并应用付款额来构建  `摊销表 "
"<https://www.ramseysolutions.com/real-estate/amortization-schedule>`_："

#: ../../library/itertools.rst:140
msgid ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# Amortize a 5% loan of 1000 with 10 annual payments of 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"
msgstr ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # 运行最大值\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # 运行乘积\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# 分期偿还利率 5% 总额 1000 的货款，每年还款 10 次，每次 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"

#: ../../library/itertools.rst:153
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr "参考一个类似函数  :func:`functools.reduce`  ，它只返回一个最终累积值。"

#: ../../library/itertools.rst:158
msgid "Added the optional *function* parameter."
msgstr "添加了可选的 *function* 形参。"

#: ../../library/itertools.rst:161
msgid "Added the optional *initial* parameter."
msgstr "添加了可选的 *initial* 形参。"

#: ../../library/itertools.rst:167
msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch may"
" be shorter than *n*."
msgstr "来自 *iterable* 的长度为 *n* 元组形式的批次数据。 最后一个批次可能短于 *n*。"

#: ../../library/itertools.rst:170
msgid ""
"Loops over the input iterable and accumulates data into tuples up to size "
"*n*.  The input is consumed lazily, just enough to fill a batch. The result "
"is yielded as soon as the batch is full or when the input iterable is "
"exhausted:"
msgstr ""
"循环处理输入可迭代对象并将数据积累为长度至多为 *n* 的元组。 输入将被惰性地消耗，能填满一个批次即可。 "
"结果将在批次填满或输入可迭代对象被耗尽时产生:"

#: ../../library/itertools.rst:175
msgid ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"
msgstr ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"

#: ../../library/itertools.rst:184
msgid ""
"def batched(iterable, n):\n"
"    # batched('ABCDEFG', 3) → ABC DEF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    iterator = iter(iterable)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        yield batch"
msgstr ""

#: ../../library/itertools.rst:197
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于："

#: ../../library/itertools.rst:202
msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

#: ../../library/itertools.rst:210
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr "构建类似 :func:`chain` 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于："

#: ../../library/itertools.rst:213
msgid ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

#: ../../library/itertools.rst:221
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "返回由输入 *iterable* 中元素组成长度为 *r* 的子序列。"

#: ../../library/itertools.rst:223
msgid ""
"The output is a subsequence of :func:`product` keeping only entries that are"
" subsequences of the *iterable*.  The length of the output is given by "
":func:`math.comb` which computes ``n! / r! / (n - r)!`` when ``0 ≤ r ≤ n`` "
"or zero when ``r > n``."
msgstr ""
"输出结果是 :func:`product` 的子序列其中只保留属于 *iterable* 的子序列的条目。 输出的长度由 "
":func:`math.comb` 给出，该函数在 ``0 ≤ r ≤ n`` 时为计算 ``n! / r! / (n - r)!`` 而在 ``r >"
" n`` 时为 0。"

#: ../../library/itertools.rst:228
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. If the input *iterable* is sorted, the output"
" tuples will be produced in sorted order."
msgstr ""
"组合元组是根据输入的 *iterable* 的顺序以词典排序方式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按排序后的顺序产生。"

#: ../../library/itertools.rst:232
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, there will be no repeated values within "
"each combination."
msgstr "元素是的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则将每个组合中将不会有重复的值。"

#: ../../library/itertools.rst:238
msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"

#: ../../library/itertools.rst:263
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "返回由输入 *iterable* 中元素组成的长度为 *r* 的子序列，允许每个元素可重复出现。"

#: ../../library/itertools.rst:266
msgid ""
"The output is a subsequence of :func:`product` that keeps only entries that "
"are subsequences (with possible repeated elements) of the *iterable*.  The "
"number of subsequence returned is ``(n + r - 1)! / r! / (n - 1)!`` when ``n "
"> 0``."
msgstr ""
"输出是 :func:`product` 的子序列，其中仅保留也属于 *iterable* 的子序列的条目（可能有重复的元素）。 当 ``n > 0`` "
"时返回的子序列数量为 ``(n + r - 1)! / r! / (n - 1)!``。"

#: ../../library/itertools.rst:271
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. if the input *iterable* is sorted, the output"
" tuples will be produced in sorted order."
msgstr ""
"组合元组是根据输入的 *iterable* 的顺序以词典排序方式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按已排序的顺序产生。"

#: ../../library/itertools.rst:275
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, the generated combinations will also be "
"unique."
msgstr "元素的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则生成的组合也将是唯一的。"

#: ../../library/itertools.rst:281
msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"

#: ../../library/itertools.rst:305
msgid ""
"Make an iterator that returns elements from *data* where the corresponding "
"element in *selectors* is true.  Stops when either the *data* or *selectors*"
" iterables have been exhausted.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回来自 *data* 在 *selectors* 中对应元素为真值的元素。 当 *data* 或 *selectors* "
"可迭代对象被耗尽时将停止。 大致相当于::"

#: ../../library/itertools.rst:310
msgid ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"
msgstr ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"

#: ../../library/itertools.rst:319
msgid ""
"Make an iterator that returns evenly spaced values beginning with *start*. "
"Can be used with :func:`map` to generate consecutive data points or with "
":func:`zip` to add sequence numbers.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回从 *start* 开始的均匀间隔的值。 可与 :func:`map` 配合使用以生成连续的数据点或与 :func:`zip` "
"配合使用以添加序列数字。 大致相当于::"

#: ../../library/itertools.rst:324
msgid ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"
msgstr ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"

#: ../../library/itertools.rst:332
msgid ""
"When counting with floating-point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"当对浮点数计数时，替换为乘法代码有时会有更高的精度，例如: ``(start + step * i for i in count())``。"

#: ../../library/itertools.rst:336
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "增加参数 *step* ，允许非整型。"

#: ../../library/itertools.rst:342
msgid ""
"Make an iterator returning elements from the *iterable* and saving a copy of"
" each.  When the iterable is exhausted, return elements from the saved copy."
"  Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它返回来自 *iterable* 中的元素并保存每个元素的拷贝。 当 iterable 耗尽时，返回来自已保存拷贝中的元素。 "
"将无限重复进行。 大致相当于::"

#: ../../library/itertools.rst:346
msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"
msgstr ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"

#: ../../library/itertools.rst:356
msgid ""
"This itertool may require significant auxiliary storage (depending on the "
"length of the iterable)."
msgstr "这个迭代工具可能需要很大的辅助存储（取决于 iterable 的长度）。"

#: ../../library/itertools.rst:362
msgid ""
"Make an iterator that drops elements from the *iterable* while the "
"*predicate* is true and afterwards returns every element.  Roughly "
"equivalent to::"
msgstr "创建一个迭代器，它将丢弃来自 *iterable* 中 *predicate* 为真值的元素然后返回每个元素。 大致相当于::"

#: ../../library/itertools.rst:366
msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"
msgstr ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"

#: ../../library/itertools.rst:378
msgid ""
"Note this does not produce *any* output until the predicate first becomes "
"false, so this itertool may have a lengthy start-up time."
msgstr "请注意它将不产生 *任何* 输出直到 predicate 首次变为假值，所以此迭代工具可能具有很长的启动时间。"

#: ../../library/itertools.rst:384
msgid ""
"Make an iterator that filters elements from the *iterable* returning only "
"those for which the *predicate* returns a false value.  If *predicate* is "
"``None``, returns the items that are false.  Roughly equivalent to::"
msgstr ""
"创建一个迭代器，它过滤来自 *iterable* 的元素从而只返回其中 *predicate* 返回假值的元素。 如果 *predicate* 为 "
"``None``，则返回本身为假值的条目。 大致相当于::"

#: ../../library/itertools.rst:389
msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"

#: ../../library/itertools.rst:400
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element."
"  If not specified or is ``None``, *key* defaults to an identity function "
"and returns the element unchanged.  Generally, the iterable needs to already"
" be sorted on the same key function."
msgstr ""
"创建一个迭代器，返回 *iterable* 中连续的键和组。*key* 是一个计算元素键值函数。如果未指定或为 ``None``，*key* "
"缺省为恒等函数（identity function），返回元素不变。一般来说，*iterable* 需用同一个键值函数预先排序。"

#: ../../library/itertools.rst:406
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix."
"  It generates a break or new group every time the value of the key function"
" changes (which is why it is usually necessary to have sorted the data using"
" the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
":func:`groupby` 操作类似于Unix中的 ``uniq``。当每次 *key* "
"函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP "
"BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。"

#: ../../library/itertools.rst:412
msgid ""
"The returned group is itself an iterator that shares the underlying iterable"
" with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer visible."
"  So, if that data is needed later, it should be stored as a list::"
msgstr ""
"返回的组本身也是一个迭代器，它与 :func:`groupby` 共享底层的可迭代对象。因为源是共享的，当 :func:`groupby` "
"对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表："

#: ../../library/itertools.rst:417
msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # 将 group 迭代器以列表形式保存\n"
"    uniquekeys.append(k)"

#: ../../library/itertools.rst:424
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` 大致相当于："

#: ../../library/itertools.rst:426
msgid ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"
msgstr ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"

#: ../../library/itertools.rst:462
msgid ""
"Make an iterator that returns selected elements from the iterable. Works "
"like sequence slicing but does not support negative values for *start*, "
"*stop*, or *step*."
msgstr ""
"创建一个迭代器，它返回 iterable 的选定元素。 效果与序列切片类似但不支持负的 *start*, *stop* 或 *step* 值。"

#: ../../library/itertools.rst:466
msgid ""
"If *start* is zero or ``None``, iteration starts at zero.  Otherwise, "
"elements from the iterable are skipped until *start* is reached."
msgstr ""
"如果 *start* 为零或为 ``None``，迭代将从零开始。 在其他情况下，iterable 中的元素将被跳过直至到达 *start*。"

#: ../../library/itertools.rst:469
msgid ""
"If *stop* is ``None``, iteration continues until the iterator is exhausted, "
"if at all.  Otherwise, it stops at the specified position."
msgstr "如果 *stop* 为 ``None``，迭代将持续进行直至迭代器被完全耗尽。 在其他情况下，它将在指定位置停止。"

#: ../../library/itertools.rst:472
msgid ""
"If *step* is ``None``, the step defaults to one.  Elements are returned "
"consecutively unless *step* is set higher than one which results in items "
"being skipped."
msgstr ""
"如果 *step* 为 ``None``，则步长默认为一。 元素将被逐一返回除非 *step* 被设为大于一的数，此情况将导致部分条目被跳过。"

#: ../../library/itertools.rst:478
msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"
msgstr ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"

#: ../../library/itertools.rst:501
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "返回从输入 *iterable* 中获取的连续重叠对。"

#: ../../library/itertools.rst:503
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two"
" values."
msgstr "输出迭代器中 2 元组的数量将比输入的数量少一个。 如果输入可迭代对象中少于两个值则它将为空。"

#: ../../library/itertools.rst:509
msgid ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"
msgstr ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"

#: ../../library/itertools.rst:522
msgid ""
"Return successive *r* length `permutations of elements "
"<https://www.britannica.com/science/permutation>`_ from the *iterable*."
msgstr ""
"根据 *iterable* 返回连续的 *r* 长度 `元素的排列 "
"<https://www.britannica.com/science/permutation>`_。"

#: ../../library/itertools.rst:525
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr "如果 *r* 未指定或为 ``None`` ，*r* 默认设置为 *iterable* 的长度，这种情况下，生成所有全长排列。"

#: ../../library/itertools.rst:529
msgid ""
"The output is a subsequence of :func:`product` where entries with repeated "
"elements have been filtered out.  The length of the output is given by "
":func:`math.perm` which computes ``n! / (n - r)!`` when ``0 ≤ r ≤ n`` or "
"zero when ``r > n``."
msgstr ""
"输出结果是 :func:`product` 的子序列并已过滤掉其中的重复元素。 输出的长度由 :func:`math.perm` 给出，它在 ``0 ≤"
" r ≤ n`` 时为计算 ``n! / (n - r)!`` 而在 ``r > n`` 时则为零。"

#: ../../library/itertools.rst:534
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*.  If the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""
"排列元组是根据输入的 *iterable* 的顺序以词典排序的形式发出的。 如果输入的 *iterable* "
"是已排序的，则输出的元组将按已排序的顺序产生。"

#: ../../library/itertools.rst:538
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  If the input elements are unique, there will be no repeated values within "
"a permutation."
msgstr "元素的唯一性是基于它们的位置，而不是它们的值。 如果输入的元素都是唯一的，则在排列中就不会有重复的元素。"

#: ../../library/itertools.rst:544
msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"

#: ../../library/itertools.rst:575
msgid "Cartesian product of input iterables."
msgstr "可迭代对象输入的笛卡儿积。"

#: ../../library/itertools.rst:577
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"大致相当于生成器表达式中的嵌套循环。例如， ``product(A, B)`` 和 ``((x,y) for x in A for y in B)`` "
"返回结果一样。"

#: ../../library/itertools.rst:580
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing"
" on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。"

#: ../../library/itertools.rst:585
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"要计算可迭代对象自身的笛卡尔积，将可选参数 *repeat* 设定为要重复的次数。例如，``product(A, repeat=4)`` 和 "
"``product(A, A, A, A)`` 是一样的。"

#: ../../library/itertools.rst:589
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr "该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。"

#: ../../library/itertools.rst:592
msgid ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""

#: ../../library/itertools.rst:605
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it"
" is only useful with finite inputs."
msgstr ""
"在 :func:`product` 运行之前，它会完全耗尽输入的可迭代对象，在内存中保留值的临时池以生成结果积。 相应地，它只适用于有限的输入。"

#: ../../library/itertools.rst:612
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr "创建一个持续地返回 *object* 的迭代器。 将会无限期地运行除非指定了 *times* 参数。"

#: ../../library/itertools.rst:617
msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"

#: ../../library/itertools.rst:626
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr "*repeat* 的一个常见用途是向 *map* 或 *zip* 提供一个常量值的流:"

#: ../../library/itertools.rst:629
msgid ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../library/itertools.rst:637
msgid ""
"Make an iterator that computes the *function* using arguments obtained from "
"the *iterable*.  Used instead of :func:`map` when argument parameters have "
"already been \"pre-zipped\" into tuples."
msgstr ""
"创建一个迭代器，它使用从 *iterable* 获取的参数来计算 *function*。 当参数形参已被“预先 zip”为元组时可代替 "
":func:`map` 来使用。"

#: ../../library/itertools.rst:641
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
":func:`map` 和 :func:`starmap` 之间的区别类似于 ``function(a,b)`` 和 ``function(*c)`` "
"之间的差异。 大致相当于::"

#: ../../library/itertools.rst:645
msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"

#: ../../library/itertools.rst:653
msgid ""
"Make an iterator that returns elements from the *iterable* as long as the "
"*predicate* is true.  Roughly equivalent to::"
msgstr "创建一个迭代器，它返回来自 *iterable* 的 *predicate* 为真值的元素。 大致相当于::"

#: ../../library/itertools.rst:656
msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"
msgstr ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"

#: ../../library/itertools.rst:663
msgid ""
"Note, the element that first fails the predicate condition is consumed from "
"the input iterator and there is no way to access it. This could be an issue "
"if an application wants to further consume the input iterator after "
"*takewhile* has been run to exhaustion.  To work around this problem, "
"consider using `more-itertools before_and_after() <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_"
" instead."
msgstr ""
"请注意，第一个未能满足 predicate 条件的元素将从输入迭代器中消耗掉并且没有办法访问它。 当应用程序想在 *takewhile* "
"运行到耗尽后进一步消耗输入迭代器时这可能会导致问题。 要绕过这个问题，可以考虑改用 `more-itertools before_and_after()"
" <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_。"

#: ../../library/itertools.rst:674
msgid "Return *n* independent iterators from a single iterable."
msgstr "从一个可迭代对象中返回 *n* 个独立的迭代器。"

#: ../../library/itertools.rst:678
msgid ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"
msgstr ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"

#: ../../library/itertools.rst:711
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when simultaneously using iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` 迭代器不是线程安全的。 当同时使用由同一个 :func:`tee` 调用所返回的迭代器时可能引发 "
":exc:`RuntimeError`，即使原本的 *iterable* 是线程安全的。is threadsafe."

#: ../../library/itertools.rst:715
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use "
":func:`list` instead of :func:`tee`."
msgstr ""
"该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 "
":func:`list` 会比 :func:`tee` 更快。"

#: ../../library/itertools.rst:723
msgid ""
"Make an iterator that aggregates elements from each of the *iterables*."
msgstr "创建一个迭代器，它聚合了来自 *iterables* 中每一项的对应元素。"

#: ../../library/itertools.rst:726
msgid ""
"If the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*.  If not specified, *fillvalue* defaults to ``None``."
msgstr ""
"如果 iterables 中每一项的长度不同，则缺失的值将以 *fillvalue* 填充。 如果未指定，则 *fillvalue* 默认为 "
"``None``。"

#: ../../library/itertools.rst:729
msgid "Iteration continues until the longest iterable is exhausted."
msgstr "迭代将持续进行直至其中最长的可迭代对象被耗尽。"

#: ../../library/itertools.rst:733
msgid ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"
msgstr ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"

#: ../../library/itertools.rst:755
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`zip_longest` function should be wrapped with something that limits "
"the number of calls (for example :func:`islice` or :func:`takewhile`)."
msgstr ""
"如果 iterables 中的每一项可能有无限长度，则 :func:`zip_longest` 函数应当用限制调用次数的代码进行包装（例如 "
":func:`islice` 或 :func:`takewhile` 等）。"

#: ../../library/itertools.rst:763
msgid "Itertools Recipes"
msgstr "itertools 配方"

#: ../../library/itertools.rst:765
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。"

#: ../../library/itertools.rst:768
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``starmap()`` and ``repeat()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and "
":mod:`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""
"这些 itertools 专题的主要目的是教学。 各个专题显示了对单个工具的各种思维方式 — 例如，``chain.from_iterable`` "
"被关联到展平的概念。 这些专题还给出了有关这些工具的组合方式的想法 — 例如，``starmap()`` 和 ``repeat()`` "
"应当如何一起工作。 这些专题还显示了 itertools 与 :mod:`operator` 和 :mod:`collections` "
"模块以及内置迭代工具如 ``map()``, ``filter()``, ``reversed()`` 和 ``enumerate()`` "
"相互配合的使用模式。"

#: ../../library/itertools.rst:777
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``sliding_window()``, ``iter_index()``, and "
"``sieve()`` recipes are being tested to see whether they prove their worth."
msgstr ""
"这些例程的次要目的是作为一个孵化器使用。 ``accumulate()``, ``compress()`` 和 ``pairwise()`` "
"等迭代工具最初就是作为例程引入的。 目前，``sliding_window()``, ``iter_index()`` 和 ``sieve()`` "
"例程正在被测试以确定它们是否堪当大任。"

#: ../../library/itertools.rst:782
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the :pypi:`more-itertools` project found on the Python Package Index::"
msgstr ""
"基本上所有这些配方和许许多多其他配方都可以通过 Python Package Index 上的 :pypi:`more-itertools` "
"项目来安装::"

#: ../../library/itertools.rst:786
msgid "python -m pip install more-itertools"
msgstr "python -m pip install more-itertools"

#: ../../library/itertools.rst:788
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a"
" time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a `functional style "
"<https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_.  High "
"speed is retained by preferring \"vectorized\" building blocks over the use "
"of for-loops and :term:`generators <generator>` which incur interpreter "
"overhead."
msgstr ""
"许多例程提供了与底层工具集相当的高性能。 更好的内存效率是通过每次只处理一个元素而不是将整个可迭代对象放入内存来保证的。 代码量的精简是通过以 "
"`函数式风格 <https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_ "
"来链接工具来实现的。 运行的早速度是通过选择使用“矢量化”构件来取代会导致较大解释器开销的 for 循环和 :term:`生成器 "
"<generator>` 来达成的。"

#: ../../library/itertools.rst:796
msgid ""
"import collections\n"
"import contextlib\n"
"import functools\n"
"import math\n"
"import operator\n"
"import random\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(func, times=None, *args):\n"
"    \"Repeat calls to func with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(func, repeat(args))\n"
"    return starmap(func, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(collections.deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        collections.deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True results.\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(operator.itemgetter(0), groupby(iterable))\n"
"    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   return unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = collections.deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # Algorithm credited to George Sakkis\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def partition(predicate, iterable):\n"
"    \"\"\"Partition entries into false entries and true entries.\n"
"\n"
"    If *predicate* is slow, consider wrapping it with functools.lru_cache().\n"
"    \"\"\"\n"
"    # partition(is_odd, range(10)) → 0 2 4 6 8   and  1 3 5 7 9\n"
"    t1, t2 = tee(iterable)\n"
"    return filterfalse(predicate, t1), filter(predicate, t2)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(operator.getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with contextlib.suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(func, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator interface.\"\n"
"    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator\n"
"    with contextlib.suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield func()"
msgstr ""

#: ../../library/itertools.rst:974
msgid "The following recipes have a more mathematical flavor:"
msgstr "下面的例程具有更数学化的风格:"

#: ../../library/itertools.rst:976
msgid ""
"def powerset(iterable):\n"
"    \"powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return math.sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, cols):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), cols)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(math.sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin.\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(math.sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(operator.neg, roots))\n"
"    return list(functools.reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return math.sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(operator.mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=math.isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and all(n % p for p in sieve(math.isqrt(n) + 1))\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(math.isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n\n"
"\n"
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() -> 5 2 1 1 2\n"
"    # multinomial(5, 2, 1, 1, 2) → 83160\n"
"    return math.prod(map(math.comb, accumulate(counts), counts))"
msgstr ""
