# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/tkinter.rst:2
msgid ":mod:`!tkinter` --- Python interface to Tcl/Tk"
msgstr ":mod:`!tkinter` --- Tcl/Tk 的 Python 接口"

#: ../../library/tkinter.rst:9
msgid "**Source code:** :source:`Lib/tkinter/__init__.py`"
msgstr "**源代码:** :source:`Lib/tkinter/__init__.py`"

#: ../../library/tkinter.rst:13
msgid ""
"The :mod:`tkinter` package (\"Tk interface\") is the standard Python "
"interface to the Tcl/Tk GUI toolkit.  Both Tk and :mod:`tkinter` are "
"available on most Unix platforms, including macOS, as well as on Windows "
"systems."
msgstr ""
":mod:`tkinter` 包 (\"Tk 接口\") 是针对 Tcl/Tk GUI 工具包的标准 Python 接口。 Tk 和 "
":mod:`tkinter` 在大多数 Unix 平台，包括 macOS，以及 Windows 系统上均可使用。"

#: ../../library/tkinter.rst:17
msgid ""
"Running ``python -m tkinter`` from the command line should open a window "
"demonstrating a simple Tk interface, letting you know that :mod:`tkinter` is"
" properly installed on your system, and also showing what version of Tcl/Tk "
"is installed, so you can read the Tcl/Tk documentation specific to that "
"version."
msgstr ""
"若在命令行执行 ``python -m tkinter``，应会弹出一个简单的 Tk 界面窗口， 表明 :mod:`tkinter` "
"包已安装完成，还会显示当前安装的 Tcl/Tk 版本，以便阅读对应版本的 Tcl/Tk 文档。"

#: ../../library/tkinter.rst:22
msgid ""
"Tkinter supports a range of Tcl/Tk versions, built either with or without "
"thread support. The official Python binary release bundles Tcl/Tk 8.6 "
"threaded. See the source code for the :mod:`_tkinter` module for more "
"information about supported versions."
msgstr ""
"Tkinter 支持众多的 Tcl/Tk 版本，带或不带多线程版本均可。官方的 Python 二进制版本捆绑了 Tcl/Tk 8.6 "
"多线程版本。关于可支持版本的更多信息，请参阅 :mod:`_tkinter` 模块的源代码。"

#: ../../library/tkinter.rst:27
msgid ""
"Tkinter is not a thin wrapper, but adds a fair amount of its own logic to "
"make the experience more pythonic. This documentation will concentrate on "
"these additions and changes, and refer to the official Tcl/Tk documentation "
"for details that are unchanged."
msgstr ""
"Tkinter 并不只是做了简单的封装，而是增加了相当多的代码逻辑，让使用体验更具 Python 风格（pythonic） "
"。本文将集中介绍这些增加和变化部分，关于未改动部分的细节，请参考 Tcl/Tk 官方文档。"

#: ../../library/tkinter.rst:34
msgid ""
"Tcl/Tk 8.5 (2007) introduced a modern set of themed user interface "
"components along with a new API to use them. Both old and new APIs are still"
" available. Most documentation you will find online still uses the old API "
"and can be woefully outdated."
msgstr ""
"Tcl/Tk 8.5 (2007) 引入了支持主题的现代风格用户界面组件集以及使用这些组件的新版 API。 旧版和新版 API 都可以使用。 "
"你在网上所能找到的大多数文档仍然是使用旧版 API 因此也许已经相当过时。"

#: ../../library/tkinter.rst:41
msgid "`TkDocs <https://tkdocs.com/>`_"
msgstr "`TkDocs <https://tkdocs.com/>`_"

#: ../../library/tkinter.rst:42
msgid ""
"Extensive tutorial on creating user interfaces with Tkinter.  Explains key "
"concepts, and illustrates recommended approaches using the modern API."
msgstr "关于使用 Tkinter 创建用户界面的详细教程。 讲解了关键概念，并介绍了使用现代 API 的推荐方式。"

#: ../../library/tkinter.rst:45
msgid ""
"`Tkinter 8.5 reference: a GUI for Python <https://www.tkdocs.com/shipman/>`_"
msgstr "`Tkinter 8.5 参考手册：一种 Python GUI <https://www.tkdocs.com/shipman/>`_"

#: ../../library/tkinter.rst:46
msgid ""
"Reference documentation for Tkinter 8.5 detailing available classes, "
"methods, and options."
msgstr "详细讲解可用的类、方法和选项的 Tkinter 8.5 参考文档。"

#: ../../library/tkinter.rst:48
msgid "Tcl/Tk Resources:"
msgstr "Tcl/Tk 资源:"

#: ../../library/tkinter.rst:50
msgid "`Tk commands <https://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm>`_"
msgstr "`Tk 命令 <https://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm>`_"

#: ../../library/tkinter.rst:51
msgid ""
"Comprehensive reference to each of the underlying Tcl/Tk commands used by "
"Tkinter."
msgstr "有关 Tkinter 所使用的每个底层 Tcl/Tk 命令的完整参考文档。"

#: ../../library/tkinter.rst:53
msgid "`Tcl/Tk Home Page <https://www.tcl.tk>`_"
msgstr "`Tcl/Tk 主页 <https://www.tcl.tk>`_"

#: ../../library/tkinter.rst:54
msgid "Additional documentation, and links to Tcl/Tk core development."
msgstr "额外的文档，以及 Tcl/Tk 核心开发相关链接。"

#: ../../library/tkinter.rst:56
msgid "Books:"
msgstr "书籍:"

#: ../../library/tkinter.rst:58
msgid ""
"`Modern Tkinter for Busy Python Developers <https://tkdocs.com/book.html>`_"
msgstr ""
"`Modern Tkinter for Busy Python Developers <https://tkdocs.com/book.html>`_"

#: ../../library/tkinter.rst:59
msgid "By Mark Roseman. (ISBN 978-1999149567)"
msgstr "Mark Roseman 著。 (ISBN 978-1999149567)"

#: ../../library/tkinter.rst:61
msgid ""
"`Python GUI programming with Tkinter <https://www.packtpub.com/en-"
"us/product/python-gui-programming-with-tkinter-9781788835886>`_"
msgstr ""
"`Python GUI programming with Tkinter <https://www.packtpub.com/en-"
"us/product/python-gui-programming-with-tkinter-9781788835886>`_"

#: ../../library/tkinter.rst:62
msgid "By Alan D. Moore. (ISBN 978-1788835886)"
msgstr "Alan D. Moore 著。 (ISBN 978-1788835886)"

#: ../../library/tkinter.rst:64
msgid "`Programming Python <https://learning-python.com/about-pp4e.html>`_"
msgstr "`Programming Python <https://learning-python.com/about-pp4e.html>`_"

#: ../../library/tkinter.rst:65
msgid "By Mark Lutz; has excellent coverage of Tkinter. (ISBN 978-0596158101)"
msgstr "Mark Lutz 著；对 Tkinter 进行了精彩的讲解。 (ISBN 978-0596158101)"

#: ../../library/tkinter.rst:67
msgid ""
"`Tcl and the Tk Toolkit (2nd edition)  "
"<https://www.amazon.com/exec/obidos/ASIN/032133633X>`_"
msgstr ""
"`Tcl and the Tk Toolkit (2nd edition)  "
"<https://www.amazon.com/exec/obidos/ASIN/032133633X>`_"

#: ../../library/tkinter.rst:68
msgid ""
"By John Ousterhout, inventor of Tcl/Tk, and Ken Jones; does not cover "
"Tkinter. (ISBN 978-0321336330)"
msgstr ""
"John Ousterhout ，Tcl/Tk 的创造者，与 Ken Jones 合著；未涉及 Tkinter。 (ISBN "
"978-0321336330)"

#: ../../library/tkinter.rst:72
msgid "Architecture"
msgstr "架构"

#: ../../library/tkinter.rst:74
msgid ""
"Tcl/Tk is not a single library but rather consists of a few distinct "
"modules, each with separate functionality and its own official "
"documentation. Python's binary releases also ship an add-on module together "
"with it."
msgstr ""
"Tcl/Tk 不是只有单个库，而是由几个不同的模块组成的，每个模块都有各自的功能和各自的官方文档。 Python 的二进制发行版还会再附加一个模块。"

#: ../../library/tkinter.rst:79
msgid "Tcl"
msgstr "Tcl"

#: ../../library/tkinter.rst:80
msgid ""
"Tcl is a dynamic interpreted programming language, just like Python. Though "
"it can be used on its own as a general-purpose programming language, it is "
"most commonly embedded into C applications as a scripting engine or an "
"interface to the Tk toolkit. The Tcl library has a C interface to create and"
" manage one or more instances of a Tcl interpreter, run Tcl commands and "
"scripts in those instances, and add custom commands implemented in either "
"Tcl or C. Each interpreter has an event queue, and there are facilities to "
"send events to it and process them. Unlike Python, Tcl's execution model is "
"designed around cooperative multitasking, and Tkinter bridges this "
"difference (see `Threading model`_ for details)."
msgstr ""
"Tcl 是一种动态解释型编程语言，正如 Python 一样。尽管它可作为一种通用的编程语言单独使用，但最常见的用法还是作为脚本引擎或 Tk "
"工具包的接口嵌入到 C 程序中。Tcl 库有一个 C 接口，用于创建和管理一个或多个 Tcl 解释器实例，并在这些实例中运行 Tcl 命令和脚本，添加用"
" Tcl 或 C 语言实现的自定义命令。每个解释器都拥有一个事件队列，某些部件可向解释器发送事件交由其处理。与 Python 不同，Tcl "
"的执行模型是围绕协同多任务而设计的，Tkinter 协调了两者的差别（详见 `Threading model`_ ）。"

#: ../../library/tkinter.rst:92 ../../library/tkinter.rst:907
msgid "Tk"
msgstr "Tk"

#: ../../library/tkinter.rst:93
msgid ""
"Tk is a `Tcl package <https://wiki.tcl-lang.org/37432>`_ implemented in C "
"that adds custom commands to create and manipulate GUI widgets. Each "
":class:`Tk` object embeds its own Tcl interpreter instance with Tk loaded "
"into it. Tk's widgets are very customizable, though at the cost of a dated "
"appearance. Tk uses Tcl's event queue to generate and process GUI events."
msgstr ""
"Tk 是一个用 C 语言实现的 `Tcl 包 <https://wiki.tcl-lang.org/37432>`_，它添加了用于创建和操纵 GUI "
"部件的自定义命令。 每个 :class:`Tk` 对象都嵌入了自己的 Tcl 解释器实例并将 Tk 加载到其中。 Tk "
"的部件是高度可定制的，但其代价则是过时的外观。 Tk 使用 Tcl 的事件队列来生成并处理 GUI 事件。"

#: ../../library/tkinter.rst:99
msgid "Ttk"
msgstr "Ttk"

#: ../../library/tkinter.rst:100
msgid ""
"Themed Tk (Ttk) is a newer family of Tk widgets that provide a much better "
"appearance on different platforms than many of the classic Tk widgets. Ttk "
"is distributed as part of Tk, starting with Tk version 8.5. Python bindings "
"are provided in a separate module, :mod:`tkinter.ttk`."
msgstr ""
"带有主题的 Tk（Ttk）是较新加入的 Tk 部件，相比很多经典的 Tk 部件，在各平台提供的界面更加美观。自 Tk 8.5 版本开始，Ttk 作为 "
"Tk 的成员进行发布。Python 则捆绑在一个单独的模块中， :mod:`tkinter.ttk`。"

#: ../../library/tkinter.rst:105
msgid ""
"Internally, Tk and Ttk use facilities of the underlying operating system, "
"i.e., Xlib on Unix/X11, Cocoa on macOS, GDI on Windows."
msgstr ""
"在内部，Tk 和 Ttk 使用下层操作系统的工具库，例如在 Unix/X11 上是 Xlib，在 macOS 上是 Cocoa，在 Windows 上是"
" GDI。"

#: ../../library/tkinter.rst:108
msgid ""
"When your Python application uses a class in Tkinter, e.g., to create a "
"widget, the :mod:`tkinter` module first assembles a Tcl/Tk command string. "
"It passes that Tcl command string to an internal :mod:`_tkinter` binary "
"module, which then calls the Tcl interpreter to evaluate it. The Tcl "
"interpreter will then call into the Tk and/or Ttk packages, which will in "
"turn make calls to Xlib, Cocoa, or GDI."
msgstr ""
"当你的 Python 应用程序使用 Tkinter 中的某个类，例如创建一个部件时，:mod:`tkinter` 模块将首先生成一个 Tcl/Tk "
"命令字符串。 它会把这个 Tcl 命令字符串传给内部的 :mod:`_tkinter` 二进制模块，后者将随后调用 Tcl 解释器来对其求值。 Tcl "
"解释器随后将对 Tk 和/和 Ttk 包唤起，它们又将继续对 Xlib, Cocoa 或 GDI 发起调用。"

#: ../../library/tkinter.rst:116
msgid "Tkinter Modules"
msgstr "Tkinter 模块"

#: ../../library/tkinter.rst:118
msgid ""
"Support for Tkinter is spread across several modules. Most applications will"
" need the main :mod:`tkinter` module, as well as the :mod:`tkinter.ttk` "
"module, which provides the modern themed widget set and API::"
msgstr ""
"对 Tkinter 的支持分布在多个模块中。 大多数应用程序将需要主模块 :mod:`tkinter`，以及 :mod:`tkinter.ttk` "
"模块，后者提供了带主题的现代部件集及相应的 API::"

#: ../../library/tkinter.rst:123
msgid ""
"from tkinter import *\n"
"from tkinter import ttk"
msgstr ""
"from tkinter import *\n"
"from tkinter import ttk"

#: ../../library/tkinter.rst:129
msgid ""
"Construct a toplevel Tk widget, which is usually the main window of an "
"application, and initialize a Tcl interpreter for this widget.  Each "
"instance has its own associated Tcl interpreter."
msgstr ""
"构造一个最高层级的 Tk 部件，这通常是一个应用程序的主窗口，并为这个部件初始化 Tcl 解释器。 每个实例都有其各自所关联的 Tcl 解释器。"

#: ../../library/tkinter.rst:133
msgid ""
"The :class:`Tk` class is typically instantiated using all default values. "
"However, the following keyword arguments are currently recognized:"
msgstr ":class:`Tk` 类通常全部使用默认值来初始化。 不过，目前还可识别下列关键字参数:"

#: ../../library/tkinter.rst:136
msgid "*screenName*"
msgstr "*screenName*"

#: ../../library/tkinter.rst:137
msgid ""
"When given (as a string), sets the :envvar:`DISPLAY` environment variable. "
"(X11 only)"
msgstr "当（作为字符串）给出时，设置 :envvar:`DISPLAY` 环境变量。 （仅限 X11）"

#: ../../library/tkinter.rst:139
msgid "*baseName*"
msgstr "*baseName*"

#: ../../library/tkinter.rst:140
msgid ""
"Name of the profile file.  By default, *baseName* is derived from the "
"program name (``sys.argv[0]``)."
msgstr "预置文件的名称。 在默认情况下，*baseName* 是来自于程序名称 (``sys.argv[0]``)。"

#: ../../library/tkinter.rst:142
msgid "*className*"
msgstr "*className*"

#: ../../library/tkinter.rst:143
msgid ""
"Name of the widget class.  Used as a profile file and also as the name with "
"which Tcl is invoked (*argv0* in *interp*)."
msgstr "控件类的名称。 会被用作预置文件同时也作为 Tcl 唤起的名称 (*interp* 中的 *argv0*)。"

#: ../../library/tkinter.rst:145
msgid "*useTk*"
msgstr "*useTk*"

#: ../../library/tkinter.rst:146
msgid ""
"If ``True``, initialize the Tk subsystem.  The :func:`tkinter.Tcl() <Tcl>` "
"function sets this to ``False``."
msgstr ""
"如果为 ``True``，则初始化 Tk 子系统。 :func:`tkinter.Tcl() <Tcl>` 函数会将其设为 ``False``。"

#: ../../library/tkinter.rst:148
msgid "*sync*"
msgstr "*sync*"

#: ../../library/tkinter.rst:149
msgid ""
"If ``True``, execute all X server commands synchronously, so that errors are"
" reported immediately.  Can be used for debugging. (X11 only)"
msgstr "如果为 ``True``，则同步执行所有 X 服务器命令，以便立即报告错误。 可被用于调试。 （仅限 X11）"

#: ../../library/tkinter.rst:151
msgid "*use*"
msgstr "*use*"

#: ../../library/tkinter.rst:152
msgid ""
"Specifies the *id* of the window in which to embed the application, instead "
"of it being created as an independent toplevel window. *id* must be "
"specified in the same way as the value for the -use option for toplevel "
"widgets (that is, it has a form like that returned by :meth:`winfo_id`)."
msgstr ""
"指定嵌入应用程序的窗口 *id*，而不是将其创建为独立的顶层窗口。 *id* 必须以与顶层控件的 -use 选项值相同的方式来指定（也就是说，它具有与 "
":meth:`winfo_id` 的返回值相同的形式）。"

#: ../../library/tkinter.rst:158
msgid ""
"Note that on some platforms this will only work correctly if *id* refers to "
"a Tk frame or toplevel that has its -container option enabled."
msgstr "请注意在某些平台上只有当 *id* 是指向一个启用了 -container 选项的 Tk 框架或顶层窗口时此参数才能正确生效。"

#: ../../library/tkinter.rst:161
msgid ""
":class:`Tk` reads and interprets profile files, named "
":file:`.{className}.tcl` and :file:`.{baseName}.tcl`, into the Tcl "
"interpreter and calls :func:`exec` on the contents of "
":file:`.{className}.py` and :file:`.{baseName}.py`.  The path for the "
"profile files is the :envvar:`HOME` environment variable or, if that isn't "
"defined, then :data:`os.curdir`."
msgstr ""
":class:`Tk` 读取并解释预置文件，其名称为 :file:`.{className}.tcl` 和 "
":file:`.{baseName}.tcl`，进入 Tcl 解释器并基于 :file:`.{className}.py` 和 "
":file:`.{baseName}.py` 的内容来调用 :func:`exec`。 预置文件的路径为 :envvar:`HOME` "
"环境变量，或者如果它未被定义，则为 :data:`os.curdir`。"

#: ../../library/tkinter.rst:170
msgid ""
"The Tk application object created by instantiating :class:`Tk`.  This "
"provides access to the Tcl interpreter.  Each widget that is attached the "
"same instance of :class:`Tk` has the same value for its :attr:`tk` "
"attribute."
msgstr ""
"通过实例化 :class:`Tk` 创建的 Tk 应用程序对象。 这提供了对 Tcl 解释器的访问。 每个被附加到相同 :class:`Tk` "
"实例的控件都具有相同的 :attr:`tk` 属性值。"

#: ../../library/tkinter.rst:177
msgid ""
"The widget object that contains this widget.  For :class:`Tk`, the *master* "
"is :const:`None` because it is the main window.  The terms *master* and "
"*parent* are similar and sometimes used interchangeably as argument names; "
"however, calling :meth:`winfo_parent` returns a string of the widget name "
"whereas :attr:`master` returns the object. *parent*/*child* reflects the "
"tree-like relationship while *master*/*slave* reflects the container "
"structure."
msgstr ""
"包含此控件的控件对象。 对于 :class:`Tk`，*master* 将为 :const:`None` 因为它是主窗口。 术语 *master* 和 "
"*parent* 是类似的且有时作为参数名称被交替使用；但是，调用 :meth:`winfo_parent` 将返回控件名称字符串而 "
":attr:`master` 将返回控件对象。 *parent*/*child* 反映了树型关系而 *master*/*slave* 反映了容器结构。"

#: ../../library/tkinter.rst:187
msgid ""
"The immediate descendants of this widget as a :class:`dict` with the child "
"widget names as the keys and the child instance objects as the values."
msgstr "以 :class:`dict` 表示的此控件的直接下级其中的键为子控件名称而值为子实例对象。"

#: ../../library/tkinter.rst:194
msgid ""
"The :func:`Tcl` function is a factory function which creates an object much "
"like that created by the :class:`Tk` class, except that it does not "
"initialize the Tk subsystem.  This is most often useful when driving the Tcl"
" interpreter in an environment where one doesn't want to create extraneous "
"toplevel windows, or where one cannot (such as Unix/Linux systems without an"
" X server).  An object created by the :func:`Tcl` object can have a Toplevel"
" window created (and the Tk subsystem initialized) by calling its "
":meth:`loadtk` method."
msgstr ""
":func:`Tcl` 函数是一个工厂函数，它创建的对象类似于 :class:`Tk` 类创建的，只是不会初始化 Tk 子系统。这在调动 Tcl "
"解释器时最为有用，这时不想创建多余的顶层窗口，或者无法创建（比如不带 X 服务的 Unix/Linux 系统）。由 :func:`Tcl` "
"创建的对象可调用 :meth:`loadtk` 方法创建一个顶层窗口（且会初始化 Tk 子系统）。"

#: ../../library/tkinter.rst:203
msgid "The modules that provide Tk support include:"
msgstr "提供 Tk 支持的模块包括:"

#: ../../library/tkinter.rst:205
msgid ":mod:`tkinter`"
msgstr ":mod:`tkinter`"

#: ../../library/tkinter.rst:206
msgid "Main Tkinter module."
msgstr "主 Tkinter 模块。"

#: ../../library/tkinter.rst:208
msgid ":mod:`tkinter.colorchooser`"
msgstr ":mod:`tkinter.colorchooser`"

#: ../../library/tkinter.rst:209
msgid "Dialog to let the user choose a color."
msgstr "让用户选择颜色的对话框。"

#: ../../library/tkinter.rst:211
msgid ":mod:`tkinter.commondialog`"
msgstr ":mod:`tkinter.commondialog`"

#: ../../library/tkinter.rst:212
msgid "Base class for the dialogs defined in the other modules listed here."
msgstr "本文其他模块定义的对话框的基类。"

#: ../../library/tkinter.rst:214
msgid ":mod:`tkinter.filedialog`"
msgstr ":mod:`tkinter.filedialog`"

#: ../../library/tkinter.rst:215
msgid "Common dialogs to allow the user to specify a file to open or save."
msgstr "允许用户指定文件的通用对话框，用于打开或保存文件。"

#: ../../library/tkinter.rst:217
msgid ":mod:`tkinter.font`"
msgstr ":mod:`tkinter.font`"

#: ../../library/tkinter.rst:218
msgid "Utilities to help work with fonts."
msgstr "帮助操作字体的工具。"

#: ../../library/tkinter.rst:220
msgid ":mod:`tkinter.messagebox`"
msgstr ":mod:`tkinter.messagebox`"

#: ../../library/tkinter.rst:221
msgid "Access to standard Tk dialog boxes."
msgstr "访问标准的 Tk 对话框。"

#: ../../library/tkinter.rst:223
msgid ":mod:`tkinter.scrolledtext`"
msgstr ":mod:`tkinter.scrolledtext`"

#: ../../library/tkinter.rst:224
msgid "Text widget with a vertical scroll bar built in."
msgstr "内置纵向滚动条的文本组件。"

#: ../../library/tkinter.rst:226
msgid ":mod:`tkinter.simpledialog`"
msgstr ":mod:`tkinter.simpledialog`"

#: ../../library/tkinter.rst:227
msgid "Basic dialogs and convenience functions."
msgstr "基础对话框和一些便捷功能。"

#: ../../library/tkinter.rst:229
msgid ":mod:`tkinter.ttk`"
msgstr ":mod:`tkinter.ttk`"

#: ../../library/tkinter.rst:230
msgid ""
"Themed widget set introduced in Tk 8.5, providing modern alternatives for "
"many of the classic widgets in the main :mod:`tkinter` module."
msgstr "在 Tk 8.5 中引入的带主题的控件集，提供了对应于 :mod:`tkinter` 模块中许多经典控件的现代替代。"

#: ../../library/tkinter.rst:233
msgid "Additional modules:"
msgstr "附加模块:"

#: ../../library/tkinter.rst:238
msgid ":mod:`_tkinter`"
msgstr ":mod:`_tkinter`"

#: ../../library/tkinter.rst:239
msgid ""
"A binary module that contains the low-level interface to Tcl/Tk. It is "
"automatically imported by the main :mod:`tkinter` module, and should never "
"be used directly by application programmers. It is usually a shared library "
"(or DLL), but might in some cases be statically linked with the Python "
"interpreter."
msgstr ""
"一个包含低层级 Tcl/Tk 接口的二进制模块。 它会被主 :mod:`tkinter` 模块自动导入，且永远不应被应用程序员所直接使用。 "
"它通常是一个共享库（或 DLL），但在某些情况下可能被动态链接到 Python 解释器。"

#: ../../library/tkinter.rst:245
msgid ":mod:`idlelib`"
msgstr ":mod:`idlelib`"

#: ../../library/tkinter.rst:246
msgid ""
"Python's Integrated Development and Learning Environment (IDLE). Based on "
":mod:`tkinter`."
msgstr "Python 的集成开发与学习环境（IDLE）。 基于 :mod:`tkinter`。"

#: ../../library/tkinter.rst:249
msgid ":mod:`tkinter.constants`"
msgstr ":mod:`tkinter.constants`"

#: ../../library/tkinter.rst:250
msgid ""
"Symbolic constants that can be used in place of strings when passing various"
" parameters to Tkinter calls. Automatically imported by the main "
":mod:`tkinter` module."
msgstr "当向 Tkinter 调用传入各种形参时可被用来代替字符串的符号常量。 由主 :mod:`tkinter` 模块自动导入。"

#: ../../library/tkinter.rst:254
msgid ":mod:`tkinter.dnd`"
msgstr ":mod:`tkinter.dnd`"

#: ../../library/tkinter.rst:255
msgid ""
"(experimental) Drag-and-drop support for :mod:`tkinter`. This will become "
"deprecated when it is replaced with the Tk DND."
msgstr "针对 :mod:`tkinter` 的（实验性的）拖放支持。 当以 Tk DND 代替时它将会被弃用。"

#: ../../library/tkinter.rst:258
msgid ":mod:`turtle`"
msgstr ":mod:`turtle`"

#: ../../library/tkinter.rst:259
msgid "Turtle graphics in a Tk window."
msgstr "Tk 窗口中的海龟绘图库。"

#: ../../library/tkinter.rst:263
msgid "Tkinter Life Preserver"
msgstr "Tkinter 拾遗"

#: ../../library/tkinter.rst:265
msgid ""
"This section is not designed to be an exhaustive tutorial on either Tk or "
"Tkinter.  For that, refer to one of the external resources noted earlier. "
"Instead, this section provides a very quick orientation to what a Tkinter "
"application looks like, identifies foundational Tk concepts, and explains "
"how the Tkinter wrapper is structured."
msgstr ""
"这一章节的设计目的不是要编写有关 Tk 或 Tkinter 的冗长教程。 要获取教程，请参阅之前列出的外部资源之一。 相反地，这一章节提供了对于 "
"Tkinter 应用程序大致样貌的快速指导，列出了基本的 Tk 概念，并解释了 Tkinter 包装器的构造是什么样的。"

#: ../../library/tkinter.rst:271
msgid ""
"The remainder of this section will help you to identify the classes, "
"methods, and options you'll need in your Tkinter application, and where to "
"find more detailed documentation on them, including in the official Tcl/Tk "
"reference manual."
msgstr ""
"这一章节的剩余部分将帮助你识别在你的 Tkinter 应用程序中需要的类、方法和选项，以及在哪里可以找到有关它们的更详细文档，包括官方 Tcl/Tk "
"参考手册等。"

#: ../../library/tkinter.rst:278
msgid "A Hello World Program"
msgstr "Hello World 程序"

#: ../../library/tkinter.rst:280
msgid ""
"We'll start by walking through a \"Hello World\" application in Tkinter. "
"This isn't the smallest one we could write, but has enough to illustrate "
"some key concepts you'll need to know."
msgstr ""
"让我们先来看一个 Tkinter 的 \"Hello World\" 应用程序。 "
"这并不是我们所能写出的最简短版本，但也足够说明你所需要了解的一些关键概念。"

#: ../../library/tkinter.rst:286
msgid ""
"from tkinter import *\n"
"from tkinter import ttk\n"
"root = Tk()\n"
"frm = ttk.Frame(root, padding=10)\n"
"frm.grid()\n"
"ttk.Label(frm, text=\"Hello World!\").grid(column=0, row=0)\n"
"ttk.Button(frm, text=\"Quit\", command=root.destroy).grid(column=1, row=0)\n"
"root.mainloop()"
msgstr ""
"from tkinter import *\n"
"from tkinter import ttk\n"
"root = Tk()\n"
"frm = ttk.Frame(root, padding=10)\n"
"frm.grid()\n"
"ttk.Label(frm, text=\"Hello World!\").grid(column=0, row=0)\n"
"ttk.Button(frm, text=\"Quit\", command=root.destroy).grid(column=1, row=0)\n"
"root.mainloop()"

#: ../../library/tkinter.rst:296
msgid ""
"After the imports, the next line creates an instance of the :class:`Tk` "
"class, which initializes Tk and creates its associated Tcl interpreter. It "
"also creates a toplevel window, known as the root window, which serves as "
"the main window of the application."
msgstr ""
"在导入语句之后，下一行语句创建了一个 :class:`Tk` 类的实例，它会初始化 Tk 并创建与其关联的 Tcl 解释器。 "
"它还会创建一个顶层窗口，名为 root 窗口，它将被作为应用程序的主窗口。"

#: ../../library/tkinter.rst:301
msgid ""
"The following line creates a frame widget, which in this case will contain a"
" label and a button we'll create next. The frame is fit inside the root "
"window."
msgstr "下一行创建了一个框架控件，在本示例中它会包含我们即将创建的一个标签和一个按钮。 框架被嵌在 root 窗口内部。"

#: ../../library/tkinter.rst:305
msgid ""
"The next line creates a label widget holding a static text string. The "
":meth:`grid` method is used to specify the relative layout (position) of the"
" label within its containing frame widget, similar to how tables in HTML "
"work."
msgstr ""
"下一行创建了一个包含静态文本字符串的标签控件。 :meth:`grid` 方法被用来指明标签在包含它的框架控件中的相对布局（定位），作用类似于 HTML"
" 中的表格。"

#: ../../library/tkinter.rst:309
msgid ""
"A button widget is then created, and placed to the right of the label. When "
"pressed, it will call the :meth:`destroy` method of the root window."
msgstr "接下来创建了一个按钮控件，并被放置到标签的右侧。 当被按下时，它将调用 root 窗口的 :meth:`destroy` 方法。"

#: ../../library/tkinter.rst:312
msgid ""
"Finally, the :meth:`mainloop` method puts everything on the display, and "
"responds to user input until the program terminates."
msgstr "最后，:meth:`mainloop` 方法将所有控件显示出来，并响应用户输入直到程序终结。"

#: ../../library/tkinter.rst:318
msgid "Important Tk Concepts"
msgstr "重要的 Tk 概念"

#: ../../library/tkinter.rst:320
msgid "Even this simple program illustrates the following key Tk concepts:"
msgstr "即便是这样简单的程序也阐明了以下关键 Tk 概念:"

#: ../../library/tkinter.rst:322
msgid "widgets"
msgstr "控件"

#: ../../library/tkinter.rst:323
msgid ""
"A Tkinter user interface is made up of individual *widgets*. Each widget is "
"represented as a Python object, instantiated from classes like "
":class:`ttk.Frame`, :class:`ttk.Label`, and :class:`ttk.Button`."
msgstr ""
"Tkinter 用户界面是由一个个 *控件* 组成的。 每个控件都由相应的 Python 对象表示，由 :class:`ttk.Frame`, "
":class:`ttk.Label` 以及 :class:`ttk.Button` 这样的类来实例化。"

#: ../../library/tkinter.rst:327
msgid "widget hierarchy"
msgstr "控件层级结构"

#: ../../library/tkinter.rst:328
msgid ""
"Widgets are arranged in a *hierarchy*. The label and button were contained "
"within a frame, which in turn was contained within the root window. When "
"creating each *child* widget, its *parent* widget is passed as the first "
"argument to the widget constructor."
msgstr ""
"控件按 *层级结构* 来组织。 标签和按钮包含在框架中，框架又包含在根窗口中。 当创建每个 *子* 控件时，它的 *父* "
"控件会作为控件构造器的第一个参数被传入。"

#: ../../library/tkinter.rst:333
msgid "configuration options"
msgstr "配置选项"

#: ../../library/tkinter.rst:334
msgid ""
"Widgets have *configuration options*, which modify their appearance and "
"behavior, such as the text to display in a label or button. Different "
"classes of widgets will have different sets of options."
msgstr "控件具有 *配置选项*，配置选项会改变控件的外观和行为，例如要在标签或按钮中显示的文本。 不同的控件类会具有不同的选项集。"

#: ../../library/tkinter.rst:338
msgid "geometry management"
msgstr "几何管理"

#: ../../library/tkinter.rst:339
msgid ""
"Widgets aren't automatically added to the user interface when they are "
"created. A *geometry manager* like ``grid`` controls where in the user "
"interface they are placed."
msgstr "小部件在创建时不会自动添加到用户界面。一个像 ``grid`` 的 *几何管理器* 控制这些小部件在用户界面的位置。"

#: ../../library/tkinter.rst:343
msgid "event loop"
msgstr "事件循环"

#: ../../library/tkinter.rst:344
msgid ""
"Tkinter reacts to user input, changes from your program, and even refreshes "
"the display only when actively running an *event loop*. If your program "
"isn't running the event loop, your user interface won't update."
msgstr ""
"只有主动运行一个 *事件循环*，Tkinter "
"才会对用户的输入做出反应，改变你的程序，以及刷新显示。如果你的程序没有运行事件循环，你的用户界面不会更新。"

#: ../../library/tkinter.rst:350
msgid "Understanding How Tkinter Wraps Tcl/Tk"
msgstr "了解 Tkinter 如何封装 Tcl/Tk"

#: ../../library/tkinter.rst:352
msgid ""
"When your application uses Tkinter's classes and methods, internally Tkinter"
" is assembling strings representing Tcl/Tk commands, and executing those "
"commands in the Tcl interpreter attached to your application's :class:`Tk` "
"instance."
msgstr ""
"当你的应用程序使用 Tkinter 的类和方法时，Tkinter 内部汇编代表 Tcl/Tk 命令的字符串，并在连接到你的应用程序的 "
":class:`Tk` 实例的 Tcl 解释器中执行这些命令。"

#: ../../library/tkinter.rst:357
msgid ""
"Whether it's trying to navigate reference documentation, trying to find the "
"right method or option, adapting some existing code, or debugging your "
"Tkinter application, there are times that it will be useful to understand "
"what those underlying Tcl/Tk commands look like."
msgstr ""
"无论是试图浏览参考文档，或是试图找到正确的方法或选项，调整一些现有的代码，亦或是调试 Tkinter 应用程序，有时候理解底层 Tcl/Tk "
"命令是什么样子的会很有用。"

#: ../../library/tkinter.rst:362
msgid ""
"To illustrate, here is the Tcl/Tk equivalent of the main part of the Tkinter"
" script above."
msgstr "为了说明这一点，下面是 Tcl/Tk 等价于上面 Tkinter 脚本的主要部分。"

#: ../../library/tkinter.rst:367
msgid ""
"ttk::frame .frm -padding 10\n"
"grid .frm\n"
"grid [ttk::label .frm.lbl -text \"Hello World!\"] -column 0 -row 0\n"
"grid [ttk::button .frm.btn -text \"Quit\" -command \"destroy .\"] -column 1 -row 0"
msgstr ""
"ttk::frame .frm -padding 10\n"
"grid .frm\n"
"grid [ttk::label .frm.lbl -text \"Hello World!\"] -column 0 -row 0\n"
"grid [ttk::button .frm.btn -text \"Quit\" -command \"destroy .\"] -column 1 -row 0"

#: ../../library/tkinter.rst:373
msgid ""
"Tcl's syntax is similar to many shell languages, where the first word is the"
" command to be executed, with arguments to that command following it, "
"separated by spaces. Without getting into too many details, notice the "
"following:"
msgstr "Tcl 的语法类似于许多 shell 语言，其中第一个单词是要执行的命令，后面是该命令的参数，用空格分隔。不谈太多细节，请注意以下几点："

#: ../../library/tkinter.rst:377
msgid ""
"The commands used to create widgets (like ``ttk::frame``) correspond to "
"widget classes in Tkinter."
msgstr "用于创建窗口小部件（如 ``ttk::frame``）的命令对应于 Tkinter 中的 widget 类。"

#: ../../library/tkinter.rst:380
msgid ""
"Tcl widget options (like ``-text``) correspond to keyword arguments in "
"Tkinter."
msgstr "Tcl 窗口控件选项（如 ``-tex``）对应于 Tkinter 中的关键字参数。"

#: ../../library/tkinter.rst:383
msgid ""
"Widgets are referred to by a *pathname* in Tcl (like ``.frm.btn``), whereas "
"Tkinter doesn't use names but object references."
msgstr "在 Tcl 中，小部件是通过 *路径名* 引用的（例如 ``.frm.btn``），而 Tkinter 不使用名称，而是使用对象引用。"

#: ../../library/tkinter.rst:386
msgid ""
"A widget's place in the widget hierarchy is encoded in its (hierarchical) "
"pathname, which uses a ``.`` (dot) as a path separator. The pathname for the"
" root window is just ``.`` (dot). In Tkinter, the hierarchy is defined not "
"by pathname but by specifying the parent widget when creating each child "
"widget."
msgstr ""
"控件在控件层次结构中的位置在其（层次结构）路径名中编码，该路径名使用一个 ``.`` （点）作为路径分隔符。根窗口的路径名是 ``.`` （点）。在 "
"Tkinter 中，层次结构不是通过路径名定义的，而是通过在创建每个子控件时指定父控件来定义的。"

#: ../../library/tkinter.rst:392
msgid ""
"Operations which are implemented as separate *commands* in Tcl (like "
"``grid`` or ``destroy``) are represented as *methods* on Tkinter widget "
"objects. As you'll see shortly, at other times Tcl uses what appear to be "
"method calls on widget objects, which more closely mirror what would is used"
" in Tkinter."
msgstr ""
"在 Tcl 中以独立的 *命令* 实现的操作（比如 ``grid`` 和 ``destroy`` ）在 Tkinter 控件对象上以 *方法* "
"表示。稍后您将看到，在其他时候，Tcl 在控件对象调用的方法，在 Tkinter 也有对应的使用。"

#: ../../library/tkinter.rst:400
msgid "How do I...? What option does...?"
msgstr "我该如何...？这个选项会做...？"

#: ../../library/tkinter.rst:402
msgid ""
"If you're not sure how to do something in Tkinter, and you can't immediately"
" find it in the tutorial or reference documentation you're using, there are "
"a few strategies that can be helpful."
msgstr "如果您不确定如何在 Tkinter 中做一些事情，并且您不能立即在您正在使用的教程或参考文档中找到它，这里有一些策略可以帮助您。"

#: ../../library/tkinter.rst:406
msgid ""
"First, remember that the details of how individual widgets work may vary "
"across different versions of both Tkinter and Tcl/Tk. If you're searching "
"documentation, make sure it corresponds to the Python and Tcl/Tk versions "
"installed on your system."
msgstr ""
"首先，请记住，在不同版本的 Tkinter 和 Tcl/Tk 中，各个控件如何工作的细节可能会有所不同。如果您正在搜索文档，请确保它与安装在系统上的 "
"Python 和 Tcl/Tk 版本相对应。"

#: ../../library/tkinter.rst:411
msgid ""
"When searching for how to use an API, it helps to know the exact name of the"
" class, option, or method that you're using. Introspection, either in an "
"interactive Python shell or with :func:`print`, can help you identify what "
"you need."
msgstr ""
"在搜索如何使用 API 时，知道正在使用的类、选项或方法的确切名称会有所帮助。内省，无论是在交互式 Python shell 中，还是在 "
":func:`print` 中，都可以帮助你确定你需要什么。"

#: ../../library/tkinter.rst:416
msgid ""
"To find out what configuration options are available on any widget, call its"
" :meth:`configure` method, which returns a dictionary containing a variety "
"of information about each object, including its default and current values. "
"Use :meth:`keys` to get just the names of each option."
msgstr ""
"要找出控件上可用的配置选项，请调用其 :meth:`configure` "
"方法，该方法返回一个字典，其中包含每个对象的各种信息，包括其默认值和当前值。使用 :meth:`keys` 获取每个选项的名称。"

#: ../../library/tkinter.rst:423
msgid ""
"btn = ttk.Button(frm, ...)\n"
"print(btn.configure().keys())"
msgstr ""
"btn = ttk.Button(frm, ...)\n"
"print(btn.configure().keys())"

#: ../../library/tkinter.rst:426
msgid ""
"As most widgets have many configuration options in common, it can be useful "
"to find out which are specific to a particular widget class. Comparing the "
"list of options to that of a simpler widget, like a frame, is one way to do "
"that."
msgstr ""
"由于大多数控件都有许多共同的配置选项，因此找出特定于特定控件类的配置选项可能会很有用。将选项列表与更简单的控件（如框架）的列表进行比较是一种方法。"

#: ../../library/tkinter.rst:433
msgid "print(set(btn.configure().keys()) - set(frm.configure().keys()))"
msgstr "print(set(btn.configure().keys()) - set(frm.configure().keys()))"

#: ../../library/tkinter.rst:435
msgid ""
"Similarly, you can find the available methods for a widget object using the "
"standard :func:`dir` function. If you try it, you'll see there are over 200 "
"common widget methods, so again identifying those specific to a widget class"
" is helpful."
msgstr ""
"类似地，你可以使用标准函数 :func:`dir` "
"来查找控件对象的可用方法。如果您尝试一下，您会发现有超过200种常见的控件方法，因此再次确认那些特定于控件类的方法是有帮助的。"

#: ../../library/tkinter.rst:442
msgid ""
"print(dir(btn))\n"
"print(set(dir(btn)) - set(dir(frm)))"
msgstr ""
"print(dir(btn))\n"
"print(set(dir(btn)) - set(dir(frm)))"

#: ../../library/tkinter.rst:447
msgid "Navigating the Tcl/Tk Reference Manual"
msgstr "浏览 Tcl/Tk 参考手册"

#: ../../library/tkinter.rst:449
msgid ""
"As noted, the official `Tk commands "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm>`_ reference manual (man "
"pages) is often the most accurate description of what specific operations on"
" widgets do. Even when you know the name of the option or method that you "
"need, you may still have a few places to look."
msgstr ""
"如上所述，官方的 `Tk commands <https://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm>`_  "
"参考手册（手册页）通常有对控件特定操作的最准确描述。即使您知道需要的选项或方法的名称，您可能仍然有一些地方可以查找。"

#: ../../library/tkinter.rst:454
msgid ""
"While all operations in Tkinter are implemented as method calls on widget "
"objects, you've seen that many Tcl/Tk operations appear as commands that "
"take a widget pathname as its first parameter, followed by optional "
"parameters, e.g."
msgstr ""
"虽然 Tkinter 中的所有操作都是通过对控件对象的方法调用来实现的，但您已经看到许多 Tcl/Tk "
"操作都是以命令的形式出现的，这些命令以小部件的路径名作为它的第一个参数，然后是可选参数，例如："

#: ../../library/tkinter.rst:461
msgid ""
"destroy .\n"
"grid .frm.btn -column 0 -row 0"
msgstr ""
"destroy .\n"
"grid .frm.btn -column 0 -row 0"

#: ../../library/tkinter.rst:464
msgid ""
"Others, however, look more like methods called on a widget object (in fact, "
"when you create a widget in Tcl/Tk, it creates a Tcl command with the name "
"of the widget pathname, with the first parameter to that command being the "
"name of a method to call)."
msgstr ""
"但是，其他方法看起来更像在控件对象上调用的方法（实际上，当您在 Tcl/Tk 中创建小部件时，它会使用控件路径名创建 Tcl "
"命令，该命令的第一个参数是要调用的方法名）。"

#: ../../library/tkinter.rst:471
msgid ""
".frm.btn invoke\n"
".frm.lbl configure -text \"Goodbye\""
msgstr ""
".frm.btn invoke\n"
".frm.lbl configure -text \"Goodbye\""

#: ../../library/tkinter.rst:475
msgid ""
"In the official Tcl/Tk reference documentation, you'll find most operations "
"that look like method calls on the man page for a specific widget (e.g., "
"you'll find the :meth:`invoke` method on the `ttk::button "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_button.htm>`_ man page), while "
"functions that take a widget as a parameter often have their own man page "
"(e.g., `grid <https://www.tcl.tk/man/tcl8.6/TkCmd/grid.htm>`_)."
msgstr ""
"在 Tcl/Tk 官方参考文档中，你会发现手册页上大多数操作看起来都像是特定控件的的方法调用（例如，你会在 `ttk::button "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_button.htm>`_ 手册页上找到 :meth:`invoke`"
" 方法），而以控件作为参数的函数通常有自己的手册页（例如，`grid "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/grid.htm>`_ ）。"

#: ../../library/tkinter.rst:483
msgid ""
"You'll find many common options and methods in the `options "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/options.htm>`_ or `ttk::widget "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_widget.htm>`_ man pages, while "
"others are found in the man page for a specific widget class."
msgstr ""
"您将在 `options <https://www.tcl.tk/man/tcl8.6/TkCmd/options.htm>`_ 或 "
"`ttk::widget <https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_widget.htm>`_ "
"手册页中找到许多常见的选项和方法，而其他的选项和方法可以在特定控件类的手册页中找到。"

#: ../../library/tkinter.rst:488
msgid ""
"You'll also find that many Tkinter methods have compound names, e.g., "
":func:`winfo_x`, :func:`winfo_height`, :func:`winfo_viewable`. You'd find "
"documentation for all of these in the `winfo "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/winfo.htm>`_ man page."
msgstr ""
"你还会发现许多 Tkinter 方法有复合名称，例如 "
":func:`winfo_x`，:func:`winfo_height`，:func:`winfo_viewable`。你可以在 `winfo "
"<https://www.tcl.tk/man/tcl8.6/TkCmd/winfo.htm>`_ 页面找到这些文档。"

#: ../../library/tkinter.rst:494
msgid ""
"Somewhat confusingly, there are also methods on all Tkinter widgets that "
"don't actually operate on the widget, but operate at a global scope, "
"independent of any widget. Examples are methods for accessing the clipboard "
"or the system bell. (They happen to be implemented as methods in the base "
":class:`Widget` class that all Tkinter widgets inherit from)."
msgstr ""
"有些令人困惑的是，所有 Tkinter "
"小部件上还有一些方法实际上并不在控件上操作，而是在全局范围内操作，独立于任何控件。例如访问剪贴板或系统响铃的方法。（它们恰好被实现为所有 Tkinter"
" 小部件都继承自的基类 :class:`Widget` 中的方法）。"

#: ../../library/tkinter.rst:503
msgid "Threading model"
msgstr "线程模型"

#: ../../library/tkinter.rst:505
msgid ""
"Python and Tcl/Tk have very different threading models, which :mod:`tkinter`"
" tries to bridge. If you use threads, you may need to be aware of this."
msgstr "Python 和 Tcl/Tk 的线程模型大不相同，而 :mod:`tkinter` 则会试图进行调和。若要用到线程，可能需要注意这一点。"

#: ../../library/tkinter.rst:508
msgid ""
"A Python interpreter may have many threads associated with it. In Tcl, "
"multiple threads can be created, but each thread has a separate Tcl "
"interpreter instance associated with it. Threads can also create more than "
"one interpreter instance, though each interpreter instance can be used only "
"by the one thread that created it."
msgstr ""
"一个 Python 解释器可能会关联很多线程。在 Tcl 中，可以创建多个线程，但每个线程都关联了单独的 Tcl "
"解释器实例。线程也可以创建一个以上的解释器实例，尽管每个解释器实例只能由创建它的那个线程使用。"

#: ../../library/tkinter.rst:513
msgid ""
"Each :class:`Tk` object created by :mod:`tkinter` contains a Tcl "
"interpreter. It also keeps track of which thread created that interpreter. "
"Calls to :mod:`tkinter` can be made from any Python thread. Internally, if a"
" call comes from a thread other than the one that created the :class:`Tk` "
"object, an event is posted to the interpreter's event queue, and when "
"executed, the result is returned to the calling Python thread."
msgstr ""
":mod:`tkinter` 创建的每个 :class:`Tk` 对象均包含一个 Tcl 解释器。 它还会记录解释器是由哪个线程创建的。对 "
":mod:`tkinter` 的调用可从任何 Python 线程发起。 如果唤起的线程不是创建 :class:`Tk` "
"对象的线程，则会自动向解释器的事件队列中发送一条事件，在执行该事件时，会向发起调用的 Python 线程返回结果。"

#: ../../library/tkinter.rst:520
msgid ""
"Tcl/Tk applications are normally event-driven, meaning that after "
"initialization, the interpreter runs an event loop (i.e. "
":func:`Tk.mainloop`) and responds to events. Because it is single-threaded, "
"event handlers must respond quickly, otherwise they will block other events "
"from being processed. To avoid this, any long-running computations should "
"not run in an event handler, but are either broken into smaller pieces using"
" timers, or run in another thread. This is different from many GUI toolkits "
"where the GUI runs in a completely separate thread from all application code"
" including event handlers."
msgstr ""
"Tcl/Tk 应用程序通常是事件驱动的，这意味着在完成初始化以后，解释器会运行一个事件循环（即 "
":func:`Tk.mainloop`）并对事件做出响应。因为它是单线程的，所以事件处理程序必须快速响应，否则会阻塞其他事件的处理。为了避免阻塞，不应在事件处理程序中执行任何耗时很久的计算，而应利用计时器将任务分块，或者在其他线程中运行。而其他很多工具包的"
" GUI 是在一个完全独立的线程中运行的，独立于包括事件处理程序在内的所有代码。"

#: ../../library/tkinter.rst:529
msgid ""
"If the Tcl interpreter is not running the event loop and processing events, "
"any :mod:`tkinter` calls made from threads other than the one running the "
"Tcl interpreter will fail."
msgstr ""
"如果 Tcl 解释器没有运行事件循环并处理解释器事件，则除运行 Tcl 解释器的线程外，任何其他线程发起的 :mod:`tkinter` 调用都会失败。"

#: ../../library/tkinter.rst:533
msgid "A number of special cases exist:"
msgstr "存在一些特殊情况："

#: ../../library/tkinter.rst:535
msgid ""
"Tcl/Tk libraries can be built so they are not thread-aware. In this case, "
":mod:`tkinter` calls the library from the originating Python thread, even if"
" this is different than the thread that created the Tcl interpreter. A "
"global lock ensures only one call occurs at a time."
msgstr ""
"Tcl/Tk 库可编译为不支持多线程的版本。这时 :mod:`tkinter` 会从初始 Python 线程调用底层库，即便那不是创建 Tcl "
"解释器的线程。会有一个全局锁来确保每次只会发生一次调用。"

#: ../../library/tkinter.rst:540
msgid ""
"While :mod:`tkinter` allows you to create more than one instance of a "
":class:`Tk` object (with its own interpreter), all interpreters that are "
"part of the same thread share a common event queue, which gets ugly fast. In"
" practice, don't create more than one instance of :class:`Tk` at a time. "
"Otherwise, it's best to create them in separate threads and ensure you're "
"running a thread-aware Tcl/Tk build."
msgstr ""
"虽然 :mod:`tkinter` 允许创建一个以上的 :class:`Tk` "
"实例（都带有自己的解释器），但所有属于同一线程的解释器均会共享同一个事件队列，这样很快就会一团糟。在实际编程时，一次创建的 :class:`Tk` "
"实例不要超过一个。否则最好在不同的线程中创建，并确保运行的是支持多线程的 Tcl/Tk 版本。"

#: ../../library/tkinter.rst:546
msgid ""
"Blocking event handlers are not the only way to prevent the Tcl interpreter "
"from reentering the event loop. It is even possible to run multiple nested "
"event loops or abandon the event loop entirely. If you're doing anything "
"tricky when it comes to events or threads, be aware of these possibilities."
msgstr ""
"为了防止 Tcl "
"解释器重新进入事件循环，阻塞事件处理程序并不是唯一的做法。甚至可以运行多个嵌套的事件循环，或者完全放弃事件循环。如果在处理事件或线程时碰到棘手的问题，请小心这些可能的事情。"

#: ../../library/tkinter.rst:551
msgid ""
"There are a few select :mod:`tkinter` functions that presently work only "
"when called from the thread that created the Tcl interpreter."
msgstr "有几个 :mod:`tkinter` 函数，目前只在创建 Tcl 解释器的线程中调用才行。"

#: ../../library/tkinter.rst:556
msgid "Handy Reference"
msgstr "快速参考"

#: ../../library/tkinter.rst:562
msgid "Setting Options"
msgstr "可选配置项"

#: ../../library/tkinter.rst:564
msgid ""
"Options control things like the color and border width of a widget. Options "
"can be set in three ways:"
msgstr "配置参数可以控制组件颜色和边框宽度等。可通过三种方式进行设置："

#: ../../library/tkinter.rst:567
msgid "At object creation time, using keyword arguments"
msgstr "在对象创建时，使用关键字参数"

#: ../../library/tkinter.rst:570
msgid "fred = Button(self, fg=\"red\", bg=\"blue\")"
msgstr "fred = Button(self, fg=\"red\", bg=\"blue\")"

#: ../../library/tkinter.rst:572
msgid ""
"After object creation, treating the option name like a dictionary index"
msgstr "在对象创建后，将参数名用作字典索引"

#: ../../library/tkinter.rst:575
msgid ""
"fred[\"fg\"] = \"red\"\n"
"fred[\"bg\"] = \"blue\""
msgstr ""
"fred[\"fg\"] = \"red\"\n"
"fred[\"bg\"] = \"blue\""

#: ../../library/tkinter.rst:578
msgid ""
"Use the config() method to update multiple attrs subsequent to object "
"creation"
msgstr "利用 config() 方法修改对象的多个属性"

#: ../../library/tkinter.rst:581
msgid "fred.config(fg=\"red\", bg=\"blue\")"
msgstr "fred.config(fg=\"red\", bg=\"blue\")"

#: ../../library/tkinter.rst:583
msgid ""
"For a complete explanation of a given option and its behavior, see the Tk "
"man pages for the widget in question."
msgstr "关于这些参数及其表现的完整解释，请参阅 Tk 手册中有关组件的 man 帮助页。"

#: ../../library/tkinter.rst:586
msgid ""
"Note that the man pages list \"STANDARD OPTIONS\" and \"WIDGET SPECIFIC "
"OPTIONS\" for each widget.  The former is a list of options that are common "
"to many widgets, the latter are the options that are idiosyncratic to that "
"particular widget.  The Standard Options are documented on the "
":manpage:`options(3)` man page."
msgstr ""
"请注意，man 手册页列出了每个部件的“标准选项”和“组件特有选项”。前者是很多组件通用的选项列表，后者是该组件特有的选项。标准选项在  "
":manpage:`options(3)` man 手册中有文档。"

#: ../../library/tkinter.rst:592
msgid ""
"No distinction between standard and widget-specific options is made in this "
"document.  Some options don't apply to some kinds of widgets. Whether a "
"given widget responds to a particular option depends on the class of the "
"widget; buttons have a ``command`` option, labels do not."
msgstr ""
"本文没有区分标准选项和部件特有选项。有些选项不适用于某类组件。组件是否对某选项做出响应，取决于组件的类别；按钮组件有一个 ``command`` "
"选项，而标签组件就没有。"

#: ../../library/tkinter.rst:597
msgid ""
"The options supported by a given widget are listed in that widget's man "
"page, or can be queried at runtime by calling the :meth:`config` method "
"without arguments, or by calling the :meth:`keys` method on that widget.  "
"The return value of these calls is a dictionary whose key is the name of the"
" option as a string (for example, ``'relief'``) and whose values are "
"5-tuples."
msgstr ""
"组件支持的选项在其手册中有列出，也可在运行时调用 :meth:`config` 方法（不带参数）查看，或者通过调用组件的 :meth:`keys` "
"方法进行查询。这些调用的返回值为字典，字典的键是字符串格式的选项名（比如 ``'relief'``），字典的值为五元组。"

#: ../../library/tkinter.rst:603
msgid ""
"Some options, like ``bg`` are synonyms for common options with long names "
"(``bg`` is shorthand for \"background\"). Passing the ``config()`` method "
"the name of a shorthand option will return a 2-tuple, not 5-tuple. The "
"2-tuple passed back will contain the name of the synonym and the \"real\" "
"option (such as ``('bg', 'background')``)."
msgstr ""
"有些选项，比如 ``bg`` 是全名通用选项的同义词（``bg`` 是 “background”的简写）。向 ``config()`` "
"方法传入选项的简称将返回一个二元组，而不是五元组。传回的二元组将包含同义词的全名和“真正的”选项（比如 ``('bg', "
"'background')``）。"

#: ../../library/tkinter.rst:610
msgid "Index"
msgstr "索引"

#: ../../library/tkinter.rst:610
msgid "Meaning"
msgstr "含意"

#: ../../library/tkinter.rst:610
msgid "Example"
msgstr "示例"

#: ../../library/tkinter.rst:612
msgid "0"
msgstr "0"

#: ../../library/tkinter.rst:612
msgid "option name"
msgstr "选项名称"

#: ../../library/tkinter.rst:612 ../../library/tkinter.rst:614
msgid "``'relief'``"
msgstr "``'relief'``"

#: ../../library/tkinter.rst:614
msgid "1"
msgstr "1"

#: ../../library/tkinter.rst:614
msgid "option name for database lookup"
msgstr "数据库查找的选项名称"

#: ../../library/tkinter.rst:616
msgid "2"
msgstr "2"

#: ../../library/tkinter.rst:616
msgid "option class for database lookup"
msgstr "数据库查找的选项类"

#: ../../library/tkinter.rst:616
msgid "``'Relief'``"
msgstr "``'Relief'``"

#: ../../library/tkinter.rst:619
msgid "3"
msgstr "3"

#: ../../library/tkinter.rst:619
msgid "default value"
msgstr "默认值"

#: ../../library/tkinter.rst:619
msgid "``'raised'``"
msgstr "``'raised'``"

#: ../../library/tkinter.rst:621
msgid "4"
msgstr "4"

#: ../../library/tkinter.rst:621
msgid "current value"
msgstr "当前值"

#: ../../library/tkinter.rst:621
msgid "``'groove'``"
msgstr "``'groove'``"

#: ../../library/tkinter.rst:624
msgid "Example::"
msgstr "示例::"

#: ../../library/tkinter.rst:626
msgid ""
">>> print(fred.config())\n"
"{'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}"
msgstr ""
">>> print(fred.config())\n"
"{'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}"

#: ../../library/tkinter.rst:629
msgid ""
"Of course, the dictionary printed will include all the options available and"
" their values.  This is meant only as an example."
msgstr "当然，输出的字典将包含所有可用选项及其值。这里只是举个例子。"

#: ../../library/tkinter.rst:634
msgid "The Packer"
msgstr "包装器"

#: ../../library/tkinter.rst:638
msgid ""
"The packer is one of Tk's geometry-management mechanisms.    Geometry "
"managers are used to specify the relative positioning of widgets within "
"their container - their mutual *master*.  In contrast to the more cumbersome"
" *placer* (which is used less commonly, and we do not cover here), the "
"packer takes qualitative relationship specification - *above*, *to the left "
"of*, *filling*, etc - and works everything out to determine the exact "
"placement coordinates for you."
msgstr ""
"包装器是 Tk 的形状管理机制之一。 形状（geometry ）管理器用于指定多个部件在容器（共同的 *主* 组件）内的相对位置。与更为麻烦的 "
"*定位器* 相比（不太常用，这里不做介绍），包装器可接受定性的相对关系—— *上面* 、*左边* 、*填充* 等，并确定精确的位置坐标。"

#: ../../library/tkinter.rst:645
msgid ""
"The size of any *master* widget is determined by the size of the \"slave "
"widgets\" inside.  The packer is used to control where slave widgets appear "
"inside the master into which they are packed.  You can pack widgets into "
"frames, and frames into other frames, in order to achieve the kind of layout"
" you desire. Additionally, the arrangement is dynamically adjusted to "
"accommodate incremental changes to the configuration, once it is packed."
msgstr ""
"*主* 部件的大小都由其内部的 “从属部件” "
"的大小决定。包装器用于控制从属部件在主部件中出现的位置。可以把部件包入框架，再把框架包入其他框架中，搭建出所需的布局。此外，只要完成了包装，组件的布局就会进行动态调整，以适应布局参数的变化。"

#: ../../library/tkinter.rst:652
msgid ""
"Note that widgets do not appear until they have had their geometry specified"
" with a geometry manager.  It's a common early mistake to leave out the "
"geometry specification, and then be surprised when the widget is created but"
" nothing appears.  A widget will appear only after it has had, for example, "
"the packer's :meth:`pack` method applied to it."
msgstr ""
"请注意，只有用形状管理器指定几何形状后，部件才会显示出来。忘记设置形状参数是新手常犯的错误，惊讶于创建完部件却啥都没出现。部件只有在应用了类似于打包器的"
" :meth:`pack` 方法之后才会显示在屏幕上。"

#: ../../library/tkinter.rst:658
msgid ""
"The pack() method can be called with keyword-option/value pairs that control"
" where the widget is to appear within its container, and how it is to behave"
" when the main application window is resized.  Here are some examples::"
msgstr ""
"调用 pack() 方法时可以给出由关键字/参数值组成的键值对，以便控制组件在其容器中出现的位置，以及主程序窗口大小变动时的行为。下面是一些例子："

#: ../../library/tkinter.rst:662
msgid ""
"fred.pack()                     # defaults to side = \"top\"\n"
"fred.pack(side=\"left\")\n"
"fred.pack(expand=1)"
msgstr ""
"fred.pack()                     # 默认为 side = \"top\"\n"
"fred.pack(side=\"left\")\n"
"fred.pack(expand=1)"

#: ../../library/tkinter.rst:668
msgid "Packer Options"
msgstr "包装器的参数"

#: ../../library/tkinter.rst:670
msgid ""
"For more extensive information on the packer and the options that it can "
"take, see the man pages and page 183 of John Ousterhout's book."
msgstr "关于包装器及其可接受的参数，更多信息请参阅 man 手册和 John Ousterhout 书中的第 183 页。"

#: ../../library/tkinter.rst:673 ../../library/tkinter.rst:792
msgid "anchor"
msgstr "anchor"

#: ../../library/tkinter.rst:674
msgid ""
"Anchor type.  Denotes where the packer is to place each slave in its parcel."
msgstr "anchor 类型。 表示包装器要放置的每个从属组件的位置。"

#: ../../library/tkinter.rst:676
msgid "expand"
msgstr "expand"

#: ../../library/tkinter.rst:677
msgid "Boolean, ``0`` or ``1``."
msgstr "布尔型，``0`` 或 ``1`` 。"

#: ../../library/tkinter.rst:679
msgid "fill"
msgstr "fill"

#: ../../library/tkinter.rst:680
msgid "Legal values: ``'x'``, ``'y'``, ``'both'``, ``'none'``."
msgstr "合法值为：``'x'`` 、``'y'`` 、``'both'`` 、``'none'``。"

#: ../../library/tkinter.rst:682
msgid "ipadx and ipady"
msgstr "ipadx 和 ipady"

#: ../../library/tkinter.rst:683
msgid ""
"A distance - designating internal padding on each side of the slave widget."
msgstr "距离值，指定从属部件的内边距。"

#: ../../library/tkinter.rst:685
msgid "padx and pady"
msgstr "padx 和 pady"

#: ../../library/tkinter.rst:686
msgid ""
"A distance - designating external padding on each side of the slave widget."
msgstr "距离值，指定从属部件的外边距。"

#: ../../library/tkinter.rst:688
msgid "side"
msgstr "side"

#: ../../library/tkinter.rst:689
msgid "Legal values are: ``'left'``, ``'right'``, ``'top'``, ``'bottom'``."
msgstr "合法值为：``'left'``、 ``'right'`` 、 ``'top'``、 ``'bottom'``。"

#: ../../library/tkinter.rst:693
msgid "Coupling Widget Variables"
msgstr "部件与变量的关联"

#: ../../library/tkinter.rst:695
msgid ""
"The current-value setting of some widgets (like text entry widgets) can be "
"connected directly to application variables by using special options.  These"
" options are ``variable``, ``textvariable``, ``onvalue``, ``offvalue``, and "
"``value``.  This connection works both ways: if the variable changes for any"
" reason, the widget it's connected to will be updated to reflect the new "
"value."
msgstr ""
"通过一些特定参数，某些组件（如文本输入组件）的当前设置可直接与应用程序的变量关联。这些参数包括 ``variable`` 、 "
"``textvariable`` 、 ``onvalue`` 、 ``offvalue``  、 "
"``value``。这种关联是双向的：只要这些变量因任何原因发生变化，其关联的部件就会更新以反映新的参数值。"

#: ../../library/tkinter.rst:701
msgid ""
"Unfortunately, in the current implementation of :mod:`tkinter` it is not "
"possible to hand over an arbitrary Python variable to a widget through a "
"``variable`` or ``textvariable`` option.  The only kinds of variables for "
"which this works are variables that are subclassed from a class called "
"Variable, defined in :mod:`tkinter`."
msgstr ""
"不幸的是，在目前 :mod:`tkinter` 的实现代码中，不可能通过 ``variable`` 或 ``textvariable`` 参数将任意 "
"Python 变量移交给组件。变量只有是 :mod:`tkinter` 中定义的 Variable 类的子类，才能生效。"

#: ../../library/tkinter.rst:707
msgid ""
"There are many useful subclasses of Variable already defined: "
":class:`StringVar`, :class:`IntVar`, :class:`DoubleVar`, and "
":class:`BooleanVar`.  To read the current value of such a variable, call the"
" :meth:`get` method on it, and to change its value you call the :meth:`!set`"
" method.  If you follow this protocol, the widget will always track the "
"value of the variable, with no further intervention on your part."
msgstr ""
"已经定义了很多有用的 Variable 子类： :class:`StringVar` 、 :class:`IntVar` "
"、:class:`DoubleVar` 和 :class:`BooleanVar`。调用 :meth:`get` 方法可以读取这些变量的当前值；调用 "
":meth:`!set` 方法则可改变变量值。只要遵循这种用法，组件就会保持跟踪变量的值，而不需要更多的干预。"

#: ../../library/tkinter.rst:714 ../../library/tkinter.rst:894
msgid "For example::"
msgstr "例如："

#: ../../library/tkinter.rst:716
msgid ""
"import tkinter as tk\n"
"\n"
"class App(tk.Frame):\n"
"    def __init__(self, master):\n"
"        super().__init__(master)\n"
"        self.pack()\n"
"\n"
"        self.entrythingy = tk.Entry()\n"
"        self.entrythingy.pack()\n"
"\n"
"        # Create the application variable.\n"
"        self.contents = tk.StringVar()\n"
"        # Set it to some value.\n"
"        self.contents.set(\"this is a variable\")\n"
"        # Tell the entry widget to watch this variable.\n"
"        self.entrythingy[\"textvariable\"] = self.contents\n"
"\n"
"        # Define a callback for when the user hits return.\n"
"        # It prints the current value of the variable.\n"
"        self.entrythingy.bind('<Key-Return>',\n"
"                             self.print_contents)\n"
"\n"
"    def print_contents(self, event):\n"
"        print(\"Hi. The current entry content is:\",\n"
"              self.contents.get())\n"
"\n"
"root = tk.Tk()\n"
"myapp = App(root)\n"
"myapp.mainloop()"
msgstr ""
"import tkinter as tk\n"
"\n"
"class App(tk.Frame):\n"
"    def __init__(self, master):\n"
"        super().__init__(master)\n"
"        self.pack()\n"
"\n"
"        self.entrythingy = tk.Entry()\n"
"        self.entrythingy.pack()\n"
"\n"
"        # 创建应用程序变量。\n"
"        self.contents = tk.StringVar()\n"
"        # 将其设为特定的值。\n"
"        self.contents.set(\"this is a variable\")\n"
"        # 告诉输入控件监视此变量。\n"
"        self.entrythingy[\"textvariable\"] = self.contents\n"
"\n"
"        # 定义一个回调在用户按下回车时调用。\n"
"        # 它将打印变量的当前值。\n"
"        self.entrythingy.bind('<Key-Return>',\n"
"                             self.print_contents)\n"
"\n"
"    def print_contents(self, event):\n"
"        print(\"Hi. The current entry content is:\",\n"
"              self.contents.get())\n"
"\n"
"root = tk.Tk()\n"
"myapp = App(root)\n"
"myapp.mainloop()"

#: ../../library/tkinter.rst:747
msgid "The Window Manager"
msgstr "窗口管理器"

#: ../../library/tkinter.rst:751
msgid ""
"In Tk, there is a utility command, ``wm``, for interacting with the window "
"manager.  Options to the ``wm`` command allow you to control things like "
"titles, placement, icon bitmaps, and the like.  In :mod:`tkinter`, these "
"commands have been implemented as methods on the :class:`Wm` class.  "
"Toplevel widgets are subclassed from the :class:`Wm` class, and so can call "
"the :class:`Wm` methods directly."
msgstr ""
"Tk 有个实用命令 ``wm``，用于与窗口管理器进行交互。``wm`` 命令的参数可用于控制标题、位置、图标之类的东西。在 "
":mod:`tkinter` 中，这些命令已被实现为 :class:`Wm` 类的方法。顶层部件是 :class:`Wm` 类的子类，所以可以直接调用 "
":class:`Wm` 的这些方法。"

#: ../../library/tkinter.rst:758
msgid ""
"To get at the toplevel window that contains a given widget, you can often "
"just refer to the widget's master.  Of course if the widget has been packed "
"inside of a frame, the master won't represent a toplevel window.  To get at "
"the toplevel window that contains an arbitrary widget, you can call the "
":meth:`_root` method. This method begins with an underscore to denote the "
"fact that this function is part of the implementation, and not an interface "
"to Tk functionality."
msgstr ""
"要获得指定部件所在的顶层窗口，通常只要引用该部件的主窗口即可。当然，如果该部件是包装在框架内的，那么主窗口不代表就是顶层窗口。为了获得任意组件所在的顶层窗口，可以调用"
" :meth:`_root` 方法。该方法以下划线开头，表明其为 Python 实现的代码，而非 Tk 提供的某个接口。"

#: ../../library/tkinter.rst:765
msgid "Here are some examples of typical usage::"
msgstr "以下是一些典型用法："

#: ../../library/tkinter.rst:767
msgid ""
"import tkinter as tk\n"
"\n"
"class App(tk.Frame):\n"
"    def __init__(self, master=None):\n"
"        super().__init__(master)\n"
"        self.pack()\n"
"\n"
"# create the application\n"
"myapp = App()\n"
"\n"
"#\n"
"# here are method calls to the window manager class\n"
"#\n"
"myapp.master.title(\"My Do-Nothing Application\")\n"
"myapp.master.maxsize(1000, 400)\n"
"\n"
"# start the program\n"
"myapp.mainloop()"
msgstr ""
"import tkinter as tk\n"
"\n"
"class App(tk.Frame):\n"
"    def __init__(self, master=None):\n"
"        super().__init__(master)\n"
"        self.pack()\n"
"\n"
"# 创建应用程序\n"
"myapp = App()\n"
"\n"
"#\n"
"# 以下是对窗口管理器类的方法调用\n"
"#\n"
"myapp.master.title(\"My Do-Nothing Application\")\n"
"myapp.master.maxsize(1000, 400)\n"
"\n"
"# 启动程序\n"
"myapp.mainloop()"

#: ../../library/tkinter.rst:788 ../../library/tkinter.rst:790
msgid "Tk Option Data Types"
msgstr "Tk 参数的数据类型"

#: ../../library/tkinter.rst:793
msgid ""
"Legal values are points of the compass: ``\"n\"``, ``\"ne\"``, ``\"e\"``, "
"``\"se\"``, ``\"s\"``, ``\"sw\"``, ``\"w\"``, ``\"nw\"``, and also "
"``\"center\"``."
msgstr ""
"合法值是罗盘的方位点：``\"n\"`` 、``\"ne\"`` 、``\"e\"`` 、``\"se\"`` 、``\"s\"`` "
"、``\"sw\"`` 、``\"w\"`` 、``\"nw\"``  和 ``\"center\"`` 。"

#: ../../library/tkinter.rst:796
msgid "bitmap"
msgstr "bitmap"

#: ../../library/tkinter.rst:797
msgid ""
"There are eight built-in, named bitmaps: ``'error'``, ``'gray25'``, "
"``'gray50'``, ``'hourglass'``, ``'info'``, ``'questhead'``, ``'question'``, "
"``'warning'``.  To specify an X bitmap filename, give the full path to the "
"file, preceded with an ``@``, as in ``\"@/usr/contrib/bitmap/gumby.bit\"``."
msgstr ""
"内置已命名的位图有八个：``'error'``、 ``'gray25'`` 、``'gray50'`` 、``'hourglass'``、 "
"``'info'`` 、``'questhead'`` 、``'question'`` 、``'warning'`` "
"。若要指定位图的文件名，请给出完整路径，前面加一个 ``@``，比如 ``\"@/usr/contrib/bitmap/gumby.bit\"``。"

#: ../../library/tkinter.rst:802
msgid "boolean"
msgstr "boolean"

#: ../../library/tkinter.rst:803
msgid "You can pass integers 0 or 1 or the strings ``\"yes\"`` or ``\"no\"``."
msgstr "可以传入整数 0 或 1，或是字符串 ``\"yes\"`` 或 ``\"no\"``。"

#: ../../library/tkinter.rst:805
msgid "callback"
msgstr "callback -- 回调"

#: ../../library/tkinter.rst:806
msgid "This is any Python function that takes no arguments.  For example::"
msgstr "指任何无需调用参数的 Python 函数。 例如："

#: ../../library/tkinter.rst:808
msgid ""
"def print_it():\n"
"    print(\"hi there\")\n"
"fred[\"command\"] = print_it"
msgstr ""
"def print_it():\n"
"    print(\"hi there\")\n"
"fred[\"command\"] = print_it"

#: ../../library/tkinter.rst:812
msgid "color"
msgstr "color"

#: ../../library/tkinter.rst:813
msgid ""
"Colors can be given as the names of X colors in the rgb.txt file, or as "
"strings representing RGB values in 4 bit: ``\"#RGB\"``, 8 bit: "
"``\"#RRGGBB\"``, 12 bit: ``\"#RRRGGGBBB\"``, or 16 bit: "
"``\"#RRRRGGGGBBBB\"`` ranges, where R,G,B here represent any legal hex "
"digit.  See page 160 of Ousterhout's book for details."
msgstr ""
"可在 rgb.txt 文件中以颜色名的形式给出，或是 RGB 字符串的形式，4 位 ：``\"#RGB\"`` ，8 位 "
"：``\"#RRGGBB\"``，12 位：``\"#RRRGGGBBB\"``，16 位：``\"#RRRRGGGGBBBB\"``，其中R、G、B "
"为合法的十六进制数值。 详见 Ousterhout 书中的第 160 页。"

#: ../../library/tkinter.rst:818
msgid "cursor"
msgstr "cursor"

#: ../../library/tkinter.rst:819
msgid ""
"The standard X cursor names from :file:`cursorfont.h` can be used, without "
"the ``XC_`` prefix.  For example to get a hand cursor (:const:`XC_hand2`), "
"use the string ``\"hand2\"``.  You can also specify a bitmap and mask file "
"of your own. See page 179 of Ousterhout's book."
msgstr ""
"可采用 :file:`cursorfont.h` 中的标准光标名称，去掉 ``XC_`` 前缀。 "
"比如要获取一个手形光标（:const:`XC_hand2`），可以用字符串 ``\"hand2\"``。也可以指定自己的位图和掩码文件作为光标。参见 "
"Ousterhout 书中的第 179 页。"

#: ../../library/tkinter.rst:824
msgid "distance"
msgstr "distance"

#: ../../library/tkinter.rst:825
msgid ""
"Screen distances can be specified in either pixels or absolute distances. "
"Pixels are given as numbers and absolute distances as strings, with the "
"trailing character denoting units: ``c`` for centimetres, ``i`` for inches, "
"``m`` for millimetres, ``p`` for printer's points.  For example, 3.5 inches "
"is expressed as ``\"3.5i\"``."
msgstr ""
"屏幕距离可以用像素或绝对距离来指定。像素是数字，绝对距离是字符串，后面的字符表示单位：``c`` 是厘米，``i`` 是英寸，``m`` "
"是毫米，``p`` 则表示打印机的点数。例如，3.5 英寸可表示为 ``\"3.5i\"``。"

#: ../../library/tkinter.rst:831
msgid "font"
msgstr "font"

#: ../../library/tkinter.rst:832
msgid ""
"Tk uses a list font name format, such as ``{courier 10 bold}``. Font sizes "
"with positive numbers are measured in points; sizes with negative numbers "
"are measured in pixels."
msgstr "Tk 采用一串名称的格式表示字体，例如 ``{courier 10 bold}``。正数的字体大小以点为单位，负数的大小以像素为单位。"

#: ../../library/tkinter.rst:836
msgid "geometry"
msgstr "geometry"

#: ../../library/tkinter.rst:837
msgid ""
"This is a string of the form ``widthxheight``, where width and height are "
"measured in pixels for most widgets (in characters for widgets displaying "
"text). For example: ``fred[\"geometry\"] = \"200x100\"``."
msgstr ""
"这是一个 ``widthxheight`` "
"形式的字符串，其中宽度和高度对于大多数部件来说是以像素为单位的（对于显示文本的部件来说是以字符为单位的）。例如：fred[\"geometry\"] ="
" \"200x100\"。"

#: ../../library/tkinter.rst:841
msgid "justify"
msgstr "justify"

#: ../../library/tkinter.rst:842
msgid ""
"Legal values are the strings: ``\"left\"``, ``\"center\"``, ``\"right\"``, "
"and ``\"fill\"``."
msgstr "合法的值为字符串： ``\"left\"`` 、 ``\"center\"`` 、 ``\"right\"`` 和 ``\"fill\"`` 。"

#: ../../library/tkinter.rst:845
msgid "region"
msgstr "region"

#: ../../library/tkinter.rst:846
msgid ""
"This is a string with four space-delimited elements, each of which is a "
"legal distance (see above).  For example: ``\"2 3 4 5\"`` and ``\"3i 2i 4.5i"
" 2i\"`` and ``\"3c 2c 4c 10.43c\"``  are all legal regions."
msgstr ""
"这是包含四个元素的字符串，以空格分隔，每个元素是表示一个合法的距离值（见上文）。例如：``\"2 3 4 5\"`` 、 ``\"3i 2i 4.5i "
"2i\"`` 和 ``\"3c 2c 4c 10.43c\"`` 都是合法的区域值。"

#: ../../library/tkinter.rst:850
msgid "relief"
msgstr "relief"

#: ../../library/tkinter.rst:851
msgid ""
"Determines what the border style of a widget will be.  Legal values are: "
"``\"raised\"``, ``\"sunken\"``, ``\"flat\"``, ``\"groove\"``, and "
"``\"ridge\"``."
msgstr ""
"决定了组件的边框样式。 合法值包括：``\"raised\"``、 ``\"sunken\"`` 、``\"flat\"`` "
"、``\"groove\"``  和 ``\"ridge\"`` 。"

#: ../../library/tkinter.rst:854
msgid "scrollcommand"
msgstr "scrollcommand"

#: ../../library/tkinter.rst:855
msgid ""
"This is almost always the :meth:`!set` method of some scrollbar widget, but "
"can be any widget method that takes a single argument."
msgstr "这几乎就是带滚动条部件的 :meth:`!set` 方法，但也可是任一只有一个参数的部件方法。"

#: ../../library/tkinter.rst:858
msgid "wrap"
msgstr "wrap"

#: ../../library/tkinter.rst:859
msgid "Must be one of: ``\"none\"``, ``\"char\"``, or ``\"word\"``."
msgstr "只能是以下值之一：``\"none\"`` 、 ``\"char\"`` 、 ``\"word\"``。"

#: ../../library/tkinter.rst:864
msgid "Bindings and Events"
msgstr "绑定和事件"

#: ../../library/tkinter.rst:870
msgid ""
"The bind method from the widget command allows you to watch for certain "
"events and to have a callback function trigger when that event type occurs."
"  The form of the bind method is::"
msgstr "部件命令中的 bind 方法可觉察某些事件，并在事件发生时触发一个回调函数。bind 方法的形式是："

#: ../../library/tkinter.rst:874
msgid "def bind(self, sequence, func, add=''):"
msgstr "def bind(self, sequence, func, add=''):"

#: ../../library/tkinter.rst:876
msgid "where:"
msgstr "其中："

#: ../../library/tkinter.rst:878
msgid "sequence"
msgstr "sequence"

#: ../../library/tkinter.rst:879
msgid ""
"is a string that denotes the target kind of event.  (See the "
":manpage:`bind(3tk)` man page, and page 201 of John Ousterhout's book, "
":title-reference:`Tcl and the Tk Toolkit (2nd edition)`, for details)."
msgstr ""
"是一个表示事件的目标种类的字符串。（详情请看 :manpage:`bind(3tk) 的手册页和 John Outsterhout 的书，:title-"
"reference:`Tcl and the Tk Toolkit (2nd edition)`，第 201 页。）"

#: ../../library/tkinter.rst:883
msgid "func"
msgstr "func"

#: ../../library/tkinter.rst:884
msgid ""
"is a Python function, taking one argument, to be invoked when the event "
"occurs. An Event instance will be passed as the argument. (Functions "
"deployed this way are commonly known as *callbacks*.)"
msgstr ""
"是带有一个参数的 Python 函数，发生事件时将会调用。传入的参数为一个 Event 实例。（以这种方式部署的函数通常称为 *回调函数*。）"

#: ../../library/tkinter.rst:888
msgid "add"
msgstr "add"

#: ../../library/tkinter.rst:889
msgid ""
"is optional, either ``''`` or ``'+'``.  Passing an empty string denotes that"
" this binding is to replace any other bindings that this event is associated"
" with.  Passing a ``'+'`` means that this function is to be added to the "
"list of functions bound to this event type."
msgstr ""
"可选项， ``''`` 或 ``'+'`` 。传入空字符串表示本次绑定将替换与此事件关联的其他所有绑定。传递 ``'+'`` "
"则意味着加入此事件类型已绑定函数的列表中。"

#: ../../library/tkinter.rst:896
msgid ""
"def turn_red(self, event):\n"
"    event.widget[\"activeforeground\"] = \"red\"\n"
"\n"
"self.button.bind(\"<Enter>\", self.turn_red)"
msgstr ""
"def turn_red(self, event):\n"
"    event.widget[\"activeforeground\"] = \"red\"\n"
"\n"
"self.button.bind(\"<Enter>\", self.turn_red)"

#: ../../library/tkinter.rst:901
msgid ""
"Notice how the widget field of the event is being accessed in the "
"``turn_red()`` callback.  This field contains the widget that caught the X "
"event.  The following table lists the other event fields you can access, and"
" how they are denoted in Tk, which can be useful when referring to the Tk "
"man pages."
msgstr ""
"请注意，在 ``turn_red()`` 回调函数中如何访问事件的 widget 字段。该字段包含了捕获 X "
"事件的控件。下表列出了事件可供访问的其他字段，及其在 Tk 中的表示方式，这在查看 Tk 手册时很有用处。"

#: ../../library/tkinter.rst:907
msgid "Tkinter Event Field"
msgstr "Tkinter 事件字段"

#: ../../library/tkinter.rst:909
msgid "%f"
msgstr "%f"

#: ../../library/tkinter.rst:909
msgid "focus"
msgstr "focus"

#: ../../library/tkinter.rst:909
msgid "%A"
msgstr "%A"

#: ../../library/tkinter.rst:909
msgid "char"
msgstr "char"

#: ../../library/tkinter.rst:911
msgid "%h"
msgstr "%h"

#: ../../library/tkinter.rst:911
msgid "height"
msgstr "height"

#: ../../library/tkinter.rst:911
msgid "%E"
msgstr "%E"

#: ../../library/tkinter.rst:911
msgid "send_event"
msgstr "send_event"

#: ../../library/tkinter.rst:913
msgid "%k"
msgstr "%k"

#: ../../library/tkinter.rst:913
msgid "keycode"
msgstr "keycode"

#: ../../library/tkinter.rst:913
msgid "%K"
msgstr "%K"

#: ../../library/tkinter.rst:913
msgid "keysym"
msgstr "keysym"

#: ../../library/tkinter.rst:915
msgid "%s"
msgstr "%s"

#: ../../library/tkinter.rst:915
msgid "state"
msgstr "state"

#: ../../library/tkinter.rst:915
msgid "%N"
msgstr "%N"

#: ../../library/tkinter.rst:915
msgid "keysym_num"
msgstr "keysym_num"

#: ../../library/tkinter.rst:917
msgid "%t"
msgstr "%t"

#: ../../library/tkinter.rst:917
msgid "time"
msgstr "time"

#: ../../library/tkinter.rst:917
msgid "%T"
msgstr "%T"

#: ../../library/tkinter.rst:917
msgid "type"
msgstr "type"

#: ../../library/tkinter.rst:919
msgid "%w"
msgstr "%w"

#: ../../library/tkinter.rst:919
msgid "width"
msgstr "width"

#: ../../library/tkinter.rst:919
msgid "%W"
msgstr "%W"

#: ../../library/tkinter.rst:919
msgid "widget"
msgstr "widget"

#: ../../library/tkinter.rst:921
msgid "%x"
msgstr "%x"

#: ../../library/tkinter.rst:921
msgid "x"
msgstr "x"

#: ../../library/tkinter.rst:921
msgid "%X"
msgstr "%X"

#: ../../library/tkinter.rst:921
msgid "x_root"
msgstr "x_root"

#: ../../library/tkinter.rst:923
msgid "%y"
msgstr "%y"

#: ../../library/tkinter.rst:923
msgid "y"
msgstr "y"

#: ../../library/tkinter.rst:923
msgid "%Y"
msgstr "%Y"

#: ../../library/tkinter.rst:923
msgid "y_root"
msgstr "y_root"

#: ../../library/tkinter.rst:928
msgid "The index Parameter"
msgstr "index 参数"

#: ../../library/tkinter.rst:930
msgid ""
"A number of widgets require \"index\" parameters to be passed.  These are "
"used to point at a specific place in a Text widget, or to particular "
"characters in an Entry widget, or to particular menu items in a Menu widget."
msgstr ""
"很多控件都需要传入 index 参数。该参数用于指明 Text 控件中的位置，或指明 Entry 控件中的字符，或指明 Menu 控件中的菜单项。"

#: ../../library/tkinter.rst:934
msgid "Entry widget indexes (index, view index, etc.)"
msgstr "Entry 控件的索引（index、view index 等）"

#: ../../library/tkinter.rst:935
msgid ""
"Entry widgets have options that refer to character positions in the text "
"being displayed.  You can use these :mod:`tkinter` functions to access these"
" special points in text widgets:"
msgstr "Entry 控件带有索引属性，指向显示文本中的字符位置。这些 :mod:`tkinter`  函数可用于访问文本控件中的这些特定位置："

#: ../../library/tkinter.rst:939
msgid "Text widget indexes"
msgstr "Text 控件的索引"

#: ../../library/tkinter.rst:940
msgid ""
"The index notation for Text widgets is very rich and is best described in "
"the Tk man pages."
msgstr "Text 控件的索引语法非常复杂，最好还是在 Tk 手册中查看。"

#: ../../library/tkinter.rst:943
msgid "Menu indexes (menu.invoke(), menu.entryconfig(), etc.)"
msgstr "Menu 索引（menu.invoke()、menu.entryconfig() 等）"

#: ../../library/tkinter.rst:944
msgid ""
"Some options and methods for menus manipulate specific menu entries. Anytime"
" a menu index is needed for an option or a parameter, you may pass in:"
msgstr "菜单的某些属性和方法可以操纵特定的菜单项。只要属性或参数需要用到菜单索引，就可用以下方式传入："

#: ../../library/tkinter.rst:947
msgid ""
"an integer which refers to the numeric position of the entry in the widget, "
"counted from the top, starting with 0;"
msgstr "一个整数，指的是菜单项的数字位置，从顶部开始计数，从 0 开始；"

#: ../../library/tkinter.rst:950
msgid ""
"the string ``\"active\"``, which refers to the menu position that is "
"currently under the cursor;"
msgstr "字符串 ``\"active\"``，指的是当前光标所在的菜单；"

#: ../../library/tkinter.rst:953
msgid "the string ``\"last\"`` which refers to the last menu item;"
msgstr "字符串 ``\"last\"``，指的是上一个菜单项；"

#: ../../library/tkinter.rst:955
msgid ""
"An integer preceded by ``@``, as in ``@6``, where the integer is interpreted"
" as a y pixel coordinate in the menu's coordinate system;"
msgstr "带有 ``@`` 前缀的整数，比如 ``@6``，这里的整数解释为菜单坐标系中的 y 像素坐标；"

#: ../../library/tkinter.rst:958
msgid ""
"the string ``\"none\"``, which indicates no menu entry at all, most often "
"used with menu.activate() to deactivate all entries, and finally,"
msgstr "表示没有任何菜单条目的字符串 ``\"none\"`` 经常与 menu.activate() 一同被用来停用所有条目，以及 ——"

#: ../../library/tkinter.rst:961
msgid ""
"a text string that is pattern matched against the label of the menu entry, "
"as scanned from the top of the menu to the bottom.  Note that this index "
"type is considered after all the others, which means that matches for menu "
"items labelled ``last``, ``active``, or ``none`` may be interpreted as the "
"above literals, instead."
msgstr ""
"与菜单项的文本标签进行模式匹配的文本串，从菜单顶部扫描到底部。请注意，此索引类型是在其他所有索引类型之后才会考虑的，这意味着文本标签为 "
"``last``、``active`` 或 ``none``  的菜单项匹配成功后，可能会视为这些单词文字本身。"

#: ../../library/tkinter.rst:969
msgid "Images"
msgstr "图片"

#: ../../library/tkinter.rst:971
msgid ""
"Images of different formats can be created through the corresponding "
"subclass of :class:`tkinter.Image`:"
msgstr "通过 :class:`tkinter.Image` 的各种子类可以创建相应格式的图片："

#: ../../library/tkinter.rst:974
msgid ":class:`BitmapImage` for images in XBM format."
msgstr ":class:`BitmapImage` 对应 XBM 格式的图片。"

#: ../../library/tkinter.rst:976
msgid ""
":class:`PhotoImage` for images in PGM, PPM, GIF and PNG formats. The latter "
"is supported starting with Tk 8.6."
msgstr ":class:`PhotoImage` 对应 PGM、PPM、GIF 和 PNG 格式的图片。后者自 Tk 8.6 开始支持。"

#: ../../library/tkinter.rst:979
msgid ""
"Either type of image is created through either the ``file`` or the ``data`` "
"option (other options are available as well)."
msgstr "这两种图片可通过 ``file`` 或 ``data`` 属性创建的（也可能由其他属性创建）。"

#: ../../library/tkinter.rst:982
msgid ""
"Added the :class:`!PhotoImage` method :meth:`!copy_replace` to copy a region"
" from one image to other image, possibly with pixel zooming and/or "
"subsampling. Add *from_coords* parameter to :class:`!PhotoImage` methods "
":meth:`!copy`, :meth:`!zoom` and :meth:`!subsample`. Add *zoom* and "
"*subsample* parameters to :class:`!PhotoImage` method :meth:`!copy`."
msgstr ""
"添加了 :class:`!PhotoImage` 方法 :meth:`!copy_replace` "
"以将一个图像的某个区域拷贝到另一个图像，可能带有像素缩放和/或子采样。 为 :class:`!PhotoImage` 方法 :meth:`!copy`,"
" :meth:`!zoom` 和 :meth:`!subsample` 添加了 *from_coords* 形参。 为 "
":class:`!PhotoImage` 方法 :meth:`!copy` 添加了 *zoom* 和 *subsample* 形参。"

#: ../../library/tkinter.rst:991
msgid ""
"The image object can then be used wherever an ``image`` option is supported "
"by some widget (e.g. labels, buttons, menus). In these cases, Tk will not "
"keep a reference to the image. When the last Python reference to the image "
"object is deleted, the image data is deleted as well, and Tk will display an"
" empty box wherever the image was used."
msgstr ""
"然后可在某些支持 ``image`` 属性的控件中（如标签、按钮、菜单）使用图片对象。这时，Tk 不会保留对图片对象的引用。当图片对象的最后一个 "
"Python 引用被删除时，图片数据也会删除，并且 Tk 会在用到图片对象的地方显示一个空白框。"

#: ../../library/tkinter.rst:999
msgid ""
"The `Pillow <https://python-pillow.org/>`_ package adds support for formats "
"such as BMP, JPEG, TIFF, and WebP, among others."
msgstr ""
"`Pillow <https://python-pillow.org/>`_ 包增加了对 BMP, JPEG, TIFF 和 WebP "
"等多种格式的支持。"

#: ../../library/tkinter.rst:1005
msgid "File Handlers"
msgstr "文件处理程序"

#: ../../library/tkinter.rst:1007
msgid ""
"Tk allows you to register and unregister a callback function which will be "
"called from the Tk mainloop when I/O is possible on a file descriptor. Only "
"one handler may be registered per file descriptor. Example code::"
msgstr ""
"Tk 允许为文件操作注册和注销一个回调函数，当对文件描述符进行 I/O 时，Tk "
"的主循环会调用该回调函数。每个文件描述符只能注册一个处理程序。示例代码如下："

#: ../../library/tkinter.rst:1011
msgid ""
"import tkinter\n"
"widget = tkinter.Tk()\n"
"mask = tkinter.READABLE | tkinter.WRITABLE\n"
"widget.tk.createfilehandler(file, mask, callback)\n"
"...\n"
"widget.tk.deletefilehandler(file)"
msgstr ""
"import tkinter\n"
"widget = tkinter.Tk()\n"
"mask = tkinter.READABLE | tkinter.WRITABLE\n"
"widget.tk.createfilehandler(file, mask, callback)\n"
"...\n"
"widget.tk.deletefilehandler(file)"

#: ../../library/tkinter.rst:1018
msgid "This feature is not available on Windows."
msgstr "在 Windows 系统中不可用。"

#: ../../library/tkinter.rst:1020
msgid ""
"Since you don't know how many bytes are available for reading, you may not "
"want to use the :class:`~io.BufferedIOBase` or :class:`~io.TextIOBase` "
":meth:`~io.BufferedIOBase.read` or :meth:`~io.IOBase.readline` methods, "
"since these will insist on reading a predefined number of bytes. For "
"sockets, the :meth:`~socket.socket.recv` or :meth:`~socket.socket.recvfrom` "
"methods will work fine; for other files, use raw reads or "
"``os.read(file.fileno(), maxbytecount)``."
msgstr ""
"由于不知道可读取多少字节，你可能不希望使用 :class:`~io.BufferedIOBase` 或 :class:`~io.TextIOBase` "
"的 :meth:`~io.BufferedIOBase.read` 或 :meth:`~io.IOBase.readline` "
"方法，因为这些方法必须读取预定数量的字节。 对于套接字，可使用 :meth:`~socket.socket.recv` 或 "
":meth:`~socket.socket.recvfrom` 方法；对于其他文件，可使用原始读取方法或 "
"``os.read(file.fileno(), maxbytecount)``。"

#: ../../library/tkinter.rst:1031
msgid ""
"Registers the file handler callback function *func*. The *file* argument may"
" either be an object with a :meth:`~io.IOBase.fileno` method (such as a file"
" or socket object), or an integer file descriptor. The *mask* argument is an"
" ORed combination of any of the three constants below. The callback is "
"called as follows::"
msgstr ""
"注册文件处理程序的回调函数 *func*。 *file* 参数可以是具备 :meth:`~io.IOBase.fileno` "
"方法的对象（例如文件或套接字对象），也可以是整数文件描述符。 *mask* 参数是下述三个常量的逻辑“或”组合。回调函数将用以下格式调用："

#: ../../library/tkinter.rst:1037
msgid "callback(file, mask)"
msgstr "callback(file, mask)"

#: ../../library/tkinter.rst:1042
msgid "Unregisters a file handler."
msgstr "注销文件处理函数。"

#: ../../library/tkinter.rst:1049
msgid "Constants used in the *mask* arguments."
msgstr " *mask* 参数用到的常量。"

#: ../../library/tkinter.rst:636
msgid "packing (widgets)"
msgstr "packing (部件)"

#: ../../library/tkinter.rst:749
msgid "window manager (widgets)"
msgstr "window manager (部件)"

#: ../../library/tkinter.rst:866
msgid "bind (widgets)"
msgstr "bind (部件)"

#: ../../library/tkinter.rst:866
msgid "events (widgets)"
msgstr "events (部件)"
