# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 15:01+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/csv.rst:2
msgid ":mod:`!csv` --- CSV File Reading and Writing"
msgstr ":mod:`!csv` --- CSV 文件读写"

#: ../../library/csv.rst:9
msgid "**Source code:** :source:`Lib/csv.py`"
msgstr "**源代码：** :source:`Lib/csv.py`"

#: ../../library/csv.rst:17
msgid ""
"The so-called CSV (Comma Separated Values) format is the most common import "
"and export format for spreadsheets and databases.  CSV format was used for "
"many years prior to attempts to describe the format in a standardized way in"
" :rfc:`4180`.  The lack of a well-defined standard means that subtle "
"differences often exist in the data produced and consumed by different "
"applications.  These differences can make it annoying to process CSV files "
"from multiple sources. Still, while the delimiters and quoting characters "
"vary, the overall format is similar enough that it is possible to write a "
"single module which can efficiently manipulate such data, hiding the details"
" of reading and writing the data from the programmer."
msgstr ""
"CSV (Comma Separated Values) 格式是电子表格和数据库中最常见的输入、输出文件格式。在 :rfc:`4180` "
"规范推出的很多年前，CSV 格式就已经被开始使用了，由于当时并没有合理的标准，不同应用程序读写的数据会存在细微的差别。这种差别让处理多个来源的 CSV "
"文件变得困难。但尽管分隔符会变化，此类文件的大致格式是相似的，所以编写一个单独的模块以高效处理此类数据，将程序员从读写数据的繁琐细节中解放出来是有可能的。"

#: ../../library/csv.rst:28
msgid ""
"The :mod:`csv` module implements classes to read and write tabular data in "
"CSV format.  It allows programmers to say, \"write this data in the format "
"preferred by Excel,\" or \"read data from this file which was generated by "
"Excel,\" without knowing the precise details of the CSV format used by "
"Excel.  Programmers can also describe the CSV formats understood by other "
"applications or define their own special-purpose CSV formats."
msgstr ""
":mod:`csv` 模块实现了 CSV 格式表单数据的读写。其提供了诸如“以兼容 Excel 的方式输出数据文件”或“读取 Excel "
"程序输出的数据文件”的功能，程序员无需知道 Excel 所采用 CSV 格式的细节。此模块同样可以用于定义其他应用程序可用的 CSV "
"格式或定义特定需求的 CSV 格式。"

#: ../../library/csv.rst:35
msgid ""
"The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and"
" write sequences.  Programmers can also read and write data in dictionary "
"form using the :class:`DictReader` and :class:`DictWriter` classes."
msgstr ""
":mod:`csv` 模块中的 :class:`reader` 类和 :class:`writer` 类可用于读写序列化的数据。也可使用 "
":class:`DictReader` 类和 :class:`DictWriter` 类以字典的形式读写数据。"

#: ../../library/csv.rst:41
msgid ":pep:`305` - CSV File API"
msgstr "该实现在“Python 增强提议” - PEP `305` (CSV 文件 API)  中被提出"

#: ../../library/csv.rst:42
msgid ""
"The Python Enhancement Proposal which proposed this addition to Python."
msgstr "《Python 增强提议》提出了对 Python 的这一补充。"

#: ../../library/csv.rst:48
msgid "Module Contents"
msgstr "模块内容"

#: ../../library/csv.rst:50
msgid "The :mod:`csv` module defines the following functions:"
msgstr ":mod:`csv` 模块定义了以下函数："

#: ../../library/csv.rst:58
msgid ""
"Return a :ref:`reader object <reader-objects>` that will process lines from "
"the given *csvfile*.  A csvfile must be an iterable of strings, each in the "
"reader's defined csv format. A csvfile is most commonly a file-like object "
"or list. If *csvfile* is a file object, it should be opened with "
"``newline=''``. [1]_  An optional *dialect* parameter can be given which is "
"used to define a set of parameters specific to a particular CSV dialect.  It"
" may be an instance of a subclass of the :class:`Dialect` class or one of "
"the strings returned by the :func:`list_dialects` function.  The other "
"optional *fmtparams* keyword arguments can be given to override individual "
"formatting parameters in the current dialect.  For full details about the "
"dialect and formatting parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"返回一个 :ref:`reader 对象 <reader-objects>`，该对象将处理给定 *csvfile* 中的行。 csvfile "
"必须是一个包含字符串的可迭代对象，使用 reader 所定义的 csv 格式。 csvfile 通常是一个文件型对象或列表。 如果 *csvfile* "
"是一个文件对象，则打开它时应设置 ``newline=''``. [1]_  给定可选 *dialect* 形参将被用于定义一组专属于特定 CSV "
"变种的形参。 它可以是 :class:`Dialect` 类的子类的实例，或是 :func:`list_dialects` 函数所返回的字符串之一。 "
"另一个可选关键字形参 *fmtparams* 可被用来覆盖当前变种中的单个格式形参。 有关变种和格式设置形参的完整细节，请参阅 :ref:`csv-"
"fmt-params` 一节。"

#: ../../library/csv.rst:72
msgid ""
"Each row read from the csv file is returned as a list of strings.  No "
"automatic data type conversion is performed unless the "
":data:`QUOTE_NONNUMERIC` format option is specified (in which case unquoted "
"fields are transformed into floats)."
msgstr ""
"Each row read from the从 csv 文件读取的每一行都将返回为一个字符串列表。 除非指定了 "
":data:`QUOTE_NONNUMERIC` 格式选项（在这种情况下未加引号的字段会被转换为浮点数）否则不会执行自动数据类型转换。"

#: ../../library/csv.rst:76 ../../library/csv.rst:106
#: ../../library/csv.rst:181 ../../library/csv.rst:219
msgid "A short usage example::"
msgstr "一个简短的用法示例::"

#: ../../library/csv.rst:78
msgid ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"
msgstr ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"

#: ../../library/csv.rst:89
msgid ""
"Return a writer object responsible for converting the user's data into "
"delimited strings on the given file-like object.  *csvfile* can be any "
"object with a :meth:`~io.TextIOBase.write` method.  If *csvfile* is a file "
"object, it should be opened with ``newline=''`` [1]_.  An optional *dialect*"
" parameter can be given which is used to define a set of parameters specific"
" to a particular CSV dialect.  It may be an instance of a subclass of the "
":class:`Dialect` class or one of the strings returned by the "
":func:`list_dialects` function.  The other optional *fmtparams* keyword "
"arguments can be given to override individual formatting parameters in the "
"current dialect.  For full details about dialects and formatting parameters,"
" see the :ref:`csv-fmt-params` section. To make it as easy as possible to "
"interface with modules which implement the DB API, the value :const:`None` "
"is written as the empty string.  While this isn't a reversible "
"transformation, it makes it easier to dump SQL NULL data values to CSV files"
" without preprocessing the data returned from a ``cursor.fetch*`` call. All "
"other non-string data are stringified with :func:`str` before being written."
msgstr ""
"返回一个 writer 对象，该对象负责将用户的数据在给定的文件型对象上转换为带分隔符的字符串。 *csvfile* 可以是任何具有 "
":meth:`~io.TextIOBase.write` 方法的对象。 如果 *csvfile* 是一个文件对象，则打开它时应使用 "
"``newline=''`` [1]_。 可以给出可选的 *dialect* 形参用来定义一组特定 CSV 变种专属的形参。 它可以是 "
":class:`Dialect` 类的某个子类的实例或是 :func:`list_dialects` 函数所返回的字符串之一。 还可以给出另一个可选的 "
"*fmtparams* 关键字参数来覆盖当前变种中的单个格式化形参。 有关各个变种和格式化形参的完整细节，请参阅 :ref:`csv-fmt-"
"params` 部分。 为了尽量简化与实现 DB API 的模块之间的接口，可以将 :const:`None` 作为空字符串写入。 "
"虽然这个转换是不可逆的，但它可以简化 SQL NULL 数据值到 CSV 文件的转储而无需预处理从 ``cursor.fetch*`` 调用返回的数据。"
" 在被写入之前所有其他非字符串数据都会先用 :func:`str` 来转换为字符串。"

#: ../../library/csv.rst:108
msgid ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"
msgstr ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"

#: ../../library/csv.rst:118
msgid ""
"Associate *dialect* with *name*.  *name* must be a string. The dialect can "
"be specified either by passing a sub-class of :class:`Dialect`, or by "
"*fmtparams* keyword arguments, or both, with keyword arguments overriding "
"parameters of the dialect. For full details about dialects and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"将 *dialect* 与 *name* 关联起来。  *name* 必须是字符串。 变种的指定可以通过传入一个 :class:`Dialect` "
"的子类，或通过 *fmtparams* 关键字参数，或是两者同时传入，此时关键字参数会覆盖 dialect 形参。 "
"有关变种和格式化形参的完整细节，请参阅 :ref:`csv-fmt-params` 部分。"

#: ../../library/csv.rst:127
msgid ""
"Delete the dialect associated with *name* from the dialect registry.  An "
":exc:`Error` is raised if *name* is not a registered dialect name."
msgstr "从变种注册表中删除 *name* 对应的变种。如果 *name* 不是已注册的变种名称，则抛出 :exc:`Error` 异常。"

#: ../../library/csv.rst:133
msgid ""
"Return the dialect associated with *name*.  An :exc:`Error` is raised if "
"*name* is not a registered dialect name.  This function returns an immutable"
" :class:`Dialect`."
msgstr ""
"返回 *name* 对应的变种。如果 *name* 不是已注册的变种名称，则抛出 :exc:`Error` 异常。该函数返回的是不可变的 "
":class:`Dialect` 对象。"

#: ../../library/csv.rst:139
msgid "Return the names of all registered dialects."
msgstr "返回所有已注册变种的名称。"

#: ../../library/csv.rst:144
msgid ""
"Returns the current maximum field size allowed by the parser. If *new_limit*"
" is given, this becomes the new limit."
msgstr "返回解析器当前允许的最大字段大小。如果指定了 *new_limit*，则它将成为新的最大字段大小。"

#: ../../library/csv.rst:148
msgid "The :mod:`csv` module defines the following classes:"
msgstr ":mod:`csv` 模块定义了以下类："

#: ../../library/csv.rst:153
msgid ""
"Create an object that operates like a regular reader but maps the "
"information in each row to a :class:`dict` whose keys are given by the "
"optional *fieldnames* parameter."
msgstr ""
"创建一个对象，该对象在操作上类似于常规 reader，但是将每行中的信息映射到一个 :class:`dict`，该 dict 的键由 "
"*fieldnames* 可选参数给出。"

#: ../../library/csv.rst:157
msgid ""
"The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is "
"omitted, the values in the first row of file *f* will be used as the "
"fieldnames and will be omitted from the results. If *fieldnames* is "
"provided, they will be used and the first row will be included in the "
"results.  Regardless of how the fieldnames are determined, the dictionary "
"preserves their original ordering."
msgstr ""
"*fieldnames* 形参是一个 :term:`sequence`。 如果省略 *fieldnames*，则文件 *f* "
"第一行中的值将用作字段名并将从结果中去除。 如果提供了 *fieldnames*，它们将被使用而第一行将包括在结果中。 "
"无论字段名是如何确定的，字典都将保留其原始顺序。"

#: ../../library/csv.rst:164
msgid ""
"If a row has more fields than fieldnames, the remaining data is put in a "
"list and stored with the fieldname specified by *restkey* (which defaults to"
" ``None``).  If a non-blank row has fewer fields than fieldnames, the "
"missing values are filled-in with the value of *restval* (which defaults to "
"``None``)."
msgstr ""
"如果某一行中的字段多于字段名，则剩余数据会被放入一个列表，并与 *restkey* 所指定的字段名 (默认为 ``None``) 一起保存。 "
"如果某个非空白行的字段少于字段名，则缺失的值会使用 *restval* 的值来填充 (默认为 ``None``)。"

#: ../../library/csv.rst:170
msgid ""
"All other optional or keyword arguments are passed to the underlying "
":class:`reader` instance."
msgstr "所有其他可选或关键字参数都传递给底层的 :class:`reader` 实例。"

#: ../../library/csv.rst:173 ../../library/csv.rst:217
msgid ""
"If the argument passed to *fieldnames* is an iterator, it will be coerced to"
" a :class:`list`."
msgstr "如果传给 *fieldnames* 的参数是一个迭代器，它将被强制转换为 :class:`list`。"

#: ../../library/csv.rst:175
msgid "Returned rows are now of type :class:`OrderedDict`."
msgstr "返回的行现在的类型是 :class:`OrderedDict`。"

#: ../../library/csv.rst:178
msgid "Returned rows are now of type :class:`dict`."
msgstr "现在，返回的行是 :class:`dict` 类型。"

#: ../../library/csv.rst:183
msgid ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"
msgstr ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"

#: ../../library/csv.rst:199
msgid ""
"Create an object which operates like a regular writer but maps dictionaries "
"onto output rows.  The *fieldnames* parameter is a :mod:`sequence "
"<collections.abc>` of keys that identify the order in which values in the "
"dictionary passed to the :meth:`~csvwriter.writerow` method are written to "
"file *f*.  The optional *restval* parameter specifies the value to be "
"written if the dictionary is missing a key in *fieldnames*.  If the "
"dictionary passed to the :meth:`~csvwriter.writerow` method contains a key "
"not found in *fieldnames*, the optional *extrasaction* parameter indicates "
"what action to take. If it is set to ``'raise'``, the default value, a "
":exc:`ValueError` is raised. If it is set to ``'ignore'``, extra values in "
"the dictionary are ignored. Any other optional or keyword arguments are "
"passed to the underlying :class:`writer` instance."
msgstr ""
"创建一个对象，该对象在操作上类似常规 writer，但会将字典映射到输出行。 *fieldnames* 形参是一个由键组成的 :mod:`序列 "
"<collections.abc>`，它指定字典中要传给 :meth:`~csvwriter.writerow` 方法并写入文件 *f* 的值的顺序。 "
"如果字典没有 *fieldnames* 中的键，则可选的 *restval* 形参将指明要写入的值。 如果传递给 "
":meth:`~csvwriter.writerow` 方法包含的键在 *fieldnames* 中找不到，则可选的 *extrasaction* "
"形参将指明要执行的操作。 如果将其设为默认值 ``'raise'``，则会引发 :exc:`ValueError`。 如果将其设为 "
"``'ignore'``，则字典中额外的值将被忽略。 任何其他可选或关键字参数都将被传递给下层的 :class:`writer` 实例。"

#: ../../library/csv.rst:214
msgid ""
"Note that unlike the :class:`DictReader` class, the *fieldnames* parameter "
"of the :class:`DictWriter` class is not optional."
msgstr ""
"注意，与 :class:`DictReader` 类不同，:class:`DictWriter` 类的 *fieldnames* 参数不是可选参数。"

#: ../../library/csv.rst:221
msgid ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"
msgstr ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"

#: ../../library/csv.rst:235
msgid ""
"The :class:`Dialect` class is a container class whose attributes contain "
"information for how to handle doublequotes, whitespace, delimiters, etc. Due"
" to the lack of a strict CSV specification, different applications produce "
"subtly different CSV data.  :class:`Dialect` instances define how "
":class:`reader` and :class:`writer` instances behave."
msgstr ""
":class:`Dialect` 类是一个容器类，其属性包含有如何处理双引号、空白符、分隔符等的信息。 由于缺少严格的 CSV "
"规格描述，不同的应用程序会产生略有差别的 CSV 数据。  :class:`Dialect` 实例定义了 :class:`reader` 和 "
":class:`writer` 实例将具有怎样的行为。"

#: ../../library/csv.rst:241
msgid ""
"All available :class:`Dialect` names are returned by :func:`list_dialects`, "
"and they can be registered with specific :class:`reader` and :class:`writer`"
" classes through their initializer (``__init__``) functions like this::"
msgstr ""
"所有可用的 :class:`Dialect` 名称会由 :func:`list_dialects` 返回，并且它们可由特定的 "
":class:`reader` 和 :class:`writer` 类通过它们的初始化函数 (``__init__``) 来注册，例如::"

#: ../../library/csv.rst:245
msgid ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"
msgstr ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"

#: ../../library/csv.rst:253
msgid ""
"The :class:`excel` class defines the usual properties of an Excel-generated "
"CSV file.  It is registered with the dialect name ``'excel'``."
msgstr ":class:`excel` 类定义了 Excel 生成的 CSV 文件的常规属性。它在变种注册表中的名称是 ``'excel'``。"

#: ../../library/csv.rst:259
msgid ""
"The :class:`excel_tab` class defines the usual properties of an Excel-"
"generated TAB-delimited file.  It is registered with the dialect name "
"``'excel-tab'``."
msgstr ""
":class:`excel_tab` 类定义了 Excel 生成的、制表符分隔的 CSV 文件的常规属性。它在变种注册表中的名称是 ``'excel-"
"tab'``。"

#: ../../library/csv.rst:265
msgid ""
"The :class:`unix_dialect` class defines the usual properties of a CSV file "
"generated on UNIX systems, i.e. using ``'\\n'`` as line terminator and "
"quoting all fields.  It is registered with the dialect name ``'unix'``."
msgstr ""
":class:`unix_dialect` 类定义了在 UNIX 系统上生成的 CSV 文件的常规属性，即使用 ``'\\n'`` "
"作为换行符，且所有字段都有引号包围。它在变种注册表中的名称是 ``'unix'``。"

#: ../../library/csv.rst:274
msgid "The :class:`Sniffer` class is used to deduce the format of a CSV file."
msgstr ":class:`Sniffer` 类用于推断 CSV 文件的格式。"

#: ../../library/csv.rst:276
msgid "The :class:`Sniffer` class provides two methods:"
msgstr ":class:`Sniffer` 类提供了两个方法："

#: ../../library/csv.rst:280
msgid ""
"Analyze the given *sample* and return a :class:`Dialect` subclass reflecting"
" the parameters found.  If the optional *delimiters* parameter is given, it "
"is interpreted as a string containing possible valid delimiter characters."
msgstr ""
"分析给定的 *sample* 并返回一个 :class:`Dialect` 子类，该子类中包含了分析出的格式参数。如果给出可选的 "
"*delimiters* 参数，则该参数会被解释为字符串，该字符串包含了可能的有效定界符。"

#: ../../library/csv.rst:288
msgid ""
"Analyze the sample text (presumed to be in CSV format) and return "
":const:`True` if the first row appears to be a series of column headers. "
"Inspecting each column, one of two key criteria will be considered to "
"estimate if the sample contains a header:"
msgstr ""
"分析 sample 文本（假定为 CSV 格式），如果发现其首行为一组列标题则返回 :const:`True`。 "
"在检查每一列时，将考虑是否满足两个关键标准之一来估计 sample 是否包含标题:"

#: ../../library/csv.rst:293
msgid "the second through n-th rows contain numeric values"
msgstr "第二至第 n 行包含数字值"

#: ../../library/csv.rst:294
msgid ""
"the second through n-th rows contain strings where at least one value's "
"length differs from that of the putative header of that column."
msgstr "第二至第 n 行包含字符串值，其中至少有一个值的长度与该列预期标题的长度不同。"

#: ../../library/csv.rst:297
msgid ""
"Twenty rows after the first row are sampled; if more than half of columns + "
"rows meet the criteria, :const:`True` is returned."
msgstr "会对第一行之后的二十行进行采样；如果有超过一半的列 + 行符合标准，则返回 :const:`True`。"

#: ../../library/csv.rst:302
msgid ""
"This method is a rough heuristic and may produce both false positives and "
"negatives."
msgstr "此方法是一个粗略的启发式方式，有可能产生错误的真值和假值。"

#: ../../library/csv.rst:305
msgid "An example for :class:`Sniffer` use::"
msgstr "使用 :class:`Sniffer` 的示例："

#: ../../library/csv.rst:307
msgid ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... process CSV file contents here ..."
msgstr ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... 在此处理 CSV 文件内容 ..."

#: ../../library/csv.rst:316
msgid "The :mod:`csv` module defines the following constants:"
msgstr ":mod:`csv` 模块定义了以下常量："

#: ../../library/csv.rst:320
msgid "Instructs :class:`writer` objects to quote all fields."
msgstr "指示 :class:`writer` 对象给所有字段加上引号。"

#: ../../library/csv.rst:325
msgid ""
"Instructs :class:`writer` objects to only quote those fields which contain "
"special characters such as *delimiter*, *quotechar*, ``'\\r'``, ``'\\n'`` or"
" any of the characters in *lineterminator*."
msgstr ""
"指示 :class:`writer` 对象仅对包含特殊字符如 *delimiter*, *quotechar*, ``'\\r'``, "
"``'\\n'`` 或 *lineterminator* 中的任何字符的字段加引号。"

#: ../../library/csv.rst:332
msgid "Instructs :class:`writer` objects to quote all non-numeric fields."
msgstr "指示 :class:`writer` 对象为所有非数字字段加上引号。"

#: ../../library/csv.rst:334
msgid ""
"Instructs :class:`reader` objects to convert all non-quoted fields to type "
":class:`float`."
msgstr "指示 :class:`reader` 对象将所有未加引号的字段转换为 :class:`float` 类型。"

#: ../../library/csv.rst:337
msgid ""
"Some numeric types, such as :class:`bool`, :class:`~fractions.Fraction`, or "
":class:`~enum.IntEnum`, have a string representation that cannot be "
"converted to :class:`float`. They cannot be read in the "
":data:`QUOTE_NONNUMERIC` and :data:`QUOTE_STRINGS` modes."
msgstr ""
"某些数字类型，如 :class:`bool`, :class:`~fractions.Fraction` 或 "
":class:`~enum.IntEnum`，具有不可被转换为 :class:`float` 的字符串表示形式。 它们无法在 "
":data:`QUOTE_NONNUMERIC` 和 :data:`QUOTE_STRINGS` 模式下被读取。"

#: ../../library/csv.rst:345
msgid ""
"Instructs :class:`writer` objects to never quote fields. When the current "
"*delimiter*, *quotechar*, *escapechar*, ``'\\r'``, ``'\\n'`` or any of the "
"characters in *lineterminator* occurs in output data it is preceded by the "
"current *escapechar* character. If *escapechar* is not set, the writer will "
"raise :exc:`Error` if any characters that require escaping are encountered. "
"Set *quotechar* to ``None`` to prevent its escaping."
msgstr ""
"指示 :class:`writer` 对象不对字段加引号。 在现有的 *delimiter*, *quotechar*, *escapechar*, "
"``'\\r'``, ``'\\n'`` 或 *lineterminator* 中的任何字符出现在输出数据中的时候它前面会添加当前的 "
"*escapechar*。 如果未设置*escapechar*，则在遇到任何需要转义的字符时 writer 都会引发 :exc:`Error`。 将 "
"*quotechar* 设为 ``None`` 以避免进行转义。"

#: ../../library/csv.rst:353
msgid ""
"Instructs :class:`reader` objects to perform no special processing of quote "
"characters."
msgstr "指示 :class:`reader` 对象不对引号字符执行特殊处理。"

#: ../../library/csv.rst:357
msgid ""
"Instructs :class:`writer` objects to quote all fields which are not "
"``None``.  This is similar to :data:`QUOTE_ALL`, except that if a field "
"value is ``None`` an empty (unquoted) string is written."
msgstr ""
"指示 :class:`writer` 对象为所有不为 ``None`` 的字段加引号。 这类似于 "
":data:`QUOTE_ALL`，区别是如果一个字段值为 ``None`` 则会写入一个（不带引号的）空字符串。"

#: ../../library/csv.rst:361
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) field as "
"``None`` and to otherwise behave as :data:`QUOTE_ALL`."
msgstr ""
"指示 :class:`reader` 对象将（不带引号的）空字段解读为 ``None`` 并在其他情况下采取与 :data:`QUOTE_ALL` "
"相同的行为。"

#: ../../library/csv.rst:368
msgid ""
"Instructs :class:`writer` objects to always place quotes around fields which"
" are strings.  This is similar to :data:`QUOTE_NONNUMERIC`, except that if a"
" field value is ``None`` an empty (unquoted) string is written."
msgstr ""
"指示 :class:`writer` 对象总是为字符串字段加引号。 这类似于 :data:`QUOTE_NONNUMERIC`，区别是如果一个字段值为 "
"``None`` 则会写入一个（不带引号的）空字符串。"

#: ../../library/csv.rst:372
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) string as"
" ``None`` and to otherwise behave as :data:`QUOTE_NONNUMERIC`."
msgstr ""
"指示 :class:`reader` 对象将（不带引号的）空字符串解读为 ``None`` 并在其他情况下采取与 "
":data:`QUOTE_NONNUMERIC` 相同的行为。"

#: ../../library/csv.rst:377
msgid "The :mod:`csv` module defines the following exception:"
msgstr ":mod:`csv` 模块定义了以下异常："

#: ../../library/csv.rst:382
msgid "Raised by any of the functions when an error is detected."
msgstr "该异常可能由任何发生错误的函数抛出。"

#: ../../library/csv.rst:387
msgid "Dialects and Formatting Parameters"
msgstr "变种与格式参数"

#: ../../library/csv.rst:389
msgid ""
"To make it easier to specify the format of input and output records, "
"specific formatting parameters are grouped together into dialects.  A "
"dialect is a subclass of the :class:`Dialect` class containing various "
"attributes describing the format of the CSV file.  When creating "
":class:`reader` or :class:`writer` objects, the programmer can specify a "
"string or a subclass of the :class:`Dialect` class as the dialect parameter."
"  In addition to, or instead of, the *dialect* parameter, the programmer can"
" also specify individual formatting parameters, which have the same names as"
" the attributes defined below for the :class:`Dialect` class."
msgstr ""
"为了更容易地指定输入和输出记录的格式，特定的多个格式化形参将组合成为不同的 dialect。 特定的 dialect 是 "
":class:`Dialect` 类的一个子类，它包含多个用于描述 CSV 文件的格式的属性。 当创建 :class:`reader` 或 "
":class:`writer` 对象时，程序员可以指定一个字符串或 :class:`Dialect` 类的子类作为 dialect 形参。 作为对 "
"*dialect* 形参的补充或替代，程序员还可以指定单独的格式化形参，它们的名称与 :class:`Dialect` 类所定义的以下属性相同。"

#: ../../library/csv.rst:399
msgid "Dialects support the following attributes:"
msgstr "Dialect 类支持以下属性："

#: ../../library/csv.rst:404
msgid ""
"A one-character string used to separate fields.  It defaults to ``','``."
msgstr "一个用于分隔字段的单字符，默认为 ``','``。"

#: ../../library/csv.rst:409
msgid ""
"Controls how instances of *quotechar* appearing inside a field should "
"themselves be quoted.  When :const:`True`, the character is doubled. When "
":const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It"
" defaults to :const:`True`."
msgstr ""
"控制出现在字段中的 *引号字符* 本身应如何被引出。当该属性为 :const:`True` 时，双写引号字符。如果该属性为 "
":const:`False`，则在 *引号字符* 的前面放置 *转义符*。默认值为 :const:`True`。"

#: ../../library/csv.rst:414
msgid ""
"On output, if *doublequote* is :const:`False` and no *escapechar* is set, "
":exc:`Error` is raised if a *quotechar* is found in a field."
msgstr ""
"在输出时，如果 *doublequote* 是 :const:`False`，且 *转义符* 未指定，且在字段中发现 *引号字符* 时，会抛出 "
":exc:`Error` 异常。"

#: ../../library/csv.rst:420
msgid ""
"A one-character string used by the writer to escape characters that require "
"escaping:"
msgstr "被 writer 用来对需要转义的字符进行转义的单字符字符串："

#: ../../library/csv.rst:423
msgid ""
"the *delimiter*, the *quotechar*, ``'\\r'``, ``'\\n'`` and any of the "
"characters in *lineterminator* are escaped if *quoting* is set to "
":const:`QUOTE_NONE`;"
msgstr ""
"如果 *quoting* 被设为 :const:`QUOTE_NONE` 则 *delimiter*, *quotechar*, ``'\\r'``, "
"``'\\n'`` 以及 *lineterminator* 中的任何字符都会被转义；"

#: ../../library/csv.rst:426
msgid "the *quotechar* is escaped if *doublequote* is :const:`False`;"
msgstr "如果 *doublequote* 为 :const:`False` 则 *quotechar* 会被转义；"

#: ../../library/csv.rst:427
msgid "the *escapechar* itself."
msgstr "*escapechar* 本身。"

#: ../../library/csv.rst:429
msgid ""
"On reading, the *escapechar* removes any special meaning from the following "
"character. It defaults to :const:`None`, which disables escaping."
msgstr "在读取时，*escapechar* 将从以下字符中去除任何特殊含义。 它默认为 :const:`None`，表示禁用转义。"

#: ../../library/csv.rst:432
msgid "An empty *escapechar* is not allowed."
msgstr "不允许空的 *escapechar*。"

#: ../../library/csv.rst:437
msgid ""
"The string used to terminate lines produced by the :class:`writer`. It "
"defaults to ``'\\r\\n'``."
msgstr "放在 :class:`writer` 产生的行的结尾，默认为 ``'\\r\\n'``。"

#: ../../library/csv.rst:442
msgid ""
"The :class:`reader` is hard-coded to recognise either ``'\\r'`` or ``'\\n'``"
" as end-of-line, and ignores *lineterminator*. This behavior may change in "
"the future."
msgstr ""
":class:`reader` 经过硬编码，会识别 ``'\\r'`` 或 ``'\\n'`` 作为行尾，并忽略 "
"*lineterminator*。未来可能会更改这一行为。"

#: ../../library/csv.rst:449
msgid ""
"A one-character string used to quote fields containing special characters, "
"such as the *delimiter* or the *quotechar*, or which contain new-line "
"characters (``'\\r'``, ``'\\n'`` or any of the characters in "
"*lineterminator*). It defaults to ``'\"'``. Can be set to ``None`` to "
"prevent escaping ``'\"'`` if *quoting* is set to :const:`QUOTE_NONE`."
msgstr ""

#: ../../library/csv.rst:456
msgid "An empty *quotechar* is not allowed."
msgstr "不允许空的 *quotechar*。"

#: ../../library/csv.rst:461
msgid ""
"Controls when quotes should be generated by the writer and recognised by the"
" reader.  It can take on any of the :ref:`QUOTE_\\* constants <csv-"
"constants>` and defaults to :const:`QUOTE_MINIMAL` if *quotechar* is not "
"``None``, and :const:`QUOTE_NONE` otherwise."
msgstr ""

#: ../../library/csv.rst:469
msgid ""
"When :const:`True`, spaces immediately following the *delimiter* are "
"ignored. The default is :const:`False`."
msgstr "当为 :const:`True` 时，紧接在 *delimiter* 之后空格会被忽略。 默认值为 :const:`False`。"

#: ../../library/csv.rst:475
msgid ""
"When ``True``, raise exception :exc:`Error` on bad CSV input. The default is"
" ``False``."
msgstr "如果为 ``True``，则在输入错误的 CSV 时抛出 :exc:`Error` 异常。默认值为 ``False``。"

#: ../../library/csv.rst:481
msgid "Reader Objects"
msgstr "Reader 对象"

#: ../../library/csv.rst:483
msgid ""
"Reader objects (:class:`DictReader` instances and objects returned by the "
":func:`reader` function) have the following public methods:"
msgstr "Reader 对象（:class:`DictReader` 实例和 :func:`reader` 函数返回的对象）具有以下公开方法："

#: ../../library/csv.rst:488
msgid ""
"Return the next row of the reader's iterable object as a list (if the object"
" was returned from :func:`reader`) or a dict (if it is a :class:`DictReader`"
" instance), parsed according to the current :class:`Dialect`.  Usually you "
"should call this as ``next(reader)``."
msgstr ""
"返回 reader 的可迭代对象的下一行，它可以是一个列表（如果对象是由 :func:`reader` 返回）或字典（如果是一个 "
":class:`DictReader` 实例），根据当前 :class:`Dialect` 来解析。 通常你应当以 ``next(reader)`` "
"的形式来调用它。"

#: ../../library/csv.rst:494
msgid "Reader objects have the following public attributes:"
msgstr "Reader 对象具有以下公开属性："

#: ../../library/csv.rst:498
msgid "A read-only description of the dialect in use by the parser."
msgstr "变种描述，只读，供解析器使用。"

#: ../../library/csv.rst:503
msgid ""
"The number of lines read from the source iterator. This is not the same as "
"the number of records returned, as records can span multiple lines."
msgstr "源迭代器已经读取了的行数。它与返回的记录数不同，因为记录可能跨越多行。"

#: ../../library/csv.rst:507
msgid "DictReader objects have the following public attribute:"
msgstr "DictReader 对象具有以下公开属性："

#: ../../library/csv.rst:511
msgid ""
"If not passed as a parameter when creating the object, this attribute is "
"initialized upon first access or when the first record is read from the "
"file."
msgstr "字段名称。如果在创建对象时未传入字段名称，则首次访问时或从文件中读取第一条记录时会初始化此属性。"

#: ../../library/csv.rst:518
msgid "Writer Objects"
msgstr "Writer 对象"

#: ../../library/csv.rst:520
msgid ""
":class:`writer` objects (:class:`DictWriter` instances and objects returned "
"by the :func:`writer` function) have the following public methods.  A *row* "
"must be an iterable of strings or numbers for :class:`writer` objects and a "
"dictionary mapping fieldnames to strings or numbers (by passing them through"
" :func:`str` first) for :class:`DictWriter` objects.  Note that complex "
"numbers are written out surrounded by parens. This may cause some problems "
"for other programs which read CSV files (assuming they support complex "
"numbers at all)."
msgstr ""
":class:`writer` 对象 (:class:`DictWriter` 实例和 :func:`writer` 函数所返回的对象 ) "
"具有以下公共方法。 对于 :class:`writer` 对象 *row* 必须是输出字符串或数字的可迭代对象的数字，而对于 "
":class:`DictWriter` 对象则是一个将文件名映射到字符串或数字 (会先将其传给 :func:`str`) 的字典。 "
"请注意在写入复数时会用圆括号括起来。 这可能会给其他读取 CSV 文件的程序带来一些问题 (假定它们确实支持复数)。"

#: ../../library/csv.rst:531
msgid ""
"Write the *row* parameter to the writer's file object, formatted according "
"to the current :class:`Dialect`. Return the return value of the call to the "
"*write* method of the underlying file object."
msgstr ""
"将 *row* 形参写入到 writer 的文件对象，根据当前 :class:`Dialect` 进行格式化。 返回对下层文件对象的 *write* "
"方法的调用的返回值。"

#: ../../library/csv.rst:535
msgid "Added support of arbitrary iterables."
msgstr "开始支持任意类型的迭代器。"

#: ../../library/csv.rst:540
msgid ""
"Write all elements in *rows* (an iterable of *row* objects as described "
"above) to the writer's file object, formatted according to the current "
"dialect."
msgstr ""
"将 *rows*（即能迭代出多个上述 *row* 对象的迭代器）中的所有元素写入 writer 的文件对象，并根据当前设置的变种进行格式化。"

#: ../../library/csv.rst:544
msgid "Writer objects have the following public attribute:"
msgstr "Writer 对象具有以下公开属性："

#: ../../library/csv.rst:549
msgid "A read-only description of the dialect in use by the writer."
msgstr "变种描述，只读，供 writer 使用。"

#: ../../library/csv.rst:552
msgid "DictWriter objects have the following public method:"
msgstr "DictWriter 对象具有以下公开方法："

#: ../../library/csv.rst:557
msgid ""
"Write a row with the field names (as specified in the constructor) to the "
"writer's file object, formatted according to the current dialect. Return the"
" return value of the :meth:`csvwriter.writerow` call used internally."
msgstr ""
"在 writer 的文件对象中，写入一行字段名称（字段名称在构造函数中指定），并根据当前设置的变种进行格式化。本方法的返回值就是内部使用的 "
":meth:`csvwriter.writerow` 方法的返回值。"

#: ../../library/csv.rst:562
msgid ""
":meth:`writeheader` now also returns the value returned by the "
":meth:`csvwriter.writerow` method it uses internally."
msgstr "现在 :meth:`writeheader` 也返回其内部使用的 :meth:`csvwriter.writerow` 方法的返回值。"

#: ../../library/csv.rst:570
msgid "Examples"
msgstr "例子"

#: ../../library/csv.rst:572
msgid "The simplest example of reading a CSV file::"
msgstr "读取 CSV 文件最简单的一个例子::"

#: ../../library/csv.rst:574
msgid ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:580
msgid "Reading a file with an alternate format::"
msgstr "读取其他格式的文件::"

#: ../../library/csv.rst:582
msgid ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:588
msgid "The corresponding simplest possible writing example is::"
msgstr "相应最简单的写入示例是::"

#: ../../library/csv.rst:590
msgid ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"
msgstr ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"

#: ../../library/csv.rst:595
msgid ""
"Since :func:`open` is used to open a CSV file for reading, the file will by "
"default be decoded into unicode using the system default encoding (see "
":func:`locale.getencoding`).  To decode a file using a different encoding, "
"use the ``encoding`` argument of open::"
msgstr ""
"由于 :func:`open` 被用来打开 CSV 文件供读取，因此在默认情况下将使用系统默认编码格式  (参见 "
":func:`locale.getencoding`) 把文件解码至 unicode。 要使用其他编码格式来解码文件，请使用 open 的 "
"``encoding`` 参数::"

#: ../../library/csv.rst:600
msgid ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:606
msgid ""
"The same applies to writing in something other than the system default "
"encoding: specify the encoding argument when opening the output file."
msgstr "这同样适用于写入非系统默认编码的内容：打开输出文件时，指定 encoding 参数。"

#: ../../library/csv.rst:609
msgid "Registering a new dialect::"
msgstr "注册一个新的变种::"

#: ../../library/csv.rst:611
msgid ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"
msgstr ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"

#: ../../library/csv.rst:616
msgid ""
"A slightly more advanced use of the reader --- catching and reporting "
"errors::"
msgstr "Reader 的更高级用法——捕获并报告错误::"

#: ../../library/csv.rst:618
msgid ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit(f'file {filename}, line {reader.line_num}: {e}')"
msgstr ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit(f'file {filename}, line {reader.line_num}: {e}')"

#: ../../library/csv.rst:628
msgid ""
"And while the module doesn't directly support parsing strings, it can easily"
" be done::"
msgstr "尽管该模块不直接支持解析字符串，但仍可如下轻松完成::"

#: ../../library/csv.rst:631
msgid ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"
msgstr ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"

#: ../../library/csv.rst:637
msgid "Footnotes"
msgstr "备注"

#: ../../library/csv.rst:638
msgid ""
"If ``newline=''`` is not specified, newlines embedded inside quoted fields "
"will not be interpreted correctly, and on platforms that use ``\\r\\n`` "
"linendings on write an extra ``\\r`` will be added.  It should always be "
"safe to specify ``newline=''``, since the csv module does its own "
"(:term:`universal <universal newlines>`) newline handling."
msgstr ""
"如果没有指定 ``newline=''``，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用 ``\\r\\n`` 换行的平台会有多余的 "
"``\\r`` 写入。由于 csv 模块会执行自己的（:term:`通用 <universal newlines>`）换行符处理，因此指定 "
"``newline=''`` 应该总是安全的。"

#: ../../library/csv.rst:11
msgid "csv"
msgstr "csv"

#: ../../library/csv.rst:11
msgid "data"
msgstr "数据"

#: ../../library/csv.rst:11
msgid "tabular"
msgstr "tabular"

#: ../../library/csv.rst:53
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/csv.rst:53
msgid "csv.reader function"
msgstr "csv.reader 函数"
