# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-15 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/http.cookies.rst:2
msgid ":mod:`!http.cookies` --- HTTP state management"
msgstr ":mod:`!http.cookies` --- HTTP 状态管理"

#: ../../library/http.cookies.rst:10
msgid "**Source code:** :source:`Lib/http/cookies.py`"
msgstr "**源代码:** :source:`Lib/http/cookies.py`"

#: ../../library/http.cookies.rst:14
msgid ""
"The :mod:`http.cookies` module defines classes for abstracting the concept "
"of cookies, an HTTP state management mechanism. It supports both simple "
"string-only cookies, and provides an abstraction for having any serializable"
" data-type as cookie value."
msgstr ""
":mod:`http.cookies` 模块定义的类将 cookie 的概念抽象了出来，这是一种 HTTP 状态的管理机制。它既支持简单的纯字符串形式的"
" cookie，也为任何可序列化数据类型的 cookie 提供抽象。"

#: ../../library/http.cookies.rst:19
msgid ""
"The module formerly strictly applied the parsing rules described in the "
":rfc:`2109` and :rfc:`2068` specifications.  It has since been discovered "
"that MSIE 3.0x didn't follow the character rules outlined in those specs; "
"many current-day browsers and servers have also relaxed parsing rules when "
"it comes to cookie handling.  As a result, this module now uses parsing "
"rules that are a bit less strict than they once were."
msgstr ""
"之前该模块严格应用了 :rfc:`2109` 和 :rfc:`2068` 规范中描述的解析规则。 后来人们发现 MSIE 3.0x "
"并未遵循这些规范中描述的字符规则；目前各种浏览器和服务器在处理 cookie 时也放宽了解析规则。 因此，该模块目前使用的解析规则也没有以前那么严格了。"

#: ../../library/http.cookies.rst:26
msgid ""
"The character set, :data:`string.ascii_letters`, :data:`string.digits` and "
"``!#$%&'*+-.^_`|~:`` denote the set of valid characters allowed by this "
"module in a cookie name (as :attr:`~Morsel.key`)."
msgstr ""
"字符集 :data:`string.ascii_letters`, :data:`string.digits` 和 "
"``!#$%&'*+-.^_`|~:`` 标明了本模块允许在 cookie 名称中出现的有效字符 (如 :attr:`~Morsel.key`)。"

#: ../../library/http.cookies.rst:30
msgid "Allowed ':' as a valid cookie name character."
msgstr "允许 ':' 作为有效的 cookie 名称字符。"

#: ../../library/http.cookies.rst:36
msgid ""
"On encountering an invalid cookie, :exc:`CookieError` is raised, so if your "
"cookie data comes from a browser you should always prepare for invalid data "
"and catch :exc:`CookieError` on parsing."
msgstr ""
"当遇到无效 cookie 时会触发 :exc:`CookieError`，所以若 cookie "
"数据来自浏览器，一定要做好应对无效数据的准备，并在解析时捕获 :exc:`CookieError`。"

#: ../../library/http.cookies.rst:43
msgid ""
"Exception failing because of :rfc:`2109` invalidity: incorrect attributes, "
"incorrect :mailheader:`Set-Cookie` header, etc."
msgstr "出现异常的原因，可能是不符合 :rfc:`2109` ：属性不正确、:mailheader:`Set-Cookie` 头部信息不正确等等。"

#: ../../library/http.cookies.rst:49
msgid ""
"This class is a dictionary-like object whose keys are strings and whose "
"values are :class:`Morsel` instances. Note that upon setting a key to a "
"value, the value is first converted to a :class:`Morsel` containing the key "
"and the value."
msgstr ""
"类似字典的对象，字典键为字符串，字典值是 :class:`Morsel` 实例。请注意，在将键值关联时，首先会把值转换为包含键和值的 "
":class:`Morsel` 对象。"

#: ../../library/http.cookies.rst:53
msgid "If *input* is given, it is passed to the :meth:`load` method."
msgstr "若给出 *input* ，将会传给 :meth:`load` 方法。"

#: ../../library/http.cookies.rst:58
msgid ""
"This class derives from :class:`BaseCookie` and overrides "
":meth:`~BaseCookie.value_decode` and :meth:`~BaseCookie.value_encode`. "
":class:`!SimpleCookie` supports strings as cookie values. When setting the "
"value, :class:`!SimpleCookie` calls the builtin :func:`str` to convert the "
"value to a string. Values received from HTTP are kept as strings."
msgstr ""
"该类派生自 :class:`BaseCookie` 并重写了 :meth:`~BaseCookie.value_decode` 和 "
":meth:`~BaseCookie.value_encode`。 :class:`!SimpleCookie` 支持用字符串作为 cookie 值。 "
"在设置值时，:class:`!SimpleCookie` 会调用内置 :func:`str` 将值转换为字符串。 从 HTTP "
"接收的值仍然保持为字符串。"

#: ../../library/http.cookies.rst:66
msgid "Module :mod:`http.cookiejar`"
msgstr ":mod:`http.cookiejar` 模块"

#: ../../library/http.cookies.rst:67
msgid ""
"HTTP cookie handling for web *clients*.  The :mod:`http.cookiejar` and "
":mod:`http.cookies` modules do not depend on each other."
msgstr ""
"处理网络 *客户端* 的 HTTP cookie。 :mod:`http.cookiejar` 和 :mod:`http.cookies` "
"模块相互没有依赖关系。"

#: ../../library/http.cookies.rst:70
msgid ":rfc:`2109` - HTTP State Management Mechanism"
msgstr ":rfc:`2109` - HTTP状态管理机制"

#: ../../library/http.cookies.rst:71
msgid "This is the state management specification implemented by this module."
msgstr "这是本模块实现的状态管理规范。"

#: ../../library/http.cookies.rst:77
msgid "Cookie Objects"
msgstr "Cookie 对象"

#: ../../library/http.cookies.rst:82
msgid ""
"Return a tuple ``(real_value, coded_value)`` from a string representation. "
"``real_value`` can be any type. This method does no decoding in "
":class:`BaseCookie` --- it exists so it can be overridden."
msgstr ""
"由字符串返回元组 ``(real_value, coded_value)``。``real_value`` "
"可为任意类型。:class:`BaseCookie` 中的此方法未实现任何解码工作——只为能被子类重写。"

#: ../../library/http.cookies.rst:89
msgid ""
"Return a tuple ``(real_value, coded_value)``. *val* can be any type, but "
"``coded_value`` will always be converted to a string. This method does no "
"encoding in :class:`BaseCookie` --- it exists so it can be overridden."
msgstr ""
"返回元组 ``(real_value, coded_value)``。*val* 可为任意类型，``coded_value`` 则会转换为字符串。 "
":class:`BaseCookie` 中的此方法未实现任何编码工作——只为能被子类重写。"

#: ../../library/http.cookies.rst:94
msgid ""
"In general, it should be the case that :meth:`value_encode` and "
":meth:`value_decode` are inverses on the range of *value_decode*."
msgstr ""
"通常在 *value_decode* 的取值范围内，:meth:`value_encode` 和 :meth:`value_decode` "
"应为可互逆操作。"

#: ../../library/http.cookies.rst:100
msgid ""
"Return a string representation suitable to be sent as HTTP headers. *attrs* "
"and *header* are sent to each :class:`Morsel`'s :meth:`~Morsel.output` "
"method. *sep* is used to join the headers together, and is by default the "
"combination ``'\\r\\n'`` (CRLF)."
msgstr ""
"返回可作为 HTTP 标头信息发送的字符串表示。 *attrs* 和 *header* 会发给每个 :class:`Morsel` 的 "
":meth:`~Morsel.output` 方法。 *sep* 用来将标头连接在一起，默认为 ``'\\r\\n'`` (CRLF) 组合。"

#: ../../library/http.cookies.rst:108
msgid ""
"Return an embeddable JavaScript snippet, which, if run on a browser which "
"supports JavaScript, will act the same as if the HTTP headers was sent."
msgstr "返回一段可供嵌入的 JavaScript 代码，若在支持 JavaScript 的浏览器上运行，其作用如同发送 HTTP 头部信息一样。"

#: ../../library/http.cookies.rst:111 ../../library/http.cookies.rst:227
#: ../../library/http.cookies.rst:235
msgid "The meaning for *attrs* is the same as in :meth:`output`."
msgstr "*attrs* 的含义与 :meth:`output` 的相同。"

#: ../../library/http.cookies.rst:116
msgid ""
"If *rawdata* is a string, parse it as an ``HTTP_COOKIE`` and add the values "
"found there as :class:`Morsel`\\ s. If it is a dictionary, it is equivalent "
"to::"
msgstr ""
"若 *rawdata* 为字符串，则会作为 ``HTTP_COOKIE`` 进行解析，并将找到的值添加为 :class:`Morsel`。 "
"如果是字典值，则等价于::"

#: ../../library/http.cookies.rst:119
msgid ""
"for k, v in rawdata.items():\n"
"    cookie[k] = v"
msgstr ""
"for k, v in rawdata.items():\n"
"    cookie[k] = v"

#: ../../library/http.cookies.rst:126
msgid "Morsel Objects"
msgstr "Morsel 对象"

#: ../../library/http.cookies.rst:131
msgid "Abstract a key/value pair, which has some :rfc:`2109` attributes."
msgstr "对键/值对的抽象，带有 :rfc:`2109` 的部分属性。"

#: ../../library/http.cookies.rst:133
msgid ""
"Morsels are dictionary-like objects, whose set of keys is constant --- the "
"valid :rfc:`2109` attributes, which are:"
msgstr "morsel 对象类似于字典，它的键是一组常量 --- 即有效的 :rfc:`2109` 属性，包括："

#: ../../library/http.cookies.rst:147
msgid ""
"The attribute :attr:`httponly` specifies that the cookie is only transferred"
" in HTTP requests, and is not accessible through JavaScript. This is "
"intended to mitigate some forms of cross-site scripting."
msgstr ""
":attr:`httponly` 属性指明了该 cookie 仅在 HTTP 请求中传输，且不能通过 JavaScript "
"访问。这是为了减轻某些跨站脚本攻击的危害。"

#: ../../library/http.cookies.rst:151
msgid ""
"The attribute :attr:`samesite` controls when the browser sends the cookie "
"with cross-site requests. This helps to mitigate CSRF attacks. Valid values "
"are \"Strict\" (only sent with same-site requests), \"Lax\" (sent with same-"
"site requests and top-level navigations), and \"None\" (sent with same-site "
"and cross-site requests). When using \"None\", the \"secure\" attribute must"
" also be set, as required by modern browsers."
msgstr ""
"属性 :attr:`samesite` 用于控制浏览器在跨站请求时何时发送 Cookie。该设置有助于缓解 "
"CSRF（跨站请求伪造）攻击。有效取值包括：\"Strict\"（仅在同站请求时发送）、\"Lax\"（在同站请求和顶级导航时发送），以及 "
"\"None\"（在同站和跨站请求时均发送）。当设置为 \"None\" 时，必须同时设置 \"secure\" 属性，这是现代浏览器的强制要求。"

#: ../../library/http.cookies.rst:158
msgid ""
"The attribute :attr:`partitioned` indicates to user agents that these cross-"
"site cookies *should* only be available in the same top-level context that "
"the cookie was first set in. For this to be accepted by the user agent, you "
"**must** also set ``Secure``."
msgstr ""
"属性 :attr:`partitioned` 提示 user agent 这些跨站点 cookie *应当* 仅在首次设置 cookie "
"所在的同一最高层级上下文中可用。 要让它被 user agent 所接受，你还 **必须** 设置 ``Secure``。"

#: ../../library/http.cookies.rst:163
msgid ""
"In addition, it is recommended to use the ``__Host`` prefix when setting "
"partitioned cookies to make them bound to the hostname and not the "
"registrable domain. Read `CHIPS (Cookies Having Independent Partitioned "
"State)`_ for full details and examples."
msgstr ""
"此外，还建议在设置分块 cookie 时使用 ``__Host`` 前缀以使其绑定到主机名而非可注册域。 请参阅 `CHIPS (Cookies "
"Having Independent Partitioned State)`_ 获取完整说明和示例。"

#: ../../library/http.cookies.rst:171
msgid "The keys are case-insensitive and their default value is ``''``."
msgstr "键不区分大小写，默认值为 ``''``。"

#: ../../library/http.cookies.rst:173
msgid ""
":meth:`!__eq__` now takes :attr:`~Morsel.key` and :attr:`~Morsel.value` into"
" account."
msgstr "现在 :meth:`!__eq__` 会同时考虑 :attr:`~Morsel.key` 和 :attr:`~Morsel.value`。"

#: ../../library/http.cookies.rst:177
msgid ""
"Attributes :attr:`~Morsel.key`, :attr:`~Morsel.value` and "
":attr:`~Morsel.coded_value` are read-only.  Use :meth:`~Morsel.set` for "
"setting them."
msgstr ""
" :attr:`~Morsel.key` 、 :attr:`~Morsel.value` 和 :attr:`~Morsel.coded_value` "
"是只读属性。可用 :meth:`~Morsel.set`  进行设置。"

#: ../../library/http.cookies.rst:182
msgid "Added support for the :attr:`samesite` attribute."
msgstr "增加对 :attr:`samesite` 属性的支持。"

#: ../../library/http.cookies.rst:185
msgid "Added support for the :attr:`partitioned` attribute."
msgstr "增加对 :attr:`partitioned` 属性的支持。"

#: ../../library/http.cookies.rst:191
msgid "The value of the cookie."
msgstr "Cookie的值。"

#: ../../library/http.cookies.rst:196
msgid "The encoded value of the cookie --- this is what should be sent."
msgstr "编码后的 cookie 值——也即要发送的内容。"

#: ../../library/http.cookies.rst:201
msgid "The name of the cookie."
msgstr "cookie 名称"

#: ../../library/http.cookies.rst:206
msgid "Set the *key*, *value* and *coded_value* attributes."
msgstr "设置 *key*、*value* 和 *coded_value* 属性。"

#: ../../library/http.cookies.rst:211
msgid "Whether *K* is a member of the set of keys of a :class:`Morsel`."
msgstr "判断 *K* 是否属于 :class:`Morsel` 的键。"

#: ../../library/http.cookies.rst:216
msgid ""
"Return a string representation of the Morsel, suitable to be sent as an HTTP"
" header. By default, all the attributes are included, unless *attrs* is "
"given, in which case it should be a list of attributes to use. *header* is "
"by default ``\"Set-Cookie:\"``."
msgstr ""
"返回 morsel 的字符串形式，适用于作为 HTTP 头部信息进行发送。默认包含所有属性，除非给出 *attrs* 属性列表。*header* 默认为"
" ``\"Set-Cookie:\"``。"

#: ../../library/http.cookies.rst:224
msgid ""
"Return an embeddable JavaScript snippet, which, if run on a browser which "
"supports JavaScript, will act the same as if the HTTP header was sent."
msgstr "返回一段可供嵌入的 JavaScript 代码，若在支持 JavaScript 的浏览器上运行，其作用如同发送 HTTP 头部信息一样。"

#: ../../library/http.cookies.rst:232
msgid ""
"Return a string representing the Morsel, without any surrounding HTTP or "
"JavaScript."
msgstr "返回 morsel 的字符串形式，不含 HTTP 或 JavaScript 数据。"

#: ../../library/http.cookies.rst:240
msgid ""
"Update the values in the Morsel dictionary with the values in the dictionary"
" *values*.  Raise an error if any of the keys in the *values* dict is not a "
"valid :rfc:`2109` attribute."
msgstr ""
"用字典 *values* 中的值更新  morsel 字典中的值。若有 *values* 字典中的键不是有效的 :rfc:`2109` "
"属性，则会触发错误。"

#: ../../library/http.cookies.rst:244
msgid "an error is raised for invalid keys."
msgstr "无效键会触发错误。"

#: ../../library/http.cookies.rst:250
msgid "Return a shallow copy of the Morsel object."
msgstr "返回 morsel 对象的浅表复制副本。"

#: ../../library/http.cookies.rst:252
msgid "return a Morsel object instead of a dict."
msgstr "返回一个 morsel 对象，而非字典。"

#: ../../library/http.cookies.rst:258
msgid ""
"Raise an error if key is not a valid :rfc:`2109` attribute, otherwise behave"
" the same as :meth:`dict.setdefault`."
msgstr "若 key 不是有效的 :rfc:`2109` 属性则触发错误，否则与 :meth:`dict.setdefault` 相同。"

#: ../../library/http.cookies.rst:265
msgid "Example"
msgstr "示例"

#: ../../library/http.cookies.rst:267
msgid ""
"The following example demonstrates how to use the :mod:`http.cookies` "
"module."
msgstr "以下例子演示了 :mod:`http.cookies` 模块的用法。"

#: ../../library/http.cookies.rst:269
msgid ""
">>> from http import cookies\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"fig\"] = \"newton\"\n"
">>> C[\"sugar\"] = \"wafer\"\n"
">>> print(C) # generate HTTP headers\n"
"Set-Cookie: fig=newton\n"
"Set-Cookie: sugar=wafer\n"
">>> print(C.output()) # same thing\n"
"Set-Cookie: fig=newton\n"
"Set-Cookie: sugar=wafer\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"rocky\"] = \"road\"\n"
">>> C[\"rocky\"][\"path\"] = \"/cookie\"\n"
">>> print(C.output(header=\"Cookie:\"))\n"
"Cookie: rocky=road; Path=/cookie\n"
">>> print(C.output(attrs=[], header=\"Cookie:\"))\n"
"Cookie: rocky=road\n"
">>> C = cookies.SimpleCookie()\n"
">>> C.load(\"chips=ahoy; vienna=finger\") # load from a string (HTTP header)\n"
">>> print(C)\n"
"Set-Cookie: chips=ahoy\n"
"Set-Cookie: vienna=finger\n"
">>> C = cookies.SimpleCookie()\n"
">>> C.load('keebler=\"E=everybody; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\";')\n"
">>> print(C)\n"
"Set-Cookie: keebler=\"E=everybody; L=\\\"Loves\\\"; fudge=\\012;\"\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"oreo\"] = \"doublestuff\"\n"
">>> C[\"oreo\"][\"path\"] = \"/\"\n"
">>> print(C)\n"
"Set-Cookie: oreo=doublestuff; Path=/\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"twix\"] = \"none for you\"\n"
">>> C[\"twix\"].value\n"
"'none for you'\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"number\"] = 7 # equivalent to C[\"number\"] = str(7)\n"
">>> C[\"string\"] = \"seven\"\n"
">>> C[\"number\"].value\n"
"'7'\n"
">>> C[\"string\"].value\n"
"'seven'\n"
">>> print(C)\n"
"Set-Cookie: number=7\n"
"Set-Cookie: string=seven"
msgstr ""
">>> from http import cookies\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"fig\"] = \"newton\"\n"
">>> C[\"sugar\"] = \"wafer\"\n"
">>> print(C) # 生成 HTTP 标头\n"
"Set-Cookie: fig=newton\n"
"Set-Cookie: sugar=wafer\n"
">>> print(C.output()) # 同样的内容\n"
"Set-Cookie: fig=newton\n"
"Set-Cookie: sugar=wafer\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"rocky\"] = \"road\"\n"
">>> C[\"rocky\"][\"path\"] = \"/cookie\"\n"
">>> print(C.output(header=\"Cookie:\"))\n"
"Cookie: rocky=road; Path=/cookie\n"
">>> print(C.output(attrs=[], header=\"Cookie:\"))\n"
"Cookie: rocky=road\n"
">>> C = cookies.SimpleCookie()\n"
">>> C.load(\"chips=ahoy; vienna=finger\") # 从字符串加载 (HTTP 标头)\n"
">>> print(C)\n"
"Set-Cookie: chips=ahoy\n"
"Set-Cookie: vienna=finger\n"
">>> C = cookies.SimpleCookie()\n"
">>> C.load('keebler=\"E=everybody; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\";')\n"
">>> print(C)\n"
"Set-Cookie: keebler=\"E=everybody; L=\\\"Loves\\\"; fudge=\\012;\"\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"oreo\"] = \"doublestuff\"\n"
">>> C[\"oreo\"][\"path\"] = \"/\"\n"
">>> print(C)\n"
"Set-Cookie: oreo=doublestuff; Path=/\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"twix\"] = \"none for you\"\n"
">>> C[\"twix\"].value\n"
"'none for you'\n"
">>> C = cookies.SimpleCookie()\n"
">>> C[\"number\"] = 7 # 等价于 C[\"number\"] = str(7)\n"
">>> C[\"string\"] = \"seven\"\n"
">>> C[\"number\"].value\n"
"'7'\n"
">>> C[\"string\"].value\n"
"'seven'\n"
">>> print(C)\n"
"Set-Cookie: number=7\n"
"Set-Cookie: string=seven"
