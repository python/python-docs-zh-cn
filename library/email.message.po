# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.message.rst:2
msgid ":mod:`email.message`: Representing an email message"
msgstr ":mod:`email.message`: 表示一封电子邮件信息"

#: ../../library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**源代码:** :source:`Lib/email/message.py`"

#: ../../library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.message.rst:16
msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
"位于 :mod:`email` 包的中心的类就是 :class:`EmailMessage` 类。这个类导入自 :mod:`email.message`"
" 模块。它是 :mod:`email` 对象模型的基类。:class:`EmailMessage` "
"为设置和查询头字段内容、访问信息体的内容、以及创建和修改结构化信息提供了核心功能。"

#: ../../library/email.message.rst:22
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style"
" field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or "
":mimetype:`message/rfc822`."
msgstr ""
"一份电子邮件信息由 *标头* 和 *载荷* （又被称为 *内容* ）组成。 标头遵循 :rfc:`5322` 或者 :rfc:`6532` "
"风格的字段名和值，字段名和字段值之间由一个冒号隔开。 "
"这个冒号既不属于字段名，也不属于字段值。信息的载荷可能是一段简单的文字消息，也可能是一个二进制的对象，更可能是由多个拥有各自标头和载荷的子信息组成的结构化子信息序列。"
" 对于后者类型的载荷，信息的 MIME 类型将会被指明为诸如 :mimetype:`multipart/\\*` 或 "
":mimetype:`message/rfc822` 的类型。"

#: ../../library/email.message.rst:31
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of "
"sub-``EmailMessage`` objects.  In addition to the normal dictionary methods "
"for accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
":class:`EmailMessage` 对象所提供的抽象概念模型是一个头字段组成的有序字典加一个代表 :rfc:`5322` 标准的信息体的 "
"*载荷* 。 载荷有可能是一系列子 ``EmailMessage`` "
"对象的列表。你除了可以通过一般的字典方法来访问头字段名和值，还可以使用特制方法来访问头的特定字段（比如说 MIME "
"内容类型字段）、操纵载荷、生成信息的序列化版本、递归遍历对象树。"

#: ../../library/email.message.rst:40
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header"
" names, which must be ASCII values.  The values of the dictionary are "
"strings with some extra methods.  Headers are stored and returned in case-"
"preserving form, but field names are matched case-insensitively.  The keys "
"are ordered, but unlike a real dict, there can be duplicates.  Addtional "
"methods are provided for working with headers that have duplicate keys."
msgstr ""
":class:`EmailMessage` 字典型接口使用的索引是标头名称，它必须为 ASCII 值。 字典的值是包含一些附加方法的字符串。 "
"标头是以保留大小写的形式存储和返回的，但字段名的匹配则是大小写不敏感的。 键是保留顺序的，但与真正字典不同的是键可以重复。 "
"额外提供了一些方法来处理包含重复键的标头。"

#: ../../library/email.message.rst:47
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and "
":mimetype:`message/rfc822` message objects."
msgstr ""
"*载荷* 是多样的。对于简单的信息对象，它是字符串或字节对象；对于诸如 :mimetype:`multipart/\\*` 和 "
":mimetype:`message/rfc822` 信息对象的 MIME 容器文档，它是一个 :class:`EmailMessage` 对象列表。"

#: ../../library/email.message.rst:55
msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the "
":class:`~email.policy.default` policy, which follows the rules of the email "
"RFCs except for line endings (instead of the RFC mandated ``\\r\\n``, it "
"uses the Python standard ``\\n`` line endings).  For more information see "
"the :mod:`~email.policy` documentation."
msgstr ""
"如果指定了 *policy* ，消息将由这个 *policy* 所指定的规则来更新和序列化信息的表达。如果没有指定 *policy* ，其将默认使用 "
":class:`~email.policy.default` 策略。这个策略遵循电子邮件的RFC标准，除了行终止符号（RFC要求使用 "
"``\\r\\n`` ，此策略使用Python标准的 ``\\n`` 行终止符）。请前往 :mod:`~email.policy` 的文档获取更多信息。"

#: ../../library/email.message.rst:64
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom*"
" defaults to ``False``.  For backward compatibility with the base "
":class:`~email.message.Message` class *maxheaderlen* is accepted, but "
"defaults to ``None``, which means that by default the line length is "
"controlled by the :attr:`~email.policy.Policy.max_line_length` of the "
"policy.  The *policy* argument may be used to override the default policy "
"obtained from the message instance.  This can be used to control some of the"
" formatting produced by the method, since the specified *policy* will be "
"passed to the :class:`~email.generator.Generator`."
msgstr ""
"以一段字符串的形式返回整个消息对象。 若可选的 *unixfrom* 为真值，信封头将包括在返回的字符串中。 *unixfrom* 默认为 "
"``False``。 为了保持向下兼容基类 :class:`~email.message.Message` 还接受 "
"*maxheaderlen*，但其默认为 ``None``，这意味着在默认情况下行长度将由策略的 "
":attr:`~email.policy.Policy.max_line_length` 来控制。 *policy* "
"参数可以被用于覆盖从消息实例获取到的默认策略。 这可以被用来控制该方法所产生的某些格式，因为指定的 *policy* 将被传给 "
":class:`~email.generator.Generator`。"

#: ../../library/email.message.rst:76 ../../library/email.message.rst:114
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"扁平化信息可能会对 :class:`EmailMessage` 做出修改。这是因为为了完成向字符串的转换，一些内容需要使用默认值填入（举个例子，MIME"
" 边界字段可能会被生成或被修改）。"

#: ../../library/email.message.rst:80
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is"
" restricted to producing messages serialized as \"7 bit clean\" when "
":attr:`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"请注意，这个方法是为了便利而提供，不一定是适合你的应用程序的最理想的序列化信息的方法。这在你处理多封信息的时候尤甚。如果你需要使用更加灵活的API来序列化信息，请参见"
" :class:`email.generator.Generator` 。同时请注意，当 "
":attr:`~email.policy.EmailPolicy.utf8` 属性为其默认值 ``False`` 的时候，本方法将限制其行为为生成以“7"
" bit clean”方式序列化的信息。"

#: ../../library/email.message.rst:88
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr "*maxheaderlen* 没有被指定时的默认行为从默认为0修改为默认为策略的 *max_line_length* 值。"

#: ../../library/email.message.rst:95
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"与 ``as_string(policy=self.policy.clone(utf8=True))`` 等价。这将让 ``str(msg)`` "
"产生的字符串包含人类可读的的序列化信息内容。"

#: ../../library/email.message.rst:99
msgid ""
"the method was changed to use ``utf8=True``, thus producing an "
":rfc:`6531`-like message representation, instead of being a direct alias for"
" :meth:`as_string`."
msgstr ""
"本方法开始使用 ``utf8=True`` ，而非 :meth:`as_string` 的直接替身。使用 ``utf8=True`` 会产生类似于 "
":rfc:`6531` 的信息表达。"

#: ../../library/email.message.rst:106
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string."
"  *unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the "
":class:`~email.generator.BytesGenerator`."
msgstr ""
"以字节串对象的形式返回整个扁平化后的消息。 当可选的 *unixfrom* 为真值时，返回的字符串会包含信封标头。 *unixfrom* 的默认值为 "
"``False``。 *policy* 参数可被用于覆盖从消息实例获取的默认 policy。 这可被用来控制该方法所产生的部分格式效果，因为指定的 "
"*policy* 将被传递给 :class:`~email.generator.BytesGenerator`。"

#: ../../library/email.message.rst:118
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator`"
" for a more flexible API for serializing messages."
msgstr ""
"请注意，这个方法是为了便利而提供，不一定是适合你的应用程序的最理想的序列化信息的方法。这在你处理多封信息的时候尤甚。如果你需要使用更加灵活的API来序列化信息，请参见"
" :class:`email.generator.BytesGenerator` 。"

#: ../../library/email.message.rst:127
msgid ""
"Equivalent to :meth:`.as_bytes()`.  Allows ``bytes(msg)`` to produce a bytes"
" object containing the serialized message."
msgstr "与 :meth:`.as_bytes()` 等价。这将让 ``bytes(msg)`` 产生一个包含序列化信息内容的字节序列对象。"

#: ../../library/email.message.rst:133
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ "
":class:`EmailMessage` objects, otherwise return ``False``.  When "
":meth:`is_multipart` returns ``False``, the payload should be a string "
"object (which might be a CTE encoded binary payload).  Note that "
":meth:`is_multipart` returning ``True`` does not necessarily mean that "
"\"msg.get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the "
":class:`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"如果该信息的载荷是一个子 :class:`EmailMessage` 对象列表，返回 ``True`` ；否则返回 ``False`` 。在 "
":meth:`is_multipart` 返回 ``True`` "
"的场合下，载荷应当是一个字符串对象（有可能是一个使用了内容传输编码进行编码的二进制载荷）。请注意， :meth:`is_multipart` 返回 "
"``True`` 不意味着 ``msg.get_content_maintype() == 'multipart'`` 也会返回 ``True`` "
"。举个例子， ``is_multipart`` 在 :class:`EmailMessage` 是 ``message/rfc822`` "
"类型的信息的情况下，其返回值也是 ``True`` 。"

#: ../../library/email.message.rst:145
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"将信息的信封头设置为 *unixform* ，这应当是一个字符串。（在  :class:`~mailbox.mboxMessage` "
"中有关于这个头的一段简短介绍。）"

#: ../../library/email.message.rst:152
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr "返回消息的信封头。如果信封头从未被设置过，默认返回 ``None`` 。"

#: ../../library/email.message.rst:156
msgid ""
"The following methods implement the mapping-like interface for accessing the"
" message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header"
" list."
msgstr ""
"以下方法实现了对信息的头字段进行访问的类映射接口。请留意，只是类映射接口，这与平常的映射接口（比如说字典映射）有一些语义上的不同。举个例子，在一个字典当中，键之间不可重复，但是信息头字段是可以重复的。不光如此，在字典当中调用"
" :meth:`keys` 方法返回的结果，其顺序没有保证；但是在一个 :class:`EmailMessage` "
"对象当中，返回的头字段永远以其在原信息当中出现的顺序，或以其加入信息的顺序为序。任何删了后又重新加回去的头字段总是添加在当时列表的末尾。"

#: ../../library/email.message.rst:167
msgid ""
"These semantic differences are intentional and are biased toward convenience"
" in the most common use cases."
msgstr "这些语义上的不同是刻意而为之的，是出于在绝大多数常见使用情景中都方便的初衷下设计的。"

#: ../../library/email.message.rst:170
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr "请注意在任何情况下，消息当中的任何封包标头都不会包含在映射接口当中。"

#: ../../library/email.message.rst:176
msgid "Return the total number of headers, including duplicates."
msgstr "返回标头的总数，包括重复项。"

#: ../../library/email.message.rst:181
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon."
"  Used for the ``in`` operator.  For example::"
msgstr ""
"如果消息对象中有一个名为 *name* 的字段，其返回值为 ``True`` 。匹配无视大小写差异， *name* 也不包含末尾的的冒号。  "
"``in`` 操作符的实现中用到了这个方法，比如说："

#: ../../library/email.message.rst:191
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a "
":exc:`KeyError` is never raised."
msgstr ""
"返回头字段名对应的字段值。 *name* 不含冒号分隔符。如果字段未找到，返回 ``None`` 。 :exc:`KeyError` 异常永不抛出。"

#: ../../library/email.message.rst:195
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined."
"  Use the :meth:`get_all` method to get the values of all the extant headers"
" named *name*."
msgstr ""
"请注意，如果对应名字的字段找到了多个，具体返回哪个字段值是未定义的。请使用 :meth:`get_all` 方法获取当前匹配字段名的所有字段值。"

#: ../../library/email.message.rst:200
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"使用标准策略（非 ``compat32``）时，返回值是 :class:`email.headerregistry.BaseHeader` "
"的某个子类的一个实例。"

#: ../../library/email.message.rst:206
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr "在信息头中添加名为 *name* 值为 *val* 的字段。这个字段会被添加在已有字段列表的结尾处。"

#: ../../library/email.message.rst:209
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, "
"e.g.::"
msgstr ""
"请注意，这个方法 *既不会* 覆盖 *也不会* 删除任何字段名重名的已有字段。如果你确实想保证新字段是整个信息头当中唯一拥有 *name* "
"字段名的字段，你需要先把旧字段删除。例如："

#: ../../library/email.message.rst:216
msgid ""
"If the :mod:`policy <email.policy>` defines certain headers to be unique (as"
" the standard policies do), this method may raise a :exc:`ValueError` when "
"an attempt is made to assign a value to such a header when one already "
"exists.  This behavior is intentional for consistency's sake, but do not "
"depend on it as we may choose to make such assignments do an automatic "
"deletion of the existing header in the future."
msgstr ""
"如果 :mod:`policy <email.policy>` "
"将特定标头定义为唯一的（就像标准策略所做的一样），则当这样的标头已存在时试图为其赋值此方法会引发 :exc:`ValueError`。 "
"采取此种行为是出于保持一致性的考量，但不能依赖它因为在未来我们可能会选择让这样的赋值操作自动删除现有的标头。"

#: ../../library/email.message.rst:226
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "删除信息头当中字段名匹配 *name* 的所有字段。如果匹配指定名称的字段没有找到，也不会抛出任何异常。"

#: ../../library/email.message.rst:233
msgid "Return a list of all the message's header field names."
msgstr "以列表形式返回消息头中所有的字段名。"

#: ../../library/email.message.rst:238
msgid "Return a list of all the message's field values."
msgstr "以列表形式返回消息头中所有的字段值。"

#: ../../library/email.message.rst:243
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "以二元元组的列表形式返回消息头中所有的字段名和字段值。"

#: ../../library/email.message.rst:249
msgid ""
"Return the value of the named header field.  This is identical to "
":meth:`~object.__getitem__` except that optional *failobj* is returned if "
"the named header is missing (*failobj* defaults to ``None``)."
msgstr ""
"返回对应标头字段名的值。 这个方法与 :meth:`~object.__getitem__` 是一样的，只是如果对应标头不存在则返回可选的 "
"*failobj* (*failobj* 默认为 ``None``)。"

#: ../../library/email.message.rst:254
msgid "Here are some additional useful header related methods:"
msgstr "以下是一些与头有关的更多有用方法："

#: ../../library/email.message.rst:259
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr "返回字段名为 *name* 的所有字段值的列表。如果信息内不存在匹配的字段，返回 *failobj* （其默认值为 ``None`` ）。"

#: ../../library/email.message.rst:266
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary*"
" value for the header."
msgstr ""
"高级头字段设定。这个方法与 :meth:`__setitem__` 类似，不过你可以使用关键字参数为字段提供附加参数。 *_name* 是字段名， "
"*_value* 是字段 *主* 值。"

#: ../../library/email.message.rst:271
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken"
" as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"对于关键字参数字典 *_params* "
"的每个键值对而言，它的键被用作参数的名字，其中下划线被替换为短横杠（毕竟短横杠不是合法的Python标识符）。一般来讲，参数以 ``键=\"值\"`` "
"的方式添加，除非值是 ``None`` 。要真的是这样的话，只有键会被添加。"

#: ../../library/email.message.rst:277
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format"
" ``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8``"
" and a ``LANGUAGE`` of ``None``."
msgstr ""
"如果值含有非 ASCII 字符，你可以将值写成 ``(CHARSET, LANGUAGE, VALUE)`` "
"形式的三元组，这样你可以人为控制字符的字符集和语言。 ``CHARSET`` 是一个字符串，它为你的值的编码命名； ``LANGUAGE`` "
"一般可以直接设为 ``None`` ，也可以直接设为空字符串（其他可能取值参见 :rfc:`2231` ）； ``VALUE`` "
"是一个字符串值，其包含非ASCII的码点。如果你没有使用三元组，你的字符串又含有非 ASCII 字符，那么它就会使用 :rfc:`2231` 中， "
"``CHARSET`` 为 ``utf-8`` ， ``LANGUAGE`` 为 ``None`` 的格式编码。"

#: ../../library/email.message.rst:287
msgid "Here is an example::"
msgstr "例如："

#: ../../library/email.message.rst:291
msgid "This will add a header that looks like ::"
msgstr "会添加一个形如下文的头字段："

#: ../../library/email.message.rst:295
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "带有非ASCII字符的拓展接口："

#: ../../library/email.message.rst:303
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"替换头字段。只会替换掉信息内找到的第一个字段名匹配 *_name* 的字段值。字段的顺序不变，原字段名的大小写也不变。如果没有找到匹配的字段，抛出 "
":exc:`KeyError` 异常。"

#: ../../library/email.message.rst:311
msgid ""
"Return the message's content type, coerced to lower case of the form "
":mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:`get_default_type`."
"  If the :mailheader:`Content-Type` header is invalid, return "
"``text/plain``."
msgstr ""
"返回信息的内容类型，其形如 :mimetype:`maintype/subtype` ，强制全小写。如果信息的 "
":mailheader:`Content-Type` 头字段不存在则返回 :meth:`get_default_type` 的返回值；如果信息的 "
":mailheader:`Content-Type` 头字段无效则返回 ``text/plain`` 。"

#: ../../library/email.message.rst:317
msgid ""
"(According to :rfc:`2045`, messages always have a default type, "
":meth:`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside"
" a :mimetype:`multipart/digest` container, in which case it would be "
":mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an"
" invalid type specification, :rfc:`2045` mandates that the default type be "
":mimetype:`text/plain`.)"
msgstr ""
"（根据 :rfc:`2045` 所述，信息永远都有一个默认类型，所以 :meth:`get_content_type` 一定会返回一个值。 "
":rfc:`2045` 定义信息的默认类型为 :mimetype:`text/plain` 或 :mimetype:`message/rfc822` "
"，其中后者仅出现在消息头位于一个 :mimetype:`multipart/digest` 容器中的场合中。如果消息头的 "
":mailheader:`Content-Type` 字段所指定的类型是无效的， :rfc:`2045` 令其默认类型为 "
":mimetype:`text/plain` 。）"

#: ../../library/email.message.rst:328
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"返回信息的主要内容类型。准确来说，此方法返回的是 :meth:`get_content_type` 方法所返回的形如 "
":mimetype:`maintype/subtype` 的字符串当中的 :mimetype:`maintype` 部分。"

#: ../../library/email.message.rst:334
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part"
" of the string returned by :meth:`get_content_type`."
msgstr ""
"返回信息的子内容类型。准确来说，此方法返回的是 :meth:`get_content_type` 方法所返回的形如 "
":mimetype:`maintype/subtype` 的字符串当中的 :mimetype:`subtype` 部分。"

#: ../../library/email.message.rst:340
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of "
":mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"返回默认的内容类型。绝大多数的信息，其默认内容类型都是 :mimetype:`text/plain` 。作为 "
":mimetype:`multipart/digest` 容器内子部分的信息除外，它们的默认内容类型是 "
":mimetype:`message/rfc822` 。"

#: ../../library/email.message.rst:348
msgid ""
"Set the default content type.  *ctype* should either be "
":mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is not "
"enforced.  The default content type is not stored in the "
":mailheader:`Content-Type` header, so it only affects the return value of "
"the ``get_content_type`` methods when no :mailheader:`Content-Type` header "
"is present in the message."
msgstr ""
"设置默认的内容类型。 尽管并非强制，但是 *ctype* 仍应当是 :mimetype:`text/plain` 或 "
":mimetype:`message/rfc822` 二者取一。默认内容类型并不存储在 :mailheader:`Content-Type` "
"头字段当中，所以设置此项的唯一作用就是决定当 :mailheader:`Content-Type` "
"头字段在信息中不存在时，``get_content_type`` 方法的返回值。"

#: ../../library/email.message.rst:359
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new"
" parameter value.  Optional *header* specifies an alternative header to "
":mailheader:`Content-Type`."
msgstr ""
"在 :mailheader:`Content-Type` 头字段当中设置一个参数。如果该参数已于字段中存在，将其旧值替换为 *value* 。如果 "
"*header* 是 ``Content-Type`` （默认值），并且该头字段于信息中尚未存在，则会先添加该字段，将其值设置为 "
":mimetype:`text/plain` ，并附加参数值。可选的 *header* 可以让你指定 :mailheader:`Content-"
"Type` 之外的另一个头字段。"

#: ../../library/email.message.rst:366
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* parameters."
"  Optional *language* specifies the :rfc:`2231` language, defaulting to the "
"empty string.  Both *charset* and *language* should be strings.  The default"
" is to use the ``utf8`` *charset* and ``None`` for the *language*."
msgstr ""
"如果值包含非ASCII字符，其字符集和语言可以通过可选参数 *charset* 和 *language* 显式指定。可选参数 *language* 指定"
" :rfc:`2231` 当中的语言，其默认值是空字符串。 *charset* 和 *language* 都应当字符串。默认使用的是 ``utf8`` "
"*charset* ，*language* 为 ``None`` 。"

#: ../../library/email.message.rst:373
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"如果 *replace* 为 ``False`` （默认值），该头字段会被移动到所有头字段列表的末尾。如果 *replace* 为 ``True`` "
"，字段会被原地更新。"

#: ../../library/email.message.rst:377 ../../library/email.message.rst:394
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr "于 :class:`EmailMessage` 对象而言， *requote* 参数已被弃用。"

#: ../../library/email.message.rst:380
msgid ""
"Note that existing parameter values of headers may be accessed through the "
":attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of "
"the header value (for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"请注意标头现有的形参值可以通过标头值的 "
":attr:`~email.headerregistry.ParameterizedMIMEHeader.params` 属性来访问 (例如 "
"``msg['Content-Type'].params['charset']``)。"

#: ../../library/email.message.rst:384
msgid "``replace`` keyword was added."
msgstr "添加了 ``replace`` 关键字。"

#: ../../library/email.message.rst:389
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its"
" value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"从 :mailheader:`Content-Type` 头字段中完全移去给定的参数。头字段会被原地重写，重写后的字段不含参数和值。可选的 "
"*header* 可以让你指定 :mailheader:`Content-Type` 之外的另一个字段。"

#: ../../library/email.message.rst:400
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or"
" the header is missing, then *failobj* is returned. The returned string will"
" always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"返回信息头当中 :mailheader:`Content-Disposition` 字段当中名为 ``filename`` "
"的参数值。如果该字段当中没有此参数，该方法会退而寻找 :mailheader:`Content-Type` 字段当中的 ``name`` "
"参数值。如果这个也没有找到，或者这些个字段压根就不存在，返回 *failobj* 。返回的字符串永远按照 "
":func:`email.utils.unquote` 方法去除引号。"

#: ../../library/email.message.rst:411
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"返回信息头当中 :mailheader:`Content-Type` 字段当中名为 ``boundary`` "
"的参数值。如果字段当中没有此参数，或者这些个字段压根就不存在，返回 *failobj* 。返回的字符串永远按照 "
":func:`email.utils.unquote` 方法去除引号。"

#: ../../library/email.message.rst:419
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if necessary."
"  A :exc:`~email.errors.HeaderParseError` is raised if the message object "
"has no :mailheader:`Content-Type` header."
msgstr ""
"将 :mailheader:`Content-Type` 头字段的 ``boundary`` 参数设置为 *boundary* 。 "
":meth:`set_boundary` 方法永远都会在必要的时候为 *boundary* 添加引号。如果信息对象中没有 "
":mailheader:`Content-Type` 头字段，抛出 :exc:`~email.errors.HeaderParseError` 异常。"

#: ../../library/email.message.rst:424
msgid ""
"Note that using this method is subtly different from deleting the old "
":mailheader:`Content-Type` header and adding a new one with the new boundary"
" via :meth:`add_header`, because :meth:`set_boundary` preserves the order of"
" the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"请注意使用这个方法与直接删除旧的 :mailheader:`Content-Type` 头字段然后使用 :meth:`add_header` "
"方法添加一个带有新边界值参数的 :mailheader:`Content-Type` 头字段有细微差距。 :meth:`set_boundary` "
"方法会保留 :mailheader:`Content-Type` 头字段在原信息头当中的位置。"

#: ../../library/email.message.rst:433
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or"
" if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"返回 :mailheader:`Content-Type` 头字段中的 ``charset`` "
"参数，强制小写。如果字段当中没有此参数，或者这个字段压根不存在，返回 *failobj* 。"

#: ../../library/email.message.rst:440
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"返回一个包含了信息内所有字符集名字的列表。 如果信息是 :mimetype:`multipart` "
"类型的，那么列表当中的每一项都对应其载荷的子部分的字符集名字。 否则，该列表是一个长度为 1 的列表。"

#: ../../library/email.message.rst:444
msgid ""
"Each item in the list will be a string which is the value of the ``charset``"
" parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"列表当中的每一项都是一个字符串，其值为对应子部分的 :mailheader:`Content-Type` 头字段的 ``charset`` "
"参数值。如果该子部分没有此头字段，或者没有此参数，或者其主要 MIME 类型并非 :mimetype:`text` ，那么列表中的那一项即为 "
"*failobj* 。"

#: ../../library/email.message.rst:453
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
"如果信息头当中存在一个名为 :mailheader:`Content-Disposition` 的字段，且该字段的值为 ``attachment`` "
"（大小写无关），返回 ``True`` 。否则，返回 ``False`` 。"

#: ../../library/email.message.rst:456
msgid ""
"is_attachment is now a method instead of a property, for consistency with "
":meth:`~email.message.Message.is_multipart`."
msgstr ""
"为了与 :meth:`~email.message.Message.is_multipart` 方法一致，is_attachment "
"现在是一个方法，不再是属性了。"

#: ../../library/email.message.rst:463
msgid ""
"Return the lowercased value (without parameters) of the message's "
":mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"如果信息的 :mailheader:`Content-Disposition` 头字段存在，返回其字段值；否则返回 ``None`` "
"。返回的值均为小写，不包含参数。如果信息遵循 :rfc:`2183` 标准，则此方法的返回值只可能在 *inline* 、 *attachment* 和"
" ``None`` 之间选择。"

#: ../../library/email.message.rst:471
msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr "下列方法与信息内容（载荷）之访问与操控有关。"

#: ../../library/email.message.rst:477
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 方法是一个多功能生成器。它可以被用来以深度优先顺序遍历信息对象树的所有部分和子部分。一般而言， :meth:`walk` "
"会被用作 ``for`` 循环的迭代器，每一次迭代都返回其下一个子部分。"

#: ../../library/email.message.rst:482
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "以下例子会打印出一封具有多部分结构之信息的每个部分的 MIME 类型。"

#: ../../library/email.message.rst:503
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` 会遍历所有 :meth:`is_multipart` 方法返回 ``True`` 的部分之子部分，哪怕 "
"``msg.get_content_maintype() == 'multipart'`` 返回的是 ``False`` 。使用 "
"``_structure`` 除错帮助函数可以帮助我们在下面这个例子当中看清楚这一点："

#: ../../library/email.message.rst:531
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the"
" subparts."
msgstr ""
"在这里， ``message`` 的部分并非 ``multiparts`` ，但是它们真的包含子部分！ ``is_multipart()`` 返回 "
"``True`` ， ``walk`` 也深入进这些子部分中。"

#: ../../library/email.message.rst:538
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr "返回信息的 MIME 部分。这个部分是最可能成为信息体的部分。"

#: ../../library/email.message.rst:541
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* 必须是一个字符串序列，其内容从 ``related`` 、 ``html`` 和 ``plain`` "
"这三者组成的集合中选取。这个序列代表着返回的部分的内容类型之偏好。"

#: ../../library/email.message.rst:545
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr "在 ``get_body`` 方法被调用的对象上寻找匹配的候选者。"

#: ../../library/email.message.rst:548
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr ""
"如果 ``related`` 未包括在 *preferencelist* "
"中，可考虑将所遇到的任意相关的根部分（或根部分的子部分）在该（子）部分与一个首选项相匹配时作为候选项。"

#: ../../library/email.message.rst:552
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and"
" if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"当遇到一个 ``multipart/related`` 时，将检查 ``start`` 形参并且如果找到了一个匹配 "
":mailheader:`Content-ID` 的部分，在查找候选匹配时只考虑它。 在其他情况下则只考虑 ``multipart/related`` "
"的第一个（默认的根）部分。"

#: ../../library/email.message.rst:557
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"如果一个部分具有 :mailheader:`Content-Disposition` 标头，则当标头值为 ``inline`` "
"时将只考虑将该部分作为候选匹配。"

#: ../../library/email.message.rst:560
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr "如果没有任何候选部分匹配 *preferencelist* 中的任何首选项，则返回 ``None``。"

#: ../../library/email.message.rst:563
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that"
" really make sense are ``('plain',)``, ``('html', 'plain')``, and the "
"default ``('related', 'html', 'plain')``.  (2) Because matching starts with "
"the object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify"
" a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""
"注: (1) 对于大多数应用来说有意义的 *preferencelist* 组合仅有 ``('plain',)``, ``('html', "
"'plain')`` 以及默认的 ``('related', 'html', 'plain')``。 (2) 由于匹配是从调用 ``get_body``"
" 的对象开始的，因此在 ``multipart/related`` 上调用 ``get_body`` 将返回对象本身，除非 "
"*preferencelist* 具有非默认值。 (3) 未指定 :mailheader:`Content-Type` 或者 "
":mailheader:`Content-Type` 标头无效的消息（或消息部分）将被当作具有 ``text/plain`` 类型来处理，这有时可能导致"
" ``get_body`` 返回非预期的结果。"

#: ../../library/email.message.rst:577
msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or "
"``multipart/alternative`` (unless they are explicitly marked as attachments "
"via :mailheader:`Content-Disposition: attachment`), and return all remaining"
" parts.  When applied directly to a ``multipart/related``, return an "
"iterator over the all the related parts except the root part (ie: the part "
"pointed to by the ``start`` parameter, or the first part if there is no "
"``start`` parameter or the ``start`` parameter doesn't match the "
":mailheader:`Content-ID` of any of the parts).  When applied directly to a "
"``multipart/alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""
"返回包含所有不是候选 \"body\" 部分的消息的直接子部分的迭代器。 也就是说，跳过首次出现的每个 ``text/plain``, "
"``text/html``, ``multipart/related`` 或 ``multipart/alternative`` (除非通过 "
":mailheader:`Content-Disposition: attachment` 将它们显式地标记为附件)，并返回所有的其余部分。 "
"当直接应用于 ``multipart/related`` 时，将返回包含除根部分之外所有相关部分的迭代器（即由 ``start`` "
"形参所指向的部分，或者当没有 ``start`` 形参或 ``start`` 形参不能匹配任何部分的 :mailheader:`Content-ID` "
"时则为第一部分）。 当直接应用于 ``multipart/alternative`` 或非 ``multipart`` 时，将返回一个空迭代器。"

#: ../../library/email.message.rst:593
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which"
" will be empty for a non-``multipart``.  (See also "
":meth:`~email.message.EmailMessage.walk`.)"
msgstr ""
"返回包含消息的所有直接子部分的迭代器，对于非 ``multipart`` 将为空对象。 （另请参阅 "
":meth:`~email.message.EmailMessage.walk`。）"

#: ../../library/email.message.rst:600
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along"
" any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by"
" the current :mod:`~email.policy`."
msgstr ""
"调用 *content_manager* 的 "
":meth:`~email.contentmanager.ContentManager.get_content` "
"方法，将自身作为消息对象传入，并将其他参数或关键字作为额外参数传入。 如果未指定 *content_manager*，则会使用当前 "
":mod:`~email.policy` 所指定的 ``content_manager``。"

#: ../../library/email.message.rst:609
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along"
" any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by"
" the current :mod:`~email.policy`."
msgstr ""
"调用 *content_manager* 的 "
":meth:`~email.contentmanager.ContentManager.set_content` "
"方法，将自身作为消息传入，并将其他参数或关键字作为额外参数传入。 如果未指定 *content_manager*，则会使用当前 "
":mod:`~email.policy` 所指定的 ``content_manager``。"

#: ../../library/email.message.rst:618
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""
"将非 ``multipart`` 消息转换为 ``multipart/related`` 消息，将任何现有的 "
":mailheader:`Content-` 标头和载荷移入 ``multipart`` 的（新加）首部分。 如果指定了 "
"*boundary*，会用它作为 multipart 中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。"

#: ../../library/email.message.rst:628
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a "
"``multipart/alternative``, moving any existing :mailheader:`Content-` "
"headers and payload into a (new) first part of the ``multipart``.  If "
"*boundary* is specified, use it as the boundary string in the multipart, "
"otherwise leave the boundary to be automatically created when it is needed "
"(for example, when the message is serialized)."
msgstr ""
"将非 ``multipart`` 或 ``multipart/related`` 转换为 "
"``multipart/alternative``，将任何现有的 :mailheader:`Content-` 标头和载荷移入 "
"``multipart`` 的（新加）首部分。 如果指定了 *boundary*，会用它作为 multipart "
"中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。"

#: ../../library/email.message.rst:638
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing "
":mailheader:`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in"
" the multipart, otherwise leave the boundary to be automatically created "
"when it is needed (for example, when the message is serialized)."
msgstr ""
"将非 ``multipart``, ``multipart/related`` 或 ``multipart-alternative`` 转换为 "
"``multipart/mixed``，将任何现有的 :mailheader:`Content-` 标头和载荷移入 ``multipart`` "
"的（新加）首部分。 如果指定了 *boundary*，会用它作为 multipart "
"中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。"

#: ../../library/email.message.rst:648
msgid ""
"If the message is a ``multipart/related``, create a new message object, pass"
" all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart``, call :meth:`make_related` and then proceed "
"as above.  If the message is any other type of ``multipart``, raise a "
":exc:`TypeError`. If *content_manager* is not specified, use the "
"``content_manager`` specified by the current :mod:`~email.policy`. If the "
"added part has no :mailheader:`Content-Disposition` header, add one with the"
" value ``inline``."
msgstr ""
"如果消息为 ``multipart/related``，则创建一个新的消息对象，将所有参数传给其 :meth:`set_content` 方法，并将其 "
":meth:`~email.message.Message.attach` 到 ``multipart``。 如果消息为非 "
"``multipart``，则先调用 :meth:`make_related` 然后再继续上述步骤。 如果消息为任何其他类型的 "
"``multipart``，则会引发 :exc:`TypeError`。 如果未指定 *content_manager*，则使用当前 "
":mod:`~email.policy` 所指定的 ``content_manager``。 如果添加的部分没有 "
":mailheader:`Content-Disposition` 标头，则会添加一个值为 ``inline`` 的标头。"

#: ../../library/email.message.rst:661
msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart`` or ``multipart/related``, call "
":meth:`make_alternative` and then proceed as above.  If the message is any "
"other type of ``multipart``, raise a :exc:`TypeError`. If *content_manager* "
"is not specified, use the ``content_manager`` specified by the current "
":mod:`~email.policy`."
msgstr ""
"如果消息为 ``multipart/alternative``，则创建一个新的消息对象，将所有参数传给其 :meth:`set_content` "
"方法，并将其 :meth:`~email.message.Message.attach` 到 ``multipart``。 如果消息为非 "
"``multipart`` 或 ``multipart/related``，则先调用 :meth:`make_alternative` "
"然后再继续上述步骤。 如果消息为任何其他类型的 ``multipart``，则会引发 :exc:`TypeError`。 如果未指定 "
"*content_manager*，则会使用当前 :mod:`~email.policy` 所指定的 ``content_manager``。"

#: ../../library/email.message.rst:673
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart``, ``multipart/related``, or "
"``multipart/alternative``, call :meth:`make_mixed` and then proceed as "
"above. If *content_manager* is not specified, use the ``content_manager`` "
"specified by the current :mod:`~email.policy`.  If the added part has no "
":mailheader:`Content-Disposition` header, add one with the value "
"``attachment``.  This method can be used both for explicit attachments "
"(:mailheader:`Content-Disposition: attachment`) and ``inline`` attachments "
"(:mailheader:`Content-Disposition: inline`), by passing appropriate options "
"to the ``content_manager``."
msgstr ""
"如果消息为 ``multipart/mixed``，则创建一个新的消息对象，将所有参数传给其 :meth:`set_content` 方法，并将其 "
":meth:`~email.message.Message.attach` 到 ``multipart``。 如果消息为非 ``multipart``,"
" ``multipart/related`` 或 ``multipart/alternative``，则先调用 :meth:`make_mixed` "
"然后再继续上述步骤。 如果未指定 *content_manager*，则使用当前 :mod:`~email.policy` 所指定的 "
"``content_manager``。 如果添加的部分没有 :mailheader:`Content-Disposition` 标头，则会添加一个值为"
" ``attachment`` 的标头。 此方法对于显式附件 (:mailheader:`Content-Disposition: "
"attachment`) 和 ``inline`` 附件 (:mailheader:`Content-Disposition: inline`) "
"均可使用，只须向 ``content_manager`` 传入适当的选项即可。"

#: ../../library/email.message.rst:689
msgid "Remove the payload and all of the headers."
msgstr "移除所有载荷和所有标头。"

#: ../../library/email.message.rst:694
msgid ""
"Remove the payload and all of the :mailheader:`!Content-` headers, leaving "
"all other headers intact and in their original order."
msgstr "移除载荷以及所有 :mailheader:`!Content-` 标头，保持所有其他标头不变并保留其原始顺序。"

#: ../../library/email.message.rst:698
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr ":class:`EmailMessage` 对象具有下列实例属性:"

#: ../../library/email.message.rst:703
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"MIME 文档格式在标头之后的空白行以及第一个多部分的分界字符串之间允许添加一些文本， 通常，此文本在支持 MIME "
"的邮件阅读器中永远不可见，因为它处在标准 MIME 保护范围之外。 但是，当查看消息的原始文本，或当在不支持 MIME "
"的阅读器中查看消息时，此文本会变得可见。"

#: ../../library/email.message.rst:710
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after"
" the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the "
":class:`~email.generator.Generator` is writing out the plain text "
"representation of a MIME message, and it finds the message has a *preamble* "
"attribute, it will write this text in the area between the headers and the "
"first boundary.  See :mod:`email.parser` and :mod:`email.generator` for "
"details."
msgstr ""
"*preamble* 属性包含 MIME 文档开头部分的这些处于保护范围之外的文本。 当 :class:`~email.parser.Parser` "
"在标头之后及第一个分界字符串之前发现一些文本时，它会将这些文本赋值给消息的 *preamble* 属性。 当 "
":class:`~email.generator.Generator` 写出 MIME 消息的纯文本表示形式时，如果它发现消息具有 *preamble*"
" 属性，它将在标头及第一个分界之间区域写出这些文本。 请参阅 :mod:`email.parser` 和 :mod:`email.generator` "
"了解更多细节。"

#: ../../library/email.message.rst:720
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr "请注意如果消息对象没有前导文本，则 *preamble* 属性将为 ``None``。"

#: ../../library/email.message.rst:726
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is"
" no epilog text this attribute will be ``None``."
msgstr ""
"*epilogue* 属性的作用方式与 *preamble* 相同，区别在于它包含在最后一个分界及消息结尾之间出现的文本。 与 "
":attr:`~EmailMessage.preamble` 类似，如果没有附加文本，则此属性将为 ``None``。"

#: ../../library/email.message.rst:734
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of"
" the possible parsing defects."
msgstr ""
"*defects* 属性包含在解析消息时发现的所有问题的列表。 请参阅 :mod:`email.errors` 了解可能的解析缺陷的详细描述。"

#: ../../library/email.message.rst:741
msgid ""
"This class represents a subpart of a MIME message.  It is identical to "
":class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are"
" added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"这个类代表 MIME 消息的子部分。 它与 :class:`EmailMessage` 相似，不同之处在于当 "
":meth:`~EmailMessage.set_content` 被调用时不会添加 :mailheader:`MIME-Version` "
"标头，因为子部分不需要有它们自己的 :mailheader:`MIME-Version` 标头。"

#: ../../library/email.message.rst:748
msgid "Footnotes"
msgstr "备注"

#: ../../library/email.message.rst:749
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr ""
"原先在3.4版本中以 :term:`provisional module <provisional package>` 添加。过时的文档被移动至 "
":ref:`compat32_message` 。"
