# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-20 14:57+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/bisect.rst:2
msgid ":mod:`!bisect` --- Array bisection algorithm"
msgstr ":mod:`!bisect` --- 数组二分算法"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**源代码：** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over linear "
"searches or frequent resorting."
msgstr ""
"本模块提供对维护一个已排序列表而无须在每次插入后对该列表重排序的支持。 对于具有大量条目需要大量比较运算的长列表，这改进了原来的线性搜索或频繁重排序。"

#: ../../library/bisect.rst:19
msgid ""
"The module is called :mod:`bisect` because it uses a basic bisection "
"algorithm to do its work.  Unlike other bisection tools that search for a "
"specific value, the functions in this module are designed to locate an "
"insertion point. Accordingly, the functions never call an "
":meth:`~object.__eq__` method to determine whether a value has been found.  "
"Instead, the functions only call the :meth:`~object.__lt__` method and will "
"return an insertion point between values in an array."
msgstr ""
"本模块被命名为 :mod:`bisect` 是因为它使用了基本的二分算法来完成任务。 "
"不同于其他搜索特定值的二分算法工具，本模块的函数被设计为定位一个插入点。 相应地，这些函数绝不会调用 :meth:`~object.__eq__` "
"方法来确定是否找到特定值。 相反，这些函数只会调用 :meth:`~object.__lt__` 方法并将返回一个数组的值之间的插入点。"

#: ../../library/bisect.rst:29
msgid "The following functions are provided:"
msgstr "定义了以下函数："

#: ../../library/bisect.rst:34
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already"
" present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"在 *a* 中找到 *x* 合适的插入点以维持有序。参数 *lo* 和 *hi* 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 "
"*x* 已经在 *a* 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 *a* 是列表（list）的话，返回值是可以被放在 "
"``list.insert()`` 的第一个参数的。"

#: ../../library/bisect.rst:41
msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem < x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem >= x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"返回的插入点 *ip* 将数组 *a* 分为两个切片使得对于左侧切片 ``all(elem < x for elem in a[lo : ip])`` "
"为真值而对于右侧切片 ``all(elem >= x for elem in a[ip : hi])`` 为真值。"

#: ../../library/bisect.rst:46
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* value."
msgstr ""
"*key* 指定带有单个参数的 :term:`key function` 用来从数组的每个元素中提取比较键。 为了支持搜索复杂记录，键函数不会被应用到 "
"*x* 值。"

#: ../../library/bisect.rst:50
msgid ""
"If *key* is ``None``, the elements are compared directly and no key function"
" is called."
msgstr "如果 *key* 为 ``None``，则将直接比较元素而不调用任何键函数。"

#: ../../library/bisect.rst:53 ../../library/bisect.rst:67
#: ../../library/bisect.rst:85 ../../library/bisect.rst:105
msgid "Added the *key* parameter."
msgstr "增加了 *key* 形参。"

#: ../../library/bisect.rst:60
msgid ""
"Similar to :py:func:`~bisect.bisect_left`, but returns an insertion point "
"which comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
"类似于 :py:func:`~bisect.bisect_left`，但是返回的插入点是在 *a* 中任何现有条目 *x* 之后（即其右侧）。"

#: ../../library/bisect.rst:63
msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem <= x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem > x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"返回的插入点 *ip* 将数组 *a* 分为两个切片使得对于左侧切片 ``all(elem <= x for elem in a[lo : ip])``"
" 为真值而对于右侧切片 ``all(elem > x for elem in a[ip : hi])`` 为真值。"

#: ../../library/bisect.rst:73
msgid "Insert *x* in *a* in sorted order."
msgstr "按照已排序顺序将 *x* 插入到 *a* 中。"

#: ../../library/bisect.rst:75
msgid ""
"This function first runs :py:func:`~bisect.bisect_left` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"此函数会先运行 :py:func:`~bisect.bisect_left` 来定位一个插入点。 然后，它会在 *a* 上运行 "
":meth:`!insert` 方法在适当的位置插入 *x* 以保持排序顺序。"

#: ../../library/bisect.rst:79 ../../library/bisect.rst:99
msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr "为了支持将记录插入到表中，*key* 函数（如果存在）将被应用到 *x* 用于搜索步骤但不会用于插入步骤。"

#: ../../library/bisect.rst:82 ../../library/bisect.rst:102
msgid ""
"Keep in mind that the *O*\\ (log *n*) search is dominated by the slow *O*\\ "
"(*n*) insertion step."
msgstr "请记住 *O*\\ (log *n*) 搜索是由缓慢的 *O*\\ (*n*) 插入步骤主导的。"

#: ../../library/bisect.rst:92
msgid ""
"Similar to :py:func:`~bisect.insort_left`, but inserting *x* in *a* after "
"any existing entries of *x*."
msgstr "类似于 :py:func:`~bisect.insort_left`，但是会把 *x* 插入到 *a* 中任何现有条目 *x* 之后。"

#: ../../library/bisect.rst:95
msgid ""
"This function first runs :py:func:`~bisect.bisect_right` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"此函数会先运行 :py:func:`~bisect.bisect_right` 来定位一个插入点。 然后，它会在 *a* 上运行 "
":meth:`!insert` 方法在适当的位置插入 *x* 以保持排序顺序。"

#: ../../library/bisect.rst:110
msgid "Performance Notes"
msgstr "性能说明"

#: ../../library/bisect.rst:112
msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep these"
" thoughts in mind:"
msgstr "当使用 *bisect()* 和 *insort()* 编写时间敏感的代码时，请记住以下概念。"

#: ../../library/bisect.rst:115
msgid ""
"Bisection is effective for searching ranges of values. For locating specific"
" values, dictionaries are more performant."
msgstr "二分法对于搜索一定范围的值是很高效的。 对于定位特定的值，则字典的性能更好。"

#: ../../library/bisect.rst:118
msgid ""
"The *insort()* functions are *O*\\ (*n*) because the logarithmic search step"
" is dominated by the linear time insertion step."
msgstr "*insort()* 函数的时间复杂度为 *O*\\ (*n*) 因为对数时间的搜索步骤被线性时间的插入步骤所主导。"

#: ../../library/bisect.rst:121
msgid ""
"The search functions are stateless and discard key function results after "
"they are used.  Consequently, if the search functions are used in a loop, "
"the key function may be called again and again on the same array elements. "
"If the key function isn't fast, consider wrapping it with "
":py:func:`functools.cache` to avoid duplicate computations.  Alternatively, "
"consider searching an array of precomputed keys to locate the insertion "
"point (as shown in the examples section below)."
msgstr ""
"这些搜索函数都是无状态的并且会在它们被使用后丢弃键函数的结果。 因此，如果在一个循环中使用搜索函数，则键函数可能会在同一个数据元素上被反复调用。 "
"如果键函数速度不够快，请考虑用 :py:func:`functools.cache` 来包装它以避免重复计算。 "
"另外，也可以考虑搜索一个预先计算好的键数组来定位插入点（如下面的示例小节所演示的）。"

#: ../../library/bisect.rst:131
msgid ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ is a "
"high performance module that uses *bisect* to managed sorted collections of "
"data."
msgstr ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ 是一个使用"
" *bisect* 来管理数据的已排序多项集的高性能模块。"

#: ../../library/bisect.rst:135
msgid ""
"The `SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ uses "
"bisect to build a full-featured collection class with straight-forward "
"search methods and support for a key-function.  The keys are precomputed to "
"save unnecessary calls to the key function during searches."
msgstr ""
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ 使用 bisect "
"构建了一个功能完整的多项集类，拥有直观的搜索方法和对键函数的支持。 所有键函数都 是预先计算好的以避免在搜索期间对键函数的不必要的调用。"

#: ../../library/bisect.rst:143
msgid "Searching Sorted Lists"
msgstr "搜索有序列表"

#: ../../library/bisect.rst:145
msgid ""
"The above `bisect functions`_ are useful for finding insertion points but "
"can be tricky or awkward to use for common searching tasks. The following "
"five functions show how to transform them into the standard lookups for "
"sorted lists::"
msgstr ""
"上面的 `bisect functions`_ 对于找到插入点是有用的，但在一般的搜索任务中可能会有点尴尬。 "
"下面的五个函数展示了如何将其转换为针对有序列表的标准查找函数::"

#: ../../library/bisect.rst:150
msgid ""
"def index(a, x):\n"
"    'Locate the leftmost value exactly equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a) and a[i] == x:\n"
"        return i\n"
"    raise ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    'Find rightmost value less than x'\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_le(a, x):\n"
"    'Find rightmost value less than or equal to x'\n"
"    i = bisect_right(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_gt(a, x):\n"
"    'Find leftmost value greater than x'\n"
"    i = bisect_right(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError\n"
"\n"
"def find_ge(a, x):\n"
"    'Find leftmost item greater than or equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError"
msgstr ""

#: ../../library/bisect.rst:187
msgid "Examples"
msgstr "例子"

#: ../../library/bisect.rst:191
msgid ""
"The :py:func:`~bisect.bisect` function can be useful for numeric table "
"lookups. This example uses :py:func:`~bisect.bisect` to look up a letter "
"grade for an exam score (say) based on a set of ordered numeric breakpoints:"
" 90 and up is an 'A', 80 to 89 is a 'B', and so on::"
msgstr ""
":py:func:`~bisect.bisect` 函数对于数字表查询也是适用的。 这个例子使用 :py:func:`~bisect.bisect` "
"根据一组有序的数字划分点来查找考试成绩对应的字母等级: (如) 90 及以上为 'A'，80 至 89 为 'B'，依此类推::"

#: ../../library/bisect.rst:196
msgid ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"
msgstr ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"

#: ../../library/bisect.rst:203
msgid ""
"The :py:func:`~bisect.bisect` and :py:func:`~bisect.insort` functions also "
"work with lists of tuples.  The *key* argument can serve to extract the "
"field used for ordering records in a table::"
msgstr ""
":py:func:`~bisect.bisect` 和 :py:func:`~bisect.insort` 对于列表和元组也是适用的。 *key* "
"参数可以提取用于表中记录排序的字段::"

#: ../../library/bisect.rst:207
msgid ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"
msgstr ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"

#: ../../library/bisect.rst:237
msgid ""
"If the key function is expensive, it is possible to avoid repeated function "
"calls by searching a list of precomputed keys to find the index of a "
"record::"
msgstr "如果键函数较为消耗资源，可以通过搜索一个预先计算的键列表来查找记录的索引以避免重复的函数调用::"

#: ../../library/bisect.rst:240
msgid ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # Or use operator.itemgetter(1).\n"
">>> keys = [r[1] for r in data]         # Precompute a list of keys.\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
msgstr ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # 或者使用 operator.itemgetter(1)。\n"
">>> keys = [r[1] for r in data]         # 预计算一个由键组成的列表。\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
