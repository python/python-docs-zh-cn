# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Woko <banbooliu@gmail.com>, 2021
# nick <2330458484@qq.com>, 2021
# iceyasha <IceYasha@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/bisect.rst:2
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- 数组二分查找算法"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**源代码：** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over the more "
"common approach.  The module is called :mod:`bisect` because it uses a basic"
" bisection algorithm to do its work.  The source code may be most useful as "
"a working example of the algorithm (the boundary conditions are already "
"right!)."
msgstr ""
"这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进。这个模块叫做"
" :mod:`bisect` 因为其使用了基本的二分（bisection）算法。源代码也可以作为很棒的算法示例（边界判断也做好啦！）"

#: ../../library/bisect.rst:21
msgid "The following functions are provided:"
msgstr "定义了以下函数："

#: ../../library/bisect.rst:26
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already"
" present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"在 *a* 中找到 *x* 合适的插入点以维持有序。参数 *lo* 和 *hi* 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 "
"*x* 已经在 *a* 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 *a* 是列表（list）的话，返回值是可以被放在 "
"``list.insert()`` 的第一个参数的。"

#: ../../library/bisect.rst:33
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so"
" that ``all(val < x for val in a[lo : i])`` for the left side and ``all(val "
">= x for val in a[i : hi])`` for the right side."
msgstr ""
"返回的插入点 *i* 将数组 *a* 分成两半，使得 ``all(val < x for val in a[lo : i])`` 在左半边而 "
"``all(val >= x for val in a[i : hi])`` 在右半边。"

#: ../../library/bisect.rst:37 ../../library/bisect.rst:58
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* value."
msgstr ""

#: ../../library/bisect.rst:41 ../../library/bisect.rst:62
msgid ""
"If *key* is ``None``, the elements are compared directly with no intervening"
" function call."
msgstr ""

#: ../../library/bisect.rst:44 ../../library/bisect.rst:65
#: ../../library/bisect.rst:83 ../../library/bisect.rst:103
msgid "Added the *key* parameter."
msgstr "增加了 *key* 形参。"

#: ../../library/bisect.rst:51
msgid ""
"Similar to :func:`bisect_left`, but returns an insertion point which comes "
"after (to the right of) any existing entries of *x* in *a*."
msgstr "类似于 :func:`bisect_left`，但是返回的插入点是 *a* 中已存在元素 *x* 的右侧。"

#: ../../library/bisect.rst:54
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so"
" that ``all(val <= x for val in a[lo : i])`` for the left side and ``all(val"
" > x for val in a[i : hi])`` for the right side."
msgstr ""
"返回的插入点 *i* 将数组 *a* 分成两半，使得左半边为 ``all(val <= x for val in a[lo : i])`` 而右半边为 "
"``all(val > x for val in a[i : hi])``。"

#: ../../library/bisect.rst:71
msgid "Insert *x* in *a* in sorted order."
msgstr "按照已排序顺序将 *x* 插入到 *a* 中。"

#: ../../library/bisect.rst:73
msgid ""
"This function first runs :func:`bisect_left` to locate an insertion point. "
"Next, it runs the :meth:`insert` method on *a* to insert *x* at the "
"appropriate position to maintain sort order."
msgstr ""
"此函数首先会运行 :func:`bisect_left` 来定位一个插入点。 然后，它会在 *a* 上运行 :meth:`insert` "
"方法在正确的位置插入 *x* 以保持排序顺序。"

#: ../../library/bisect.rst:77 ../../library/bisect.rst:97
msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr ""

#: ../../library/bisect.rst:80 ../../library/bisect.rst:100
msgid ""
"Keep in mind that the ``O(log n)`` search is dominated by the slow O(n) "
"insertion step."
msgstr "请记住 ``O(log n)`` 搜索是由缓慢的 O(n) 抛入步骤主导的。"

#: ../../library/bisect.rst:90
msgid ""
"Similar to :func:`insort_left`, but inserting *x* in *a* after any existing "
"entries of *x*."
msgstr "类似于 :func:`insort_left`，但是把 *x* 插入到 *a* 中已存在元素 *x* 的右侧。"

#: ../../library/bisect.rst:93
msgid ""
"This function first runs :func:`bisect_right` to locate an insertion point. "
"Next, it runs the :meth:`insert` method on *a* to insert *x* at the "
"appropriate position to maintain sort order."
msgstr ""
"此函数首先会运行 :func:`bisect_right` 来定位一个插入点。 然后，它会在 *a* 上运行 :meth:`insert` "
"方法在正确的位置插入 *x* 以保持排序顺序。"

#: ../../library/bisect.rst:108
msgid "Performance Notes"
msgstr "性能说明"

#: ../../library/bisect.rst:110
msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep these"
" thoughts in mind:"
msgstr "当使用 *bisect()* 和 *insort()* 编写时间敏感的代码时，请记住以下概念。"

#: ../../library/bisect.rst:113
msgid ""
"Bisection is effective for searching ranges of values. For locating specific"
" values, dictionaries are more performant."
msgstr "二分法对于搜索一定范围的值是很高效的。 对于定位特定的值，则字典的性能更好。"

#: ../../library/bisect.rst:116
msgid ""
"The *insort()* functions are ``O(n)`` because the logarithmic search step is"
" dominated by the linear time insertion step."
msgstr "*insort()* 函数的时间复杂度为 ``O(n)`` 因为对数时间的搜索步骤被线性时间的插入步骤所主导。"

#: ../../library/bisect.rst:119
msgid ""
"The search functions are stateless and discard key function results after "
"they are used.  Consequently, if the search functions are used in a loop, "
"the key function may be called again and again on the same array elements. "
"If the key function isn't fast, consider wrapping it with "
":func:`functools.cache` to avoid duplicate computations.  Alternatively, "
"consider searching an array of precomputed keys to locate the insertion "
"point (as shown in the examples section below)."
msgstr ""
"这些搜索函数都是无状态的并且会在它们被使用后丢弃键函数的结果。 因此，如果在一个循环中使用搜索函数，则键函数可能会在同一个数据元素上被反复调用。 "
"如果键函数速度不快，请考虑用 :func:`functools.cache` 来包装它以避免重复计算。 "
"另外，也可以考虑搜索一个预先计算好的键数组来定位插入点（如下面的示例节所演示的）。"

#: ../../library/bisect.rst:129
msgid ""
"`Sorted Collections <http://www.grantjenks.com/docs/sortedcollections/>`_ is"
" a high performance module that uses *bisect* to managed sorted collections "
"of data."
msgstr ""
"`Sorted Collections <http://www.grantjenks.com/docs/sortedcollections/>`_ "
"是一个使用 *bisect* 来管理数据的已排序多项集的高性能模块。"

#: ../../library/bisect.rst:133
msgid ""
"The `SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ uses "
"bisect to build a full-featured collection class with straight-forward "
"search methods and support for a key-function.  The keys are precomputed to "
"save unnecessary calls to the key function during searches."
msgstr ""
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ 使用 bisect "
"构建了一个功能完整的多项集类，拥有直观的搜索方法和对键函数的支持。 所有键函数都 是预先计算好的以避免在搜索期间对键函数的不必要的调用。"

#: ../../library/bisect.rst:141
msgid "Searching Sorted Lists"
msgstr "搜索有序列表"

#: ../../library/bisect.rst:143
msgid ""
"The above :func:`bisect` functions are useful for finding insertion points "
"but can be tricky or awkward to use for common searching tasks. The "
"following five functions show how to transform them into the standard "
"lookups for sorted lists::"
msgstr ""
"上面的 :func:`bisect` 函数对于找到插入点是有用的，但在一般的搜索任务中可能会有点尴尬。下面 5 "
"个函数展示了如何将其转变成有序列表中的标准查找函数 ::"

#: ../../library/bisect.rst:185
msgid "Examples"
msgstr "例子"

#: ../../library/bisect.rst:189
msgid ""
"The :func:`bisect` function can be useful for numeric table lookups. This "
"example uses :func:`bisect` to look up a letter grade for an exam score "
"(say) based on a set of ordered numeric breakpoints: 90 and up is an 'A', 80"
" to 89 is a 'B', and so on::"
msgstr ""
"函数 :func:`bisect` 还可以用于数字表查询。这个例子是使用 :func:`bisect` "
"从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：90 分及以上是 'A'，80 到 89 是 'B'，以此类推 ::"

#: ../../library/bisect.rst:201
msgid ""
"The :func:`bisect` and :func:`insort` functions also work with lists of "
"tuples.  The *key* argument can serve to extract the field used for ordering"
" records in a table::"
msgstr ""

#: ../../library/bisect.rst:235
msgid ""
"If the key function is expensive, it is possible to avoid repeated function "
"calls by searching a list of precomputed keys to find the index of a "
"record::"
msgstr ""
