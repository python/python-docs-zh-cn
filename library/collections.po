# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jian Aijun <jianaijun@gmail.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# Arisaka97 <solitaire2312@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# Jiuh.star <jiuh.star@gmail.com>, 2022
# 乐成 王, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/collections.rst:2
msgid ":mod:`!collections` --- Container datatypes"
msgstr ":mod:`!collections` --- 容器数据类型"

#: ../../library/collections.rst:10
msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**源代码：** :source:`Lib/collections/__init__.py`"

#: ../../library/collections.rst:20
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:`dict`,"
" :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"这个模块实现了一些专门化的容器，提供了对 Python 的通用内建容器 :class:`dict`、:class:`list`、:class:`set`"
" 和 :class:`tuple` 的补充。"

#: ../../library/collections.rst:25
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../../library/collections.rst:25
msgid "factory function for creating tuple subclasses with named fields"
msgstr "一个工厂函数，用来创建元组的子类，子类的字段是有名称的。"

#: ../../library/collections.rst:26
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../../library/collections.rst:26
msgid "list-like container with fast appends and pops on either end"
msgstr "类似列表的容器，但 append 和 pop 在其两端的速度都很快。"

#: ../../library/collections.rst:27
msgid ":class:`ChainMap`"
msgstr ":class:`ChainMap`"

#: ../../library/collections.rst:27
msgid "dict-like class for creating a single view of multiple mappings"
msgstr "类似字典的类，用于创建包含多个映射的单个视图。"

#: ../../library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../../library/collections.rst:28
msgid "dict subclass for counting :term:`hashable` objects"
msgstr "用于计数 :term:`hashable` 对象的字典子类"

#: ../../library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../../library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr "字典的子类，能记住条目被添加进去的顺序。"

#: ../../library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../../library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr "字典的子类，通过调用用户指定的工厂函数，为键提供默认值。"

#: ../../library/collections.rst:31
msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

#: ../../library/collections.rst:31
msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr "封装了字典对象，简化了字典子类化"

#: ../../library/collections.rst:32
msgid ":class:`UserList`"
msgstr ":class:`UserList`"

#: ../../library/collections.rst:32
msgid "wrapper around list objects for easier list subclassing"
msgstr "封装了列表对象，简化了列表子类化"

#: ../../library/collections.rst:33
msgid ":class:`UserString`"
msgstr ":class:`UserString`"

#: ../../library/collections.rst:33
msgid "wrapper around string objects for easier string subclassing"
msgstr "封装了字符串对象，简化了字符串子类化"

#: ../../library/collections.rst:38
msgid ":class:`ChainMap` objects"
msgstr ":class:`ChainMap` 对象"

#: ../../library/collections.rst:42
msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much faster "
"than creating a new dictionary and running multiple :meth:`~dict.update` "
"calls."
msgstr ""
":class:`ChainMap` 类将多个映射迅速地链到一起，这样它们就可以作为一个单元处理。这通常比创建一个新字典再重复地使用 "
":meth:`~dict.update` 要快得多。"

#: ../../library/collections.rst:46
msgid ""
"The class can be used to simulate nested scopes and is useful in templating."
msgstr "这个类可以用于模拟嵌套作用域，并且对模版化有用。"

#: ../../library/collections.rst:50
msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
"一个 :class:`ChainMap` 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。 如果没有指定任何 "
"*maps*，一个空字典会被作为 *maps*。这样，每个新链至少包含一个映射。"

#: ../../library/collections.rst:54
msgid ""
"The underlying mappings are stored in a list.  That list is public and can "
"be accessed or updated using the *maps* attribute.  There is no other state."
msgstr "底层映射被存储在一个列表中。这个列表是公开的，可以通过 *maps* 属性存取和更新。没有其他的状态。"

#: ../../library/collections.rst:57
msgid ""
"Lookups search the underlying mappings successively until a key is found.  "
"In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr "搜索查询底层映射，直到一个键被找到。不同的是，写，更新和删除只操作第一个映射。"

#: ../../library/collections.rst:60
msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  So, "
"if one of the underlying mappings gets updated, those changes will be "
"reflected in :class:`ChainMap`."
msgstr ""
"一个 :class:`ChainMap` 通过引用合并底层映射。 所以，如果一个底层映射更新了，这些更改会反映到 :class:`ChainMap` 。"

#: ../../library/collections.rst:64
msgid ""
"All of the usual dictionary methods are supported.  In addition, there is a "
"*maps* attribute, a method for creating new subcontexts, and a property for "
"accessing all but the first mapping:"
msgstr ""
"支持所有常用字典方法。另外还有一个  *maps* 属性(attribute)，一个创建子上下文的方法(method)， "
"一个存取它们首个映射的属性(property):"

#: ../../library/collections.rst:70
msgid ""
"A user updateable list of mappings.  The list is ordered from first-searched"
" to last-searched.  It is the only stored state and can be modified to "
"change which mappings are searched.  The list should always contain at least"
" one mapping."
msgstr "一个可以更新的映射列表。这个列表是按照第一次搜索到最后一次搜索的顺序组织的。它是仅有的存储状态，可以被修改。列表最少包含一个映射。"

#: ../../library/collections.rst:77
msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of the "
"maps in the current instance.  If ``m`` is specified, it becomes the new map"
" at the front of the list of mappings; if not specified, an empty dict is "
"used, so that a call to ``d.new_child()`` is equivalent to: ``ChainMap({}, "
"*d.maps)``. If any keyword arguments are specified, they update passed map "
"or new empty dict. This method is used for creating subcontexts that can be "
"updated without altering values in any of the parent mappings."
msgstr ""
"返回一个新的 :class:`ChainMap`，其中包含一个新的映射，后面跟随当前实例中的所有映射。 如果指定了 "
"``m``，它会成为新的映射加在映射列表的前面；如果未指定，则会使用一个空字典，因此调用 ``d.new_child()`` 就等价于 "
"``ChainMap({}, *d.maps)``。 如果指定了任何关键字参数，它们会更新所传入的映射或新的空字典。 "
"此方法被用于创建子上下文，它可在不改变任何上级映射的情况下被更新。"

#: ../../library/collections.rst:86
msgid "The optional ``m`` parameter was added."
msgstr "添加了可选的 ``m``  形参。"

#: ../../library/collections.rst:89
msgid "Keyword arguments support was added."
msgstr "增加了对关键字参数的支持。"

#: ../../library/collections.rst:94
msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in the"
" current instance except the first one.  This is useful for skipping the "
"first map in the search.  Use cases are similar to those for the "
":keyword:`nonlocal` keyword used in :term:`nested scopes <nested scope>`.  "
"The use cases also parallel those for the built-in :func:`super` function.  "
"A reference to ``d.parents`` is equivalent to: ``ChainMap(*d.maps[1:])``."
msgstr ""
"属性返回一个新的 :class:`ChainMap` 包含所有的当前实例的映射，除了第一个。这样可以在搜索的时候跳过第一个映射。 使用的场景类似在 "
":term:`nested scopes <nested scope>` 嵌套作用域中使用 :keyword:`nonlocal` "
"关键词。用例也可以类比内建函数  :func:`super` 。一个 ``d.parents`` 的引用等价于 "
"``ChainMap(*d.maps[1:])`` 。"

#: ../../library/collections.rst:102
msgid ""
"Note, the iteration order of a :class:`ChainMap` is determined by scanning "
"the mappings last to first::"
msgstr "注意，:class:`ChainMap` 的迭代顺序是通过从后往前扫描所有映射来确定的::"

#: ../../library/collections.rst:105
msgid ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"
msgstr ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"

#: ../../library/collections.rst:110
msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr "使得顺序与从最后一个映射开始调用一系列 :meth:`dict.update` 得到的字典的迭代顺序相同："

#: ../../library/collections.rst:113
msgid ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"
msgstr ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"

#: ../../library/collections.rst:118
msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr "增加了对 ``|`` 和 ``|=`` 运算符的支持，相关说明见 :pep:`584`。"

#: ../../library/collections.rst:123
msgid ""
"The `MultiContext class "
"<https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py>`_"
" in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing to"
" any mapping in the chain."
msgstr ""
"`MultiContext class "
"<https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py>`_"
" 在 Enthought `CodeTools package <https://github.com/enthought/codetools>`_ "
"有支持写映射的选项。"

#: ../../library/collections.rst:129
msgid ""
"Django's `Context class "
"<https://github.com/django/django/blob/main/django/template/context.py>`_ "
"for templating is a read-only chain of mappings.  It also features pushing "
"and popping of contexts similar to the "
":meth:`~collections.ChainMap.new_child` method and the "
":attr:`~collections.ChainMap.parents` property."
msgstr ""
"Django 中用于模板的 `Context class "
"<https://github.com/django/django/blob/main/django/template/context.py>`_ "
"是只读的映射链。 它还具有上下文推送和弹出特性，类似于 :meth:`~collections.ChainMap.new_child` 方法和 "
":attr:`~collections.ChainMap.parents` 特征属性。"

#: ../../library/collections.rst:136
msgid ""
"The `Nested Contexts recipe "
"<https://code.activestate.com/recipes/577434-nested-contexts-a-chain-of-"
"mapping-objects/>`_ has options to control whether writes and other "
"mutations apply only to the first mapping or to any mapping in the chain."
msgstr ""
"`Nested Contexts recipe <https://code.activestate.com/recipes/577434-nested-"
"contexts-a-chain-of-mapping-objects/>`_ 提供了对于写入和其他修改是只应用于链路中第一个映射还是所有映射的选项。"

#: ../../library/collections.rst:141
msgid ""
"A `greatly simplified read-only version of Chainmap "
"<https://code.activestate.com/recipes/305268/>`_."
msgstr "一个 `极简的只读版 Chainmap <https://code.activestate.com/recipes/305268/>`_."

#: ../../library/collections.rst:146
msgid ":class:`ChainMap` Examples and Recipes"
msgstr ":class:`ChainMap` 例子和方法"

#: ../../library/collections.rst:148
msgid "This section shows various approaches to working with chained maps."
msgstr "这一节提供了多个使用链映射的案例。"

#: ../../library/collections.rst:151
msgid "Example of simulating Python's internal lookup chain::"
msgstr "模拟Python内部lookup链的例子 ::"

#: ../../library/collections.rst:153
msgid ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"
msgstr ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"

#: ../../library/collections.rst:156
msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr "让用户指定的命令行参数优先于环境变量，优先于默认值的例子 ::"

#: ../../library/collections.rst:159
msgid ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"
msgstr ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"

#: ../../library/collections.rst:173
msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested "
"contexts::"
msgstr "用 :class:`ChainMap` 类模拟嵌套上下文的例子 ::"

#: ../../library/collections.rst:176
msgid ""
"c = ChainMap()        # Create root context\n"
"d = c.new_child()     # Create nested child context\n"
"e = c.new_child()     # Child of c, independent from d\n"
"e.maps[0]             # Current context dictionary -- like Python's locals()\n"
"e.maps[-1]            # Root context -- like Python's globals()\n"
"e.parents             # Enclosing context chain -- like Python's nonlocals\n"
"\n"
"d['x'] = 1            # Set value in current context\n"
"d['x']                # Get first key in the chain of contexts\n"
"del d['x']            # Delete from current context\n"
"list(d)               # All nested values\n"
"k in d                # Check all nested values\n"
"len(d)                # Number of nested values\n"
"d.items()             # All nested items\n"
"dict(d)               # Flatten into a regular dictionary"
msgstr ""
"c = ChainMap()        # 创建根上下文\n"
"d = c.new_child()     # 创建嵌套的子上下文\n"
"e = c.new_child()     # c 的子上下文，独立于 d\n"
"e.maps[0]             # 当前上下文字典 -- 类似 Python 的 locals()\n"
"e.maps[-1]            # 根上下文 -- 类似 Python 的 globals()\n"
"e.parents             # 闭包的上下文链 -- 类似 Python 的 nonlocals\n"
"\n"
"d['x'] = 1            # 在当前上下文中设置值\n"
"d['x']                # 在上下文链中获取第一个键\n"
"del d['x']            # 在当前上下文中删除\n"
"list(d)               # 所有嵌套的值\n"
"k in d                # 检查所有嵌套的值\n"
"len(d)                # 嵌套的值的数量\n"
"d.items()             # 所有嵌套的条目\n"
"dict(d)               # 展平为一个常规字典"

#: ../../library/collections.rst:192
msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to the"
" first mapping in the chain while lookups will search the full chain.  "
"However, if deep writes and deletions are desired, it is easy to make a "
"subclass that updates keys found deeper in the chain::"
msgstr ""
":class:`ChainMap` 类只更新链中的第一个映射，但lookup会搜索整个链。 "
"然而，如果需要深度写和删除，也可以很容易的通过定义一个子类来实现它 ::"

#: ../../library/collections.rst:197
msgid ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})\n"
">>> d['lion'] = 'orange'         # update an existing key two levels down\n"
">>> d['snake'] = 'red'           # new keys get added to the topmost dict\n"
">>> del d['elephant']            # remove an existing key one level down\n"
">>> d                            # display result\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"
msgstr ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})\n"
">>> d['lion'] = 'orange'         # 更新向下两级的现有键\n"
">>> d['snake'] = 'red'           # 添加新键到最高层级的字典\n"
">>> del d['elephant']            # 移除向下一级的现有键\n"
">>> d                            # 显示结果\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"

#: ../../library/collections.rst:223
msgid ":class:`Counter` objects"
msgstr ":class:`Counter` 对象"

#: ../../library/collections.rst:225
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr "一个计数器工具，为的是可以方便快速地计账。例如："

#: ../../library/collections.rst:228
msgid ""
">>> # Tally occurrences of words in a list\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # Find the ten most common words in Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"
msgstr ""
">>> # 统计一个列表中各单词的出现次数\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # 找出《哈姆雷特》中出现次数排前十的单词\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"

#: ../../library/collections.rst:245
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting :term:`hashable`"
" objects. It is a collection where elements are stored as dictionary keys "
"and their counts are stored as dictionary values.  Counts are allowed to be "
"any integer value including zero or negative counts.  The :class:`Counter` "
"class is similar to bags or multisets in other languages."
msgstr ""
":class:`Counter` 是 :class:`dict` 的子类，用于计数 :term:`hashable` "
"对象。它是一个多项集，元素存储为字典的键而它们的计数存储为字典的值。计数可以是任何整数，包括零或负的计数值。:class:`Counter` "
"类与其他语言中的 bag 或 multiset 很相似。"

#: ../../library/collections.rst:251
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr "它可以通过计数一个 *iterable* 中的元素来初始化，或用其它 *mapping* (包括 counter) 初始化："

#: ../../library/collections.rst:259
msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"Counter 对象的接口类似于字典，不同的是，如果查询的键不在 Counter 中，它会返回一个 0 而不是引发一个 :exc:`KeyError`："

#: ../../library/collections.rst:266
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr "设置一个计数为0不会从计数器中移去一个元素。使用 ``del`` 来删除它:"

#: ../../library/collections.rst:274
msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to "
"remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is first "
"encountered in the left operand and then by the order encountered in the "
"right operand."
msgstr ""
"作为 :class:`dict` 的子类，:class:`Counter` 继承了记住插入顺序的功能。*Counter* "
"对象间的数学运算也是保序的。结果首先把左操作数中存在的元素按照它们在左操作数中的顺序排序，后面跟着其它元素，按它们在右操作数中的顺序排序。"

#: ../../library/collections.rst:280
msgid ""
"Counter objects support additional methods beyond those available for all "
"dictionaries:"
msgstr "Counter 对象在对所有字典可用的方法以外还支持一些附加方法:"

#: ../../library/collections.rst:285
msgid ""
"Return an iterator over elements repeating each as many times as its count."
"  Elements are returned in the order first encountered. If an element's "
"count is less than one, :meth:`elements` will ignore it."
msgstr ""
"返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，:meth:`elements` "
"将会忽略它。"

#: ../../library/collections.rst:295
msgid ""
"Return a list of the *n* most common elements and their counts from the most"
" common to the least.  If *n* is omitted or ``None``, :meth:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered in the order first encountered:"
msgstr ""
"返回一个列表，其中包含 *n* 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 *n* 被省略或为 "
"``None``，:meth:`most_common` 将返回计数器中的 *所有* 元素。 计数值相等的元素按首次出现的顺序排序："

#: ../../library/collections.rst:305
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"减去一个 *可迭代对象* 或 *映射对象* (或 counter) 中的元素。类似于 :meth:`dict.update` "
"但是是减去而非替换。输入和输出都可以是 0 或负数。"

#: ../../library/collections.rst:319
msgid "Compute the sum of the counts."
msgstr "计算总计数值。"

#: ../../library/collections.rst:327
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr "通常字典方法都可用于 :class:`Counter` 对象，除了有两个方法工作方式与字典并不相同。"

#: ../../library/collections.rst:332
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr "这个类方法没有在 :class:`Counter` 中实现。"

#: ../../library/collections.rst:336
msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing"
" them.  Also, the *iterable* is expected to be a sequence of elements, not a"
" sequence of ``(key, value)`` pairs."
msgstr ""
"加上一个 *可迭代对象* 或 *映射对象* (或 counter) 中的元素。类似于 :meth:`dict.update` "
"但是是加上而非替换。另外，*可迭代对象* 应当是一个元素序列，而不是一个 ``(key, value)`` 对的序列。"

#: ../../library/collections.rst:341
msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All of"
" those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""
"计数对象支持相等性、子集和超集关系等富比较运算符: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``。 "
"所有这些检测会将不存在的元素当作计数值为零，因此 ``Counter(a=1) == Counter(a=1, b=0)`` 将返回真值。"

#: ../../library/collections.rst:346
msgid "Rich comparison operations were added."
msgstr "增加了富比较运算。"

#: ../../library/collections.rst:349
msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""
"在相等性检测中，不存在的元素会被当作计数值为零。 在此之前，``Counter(a=3)`` 和 ``Counter(a=3, b=0)`` "
"会被视为不同。"

#: ../../library/collections.rst:354
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr ":class:`Counter` 对象的常用案例 ::"

#: ../../library/collections.rst:356
msgid ""
"c.total()                       # total of all counts\n"
"c.clear()                       # reset all counts\n"
"list(c)                         # list unique elements\n"
"set(c)                          # convert to a set\n"
"dict(c)                         # convert to a regular dictionary\n"
"c.items()                       # access the (elem, cnt) pairs\n"
"Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs\n"
"c.most_common()[:-n-1:-1]       # n least common elements\n"
"+c                              # remove zero and negative counts"
msgstr ""
"c.total()                       # 所有计数的总和\n"
"c.clear()                       # 重置所有计数\n"
"list(c)                         # 列出不同的元素\n"
"set(c)                          # 转换为集合\n"
"dict(c)                         # 转换为常规字典\n"
"c.items()                       # 访问 (元素, 计数) 对\n"
"Counter(dict(list_of_pairs))    # 转换自 (元素, 计数) 对的列表\n"
"c.most_common()[:-n-1:-1]       # n 个最不常见的元素\n"
"+c                              # 移除为零和负的计数"

#: ../../library/collections.rst:366
msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum"
" and maximum of corresponding counts.  Equality and inclusion compare "
"corresponding counts.  Each operation can accept inputs with signed counts, "
"but the output will exclude results with counts of zero or less."
msgstr ""
"提供了几种数学运算用来合并 :class:`Counter` 对象，产生多集（所有计数值均大于零的 "
"counter）。加减运算通过增加或减少两者间对应元素的计数来合并 "
"counter。交并运算返回对应计数的最小值和最大值。相等和包含运算比较对应的计数。每个运算的参数都可以含有有符号的计数，但输出将排除计数小于等于零的元素。"

#: ../../library/collections.rst:374
msgid ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # add two counters together:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtract (keeping only positive counts)\n"
"Counter({'a': 2})\n"
">>> c & d                       # intersection:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # union:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # equality:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusion:  c[x] <= d[x]\n"
"False"
msgstr ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # 将两个计数器相加:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # 相减（只保留为正的计数）\n"
"Counter({'a': 2})\n"
">>> c & d                       # 交集:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # 并集:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # 相等:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # 包括:  c[x] <= d[x]\n"
"False"

#: ../../library/collections.rst:391
msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter or "
"subtracting from an empty counter."
msgstr "单目加和减（一元操作符）意思是从空计数器加或者减去。"

#: ../../library/collections.rst:400
msgid ""
"Added support for unary plus, unary minus, and in-place multiset operations."
msgstr "添加了对一元加，一元减和位置集合操作的支持。"

#: ../../library/collections.rst:405
msgid ""
"Counters were primarily designed to work with positive integers to represent"
" running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases,"
" this section documents the minimum range and type restrictions."
msgstr "计数器主要是为了表达运行的正的计数而设计；但是，小心不要预先排除负数或者其他类型。为了帮助这些用例，这一节记录了最小范围和类型限制。"

#: ../../library/collections.rst:410
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ":class:`Counter` 类是一个字典的子类，不限制键和值。值用于表示计数，但你实际上 *可以* 存储任何其他值。"

#: ../../library/collections.rst:414
msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ":meth:`~Counter.most_common` 方法在值需要排序的时候用。"

#: ../../library/collections.rst:416
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for "
":meth:`~Counter.update` and :meth:`~Counter.subtract` which allow negative "
"and zero values for both inputs and outputs."
msgstr ""
"参与原地操作如 ``c[key] += 1`` 的值的类型只需要支持加和减，所以分数、小数和 decimals "
"都可以用，也支持负数。:meth:`~Counter.update` 和 :meth:`~Counter.subtract` "
"当然也一样，输入和输出都支持 0 和 负数。"

#: ../../library/collections.rst:422
msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr "多集方法是专为只会遇到正值的使用情况设计的。输入可以是 0 或负数，但只输出计数为正的值。没有类型限制，但值的类型需支持加、减和比较操作。"

#: ../../library/collections.rst:427
msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores "
"zero and negative counts."
msgstr ":meth:`~Counter.elements` 方法要求正整数计数。忽略0和负数计数。"

#: ../../library/collections.rst:432
msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-"
"base/html_node/Bag.html>`_ in Smalltalk."
msgstr ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-"
"base/html_node/Bag.html>`_ 在 Smalltalk。"

#: ../../library/collections.rst:435
msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr "Wikipedia 链接 `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."

#: ../../library/collections.rst:437
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-"
"multiset/Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-"
"multiset/Catalog0380__set-multiset.htm>`_ 教程和例子。"

#: ../../library/collections.rst:440
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"数学操作和多集合用例，参考 *Knuth, Donald. The Art of Computer Programming Volume II, "
"Section 4.6.3, Exercise 19* 。"

#: ../../library/collections.rst:444
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"在给定数量和集合元素枚举所有不同的多集合，参考 :func:`itertools.combinations_with_replacement` ::"

#: ../../library/collections.rst:447
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC "
"CC"
msgstr ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC "
"CC"

#: ../../library/collections.rst:451
msgid ":class:`deque` objects"
msgstr ":class:`deque` 对象"

#: ../../library/collections.rst:455
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is"
" empty."
msgstr ""
"返回一个新的双向队列对象，从左到右初始化(用方法 :meth:`append`) ，从 *iterable* （迭代对象) 数据创建。如果 "
"*iterable* 没有指定，新队列为空。"

#: ../../library/collections.rst:458
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same *O*\\ (1) performance in either direction."
msgstr ""
"Deque 队列是对栈或 queue 队列的泛化（该名称的发音为 \"deck\"，是 \"double-ended queue\" 的简写形式)。 "
"Deque 支持线程安全，高度节省内存地从 deque 的任一端添加和弹出条目，在两个方向上的大致性能均为 *O*\\ (1)。"

#: ../../library/collections.rst:463
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur *O*\\ (*n*) memory movement costs"
" for ``pop(0)`` and ``insert(0, v)`` operations which change both the size "
"and position of the underlying data representation."
msgstr ""
"虽然 :class:`list` 对象也支持类似的操作，但它们是针对快速的固定长度的操作进行优化而 ``pop(0)`` 和 ``insert(0, "
"v)`` 操作对下层数据表示的大小和位置改变都将产生 *O*\\ (*n*) 的内存移动开销。"

#: ../../library/collections.rst:469
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary"
" length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where"
" only the most recent activity is of interest."
msgstr ""
"如果 *maxlen* 没有指定或者是 ``None`` ，deques "
"可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。限定长度deque提供类似Unix"
" filter ``tail`` 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。"

#: ../../library/collections.rst:478
msgid "Deque objects support the following methods:"
msgstr "双向队列(deque)对象支持以下方法："

#: ../../library/collections.rst:482
msgid "Add *x* to the right side of the deque."
msgstr "添加 *x* 到右端。"

#: ../../library/collections.rst:487
msgid "Add *x* to the left side of the deque."
msgstr "添加 *x* 到左端。"

#: ../../library/collections.rst:492
msgid "Remove all elements from the deque leaving it with length 0."
msgstr "移除所有元素，使其长度为0."

#: ../../library/collections.rst:497
msgid "Create a shallow copy of the deque."
msgstr "创建一份浅拷贝。"

#: ../../library/collections.rst:504
msgid "Count the number of deque elements equal to *x*."
msgstr "计算 deque 中元素等于 *x* 的个数。"

#: ../../library/collections.rst:511
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr "扩展deque的右侧，通过添加iterable参数中的元素。"

#: ../../library/collections.rst:517
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr "扩展deque的左侧，通过添加iterable参数中的元素。注意，左添加时，在结果中iterable参数中的顺序将被反过来添加。"

#: ../../library/collections.rst:524
msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises :exc:`ValueError` "
"if not found."
msgstr ""
"返回 *x* 在 deque 中的位置（在索引 *start* 之后，索引 *stop* 之前）。 返回第一个匹配项，如果未找到则引发 "
":exc:`ValueError`。"

#: ../../library/collections.rst:533
msgid "Insert *x* into the deque at position *i*."
msgstr "在位置 *i* 插入 *x* 。"

#: ../../library/collections.rst:535
msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an "
":exc:`IndexError` is raised."
msgstr "如果插入会导致一个限长 deque 超出长度 *maxlen* 的话，就引发一个 :exc:`IndexError`。"

#: ../../library/collections.rst:543
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr "移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 :exc:`IndexError`。"

#: ../../library/collections.rst:549
msgid ""
"Remove and return an element from the left side of the deque. If no elements"
" are present, raises an :exc:`IndexError`."
msgstr "移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 :exc:`IndexError`。"

#: ../../library/collections.rst:555
msgid ""
"Remove the first occurrence of *value*.  If not found, raises a "
":exc:`ValueError`."
msgstr "移除找到的第一个 *value*。 如果没有的话就引发 :exc:`ValueError`。"

#: ../../library/collections.rst:561
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "将deque逆序排列。返回 ``None`` 。"

#: ../../library/collections.rst:568
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left."
msgstr "向右循环移动 *n* 步。 如果 *n* 是负数，就向左循环。"

#: ../../library/collections.rst:571
msgid ""
"When the deque is not empty, rotating one step to the right is equivalent to"
" ``d.appendleft(d.pop())``, and rotating one step to the left is equivalent "
"to ``d.append(d.popleft())``."
msgstr ""
"如果deque不是空的，向右循环移动一步就等价于 ``d.appendleft(d.pop())`` ， 向左循环一步就等价于 "
"``d.append(d.popleft())`` 。"

#: ../../library/collections.rst:576
msgid "Deque objects also provide one read-only attribute:"
msgstr "Deque对象同样提供了一个只读属性:"

#: ../../library/collections.rst:580
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "Deque的最大尺寸，如果没有限定的话就是 ``None`` 。"

#: ../../library/collections.rst:585
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[0]`` "
"to access the first element.  Indexed access is *O*\\ (1) at both ends but "
"slows to *O*\\ (*n*) in the middle.  For fast random access, use lists "
"instead."
msgstr ""
"在上述操作以外，deque 还支持迭代, 封存, ``len(d)``, ``reversed(d)``, ``copy.copy(d)``, "
"``copy.deepcopy(d)``, 使用 :keyword:`in` 运算符的成员检测以及下标引用例如通过 ``d[0]`` 访问首个元素等。 "
"索引访问在两端的时间复杂度均为 *O*\\ (1) 但在中间则会低至 *O*\\ (*n*)。 对于快速随机访问，请改用列表。"

#: ../../library/collections.rst:591
msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and "
"``__imul__()``."
msgstr "Deque从版本3.5开始支持 ``__add__()``, ``__mul__()``, 和 ``__imul__()`` 。"

#: ../../library/collections.rst:594
msgid "Example:"
msgstr "示例:"

#: ../../library/collections.rst:596
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # 新建一个包含三项的双端队列\n"
">>> for elem in d:                   # 迭代双端队列的元素\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # 添加一个新条目到右端\n"
">>> d.appendleft('f')                # 添加一个新条目到左端\n"
">>> d                                # 显示双端队列的表示形式\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # 返回并移除最右端的项\n"
"'j'\n"
">>> d.popleft()                      # 返回并移除最左端的项\n"
"'f'\n"
">>> list(d)                          # 列出双端队列的内容\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # 查看最左端的项\n"
"'g'\n"
">>> d[-1]                            # 查看最右端的项\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # 反向列出双端队列的内容\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # 搜索双端队列\n"
"True\n"
">>> d.extend('jkl')                  # 一次添加多个元素\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # 向右轮转\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # 向左轮转\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # 新建一个反向的双端队列\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # 清空双端队列\n"
">>> d.pop()                          # 无法从空的双端队列弹出元素\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() 将反转输入顺序\n"
">>> d\n"
"deque(['c', 'b', 'a'])"

#: ../../library/collections.rst:651
msgid ":class:`deque` Recipes"
msgstr ":class:`deque` 用法"

#: ../../library/collections.rst:653
msgid "This section shows various approaches to working with deques."
msgstr "这一节展示了deque的多种用法。"

#: ../../library/collections.rst:655
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr "限长deque提供了类似Unix ``tail`` 过滤功能 ::"

#: ../../library/collections.rst:658
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"
msgstr ""
"def tail(filename, n=10):\n"
"    '返回文件的最后 n 行'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"

#: ../../library/collections.rst:663
msgid ""
"Another approach to using deques is to maintain a sequence of recently added"
" elements by appending to the right and popping to the left::"
msgstr "另一个用法是维护一个近期添加元素的序列，通过从右边添加和从左边弹出 ::"

#: ../../library/collections.rst:666
msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"
msgstr ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"

#: ../../library/collections.rst:678
msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a "
":class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with "
":meth:`~deque.popleft`; otherwise, it can be cycled back to the end with the"
" :meth:`~deque.rotate` method::"
msgstr ""
"一个 `轮询调度器 <https://en.wikipedia.org/wiki/Round-robin_scheduling>`_ 可以通过在 "
":class:`deque` 中放入迭代器来实现。值从当前迭代器的位置0被取出并暂存(yield)。 如果这个迭代器消耗完毕，就用 "
":meth:`~deque.popleft` 将其从对列中移去；否则，就通过  :meth:`~deque.rotate` 将它移到队列的末尾 ::"

#: ../../library/collections.rst:685
msgid ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove an exhausted iterator.\n"
"            iterators.popleft()"
msgstr ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # 移除已耗尽的迭代器。\n"
"            iterators.popleft()"

#: ../../library/collections.rst:697
msgid ""
"The :meth:`~deque.rotate` method provides a way to implement :class:`deque` "
"slicing and deletion.  For example, a pure Python implementation of ``del "
"d[n]`` relies on the ``rotate()`` method to position elements to be popped::"
msgstr ""
":meth:`~deque.rotate` 方法提供了一种方式来实现 :class:`deque` 切片和删除。 例如， 一个纯的Python "
"``del d[n]`` 实现依赖于 ``rotate()`` 来定位要弹出的元素 ::"

#: ../../library/collections.rst:701
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"

#: ../../library/collections.rst:706
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying "
":meth:`~deque.rotate` to bring a target element to the left side of the "
"deque. Remove old entries with :meth:`~deque.popleft`, add new entries with "
":meth:`~deque.extend`, and then reverse the rotation. With minor variations "
"on that approach, it is easy to implement Forth style stack manipulations "
"such as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and "
"``roll``."
msgstr ""
"要实现 :class:`deque` 切片， 使用一个类似的方法，应用 :meth:`~deque.rotate` 将目标元素放到左边。通过 "
":meth:`~deque.popleft` 移去老的条目（entries），通过 :meth:`~deque.extend` 添加新的条目， 然后反向"
" rotate。这个方法可以最小代价实现命令式的栈操作，诸如 ``dup``, ``drop``, ``swap``, ``over``, "
"``pick``, ``rot``, 和 ``roll`` 。"

#: ../../library/collections.rst:716
msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict` 对象"

#: ../../library/collections.rst:720
msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"返回一个新的类似字典的对象。 :class:`defaultdict` 是内置 :class:`dict` 类的子类。 "
"它重写了一个方法并添加了一个可写的实例变量。 其余的功能与 :class:`dict` 类相同因而不在此文档中写明。"

#: ../../library/collections.rst:725
msgid ""
"The first argument provides the initial value for the "
":attr:`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"本对象包含一个名为 :attr:`default_factory` 的属性，构造时，第一个参数用于为该属性提供初始值，默认为 "
"``None``。所有其他参数（包括关键字参数）都相当于传递给 :class:`dict` 的构造函数。"

#: ../../library/collections.rst:731
msgid ""
":class:`defaultdict` objects support the following method in addition to the"
" standard :class:`dict` operations:"
msgstr ":class:`defaultdict` 对象除了支持标准 :class:`dict` 的操作，还支持以下方法作为扩展："

#: ../../library/collections.rst:736
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a "
":exc:`KeyError` exception with the *key* as argument."
msgstr ""
"如果 :attr:`default_factory` 属性为 ``None``，则调用本方法会抛出 :exc:`KeyError` 异常，附带参数 "
"*key*。"

#: ../../library/collections.rst:739
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"如果 :attr:`default_factory` 不为 ``None``，则它会被（不带参数地）调用来为 *key* 提供一个默认值，这个值和 "
"*key* 作为一对键值对被插入到字典中，并作为本方法的返回值返回。"

#: ../../library/collections.rst:743
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr "如果调用 :attr:`default_factory` 时抛出了异常，这个异常会原封不动地向外层传递。"

#: ../../library/collections.rst:746
msgid ""
"This method is called by the :meth:`~object.__getitem__` method of the "
":class:`dict` class when the requested key is not found; whatever it returns"
" or raises is then returned or raised by :meth:`~object.__getitem__`."
msgstr ""
"当请求的键未找到时本方法会被 :class:`dict` 类的 :meth:`~object.__getitem__` "
"方法调用；它返回或引发的任何对象都会被 :meth:`~object.__getitem__` 返回或引发。"

#: ../../library/collections.rst:750
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides "
":meth:`~object.__getitem__`. This means that :meth:`~dict.get` will, like "
"normal dictionaries, return ``None`` as a default rather than using "
":attr:`default_factory`."
msgstr ""
"请注意除了 :meth:`~object.__getitem__` 以外 :meth:`__missing__` 将 *不会* 被调用以执行任何操作。 "
"这意味着 :meth:`~dict.get` 会像普通字典一样返回 ``None`` 作为默认值而不是使用 "
":attr:`default_factory`。"

#: ../../library/collections.rst:756
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ":class:`defaultdict` 对象支持以下实例变量："

#: ../../library/collections.rst:761
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""
"本属性由 :meth:`__missing__` "
"方法来调用。如果构造对象时提供了第一个参数，则本属性会被初始化成那个参数，如果未提供第一个参数，则本属性为 ``None``。"

#: ../../library/collections.rst:765 ../../library/collections.rst:1192
msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in :pep:`584`."
msgstr "增加了合并 (``|``) 与更新 (``|=``) 运算符，相关说明见 :pep:`584`。"

#: ../../library/collections.rst:771
msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` 例子"

#: ../../library/collections.rst:773
msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is easy "
"to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
"使用 :class:`list` 作为 "
":attr:`~defaultdict.default_factory`，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典："

#: ../../library/collections.rst:784
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the "
":attr:`~defaultdict.default_factory` function which returns an empty "
":class:`list`.  The :meth:`!list.append` operation then attaches the value "
"to the new list.  When keys are encountered again, the look-up proceeds "
"normally (returning the list for that key) and the :meth:`!list.append` "
"operation adds another value to the list. This technique is simpler and "
"faster than an equivalent technique using :meth:`dict.setdefault`:"
msgstr ""
"当每个键首次被遇到时，它还不在映射之中；所以会使用 :attr:`~defaultdict.default_factory` "
"函数自动创建一个条目，该函数返回一个空的 :class:`list`。 随后将使用 :meth:`!list.append` "
"操作将值添加到这个新列表中。 当再次遇到该键时，将正常地执行查找并且 :meth:`!list.append` 操作会将另一个值添加到列表中。 "
"这个做法相比使用 :meth:`dict.setdefault` 的等价做法更简单更快速："

#: ../../library/collections.rst:799
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes the "
":class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""
"设置 :attr:`~defaultdict.default_factory` 为 :class:`int`，使 "
":class:`defaultdict` 用于计数（类似其他语言中的 bag 或 multiset）："

#: ../../library/collections.rst:811
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the "
":attr:`~defaultdict.default_factory` function calls :func:`int` to supply a "
"default count of zero.  The increment operation then builds up the count for"
" each letter."
msgstr ""
"当一个字母首次遇到时，它会查询失败，则 :attr:`~defaultdict.default_factory` 会调用 :func:`int` "
"来提供一个整数 0 作为默认值。后续的自增操作建立起对每个字母的计数。"

#: ../../library/collections.rst:815
msgid ""
"The function :func:`int` which always returns zero is just a special case of"
" constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""
"函数 :func:`int` 总是返回 0，这是常数函数的特殊情况。一个更快和灵活的方法是使用 lambda 函数，可以提供任何常量值（不只是0）："

#: ../../library/collections.rst:828
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes the "
":class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
"设置 :attr:`~defaultdict.default_factory` 为 :class:`set` 使 "
":class:`defaultdict` 用于构建 set 集合："

#: ../../library/collections.rst:841
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` 命名元组的工厂函数"

#: ../../library/collections.rst:843
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr "命名元组赋予每个位置一个含义，提供可读性和自文档性。它们可以用于任何普通元组，并添加了通过名字获取值的能力，通过索引值也是可以的。"

#: ../../library/collections.rst:849
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as"
" well as being indexable and iterable.  Instances of the subclass also have "
"a helpful docstring (with *typename* and *field_names*) and a helpful "
":meth:`~object.__repr__` method which lists the tuple contents in a "
"``name=value`` format."
msgstr ""
"返回一个新的名为 *typename* 的元组子类。 这个新子类将被用于创建具有即可通过索引和迭代又可通过属性查找来访问的字段的元组型对象。 "
"这样的子类实例还将具有文档字符串 (包含 *typename* 和 *field_names*) 和以 ``name=value`` 格式列出元组内容的"
" :meth:`~object.__repr__` 方法以方便使用。"

#: ../../library/collections.rst:856
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"*field_names* 是一个像 ``[‘x’, ‘y’]`` 一样的字符串序列。另外 *field_names* "
"可以是一个纯字符串，用空白或逗号分隔开元素名，比如 ``'x y'`` 或者 ``'x, y'`` 。"

#: ../../library/collections.rst:860
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a "
":mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or "
"*raise*."
msgstr ""
"任何有效的Python 标识符都可以作为字段名，除了下划线开头的那些。有效标识符由字母，数字，下划线组成，但首字母不能是数字或下划线，另外不能是关键词 "
":mod:`keyword` 比如 *class*, *for*, *return*, *global*, *pass*, 或 *raise* 。"

#: ../../library/collections.rst:866
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def``"
" and the duplicate fieldname ``abc``."
msgstr ""
"如果 *rename* 为真， 无效字段名会自动转换成位置名。比如 ``['abc', 'def', 'ghi', 'abc']`` 转换成 "
"``['abc', '_1', 'ghi', '_3']`` ， 消除关键词 ``def``  和重复字段名 ``abc`` 。"

#: ../../library/collections.rst:871
msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. Since "
"fields with a default value must come after any fields without a default, "
"the *defaults* are applied to the rightmost parameters.  For example, if the"
" fieldnames are ``['x', 'y', 'z']`` and the defaults are ``(1, 2)``, then "
"``x`` will be a required argument, ``y`` will default to ``1``, and ``z`` "
"will default to ``2``."
msgstr ""
"*defaults* 可以为 ``None`` 或者是一个默认值的 :term:`iterable` "
"。如果一个默认值域必须跟其他没有默认值的域在一起出现，*defaults* 就应用到最右边的参数。比如如果域名 ``['x', 'y', 'z']`` "
"和默认值 ``(1, 2)`` ，那么 ``x`` 就必须指定一个参数值 ，``y`` 默认值 ``1`` ， ``z`` 默认值 ``2`` 。"

#: ../../library/collections.rst:878
msgid ""
"If *module* is defined, the :attr:`~type.__module__` attribute of the named "
"tuple is set to that value."
msgstr "如果定义了 *module*，则命名元组的 :attr:`~type.__module__` 属性将被设为该值。"

#: ../../library/collections.rst:881
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr "具名元组实例毋需字典来保存每个实例的不同属性，所以它们轻量，占用的内存和普通元组一样。"

#: ../../library/collections.rst:884
msgid ""
"To support pickling, the named tuple class should be assigned to a variable "
"that matches *typename*."
msgstr "要支持封存操作，应当将命名元组类赋值给一个匹配 *typename* 的变量。"

#: ../../library/collections.rst:887
msgid "Added support for *rename*."
msgstr "添加了对 *rename* 的支持。"

#: ../../library/collections.rst:890
msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments "
"<keyword-only_parameter>`."
msgstr "*verbose* 和 *rename* 参数成为 :ref:`仅限关键字参数 <keyword-only_parameter>`."

#: ../../library/collections.rst:894
msgid "Added the *module* parameter."
msgstr "添加了 *module* 参数。"

#: ../../library/collections.rst:897
msgid "Removed the *verbose* parameter and the :attr:`!_source` attribute."
msgstr "移除了 *verbose* 形参和 :attr:`!_source` 属性。"

#: ../../library/collections.rst:900
msgid ""
"Added the *defaults* parameter and the "
":attr:`~somenamedtuple._field_defaults` attribute."
msgstr "添加了 *defaults* 形参和 :attr:`~somenamedtuple._field_defaults` 属性。"

#: ../../library/collections.rst:904
msgid ""
">>> # Basic example\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""
">>> # 基本示例\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # 使用位置或关键字参数进行实例化\n"
">>> p[0] + p[1]             # 像普通元组 (11, 22) 一样可索引\n"
"33\n"
">>> x, y = p                # 像普通元素一样解包\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # 字段也可按名称访问\n"
"33\n"
">>> p                       # 名称=值 风格的易读的 __repr__ \n"
"Point(x=11, y=22)"

#: ../../library/collections.rst:920
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr "命名元组尤其有用于赋值 :mod:`csv`  :mod:`sqlite3` 模块返回的元组 ::"

#: ../../library/collections.rst:923
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", \"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", \"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"

#: ../../library/collections.rst:936
msgid ""
"In addition to the methods inherited from tuples, named tuples support three"
" additional methods and two attributes.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr "除了继承元组的方法，命名元组还支持三个额外的方法和两个属性。为了防止字段名冲突，方法和属性以下划线开始。"

#: ../../library/collections.rst:942
msgid ""
"Class method that makes a new instance from an existing sequence or "
"iterable."
msgstr "类方法从存在的序列或迭代实例创建一个新实例。"

#: ../../library/collections.rst:944
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"

#: ../../library/collections.rst:952
msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr "返回一个新的 :class:`dict` ，它将字段名称映射到它们对应的值："

#: ../../library/collections.rst:955
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"

#: ../../library/collections.rst:961
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "返回一个 :class:`OrderedDict` 而不是  :class:`dict` 。"

#: ../../library/collections.rst:964
msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of "
"Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation is "
"to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
"返回一个常规 :class:`dict` 而不是 :class:`OrderedDict`。 因为自 Python 3.7 起，常规字典已经保证有序。 "
"如果需要 :class:`OrderedDict` 的额外特性，推荐的解决方案是将结果转换为需要的类型: "
"``OrderedDict(nt._asdict())``。"

#: ../../library/collections.rst:973
msgid ""
"Return a new instance of the named tuple replacing specified fields with new"
" values::"
msgstr "返回一个新的命名元组实例，并将指定域替换为新的值 ::"

#: ../../library/collections.rst:976
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())"
msgstr ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())"

#: ../../library/collections.rst:983
msgid ""
"Named tuples are also supported by generic function :func:`copy.replace`."
msgstr "泛型函数 :func:`copy.replace` 也支持具名元组。"

#: ../../library/collections.rst:985
msgid ""
"Raise :exc:`TypeError` instead of :exc:`ValueError` for invalid keyword "
"arguments."
msgstr "对于无效的关键字参数将引发 :exc:`TypeError` 而不是 :exc:`ValueError`。"

#: ../../library/collections.rst:991
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr "字符串元组列出了字段名。用于提醒和从现有元组创建一个新的命名元组类型。"

#: ../../library/collections.rst:994
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""
">>> p._fields            # 查看字段名\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"

#: ../../library/collections.rst:1006
msgid "Dictionary mapping field names to default values."
msgstr "字典将字段名称映射到默认值。"

#: ../../library/collections.rst:1008
msgid ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"
msgstr ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"

#: ../../library/collections.rst:1016
msgid ""
"To retrieve a field whose name is stored in a string, use the "
":func:`getattr` function:"
msgstr "要获取这个名字域的值，使用 :func:`getattr` 函数 :"

#: ../../library/collections.rst:1022
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr "转换一个字典到命名元组，使用 ** 两星操作符 (所述如 :ref:`tut-unpacking-arguments`):"

#: ../../library/collections.rst:1029
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr "因为一个命名元组是一个正常的Python类，它可以很容易的通过子类更改功能。这里是如何添加一个计算域和定宽输出打印格式:"

#: ../../library/collections.rst:1033
msgid ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"
msgstr ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"

#: ../../library/collections.rst:1048
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr "上面的子类设置 ``__slots__`` 为一个空元组。通过阻止创建实例字典保持了较低的内存开销。"

#: ../../library/collections.rst:1051
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"子类化对于添加和存储新的名字域是无效的。应当通过 :attr:`~somenamedtuple._fields` 创建一个新的命名元组来实现它:"

#: ../../library/collections.rst:1056
msgid ""
"Docstrings can be customized by making direct assignments to the ``__doc__``"
" fields:"
msgstr "文档字符串可以自定义，通过直接赋值给 ``__doc__`` 属性:"

#: ../../library/collections.rst:1065
msgid "Property docstrings became writeable."
msgstr "文档字符串属性变成可写。"

#: ../../library/collections.rst:1070
msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named tuples."
"  It also provides an elegant notation using the :keyword:`class` keyword::"
msgstr ""
"请参阅 :class:`typing.NamedTuple` ，以获取为命名元组添加类型提示的方法。 它还使用 :keyword:`class` "
"关键字提供了一种优雅的符号::"

#: ../../library/collections.rst:1074
msgid ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"
msgstr ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"

#: ../../library/collections.rst:1079
msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr "对于以字典为底层的可变域名， 参考 :meth:`types.SimpleNamespace` 。"

#: ../../library/collections.rst:1082
msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ":mod:`dataclasses` 模块提供了一个装饰器和一些函数，用于自动将生成的特殊方法添加到用户定义的类中。"

#: ../../library/collections.rst:1087
msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict` 对象"

#: ../../library/collections.rst:1089
msgid ""
"Ordered dictionaries are just like regular dictionaries but have some extra "
"capabilities relating to ordering operations.  They have become less "
"important now that the built-in :class:`dict` class gained the ability to "
"remember insertion order (this new behavior became guaranteed in Python "
"3.7)."
msgstr ""
"有序词典就像常规词典一样，但有一些与排序操作相关的额外功能。由于内置的 :class:`dict` 类获得了记住插入顺序的能力（在 Python 3.7"
" 中保证了这种新行为），它们变得不那么重要了。"

#: ../../library/collections.rst:1095
msgid "Some differences from :class:`dict` still remain:"
msgstr "一些与 :class:`dict` 的不同仍然存在："

#: ../../library/collections.rst:1097
msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr "常规的 :class:`dict` 被设计为非常擅长映射操作。 跟踪插入顺序是次要的。"

#: ../../library/collections.rst:1100
msgid ""
"The :class:`OrderedDict` was designed to be good at reordering operations. "
"Space efficiency, iteration speed, and the performance of update operations "
"were secondary."
msgstr ":class:`OrderedDict` 旨在擅长重新排序操作。 空间效率、迭代速度和更新操作的性能是次要的。"

#: ../../library/collections.rst:1104
msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering operations"
" better than :class:`dict`.  As shown in the recipes below, this makes it "
"suitable for implementing various kinds of LRU caches."
msgstr ""
":class:`OrderedDict` 算法能比 :class:`dict` 更好地处理频繁的重排序操作。 如下面的例程所示，这使得它更适用于实现各种"
" LRU 缓存。"

#: ../../library/collections.rst:1108
msgid ""
"The equality operation for :class:`OrderedDict` checks for matching order."
msgstr "对于 :class:`OrderedDict` ，相等操作检查匹配顺序。"

#: ../../library/collections.rst:1110
msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test with "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""
"常规的 :class:`dict` 可以使用 ``p == q and all(k1 == k2 for k1, k2 in zip(p, q))`` "
"进行模拟顺序相等性测试。"

#: ../../library/collections.rst:1113
msgid ""
"The :meth:`~OrderedDict.popitem` method of :class:`OrderedDict` has a "
"different signature.  It accepts an optional argument to specify which item "
"is popped."
msgstr ""
":class:`OrderedDict` 的 :meth:`~OrderedDict.popitem` 方法具有不同的签名。 "
"它接受一个可选参数来指定要弹出哪一项。"

#: ../../library/collections.rst:1116
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=True)`` "
"with ``d.popitem()`` which is guaranteed to pop the rightmost (last) item."
msgstr ""
"常规的 :class:`dict` 可以使用 ``d.popitem()`` 模拟 OrderedDict 的 "
"``od.popitem(last=True)``，其保证会返回最右边（最后）的项。"

#: ../../library/collections.rst:1119
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=False)``"
" with ``(k := next(iter(d)), d.pop(k))`` which will return and remove the "
"leftmost (first) item if it exists."
msgstr ""
"常规的 :class:`dict` 可以通过 ``(k := next(iter(d)), d.pop(k))`` 来模拟 OrderedDict 的 "
"``od.popitem(last=False)``，它将返回并移除最左边（开头）的条目，如果条目存在的话。"

#: ../../library/collections.rst:1123
msgid ""
":class:`OrderedDict` has a :meth:`~OrderedDict.move_to_end` method to "
"efficiently reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict` 具有一个 :meth:`~OrderedDict.move_to_end` 方法以高效地将元素移到任一端点。"

#: ../../library/collections.rst:1126
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""
"常规的 :class:`dict` 可以通过 ``d[k] = d.pop(k)`` 来模拟 OrderedDict 的 "
"``od.move_to_end(k, last=True)``，它将把键及其所关联的值移到最右边（末尾）的位置。"

#: ../../library/collections.rst:1130
msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and its "
"associated value to the leftmost (first) position."
msgstr ""
"常规的 :class:`dict` 没有 OrderedDict 的 ``od.move_to_end(k, last=False)`` "
"的高效等价物，它会把键及其所关联的值移到最左边（开头）的位置。"

#: ../../library/collections.rst:1134
msgid ""
"Until Python 3.8, :class:`dict` lacked a :meth:`~object.__reversed__` "
"method."
msgstr "在 Python 3.8 之前，:class:`dict` 都缺少 :meth:`~object.__reversed__` 方法。"

#: ../../library/collections.rst:1139
msgid ""
"Return an instance of a :class:`dict` subclass that has methods specialized "
"for rearranging dictionary order."
msgstr "返回一个 :class:`dict` 子类的实例，它具有专门用于重新排列字典顺序的方法。"

#: ../../library/collections.rst:1146
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, first-"
"out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)` order if"
" false."
msgstr ""
"有序字典的 :meth:`popitem` 方法移除并返回一个 (key, value) 键值对。 如果 *last* 值为真，则按 "
":abbr:`LIFO (last-in, first-out)` 后进先出的顺序返回键值对，否则就按 :abbr:`FIFO (first-in, "
"first-out)` 先进先出的顺序返回键值对。"

#: ../../library/collections.rst:1153
msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item is "
"moved to the right end if *last* is true (the default) or to the beginning "
"if *last* is false.  Raises :exc:`KeyError` if the *key* does not exist:"
msgstr ""
"将一个现有的 *key* 移到序字典的任一端。 如果 *last* 为真值（默认）则将条目移到右端，或者如果 *last* 为假值则将条目移到开头。 "
"如果 *key* 不存在则会引发 :exc:`KeyError`:"

#: ../../library/collections.rst:1158
msgid ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"
msgstr ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"

#: ../../library/collections.rst:1170
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr "相对于通常的映射方法，有序字典还另外提供了逆序迭代的支持，通过 :func:`reversed` 。"

#: ../../library/collections.rst:1175
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are roughly equivalent to ``list(od1.items())==list(od2.items())``."
msgstr ""
":class:`OrderedDict` 对象之间的相等性检测对顺序敏感并且大致等价于 "
"``list(od1.items())==list(od2.items())``。"

#: ../../library/collections.rst:1178
msgid ""
"Equality tests between :class:`OrderedDict` objects and other "
":class:`~collections.abc.Mapping` objects are order-insensitive like regular"
" dictionaries.  This allows :class:`OrderedDict` objects to be substituted "
"anywhere a regular dictionary is used."
msgstr ""
":class:`OrderedDict` 对象和其他 :class:`~collections.abc.Mapping` "
"对象之间的相等性检测像常规字典那样对顺序不敏感。 这允许 :class:`OrderedDict` 对象在任何可使用字典的地方被替代。"

#: ../../library/collections.rst:1183
msgid ""
"The items, keys, and values :term:`views <dictionary view>` of "
":class:`OrderedDict` now support reverse iteration using :func:`reversed`."
msgstr ""
":class:`OrderedDict` 的项(item)，键(key)和值(value) :term:`视图 <dictionary view>` "
"现在支持逆序迭代，通过 :func:`reversed` 。"

#: ../../library/collections.rst:1187
msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword arguments "
"passed to the :class:`OrderedDict` constructor and its :meth:`~dict.update` "
"method."
msgstr ""
"随着 :pep:`468` 的通过，传给 :class:`OrderedDict` 构造器及其 :meth:`~dict.update` "
"方法的关键字参数顺序将被保留。"

#: ../../library/collections.rst:1197
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` 例子和用法"

#: ../../library/collections.rst:1199
msgid ""
"It is straightforward to create an ordered dictionary variant that remembers"
" the order the keys were *last* inserted. If a new entry overwrites an "
"existing entry, the original insertion position is changed and moved to the "
"end::"
msgstr "创建记住键值 *最后* 插入顺序的有序字典变体很简单。 如果新条目覆盖现有条目，则原始插入位置将更改并移至末尾::"

#: ../../library/collections.rst:1204
msgid ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"
msgstr ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"

#: ../../library/collections.rst:1211
msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of "
":func:`functools.lru_cache`:"
msgstr "一个 :class:`OrderedDict` 对于实现 :func:`functools.lru_cache` 的变体也很有用:"

#: ../../library/collections.rst:1214
msgid ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"

#: ../../library/collections.rst:1241
msgid ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count }\n"
"        self.cache = OrderedDict()      # { cached_key : function_result }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # max number of uncached requests\n"
"        self.maxsize = maxsize          # max number of stored return values\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count }\n"
"        self.cache = OrderedDict()      # { cached_key : function_result }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # 未缓存请求的最大数量\n"
"        self.maxsize = maxsize          # 已存储返回值的最大数量\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"

#: ../../library/collections.rst:1310
msgid ":class:`UserDict` objects"
msgstr ":class:`UserDict` 对象"

#: ../../library/collections.rst:1312
msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""
":class:`UserDict` 类是用作字典对象的外包装。对这个类的需求已部分由直接创建 :class:`dict` "
"的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字典可以作为属性来访问。"

#: ../../library/collections.rst:1320
msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of "
":class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it to be used for other purposes."
msgstr ""
"模拟字典的类。 这个实例的内容保存在一个常规字典中，它可以通过  :class:`UserDict` 实例的 :attr:`data` 属性来访问。 "
"如果提供了 *initialdata*，则 :attr:`data` 会用其内容来初始化；请注意对 *initialdata* "
"的引用将不会被保留，以允许它被用于其他目的。"

#: ../../library/collections.rst:1326
msgid ""
"In addition to supporting the methods and operations of mappings, "
":class:`UserDict` instances provide the following attribute:"
msgstr ":class:`UserDict` 实例提供了以下属性作为扩展方法和操作的支持:"

#: ../../library/collections.rst:1331
msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr "一个真实的字典，用于保存 :class:`UserDict` 类的内容。"

#: ../../library/collections.rst:1337
msgid ":class:`UserList` objects"
msgstr ":class:`UserList` 对象"

#: ../../library/collections.rst:1339
msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class"
" for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to"
" lists."
msgstr ""
"这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。"

#: ../../library/collections.rst:1344
msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""
"对这个类的需求已部分由直接创建 :class:`list` 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的列表可以作为属性来访问。"

#: ../../library/collections.rst:1350
msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of "
":class:`UserList` instances.  The instance's contents are initially set to a"
" copy of *list*, defaulting to the empty list ``[]``.  *list* can be any "
"iterable, for example a real Python list or a :class:`UserList` object."
msgstr ""
"模拟一个列表。这个实例的内容被保存为一个正常列表，通过 :class:`UserList` 的 :attr:`data` "
"属性存取。实例内容被初始化为一个 *list* 的copy，默认为 ``[]`` 空列表。 *list* "
"可以是迭代对象，比如一个Python列表，或者一个  :class:`UserList` 对象。"

#: ../../library/collections.rst:1356
msgid ""
"In addition to supporting the methods and operations of mutable sequences, "
":class:`UserList` instances provide the following attribute:"
msgstr ":class:`UserList` 提供了以下属性作为可变序列的方法和操作的扩展:"

#: ../../library/collections.rst:1361
msgid ""
"A real :class:`list` object used to store the contents of the "
":class:`UserList` class."
msgstr "一个 :class:`list` 对象用于存储 :class:`UserList` 的内容。"

#: ../../library/collections.rst:1364
msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expected "
"to offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""
"**子类化的要求:** :class:`UserList` "
"的子类需要提供一个构造器，可以无参数调用，或者一个参数调用。返回一个新序列的列表操作需要创建一个实现类的实例。它假定了构造器可以以一个参数进行调用，这个参数是一个序列对象，作为数据源。"

#: ../../library/collections.rst:1371
msgid ""
"If a derived class does not wish to comply with this requirement, all of the"
" special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr "如果一个分离的类不希望依照这个需求，所有的特殊方法就必须重写；请参照源代码进行修改。"

#: ../../library/collections.rst:1377
msgid ":class:`UserString` objects"
msgstr ":class:`UserString` 对象"

#: ../../library/collections.rst:1379
msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass"
" directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""
":class:`UserString` 类是用作字符串对象的外包装。对这个类的需求已部分由直接创建 :class:`str` "
"的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字符串可以作为属性来访问。"

#: ../../library/collections.rst:1387
msgid ""
"Class that simulates a string object.  The instance's content is kept in a "
"regular string object, which is accessible via the :attr:`data` attribute of"
" :class:`UserString` instances.  The instance's contents are initially set "
"to a copy of *seq*.  The *seq* argument can be any object which can be "
"converted into a string using the built-in :func:`str` function."
msgstr ""
"模拟一个字符串对象。这个实例对象的内容保存为一个正常字符串，通过 :class:`UserString` 的 :attr:`data` "
"属性存取。实例内容初始化设置为 *seq* 的copy。*seq* 参数可以是任何可通过内建 :func:`str` 函数转换为字符串的对象。"

#: ../../library/collections.rst:1394
msgid ""
"In addition to supporting the methods and operations of strings, "
":class:`UserString` instances provide the following attribute:"
msgstr ":class:`UserString` 提供了以下属性作为字符串方法和操作的额外支持："

#: ../../library/collections.rst:1399
msgid ""
"A real :class:`str` object used to store the contents of the "
":class:`UserString` class."
msgstr "一个真正的 :class:`str` 对象用来存放 :class:`UserString` 类的内容。"

#: ../../library/collections.rst:1402
msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, and ``maketrans``."
msgstr ""
"新方法 ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, 和 ``maketrans``。"
