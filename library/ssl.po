# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# cdarlint <cdarling@126.com>, 2019
# eric R <trencyclopedia@gmail.com>, 2019
# 汪心禾 <wangxinhe06@gmail.com>, 2019
# ww song <sww4718168@gmail.com>, 2019
# nick <2330458484@qq.com>, 2019
# Zombie110year <zombie110year@gmail.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# KaMingChung <zjm947373@gmail.com>, 2020
# 之航 P <ppzzhh1186861238@hotmail.com>, 2020
# Hissy <aozora@live.cn>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-10 22:51+0000\n"
"PO-Revision-Date: 2019-09-01 03:20+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- 套接字对象的TLS/SSL封装"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**源代码:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS"
" X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr ""
"本模块保证了对传安全传输层协议（TLS）的访问 "
"(SSL)加密，并且提供客户端和服务端层面的网络嵌套字层面的对等连接认证技术。本模块使用OpenSSL库。适用于所有现代Unix系统、Windows以及Mac"
" OS X。只要Open SSL存在的系统，都有机会正常使用。"

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr ""
"某些行为可能具有平台依赖，因为调用是根据操作系统的嵌套字API。不同版本的Open SSL也会引起差异：例如Open SSL版本1.0.1 "
"自带TLSv1.1 和 TLSv1.2 "

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ""
"在阅读 :ref:`ssl-security` 前不要使用此模块。 这样做可能会导致虚假的安全感，因为ssl模块的默认设置不一定适合你的应用程序。"

#: ../../library/ssl.rst:37
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr "本文档记录\"ssl\"模块的对象和函数；更多关于TLS,SSL,和证书的信息，请参阅下方的“详情”选项"

#: ../../library/ssl.rst:41
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"本模块提供了一个类 :class:`ssl.SSLSocket`，它派生自 :class:`socket.socket` "
"类型，并提供类似套接字的包装器，也能够对通过带 SSL 套接字的数据进行加密和解密。 它支持一些额外方法例如 "
":meth:`getpeercert`，该方法可从连接的另一端获取证书，还有 :meth:`cipher`，该方法可获取安全连接所使用的密码。"

#: ../../library/ssl.rst:48
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"对于更复杂的应用程序，:class:`ssl.SSLContext` 类有助于管理设置项和证书，进而可以被使用 "
":meth:`SSLContext.wrap_socket` 方法创建的 SSL 套接字继承。"

#: ../../library/ssl.rst:52
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "更新以支持和 OpenSSL 1.1.0 的链接"

#: ../../library/ssl.rst:57
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8、1.0.0 和 1.0.1 已过时，将不再被支持。在 ssl 模块未来的版本中，最低需要 OpenSSL 1.0.2 或 "
"1.1.0。"

#: ../../library/ssl.rst:63
msgid "Functions, Constants, and Exceptions"
msgstr "方法、常量和异常处理"

#: ../../library/ssl.rst:67
msgid "Socket creation"
msgstr "套接字创建"

#: ../../library/ssl.rst:69
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` of an :class:`SSLContext` instance to wrap "
"sockets as :class:`SSLSocket` objects. The helper functions "
":func:`create_default_context` returns a new context with secure default "
"settings. The old :func:`wrap_socket` function is deprecated since it is "
"both inefficient and has no support for server name indication (SNI) and "
"hostname matching."
msgstr ""
"从 Python 3.2 和 2.7.9 开始，建议使用 :class:`SSLContext` 实例的 "
":meth:`SSLContext.wrap_socket` 来将套接字包装为 :class:`SSLSocket` 对象。 辅助函数 "
":func:`create_default_context` 会返回一个新的带有安全默认设置的上下文。 旧的 :func:`wrap_socket` "
"函数已被弃用，因为它效率较差并且不支持服务器名称提示（SNI）和主机匹配。"

#: ../../library/ssl.rst:77
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "客户端套接字实例，采用默认上下文和IPv4/IPv6双栈::"

#: ../../library/ssl.rst:90
msgid "Client socket example with custom context and IPv4::"
msgstr "客户端套接字示例，带有自定义上下文和IPv4::"

#: ../../library/ssl.rst:102
msgid "Server socket example listening on localhost IPv4::"
msgstr "服务器套接字实例，在localhost上监听IPv4::"

#: ../../library/ssl.rst:116
msgid "Context creation"
msgstr "上下文创建"

#: ../../library/ssl.rst:118
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "便捷函数，可以帮助创建 :class:`SSLContext` 对象，用于常见的目的。"

#: ../../library/ssl.rst:123
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"返回一个新的 :class:`SSLContext` 对象，使用给定 *purpose* 的默认设置。 该设置由 :mod:`ssl` "
"模块选择，并且通常是代表一个比直接调用 :class:`SSLContext` 构造器时更高的安全等级。"

#: ../../library/ssl.rst:128
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* 代表用于进行证书核验的可选受信任 CA 证书，与 "
":meth:`SSLContext.load_verify_locations` 的一致。 如果三个参数均为 "
":const:`None`，此函数可以转而选择信任系统的默认 CA 证书。"

#: ../../library/ssl.rst:134
msgid ""
"The settings are: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2`, and "
":data:`OP_NO_SSLv3` with high encryption cipher suites without RC4 and "
"without unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` "
"as *purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` "
"and either loads CA certificates (when at least one of *cafile*, *capath* or"
" *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr ""
"设置包括: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2` 以及 :data:`OP_NO_SSLv3`，具有不带 "
"RC4 和不带无身份验证密码套件的高度加密密码套件。 传入 :data:`~Purpose.SERVER_AUTH` 作为 *purpose* 会把 "
":data:`~SSLContext.verify_mode` 设为 :data:`CERT_REQUIRED` 并且加载指定 CA 证书（当给出 "
"*cafile*, *capath* 和 *cadata* 中的至少一个）或者使用 "
":meth:`SSLContext.load_default_certs` 来加载默认 CA 证书。"

#: ../../library/ssl.rst:143
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr "协议、选项、密码和其他设置可随时更改为更具约束性的值而无须事先弃用。 这些值代表了兼容性和安全性之间的合理平衡。"

#: ../../library/ssl.rst:147
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr "如果你的应用需要特定的设置，你应当创建一个 :class:`SSLContext` 并自行应用设置。"

#: ../../library/ssl.rst:151
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr ""
"如果你发现当某些较旧的客户端或服务器尝试与用此函数创建的 :class:`SSLContext` 进行连接时收到了报错提示 \"Protocol or "
"cipher suite mismatch\"，这可能是因为它们只支持 SSL3.0 而它被此函数用 :data:`OP_NO_SSLv3` 排除掉了。"
" SSL3.0 被广泛认为 `完全不可用 <https://en.wikipedia.org/wiki/POODLE>`_。 "
"如果你仍希望继续使用此函数但仍允许 SSL 3.0 连接，你可以使用以下代码重新启用它们::"

#: ../../library/ssl.rst:167
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 被从默认密码字符串中丢弃。"

#: ../../library/ssl.rst:171
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 被添加到默认密码字符串中。"

#: ../../library/ssl.rst:173
msgid "3DES was dropped from the default cipher string."
msgstr "3DES 被从默认密码字符串中丢弃。"

#: ../../library/ssl.rst:177
msgid "Exceptions"
msgstr "异常"

#: ../../library/ssl.rst:181
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"引发此异常以提示来自下层 SSL 实现（目前由 OpenSSL 库提供）的错误。 它表示在下层网络连接之上叠加的高层级加密和验证层存在某种问题。 "
"此错误是 :exc:`OSError` 的一个子类型。 :exc:`SSLError` 实例的错误和消息是由 OpenSSL 库提供的。"

#: ../../library/ssl.rst:188
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` 曾经是 :exc:`socket.error` 的一个子类型。"

#: ../../library/ssl.rst:193
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"一个字符串形式的助词符，用来指明发生错误的 OpenSSL 子模块，例如 ``SSL``, ``PEM`` 或 ``X509``。 可能的取值范围依赖于"
" OpenSSL 的版本。"

#: ../../library/ssl.rst:201
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"一个字符串形式的助记符，用来指明发生错误的原因，例如 ``CERTIFICATE_VERIFY_FAILED``。 可能的取值范围依赖于 OpenSSL"
" 的版本。"

#: ../../library/ssl.rst:209
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
":exc:`SSLError` 的一个子类，当尝试读取或写入且 SSL 连接已被完全关闭时会被引发。 请注意这并不意味着下层的传输（读取 "
"TCP）已被关闭。"

#: ../../library/ssl.rst:217
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
":exc:`SSLError` 的一个子类，当尝试读取或写入但，并在请求被满足之前还需要在下层的 TCP 传输上接收更多数据时会被 :ref:`非阻塞型"
" SSL 套接字 <ssl-nonblocking>` 引发。"

#: ../../library/ssl.rst:226
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
":exc:`SSLError` 的一个子类，当尝试读取或写入数据，但在请求被满足之前还需要在下层的 TCP 传输上发送更多数据时会被 "
":ref:`非阻塞型 SSL 套接字 <ssl-nonblocking>` 引发。"

#: ../../library/ssl.rst:235
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
":exc:`SSLError` 的子类，当尝试在 SSL 套接字上执行操作时遇到系统错误时会被引发。 不幸的是，没有简单的方式能检查原始 errno "
"编号。"

#: ../../library/ssl.rst:243
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ":exc:`SSLError` 的子类，当 SSL 连接被突然终止时会被引发。 通常，当遇到此错误时你不应再尝试重用下层的传输。"

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ":exc:`SSLError` 的子类，当证书验证失败时会被引发。"

#: ../../library/ssl.rst:258
msgid "A numeric error number that denotes the verification error."
msgstr "一个数字形式的错误编号，用于表示验证错误。"

#: ../../library/ssl.rst:262
msgid "A human readable string of the verification error."
msgstr "用于表示验证错误的人类可读的字符串。"

#: ../../library/ssl.rst:266
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ":exc:`SSLCertVerificationError` 的别名。"

#: ../../library/ssl.rst:268
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "此异常现在是 :exc:`SSLCertVerificationError` 的别名。"

#: ../../library/ssl.rst:273
msgid "Random generation"
msgstr "随机生成"

#: ../../library/ssl.rst:277
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an "
":class:`SSLError` if the PRNG has not been seeded with enough data or if the"
" operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used"
" to seed the PRNG."
msgstr ""
"返回 *num* 个高加密强度伪随机字节数据。 如果 PRNG 未使用足够的数据作为随机种子或者如果当前 RAND 方法不支持该操作则会引发 "
":class:`SSLError`。 :func:`RAND_status` 可被用来检查 PRNG 的状态而 :func:`RAND_add` "
"可被用来为 PRNG 设置随机种子。"

#: ../../library/ssl.rst:283 ../../library/ssl.rst:304
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "对于几乎所有应用程序都更推荐使用 :func:`os.urandom`。"

#: ../../library/ssl.rst:285
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_,"
" to get the requirements of a cryptographically generator."
msgstr ""

#: ../../library/ssl.rst:294
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the"
" current RAND method."
msgstr ""
"返回 (bytes, is_cryptographic): bytes 是 *num* 个伪随机字节数据，如果所生成的字节数据为高加密强度则 "
"is_cryptographic 为 ``True``。 如果当前 RAND 方法不支持此操作则会引发 :class:`SSLError`。"

#: ../../library/ssl.rst:299
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"所生成的伪随机字节序列如果具有足够的长度则将会具有唯一性，并是并非不可预测。 "
"它们可被用于非加密目的以及加密协议中的特定目的，但通常不可被用于密钥生成等目的。"

#: ../../library/ssl.rst:310
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use "
":func:`ssl.RAND_bytes` instead."
msgstr ""
"OpenSSL 已弃用了 :func:`ssl.RAND_pseudo_bytes`，请改用 :func:`ssl.RAND_bytes`。"

#: ../../library/ssl.rst:315
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr ""
"如果 SSL 伪随机数生成器已使用‘足够的’随机性作为种子则返回  ``True``，否则返回 ``False``。 你可以使用 "
":func:`ssl.RAND_egd` 和 :func:`ssl.RAND_add` 来增加伪随机数生成器的随机性。"

#: ../../library/ssl.rst:322
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""
"如果你在某处运行了一个熵收集守护程序（EGD），且 *path* 是向其打开的套接字连接路径名，此函数将从该套接字读取 256 "
"个字节的随机性数据，并将其添加到 SSL 伪随机数生成器以增加所生成密钥的安全性。 此操作通常只在没有更好随机性源的系统上才是必要的。"

#: ../../library/ssl.rst:328
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources"
" of entropy-gathering daemons."
msgstr ""
"请查看 http://egd.sourceforge.net/ 或 http://prngd.sourceforge.net/ "
"来了解有关熵收集守护程序源的信息。"

#: ../../library/ssl.rst:331
msgid ""
":ref:`Availability <availability>`: not available with LibreSSL and OpenSSL "
"> 1.1.0."
msgstr ":ref:`可用性 <availability>`: 对于 LibreSSL 和 OpenSSL > 1.1.0 不可用。"

#: ../../library/ssl.rst:335
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"将给定的 *bytes* 混合到 SSL 伪随机数生成器中。 形参 *entropy* (float 类型) 是数据所包含的熵的下界 "
"(因此你可以总是使用 :const:`0.0`)。 请查看 :rfc:`1750` 了解有关熵源的更多信息。"

#: ../../library/ssl.rst:340
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "现在支持可写的 :term:`字节类对象 <bytes-like object>`。"

#: ../../library/ssl.rst:344
msgid "Certificate handling"
msgstr "证书处理"

#: ../../library/ssl.rst:352
msgid ""
"Verify that *cert* (in decoded format as returned by "
":meth:`SSLSocket.getpeercert`) matches the given *hostname*.  The rules "
"applied are those for checking the identity of HTTPS servers as outlined in "
":rfc:`2818`, :rfc:`5280` and :rfc:`6125`.  In addition to HTTPS, this "
"function should be suitable for checking the identity of servers in various "
"SSL-based protocols such as FTPS, IMAPS, POPS and others."
msgstr ""
"验证 *cert* (使用 :meth:`SSLSocket.getpeercert` 所返回的已解码格式) 是否匹配给定的 *hostname*。 "
"所应用的规则是在 :rfc:`2818`, :rfc:`5280` 和 :rfc:`6125` 中描述的检查 HTTPS 服务器身份的规则。 除了 "
"HTTPS，此函数还应当适用于各种基于 SSL 协议的服务器身份检查操作，例如 FTPS, IMAPS, POPS 等等。"

#: ../../library/ssl.rst:359
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr "失败时引发 :exc:`CertificateError`。 成功时此函数无返回值::"

#: ../../library/ssl.rst:372
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"此函数现在遵循 :rfc:`6125`, 6.4.3 小节，它不会匹配多个通配符 (例如 ``*.*.com`` 或 "
"``*a*.example.org``) 也不匹配国际化域名 (IDN) 片段内部的通配符。 IDN A 标签例如 ``www*.xn--pthon-"
"kva.org`` 仍然受支持，但 ``x*.python.org`` 不再能匹配 ``xn--tda.python.org``。"

#: ../../library/ssl.rst:379
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr "现在支持匹配存在于证书的 subjectAltName 字段中的 IP 地址。"

#: ../../library/ssl.rst:383
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr "此函数不再被用于 TLS 连接。 主机匹配现在是由 OpenSSL 执行的。"

#: ../../library/ssl.rst:387
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer "
"supported."
msgstr "允许位于段的最左端且为唯一字符的通配符。 部分通配符例如 ``www*.example.com`` 已不再受支持。"

#: ../../library/ssl.rst:395
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"返回距离 Unix 纪元零时的秒数，给定的 ``cert_time`` 字符串代表来自证书的 \"notBefore\" 或 \"notAfter\" "
"日期值，采用 ``\"%b %d %H:%M:%S %Y %Z\"`` strptime 格式（C 区域）。"

#: ../../library/ssl.rst:400
msgid "Here's an example:"
msgstr "以下为示例代码:"

#: ../../library/ssl.rst:412
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" 或 \"notAfter\" 日期值必须使用 GMT (:rfc:`5280`)。"

#: ../../library/ssl.rst:414
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"将输入时间解读为 UTC 时间，基于输入字符串中指明的 'GMT' 时区。 在之前使用的是本地时区。 返回一个整数（不带输入格式中秒的分数部分）"

#: ../../library/ssl.rst:422
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in "
":meth:`SSLContext.wrap_socket`.  The call will attempt to validate the "
"server certificate against that set of root certificates, and will fail if "
"the validation attempt fails."
msgstr ""
"带 SSL 保护的服务器的地址 ``addr`` 以 (*hostname*, *port-number*) 对的形式给出，获取服务器的证书，并将其以 "
"PEM 编码字符串的形式返回。 如果指定了 ``ssl_version``，则使用该版本的 SSL 协议尝试连接服务器。 如果指定了 "
"``ca_certs``，它应当是一个包含根证书列表的文件，使用与 :meth:`SSLContext.wrap_socket` 中同名形参一致的格式。"
" 该调用将尝试根据指定的根证书集来验证服务器证书，如果验证失败则该调用也将失败。"

#: ../../library/ssl.rst:432
msgid "This function is now IPv6-compatible."
msgstr "此函数现在是 IPv6 兼容的。-compatible."

#: ../../library/ssl.rst:435
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to "
":data:`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"默认的 *ssl_version* 从 :data:`PROTOCOL_SSLv3` 改为 :data:`PROTOCOL_TLS` "
"以保证与现代服务器的最大兼容性。"

#: ../../library/ssl.rst:441
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "根据给定的 DER 编码字节块形式的证书，返回同一证书的 PEM 编码字符串版本。"

#: ../../library/ssl.rst:446
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "根据给定的 ASCII PEM 字符串形式的证书，返回同一证书的 DER 编码字节序列。"

#: ../../library/ssl.rst:451
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"返回包含 OpenSSL 的默认 cafile 和 capath 的路径的命名元组。 此路径与 "
":meth:`SSLContext.set_default_verify_paths` 所使用的相同。 返回值是一个 :term:`named "
"tuple` ``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:456
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - 解析出的 cafile 路径或者如果文件不存在则为 ``None``,"

#: ../../library/ssl.rst:457
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - 解析出的 capath 路径或者如果目录不存在则为 ``None``,"

#: ../../library/ssl.rst:458
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - 指向一个 cafile 的 OpenSSL 环境键,"

#: ../../library/ssl.rst:459
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - 一个 cafile 的硬编码路径,"

#: ../../library/ssl.rst:460
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - 指向一个 capath 的 OpenSSL 环境键,"

#: ../../library/ssl.rst:461
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - 一个 capath 目录的硬编码路径"

#: ../../library/ssl.rst:465
msgid ""
":ref:`Availability <availability>`: LibreSSL ignores the environment vars "
":attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
msgstr ""
":ref:`可用性 <availability>`: LibreSSL 会忽略环境变量 :attr:`openssl_cafile_env` 和 "
":attr:`openssl_capath_env`。"

#: ../../library/ssl.rst:470
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"从 Windows 的系统证书库中检索证书。 *store_name* 可以是 ``CA``, ``ROOT`` 或 ``MY`` 中的一个。 "
"Windows 也可能会提供额外的证书库。"

#: ../../library/ssl.rst:474
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 "
"cert_bytes 的编码格式。 它可以为 :const:`x509_asn` 以表示 X.509 ASN.1 数据或是 "
":const:`pkcs_7_asn` 以表示 PKCS#7 ASN.1 数据。 trust 以 OIDS "
"集合的形式指明证书的目的，或者如果证书对于所有目的都可以信任则为 ``True``。"

#: ../../library/ssl.rst:481 ../../library/ssl.rst:1568
#: ../../library/ssl.rst:1883
msgid "Example::"
msgstr "示例::"

#: ../../library/ssl.rst:488 ../../library/ssl.rst:503
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`可用性 <availability>`: Windows。"

#: ../../library/ssl.rst:493
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Windows 的系统证书库中检索 CRL。 *store_name* 可以是 ``CA``, ``ROOT`` 或 ``MY`` 中的一个。 "
"Windows 也可能会提供额外的证书库。"

#: ../../library/ssl.rst:497
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr ""
"此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 "
"cert_bytes 的编码格式。 它可以为 :const:`x509_asn` 以表示 X.509 ASN.1 数据或是 "
":const:`pkcs_7_asn` 以表示 PKCS#7 ASN.1 数据。"

#: ../../library/ssl.rst:511
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a "
":data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"接受一个 :class:`socket.socket` 的实例 ``sock``，并返回一个 :class:`ssl.SSLSocket` "
"的实例，该类型是 :class:`socket.socket` 的子类型，它将下层的套接字包装在一个 SSL 上下文中。 ``sock`` 必须是一个 "
":data:`~socket.SOCK_STREAM` 套接字；其他套接字类型不被支持。"

#: ../../library/ssl.rst:516
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, "
":meth:`SSLContext.load_verify_locations`, and "
":meth:`SSLContext.set_ciphers`."
msgstr ""
"在内部，该函数会创建一个 :class:`SSLContext`，其协议版本为 *ssl_version* 且 "
":attr:`SSLContext.options` 设为 *cert_reqs*。 如果设置了 *keyfile*, *certfile*, "
"*ca_certs* 或 *ciphers* 等形参，则参数值会被传给 :meth:`SSLContext.load_cert_chain`, "
":meth:`SSLContext.load_verify_locations` 以及 :meth:`SSLContext.set_ciphers`。"

#: ../../library/ssl.rst:523
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as "
":meth:`SSLContext.wrap_socket`."
msgstr ""
"参数 *server_side*, *do_handshake_on_connect* 和 *suppress_ragged_eofs* 具有与 "
":meth:`SSLContext.wrap_socket` 相同的含义。"

#: ../../library/ssl.rst:529
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the "
":meth:`SSLContext.wrap_socket` instead of :func:`wrap_socket`. The top-level"
" function is limited and creates an insecure client socket without server "
"name indication or hostname matching."
msgstr ""
"从 Python 3.2 和 2.7.9 开始，建议使用 :meth:`SSLContext.wrap_socket` 来代替 "
":func:`wrap_socket`。 模块级函数的功能受限并且将创建不安全的客户端套接字，不带服务器名称提示或主机名匹配。"

#: ../../library/ssl.rst:535
msgid "Constants"
msgstr "常量"

#: ../../library/ssl.rst:537
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr "所有常量现在都是 :class:`enum.IntEnum` 或 :class:`enum.IntFlag` 多项集的成员。"

#: ../../library/ssl.rst:543
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored"
" and do not abort the TLS/SSL handshake."
msgstr ""
":attr:`SSLContext.verify_mode` 或 :func:`wrap_socket` 的 ``cert_reqs`` "
"形参可能的取值。 :const:`PROTOCOL_TLS_CLIENT` 除外，这是默认的模式。 对于客户端套接字，几乎任何证书都是可接受的。 "
"验证错误例如不受信任或过期的证书错误会被忽略并且不会中止 TLS/SSL 握手。"

#: ../../library/ssl.rst:549
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr "在服务器模式下，不会从客户端请求任何证书，因此客户端不会发送任何用于客户端证书身份验证的证书。"

#: ../../library/ssl.rst:552 ../../library/ssl.rst:2281
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "参见下文对于 :ref:`ssl-security` 的讨论。"

#: ../../library/ssl.rst:556
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use "
":const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
":attr:`SSLContext.verify_mode` 或 :func:`wrap_socket` 的 ``cert_reqs`` "
"形参可能的取值。 :const:`CERT_OPTIONAL` 具有与 :const:`CERT_REQUIRED` 相同的含义。 "
"对于客户端套接字推荐改用 :const:`CERT_REQUIRED`。"

#: ../../library/ssl.rst:561
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"在服务器模式下，客户端证书请求会被发送给客户端。 客户端可以忽略请求也可以发送一个证书以执行 TLS 客户端证书身份验证。 "
"如果客户端选择发送证书，则将对其执行验证。 任何验证错误都将立即中止 TLS 握手。"

#: ../../library/ssl.rst:567 ../../library/ssl.rst:587
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"使用此设置要求将一组有效的 CA 证书传递给 :meth:`SSLContext.load_verify_locations` 或是作为 "
":func:`wrap_socket` 的 ``ca_certs`` 形参值。"

#: ../../library/ssl.rst:573
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well"
" to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses "
":const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
":attr:`SSLContext.verify_mode` 或 :func:`wrap_socket` 的 ``cert_reqs`` "
"形参可能的取值。 在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 :class:`SSLError`。 此模式 "
"**不能** 在客户端模式下对证书进行验证，因为它不会匹配主机名。 :attr:`~SSLContext.check_hostname` "
"也必须被启用以验证证书的真实性。 :const:`PROTOCOL_TLS_CLIENT` 会使用 :const:`CERT_REQUIRED` "
"并默认启用 :attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:583
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr "对于服务器套接字，此模式会提供强制性的 TLS 客户端证书验证。 客户端证书请求会被发送给客户端并且客户端必须提供有效且受信任的证书。"

#: ../../library/ssl.rst:593
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "CERT_* 常量的 :class:`enum.IntEnum` 多项集。"

#: ../../library/ssl.rst:599
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags` 可能的取值。 在此模式下，证书吊销列表（CRL）并不会被检查。 OpenSSL "
"默认不要求也不验证 CRL。"

#: ../../library/ssl.rst:607
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has has been loaded with "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ""

#: ../../library/ssl.rst:617
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ":attr:`SSLContext.verify_flags` 可能的取值。 在此模式下，会检查对等证书链中所有证书的 CRL。"

#: ../../library/ssl.rst:624
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ":attr:`SSLContext.verify_flags` 可能的取值，用于禁用已损坏 X.509 证书的绕过操作。"

#: ../../library/ssl.rst:631
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags` 可能的取值。 它指示 OpenSSL 在构建用于验证某个证书的信任链时首选受信任的证书。"
" 此旗标将默认被启用。"

#: ../../library/ssl.rst:639
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "VERIFY_* 常量的 :class:`enum.IntFlag` 多项集。"

#: ../../library/ssl.rst:645
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr "选择客户端和服务器均支持的最高协议版本。 此选项名称并不准确，实际上 \"SSL\" 和 \"TLS\" 协议均可被选择。"

#: ../../library/ssl.rst:652
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support client-side :class:`SSLSocket` connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"像 :data:`PROTOCOL_TLS` 一样地自动协商最高协议版本，但是只支持客户端 :class:`SSLSocket` 连接。 "
"此协议默认会启用 :data:`CERT_REQUIRED` 和 :attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:661
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support server-side :class:`SSLSocket` connections."
msgstr "像 :data:`PROTOCOL_TLS` 一样地自动协商最高协议版本，但是只支持服务器 :class:`SSLSocket` 连接。"

#: ../../library/ssl.rst:668
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr ":data:`PROTOCOL_TLS` 的别名。"

#: ../../library/ssl.rst:672
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "请改用 :data:`PROTOCOL_TLS`。"

#: ../../library/ssl.rst:676
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "选择 SSL 版本 2 作为通道加密协议。"

#: ../../library/ssl.rst:678
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr "如果 OpenSSL 编译时附带了 ``OPENSSL_NO_SSL2`` 旗标则此协议将不可用。"

#: ../../library/ssl.rst:683
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL 版本 2 并不安全。 极不建议使用它。"

#: ../../library/ssl.rst:687
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL 已经移除了对 SSLv2 的支持。"

#: ../../library/ssl.rst:691
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "选择 SSL 版本 3 作为通道加密协议。"

#: ../../library/ssl.rst:693
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr "如果 OpenSSL 编译时使用了 ``OPENSSL_NO_SSLv3`` 旗标则此协议将不可用。"

#: ../../library/ssl.rst:698
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL 版本 3 并不安全。 极不建议使用它。"

#: ../../library/ssl.rst:702 ../../library/ssl.rst:711
#: ../../library/ssl.rst:723 ../../library/ssl.rst:736
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS` with flags like :data:`OP_NO_SSLv3` instead."
msgstr ""
"OpenSSL 已经弃用了所有带有特定版本号的协议。 请改用默认协议 :data:`PROTOCOL_TLS` 并附带 "
":data:`OP_NO_SSLv3` 等旗标。"

#: ../../library/ssl.rst:707
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "选择 TLS 版本 1.0 作为通道加密协议。"

#: ../../library/ssl.rst:716
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "选择 TLS 版本 1.1 作为通道加密协议。 仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:728
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most"
" modern version, and probably the best choice for maximum protection, if "
"both sides can speak it.  Available only with openssl version 1.0.1+."
msgstr ""
"选译 TLS 版本 1.2 作为通道加密协议。 这是最新的版本，也应是能提供最大保护的最佳选择，如果通信双方都支持它的话。 仅适用于 openssl "
"版本 1.0.1+。"

#: ../../library/ssl.rst:741
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"对存在于其他 SSL 实现中的各种缺陷启用绕过操作。 默认会设置此选项。 没有必要设置与 OpenSSL 的 ``SSL_OP_ALL`` "
"常量同名的旗标。"

#: ../../library/ssl.rst:749
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"阻止 SSLv2 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 SSLv2 作为协议版本。"

#: ../../library/ssl.rst:757
msgid "SSLv2 is deprecated"
msgstr "SSLv2 已被弃用。"

#: ../../library/ssl.rst:762
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"阻止 SSLv3 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 SSLv3 作为协议版本。"

#: ../../library/ssl.rst:770
msgid "SSLv3 is deprecated"
msgstr "SSLv3 已被弃用"

#: ../../library/ssl.rst:774
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"阻止 TLSv1 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1 作为协议版本。"

#: ../../library/ssl.rst:780
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"此选项自 OpenSSL 1.1.0 起已被弃用，请改用新的 :attr:`SSLContext.minimum_version` 和 "
":attr:`SSLContext.maximum_version`。"

#: ../../library/ssl.rst:787
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.1 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.1 作为协议版本。 "
"仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:793 ../../library/ssl.rst:804
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "此选项自 OpenSSL 1.1.0 起已被弃用。"

#: ../../library/ssl.rst:798
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.2 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.2 作为协议版本。 "
"仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:809
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"阻止 TLSv1.3 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.3 作为协议版本。 "
"TLS 1.3 适用于 OpenSSL 1.1.1 或更新的版本。 当 Python 编译是基于较旧版本的 OpenSSL 时，该旗标默认为 *0*。"

#: ../../library/ssl.rst:817
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"此选项自 OpenSSL 1.1.0 起已被弃用。 它被添加到 2.7.15, 3.6.3 和 3.7.0 是为了向下兼容 OpenSSL 1.0.2。"

#: ../../library/ssl.rst:823
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"禁用所有 TLSv1.2 和更早版本的重协商操作。 不发送 HelloRequest 消息，并忽略通过 ClientHello 发起的重协商请求。"

#: ../../library/ssl.rst:826
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "此选项仅适用于 OpenSSL 1.1.0h 及更新的版本。"

#: ../../library/ssl.rst:832
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr "使用服务器的密码顺序首选项，而不是客户端的首选项。 此选项在客户端套接字和 SSLv2 服务器套接字上无效。"

#: ../../library/ssl.rst:839
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves"
" forward secrecy but requires more computational resources. This option only"
" applies to server sockets."
msgstr "阻止对于单独的 SSL 会话重用相同的 DH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。"

#: ../../library/ssl.rst:847
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr "阻止对于单独的 SSL 会话重用相同的 ECDH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。"

#: ../../library/ssl.rst:855
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr "在 TLS 1.3 握手中发送虚拟更改密码规格（CCS）消息以使得 TLS 1.3 连接看起来更像是 TLS 1.2 连接。"

#: ../../library/ssl.rst:858
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "此选项仅适用于 OpenSSL 1.1.1 及更新的版本。"

#: ../../library/ssl.rst:864
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""

#: ../../library/ssl.rst:867
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr ""

#: ../../library/ssl.rst:873
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ""

#: ../../library/ssl.rst:877
msgid "Prevent client side from requesting a session ticket."
msgstr ""

#: ../../library/ssl.rst:883
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""

#: ../../library/ssl.rst:890
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common"
" name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""

#: ../../library/ssl.rst:898
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""

#: ../../library/ssl.rst:906
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""

#: ../../library/ssl.rst:913
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""

#: ../../library/ssl.rst:923
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""

#: ../../library/ssl.rst:929
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""

#: ../../library/ssl.rst:935
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""

#: ../../library/ssl.rst:941
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""

#: ../../library/ssl.rst:947
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""

#: ../../library/ssl.rst:953
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""

#: ../../library/ssl.rst:959
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""

#: ../../library/ssl.rst:966
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""

#: ../../library/ssl.rst:975
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""

#: ../../library/ssl.rst:985
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""

#: ../../library/ssl.rst:998
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""

#: ../../library/ssl.rst:1002
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ""

#: ../../library/ssl.rst:1009
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ""

#: ../../library/ssl.rst:1015
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ""

#: ../../library/ssl.rst:1024
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate Web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ""

#: ../../library/ssl.rst:1033
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ""

#: ../../library/ssl.rst:1039
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for "
":attr:`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""

#: ../../library/ssl.rst:1047
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available "
"TLS/SSL versions."
msgstr ""

#: ../../library/ssl.rst:1057
msgid "SSL 3.0 to TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1060
msgid "SSL Sockets"
msgstr ""

#: ../../library/ssl.rst:1064
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr ""

#: ../../library/ssl.rst:1066
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1067
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1068
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1069
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1070
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1071
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1072
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1073
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1074
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, "
":meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1076
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1077
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1078
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"

#: ../../library/ssl.rst:1080
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"

#: ../../library/ssl.rst:1082
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"

#: ../../library/ssl.rst:1084
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1086
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""

#: ../../library/ssl.rst:1091
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method."
msgstr ""

#: ../../library/ssl.rst:1094
msgid "The :meth:`sendfile` method was added."
msgstr ""

#: ../../library/ssl.rst:1097
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the"
" shutdown."
msgstr ""

#: ../../library/ssl.rst:1102
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use "
":meth:`SSLContext.wrap_socket` to wrap a socket."
msgstr ""

#: ../../library/ssl.rst:1106
msgid ""
":class:`SSLSocket` instances must to created with "
":meth:`~SSLContext.wrap_socket`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""

#: ../../library/ssl.rst:1112
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr ""

#: ../../library/ssl.rst:1116
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""

#: ../../library/ssl.rst:1120
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""

#: ../../library/ssl.rst:1123
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also"
" cause write operations."
msgstr ""

#: ../../library/ssl.rst:1126
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""

#: ../../library/ssl.rst:1131
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ""

#: ../../library/ssl.rst:1136
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""

#: ../../library/ssl.rst:1139
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""

#: ../../library/ssl.rst:1142
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""

#: ../../library/ssl.rst:1145
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""

#: ../../library/ssl.rst:1149
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ""

#: ../../library/ssl.rst:1154
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the "
"low-level methods that read and write unencrypted, application-level data "
"and decrypt/encrypt it to encrypted, wire-level data. These methods require "
"an active SSL connection, i.e. the handshake was completed and "
":meth:`SSLSocket.unwrap` was not called."
msgstr ""

#: ../../library/ssl.rst:1160
msgid ""
"Normally you should use the socket API methods like "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` instead of these"
" methods."
msgstr ""

#: ../../library/ssl.rst:1166
msgid "Perform the SSL setup handshake."
msgstr ""

#: ../../library/ssl.rst:1168
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr ""

#: ../../library/ssl.rst:1173
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""

#: ../../library/ssl.rst:1177
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function "
":func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname"
" or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""

#: ../../library/ssl.rst:1185
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1189
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""

#: ../../library/ssl.rst:1198
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""

#: ../../library/ssl.rst:1224
msgid ""
"To validate a certificate for a particular service, you can use the "
":func:`match_hostname` function."
msgstr ""

#: ../../library/ssl.rst:1227
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""

#: ../../library/ssl.rst:1233
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""

#: ../../library/ssl.rst:1236
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr ""

#: ../../library/ssl.rst:1241
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""

#: ../../library/ssl.rst:1245
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""

#: ../../library/ssl.rst:1250
msgid "IPv6 address strings no longer have a trailing new line."
msgstr ""

#: ../../library/ssl.rst:1255
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""

#: ../../library/ssl.rst:1261
msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the"
" cipher, the version of the SSL protocol that defines its use, and the "
"number of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` "
"returns ``None`` if no connection has been established or the socket is a "
"client socket."
msgstr ""

#: ../../library/ssl.rst:1272
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""

#: ../../library/ssl.rst:1275
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""

#: ../../library/ssl.rst:1282
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr ""

#: ../../library/ssl.rst:1285
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr ""

#: ../../library/ssl.rst:1295
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr ""

#: ../../library/ssl.rst:1305
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr ""

#: ../../library/ssl.rst:1314
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""

#: ../../library/ssl.rst:1322
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see "
":attr:`SSLContext.post_handshake_auth`."
msgstr ""

#: ../../library/ssl.rst:1327
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""

#: ../../library/ssl.rst:1331
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an "
":exc:`SSLError` is raised."
msgstr ""

#: ../../library/ssl.rst:1335
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""

#: ../../library/ssl.rst:1342
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` is no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""

#: ../../library/ssl.rst:1352
msgid ""
"Returns the number of already decrypted bytes available for read, pending on"
" the connection."
msgstr ""

#: ../../library/ssl.rst:1357
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather"
" than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""

#: ../../library/ssl.rst:1366
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for "
"client-side sockets."
msgstr ""

#: ../../library/ssl.rst:1373
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""

#: ../../library/ssl.rst:1378
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form "
"(``\"pythön.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1386
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before "
":meth:`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""

#: ../../library/ssl.rst:1399
msgid "SSL Contexts"
msgstr ""

#: ../../library/ssl.rst:1403
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""

#: ../../library/ssl.rst:1410
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other versions."
"  If not specified, the default is :data:`PROTOCOL_TLS`; it provides the "
"most compatibility with other versions."
msgstr ""

#: ../../library/ssl.rst:1419
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""

#: ../../library/ssl.rst:1425
msgid "*client* / **server**"
msgstr "*client* / **server**"

#: ../../library/ssl.rst:1425
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1425
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1425
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1425
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1425
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1425
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1427
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1429 ../../library/ssl.rst:1429
#: ../../library/ssl.rst:1429 ../../library/ssl.rst:1429
#: ../../library/ssl.rst:1430 ../../library/ssl.rst:1430
#: ../../library/ssl.rst:1431 ../../library/ssl.rst:1431
#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1432
msgid "yes"
msgstr "是"

#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1427
#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1427
#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1428
#: ../../library/ssl.rst:1430 ../../library/ssl.rst:1430
#: ../../library/ssl.rst:1430 ../../library/ssl.rst:1430
#: ../../library/ssl.rst:1431 ../../library/ssl.rst:1431
#: ../../library/ssl.rst:1431 ../../library/ssl.rst:1431
#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1432
#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1432
msgid "no"
msgstr "否"

#: ../../library/ssl.rst:1427 ../../library/ssl.rst:1429
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1428
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1428 ../../library/ssl.rst:1429
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1429
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1430
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1431
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1432
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1435
msgid "Footnotes"
msgstr "备注"

#: ../../library/ssl.rst:1436
msgid ""
":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""

#: ../../library/ssl.rst:1437
msgid ""
":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""

#: ../../library/ssl.rst:1438
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1443
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""

#: ../../library/ssl.rst:1448
msgid ""
"The context is created with secure default values. The options "
":data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, "
":data:`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` "
"(except for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for "
":data:`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list "
"contains only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers "
"(except for :data:`PROTOCOL_SSLv2`)."
msgstr ""

#: ../../library/ssl.rst:1458
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ""

#: ../../library/ssl.rst:1462
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr ""

#: ../../library/ssl.rst:1466
msgid "Example for a context with one CA cert and one other cert::"
msgstr ""

#: ../../library/ssl.rst:1476
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr ""

#: ../../library/ssl.rst:1485
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""

#: ../../library/ssl.rst:1494
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""

#: ../../library/ssl.rst:1498
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""

#: ../../library/ssl.rst:1501
msgid "New optional argument *password*."
msgstr ""

#: ../../library/ssl.rst:1506
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On other systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr ""

#: ../../library/ssl.rst:1512
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :data:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr ""

#: ../../library/ssl.rst:1522
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""

#: ../../library/ssl.rst:1526
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""

#: ../../library/ssl.rst:1530
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""

#: ../../library/ssl.rst:1535
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../library/ssl.rst:1540
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates"
" are ignored but at least one certificate must be present."
msgstr ""

#: ../../library/ssl.rst:1545
msgid "New optional argument *cadata*"
msgstr ""

#: ../../library/ssl.rst:1550
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""

#: ../../library/ssl.rst:1558
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""

#: ../../library/ssl.rst:1565
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See "
":meth:`SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:1588
msgid "On OpenSSL 1.1 and newer the cipher dict contains additional fields::"
msgstr ""

#: ../../library/ssl.rst:1617
msgid ":ref:`Availability <availability>`: OpenSSL 1.0.2+."
msgstr ""

#: ../../library/ssl.rst:1622
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""

#: ../../library/ssl.rst:1631
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_. If no cipher "
"can be selected (because compile-time options or other configuration forbids"
" use of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1639
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr ""

#: ../../library/ssl.rst:1642
msgid ""
"OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites "
"cannot be disabled with :meth:`~SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:1647
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""

#: ../../library/ssl.rst:1654
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""

#: ../../library/ssl.rst:1657
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves"
" like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../../library/ssl.rst:1665
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the "
":meth:`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""

#: ../../library/ssl.rst:1673
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""

#: ../../library/ssl.rst:1680
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""

#: ../../library/ssl.rst:1685
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""

#: ../../library/ssl.rst:1689
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if"
" the TLS Client Hello does not contain a server name) and the third argument"
" is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn"
"--pythn-mua.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1697
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr ""

#: ../../library/ssl.rst:1702
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher` and :meth:`SSLSocket.compress` methods require that"
" the TLS connection has progressed beyond the TLS Client Hello and therefore"
" will not contain return meaningful values nor can they be called safely."
msgstr ""

#: ../../library/ssl.rst:1710
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""

#: ../../library/ssl.rst:1716
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""

#: ../../library/ssl.rst:1720
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""

#: ../../library/ssl.rst:1727
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1733
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../../library/ssl.rst:1741
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""

#: ../../library/ssl.rst:1747
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""

#: ../../library/ssl.rst:1754
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""

#: ../../library/ssl.rst:1760
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""

#: ../../library/ssl.rst:1763
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr ""

#: ../../library/ssl.rst:1768
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011"
"-ssl-perfect-forward-secrecy>`_"
msgstr ""

#: ../../library/ssl.rst:1769
msgid "Vincent Bernat."
msgstr ""

#: ../../library/ssl.rst:1775
msgid ""
"Wrap an existing Python socket *sock* and return an instance of "
":attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The "
"returned SSL socket is tied to the context, its settings and certificates. "
"*sock* must be a :data:`~socket.SOCK_STREAM` socket; other socket types are "
"unsupported."
msgstr ""

#: ../../library/ssl.rst:1781
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""

#: ../../library/ssl.rst:1784
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise "
":exc:`SSLError`."
msgstr ""

#: ../../library/ssl.rst:1792
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""

#: ../../library/ssl.rst:1798
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr ""

#: ../../library/ssl.rst:1805
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.recv` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr ""

#: ../../library/ssl.rst:1812
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr ""

#: ../../library/ssl.rst:1814
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""

#: ../../library/ssl.rst:1818 ../../library/ssl.rst:1844
msgid "*session* argument was added."
msgstr ""

#: ../../library/ssl.rst:1821
msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead"
" of hard-coded :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1827
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to "
":class:`SSLSocket`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1836
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of "
":attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""

#: ../../library/ssl.rst:1841
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:1847
msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead"
" of hard-coded :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1853
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to "
":class:`SSLObject`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1861
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1872
msgid ""
"Whether to match the peer cert's hostname with :func:`match_hostname` in "
":meth:`SSLSocket.do_handshake`. The context's "
":attr:`~SSLContext.verify_mode` must be set to :data:`CERT_OPTIONAL` or "
":data:`CERT_REQUIRED`, and you must pass *server_hostname* to "
":meth:`~SSLContext.wrap_socket` in order to match the hostname.  Enabling "
"hostname checking automatically sets :attr:`~SSLContext.verify_mode` from "
":data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be set back to "
":data:`CERT_NONE` as long as hostname checking is enabled. The "
":data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""

#: ../../library/ssl.rst:1900
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to "
":data:`CERT_REQUIRED`  when hostname checking is enabled and "
":attr:`~SSLContext.verify_mode` is :data:`CERT_NONE`. Previously the same "
"operation would have failed with a :exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1907
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr ""

#: ../../library/ssl.rst:1911
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, "
":attr:`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:1916
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` and :attr:`SSLContext.options` all "
"affect the supported SSL and TLS versions of the context. The implementation"
" does not prevent invalid combination. For example a context with "
":attr:`OP_NO_TLSv1_2` in :attr:`~SSLContext.options` and "
":attr:`~SSLContext.maximum_version` set to :attr:`TLSVersion.TLSv1_2` will "
"not be able to establish a TLS 1.2 connection."
msgstr ""

#: ../../library/ssl.rst:1927 ../../library/ssl.rst:1939
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.0g or newer."
msgstr ""

#: ../../library/ssl.rst:1934
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""

#: ../../library/ssl.rst:1946
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr ""

#: ../../library/ssl.rst:1951
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the"
" corresponding bits) will raise a :exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1955
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ""

#: ../../library/ssl.rst:1963
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""

#: ../../library/ssl.rst:1968
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""

#: ../../library/ssl.rst:1971
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until "
":meth:`SSLSocket.verify_client_post_handshake` is called and some I/O is "
"performed."
msgstr ""

#: ../../library/ssl.rst:1978
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the property value is None and can't be modified"
msgstr ""

#: ../../library/ssl.rst:1985
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""

#: ../../library/ssl.rst:1990
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""

#: ../../library/ssl.rst:1995
msgid "Only writeable with OpenSSL 1.1.0 or higher."
msgstr ""

#: ../../library/ssl.rst:2001
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs). "
"Available only with openssl version 0.9.8+."
msgstr ""

#: ../../library/ssl.rst:2008
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""

#: ../../library/ssl.rst:2016
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""

#: ../../library/ssl.rst:2020
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ""

#: ../../library/ssl.rst:2033
msgid "Certificates"
msgstr ""

#: ../../library/ssl.rst:2035
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr ""

#: ../../library/ssl.rst:2043
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../library/ssl.rst:2053
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr ""

#: ../../library/ssl.rst:2063
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""

#: ../../library/ssl.rst:2072
msgid "Certificate chains"
msgstr ""

#: ../../library/ssl.rst:2074
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr ""

#: ../../library/ssl.rst:2098
msgid "CA certificates"
msgstr ""

#: ../../library/ssl.rst:2100
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr ""

#: ../../library/ssl.rst:2109
msgid "Combined key and certificate"
msgstr ""

#: ../../library/ssl.rst:2111
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""

#: ../../library/ssl.rst:2125
msgid "Self-signed certificates"
msgstr ""

#: ../../library/ssl.rst:2127
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""

#: ../../library/ssl.rst:2156
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""

#: ../../library/ssl.rst:2162
msgid "Examples"
msgstr "例子"

#: ../../library/ssl.rst:2165
msgid "Testing for SSL support"
msgstr ""

#: ../../library/ssl.rst:2167
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""

#: ../../library/ssl.rst:2178
msgid "Client-side operation"
msgstr ""

#: ../../library/ssl.rst:2180
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""

#: ../../library/ssl.rst:2185
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr ""

#: ../../library/ssl.rst:2192
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""

#: ../../library/ssl.rst:2196
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set"
" to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""

#: ../../library/ssl.rst:2201
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and "
":attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""

#: ../../library/ssl.rst:2211
msgid "You may then fetch the certificate::"
msgstr ""

#: ../../library/ssl.rst:2215
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""

#: ../../library/ssl.rst:2258
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""

#: ../../library/ssl.rst:2285
msgid "Server-side operation"
msgstr ""

#: ../../library/ssl.rst:2287
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""

#: ../../library/ssl.rst:2302
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr ""

#: ../../library/ssl.rst:2315
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""

#: ../../library/ssl.rst:2329
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""

#: ../../library/ssl.rst:2337
msgid "Notes on non-blocking sockets"
msgstr ""

#: ../../library/ssl.rst:2339
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""

#: ../../library/ssl.rst:2343
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and "
":exc:`SSLWantWriteError` for a write operation on the underlying socket. "
"Note that attempts to *write* to an SSL socket may require *reading* from "
"the underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""

#: ../../library/ssl.rst:2355
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero"
" instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""

#: ../../library/ssl.rst:2359
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ""

#: ../../library/ssl.rst:2366
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr ""

#: ../../library/ssl.rst:2372
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""

#: ../../library/ssl.rst:2375
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr ""

#: ../../library/ssl.rst:2391
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using the"
" :mod:`selectors` module and handles :exc:`SSLWantWriteError`, "
":exc:`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the "
"SSL handshake asynchronously as well."
msgstr ""

#: ../../library/ssl.rst:2400
msgid "Memory BIO Support"
msgstr ""

#: ../../library/ssl.rst:2404
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the "
":class:`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""

#: ../../library/ssl.rst:2407
msgid "SSL protocol handling"
msgstr ""

#: ../../library/ssl.rst:2408
msgid "Network IO"
msgstr ""

#: ../../library/ssl.rst:2410
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be"
" used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""

#: ../../library/ssl.rst:2415
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there"
" are some cases where it doesn't. An example is async IO frameworks that "
"want to use a different IO multiplexing model than the \"select/poll on a "
"file descriptor\" (readiness based) model that is assumed by "
":class:`socket.socket` and by the internal OpenSSL socket IO routines. This "
"is mostly relevant for platforms like Windows where this model is not "
"efficient. For this purpose, a reduced scope variant of :class:`SSLSocket` "
"called :class:`SSLObject` is provided."
msgstr ""

#: ../../library/ssl.rst:2426
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""

#: ../../library/ssl.rst:2431
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through"
" separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""

#: ../../library/ssl.rst:2436
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way "
"around."
msgstr ""

#: ../../library/ssl.rst:2443
msgid "The following methods are available:"
msgstr "可以使用以下方法："

#: ../../library/ssl.rst:2445
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2446
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2447
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2448
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2449
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2450
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2451
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2452
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2453
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2454
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2455
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2456
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2457
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2458
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2459
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2460
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2462
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""

#: ../../library/ssl.rst:2465
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the"
" underlying :class:`MemoryBIO` buffers."
msgstr ""

#: ../../library/ssl.rst:2468
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""

#: ../../library/ssl.rst:2471
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the "
":exc:`SSLEOFError` exception."
msgstr ""

#: ../../library/ssl.rst:2475
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""

#: ../../library/ssl.rst:2478
msgid ""
"The *server_name_callback* callback passed to "
":meth:`SSLContext.set_servername_callback` will get an :class:`SSLObject` "
"instance instead of a :class:`SSLSocket` instance as its first parameter."
msgstr ""

#: ../../library/ssl.rst:2482
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ""

#: ../../library/ssl.rst:2484
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an "
":exc:`SSLWantReadError` if it needs more data than the incoming BIO has "
"available."
msgstr ""

#: ../../library/ssl.rst:2489
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for "
":meth:`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via"
" an :class:`SSLContext`."
msgstr ""

#: ../../library/ssl.rst:2493
msgid ""
":class:`SSLObject` instances must to created with "
":meth:`~SSLContext.wrap_bio`. In earlier versions, it was possible to create"
" instances directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:2499
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""

#: ../../library/ssl.rst:2505
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""

#: ../../library/ssl.rst:2510
msgid "Return the number of bytes currently in the memory buffer."
msgstr ""

#: ../../library/ssl.rst:2514
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""

#: ../../library/ssl.rst:2519
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""

#: ../../library/ssl.rst:2524
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""

#: ../../library/ssl.rst:2527
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""

#: ../../library/ssl.rst:2532
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it"
" is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will"
" become true after all data currently in the buffer has been read."
msgstr ""

#: ../../library/ssl.rst:2538
msgid "SSL session"
msgstr ""

#: ../../library/ssl.rst:2544
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ""

#: ../../library/ssl.rst:2556
msgid "Security considerations"
msgstr ""

#: ../../library/ssl.rst:2559
msgid "Best defaults"
msgstr ""

#: ../../library/ssl.rst:2561
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""

#: ../../library/ssl.rst:2568
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""

#: ../../library/ssl.rst:2577
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr ""

#: ../../library/ssl.rst:2580
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr ""

#: ../../library/ssl.rst:2586
msgid "Manual settings"
msgstr ""

#: ../../library/ssl.rst:2589
msgid "Verifying certificates"
msgstr ""

#: ../../library/ssl.rst:2591
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname; "
"in this case, the :func:`match_hostname` function can be used.  This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""

#: ../../library/ssl.rst:2604
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses "
":func:`match_hostname`."
msgstr ""

#: ../../library/ssl.rst:2608
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""

#: ../../library/ssl.rst:2614
msgid "Protocol versions"
msgstr ""

#: ../../library/ssl.rst:2616
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or "
":const:`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are "
"disabled by default."
msgstr ""

#: ../../library/ssl.rst:2629
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. "
":const:`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname "
"checks by default. You have to load certificates into the context."
msgstr ""

#: ../../library/ssl.rst:2636
msgid "Cipher selection"
msgstr ""

#: ../../library/ssl.rst:2638
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-"
"FORMAT>`_. If you want to check which ciphers are enabled by a given cipher "
"list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` command "
"on your system."
msgstr ""

#: ../../library/ssl.rst:2649
msgid "Multi-processing"
msgstr ""

#: ../../library/ssl.rst:2651
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or "
":func:`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""

#: ../../library/ssl.rst:2663
msgid "TLS 1.3"
msgstr ""

#: ../../library/ssl.rst:2667
msgid ""
"Python has provisional and experimental support for TLS 1.3 with OpenSSL "
"1.1.1.  The new protocol behaves slightly differently than previous version "
"of TLS/SSL.  Some new TLS 1.3 features are not yet available."
msgstr ""

#: ../../library/ssl.rst:2671
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method "
":meth:`SSLContext.set_ciphers` cannot enable or disable any TLS 1.3 ciphers "
"yet, but :meth:`SSLContext.get_ciphers` returns them."
msgstr ""

#: ../../library/ssl.rst:2675
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:2678
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process"
" certificate requests while they send or receive application data from the "
"server."
msgstr ""

#: ../../library/ssl.rst:2682
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""

#: ../../library/ssl.rst:2689
msgid "LibreSSL support"
msgstr ""

#: ../../library/ssl.rst:2691
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""

#: ../../library/ssl.rst:2695
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods "
":meth:`SSLContext.set_npn_protocols` and "
":meth:`SSLSocket.selected_npn_protocol` are not available."
msgstr ""

#: ../../library/ssl.rst:2698
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars "
":envvar:`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although "
":func:`get_default_verify_paths` still reports them."
msgstr ""

#: ../../library/ssl.rst:2706
msgid "Class :class:`socket.socket`"
msgstr "Class :class:`socket.socket`"

#: ../../library/ssl.rst:2706
msgid "Documentation of underlying :mod:`socket` class"
msgstr ""

#: ../../library/ssl.rst:2709
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr ""

#: ../../library/ssl.rst:2709
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Apache HTTP Server文档介绍"

#: ../../library/ssl.rst:2712
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""

#: ../../library/ssl.rst:2712
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2715
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ""

#: ../../library/ssl.rst:2715
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2718
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""

#: ../../library/ssl.rst:2718
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2721
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""

#: ../../library/ssl.rst:2721
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2724
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ""

#: ../../library/ssl.rst:2724
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2727
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""

#: ../../library/ssl.rst:2727
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2730
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""

#: ../../library/ssl.rst:2730
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2732
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""

#: ../../library/ssl.rst:2733
msgid "Mozilla"
msgstr "Mozilla"
