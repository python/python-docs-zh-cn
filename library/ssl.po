# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`!ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`!ssl` --- 套接字对象的 TLS/SSL 包装器"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**源代码:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS,"
" and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"该模块提供了对传输层安全（通常称为 \"安全套接字层\"）加密和网络套接字的对等认证设施的访问，包括客户端和服务器端。 该模块使用 OpenSSL "
"库。它可以在所有现代 Unix 系统、 Windows 、 macOS 和可能的其他平台上使用，只要 OpenSSL 安装在该平台上。"

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""
"某些行为可能依赖于具体平台，因为调用了操作系统的套接字 API. 已安装的 OpenSSL 版本也可能会导致不同的行为。 比如，TLSv1.3 是 "
"OpenSSL 1.1.1 版才提供的。"

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may"
" lead to a false sense of security, as the default settings of the ssl "
"module are not necessarily appropriate for your application."
msgstr ""
"在阅读 :ref:`ssl-security` 前不要使用此模块。 这样做可能会导致虚假的安全感，因为ssl模块的默认设置不一定适合你的应用程序。"

#: ../../library/ssl.rst:454 ../../library/ssl.rst:469
#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr "文档本文档记录 ``ssl`` 模块的对象和函数；更多关于TLS,SSL,和证书的信息，请参阅下方的“详情”选项"

#: ../../library/ssl.rst:42
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the"
" certificate of the other side of the connection, :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection or "
":meth:`get_verified_chain`, :meth:`get_unverified_chain` which retrieves "
"certificate chain."
msgstr ""
"本模块提供了一个类 :class:`ssl.SSLSocket`，它派生自 :class:`socket.socket` "
"类型，并提供类似套接字的包装器，也能够使用 SSL 对通过套接字的数据进行加密和解密。 它支持一些额外方法例如 "
":meth:`getpeercert`，该方法可以从连接的另一端获取证书，还有 :meth:`cipher`，该方法可获取安全连接所使用的密码，以及 "
":meth:`get_verified_chain`、:meth:`get_unverified_chain`，它们可获取证书链。"

#: ../../library/ssl.rst:51
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps"
" manage settings and certificates, which can then be inherited by SSL "
"sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"对于更复杂的应用程序，:class:`ssl.SSLContext` 类有助于管理设置项和证书，进而可以被使用 "
":meth:`SSLContext.wrap_socket` 方法创建的 SSL 套接字继承。"

#: ../../library/ssl.rst:55
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "更新以支持和 OpenSSL 1.1.0 的链接"

#: ../../library/ssl.rst:60
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8、1.0.0 和 1.0.1 已过时，将不再被支持。在 ssl 模块未来的版本中，最低需要 OpenSSL 1.0.2 或 "
"1.1.0。"

#: ../../library/ssl.rst:66
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ":pep:`644` 已经实现。ssl 模块需要 OpenSSL 1.1.1 以上版本的支持。"

#: ../../library/ssl.rst:69
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr "使用废弃的常量和函数会导致废弃警告。"

#: ../../library/ssl.rst:73
msgid "Functions, Constants, and Exceptions"
msgstr "方法、常量和异常处理"

#: ../../library/ssl.rst:77
msgid "Socket creation"
msgstr "套接字创建"

#: ../../library/ssl.rst:79
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method. The helper function "
":func:`create_default_context` returns a new context with secure default "
"settings."
msgstr ""
":class:`SSLSocket` 的实例必须使用 :meth:`SSLContext.wrap_socket` 方法来创建。 辅助函数 "
":func:`create_default_context` 将返回一个使用安全的默认设置的新上下文。"

#: ../../library/ssl.rst:84
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "客户端套接字实例，采用默认上下文和IPv4/IPv6双栈::"

#: ../../library/ssl.rst:86
msgid ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

#: ../../library/ssl.rst:97
msgid "Client socket example with custom context and IPv4::"
msgstr "客户端套接字示例，带有自定义上下文和IPv4::"

#: ../../library/ssl.rst:99
msgid ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT 需要有效的证书链和主机名\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

#: ../../library/ssl.rst:109
msgid "Server socket example listening on localhost IPv4::"
msgstr "服务器套接字实例，在localhost上监听IPv4::"

#: ../../library/ssl.rst:111
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."

#: ../../library/ssl.rst:123
msgid "Context creation"
msgstr "上下文创建"

#: ../../library/ssl.rst:125
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "便捷函数，可以帮助创建 :class:`SSLContext` 对象，用于常见的目的。"

#: ../../library/ssl.rst:130
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"返回一个新的 :class:`SSLContext` 对象，使用给定 *purpose* 的默认设置。 该设置由 :mod:`ssl` "
"模块选择，并且通常是代表一个比直接调用 :class:`SSLContext` 构造器时更高的安全等级。"

#: ../../library/ssl.rst:135
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for"
" certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* 代表用于进行证书核验的可选受信任 CA 证书，与 "
":meth:`SSLContext.load_verify_locations` 的一致。 如果三个参数均为 "
":const:`None`，此函数可以转而选择信任系统的默认 CA 证书。"

#: ../../library/ssl.rst:141
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` "
"with high encryption cipher suites without RC4 and without unauthenticated "
"cipher suites. Passing :const:`~Purpose.SERVER_AUTH` as *purpose* sets "
":data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA"
" certificates (when at least one of *cafile*, *capath* or *cadata* is given)"
" or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"设置为: :data:`PROTOCOL_TLS_CLIENT` 或 :data:`PROTOCOL_TLS_SERVER`, "
":data:`OP_NO_SSLv2` 和 :data:`OP_NO_SSLv3` 带有不含 RC4 及未认证的高强度加密密码套件。 传入 "
":const:`~Purpose.SERVER_AUTH` 作为 *purpose* 将把 "
":data:`~SSLContext.verify_mode` 设为 :data:`CERT_REQUIRED` 并加载 CA 证书（若至少给出 "
"*cafile*, *capath* 或 *cadata* 之一）或使用 :meth:`SSLContext.load_default_certs` "
"加载默认的 CA 证书。"

#: ../../library/ssl.rst:150
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"当 :attr:`~SSLContext.keylog_filename` 受支持并且设置了环境变量 :envvar:`SSLKEYLOGFILE` "
"时，:func:`create_default_context` 会启用密钥日志记录。"

#: ../../library/ssl.rst:154
msgid ""
"The default settings for this context include "
":data:`VERIFY_X509_PARTIAL_CHAIN` and :data:`VERIFY_X509_STRICT`. These make"
" the underlying OpenSSL implementation behave more like a conforming "
"implementation of :rfc:`5280`, in exchange for a small amount of "
"incompatibility with older X.509 certificates."
msgstr ""
"此上下文的默认设置包括 :data:`VERIFY_X509_PARTIAL_CHAIN` 和 :data:`VERIFY_X509_STRICT`。 "
"这使得下层的 OpenSSL 实现的行为与符合 :rfc:`5280` 的实现更为相似，代价则是与较旧的 X.509 证书存在少量不兼容。"

#: ../../library/ssl.rst:161
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr "协议、选项、密码和其他设置可随时更改为更具约束性的值而无须事先弃用。 这些值代表了兼容性和安全性之间的合理平衡。"

#: ../../library/ssl.rst:165
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr "如果你的应用需要特定的设置，你应当创建一个 :class:`SSLContext` 并自行应用设置。"

#: ../../library/ssl.rst:169
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken "
"<https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue to "
"use this function but still allow SSL 3.0 connections you can re-enable them"
" using::"
msgstr ""
"如果你发现当某些较旧的客户端或服务器尝试与用此函数创建的 :class:`SSLContext` 进行连接时收到了报错提示 \"Protocol or "
"cipher suite mismatch\"，这可能是因为它们只支持 SSL3.0 而它被此函数用 :data:`OP_NO_SSLv3` 排除掉了。"
" SSL3.0 被广泛认为 `完全不可用 <https://en.wikipedia.org/wiki/POODLE>`_。 "
"如果你仍希望继续使用此函数但仍允许 SSL 3.0 连接，你可以使用以下代码重新启用它们::"

#: ../../library/ssl.rst:178
msgid ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"
msgstr ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"

#: ../../library/ssl.rst:182
msgid ""
"This context enables :data:`VERIFY_X509_STRICT` by default, which may reject"
" pre-:rfc:`5280` or malformed certificates that the underlying OpenSSL "
"implementation otherwise would accept. While disabling this is not "
"recommended, you can do so using::"
msgstr ""
"此上下文默认会启用 :data:`VERIFY_X509_STRICT`，它可能拒绝下层 OpenSSL 实现在其他情况下应当会接受的 "
":rfc:`5280` 之前的证书或格式错误的证书。 虽然不建议禁用此功能，但你可以使用以下方式做到这一点::"

#: ../../library/ssl.rst:187
msgid ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"
msgstr ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"

#: ../../library/ssl.rst:194
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 被从默认密码字符串中丢弃。"

#: ../../library/ssl.rst:198
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 被添加到默认密码字符串中。"

#: ../../library/ssl.rst:200
msgid "3DES was dropped from the default cipher string."
msgstr "3DES 被从默认密码字符串中丢弃。"

#: ../../library/ssl.rst:204
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "增加了对密钥日志记录至 :envvar:`SSLKEYLOGFILE` 的支持。"

#: ../../library/ssl.rst:208
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol instead of generic "
":data:`PROTOCOL_TLS`."
msgstr ""
"当前上下文使用 :data:`PROTOCOL_TLS_CLIENT` 或 :data:`PROTOCOL_TLS_SERVER` 协议而非通用的 "
":data:`PROTOCOL_TLS`。"

#: ../../library/ssl.rst:214
msgid ""
"The context now uses :data:`VERIFY_X509_PARTIAL_CHAIN` and "
":data:`VERIFY_X509_STRICT` in its default verify flags."
msgstr ""
"此上下文现在会在其默认验证旗标中使用 :data:`VERIFY_X509_PARTIAL_CHAIN` 和 "
":data:`VERIFY_X509_STRICT`。"

#: ../../library/ssl.rst:219
msgid "Exceptions"
msgstr "异常"

#: ../../library/ssl.rst:223
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the "
"higher-level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"引发此异常以提示来自下层 SSL 实现（目前由 OpenSSL 库提供）的错误。 它表示在下层网络连接之上叠加的高层级加密和验证层存在某种问题。 "
"此错误是 :exc:`OSError` 的一个子类型。 :exc:`SSLError` 实例的错误和消息是由 OpenSSL 库提供的。"

#: ../../library/ssl.rst:230
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` 曾经是 :exc:`socket.error` 的一个子类型。"

#: ../../library/ssl.rst:235
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"一个字符串形式的助记符，用来指明发生错误的 OpenSSL 子模块，例如 ``SSL``, ``PEM`` 或 ``X509``。 可能的取值范围依赖于"
" OpenSSL 的版本。"

#: ../../library/ssl.rst:243
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"一个字符串形式的助记符，用来指明发生错误的原因，例如 ``CERTIFICATE_VERIFY_FAILED``。 可能的取值范围依赖于 OpenSSL"
" 的版本。"

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
":exc:`SSLError` 的子类，当尝试读取或写入且 SSL 连接已被完全关闭时会被引发。 请注意这并不意味着下层的传输（读取 TCP）已被关闭。"

#: ../../library/ssl.rst:259
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be received on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
":exc:`SSLError` 的子类，当尝试读取或写入数据，但在请求被满足之前还需要在下层的 TCP 传输上接收更多数据时会被 :ref:`非阻塞型 "
"SSL 套接字 <ssl-nonblocking>` 引发。"

#: ../../library/ssl.rst:268
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs to"
" be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
":exc:`SSLError` 的子类，当尝试读取或写入数据，但在请求被满足之前还需要在下层的 TCP 传输上发送更多数据时会被 :ref:`非阻塞型 "
"SSL 套接字 <ssl-nonblocking>` 引发。"

#: ../../library/ssl.rst:277
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
":exc:`SSLError` 的子类，当尝试在 SSL 套接字上执行操作时遇到系统错误时会被引发。 不幸的是，没有简单的方式能检查原始 errno "
"编号。"

#: ../../library/ssl.rst:285
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ":exc:`SSLError` 的子类，当 SSL 连接被突然终止时会被引发。 通常，当遇到此错误时你不应再尝试重用下层的传输。"

#: ../../library/ssl.rst:293
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ":exc:`SSLError` 的子类，当证书验证失败时会被引发。"

#: ../../library/ssl.rst:300
msgid "A numeric error number that denotes the verification error."
msgstr "一个数字形式的错误编号，用于表示验证错误。"

#: ../../library/ssl.rst:304
msgid "A human readable string of the verification error."
msgstr "用于表示验证错误的人类可读的字符串。"

#: ../../library/ssl.rst:308
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ":exc:`SSLCertVerificationError` 的别名。"

#: ../../library/ssl.rst:310
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "此异常现在是 :exc:`SSLCertVerificationError` 的别名。"

#: ../../library/ssl.rst:315
msgid "Random generation"
msgstr "随机生成"

#: ../../library/ssl.rst:319
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an "
":class:`SSLError` if the PRNG has not been seeded with enough data or if the"
" operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used"
" to seed the PRNG."
msgstr ""
"返回 *num* 个高加密强度伪随机字节数据。 如果 PRNG 未使用足够的数据作为随机种子或者如果当前 RAND 方法不支持该操作则会引发 "
":class:`SSLError`。 :func:`RAND_status` 可被用来检查 PRNG 的状态而 :func:`RAND_add` "
"可被用来为 PRNG 设置随机种子。"

#: ../../library/ssl.rst:325
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "对于几乎所有应用程序都更推荐使用 :func:`os.urandom`。"

#: ../../library/ssl.rst:327
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_,"
" to get the requirements of a cryptographically strong generator."
msgstr ""
"请阅读维基百科文章 `Cryptographically secure pseudorandom number generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_"
" 以了解对于高加密强度生成器的具体要求。"

#: ../../library/ssl.rst:336
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of "
"the pseudo-random number generator."
msgstr ""
"如果 SSL 伪随机数生成器已使用‘足够的’随机性作为种子则返回  ``True``，否则返回 ``False``。 你可以使用 "
":func:`ssl.RAND_egd` 和 :func:`ssl.RAND_add` 来增加伪随机数生成器的随机性。"

#: ../../library/ssl.rst:343
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"将给定的 *bytes* 混合到 SSL 伪随机数生成器中。 参数 *entropy* (浮点数) 是字符串中包含的熵值的下限 （因此可以始终使用 "
"``0.0``)。 请参阅 :rfc:`1750` 了解有关熵源的更多信息。"

#: ../../library/ssl.rst:348
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "现在接受可写的 :term:`字节类对象 <bytes-like object>`。"

#: ../../library/ssl.rst:352
msgid "Certificate handling"
msgstr "证书处理"

#: ../../library/ssl.rst:360
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"返回距离 Unix 纪元零时的秒数，给定的 ``cert_time`` 字符串代表来自证书的 \"notBefore\" 或 \"notAfter\" "
"日期值，采用 ``\"%b %d %H:%M:%S %Y %Z\"`` strptime 格式（C 区域）。"

#: ../../library/ssl.rst:365
msgid "Here's an example:"
msgstr "以下为示例代码:"

#: ../../library/ssl.rst:367
msgid ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"
msgstr ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"

#: ../../library/ssl.rst:377
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" 或 \"notAfter\" 日期值必须使用 GMT (:rfc:`5280`)。"

#: ../../library/ssl.rst:379
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"将输入时间解读为 UTC 时间，基于输入字符串中指明的 'GMT' 时区。 在之前使用的是本地时区。 返回一个整数（不带输入格式中秒的分数部分）"

#: ../../library/ssl.rst:388
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If *ca_certs* is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the *cafile* parameter in "
":meth:`SSLContext.load_verify_locations`.  The call will attempt to validate"
" the server certificate against that set of root certificates, and will fail"
" if the validation attempt fails.  A timeout can be specified with the "
"``timeout`` parameter."
msgstr ""
"给定使用 SSL 保护的服务器的地址 ``addr``，形式为一个 (*hostname*, *port-number*) "
"对，获取该服务器的证书，并返回为 PEM 编码的字符串。 如果指定了 ``ssl_version``，则使用该版本的 SSL 协议尝试连接该服务器。 "
"如果指定了 *ca_certs*，它应当是一个包含根证书列表的文件，与 :meth:`SSLContext.load_verify_locations`"
" 中 *cafile* 形参所使用的格式相同。 该调用将尝试根据该根证书集来难服务器的证书，如果验证失败则调用也将失败。 可以通过 "
"``timeout`` 形参来指定超时限制。"

#: ../../library/ssl.rst:399
msgid "This function is now IPv6-compatible."
msgstr "此函数现在是 IPv6 兼容的。-compatible."

#: ../../library/ssl.rst:402
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to "
":data:`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"默认的 *ssl_version* 从 :data:`PROTOCOL_SSLv3` 改为 :data:`PROTOCOL_TLS` "
"以保证与现代服务器的最大兼容性。"

#: ../../library/ssl.rst:406
msgid "The *timeout* parameter was added."
msgstr "加入 *timeout* 参数。"

#: ../../library/ssl.rst:411
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "根据给定的 DER 编码字节块形式的证书，返回同一证书的 PEM 编码字符串版本。"

#: ../../library/ssl.rst:416
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "根据给定的 ASCII PEM 字符串形式的证书，返回同一证书的 DER 编码字节序列。"

#: ../../library/ssl.rst:421
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The"
" paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"返回包含 OpenSSL 的默认 cafile 和 capath 的路径的命名元组。 此路径与 "
":meth:`SSLContext.set_default_verify_paths` 所使用的相同。 返回值是一个 :term:`named "
"tuple` ``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:426
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - 解析出的 cafile 路径或者如果文件不存在则为 ``None``,"

#: ../../library/ssl.rst:427
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - 解析出的 capath 路径或者如果目录不存在则为 ``None``,"

#: ../../library/ssl.rst:428
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - 指向一个 cafile 的 OpenSSL 环境键,"

#: ../../library/ssl.rst:429
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - 一个 cafile 的硬编码路径,"

#: ../../library/ssl.rst:430
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - 指向一个 capath 的 OpenSSL 环境键,"

#: ../../library/ssl.rst:431
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - 一个 capath 目录的硬编码路径"

#: ../../library/ssl.rst:437
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"从 Windows 的系统证书库中检索证书。 *store_name* 可以是 ``CA``, ``ROOT`` 或 ``MY`` 中的一个。 "
"Windows 也可能会提供额外的证书库。"

#: ../../library/ssl.rst:441
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS "
"or exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 "
"cert_bytes 的编码格式。 它可以为 :const:`x509_asn` 以表示 X.509 ASN.1 数据或是 "
":const:`pkcs_7_asn` 以表示 PKCS#7 ASN.1 数据。 trust 以 OIDS "
"集合的形式指明证书的目的，或者如果证书对于所有目的都可以信任则为 ``True``。"

#: ../../library/ssl.rst:448 ../../library/ssl.rst:1605
#: ../../library/ssl.rst:1904
msgid "Example::"
msgstr "示例::"

#: ../../library/ssl.rst:450
msgid ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"
msgstr ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"

#: ../../library/ssl.rst:460
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Windows 的系统证书库中检索 CRL。 *store_name* 可以是 ``CA``, ``ROOT`` 或 ``MY`` 中的一个。 "
"Windows 也可能会提供额外的证书库。"

#: ../../library/ssl.rst:464
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr ""
"此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 "
"cert_bytes 的编码格式。 它可以为 :const:`x509_asn` 以表示 X.509 ASN.1 数据或是 "
":const:`pkcs_7_asn` 以表示 PKCS#7 ASN.1 数据。"

#: ../../library/ssl.rst:475
msgid "Constants"
msgstr "常量"

#: ../../library/ssl.rst:477
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr "所有常量现在都是 :class:`enum.IntEnum` 或 :class:`enum.IntFlag` 多项集的成员。"

#: ../../library/ssl.rst:483
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. Except for "
":const:`PROTOCOL_TLS_CLIENT`, it is the default mode.  With client-side "
"sockets, just about any cert is accepted.  Validation errors, such as "
"untrusted or expired cert, are ignored and do not abort the TLS/SSL "
"handshake."
msgstr ""
":attr:`SSLContext.verify_mode` 可能的取值。 :const:`PROTOCOL_TLS_CLIENT` "
"除外，这是默认的模式。 对于客户端套接字，几乎任何证书都会被接受。 验证错误，如不受信任或过期的证书等，会被忽略并且不会中止 TLS/SSL 握手。"

#: ../../library/ssl.rst:489
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr "在服务器模式下，不会从客户端请求任何证书，因此客户端不会发送任何用于客户端证书身份验证的证书。"

#: ../../library/ssl.rst:492 ../../library/ssl.rst:2406
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "参见下文对于 :ref:`ssl-security` 的讨论。"

#: ../../library/ssl.rst:496
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In client mode, "
":const:`CERT_OPTIONAL` has the same meaning as :const:`CERT_REQUIRED`. It is"
" recommended to use :const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
":attr:`SSLContext.verify_mode` 可能的取值。 在客户端模式下，:const:`CERT_OPTIONAL` 具有与 "
":const:`CERT_REQUIRED` 相同的含义。 对于客户端套接字推荐改用 :const:`CERT_REQUIRED`。"

#: ../../library/ssl.rst:501
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"在服务器模式下，客户端证书请求会被发送给客户端。 客户端可以忽略请求也可以发送一个证书以执行 TLS 客户端证书身份验证。 "
"如果客户端选择发送证书，则将对其执行验证。 任何验证错误都将立即中止 TLS 握手。"

#: ../../library/ssl.rst:507 ../../library/ssl.rst:526
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed to "
":meth:`SSLContext.load_verify_locations`."
msgstr "使用此设置要求将一组有效的 CA 证书传递给 :meth:`SSLContext.load_verify_locations`。"

#: ../../library/ssl.rst:512
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In this mode, "
"certificates are required from the other side of the socket connection; an "
":class:`SSLError` will be raised if no certificate is provided, or if its "
"validation fails. This mode is **not** sufficient to verify a certificate in"
" client mode as it does not match hostnames.  "
":attr:`~SSLContext.check_hostname` must be enabled as well to verify the "
"authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses "
":const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
":attr:`SSLContext.verify_mode` 可能的取值。 "
"在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书，或验证失败则将引发 :class:`SSLError`。 此模式 **不能** "
"在客户端模式下对证书进行验证因为它不会匹配主机名。 :attr:`~SSLContext.check_hostname` "
"也必须被启用以验证证书的真实性。 :const:`PROTOCOL_TLS_CLIENT` 会使用 :const:`CERT_REQUIRED` "
"并默认启用 :attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:522
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr "对于服务器套接字，此模式会提供强制性的 TLS 客户端证书验证。 客户端证书请求会被发送给客户端并且客户端必须提供有效且受信任的证书。"

#: ../../library/ssl.rst:531
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "CERT_* 常量的 :class:`enum.IntEnum` 多项集。"

#: ../../library/ssl.rst:537
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does"
" neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags` 可能的取值。 在此模式下，证书吊销列表（CRL）并不会被检查。 OpenSSL "
"默认不要求也不验证 CRL。"

#: ../../library/ssl.rst:545
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ""
":attr:`SSLContext.verify_flags` 可能的取值。 在此模式下， 只会检查对等证书而不检查任何中间 CA 证书。 "
"此模式要求提供由对等证书颁发者（其直接上级 CA）签名的有效 CRL。 如果未使用 "
":attr:`SSLContext.load_verify_locations` 加载正确的 CRL，则验证将失败。"

#: ../../library/ssl.rst:555
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ":attr:`SSLContext.verify_flags` 可能的取值。 在此模式下，会检查对等证书链中所有证书的 CRL。"

#: ../../library/ssl.rst:562
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ":attr:`SSLContext.verify_flags` 可能的取值，用于禁用已损坏 X.509 证书的绕过操作。"

#: ../../library/ssl.rst:569
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ":attr:`SSLContext.verify_flags` 的可能取值，启用代理证书验证。"

#: ../../library/ssl.rst:576
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags` 可能的取值。 它指示 OpenSSL 在构建用于验证某个证书的信任链时首选受信任的证书。"
" 此旗标将默认被启用。"

#: ../../library/ssl.rst:584
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
":attr:`SSLContext.verify_flags` 的可能取值。它指示 OpenSSL 接受信任存储中的中间 CA "
"作为信任锚，与自我签名的根 CA 证书的方式相同。这样就能信任中间 CA 颁发的证书，而不一定非要去信任其祖先的根 CA。"

#: ../../library/ssl.rst:595
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "VERIFY_* 常量的 :class:`enum.IntFlag` 多项集。"

#: ../../library/ssl.rst:601
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr "选择客户端和服务器均支持的最高协议版本。 此选项名称并不准确，实际上 \"SSL\" 和 \"TLS\" 协议均可被选择。"

#: ../../library/ssl.rst:608
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of "
":data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"TLS 客户端和服务器需要不同的默认设置来实现安全通信。通用的 TLS 协议常量已废弃，而采用 :data:`PROTOCOL_TLS_CLIENT` "
"和 :data:`PROTOCOL_TLS_SERVER`。"

#: ../../library/ssl.rst:614
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"自动协商为客户端和服务器都支持的最高版本协议，并配置当前上下文客户端的连接。该协议默认启用 :data:`CERT_REQUIRED` 和 "
":attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:623
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr "自动协商为客户端和服务器都支持的最高版本协议，并配置上下文服务器端的连接。"

#: ../../library/ssl.rst:630
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr ":data:`PROTOCOL_TLS` 的别名。"

#: ../../library/ssl.rst:634
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "请改用 :data:`PROTOCOL_TLS`。"

#: ../../library/ssl.rst:638
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "选择 SSL 版本 3 作为通道加密协议。"

#: ../../library/ssl.rst:640
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr "如果OpenSSL是用 ``no-ssl3`` 选项编译的，则该协议不可用。"

#: ../../library/ssl.rst:645
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL 版本 3 并不安全。 极不建议使用它。"

#: ../../library/ssl.rst:649
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL 已经废弃了所有特定于版本的协议。请换用带有 :attr:`SSLContext.minimum_version` 和 "
":attr:`SSLContext.maximum_version` 的默认协议 :data:`PROTOCOL_TLS_SERVER` 或 "
":data:`PROTOCOL_TLS_CLIENT`  。"

#: ../../library/ssl.rst:657
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "选择 TLS 版本 1.0 作为通道加密协议。"

#: ../../library/ssl.rst:661 ../../library/ssl.rst:672
#: ../../library/ssl.rst:683
msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL 已经废弃了所有特定于版本的协议。"

#: ../../library/ssl.rst:665
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "选择 TLS 版本 1.1 作为通道加密协议。 仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:676
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "选用 TLS 1.2 版本作为隧道加密协议。只适用于 openssl 1.0.1 以上版本。"

#: ../../library/ssl.rst:687
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"对存在于其他 SSL 实现中的各种缺陷启用绕过操作。 默认会设置此选项。 没有必要设置与 OpenSSL 的 ``SSL_OP_ALL`` "
"常量同名的旗标。"

#: ../../library/ssl.rst:695
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"阻止 SSLv2 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 SSLv2 作为协议版本。"

#: ../../library/ssl.rst:703
msgid "SSLv2 is deprecated"
msgstr "SSLv2 已被弃用"

#: ../../library/ssl.rst:707
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"阻止 SSLv3 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 SSLv3 作为协议版本。"

#: ../../library/ssl.rst:715
msgid "SSLv3 is deprecated"
msgstr "SSLv3 已被弃用"

#: ../../library/ssl.rst:719
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"阻止 TLSv1 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1 作为协议版本。"

#: ../../library/ssl.rst:725
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"此选项自 OpenSSL 1.1.0 起已被弃用，请改用新的 :attr:`SSLContext.minimum_version` 和 "
":attr:`SSLContext.maximum_version`。"

#: ../../library/ssl.rst:732
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.1 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.1 作为协议版本。 "
"仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:738 ../../library/ssl.rst:749
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "此选项自 OpenSSL 1.1.0 起已被弃用。"

#: ../../library/ssl.rst:743
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.2 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.2 作为协议版本。 "
"仅适用于 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:754
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction"
" with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When"
" Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"阻止 TLSv1.3 连接。 此选项仅可与 :const:`PROTOCOL_TLS` 结合使用。 它会阻止对等方选择 TLSv1.3 作为协议版本。 "
"TLS 1.3 适用于 OpenSSL 1.1.1 或更新的版本。 当 Python 编译是基于较旧版本的 OpenSSL 时，该旗标默认为 *0*。"

#: ../../library/ssl.rst:762
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr "此选项自 OpenSSL 1.1.0 起已被弃用。 它被添加到 2.7.15 和 3.6.3 是为了向下兼容 OpenSSL 1.0.2。"

#: ../../library/ssl.rst:768
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"禁用所有 TLSv1.2 和更早版本的重协商操作。 不发送 HelloRequest 消息，并忽略通过 ClientHello 发起的重协商请求。"

#: ../../library/ssl.rst:771
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "此选项仅适用于 OpenSSL 1.1.0h 及更新的版本。"

#: ../../library/ssl.rst:777
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr "使用服务器的密码顺序首选项，而不是客户端的首选项。 此选项在客户端套接字和 SSLv2 服务器套接字上无效。"

#: ../../library/ssl.rst:784
msgid ""
"Prevents reuse of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr "防止对于单独 SSL 会话重用相同的 DH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。"

#: ../../library/ssl.rst:792
msgid ""
"Prevents reuse of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr "防止对于单独 SSL 会话重用相同的 ECDH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。"

#: ../../library/ssl.rst:800
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr "在 TLS 1.3 握手中发送虚拟更改密码规格（CCS）消息以使得 TLS 1.3 连接看起来更像是 TLS 1.2 连接。"

#: ../../library/ssl.rst:803
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "此选项仅适用于 OpenSSL 1.1.1 及更新的版本。"

#: ../../library/ssl.rst:809
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr "在 SSL 通道上禁用压缩。 这适用于应用协议支持自己的压缩方案的情况。"

#: ../../library/ssl.rst:816
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "OP_* 常量的 :class:`enum.IntFlag` 多项集。"

#: ../../library/ssl.rst:820
msgid "Prevent client side from requesting a session ticket."
msgstr "阻止客户端请求会话凭据。"

#: ../../library/ssl.rst:826
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "忽略 TLS 连接的意外关闭。"

#: ../../library/ssl.rst:828 ../../library/ssl.rst:844
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "此选项仅适用于 OpenSSL 3.0.0 及更新的版本。"

#: ../../library/ssl.rst:834
msgid ""
"Enable the use of the kernel TLS. To benefit from the feature, OpenSSL must "
"have been compiled with support for it, and the negotiated cipher suites and"
" extensions must be supported by it (a list of supported ones may vary by "
"platform and kernel version)."
msgstr ""
"启用内核 TLS。 为了利用该特征，OpenSSL "
"编译时必须附带对它的支持，并且协商的密码套件和扩展必须被它所支持（受支持项的列表可能因平台和内核版本而有所变化）。"

#: ../../library/ssl.rst:839
msgid ""
"Note that with enabled kernel TLS some cryptographic operations are "
"performed by the kernel directly and not via any available OpenSSL "
"Providers. This might be undesirable if, for example, the application "
"requires all cryptographic operations to be performed by the FIPS provider."
msgstr ""
"请注意当启用内核 TLS 时某些加解密操作将由内核直接执行而不是通过任何可用的 OpenSSL 提供程序。 "
"这可能并不是你想要的，例如，当应用程序要求所有加解密操作由 FIPS 提供程序执行时。"

#: ../../library/ssl.rst:850
msgid ""
"Allow legacy insecure renegotiation between OpenSSL and unpatched servers "
"only."
msgstr "允许只在 OpenSSL 和未打补丁的服务器之间进行旧式的不安全协商。"

#: ../../library/ssl.rst:857
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr "OpenSSL 库是否具有对 :rfc:`7301` 中描述的 *应用层协议协商* TLS 扩展的内置支持。"

#: ../../library/ssl.rst:864
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common"
" name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"OpenSSL 库是否具有对不检测目标通用名称的内置支持且 :attr:`SSLContext.hostname_checks_common_name`"
" 为可写状态。"

#: ../../library/ssl.rst:872
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"OpenSSL 库是否具有对基于椭圆曲线的 Diffie-Hellman 密钥交换的内置支持。 此常量应当为真值，除非发布者明确地禁用了此功能。"

#: ../../library/ssl.rst:880
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr "OpenSSL 库是否具有对 *服务器名称提示* 扩展（在 :rfc:`6066` 中定义）的内置支持。"

#: ../../library/ssl.rst:887
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"OpenSSL 库是否具有对 `应用层协议协商 <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_ 中描述的 *下一协议协商* 的内置支持。 当此常量为真值时，你可以使用 "
":meth:`SSLContext.set_npn_protocols` 方法来公告你想要支持的协议。"

#: ../../library/ssl.rst:897
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "OpenSSL 库是否具有对 SSL 2.0 协议的内置支持。"

#: ../../library/ssl.rst:903
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "OpenSSL 库是否具有对 SSL 3.0 协议的内置支持。"

#: ../../library/ssl.rst:909
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "OpenSSL 库是否具有对 TLS 1.0 协议的内置支持。"

#: ../../library/ssl.rst:915
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "OpenSSL 库是否具有对 TLS 1.1 协议的内置支持。"

#: ../../library/ssl.rst:921
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "OpenSSL 库是否具有对 TLS 1.2 协议的内置支持。"

#: ../../library/ssl.rst:927
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "OpenSSL 库是否具有对 TLS 1.3 协议的内置支持。"

#: ../../library/ssl.rst:933
msgid "Whether the OpenSSL library has built-in support for TLS-PSK."
msgstr "OpenSSL 库是否具有对 TLS-PSK 的内置支持。"

#: ../../library/ssl.rst:939
msgid "Whether the OpenSSL library has built-in support for TLS-PHA."
msgstr "OpenSSL 库是否具有对 TLS-PHA 的内置支持。"

#: ../../library/ssl.rst:945
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"受支持的 TLS 通道绑定类型组成的列表。 此列表中的字符串可被用作传给 :meth:`SSLSocket.get_channel_binding` "
"的参数。"

#: ../../library/ssl.rst:952
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "解释器所加载的 OpenSSL 库的版本字符串::"

#: ../../library/ssl.rst:954
msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"
msgstr ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"

#: ../../library/ssl.rst:961
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "代表 OpenSSL 库的版本信息的五个整数所组成的元组::"

#: ../../library/ssl.rst:964
msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"
msgstr ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"

#: ../../library/ssl.rst:971
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "OpenSSL 库的原始版本号，以单个整数表示::"

#: ../../library/ssl.rst:973
msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"
msgstr ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"

#: ../../library/ssl.rst:984
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry"
" <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"来自 :rfc:`5246` 等文档的警报描述。 `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ 中包含了这个列表及对定义其含义的 RFC 引用。"

#: ../../library/ssl.rst:988
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr "被用作 :meth:`SSLContext.set_servername_callback` 中的回调函数的返回值。"

#: ../../library/ssl.rst:995
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "ALERT_DESCRIPTION_* 常量的 :class:`enum.IntEnum` 多项集。"

#: ../../library/ssl.rst:1001
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web servers (therefore, it will be used "
"to create client-side sockets)."
msgstr ""
"用于 :func:`create_default_context` 和 :meth:`SSLContext.load_default_certs` "
"的参数。表示上下文可用于验证网络服务器（因此，它将被用于创建客户端套接字）。"

#: ../../library/ssl.rst:1010
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web clients (therefore, it will be used "
"to create server-side sockets)."
msgstr ""
"用于 :func:`create_default_context` 和 :meth:`SSLContext.load_default_certs` "
"的参数。 表示上下文可用于验证网络客户（因此，它将被用于创建服务器端套接字）。"

#: ../../library/ssl.rst:1019
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "SSL_ERROR_* 常量的 :class:`enum.IntEnum` 多项集。"

#: ../../library/ssl.rst:1025
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for "
":attr:`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":attr:`SSLContext.maximum_version` 和 :attr:`SSLContext.minimum_version` 中的 "
"SSL 和 TLS 版本的 :class:`enum.IntEnum` 多项集。"

#: ../../library/ssl.rst:1033
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available "
"TLS/SSL versions."
msgstr "受支持的最低和最高 SSL 或 TLS 版本。 这些常量被称为魔术常量。 它们的值并不反映可用的最低和最高 TLS/SSL 版本。"

#: ../../library/ssl.rst:1043
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 至 TLS 1.3。"

#: ../../library/ssl.rst:1047
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and "
":attr:`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"所有 :class:`TLSVersion` 成员，除 :attr:`TLSVersion.TLSv1_2` 和 "
":attr:`TLSVersion.TLSv1_3` 之外均已废弃。"

#: ../../library/ssl.rst:1052
msgid "SSL Sockets"
msgstr "SSL 套接字"

#: ../../library/ssl.rst:1056
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL 套接字提供了 :ref:`socket-objects` 的下列方法:"

#: ../../library/ssl.rst:1058
msgid ":meth:`~socket.socket.accept`"
msgstr ":meth:`~socket.socket.accept`"

#: ../../library/ssl.rst:1059
msgid ":meth:`~socket.socket.bind`"
msgstr ":meth:`~socket.socket.bind`"

#: ../../library/ssl.rst:1060
msgid ":meth:`~socket.socket.close`"
msgstr ":meth:`~socket.socket.close`"

#: ../../library/ssl.rst:1061
msgid ":meth:`~socket.socket.connect`"
msgstr ":meth:`~socket.socket.connect`"

#: ../../library/ssl.rst:1062
msgid ":meth:`~socket.socket.detach`"
msgstr ":meth:`~socket.socket.detach`"

#: ../../library/ssl.rst:1063
msgid ":meth:`~socket.socket.fileno`"
msgstr ":meth:`~socket.socket.fileno`"

#: ../../library/ssl.rst:1064
msgid ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"
msgstr ""
":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"

#: ../../library/ssl.rst:1065
msgid ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"
msgstr ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"

#: ../../library/ssl.rst:1066
msgid ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, "
":meth:`~socket.socket.setblocking`"
msgstr ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, "
":meth:`~socket.socket.setblocking`"

#: ../../library/ssl.rst:1068
msgid ":meth:`~socket.socket.listen`"
msgstr ":meth:`~socket.socket.listen`"

#: ../../library/ssl.rst:1069
msgid ":meth:`~socket.socket.makefile`"
msgstr ":meth:`~socket.socket.makefile`"

#: ../../library/ssl.rst:1070
msgid ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (but passing a"
" non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (但不允许传入非零的 "
"``flags`` 参数)"

#: ../../library/ssl.rst:1072
msgid ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (with the same "
"limitation)"
msgstr ":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (具有同样的限制)"

#: ../../library/ssl.rst:1074
msgid ""
":meth:`~socket.socket.sendfile` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile` (但 :mod:`os.sendfile` 将仅用于纯文本套接字，在其他情况下将使用 "
":meth:`~socket.socket.send`)"

#: ../../library/ssl.rst:1076
msgid ":meth:`~socket.socket.shutdown`"
msgstr ":meth:`~socket.socket.shutdown`"

#: ../../library/ssl.rst:1078
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"但是，由于 SSL（和 TLS）协议在 TCP 之上具有自己的框架，因此 SSL 套接字抽象在某些方面可能与常规的 OS 层级套接字存在差异。 "
"特别是要查看 :ref:`非阻塞型套接字说明 <ssl-nonblocking>`。"

#: ../../library/ssl.rst:1083
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method."
msgstr ":class:`SSLSocket` 的实例必须使用 :meth:`SSLContext.wrap_socket` 方法来创建。"

#: ../../library/ssl.rst:1086
msgid "The :meth:`sendfile` method was added."
msgstr "新增了 :meth:`sendfile` 方法。"

#: ../../library/ssl.rst:1089
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ":meth:`shutdown` 不会在每次接收或发送字节数据后重置套接字超时。 现在套接字超时为关闭的最大总持续时间。"

#: ../../library/ssl.rst:1094
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use "
":meth:`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"直接创建 :class:`SSLSocket` 实例的做法已被弃用，请使用 :meth:`SSLContext.wrap_socket` 来包装套接字。"

#: ../../library/ssl.rst:1098
msgid ""
":class:`SSLSocket` instances must to created with "
":meth:`~SSLContext.wrap_socket`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""
":class:`SSLSocket` 的实例必须使用 :meth:`~SSLContext.wrap_socket` 来创建。 "
"在较早的版本中，直接创建实例是可能的。 但这从未被记入文档或是被正式支持。"

#: ../../library/ssl.rst:1104
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing "
"zero-length data no longer fails with a protocol violation error."
msgstr ""
"Python 内部现在使用 ``SSL_read_ex`` 和 ``SSL_write_ex``。这些函数支持读取和写入大于 2GB "
"的数据。写入零长数据不再出现违反协议的错误。"

#: ../../library/ssl.rst:1109
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL 套接字还具有下列方法和属性:"

#: ../../library/ssl.rst:1113
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"从 SSL 套接字读取至多 *len* 个字节的数据并将结果作为 ``bytes`` 实例返回。 如果指定了 "
"*buffer*，则改为读取到缓冲区，并返回所读取的字节数。"

#: ../../library/ssl.rst:1117
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"如果套接字为 :ref:`非阻塞型 <ssl-nonblocking>` 则会引发 :exc:`SSLWantReadError` 或 "
":exc:`SSLWantWriteError` 且读取将阻塞。"

#: ../../library/ssl.rst:1120
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also"
" cause write operations."
msgstr "由于在任何时候重新协商都是可能的，因此调用 :meth:`read` 也可能导致写入操作。"

#: ../../library/ssl.rst:1123
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr "套接字超时在每次接收或发送字节数据后不会再被重置。 现在套接字超时为读取至多 *len* 个字节数据的最大总持续时间。"

#: ../../library/ssl.rst:1128
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "请使用 :meth:`~SSLSocket.recv` 来代替 :meth:`~SSLSocket.read`。"

#: ../../library/ssl.rst:1133
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr "将 *buf* 写入到 SSL 套接字并返回所写入的字节数。 *buf* 参数必须为支持缓冲区接口的对象。"

#: ../../library/ssl.rst:1136
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is "
":ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"如果套接字为 :ref:`非阻塞型 <ssl-nonblocking>` 则会引发 :exc:`SSLWantReadError` 或 "
":exc:`SSLWantWriteError` 且读取将阻塞。"

#: ../../library/ssl.rst:1139
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr "由于在任何时候重新协商都是可能的，因此调用 :meth:`write` 也可能导致读取操作。"

#: ../../library/ssl.rst:1142
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr "套接字超时在每次接收或发送字节数据后不会再被重置。 现在套接字超时为写入 *buf* 的最大总持续时间。"

#: ../../library/ssl.rst:1146
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "请使用 :meth:`~SSLSocket.send` 来代替 :meth:`~SSLSocket.write`。"

#: ../../library/ssl.rst:1151
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the "
"low-level methods that read and write unencrypted, application-level data "
"and decrypt/encrypt it to encrypted, wire-level data. These methods require "
"an active SSL connection, i.e. the handshake was completed and "
":meth:`SSLSocket.unwrap` was not called."
msgstr ""
":meth:`~SSLSocket.read` 和 :meth:`~SSLSocket.write` "
"方法是读写未加密的应用级数据，并将其解密/加密为带加密的线路级数据的低层级方法。 这些方法需要有激活的 SSL 连接，即握手已完成而 "
":meth:`SSLSocket.unwrap` 尚未被调用。"

#: ../../library/ssl.rst:1157
msgid ""
"Normally you should use the socket API methods like "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` instead of these"
" methods."
msgstr ""
"通常你应当使用套接字 API 方法例如 :meth:`~socket.socket.recv` 和 "
":meth:`~socket.socket.send` 来代替这些方法。"

#: ../../library/ssl.rst:1163
msgid "Perform the SSL setup handshake."
msgstr "执行 SSL 设置握手。"

#: ../../library/ssl.rst:1165
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr ""
"当套接字的 :attr:`~SSLSocket.context` 的 :attr:`~SSLContext.check_hostname` "
"属性为真值时此握手方法还会执行 :func:`match_hostname`。"

#: ../../library/ssl.rst:1170
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr "套接字超时在每次接收或发送字节数据时不会再被重置。 现在套接字超时为握手的最大总持续时间。"

#: ../../library/ssl.rst:1174
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function "
":func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname"
" or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"主机名或 IP 地址会在握手期间由 OpenSSL 进行匹配。 函数 :func:`match_hostname` 不再被使用。 在 OpenSSL "
"拒绝主机名或 IP 地址的情况下，握手将提前被中止并向对等方发送 TLS 警告消息。"

#: ../../library/ssl.rst:1182
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise "
":exc:`ValueError`."
msgstr "如果连接另一端的对等方没有证书，则返回 ``None``。 如果 SSL 握手还未完成，则会引发 :exc:`ValueError`。"

#: ../../library/ssl.rst:1186
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject``"
" (the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"如果 ``binary_form`` 形参为 :const:`False`，并且从对等方接收到了证书，此方法将返回一个 :class:`dict` "
"实例。 如果证书未通过验证，则字典将为空。 如果证书通过验证，它将返回由多个密钥组成的字典，其中包括 ``subject`` (证书颁发给的主体) 和 "
"``issuer`` (颁发证书的主体)。 如果证书包含一个 *Subject Alternative Name* 扩展的实例 (see "
":rfc:`3280`)，则字典中还将有一个 ``subjectAltName`` 键。"

#: ../../library/ssl.rst:1195
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"``subject`` 和 ``issuer`` 字段都是包含在证书中相应字段的数据结构中给出的相对专有名称（RDN）序列的元组，每个 RDN 均为 "
"name-value 对的序列。 这里是一个实际的示例::"

#: ../../library/ssl.rst:1200
msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"

#: ../../library/ssl.rst:1219
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate"
" as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"如果 ``binary_form`` 形参为 :const:`True`，并且提供了证书，此方法会将整个证书的 DER "
"编码形式作为字节序列返回，或者如果对等方未提供证书则返回 :const:`None`。 对等方是否提供证书取决于 SSL 套接字的角色:"

#: ../../library/ssl.rst:1225
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "对于客户端 SSL 套接字，服务器将总是提供证书，无论是否需要进行验证;"

#: ../../library/ssl.rst:1228
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr ""
"对于服务器 SSL 套接字，客户端将仅在服务器要求时才提供证书；因此如果你使用了 :const:`CERT_NONE` (而不是 "
":const:`CERT_OPTIONAL` 或 :const:`CERT_REQUIRED`) 则 :meth:`getpeercert` 将返回 "
":const:`None`。"

#: ../../library/ssl.rst:1233
msgid "See also :attr:`SSLContext.check_hostname`."
msgstr "另请参阅 :attr:`SSLContext.check_hostname`。"

#: ../../library/ssl.rst:1235
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr "返回的字典包括额外的条目例如 ``issuer`` 和 ``notBefore``。"

#: ../../library/ssl.rst:1239
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
"如果握手未完成则会引发 :exc:`ValueError`。 返回的字典包括额外的 X509v3 扩展条目例如 "
"``crlDistributionPoints``, ``caIssuers`` 和 ``OCSP`` URI。"

#: ../../library/ssl.rst:1244
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "IPv6 地址字符串不再附带末尾换行符。"

#: ../../library/ssl.rst:1249
msgid ""
"Returns verified certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes. If certificate verification was "
"disabled method acts the same as :meth:`~SSLSocket.get_unverified_chain`."
msgstr ""
"返回由 SSL 通道另一端以 DER 编码字节列表形式提供的经过验证的证书链。 如果证书验证被禁用则此方法的行为与 "
":meth:`~SSLSocket.get_unverified_chain` 相同。"

#: ../../library/ssl.rst:1258
msgid ""
"Returns raw certificate chain provided by the other end of the SSL channel "
"as a list of DER-encoded bytes."
msgstr "返回由 SSL 通道另一端以 DER 编码字节列表形式提供的原始证书链。"

#: ../../library/ssl.rst:1265
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"返回由三个值组成的元组，其中包含所使用的密码名称，定义其使用方式的 SSL 协议版本，以及所使用的加密比特位数。 如果尚未建立连接，则返回 "
"``None``。"

#: ../../library/ssl.rst:1271
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the"
" cipher, the version of the SSL protocol that defines its use, and the "
"number of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` "
"returns ``None`` if no connection has been established or the socket is a "
"client socket."
msgstr ""
"返回在客户端和服务器均可用的密码列表。 所返回列表的每个条目都是由三个值组成的元组其中包含密码名称、定义其使用方式的 SSL "
"协议版本，以及密码所使用的加密比特位数量。 如果连接尚未建立或套接字为客户端套接字则 :meth:`~SSLSocket.shared_ciphers`"
" 将返回 ``None``。"

#: ../../library/ssl.rst:1282
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr "以字符串形式返回所使用的压缩算法，或者如果连接没有使用压缩则返回 ``None``。"

#: ../../library/ssl.rst:1285
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can"
" use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr "如果高层级的协议支持自己的压缩机制，你可以使用 :data:`OP_NO_COMPRESSION` 来禁用 SSL 层级的压缩。"

#: ../../library/ssl.rst:1292
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns"
" ``None`` if not connected or the handshake has not been completed."
msgstr "为当前连接获取字节串形式的通道绑定数据。 如果尚未连接或握手尚未完成则返回 ``None``。"

#: ../../library/ssl.rst:1295
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type."
" Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES`"
" list.  Currently only the 'tls-unique' channel binding, defined by "
":rfc:`5929`, is supported.  :exc:`ValueError` will be raised if an "
"unsupported channel binding type is requested."
msgstr ""
"*cb_type* 形参允许选择需要的通道绑定类型。 有效的通道绑定类型在 :data:`CHANNEL_BINDING_TYPES` 列表中列出。 "
"目前只支持由 :rfc:`5929` 所定义的 'tls-unique' 通道绑定。 如果请求了一个不受支持的通道绑定类型则将引发 "
":exc:`ValueError`。"

#: ../../library/ssl.rst:1305
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the client's "
"proposed protocols, or if the handshake has not happened yet, ``None`` is "
"returned."
msgstr ""
"返回在 TLS 握手期间所选择的协议。 如果 :meth:`SSLContext.set_alpn_protocols` 未被调用，如果另一方不支持 "
"ALPN，如果此套接字不支持任何客户端所用的协议，或者如果握手尚未发生，则将返回 ``None``。"

#: ../../library/ssl.rst:1315
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the"
" other party does not support NPN, or if the handshake has not yet happened,"
" this will return ``None``."
msgstr ""
"返回在Return the higher-level protocol that was selected during the TLS/SSL "
"握手期间所选择的高层级协议。 如果 :meth:`SSLContext.set_npn_protocols` 未被调用，或者如果另一方不支持 "
"NPN，或者如果握手尚未发生，则将返回 ``None``。"

#: ../../library/ssl.rst:1324 ../../library/ssl.rst:1693
msgid "NPN has been superseded by ALPN"
msgstr "NPN 已被 ALPN 取代。"

#: ../../library/ssl.rst:1328
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"执行 SSL 关闭握手，这会从下层的套接字中移除 TLS 层，并返回下层的套接字对象。 这可被用来通过一个连接将加密操作转为非加密。 "
"返回的套接字应当总是被用于同连接另一方的进一步通信，而不是原始的套接字。"

#: ../../library/ssl.rst:1336
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see "
":attr:`SSLContext.post_handshake_auth`."
msgstr ""
"向一个 TLS 1.3 客户端请求握手后身份验证（PHA）。 只有在初始 TLS 握手之后且双方都启用了 PHA 的情况下才能为服务器端套接字的 TLS"
" 1.3 连接启用 PHA，参见 :attr:`SSLContext.post_handshake_auth`。"

#: ../../library/ssl.rst:1341
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"此方法不会立即执行证书交换。 服务器端会在下一次写入事件期间发送 CertificateRequest "
"并期待客户端在下一次读取事件期间附带证书进行响应。"

#: ../../library/ssl.rst:1345
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an "
":exc:`SSLError` is raised."
msgstr "如果有任何前置条件未被满足（例如非 TLS 1.3，PHA 未启用），则会引发 :exc:`SSLError`。"

#: ../../library/ssl.rst:1349
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"仅在 OpenSSL 1.1.1 且 TLS 1.3 被启用时可用。 没有 TLS 1.3 支持，此方法将引发 "
":exc:`NotImplementedError`。"

#: ../../library/ssl.rst:1356
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"以字符串形式返回由连接协商确定的实际 SSL 协议版本，或者如果未建立安全连接则返回 ``None``。 在撰写本文档时，可能的返回值包括 "
"``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` 和 "
"``\"TLSv1.2\"``。 最新的 OpenSSL 版本可能会定义更多的返回值。"

#: ../../library/ssl.rst:1366
msgid ""
"Returns the number of already decrypted bytes available for read, pending on"
" the connection."
msgstr "返回在连接上等待被读取的已解密字节数。"

#: ../../library/ssl.rst:1371
msgid "The :class:`SSLContext` object this SSL socket is tied to."
msgstr "该 SSL 套接字所关联的 :class:`SSLContext` 对象。"

#: ../../library/ssl.rst:1377
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for "
"client-side sockets."
msgstr "一个布尔值，对于服务器端套接字为 ``True`` 而对于客户端套接字则为 ``False``。"

#: ../../library/ssl.rst:1384
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr "服务器的主机名: :class:`str` 类型，对于服务器端套接字或者如果构造器中未指定主机名则为 ``None``。"

#: ../../library/ssl.rst:1389
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form "
"(``\"pythön.org\"``)."
msgstr ""
"现在该属性将始终为 ASCII 文本。 当 ``server_hostname`` 为一个国际化域名（IDN）时，该属性现在会保存为 A 标签形式 "
"(``\"xn--pythn-mua.org\"``) 而非 U 标签形式 (``\"pythön.org\"``)。"

#: ../../library/ssl.rst:1397
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before "
":meth:`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"用于 SSL 连接的 :class:`SSLSession`。 该会话将在执行 TLS 握手后对客户端和服务器端套接字可用。 "
"对于客户端套接字该会话可以在调用 :meth:`~SSLSocket.do_handshake` 之前被设置以重用一个会话。"

#: ../../library/ssl.rst:1410
msgid "SSL Contexts"
msgstr "SSL 上下文"

#: ../../library/ssl.rst:1414
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"SSL 上下文可保存各种比单独 SSL 连接寿命更长的数据，例如 SSL 配置选项，证书和私钥等。 "
"它还可为服务器端套接字管理缓存，以加快来自相同客户端的重复连接。"

#: ../../library/ssl.rst:1421
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other versions."
"  If not specified, the default is :data:`PROTOCOL_TLS`; it provides the "
"most compatibility with other versions."
msgstr ""
"创建一个新的 SSL 上下文。 你可以传入 *protocol*，它必须为此模块中定义的 ``PROTOCOL_*`` 常量之一。 该形参指定要使用哪个"
" SSL 协议版本。 通常，服务器会选择一个特定的协议版本，而客户端必须适应服务器的选择。 大多数版本都不能与其他版本互操作。 如果未指定，则默认值为 "
":data:`PROTOCOL_TLS`；它提供了与其他版本的最大兼容性。"

#: ../../library/ssl.rst:1430
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "这个表显示了客户端（横向）的哪个版本能够连接服务器（纵向）的哪个版本。"

#: ../../library/ssl.rst:1436
msgid "*client* / **server**"
msgstr "*客户端* / **服务器**"

#: ../../library/ssl.rst:1436
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1436
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1436
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1436
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1436
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1436
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1438
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1438 ../../library/ssl.rst:1439
#: ../../library/ssl.rst:1440 ../../library/ssl.rst:1441
#: ../../library/ssl.rst:1442 ../../library/ssl.rst:1443
msgid "yes"
msgstr "是"

#: ../../library/ssl.rst:1438 ../../library/ssl.rst:1439
#: ../../library/ssl.rst:1441 ../../library/ssl.rst:1442
#: ../../library/ssl.rst:1443
msgid "no"
msgstr "否"

#: ../../library/ssl.rst:1438 ../../library/ssl.rst:1440
msgid "no [1]_"
msgstr "否 [1]_"

#: ../../library/ssl.rst:1439
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1439 ../../library/ssl.rst:1440
msgid "no [2]_"
msgstr "否 [2]_"

#: ../../library/ssl.rst:1440
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1441
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1442
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1443
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1446
msgid "Footnotes"
msgstr "备注"

#: ../../library/ssl.rst:1447
msgid ""
":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ":class:`SSLContext` 默认设置 :data:`OP_NO_SSLv2` 以禁用 SSLv2。"

#: ../../library/ssl.rst:1448
msgid ""
":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ":class:`SSLContext` 默认设置 :data:`OP_NO_SSLv3` 以禁用 SSLv3。"

#: ../../library/ssl.rst:1449
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"TLS 1.3 协议在 OpenSSL >= 1.1.1 中设置 :data:`PROTOCOL_TLS` 时可用。 没有专门针对 TLS 1.3 的 "
"PROTOCOL 常量。"

#: ../../library/ssl.rst:1454
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ":func:`create_default_context` 让 :mod:`ssl` 为特定目标选择安全设置。"

#: ../../library/ssl.rst:1459
msgid ""
"The context is created with secure default values. The options "
":data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, "
":data:`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2`, "
"and :data:`OP_NO_SSLv3` (except for :data:`PROTOCOL_SSLv3`) are set by "
"default. The initial cipher suite list contains only ``HIGH`` ciphers, no "
"``NULL`` ciphers and no ``MD5`` ciphers."
msgstr ""
"上下文会使用安全的默认值来创建。 默认设置的选项有 :data:`OP_NO_COMPRESSION`, "
":data:`OP_CIPHER_SERVER_PREFERENCE`, :data:`OP_SINGLE_DH_USE`, "
":data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` 和 :data:`OP_NO_SSLv3` "
"(:data:`PROTOCOL_SSLv3` 除外)。 初始密码套件列表只包含 ``HIGH`` 密码，而不包含 ``NULL`` 密码和 "
"``MD5`` 密码。"

#: ../../library/ssl.rst:1469
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
"不带协议参数的 :class:`SSLContext` 已废弃。将来，上下文类会要求使用 :data:`PROTOCOL_TLS_CLIENT` 或 "
":data:`PROTOCOL_TLS_SERVER` 协议。"

#: ../../library/ssl.rst:1475
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. "
":data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and "
":data:`PROTOCOL_TLS_SERVER` use TLS 1.2 as minimum TLS version."
msgstr ""
"现在默认的密码套件只包含安全的 AES 和 ChaCha20 密码，具有前向保密性和安全级别2。禁止使用少于 2048 位的 RSA 和 DH "
"密钥以及少于 224 位的ECC密钥。 :data:`PROTOCOL_TLS` 、 :data:`PROTOCOL_TLS_CLIENT` 和  "
":data:`PROTOCOL_TLS_SERVER` 至少使用 TLS 1.2 版本。"

#: ../../library/ssl.rst:1483
msgid ""
":class:`SSLContext` only supports limited mutation once it has been used by "
"a connection. Adding new certificates to the internal trust store is "
"allowed, but changing ciphers, verification settings, or mTLS certificates "
"may result in surprising behavior."
msgstr ""
":class:`SSLContext` 一旦被某个连接使用它将只支持有限的变异。 在内部信任存储中添加新证书是允许的，但是更改密码、验证设置或 mTLS"
" 证书则可能导致令人吃惊的行为。"

#: ../../library/ssl.rst:1490
msgid ""
":class:`SSLContext` is designed to be shared and used by multiple "
"connections. Thus, it is thread-safe as long as it is not reconfigured after"
" being used by a connection."
msgstr ":class:`SSLContext` 被设计为可由多个连接共享和使用。 因此，只要在被某个连接使用后不重新配置那么它就是线程安全的。"

#: ../../library/ssl.rst:1495
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` 对象具有以下方法和属性:"

#: ../../library/ssl.rst:1499
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509"
" certificates flagged as CA certificates and certificate revocation lists as"
" dictionary."
msgstr "获取以字典表示的有关已加载的 X.509 证书数量，被标记为 CA 证书的 X.509 证书数量以及证书吊销列表的统计信息。"

#: ../../library/ssl.rst:1503
msgid "Example for a context with one CA cert and one other cert::"
msgstr "具有一个 CA 证书和一个其他证书的上下文示例::"

#: ../../library/ssl.rst:1505
msgid ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"
msgstr ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"

#: ../../library/ssl.rst:1513
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string"
" must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to"
" a file containing the private key.  Otherwise the private key will be taken"
" from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for"
" more information on how the certificate is stored in the *certfile*."
msgstr ""
"加载一个私钥及对应的证书。 *certfile* 字符串必须为以 PEM 格式表示的单个文件路径，该文件中包含证书以及确立证书真实性所需的任意数量的 "
"CA 证书。 如果存在 *keyfile* 字符串，它必须指向一个包含私钥的文件。 否则私钥也将从 *certfile* 中提取。 请参阅 "
":ref:`ssl-certificates` 中的讨论来了解有关如何将证书存储至 *certfile* 的更多信息。"

#: ../../library/ssl.rst:1522
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments,"
" and it should return a string, bytes, or bytearray.  If the return value is"
" a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"*password* 参数可以是一个函数，调用时将得到用于解密私钥的密码。 它在私钥被加密且需要密码时才会被调用。 "
"它调用时将不带任何参数，并且应当返回一个字符串、字节串或字节数组。 如果返回值是一个字符串，在用它解密私钥之前它将以 UTF-8 进行编码。 "
"或者也可以直接将字符串、字节串或字节数组值作为 *password* 参数提供。 如果私钥未被加密且不需要密码则它将被忽略。"

#: ../../library/ssl.rst:1531
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr "如果未指定 *password* 参数且需要一个密码，将会使用 OpenSSL 内置的密码提示机制来交互式地提示用户输入密码。"

#: ../../library/ssl.rst:1535
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "如果私钥不能匹配证书则会引发 :class:`SSLError`。"

#: ../../library/ssl.rst:1538
msgid "New optional argument *password*."
msgstr "新增可选参数 *password*。"

#: ../../library/ssl.rst:1543
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT``"
" system stores. On all systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may "
"load CA certificates from other locations, too."
msgstr ""
"从默认位置加载一组默认的 \"证书颁发机构\" (CA) 证书。 在 Windows 上它将从 ``CA`` 和 ``ROOT`` 系统存储中加载 CA"
" 证书。 在所有系统上它会调用 :meth:`SSLContext.set_default_verify_paths` 。 "
"将来该方法也可能会从其他位置加载 CA 证书。"

#: ../../library/ssl.rst:1549
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side sockets)."
" :const:`Purpose.CLIENT_AUTH` loads CA certificates for client certificate "
"verification on the server side."
msgstr ""
"*purpose* 旗标指明要加载哪种 CA 证书。 默认设置 :const:`Purpose.SERVER_AUTH` 将加载被标记且被信任用于 "
"TLS Web 服务器验证（客户端套接字）的证书。 :const:`Purpose.CLIENT_AUTH` 则会加载用于在服务器端进行客户端证书验证的"
" CA 证书。"

#: ../../library/ssl.rst:1559
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate"
" other peers' certificates when :data:`verify_mode` is other than "
":data:`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"当 :data:`verify_mode` 不为 :data:`CERT_NONE` 时加载一组用于验证其他对等方证书的 \"证书颁发机构\" (CA)"
" 证书。 必须至少指定 *cafile* 或 *capath* 中的一个。"

#: ../../library/ssl.rst:1563
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"此方法还可加载 PEM 或 DER 格式的证书吊销列表 (CRL)，为此必须正确配置 :attr:`SSLContext.verify_flags`。"

#: ../../library/ssl.rst:1567
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"如果存在 *cafile* 字符串，它应为 PEM 格式的级联 CA 证书文件的路径。 请参阅 :ref:`ssl-certificates` "
"中的讨论来了解有关如何处理此文件中的证书的更多信息。"

#: ../../library/ssl.rst:1572
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout"
" <https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."
msgstr ""
"如果存在 *capath* 字符串，它将为包含多个 PEM 格式的 CA 证书的目录的路径，并遵循 `OpenSSL 专属布局 "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_。"

#: ../../library/ssl.rst:1577
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates"
" are ignored but at least one certificate must be present."
msgstr ""
"如果存在 *cadata* 对象，它应为一个或多个 PEM 编码的证书的 ASCII 字符串或者 DER 编码的证书的 :term:`bytes-"
"like object`。 与 *capath* 一样 PEM 编码的证书之外的多余行会被忽略，但至少要有一个证书。"

#: ../../library/ssl.rst:1582
msgid "New optional argument *cadata*"
msgstr "新增可选参数 *cadata*"

#: ../../library/ssl.rst:1587
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"获取已离开法人 \"证书颁发机构\" (CA) 证书列表。 如果 ``binary_form`` 形参为 :const:`False` "
"则每个列表条目都是一个类似于 :meth:`SSLSocket.getpeercert` 输出的字典。 在其他情况下此方法将返回一个 DER "
"编码的证书的列表。 返回的列表不包含来自 *capath* 的证书，除非 SSL 连接请求并加载了一个证书。"

#: ../../library/ssl.rst:1595
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr "capath 目录中的证书不会被加载，除非它们已至少被使用过一次。"

#: ../../library/ssl.rst:1602
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See "
":meth:`SSLContext.set_ciphers`."
msgstr "获取已启用密码的列表。 该列表将按密码的优先级排序。 参见 :meth:`SSLContext.set_ciphers`。"

#: ../../library/ssl.rst:1607
msgid ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"
msgstr ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"

#: ../../library/ssl.rst:1639
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"从构建 OpenSSL 库时定义的文件系统路径中加载一组默认的 \"证书颁发机构\" (CA) 证书。 "
"不幸的是，没有一种简单的方式能知道此方法是否执行成功：如果未找到任何证书也不会返回错误。 不过，当 OpenSSL "
"库是作为操作系统的一部分被提供时，它的配置应当是正确的。"

#: ../../library/ssl.rst:1648
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format "
"<https://docs.openssl.org/master/man1/ciphers/>`_. If no cipher can be "
"selected (because compile-time options or other configuration forbids use of"
" all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""
"为使用此上下文创建的套接字设置可用密码。 它应当为 `OpenSSL 密码列表格式 "
"<https://docs.openssl.org/master/man1/ciphers/>`_ 的字符串。 "
"如果没有可被选择的密码（由于编译时选项或其他配置禁止使用已指定的所有密码），则将引发 :class:`SSLError`。"

#: ../../library/ssl.rst:1656
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give"
" the currently selected cipher."
msgstr "在连接后，SSL 套接字的 :meth:`SSLSocket.cipher` 方法将给出当前所选择的密码。"

#: ../../library/ssl.rst:1659
msgid ""
"TLS 1.3 cipher suites cannot be disabled with "
":meth:`~SSLContext.set_ciphers`."
msgstr "TLS 1.3 密码套件不能通过 :meth:`~SSLContext.set_ciphers` 禁用。"

#: ../../library/ssl.rst:1664
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"指定在 SSL/TLS 握手期间套接字应当通告的协议。 它应为由 ASCII 字符串组成的列表，例如 ``['http/1.1', "
"'spdy/2']``，按首选顺序排列。 协议的选择将在握手期间发生，并依据 :rfc:`7301` 来执行。 "
"在握手成功后，:meth:`SSLSocket.selected_alpn_protocol` 方法将返回已达成一致的协议。"

#: ../../library/ssl.rst:1671
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr "如果 :data:`HAS_ALPN` 为 ``False`` 则此方法将引发 :exc:`NotImplementedError`。"

#: ../../library/ssl.rst:1678
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the "
":meth:`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"指定在Specify which protocols the socket should advertise during the SSL/TLS "
"握手期间套接字应当通告的协议。 它应为由字符串组成的列表，例如 ``['http/1.1', 'spdy/2']``，按首选顺序排列。 "
"协议的选择将在握手期间发生，并将依据 `应用层协议协商 <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_ 来执行。 "
"在握手成功后，:meth:`SSLSocket.selected_npn_protocol` 方法将返回已达成一致的协议。"

#: ../../library/ssl.rst:1686
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr "如果 :data:`HAS_NPN` 为 ``False`` 则此方法将引发 :exc:`NotImplementedError`。"

#: ../../library/ssl.rst:1697
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"注册一个回调函数，当 TLS 客户端指定了一个服务器名称提示时，该回调函数将在 SSL/TLS 服务器接收到 TLS Client Hello "
"握手消息后被调用。 服务器名称提示机制的定义见 :rfc:`6066` section 3 - Server Name Indication。"

#: ../../library/ssl.rst:1702
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"每个 ``SSLContext`` 只能设置一个回调。 如果 *sni_callback* 被设置为 ``None`` 则会禁用回调。 "
"对该函数的后续调用将禁用之前注册的回调。"

#: ../../library/ssl.rst:1706
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if"
" the TLS Client Hello does not contain a server name) and the third argument"
" is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"此回调函数将附带三个参数来调用；第一个参数是 :class:`ssl.SSLSocket`，第二个参数是代表客户端准备与之通信的服务器的字符串 "
"(或者如果 TLS Client Hello 不包含服务器名称则为 :const:`None`) 而第三个参数是原来的 "
":class:`SSLContext`。 服务器名称参数为文本形式。 对于国际化域名，服务器名称是一个 IDN A 标签 (``\"xn--pythn-"
"mua.org\"``)。"

#: ../../library/ssl.rst:1714
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the server"
" name."
msgstr ""
"此回调的一个典型用法是将 :class:`ssl.SSLSocket` 的 :attr:`SSLSocket.context` 属性修改为一个 "
":class:`SSLContext` 类型的新对象，该对象代表与服务器相匹配的证书链。"

#: ../../library/ssl.rst:1719
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. The "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.get_verified_chain`, "
":meth:`SSLSocket.get_unverified_chain` :meth:`SSLSocket.cipher` and "
":meth:`SSLSocket.compression` methods require that the TLS connection has "
"progressed beyond the TLS Client Hello and therefore will not return "
"meaningful values nor can they be called safely."
msgstr ""
"由于 TLS 连接处于早期协商阶段，因此仅能使用有限的方法和属性例如 :meth:`SSLSocket.selected_alpn_protocol` "
"和 :attr:`SSLSocket.context`。 :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.get_verified_chain`, :meth:`SSLSocket.get_unverified_chain`"
" :meth:`SSLSocket.cipher` 和 :meth:`SSLSocket.compression` 方法要求 TLS 连接已过 TLS "
"Client Hello 步骤因而不会返回有意义的值也不能安全地调用它们。"

#: ../../library/ssl.rst:1728
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"*sni_callback* 函数必须返回 ``None`` 以允许 TLS 协商继续进行。 如果想要 TLS 失败，则可以返回常量 "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`。 其他返回值将导致 "
"TLS 的致命错误 :const:`ALERT_DESCRIPTION_INTERNAL_ERROR`。"

#: ../../library/ssl.rst:1734
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"如果从 *sni_callback* 函数引发了异常，则 TLS 连接将终止并发出 TLS 致命警告消息 "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`。"

#: ../../library/ssl.rst:1738
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had"
" OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"如果 OpenSSL library 库在构建时定义了 OPENSSL_NO_TLSEXT 则此方法将返回 "
":exc:`NotImplementedError`。"

#: ../../library/ssl.rst:1745
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"这是被保留用于向下兼容的旧式 API。 在可能的情况下，你应当改用 :attr:`sni_callback`。 给出的 "
"*server_name_callback* 类似于 *sni_callback*，不同之处在于当服务器主机名是 IDN "
"编码的国际化域名时，*server_name_callback* 会接收到一个已编码的 U 标签 (``\"pythön.org\"``)。"

#: ../../library/ssl.rst:1751
msgid ""
"If there is a decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"如果发生了服务器名称解码错误。 TLS 连接将终止并向客户端发出 :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` "
"最严重 TLS 警告消息。"

#: ../../library/ssl.rst:1759
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile*"
" parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"加载密钥生成参数用于 Diffie-Hellman (DH) 密钥交换。 使用 DH 密钥交换能以消耗（服务器和客户端的）计算资源为代价提升前向保密性。"
" *dhfile* 参数应当为指向一个包含 PEM 格式的 DH 形参的文件的路径。"

#: ../../library/ssl.rst:1765
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr "此设置不会应用于客户端套接字。 你还可以使用 :data:`OP_SINGLE_DH_USE` 选项来进一步提升安全性。"

#: ../../library/ssl.rst:1772
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"为基于椭圆曲线的 Elliptic Curve-based Diffie-Hellman (ECDH) 密钥交换设置曲线名称。 ECDH 显著快于常规 "
"DH 同时据信同样安全。 *curve_name* 形参应为描述某个知名椭圆曲线的字符串，例如受到广泛支持的曲线 ``prime256v1``。"

#: ../../library/ssl.rst:1778
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr "此设置不会应用于客户端套接字。 你还可以使用 :data:`OP_SINGLE_ECDH_USE` 选项来进一步提升安全性。"

#: ../../library/ssl.rst:1781
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "如果 :data:`HAS_ECDH` 为 ``False`` 则此方法将不可用。"

#: ../../library/ssl.rst:1786
msgid ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy>`_"

#: ../../library/ssl.rst:1787
msgid "Vincent Bernat."
msgstr "Vincent Bernat。"

#: ../../library/ssl.rst:1793
msgid ""
"Wrap an existing Python socket *sock* and return an instance of "
":attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The "
"returned SSL socket is tied to the context, its settings and certificates. "
"*sock* must be a :const:`~socket.SOCK_STREAM` socket; other socket types are"
" unsupported."
msgstr ""
"包装一个现有的 Python 套接字 *sock* 并返回一个 :attr:`SSLContext.sslsocket_class` 的实例 (默认为 "
":class:`SSLSocket`)。 返回的 SSL 套接字会关联到相应上下文、设置及证书。 *sock* 必须是一个 "
":const:`~socket.SOCK_STREAM` 套接字；其他套接字类型均不受支持。"

#: ../../library/ssl.rst:1799
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr "形参 ``server_side`` 是一个布尔值，它标明希望从该套接字获得服务器端行为还是客户端行为。"

#: ../../library/ssl.rst:1802
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying"
" socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise "
":exc:`SSLError`."
msgstr ""
"对于客户端套接字，上下文的构造会延迟执行；如果下层的套接字尚未连接，上下文的构造将在对套接字调用 :meth:`connect` 之后执行。 "
"对于服务器端套接字，如果套接字没有远端对等方，它会被视为一个监听套接字，并且服务器端 SSL 包装操作会在通过 :meth:`accept` "
"方法所接受的客户端连接上自动执行。 此方法可能会引发 :exc:`SSLError`。"

#: ../../library/ssl.rst:1810
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"在客户端连接上，可选形参 *server_hostname* 指定所要连接的服务的主机名。 这允许单个服务器托管具有单独证书的多个基于 SSL "
"的服务，很类似于 HTTP 虚拟主机。 如果 *server_side* 为真值则指定 *server_hostname* 将引发 "
":exc:`ValueError`。"

#: ../../library/ssl.rst:1816
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the"
" application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over the"
" blocking behavior of the socket I/O involved in the handshake."
msgstr ""
"形参 ``do_handshake_on_connect`` 指明是否要在调用 :meth:`socket.connect` 之后自动执行 SSL "
"握手，还是要通过唤起 :meth:`SSLSocket.do_handshake` 方法让应用程序显式地调用它。 显式地调用 "
":meth:`SSLSocket.do_handshake` 可给予程序对握手中所涉及的套接字 I/O 阻塞行为的控制。"

#: ../../library/ssl.rst:1823
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.recv` method should signal unexpected EOF from the other "
"end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected EOF "
"errors raised from the underlying socket; if :const:`False`, it will raise "
"the exceptions back to the caller."
msgstr ""
"形参 ``suppress_ragged_eofs`` 指明 :meth:`SSLSocket.recv` 方法应当如何从连接的另一端发送非预期的 "
"EOF 信号。 如果指定为 :const:`True` (默认值)，它将返回正常的 EOF (空字节串对象) 来响应从下层套接字引发的非预期的 EOF "
"错误；如果指定为 :const:`False`，它将向调用方引发异常。"

#: ../../library/ssl.rst:1830
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*，参见 :attr:`~SSLSocket.session`。"

#: ../../library/ssl.rst:1832
msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use "
":meth:`SSLContext.wrap_bio`."
msgstr ""
"要将 :class:`SSLSocket` 包装在另一个 :class:`SSLSocket` 中，请使用 "
":meth:`SSLContext.wrap_bio`。"

#: ../../library/ssl.rst:1835
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr "总是允许传送 server_hostname，即使 OpenSSL 没有 SNI。"

#: ../../library/ssl.rst:1839 ../../library/ssl.rst:1865
msgid "*session* argument was added."
msgstr "增加了 *session* 参数。"

#: ../../library/ssl.rst:1842
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead"
" of hard-coded :class:`SSLSocket`."
msgstr ""
"此方法返回 :attr:`SSLContext.sslsocket_class` 的实例而不是硬编码的 :class:`SSLSocket`。"

#: ../../library/ssl.rst:1848
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to "
":class:`SSLSocket`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLSocket`."
msgstr ""
":meth:`SSLContext.wrap_socket` 的返回类型，默认为 :class:`SSLSocket`。 "
"该属性可以在类实例上被重载以便返回自定义的 :class:`SSLSocket` 的子类。"

#: ../../library/ssl.rst:1857
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of "
":attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"包装 BIO 对象 *incoming* 和 *outgoing* 并返回一个 :attr:`SSLContext.sslobject_class` "
"(默认为 :class:`SSLObject`) 的实例。 SSL 例程将从 BIO 中读取输入数据并将数据写入到 outgoing BIO。"

#: ../../library/ssl.rst:1862
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"*server_side*, *server_hostname* 和 *session* 形参具有与 "
":meth:`SSLContext.wrap_socket` 中相同的含义。"

#: ../../library/ssl.rst:1868
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead"
" of hard-coded :class:`SSLObject`."
msgstr ""
"此方法返回 :attr:`SSLContext.sslobject_class` 的实例而不是硬编码的 :class:`SSLObject`。"

#: ../../library/ssl.rst:1874
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to "
":class:`SSLObject`. The attribute can be overridden on instance of class in "
"order to return a custom subclass of :class:`SSLObject`."
msgstr ""
":meth:`SSLContext.wrap_bio` 的返回类型，默认为 :class:`SSLObject`。 "
"该属性可以在类实例上被重载以便返回自定义的 :class:`SSLObject` 的子类。"

#: ../../library/ssl.rst:1882
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ to their "
"numeric values.  For example, here is the total number of hits and misses in"
" the session cache since the context was created::"
msgstr ""
"获取由该上下文创建或管理的 SSL 会话的统计数据。 返回将每个 `信息块 "
"<https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ 映射到其数字值的字典。 "
"例如，下面是自该上下文创建以来会话缓存中命中和未命中的总计数::"

#: ../../library/ssl.rst:1887
msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"

#: ../../library/ssl.rst:1893
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`."
" The context's :attr:`~SSLContext.verify_mode` must be set to "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets "
":attr:`~SSLContext.verify_mode` from :data:`CERT_NONE` to "
":data:`CERT_REQUIRED`.  It cannot be set back to :data:`CERT_NONE` as long "
"as hostname checking is enabled. The :data:`PROTOCOL_TLS_CLIENT` protocol "
"enables hostname checking by default. With other protocols, hostname "
"checking must be enabled explicitly."
msgstr ""
"是否要将匹配 :meth:`SSLSocket.do_handshake` 中对等方证书的主机名。 该上下文的 "
":attr:`~SSLContext.verify_mode` 必须被设为 :data:`CERT_OPTIONAL` 或 "
":data:`CERT_REQUIRED`，并且你必须将 *server_hostname* 传给 "
":meth:`~SSLContext.wrap_socket` 以便匹配主机名。 启用主机名检查会自动将 "
":attr:`~SSLContext.verify_mode` 从 :data:`CERT_NONE` 设为 "
":data:`CERT_REQUIRED`。 只要启用了主机名检查就无法将其设回 :data:`CERT_NONE`。 "
":data:`PROTOCOL_TLS_CLIENT` 协议默认启用主机名检查。 对于其他协议，则必须显式地启用主机名检查。"

#: ../../library/ssl.rst:1906
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"

#: ../../library/ssl.rst:1921
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to "
":data:`CERT_REQUIRED`  when hostname checking is enabled and "
":attr:`~SSLContext.verify_mode` is :data:`CERT_NONE`. Previously the same "
"operation would have failed with a :exc:`ValueError`."
msgstr ""
"现在当主机名检查被启用且 :attr:`~SSLContext.verify_mode` 为 :data:`CERT_NONE` 时 "
":attr:`~SSLContext.verify_mode` 会自动更改为 :data:`CERT_REQUIRED`。 "
"在之前版本中同样的操作将失败并引发 :exc:`ValueError`。"

#: ../../library/ssl.rst:1928
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"每当生成或接收到密钥时，将 TLS 密钥写入到一个密钥日志文件。 密钥日志文件的设计仅适用于调试目的。 文件的格式由 NSS "
"指明并为许多流量分析工具例如 Wireshark 所使用。 日志文件会以追加模式打开。 写入操作会在线程之间同步，但不会在进程之间同步。"

#: ../../library/ssl.rst:1938
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :const:`PROTOCOL_TLS`, "
":const:`PROTOCOL_TLS_CLIENT`, and :const:`PROTOCOL_TLS_SERVER`."
msgstr ""
"一个代表所支持的最高 TLS 版本的 :class:`TLSVersion` 枚举成员。 该值默认为 "
":attr:`TLSVersion.MAXIMUM_SUPPORTED`。 这个属性对于 :const:`PROTOCOL_TLS`, "
":const:`PROTOCOL_TLS_CLIENT` 和 :const:`PROTOCOL_TLS_SERVER` 以外的其他协议来说都是只读的。"

#: ../../library/ssl.rst:1943
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` and :attr:`SSLContext.options` all "
"affect the supported SSL and TLS versions of the context. The implementation"
" does not prevent invalid combination. For example a context with "
":attr:`OP_NO_TLSv1_2` in :attr:`~SSLContext.options` and "
":attr:`~SSLContext.maximum_version` set to :attr:`TLSVersion.TLSv1_2` will "
"not be able to establish a TLS 1.2 connection."
msgstr ""
":attr:`~SSLContext.maximum_version`, :attr:`~SSLContext.minimum_version` 和 "
":attr:`SSLContext.options` 等属性都会影响上下文所支持的 SSL 和 TLS 版本。 这个实现不会阻止无效的组合。 例如一个 "
":attr:`~SSLContext.options` 为 :attr:`OP_NO_TLSv1_2` 而 "
":attr:`~SSLContext.maximum_version` 设为 :attr:`TLSVersion.TLSv1_2` 的上下文将无法建立 "
"TLS 1.2 连接。"

#: ../../library/ssl.rst:1956
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"与 :attr:`SSLContext.maximum_version` 类似，区别在于它是所支持的最低版本或为 "
":attr:`TLSVersion.MINIMUM_SUPPORTED`。"

#: ../../library/ssl.rst:1963
msgid ""
"Control the number of TLS 1.3 session tickets of a "
":const:`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 "
"to 1.2 connections."
msgstr ""
"控制一个 :const:`PROTOCOL_TLS_SERVER` 上下文的 TLS 1.3 会话凭据数量。 这个设置不会影响 TLS 1.0 至 "
"1.2 的连接。"

#: ../../library/ssl.rst:1971
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as "
":data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"一个代表此上下文中所启用的 SSL 选项集的整数。 默认值为 :data:`OP_ALL`，但你也可以通过在选项间进行 OR 运算来指定其他选项例如 "
":data:`OP_NO_SSLv2`。"

#: ../../library/ssl.rst:1975
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` 返回 :class:`Options` 旗标:"

#: ../../library/ssl.rst:1983
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and "
":attr:`SSLContext.maximum_version` instead."
msgstr ""
"自 OpenSSL 1.1.0 起，所有 ``OP_NO_SSL*`` 和 ``OP_NO_TLS*`` 选项已被弃用，请改用新的 "
":attr:`SSLContext.minimum_version` 和 :attr:`SSLContext.maximum_version`。"

#: ../../library/ssl.rst:1989
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"启用 TLS 1.3 握手后客户端身份验证。 握手后验证默认是被禁用的，服务器只能在初始握手期间请求 TLS 客户端证书。 "
"当启用时，服务器可以在握手之后的任何时候请求 TLS 客户端证书。"

#: ../../library/ssl.rst:1994
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr "当在客户端套接字上启用时，客户端会向服务器发信号说明它支持握手后身份验证。"

#: ../../library/ssl.rst:1997
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until "
":meth:`SSLSocket.verify_client_post_handshake` is called and some I/O is "
"performed."
msgstr ""
"当在服务器端套接字上启用时，:attr:`SSLContext.verify_mode` 也必须被设为 :data:`CERT_OPTIONAL` 或 "
":data:`CERT_REQUIRED`。 实际的客户端证书交换会被延迟直至 "
":meth:`SSLSocket.verify_client_post_handshake` 被调用并执行了一些 I/O 操作后再进行。"

#: ../../library/ssl.rst:2007
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr "构造上下文时所选择的协议版本。 这个属性是只读的。"

#: ../../library/ssl.rst:2012
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"在没有目标替代名称扩展的情况下 :attr:`~SSLContext.check_hostname` 是否要回退为验证证书的通用名称（默认为真值）。"

#: ../../library/ssl.rst:2020
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"此旗标在 OpenSSL 1.1.1l 之前的版本上不起作用。 Python 3.8.9, 3.9.3 和 3.10 包括了针对之前版本的变通处理。"

#: ../../library/ssl.rst:2025
msgid ""
"An integer representing the `security level "
"<https://docs.openssl.org/master/man3/SSL_CTX_get_security_level/>`_ for the"
" context. This attribute is read-only."
msgstr ""
"一个代表上下文 `安全级别 "
"<https://docs.openssl.org/master/man3/SSL_CTX_get_security_level/>`_ 的整数。 "
"该属性是只读的。"

#: ../../library/ssl.rst:2033
msgid ""
"The flags for certificate verification operations. You can set flags like "
":data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL "
"does neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"证书验证操作的标志位。可以用“或”的方式组合在一起设置 :data:`VERIFY_CRL_CHECK_LEAF` 这类标志。默认情况下，OpenSSL"
" 既不需要也不验证证书吊销列表（CRL）。"

#: ../../library/ssl.rst:2039
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` 返回 :class:`VerifyFlags` 旗标:"

#: ../../library/ssl.rst:2047
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"是否要尝试验证其他对等方的证书以及如果验证失败应采取何种行为。 该属性值必须为 :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` 或 :data:`CERT_REQUIRED` 之一。"

#: ../../library/ssl.rst:2051
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` 返回 :class:`VerifyMode` 枚举:"

#: ../../library/ssl.rst:2059
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a client-side connection."
msgstr "在客户端连接上启用 TLS-PSK（预共享密钥）验证。"

#: ../../library/ssl.rst:2061 ../../library/ssl.rst:2110
msgid ""
"In general, certificate based authentication should be preferred over this "
"method."
msgstr "一般来说，基于证书的身份验证应当优先于此方法。"

#: ../../library/ssl.rst:2063
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. The ``hint`` "
"parameter is an optional identity hint sent by the server. The return value "
"is a tuple in the form (client-identity, psk). Client-identity is an "
"optional string which may be used by the server to select a corresponding "
"PSK for the client. The string must be less than or equal to ``256`` octets "
"when UTF-8 encoded. PSK is a :term:`bytes-like object` representing the pre-"
"shared key. Return a zero length PSK to reject the connection."
msgstr ""
"形参 ``callback`` 是一个签名为 ``def callback(hint: str | None) -> tuple[str | None,"
" bytes]`` 的可调用对象。``hint`` 形参是服务器所发送的可选身份标识。 返回值是一个 (client-identity, psk) "
"形式的元组。 其中 client-identity 是一个可选的字符串，它可被服务器用来为客户选择相应的 PSK。 该字符串在使用 UTF-8 "
"编码时必须小于等于 ``256`` 个八位字节。 PSK 是一个代表预共享密钥的 :term:`bytes-like object`。 返回一个零长度的"
" PSK 以拒绝连接。"

#: ../../library/ssl.rst:2073 ../../library/ssl.rst:2119
msgid "Setting ``callback`` to :const:`None` removes any existing callback."
msgstr "将 ``callback`` 设为 :const:`None` 将移除任何现有的回调。"

#: ../../library/ssl.rst:2076
msgid "When using TLS 1.3:"
msgstr "当使用 TLS 1.3 时："

#: ../../library/ssl.rst:2078
msgid "the ``hint`` parameter is always :const:`None`."
msgstr "``hint`` 形参值将始终为 :const:`None`。"

#: ../../library/ssl.rst:2079
msgid "client-identity must be a non-empty string."
msgstr "client-identity 必须是一个非空字符串。"

#: ../../library/ssl.rst:2081 ../../library/ssl.rst:2128
msgid "Example usage::"
msgstr "用法示例::"

#: ../../library/ssl.rst:2083
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# A table using the hint from the server:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# 一个简单的 lambda：\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# 一个使用来自服务器的提示的表：\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"

#: ../../library/ssl.rst:2101 ../../library/ssl.rst:2146
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_PSK` is "
"``False``."
msgstr "如果 :data:`HAS_PSK` 为 ``False`` 则此方法将引发 :exc:`NotImplementedError`。"

#: ../../library/ssl.rst:2108
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a server-side connection."
msgstr "在服务器端连接上启用 TLS-PSK（预共享密钥验证）。"

#: ../../library/ssl.rst:2112
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(identity: str | None) -> bytes``. The ``identity`` parameter is an "
"optional identity sent by the client which can be used to select a "
"corresponding PSK. The return value is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""
"形参 ``callback`` 是一个签名为 ``def callback(identity: str | None) -> bytes`` "
"的可调用对象。 ``identity`` 形参是客户端所发送的可选身份标识，可用于选择相应的 PSK。 返回值是一个代表预共享密钥的 "
":term:`bytes-like object`。 返回一个零长度的 PSK 以拒绝连接。"

#: ../../library/ssl.rst:2121
msgid ""
"The parameter ``identity_hint`` is an optional identity hint string sent to "
"the client. The string must be less than or equal to ``256`` octets when "
"UTF-8 encoded."
msgstr ""
"形参 ``identity_hint`` 是发送给客户端的可选身份标识字符串。 该字符串在使用 UTF-8 编码时必须小于等于 ``256`` "
"个八位字节。"

#: ../../library/ssl.rst:2126
msgid ""
"When using TLS 1.3 the ``identity_hint`` parameter is not sent to the "
"client."
msgstr "当使用 TLS 1.3 时 ``identity_hint`` 形参将不会被发送给客户端。"

#: ../../library/ssl.rst:2130
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# A table using the identity of the client:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# 一个简单的 lambda：\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# 一个使用客户端标识的表：\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"

#: ../../library/ssl.rst:2158
msgid "Certificates"
msgstr "证书"

#: ../../library/ssl.rst:2160
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the"
" key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that"
" if you encrypt a message with one of the parts, you can decrypt it with the"
" other part, and **only** with the other part."
msgstr ""
"总的来说证书是公钥/私钥系统的一个组成部分。 在这个系统中，每 个 *主体* (可能是一台机器、一个人或者一个组织) "
"都会分配到唯一的包含两部分的加密密钥。 一部分密钥是公开的，称为 *公钥*；另一部分密钥是保密的，称为 *私钥*。 "
"这两个部分是互相关联的，就是说如果你用其中一个部分来加密一条消息，你将能用并且 **只能** 用另一个部分来解密它。"

#: ../../library/ssl.rst:2168
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's"
" statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed"
" as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"在一个证书中包含有两个主体的相关信息。 它包含 *目标方* 的名称和目标方的公钥。 它还包含由第二个主体 *颁发方* "
"所发布的声明：目标方的身份与他们所宣称的一致，包含的公钥也确实是目标方的公钥。 颁发方的声明使用颁发方的私钥进行签名，该私钥的内容只有颁发方自己才知道。"
" 但是，任何人都可以找到颁发方的公钥，用它来解密这个声明，并将其与证书中的其他信息进行比较来验证颁发方声明的真实性。 证书还包含有关其有效期限的信息。 "
"这被表示为两个字段，即 \"notBefore\" 和 \"notAfter\"。"

#: ../../library/ssl.rst:2178
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The"
" connection attempt can be set to raise an exception if the validation "
"fails. Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics.  But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr ""
"在 Python 中应用证书时，客户端或服务器可以用证书来证明自己的身份。 "
"还可以要求网络连接的另一方提供证书，提供的证书可以用于验证以满足客户端或服务器的验证要求。 如果验证失败，连接尝试可被设置为引发一个异常。 "
"验证是由下层的 OpenSSL 框架来自动执行的；应用程序本身不必关注其内部的机制。 但是应用程序通常需要提供一组证书以允许此过程的发生。"

#: ../../library/ssl.rst:2188
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python 使用文件来包含证书。 它们应当采用 \"PEM\" 格式 (参见 :rfc:`1422`)，这是一种带有头部行和尾部行的 base-64 "
"编码包装形式::"

#: ../../library/ssl.rst:2192
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN CERTIFICATE-----\n"
"... (使用 base64 PEM 编码的证书) ...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2197
msgid "Certificate chains"
msgstr "证书链"

#: ../../library/ssl.rst:2199
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the"
" agency which issued the certification authority's certificate::"
msgstr ""
"包含证书的 Python 文件可以包含一系列的证书，有时被称为 *证书链*。 这个证书链应当以 \"作为\" "
"客户端或服务器的主体的专属证书打头，然后是证书颁发方的证书，然后是 *上述* 证书的颁发方的证书，证书链就这样不断上溯直到你得到一个 *自签名* "
"的证书，即具有相同目标方和颁发方的证书，有时也称为 *根证书*。 在证书文件中这些证书应当被拼接为一体。 "
"例如，假设我们有一个包含三个证书的证书链，以我们的服务器证书打头，然后是为我们的服务器证书签名的证书颁发机构的证书，最后是为证书颁发机构的证书颁发证书的机构的根证书::"

#: ../../library/ssl.rst:2212
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN CERTIFICATE-----\n"
"... (你的服务器的证书)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (CA 的证书)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (CA 的颁发者的根证书)...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2223
msgid "CA certificates"
msgstr "CA 证书"

#: ../../library/ssl.rst:2225
msgid ""
"If you are going to require validation of the other side of the connection's"
" certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr ""
"如果你想要求对连接的另一方的证书进行验证，你必须提供一个 \"CA 证书\" 文件，其中包含了你愿意信任的每个颁发方的证书链。 "
"同样地，这个文件的内容就是这些证书链拼接在一起的结果。 为了进行验证，Python 将使用它在文件中找到的第一个匹配的证书链。 可以通过调用 "
":meth:`SSLContext.load_default_certs` 来使用系统平台的证书文件，这可以由 "
":func:`.create_default_context` 自动完成。"

#: ../../library/ssl.rst:2234
msgid "Combined key and certificate"
msgstr "合并的密钥和证书"

#: ../../library/ssl.rst:2236
msgid ""
"Often the private key is stored in the same file as the certificate; in this"
" case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain`"
" needs to be passed.  If the private key is stored with the certificate, it "
"should come before the first certificate in the certificate chain::"
msgstr ""
"私钥往往与证书存储在相同的文件中；在此情况下，只需要将 ``certfile`` 形参传给 "
":meth:`SSLContext.load_cert_chain`。 如果私钥是与证书一起存储的，则它应当放在证书链的第一个证书之前::"

#: ../../library/ssl.rst:2242
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (使用 base64 编码格式的私钥) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (使用 base64 PEM 编码格式的证书) ...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2250
msgid "Self-signed certificates"
msgstr "自签名证书"

#: ../../library/ssl.rst:2252
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from"
" a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"如果你准备创建一个提供 SSL 加密连接服务的服务器，你需要为该服务获取一份证书。 有许多方式可以获取合适的证书，例如从证书颁发机构购买。 "
"另一种常见做法是生成自签名证书。 生成自签名证书的最简单方式是使用 OpenSSL 软件包，代码如下所示::"

#: ../../library/ssl.rst:2259
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"

#: ../../library/ssl.rst:2281
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr "自签名证书的缺点在于它是它自身的根证书，因此不会存在于别人的已知（且信任的）根证书缓存当中。"

#: ../../library/ssl.rst:2287
msgid "Examples"
msgstr "例子"

#: ../../library/ssl.rst:2290
msgid "Testing for SSL support"
msgstr "检测 SSL 支持"

#: ../../library/ssl.rst:2292
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr "要检测一个 Python 安装版中是否带有 SSL 支持，用户代码应当使用以下例程::"

#: ../../library/ssl.rst:2295
msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"
msgstr ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # 执行需要 SSL 支持的操作"

#: ../../library/ssl.rst:2303
msgid "Client-side operation"
msgstr "客户端操作"

#: ../../library/ssl.rst:2305
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr "这个例子创建了一个 SSL 上下文并使用客户端套接字的推荐安全设置，包括自动证书验证::"

#: ../../library/ssl.rst:2308
msgid ">>> context = ssl.create_default_context()"
msgstr ">>> context = ssl.create_default_context()"

#: ../../library/ssl.rst:2310
msgid ""
"If you prefer to tune security settings yourself, you might create a context"
" from scratch (but beware that you might not get the settings right)::"
msgstr "如果你喜欢自行调整安全设置，你可能需要从头创建一个上下文（但是请请注意避免不正确的设置）::"

#: ../../library/ssl.rst:2314
msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"

#: ../../library/ssl.rst:2317
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(这段代码假定你的操作系统将所有 CA 证书打包存放于 ``/etc/ssl/certs/ca-"
"bundle.crt``；如果不是这样，你将收到报错信息，必须修改此位置)"

#: ../../library/ssl.rst:2321
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set"
" to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
":data:`PROTOCOL_TLS_CLIENT` 协议配置用于证书验证和主机名验证的上下文。 "
":attr:`~SSLContext.verify_mode` 设为 :data:`CERT_REQUIRED` 而 "
":attr:`~SSLContext.check_hostname` 设为 ``True``。 所有其他协议都会使用不安全的默认值创建 SSL 上下文。"

#: ../../library/ssl.rst:2326
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and "
":attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"当你使用此上下文去连接服务器时，:const:`CERT_REQUIRED` 和 :attr:`~SSLContext.check_hostname` "
"会验证服务器证书；它将确认服务器证书使用了某个 CA 证书进行签名，检查签名是否正确，并验证其他属性例如主机名的有效性和身份真实性::"

#: ../../library/ssl.rst:2332
msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"
msgstr ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"

#: ../../library/ssl.rst:2336
msgid "You may then fetch the certificate::"
msgstr "你可以随后获取该证书::"

#: ../../library/ssl.rst:2338
msgid ">>> cert = conn.getpeercert()"
msgstr ">>> cert = conn.getpeercert()"

#: ../../library/ssl.rst:2340
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr "可视化检查显示证书能够证明目标服务 (即 HTTPS 主机 ``www.python.org``) 的身份::"

#: ../../library/ssl.rst:2343
msgid ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1.crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1.crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"
msgstr ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1.crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1.crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"

#: ../../library/ssl.rst:2383
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "现在 SSL 通道已建立并已验证了证书，你可以继续与服务器对话了::"

#: ../../library/ssl.rst:2386
msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"
msgstr ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"

#: ../../library/ssl.rst:2410
msgid "Server-side operation"
msgstr "服务器端操作"

#: ../../library/ssl.rst:2412
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"对于服务器操作，通常你需要在文件中存放服务器证书和私钥各一份。 你将首先创建一个包含密钥和证书的上下文，这样客户端就能检查你的身份真实性。 "
"然后你将打开一个套接字，将其绑定到一个端口，在其上调用 :meth:`listen`，并开始等待客户端连接::"

#: ../../library/ssl.rst:2418
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"

#: ../../library/ssl.rst:2427
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket for"
" the connection::"
msgstr ""
"当有客户端连接时，你将在套接字上调用 :meth:`accept` 以从另一端获取新的套接字，并使用上下文的 "
":meth:`SSLContext.wrap_socket` 方法来为连接创建一个服务器端 SSL 套接字::"

#: ../../library/ssl.rst:2431
msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"

#: ../../library/ssl.rst:2440
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr "随后你将从 ``connstream`` 读取数据并对其进行处理，直至你结束与客户端的会话（或客户端结束与你的会话）::"

#: ../../library/ssl.rst:2443
msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # 空数据表明客户端已结束与我们的通信\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # 我们将假定当我们结束与客户端的通信时\n"
"            # do_something 将返回 False\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # 结束与客户端的通信"

#: ../../library/ssl.rst:2454
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or"
" put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"并返回至监听新的客户端连接（当然，真正的服务器应当会在单独的线程中处理每个客户端连接，或者将套接字设为 :ref:`非阻塞模式 <ssl-"
"nonblocking>` 并使用事件循环）。"

#: ../../library/ssl.rst:2462
msgid "Notes on non-blocking sockets"
msgstr "关于非阻塞套接字的说明"

#: ../../library/ssl.rst:2464
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr "在非阻塞模式下 SSL 套接字的行为与常规套接字略有不同。 当使用非阻塞模式时，你需要注意下面这些事情:"

#: ../../library/ssl.rst:2468
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and "
":exc:`SSLWantWriteError` for a write operation on the underlying socket. "
"Note that attempts to *write* to an SSL socket may require *reading* from "
"the underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"如果一个 I/O 操作会阻塞，大多数 :class:`SSLSocket` 方法都将引发 :exc:`SSLWantWriteError` 或 "
":exc:`SSLWantReadError` 而非 :exc:`BlockingIOError`。 如果有必要在下层套接字上执行读取操作将引发 "
":exc:`SSLWantReadError`，在下层套接字上执行写入操作则将引发 :exc:`SSLWantWriteError`。 请注意尝试 "
"*写入* 到 SSL 套接字可能需要先从下层套接字 *读取*，而尝试从 SSL 套接字 *读取* 则可能需要先向下层套接字 *写入*。"

#: ../../library/ssl.rst:2480
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero"
" instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"在较早的 Python 版本中，:meth:`!SSLSocket.send` 方法会返回零值而非引发 :exc:`SSLWantWriteError`"
" 或 :exc:`SSLWantReadError`。"

#: ../../library/ssl.rst:2484
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv`"
" and :meth:`SSLSocket.send` failures, and retry after another call to "
":func:`~select.select`."
msgstr ""
"调用 :func:`~select.select` 将告诉你可以从 OS 层级的套接字读取（或向其写入），但这并不意味着在上面的 SSL "
"层有足够的数据。 例如，可能只有部分 SSL 帧已经到达。 因此，你必须准备好处理 :meth:`SSLSocket.recv` 和 "
":meth:`SSLSocket.send` 失败的情况，并在再次调用 :func:`~select.select` 之后重新尝试。"

#: ../../library/ssl.rst:2491
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any"
" potentially available data, and then only block on a :func:`~select.select`"
" call if still necessary."
msgstr ""
"相反地，由于 SSL 层具有自己的帧机制，一个 SSL 套接字可能仍有可读取的数据而 :func:`~select.select` 并不知道这一点。 "
"因此，你应当先调用 :meth:`SSLSocket.recv` 取走所有潜在的可用数据，然后只在必要时对 :func:`~select.select`"
" 调用执行阻塞。"

#: ../../library/ssl.rst:2497
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(当然，类似的保留规则在使用其他原语例如 :func:`~select.poll`，或 :mod:`selectors` 模块中的原语时也适用)"

#: ../../library/ssl.rst:2500
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait for "
"the socket's readiness::"
msgstr ""
"SSL 握手本身将是非阻塞的: :meth:`SSLSocket.do_handshake` 方法必须不断重试直至其成功返回。 下面是一个使用 "
":func:`~select.select` 来等待套接字就绪的简短例子::"

#: ../../library/ssl.rst:2505
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"
msgstr ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"

#: ../../library/ssl.rst:2516
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level :ref:`Streams API <asyncio-"
"streams>`. It polls for events using the :mod:`selectors` module and handles"
" :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` and "
":exc:`BlockingIOError` exceptions. It runs the SSL handshake asynchronously "
"as well."
msgstr ""
":mod:`asyncio` 模块支持 :ref:`非阻塞 SSL 套接字 <ssl-nonblocking>` 并提供了更高层级的 :ref:`流 "
"API <asyncio-streams>`。 它会使用 :mod:`selectors` 模块来轮询事件并处理 "
":exc:`SSLWantWriteError`, :exc:`SSLWantReadError` 和 :exc:`BlockingIOError` "
"等异常。 它还会异步地执行 SSL 握手。handshake asynchronously as well."

#: ../../library/ssl.rst:2525
msgid "Memory BIO Support"
msgstr "内存 BIO 支持"

#: ../../library/ssl.rst:2529
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the "
":class:`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr "自从 SSL 模块在 Python 2.6 起被引入之后，:class:`SSLSocket` 类提供了两个互相关联但彼此独立的功能分块:"

#: ../../library/ssl.rst:2532
msgid "SSL protocol handling"
msgstr "SSL 协议处理"

#: ../../library/ssl.rst:2533
msgid "Network IO"
msgstr "网络 IO"

#: ../../library/ssl.rst:2535
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be"
" used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"网络 IO API 与 :class:`socket.socket` 所提供的功能一致，:class:`SSLSocket` 也是从那里继承而来的。 "
"这允许 SSL 套接字被用作常规套接字的替代，使得向现有应用程序添加 SSL 支持变得非常容易。"

#: ../../library/ssl.rst:2540
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there"
" are some cases where it doesn't. An example is async IO frameworks that "
"want to use a different IO multiplexing model than the \"select/poll on a "
"file descriptor\" (readiness based) model that is assumed by "
":class:`socket.socket` and by the internal OpenSSL socket IO routines. This "
"is mostly relevant for platforms like Windows where this model is not "
"efficient. For this purpose, a reduced scope variant of :class:`SSLSocket` "
"called :class:`SSLObject` is provided."
msgstr ""
"将 SSL 协议处理与网络 IO 结合使用通常都能运行良好，但在某些情况下则不能。 此情况的一个例子是 async IO 框架，该框架要使用不同的 IO"
" 多路复用模型而非 (基于就绪状态的) \"在文件描述器上执行选择/轮询\" 模型，该模型是 :class:`socket.socket` 和内部 "
"OpenSSL 套接字 IO 例程正常运行的假设前提。 这种情况在该模型效率不高的 Windows 平台上最为常见。 为此还提供了一个 "
":class:`SSLSocket` 的简化形式，称为 :class:`SSLObject`。"

#: ../../library/ssl.rst:2551
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
":class:`SSLSocket` 的简化形式，表示一个不包含任何网络 IO 方法的 SSL 协议实例。 这个类通常由想要通过内存缓冲区为 SSL "
"实现异步 IO 的框架作者来使用。"

#: ../../library/ssl.rst:2556
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through"
" separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"这个类在低层级 SSL 对象上实现了一个接口，与 OpenSSL 所实现的类似。 此对象会捕获 SSL 连接的状态但其本身不提供任何网络 IO。 IO "
"需要通过单独的 \"BIO\" 对象来执行，该对象是 OpenSSL 的 IO 抽象层。"

#: ../../library/ssl.rst:2561
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way "
"around."
msgstr ""
"这个类没有公有构造器。 :class:`SSLObject` 实例必须使用 :meth:`~SSLContext.wrap_bio` 方法来创建。 "
"此方法将创建 :class:`SSLObject` 实例并将其绑定到一个 BIO 对。 其中 *incoming* BIO 用来将数据从 Python "
"传递到 SSL 协议实例，而 *outgoing* BIO 用来进行数据反向传递。"

#: ../../library/ssl.rst:2568
msgid "The following methods are available:"
msgstr "可以使用以下方法："

#: ../../library/ssl.rst:2570
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2571
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2572
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2573
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2574
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2575
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2576
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2577
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2578
msgid ":meth:`~SSLSocket.get_verified_chain`"
msgstr ":meth:`~SSLSocket.get_verified_chain`"

#: ../../library/ssl.rst:2579
msgid ":meth:`~SSLSocket.get_unverified_chain`"
msgstr ":meth:`~SSLSocket.get_unverified_chain`"

#: ../../library/ssl.rst:2580
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2581
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2582
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2583
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2584
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2585
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2586
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2587
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2588
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2589
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2590
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2592
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr "与 :class:`SSLSocket` 相比，此对象缺少下列特性:"

#: ../../library/ssl.rst:2595
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the"
" underlying :class:`MemoryBIO` buffers."
msgstr ""
"任何形式的网络 IO; ``recv()`` 和 ``send()`` 仅对下层的 :class:`MemoryBIO` 缓冲区执行读取和写入。"

#: ../../library/ssl.rst:2598
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"不存在 *do_handshake_on_connect* 机制。 你必须总是手动调用 :meth:`~SSLSocket.do_handshake` "
"来开始握手操作。"

#: ../../library/ssl.rst:2601
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the "
":exc:`SSLEOFError` exception."
msgstr ""
"不存在对 *suppress_ragged_eofs* 的处理。 所有违反协议的文件结束条件将通过 :exc:`SSLEOFError` 异常来报告。"

#: ../../library/ssl.rst:2605
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr "方法 :meth:`~SSLSocket.unwrap` 的调用不返回任何东西，不会如 SSL 套接字那样返回下层的套接字。"

#: ../../library/ssl.rst:2608
msgid ""
"The *server_name_callback* callback passed to "
":meth:`SSLContext.set_servername_callback` will get an :class:`SSLObject` "
"instance instead of a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"*server_name_callback* 回调被传给 :meth:`SSLContext.set_servername_callback` "
"时将获得一个 :class:`SSLObject` 实例而非 :class:`SSLSocket` 实例作为其第一个形参。"

#: ../../library/ssl.rst:2612
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "有关 :class:`SSLObject` 用法的一些说明:"

#: ../../library/ssl.rst:2614
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an "
":exc:`SSLWantReadError` if it needs more data than the incoming BIO has "
"available."
msgstr ""
"在 :class:`SSLObject` 上的所有 IO 都是 :ref:`非阻塞的 <ssl-nonblocking>`。 这意味着例如 "
":meth:`~SSLSocket.read` 在其需要比 incoming BIO 可用的更多数据时将会引发 "
":exc:`SSLWantReadError`。"

#: ../../library/ssl.rst:2619
msgid ""
":class:`SSLObject` instances must be created with "
":meth:`~SSLContext.wrap_bio`. In earlier versions, it was possible to create"
" instances directly. This was never documented or officially supported."
msgstr ""
":class:`SSLObject` 的实例必须使用 :meth:`~SSLContext.wrap_bio` 来创建。 "
"在较早的版本中，直接创建该实例是可能的。 但这从未被写入文档或是被正式支持。"

#: ../../library/ssl.rst:2625
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject 会使用内存缓冲区与外部世界通信。 :class:`MemoryBIO` 类提供了可被用于此目的的内存缓冲区。 它包装了一个 "
"OpenSSL 内存 BIO (Basic IO) 对象:"

#: ../../library/ssl.rst:2631
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr "一个可被用来在 Python 和 SSL 协议实例之间传递数据的内存缓冲区。"

#: ../../library/ssl.rst:2636
msgid "Return the number of bytes currently in the memory buffer."
msgstr "返回当前存在于内存缓冲区的字节数。"

#: ../../library/ssl.rst:2640
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr "一个表明内存 BIO 目前是否位于文件末尾的布尔值。"

#: ../../library/ssl.rst:2645
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr "从内存缓冲区读取至多 *n* 个字节。 如果 *n* 未指定或为负值，则返回全部字节数据。"

#: ../../library/ssl.rst:2650
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr "将字节数据从 *buf* 写入到内存 BIO。 *buf* 参数必须为支持缓冲区协议的对象。"

#: ../../library/ssl.rst:2653
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr "返回值为写入的字节数，它总是与 *buf* 的长度相等。"

#: ../../library/ssl.rst:2658
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it"
" is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will"
" become true after all data currently in the buffer has been read."
msgstr ""
"将一个 EOF 标记写入到内存 BIO。 在此方法被调用以后，再调用 :meth:`~MemoryBIO.write` 将是非法的。 属性 "
":attr:`eof` will 在缓冲区当前的所有数据都被读取之后将变为真值。"

#: ../../library/ssl.rst:2664
msgid "SSL session"
msgstr "SSL 会话"

#: ../../library/ssl.rst:2670
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ":attr:`~SSLSocket.session` 所使用的会话对象。"

#: ../../library/ssl.rst:2682
msgid "Security considerations"
msgstr "安全考量"

#: ../../library/ssl.rst:2685
msgid "Best defaults"
msgstr "最佳默认值"

#: ../../library/ssl.rst:2687
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It will "
"load the system's trusted CA certificates, enable certificate validation and"
" hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"针对 **客户端使用**，如果你对于安全策略没有任何特殊要求，则强烈推荐你使用 :func:`create_default_context` "
"函数来创建你的 SSL 上下文。 它将加载系统的受信任 CA 证书，启用证书验证和主机名检查，并尝试合理地选择安全的协议和密码设置。"

#: ../../library/ssl.rst:2694
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr "例如，以下演示了你应当如何使用 :class:`smtplib.SMTP` 类来创建指向一个 SMTP 服务器的受信任且安全的连接::"

#: ../../library/ssl.rst:2697
msgid ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"
msgstr ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"

#: ../../library/ssl.rst:2703
msgid ""
"If a client certificate is needed for the connection, it can be added with "
":meth:`SSLContext.load_cert_chain`."
msgstr "如果连接需要客户端证书，可使用 :meth:`SSLContext.load_cert_chain` 来添加。"

#: ../../library/ssl.rst:2706
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, please "
"read the paragraphs below to achieve a good security level."
msgstr ""
"作为对比，如果你通过自行调用 :class:`SSLContext` 构造器来创建 SSL 上下文，它默认将不会启用证书验证和主机名检查。 "
"如果你这样做，请阅读下面的段落以达到良好的安全级别。"

#: ../../library/ssl.rst:2712
msgid "Manual settings"
msgstr "手动设置"

#: ../../library/ssl.rst:2715
msgid "Verifying certificates"
msgstr "验证证书"

#: ../../library/ssl.rst:2717
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the other"
" peer, it can be insecure, especially in client mode where most of the time "
"you would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use "
":const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you also "
"have to check that the server certificate, which can be obtained by calling "
":meth:`SSLSocket.getpeercert`, matches the desired service.  For many "
"protocols and applications, the service can be identified by the hostname. "
"This common check is automatically performed when "
":attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"当直接调用 :class:`SSLContext` 构造器时，默认值为 :const:`CERT_NONE`。 "
"由于它不会验证对端的身份，因而是不安全的，特别是在大部分时间里你都希望能确保与你通信的服务器的可靠性的客户端模式下。 "
"为此，当在客户端模式下，强烈建议使用 :const:`CERT_REQUIRED`。 但是，仅靠它本身是不够的；你还必须检查服务器证书，它可通过调用 "
":meth:`SSLSocket.getpeercert` 来获取，确定它与目标服务相匹配。 对于许多协议和应用程序来说，服务可通过主机名来进行标识。 "
"这种通用检查会在 :attr:`SSLContext.check_hostname` 已启用时自动执行。"

#: ../../library/ssl.rst:2729
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses "
":func:`match_hostname`."
msgstr "主机名匹配现在是由 OpenSSL 来执行的。 Python 不会再使用 :func:`match_hostname`。"

#: ../../library/ssl.rst:2733
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer"
" (rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"在服务器模式下，如果你想要使用 SSL 层来验证客户端（而不是使用更高层级的验证机制），你也必须要指定 :const:`CERT_REQUIRED` "
"并以类似方式检查客户端证书。"

#: ../../library/ssl.rst:2739
msgid "Protocol versions"
msgstr "协议版本"

#: ../../library/ssl.rst:2741
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or "
":const:`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are "
"disabled by default."
msgstr ""
"SSL 版本 2 和 3 被认为是不安全的因而使用它们会有风险。 如果你想要客户端和服务器之间有最大的兼容性，推荐使用 "
":const:`PROTOCOL_TLS_CLIENT` 或 :const:`PROTOCOL_TLS_SERVER` 作为协议版本。 SSLv2 和 "
"SSLv3 默认会被禁用。"

#: ../../library/ssl.rst:2749
msgid ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"
msgstr ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"

#: ../../library/ssl.rst:2754
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. "
":const:`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname "
"checks by default. You have to load certificates into the context."
msgstr ""
"上面创建的 SSL 上下文将只允许与服务器进行 TLSv1.3 及更高版本（如果你的系统支持）的连接。 在默认情况下 "
":const:`PROTOCOL_TLS_CLIENT` 将使用证书验证和主机名检查。 你必须将证书加载到上下文中。"

#: ../../library/ssl.rst:2761
msgid "Cipher selection"
msgstr "密码选择"

#: ../../library/ssl.rst:2763
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl "
"module disables certain weak ciphers by default, but you may want to further"
" restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format "
"<https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-list-format>`_. If you "
"want to check which ciphers are enabled by a given cipher list, use "
":meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` command on your "
"system."
msgstr ""
"如果你有更高级的安全要求，也可通过 :meth:`SSLContext.set_ciphers` 方法在协商 SSL 会话时对启用的加密进行微调。 从 "
"Python 3.2.3 开始，ssl 模块默认禁用了某些较弱的加密，但你还可能希望进一步限制加密选项。 请确保仔细阅读有关 `加密列表格式 "
"<https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-list-format>`_ 的 "
"OpenSSL 文档。 如果你想要检查给定的加密列表启用了哪些加密，可以使用 :meth:`SSLContext.get_ciphers` "
"或你所用系统的 ``openssl ciphers`` 命令。"

#: ../../library/ssl.rst:2774
msgid "Multi-processing"
msgstr "多进程"

#: ../../library/ssl.rst:2776
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be"
" aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add` or :func:`~ssl.RAND_bytes` is "
"sufficient."
msgstr ""
"如果使用此模块作为多进程应用的一部分（例如，使用 :mod:`multiprocessing` 或 :mod:`concurrent.futures` "
"模块），请注意 OpenSSL 的内部随机数字生成器并不能正确处理分叉的进程。 应用程序必须修改父进程的 PRNG 状态，如果它们要使用任何包含 "
":func:`os.fork` 的 SSL 特征的话。 任何对 :func:`~ssl.RAND_add` 或 "
":func:`~ssl.RAND_bytes` 的成功调用都可以做到这一点。"

#: ../../library/ssl.rst:2788
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2792
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr "TLS 1.3 协议的行为与低版本的 TLS/SSL 略有不同。某些 TLS 1.3 新特性还不可用。"

#: ../../library/ssl.rst:2795
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method "
":meth:`SSLContext.set_ciphers` cannot enable or disable any TLS 1.3 ciphers "
"yet, but :meth:`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 使用一组不同的加密套件集。 默认情况下所有 AES-GCM 和 ChaCha20 加密套件都会被启用。 "
":meth:`SSLContext.set_ciphers` 方法还不能启用或禁用任何 TLS 1.3 加密，但 "
":meth:`SSLContext.get_ciphers` 会返回它们。"

#: ../../library/ssl.rst:2799
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"会话凭据不再会作为初始握手的组成部分被发送而是以不同的方式来处理。 :attr:`SSLSocket.session` 和 "
":class:`SSLSession` 与 TLS 1.3 不兼容。"

#: ../../library/ssl.rst:2802
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process"
" certificate requests while they send or receive application data from the "
"server."
msgstr "客户端证书在初始握手期间也不会再被验证。 服务器可以在任何时候请求证书。 客户端会在它们从服务器发送或接收应用数据时处理证书请求。"

#: ../../library/ssl.rst:2806
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr "早期数据、延迟的 TLS 客户端证书请求、签名算法配置和密钥重生成等 TLS 1.3 特性尚未被支持。"

#: ../../library/ssl.rst:2812
msgid "Class :class:`socket.socket`"
msgstr "Class :class:`socket.socket`"

#: ../../library/ssl.rst:2813
msgid "Documentation of underlying :mod:`socket` class"
msgstr "下层 :mod:`socket` 类的文档"

#: ../../library/ssl.rst:2815
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS 高强度加密：概述 "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2816
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Apache HTTP Server文档介绍"

#: ../../library/ssl.rst:2818
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ":rfc:`RFC 1422: 因特网电子邮件的隐私加强：第二部分：基于证书的密钥管理 <1422>`"

#: ../../library/ssl.rst:2819
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2821
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: 确保安全的随机性要求 <4086>`"

#: ../../library/ssl.rst:2822
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2824
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ":rfc:`RFC 5280: 互联网 X.509 公钥基础架构证书和证书吊销列表 (CRL) 配置文件 <5280>`"

#: ../../library/ssl.rst:2825
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2827
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ":rfc:`RFC 5246: 传输层安全性 (TLS) 协议版本 1.2 <5246>`"

#: ../../library/ssl.rst:2828
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2830
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: 传输层安全性 (TLS) 的扩展 <6066>`"

#: ../../library/ssl.rst:2831
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2833
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: 传输层安全性 (TLS) 的参数 <https://www.iana.org/assignments/tls-"
"parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2834
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2836
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ":rfc:`RFC 7525: 传输层安全性 (TLS) 和数据报传输层安全性 (DTLS) 的安全使用建议 <7525>`"

#: ../../library/ssl.rst:2837
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2839
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr ""
"`Mozilla 的服务器端 TLS 建议 <https://wiki.mozilla.org/Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2840
msgid "Mozilla"
msgstr "Mozilla"

#: ../../library/ssl.rst:12
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr "(在 ssl 模块中使用)"

#: ../../library/ssl.rst:14
msgid "TLS"
msgstr "TLS"

#: ../../library/ssl.rst:14
msgid "SSL"
msgstr "SSL"

#: ../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr "Transport Layer Security"

#: ../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr "Secure Sockets Layer"

#: ../../library/ssl.rst:2151
msgid "certificates"
msgstr "certificates"

#: ../../library/ssl.rst:2153
msgid "X509 certificate"
msgstr "X509 证书"
