# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/__main__.rst:2
msgid ":mod:`!__main__` --- Top-level code environment"
msgstr ":mod:`!__main__` --- 最高层级代码环境"

#: ../../library/__main__.rst:10
msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr "Python 的特殊名 ``__main__`` 用于两个重要的构造："

#: ../../library/__main__.rst:12
msgid ""
"the name of the top-level environment of the program, which can be checked "
"using the ``__name__ == '__main__'`` expression; and"
msgstr "程序的顶层环境的名称，可用表达式 ``__name__ == '__main__'`` 来检查；以及"

#: ../../library/__main__.rst:14
msgid "the ``__main__.py`` file in Python packages."
msgstr "Python 包中的文件 ``__main__.py``。"

#: ../../library/__main__.rst:16
msgid ""
"Both of these mechanisms are related to Python modules; how users interact "
"with them and how they interact with each other.  They are explained in "
"detail below.  If you're new to Python modules, see the tutorial section "
":ref:`tut-modules` for an introduction."
msgstr ""
"这两个机制都与 Python 模块相关——用户与它们如何交互，及它们之间如何交互——下文详述。而教程的 :ref:`tut-modules` "
"一节则为初学者介绍了 Python 模块。"

#: ../../library/__main__.rst:25
msgid "``__name__ == '__main__'``"
msgstr "``__name__ == '__main__'``"

#: ../../library/__main__.rst:27
msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself without "
"the ``.py`` extension::"
msgstr ""
"当一个 Python 模块或包被导入时，``__name__`` 被设为模块的名称——通常为 Python 文件本身的名称去掉 ``.py`` 后缀："

#: ../../library/__main__.rst:31
msgid ""
">>> import configparser\n"
">>> configparser.__name__\n"
"'configparser'"
msgstr ""
">>> import configparser\n"
">>> configparser.__name__\n"
"'configparser'"

#: ../../library/__main__.rst:35
msgid ""
"If the file is part of a package, ``__name__`` will also include the parent "
"package's path::"
msgstr "如果文件是包的一部分，则 ``__name__`` 还将包括父包的路径："

#: ../../library/__main__.rst:38
msgid ""
">>> from concurrent.futures import process\n"
">>> process.__name__\n"
"'concurrent.futures.process'"
msgstr ""
">>> from concurrent.futures import process\n"
">>> process.__name__\n"
"'concurrent.futures.process'"

#: ../../library/__main__.rst:42
msgid ""
"However, if the module is executed in the top-level code environment, its "
"``__name__`` is set to the string ``'__main__'``."
msgstr "而若模块是在顶层代码环境中执行的，则其 ``__name__`` 被设为字符串 ``'__main__'``。"

#: ../../library/__main__.rst:46
msgid "What is the \"top-level code environment\"?"
msgstr "什么是“顶层代码环境”？"

#: ../../library/__main__.rst:48
msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the "
"program needs. Sometimes \"top-level code\" is called an *entry point* to "
"the application."
msgstr ""
"``__main__`` 是顶层代码运行环境的名称。“顶层代码”是指由用户指定的最先开始运行的那一个 Python "
"模块。之所以它是“顶层”，是因为它将导入程序所需的所有其它模块。有时“顶层代码”被称为应用程序的 *入口点*。"

#: ../../library/__main__.rst:53
msgid "The top-level code environment can be:"
msgstr "顶层代码环境可以是："

#: ../../library/__main__.rst:55
msgid "the scope of an interactive prompt::"
msgstr "交互提示符的作用域："

#: ../../library/__main__.rst:57
msgid ""
">>> __name__\n"
"'__main__'"
msgstr ""
">>> __name__\n"
"'__main__'"

#: ../../library/__main__.rst:60
msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr "作为文件参数传给 Python 解释器的 Python 模块："

#: ../../library/__main__.rst:62
msgid ""
"$ python helloworld.py\n"
"Hello, world!"
msgstr ""
"$ python helloworld.py\n"
"Hello, world!"

#: ../../library/__main__.rst:67
msgid ""
"the Python module or package passed to the Python interpreter with the "
":option:`-m` argument:"
msgstr "与 :option:`-m` 一起传给 Python 解释器的 Python 模块或包："

#: ../../library/__main__.rst:70
msgid ""
"$ python -m tarfile\n"
"usage: tarfile.py [-h] [-v] (...)"
msgstr ""
"$ python -m tarfile\n"
"usage: tarfile.py [-h] [-v] (...)"

#: ../../library/__main__.rst:75
msgid "Python code read by the Python interpreter from standard input:"
msgstr "Python 解释器从标准输入中读取的 Python 代码："

#: ../../library/__main__.rst:77
msgid ""
"$ echo \"import this\" | python\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."
msgstr ""
"$ echo \"import this\" | python\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."

#: ../../library/__main__.rst:86
msgid ""
"Python code passed to the Python interpreter with the :option:`-c` argument:"
msgstr "与 :option:`-c` 一起传给 Python 解释器的 Python 代码："

#: ../../library/__main__.rst:88
msgid ""
"$ python -c \"import this\"\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."
msgstr ""
"$ python -c \"import this\"\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."

#: ../../library/__main__.rst:97
msgid ""
"In each of these situations, the top-level module's ``__name__`` is set to "
"``'__main__'``."
msgstr "上述每种情况中的顶层模块的 ``__name__`` 被设为 ``'__main__'``。"

#: ../../library/__main__.rst:100
msgid ""
"As a result, a module can discover whether or not it is running in the top-"
"level environment by checking its own ``__name__``, which allows a common "
"idiom for conditionally executing code when the module is not initialized "
"from an import statement::"
msgstr "作为结果，模块通过检查自己的 ``__name__`` 可发现自己是否运行于顶层环境，使一些代码仅当模块不是被导入语句初始化的时候才执行："

#: ../../library/__main__.rst:105
msgid ""
"if __name__ == '__main__':\n"
"    # Execute when the module is not initialized from an import statement.\n"
"    ..."
msgstr ""
"if __name__ == '__main__':\n"
"    # 将在模块不是由于 import 语句被初始化的情况下执行。\n"
"    ..."

#: ../../library/__main__.rst:111
msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, see "
"the tutorial section :ref:`tut-modules`."
msgstr "关于在所有情况下 ``__name__`` 是被如何设置的，详见教程的 :ref:`tut-modules` 一节。"

#: ../../library/__main__.rst:116 ../../library/__main__.rst:239
msgid "Idiomatic Usage"
msgstr "惯用法"

#: ../../library/__main__.rst:118
msgid ""
"Some modules contain code that is intended for script use only, like parsing"
" command-line arguments or fetching data from standard input.  If a module "
"like this was imported from a different module, for example to unit test it,"
" the script code would unintentionally execute as well."
msgstr ""
"有些模块包含了仅供脚本使用的代码，比如解析命令行参数或从标准输入获取数据。 "
"如果这样的模块被从不同的模块中导入，例如为了单元测试，脚本代码也会无意中执行。"

#: ../../library/__main__.rst:123
msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in "
"handy. Code within this block won't run unless the module is executed in the"
" top-level environment."
msgstr ""
"这就是 ``if __name__ == '__main__'`` 代码块的用武之地。除非模块在顶层环境中被执行，否则该块内的代码不会运行。"

#: ../../library/__main__.rst:127
msgid ""
"Putting as few statements as possible in the block below ``if __name__ == "
"'__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""
"将尽可能少的语句放在位于 ``if __name__ == '__main__'`` 之下的代码块中可以提高代码的清晰度和准确度。 通常，将由一个名为 "
"``main`` 的函数来封装程序的主要行为::"

#: ../../library/__main__.rst:131
msgid ""
"# echo.py\n"
"\n"
"import shlex\n"
"import sys\n"
"\n"
"def echo(phrase: str) -> None:\n"
"   \"\"\"A dummy wrapper around print.\"\"\"\n"
"   # for demonstration purposes, you can imagine that there is some\n"
"   # valuable and reusable logic inside this function\n"
"   print(phrase)\n"
"\n"
"def main() -> int:\n"
"    \"\"\"Echo the input arguments to standard output\"\"\"\n"
"    phrase = shlex.join(sys.argv)\n"
"    echo(phrase)\n"
"    return 0\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())  # next section explains the use of sys.exit"
msgstr ""
"# echo.py\n"
"\n"
"import shlex\n"
"import sys\n"
"\n"
"def echo(phrase: str) -> None:\n"
"   \"\"\"一个对 print 的简单包装器。\"\"\"\n"
"   # 出于演示目的，你可以想象在此函数内部\n"
"   # 存在有价值且可重用的逻辑\n"
"   print(phrase)\n"
"\n"
"def main() -> int:\n"
"    \"\"\"将输入参数回显到标准输出\"\"\"\n"
"    phrase = shlex.join(sys.argv)\n"
"    echo(phrase)\n"
"    return 0\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())  # 下一节将讲解 sys.exit 的使用"

#: ../../library/__main__.rst:151
msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` function"
" but instead put it directly within the ``if __name__ == '__main__'`` block,"
" the ``phrase`` variable would be global to the entire module.  This is "
"error-prone as other functions within the module could be unintentionally "
"using the global variable instead of a local name.  A ``main`` function "
"solves this problem."
msgstr ""
"请注意，如果模块没有将代码封装在 ``main`` 函数内，而是直接放在 ``if __name__ == '__main__'`` 块内，那么这个 "
"``phrase`` 变量对整个模块来说就是全局变量。 这很容易出错，因为模块内的其他函数可能会无意中使用全局变量而不是局部名称。 一个 "
"``main`` 函数解决了这个问题。"

#: ../../library/__main__.rst:158
msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but neither "
"of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"使用 ``main`` 函数有一个额外的好处，就是 ``echo`` 函数本身是孤立的，可以在其他地方导入。当 ``echo.py`` "
"被导入时，``echo`` 和 ``main`` 函数将被定义，但它们都不会被调用，因为 ``__name__ != '__main__'`` 。"

#: ../../library/__main__.rst:165
msgid "Packaging Considerations"
msgstr "打包考量"

#: ../../library/__main__.rst:167
msgid ""
"``main`` functions are often used to create command-line tools by specifying"
" them as entry points for console scripts.  When this is done, `pip "
"<https://pip.pypa.io/>`_ inserts the function call into a template script, "
"where the return value of ``main`` is passed into :func:`sys.exit`. For "
"example::"
msgstr ""
"``main`` 函数经常被用来创建命令行工具，把它们指定为控制台脚本的入口点。 当这样做时，`pip <https://pip.pypa.io/>`_"
" 将函数调用插入到模板脚本中，其中 ``main`` 的返回值被传递到 :func:`sys.exit` 。例如::"

#: ../../library/__main__.rst:173
msgid "sys.exit(main())"
msgstr "sys.exit(main())"

#: ../../library/__main__.rst:175
msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the expectation "
"is that your function will return some value acceptable as an input to "
":func:`sys.exit`; typically, an integer or ``None`` (which is implicitly "
"returned if your function does not have a return statement)."
msgstr ""
"由于 ``main`` 调用被包裹在 :func:`sys.exit` 中，期望你的函数将返回一些可被 :func:`sys.exit` "
"作为输入而接受的值；通常为一个整数或 ``None`` （如果你的函数没有返回语句，则隐含返回）。"

#: ../../library/__main__.rst:180
msgid ""
"By proactively following this convention ourselves, our module will have the"
" same behavior when run directly (i.e. ``python echo.py``) as it will have "
"if we later package it as a console script entry-point in a pip-installable "
"package."
msgstr ""
"通过主动遵循这一惯例，我们的模块在直接运行时 (即 ``python echo.py``) 会有相同的行为，当我们以后把它打包成可用 pip "
"安装的软件包的控制台脚本入口时也会如此。"

#: ../../library/__main__.rst:185
msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The "
"``echo.py`` example from earlier exemplifies using the ``sys.exit(main())`` "
"convention."
msgstr ""
"特别的是，要小心从你的 ``main`` 函数中返回字符串。 :func:`sys.exit` 将把一个字符串参数解释为失败信息，所以你的程序将有一个 "
"``1`` 的退出代码，表示失败。并且这个字符串将被写入 :data:`sys.stderr` 。 前面的 ``echo.py`` 例子举例说明了使用 "
"``sys.exit(main())`` 的约定。"

#: ../../library/__main__.rst:193
msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a "
"collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""
"`Python 打包用户指南 <https://packaging.python.org/>`_ 包含了一系列关于如何用现代工具分发和安装 Python"
" 包的教程和参考资料。"

#: ../../library/__main__.rst:199
msgid "``__main__.py`` in Python Packages"
msgstr "Python 包中的 ``__main__.py``"

#: ../../library/__main__.rst:201
msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is used "
"to provide a command-line interface for a package. Consider the following "
"hypothetical package, \"bandclass\":"
msgstr ""
"如果你不熟悉Python包，请参阅本教程的 :ref:`tut-packages` 一节。最常见的是， ``__main__.py`` "
"文件被用来为一个包提供命令行接口。假设有下面这个虚构的包，\"bandclass\":"

#: ../../library/__main__.rst:206
msgid ""
"bandclass\n"
"  ├── __init__.py\n"
"  ├── __main__.py\n"
"  └── student.py"
msgstr ""
"bandclass\n"
"  ├── __init__.py\n"
"  ├── __main__.py\n"
"  └── student.py"

#: ../../library/__main__.rst:213
msgid ""
"``__main__.py`` will be executed when the package itself is invoked directly"
" from the command line using the :option:`-m` flag. For example:"
msgstr "当使用 :option:`-m` 标志从命令行直接调用软件包本身时，将执行 ``__main__.py`` 。比如说。"

#: ../../library/__main__.rst:216
msgid "$ python -m bandclass"
msgstr "$ python -m bandclass"

#: ../../library/__main__.rst:220
msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but in "
"this hypothetical case, it might make sense to allow the teacher to search "
"for students::"
msgstr ""
"这个命令将导致 ``__main__.py`` "
"的运行。你如何利用这一机制将取决于你所编写的软件包的性质，但在这个假设的案例中，允许教师搜索学生可能是有意义的::"

#: ../../library/__main__.rst:225
msgid ""
"# bandclass/__main__.py\n"
"\n"
"import sys\n"
"from .student import search_students\n"
"\n"
"student_name = sys.argv[1] if len(sys.argv) >= 2 else ''\n"
"print(f'Found student: {search_students(student_name)}')"
msgstr ""
"# bandclass/__main__.py\n"
"\n"
"import sys\n"
"from .student import search_students\n"
"\n"
"student_name = sys.argv[1] if len(sys.argv) >= 2 else ''\n"
"print(f'Found student: {search_students(student_name)}')"

#: ../../library/__main__.rst:233
msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` in "
"the :ref:`tut-modules` section of the tutorial."
msgstr ""
"注意， ``from .student import search_students`` 是一个相对导入的例子。 "
"这种导入方式可以在引用一个包内的模块时使用。 更多细节，请参见教程 :ref:`tut-modules` 中的 :ref:`intra-package-"
"references` 一节。"

#: ../../library/__main__.rst:241
msgid ""
"The content of ``__main__.py`` typically isn't fenced with an ``if __name__ "
"== '__main__'`` block.  Instead, those files are kept short and import "
"functions to execute from other modules.  Those other modules can then be "
"easily unit-tested and are properly reusable."
msgstr ""
"``__main__.py`` 的内容通常不会用 ``if __name__ == '__main__'`` 块围起来。 "
"相反，这些文件会保持简短并从其他模块导入函数来执行。 这样其他模块就可以很容易地进行单元测试并可以适当地重用。"

#: ../../library/__main__.rst:246
msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as expected "
"for a ``__main__.py`` file within a package, because its ``__name__`` "
"attribute will include the package's path if imported::"
msgstr ""
"如果使用，一个 ``if __name__ == '__main__'`` 区块仍然会像预期的那样对包内的 ``__main__.py`` "
"文件起作用，因为如果导入，它的 ``__name__`` 属性将包括包的路径::"

#: ../../library/__main__.rst:250
msgid ""
">>> import asyncio.__main__\n"
">>> asyncio.__main__.__name__\n"
"'asyncio.__main__'"
msgstr ""
">>> import asyncio.__main__\n"
">>> asyncio.__main__.__name__\n"
"'asyncio.__main__'"

#: ../../library/__main__.rst:254
msgid ""
"This won't work for ``__main__.py`` files in the root directory of a "
"``.zip`` file though.  Hence, for consistency, a minimal ``__main__.py`` "
"without a ``__name__`` check is preferred."
msgstr ""
"但这对 ``.zip`` 文件的根目录中的 ``__main__.py`` 文件不起作用。 因此，为了保持一致性，建议使用不带 ``__name__``"
" 检测的最小化 ``__main__.py``。"

#: ../../library/__main__.rst:260
msgid ""
"See :mod:`venv` for an example of a package with a minimal ``__main__.py`` "
"in the standard library. It doesn't contain a ``if __name__ == '__main__'`` "
"block. You can invoke it with ``python -m venv [directory]``."
msgstr ""
"请参阅 :mod:`venv` 以获取标准库中具有最小化 ``__main__.py`` 的软件包示例。 它不包含 ``if __name__ == "
"'__main__'`` 代码块。 你可以用 ``python -m venv [directory]`` 来唤起。"

#: ../../library/__main__.rst:264
msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr "参见 :mod:`runpy` 以了解更多关于 :option:`-m` 标志对解释器可执行包的细节。"

#: ../../library/__main__.rst:267
msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. In "
"this case Python looks for a ``__main__.py`` file in the root directory of "
"the archive."
msgstr ""
"参见 :mod:`zipapp` 了解如何运行打包成 *.zip* 文件的应用程序。在这种情况下，Python 会在归档文件的根目录下寻找一个 "
"``__main__.py`` 文件。"

#: ../../library/__main__.rst:274
msgid "``import __main__``"
msgstr "``import __main__``"

#: ../../library/__main__.rst:276
msgid ""
"Regardless of which module a Python program was started with, other modules "
"running within that same program can import the top-level environment's "
"scope (:term:`namespace`) by importing the ``__main__`` module.  This "
"doesn't import a ``__main__.py`` file but rather whichever module that "
"received the special name ``'__main__'``."
msgstr ""
"不管 Python 程序是用哪个模块启动的，在同一程序中运行的其他模块可以通过导入 ``__main__`` 模块来导入顶级环境的范围 ( "
":term:`namespace` )。这并不是导入一个 ``__main__.py`` 文件，而是导入使用特殊名称 ``'__main__'`` "
"的哪个模块。"

#: ../../library/__main__.rst:282
msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr "下面是一个使用 ``__main__`` 命名空间的模块的例子::"

#: ../../library/__main__.rst:284
msgid ""
"# namely.py\n"
"\n"
"import __main__\n"
"\n"
"def did_user_define_their_name():\n"
"    return 'my_name' in dir(__main__)\n"
"\n"
"def print_user_name():\n"
"    if not did_user_define_their_name():\n"
"        raise ValueError('Define the variable `my_name`!')\n"
"\n"
"    print(__main__.my_name)"
msgstr ""
"# namely.py\n"
"\n"
"import __main__\n"
"\n"
"def did_user_define_their_name():\n"
"    return 'my_name' in dir(__main__)\n"
"\n"
"def print_user_name():\n"
"    if not did_user_define_their_name():\n"
"        raise ValueError('Define the variable `my_name`!')\n"
"\n"
"    print(__main__.my_name)"

#: ../../library/__main__.rst:297
msgid "Example usage of this module could be as follows::"
msgstr "该模块的用法示例如下::"

#: ../../library/__main__.rst:299
msgid ""
"# start.py\n"
"\n"
"import sys\n"
"\n"
"from namely import print_user_name\n"
"\n"
"# my_name = \"Dinsdale\"\n"
"\n"
"def main():\n"
"    try:\n"
"        print_user_name()\n"
"    except ValueError as ve:\n"
"        return str(ve)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    sys.exit(main())"
msgstr ""
"# start.py\n"
"\n"
"import sys\n"
"\n"
"from namely import print_user_name\n"
"\n"
"# my_name = \"Dinsdale\"\n"
"\n"
"def main():\n"
"    try:\n"
"        print_user_name()\n"
"    except ValueError as ve:\n"
"        return str(ve)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    sys.exit(main())"

#: ../../library/__main__.rst:316
msgid "Now, if we started our program, the result would look like this:"
msgstr "现在，如果我们启动我们的程序，结果会是这样的:"

#: ../../library/__main__.rst:318
msgid ""
"$ python start.py\n"
"Define the variable `my_name`!"
msgstr ""
"$ python start.py\n"
"Define the variable `my_name`!"

#: ../../library/__main__.rst:323
msgid ""
"The exit code of the program would be 1, indicating an error. Uncommenting "
"the line with ``my_name = \"Dinsdale\"`` fixes the program and now it exits "
"with status code 0, indicating success:"
msgstr ""
"该程序的退出代码为 1 ，表明有错误。取消对 ``my_name = \"Dinsdale\"`` 这一行的注释，就可以修复程序，现在它的退出状态代码为"
" 0 ，表示成功。"

#: ../../library/__main__.rst:327
msgid ""
"$ python start.py\n"
"Dinsdale"
msgstr ""
"$Python start.py\n"
"Dinsdale"

#: ../../library/__main__.rst:332
msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put in "
"the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why does "
"this work?"
msgstr ""
"请注意，导入 ``__main__`` 不会导致无意中运行旨在用于脚本的顶层代码的问题，这些代码被放在模块 ``start`` 的 ``if "
"__name__ == \"__main__\"`` 块中。为什么这样做？"

#: ../../library/__main__.rst:336
msgid ""
"Python inserts an empty ``__main__`` module in :data:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :data:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how "
"this works."
msgstr ""
"Python 解释器启动时会在 :data:`sys.modules` 中插入一个空的 ``__main__`` 模块，并通过运行最高层级代码来填充它。"
" 在我们的例子中这就是 ``start`` 模块，它逐行运行并导入 ``namely``。 相应地，``namely`` 会导入 "
"``__main__`` (它实际上就是 ``start``)。 这就是一个导入循环！ 幸运的是，由于部分填充的 ``__main__`` 模块存在于 "
":data:`sys.modules` 中，Python 会将其传递给 ``namely``。 请参阅导入系统的参考文档中 :ref:`有关 "
"__main__ 的特别考量 <import-dunder-main>` 来了解其中的详情。"

#: ../../library/__main__.rst:345
msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr "Python REPL 是另一个 \"顶层环境 \"的例子，所以在 REPL 中定义的任何东西都成为 ``__main__`` 范围的一部分::"

#: ../../library/__main__.rst:348
msgid ""
">>> import namely\n"
">>> namely.did_user_define_their_name()\n"
"False\n"
">>> namely.print_user_name()\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Define the variable `my_name`!\n"
">>> my_name = 'Jabberwocky'\n"
">>> namely.did_user_define_their_name()\n"
"True\n"
">>> namely.print_user_name()\n"
"Jabberwocky"
msgstr ""
">>> import namely\n"
">>> namely.did_user_define_their_name()\n"
"False\n"
">>> namely.print_user_name()\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Define the variable `my_name`!\n"
">>> my_name = 'Jabberwocky'\n"
">>> namely.did_user_define_their_name()\n"
"True\n"
">>> namely.print_user_name()\n"
"Jabberwocky"

#: ../../library/__main__.rst:361
msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and "
":mod:`rlcompleter`."
msgstr "``__main__`` 范围用于 :mod:`pdb` 和 :mod:`rlcompleter` 的实现。"
