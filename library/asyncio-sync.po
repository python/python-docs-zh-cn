# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-29 14:17+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr "同步原语"

#: ../../library/asyncio-sync.rst:9
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**源代码:** :source:`Lib/asyncio/locks.py`"

#: ../../library/asyncio-sync.rst:13
msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr "asyncio 同步原语被设计为与 :mod:`threading` 模块的类似，但有两个关键注意事项:"

#: ../../library/asyncio-sync.rst:16
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr "asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用 :mod:`threading`)；"

#: ../../library/asyncio-sync.rst:20
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr "这些同步原语的方法不接受 *timeout* 参数；请使用 :func:`asyncio.wait_for` 函数来执行带有超时的操作。"

#: ../../library/asyncio-sync.rst:24
msgid "asyncio has the following basic synchronization primitives:"
msgstr "asyncio 具有下列基本同步原语:"

#: ../../library/asyncio-sync.rst:26
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: ../../library/asyncio-sync.rst:27
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: ../../library/asyncio-sync.rst:28
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: ../../library/asyncio-sync.rst:29
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: ../../library/asyncio-sync.rst:30
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: ../../library/asyncio-sync.rst:31
msgid ":class:`Barrier`"
msgstr ":class:`Barrier`"

#: ../../library/asyncio-sync.rst:38
msgid "Lock"
msgstr "Lock"

#: ../../library/asyncio-sync.rst:42
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr "实现一个用于 asyncio 任务的互斥锁。 非线程安全。"

#: ../../library/asyncio-sync.rst:44
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr "asyncio 锁可被用来保证对共享资源的独占访问。"

#: ../../library/asyncio-sync.rst:47
msgid ""
"The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr "使用 Lock 的推荐方式是通过 :keyword:`async with` 语句::"

#: ../../library/asyncio-sync.rst:50
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... 稍后\n"
"async with lock:\n"
"    # 访问共享状态"

#: ../../library/asyncio-sync.rst:56 ../../library/asyncio-sync.rst:201
#: ../../library/asyncio-sync.rst:309
msgid "which is equivalent to::"
msgstr "这等价于::"

#: ../../library/asyncio-sync.rst:58
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... 稍后\n"
"await lock.acquire()\n"
"try:\n"
"    # 访问共享状态\n"
"finally:\n"
"    lock.release()"

#: ../../library/asyncio-sync.rst:67 ../../library/asyncio-sync.rst:113
#: ../../library/asyncio-sync.rst:189 ../../library/asyncio-sync.rst:297
#: ../../library/asyncio-sync.rst:353
msgid "Removed the *loop* parameter."
msgstr "移除了 *loop* 形参。"

#: ../../library/asyncio-sync.rst:73
msgid "Acquire the lock."
msgstr "获取锁。"

#: ../../library/asyncio-sync.rst:75
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr "此方法会等待直至锁为 *unlocked*，将其设为 *locked* 并返回 ``True``。"

#: ../../library/asyncio-sync.rst:78
msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr "当有一个以上的协程在 :meth:`acquire` 中被阻塞则会等待解锁，最终只有一个协程会被执行。"

#: ../../library/asyncio-sync.rst:82
msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr "锁的获取是 *公平的*: 被执行的协程将是第一个开始等待锁的协程。"

#: ../../library/asyncio-sync.rst:87
msgid "Release the lock."
msgstr "释放锁。"

#: ../../library/asyncio-sync.rst:89
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr "当锁为 *locked* 时，将其设为 *unlocked* 并返回。"

#: ../../library/asyncio-sync.rst:91
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "如果锁为 *unlocked*，则会引发 :exc:`RuntimeError`。"

#: ../../library/asyncio-sync.rst:95
msgid "Return ``True`` if the lock is *locked*."
msgstr "如果锁为 *locked* 则返回 ``True``。"

#: ../../library/asyncio-sync.rst:99
msgid "Event"
msgstr "Event"

#: ../../library/asyncio-sync.rst:103
msgid "An event object.  Not thread-safe."
msgstr "事件对象。 该对象不是线程安全的。"

#: ../../library/asyncio-sync.rst:105
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr "asyncio 事件可被用来通知多个 asyncio 任务已经有事件发生。"

#: ../../library/asyncio-sync.rst:108
msgid ""
"An Event object manages an internal flag that can be set to *true* with the "
":meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Event 对象会管理一个内部旗标，可通过 :meth:`~Event.set` 方法将其设为 *true* 并通过 :meth:`clear` "
"方法将其重设为 *false*。 :meth:`~Event.wait` 方法会阻塞直至该旗标被设为 *true*。 该旗标初始时会被设为 "
"*false*。"

#: ../../library/asyncio-sync.rst:118 ../../library/asyncio-sync.rst:377
msgid "Example::"
msgstr "示例::"

#: ../../library/asyncio-sync.rst:120
msgid ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # 创建一个 Event 对象。\n"
"    event = asyncio.Event()\n"
"\n"
"    # 产生一个任务等待直到 'event' 被设置。\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # 休眠 1 秒钟并设置事件。\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # 等待直到 waiter 任务完成。\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-sync.rst:144
msgid "Wait until the event is set."
msgstr "等待直至事件被设置。"

#: ../../library/asyncio-sync.rst:146
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr "如果事件已被设置，则立即返回 ``True``。 否则将阻塞直至另一个任务调用 :meth:`~Event.set`。"

#: ../../library/asyncio-sync.rst:151
msgid "Set the event."
msgstr "设置事件。"

#: ../../library/asyncio-sync.rst:153
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr "所有等待事件被设置的任务将被立即唤醒。"

#: ../../library/asyncio-sync.rst:158
msgid "Clear (unset) the event."
msgstr "清空（取消设置）事件。"

#: ../../library/asyncio-sync.rst:160
msgid ""
"Subsequent tasks awaiting on :meth:`~Event.wait` will now block until the "
":meth:`~Event.set` method is called again."
msgstr "通过 :meth:`~Event.wait` 进行等待的持续任务现在将会阻塞直至 :meth:`~Event.set` 方法被再次调用"

#: ../../library/asyncio-sync.rst:165
msgid "Return ``True`` if the event is set."
msgstr "如果事件已被设置则返回 ``True``。"

#: ../../library/asyncio-sync.rst:169
msgid "Condition"
msgstr "Condition"

#: ../../library/asyncio-sync.rst:173
msgid "A Condition object.  Not thread-safe."
msgstr "条件对象。 该对象不是线程安全的。"

#: ../../library/asyncio-sync.rst:175
msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr "asyncio 条件原语可被任务用于等待某个事件发生，然后获取对共享资源的独占访问。"

#: ../../library/asyncio-sync.rst:179
msgid ""
"In essence, a Condition object combines the functionality of an "
":class:`Event` and a :class:`Lock`.  It is possible to have multiple "
"Condition objects share one Lock, which allows coordinating exclusive access"
" to a shared resource between different tasks interested in particular "
"states of that shared resource."
msgstr ""
"在本质上，Condition 对象合并了 :class:`Event` 和 :class:`Lock` 的功能。 多个 Condition "
"对象有可能共享一个 Lock，这允许关注于共享资源的特定状态的不同任务实现对共享资源的协同独占访问。"

#: ../../library/asyncio-sync.rst:185
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In"
" the latter case a new Lock object is created automatically."
msgstr ""
"可选的 *lock* 参数必须为 :class:`Lock` 对象或 ``None``。 在后一种情况下会自动创建一个新的 Lock 对象。"

#: ../../library/asyncio-sync.rst:192
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr "使用 Condition 的推荐方式是通过 :keyword:`async with` 语句::"

#: ../../library/asyncio-sync.rst:195
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... 稍后\n"
"async with cond:\n"
"    await cond.wait()"

#: ../../library/asyncio-sync.rst:203
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... 稍后\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"

#: ../../library/asyncio-sync.rst:215
msgid "Acquire the underlying lock."
msgstr "获取下层的锁。"

#: ../../library/asyncio-sync.rst:217
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr "此方法会等待直至下层的锁为 *unlocked*，将其设为 *locked* 并返回 returns ``True``。"

#: ../../library/asyncio-sync.rst:222
msgid ""
"Wake up *n* tasks (1 by default) waiting on this condition.  If fewer than "
"*n* tasks are waiting they are all awakened."
msgstr ""
"唤醒正在等待此条件的 *n* 个任务（默认 1 个）。 如果正在等待的任务少于 *n* 个则它们都将被唤醒。tasks are waiting they"
" are all awakened."

#: ../../library/asyncio-sync.rst:225 ../../library/asyncio-sync.rst:240
msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"锁必须在此方法被调用前被获取并在随后被快速释放。 如果通过一个 *unlocked* 锁调用则会引发 :exc:`RuntimeError`。"

#: ../../library/asyncio-sync.rst:231
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "如果下层的锁已被获取则返回 ``True``。"

#: ../../library/asyncio-sync.rst:235
msgid "Wake up all tasks waiting on this condition."
msgstr "唤醒所有正在等待此条件的任务。"

#: ../../library/asyncio-sync.rst:237
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr "此方法的行为类似于 :meth:`notify`，但会唤醒所有正在等待的任务。"

#: ../../library/asyncio-sync.rst:246
msgid "Release the underlying lock."
msgstr "释放下层的锁。"

#: ../../library/asyncio-sync.rst:248
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "当在未锁定的锁上唤起时，会引发 :exc:`RuntimeError`。"

#: ../../library/asyncio-sync.rst:254
msgid "Wait until notified."
msgstr "等待直至收到通知。"

#: ../../library/asyncio-sync.rst:256
msgid ""
"If the calling task has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr "当此方法被调用时如果调用方任务未获得锁，则会引发 :exc:`RuntimeError`。"

#: ../../library/asyncio-sync.rst:259
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"这个方法会释放下层的锁，然后保持阻塞直到被 :meth:`notify` 或 :meth:`notify_all` 调用所唤醒。 "
"一旦被唤醒，Condition 会重新获取它的锁并且此方法将返回 ``True``。"

#: ../../library/asyncio-sync.rst:264
msgid ""
"Note that a task *may* return from this call spuriously, which is why the "
"caller should always re-check the state and be prepared to "
":meth:`~Condition.wait` again. For this reason, you may prefer to use "
":meth:`~Condition.wait_for` instead."
msgstr ""
"请注意一个任务 *有可能* 虚假地从此调用返回，这就是为什么调用者总是应当重新检查状态并准备好再次执行 :meth:`~Condition.wait`。"
" 出于此理由，你可能会倾向于改用 :meth:`~Condition.wait_for`。"

#: ../../library/asyncio-sync.rst:272
msgid "Wait until a predicate becomes *true*."
msgstr "等待直到目标值变为 *true*。"

#: ../../library/asyncio-sync.rst:274
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The method will repeatedly :meth:`~Condition.wait` until the"
" predicate evaluates to *true*. The final value is the return value."
msgstr ""
"目标必须为一个可调用对象，其结果将被解读为一个布尔值。 此方法将重复地执行 :meth:`~Condition.wait` 直到目标被求值为 *真*。 "
"最终的值将被作为返回值。"

#: ../../library/asyncio-sync.rst:281
msgid "Semaphore"
msgstr "Semaphore"

#: ../../library/asyncio-sync.rst:285
msgid "A Semaphore object.  Not thread-safe."
msgstr "信号量对象。 该对象不是线程安全的。"

#: ../../library/asyncio-sync.rst:287
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`acquire` call and incremented by each :meth:`release` call. The "
"counter can never go below zero; when :meth:`acquire` finds that it is zero,"
" it blocks, waiting until some task calls :meth:`release`."
msgstr ""
"信号量会管理一个内部计数器，该计数器会随每次 :meth:`acquire` 调用递减并随每次 :meth:`release` 调用递增。 "
"计数器的值永远不会降到零以下；当 :meth:`acquire` 发现其值为零时，它将保持阻塞直到有某个任务调用了 :meth:`release`。"

#: ../../library/asyncio-sync.rst:293
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a "
":exc:`ValueError` is raised."
msgstr ""
"可选的 *value* 参数用来为内部计数器赋初始值 (默认值为 ``1``)。 如果给定的值小于 ``0`` 则会引发 "
":exc:`ValueError`。"

#: ../../library/asyncio-sync.rst:300
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr "使用 Semaphore 的推荐方式是通过 :keyword:`async with` 语句。::"

#: ../../library/asyncio-sync.rst:303
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... 稍后\n"
"async with sem:\n"
"    # 操作共享的资源"

#: ../../library/asyncio-sync.rst:311
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... 稍后\n"
"await sem.acquire()\n"
"try:\n"
"    # 操作共享的资源\n"
"finally:\n"
"    sem.release()"

#: ../../library/asyncio-sync.rst:323
msgid "Acquire a semaphore."
msgstr "获取一个信号量。"

#: ../../library/asyncio-sync.rst:325
msgid ""
"If the internal counter is greater than zero, decrement it by one and return"
" ``True`` immediately.  If it is zero, wait until a :meth:`release` is "
"called and return ``True``."
msgstr ""
"如果内部计数器的值大于零，则将其减一并立即返回 ``True``。 如果其值为零，则会等待直到 :meth:`release` 并调用并返回 "
"``True``。"

#: ../../library/asyncio-sync.rst:331
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "如果信号量对象无法被立即获取则返回 ``True``。"

#: ../../library/asyncio-sync.rst:335
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a"
" task waiting to acquire the semaphore."
msgstr "释放一个信号量对象，将内部计数器的值加一。 可以唤醒一个正在等待获取信号量对象的任务。"

#: ../../library/asyncio-sync.rst:338
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"不同于 :class:`BoundedSemaphore`，:class:`Semaphore` 允许执行的 ``release()`` 调用多于 "
"``acquire()`` 调用。"

#: ../../library/asyncio-sync.rst:343
msgid "BoundedSemaphore"
msgstr "BoundedSemaphore"

#: ../../library/asyncio-sync.rst:347
msgid "A bounded semaphore object.  Not thread-safe."
msgstr "绑定的信号量对象。 该对象不是线程安全的。"

#: ../../library/asyncio-sync.rst:349
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a "
":exc:`ValueError` in :meth:`~Semaphore.release` if it increases the internal"
" counter above the initial *value*."
msgstr ""
"BoundedSemaphore 是特殊版本的 :class:`Semaphore`，如果在 :meth:`~Semaphore.release` "
"中内部计数器值增加到初始 *value* 以上它将引发一个 :exc:`ValueError`。"

#: ../../library/asyncio-sync.rst:358
msgid "Barrier"
msgstr "Barrier"

#: ../../library/asyncio-sync.rst:362
msgid "A barrier object.  Not thread-safe."
msgstr "屏障对象。 该对象不是线程安全的。"

#: ../../library/asyncio-sync.rst:364
msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the "
":meth:`~Barrier.wait` method and would be blocked until the specified number"
" of tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""
"屏障是一个允许阻塞直到 *parties* 个任务在其上等待的简单同步原语。 任务可以在 :meth:`~Barrier.wait` "
"方法上等待并将被阻塞直到有指定数量的任务在 :meth:`~Barrier.wait` 上等待。 在那时所有正在等待的任务将同时撤销阻塞。"

#: ../../library/asyncio-sync.rst:370
msgid ""
":keyword:`async with` can be used as an alternative to awaiting on "
":meth:`~Barrier.wait`."
msgstr ":keyword:`async with` 可以被用作在 :meth:`~Barrier.wait` 上等待的替代。"

#: ../../library/asyncio-sync.rst:373
msgid "The barrier can be reused any number of times."
msgstr "屏障可被重复使用任意次数。"

#: ../../library/asyncio-sync.rst:379
msgid ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"
msgstr ""
"async def example_barrier():\n"
"   # 包含三部分的屏障\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # 新建 2 个等待任务\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # 第三个 .wait() 调用通过屏障\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"

#: ../../library/asyncio-sync.rst:400
msgid "Result of this example is::"
msgstr "该示例的结果为::"

#: ../../library/asyncio-sync.rst:402
msgid ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"
msgstr ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"

#: ../../library/asyncio-sync.rst:412
msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr "穿过屏障。 当屏障汇集的所有任务都调用了此函数时，它们将被同时撤销阻塞。"

#: ../../library/asyncio-sync.rst:415
msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr "当该屏障中等待或阻塞的任务被取消时，此任务将退出屏障而屏障将保持相同状态。 如果屏障的状态为 \"正在填充\"，则等待的任务数量将减 1。"

#: ../../library/asyncio-sync.rst:420
msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different"
" for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""
"返回值是一个 0 到 ``parties-1`` 之间的整数，对于每个任务来说各不相同。 这可被用来选择一个任务以执行某些特别的操作。 例如::"

#: ../../library/asyncio-sync.rst:424
msgid ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"
msgstr ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # 只有一个任务会打印此内容\n"
"      print('End of *draining phase*')"

#: ../../library/asyncio-sync.rst:430
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier"
" is broken or reset while a task is waiting. It could raise a "
":exc:`CancelledError` if a task is cancelled."
msgstr ""
"如果屏障在有任务在等待时已被破坏或重置则此方法可能会引发 :class:`BrokenBarrierError`。 如果有任务被取消则它可能会引发 "
":exc:`CancelledError`。"

#: ../../library/asyncio-sync.rst:437
msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr "将屏障返回为默认的空白状态。 任何正在其上等待的任务将会接收到 :class:`BrokenBarrierError` 异常。"

#: ../../library/asyncio-sync.rst:440
msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr "如果屏障已被破坏则最好的是让其保持原状并创建一个新的屏障。"

#: ../../library/asyncio-sync.rst:445
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls"
" to :meth:`~Barrier.wait` to fail with the :class:`BrokenBarrierError`. Use "
"this for example if one of the tasks needs to abort, to avoid infinite "
"waiting tasks."
msgstr ""
"将屏障置为已破坏状态。 这会导致任何已激活或未来对 :meth:`~Barrier.wait` 的调用失败并引发 "
":class:`BrokenBarrierError`。 例如可以在需要中止某个任务时使用此方法，以避免无限等待任务。"

#: ../../library/asyncio-sync.rst:452
msgid "The number of tasks required to pass the barrier."
msgstr "请求穿过该屏障的任务的数量。"

#: ../../library/asyncio-sync.rst:456
msgid "The number of tasks currently waiting in the barrier while filling."
msgstr "当执行填充时正在屏障中等待的任务的数量。"

#: ../../library/asyncio-sync.rst:460
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "一个布尔值，值为 ``True`` 表明栅栏为破损态。"

#: ../../library/asyncio-sync.rst:465
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the "
":class:`Barrier` object is reset or broken."
msgstr ""
"异常类，是 :exc:`RuntimeError` 异常的子类，在 :class:`Barrier` 对象重置时仍有线程阻塞时和对象进入破损态时被引发。"

#: ../../library/asyncio-sync.rst:473
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or "
":keyword:`with` statement (``with await lock``, ``with (yield from lock)``) "
"was removed.  Use ``async with lock`` instead."
msgstr ""
"使用 ``await lock`` 或 ``yield from lock`` 以及/或者 :keyword:`with` 语句 (``with "
"await lock``, ``with (yield from lock)``) 来获取锁的操作已被移除。 请改用 ``async with "
"lock``。"
