# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/urllib.parse.rst:2
msgid ":mod:`!urllib.parse` --- Parse URLs into components"
msgstr ":mod:`!urllib.parse` --- 将 URL 解析为组件"

#: ../../library/urllib.parse.rst:7
msgid "**Source code:** :source:`Lib/urllib/parse.py`"
msgstr "**源代码:** :source:`Lib/urllib/parse.py`"

#: ../../library/urllib.parse.rst:18
msgid ""
"This module defines a standard interface to break Uniform Resource Locator "
"(URL) strings up in components (addressing scheme, network location, path "
"etc.), to combine the components back into a URL string, and to convert a "
"\"relative URL\" to an absolute URL given a \"base URL.\""
msgstr ""
"该模块定义了一个标准接口，用于将统一资源定位符（URL）字符串拆分为不同部分（协议、网络位置、路径等），或将各个部分组合回 URL 字符串，并将“相对 "
"URL”转换为基于给定的“基准 URL”的绝对 URL。"

#: ../../library/urllib.parse.rst:23
msgid ""
"The module has been designed to match the internet RFC on Relative Uniform "
"Resource Locators. It supports the following URL schemes: ``file``, ``ftp``,"
" ``gopher``, ``hdl``, ``http``, ``https``, ``imap``, ``itms-services``, "
"``mailto``, ``mms``, ``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, "
"``rtsps``, ``rtspu``, ``sftp``, ``shttp``, ``sip``, ``sips``, ``snews``, "
"``svn``, ``svn+ssh``, ``telnet``, ``wais``, ``ws``, ``wss``."
msgstr ""
"该模块被设计为匹配针对相对统一资源定位符的互联网 RFC。 它支持下列 URL 类别: ``file``, ``ftp``, ``gopher``, "
"``hdl``, ``http``, ``https``, ``imap``, ``itms-services``, ``mailto``, "
"``mms``, ``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, ``rtsps``, "
"``rtspu``, ``sftp``, ``shttp``, ``sip``, ``sips``, ``snews``, ``svn``, "
"``svn+ssh``, ``telnet``, ``wais``, ``ws``, ``wss``。"

#: ../../library/urllib.parse.rst:32
msgid ""
"The inclusion of the ``itms-services`` URL scheme can prevent an app from "
"passing Apple's App Store review process for the macOS and iOS App Stores. "
"Handling for the ``itms-services`` scheme is always removed on iOS; on "
"macOS, it *may* be removed if CPython has been built with the "
":option:`--with-app-store-compliance` option."
msgstr ""
"包括 ``itms-services`` URL 类别可以防止 app 为 macOS 和 iOS App 商店传递 Apple 的 App "
"商店评论进程。 对 ``itms-services`` 类别的处理在 iOS 上总是会被移除；在 macOS 上，如果 CPython 编译时附带了 "
":option:`--with-app-store-compliance` 选项则它 *可以* 被移除。"

#: ../../library/urllib.parse.rst:38
msgid ""
"The :mod:`urllib.parse` module defines functions that fall into two broad "
"categories: URL parsing and URL quoting. These are covered in detail in the "
"following sections."
msgstr ""
":mod:`urllib.parse` 模块定义的函数可分为两个主要门类: URL 解析和 URL 转码。 这些函数将在以下各节中详细说明。"

#: ../../library/urllib.parse.rst:42
msgid ""
"This module's functions use the deprecated term ``netloc`` (or ``net_loc``),"
" which was introduced in :rfc:`1808`. However, this term has been obsoleted "
"by :rfc:`3986`, which introduced the term ``authority`` as its replacement. "
"The use of ``netloc`` is continued for backward compatibility."
msgstr ""
"本模块的函数使用已弃用的术语 ``netloc`` (或 ``net_loc``)，它是在 :rfc:`1808` 中引入的。 但是，此术语在 "
":rfc:`3986` 引入术语 ``authority`` 作为其替代后已过时。 ``netloc`` 仅为向下兼容而继续被使用。"

#: ../../library/urllib.parse.rst:48
msgid "URL Parsing"
msgstr "URL 解析"

#: ../../library/urllib.parse.rst:50
msgid ""
"The URL parsing functions focus on splitting a URL string into its "
"components, or on combining URL components into a URL string."
msgstr "URL 解析函数用于将一个 URL 字符串分割成其组成部分，或者将 URL 的多个部分组合成一个 URL 字符串。"

#: ../../library/urllib.parse.rst:55
msgid ""
"Parse a URL into six components, returning a 6-item :term:`named tuple`.  "
"This corresponds to the general structure of a URL: "
"``scheme://netloc/path;parameters?query#fragment``. Each tuple item is a "
"string, possibly empty. The components are not broken up into smaller parts "
"(for example, the network location is a single string), and % escapes are "
"not expanded. The delimiters as shown above are not part of the result, "
"except for a leading slash in the *path* component, which is retained if "
"present.  For example:"
msgstr ""
"将一个 URL 解析为六个部分，返回一个包含 6 项的 :term:`named tuple`。 这对应于 URL 的主要结构: "
"``scheme://netloc/path;parameters?query#fragment``。 每个元组项均为字符串，可能为空字符串。 "
"这些部分不会再被拆分为更小的部分（例如，netloc 将为单个字符串），并且 % 转义不会被扩展。 上面显示的分隔符不会出现在结果中，只有 *path*"
" 部分的开头斜杠例外，它如果存在则会被保留。 例如:"

#: ../../library/urllib.parse.rst:64
msgid ""
">>> from urllib.parse import urlparse\n"
">>> urlparse(\"scheme://netloc/path;parameters?query#fragment\")\n"
"ParseResult(scheme='scheme', netloc='netloc', path='/path;parameters', params='',\n"
"            query='query', fragment='fragment')\n"
">>> o = urlparse(\"http://docs.python.org:80/3/library/urllib.parse.html?\"\n"
"...              \"highlight=params#url-parsing\")\n"
">>> o\n"
"ParseResult(scheme='http', netloc='docs.python.org:80',\n"
"            path='/3/library/urllib.parse.html', params='',\n"
"            query='highlight=params', fragment='url-parsing')\n"
">>> o.scheme\n"
"'http'\n"
">>> o.netloc\n"
"'docs.python.org:80'\n"
">>> o.hostname\n"
"'docs.python.org'\n"
">>> o.port\n"
"80\n"
">>> o._replace(fragment=\"\").geturl()\n"
"'http://docs.python.org:80/3/library/urllib.parse.html?highlight=params'"
msgstr ""
">>> from urllib.parse import urlparse\n"
">>> urlparse(\"scheme://netloc/path;parameters?query#fragment\")\n"
"ParseResult(scheme='scheme', netloc='netloc', path='/path;parameters', params='',\n"
"            query='query', fragment='fragment')\n"
">>> o = urlparse(\"http://docs.python.org:80/3/library/urllib.parse.html?\"\n"
"...              \"highlight=params#url-parsing\")\n"
">>> o\n"
"ParseResult(scheme='http', netloc='docs.python.org:80',\n"
"            path='/3/library/urllib.parse.html', params='',\n"
"            query='highlight=params', fragment='url-parsing')\n"
">>> o.scheme\n"
"'http'\n"
">>> o.netloc\n"
"'docs.python.org:80'\n"
">>> o.hostname\n"
"'docs.python.org'\n"
">>> o.port\n"
"80\n"
">>> o._replace(fragment=\"\").geturl()\n"
"'http://docs.python.org:80/3/library/urllib.parse.html?highlight=params'"

#: ../../library/urllib.parse.rst:88
msgid ""
"Following the syntax specifications in :rfc:`1808`, urlparse recognizes a "
"netloc only if it is properly introduced by '//'.  Otherwise the input is "
"presumed to be a relative URL and thus to start with a path component."
msgstr ""
"根据 :rfc:`1808` 中的语法规范，urlparse 仅在 netloc 前面正确地附带了 '//' 的情况下才会识别它。 "
"否则输入会被当作是一个相对 URL 因而以路径的组成部分开头。"

#: ../../library/urllib.parse.rst:93
msgid ""
">>> from urllib.parse import urlparse\n"
">>> urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> urlparse('www.cwi.nl/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> urlparse('help/Python.html')\n"
"ParseResult(scheme='', netloc='', path='help/Python.html', params='',\n"
"            query='', fragment='')"
msgstr ""
">>> from urllib.parse import urlparse\n"
">>> urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> urlparse('www.cwi.nl/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> urlparse('help/Python.html')\n"
"ParseResult(scheme='', netloc='', path='help/Python.html', params='',\n"
"            query='', fragment='')"

#: ../../library/urllib.parse.rst:107
msgid ""
"The *scheme* argument gives the default addressing scheme, to be used only "
"if the URL does not specify one.  It should be the same type (text or bytes)"
" as *urlstring*, except that the default value ``''`` is always allowed, and"
" is automatically converted to ``b''`` if appropriate."
msgstr ""
"*scheme* 参数给出了默认的协议，只有在 URL 未指定协议的情况下才会被使用。 它应该是与 *urlstring* "
"相同的类型（文本或字节串），除此之外默认值 ``''`` 也总是被允许，并会在适当情况下自动转换为 ``b''``。"

#: ../../library/urllib.parse.rst:112
msgid ""
"If the *allow_fragments* argument is false, fragment identifiers are not "
"recognized.  Instead, they are parsed as part of the path, parameters or "
"query component, and :attr:`fragment` is set to the empty string in the "
"return value."
msgstr ""
"如果 *allow_fragments* 参数为假值，则片段标识符不会被识别。 它们会被解析为路径、参数或查询部分，在返回值中 "
":attr:`fragment` 会被设为空字符串。"

#: ../../library/urllib.parse.rst:117
msgid ""
"The return value is a :term:`named tuple`, which means that its items can be"
" accessed by index or as named attributes, which are:"
msgstr "返回值是一个 :term:`named tuple`，这意味着它的条目可以通过索引或作为命名属性来访问，这些属性是："

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Attribute"
msgstr "属性"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Index"
msgstr "索引"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Value"
msgstr "值"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Value if not present"
msgstr "值（如果不存在）"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid ":attr:`scheme`"
msgstr ":attr:`scheme`"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
#: ../../library/urllib.parse.rst:434
msgid "0"
msgstr "0"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid "URL scheme specifier"
msgstr "URL 协议说明符"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid "*scheme* parameter"
msgstr "*scheme* 参数"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
msgid ":attr:`netloc`"
msgstr ":attr:`netloc`"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
#: ../../library/urllib.parse.rst:436
msgid "1"
msgstr "1"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
msgid "Network location part"
msgstr "网络位置部分"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:127
#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:132
#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:314
#: ../../library/urllib.parse.rst:316 ../../library/urllib.parse.rst:318
#: ../../library/urllib.parse.rst:320 ../../library/urllib.parse.rst:434
#: ../../library/urllib.parse.rst:436
msgid "empty string"
msgstr "空字符串"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid ":attr:`path`"
msgstr ":attr:`path`"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid "2"
msgstr "2"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid "Hierarchical path"
msgstr "分层路径"

#: ../../library/urllib.parse.rst:129
msgid ":attr:`params`"
msgstr ":attr:`params`"

#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:318
msgid "3"
msgstr "3"

#: ../../library/urllib.parse.rst:129
msgid "Parameters for last path element"
msgstr "最后路径元素的参数"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:318
msgid ":attr:`query`"
msgstr ":attr:`query`"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:320
msgid "4"
msgstr "4"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:318
msgid "Query component"
msgstr "查询组件"

#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:320
#: ../../library/urllib.parse.rst:436
msgid ":attr:`fragment`"
msgstr ":attr:`fragment`"

#: ../../library/urllib.parse.rst:134
msgid "5"
msgstr "5"

#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:320
#: ../../library/urllib.parse.rst:436
msgid "Fragment identifier"
msgstr "片段标识符"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:322
msgid ":attr:`username`"
msgstr ":attr:`username`"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:322
msgid "User name"
msgstr "用户名"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:138
#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:142
#: ../../library/urllib.parse.rst:322 ../../library/urllib.parse.rst:324
#: ../../library/urllib.parse.rst:326 ../../library/urllib.parse.rst:328
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/urllib.parse.rst:138 ../../library/urllib.parse.rst:324
msgid ":attr:`password`"
msgstr ":attr:`password`"

#: ../../library/urllib.parse.rst:138 ../../library/urllib.parse.rst:324
msgid "Password"
msgstr "密码"

#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:326
msgid ":attr:`hostname`"
msgstr ":attr:`hostname`"

#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:326
msgid "Host name (lower case)"
msgstr "主机名（小写）"

#: ../../library/urllib.parse.rst:142 ../../library/urllib.parse.rst:328
msgid ":attr:`port`"
msgstr ":attr:`port`"

#: ../../library/urllib.parse.rst:142 ../../library/urllib.parse.rst:328
msgid "Port number as integer, if present"
msgstr "端口号为整数（如果存在）"

#: ../../library/urllib.parse.rst:146 ../../library/urllib.parse.rst:332
msgid ""
"Reading the :attr:`port` attribute will raise a :exc:`ValueError` if an "
"invalid port is specified in the URL.  See section :ref:`urlparse-result-"
"object` for more information on the result object."
msgstr ""
"如果在 URL 中指定了无效的端口，读取 :attr:`port` 属性将引发 :exc:`ValueError`。 有关结果对象的更多信息请参阅 "
":ref:`urlparse-result-object` 一节。"

#: ../../library/urllib.parse.rst:150 ../../library/urllib.parse.rst:336
msgid ""
"Unmatched square brackets in the :attr:`netloc` attribute will raise a "
":exc:`ValueError`."
msgstr "在 :attr:`netloc` 属性中不匹配的方括号将引发 :exc:`ValueError`。"

#: ../../library/urllib.parse.rst:153 ../../library/urllib.parse.rst:339
msgid ""
"Characters in the :attr:`netloc` attribute that decompose under NFKC "
"normalization (as used by the IDNA encoding) into any of ``/``, ``?``, "
"``#``, ``@``, or ``:`` will raise a :exc:`ValueError`. If the URL is "
"decomposed before parsing, no error will be raised."
msgstr ""
"如果 :attr:`netloc` 属性中的字符在 NFKC 规范化下（如 IDNA 编码格式所使用的）被分解成 ``/``, ``?``, "
"``#``, ``@`` 或 ``:`` 则将引发 :exc:`ValueError`。 如果在解析之前 URL 就被分解，则不会引发错误。"

#: ../../library/urllib.parse.rst:158
msgid ""
"As is the case with all named tuples, the subclass has a few additional "
"methods and attributes that are particularly useful. One such method is "
":meth:`_replace`. The :meth:`_replace` method will return a new ParseResult "
"object replacing specified fields with new values."
msgstr ""
"与所有具名元组的情况一样，该子类还有一些特别有用的附加方法和属性。 其中一个方法是 :meth:`_replace`。 :meth:`_replace`"
" 方法将返回一个新的 ParseResult 对象来将指定字段替换为新的值。"

#: ../../library/urllib.parse.rst:163
msgid ""
">>> from urllib.parse import urlparse\n"
">>> u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
">>> u\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> u._replace(scheme='http')\n"
"ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')"
msgstr ""
">>> from urllib.parse import urlparse\n"
">>> u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
">>> u\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> u._replace(scheme='http')\n"
"ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')"

#: ../../library/urllib.parse.rst:177
msgid ""
":func:`urlparse` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""
":func:`urlparse` 不会执行验证。 请参阅 :ref:`URL 解析安全 <url-parsing-security>` 了解详情。"

#: ../../library/urllib.parse.rst:180
msgid "Added IPv6 URL parsing capabilities."
msgstr "添加了IPv6 URL解析功能。"

#: ../../library/urllib.parse.rst:183
msgid ""
"The fragment is now parsed for all URL schemes (unless *allow_fragments* is "
"false), in accordance with :rfc:`3986`.  Previously, an allowlist of schemes"
" that support fragments existed."
msgstr ""
"现在会针对所有 URL 方案解析此片段（除非 *allow_fragments* 为假值），以符合 :rfc:`3986` 规范。 "
"在之前版本中，存在一个支持片段的方案的允许名单。"

#: ../../library/urllib.parse.rst:188 ../../library/urllib.parse.rst:353
msgid ""
"Out-of-range port numbers now raise :exc:`ValueError`, instead of returning "
":const:`None`."
msgstr "超范围的端口号现在会引发 :exc:`ValueError`，而不是返回 :const:`None`。"

#: ../../library/urllib.parse.rst:192 ../../library/urllib.parse.rst:357
msgid ""
"Characters that affect netloc parsing under NFKC normalization will now "
"raise :exc:`ValueError`."
msgstr "在 NFKC 规范化下会影响 netloc 解析的字符现在将引发 :exc:`ValueError`。"

#: ../../library/urllib.parse.rst:199
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a "
"dictionary.  The dictionary keys are the unique query variable names and the"
" values are lists of values for each name."
msgstr ""
"解析以字符串参数形式（类型为 :mimetype:`application/x-www-form-urlencoded` 的数据）给出的查询字符串。 "
"返回字典形式的数据。 结果字典的键为唯一的查询变量名而值为每个变量名对应的值列表。"

#: ../../library/urllib.parse.rst:204 ../../library/urllib.parse.rst:249
msgid ""
"The optional argument *keep_blank_values* is a flag indicating whether blank"
" values in percent-encoded queries should be treated as blank strings. A "
"true value indicates that blanks should be retained as  blank strings.  The "
"default false value indicates that blank values are to be ignored and "
"treated as if they were not included."
msgstr ""
"可选参数 *keep_blank_values* 是一个旗标，指明是否要将以百分号转码的空值作为空字符串处理。 真值表示空值应当被保留作为空字符串。 "
"默认的假值表示空值会被忽略并将其视作未包括的值。"

#: ../../library/urllib.parse.rst:210 ../../library/urllib.parse.rst:255
msgid ""
"The optional argument *strict_parsing* is a flag indicating what to do with "
"parsing errors.  If false (the default), errors are silently ignored.  If "
"true, errors raise a :exc:`ValueError` exception."
msgstr ""
"可选参数 *strict_parsing* 是一个旗标，指明要如何处理解析错误。 如为假值（默认），错误会被静默地忽略。 如为真值，错误会引发 "
":exc:`ValueError` 异常。"

#: ../../library/urllib.parse.rst:214 ../../library/urllib.parse.rst:259
msgid ""
"The optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"可选的 *encoding* 和 *errors* 形参指定如何将以百分号编码的序列解码为 Unicode 字符，即作为 "
":meth:`bytes.decode` 方法所接受的数据。"

#: ../../library/urllib.parse.rst:218 ../../library/urllib.parse.rst:263
msgid ""
"The optional argument *max_num_fields* is the maximum number of fields to "
"read. If set, then throws a :exc:`ValueError` if there are more than "
"*max_num_fields* fields read."
msgstr ""
"可选参数 *max_num_fields* 是要读取的最大字段数量的。 如果设置，则如果读取的字段超过 *max_num_fields* 会引发 "
":exc:`ValueError`。"

#: ../../library/urllib.parse.rst:222 ../../library/urllib.parse.rst:267
msgid ""
"The optional argument *separator* is the symbol to use for separating the "
"query arguments. It defaults to ``&``."
msgstr "可选参数 *separator* 是用来分隔查询参数的符号。 默认为 ``&``。"

#: ../../library/urllib.parse.rst:225
msgid ""
"Use the :func:`urllib.parse.urlencode` function (with the ``doseq`` "
"parameter set to ``True``) to convert such dictionaries into query strings."
msgstr ""
"使用 :func:`urllib.parse.urlencode` 函数 (并将 ``doseq`` 形参设为 ``True``) "
"将这样的字典转换为查询字符串。"

#: ../../library/urllib.parse.rst:230 ../../library/urllib.parse.rst:273
msgid "Add *encoding* and *errors* parameters."
msgstr "增加了 *encoding* 和 *errors* 形参。"

#: ../../library/urllib.parse.rst:233 ../../library/urllib.parse.rst:276
msgid "Added *max_num_fields* parameter."
msgstr "增加了 *max_num_fields* 形参。"

#: ../../library/urllib.parse.rst:236 ../../library/urllib.parse.rst:279
msgid ""
"Added *separator* parameter with the default value of ``&``. Python versions"
" earlier than Python 3.10 allowed using both ``;`` and ``&`` as query "
"parameter separator. This has been changed to allow only a single separator "
"key, with ``&`` as the default separator."
msgstr ""
"增加了 *separator* 形参，默认值为 ``&``。 Python 在早于 Python 3.10 的版本中允许使用 ``;`` 和 ``&``"
" 作为查询参数分隔符。 此设置已被改为只允许单个分隔符键，并以 ``&`` 作为默认的分隔符。"

#: ../../library/urllib.parse.rst:245
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a list"
" of name, value pairs."
msgstr ""
"解析以字符串参数形式（类型为 :mimetype:`application/x-www-form-urlencoded` 的数据）给出的查询字符串。 "
"数据以字段名和字段值对列表的形式返回。"

#: ../../library/urllib.parse.rst:270
msgid ""
"Use the :func:`urllib.parse.urlencode` function to convert such lists of "
"pairs into query strings."
msgstr "使用 :func:`urllib.parse.urlencode` 函数将这样的名值对列表转换为查询字符串。"

#: ../../library/urllib.parse.rst:288
msgid ""
"Construct a URL from a tuple as returned by ``urlparse()``. The *parts* "
"argument can be any six-item iterable. This may result in a slightly "
"different, but equivalent URL, if the URL that was parsed originally had "
"unnecessary delimiters (for example, a ``?`` with an empty query; the RFC "
"states that these are equivalent)."
msgstr ""
"根据 ``urlparse()`` 所返回的元组来构造一个 URL。 *parts* 参数可以是任何包含六个条目的可迭代对象。 "
"构造的结果可能是略有不同但保持等价的 URL，如果被解析的 URL 原本包含不必要的分隔符（例如，带有空查询的 ``?``；RFC 已声明这是等价的）。"

#: ../../library/urllib.parse.rst:297
msgid ""
"This is similar to :func:`urlparse`, but does not split the params from the "
"URL. This should generally be used instead of :func:`urlparse` if the more "
"recent URL syntax allowing parameters to be applied to each segment of the "
"*path* portion of the URL (see :rfc:`2396`) is wanted.  A separate function "
"is needed to separate the path segments and parameters.  This function "
"returns a 5-item :term:`named tuple`::"
msgstr ""
"此函数类似于 :func:`urlparse`，但不会拆分来自 URL 的参数。 此函数通常应当在需要允许将参数应用到 URL 的 *path* "
"部分的每个分节的较新的 URL 语法的情况下 (参见 :rfc:`2396`) 被用来代替 :func:`urlparse`。 "
"需要使用一个拆分函数来拆分路径分节和参数。 此函数将返回包含 5 个条目的 :term:`named tuple`::"

#: ../../library/urllib.parse.rst:304
msgid ""
"(addressing scheme, network location, path, query, fragment identifier)."
msgstr "（寻址方案, 网络位置, 路径, 查询, 片段标识符)。"

#: ../../library/urllib.parse.rst:306 ../../library/urllib.parse.rst:428
msgid ""
"The return value is a :term:`named tuple`, its items can be accessed by "
"index or as named attributes:"
msgstr "返回值是一个 :term:`named tuple`，它的条目可以通过索引或作为命名属性来访问:"

#: ../../library/urllib.parse.rst:344
msgid ""
"Following some of the `WHATWG spec`_ that updates RFC 3986, leading C0 "
"control and space characters are stripped from the URL. ``\\n``, ``\\r`` and"
" tab ``\\t`` characters are removed from the URL at any position."
msgstr ""
"按照针对 RFC 3986 进行更新的 `WHATWG spec`_，打头的 C0 控制符和空格符将从 URL 中去除。 任意位置上的 ``\\n``,"
" ``\\r`` 和制表符 ``\\t`` 等字符也将从 URL 中去除。at any position."

#: ../../library/urllib.parse.rst:350
msgid ""
":func:`urlsplit` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""
":func:`urlsplit` 不会执行验证。 请参阅 :ref:`URL 解析安全 <url-parsing-security>` 了解详情。"

#: ../../library/urllib.parse.rst:361
msgid "ASCII newline and tab characters are stripped from the URL."
msgstr "ASCII 换行符和制表符会从 URL 中被去除。"

#: ../../library/urllib.parse.rst:364
msgid ""
"Leading WHATWG C0 control and space characters are stripped from the URL."
msgstr "打头的 WHATWG C0 控制符和空格符将从 URL 中去除。"

#: ../../library/urllib.parse.rst:371
msgid ""
"Combine the elements of a tuple as returned by :func:`urlsplit` into a "
"complete URL as a string. The *parts* argument can be any five-item "
"iterable. This may result in a slightly different, but equivalent URL, if "
"the URL that was parsed originally had unnecessary delimiters (for example, "
"a ? with an empty query; the RFC states that these are equivalent)."
msgstr ""
"将 :func:`urlsplit` 所返回的元组中的元素合并为一个字符串形式的完整 URL。 *parts* 参数可以是任何包含五个条目的可迭代对象。"
" 其结果可能是略有不同但保持等价的 URL，如果被解析的 URL 原本包含不必要的分隔符（例如，带有空查询的 ?；RFC 已声明这是等价的）。"

#: ../../library/urllib.parse.rst:380
msgid ""
"Construct a full (\"absolute\") URL by combining a \"base URL\" (*base*) "
"with another URL (*url*).  Informally, this uses components of the base URL,"
" in particular the addressing scheme, the network location and (part of) the"
" path, to provide missing components in the relative URL.  For example:"
msgstr ""
"通过合并一个 \"基准 URL\" (*base*) 和另一个 URL (*url*) 来构造一个完整 (\"absolute\") URL。 "
"在非正式情况下，这将使用基准 URL 的各部分，特别是地址协议、网络位置和 (一部分) 路径来提供相对 URL 中缺失的部分。 例如:"

#: ../../library/urllib.parse.rst:389
msgid ""
"The *allow_fragments* argument has the same meaning and default as for "
":func:`urlparse`."
msgstr "*allow_fragments* 参数具有与 :func:`urlparse` 中的对应参数一致的含义与默认值。"

#: ../../library/urllib.parse.rst:394
msgid ""
"If *url* is an absolute URL (that is, it starts with ``//`` or "
"``scheme://``), the *url*'s hostname and/or scheme will be present in the "
"result.  For example:"
msgstr ""
"如果 *url* 为绝对 URL (即以 ``//`` 或 ``scheme://`` 打头)，则 *url* 的主机名和/或协议将出现在结果中。 "
"例如:"

#: ../../library/urllib.parse.rst:397
msgid ""
">>> urljoin('http://www.cwi.nl/%7Eguido/Python.html',\n"
"...         '//www.python.org/%7Eguido')\n"
"'http://www.python.org/%7Eguido'"
msgstr ""
">>> urljoin('http://www.cwi.nl/%7Eguido/Python.html',\n"
"...         '//www.python.org/%7Eguido')\n"
"'http://www.python.org/%7Eguido'"

#: ../../library/urllib.parse.rst:403
msgid ""
"If you do not want that behavior, preprocess the *url* with :func:`urlsplit`"
" and :func:`urlunsplit`, removing possible *scheme* and *netloc* parts."
msgstr ""
"如果你不想要那样的行为，请使用 :func:`urlsplit` 和 :func:`urlunsplit` 对 *url* 进行预处理，移除可能存在的 "
"*scheme* 和 *netloc* 部分。"

#: ../../library/urllib.parse.rst:408
msgid ""
"Because an absolute URL may be passed as the ``url`` parameter, it is "
"generally **not secure** to use ``urljoin`` with an attacker-controlled "
"``url``. For example in, ``urljoin(\"https://website.com/users/\", "
"username)``, if ``username`` can contain an absolute URL, the result of "
"``urljoin`` will be the absolute URL."
msgstr ""
"因为可以将一个绝对 URL 作为 ``url`` 形参传入，对由攻击者控制的 ``url`` 使用 ``urljoin`` 通常是 **不安全的**。 "
"例如，在 ``urljoin(\"https://website.com/users/\", username)`` 中，如果 ``username``"
" 可以包含一个绝对 URL，``urljoin`` 的结果也将为绝对 URL。"

#: ../../library/urllib.parse.rst:418
msgid "Behavior updated to match the semantics defined in :rfc:`3986`."
msgstr "更新行为以匹配 :rfc:`3986` 中定义的语义。"

#: ../../library/urllib.parse.rst:423
msgid ""
"If *url* contains a fragment identifier, return a modified version of *url* "
"with no fragment identifier, and the fragment identifier as a separate "
"string.  If there is no fragment identifier in *url*, return *url* "
"unmodified and an empty string."
msgstr ""
"如果 *url* 包含片段标识符，则返回不带片段标识符的 *url* 修改版本。 如果 *url* 中没有片段标识符，则返回未经修改的 *url* "
"和一个空字符串。"

#: ../../library/urllib.parse.rst:434
msgid ":attr:`url`"
msgstr ":attr:`url`"

#: ../../library/urllib.parse.rst:434
msgid "URL with no fragment"
msgstr "不带片段的 URL"

#: ../../library/urllib.parse.rst:439
msgid ""
"See section :ref:`urlparse-result-object` for more information on the result"
" object."
msgstr "请参阅 :ref:`urlparse-result-object` 一节了解有关结果对象的更多信息。"

#: ../../library/urllib.parse.rst:442
msgid "Result is a structured object rather than a simple 2-tuple."
msgstr "结果为已构造好的对象而不是一个简单的 2 元组。-tuple."

#: ../../library/urllib.parse.rst:447
msgid ""
"Extract the url from a wrapped URL (that is, a string formatted as "
"``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` or ``scheme://host/path``). If *url* is not a "
"wrapped URL, it is returned without changes."
msgstr ""
"从已包装的 URL (即被格式化为 ``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` 或 ``scheme://host/path`` 的字符串) 中提取 URL。 如果 *url* "
"不是一个已包装的 URL，它将被原样返回。"

#: ../../library/urllib.parse.rst:455
msgid "URL parsing security"
msgstr "URL 解析安全"

#: ../../library/urllib.parse.rst:457
msgid ""
"The :func:`urlsplit` and :func:`urlparse` APIs do not perform **validation**"
" of inputs.  They may not raise errors on inputs that other applications "
"consider invalid.  They may also succeed on some inputs that might not be "
"considered URLs elsewhere.  Their purpose is for practical functionality "
"rather than purity."
msgstr ""
":func:`urlsplit` 和 :func:`urlparse` API 不会对输入进行 **验证**。 "
"它们可能不会因其他应用程序认为不合法的输入而引发错误。 它们还可能在其他地方认为不是 URL 的输入上成功运行。 "
"它们的目标是达成实际的功能而不是保持纯净。"

#: ../../library/urllib.parse.rst:463
msgid ""
"Instead of raising an exception on unusual input, they may instead return "
"some component parts as empty strings. Or components may contain more than "
"perhaps they should."
msgstr "他们在非正常的输入上可能不会引发异常，而是以空字符串的形式返回某些部分。 或者可能会包含某些不应包含的部分。"

#: ../../library/urllib.parse.rst:467
msgid ""
"We recommend that users of these APIs where the values may be used anywhere "
"with security implications code defensively. Do some verification within "
"your code before trusting a returned component part.  Does that ``scheme`` "
"make sense?  Is that a sensible ``path``?  Is there anything strange about "
"that ``hostname``?  etc."
msgstr ""
"我们建议这些 API 的用户在任何使用的值具有安全意义的地方应用防御性代码。 在你的代码中进行某些验证之后再信任被返回的组件。 这个 "
"``scheme`` 合理吗？那个 ``path`` 正确吗？ 那个 ``hostname`` 是否存在怪异之处？等等。"

#: ../../library/urllib.parse.rst:473
msgid ""
"What constitutes a URL is not universally well defined.  Different "
"applications have different needs and desired constraints.  For instance the"
" living `WHATWG spec`_ describes what user facing web clients such as a web "
"browser require. While :rfc:`3986` is more general.  These functions "
"incorporate some aspects of both, but cannot be claimed compliant with "
"either.  The APIs and existing user code with expectations on specific "
"behaviors predate both standards leading us to be very cautious about making"
" API behavior changes."
msgstr ""
"一个 URL 由哪些内容组成并没有通用的良好定义。 不同应用程序有不同的需求和想要的约束。 举例来说现有的 `WHATWG spec`_ "
"描述了面向用户的 Web 客户端如 Web 浏览器的需求。 而 :rfc:`3986` 则更为一般化。 "
"这些函数涵盖了这两种领域的某些部分，但称不上能兼容任何一种。 这些 API 和早于这两个标准的现有用户代码对于其他特定行为的期望使得我们对 API "
"行为的更改变得非常谨慎。"

#: ../../library/urllib.parse.rst:484
msgid "Parsing ASCII Encoded Bytes"
msgstr "解析ASCII编码字节"

#: ../../library/urllib.parse.rst:486
msgid ""
"The URL parsing functions were originally designed to operate on character "
"strings only. In practice, it is useful to be able to manipulate properly "
"quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL "
"parsing functions in this module all operate on :class:`bytes` and "
":class:`bytearray` objects in addition to :class:`str` objects."
msgstr ""
"这些 URL 解析函数最初设计只用于操作字符串。 但在实践中，它也能够操作经过正确转码和编码的 ASCII 字节序列形式的 URL。 相应地，此模块中的"
" URL 解析函数既可以操作 :class:`str` 对象也可以操作 :class:`bytes` 和 :class:`bytearray` 对象。"

#: ../../library/urllib.parse.rst:492
msgid ""
"If :class:`str` data is passed in, the result will also contain only "
":class:`str` data. If :class:`bytes` or :class:`bytearray` data is passed "
"in, the result will contain only :class:`bytes` data."
msgstr ""
"如果传入 :class:`str` 数据，结果将只包含 :class:`str` 数据。 如果传入 :class:`bytes` 或 "
":class:`bytearray` 数据，则结果也将只包含 :class:`bytes` 数据。"

#: ../../library/urllib.parse.rst:496
msgid ""
"Attempting to mix :class:`str` data with :class:`bytes` or "
":class:`bytearray` in a single function call will result in a "
":exc:`TypeError` being raised, while attempting to pass in non-ASCII byte "
"values will trigger :exc:`UnicodeDecodeError`."
msgstr ""
"试图在单个函数调用中混用 :class:`str` 数据和 :class:`bytes` 或 :class:`bytearray` 数据将导致引发 "
":exc:`TypeError`，而试图传入非 ASCII 字节值则将引发 :exc:`UnicodeDecodeError`。"

#: ../../library/urllib.parse.rst:501
msgid ""
"To support easier conversion of result objects between :class:`str` and "
":class:`bytes`, all return values from URL parsing functions provide either "
"an :meth:`encode` method (when the result contains :class:`str` data) or a "
":meth:`decode` method (when the result contains :class:`bytes` data). The "
"signatures of these methods match those of the corresponding :class:`str` "
"and :class:`bytes` methods (except that the default encoding is ``'ascii'`` "
"rather than ``'utf-8'``). Each produces a value of a corresponding type that"
" contains either :class:`bytes` data (for :meth:`encode` methods) or "
":class:`str` data (for :meth:`decode` methods)."
msgstr ""
"为了支持结果对象在 :class:`str` 和 :class:`bytes` 之间方便地转换，所有来自 URL 解析函数的返回值都会提供 "
":meth:`encode` 方法 (当结果包含 :class:`str` 数据) 或 :meth:`decode` 方法 (当结果包含 "
":class:`bytes` 数据)。 这些方法的签名与 :class:`str` 和 :class:`bytes` 的对应方法相匹配 "
"(不同之处在于其默认编码格式是 ``'ascii'`` 而非 ``'utf-8'``)。 每个方法会输出包含相应类型的 :class:`bytes` "
"数据 (对于 :meth:`encode` 方法) 或 :class:`str` 数据 (对于 :meth:`decode` 方法) 的值。"

#: ../../library/urllib.parse.rst:512
msgid ""
"Applications that need to operate on potentially improperly quoted URLs that"
" may contain non-ASCII data will need to do their own decoding from bytes to"
" characters before invoking the URL parsing methods."
msgstr ""
"对于某些需要在有可能不正确地转码的包含非 ASCII 数据的 URL 上进行操作的应用程序来说，在唤起 URL 解析方法之前必须自行将字节串解码为字符。"

#: ../../library/urllib.parse.rst:516
msgid ""
"The behaviour described in this section applies only to the URL parsing "
"functions. The URL quoting functions use their own rules when producing or "
"consuming byte sequences as detailed in the documentation of the individual "
"URL quoting functions."
msgstr ""
"在本节中描述的行为仅适用于 URL 解析函数。 URL 转码函数在产生和消耗字节序列时使用它们自己的规则，详情参见单独 URL 转码函数的文档。"

#: ../../library/urllib.parse.rst:521
msgid "URL parsing functions now accept ASCII encoded byte sequences"
msgstr "URL 解析函数现在接受 ASCII 编码的字节序列"

#: ../../library/urllib.parse.rst:528
msgid "Structured Parse Results"
msgstr "结构化解析结果"

#: ../../library/urllib.parse.rst:530
msgid ""
"The result objects from the :func:`urlparse`, :func:`urlsplit`  and "
":func:`urldefrag` functions are subclasses of the :class:`tuple` type. These"
" subclasses add the attributes listed in the documentation for those "
"functions, the encoding and decoding support described in the previous "
"section, as well as an additional method:"
msgstr ""
":func:`urlparse`, :func:`urlsplit` 和 :func:`urldefrag` 函数的结果对象是 "
":class:`tuple` 类型的子类。 这些子类中增加了在那些函数的文档中列出的属性，之前小节中描述的编码和解码支持，以及一个附加方法:"

#: ../../library/urllib.parse.rst:538
msgid ""
"Return the re-combined version of the original URL as a string. This may "
"differ from the original URL in that the scheme may be normalized to lower "
"case and empty components may be dropped. Specifically, empty parameters, "
"queries, and fragment identifiers will be removed."
msgstr ""
"以字符串形式返回原始 URL 的重合并版本。 这可能与原始 URL 有所不同，例如协议的名称可能被正规化为小写字母、空的组成部分可能被丢弃。 "
"特别地，空的参数、查询和片段标识符将会被移除。"

#: ../../library/urllib.parse.rst:543
msgid ""
"For :func:`urldefrag` results, only empty fragment identifiers will be "
"removed. For :func:`urlsplit` and :func:`urlparse` results, all noted "
"changes will be made to the URL returned by this method."
msgstr ""
"对于 :func:`urldefrag` 的结果，只有空的片段标识符会被移除。 对于 :func:`urlsplit` 和 "
":func:`urlparse` 的结果，所有被记录的改变都会被应用到此方法所返回的 URL 上。"

#: ../../library/urllib.parse.rst:547
msgid ""
"The result of this method remains unchanged if passed back through the "
"original parsing function:"
msgstr "如果是通过原始的解析方法传回则此方法的结果会保持不变:"

#: ../../library/urllib.parse.rst:560
msgid ""
"The following classes provide the implementations of the structured parse "
"results when operating on :class:`str` objects:"
msgstr "下面的类提供了当在 :class:`str` 对象上操作时对结构化解析结果的实现:"

#: ../../library/urllib.parse.rst:565
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`DefragResultBytes` instance."
msgstr ""
"用于 :func:`urldefrag` 结果的实体类，包含有 :class:`str` 数据。 :meth:`encode` 方法会返回一个 "
":class:`DefragResultBytes` 实例。"

#: ../../library/urllib.parse.rst:573
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`ParseResultBytes` instance."
msgstr ""
"用于 :func:`urlparse` 结果的实体类，包含有 :class:`str` 数据。 :meth:`encode` 方法会返回一个 "
":class:`ParseResultBytes` 实例。"

#: ../../library/urllib.parse.rst:579
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`SplitResultBytes` instance."
msgstr ""
"用于 :func:`urlsplit` 结果的实体类，包含有 :class:`str` 数据。 :meth:`encode` 方法会返回一个 "
":class:`SplitResultBytes` 实例。"

#: ../../library/urllib.parse.rst:584
msgid ""
"The following classes provide the implementations of the parse results when "
"operating on :class:`bytes` or :class:`bytearray` objects:"
msgstr "下面的类提供了当在 :class:`bytes` 或 :class:`bytearray` 对象上操作时对解析结果的实现:"

#: ../../library/urllib.parse.rst:589
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`bytes` data."
" The :meth:`decode` method returns a :class:`DefragResult` instance."
msgstr ""
"用于 :func:`urldefrag` 结果的实体类，包含有 :class:`bytes` 数据。 :meth:`decode` 方法会返回一个 "
":class:`DefragResult` 实例。"

#: ../../library/urllib.parse.rst:597
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`ParseResult` instance."
msgstr ""
"用于 :func:`urlparse` 结果的实体类，包含有 :class:`bytes` 数据。 :meth:`decode` 方法会返回一个 "
":class:`ParseResult` 实例。"

#: ../../library/urllib.parse.rst:605
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`SplitResult` instance."
msgstr ""
"用于 :func:`urlsplit` 结果的实体类，包含有 :class:`bytes` 数据。 :meth:`decode` 方法会返回一个 "
":class:`SplitResult` 实例。"

#: ../../library/urllib.parse.rst:613
msgid "URL Quoting"
msgstr "URL 转码"

#: ../../library/urllib.parse.rst:615
msgid ""
"The URL quoting functions focus on taking program data and making it safe "
"for use as URL components by quoting special characters and appropriately "
"encoding non-ASCII text. They also support reversing these operations to "
"recreate the original data from the contents of a URL component if that task"
" isn't already covered by the URL parsing functions above."
msgstr ""
"URL 转码函数的功能是接收程序数据并通过对特殊字符进行转码并正确编码非 ASCII 文本来将其转为可以安全地用作 URL 组成部分的形式。 "
"它们还支持逆转此操作以便从作为 URL 组成部分的内容中重建原始数据，如果上述的 URL 解析函数还未覆盖此功能的话。"

#: ../../library/urllib.parse.rst:623
msgid ""
"Replace special characters in *string* using the :samp:`%{xx}` escape. "
"Letters, digits, and the characters ``'_.-~'`` are never quoted. By default,"
" this function is intended for quoting the path section of a URL. The "
"optional *safe* parameter specifies additional ASCII characters that should "
"not be quoted --- its default value is ``'/'``."
msgstr ""
"使用 :samp:`%{xx}` 转义符替换 *string* 中的特殊字符。 字母、数字和 ``'_.-~'`` 等字符一定不会被转码。 "
"在默认情况下，此函数只对 URL 的路径部分进行转码。 可选的 *safe* 形参额外指定不应被转码的 ASCII 字符 --- 其默认值为 "
"``'/'``。"

#: ../../library/urllib.parse.rst:629 ../../library/urllib.parse.rst:675
#: ../../library/urllib.parse.rst:704
msgid "*string* may be either a :class:`str` or a :class:`bytes` object."
msgstr "*string* 可以是 :class:`str` 或 :class:`bytes` 对象。"

#: ../../library/urllib.parse.rst:631
msgid ""
"Moved from :rfc:`2396` to :rfc:`3986` for quoting URL strings. \"~\" is now "
"included in the set of unreserved characters."
msgstr "从 :rfc:`2396` 迁移到 :rfc:`3986` 以转码 URL 字符串。 \"~\" 现在已被包括在非保留字符集中。"

#: ../../library/urllib.parse.rst:635
msgid ""
"The optional *encoding* and *errors* parameters specify how to deal with "
"non-ASCII characters, as accepted by the :meth:`str.encode` method. "
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'strict'``, "
"meaning unsupported characters raise a :class:`UnicodeEncodeError`. "
"*encoding* and *errors* must not be supplied if *string* is a "
":class:`bytes`, or a :class:`TypeError` is raised."
msgstr ""
"可选的 *encoding* 和 *errors* 形参指明如何处理非 ASCII 字符，与 :meth:`str.encode` 方法所接受的值一样。"
" *encoding* 默认为 ``'utf-8'``。 *errors* 默认为 ``'strict'``，表示不受支持的字符将引发 "
":class:`UnicodeEncodeError`。 如果 *string* 为 :class:`bytes` 则不可提供 *encoding* 和"
" *errors*，否则将引发 :class:`TypeError`。"

#: ../../library/urllib.parse.rst:643
msgid ""
"Note that ``quote(string, safe, encoding, errors)`` is equivalent to "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."
msgstr ""
"请注意 ``quote(string, safe, encoding, errors)`` 等价于 "
"``quote_from_bytes(string.encode(encoding, errors), safe)``。"

#: ../../library/urllib.parse.rst:646
msgid "Example: ``quote('/El Niño/')`` yields ``'/El%20Ni%C3%B1o/'``."
msgstr "例如: ``quote('/El Niño/')`` 将产生 ``'/El%20Ni%C3%B1o/'``。"

#: ../../library/urllib.parse.rst:651
msgid ""
"Like :func:`quote`, but also replace spaces with plus signs, as required for"
" quoting HTML form values when building up a query string to go into a URL. "
"Plus signs in the original string are escaped unless they are included in "
"*safe*.  It also does not have *safe* default to ``'/'``."
msgstr ""
"类似于 :func:`quote`，但还会使用加号来替换空格，如在构建放入 URL 的查询字符串时对于转码 HTML 表单值时所要求的那样。 "
"原始字符串中的加号会被转义，除非它们已包括在 *safe* 中。 它也不会将 *safe* 的默认值设为 ``'/'``。"

#: ../../library/urllib.parse.rst:656
msgid "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."
msgstr "例如: ``quote_plus('/El Niño/')`` 将产生 ``'%2FEl+Ni%C3%B1o%2F'``。"

#: ../../library/urllib.parse.rst:661
msgid ""
"Like :func:`quote`, but accepts a :class:`bytes` object rather than a "
":class:`str`, and does not perform string-to-bytes encoding."
msgstr ""
"类似于 :func:`quote`，但是接受 :class:`bytes` 对象而非 :class:`str`，并且不执行从字符串到字节串的编码。"

#: ../../library/urllib.parse.rst:664
msgid "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."
msgstr "例如: ``quote_from_bytes(b'a&\\xef')`` 将产生 ``'a%26%EF'``。"

#: ../../library/urllib.parse.rst:670
msgid ""
"Replace :samp:`%{xx}` escapes with their single-character equivalent. The "
"optional *encoding* and *errors* parameters specify how to decode percent-"
"encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"将 :samp:`%{xx}` 转义符替换为等效的单字符。 可选的 *encoding* 和 *errors* 形参指定如何将以百分号编码的序列解码为 "
"Unicode 字符，即 :meth:`bytes.decode` 方法所接受的形式。"

#: ../../library/urllib.parse.rst:677
msgid ""
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'replace'``, "
"meaning invalid sequences are replaced by a placeholder character."
msgstr ""
"*encoding* 默认为 ``'utf-8'``。 *errors* 默认为 ``'replace'``，表示无效的序列将被替换为占位字符。"

#: ../../library/urllib.parse.rst:681
msgid "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "例如: ``unquote('/El%20Ni%C3%B1o/')`` 将产生 ``'/El Niño/'``。"

#: ../../library/urllib.parse.rst:683
msgid ""
"*string* parameter supports bytes and str objects (previously only str)."
msgstr "*string* 形参支持 bytes 和 str 对象（之前仅支持 str）。"

#: ../../library/urllib.parse.rst:691
msgid ""
"Like :func:`unquote`, but also replace plus signs with spaces, as required "
"for unquoting HTML form values."
msgstr "类似于 :func:`unquote`，但还会将加号替换为空格，如反转码表单值所要求的。"

#: ../../library/urllib.parse.rst:694
msgid "*string* must be a :class:`str`."
msgstr "*string* 必须为 :class:`str`。"

#: ../../library/urllib.parse.rst:696
msgid "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "例如: ``unquote_plus('/El+Ni%C3%B1o/')`` 将产生 ``'/El Niño/'``。"

#: ../../library/urllib.parse.rst:701
msgid ""
"Replace :samp:`%{xx}` escapes with their single-octet equivalent, and return"
" a :class:`bytes` object."
msgstr "用等价的单八位形式替换 :samp:`%{xx}` 转义码，并返回一个 :class:`bytes` 对象。"

#: ../../library/urllib.parse.rst:706
msgid ""
"If it is a :class:`str`, unescaped non-ASCII characters in *string* are "
"encoded into UTF-8 bytes."
msgstr "如果它是 :class:`str`，则 *string* 中未转义的非 ASCII 字符会被编码为 UTF-8 字节串。"

#: ../../library/urllib.parse.rst:709
msgid "Example: ``unquote_to_bytes('a%26%EF')`` yields ``b'a&\\xef'``."
msgstr "例如: ``unquote_to_bytes('a%26%EF')`` y将产生 ``b'a&\\xef'``。"

#: ../../library/urllib.parse.rst:715
msgid ""
"Convert a mapping object or a sequence of two-element tuples, which may "
"contain :class:`str` or :class:`bytes` objects, to a percent-encoded ASCII "
"text string.  If the resultant string is to be used as a *data* for POST "
"operation with the :func:`~urllib.request.urlopen` function, then it should "
"be encoded to bytes, otherwise it would result in a :exc:`TypeError`."
msgstr ""
"将一个包含有 :class:`str` 或 :class:`bytes` 对象的映射对象或二元组序列转换为以百分号编码的 ASCII 文本字符串。 "
"如果所产生的字符串要被用作 :func:`~urllib.request.urlopen` 函数的 POST 操作的 "
"*data*，则它应当被编码为字节串，否则它将导致 :exc:`TypeError`。"

#: ../../library/urllib.parse.rst:722
msgid ""
"The resulting string is a series of ``key=value`` pairs separated by ``'&'``"
" characters, where both *key* and *value* are quoted using the *quote_via* "
"function.  By default, :func:`quote_plus` is used to quote the values, which"
" means spaces are quoted as a ``'+'`` character and '/' characters are "
"encoded as ``%2F``, which follows the standard for GET requests "
"(``application/x-www-form-urlencoded``).  An alternate function that can be "
"passed as *quote_via* is :func:`quote`, which will encode spaces as ``%20`` "
"and not encode '/' characters.  For maximum control of what is quoted, use "
"``quote`` and specify a value for *safe*."
msgstr ""
"结果字符串是一系列 ``key=value`` 对，由 ``'&'`` 字符进行分隔，其中 *key* 和 *value* 都已使用 "
"*quote_via* 函数转码。 在默认情况下，会使用 :func:`quote_plus` 来转码值，这意味着空格会被转码为 ``'+'`` 字符而"
" '/' 字符会被转码为 ``%2F``，即遵循 GET 请求的标准 (``application/x-www-form-urlencoded``)。 "
"另一个可以作为 *quote_via* 传入的替代函数是 :func:`quote`，它将把空格转码为 ``%20`` 并且不编码 '/' 字符。 "
"为了最大程度地控制要转码的内容，请使用 ``quote`` 并指定 *safe* 的值。"

#: ../../library/urllib.parse.rst:732
msgid ""
"When a sequence of two-element tuples is used as the *query* argument, the "
"first element of each tuple is a key and the second is a value. The value "
"element in itself can be a sequence and in that case, if the optional "
"parameter *doseq* evaluates to ``True``, individual ``key=value`` pairs "
"separated by ``'&'`` are generated for each element of the value sequence "
"for the key.  The order of parameters in the encoded string will match the "
"order of parameter tuples in the sequence."
msgstr ""
"当使用二元组序列作为 *query* 参数时，每个元组的第一个元素为键而第二个元素为值。 值元素本身也可以为一个序列，在那种情况下，如果可选的形参 "
"*doseq* 的值为 ``True``，则每个键的值序列元素生成单个 ``key=value`` 对（以 ``'&'`` 分隔）。 "
"被编码的字符串中的参数顺序将与序列中的形参元素顺序相匹配。"

#: ../../library/urllib.parse.rst:740
msgid ""
"The *safe*, *encoding*, and *errors* parameters are passed down to "
"*quote_via* (the *encoding* and *errors* parameters are only passed when a "
"query element is a :class:`str`)."
msgstr ""
"*safe*, *encoding* 和 *errors* 形参会被传递给 *quote_via* (*encoding* 和 *errors* "
"形参仅在查询元素为 :class:`str` 时会被传递)。"

#: ../../library/urllib.parse.rst:744
msgid ""
"To reverse this encoding process, :func:`parse_qs` and :func:`parse_qsl` are"
" provided in this module to parse query strings into Python data structures."
msgstr ""
"为了反向执行这个编码过程，此模块提供了 :func:`parse_qs` 和 :func:`parse_qsl` 来将查询字符串解析为 Python "
"数据结构。"

#: ../../library/urllib.parse.rst:747
msgid ""
"Refer to :ref:`urllib examples <urllib-examples>` to find out how the "
":func:`urllib.parse.urlencode` method can be used for generating the query "
"string of a URL or data for a POST request."
msgstr ""
"请参考 :ref:`urllib 示例 <urllib-examples>` 来了解如何使用 "
":func:`urllib.parse.urlencode` 方法来生成 URL 的查询字符串或 POST 请求的数据。"

#: ../../library/urllib.parse.rst:751
msgid "*query* supports bytes and string objects."
msgstr "查询支持字节和字符串对象。"

#: ../../library/urllib.parse.rst:754
msgid "Added the *quote_via* parameter."
msgstr "增加了 *quote_via* 形参。"

#: ../../library/urllib.parse.rst:760
msgid "`WHATWG`_ -  URL Living standard"
msgstr "`WHATWG`_ -  URL 现有标准"

#: ../../library/urllib.parse.rst:761
msgid ""
"Working Group for the URL Standard that defines URLs, domains, IP addresses,"
" the application/x-www-form-urlencoded format, and their API."
msgstr "定义 URL、域名、IP 地址、application/x-www-form-urlencoded 格式及其 API 的工作组。"

#: ../../library/urllib.parse.rst:764
msgid ":rfc:`3986` - Uniform Resource Identifiers"
msgstr ":rfc:`3986` - 统一资源标识符"

#: ../../library/urllib.parse.rst:765
msgid ""
"This is the current standard (STD66). Any changes to urllib.parse module "
"should conform to this. Certain deviations could be observed, which are "
"mostly for backward compatibility purposes and for certain de-facto parsing "
"requirements as commonly observed in major browsers."
msgstr ""
"这是当前的标准 (STD66)。 任何对于 urllib.parse 模块的修改都必须遵循该标准。 "
"某些偏离也可能会出现，这大都是出于向下兼容的目的以及特定的经常存在于各主要浏览器上的实际解析需求。"

#: ../../library/urllib.parse.rst:770
msgid ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."
msgstr ":rfc:`2732` - URL 中的 IPv6 Addresses 地址显示格式。"

#: ../../library/urllib.parse.rst:771
msgid "This specifies the parsing requirements of IPv6 URLs."
msgstr "这指明了 IPv6 URL 的解析要求。"

#: ../../library/urllib.parse.rst:773
msgid ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"
msgstr ":rfc:`2396` - 统一资源标识符（URI）：通用语法"

#: ../../library/urllib.parse.rst:774
msgid ""
"Document describing the generic syntactic requirements for both Uniform "
"Resource Names (URNs) and Uniform Resource Locators (URLs)."
msgstr "描述统一资源名称 (URN) 和统一资源定位符 (URL) 通用语义要求的文档。"

#: ../../library/urllib.parse.rst:777
msgid ":rfc:`2368` - The mailto URL scheme."
msgstr ":rfc:`2368` - mailto URL 模式。"

#: ../../library/urllib.parse.rst:778
msgid "Parsing requirements for mailto URL schemes."
msgstr "mailto URL 模式的解析要求。"

#: ../../library/urllib.parse.rst:780
msgid ":rfc:`1808` - Relative Uniform Resource Locators"
msgstr ":rfc:`1808` - 相对统一资源定位符"

#: ../../library/urllib.parse.rst:781
msgid ""
"This Request For Comments includes the rules for joining an absolute and a "
"relative URL, including a fair number of \"Abnormal Examples\" which govern "
"the treatment of border cases."
msgstr "这个请求注释包括联结绝对和相对 URL 的规则，其中包括大量控制边界情况处理的 \"异常示例\"。"

#: ../../library/urllib.parse.rst:785
msgid ":rfc:`1738` - Uniform Resource Locators (URL)"
msgstr ":rfc:`1738` - 统一资源定位符 (URL)"

#: ../../library/urllib.parse.rst:786
msgid "This specifies the formal syntax and semantics of absolute URLs."
msgstr "这指明了绝对 URL 的正式语义和句法。"

#: ../../library/urllib.parse.rst:9
msgid "WWW"
msgstr "WWW"

#: ../../library/urllib.parse.rst:9
msgid "World Wide Web"
msgstr "World Wide Web"

#: ../../library/urllib.parse.rst:9
msgid "URL"
msgstr "网址"

#: ../../library/urllib.parse.rst:9
msgid "parsing"
msgstr "解析"

#: ../../library/urllib.parse.rst:9
msgid "relative"
msgstr "相关"
