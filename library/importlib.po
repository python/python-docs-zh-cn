# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- :keyword:`!import` 的实现"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**源代码** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "概述"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr ":mod:`importlib` 包具有三重目标。"

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and"
" thus, by extension, the :func:`__import__` function) in Python source code."
" This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier"
" to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"一是在 Python 源代码中提供 :keyword:`import` 语句的实现（并且因此而扩展 :func:`__import__` 函数）。 "
"这提供了一个可移植到任何 Python 解释器的 :keyword:`!import` 实现。 与使用 Python "
"以外的编程语言实现的方式相比这一实现也更易于理解。"

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"第二个目的是实现 :keyword:`import` 的部分被公开在这个包中，使得用户更容易创建他们自己的自定义对象 (通常被称为 "
":term:`importer`) 来参与到导入过程中。"

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr "三，这个包也包含了对外公开用于管理 Python 包的各个方面的附加功能的模块:"

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ":mod:`importlib.metadata` 代表对来自第三方发行版的元数据的访问。"

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ":mod:`importlib.resources` 提供了用于对来自 Python 包的非代码“资源”的访问的例程。"

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 语句的语言参考"

#: ../../library/importlib.rst:46
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`包规格说明 <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"包的初始规范。自从编写这个文档开始，一些语义已经发生改变了（比如基于 :data:`sys.modules` 中 ``None`` 的重定向）。"

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 函数"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 语句是这个函数的语法糖。"

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ":ref:`sys-path-init`"

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr ":data:`sys.path` 的初始化。"

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "在忽略大小写的平台上进行导入"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "定义 Python 源代码编码"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "新导入钩子"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "导入：多行和绝对/相对"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "主模块显式相对导入"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "隐式命名空间包"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "导入系统的一个模块规范类型"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "消除PYO文件"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "多阶段扩展模块初始化"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "确定性的 pyc 文件"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "使用 UTF-8 作为默认的源编码"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "PYC 仓库目录"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "函数"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "内置 :func:`__import__` 函数的实现。"

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr "程序式地导入模块应该使用 :func:`import_module` 而不是这个函数。"

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set"
" to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"导入一个模块。 参数 *name* 指定了以绝对或相对导入方式导入什么模块 (比如要么像这样 ``pkg.mod`` 或者这样 ``..mod``)。 "
"如果参数 name 使用相对导入的方式来指定，那么 *package* 参数必须设置为那个包名，这个包名作为解析这个包名的锚点 (比如  "
"``import_module('..mod', 'pkg.subpkg')`` 将会导入 ``pkg.mod``)。"

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
":func:`import_module` 函数是一个对 :func:`importlib.__import__` 进行简化的包装器。 "
"这意味着该函数的所有语义都来自于 :func:`importlib.__import__`。 这两个函数之间最重要的不同点在于 "
":func:`import_module` 返回指定的包或模块 (例如 ``pkg.mod``)，而 :func:`__import__` "
"返回最高层级的包或模块 (例如 ``pkg``)。"

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"如果动态导入一个自解释器开始执行以来被创建的模块（即创建了一个 Python 源代码文件），为了让导入系统知道这个新模块，可能需要调用 "
":func:`invalidate_caches`。"

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "父包会被自动导入。"

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are"
" created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"使查找器存储在 :data:`sys.meta_path` 中的内部缓存无效。如果一个查找器实现了 "
"``invalidate_caches()``，那么它会被调用来执行那个无效过程。 "
"如果创建/安装任何模块，同时正在运行的程序是为了保证所有的查找器知道新模块的存在，那么应该调用这个函数。"

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr "当注意到相同命名空间已被导入之后在不同 :data:`sys.path` 位置中创建/安装的命名空间包。"

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"重新加载之前导入的 *module*。 那个参数必须是一个模块对象，所以它之前必须已经成功导入了。 "
"这在你已经使用外部编辑器编辑过了那个模块的源代码文件并且想在退出 Python 解释器之前试验这个新版本的模块的时候将很适用。 "
"函数的返回值是那个模块对象（如果重新导入导致一个不同的对象放置在 :data:`sys.modules` 中，那么那个模块对象是有可能会不同）。"

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr "当执行 :func:`reload` 的时候："

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the module."
"  The ``init`` function of extension modules is not called a second time."
msgstr ""
"Python 模块的代码会被重新编译并且那个模块级的代码被重新执行，通过重新使用一开始加载那个模块的 "
":term:`loader`，定义一个新的绑定在那个模块字典中的名称的对象集合。扩展模块的 ``init`` 函数不会被调用第二次。"

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr "与Python中的所有的其它对象一样，旧的对象只有在它们的引用计数为0之后才会被回收。"

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr "模块命名空间中的名称重新指向任何新的或更改后的对象。"

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr "其他旧对象的引用（例如那个模块的外部名称）不会被重新绑定到引用的新对象的，并且如果有需要，必须在出现的每个命名空间中进行更新。"

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "有一些其他注意事项："

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"当一个模块被重新加载的时候，它的字典（包含了那个模块的全区变量）会被保留。名称的重新定义会覆盖旧的定义，所以通常来说这不是问题。如果一个新模块没有定义在旧版本模块中定义的名称，则将保留旧版本中的定义。这一特性可用于作为那个模块的优点，如果它维护一个全局表或者对象的缓存"
" —— 使用 :keyword:`try` 语句，就可以测试表的存在并且跳过它的初始化，如果有需要的话::"

#: ../../library/importlib.rst:182
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"重新加载内置的或者动态加载模块，通常来说不是很有用处。不推荐重新加载\":mod:`sys`，:mod:`__main__`，:mod:`builtins`"
" 和其它关键模块。在很多例子中，扩展模块并不是设计为不止一次的初始化，并且当重新加载时，可能会以任意方式失败。"

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import`"
" and qualified names (*module.name*) instead."
msgstr ""
"如果一个模块使用 :keyword:`from` ... :keyword:`import` ... 导入的对象来自另外一个模块，给其它模块调用 "
":func:`reload` 不会重新定义来自这个模块的对象 —— 解决这个问题的一种方式是重新执行 :keyword:`!from` "
"语句，另一种方式是使用 :keyword:`!import` 和限定名称(*module.name*)来代替。"

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr "如果一个模块创建一个类的实例，重新加载定义那个类的模块不影响那些实例的方法定义———它们继续使用旧类中的定义。对于子类来说同样是正确的。"

#: ../../library/importlib.rst:205
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a "
":class:`~importlib.machinery.ModuleSpec`."
msgstr ""
"如果重新加载的模块缺少  :class:`~importlib.machinery.ModuleSpec` ，则会触发 "
":exc:`ModuleNotFoundError` 。"

#: ../../library/importlib.rst:210
msgid ""
"This function is not thread-safe. Calling it from multiple threads can "
"result in unexpected behavior. It's recommended to use the "
":class:`threading.Lock` or other synchronization primitives for thread-safe "
"module reloading."
msgstr ""

#: ../../library/importlib.rst:215
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` —— 关于导入的抽象基类"

#: ../../library/importlib.rst:220
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**源代码：** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:225
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base"
" classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` 模块包含了 :keyword:`import` 使用到的所有核心抽象基类。在实现核心的 ABCs "
"中，核心抽象基类的一些子类也提供了帮助。"

#: ../../library/importlib.rst:229
msgid "ABC hierarchy::"
msgstr "ABC 类的层次结构："

#: ../../library/importlib.rst:231
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"

#: ../../library/importlib.rst:244
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "一个代表 :term:`meta path finder` 的抽象基类。"

#: ../../library/importlib.rst:248 ../../library/importlib.rst:284
msgid "No longer a subclass of :class:`!Finder`."
msgstr "不再是 :class:`!Finder` 的子类。"

#: ../../library/importlib.rst:253
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`~module.__path__` from the parent package. If a spec "
"cannot be found, ``None`` is returned. When passed in, ``target`` is a "
"module object that the finder may use to make a more educated guess about "
"what spec to return. :func:`importlib.util.spec_from_loader` may be useful "
"for implementing concrete ``MetaPathFinders``."
msgstr ""
"一个用于查找指定模块的 :term:`spec <module spec>` 的抽象方法。 如果这是最高层级的导入，*path* 将为 "
"``None``。 在其他情况下，这将是对子包或模块的搜索而 *path* 将是来自上级包的 :attr:`~module.__path__` 值。 "
"如果找不到 spec，则返回 ``None``。 在传入时，``target`` 是一个被查找器用来对返回的 spec 进行更有依据的猜测的模块对象。 "
"在实现具体 ``MetaPathFinders`` 的时候 :func:`importlib.util.spec_from_loader` "
"将会很有用处。"

#: ../../library/importlib.rst:267
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"当被调用的时候，一个可选的方法应该将查找器使用的任何内部缓存进行无效。将在 :data:`sys.meta_path` "
"上的所有查找器的缓存进行无效的时候，这个函数被 :func:`importlib.invalidate_caches` 所使用。"

#: ../../library/importlib.rst:271
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr "当被调用时将返回 ``None`` 而不是 :data:`NotImplemented`。"

#: ../../library/importlib.rst:277
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by "
":class:`importlib.machinery.PathFinder`."
msgstr ""
"一个抽象基类，代表  :term:`path entry finder`。虽然与 :class:`MetaPathFinder` 有些相似之处，但 "
"`PathEntryFinder` 仅用于 :class:`importlib.machinery.PathFinder` "
"提供的基于路径的导入子系统中。"

#: ../../library/importlib.rst:289
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. "
":func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"一个抽象方法，用于查找指定模块的 :term:`spec <module spec>`。搜索器将只在指定的 :term:`path entry` "
"内搜索该模块。找不到则会返回 ``None``。在实现具体的 ``PathEntryFinders`` 代码时，可能会用到  "
":func:`importlib.util.spec_from_loader` 。"

#: ../../library/importlib.rst:301
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by "
":meth:`importlib.machinery.PathFinder.invalidate_caches` when invalidating "
"the caches of all cached finders."
msgstr ""
"可选方法，调用后应让查找器用到的所有内部缓存失效。要让所有缓存的查找器的缓存无效时，可供 "
":meth:`importlib.machinery.PathFinder.invalidate_caches` 调用。"

#: ../../library/importlib.rst:309
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ":term:`loader` 的抽象基类。 关于一个加载器的实际定义请查看 :pep:`302`。"

#: ../../library/importlib.rst:312
msgid ""
"Loaders that wish to support resource reading should implement a "
":meth:`get_resource_reader` method as specified by "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""
"想要支持资源读取的加载器应当实现 :class:`importlib.resources.abc.ResourceReader` 所规定的 "
":meth:`get_resource_reader` 方法。"

#: ../../library/importlib.rst:316
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "引入了可选的 :meth:`get_resource_reader` 方法。"

#: ../../library/importlib.rst:321
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr "当导入一个模块的时候，一个返回将要使用的那个模块对象的方法。这个方法可能返回 ``None`` ，这暗示着应该发生默认的模块创建语义。\""

#: ../../library/importlib.rst:327
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr "当 :meth:`exec_module` 已定义时此方法将不再是可选项。"

#: ../../library/importlib.rst:333
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, "
":meth:`create_module` must be defined."
msgstr ""
"当一个模块被导入或重新加载时在自己的命名空间中执行该模块的的抽象方法。 该模块在 :meth:`exec_module` 被调用时应该已经被初始化了。 "
"当此方法存在时，必须要定义 :meth:`create_module`。"

#: ../../library/importlib.rst:340
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` 也必须要定义。"

#: ../../library/importlib.rst:345
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr "用于加载模块的传统方法。 如果模块无法被导入，则会引发 :exc:`ImportError`，在其他情况下将返回被加载的模块。"

#: ../../library/importlib.rst:349
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module"
" and insert it into :data:`sys.modules` before any loading begins, to "
"prevent recursion from the import.  If the loader inserted a module and the "
"load fails, it must be removed by the loader from :data:`sys.modules`; "
"modules already in :data:`sys.modules` before the loader began execution "
"should be left alone."
msgstr ""
"如果请求的模块已存在于 :data:`sys.modules` 中，则该模块应当被使用并重新加载。 "
"在其他情况下加载器应当创建一个新模块并在任何加载操作开始之前将其插入到 :data:`sys.modules` 中，以防止来自导入的无限递归。 "
"如果加载器插入了一个模块并且加载失败，则必须用加载器将其从 :data:`sys.modules` 中移除；在加载器开始执行之前已经存在于 "
":data:`sys.modules` 中的模块应当保持原样。"

#: ../../library/importlib.rst:358
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr "加载器应当在模块上设置几个属性（请注意在模块被重新加载时这些属性有几个可能发生改变）:"

#: ../../library/importlib.rst:362
msgid ":attr:`module.__name__`"
msgstr ":attr:`module.__name__`"

#: ../../library/importlib.rst:363
msgid ":attr:`module.__file__`"
msgstr ":attr:`module.__file__`"

#: ../../library/importlib.rst:364
msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ":attr:`module.__cached__` *(已弃用)*"

#: ../../library/importlib.rst:365
msgid ":attr:`module.__path__`"
msgstr ":attr:`module.__path__`"

#: ../../library/importlib.rst:366
msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ":attr:`module.__package__` *(已弃用)*"

#: ../../library/importlib.rst:367
msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ":attr:`module.__loader__` *(已弃用)*"

#: ../../library/importlib.rst:369
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr "当 :meth:`exec_module` 可用的时候，那么则提供了向后兼容的功能。"

#: ../../library/importlib.rst:372
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`."
"  Functionality provided when :meth:`exec_module` is available."
msgstr ""
"当被调用时将引发 :exc:`ImportError` 而不是 :exc:`NotImplementedError`。 在 "
":meth:`exec_module` 可用时提供的功能。"

#: ../../library/importlib.rst:377
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
":meth:`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"用于加载模块的推荐 API 是 :meth:`exec_module` (和 :meth:`create_module`)。 加载器应该实现它而不是 "
":meth:`load_module`。 当实现了 :meth:`exec_module` 时导入机制将会承担 :meth:`load_module` "
"的所有其他责任。"

#: ../../library/importlib.rst:387 ../../library/importlib.rst:640
msgid "*Superseded by TraversableResources*"
msgstr "*被 TraversableResources* 取代"

#: ../../library/importlib.rst:389
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loading arbitrary resources from the storage back-"
"end."
msgstr "一个 :term:`loader` 的抽象基类，它实现了可选的 :pep:`302` 协议用于从存储后端加载任意资源。"

#: ../../library/importlib.rst:393
msgid ""
"This ABC is deprecated in favour of supporting resource loading through "
":class:`importlib.resources.abc.TraversableResources`."
msgstr ""
"这个 ABC 已被弃用并转为通过 :class:`importlib.resources.abc.TraversableResources` "
"来支持资源加载。"

#: ../../library/importlib.rst:400
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary"
" data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's "
":attr:`~module.__file__` attribute or an item from a package's "
":attr:`~module.__path__`."
msgstr ""
"一个返回用来表示位于 *path* 的数据的字节串的抽象方法。 具有允许存储任意数据的文件型存储后端的加载器能够实现这个抽象方法来直接访问被存储的数据。"
" 如果 *path* 无法找到则会引发 :exc:`OSError`。 *path* 应当使用一个模块的 module's "
":attr:`~module.__file__` 属性或来自某个包的 :attr:`~module.__path__` 中的条目来构造。"

#: ../../library/importlib.rst:409
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "引发 :exc:`OSError` 异常而不是 :exc:`NotImplementedError` 异常。"

#: ../../library/importlib.rst:415
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loaders that inspect modules."
msgstr "一个实现加载器检查模块可选的 :pep:`302` 协议的 :term:`loader` 的抽象基类。"

#: ../../library/importlib.rst:420
msgid ""
"Return the code object for a module, or ``None`` if the module does not have"
" a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"返回一个模块的代码对象，或如果模块没有一个代码对象（例如，对于内置的模块来说，这会是这种情况），则为 ``None``。 "
"如果加载器不能找到请求的模块，则引发 :exc:`ImportError` 异常。"

#: ../../library/importlib.rst:426
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr "当这个方法有一个默认的实现的时候，出于性能方面的考虑，如果有可能的话，建议覆盖它。"

#: ../../library/importlib.rst:432
msgid "No longer abstract and a concrete implementation is provided."
msgstr "不再抽象并且提供一个具体的实现。"

#: ../../library/importlib.rst:438
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is"
" available (e.g. a built-in module). Raises :exc:`ImportError` if the loader"
" cannot find the module specified."
msgstr ""
"一个返回模块源的抽象方法。使用 :term:`universal newlines` 作为文本字符串被返回，将所有可识别行分割符翻译成 "
"``'\\n'`` 字符。 如果没有可用的源（例如，一个内置模块），则返回 ``None``。 如果加载器不能找到指定的模块，则引发 "
":exc:`ImportError` 异常。"

#: ../../library/importlib.rst:444 ../../library/importlib.rst:453
#: ../../library/importlib.rst:504
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "引发 :exc:`ImportError` 而不是 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:449
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"可选方法，如果模块为包，则返回 True，否则返回 False。 如果 :term:`loader` 找不到模块，则会触发 "
":exc:`ImportError`。"

#: ../../library/importlib.rst:458
msgid "Create a code object from Python source."
msgstr "创建一个来自Python源码的代码对象。"

#: ../../library/importlib.rst:460
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports "
"(i.e. string or bytes). The *path* argument should be the \"path\" to where "
"the source code originated from, which can be an abstract concept (e.g. "
"location in a zip file)."
msgstr ""
"参数 *data* 可以是任意 :func:`compile` 函数支持的类型（例如字符串或字节串）。 参数 *path* "
"应该是源代码来源的路径，这可能是一个抽象概念（例如位于一个 zip 文件中）。"

#: ../../library/importlib.rst:465
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr "在有后续代码对象的情况下，可以在一个模块中通过运行 ``exec(code, module.__dict__)`` 来执行它。"

#: ../../library/importlib.rst:470
msgid "Made the method static."
msgstr "使得这个方法变成静态的。"

#: ../../library/importlib.rst:475
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` 的实现。"

#: ../../library/importlib.rst:481
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` 的实现。"

#: ../../library/importlib.rst:483
msgid "use :meth:`exec_module` instead."
msgstr "使用 :meth:`exec_module` 来代替。"

#: ../../library/importlib.rst:489
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when"
" implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"一个继承自 :class:`InspectLoader` 的抽象基类，当被实现时，帮助一个模块作为脚本来执行。 这个抽象基类表示可选的 "
":pep:`302` 协议。"

#: ../../library/importlib.rst:496
msgid ""
"An abstract method that is to return the value of :attr:`~module.__file__` "
"for the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""
"一个用于为指定模块返回 :attr:`~module.__file__` 的值的抽象方法。 如果没有可用的路径，则会引发 "
":exc:`ImportError`。"

#: ../../library/importlib.rst:500
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr "如果源代码可用，那么这个方法返回源文件的路径，不管是否是用来加载模块的字节码。"

#: ../../library/importlib.rst:510
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"一个继承自 :class:`ResourceLoader` 和 :class:`ExecutionLoader`，提供 "
":meth:`ResourceLoader.get_data` 和 :meth:`ExecutionLoader.get_filename` "
"具体实现的抽象基类。"

#: ../../library/importlib.rst:514
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is"
" to handle. The *path* argument is the path to the file for the module."
msgstr "参数 *fullname* 是加载器要处理的模块的完全解析的名字。参数 *path* 是模块文件的路径。"

#: ../../library/importlib.rst:521
msgid "The name of the module the loader can handle."
msgstr "加载器可以处理的模块的名字。"

#: ../../library/importlib.rst:525
msgid "Path to the file of the module."
msgstr "模块的文件路径"

#: ../../library/importlib.rst:529
msgid "Calls super's ``load_module()``."
msgstr "调用super的 ``load_module()``。"

#: ../../library/importlib.rst:531
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "使用 :meth:`Loader.exec_module` 来代替。"

#: ../../library/importlib.rst:537 ../../library/importlib.rst:1144
msgid "Returns :attr:`path`."
msgstr "返回 :attr:`path`。"

#: ../../library/importlib.rst:542
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "读取 *path* 作为二进制文件并且返回来自它的字节数据。"

#: ../../library/importlib.rst:547
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"一个用于实现源文件（和可选地字节码）加载的抽象基类。这个类继承自 :class:`ResourceLoader` 和 "
":class:`ExecutionLoader`，需要实现："

#: ../../library/importlib.rst:551
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:552
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:553
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr "应该是只返回源文件的路径；不支持无源加载。"

#: ../../library/importlib.rst:556
msgid ""
"The abstract methods defined by this class are to add optional bytecode file"
" support. Not implementing these optional methods (or causing them to raise "
":exc:`NotImplementedError`) causes the loader to only work with source code."
" Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"由这个类定义的抽象方法用来添加可选的字节码文件支持。不实现这些可选的方法（或导致它们引发 :exc:`NotImplementedError` "
"异常）导致这个加载器只能与源代码一起工作。 实现这些方法允许加载器能与源 *和* 字节码文件一起工作。不允许只提供字节码的 *无源式* "
"加载。字节码文件是通过移除 Python 编译器的解析步骤来加速加载的优化，并且因此没有开放出字节码专用的 API。"

#: ../../library/importlib.rst:567
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr "返回一个包含关于指定路径的元数据的 :class:`dict` 的可选的抽象方法。 支持的字典键有："

#: ../../library/importlib.rst:570
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr "``'mtime'`` (必选项): 一个表示源码修改时间的整数或浮点数；"

#: ../../library/importlib.rst:572
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (可选项)：源码的字节大小。"

#: ../../library/importlib.rst:574
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "字典中任何其他键会被忽略，以允许将来的扩展。 如果不能处理该路径，则会引发 :exc:`OSError`。"

#: ../../library/importlib.rst:579 ../../library/importlib.rst:592
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "引发 :exc:`OSError` 而不是 :exc:`NotImplemented`。"

#: ../../library/importlib.rst:584
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "返回指定文件路径修改时间的可选的抽象方法。"

#: ../../library/importlib.rst:587
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. Raise"
" :exc:`OSError` if the path cannot be handled."
msgstr ""
"在有了 :meth:`path_stats` 的情况下，这个方法被弃用了。 没必要去实现它了，但是为了兼容性，它依然处于可用状态。 "
"如果文件路径不能被处理，则引发 :exc:`OSError` 异常。"

#: ../../library/importlib.rst:597
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "往一个文件路径写入指定字节的的可选的抽象方法。任何中间不存在的目录不会被自动创建。"

#: ../../library/importlib.rst:601
msgid ""
"When writing to the path fails because the path is read-only "
"(:const:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"当对路径的写入因路径为只读而失败时 (:const:`errno.EACCES`/:exc:`PermissionError`)，不会传播异常。"

#: ../../library/importlib.rst:605
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "当被调用时，不再引起 :exc:`NotImplementedError` 异常。"

#: ../../library/importlib.rst:610
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code` 的具体实现。"

#: ../../library/importlib.rst:614
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` 的具体实现。"

#: ../../library/importlib.rst:620
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr " :meth:`Loader.load_module` 的具体实现。"

#: ../../library/importlib.rst:622
msgid "Use :meth:`exec_module` instead."
msgstr "使用 :meth:`exec_module` 来代替。"

#: ../../library/importlib.rst:627
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source` 的具体实现。"

#: ../../library/importlib.rst:631
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when the "
"file extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
":meth:`InspectLoader.is_package` 的具体实现。一个模块被确定为一个包的条件是：它的文件路径（由 "
":meth:`ExecutionLoader.get_filename` 提供）当文件扩展名被移除时是一个命名为 ``__init__`` "
"的文件，**并且** 这个模块名字本身不是以 ``__init__`` 结束。"

#: ../../library/importlib.rst:642
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr "提供读取 *resources* 能力的一个 :term:`abstract base class` 。"

#: ../../library/importlib.rst:645
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip"
" file versus on the file system."
msgstr ""
"从这个 ABC 的视角出发，*resource* 指一个包附带的二进制文件。常见的如在包的  ``__init__.py`` "
"文件旁的数据文件。这个类存在的目的是为了将对数据文件的访问进行抽象，这样包就和其数据文件的存储方式无关了。不论这些文件是存放在一个 zip "
"文件里还是直接在文件系统内。"

#: ../../library/importlib.rst:653
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a "
":term:`path-like object` which represents conceptually just a file name. "
"This means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names"
" is packages and resources, respectively. This is also why instances of this"
" class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"对于该类中的任一方法，*resource* 参数的值都需要是一个在概念上表示文件名称的 :term:`path-like object`。 "
"这意味着任何子目录的路径都不该出现在 *resouce* 参数值内。 因为对于阅读器而言，包的位置就代表着「目录」。 "
"因此目录和文件名就分别对应于包和资源。 这也是该类的实例都需要和一个包直接关联（而不是潜在指代很多包或者一整个模块）的原因。"

#: ../../library/importlib.rst:664
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible"
" with this ABC should only be returned when the specified module is a "
"package."
msgstr ""
"想支持资源读取的加载器需要提供一个返回实现了此 ABC 的接口的 ``get_resource_reader(fullname)`` "
"方法。如果通过全名指定的模块不是一个包，这个方法应该返回 :const:`None`。 "
"当指定的模块是一个包时，应该只返回一个与这个抽象类ABC兼容的对象。"

#: ../../library/importlib.rst:673 ../../library/importlib.rst:793
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr "使用 :class:`importlib.resources.abc.TraversableResources` 代替。"

#: ../../library/importlib.rst:679
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr "返回一个打开的 :term:`file-like object` 用于 *resource* 的二进制读取。"

#: ../../library/importlib.rst:682
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "如果无法找到资源，将会引发 :exc:`FileNotFoundError`。"

#: ../../library/importlib.rst:688
msgid "Returns the file system path to the *resource*."
msgstr "返回 *resource* 的文件系统路径。"

#: ../../library/importlib.rst:690
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr "如果资源并不实际存在于文件系统中，将会引发 :exc:`FileNotFoundError`。"

#: ../../library/importlib.rst:696
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"如果 *name* 被视作资源，则返回True。如果 *name* 不存在，则引发 :exc:`FileNotFoundError` 异常。"

#: ../../library/importlib.rst:702
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""
"反回由字符串组成的 :term:`iterable`，表示这个包的所有内容。 请注意并不要求迭代器返回的所有名称都是实际的资源，例如返回 "
":meth:`is_resource` 为假值的名称也是可接受的。"

#: ../../library/importlib.rst:708
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used "
"directly."
msgstr ""
"允许非资源名字被返回是为了允许存储的一个包和它的资源的方式是已知先验的并且非资源名字会有用的情况。比如，允许返回子目录名字，目的是当得知包和资源存储在文件系统上面的时候，能够直接使用子目录的名字。"

#: ../../library/importlib.rst:716
msgid "The abstract method returns an iterable of no items."
msgstr "这个抽象方法返回了一个不包含任何内容的可迭代对象。"

#: ../../library/importlib.rst:721
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr "一个具有 :class:`pathlib.Path` 中方法的子集并适用于遍历目录和打开文件的对象。"

#: ../../library/importlib.rst:724
msgid ""
"For a representation of the object on the file-system, use "
":meth:`importlib.resources.as_file`."
msgstr "对于该对象在文件系统中的表示形式，请使用 :meth:`importlib.resources.as_file`。"

#: ../../library/importlib.rst:729
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr "使用 :class:`importlib.resources.abc.Traversable` 代替。"

#: ../../library/importlib.rst:734
msgid "Abstract. The base name of this object without any parent references."
msgstr "抽象属性。 此对象的不带任何父引用的基本名称。"

#: ../../library/importlib.rst:739
msgid "Yield ``Traversable`` objects in ``self``."
msgstr "产出 ``self`` 中的 ``Traversable`` 对象。"

#: ../../library/importlib.rst:744
msgid "Return ``True`` if ``self`` is a directory."
msgstr "如果 ``self`` 是一个目录则返回 ``True``。"

#: ../../library/importlib.rst:749
msgid "Return ``True`` if ``self`` is a file."
msgstr "如果 ``self`` 是一个文件则返回 ``True``。"

#: ../../library/importlib.rst:754
msgid "Return Traversable child in ``self``."
msgstr "返回 ``self`` 中的 Traversable 子对象。"

#: ../../library/importlib.rst:759
msgid "Return ``Traversable`` child in ``self``."
msgstr "返回 ``self`` 中的 ``Traversable`` 子对象。"

#: ../../library/importlib.rst:764
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* 可以为 'r' 或 'rb' 即以文本或二进制模式打开。 返回一个适用于读取的句柄（与 :attr:`pathlib.Path.open`"
" 样同）。"

#: ../../library/importlib.rst:767
msgid ""
"When opening as text, accepts encoding parameters such as those accepted by "
":class:`io.TextIOWrapper`."
msgstr "当以文件模式打开时，接受与 :class:`io.TextIOWrapper` 所接受的相同编码格式形参。"

#: ../../library/importlib.rst:772
msgid "Read contents of ``self`` as bytes."
msgstr "以字节串形式读取 ``self`` 的内容。"

#: ../../library/importlib.rst:776
msgid "Read contents of ``self`` as text."
msgstr "以文本形式读取 ``self`` 的内容。"

#: ../../library/importlib.rst:781
msgid ""
"An abstract base class for resource readers capable of serving the "
":meth:`importlib.resources.files` interface. Subclasses "
":class:`importlib.resources.abc.ResourceReader` and provides concrete "
"implementations of the :class:`importlib.resources.abc.ResourceReader`'s "
"abstract methods. Therefore, any loader supplying "
":class:`importlib.abc.TraversableResources` also supplies ResourceReader."
msgstr ""
"针对能够为 :meth:`importlib.resources.files` 接口提供服务的资源读取器的抽象基类。 子类化 "
":class:`importlib.resources.abc.ResourceReader` 并为 "
":class:`importlib.resources.abc.ResourceReader` 的抽象方法提供具体实现。 因此，任何提供了 "
":class:`importlib.abc.TraversableResources` 的加载器也会提供 ResourceReader。"

#: ../../library/importlib.rst:788
msgid ""
"Loaders that wish to support resource reading are expected to implement this"
" interface."
msgstr "需要支持资源读取的加载器应实现此接口。"

#: ../../library/importlib.rst:799
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded"
" package."
msgstr "为载入的包返回一个 :class:`importlib.resources.abc.Traversable` 对象。"

#: ../../library/importlib.rst:805
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` —— 导入器和路径钩子函数。"

#: ../../library/importlib.rst:810
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**源代码：** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:814
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr "本模块包含多个对象，以帮助 :keyword:`import` 查找并加载模块。"

#: ../../library/importlib.rst:819
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "一个字符串列表，表示源模块的可识别的文件后缀。"

#: ../../library/importlib.rst:826
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr "一个字符串列表，表示未经优化字节码模块的文件后缀。"

#: ../../library/importlib.rst:831 ../../library/importlib.rst:841
msgid "Use :const:`BYTECODE_SUFFIXES` instead."
msgstr "改用 :const:`BYTECODE_SUFFIXES`。"

#: ../../library/importlib.rst:836
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "一个字符串列表，表示已优化字节码模块的文件后缀。"

#: ../../library/importlib.rst:846
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "一个字符串列表，表示字节码模块的可识别的文件后缀（包含前导的句点符号）。"

#: ../../library/importlib.rst:851
msgid "The value is no longer dependent on ``__debug__``."
msgstr "该值不再依赖于 ``__debug__`` 。"

#: ../../library/importlib.rst:856
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr "一个字符串列表，表示扩展模块的可识别的文件后缀。"

#: ../../library/importlib.rst:863
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a"
" module without needing any details on the kind of module (for example, "
":func:`inspect.getmodulename`)."
msgstr ""
"返回字符串的组合列表，代表标准导入机制可识别模块的所有文件后缀。这是个助手函数，只需知道某个文件系统路径是否会指向模块，而不需要任何关于模块种类的细节（例如"
" :func:`inspect.getmodulename`）。"

#: ../../library/importlib.rst:874
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"用于导入内置模块的 :term:`importer`。 所有已知的内置模块都已列入 :data:`sys.builtin_module_names`。 "
"此类实现了 :class:`importlib.abc.MetaPathFinder` 和 "
":class:`importlib.abc.InspectLoader` 抽象基类。"

#: ../../library/importlib.rst:879 ../../library/importlib.rst:893
#: ../../library/importlib.rst:906 ../../library/importlib.rst:921
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "此类只定义类的方法，以减轻实例化的开销。"

#: ../../library/importlib.rst:882
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
"作为 :pep:`489` 的一部分，现在内置模块导入器实现了 :meth:`Loader.create_module` 和 "
":meth:`Loader.exec_module`。"

#: ../../library/importlib.rst:889
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"用于已冻结模块的 :term:`importer`。 此类实现了 :class:`importlib.abc.MetaPathFinder` 和 "
":class:`importlib.abc.InspectLoader` 抽象基类。"

#: ../../library/importlib.rst:896
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` "
"methods."
msgstr "有了 :meth:`~Loader.create_module` 和 :meth:`~Loader.exec_module` 方法。"

#: ../../library/importlib.rst:903
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` 用于查找在 Windows 注册表中声明的模块。该类实现了基础的 "
":class:`importlib.abc.MetaPathFinder` 。"

#: ../../library/importlib.rst:911
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr "改用 :mod:`site` 配置。未来版本的 Python 可能不会默认启用该查找器。"

#: ../../library/importlib.rst:918
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"用于 :data:`sys.path` 和包的 ``__path__`` 属性的  :term:`Finder <finder>` 。该类实现了基础的 "
":class:`importlib.abc.MetaPathFinder`。"

#: ../../library/importlib.rst:926
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is found "
"then it is used as the :term:`path entry finder` to look for the module "
"being searched for. If no entry is found in :data:`sys.path_importer_cache`,"
" then :data:`sys.path_hooks` is searched for a finder for the path entry "
"and, if found, is stored in :data:`sys.path_importer_cache` along with being"
" queried about the module. If no finder is ever found then ``None`` is both "
"stored in the cache and returned."
msgstr ""
"类方法试图在 :data:`sys.path` 或 *path* 上为 *fullname* 指定的模块查找 :term:`spec <module "
"spec>`。对于每个路径条目，都会查看  :data:`sys.path_importer_cache` 。如果找到非 False 的对象，则将其用作"
" :term:`path entry finder` 来查找要搜索的模块。如果在 :data:`sys.path_importer_cache` "
"中没有找到条目，那会在 :data:`sys.path_hooks` 检索该路径条目的查找器，找到了则和查到的模块信息一起存入 "
":data:`sys.path_importer_cache` 。如果查找器没有找到，则缓存中的查找器和模块信息都存为 ``None`` ，然后返回。"

#: ../../library/importlib.rst:940
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"如果当前工作目录不再有效（用空字符串表示），则返回 ``None``，但在 :data:`sys.path_importer_cache` "
"中不会有缓存值。"

#: ../../library/importlib.rst:947
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders"
" stored in :data:`sys.path_importer_cache` that define the method. Otherwise"
" entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"为所有存于 :data:`sys.path_importer_cache` 中的查找器，调用其  "
":meth:`importlib.abc.PathEntryFinder.invalidate_caches` 方法。 "
":data:`sys.path_importer_cache` 中为 ``None`` 的条目将被删除。"

#: ../../library/importlib.rst:952
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ":data:`sys.path_importer_cache` 中为 ``None`` 的条目将被删除。"

#: ../../library/importlib.rst:955
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr "调用 :data:`sys.path_hooks` 中的对象，当前工作目录为 ``''`` (即空字符串)。"

#: ../../library/importlib.rst:962
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ":class:`importlib.abc.PathEntryFinder` 的一个具体实现，它会缓存来自文件系统的结果。"

#: ../../library/importlib.rst:965
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "参数 *path* 是查找器负责搜索的目录。"

#: ../../library/importlib.rst:968
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"*loader_details* "
"参数是数量不定的二元组，每个元组包含加载器及其可识别的文件后缀列表。加载器应为可调用对象，可接受两个参数，即模块的名称和已找到文件的路径。"

#: ../../library/importlib.rst:973
msgid ""
"The finder will cache the directory contents as necessary, making stat calls"
" for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure"
" to call :func:`importlib.invalidate_caches`."
msgstr ""
"查找器将按需对目录内容进行缓存，通过对每个模块的检索进行状态统计，验证缓存是否过期。因为缓存的滞后性依赖于操作系统文件系统状态信息的粒度，所以搜索模块、新建文件、然后搜索新文件代表的模块，这会存在竞争状态。如果这些操作的频率太快，甚至小于状态统计的粒度，那么模块搜索将会失败。为了防止这种情况发生，在动态创建模块时，请确保调用"
" :func:`importlib.invalidate_caches`。"

#: ../../library/importlib.rst:987
msgid "The path the finder will search in."
msgstr "查找器将要搜索的路径。"

#: ../../library/importlib.rst:991
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr "尝试在 :attr:`path` 中找到处理 *fullname* 的规格。"

#: ../../library/importlib.rst:997
msgid "Clear out the internal cache."
msgstr "清理内部缓存。"

#: ../../library/importlib.rst:1001
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An"
" instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"一个类方法，返回供 :data:`sys.path_hooks` 使用的闭包。 使用直接提供给闭包的路径参数和间接提供的 "
"*loader_details* 闭包将返回一个 :class:`FileFinder` 的实例。"

#: ../../library/importlib.rst:1006
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr "如果给闭包的参数不是已存在的目录，将会触发 :exc:`ImportError`。"

#: ../../library/importlib.rst:1012
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
":class:`importlib.abc.SourceLoader` 的一个具体实现，该实现子类化了 "
":class:`importlib.abc.FileLoader` 并提供了其他一些方法的具体实现。"

#: ../../library/importlib.rst:1020
msgid "The name of the module that this loader will handle."
msgstr "该加载器将要处理的模块名称。"

#: ../../library/importlib.rst:1024
msgid "The path to the source file."
msgstr "源文件的路径"

#: ../../library/importlib.rst:1028
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "如果 :attr:`path` 看似包的路径，则返回 ``True``。"

#: ../../library/importlib.rst:1032
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats` 的具体代码实现。"

#: ../../library/importlib.rst:1036
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data` 的具体代码实现。"

#: ../../library/importlib.rst:1040 ../../library/importlib.rst:1083
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ":meth:`importlib.abc.Loader.load_module` 的具体代码实现，这里要加载的模块名是可选的。"

#: ../../library/importlib.rst:1045 ../../library/importlib.rst:1088
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "改用 :meth:`importlib.abc.Loader.exec_module` 。"

#: ../../library/importlib.rst:1050
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ":class:`importlib.abc.FileLoader` 的具体代码实现，可导入字节码文件（也即源代码文件不存在）。"

#: ../../library/importlib.rst:1053
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations"
" or new versions of Python which change the bytecode format."
msgstr "请注意，直接用字节码文件（而不是源代码文件），会让模块无法应用于所有的 Python 版本或字节码格式有所改动的新版本 Python。"

#: ../../library/importlib.rst:1062
msgid "The name of the module the loader will handle."
msgstr "加载器将要处理的模块名。"

#: ../../library/importlib.rst:1066
msgid "The path to the bytecode file."
msgstr "二进制码文件的路径。"

#: ../../library/importlib.rst:1070
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "根据 :attr:`path` 确定该模块是否为包。"

#: ../../library/importlib.rst:1074
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "返回由 :attr:`path` 创建的 :attr:`name` 的代码对象。"

#: ../../library/importlib.rst:1078
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr "因为用此加载器时字节码文件没有源码文件，所以返回 ``None``。"

#: ../../library/importlib.rst:1093
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ":class:`importlib.abc.ExecutionLoader` 的具体代码实现，用于扩展模块。"

#: ../../library/importlib.rst:1096
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr "参数 *fullname* 指定了加载器要支持的模块名。参数 *path* 是指向扩展模块文件的路径。"

#: ../../library/importlib.rst:1099
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""
"请注意，在默认情况下，在子解释器中导入未实现多阶段初始化的扩展模块 (参见 :pep:`489`) 将会失败，即使在其他情况下能够成功导入。"

#: ../../library/importlib.rst:1105
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr "在子解释器中使用时需要多阶段初始化。"

#: ../../library/importlib.rst:1110 ../../library/importlib.rst:1296
msgid "Name of the module the loader supports."
msgstr "装载器支持的模块名。"

#: ../../library/importlib.rst:1114
msgid "Path to the extension module."
msgstr "扩展模块的路径。"

#: ../../library/importlib.rst:1118
msgid ""
"Creates the module object from the given specification in accordance with "
":pep:`489`."
msgstr "根据 :pep:`489` ，由给定规范创建模块对象。"

#: ../../library/importlib.rst:1125
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "根据 :pep:`489`，初始化给定的模块对象。"

#: ../../library/importlib.rst:1131
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :const:`EXTENSION_SUFFIXES`."
msgstr ""
"如果文件路径基于 :const:`EXTENSION_SUFFIXES` 指向某个包的 ``__init__`` 模块则返回 ``True``。"

#: ../../library/importlib.rst:1136
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "返回 ``None``，因为扩展模块缺少代码对象。"

#: ../../library/importlib.rst:1140
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "返回 ``None``，因为扩展模块没有源代码。"

#: ../../library/importlib.rst:1151
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace "
"packages::"
msgstr ""
"一个针对命名空间包的 :class:`importlib.abc.InspectLoader` 具体实现。 这是一个私有类的别名，仅为在命名空间包上内省"
" ``__loader__`` 属性而被设为公有::"

#: ../../library/importlib.rst:1156
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"

#: ../../library/importlib.rst:1169
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  Many "
"of these attributes are also available directly on a module: for example, "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`~module.__file__` at runtime and this will not be"
" automatically reflected in the module's :attr:`__spec__.origin "
"<ModuleSpec.origin>`, and vice versa."
msgstr ""
"针对特定模块的导入系统相关状态的规格说明。 这通常是作为模块的 :attr:`~module.__spec__` 属性对外公开。 "
"这类属性中有许多在模块上也直接可用：例如，``module.__spec__.origin == module.__file__``。 但是请注意，虽然"
" *值* 通常是相等的，但它们也可以因为两个对象之间没有进行同步而不相等。 举例来说，有可能在运行时更新模块的 "
":attr:`~module.__file__` 而这将不会自动反映在模块的 :attr:`__spec__.origin "
"<ModuleSpec.origin>` 中，反之亦然。"

#: ../../library/importlib.rst:1183
msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The "
":term:`finder` should always set this attribute to a non-empty string."
msgstr ""
"模块的完整限定名称 (参见 :attr:`module.__name__`)。 :term:`finder` 应当总是将该属性设为一个非空字符串。"

#: ../../library/importlib.rst:1188
msgid ""
"The :term:`loader` used to load the module (see :attr:`module.__loader__`). "
"The :term:`finder` should always set this attribute."
msgstr ""
"用于加载模块的 :term:`loader` (参见 :attr:`module.__loader__`)。 :term:`finder` "
"应当总是设置该属性。"

#: ../../library/importlib.rst:1193
msgid ""
"The location the :term:`loader` should use to load the module (see "
":attr:`module.__file__`). For example, for modules loaded from a ``.py`` "
"file this is the filename. The :term:`finder` should always set this "
"attribute to a meaningful value for the :term:`loader` to use.  In the "
"uncommon case that there is not one (like for namespace packages), it should"
" be set to ``None``."
msgstr ""
"应当被 :term:`loader` 用于加载模块的位置 (参见 :attr:`module.__file__`)。 例如，对于从 ``.py`` "
"新闻公报加载的模块来说这将为文件名。 :term:`finder` 应当总是将此属性设为一个有意义的值以供 :term:`loader` 使用。 "
"在没有可用值的少数情况下（如命名空间包），它应当被设为 ``None``。"

#: ../../library/importlib.rst:1202
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations in "
"which a package's submodules will be found (see :attr:`module.__path__`). "
"Most of the time there will only be a single directory in this list."
msgstr ""
"一个（可能为空的）枚举用于查找包中的子模块的位置的由字符串组成的 :term:`sequence` (参见 "
":attr:`module.__path__`)。 在大多数时候该列表中都将只有一个目录。"

#: ../../library/importlib.rst:1207
msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty "
"one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set automatically "
"later to a special object for namespace packages."
msgstr ""
":term:`finder` 应当将此属性设为一个序列，甚至可以为空序列，以向导入系统提示该模块是一个包。 对于非包模块它应当被设为 ``None``。"
" 对于命名空间包它会在稍后被自动设为一个特殊对象。"

#: ../../library/importlib.rst:1215
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""
":term:`finder` 可以将此属性设为一个包含额外的模块专属数据的对象供加载模块时使用。 在其他情况下应将其设为 ``None``。"

#: ../../library/importlib.rst:1221
msgid ""
"The filename of a compiled version of the module's code (see "
":attr:`module.__cached__`). The :term:`finder` should always set this "
"attribute but it may be ``None`` for modules that do not need compiled code "
"stored."
msgstr ""
"模块代码的已编译版本的文件名 (参见 :attr:`module.__cached__`)。 :term:`finder` "
"总是应当设置此属性但对于不需要存储已编译代码的模块来说它可以为 ``None``。"

#: ../../library/importlib.rst:1228
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the"
" empty string for a top-level module). See :attr:`module.__package__`. If "
"the module is a package then this is the same as :attr:`name`."
msgstr ""
"（只读）模块所在的包的完整限定名称（或者对于最高层级模块来说则空字符串）。 参见 :attr:`module.__package__`。 "
"如果模块是一个包则它将与 :attr:`name` 相同。"

#: ../../library/importlib.rst:1235
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is interpreted "
"and how the module's :attr:`~module.__file__` is populated."
msgstr ""
"如果 spec 的 :attr:`origin` 指向一个可加载的位置则为 ``True``，否则为 ``False``。 该值将确定如何解读 "
":attr:`!origin` 以及如何填充模块的 :attr:`~module.__file__`。"

#: ../../library/importlib.rst:1242
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is"
" able to load extension modules in Framework format."
msgstr ""
":class:`importlib.machinery.ExtensionFileLoader` 的一个专用版本，能以 Framework "
"格式加载扩展模块。"

#: ../../library/importlib.rst:1245
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app"
" must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can"
" be only a single binary per framework, and there can be no executable "
"binary material outside the Frameworks folder."
msgstr ""
"为了保持与 iOS App Store 的兼容性，在 iOS app 中的 *所有* "
"二进制模块都必须为动态库，包含在具有适当元数据的框架中，保存于被打包 app 的 ``Frameworks`` 文件夹下。 "
"每个框架只能有一个二进制模块，而在 Frameworks 文件夹之外不能有可执行的二进制模块。"

#: ../../library/importlib.rst:1251
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is be registered against the ``.fwork`` file extension, with a ``.fwork`` "
"file acting as a placeholder in the original location of the binary on "
"``sys.path``. The ``.fwork`` file contains the path of the actual binary in "
"the ``Frameworks`` folder, relative to the app bundle. To allow for "
"resolving a framework-packaged binary back to the original location, the "
"framework is expected to contain a ``.origin`` file that contains the "
"location of the ``.fwork`` file, relative to the app bundle."
msgstr ""
"为满足此要求，当在 iOS 上运行时，扩展模块二进制代码 *不会* 被打包为 ``sys.path`` 中的 ``.so`` "
"文件，而是作为单个的独立框架。 要发现这些框架，此加载器必须针对 ``.fwork`` 文件扩展名进行注册，并以一个 ``.fwork`` 文件作为 "
"``sys.path`` 中二进制代码的原始位置上的占位符。 ``.fwork`` 文件包含 ``Frameworks`` 文件夹中实际二进制文件相对于"
" app 包的路径。 为允许将框架打包的二进制代码解析到原始位置上，框架应当包含一个 ``.origin`` 文件，其中包含 ``.fwork`` "
"文件相对于 app 包的位置。"

#: ../../library/importlib.rst:1262
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module "
"``sources/foo/bar/_whiz.abi3.so``, with ``sources`` being the location "
"registered on ``sys.path``, relative to the application bundle. This module "
"*must* be distributed as "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (creating the framework"
" name from the full import path of the module), with an ``Info.plist`` file "
"in the ``.framework`` directory identifying the binary as a framework. The "
"``foo.bar._whiz`` module would be represented in the original location with "
"a ``sources/foo/bar/_whiz.abi3.fwork`` marker file, containing the path "
"``Frameworks/foo.bar._whiz/foo.bar._whiz``. The framework would also contain"
" ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, containing the"
" path to the ``.fwork`` file."
msgstr ""
"例如，考虑导入 ``from foo.bar import _whiz`` 的情况，其中 ``_whiz`` 是使用二进制模块 "
"``sources/foo/bar/_whiz.abi3.so`` 实现的，这里 ``sources`` 是在 ``sys.path`` 中注册的相对于"
" app 包的位置。 此模块 *必须* 发布为 ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz``"
" (根据模块的完整导入路径创建框架名称)，并通过 ``.framework`` 目录中的 ``Info.plist`` 文件将二进制文件标识为一个框架。"
" ``foo.bar._whiz`` 模块在原始位置中以一个 ``sources/foo/bar/_whiz.abi3.fwork`` "
"标记文件来代表，其中包含路径 ``Frameworks/foo.bar._whiz/foo.bar._whiz``。 该框架还要包含 "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``，其中包含 ``.fwork`` "
"文件的路径。"

#: ../../library/importlib.rst:1276
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traveral. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""
"当使用此加载器加载一个模块时，模块的 ``__file__`` 将被报告为 ``.fwork`` 文件的位置。 这允许代码使用模块的 "
"``__file__`` 作为文件系统遍历的锚点。 不过，原始规范说明将会引用 ``.framework`` 文件夹下 *实际* "
"二进制文件的位置。binary in the"

#: ../../library/importlib.rst:1282
msgid ""
"The Xcode project building the app is responsible for converting any ``.so``"
" files from wherever they exist in the ``PYTHONPATH`` into frameworks in the"
" ``Frameworks`` folder (including stripping extensions from the module file,"
" the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done"
" with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""
"构建 app 的 Xcode 项目要负责将存在于 ``PYTHONPATH`` 中的任何 ``.so`` 文件转换为 ``Frameworks`` "
"文件夹下的框架（包括从模块文件获取扩展，框架元数据的添加，以及结果框架的签名），并创建 ``.fwork`` 和 ``.origin`` 文件。 "
"这通常会在 Xcode 项目中使用一个构建步骤来完成；请参阅 iOS 文档了解有关如何构造此构建步骤的细节。"

#: ../../library/importlib.rst:1292
msgid "Availability"
msgstr "Availability"

#: ../../library/importlib.rst:1300
msgid "Path to the ``.fwork`` file for the extension module."
msgstr "扩展模块 ``.fwork`` 文件的路径。"

#: ../../library/importlib.rst:1304
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` —— 导入器的工具程序代码"

#: ../../library/importlib.rst:1310
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**源代码：** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1314
msgid ""
"This module contains the various objects that help in the construction of an"
" :term:`importer`."
msgstr "本模块包含了帮助构建 :term:`importer` 的多个对象。"

#: ../../library/importlib.rst:1319
msgid ""
"The bytes which represent the bytecode version number. If you need help with"
" loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"代表字节码版本号的字节串。若要有助于加载/写入字节码，可考虑采用  :class:`importlib.abc.SourceLoader`。"

#: ../../library/importlib.rst:1326
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python"
" 3.2. The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised)."
msgstr ""
"返回 :pep:`3147`/:pep:`488` 定义的，与源 *path* 相关联的已编译字节码文件的路径。 例如，如果 *path* 为 "
"``/foo/bar/baz.py`` 则 Python 3.2 中的返回值将是 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``。 字符串 ``cpython-32`` 来自于当前的魔法标签 "
"(参见 :func:`get_tag`; 如果 :attr:`sys.implementation.cache_tag` 未定义则将会引发 "
":exc:`NotImplementedError`)。"

#: ../../library/importlib.rst:1333
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpreter's optimization level to be used. Any other value's "
"string representation is used, so ``/foo/bar/baz.py`` with an *optimization*"
" of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string representation"
" of *optimization* can only be alphanumeric, else :exc:`ValueError` is "
"raised."
msgstr ""
"参数 *optimization* 用于指定字节码文件的优化级别。空字符串代表没有优化，所以 *optimization* 为  的 "
"``/foo/bar/baz.py``，将会得到字节码路径为 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``。``None`` "
"会导致采用解释器的优化。任何其他字符串都会被采用，所以 *optimization* 为 ``''`` 的 ``/foo/bar/baz.py`` "
"会导致字节码路径为 ``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``。*optimization* "
"字符串只能是字母数字，否则会触发 :exc:`ValueError`。"

#: ../../library/importlib.rst:1343
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the"
" system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as"
" setting *optimization* to ``1``. If both *debug_override* an *optimization*"
" are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* 参数已废弃，可用于覆盖系统的 ``__debug__`` 值。``True`` 值相当于将 "
"*optimization* 设为空字符串。``False`` 则相当于*optimization* 设为 ``1``。如果 "
"*debug_override* 和 *optimization* 都不为 ``None``，则会触发 :exc:`TypeError`。"

#: ../../library/importlib.rst:1351
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr "增加了 *optimization* 参数，废弃了 *debug_override* 参数。"

#: ../../library/importlib.rst:1355 ../../library/importlib.rst:1371
#: ../../library/importlib.rst:1460
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../library/importlib.rst:1361
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` or :pep:`488` format, a :exc:`ValueError` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"根据指向一个 :pep:`3147` 文件名的 *path*，返回相关联的源代码文件路径。 举例来说，如果 *path* 为 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` 则返回的路径将是 ``/foo/bar/baz.py``。 "
"*path* 不需要已存在，但如果它未遵循 :pep:`3147` 或 :pep:`488` 的格式，则会引发 :exc:`ValueError`。 "
"如果未定义 :attr:`sys.implementation.cache_tag`，则会引发 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:1376
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"对代表源代码的字节串进行解码，并将其作为带有通用换行符的字符串返回（符合 "
":meth:`importlib.abc.InspectLoader.get_source` 要求）。"

#: ../../library/importlib.rst:1384
msgid "Resolve a relative module name to an absolute one."
msgstr "将模块的相对名称解析为绝对名称。"

#: ../../library/importlib.rst:1386
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` without doing a check to see if the **package** argument "
"is needed."
msgstr ""
"如果 **name** 前面没有句点，那就简单地返回 **name**。这样就能采用 "
"``importlib.util.resolve_name('sys', __spec__.parent)`` 之类的写法，而无需检查是否需要 "
"**package** 参数。"

#: ../../library/importlib.rst:1391
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). "
":exc:`ImportError` is also raised if a relative name would escape its "
"containing package (e.g. requesting ``..bacon`` from within the ``spam`` "
"package)."
msgstr ""
"如果 **name** 是一个相对模块名称但 **package** 为假值（如为 ``None`` 或空字符串）则会引发 "
":exc:`ImportError`。 如果相对名称离开了其所在的包（如为从 ``spam`` 包请求 ``..bacon`` 的形式）则也会引发 "
":exc:`ImportError`。"

#: ../../library/importlib.rst:1399
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"为了改善与 import 语句的一致性，对于无效的相对导入尝试会引发 :exc:`ImportError` 而不是 :exc:`ValueError`。"

#: ../../library/importlib.rst:1406
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the"
" specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned"
" if no spec is found."
msgstr ""
"查找模块的 :term:`spec <module spec>`，可选择相对于指定的 **package** 名称。 如果该模块位于 "
":data:`sys.modules` 中，则会返回 ``sys.modules[name].__spec__`` (除非 spec 为 "
"``None`` 或未设置，在此情况下则会引发 :exc:`ValueError`)。 在其他情况下将使用 :data:`sys.meta_path` "
"进行搜索。 如果找不到任何 spec 则返回 ``None``。"

#: ../../library/importlib.rst:1413
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "如果 **name** 为一个子模块（带有一个句点），则会自动导入父级模块。"

#: ../../library/importlib.rst:1416
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name** 和 **package** 的用法与 :func:`import_module` 相同。"

#: ../../library/importlib.rst:1420
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`~module.__path__` "
"attribute)."
msgstr ""
"如果 **package** 实际上不是一个包（即缺少 :attr:`~module.__path__` 属性）则会引发 "
":exc:`ModuleNotFoundError` 而不是 :exc:`AttributeError`。"

#: ../../library/importlib.rst:1427
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"基于 **spec** 和 :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>` 创建一个新模块。"

#: ../../library/importlib.rst:1430
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"如果 :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"未返回 ``None``，那么先前已存在的属性不会被重置。另外，如果 :exc:`AttributeError` 是在访问 **spec** "
"或设置模块属性时触发的，则不会触发 。"

#: ../../library/importlib.rst:1435
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"本函数比 :class:`types.ModuleType` 创建新模块要好，因为用到 **spec** 模块设置了尽可能多的导入控制属性。"

#: ../../library/importlib.rst:1443
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do"
" for ModuleSpec.  The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"一个工厂函数，用于创建基于加载器的 :class:`~importlib.machinery.ModuleSpec` 实例。参数的含义与 "
"ModuleSpec 的相同。该函数会利用当前可用的 :term:`loader` API，比如 "
":meth:`InspectLoader.is_package`，以填充所有缺失的规格信息。"

#: ../../library/importlib.rst:1453
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in"
" on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"一个工厂函数，根据文件路径创建 :class:`~importlib.machinery.ModuleSpec` 实例。缺失的信息将根据 spec "
"进行填补，利用加载器 API ，以及模块基于文件的隐含条件。"

#: ../../library/importlib.rst:1465
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"以字节串的形式返回 *source_bytes* 的哈希值。基于哈希值的 ``.pyc`` 文件在头部嵌入了对应源文件内容的 "
":func:`source_hash`。"

#: ../../library/importlib.rst:1473
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""
"一个可以暂时跳过扩展模块兼容性检查的上下文管理器。 在默认情况下该检查将被启用并且当在子解释器中导入单阶段初始化模块时该检查会失败。 "
"如果多阶段初始化模块没有显式地支持针对子解释器的 GIL，那么当它在一个有自己的 GIL 的解释器中被导入时，该检查也会失败。"

#: ../../library/importlib.rst:1480
msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr "请注意该函数是为了适应一种不寻常的情况；这种情况可能最终会消失。 这很有可能不是你需要考虑的事情。"

#: ../../library/importlib.rst:1484
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr "你可以通过实现多阶段初始化的基本接口 (:pep:`489`) 并假装支持多解释器 (或解释器级的 GIL) 来获得与该函数相同的效果。"

#: ../../library/importlib.rst:1489
msgid ""
"Using this function to disable the check can lead to unexpected behavior and"
" even crashes.  It should only be used during extension module development."
msgstr "使用该函数来禁用检查可能会导致预期之外的行为甚至崩溃。 它应当仅在扩展模块开发过程中使用。"

#: ../../library/importlib.rst:1497
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr "此类会延迟执行模块加载器，直至该模块有一个属性被访问到。"

#: ../../library/importlib.rst:1500
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module type "
"is used for the module is required. For those same reasons, the loader's "
":meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a"
" type for which its ``__class__`` attribute can be mutated along with not "
"using :term:`slots <__slots__>`. Finally, modules which substitute the "
"object placed into :data:`sys.modules` will not work as there is no way to "
"properly replace the module references throughout the interpreter safely; "
":exc:`ValueError` is raised if such a substitution is detected."
msgstr ""
"此类 **仅仅** 适用于定义 :meth:`~importlib.abc.Loader.exec_module` "
"作为需要控制模块使用何种模块类型的加载器。 出于相同理由，加载器的 "
":meth:`~importlib.abc.Loader.create_module` 方法必须返回 ``None`` 或其 ``__class__``"
" 属性可被改变并且不使用 :term:`槽位 <__slots__>` 的类型。 最后，用于替换已放入 :data:`sys.modules` "
"的对象的模块将无法工作因为没有办法安全地在整个解释器中正确替换模块引用；  如果检测到这种替换则会引发 :exc:`ValueError`。"

#: ../../library/importlib.rst:1511
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For"
" projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"如果项目对启动时间要求很高，只要模块未被用过，此类能够最小化加载模块的开销。对于启动时间并不重要的项目来说，由于加载过程中产生的错误信息会被暂时搁置，因此强烈不建议使用此类。"

#: ../../library/importlib.rst:1519
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and "
":class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"开始调用 :meth:`~importlib.abc.Loader.create_module`，移除 "
":class:`importlib.machinery.BuiltinImporter` 和 "
":class:`importlib.machinery.ExtensionFileLoader` 的兼容性警告。"

#: ../../library/importlib.rst:1526
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr "一个返回创建延迟加载器的可调用对象的类方法。 这专门被用于加载器由类而不是实例来传入的场合。 ::"

#: ../../library/importlib.rst:1531
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"

#: ../../library/importlib.rst:1539
msgid "Examples"
msgstr "例子"

#: ../../library/importlib.rst:1542
msgid "Importing programmatically"
msgstr "用编程方式导入"

#: ../../library/importlib.rst:1544
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr "要以编程方式导入一个模块，请使用 :func:`importlib.import_module` ："

#: ../../library/importlib.rst:1547
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"

#: ../../library/importlib.rst:1553
msgid "Checking if a module can be imported"
msgstr "检查某模块可否导入。"

#: ../../library/importlib.rst:1555
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"如果你需要在不实际执行导入的情况下确定某个模块是否可被导入，则你应当使用 :func:`importlib.util.find_spec`。"

#: ../../library/importlib.rst:1558
msgid ""
"Note that if ``name`` is a submodule (contains a dot), "
":func:`importlib.util.find_spec` will import the parent module. ::"
msgstr ""
"请注意如果 ``name`` 是一个子模块（即包含一个点号），则 :func:`importlib.util.find_spec` 将会导入父模块。 "
"::"

#: ../../library/importlib.rst:1562
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"# 出于展示目的。\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # 如果你选择执行实际的导入 ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"

#: ../../library/importlib.rst:1581
msgid "Importing a source file directly"
msgstr "直接导入源码文件。"

#: ../../library/importlib.rst:1583
msgid ""
"This recipe should be used with caution: it is an approximation of an import"
" statement where the file path is specified directly, rather than "
":data:`sys.path` being searched. Alternatives should first be considered "
"first, such as modifying :data:`sys.path` when a proper module is required, "
"or using :func:`runpy.run_path` when the global namespace resulting from "
"running a Python file is appropriate."
msgstr ""
"这个专用方案应当谨慎使用：它是直接指明文件路径而不搜索 :data:`sys.path` 的 import 语句的近似物。 "
"应当首先考虑其他替代方案，比如在需要某个特定模块时修改 :data:`sys.path`，或在运行某个 Python 得到正确的全局命名空间时使用 "
":func:`runpy.run_path`。"

#: ../../library/importlib.rst:1590
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr "要直接从某个路径导入 Python 源文件，请使用以下写法::"

#: ../../library/importlib.rst:1592
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# 仅用于演示目的 (`json` 是随意选择的)。\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# 结果与 `import json` 类似。\n"
"json = import_from_path(module_name, file_path)"

#: ../../library/importlib.rst:1614
msgid "Implementing lazy imports"
msgstr "实现延迟导入"

#: ../../library/importlib.rst:1616
msgid "The example below shows how to implement lazy imports::"
msgstr "以下例子展示了如何实现延迟导入："

#: ../../library/importlib.rst:1618
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"

#: ../../library/importlib.rst:1637
msgid "Setting up an importer"
msgstr "导入器的配置"

#: ../../library/importlib.rst:1639
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to choose "
"from depending on your needs: a :term:`meta path finder` or a :term:`path "
"entry finder`. The former is what you would put on :data:`sys.meta_path` "
"while the latter is what you create using a :term:`path entry hook` on "
":data:`sys.path_hooks` which works with :data:`sys.path` entries to "
"potentially create a finder. This example will show you how to register your"
" own importers so that import will use them (for creating an importer for "
"yourself, read the documentation for the appropriate classes defined within "
"this package)::"
msgstr ""
"对于导入的深度定制，通常你需要实现一个 :term:`importer`。 这意味着同时管理 :term:`finder` 和 "
":term:`loader` 两方面。 对于查找器来说根据你的需求有两种类别可供选择: :term:`meta path finder` 或 "
":term:`path entry finder`。 前者你应当放到 :data:`sys.meta_path` 而后者是使用 :term:`path "
"entry hook` 在 :data:`sys.path_hooks` 上创建并与 :data:`sys.path` 条目一起创建一个潜在的查找器。 "
"下面的例子将向你演示如何注册自己的导入器供导入机制使用 (关于自行创建导入器，请阅读在本包内定义的相应类的文档)::"

#: ../../library/importlib.rst:1650
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# 仅用于展示目的。\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# 设置一个元路径查找器。\n"
"# 确保根据优先级别将查找器放在列表中正确的位置上。\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# 设置一个路径条目查找器。\n"
"# 确保根据优先级别将路径钩子放在列表中正确的位置上。\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"

#: ../../library/importlib.rst:1671
msgid "Approximating :func:`importlib.import_module`"
msgstr ":func:`importlib.import_module` 的近似实现"

#: ../../library/importlib.rst:1673
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"导入过程本身是用 Python 代码实现的，这样就有可能通过 importlib 来对外公开大部分导入机制。 以下代码通过提供 "
":func:`importlib.import_module` 的近似实现来说明 importlib 所公开的几种 API::"

#: ../../library/importlib.rst:1679
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"导入的近似实现。\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"

#: ../../library/importlib.rst:429
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/importlib.rst:429
msgid "importlib.abc.InspectLoader.get_source method"
msgstr "importlib.abc.InspectLoader.get_source 方法"
