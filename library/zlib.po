# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# sgqy <sgqyzh@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/zlib.rst:2
msgid ":mod:`!zlib` --- Compression compatible with :program:`gzip`"
msgstr ":mod:`!zlib` --- 与 :program:`gzip` 兼容的压缩"

#: ../../library/zlib.rst:10
msgid ""
"For applications that require data compression, the functions in this module"
" allow compression and decompression, using the zlib library. The zlib "
"library has its own home page at https://www.zlib.net.   There are known "
"incompatibilities between the Python module and versions of the zlib library"
" earlier than 1.1.3; 1.1.3 has a `security vulnerability "
"<https://zlib.net/zlib_faq.html#faq33>`_, so we recommend using 1.1.4 or "
"later."
msgstr ""
"对于需要数据压缩的应用，此模块中的函数允许使用 zlib 库进行压缩和解压缩。 zlib 库的项目主页是 https://www.zlib.net。 "
"已知此 Python 模块与 1.1.3 之前版本的 zlib 库存在不兼容；1.1.3 版则存在一个 `安全缺陷 "
"<https://zlib.net/zlib_faq.html#faq33>`_，因此我们推荐使用 1.1.4 或更新的版本。"

#: ../../library/zlib.rst:17
msgid ""
"zlib's functions have many options and often need to be used in a particular"
" order.  This documentation doesn't attempt to cover all of the "
"permutations; consult the zlib manual at http://www.zlib.net/manual.html for"
" authoritative information."
msgstr ""
"zlib 的函数有很多选项，一般需要按特定顺序使用。本文档没有覆盖全部的用法。更多详细信息请于 "
"http://www.zlib.net/manual.html 参阅官方手册。"

#: ../../library/zlib.rst:22
msgid "For reading and writing ``.gz`` files see the :mod:`gzip` module."
msgstr "要读写 ``.gz`` 格式的文件，请参考 :mod:`gzip` 模块。"

#: ../../library/zlib.rst:24
msgid "The available exception and functions in this module are:"
msgstr "此模块中可用的异常和函数如下："

#: ../../library/zlib.rst:29
msgid "Exception raised on compression and decompression errors."
msgstr "在压缩或解压缩过程中发生错误时的异常。"

#: ../../library/zlib.rst:34
msgid ""
"Computes an Adler-32 checksum of *data*.  (An Adler-32 checksum is almost as"
" reliable as a CRC32 but can be computed much more quickly.)  The result is "
"an unsigned 32-bit integer.  If *value* is present, it is used as the "
"starting value of the checksum; otherwise, a default value of 1 is used.  "
"Passing in *value* allows computing a running checksum over the "
"concatenation of several inputs.  The algorithm is not cryptographically "
"strong, and should not be used for authentication or digital signatures.  "
"Since the algorithm is designed for use as a checksum algorithm, it is not "
"suitable for use as a general hash algorithm."
msgstr ""
"计算 *data* 的 Adler-32 校验值。(Adler-32 校验的可靠性与 CRC32 基本相当，但比计算 CRC32 更高效。) "
"计算的结果是一个 32 位的整数。参数 *value* 是校验时的起始值，其默认值为 1。借助参数 *value* "
"可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。"

#: ../../library/zlib.rst:44 ../../library/zlib.rst:136
msgid "The result is always unsigned."
msgstr "结果将总是不带符号的。"

#: ../../library/zlib.rst:49
msgid ""
"Compresses the bytes in *data*, returning a bytes object containing "
"compressed data. *level* is an integer from ``0`` to ``9`` or ``-1`` "
"controlling the level of compression; ``1`` (Z_BEST_SPEED) is fastest and "
"produces the least compression, ``9`` (Z_BEST_COMPRESSION) is slowest and "
"produces the most.  ``0`` (Z_NO_COMPRESSION) is no compression. The default "
"value is ``-1`` (Z_DEFAULT_COMPRESSION).  Z_DEFAULT_COMPRESSION represents a"
" default compromise between speed and compression (currently equivalent to "
"level 6)."
msgstr ""
"压缩 *data* 中的字节，返回包含已压缩数据的字节串对象。 *level* 是一个用于控制压缩级别的 ``0`` 到 ``9`` 之间的整数或 "
"``-1``；``1`` (Z_BEST_SPEED) 表示最快速度和最低压缩率，``9`` (Z_BEST_COMPRESSION) "
"表示最慢速度和最高压缩率。 ``0`` (Z_NO_COMPRESSION) 表示不压缩。 默认值为 ``-1`` "
"(Z_DEFAULT_COMPRESSION)。 Z_DEFAULT_COMPRESSION 表示速度和压缩率折中的默认值 (目前相当于级别 6)。"

#: ../../library/zlib.rst:58
msgid ""
"The *wbits* argument controls the size of the history buffer (or the "
"\"window size\") used when compressing data, and whether a header and "
"trailer is included in the output.  It can take several ranges of values, "
"defaulting to ``15`` (MAX_WBITS):"
msgstr ""
"参数 *wbits* 指定压缩数据时所使用的历史缓冲区的大小 (窗口大小)，并指定压缩输出是否包含头部或尾部。参数的默认值是 ``15`` "
"(MAX_WBITS)。参数的值分为几个范围："

#: ../../library/zlib.rst:63
msgid ""
"+9 to +15: The base-two logarithm of the window size, which therefore ranges"
" between 512 and 32768.  Larger values produce better compression at the "
"expense of greater memory usage.  The resulting output will include a zlib-"
"specific header and trailer."
msgstr ""
"+9 至 +15：窗口大小以二为底的对数。 即这些值对应着 512 至 32768 的窗口大小。 更大的值会提供更好的压缩，同时内存开销也会更大。 "
"压缩输出会包含 zlib 特定格式的头部和尾部。"

#: ../../library/zlib.rst:68
msgid ""
"−9 to −15: Uses the absolute value of *wbits* as the window size logarithm, "
"while producing a raw output stream with no header or trailing checksum."
msgstr "−9 至 −15：绝对值为窗口大小以二为底的对数。 压缩输出仅包含压缩数据，没有头部和尾部。"

#: ../../library/zlib.rst:72
msgid ""
"+25 to +31 = 16 + (9 to 15): Uses the low 4 bits of the value as the window "
"size logarithm, while including a basic :program:`gzip` header and trailing "
"checksum in the output."
msgstr ""
"+25 至 +31 = 16 + (9 至 15)：后 4 个比特位为窗口大小以二为底的对数。 压缩输出包含一个基本的 :program:`gzip` "
"头部，并以校验和为尾部。"

#: ../../library/zlib.rst:76
msgid "Raises the :exc:`error` exception if any error occurs."
msgstr "如果发生任何错误则将引发 :exc:`error` 异常。"

#: ../../library/zlib.rst:78
msgid "*level* can now be used as a keyword parameter."
msgstr "现在，*level* 可作为关键字参数。"

#: ../../library/zlib.rst:81
msgid ""
"The *wbits* parameter is now available to set window bits and compression "
"type."
msgstr "现在可以用 *wbits* 形参来设置窗口位和压缩类型。"

#: ../../library/zlib.rst:87
msgid ""
"Returns a compression object, to be used for compressing data streams that "
"won't fit into memory at once."
msgstr "返回一个 压缩对象，用来压缩内存中难以容下的数据流。"

#: ../../library/zlib.rst:90
msgid ""
"*level* is the compression level -- an integer from ``0`` to ``9`` or "
"``-1``. A value of ``1`` (Z_BEST_SPEED) is fastest and produces the least "
"compression, while a value of ``9`` (Z_BEST_COMPRESSION) is slowest and "
"produces the most. ``0`` (Z_NO_COMPRESSION) is no compression.  The default "
"value is ``-1`` (Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION represents a "
"default compromise between speed and compression (currently equivalent to "
"level 6)."
msgstr ""
"参数 *level* 为压缩等级，是整数，可取值为 ``0`` 到 ``9`` 或 ``-1``。``1`` (Z_BEST_SPEED) "
"表示最快速度和最低压缩率，``9`` (Z_BEST_COMPRESSION) 表示最慢速度和最高压缩率。``0`` "
"(Z_NO_COMPRESSION) 表示不压缩。参数默认值为 ``-1`` "
"(Z_DEFAULT_COMPRESSION)。Z_DEFAULT_COMPRESSION 是速度和压缩率之间的平衡 (一般相当于设压缩等级为 6)。"

#: ../../library/zlib.rst:97
msgid ""
"*method* is the compression algorithm. Currently, the only supported value "
"is :const:`DEFLATED`."
msgstr "*method* 表示压缩算法。现在只支持 :const:`DEFLATED` 这个算法。"

#: ../../library/zlib.rst:100
msgid ""
"The *wbits* parameter controls the size of the history buffer (or the "
"\"window size\"), and what header and trailer format will be used. It has "
"the same meaning as `described for compress() <#compress-wbits>`__."
msgstr ""
"*wbits* 形参控制历史缓冲区的大小（或称“窗口大小”），以及将要使用的头部和尾部格式。 它的含义与 `对 compress() 的描述 "
"<#compress-wbits>`__ 相同。"

#: ../../library/zlib.rst:104
msgid ""
"The *memLevel* argument controls the amount of memory used for the internal "
"compression state. Valid values range from ``1`` to ``9``. Higher values use"
" more memory, but are faster and produce smaller output."
msgstr ""
"参数 *memLevel* 指定内部压缩操作时所占用内存大小。参数取 ``1`` 到 ``9``。更大的值占用更多的内存，同时速度也更快输出也更小。"

#: ../../library/zlib.rst:108
msgid ""
"*strategy* is used to tune the compression algorithm. Possible values are "
":const:`Z_DEFAULT_STRATEGY`, :const:`Z_FILTERED`, :const:`Z_HUFFMAN_ONLY`, "
":const:`Z_RLE` (zlib 1.2.0.1) and :const:`Z_FIXED` (zlib 1.2.2.2)."
msgstr ""
"参数 *strategy* 用于调节压缩算法。可取值为  "
":const:`Z_DEFAULT_STRATEGY`、:const:`Z_FILTERED`、:const:`Z_HUFFMAN_ONLY`、:const:`Z_RLE`"
" (zlib 1.2.0.1) 或 :const:`Z_FIXED` (zlib 1.2.2.2)。"

#: ../../library/zlib.rst:112
msgid ""
"*zdict* is a predefined compression dictionary. This is a sequence of bytes "
"(such as a :class:`bytes` object) containing subsequences that are expected "
"to occur frequently in the data that is to be compressed. Those subsequences"
" that are expected to be most common should come at the end of the "
"dictionary."
msgstr ""
"参数 *zdict* 指定预定义的压缩字典。它是一个字节序列 (如 :class:`bytes` "
"对象)，其中包含用户认为要压缩的数据中可能频繁出现的子序列。频率高的子序列应当放在字典的尾部。"

#: ../../library/zlib.rst:117
msgid "Added the *zdict* parameter and keyword argument support."
msgstr "添加关键字参数 *zdict*。"

#: ../../library/zlib.rst:127
msgid ""
"Computes a CRC (Cyclic Redundancy Check) checksum of *data*. The result is "
"an unsigned 32-bit integer. If *value* is present, it is used as the "
"starting value of the checksum; otherwise, a default value of 0 is used.  "
"Passing in *value* allows computing a running checksum over the "
"concatenation of several inputs.  The algorithm is not cryptographically "
"strong, and should not be used for authentication or digital signatures.  "
"Since the algorithm is designed for use as a checksum algorithm, it is not "
"suitable for use as a general hash algorithm."
msgstr ""
"计算 *data* 的 CRC (循环冗余校验) 值。计算的结果是一个 32 位的整数。参数 *value* 是校验时的起始值，其默认值为 0。借助参数"
" *value* 可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。"

#: ../../library/zlib.rst:141
msgid ""
"Decompresses the bytes in *data*, returning a bytes object containing the "
"uncompressed data.  The *wbits* parameter depends on the format of *data*, "
"and is discussed further below. If *bufsize* is given, it is used as the "
"initial size of the output buffer.  Raises the :exc:`error` exception if any"
" error occurs."
msgstr ""
"解压 *data* 中的字节，返回含有已解压内容的 bytes 对象。参数 *wbits* 取决于 *data* "
"的格式，具体参见下边的说明。*bufsize* 为输出缓冲区的起始大小。函数发生错误时抛出 :exc:`error` 异常。"

#: ../../library/zlib.rst:149
msgid ""
"The *wbits* parameter controls the size of the history buffer (or \"window "
"size\"), and what header and trailer format is expected. It is similar to "
"the parameter for :func:`compressobj`, but accepts more ranges of values:"
msgstr ""
"*wbits* 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它类似于 :func:`compressobj` "
"的形参，但可接受更大范围的值："

#: ../../library/zlib.rst:154
msgid ""
"+8 to +15: The base-two logarithm of the window size.  The input must "
"include a zlib header and trailer."
msgstr "+8 至 +15：窗口尺寸以二为底的对数。 输入必须包含 zlib 头部和尾部。"

#: ../../library/zlib.rst:157
msgid ""
"0: Automatically determine the window size from the zlib header. Only "
"supported since zlib 1.2.3.5."
msgstr "0：根据 zlib 头部自动确定窗口大小。 只从 zlib 1.2.3.5 版起受支持。"

#: ../../library/zlib.rst:160
msgid ""
"−8 to −15: Uses the absolute value of *wbits* as the window size logarithm."
"  The input must be a raw stream with no header or trailer."
msgstr "−8 至 −15：使用 *wbits* 的绝对值作为窗口大小以二为底的对数。 输入必须为原始数据流，没有头部和尾部。"

#: ../../library/zlib.rst:163
msgid ""
"+24 to +31 = 16 + (8 to 15): Uses the low 4 bits of the value as the window "
"size logarithm.  The input must include a gzip header and trailer."
msgstr "+24 至 +31 = 16 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数。 输入必须包括 gzip 头部和尾部。"

#: ../../library/zlib.rst:167
msgid ""
"+40 to +47 = 32 + (8 to 15): Uses the low 4 bits of the value as the window "
"size logarithm, and automatically accepts either the zlib or gzip format."
msgstr ""
"+40 至 +47 = 32 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数，并且自动接受 zlib 或 gzip 格式。"

#: ../../library/zlib.rst:171
msgid ""
"When decompressing a stream, the window size must not be smaller than the "
"size originally used to compress the stream; using a too-small value may "
"result in an :exc:`error` exception. The default *wbits* value corresponds "
"to the largest window size and requires a zlib header and trailer to be "
"included."
msgstr ""
"当解压缩一个数据流时，窗口大小必须不小于用于压缩数据流的原始窗口大小；使用太小的值可能导致 :exc:`error` 异常。 默认 *wbits* "
"值对应于最大的窗口大小并且要求包括 zlib 头部和尾部。"

#: ../../library/zlib.rst:177
msgid ""
"*bufsize* is the initial size of the buffer used to hold decompressed data."
"  If more space is required, the buffer size will be increased as needed, so"
" you don't have to get this value exactly right; tuning it will only save a "
"few calls to :c:func:`malloc`."
msgstr ""
"*bufsize* 是用于存放解压数据的缓冲区初始大小。 "
"如果需要更大空间，缓冲区大小将按需增加，因此你不需要让这个值完全精确；对其进行调整仅会节省一点对 :c:func:`malloc` 的调用次数。"

#: ../../library/zlib.rst:182
msgid "*wbits* and *bufsize* can be used as keyword arguments."
msgstr "*wbits* 和 *bufsize* 可用作关键字参数。"

#: ../../library/zlib.rst:187
msgid ""
"Returns a decompression object, to be used for decompressing data streams "
"that won't fit into memory at once."
msgstr "返回一个解压对象，用来解压无法被一次性放入内存的数据流。"

#: ../../library/zlib.rst:190
msgid ""
"The *wbits* parameter controls the size of the history buffer (or the "
"\"window size\"), and what header and trailer format is expected.  It has "
"the same meaning as `described for decompress() <#decompress-wbits>`__."
msgstr ""
"*wbits* 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它的含义与 `对 decompress() 的描述 "
"<#decompress-wbits>`__ 相同。"

#: ../../library/zlib.rst:194
msgid ""
"The *zdict* parameter specifies a predefined compression dictionary. If "
"provided, this must be the same dictionary as was used by the compressor "
"that produced the data that is to be decompressed."
msgstr "*zdict* 形参指定指定一个预定义的压缩字典。 如果提供了此形参，它必须与产生将解压数据的压缩器所使用的字典相同。"

#: ../../library/zlib.rst:200
msgid ""
"If *zdict* is a mutable object (such as a :class:`bytearray`), you must not "
"modify its contents between the call to :func:`decompressobj` and the first "
"call to the decompressor's ``decompress()`` method."
msgstr ""
"如果 *zdict* 是一个可变对象 (例如 :class:`bytearray`)，则你不可在对 :func:`decompressobj` "
"的调用和对解压器的 ``decompress()`` 方法的调用之间修改其内容。"

#: ../../library/zlib.rst:204
msgid "Added the *zdict* parameter."
msgstr "增加了 *zdict* 形参。"

#: ../../library/zlib.rst:208
msgid "Compression objects support the following methods:"
msgstr "压缩对象支持以下方法："

#: ../../library/zlib.rst:213
msgid ""
"Compress *data*, returning a bytes object containing compressed data for at "
"least part of the data in *data*.  This data should be concatenated to the "
"output produced by any preceding calls to the :meth:`compress` method.  Some"
" input may be kept in internal buffers for later processing."
msgstr ""
"压缩 *data* 并返回 bytes 对象，这个对象含有 *data* 的部分或全部内容的已压缩数据。所得的对象必须拼接在上一次调用 "
":meth:`compress` 方法所得数据的后面。缓冲区中可能留存部分输入以供下一次调用。"

#: ../../library/zlib.rst:221
msgid ""
"All pending input is processed, and a bytes object containing the remaining "
"compressed output is returned.  *mode* can be selected from the constants "
":const:`Z_NO_FLUSH`, :const:`Z_PARTIAL_FLUSH`, :const:`Z_SYNC_FLUSH`, "
":const:`Z_FULL_FLUSH`, :const:`Z_BLOCK` (zlib 1.2.3.4), or "
":const:`Z_FINISH`, defaulting to :const:`Z_FINISH`.  Except "
":const:`Z_FINISH`, all constants allow compressing further bytestrings of "
"data, while :const:`Z_FINISH` finishes the compressed stream and prevents "
"compressing any more data.  After calling :meth:`flush` with *mode* set to "
":const:`Z_FINISH`, the :meth:`compress` method cannot be called again; the "
"only realistic action is to delete the object."
msgstr ""
"压缩所有缓冲区的数据并返回已压缩的数据。参数 *mode* "
"可以传入的常量为：:const:`Z_NO_FLUSH`、:const:`Z_PARTIAL_FLUSH`、:const:`Z_SYNC_FLUSH`、:const:`Z_FULL_FLUSH`、:const:`Z_BLOCK`"
" (zlib 1.2.3.4) 或 :const:`Z_FINISH`。默认值为 :const:`Z_FINISH`。:const:`Z_FINISH`"
" 关闭已压缩数据流并不允许再压缩其他数据，:const:`Z_FINISH`  以外的值皆允许这个对象继续压缩数据。调用 :meth:`flush` "
"方法并将 *mode* 设为 :const:`Z_FINISH` 后会无法再次调用 :meth:`compress`，此时只能删除这个对象。"

#: ../../library/zlib.rst:234
msgid ""
"Returns a copy of the compression object.  This can be used to efficiently "
"compress a set of data that share a common initial prefix."
msgstr "返回此压缩对象的一个拷贝。它可以用来高效压缩一系列拥有相同前缀的数据。"

#: ../../library/zlib.rst:238
msgid ""
"Added :func:`copy.copy` and :func:`copy.deepcopy` support to compression "
"objects."
msgstr "添加了对压缩对象执行 :func:`copy.copy` 和 :func:`copy.deepcopy` 的支持。"

#: ../../library/zlib.rst:243
msgid "Decompression objects support the following methods and attributes:"
msgstr "解压缩对象支持以下方法："

#: ../../library/zlib.rst:248
msgid ""
"A bytes object which contains any bytes past the end of the compressed data."
" That is, this remains ``b\"\"`` until the last byte that contains "
"compression data is available.  If the whole bytestring turned out to "
"contain compressed data, this is ``b\"\"``, an empty bytes object."
msgstr ""
"一个 bytes 对象，其中包含压缩数据结束之后的任何字节数据。 也就是说，它将为 ``b\"\"`` 直到包含压缩数据的末尾字节可用。 "
"如果整个结果字节串都包含压缩数据，它将为一个空的 bytes 对象 ``b\"\"``。"

#: ../../library/zlib.rst:256
msgid ""
"A bytes object that contains any data that was not consumed by the last "
":meth:`decompress` call because it exceeded the limit for the uncompressed "
"data buffer.  This data has not yet been seen by the zlib machinery, so you "
"must feed it (possibly with further data concatenated to it) back to a "
"subsequent :meth:`decompress` method call in order to get correct output."
msgstr ""
"一个 bytes 对象，其中包含未被上一次 :meth:`decompress` 调用所消耗的任何数据。 此数据不能被 zlib "
"机制看到，因此你必须将其送回（可能要附带额外的数据拼接）到后续的 :meth:`decompress` 方法调用以获得正确的输出。"

#: ../../library/zlib.rst:265
msgid ""
"A boolean indicating whether the end of the compressed data stream has been "
"reached."
msgstr "一个布尔值，指明是否已到达压缩数据流的末尾。"

#: ../../library/zlib.rst:268
msgid ""
"This makes it possible to distinguish between a properly formed compressed "
"stream, and an incomplete or truncated one."
msgstr "这使得区分正确构造的压缩数据流和不完整或被截断的流成为可能。"

#: ../../library/zlib.rst:276
msgid ""
"Decompress *data*, returning a bytes object containing the uncompressed data"
" corresponding to at least part of the data in *string*.  This data should "
"be concatenated to the output produced by any preceding calls to the "
":meth:`decompress` method.  Some of the input data may be preserved in "
"internal buffers for later processing."
msgstr ""
"解压缩 *data* 并返回 bytes 对象，其中包含对应于 *string* 中至少一部分数据的解压缩数据。 此数据应当被拼接到之前任何对 "
":meth:`decompress` 方法的调用所产生的输出。 部分输入数据可能会被保留在内部缓冲区以供后续处理。"

#: ../../library/zlib.rst:282
msgid ""
"If the optional parameter *max_length* is non-zero then the return value "
"will be no longer than *max_length*. This may mean that not all of the "
"compressed input can be processed; and unconsumed data will be stored in the"
" attribute :attr:`unconsumed_tail`. This bytestring must be passed to a "
"subsequent call to :meth:`decompress` if decompression is to continue.  If "
"*max_length* is zero then the whole input is decompressed, and "
":attr:`unconsumed_tail` is empty."
msgstr ""
"如果可选的形参 *max_length* 非零则返回值将不会长于 *max_length*。 "
"这可能意味着不是所有已压缩输入都能被处理；并且未被消耗的数据将被保存在 :attr:`unconsumed_tail` 属性中。 "
"如果要继续解压缩则这个字节串必须被传给对 :meth:`decompress` 的后续调用。 如果 *max_length* "
"为零则整个输入都会被解压缩，并且 :attr:`unconsumed_tail` 将为空。"

#: ../../library/zlib.rst:289
msgid "*max_length* can be used as a keyword argument."
msgstr "*max_length* 可用作关键字参数。"

#: ../../library/zlib.rst:295
msgid ""
"All pending input is processed, and a bytes object containing the remaining "
"uncompressed output is returned.  After calling :meth:`flush`, the "
":meth:`decompress` method cannot be called again; the only realistic action "
"is to delete the object."
msgstr ""
"所有挂起的输入会被处理，并且返回包含剩余未压缩输出的 bytes 对象。 在调用 :meth:`flush` 之后，:meth:`decompress`"
" 方法将无法被再次调用；唯一可行的操作是删除该对象。"

#: ../../library/zlib.rst:300
msgid ""
"The optional parameter *length* sets the initial size of the output buffer."
msgstr "可选的形参 *length* 设置输出缓冲区的初始大小。"

#: ../../library/zlib.rst:305
msgid ""
"Returns a copy of the decompression object.  This can be used to save the "
"state of the decompressor midway through the data stream in order to speed "
"up random seeks into the stream at a future point."
msgstr "返回解压缩对象的一个拷贝。 它可以用来在数据流的中途保存解压缩器的状态以便加快随机查找数据流后续位置的速度。"

#: ../../library/zlib.rst:310
msgid ""
"Added :func:`copy.copy` and :func:`copy.deepcopy` support to decompression "
"objects."
msgstr "添加了对解压缩对象执行 :func:`copy.copy` 和 :func:`copy.deepcopy` 的支持。"

#: ../../library/zlib.rst:315
msgid ""
"Information about the version of the zlib library in use is available "
"through the following constants:"
msgstr "通过下列常量可获取模块所使用的 zlib 库的版本信息："

#: ../../library/zlib.rst:321
msgid ""
"The version string of the zlib library that was used for building the "
"module. This may be different from the zlib library actually used at "
"runtime, which is available as :const:`ZLIB_RUNTIME_VERSION`."
msgstr ""
"构建此模块时所用的 zlib 库的版本字符串。它的值可能与运行时所加载的 zlib 不同。运行时加载的 zlib 库的版本字符串为 "
":const:`ZLIB_RUNTIME_VERSION`。"

#: ../../library/zlib.rst:328
msgid ""
"The version string of the zlib library actually loaded by the interpreter."
msgstr "解释器所加载的 zlib 库的版本字符串。"

#: ../../library/zlib.rst:335
msgid ""
"The version string of the zlib-ng library that was used for building the "
"module if zlib-ng was used. When present, the :data:`ZLIB_VERSION` and "
":data:`ZLIB_RUNTIME_VERSION` constants reflect the version of the zlib API "
"provided by zlib-ng."
msgstr ""
"如果使用了 zlib-ng 则会将 zlib-ng 库的版本字符串用于构建该模块。 当存在 :data:`ZLIB_VERSION` 和 "
":data:`ZLIB_RUNTIME_VERSION` 常量时它们将反映由 zlib-ng 提供的 zlib API 版本。"

#: ../../library/zlib.rst:340
msgid ""
"If zlib-ng was not used to build the module, this constant will be absent."
msgstr "如果 zlib-ng 未被用于构建该模块，此常量将不存在。"

#: ../../library/zlib.rst:347
msgid "Module :mod:`gzip`"
msgstr "模块 :mod:`gzip`"

#: ../../library/zlib.rst:348
msgid "Reading and writing :program:`gzip`\\ -format files."
msgstr "读写 :program:`gzip` 格式的文件。"

#: ../../library/zlib.rst:350
msgid "http://www.zlib.net"
msgstr "http://www.zlib.net"

#: ../../library/zlib.rst:351
msgid "The zlib library home page."
msgstr "zlib 库项目主页。"

#: ../../library/zlib.rst:353
msgid "http://www.zlib.net/manual.html"
msgstr "http://www.zlib.net/manual.html"

#: ../../library/zlib.rst:354
msgid ""
"The zlib manual explains  the semantics and usage of the library's many "
"functions."
msgstr "zlib 库用户手册。提供了库的许多功能的解释和用法。"

#: ../../library/zlib.rst:357
msgid ""
"In case gzip (de)compression is a bottleneck, the `python-isal`_ package "
"speeds up (de)compression with a mostly compatible API."
msgstr "对于 gzip (解)压缩成为瓶颈的情况，`python-isal`_ 软件包会使用最兼容的 API 来加快 (解)压缩的速度。"

#: ../../library/zlib.rst:123
msgid "Cyclic Redundancy Check"
msgstr "循环冗余检测"

#: ../../library/zlib.rst:123
msgid "checksum"
msgstr "checksum"
