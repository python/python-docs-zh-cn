# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 心韵 方 <fxy9905@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 05:02+0000\n"
"PO-Revision-Date: 2017-02-16 23:20+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/numbers.rst:2
msgid ":mod:`numbers` --- Numeric abstract base classes"
msgstr ":mod:`numbers` --- 数字的抽象基类"

#: ../../library/numbers.rst:7
msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**源代码：** :source:`Lib/numbers.py`"

#: ../../library/numbers.rst:11
msgid ""
"The :mod:`numbers` module (:pep:`3141`) defines a hierarchy of numeric "
":term:`abstract base classes <abstract base class>` which progressively "
"define more operations.  None of the types defined in this module can be "
"instantiated."
msgstr ""
":mod:`numbers` 模块 (:pep:`3141`) 定义了数字 :term:`抽象基类 <abstract base class>` "
"的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。"

#: ../../library/numbers.rst:18
msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr "数字的层次结构的基础。如果你只想确认参数 *x* 是不是数字而不关心其类型，则使用``isinstance(x, Number)``。"

#: ../../library/numbers.rst:23
msgid "The numeric tower"
msgstr "数字的层次"

#: ../../library/numbers.rst:27
msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions to "
":class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, "
"``-``, ``*``, ``/``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!=``. All"
" except ``-`` and ``!=`` are abstract."
msgstr ""
"内置在类型 :class:`complex` 里的子类描述了复数和它的运算操作。这些操作有：转化至  :class:`complex` 和 "
":class:`bool`， :attr:`.real`、 :attr:`.imag`、``+``、``-``、``*``、``/``、 "
":func:`abs`、 :meth:`conjugate`、 ``==`` 和 ``!=``。 所有的异常，``-`` 和 ``!=`` "
"，都是抽象的。"

#: ../../library/numbers.rst:35
msgid "Abstract. Retrieves the real component of this number."
msgstr "抽象的。得到该数字的实数部分。"

#: ../../library/numbers.rst:39
msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "抽象的。得到该数字的虚数部分。"

#: ../../library/numbers.rst:43
msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr "抽象的。返回共轭复数。例如 ``(1+3j).conjugate() == (1-3j)``。"

#: ../../library/numbers.rst:48
msgid ""
"To :class:`Complex`, :class:`Real` adds the operations that work on real "
"numbers."
msgstr "相对于 :class:`Complex`，:class:`Real` 加入了只有实数才能进行的操作。"

#: ../../library/numbers.rst:51
msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, "
":func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, "
"``//``, ``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"简单的说，它们是：转化至 :class:`float`，:func:`math.trunc`、 :func:`round`、 "
":func:`math.floor`、 :func:`math.ceil`、 :func:`divmod`、 ``//``、 ``%``、 ``<``、"
" ``<=``、 ``>``、 和 ``>=``。"

#: ../../library/numbers.rst:55
msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, "
":attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"实数同样默认支持 :func:`complex`、 :attr:`~Complex.real`、 :attr:`~Complex.imag` 和 "
":meth:`~Complex.conjugate`。"

#: ../../library/numbers.rst:61
msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and "
":attr:`~Rational.denominator` properties, which should be in lowest terms. "
"With these, it provides a default for :func:`float`."
msgstr ""
"子类型 :class:`Real` 并加入 :attr:`~Rational.numerator` 和 "
":attr:`~Rational.denominator` 两种属性，这两种属性应该属于最低的级别。加入后，这默认支持 :func:`float`。"

#: ../../library/numbers.rst:68 ../../library/numbers.rst:72
msgid "Abstract."
msgstr "抽象的。"

#: ../../library/numbers.rst:77
msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, and "
":attr:`~Rational.denominator`.  Adds abstract methods for ``**`` and bit-"
"string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~``."
msgstr ""
"子类型 :class:`Rational` 加上转化至 :class:`int`。 默认支持 :func:`float`、 "
":attr:`~Rational.numerator` 和 :attr:`~Rational.denominator`。 在 ``**`` "
"中加入抽象方法和比特字符串的操作： ``<<``、 ``>>``、 ``&``、 ``^``、 ``|``、 ``~``。"

#: ../../library/numbers.rst:84
msgid "Notes for type implementors"
msgstr "类型接口注释。"

#: ../../library/numbers.rst:86
msgid ""
"Implementors should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of"
" the real numbers. For example, :class:`fractions.Fraction` implements "
":func:`hash` as follows::"
msgstr ""
"实现者需要注意使相等的数字相等并拥有同样的值。当这两个数使用不同的扩展模块时，这其中的差异是很微妙的。例如，用 "
":class:`fractions.Fraction` 实现 :func:`hash` 如下::"

#: ../../library/numbers.rst:105
msgid "Adding More Numeric ABCs"
msgstr "加入更多数字的ABC"

#: ../../library/numbers.rst:107
msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"当然，这里有更多支持数字的ABC，如果不加入这些，就将缺少层次感。你可以用如下方法在 :class:`Complex` 和 :class:`Real` "
"中加入 ``MyFoo``::"

#: ../../library/numbers.rst:119
msgid "Implementing the arithmetic operations"
msgstr "实现算术运算"

#: ../../library/numbers.rst:121
msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations"
" either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation"
" there. For subtypes of :class:`Integral`, this means that :meth:`__add__` "
"and :meth:`__radd__` should be defined as::"
msgstr ""
"我们希望实现计算，因此，混合模式操作要么调用一个作者知道参数类型的实现，要么转变成为最接近的内置类型并对这个执行操作。对于子类 "
":class:`Integral`，这意味着 :meth:`__add__` 和 :meth:`__radd__` 必须用如下方式定义："

#: ../../library/numbers.rst:152
msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of "
":class:`Complex`. I'll refer to all of the above code that doesn't refer to "
"``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will be"
" an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
":class:`Complex` 有 5 种不同的混合类型的操作。 我将上面提到的所有代码作为“模板”称作 ``MyIntegral`` 和 "
"``OtherTypeIKnowAbout``。 ``a`` 是  :class:`Complex` 的子类型 ``A`` 的实例 (``a : A "
"<: Complex``)，同时 ``b : B <: Complex``。 我将要计算 ``a + b``:"

#: ../../library/numbers.rst:159
msgid "If ``A`` defines an :meth:`__add__` which accepts ``b``, all is well."
msgstr "如果 ``A`` 被定义成一个承认 ``b`` 的 :meth:`__add__`，一切都没有问题。"

#: ../../library/numbers.rst:161
msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`__add__`, we'd miss the possibility that ``B`` defines a more "
"intelligent :meth:`__radd__`, so the boilerplate should return "
":const:`NotImplemented` from :meth:`__add__`. (Or ``A`` may not implement "
":meth:`__add__` at all.)"
msgstr ""
"如果 ``A`` 转回成“模板”失败，它将返回一个属于 :meth:`__add__` 的值，我们需要避免 ``B`` 定义了一个更加智能的 "
":meth:`__radd__`，因此模板需要返回一个属于 :meth:`__add__` 的 :const:`NotImplemented` 。（或者"
" ``A`` 可能完全不实现 :meth:`__add__` 。）"

#: ../../library/numbers.rst:167
msgid ""
"Then ``B``'s :meth:`__radd__` gets a chance. If it accepts ``a``, all is "
"well."
msgstr "接着看 ``B`` 的 :meth:`__radd__` 。如果它承认 ``a`` ，一切都没有问题。"

#: ../../library/numbers.rst:169
msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr "如果没有成功回退到模板，就没有更多的方法可以去尝试，因此这里将使用默认的实现。"

#: ../../library/numbers.rst:172
msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok,"
" because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"如果 ``B <: A`` ， Python 在 ``A.__add__`` 之前尝试 ``B.__radd__`` 。 这是可行的，是通过对 "
"``A`` 的认识实现的，因此这可以在交给 :class:`Complex` 处理之前处理这些实例。"

#: ../../library/numbers.rst:177
msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built in "
":class:`complex`, and both :meth:`__radd__` s land there, so ``a+b == b+a``."
msgstr ""
"如果 ``A <: Complex`` 和 ``B <: Real`` 没有共享任何资源，那么适当的共享操作涉及内置的 :class:`complex`"
" ，并且分别获得 :meth:`__radd__` ，因此 ``a+b == b+a``。"

#: ../../library/numbers.rst:182
msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For example, "
":class:`fractions.Fraction` uses::"
msgstr ""
"由于对任何一直类型的大部分操作是十分相似的，可以定义一个帮助函数，即一个生成后续或相反的实例的生成器。例如，使用 "
":class:`fractions.Fraction` 如下："
