# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 操旭 <caoxu3000@126.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2021
# 汪心禾 <wangxinhe06@gmail.com>, 2021
# Konge <zkonge@outlook.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# ww song <sww4718168@gmail.com>, 2022
# CCXXXI <ccxxxi@qq.com>, 2022
# Chris Lau, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Chris Lau, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- 正则表达式操作"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**源代码:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl."
msgstr "本模块提供了与 Perl 语言类似的正则表达式匹配操作。"

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a byte pattern or vice-versa; similarly, when asking for"
" a substitution, the replacement string must be of the same type as both the"
" pattern and the search string."
msgstr ""
"模式和被搜索的字符串既可以是 Unicode 字符串 (:class:`str`) ，也可以是8位字节串 (:class:`bytes`)。 "
"但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能用字节串模式匹配 Unicode "
"字符串，反之亦然；同理，替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。"

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in"
" the future this will become a :exc:`SyntaxError`. This behaviour will "
"happen even if it is a valid escape sequence for a regular expression."
msgstr ""
"正则表达式用反斜杠字符 (``'\\'``) 表示特殊形式，或是允许在使用特殊字符时，不引发它们的特殊含义。 这与 Python "
"的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 ``'\\\\\\\\'`` "
"来作为模式字符串，因为正则表达式必须为 ``\\\\``，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 ``\\\\``。 "
"而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在会触发 "
":exc:`DeprecationWarning`，但以后会改为 :exc:`SyntaxError`。 "
"此行为即使对于正则表达式来说有效的转义字符同样会发生。"

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr ""
"解决办法是对于正则表达式模式（patterns）使用 Python 的原始字符串表示法；在带有 ``'r'`` "
"前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 ``r\"\\n\"`` 表示包含 ``'\\'`` 和 ``'n'`` 两个字符的字符串，而 "
"``\"\\n\"`` 则表示只包含一个换行符的字符串。 模式在 Python 代码中通常都使用原始字符串表示法。"

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"绝大多数正则表达式操作都提供为模块函数和方法，在 :ref:`编译正则表达式 <re-objects>`.  "
"这些函数是一个捷径，不需要先编译正则对象，但是损失了一些优化参数。"

#: ../../library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has"
" an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"第三方模块 `regex <https://pypi.org/project/regex/>`_ , 提供了与标准库 :mod:`re` 模块兼容的 "
"API 接口，同时，还提供了更多功能和更全面的 Unicode 支持。"

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "正则表达式语法"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"正则表达式（或 "
"RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。"

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"正则表达式可以拼接；如果 *A* 和 *B* 都是正则表达式，则 *AB* 也是正则表达式。通常，如果字符串 *p* 匹配 *A*，并且另一个字符串 "
"*q* 匹配 *B*，那么 *pq* 可以匹配 AB。除非 *A* 或者 *B* 包含低优先级操作，*A* 和 *B* "
"存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。更多正则表达式理论和实现，详见 the Friedl book"
" [Frie09]_ ，或者其他构建编译器的书籍。"

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr "以下是正则表达式格式的简要说明。更详细的信息和演示，参考  :ref:`regex-howto`。"

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 ``'A'``, ``'a'``, 或者 "
"``'0'``，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 ``last`` 匹配字符串 ``'last'``.  "
"（在这一节的其他部分，我们将用 ``this special style`` 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 ``'in "
"single quotes'`` ，单引号形式。）"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"有些字符，比如 ``'|'`` 或者 ``'('``，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。"

#: ../../library/re.rst:90
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the"
" expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"重复修饰符 (``*``, ``+``, ``?``, ``{m,n}``, 等) 不能直接嵌套。这样避免了非贪婪后缀 ``?`` "
"修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 ``(?:a{6})*`` 匹配6个 ``'a'`` "
"字符重复任意次数。"

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "特殊字符有："

#: ../../library/re.rst:104 ../../library/re.rst:1431
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr "(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 :const:`DOTALL` ，它将匹配包括换行符的任意字符。"

#: ../../library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "(插入符号)  匹配字符串的开头， 并且在 :const:`MULTILINE` 模式也匹配换行后的首个符号。"

#: ../../library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr ""
"匹配字符串尾或者在字符串尾的换行符的前一个字符，在 :const:`MULTILINE` 模式下也会匹配换行符之前的文本。 ``foo`` 匹配 "
"'foo' 和 'foobar'，但正则表达式 ``foo$`` 只匹配 'foo'。 更有趣的是，在 ``'foo1\\nfoo2\\n'`` 中搜索"
" ``foo.$``，通常匹配  'foo2'，但在 :const:`MULTILINE` 模式下可以匹配到 'foo1'；在 ``'foo\\n'``"
" 中搜索 ``$`` 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。"

#: ../../library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。  ``ab*`` 会匹配 ``'a'``，``'ab'``，或者 ``'a'`` "
"后面跟随任意个 ``'b'``。"

#: ../../library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"对它前面的正则式匹配1到任意次重复。 ``ab+`` 会匹配 ``'a'`` 后面跟随1个以上到任意个 ``'b'``，它不会匹配 ``'a'``。"

#: ../../library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr "对它前面的正则式匹配0到1次重复。 ``ab?`` 会匹配 ``'a'`` 或者 ``'ab'``。"

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire"
" string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'``, ``'+'``，和 ``'?'`` 修饰符都是 "
":dfn:`贪婪的`；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 ``<.*>`` 希望找到 ``'<a> b "
"<c>'``，它将会匹配整个字符串，而不仅是 ``'<a>'``。在修饰符之后添加 ``?`` 将使样式以 :dfn:`非贪婪`方式或者 "
":dfn:`最小` 方式进行匹配； 尽量 *少* 的字符将会被匹配。 使用正则式 ``<.*?>`` 将会仅仅匹配 ``'<a>'``。"

#: ../../library/re.rst:163
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:161
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"对其之前的正则式指定匹配 *m* 个重复；少于 *m* 的话就会导致匹配失败。比如， ``a{6}`` 将匹配6个 ``'a'`` , 但是不能是5个。"

#: ../../library/re.rst:172
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:166
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand"
" ``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may"
" not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"对正则式进行 *m* 到 *n* 次匹配，在 *m* 和 *n* 之间取尽量多。 比如，``a{3,5}`` 将匹配 3 到 5个 ``'a'``。忽略"
" *m* 意为指定下界为0，忽略 *n* 指定上界为无限次。 比如 ``a{4,}b`` 将匹配 ``'aaaab'`` 或者1000个 ``'a'``"
" 尾随一个 ``'b'``，但不能匹配 ``'aaab'``。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。"

#: ../../library/re.rst:179
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:175
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous qualifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 ``'aaaaaa'``， ``a{3,5}`` 匹配 5个 ``'a'`` ，而 "
"``a{3,5}?`` 只匹配3个 ``'a'``。"

#: ../../library/re.rst:194
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:184
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr "转义特殊字符（允许你匹配 ``'*'``, ``'?'``, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。"

#: ../../library/re.rst:188
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"如果你没有使用原始字符串（ ``r'raw'`` "
"）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。"

#: ../../library/re.rst:254
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:200
msgid "Used to indicate a set of characters.  In a set:"
msgstr "用于表示一个字符集合。在一个集合中："

#: ../../library/re.rst:202
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "字符可以单独列出，比如 ``[amk]`` 匹配 ``'a'``， ``'m'``， 或者 ``'k'``。"

#: ../../library/re.rst:207
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"可以表示字符范围，通过用 ``'-'`` 将两个字符连起来。比如 ``[a-z]`` 将匹配任何小写ASCII字符， ``[0-5][0-9]`` "
"将匹配从 ``00`` 到 ``59`` 的两位数字， ``[0-9A-Fa-f]`` 将匹配任何十六进制数位。 如果 ``-`` 进行了转义 （比如 "
"``[a\\-z]``）或者它的位置在首位或者末尾（如 ``[-a]`` 或 ``[a-]``），它就只表示普通字符 ``'-'``。"

#: ../../library/re.rst:214
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"特殊字符在集合中会失去其特殊意义。比如 ``[(+*)]`` 只会匹配这几个字面字符之一 ``'('``, ``'+'``, ``'*'``, or "
"``')'``。"

#: ../../library/re.rst:220
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on whether"
" :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"字符类如 ``\\w`` 或者 ``\\S`` (如下定义) 在集合内可以接受，它们可以匹配的字符由 :const:`ASCII` 或者 "
":const:`LOCALE` 模式决定。"

#: ../../library/re.rst:226
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"不在集合范围内的字符可以通过 :dfn:`取反` 来进行匹配。如果集合首字符是 ``'^'`` ，所有 *不* 在集合内的字符将会被匹配，比如 "
"``[^5]`` 将匹配所有字符，除了 ``'5'``， ``[^^]`` 将匹配所有字符，除了 ``'^'``.  ``^`` "
"如果不在集合首位，就没有特殊含义。"

#: ../../library/re.rst:233
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"在集合内要匹配一个字符 ``']'``，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， ``[()[\\]{}]`` 和 "
"``[]()[{}]`` 都可以匹配括号。"

#: ../../library/re.rst:242
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['``"
" or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and"
" ``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"`Unicode Technical Standard #18`_ 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个"
" :exc:`FutureWarning` 将会在有多义的情况里被 ``raise``，包含以下几种情况，集合由 ``'['`` "
"开始，或者包含下列字符序列  ``'--'``, ``'&&'``, ``'~~'``, 和 ``'||'``。为了避免警告，需要将它们用反斜杠转义。"

#: ../../library/re.rst:252
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr "如果一个字符串构建的语义在未来会改变的话，一个 :exc:`FutureWarning` 会 ``raise`` 。"

#: ../../library/re.rst:267
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:259
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups"
" (see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``， *A* 和 *B* 可以是任意正则表达式，创建一个正则表达式，匹配 *A* 或者 *B*.  任意个正则表达式可以用 ``'|'`` "
"连接。它也可以在组合（见下列）内使用。扫描目标字符串时， ``'|'`` "
"分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 *A* 匹配成功， *B* "
"就不再进行匹配，即便它能产生一个更好的匹配。或者说，``'|'`` 操作符绝不贪婪。  如果要匹配 ``'|'`` 字符，使用 ``\\|``， "
"或者把它包含在字符集里，比如 ``[|]``."

#: ../../library/re.rst:277
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:273
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(]``, ``[)]``."
msgstr ""
"（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用  ``\\number`` "
"转义序列进行再次匹配，之后进行详细说明。要匹配字符 ``'('`` 或者 ``')'``, 用 ``\\(`` 或 ``\\)``, "
"或者把它们包含在字符集合里: ``[(]``, ``[)]``."

#: ../../library/re.rst:286
msgid "``(?...)``"
msgstr "``(?…)``"

#: ../../library/re.rst:282
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"这是个扩展标记法 （一个 ``'?'`` 跟随 ``'('`` 并无含义）。  ``'?'`` "
"后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； ``(?P<name>...)`` 是唯一的例外。 "
"以下是目前支持的扩展。"

#: ../../library/re.rst:300
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:289
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters"
" set the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the entire regular expression. "
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if"
" you wish to include the flags as part of the regular expression, instead of"
" passing a *flag* argument to the :func:`re.compile` function.  Flags should"
" be used first in the expression string."
msgstr ""
"( ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` 中的一个或多个) "
"这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 :const:`re.A` (只匹配ASCII字符), :const:`re.I` "
"(忽略大小写), :const:`re.L` (语言依赖), :const:`re.M` (多行模式), :const:`re.S` "
"(点dot匹配全部字符), :const:`re.U` (Unicode匹配), and :const:`re.X` (冗长模式)。 (这些标记在 "
":ref:`contents-of-module-re` 中描述) 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 "
":func:`re.compile` 中传递 *flag* 参数。标记应该在表达式字符串首位表示。"

#: ../../library/re.rst:308
msgid "``(?:...)``"
msgstr "``(?:…)``"

#: ../../library/re.rst:305
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr "正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 *不能* 在执行匹配后被获取或是之后在模式中被引用。"

#: ../../library/re.rst:334
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:…)``"

#: ../../library/re.rst:311
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or"
" more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), "
":const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M`"
" (multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The"
" flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'`` 中的0或者多个， "
"之后可选跟随 ``'-'`` 在后面跟随 ``'i'`` , ``'m'`` , ``'s'`` , ``'x'`` 中的一到多个 .) "
"这些字符为表达式的其中一部分 *设置* 或者 *去除* 相应标记 :const:`re.A` (只匹配ASCII), :const:`re.I` "
"(忽略大小写), :const:`re.L` (语言依赖), :const:`re.M` (多行), :const:`re.S` (点匹配所有字符), "
":const:`re.U` (Unicode匹配), and :const:`re.X` (冗长模式)。(标记描述在 :ref:`contents-"
"of-module-re` .)"

#: ../../library/re.rst:321
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as"
" inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and "
"``(?a:...)`` switches to ASCII-only matching (default). This override is "
"only in effect for the narrow inline group, and the original matching mode "
"is restored outside of the group."
msgstr ""
"``'a'``, ``'L'`` and ``'u'`` 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 ``'-'`` 。 "
"当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， ``(?a:...)`` 切换为 只匹配ASCII， "
"``(?u:...)`` 切换为Unicode匹配 (默认).  在byte样式中 ``(?L:...)`` 切换为语言依赖模式， "
"``(?a:...)`` 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。"

#: ../../library/re.rst:333
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "符号 ``'a'``, ``'L'`` 和 ``'u'`` 同样可以用在一个组合内。"

#: ../../library/re.rst:361
msgid "``(?P<name>...)``"
msgstr "``(?P<name>…)``"

#: ../../library/re.rst:339
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 *name* "
"来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。"

#: ../../library/re.rst:345
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr ""
"命名组合可以在三种上下文中引用。如果样式是 ``(?P<quote>['\"]).*?(?P=quote)`` "
"（也就是说，匹配单引号或者双引号括起来的字符串)："

#: ../../library/re.rst:350
msgid "Context of reference to group \"quote\""
msgstr "引用组合 \"quote\" 的上下文"

#: ../../library/re.rst:350
msgid "Ways to reference it"
msgstr "引用方法"

#: ../../library/re.rst:352
msgid "in the same pattern itself"
msgstr "在正则式自身内"

#: ../../library/re.rst:352
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (如示)"

#: ../../library/re.rst:353 ../../library/re.rst:360
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:355
msgid "when processing match object *m*"
msgstr "处理匹配对象 *m*"

#: ../../library/re.rst:355
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:356
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (等)"

#: ../../library/re.rst:358
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "传递到 ``re.sub()`` 里的 *repl* 参数中"

#: ../../library/re.rst:358
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:359
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:367
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:366
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "反向引用一个命名组合；它匹配前面那个叫 *name* 的命名组中匹配到的串同样的字串。"

#: ../../library/re.rst:372
msgid "``(?#...)``"
msgstr "``(?#…)``"

#: ../../library/re.rst:372
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "注释；里面的内容会被忽略。"

#: ../../library/re.rst:379
msgid "``(?=...)``"
msgstr "``(?=…)``"

#: ../../library/re.rst:377
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"当 ``…`` 匹配时，匹配成功，但不消耗字符串中的任何字符。这个叫做 :dfn:`前视断言` （lookahead assertion）。比如， "
"``Isaac (?=Asimov)`` 将会匹配 ``'Isaac '`` ，仅当其后紧跟  ``'Asimov'`` 。"

#: ../../library/re.rst:386
msgid "``(?!...)``"
msgstr "``(?!…)``"

#: ../../library/re.rst:384
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"当 ``…`` 不匹配时，匹配成功。这个叫 :dfn:`否定型前视断言` （negative lookahead assertion）。例如， "
"``Isaac (?!Asimov)`` 将会匹配 ``'Isaac '`` ，仅当它后面 *不是* ``'Asimov'``   。"

#: ../../library/re.rst:413
msgid "``(?<=...)``"
msgstr "``(?<=…)``"

#: ../../library/re.rst:391
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Note that patterns which start with positive lookbehind"
" assertions will not match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than the"
" :func:`match` function:"
msgstr ""
"如果 ``...`` 的匹配内容出现在当前位置的左侧，则匹配。这叫做 :dfn:`肯定型后视断言` （positive lookbehind "
"assertion）。 ``(?<=abc)def`` 将会在 ``'abcdef'`` "
"中找到一个匹配，因为后视会回退3个字符并检查内部表达式是否匹配。内部表达式（匹配的内容）必须是固定长度的，意思就是 ``abc`` 或 ``a|b`` "
"是允许的，但是 ``a*`` 和 ``a{3,4}`` "
"不可以。注意，以肯定型后视断言开头的正则表达式，匹配项一般不会位于搜索字符串的开头。很可能你应该使用 :func:`search` 函数，而不是 "
":func:`match` 函数："

#: ../../library/re.rst:406
msgid "This example looks for a word following a hyphen:"
msgstr "这个例子搜索一个跟随在连字符后的单词："

#: ../../library/re.rst:412
msgid "Added support for group references of fixed length."
msgstr "添加定长组合引用的支持。"

#: ../../library/re.rst:422
msgid "``(?<!...)``"
msgstr "``(?<!…)``"

#: ../../library/re.rst:418
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind"
" assertions may match at the beginning of the string being searched."
msgstr ""
"如果 ``...`` 的匹配内容没有出现在当前位置的左侧，则匹配。这个叫做 :dfn:`否定型后视断言` （negative lookbehind "
"assertion）。类似于肯定型后视断言，内部表达式（匹配的内容）必须是固定长度的。以否定型后视断言开头的正则表达式，匹配项可能位于搜索字符串的开头。"

#: ../../library/re.rst:431
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:425
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"如果给定的  *id* 或 *name* 存在，将会尝试匹配 ``yes-pattern`` ，否则就尝试匹配 ``no-pattern``，``no-"
"pattern`` 可选，也可以被忽略。比如， ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` "
"是一个email样式匹配，将匹配 ``'<user@host.com>'`` 或 ``'user@host.com'`` ，但不会匹配 "
"``'<user@host.com'`` ，也不会匹配 ``'user@host.com>'``。"

#: ../../library/re.rst:433
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$``"
" matches the character ``'$'``."
msgstr ""
"由 ``'\\'`` 和一个字符组成的特殊序列在以下列出。 "
"如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，``\\$`` 匹配字符 ``'$'``."

#: ../../library/re.rst:448
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:441
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 ``(.+) \\1`` 匹配 ``'the the'`` 或者 ``'55 "
"55'``, 但不会匹配 ``'thethe'`` (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果  *number* "
"的第一个数位是0， 或者 *number* 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 ``'['`` 和 ``']'`` "
"字符集合内，任何数字转义都被看作是字符。"

#: ../../library/re.rst:453
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:453
msgid "Matches only at the start of the string."
msgstr "只匹配字符串开始。"

#: ../../library/re.rst:469
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:458
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word"
" is defined as a sequence of word characters.  Note that formally, ``\\b`` "
"is defined as the boundary between a ``\\w`` and a ``\\W`` character (or "
"vice versa), or between ``\\w`` and the beginning/end of the string. This "
"means that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, "
"``'bar foo baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 ``\\b`` 定义为 ``\\w`` 和 ``\\W`` "
"字符之间，或者 ``\\w`` 和字符串开始/结尾的边界， 意思就是 ``r'\\bfoo\\b'`` 匹配 ``'foo'``, "
"``'foo.'``, ``'(foo)'``, ``'bar foo baz'`` 但不匹配 ``'foobar'`` 或者 ``'foo3'``。"

#: ../../library/re.rst:465
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside"
" a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用  :const:`ASCII` 标记来更改。如果 "
":const:`LOCALE` 标记被设置的话，词的边界是由当前语言区域设置决定的，``\\b`` 表示退格字符，以便与Python字符串文本兼容。"

#: ../../library/re.rst:480
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:474
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the "
":const:`ASCII` flag.  Word boundaries are determined by the current locale "
"if the :const:`LOCALE` flag is used."
msgstr ""
"匹配空字符串，但 *不* 能在词的开头或者结尾。意思就是 ``r'py\\B'`` 匹配 ``'python'``, ``'py3'``, "
"``'py2'``, 但不匹配 ``'py'``, ``'py.'``, 或者 ``'py!'``. ``\\B`` 是 ``\\b`` "
"的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 :const:`ASCII` 标志来改变。如果使用了 "
":const:`LOCALE` 标志，则词的边界由当前语言区域设置。"

#: ../../library/re.rst:492
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:489 ../../library/re.rst:509 ../../library/re.rst:529
msgid "For Unicode (str) patterns:"
msgstr "对于 Unicode (str) 样式："

#: ../../library/re.rst:486
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 ``[0-9]`` ，和很多其他的数字字符。如果设置了 "
":const:`ASCII` 标志，就只匹配 ``[0-9]`` 。"

#: ../../library/re.rst:492 ../../library/re.rst:513 ../../library/re.rst:535
msgid "For 8-bit (bytes) patterns:"
msgstr "对于8位(bytes)样式："

#: ../../library/re.rst:492
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "匹配任何十进制数，就是 ``[0-9]``。"

#: ../../library/re.rst:499
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:497
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr "匹配任何非十进制数字的字符。就是 ``\\d`` 取非。 如果设置了 :const:`ASCII` 标志，就相当于 ``[^0-9]`` 。"

#: ../../library/re.rst:513
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:505
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the "
":const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"匹配任何Unicode空白字符（包括 ``[ \\t\\n\\r\\f\\v]`` ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 "
":const:`ASCII` 被设置，就只匹配 ``[ \\t\\n\\r\\f\\v]`` 。"

#: ../../library/re.rst:512
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is"
" equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr "匹配ASCII中的空白字符，就是 ``[ \\t\\n\\r\\f\\v]`` 。"

#: ../../library/re.rst:520
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:518
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr "匹配任何非空白字符。就是 ``\\s`` 取非。如果设置了 :const:`ASCII` 标志，就相当于 ``[^ \\t\\n\\r\\f\\v]`` 。"

#: ../../library/re.rst:535
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:526
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""
"匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 :const:`ASCII` 标志，就只匹配 "
"``[a-zA-Z0-9_]`` 。"

#: ../../library/re.rst:532
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"匹配ASCII字符中的数字和字母和下划线，就是 ``[a-zA-Z0-9_]`` 。如果设置了 :const:`LOCALE` "
"标记，就匹配当前语言区域的数字和字母和下划线。"

#: ../../library/re.rst:544
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:540
msgid ""
"Matches any character which is not a word character. This is the opposite of"
" ``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"匹配非单词字符的字符。这与 ``\\w`` 正相反。如果使用了 :const:`ASCII` 旗标，这就等价于 "
"``[^a-zA-Z0-9_]``。如果使用了 :const:`LOCALE` 旗标，则会匹配当前区域中既非字母数字也非下划线的字符。"

#: ../../library/re.rst:549
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:549
msgid "Matches only at the end of the string."
msgstr "只匹配字符串尾。"

#: ../../library/re.rst:565
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "绝大部分Python的标准转义字符也被正则表达式分析器支持。::"

#: ../../library/re.rst:572
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "（注意 ``\\b`` 被用于表示词语的边界，它只在字符集合内表示退格，比如 ``[\\b]`` 。）"

#: ../../library/re.rst:575
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"``'\\u'``, ``'\\U'`` 和 ``'\\N'`` 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。"
" 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。"

#: ../../library/re.rst:579
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or"
" if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"八进制转义包含为一个有限形式。如果首位数字是 0， "
"或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。"

#: ../../library/re.rst:584
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "增加了 ``'\\u'`` 和 ``'\\U'`` 转义序列。"

#: ../../library/re.rst:587
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "由 ``'\\'`` 和一个ASCII字符组成的未知转义会被看成错误。"

#: ../../library/re.rst:590
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"添加了 ``'\\N{name}'`` 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 ``'\\N{EM "
"DASH}'``)。"

#: ../../library/re.rst:598
msgid "Module Contents"
msgstr "模块内容"

#: ../../library/re.rst:600
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"模块定义了几个函数、常量，和一个异常。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。重要的应用程序大多会在使用前先编译正则表达式。"

#: ../../library/re.rst:607
msgid "Flags"
msgstr "标志"

#: ../../library/re.rst:609
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr "标志常量现在是 :class:`RegexFlag` 类的实例，这个类是 :class:`enum.IntFlag` 的子类。"

#: ../../library/re.rst:618
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"让 ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` 和 ``\\S`` "
"只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 ``(?a)`` 。"

#: ../../library/re.rst:623
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart "
"``(?u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"注意，为了保持向后兼容， :const:`re.U` 标记依然存在（还有他的同义  :const:`re.UNICODE` 和嵌入形式 ``(?u)``"
" ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。"

#: ../../library/re.rst:632
msgid ""
"Display debug information about compiled expression. No corresponding inline"
" flag."
msgstr "显示编译时的debug信息，没有内联标记。"

#: ../../library/re.rst:639
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"进行忽略大小写匹配；表达式如 ``[A-Z]`` 也会匹配小写字符。Unicode匹配（比如 ``Ü`` 匹配 ``ü``）同样有用，除非设置了 "
":const:`re.ASCII` 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 :const:`re.LOCALE` "
"标记。这个相当于内联标记 ``(?i)`` 。"

#: ../../library/re.rst:646
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' "
"(U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If the "
":const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"注意，当设置了 :const:`IGNORECASE` 标记，搜索Unicode样式 ``[a-z]`` 或 ``[A-Z]`` "
"的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： 'İ' (U+0130, 拉丁大写的 I 带个点在上面), 'ı' "
"(U+0131, 拉丁小写没有点的 I ), 'ſ' (U+017F, 拉丁小写长 s) and 'K' (U+212A, 开尔文符号).如果使用 "
":const:`ASCII` 标记，就只匹配 'a' 到 'z' 和 'A' 到 'Z' 。"

#: ../../library/re.rst:657
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in"
" Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"由当前语言区域决定 ``\\w``, ``\\W``, ``\\b``, ``\\B`` "
"和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 "
"\"习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 ``(?L)`` 。"

#: ../../library/re.rst:666
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ":const:`re.LOCALE` 只能用于byte样式，而且不能和 :const:`re.ASCII` 一起用。"

#: ../../library/re.rst:670
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr "设置了 :const:`re.LOCALE` 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。"

#: ../../library/re.rst:679
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"设置以后，样式字符 ``'^'`` 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 ``'$'`` "
"匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，``’^’`` 匹配字符串头，``'$'`` 匹配字符串尾。对应内联标记 "
"``(?m)`` 。"

#: ../../library/re.rst:691
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"让 ``'.'`` 特殊字符匹配任何字符，包括换行符；如果没有这个标记，``'.'`` 就匹配 *除了* 换行符的其他任意字符。对应内联标记 "
"``(?s)`` 。"

#: ../../library/re.rst:701
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""
"这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 ``*?``, "
"``(?:`` or ``(?P<…>`` 分组之内。当一个行内有 ``#`` 不在字符集和转义序列，那么它之后的所有字符都是注释。"

#: ../../library/re.rst:710
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "意思就是下面两个正则表达式等价地匹配一个十进制数字："

#: ../../library/re.rst:718
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "对应内联标记 ``(?x)`` 。"

#: ../../library/re.rst:722
msgid "Functions"
msgstr "函数"

#: ../../library/re.rst:726
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its "
":func:`~Pattern.match`, :func:`~Pattern.search` and other methods, described"
" below."
msgstr ""
"将正则表达式的样式编译为一个 :ref:`正则表达式对象 <re-objects>`  （正则对象），可以用于匹配，通过这个对象的方法  "
":func:`~Pattern.match`, :func:`~Pattern.search` 以及其他如下描述。"

#: ../../library/re.rst:731
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the"
" ``|`` operator)."
msgstr "这个表达式的行为可以通过指定 *标记* 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ ``|`` 操作符）。"

#: ../../library/re.rst:735
msgid "The sequence ::"
msgstr "序列 ::"

#: ../../library/re.rst:740
msgid "is equivalent to ::"
msgstr "等价于 ::"

#: ../../library/re.rst:744
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr "如果需要多次使用这个正则表达式的话，使用 :func:`re.compile` 和保存这个正则对象以便复用，可以让程序更加高效。"

#: ../../library/re.rst:750
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr "通过 :func:`re.compile` 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。"

#: ../../library/re.rst:758
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":ref:`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"扫描整个 *字符串* 找到匹配样式的第一个位置，并返回一个相应的 :ref:`匹配对象 <match-objects>`。如果没有匹配，就返回一个 "
"``None`` ； 注意这和找到一个零长度匹配是不同的。"

#: ../../library/re.rst:767
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"如果 *string* 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 :ref:`匹配对象 <match-objects>` 。 "
"如果没有匹配，就返回 ``None`` ；注意它跟零长度匹配是不同的。"

#: ../../library/re.rst:772
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"注意即便是 :const:`MULTILINE` 多行模式， :func:`re.match` 也只匹配字符串的开始位置，而不匹配每行开始。"

#: ../../library/re.rst:775
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"如果你想定位 *string* 的任何位置，使用 :func:`search` 来替代（也可参考 :ref:`search-vs-match` ）"

#: ../../library/re.rst:781
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"如果整个 *string* 匹配到正则表达式样式，就返回一个相应的 :ref:`匹配对象 <match-objects>` 。 否则就返回一个 "
"``None`` ；注意这跟零长度匹配是不同的。"

#: ../../library/re.rst:791
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"用 *pattern* 分开  *string* 。 如果在 *pattern* 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 "
"*maxsplit* 非零， 最多进行 *maxsplit* 次分隔， 剩下的字符全部返回到列表的最后一个元素。 ::"

#: ../../library/re.rst:806
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr "如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样 ::"

#: ../../library/re.rst:813
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list."
msgstr "这样的话，分隔组将会出现在结果列表中同样的位置。"

#: ../../library/re.rst:816
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr "样式的空匹配仅在与前一个空匹配不相邻时才会拆分字符串。"

#: ../../library/re.rst:826 ../../library/re.rst:916 ../../library/re.rst:940
msgid "Added the optional flags argument."
msgstr "增加了可选标记参数。"

#: ../../library/re.rst:829
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr "增加了空字符串的样式分隔。"

#: ../../library/re.rst:835
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"返回 *pattern* 在 *string* 中的所有非重叠匹配，以字符串列表或字符串元组列表的形式。对 *string* "
"的扫描从左至右，匹配结果按照找到的顺序返回。 空匹配也包括在结果中。"

#: ../../library/re.rst:839
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that group."
"  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"返回结果取决于模式中捕获组的数量。如果没有组，返回与整个模式匹配的字符串列表。如果有且仅有一个组，返回与该组匹配的字符串列表。如果有多个组，返回与这些组匹配的字符串元组列表。非捕获组不影响结果。"

#: ../../library/re.rst:851 ../../library/re.rst:862
msgid "Non-empty matches can now start just after a previous empty match."
msgstr "非空匹配现在可以在前一个空匹配之后出现了。"

#: ../../library/re.rst:857
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"*pattern* 在 *string* 里所有的非重复匹配，返回为一个迭代器  :term:`iterator` 保存了  :ref:`匹配对象 "
"<match-objects>` 。 *string* 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。"

#: ../../library/re.rst:868
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of"
" ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"返回通过使用 *repl* 替换在 *string* 最左边非重叠出现的 *pattern* 而获得的字符串。 如果样式没有找到，则不加改变地返回 "
"*string*。 *repl* 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，``\\n`` "
"会被转换为一个换行符，``\\r`` 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 "
"其他未知转义序列例如 ``\\&`` 会保持原样。 向后引用像是 ``\\6`` 会用样式中第 6 组所匹配到的子字符串来替换。 例如::"

#: ../../library/re.rst:884
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"如果 *repl* 是一个函数，那它会对每个非重复的 *pattern* 的情况调用。这个函数只能有一个 :ref:`匹配对象 <match-"
"objects>` 参数，并返回一个替换后的字符串。比如 ::"

#: ../../library/re.rst:896
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "样式可以是一个字符串或者一个 :ref:`样式对象 <re-objects>` 。"

#: ../../library/re.rst:898
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous empty match, so ``sub('x*', "
"'-', 'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"可选参数 *count* 是要替换的最大次数；*count* 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 "
"样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以  ``sub('x*', '-', 'abxd')`` 返回 ``'-a-b--d-'`` 。"

#: ../../library/re.rst:906
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"在字符串类型的 *repl* 参数里，如上所述的转义和向后引用中，``\\g<name>`` 会使用命名组合 ``name``，（在  "
"``(?P<name>…)`` 语法中定义） ``\\g<number>`` 会使用数字组；``\\g<2>`` 就是 "
"``\\2``，但它避免了二义性，如 ``\\g<2>0``。 ``\\20`` 就会被解释为组20，而不是组2后面跟随一个字符 "
"``'0'``。向后引用 ``\\g<0>`` 把 *pattern* 作为一整个组进行引用。"

#: ../../library/re.rst:919 ../../library/re.rst:943 ../../library/re.rst:1177
msgid "Unmatched groups are replaced with an empty string."
msgstr "不匹配的组合替换为空字符串。"

#: ../../library/re.rst:922
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr "*pattern* 中的未知转义（由 ``'\\'`` 和一个 ASCII 字符组成）被视为错误。"

#: ../../library/re.rst:926
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are"
" errors."
msgstr "*repl* 中的未知转义（由 ``'\\'`` 和一个 ASCII 字符组成）被视为错误。"

#: ../../library/re.rst:930
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr "样式中的空匹配相邻接时会被替换。"

#: ../../library/re.rst:937
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr "行为与 :func:`sub` 相同，但是返回一个元组 ``(字符串, 替换次数)``."

#: ../../library/re.rst:949
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr "转义 *pattern* 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如 ::"

#: ../../library/re.rst:964
msgid ""
"This function must not be used for the replacement string in :func:`sub` and"
" :func:`subn`, only backslashes should be escaped.  For example::"
msgstr "这个函数不能被用于 :func:`sub` 和 :func:`subn` 的替换字符串，只有反斜杠应该被转义。 例如::"

#: ../../library/re.rst:972
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` 不再被转义。"

#: ../../library/re.rst:975
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"``"
" are no longer escaped."
msgstr ""
"只有在正则表达式中具有特殊含义的字符才会被转义。 因此， ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``,"
" ``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'`` 和 ``\"`\"`` "
"将不再会被转义。"

#: ../../library/re.rst:984
msgid "Clear the regular expression cache."
msgstr "清除正则表达式的缓存。"

#: ../../library/re.rst:988
msgid "Exceptions"
msgstr "异常"

#: ../../library/re.rst:992
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern.  The "
"error instance has the following additional attributes:"
msgstr ""
"当传递给函数的正则表达式不合法（比如括号不匹配），或者在编译或匹配过程中出现其他错误时，会引发异常。所给字符串不匹配所给模式不会引发异常。异常实例有以下附加属性："

#: ../../library/re.rst:1000
msgid "The unformatted error message."
msgstr "未格式化的错误消息。"

#: ../../library/re.rst:1004
msgid "The regular expression pattern."
msgstr "正则表达式的模式串。"

#: ../../library/re.rst:1008
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "编译失败的 *pattern* 的位置索引（可以是 ``None`` ）。"

#: ../../library/re.rst:1012
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "对应 *pos* (可以是 ``None``) 的行号。"

#: ../../library/re.rst:1016
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "对应 *pos* (可以是 ``None``) 的列号。"

#: ../../library/re.rst:1018
msgid "Added additional attributes."
msgstr "增加了额外的属性。"

#: ../../library/re.rst:1024
msgid "Regular Expression Objects"
msgstr "正则表达式对象 （正则对象）"

#: ../../library/re.rst:1026
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr "编译后的正则表达式对象支持以下方法和属性："

#: ../../library/re.rst:1031
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"扫描整个 *string* 寻找第一个匹配的位置， 并返回一个相应的 :ref:`匹配对象 <match-objects>`。如果没有匹配，就返回 "
"``None`` ；注意它和零长度匹配是不同的。"

#: ../../library/re.rst:1037
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"可选的第二个参数 *pos* 给出了字符串中开始搜索的位置索引；默认为 ``0``，它不完全等价于字符串切片； ``'^'`` "
"样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。"

#: ../../library/re.rst:1043
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"可选参数 *endpos* 限定了字符串搜索的结束；它假定字符串长度到 *endpos* ， 所以只有从 ``pos`` 到 ``endpos - "
"1`` 的字符会被匹配。如果 *endpos* 小于 *pos*，就不会有匹配产生；另外，如果 *rx* 是一个编译后的正则对象， "
"``rx.search(string, 0, 50)`` 等价于 ``rx.search(string[:50], 0)``。 ::"

#: ../../library/re.rst:1058
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"如果 *string* 的 *开始位置* 能够找到这个正则样式的任意个匹配，就返回一个相应的 :ref:`匹配对象 <match-"
"objects>`。如果不匹配，就返回 ``None`` ；注意它与零长度匹配是不同的。"

#: ../../library/re.rst:1063 ../../library/re.rst:1081
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~Pattern.search` method. ::"
msgstr "可选参数 *pos* 和 *endpos* 与 :meth:`~Pattern.search` 含义相同。 ::"

#: ../../library/re.rst:1071
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"如果你想定位匹配在 *string* 中的位置，使用 :meth:`~Pattern.search` 来替代（另参考  :ref:`search-vs-"
"match`）。"

#: ../../library/re.rst:1077
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"如果整个 *string* 匹配这个正则表达式，就返回一个相应的 :ref:`匹配对象 <match-objects>` 。 否则就返回 "
"``None`` ； 注意跟零长度匹配是不同的。"

#: ../../library/re.rst:1095
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "等价于 :func:`split` 函数，使用了编译后的样式。"

#: ../../library/re.rst:1100
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"类似函数 :func:`findall` ， 使用了编译后样式，但也可以接收可选参数 *pos* 和 *endpos* ，限制搜索范围，就像 "
":meth:`search`。"

#: ../../library/re.rst:1107
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"类似函数 :func:`finditer` ， 使用了编译后样式，但也可以接收可选参数 *pos* 和 *endpos* ，限制搜索范围，就像 "
":meth:`search`。"

#: ../../library/re.rst:1114
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "等价于 :func:`sub` 函数，使用了编译后的样式。"

#: ../../library/re.rst:1119
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "等价于 :func:`subn` 函数，使用了编译后的样式。"

#: ../../library/re.rst:1124
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and implicit "
"flags such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"正则匹配标记。这是可以传递给 :func:`.compile` 的参数，任何 ``(?…)`` 内联标记，隐性标记比如 :data:`UNICODE` "
"的结合。"

#: ../../library/re.rst:1131
msgid "The number of capturing groups in the pattern."
msgstr "捕获到的模式串中组的数量。"

#: ../../library/re.rst:1136
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr "映射由 ``(?P<id>)`` 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。"

#: ../../library/re.rst:1143
msgid "The pattern string from which the pattern object was compiled."
msgstr "编译对象的原始样式字符串。"

#: ../../library/re.rst:1146
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"添加 :func:`copy.copy` 和 :func:`copy.deepcopy` 函数的支持。编译后的正则表达式对象被认为是原子性的。"

#: ../../library/re.rst:1154
msgid "Match Objects"
msgstr "匹配对象"

#: ../../library/re.rst:1156
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` when "
"there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""
"匹配对象总是有一个布尔值 ``True``。如果没有匹配的话 :meth:`~Pattern.match` 和 "
":meth:`~Pattern.search` 返回 ``None`` 所以你可以简单的用 ``if`` 语句来判断是否匹配 ::"

#: ../../library/re.rst:1165
msgid "Match objects support the following methods and attributes:"
msgstr "匹配对象支持以下方法和属性："

#: ../../library/re.rst:1170
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"对 *template* 进行反斜杠转义替换并且返回，就像 :meth:`~Pattern.sub` 方法中一样。转义如同 ``\\n`` "
"被转换成合适的字符，数字引用(``\\1``, ``\\2``)和命名组合(``\\g<1>``, ``\\g<name>``) 替换为相应组合的内容。"

#: ../../library/re.rst:1182
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。"
" 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 "
"[1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 :exc:`IndexError` "
"异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。::"

#: ../../library/re.rst:1204
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""
"如果正则表达式使用了 ``(?P<name>...)`` 语法， *groupN* "
"参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，就引发一个 :exc:`IndexError` 异常。"

#: ../../library/re.rst:1209
msgid "A moderately complicated example::"
msgstr "一个相对复杂的例子 ::"

#: ../../library/re.rst:1217
msgid "Named groups can also be referred to by their index::"
msgstr "命名组合同样可以通过索引值引用 ::"

#: ../../library/re.rst:1224
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr "如果一个组匹配成功多次，就只返回最后一个匹配 ::"

#: ../../library/re.rst:1233
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr "这个等价于 ``m.group(g)``。这允许更方便的引用一个匹配 ::"

#: ../../library/re.rst:1249
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 *default* 参数用于不参与匹配的情况，默认为 ``None``。"

#: ../../library/re.rst:1253 ../../library/re.rst:1475
msgid "For example::"
msgstr "例如："

#: ../../library/re.rst:1259
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 ``None`` ，除非指定了 *default* 参数。 ::"

#: ../../library/re.rst:1272
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"返回一个字典，包含了所有的 *命名* 子组。key就是组名。 *default* 参数用于不参与匹配的组合；默认为 ``None``。 例如 ::"

#: ../../library/re.rst:1284
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"返回 *group* 匹配到的字串的开始和结束标号。*group* 默认为0（意思是整个匹配的子串）。如果  *group* 存在，但未产生匹配，就返回"
" ``-1`` 。对于一个匹配对象 *m*， 和一个未参与匹配的组 *g* ，组 *g* (等价于 ``m.group(g)``)产生的匹配是 ::"

#: ../../library/re.rst:1292
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"注意 ``m.start(group)`` 将会等于 ``m.end(group)`` ，如果 *group* 匹配一个空字符串的话。比如，在 ``m "
"= re.search('b(c?)', 'cba')`` 之后，``m.start(0)`` 为 1, ``m.end(0)`` 为 2, "
"``m.start(1)`` 和 ``m.end(1)`` 都是 2, ``m.start(2)`` 引发一个 :exc:`IndexError` "
"异常。"

#: ../../library/re.rst:1297
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "这个例子会从email地址中移除掉 *remove_this* ::"

#: ../../library/re.rst:1307
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note"
" that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"对于一个匹配 *m* ， 返回一个二元组 ``(m.start(group), m.end(group))`` 。 注意如果 *group* "
"没有在这个匹配中，就返回 ``(-1, -1)`` 。*group* 默认为0，就是整个匹配。"

#: ../../library/re.rst:1314
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string at which the RE engine started looking for a "
"match."
msgstr ""
"*pos* 的值，会传递给 :meth:`~Pattern.search` 或 :meth:`~Pattern.match` 的方法 a "
":ref:`正则对象 <re-objects>` 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。"

#: ../../library/re.rst:1321
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string beyond which the RE engine will not go."
msgstr ""
"*endpos* 的值，会传递给 :meth:`~Pattern.search` 或 :meth:`~Pattern.match` 的方法 a "
":ref:`正则对象 <re-objects>` 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。"

#: ../../library/re.rst:1328
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr ""
"捕获组的最后一个匹配的整数索引值，或者 ``None`` 如果没有匹配产生的话。比如，对于字符串 ``'ab'``，表达式 ``(a)b``, "
"``((a)(b))``, 和 ``((ab))`` 将得到 ``lastindex == 1`` ， 而 ``(a)(b)`` 会得到 "
"``lastindex == 2`` 。"

#: ../../library/re.rst:1337
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr "最后一个匹配的命名组名字，或者 ``None`` 如果没有产生匹配的话。"

#: ../../library/re.rst:1343
msgid ""
"The :ref:`regular expression object <re-objects>` whose "
":meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this match"
" instance."
msgstr ""
"返回产生这个实例的 :ref:`正则对象 <re-objects>` ， 这个实例是由 正则对象的 :meth:`~Pattern.match` 或 "
":meth:`~Pattern.search` 方法产生的。"

#: ../../library/re.rst:1349
msgid ""
"The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr "传递到 :meth:`~Pattern.match` 或 :meth:`~Pattern.search` 的字符串。"

#: ../../library/re.rst:1352
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects"
" are considered atomic."
msgstr "添加了对 :func:`copy.copy` 和 :func:`copy.deepcopy` 的支持。匹配对象被看作是原子性的。"

#: ../../library/re.rst:1360
msgid "Regular Expression Examples"
msgstr "正则表达式例子"

#: ../../library/re.rst:1364
msgid "Checking for a Pair"
msgstr "检查对子"

#: ../../library/re.rst:1366
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr "在这个例子里，我们使用以下辅助函数来更好地显示匹配对象::"

#: ../../library/re.rst:1374
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，\"a\" 就是 A, \"k\"  K， \"q\"  Q, \"j\" "
"J, \"t\" 为 10, \"2\" 到 \"9\" 表示2 到 9。"

#: ../../library/re.rst:1379
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr "要看给定的字符串是否有效，我们可以按照以下步骤 ::"

#: ../../library/re.rst:1389
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such::"
msgstr "最后一手牌，``\"727ak\"`` ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下 ::"

#: ../../library/re.rst:1399
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~Match.group` method of the match object in the following manner::"
msgstr "要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 :meth:`~Match.group` 方法::"

#: ../../library/re.rst:1418
msgid "Simulating scanf()"
msgstr "模拟 scanf()"

#: ../../library/re.rst:1422
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python 目前没有一个类似c函数 :c:func:`scanf` 的替代品。正则表达式通常比 :c:func:`scanf` "
"格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 :c:func:`scanf` 格式符和正则表达式大致相同的映射。"

#: ../../library/re.rst:1429
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` 格式符"

#: ../../library/re.rst:1429
msgid "Regular Expression"
msgstr "正则表达式"

#: ../../library/re.rst:1431
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1433
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1433
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1435
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1435
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1437
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1437
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1439
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1439
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1441
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1441
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1443
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1443
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1445
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1445
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1447
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1447
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1450
msgid "To extract the filename and numbers from a string like ::"
msgstr "从文件名和数字提取字符串 ::"

#: ../../library/re.rst:1454
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "你可以使用 :c:func:`scanf` 格式化 ::"

#: ../../library/re.rst:1458
msgid "The equivalent regular expression would be ::"
msgstr "等价的正则表达式是："

#: ../../library/re.rst:1466
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1470
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python 提供了两种不同的操作：基于 :func:`re.match` 检查字符串开头，或者 :func:`re.search` "
"检查字符串的任意位置（默认Perl中的行为）。"

#: ../../library/re.rst:1481
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "在 :func:`search` 中，可以用 ``'^'`` 作为开始来限制匹配到字符串的首位 ::"

#: ../../library/re.rst:1489
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line. "
"::"
msgstr ""
"注意 :const:`MULTILINE` 多行模式中函数 :func:`match` 只匹配字符串的开始，但使用 :func:`search` 和以 "
"``'^'`` 开始的正则表达式会匹配每行的开始 ::"

#: ../../library/re.rst:1499
msgid "Making a Phonebook"
msgstr "制作一个电话本"

#: ../../library/re.rst:1501
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。"

#: ../../library/re.rst:1506
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr "首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法"

#: ../../library/re.rst:1519
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr "条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:"

#: ../../library/re.rst:1532
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 :func:`split` 使用了 ``maxsplit`` "
"形参，因为地址中包含有被我们作为分割模式的空格符:"

#: ../../library/re.rst:1545
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"``:?`` 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 ``maxsplit`` 设置为 ``4`` ，我们还可以从地址中获取到房间号:"

#: ../../library/re.rst:1560
msgid "Text Munging"
msgstr "文字整理"

#: ../../library/re.rst:1562
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` 替换字符串中出现的样式的每一个实例。这个例子证明了使用  :func:`sub` "
"来整理文字，或者随机化每个字符的位置，除了首位和末尾字符 ::"

#: ../../library/re.rst:1579
msgid "Finding all Adverbs"
msgstr "查找所有副词"

#: ../../library/re.rst:1581
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` 匹配样式 *所有* 的出现，不仅是像 :func:`search` "
"中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 :func:`findall` ::"

#: ../../library/re.rst:1592
msgid "Finding all Adverbs and their Positions"
msgstr "查找所有的副词及其位置"

#: ../../library/re.rst:1594
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"如果需要匹配样式的更多信息， :func:`finditer` 可以起到作用，它提供了 :ref:`匹配对象 <match-objects>` "
"作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 :func:`finditer`  ::"

#: ../../library/re.rst:1608
msgid "Raw String Notation"
msgstr "原始字符串标记"

#: ../../library/re.rst:1610
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"原始字符串记法 (``r\"text\"``) 保持正则表达式正常。否则，每个正则式里的反斜杠(``'\\'``) "
"都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的 ::"

#: ../../library/re.rst:1620
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr "当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 ``r\"\\\\\"``。否则就必须用 ``\"\\\\\\\\\"``，来表示同样的意思 ::"

#: ../../library/re.rst:1632
msgid "Writing a Tokenizer"
msgstr "写一个词法分析器"

#: ../../library/re.rst:1634
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"一个 `词法器或词法分析器 <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。"

#: ../../library/re.rst:1638
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over"
" successive matches::"
msgstr "文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的 ::"

#: ../../library/re.rst:1694
msgid "The tokenizer produces the following output::"
msgstr "该词法器产生以下的输出 ::"

#: ../../library/re.rst:1717
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. 该书的第三版不再包含 Python，但第一版极详细地覆盖了正则表达式模式串的编写。"
