# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:06+0000\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ""

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re/`"
msgstr ""

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those"
" found in Perl."
msgstr ""

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a bytes pattern or vice-versa; similarly, when asking "
"for a substitution, the replacement string must be of the same type as both "
"the pattern and the search string."
msgstr ""

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in"
" the future this will become a :exc:`SyntaxError`. This behaviour will "
"happen even if it is a valid escape sequence for a regular expression."
msgstr ""

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal"
" prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string"
" containing a newline.  Usually patterns will be expressed in Python code "
"using this raw string notation."
msgstr ""

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""

#: ../../library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has"
" an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr ""

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the"
" functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described here."
"  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""

#: ../../library/re.rst:90
msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) "
"cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations. To"
" apply a second repetition to an inner repetition, parentheses may be used. "
"For example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr ""

#: ../../library/re.rst:104 ../../library/re.rst:1604
msgid "``.``"
msgstr ""

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""

#: ../../library/re.rst:110
msgid "``^``"
msgstr ""

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""

#: ../../library/re.rst:121
msgid "``$``"
msgstr ""

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in"
" ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will "
"find two (empty) matches: one just before the newline, and one at the end of"
" the string."
msgstr ""

#: ../../library/re.rst:128
msgid "``*``"
msgstr ""

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""

#: ../../library/re.rst:135
msgid "``+``"
msgstr ""

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""

#: ../../library/re.rst:141
msgid "``?``"
msgstr ""

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr ""

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire"
" string, and not just ``'<a>'``.  Adding ``?`` after the quantifier makes it"
" perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""

#: ../../library/re.rst:179
msgid "``*+``, ``++``, ``?+``"
msgstr ""

#: ../../library/re.rst:163
msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` is "
"appended also match as many times as possible. However, unlike the true "
"greedy quantifiers, these do not allow back-tracking when the expression "
"following it fails to match. These are known as :dfn:`possessive` "
"quantifiers. For example, ``a*a`` will match ``'aaaa'`` because the ``a*`` "
"will match all 4 ``'a'``\\ s, but, when the final ``'a'`` is encountered, "
"the expression is backtracked so that in the end the ``a*`` ends up matching"
" 3 ``'a'``\\ s total, and the fourth ``'a'`` is matched by the final "
"``'a'``. However, when ``a*+a`` is used to match ``'aaaa'``, the ``a*+`` "
"will match all 4 ``'a'``, but when the final ``'a'`` fails to find any more "
"characters to match, the expression cannot be backtracked and will thus fail"
" to match. ``x*+``, ``x++`` and ``x?+`` are equivalent to ``(?>x*)``, "
"``(?>x+)`` and ``(?>x?)`` correspondingly."
msgstr ""

#: ../../library/re.rst:187
msgid "``{m}``"
msgstr ""

#: ../../library/re.rst:185
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""

#: ../../library/re.rst:196
msgid "``{m,n}``"
msgstr ""

#: ../../library/re.rst:190
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m*"
" specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand"
" ``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may"
" not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""

#: ../../library/re.rst:203
msgid "``{m,n}?``"
msgstr ""

#: ../../library/re.rst:199
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is"
" the non-greedy version of the previous quantifier.  For example, on the "
"6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters,"
" while ``a{3,5}?`` will only match 3 characters."
msgstr ""

#: ../../library/re.rst:218
msgid "``{m,n}+``"
msgstr ""

#: ../../library/re.rst:206
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible *without* "
"establishing any backtracking points. This is the possessive version of the "
"quantifier above. For example, on the 6-character string ``'aaaaaa'``, "
"``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, requiring 2 more "
"``'a'``\\ s, will need more characters than available and thus fail, while "
"``a{3,5}aa`` will match with ``a{3,5}`` capturing 5, then 4 ``'a'``\\ s by "
"backtracking and then the final 2 ``'a'``\\ s are matched by the final "
"``aa`` in the pattern. ``x{m,n}+`` is equivalent to ``(?>x{m,n})``."
msgstr ""

#: ../../library/re.rst:233
msgid "``\\``"
msgstr ""

#: ../../library/re.rst:223
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""

#: ../../library/re.rst:227
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""

#: ../../library/re.rst:293
msgid "``[]``"
msgstr ""

#: ../../library/re.rst:239
msgid "Used to indicate a set of characters.  In a set:"
msgstr ""

#: ../../library/re.rst:241
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""

#: ../../library/re.rst:246
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase"
" ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""

#: ../../library/re.rst:253
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""

#: ../../library/re.rst:259
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depend on the "
"flags_ used."
msgstr ""

#: ../../library/re.rst:264
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is ``'^'``,"
" all the characters that are *not* in the set will be matched.  For example,"
" ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""

#: ../../library/re.rst:271
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""

#: ../../library/re.rst:281
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['``"
" or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and"
" ``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""

#: ../../library/re.rst:291
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""

#: ../../library/re.rst:306
msgid "``|``"
msgstr ""

#: ../../library/re.rst:298
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups"
" (see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""

#: ../../library/re.rst:316
msgid "``(...)``"
msgstr ""

#: ../../library/re.rst:312
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates"
" the start and end of a group; the contents of a group can be retrieved "
"after a match has been performed, and can be matched later in the string "
"with the ``\\number`` special sequence, described below.  To match the "
"literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside "
"a character class: ``[(]``, ``[)]``."
msgstr ""

#: ../../library/re.rst:325
msgid "``(?...)``"
msgstr ""

#: ../../library/re.rst:321
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""

#: ../../library/re.rst:348
msgid "``(?aiLmsux)``"
msgstr ""

#: ../../library/re.rst:328
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) The group matches the empty string; the letters "
"set the corresponding flags for the entire regular expression:"
msgstr ""

#: ../../library/re.rst:333 ../../library/re.rst:365
msgid ":const:`re.A` (ASCII-only matching)"
msgstr ""

#: ../../library/re.rst:334 ../../library/re.rst:366
msgid ":const:`re.I` (ignore case)"
msgstr ""

#: ../../library/re.rst:335 ../../library/re.rst:367
msgid ":const:`re.L` (locale dependent)"
msgstr ""

#: ../../library/re.rst:336 ../../library/re.rst:368
msgid ":const:`re.M` (multi-line)"
msgstr ""

#: ../../library/re.rst:337 ../../library/re.rst:369
msgid ":const:`re.S` (dot matches all)"
msgstr ""

#: ../../library/re.rst:338 ../../library/re.rst:370
msgid ":const:`re.U` (Unicode matching)"
msgstr ""

#: ../../library/re.rst:339 ../../library/re.rst:371
msgid ":const:`re.X` (verbose)"
msgstr ""

#: ../../library/re.rst:341
msgid ""
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if"
" you wish to include the flags as part of the regular expression, instead of"
" passing a *flag* argument to the :func:`re.compile` function. Flags should "
"be used first in the expression string."
msgstr ""

#: ../../library/re.rst:347
msgid "This construction can only be used at the start of the expression."
msgstr ""

#: ../../library/re.rst:356
msgid "``(?:...)``"
msgstr ""

#: ../../library/re.rst:353
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group"
" *cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""

#: ../../library/re.rst:388
msgid "``(?aiLmsux-imsx:...)``"
msgstr ""

#: ../../library/re.rst:359
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or"
" more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags for the part of the expression:"
msgstr ""

#: ../../library/re.rst:373
msgid "(The flags are described in :ref:`contents-of-module-re`.)"
msgstr ""

#: ../../library/re.rst:375
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as"
" inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"bytes patterns ``(?L:...)`` switches to locale dependent matching, and "
"``(?a:...)`` switches to ASCII-only matching (default). This override is "
"only in effect for the narrow inline group, and the original matching mode "
"is restored outside of the group."
msgstr ""

#: ../../library/re.rst:387
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""

#: ../../library/re.rst:403
msgid "``(?>...)``"
msgstr ""

#: ../../library/re.rst:391
msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and if"
" successful, continues to match the rest of the pattern following it. If the"
" subsequent pattern fails to match, the stack can only be unwound to a point"
" *before* the ``(?>...)`` because once exited, the expression, known as an "
":dfn:`atomic group`, has thrown away all stack points within itself. Thus, "
"``(?>.*).`` would never match anything because first the ``.*`` would match "
"all characters possible, then, having nothing left to match, the final ``.``"
" would fail to match. Since there are no stack points saved in the Atomic "
"Group, and there is no stack point before it, the entire expression would "
"thus fail to match."
msgstr ""

#: ../../library/re.rst:434
msgid "``(?P<name>...)``"
msgstr ""

#: ../../library/re.rst:408
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""

#: ../../library/re.rst:414
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either"
" single or double quotes):"
msgstr ""

#: ../../library/re.rst:419
msgid "Context of reference to group \"quote\""
msgstr ""

#: ../../library/re.rst:419
msgid "Ways to reference it"
msgstr ""

#: ../../library/re.rst:421
msgid "in the same pattern itself"
msgstr ""

#: ../../library/re.rst:421
msgid "``(?P=quote)`` (as shown)"
msgstr ""

#: ../../library/re.rst:422 ../../library/re.rst:429
msgid "``\\1``"
msgstr ""

#: ../../library/re.rst:424
msgid "when processing match object *m*"
msgstr ""

#: ../../library/re.rst:424
msgid "``m.group('quote')``"
msgstr ""

#: ../../library/re.rst:425
msgid "``m.end('quote')`` (etc.)"
msgstr ""

#: ../../library/re.rst:427
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr ""

#: ../../library/re.rst:427
msgid "``\\g<quote>``"
msgstr ""

#: ../../library/re.rst:428
msgid "``\\g<1>``"
msgstr ""

#: ../../library/re.rst:432
msgid ""
"Group *name* containing characters outside the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``) in :class:`bytes` patterns."
msgstr ""

#: ../../library/re.rst:440
msgid "``(?P=name)``"
msgstr ""

#: ../../library/re.rst:439
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""

#: ../../library/re.rst:445
msgid "``(?#...)``"
msgstr ""

#: ../../library/re.rst:445
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr ""

#: ../../library/re.rst:452
msgid "``(?=...)``"
msgstr ""

#: ../../library/re.rst:450
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""

#: ../../library/re.rst:459
msgid "``(?!...)``"
msgstr ""

#: ../../library/re.rst:457
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""

#: ../../library/re.rst:486
msgid "``(?<=...)``"
msgstr ""

#: ../../library/re.rst:464
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed"
" length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and "
"``a{3,4}`` are not.  Note that patterns which start with positive lookbehind"
" assertions will not match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than the"
" :func:`match` function:"
msgstr ""

#: ../../library/re.rst:479
msgid "This example looks for a word following a hyphen:"
msgstr ""

#: ../../library/re.rst:485
msgid "Added support for group references of fixed length."
msgstr ""

#: ../../library/re.rst:495
msgid "``(?<!...)``"
msgstr ""

#: ../../library/re.rst:491
msgid ""
"Matches if the current position in the string is not preceded by a match for"
" ``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar "
"to positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind"
" assertions may match at the beginning of the string being searched."
msgstr ""

#: ../../library/re.rst:512
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr ""

#: ../../library/re.rst:501
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching pattern, "
"which will match with ``'<user@host.com>'`` as well as ``'user@host.com'``, "
"but not with ``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""

#: ../../library/re.rst:508 ../../library/re.rst:1084
msgid ""
"Group *id* containing anything except ASCII digits. Group *name* containing "
"characters outside the ASCII range (``b'\\x00'``-``b'\\x7f'``) in "
":class:`bytes` replacement strings."
msgstr ""

#: ../../library/re.rst:516
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$``"
" matches the character ``'$'``."
msgstr ""

#: ../../library/re.rst:531
msgid "``\\number``"
msgstr ""

#: ../../library/re.rst:524
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first"
" digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""

#: ../../library/re.rst:536
msgid "``\\A``"
msgstr ""

#: ../../library/re.rst:536
msgid "Matches only at the start of the string."
msgstr ""

#: ../../library/re.rst:558
msgid "``\\b``"
msgstr ""

#: ../../library/re.rst:541
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word"
" is defined as a sequence of word characters. Note that formally, ``\\b`` is"
" defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning or end of the string. This "
"means that ``r'\\bat\\b'`` matches ``'at'``, ``'at.'``, ``'(at)'``, and "
"``'as at ay'`` but not ``'attempt'`` or ``'atlas'``."
msgstr ""

#: ../../library/re.rst:549
msgid ""
"The default word characters in Unicode (str) patterns are Unicode "
"alphanumerics and the underscore, but this can be changed by using the "
":py:const:`~re.ASCII` flag. Word boundaries are determined by the current "
"locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""

#: ../../library/re.rst:557
msgid ""
"Inside a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""

#: ../../library/re.rst:572
msgid "``\\B``"
msgstr ""

#: ../../library/re.rst:563
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word. This means that ``r'at\\B'`` matches ``'athens'``, ``'atom'``, "
"``'attorney'``, but not ``'at'``, ``'at.'``, or ``'at!'``. ``\\B`` is the "
"opposite of ``\\b``, so word characters in Unicode (str) patterns are "
"Unicode alphanumerics or the underscore, although this can be changed by "
"using the :py:const:`~re.ASCII` flag. Word boundaries are determined by the "
"current locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""

#: ../../library/re.rst:588
msgid "``\\d``"
msgstr ""

#: ../../library/re.rst:584 ../../library/re.rst:607 ../../library/re.rst:630
msgid "For Unicode (str) patterns:"
msgstr ""

#: ../../library/re.rst:578
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category `[Nd]`__). This includes ``[0-9]``, and also many other "
"digit characters."
msgstr ""

#: ../../library/re.rst:582
msgid "Matches ``[0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:588 ../../library/re.rst:611 ../../library/re.rst:636
msgid "For 8-bit (bytes) patterns:"
msgstr ""

#: ../../library/re.rst:587
msgid ""
"Matches any decimal digit in the ASCII character set; this is equivalent to "
"``[0-9]``."
msgstr ""

#: ../../library/re.rst:596
msgid "``\\D``"
msgstr ""

#: ../../library/re.rst:593
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``."
msgstr ""

#: ../../library/re.rst:596
msgid "Matches ``[^0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:611
msgid "``\\s``"
msgstr ""

#: ../../library/re.rst:602
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages)."
msgstr ""

#: ../../library/re.rst:607
msgid "Matches ``[ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:610
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is"
" equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""

#: ../../library/re.rst:619
msgid "``\\S``"
msgstr ""

#: ../../library/re.rst:616
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``."
msgstr ""

#: ../../library/re.rst:619
msgid "Matches ``[^ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:636
msgid "``\\w``"
msgstr ""

#: ../../library/re.rst:625
msgid ""
"Matches Unicode word characters; this includes all Unicode alphanumeric "
"characters (as defined by :py:meth:`str.isalnum`), as well as the underscore"
" (``_``)."
msgstr ""

#: ../../library/re.rst:630
msgid "Matches ``[a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:633
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``. If the :py:const:`~re.LOCALE` flag is "
"used, matches characters considered alphanumeric in the current locale and "
"the underscore."
msgstr ""

#: ../../library/re.rst:650
msgid "``\\W``"
msgstr ""

#: ../../library/re.rst:641
msgid ""
"Matches any character which is not a word character. This is the opposite of"
" ``\\w``. By default, matches non-underscore (``_``) characters for which "
":py:meth:`str.isalnum` returns ``False``."
msgstr ""

#: ../../library/re.rst:646
msgid "Matches ``[^a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:648
msgid ""
"If the :py:const:`~re.LOCALE` flag is used, matches characters which are "
"neither alphanumeric in the current locale nor the underscore."
msgstr ""

#: ../../library/re.rst:655
msgid "``\\Z``"
msgstr ""

#: ../../library/re.rst:655
msgid "Matches only at the end of the string."
msgstr ""

#: ../../library/re.rst:671
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""

#: ../../library/re.rst:678
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""

#: ../../library/re.rst:681
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes "
"of ASCII letters are reserved for future use and treated as errors."
msgstr ""

#: ../../library/re.rst:687
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or"
" if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""

#: ../../library/re.rst:692
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr ""

#: ../../library/re.rst:695
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""

#: ../../library/re.rst:698
msgid ""
"The :samp:`'\\\\N\\\\{{name}\\\\}'` escape sequence has been added. As in "
"string literals, it expands to the named Unicode character (e.g. ``'\\N{EM "
"DASH}'``)."
msgstr ""

#: ../../library/re.rst:706
msgid "Module Contents"
msgstr ""

#: ../../library/re.rst:708
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""

#: ../../library/re.rst:715
msgid "Flags"
msgstr ""

#: ../../library/re.rst:717
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""

#: ../../library/re.rst:724
msgid ""
"An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr ""

#: ../../library/re.rst:726
msgid "- added to ``__all__``"
msgstr ""

#: ../../library/re.rst:731
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode (str) patterns, and is ignored for bytes "
"patterns."
msgstr ""

#: ../../library/re.rst:735
msgid "Corresponds to the inline flag ``(?a)``."
msgstr ""

#: ../../library/re.rst:739
msgid ""
"The :py:const:`~re.U` flag still exists for backward compatibility, but is "
"redundant in Python 3 since matches are Unicode by default for ``str`` "
"patterns, and Unicode matching isn't allowed for bytes patterns. "
":py:const:`~re.UNICODE` and the inline flag ``(?u)`` are similarly "
"redundant."
msgstr ""

#: ../../library/re.rst:748
msgid "Display debug information about compiled expression."
msgstr ""

#: ../../library/re.rst:750
msgid "No corresponding inline flag."
msgstr ""

#: ../../library/re.rst:756
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also  "
"match lowercase letters. Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :py:const:`~re.ASCII` flag is used to disable "
"non-ASCII matches. The current locale does not change the effect of this "
"flag unless the :py:const:`~re.LOCALE` flag is also used."
msgstr ""

#: ../../library/re.rst:764
msgid "Corresponds to the inline flag ``(?i)``."
msgstr ""

#: ../../library/re.rst:766
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' "
"(U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If the "
":py:const:`~re.ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' "
"are matched."
msgstr ""

#: ../../library/re.rst:777
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale. This flag can be used only with bytes "
"patterns."
msgstr ""

#: ../../library/re.rst:781
msgid "Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../../library/re.rst:785
msgid ""
"This flag is discouraged; consider Unicode matching instead. The locale "
"mechanism is very unreliable as it only handles one \"culture\" at a time "
"and only works with 8-bit locales. Unicode matching is enabled by default "
"for Unicode (str) patterns and it is able to handle different locales and "
"languages."
msgstr ""

#: ../../library/re.rst:792
msgid ""
":py:const:`~re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :py:const:`~re.ASCII`."
msgstr ""

#: ../../library/re.rst:796
msgid ""
"Compiled regular expression objects with the :py:const:`~re.LOCALE` flag no "
"longer depend on the locale at compile time. Only the locale at matching "
"time affects the result of matching."
msgstr ""

#: ../../library/re.rst:805
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string"
" and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at"
" the end of the string."
msgstr ""

#: ../../library/re.rst:812
msgid "Corresponds to the inline flag ``(?m)``."
msgstr ""

#: ../../library/re.rst:816
msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be used "
"as a default value for a function keyword argument or as a base value that "
"will be conditionally ORed with other flags.  Example of use as a default "
"value::"
msgstr ""

#: ../../library/re.rst:829
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""

#: ../../library/re.rst:832
msgid "Corresponds to the inline flag ``(?s)``."
msgstr ""

#: ../../library/re.rst:838
msgid ""
"In Python 3, Unicode characters are matched by default for ``str`` patterns."
" This flag is therefore redundant with **no effect** and is only kept for "
"backward compatibility."
msgstr ""

#: ../../library/re.rst:843
msgid ""
"See :py:const:`~re.ASCII` to restrict matching to ASCII characters instead."
msgstr ""

#: ../../library/re.rst:850
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""

#: ../../library/re.rst:860
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""

#: ../../library/re.rst:868
msgid "Corresponds to the inline flag ``(?x)``."
msgstr ""

#: ../../library/re.rst:872
msgid "Functions"
msgstr ""

#: ../../library/re.rst:876
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its "
":func:`~Pattern.match`, :func:`~Pattern.search` and other methods, described"
" below."
msgstr ""

#: ../../library/re.rst:881
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the `flags`_ variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""

#: ../../library/re.rst:885
msgid "The sequence ::"
msgstr ""

#: ../../library/re.rst:890
msgid "is equivalent to ::"
msgstr ""

#: ../../library/re.rst:894
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""

#: ../../library/re.rst:900
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr ""

#: ../../library/re.rst:908
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":class:`~re.Match`. Return ``None`` if no position in the string matches the"
" pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""

#: ../../library/re.rst:916
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`~re.Match`.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../../library/re.rst:921
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""

#: ../../library/re.rst:924
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../../library/re.rst:930
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""

#: ../../library/re.rst:939
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""

#: ../../library/re.rst:954
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""

#: ../../library/re.rst:961
msgid ""
"That way, separator components are always found at the same relative indices"
" within the result list."
msgstr ""

#: ../../library/re.rst:964
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""

#: ../../library/re.rst:976 ../../library/re.rst:1066
#: ../../library/re.rst:1095
msgid "Added the optional flags argument."
msgstr ""

#: ../../library/re.rst:979
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""

#: ../../library/re.rst:985
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""

#: ../../library/re.rst:989
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that group."
"  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""

#: ../../library/re.rst:1001 ../../library/re.rst:1012
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""

#: ../../library/re.rst:1007
msgid ""
"Return an :term:`iterator` yielding :class:`~re.Match` objects over all non-"
"overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result."
msgstr ""

#: ../../library/re.rst:1018
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string"
" or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of"
" ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""

#: ../../library/re.rst:1034
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :class:`~re.Match` argument, and "
"returns the replacement string.  For example::"
msgstr ""

#: ../../library/re.rst:1046
msgid "The pattern may be a string or a :class:`~re.Pattern`."
msgstr ""

#: ../../library/re.rst:1048
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero,"
" all occurrences will be replaced. Empty matches for the pattern are "
"replaced only when not adjacent to a previous empty match, so ``sub('x*', "
"'-', 'abxd')`` returns ``'-a-b--d-'``."
msgstr ""

#: ../../library/re.rst:1056
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched"
" by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore"
" equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""

#: ../../library/re.rst:1069 ../../library/re.rst:1098
#: ../../library/re.rst:1342
msgid "Unmatched groups are replaced with an empty string."
msgstr ""

#: ../../library/re.rst:1072
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""

#: ../../library/re.rst:1076
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are"
" errors."
msgstr ""

#: ../../library/re.rst:1080
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""

#: ../../library/re.rst:1092
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string,"
" number_of_subs_made)``."
msgstr ""

#: ../../library/re.rst:1104
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""

#: ../../library/re.rst:1119
msgid ""
"This function must not be used for the replacement string in :func:`sub` and"
" :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../../library/re.rst:1127
msgid "The ``'_'`` character is no longer escaped."
msgstr ""

#: ../../library/re.rst:1130
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"``"
" are no longer escaped."
msgstr ""

#: ../../library/re.rst:1139
msgid "Clear the regular expression cache."
msgstr ""

#: ../../library/re.rst:1143
msgid "Exceptions"
msgstr ""

#: ../../library/re.rst:1147
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or matching."
"  It is never an error if a string contains no match for a pattern.  The "
"error instance has the following additional attributes:"
msgstr ""

#: ../../library/re.rst:1155
msgid "The unformatted error message."
msgstr ""

#: ../../library/re.rst:1159
msgid "The regular expression pattern."
msgstr ""

#: ../../library/re.rst:1163
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""

#: ../../library/re.rst:1167
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../../library/re.rst:1171
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../../library/re.rst:1173
msgid "Added additional attributes."
msgstr ""

#: ../../library/re.rst:1179
msgid "Regular Expression Objects"
msgstr ""

#: ../../library/re.rst:1183
msgid "Compiled regular expression object returned by :func:`re.compile`."
msgstr ""

#: ../../library/re.rst:1185
msgid ""
":py:class:`re.Pattern` supports ``[]`` to indicate a Unicode (str) or bytes "
"pattern. See :ref:`types-genericalias`."
msgstr ""

#: ../../library/re.rst:1191
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :class:`~re.Match`. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""

#: ../../library/re.rst:1196
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent"
" to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""

#: ../../library/re.rst:1202
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a"
" compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""

#: ../../library/re.rst:1217
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular"
" expression, return a corresponding :class:`~re.Match`. Return ``None`` if "
"the string does not match the pattern; note that this is different from a "
"zero-length match."
msgstr ""

#: ../../library/re.rst:1222 ../../library/re.rst:1240
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the "
":meth:`~Pattern.search` method. ::"
msgstr ""

#: ../../library/re.rst:1230
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../../library/re.rst:1236
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""

#: ../../library/re.rst:1254
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1259
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../../library/re.rst:1266
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../../library/re.rst:1273
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1278
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1283
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and implicit "
"flags such as :py:const:`~re.UNICODE` if the pattern is a Unicode string."
msgstr ""

#: ../../library/re.rst:1290
msgid "The number of capturing groups in the pattern."
msgstr ""

#: ../../library/re.rst:1295
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""

#: ../../library/re.rst:1302
msgid "The pattern string from which the pattern object was compiled."
msgstr ""

#: ../../library/re.rst:1305
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""

#: ../../library/re.rst:1313
msgid "Match Objects"
msgstr ""

#: ../../library/re.rst:1315
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` when "
"there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""

#: ../../library/re.rst:1326
msgid "Match object returned by successful ``match``\\ es and ``search``\\ es."
msgstr ""

#: ../../library/re.rst:1328
msgid ""
":py:class:`re.Match` supports ``[]`` to indicate a Unicode (str) or bytes "
"match. See :ref:`types-genericalias`."
msgstr ""

#: ../../library/re.rst:1334
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group. The "
"backreference ``\\g<0>`` will be replaced by the entire match."
msgstr ""

#: ../../library/re.rst:1347
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match,"
" the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""

#: ../../library/re.rst:1369
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""

#: ../../library/re.rst:1374
msgid "A moderately complicated example::"
msgstr ""

#: ../../library/re.rst:1382
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../../library/re.rst:1389
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../../library/re.rst:1398
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../../library/re.rst:1409
msgid "Named groups are supported as well::"
msgstr ""

#: ../../library/re.rst:1422
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""

#: ../../library/re.rst:1426 ../../library/re.rst:1651
msgid "For example::"
msgstr ""

#: ../../library/re.rst:1432
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../../library/re.rst:1445
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed"
" by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""

#: ../../library/re.rst:1457
msgid ""
"Return the indices of the start and end of the substring matched by *group*;"
" *group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""

#: ../../library/re.rst:1465
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""

#: ../../library/re.rst:1470
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../../library/re.rst:1480
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note"
" that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""

#: ../../library/re.rst:1487
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string at which the RE engine started looking for a "
"match."
msgstr ""

#: ../../library/re.rst:1494
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This "
"is the index into the string beyond which the RE engine will not go."
msgstr ""

#: ../../library/re.rst:1501
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the "
"string ``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == "
"2``, if applied to the same string."
msgstr ""

#: ../../library/re.rst:1510
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""

#: ../../library/re.rst:1516
msgid ""
"The :ref:`regular expression object <re-objects>` whose "
":meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this match"
" instance."
msgstr ""

#: ../../library/re.rst:1522
msgid ""
"The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""

#: ../../library/re.rst:1525
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects"
" are considered atomic."
msgstr ""

#: ../../library/re.rst:1533
msgid "Regular Expression Examples"
msgstr ""

#: ../../library/re.rst:1537
msgid "Checking for a Pair"
msgstr ""

#: ../../library/re.rst:1539
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""

#: ../../library/re.rst:1547
msgid ""
"Suppose you are writing a poker program where a player's hand is represented"
" as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""

#: ../../library/re.rst:1552
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""

#: ../../library/re.rst:1562
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences"
" as such::"
msgstr ""

#: ../../library/re.rst:1572
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~Match.group` method of the match object in the following manner::"
msgstr ""

#: ../../library/re.rst:1591
msgid "Simulating scanf()"
msgstr ""

#: ../../library/re.rst:1595
msgid ""
"Python does not currently have an equivalent to :c:func:`!scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than "
":c:func:`!scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`!scanf` format tokens and regular "
"expressions."
msgstr ""

#: ../../library/re.rst:1602
msgid ":c:func:`!scanf` Token"
msgstr ""

#: ../../library/re.rst:1602
msgid "Regular Expression"
msgstr ""

#: ../../library/re.rst:1604
msgid "``%c``"
msgstr ""

#: ../../library/re.rst:1606
msgid "``%5c``"
msgstr ""

#: ../../library/re.rst:1606
msgid "``.{5}``"
msgstr ""

#: ../../library/re.rst:1608
msgid "``%d``"
msgstr ""

#: ../../library/re.rst:1608
msgid "``[-+]?\\d+``"
msgstr ""

#: ../../library/re.rst:1610
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr ""

#: ../../library/re.rst:1610
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr ""

#: ../../library/re.rst:1612
msgid "``%i``"
msgstr ""

#: ../../library/re.rst:1612
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr ""

#: ../../library/re.rst:1614
msgid "``%o``"
msgstr ""

#: ../../library/re.rst:1614
msgid "``[-+]?[0-7]+``"
msgstr ""

#: ../../library/re.rst:1616
msgid "``%s``"
msgstr ""

#: ../../library/re.rst:1616
msgid "``\\S+``"
msgstr ""

#: ../../library/re.rst:1618
msgid "``%u``"
msgstr ""

#: ../../library/re.rst:1618
msgid "``\\d+``"
msgstr ""

#: ../../library/re.rst:1620
msgid "``%x``, ``%X``"
msgstr ""

#: ../../library/re.rst:1620
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr ""

#: ../../library/re.rst:1623
msgid "To extract the filename and numbers from a string like ::"
msgstr ""

#: ../../library/re.rst:1627
msgid "you would use a :c:func:`!scanf` format like ::"
msgstr ""

#: ../../library/re.rst:1631
msgid "The equivalent regular expression would be ::"
msgstr ""

#: ../../library/re.rst:1639
msgid "search() vs. match()"
msgstr ""

#: ../../library/re.rst:1643
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""

#: ../../library/re.rst:1645
msgid ""
":func:`re.match` checks for a match only at the beginning of the string"
msgstr ""

#: ../../library/re.rst:1646
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""

#: ../../library/re.rst:1648
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ""

#: ../../library/re.rst:1660
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""

#: ../../library/re.rst:1668
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line. "
"::"
msgstr ""

#: ../../library/re.rst:1678
msgid "Making a Phonebook"
msgstr ""

#: ../../library/re.rst:1680
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""

#: ../../library/re.rst:1685
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""

#: ../../library/re.rst:1698
msgid ""
"The entries are separated by one or more newlines. Now we convert the string"
" into a list with each nonempty line having its own entry:"
msgstr ""

#: ../../library/re.rst:1711
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""

#: ../../library/re.rst:1724
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""

#: ../../library/re.rst:1739
msgid "Text Munging"
msgstr ""

#: ../../library/re.rst:1741
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""

#: ../../library/re.rst:1758
msgid "Finding all Adverbs"
msgstr ""

#: ../../library/re.rst:1760
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""

#: ../../library/re.rst:1771
msgid "Finding all Adverbs and their Positions"
msgstr ""

#: ../../library/re.rst:1773
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :class:`~re.Match` "
"objects instead of strings.  Continuing with the previous example, if a "
"writer wanted to find all of the adverbs *and their positions* in some text,"
" they would use :func:`finditer` in the following manner::"
msgstr ""

#: ../../library/re.rst:1787
msgid "Raw String Notation"
msgstr ""

#: ../../library/re.rst:1789
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without"
" it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""

#: ../../library/re.rst:1799
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""

#: ../../library/re.rst:1811
msgid "Writing a Tokenizer"
msgstr ""

#: ../../library/re.rst:1813
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""

#: ../../library/re.rst:1817
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over"
" successive matches::"
msgstr ""

#: ../../library/re.rst:1873
msgid "The tokenizer produces the following output::"
msgstr ""

#: ../../library/re.rst:1896
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""

#: ../../library/re.rst:99
msgid ". (dot)"
msgstr ""

#: ../../library/re.rst:99 ../../library/re.rst:106 ../../library/re.rst:112
#: ../../library/re.rst:123 ../../library/re.rst:130 ../../library/re.rst:137
#: ../../library/re.rst:143 ../../library/re.rst:157 ../../library/re.rst:181
#: ../../library/re.rst:220 ../../library/re.rst:235 ../../library/re.rst:244
#: ../../library/re.rst:257 ../../library/re.rst:262 ../../library/re.rst:295
#: ../../library/re.rst:308 ../../library/re.rst:318 ../../library/re.rst:350
#: ../../library/re.rst:405 ../../library/re.rst:436 ../../library/re.rst:442
#: ../../library/re.rst:447 ../../library/re.rst:454 ../../library/re.rst:461
#: ../../library/re.rst:488 ../../library/re.rst:498 ../../library/re.rst:521
#: ../../library/re.rst:533 ../../library/re.rst:538 ../../library/re.rst:560
#: ../../library/re.rst:574 ../../library/re.rst:590 ../../library/re.rst:598
#: ../../library/re.rst:613 ../../library/re.rst:621 ../../library/re.rst:638
#: ../../library/re.rst:652 ../../library/re.rst:657 ../../library/re.rst:848
#: ../../library/re.rst:1054
msgid "in regular expressions"
msgstr ""

#: ../../library/re.rst:106 ../../library/re.rst:262
msgid "^ (caret)"
msgstr ""

#: ../../library/re.rst:112
msgid "$ (dollar)"
msgstr ""

#: ../../library/re.rst:123
msgid "* (asterisk)"
msgstr ""

#: ../../library/re.rst:130
msgid "+ (plus)"
msgstr ""

#: ../../library/re.rst:137
msgid "? (question mark)"
msgstr ""

#: ../../library/re.rst:143
msgid "*?"
msgstr ""

#: ../../library/re.rst:143
msgid "+?"
msgstr ""

#: ../../library/re.rst:143
msgid "??"
msgstr ""

#: ../../library/re.rst:157
msgid "*+"
msgstr ""

#: ../../library/re.rst:157
msgid "++"
msgstr ""

#: ../../library/re.rst:157
msgid "?+"
msgstr ""

#: ../../library/re.rst:181
msgid "{} (curly brackets)"
msgstr ""

#: ../../library/re.rst:220 ../../library/re.rst:257 ../../library/re.rst:521
msgid "\\ (backslash)"
msgstr ""

#: ../../library/re.rst:235
msgid "[] (square brackets)"
msgstr ""

#: ../../library/re.rst:244
msgid "- (minus)"
msgstr ""

#: ../../library/re.rst:295
msgid "| (vertical bar)"
msgstr ""

#: ../../library/re.rst:308
msgid "() (parentheses)"
msgstr ""

#: ../../library/re.rst:318
msgid "(?"
msgstr ""

#: ../../library/re.rst:350
msgid "(?:"
msgstr ""

#: ../../library/re.rst:405
msgid "(?P<"
msgstr ""

#: ../../library/re.rst:436
msgid "(?P="
msgstr ""

#: ../../library/re.rst:442
msgid "(?#"
msgstr ""

#: ../../library/re.rst:447
msgid "(?="
msgstr ""

#: ../../library/re.rst:454
msgid "(?!"
msgstr ""

#: ../../library/re.rst:461
msgid "(?<="
msgstr ""

#: ../../library/re.rst:488
msgid "(?<!"
msgstr ""

#: ../../library/re.rst:498
msgid "(?("
msgstr ""

#: ../../library/re.rst:533
msgid "\\A"
msgstr ""

#: ../../library/re.rst:538 ../../library/re.rst:657
msgid "\\b"
msgstr ""

#: ../../library/re.rst:560
msgid "\\B"
msgstr ""

#: ../../library/re.rst:574
msgid "\\d"
msgstr ""

#: ../../library/re.rst:590
msgid "\\D"
msgstr ""

#: ../../library/re.rst:598
msgid "\\s"
msgstr ""

#: ../../library/re.rst:613
msgid "\\S"
msgstr ""

#: ../../library/re.rst:621
msgid "\\w"
msgstr ""

#: ../../library/re.rst:638
msgid "\\W"
msgstr ""

#: ../../library/re.rst:652
msgid "\\Z"
msgstr ""

#: ../../library/re.rst:657
msgid "\\a"
msgstr ""

#: ../../library/re.rst:657
msgid "\\f"
msgstr ""

#: ../../library/re.rst:657
msgid "\\n"
msgstr ""

#: ../../library/re.rst:657
msgid "\\r"
msgstr ""

#: ../../library/re.rst:657
msgid "\\t"
msgstr ""

#: ../../library/re.rst:657
msgid "\\u"
msgstr ""

#: ../../library/re.rst:657
msgid "\\U"
msgstr ""

#: ../../library/re.rst:657
msgid "\\v"
msgstr ""

#: ../../library/re.rst:657
msgid "\\x"
msgstr ""

#: ../../library/re.rst:657
msgid "\\\\"
msgstr ""

#: ../../library/re.rst:848
msgid "# (hash)"
msgstr ""

#: ../../library/re.rst:1054
msgid "\\g"
msgstr ""

#: ../../library/re.rst:1593
msgid "scanf (C function)"
msgstr ""
