# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-27 14:50+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/smtplib.rst:2
msgid ":mod:`!smtplib` --- SMTP protocol client"
msgstr ":mod:`!smtplib` --- SMTP 协议客户端"

#: ../../library/smtplib.rst:9
msgid "**Source code:** :source:`Lib/smtplib.py`"
msgstr "**源代码：** :source:`Lib/smtplib.py`"

#: ../../library/smtplib.rst:17
msgid ""
"The :mod:`smtplib` module defines an SMTP client session object that can be "
"used to send mail to any internet machine with an SMTP or ESMTP listener "
"daemon.  For details of SMTP and ESMTP operation, consult :rfc:`821` (Simple"
" Mail Transfer Protocol) and :rfc:`1869` (SMTP Service Extensions)."
msgstr ""
":mod:`smtplib` 模块定义了一个 SMTP 客户端会话对象，该对象可将邮件发送到互联网上任何带有 SMTP 或 ESMTP "
"监听程序的计算机。 关于 SMTP 和 ESMTP 操作的更多细节请参阅 :rfc:`821` (简单邮件传输协议) 和 :rfc:`1869` "
"(SMTP 服务扩展)。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`可用性 <availability>`: 非 Emscripten，非 WASI。"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模块在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不适用或不可用。 请参阅 "
":ref:`wasm-availability` 了解详情。"

#: ../../library/smtplib.rst:26
msgid ""
"An :class:`SMTP` instance encapsulates an SMTP connection.  It has methods "
"that support a full repertoire of SMTP and ESMTP operations. If the optional"
" *host* and *port* parameters are given, the SMTP :meth:`connect` method is "
"called with those parameters during initialization.  If specified, "
"*local_hostname* is used as the FQDN of the local host in the HELO/EHLO "
"command.  Otherwise, the local hostname is found using "
":func:`socket.getfqdn`.  If the :meth:`connect` call returns anything other "
"than a success code, an :exc:`SMTPConnectError` is raised. The optional "
"*timeout* parameter specifies a timeout in seconds for blocking operations "
"like the connection attempt (if not specified, the global default timeout "
"setting will be used).  If the timeout expires, :exc:`TimeoutError` is "
"raised.  The optional *source_address* parameter allows binding to some "
"specific source address in a machine with multiple network interfaces, "
"and/or to some specific source TCP port. It takes a 2-tuple ``(host, "
"port)``, for the socket to bind to as its source address before connecting. "
"If omitted (or if *host* or *port* are ``''`` and/or ``0`` respectively) the"
" OS default behavior will be used."
msgstr ""
":class:`SMTP` 实例是对 SMTP 连接的封装。 它提供了支持全部 SMTP 和 ESMTP 操作的方法。 如果给出了可选的 *host* "
"和 *port* 形参，则会在初始化期间调用 SMTP :meth:`connect` 方法并附带这些形参。 如果指定了 "
"*local_hostname*，它将在 HELO/EHLO 命令中被用作本地主机的 FQDN。 在其他情况下，会使用 "
":func:`socket.getfqdn` 来找到本地主机名。 如果 :meth:`connect` 调用返回了表示成功代码以外的任何信息，则会引发 "
":exc:`SMTPConnectError`。 可选的 *timeout* "
"形参指定了阻塞操作如连接尝试的超时秒数（如果未指定，则将使用全局默认超时设置）。 如果达到超时限制，将会引发 :exc:`TimeoutError`。 "
"可选的 *source_address* 形参允许在有多张网卡的计算机中绑定到某些特定的源地址，和/或绑定到某个特定的源 TCP 端口。 它接受一个 2"
" 元组 ``(host, port)`` 作为在连接之前要绑定为其源地址的套接字。 如果省略 (或者如果 *host* 或 *port* 分别为 "
"``''`` 和/或 ``0``) 则将使用 OS 的默认行为。"

#: ../../library/smtplib.rst:44
msgid ""
"For normal use, you should only require the initialization/connect, "
":meth:`sendmail`, and :meth:`SMTP.quit` methods. An example is included "
"below."
msgstr ""
"正常使用时，只需要初始化或 connect 方法，:meth:`sendmail` 方法，再加上 :meth:`SMTP.quit` "
"方法即可。下文包括了一个示例。"

#: ../../library/smtplib.rst:48
msgid ""
"The :class:`SMTP` class supports the :keyword:`with` statement.  When used "
"like this, the SMTP ``QUIT`` command is issued automatically when the "
":keyword:`!with` statement exits.  E.g.::"
msgstr ""
":class:`SMTP` 类支持 :keyword:`with` 语句。当这样使用时，:keyword:`!with` 语句一退出就会自动发出 "
"SMTP ``QUIT`` 命令。例如::"

#: ../../library/smtplib.rst:52
msgid ""
">>> from smtplib import SMTP\n"
">>> with SMTP(\"domain.org\") as smtp:\n"
"...     smtp.noop()\n"
"...\n"
"(250, b'Ok')\n"
">>>"
msgstr ""
">>> from smtplib import SMTP\n"
">>> with SMTP(\"domain.org\") as smtp:\n"
"...     smtp.noop()\n"
"...\n"
"(250, b'Ok')\n"
">>>"

#: ../../library/smtplib.rst:59 ../../library/smtplib.rst:61
msgid ""
"All commands will raise an :ref:`auditing event <auditing>` "
"``smtplib.SMTP.send`` with arguments ``self`` and ``data``, where ``data`` "
"is the bytes about to be sent to the remote host."
msgstr ""
"所有命令都会引发一个 :ref:`审计事件 <auditing>` ``smtplib.SMTP.send``，附带参数 ``self`` 和 "
"``data``，其中 ``data`` 是即将发送到远程主机的字节串。"

#: ../../library/smtplib.rst:65
msgid "Support for the :keyword:`with` statement was added."
msgstr "添加了对 :keyword:`with` 语句的支持。"

#: ../../library/smtplib.rst:68
msgid "*source_address* argument was added."
msgstr "添加了 *source_address* 参数。"

#: ../../library/smtplib.rst:71
msgid "The SMTPUTF8 extension (:rfc:`6531`) is now supported."
msgstr "现在已支持 SMTPUTF8 扩展 (:rfc:`6531`)。"

#: ../../library/smtplib.rst:74
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket."
msgstr "如果 *timeout* 参数设置为 0，创建非阻塞套接字时，它将引发 :class:`ValueError` 来阻止该操作。"

#: ../../library/smtplib.rst:81
msgid ""
"An :class:`SMTP_SSL` instance behaves exactly the same as instances of "
":class:`SMTP`. :class:`SMTP_SSL` should be used for situations where SSL is "
"required from the beginning of the connection and using :meth:`starttls` is "
"not appropriate. If *host* is not specified, the local host is used. If "
"*port* is zero, the standard SMTP-over-SSL port (465) is used.  The optional"
" arguments *local_hostname*, *timeout* and *source_address* have the same "
"meaning as they do in the :class:`SMTP` class.  *context*, also optional, "
"can contain a :class:`~ssl.SSLContext` and allows configuring various "
"aspects of the secure connection.  Please read :ref:`ssl-security` for best "
"practices."
msgstr ""
":class:`SMTP_SSL` 实例与 :class:`SMTP` 实例的行为完全相同。在开始连接就需要 SSL，且 "
":meth:`starttls` 不适合的情况下，应该使用 :class:`SMTP_SSL`。如果未指定 *host*，则使用 "
"localhost。如果 *port* 为 0，则使用标准 SMTP-over-SSL 端口（465）。可选参数 "
"*local_hostname*、*timeout* 和 *source_address* 的含义与 :class:`SMTP` 类中的相同。可选参数 "
"*context* 是一个 :class:`~ssl.SSLContext` 对象，可以从多个方面配置安全连接。请阅读 :ref:`ssl-"
"security` 以获取最佳实践。"

#: ../../library/smtplib.rst:92 ../../library/smtplib.rst:415
msgid "*context* was added."
msgstr "增加了 *context*。"

#: ../../library/smtplib.rst:95
msgid "The *source_address* argument was added."
msgstr "添加了 *source_address* 参数。"

#: ../../library/smtplib.rst:98
msgid ""
"The class now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"该类现在支持使用 :attr:`ssl.SSLContext.check_hostname` 和 *服务器名称提示* (参见 "
":const:`ssl.HAS_SNI`) 进行主机名检测。"

#: ../../library/smtplib.rst:103
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket"
msgstr "如果 *timeout* 形参被设为零，则它将引发 :class:`ValueError` 来阻止创建非阻塞的套接字"

#: ../../library/smtplib.rst:107 ../../library/smtplib.rst:403
msgid "The deprecated *keyfile* and *certfile* parameters have been removed."
msgstr "已弃用的 *keyfile* 和 *certfile* 形参已被移除。"

#: ../../library/smtplib.rst:113
msgid ""
"The LMTP protocol, which is very similar to ESMTP, is heavily based on the "
"standard SMTP client. It's common to use Unix sockets for LMTP, so our "
":meth:`connect` method must support that as well as a regular host:port "
"server. The optional arguments *local_hostname* and *source_address* have "
"the same meaning as they do in the :class:`SMTP` class. To specify a Unix "
"socket, you must use an absolute path for *host*, starting with a '/'."
msgstr ""
"LMTP 协议与 ESMTP 非常相似，它很大程度上基于标准 SMTP 客户端。 将 Unix 套接字用于 LMTP 是很常见的，因此 "
":meth:`connect` 方法必须支持它以及常规的 host:port 服务器。 可选参数 *local_hostname* 和 "
"*source_address* 的含义与 :class:`SMTP` 类中的相同。 要指定 Unix 套接字，你必须使用绝对路径作为 "
"*host*，即以 '/' 开头。"

#: ../../library/smtplib.rst:120
msgid ""
"Authentication is supported, using the regular SMTP mechanism. When using a "
"Unix socket, LMTP generally don't support or require any authentication, but"
" your mileage might vary."
msgstr "支持使用常规的 SMTP 机制来进行认证。 当使用 Unix 套接字时，LMTP 通常不支持或要求任何认证，但你的情况可能会有所不同。"

#: ../../library/smtplib.rst:124
msgid "The optional *timeout* parameter was added."
msgstr "添加了可选的 *timeout* 形参。"

#: ../../library/smtplib.rst:128
msgid "A nice selection of exceptions is defined as well:"
msgstr "同样地定义了一组精心选择的异常:"

#: ../../library/smtplib.rst:133
msgid ""
"Subclass of :exc:`OSError` that is the base exception class for all the "
"other exceptions provided by this module."
msgstr ":exc:`OSError` 的子类，它是本模块提供的所有其他异常的基类。"

#: ../../library/smtplib.rst:136
msgid "SMTPException became subclass of :exc:`OSError`"
msgstr "SMTPException 已成为 :exc:`OSError` 的子类"

#: ../../library/smtplib.rst:142
msgid ""
"This exception is raised when the server unexpectedly disconnects, or when "
"an attempt is made to use the :class:`SMTP` instance before connecting it to"
" a server."
msgstr "当服务器意外断开连接，或在 :class:`SMTP` 实例连接到服务器之前尝试使用它时将引发此异常。"

#: ../../library/smtplib.rst:149
msgid ""
"Base class for all exceptions that include an SMTP error code. These "
"exceptions are generated in some instances when the SMTP server returns an "
"error code.  The error code is stored in the :attr:`smtp_code` attribute of "
"the error, and the :attr:`smtp_error` attribute is set to the error message."
msgstr ""
"包括 SMTP 错误代码的所有异常的基类。 这些异常会在 SMTP 服务器返回错误代码时在实例中生成。 错误代码存放在错误的 "
":attr:`smtp_code` 属性中，并且 :attr:`smtp_error` 属性会被设为错误消息。"

#: ../../library/smtplib.rst:157
msgid ""
"Sender address refused.  In addition to the attributes set by on all "
":exc:`SMTPResponseException` exceptions, this sets 'sender' to the string "
"that the SMTP server refused."
msgstr ""
"发送方地址被拒绝。  除了在所有 :exc:`SMTPResponseException` 异常上设置的属性，还会将 'sender' 设为代表拒绝方 "
"SMTP 服务器的字符串。"

#: ../../library/smtplib.rst:164
msgid ""
"All recipient addresses refused.  The errors for each recipient are "
"accessible through the attribute :attr:`recipients`, which is a dictionary "
"of exactly the same sort as :meth:`SMTP.sendmail` returns."
msgstr ""
"所有接收方地址被拒绝。 每个接收方的错误可通过属性 :attr:`recipients` 来访问，该属性是一个字典，其元素顺序与 "
":meth:`SMTP.sendmail` 所返回的一致。"

#: ../../library/smtplib.rst:171
msgid "The SMTP server refused to accept the message data."
msgstr "SMTP 服务器拒绝接收消息数据。"

#: ../../library/smtplib.rst:176
msgid "Error occurred during establishment of a connection  with the server."
msgstr "在建立与服务器的连接期间发生了错误。"

#: ../../library/smtplib.rst:181
msgid "The server refused our ``HELO`` message."
msgstr "服务器拒绝了我们的 ``HELO`` 消息。"

#: ../../library/smtplib.rst:186
msgid "The command or option attempted is not supported by the server."
msgstr "尝试的命令或选项不被服务器所支持。"

#: ../../library/smtplib.rst:193
msgid ""
"SMTP authentication went wrong.  Most probably the server didn't accept the "
"username/password combination provided."
msgstr "SMTP 认证出现问题。 最大的可能是服务器不接受所提供的用户名/密码组合。"

#: ../../library/smtplib.rst:199
msgid ":rfc:`821` - Simple Mail Transfer Protocol"
msgstr ":rfc:`821` - 简单邮件传输协议"

#: ../../library/smtplib.rst:200
msgid ""
"Protocol definition for SMTP.  This document covers the model, operating "
"procedure, and protocol details for SMTP."
msgstr "SMTP 的协议定义。 该文件涵盖了 SMTP 的模型、操作程序和协议细节。"

#: ../../library/smtplib.rst:203
msgid ":rfc:`1869` - SMTP Service Extensions"
msgstr ":rfc:`1869` - SMTP 服务扩展"

#: ../../library/smtplib.rst:204
msgid ""
"Definition of the ESMTP extensions for SMTP.  This describes a framework for"
" extending SMTP with new commands, supporting dynamic discovery of the "
"commands provided by the server, and defines a few additional commands."
msgstr ""
"定义了 SMTP 的 ESMTP 扩展。 这描述了一个用新命令扩展 SMTP 的框架，支持动态发现服务器所提供的命令，并定义了一些额外的命令。"

#: ../../library/smtplib.rst:212
msgid "SMTP Objects"
msgstr "SMTP 对象"

#: ../../library/smtplib.rst:214
msgid "An :class:`SMTP` instance has the following methods:"
msgstr "一个 :class:`SMTP` 实例拥有以下方法："

#: ../../library/smtplib.rst:219
msgid ""
"Set the debug output level.  A value of 1 or ``True`` for *level* results in"
" debug messages for connection and for all messages sent to and received "
"from the server.  A value of 2 for *level* results in these messages being "
"timestamped."
msgstr ""
"设置调试输出级别。 如果 *level* 的值为 1 或 ``True`` ，就会产生连接的调试信息，以及所有发送和接收服务器的信息。 如果 "
"*level* 的值为 2 ，则这些信息会被加上时间戳。"

#: ../../library/smtplib.rst:224
msgid "Added debuglevel 2."
msgstr "添调试级别 2 。"

#: ../../library/smtplib.rst:229
msgid ""
"Send a command *cmd* to the server.  The optional argument *args* is simply "
"concatenated to the command, separated by a space."
msgstr "向服务器发送一条命令 *cmd* 。 可选的参数 *args* 被简单地串联到命令中，用一个空格隔开。"

#: ../../library/smtplib.rst:232
msgid ""
"This returns a 2-tuple composed of a numeric response code and the actual "
"response line (multiline responses are joined into one long line.)"
msgstr "这将返回一个由数字响应代码和实际响应行组成的2元组（多行响应被连接成一个长行）。"

#: ../../library/smtplib.rst:235
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It is used to implement other methods and may be useful for "
"testing private extensions."
msgstr "在正常操作中，应该没有必要明确地调用这个方法。它被用来实现其他方法，对于测试私有扩展可能很有用。"

#: ../../library/smtplib.rst:239
msgid ""
"If the connection to the server is lost while waiting for the reply, "
":exc:`SMTPServerDisconnected` will be raised."
msgstr "如果在等待回复的过程中，与服务器的连接丢失， :exc:`SMTPServerDisconnected` 将被触发。"

#: ../../library/smtplib.rst:245
msgid ""
"Connect to a host on a given port.  The defaults are to connect to the local"
" host at the standard SMTP port (25). If the hostname ends with a colon "
"(``':'``) followed by a number, that suffix will be stripped off and the "
"number interpreted as the port number to use. This method is automatically "
"invoked by the constructor if a host is specified during instantiation.  "
"Returns a 2-tuple of the response code and message sent by the server in its"
" connection response."
msgstr ""
"连接到某个主机的某个端口。默认是连接到 localhost 的标准 SMTP 端口（25）上。如果主机名以冒号 (``':'``) "
"结尾，后跟数字，则该后缀将被删除，且数字将视作要使用的端口号。如果在实例化时指定了 host，则构造函数会自动调用本方法。返回包含响应码和响应消息的 2"
" 元组，它们由服务器在其连接响应中发送。"

#: ../../library/smtplib.rst:253
msgid ""
"Raises an :ref:`auditing event <auditing>` ``smtplib.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``smtplib.connect`` 并附带参数 ``self``, ``host``, "
"``port``。"

#: ../../library/smtplib.rst:258
msgid ""
"Identify yourself to the SMTP server using ``HELO``.  The hostname argument "
"defaults to the fully qualified domain name of the local host. The message "
"returned by the server is stored as the :attr:`helo_resp` attribute of the "
"object."
msgstr ""
"使用 ``HELO`` 向 SMTP 服务器表明自己的身份。 hostname 参数默认为本地主机的完全合格域名。服务器返回的消息被存储为对象的 "
":attr:`helo_resp` 属性。"

#: ../../library/smtplib.rst:263
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It will be implicitly called by the :meth:`sendmail` when "
"necessary."
msgstr "在正常操作中，应该没有必要明确调用这个方法。它将在必要时被 :meth:`sendmail` 隐式调用。"

#: ../../library/smtplib.rst:269
msgid ""
"Identify yourself to an ESMTP server using ``EHLO``.  The hostname argument "
"defaults to the fully qualified domain name of the local host.  Examine the "
"response for ESMTP option and store them for use by :meth:`has_extn`. Also "
"sets several informational attributes: the message returned by the server is"
" stored as the :attr:`ehlo_resp` attribute, :attr:`does_esmtp` is set to "
"``True`` or ``False`` depending on whether the server supports ESMTP, and "
":attr:`esmtp_features` will be a dictionary containing the names of the SMTP"
" service extensions this server supports, and their parameters (if any)."
msgstr ""
"使用 ``EHLO`` 向 ESMTP 服务器表明自己的身份。 hostname 参数默认为本地主机的完全合格域名。 检查 ESMTP "
"选项的响应，并存储它们供 :meth:`has_extn` 使用。同时设置几个信息属性：服务器返回的消息被存储为 :attr:`ehlo_resp` "
"属性， :attr:`does_esmtp` 根据服务器是否支持 ESMTP 被设置为 ``True`` 或 ``False`` ，而 "
":attr:`esmtp_features` 将是一个字典，包含这个服务器支持的 SMTP 服务扩展的名称，以及它们的参数（如果有）。"

#: ../../library/smtplib.rst:279
msgid ""
"Unless you wish to use :meth:`has_extn` before sending mail, it should not "
"be necessary to call this method explicitly.  It will be implicitly called "
"by :meth:`sendmail` when necessary."
msgstr ""
"除非你想在发送邮件前使用 :meth:`has_extn` ，否则应该没有必要明确调用这个方法。 它将在必要时被 :meth:`sendmail` "
"隐式调用。"

#: ../../library/smtplib.rst:285
msgid ""
"This method calls :meth:`ehlo` and/or :meth:`helo` if there has been no "
"previous ``EHLO`` or ``HELO`` command this session.  It tries ESMTP ``EHLO``"
" first."
msgstr ""
"如果这个会话中没有先前的 ``EHLO`` 或 ``HELO`` 命令，该方法会调用 :meth:`ehlo` 和/或 :meth:`helo` "
"。它首先尝试 ESMTP ``EHLO`` 。"

#: ../../library/smtplib.rst:289 ../../library/smtplib.rst:318
#: ../../library/smtplib.rst:406 ../../library/smtplib.rst:475
msgid ":exc:`SMTPHeloError`"
msgstr ":exc:`SMTPHeloError`"

#: ../../library/smtplib.rst:290 ../../library/smtplib.rst:319
#: ../../library/smtplib.rst:407 ../../library/smtplib.rst:476
msgid "The server didn't reply properly to the ``HELO`` greeting."
msgstr "服务器没有正确回复 ``HELO`` 问候。"

#: ../../library/smtplib.rst:294
msgid ""
"Return :const:`True` if *name* is in the set of SMTP service extensions "
"returned by the server, :const:`False` otherwise. Case is ignored."
msgstr ""
"如果 *name* 在服务器返回的 SMTP 服务扩展集合中，返回 :const:`True` ，否则为 :const:`False` 。大小写被忽略。"

#: ../../library/smtplib.rst:300
msgid ""
"Check the validity of an address on this server using SMTP ``VRFY``. Returns"
" a tuple consisting of code 250 and a full :rfc:`822` address (including "
"human name) if the user address is valid. Otherwise returns an SMTP error "
"code of 400 or greater and an error string."
msgstr ""
"使用 SMTP ``VRFY`` 检查此服务器上的某个地址是否有效。 如果用户地址有效则返回一个由代码 250 和完整 :rfc:`822` "
"地址（包括人名）组成的元组。 否则返回 400 或更大的 SMTP 错误代码以及一个错误字符串。"

#: ../../library/smtplib.rst:307
msgid "Many sites disable SMTP ``VRFY`` in order to foil spammers."
msgstr "许多网站都禁用 SMTP ``VRFY`` 以阻止垃圾邮件。"

#: ../../library/smtplib.rst:312
msgid ""
"Log in on an SMTP server that requires authentication. The arguments are the"
" username and the password to authenticate with. If there has been no "
"previous ``EHLO`` or ``HELO`` command this session, this method tries ESMTP "
"``EHLO`` first. This method will return normally if the authentication was "
"successful, or may raise the following exceptions:"
msgstr ""
"登录到一个需要认证的 SMTP 服务器。 参数是用于认证的用户名和密码。 如果会话在之前没有执行过 ``EHLO`` 或 ``HELO`` "
"命令，此方法会先尝试 ESMTP ``EHLO``。 如果认证成功则此方法将正常返回，否则可能引发以下异常:"

#: ../../library/smtplib.rst:321
msgid ":exc:`SMTPAuthenticationError`"
msgstr ":exc:`SMTPAuthenticationError`"

#: ../../library/smtplib.rst:322
msgid "The server didn't accept the username/password combination."
msgstr "服务器不接受所提供的用户名/密码组合。"

#: ../../library/smtplib.rst:324 ../../library/smtplib.rst:409
#: ../../library/smtplib.rst:485
msgid ":exc:`SMTPNotSupportedError`"
msgstr ":exc:`SMTPNotSupportedError`"

#: ../../library/smtplib.rst:325
msgid "The ``AUTH`` command is not supported by the server."
msgstr "服务器不支持 ``AUTH`` 命令。"

#: ../../library/smtplib.rst:327
msgid ":exc:`SMTPException`"
msgstr ":exc:`SMTPException`"

#: ../../library/smtplib.rst:328
msgid "No suitable authentication method was found."
msgstr "未找到适当的认证方法。"

#: ../../library/smtplib.rst:330
msgid ""
"Each of the authentication methods supported by :mod:`smtplib` are tried in "
"turn if they are advertised as supported by the server.  See :meth:`auth` "
"for a list of supported authentication methods.  *initial_response_ok* is "
"passed through to :meth:`auth`."
msgstr ""
":mod:`smtplib` 所支持的每种认证方法只要被服务器声明支持就会被依次尝试。 请参阅 :meth:`auth` 获取受支持的认证方法列表。 "
"*initial_response_ok* 会被传递给 :meth:`auth`。"

#: ../../library/smtplib.rst:335
msgid ""
"Optional keyword argument *initial_response_ok* specifies whether, for "
"authentication methods that support it, an \"initial response\" as specified"
" in :rfc:`4954` can be sent along with the ``AUTH`` command, rather than "
"requiring a challenge/response."
msgstr ""
"可选的关键字参数 *initial_response_ok* 对于支持它的认证方法，是否可以与 ``AUTH`` 命令一起发送 :rfc:`4954` "
"中所规定的“初始响应”，而不是要求回复/响应。"

#: ../../library/smtplib.rst:340
msgid ""
":exc:`SMTPNotSupportedError` may be raised, and the *initial_response_ok* "
"parameter was added."
msgstr "可能会引发 :exc:`SMTPNotSupportedError`，并添加 *initial_response_ok* 形参。"

#: ../../library/smtplib.rst:347
msgid ""
"Issue an ``SMTP`` ``AUTH`` command for the specified authentication "
"*mechanism*, and handle the challenge response via *authobject*."
msgstr "为指定的认证机制 *mechanism* 发送 ``SMTP`` ``AUTH`` 命令，并通过 *authobject* 处理回复响应。"

#: ../../library/smtplib.rst:350
msgid ""
"*mechanism* specifies which authentication mechanism is to be used as "
"argument to the ``AUTH`` command; the valid values are those listed in the "
"``auth`` element of :attr:`esmtp_features`."
msgstr ""
"*mechanism* 指定要使用何种认证机制作为 ``AUTH`` 命令的参数；可用的值是在 :attr:`esmtp_features` 的 "
"``auth`` 元素中列出的内容。"

#: ../../library/smtplib.rst:354
msgid ""
"*authobject* must be a callable object taking an optional single argument::"
msgstr "*authobject* 必须为接受一个可选的单独参数的可调用对象::"

#: ../../library/smtplib.rst:356
msgid "data = authobject(challenge=None)"
msgstr "data = authobject(challenge=None)"

#: ../../library/smtplib.rst:358
msgid ""
"If optional keyword argument *initial_response_ok* is true, ``authobject()``"
" will be called first with no argument.  It can return the :rfc:`4954` "
"\"initial response\" ASCII ``str`` which will be encoded and sent with the "
"``AUTH`` command as below.  If the ``authobject()`` does not support an "
"initial response (e.g. because it requires a challenge), it should return "
"``None`` when called with ``challenge=None``.  If *initial_response_ok* is "
"false, then ``authobject()`` will not be called first with ``None``."
msgstr ""
"如果可选的关键字参数 *initial_response_ok* 为真值，则将先不带参数地调用 ``authobject()``。 它可以返回 "
":rfc:`4954` \"初始响应\" ASCII ``str``，其内容将被编码并使用下述的 ``AUTH`` 命令来发送。 如果 "
"``authobject()`` 不支持初始响应（例如由于要求一个回复），它应当将 ``None`` 作为附带 ``challenge=None`` "
"调用的返回值。 如果 *initial_response_ok* 为假值，则 ``authobject()`` 将不会附带 ``None`` "
"被首先调用。"

#: ../../library/smtplib.rst:366
msgid ""
"If the initial response check returns ``None``, or if *initial_response_ok* "
"is false, ``authobject()`` will be called to process the server's challenge "
"response; the *challenge* argument it is passed will be a ``bytes``.  It "
"should return ASCII ``str`` *data* that will be base64 encoded and sent to "
"the server."
msgstr ""
"如果初始响应检测返回了 ``None``，或者如果 *initial_response_ok* 为假值，则将调用 ``authobject()`` "
"来处理服务器的回复响应；它所传递的 *challenge* 参数将为一个 ``bytes``。 它应当返回用 base64 进行编码的 ASCII "
"``str`` *data* 并发送给服务器。"

#: ../../library/smtplib.rst:372
msgid ""
"The ``SMTP`` class provides ``authobjects`` for the ``CRAM-MD5``, ``PLAIN``,"
" and ``LOGIN`` mechanisms; they are named ``SMTP.auth_cram_md5``, "
"``SMTP.auth_plain``, and ``SMTP.auth_login`` respectively.  They all require"
" that the ``user`` and ``password`` properties of the ``SMTP`` instance are "
"set to appropriate values."
msgstr ""
"``SMTP`` 类提供的 ``authobjects`` 针对 ``CRAM-MD5``, ``PLAIN`` 和 ``LOGIN`` "
"等机制；它们的名称分别是 ``SMTP.auth_cram_md5``, ``SMTP.auth_plain`` 和 "
"``SMTP.auth_login``。 它们都要求将 ``user`` 和 ``password`` 这两个 ``SMTP`` 实例属性设为适当的值。"

#: ../../library/smtplib.rst:378
msgid ""
"User code does not normally need to call ``auth`` directly, but can instead "
"call the :meth:`login` method, which will try each of the above mechanisms "
"in turn, in the order listed.  ``auth`` is exposed to facilitate the "
"implementation of authentication methods not (or not yet) supported directly"
" by :mod:`smtplib`."
msgstr ""
"用户代码通常不需要直接调用 ``auth``，而是调用 :meth:`login` 方法，它将按上述顺序依次尝试上述每一种机制。 ``auth`` "
"被公开以便辅助实现 :mod:`smtplib` 没有（或尚未）直接支持的认证方法。"

#: ../../library/smtplib.rst:389
msgid ""
"Put the SMTP connection in TLS (Transport Layer Security) mode.  All SMTP "
"commands that follow will be encrypted.  You should then call :meth:`ehlo` "
"again."
msgstr ""
"将 SMTP 连接设为 TLS (传输层安全) 模式。 后续的所有 SMTP 命令都将被加密。 你应当随即再次调用 :meth:`ehlo`。"

#: ../../library/smtplib.rst:393
msgid ""
"If *keyfile* and *certfile* are provided, they are used to create an "
":class:`ssl.SSLContext`."
msgstr "如果提供了 *keyfile* 和 *certfile*，它们会被用来创建 :class:`ssl.SSLContext`。"

#: ../../library/smtplib.rst:396
msgid ""
"Optional *context* parameter is an :class:`ssl.SSLContext` object; This is "
"an alternative to using a keyfile and a certfile and if specified both "
"*keyfile* and *certfile* should be ``None``."
msgstr ""
"可选的 *context* 形参是一个 :class:`ssl.SSLContext` 对象；它是使用密钥文件和证书的替代方式，如果指定了该形参则 "
"*keyfile* 和 *certfile* 都应为 ``None``。"

#: ../../library/smtplib.rst:400
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first."
msgstr "如果这个会话中没有先前的 ``EHLO`` or ``HELO`` 命令，该方法会首先尝试 ESMTP ``EHLO``。"

#: ../../library/smtplib.rst:410
msgid "The server does not support the STARTTLS extension."
msgstr "服务器不支持 STARTTLS 扩展。"

#: ../../library/smtplib.rst:412
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../library/smtplib.rst:413
msgid "SSL/TLS support is not available to your Python interpreter."
msgstr "SSL/TLS 支持在你的 Python 解释器上不可用。"

#: ../../library/smtplib.rst:418
msgid ""
"The method now supports hostname check with "
":attr:`SSLContext.check_hostname` and *Server Name Indicator* (see "
":const:`~ssl.HAS_SNI`)."
msgstr ""
"此方法现在支持使用 :attr:`SSLContext.check_hostname` 和 *服务器名称指示符* (参见 "
":const:`~ssl.HAS_SNI`) 进行主机名检测。"

#: ../../library/smtplib.rst:423
msgid ""
"The error raised for lack of STARTTLS support is now the "
":exc:`SMTPNotSupportedError` subclass instead of the base "
":exc:`SMTPException`."
msgstr ""
"因缺少 STARTTLS 支持而引发的错误现在是 :exc:`SMTPNotSupportedError` 子类而不是 "
":exc:`SMTPException` 基类。"

#: ../../library/smtplib.rst:431
msgid ""
"Send mail.  The required arguments are an :rfc:`822` from-address string, a "
"list of :rfc:`822` to-address strings (a bare string will be treated as a "
"list with 1 address), and a message string.  The caller may pass a list of "
"ESMTP options (such as ``8bitmime``) to be used in ``MAIL FROM`` commands as"
" *mail_options*. ESMTP options (such as ``DSN`` commands) that should be "
"used with all ``RCPT`` commands can be passed as *rcpt_options*.  (If you "
"need to use different ESMTP options to different recipients you have to use "
"the low-level methods such as :meth:`mail`, :meth:`rcpt` and :meth:`data` to"
" send the message.)"
msgstr ""
"发送邮件。必要参数是一个 :rfc:`822` 发件地址字符串，一个 :rfc:`822` 收件地址字符串列表（裸字符串将被视为含有 1 "
"个地址的列表），以及一个消息字符串。调用者可以将 ESMTP 选项列表（如 ``8bitmime``）作为 *mail_options* 传入，用于 "
"``MAIL FROM`` 命令。需要与所有 ``RCPT`` 命令一起使用的 ESMTP 选项（如 ``DSN`` 命令）可以作为 "
"*rcpt_options* 传入。（如果需要对不同的收件人使用不同的 ESMTP 选项，则必须使用底层的方法来发送消息，如 :meth:`mail`,"
" :meth:`rcpt` 和 :meth:`data`。）"

#: ../../library/smtplib.rst:442
msgid ""
"The *from_addr* and *to_addrs* parameters are used to construct the message "
"envelope used by the transport agents.  ``sendmail`` does not modify the "
"message headers in any way."
msgstr ""
"*from_addr* 和 *to_addrs* 形参被用来构造传输代理所使用的消息封包。 ``sendmail`` 不会以任何方式修改消息标头。"

#: ../../library/smtplib.rst:446
msgid ""
"*msg* may be a string containing characters in the ASCII range, or a byte "
"string.  A string is encoded to bytes using the ascii codec, and lone "
"``\\r`` and ``\\n`` characters are converted to ``\\r\\n`` characters.  A "
"byte string is not modified."
msgstr ""
"*msg* 可以是一个包含 ASCII 范围内字符的字符串，或是一个字节串。 字符串会使用 ascii 编解码器编码为字节串，并且单独的 ``\\r``"
" 和 ``\\n`` 字符会被转换为 ``\\r\\n`` 字符序列。 字节串则不会被修改。"

#: ../../library/smtplib.rst:451
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first. If the server does ESMTP, message "
"size and each of the specified options will be passed to it (if the option "
"is in the feature set the server advertises).  If ``EHLO`` fails, ``HELO`` "
"will be tried and ESMTP options suppressed."
msgstr ""
"如果在此之前本会话没有执行过 ``EHLO`` 或 ``HELO`` 命令，此方法会先尝试 ESMTP ``EHLO``。 如果服务器执行了 "
"ESMTP，消息大小和每个指定的选项将被传递给它（如果指定的选项属于服务器声明的特性集）。 如果 ``EHLO`` 失败，则将尝试 ``HELO`` "
"并屏蔽 ESMTP 选项。"

#: ../../library/smtplib.rst:457
msgid ""
"This method will return normally if the mail is accepted for at least one "
"recipient. Otherwise it will raise an exception.  That is, if this method "
"does not raise an exception, then someone should get your mail. If this "
"method does not raise an exception, it returns a dictionary, with one entry "
"for each recipient that was refused.  Each entry contains a tuple of the "
"SMTP error code and the accompanying error message sent by the server."
msgstr ""
"如果邮件被至少一个接收方接受则此方法将正常返回。 在其他情况下它将引发异常。 也就是说，如果此方法没有引发异常，则应当会有人收到你的邮件。 "
"如果此方法没有引发异常，它将返回一个字典，其中的条目对应每个拒绝的接收方。 每个条目均包含由服务器发送的 SMTP 错误代码和相应错误消息所组成的元组。"

#: ../../library/smtplib.rst:464
msgid ""
"If ``SMTPUTF8`` is included in *mail_options*, and the server supports it, "
"*from_addr* and *to_addrs* may contain non-ASCII characters."
msgstr ""
"如果 ``SMTPUTF8`` 包括在 *mail_options* 中，并且被服务器所支持，则 *from_addr* 和 *to_addrs* "
"可能包含非 ASCII 字符。"

#: ../../library/smtplib.rst:467
msgid "This method may raise the following exceptions:"
msgstr "此方法可能引发以下异常:"

#: ../../library/smtplib.rst:469
msgid ":exc:`SMTPRecipientsRefused`"
msgstr ":exc:`SMTPRecipientsRefused`"

#: ../../library/smtplib.rst:470
msgid ""
"All recipients were refused.  Nobody got the mail.  The :attr:`recipients` "
"attribute of the exception object is a dictionary with information about the"
" refused recipients (like the one returned when at least one recipient was "
"accepted)."
msgstr ""
"所有收件人都被拒绝。 无人收到邮件。 该异常的 :attr:`recipients` "
"属性是一个字典，其中有被拒绝收件人的信息（类似于至少有一个收件人接受邮件时所返回的信息）。"

#: ../../library/smtplib.rst:478
msgid ":exc:`SMTPSenderRefused`"
msgstr ":exc:`SMTPSenderRefused`"

#: ../../library/smtplib.rst:479
msgid "The server didn't accept the *from_addr*."
msgstr "服务器不接受 *from_addr*。"

#: ../../library/smtplib.rst:481
msgid ":exc:`SMTPDataError`"
msgstr ":exc:`SMTPDataError`"

#: ../../library/smtplib.rst:482
msgid ""
"The server replied with an unexpected error code (other than a refusal of a "
"recipient)."
msgstr "服务器回复了一个意外的错误代码（而不是拒绝收件人）。"

#: ../../library/smtplib.rst:486
msgid ""
"``SMTPUTF8`` was given in the *mail_options* but is not supported by the "
"server."
msgstr "在 *mail_options* 中给出了 ``SMTPUTF8`` 但是不被服务器所支持。"

#: ../../library/smtplib.rst:489
msgid ""
"Unless otherwise noted, the connection will be open even after an exception "
"is raised."
msgstr "除非另有说明，即使在引发异常之后连接仍将被打开。"

#: ../../library/smtplib.rst:492
msgid "*msg* may be a byte string."
msgstr "*msg* 可以为字节串。"

#: ../../library/smtplib.rst:495
msgid ""
"``SMTPUTF8`` support added, and :exc:`SMTPNotSupportedError` may be raised "
"if ``SMTPUTF8`` is specified but the server does not support it."
msgstr ""
"增加了 ``SMTPUTF8`` 支持，并且如果指定了 ``SMTPUTF8`` 但是不被服务器所支持则可能会引发 "
":exc:`SMTPNotSupportedError`。"

#: ../../library/smtplib.rst:503
msgid ""
"This is a convenience method for calling :meth:`sendmail` with the message "
"represented by an :class:`email.message.Message` object.  The arguments have"
" the same meaning as for :meth:`sendmail`, except that *msg* is a "
"``Message`` object."
msgstr ""
"本方法是一种快捷方法，用于带着消息调用 :meth:`sendmail`，消息由 :class:`email.message.Message` "
"对象表示。参数的含义与 :meth:`sendmail` 中的相同，除了 *msg*，它是一个 ``Message`` 对象。"

#: ../../library/smtplib.rst:508
msgid ""
"If *from_addr* is ``None`` or *to_addrs* is ``None``, ``send_message`` fills"
" those arguments with addresses extracted from the headers of *msg* as "
"specified in :rfc:`5322`\\: *from_addr* is set to the :mailheader:`Sender` "
"field if it is present, and otherwise to the :mailheader:`From` field. "
"*to_addrs* combines the values (if any) of the :mailheader:`To`, "
":mailheader:`Cc`, and :mailheader:`Bcc` fields from *msg*.  If exactly one "
"set of :mailheader:`Resent-*` headers appear in the message, the regular "
"headers are ignored and the :mailheader:`Resent-*` headers are used instead."
" If the message contains more than one set of :mailheader:`Resent-*` "
"headers, a :exc:`ValueError` is raised, since there is no way to "
"unambiguously detect the most recent set of :mailheader:`Resent-` headers."
msgstr ""
"如果 *from_addr* 为 ``None`` 或 *to_addrs* 为 ``None`` ，那么 ``send_message`` 将根据 "
":rfc:`5322`，从 *msg* 头部提取地址填充下列参数：如果头部存在 :mailheader:`Sender` 字段，则用它填充 "
"*from_addr*，不存在则用 :mailheader:`From` 字段填充 *from_addr*。*to_addrs* 组合了 *msg* "
"中的 :mailheader:`To`, :mailheader:`Cc` 和 :mailheader:`Bcc` "
"字段的值（字段存在的情况下）。如果一组 :mailheader:`Resent-*` 头部恰好出现在 message 中，那么就忽略常规的头部，改用 "
":mailheader:`Resent-*` 头部。如果 message 包含多组 :mailheader:`Resent-*` 头部，则引发 "
":exc:`ValueError`，因为无法明确检测出哪一组 :mailheader:`Resent-` 头部是最新的。"

#: ../../library/smtplib.rst:520
msgid ""
"``send_message`` serializes *msg* using "
":class:`~email.generator.BytesGenerator` with ``\\r\\n`` as the *linesep*, "
"and calls :meth:`sendmail` to transmit the resulting message.  Regardless of"
" the values of *from_addr* and *to_addrs*, ``send_message`` does not "
"transmit any :mailheader:`Bcc` or :mailheader:`Resent-Bcc` headers that may "
"appear in *msg*.  If any of the addresses in *from_addr* and *to_addrs* "
"contain non-ASCII characters and the server does not advertise ``SMTPUTF8`` "
"support, an :exc:`SMTPNotSupported` error is raised.  Otherwise the "
"``Message`` is serialized with a clone of its :mod:`~email.policy` with the "
":attr:`~email.policy.EmailPolicy.utf8` attribute set to ``True``, and "
"``SMTPUTF8`` and ``BODY=8BITMIME`` are added to *mail_options*."
msgstr ""
"``send_message`` 使用 :class:`~email.generator.BytesGenerator` 来序列化 *msg*，且将 "
"``\\r\\n`` 作为 *linesep*，并调用 :meth:`sendmail` 来传输序列化后的结果。无论 *from_addr* 和 "
"*to_addrs* 的值为何，``send_message`` 都不会传输 *msg* 中可能出现的 :mailheader:`Bcc` 或 "
":mailheader:`Resent-Bcc` 头部。如果 *from_addr* 和 *to_addrs* 中的某个地址包含非 ASCII "
"字符，且服务器没有声明支持 ``SMTPUTF8``，则引发 :exc:`SMTPNotSupported` 错误。如果服务器支持，则 "
"``Message`` 将按新克隆的 :mod:`~email.policy` 进行序列化，其中的 "
":attr:`~email.policy.EmailPolicy.utf8` 属性被设置为 ``True``，且 ``SMTPUTF8`` 和 "
"``BODY=8BITMIME`` 被添加到 *mail_options* 中。"

#: ../../library/smtplib.rst:534
msgid "Support for internationalized addresses (``SMTPUTF8``)."
msgstr "支持国际化地址 (``SMTPUTF8``)。"

#: ../../library/smtplib.rst:540
msgid ""
"Terminate the SMTP session and close the connection.  Return the result of "
"the SMTP ``QUIT`` command."
msgstr "终结 SMTP 会话并关闭连接。 返回 SMTP ``QUIT`` 命令的结果。"

#: ../../library/smtplib.rst:544
msgid ""
"Low-level methods corresponding to the standard SMTP/ESMTP commands "
"``HELP``, ``RSET``, ``NOOP``, ``MAIL``, ``RCPT``, and ``DATA`` are also "
"supported. Normally these do not need to be called directly, so they are not"
" documented here.  For details, consult the module code."
msgstr ""
"与标准 SMTP/ESMTP 命令 ``HELP``, ``RSET``, ``NOOP``, ``MAIL``, ``RCPT`` 和 "
"``DATA`` 对应的低层级方法也是受支持的。 通常不需要直接调用这些方法，因此它们没有被写入本文档。 相关细节请参看模块代码。"

#: ../../library/smtplib.rst:553
msgid "SMTP Example"
msgstr "SMTP 示例"

#: ../../library/smtplib.rst:555
msgid ""
"This example prompts the user for addresses needed in the message envelope "
"('To' and 'From' addresses), and the message to be delivered.  Note that the"
" headers to be included with the message must be included in the message as "
"entered; this example doesn't do any processing of the :rfc:`822` headers.  "
"In particular, the 'To' and 'From' addresses must be included in the message"
" headers explicitly::"
msgstr ""
"这个例子提示用户输入消息封包所需的地址 ('To' 和 'From' 地址)，以及要发送的消息。 "
"请注意包括在消息中的标头必须包括在输入的消息中；这个例子不对 :rfc:`822` 标头进行任何处理。 具体来说，'To' 和 'From' "
"地址必须显式地包括在消息标头中::"

#: ../../library/smtplib.rst:561
msgid ""
"import smtplib\n"
"\n"
"def prompt(title):\n"
"    return input(title).strip()\n"
"\n"
"from_addr = prompt(\"From: \")\n"
"to_addrs  = prompt(\"To: \").split()\n"
"print(\"Enter message, end with ^D (Unix) or ^Z (Windows):\")\n"
"\n"
"# Add the From: and To: headers at the start!\n"
"lines = [f\"From: {from_addr}\", f\"To: {', '.join(to_addrs)}\", \"\"]\n"
"while True:\n"
"    try:\n"
"        line = input()\n"
"    except EOFError:\n"
"        break\n"
"    else:\n"
"        lines.append(line)\n"
"\n"
"msg = \"\\r\\n\".join(lines)\n"
"print(\"Message length is\", len(msg))\n"
"\n"
"server = smtplib.SMTP(\"localhost\")\n"
"server.set_debuglevel(1)\n"
"server.sendmail(from_addr, to_addrs, msg)\n"
"server.quit()"
msgstr ""

#: ../../library/smtplib.rst:590
msgid ""
"In general, you will want to use the :mod:`email` package's features to "
"construct an email message, which you can then send via "
":meth:`~smtplib.SMTP.send_message`; see :ref:`email-examples`."
msgstr ""
"通常，你将需要使用 :mod:`email` 包的特性来构造电子邮件消息，然后你可以通过 "
":meth:`~smtplib.SMTP.send_message` 来发送它，参见 :ref:`email-examples`。"

#: ../../library/smtplib.rst:11
msgid "SMTP"
msgstr "SMTP"

#: ../../library/smtplib.rst:11
msgid "protocol"
msgstr "协议"

#: ../../library/smtplib.rst:11
msgid "Simple Mail Transfer Protocol"
msgstr "简单邮件传输协议"
