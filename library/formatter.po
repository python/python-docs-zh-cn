# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 君 码侬 <einsxiao@stu.xjtu.edu.cn>, 2020
# 稀饭~~ <wangwhai@qq.com>, 2022
# Bryan不可思议, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-04-15 08:14+0000\n"
"PO-Revision-Date: 2020-05-30 12:02+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/formatter.rst:2
msgid ":mod:`formatter` --- Generic output formatting"
msgstr ":mod:`formatter` --- 通用格式化输出"

#: ../../library/formatter.rst:8
msgid "Due to lack of usage, the formatter module has been deprecated."
msgstr "因为被使用的次数很少，此格式化模块已经被弃用了。"

#: ../../library/formatter.rst:13
msgid ""
"This module supports two interface definitions, each with multiple "
"implementations: The *formatter* interface, and the *writer* interface which"
" is required by the formatter interface."
msgstr "此模块支持两个接口定义，每个定义具有多个实现：*formatter* 接口和格式化程序接口所需的 *writer* 接口。"

#: ../../library/formatter.rst:17
msgid ""
"Formatter objects transform an abstract flow of formatting events into "
"specific output events on writer objects.  Formatters manage several stack "
"structures to allow various properties of a writer object to be changed and "
"restored; writers need not be able to handle relative changes nor any sort "
"of \"change back\" operation.  Specific writer properties which may be "
"controlled via formatter objects are horizontal alignment, font, and left "
"margin indentations.  A mechanism is provided which supports providing "
"arbitrary, non-exclusive style settings to a writer as well.  Additional "
"interfaces facilitate formatting events which are not reversible, such as "
"paragraph separation."
msgstr ""
"格式化程序对象将格式化事件的抽象流转换为编写器对象上的特定输出事件。 "
"格式化程序管理多个堆栈结构，以允许更改和还原编写器对象的各种属性;编写器不需要能够处理相对更改或任何类型的“更改回来”操作。 "
"可通过格式化程序对象控制的特定编写器属性包括水平对齐方式、字体和左边距缩进。 提供了一种机制，该机制还支持向编写器提供任意的非独占样式设置。 "
"其他接口有助于格式化不可逆的事件，例如段落分隔。"

#: ../../library/formatter.rst:27
msgid ""
"Writer objects encapsulate device interfaces.  Abstract devices, such as "
"file formats, are supported as well as physical devices.  The provided "
"implementations all work with abstract devices.  The interface makes "
"available mechanisms for setting the properties which formatter objects "
"manage and inserting data into the output."
msgstr ""
"编写器对象封装设备接口。 支持抽象设备（如文件格式）以及物理设备。 提供的实现都适用于抽象设备。 "
"该接口提供了用于设置格式化程序对象管理的属性以及将数据插入输出的机制。"

#: ../../library/formatter.rst:37
msgid "The Formatter Interface"
msgstr "格式化程序接口"

#: ../../library/formatter.rst:39
msgid ""
"Interfaces to create formatters are dependent on the specific formatter "
"class being instantiated.  The interfaces described below are the required "
"interfaces which all formatters must support once initialized."
msgstr "用于创建格式化程序的接口取决于要实例化的特定格式化程序类。 下面描述的接口是所有格式化程序在初始化后必须支持的必需接口。"

#: ../../library/formatter.rst:43
msgid "One data element is defined at the module level:"
msgstr "在模块级别定义一个数据元素："

#: ../../library/formatter.rst:48
msgid ""
"Value which can be used in the font specification passed to the "
"``push_font()`` method described below, or as the new value to any other "
"``push_property()`` method.  Pushing the ``AS_IS`` value allows the "
"corresponding ``pop_property()`` method to be called without having to track"
" whether the property was changed."
msgstr ""
"可以在传递给下面描述的``push_font()`` 方法的字体规范中使用的值，或作为任何其他 ``push_property()``方法的新值使用。 "
"推送 ``AS_IS`` 值允许调用相应的``pop_property()`` 方法，而无需跟踪属性是否已更改。"

#: ../../library/formatter.rst:53
msgid "The following attributes are defined for formatter instance objects:"
msgstr "为格式化程序实例对象定义了以下属性："

#: ../../library/formatter.rst:58
msgid "The writer instance with which the formatter interacts."
msgstr "格式化程序与之交互的编写器实例。"

#: ../../library/formatter.rst:63
msgid ""
"Close any open paragraphs and insert at least *blanklines* before the next "
"paragraph."
msgstr "关闭所有打开的段落，并在下一段之前至少插入*blanklines* （空白行 ）。"

#: ../../library/formatter.rst:69
msgid ""
"Add a hard line break if one does not already exist.  This does not break "
"the logical paragraph."
msgstr "如果尚不存在硬换行符，请添加硬换行符。 这不会破坏逻辑段落。"

#: ../../library/formatter.rst:75
msgid ""
"Insert a horizontal rule in the output.  A hard break is inserted if there "
"is data in the current paragraph, but the logical paragraph is not broken.  "
"The arguments and keywords are passed on to the writer's "
":meth:`send_line_break` method."
msgstr ""
"在输出中插入水平线。 如果当前段落中有数据，但逻辑段落未中断，则插入硬中断。 参数和关键字被传递给作者的 :meth:`send_line_break`"
" 方法。"

#: ../../library/formatter.rst:83
msgid ""
"Provide data which should be formatted with collapsed whitespace. Whitespace"
" from preceding and successive calls to :meth:`add_flowing_data` is "
"considered as well when the whitespace collapse is performed.  The data "
"which is passed to this method is expected to be word-wrapped by the output "
"device.  Note that any word-wrapping still must be performed by the writer "
"object due to the need to rely on device and font information."
msgstr ""
"提供应使用折叠空格设置格式的数据。在执行空格折叠时，也会考虑之前和连续调用 :meth:`add_flowing_data` 的空格。 "
"传递给此方法的数据应由输出设备进行自动换行。 请注意，由于需要依赖设备和字体信息，任何自动换行仍必须由编写器对象执行。"

#: ../../library/formatter.rst:93
msgid ""
"Provide data which should be passed to the writer unchanged. Whitespace, "
"including newline and tab characters, are considered legal in the value of "
"*data*."
msgstr "提供应原封不动地传递给编写器的数据。空格（包括换行符和制表符）在 *data* 的值中被认为是合法的。"

#: ../../library/formatter.rst:100
msgid ""
"Insert a label which should be placed to the left of the current left "
"margin. This should be used for constructing bulleted or numbered lists.  If"
" the *format* value is a string, it is interpreted as a format specification"
" for *counter*, which should be an integer. The result of this formatting "
"becomes the value of the label; if *format* is not a string it is used as "
"the label value directly. The label value is passed as the only argument to "
"the writer's :meth:`send_label_data` method.  Interpretation of non-string "
"label values is dependent on the associated writer."
msgstr ""
"插入一个标签，该标签应放置在当前左边距的左侧。这应该用于构造项目符号列表或编号列表。 如果 *format* 值是字符串，则将其解释为 "
"*counter* 的格式规范，该规范应为整数。此格式设置的结果将成为标签的值;如果 *format* "
"不是字符串，则直接用作标签值。标签值作为唯一的参数传递给编写器的 :meth:`send_label_data` 方法。 "
"非字符串标签值的解释取决于关联的编写器。"

#: ../../library/formatter.rst:109
msgid ""
"Format specifications are strings which, in combination with a counter "
"value, are used to compute label values.  Each character in the format "
"string is copied to the label value, with some characters recognized to "
"indicate a transform on the counter value.  Specifically, the character "
"``'1'`` represents the counter value formatter as an Arabic number, the "
"characters ``'A'`` and ``'a'`` represent alphabetic representations of the "
"counter value in upper and lower case, respectively, and ``'I'`` and ``'i'``"
" represent the counter value in Roman numerals, in upper and lower case.  "
"Note that the alphabetic and roman transforms require that the counter value"
" be greater than zero."
msgstr ""
"格式规范是字符串，与计数器值结合使用，用于计算标签值。 格式字符串中的每个字符都将复制到标签值，并识别某些字符以指示计数器值上的转换。 "
"具体来说，字符``'1'`` "
"表示计数器值格式化程序为阿拉伯数字，字符``'A'``和``'a'``分别表示计数器值的字母表示形式，大写和小写，``'I'`` 和``'i'`` "
"表示罗马数字中的计数器值，大写和小写。 请注意，字母和罗马变换要求计数器值大于零。"

#: ../../library/formatter.rst:122
msgid ""
"Send any pending whitespace buffered from a previous call to "
":meth:`add_flowing_data` to the associated writer object.  This should be "
"called before any direct manipulation of the writer object."
msgstr ""
"将从上一次调用 :meth:`add_flowing_data` 缓冲的任何挂起空格发送到关联的编写器对象。 这应该在直接操作编写器对象之前调用。"

#: ../../library/formatter.rst:129
msgid ""
"Push a new alignment setting onto the alignment stack.  This may be "
":const:`AS_IS` if no change is desired.  If the alignment value is changed "
"from the previous setting, the writer's :meth:`new_alignment` method is "
"called with the *align* value."
msgstr ""
"将新的对齐设置推送到对齐堆栈上。 如果不需要更改，这可能是 :const:`AS_IS` 。 如果对齐值与以前的设置相比发生了更改，则使用 "
"*align* 值调用编写器的 :meth:`new_alignment` 方法。"

#: ../../library/formatter.rst:137
msgid "Restore the previous alignment."
msgstr "恢复以前的对齐方式。"

#: ../../library/formatter.rst:142
msgid ""
"Change some or all font properties of the writer object.  Properties which "
"are not set to :const:`AS_IS` are set to the values passed in while others "
"are maintained at their current settings.  The writer's :meth:`new_font` "
"method is called with the fully resolved font specification."
msgstr ""
"更改编写器对象的部分或全部字体属性。未设置为 :const:`AS_IS` 的属性设置为传入的值，而其他属性则保持其当前设置。编写器的 "
":meth:`new_font` 方法是使用完全解析的字体规范调用的。"

#: ../../library/formatter.rst:150
msgid "Restore the previous font."
msgstr "恢复以前的字体。"

#: ../../library/formatter.rst:155
msgid ""
"Increase the number of left margin indentations by one, associating the "
"logical tag *margin* with the new indentation.  The initial margin level is "
"``0``. Changed values of the logical tag must be true values; false values "
"other than :const:`AS_IS` are not sufficient to change the margin."
msgstr ""
"将左边距缩进数增加 1，将逻辑标记 *margin* 与新缩进相关联。 初始保证金水平为 ``0``。逻辑标记的更改值必须是真值;除 "
":const:`AS_IS` 以外的 false 值不足以更改边距。"

#: ../../library/formatter.rst:163
msgid "Restore the previous margin."
msgstr "恢复以前的边距。"

#: ../../library/formatter.rst:168
msgid ""
"Push any number of arbitrary style specifications.  All styles are pushed "
"onto the styles stack in order.  A tuple representing the entire stack, "
"including :const:`AS_IS` values, is passed to the writer's "
":meth:`new_styles` method."
msgstr ""
"推送任意数量的任意样式规范。 所有样式都按顺序推送到样式堆栈上。 表示整个堆栈的元组（包括 :const:`AS_IS` 值）将传递给编写器的 "
":meth:`new_styles` 方法。"

#: ../../library/formatter.rst:175
msgid ""
"Pop the last *n* style specifications passed to :meth:`push_style`.  A tuple"
" representing the revised stack, including :const:`AS_IS` values, is passed "
"to the writer's :meth:`new_styles` method."
msgstr ""
"弹出传递给 :meth:`push_style` 的最后一个 *n* 样式规范。 表示修订后的堆栈的元组（包括 :const:`AS_IS` "
"值）将传递给编写器的 :meth:`new_styles` 方法。"

#: ../../library/formatter.rst:182
msgid "Set the spacing style for the writer."
msgstr "设置编写器的间距样式。"

#: ../../library/formatter.rst:187
msgid ""
"Inform the formatter that data has been added to the current paragraph out-"
"of-band.  This should be used when the writer has been manipulated directly."
"  The optional *flag* argument can be set to false if the writer "
"manipulations produced a hard line break at the end of the output."
msgstr ""
"通知格式化程序数据已添加到带外当前段落。 当编写器被直接操作时，应使用此方法。 如果编写器操作在输出末尾生成了硬换行符，则可以将可选的 *flag* "
"参数设置为 false。"

#: ../../library/formatter.rst:196
msgid "Formatter Implementations"
msgstr "实现格式化程序"

#: ../../library/formatter.rst:198
msgid ""
"Two implementations of formatter objects are provided by this module. Most "
"applications may use one of these classes without modification or "
"subclassing."
msgstr "此模块提供了格式化程序对象的两种实现。大多数应用程序可以使用这些类之一，而无需修改或子类化。"

#: ../../library/formatter.rst:204
msgid ""
"A formatter which does nothing.  If *writer* is omitted, a "
":class:`NullWriter` instance is created.  No methods of the writer are "
"called by :class:`NullFormatter` instances.  Implementations should inherit "
"from this class if implementing a writer interface but don't need to inherit"
" any implementation."
msgstr ""
"什么都不做的格式化程序。 如果省略 *writer* ，则会创建一个 :class:`NullWriter` 实例。 编写器的任何方法都不会被 "
":class:`NullFormatter` 实例调用。 如果实现编写器接口，则实现应从此类继承，但不需要继承任何实现。"

#: ../../library/formatter.rst:213
msgid ""
"The standard formatter.  This implementation has demonstrated wide "
"applicability to many writers, and may be used directly in most "
"circumstances.  It has been used to implement a full-featured World Wide Web"
" browser."
msgstr "标准格式化程序。 此实现已证明对许多编写器具有广泛的适用性，并且在大多数情况下可以直接使用。 它已被用于实现功能齐全的万维网浏览器。"

#: ../../library/formatter.rst:221
msgid "The Writer Interface"
msgstr "编写器界面"

#: ../../library/formatter.rst:223
msgid ""
"Interfaces to create writers are dependent on the specific writer class "
"being instantiated.  The interfaces described below are the required "
"interfaces which all writers must support once initialized. Note that while "
"most applications can use the :class:`AbstractFormatter` class as a "
"formatter, the writer must typically be provided by the application."
msgstr ""
"用于创建编写器的接口取决于要实例化的特定编写器类。 下面描述的接口是所有编写器初始化后必须支持的必需接口。请注意，虽然大多数应用程序可以使用 "
":class:`AbstractFormatter` 类作为格式化程序，但编写器通常必须由应用程序提供。"

#: ../../library/formatter.rst:232
msgid "Flush any buffered output or device control events."
msgstr "刷新任何缓冲输出或设备控制事件。"

#: ../../library/formatter.rst:237
msgid ""
"Set the alignment style.  The *align* value can be any object, but by "
"convention is a string or ``None``, where ``None`` indicates that the "
"writer's \"preferred\" alignment should be used. Conventional *align* values"
" are ``'left'``, ``'center'``, ``'right'``, and ``'justify'``."
msgstr ""
"设置对齐样式。  *align* 值可以是任何对象，但按照惯例是字符串或 ``None``，其中 ``None`` "
"表示应使用编写器的“首选”对齐方式。常规的*对齐*值为 ``'left'``、 ``'center'``、``'right'`` 和 "
"``'justify'``。"

#: ../../library/formatter.rst:245
msgid ""
"Set the font style.  The value of *font* will be ``None``, indicating that "
"the device's default font should be used, or a tuple of the form ``(size, "
"italic, bold, teletype)``.  Size will be a string indicating the size of "
"font that should be used; specific strings and their interpretation must be "
"defined by the application.  The *italic*, *bold*, and *teletype* values are"
" Boolean values specifying which of those font attributes should be used."
msgstr ""
"设置字体样式。 *font* 的值将为 ``None``，表示应使用设备的默认字体或格式为 ``(size, italic, bold, "
"teletype)`` 的元组。 大小将是一个字符串，指示应使用的字体大小;特定字符串及其解释必须由应用程序定义。 *italic*、*bold* 和 "
"*teletype* 值是布尔值，指定应使用哪些字体属性。"

#: ../../library/formatter.rst:255
msgid ""
"Set the margin level to the integer *level* and the logical tag to *margin*."
" Interpretation of the logical tag is at the writer's discretion; the only "
"restriction on the value of the logical tag is that it not be a false value "
"for non-zero values of *level*."
msgstr ""
"将边距级别设置为整数 *level*，将逻辑标记设置为 *margin*。逻辑标签的解释由作者自行决定;对逻辑标记值的唯一限制是，对于 *level* "
"的非零值，它不是假值。"

#: ../../library/formatter.rst:263
msgid "Set the spacing style to *spacing*."
msgstr "将间距样式设置为  *spacing*。"

#: ../../library/formatter.rst:268
msgid ""
"Set additional styles.  The *styles* value is a tuple of arbitrary values; "
"the value :const:`AS_IS` should be ignored.  The *styles* tuple may be "
"interpreted either as a set or as a stack depending on the requirements of "
"the application and writer implementation."
msgstr ""
"设置其他样式。*styles* 值是任意值的元组;值 :const:`AS_IS` 应忽略。*styles* "
"元组可以解释为集合或堆栈，具体取决于应用程序和编写器实现的要求。"

#: ../../library/formatter.rst:276
msgid "Break the current line."
msgstr "断开当前行。"

#: ../../library/formatter.rst:281
msgid ""
"Produce a paragraph separation of at least *blankline* blank lines, or the "
"equivalent.  The *blankline* value will be an integer.  Note that the "
"implementation will receive a call to :meth:`send_line_break` before this "
"call if a line break is needed;  this method should not include ending the "
"last line of the paragraph. It is only responsible for vertical spacing "
"between paragraphs."
msgstr ""
"生成至少空白行 *blankline* 或等效行的段落分隔。*blankline* 值将是一个整数。 请注意，如果需要换行符，实现将在此调用之前收到对 "
":meth:`send_line_break` 的调用; 此方法不应包括结束段落的最后一行。它只负责段落之间的垂直间距。"

#: ../../library/formatter.rst:291
msgid ""
"Display a horizontal rule on the output device.  The arguments to this "
"method are entirely application- and writer-specific, and should be "
"interpreted with care.  The method implementation may assume that a line "
"break has already been issued via :meth:`send_line_break`."
msgstr ""
"在输出设备上显示水平线。 此方法的参数完全特定于应用程序和编写器，应谨慎解释。 该方法实现可能假定已通过 :meth:`send_line_break`"
" 发出换行符。"

#: ../../library/formatter.rst:299
msgid ""
"Output character data which may be word-wrapped and re-flowed as needed.  "
"Within any sequence of calls to this method, the writer may assume that "
"spans of multiple whitespace characters have been collapsed to single space "
"characters."
msgstr "输出字符数据，可以根据需要进行自动换行和重排。 在对此方法的任何调用序列中，编写器可能假定多个空格字符的范围已折叠为单个空格字符。"

#: ../../library/formatter.rst:306
msgid ""
"Output character data which has already been formatted for display.  "
"Generally, this should be interpreted to mean that line breaks indicated by "
"newline characters should be preserved and no new line breaks should be "
"introduced.  The data may contain embedded newline and tab characters, "
"unlike data provided to the :meth:`send_formatted_data` interface."
msgstr ""
"输出已格式化为显示的字符数据。 通常，这应解释为应保留由换行符指示的换行符，并且不应引入新的换行符。 数据可能包含嵌入的换行符和制表符，这与提供给 "
":meth:`send_formatted_data` 接口的数据不同。"

#: ../../library/formatter.rst:315
msgid ""
"Set *data* to the left of the current left margin, if possible. The value of"
" *data* is not restricted; treatment of non-string values is entirely "
"application- and writer-dependent.  This method will only be called at the "
"beginning of a line."
msgstr ""
"如果可能，将  *data* 设置为当前左边距的左侧。 *data* 的值不受限制;非字符串值的处理完全取决于应用程序和编写器。 此方法仅在行首调用。"

#: ../../library/formatter.rst:324
msgid "Writer Implementations"
msgstr "编写器实现"

#: ../../library/formatter.rst:326
msgid ""
"Three implementations of the writer object interface are provided as "
"examples by this module.  Most applications will need to derive new writer "
"classes from the :class:`NullWriter` class."
msgstr "本模块提供了编写器对象接口的三个实现作为示例。 大多数应用程序需要从 :class:`NullWriter` 类派生新的编写器类。"

#: ../../library/formatter.rst:333
msgid ""
"A writer which only provides the interface definition; no actions are taken "
"on any methods.  This should be the base class for all writers which do not "
"need to inherit any implementation methods."
msgstr "仅提供接口定义的编写器;不会对任何方法执行任何操作。 这应该是不需要继承任何实现方法的所有编写器的基类。"

#: ../../library/formatter.rst:340
msgid ""
"A writer which can be used in debugging formatters, but not much else.  Each"
" method simply announces itself by printing its name and arguments on "
"standard output."
msgstr "一个可用于调试格式化程序的编写器，但不能用于其他很多。 每个方法只是通过在标准输出上打印其名称和参数来宣布自己。"

#: ../../library/formatter.rst:347
msgid ""
"Simple writer class which writes output on the :term:`file object` passed in"
" as *file* or, if *file* is omitted, on standard output.  The output is "
"simply word-wrapped to the number of columns specified by *maxcol*.  This "
"class is suitable for reflowing a sequence of paragraphs."
msgstr ""
"简单的编写器类，它将输出写入作为  *file* 传入的 :term:`file object` ，或者，如果省略 *file* ，则写入标准输出。 "
"输出只是自动换行为 *maxcol* 指定的列数。 此类适用于重排段落序列。"
