# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.examples.rst:4
msgid ":mod:`email`: Examples"
msgstr ":mod:`email`: 示例"

#: ../../library/email.examples.rst:6
msgid ""
"Here are a few examples of how to use the :mod:`email` package to read, "
"write, and send simple email messages, as well as more complex MIME "
"messages."
msgstr "以下是一些如何使用 :mod:`email` 包来读取、写入和发送简单电子邮件以及更复杂的MIME邮件的示例。"

#: ../../library/email.examples.rst:9
msgid ""
"First, let's see how to create and send a simple text message (both the text"
" content and the addresses may contain unicode characters):"
msgstr "首先，让我们看看如何创建和发送简单的文本消息（文本内容和地址都可能包含unicode字符）："

#: ../../library/email.examples.rst:12
msgid ""
"# Import smtplib for the actual sending function\n"
"import smtplib\n"
"\n"
"# Import the email modules we'll need\n"
"from email.message import EmailMessage\n"
"\n"
"# Open the plain text file whose name is in textfile for reading.\n"
"with open(textfile) as fp:\n"
"    # Create a text/plain message\n"
"    msg = EmailMessage()\n"
"    msg.set_content(fp.read())\n"
"\n"
"# me == the sender's email address\n"
"# you == the recipient's email address\n"
"msg['Subject'] = f'The contents of {textfile}'\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# Send the message via our own SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"
msgstr ""
"# 导入 smtplib 以使用实际的发送函数\n"
"import smtplib\n"
"\n"
"# 导入我们需要的 email 模块\n"
"from email.message import EmailMessage\n"
"\n"
"# 打开 textfile 中相应名称的纯文本文件供读取。\n"
"with open(textfile) as fp:\n"
"    # 创建纯文本消息\n"
"    msg = EmailMessage()\n"
"    msg.set_content(fp.read())\n"
"\n"
"# me == 发送方 email 地址\n"
"# you == 接收方 email 地址\n"
"msg['Subject'] = f'The contents of {textfile}'\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# 通过我们使用的 SMTP 服务器发送消息。\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"

#: ../../library/email.examples.rst:15
msgid ""
"Parsing :rfc:`822` headers can easily be done by the using the classes from "
"the :mod:`~email.parser` module:"
msgstr "解析 :rfc:`822` 标题可以通过使用 :mod:`~email.parser` 模块中的类来轻松完成："

#: ../../library/email.examples.rst:18
msgid ""
"# Import the email modules we'll need\n"
"#from email.parser import BytesParser\n"
"from email.parser import Parser\n"
"from email.policy import default\n"
"\n"
"# If the e-mail headers are in a file, uncomment these two lines:\n"
"# with open(messagefile, 'rb') as fp:\n"
"#     headers = BytesParser(policy=default).parse(fp)\n"
"\n"
"#  Or for parsing headers in a string (this is an uncommon operation), use:\n"
"headers = Parser(policy=default).parsestr(\n"
"        'From: Foo Bar <user@example.com>\\n'\n"
"        'To: <someone_else@example.com>\\n'\n"
"        'Subject: Test message\\n'\n"
"        '\\n'\n"
"        'Body would go here\\n')\n"
"\n"
"#  Now the header items can be accessed as a dictionary:\n"
"print('To: {}'.format(headers['to']))\n"
"print('From: {}'.format(headers['from']))\n"
"print('Subject: {}'.format(headers['subject']))\n"
"\n"
"# You can also access the parts of the addresses:\n"
"print('Recipient username: {}'.format(headers['to'].addresses[0].username))\n"
"print('Sender name: {}'.format(headers['from'].addresses[0].display_name))\n"
msgstr ""
"# 导入我们需要的 email 模块\n"
"#from email.parser import BytesParser\n"
"from email.parser import Parser\n"
"from email.policy import default\n"
"\n"
"# 如果 email 标头保存在文件中，则取消注释这两行：\n"
"# with open(messagefile, 'rb') as fp:\n"
"#     headers = BytesParser(policy=default).parse(fp)\n"
"\n"
"#  或者如果要从字符串中解析标头（这是不太常见的操作），使用：\n"
"headers = Parser(policy=default).parsestr(\n"
"        'From: Foo Bar <user@example.com>\\n'\n"
"        'To: <someone_else@example.com>\\n'\n"
"        'Subject: Test message\\n'\n"
"        '\\n'\n"
"        'Body would go here\\n')\n"
"\n"
"#  现在标头条目将可作为字典访问：\n"
"print('To: {}'.format(headers['to']))\n"
"print('From: {}'.format(headers['from']))\n"
"print('Subject: {}'.format(headers['subject']))\n"
"\n"
"# 你也可以访问地址的各个部分：\n"
"print('Recipient username: {}'.format(headers['to'].addresses[0].username))\n"
"print('Sender name: {}'.format(headers['from'].addresses[0].display_name))\n"

#: ../../library/email.examples.rst:21
msgid ""
"Here's an example of how to send a MIME message containing a bunch of family"
" pictures that may be residing in a directory:"
msgstr "以下是如何发送包含可能在目录中的一系列家庭照片的MIME消息示例："

#: ../../library/email.examples.rst:24
msgid ""
"# Import smtplib for the actual sending function.\n"
"import smtplib\n"
"\n"
"# Here are the email package modules we'll need.\n"
"from email.message import EmailMessage\n"
"\n"
"# Create the container email message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = 'Our family reunion'\n"
"# me == the sender's email address\n"
"# family = the list of all recipients' email addresses\n"
"msg['From'] = me\n"
"msg['To'] = ', '.join(family)\n"
"msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"# Open the files in binary mode.  You can also omit the subtype\n"
"# if you want MIMEImage to guess it.\n"
"for file in pngfiles:\n"
"    with open(file, 'rb') as fp:\n"
"        img_data = fp.read()\n"
"    msg.add_attachment(img_data, maintype='image',\n"
"                                 subtype='png')\n"
"\n"
"# Send the email via our own SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""
"# 导入 smtplib 以使用实际的发送函数。\n"
"import smtplib\n"
"\n"
"# 以下是我们要用到的 email 包模块。\n"
"from email.message import EmailMessage\n"
"\n"
"# 创建容器 email 消息。\n"
"msg = EmailMessage()\n"
"msg['Subject'] = 'Our family reunion'\n"
"# me == 发送方 email 地址\n"
"# family = 所有接收方的 email 地址列表\n"
"msg['From'] = me\n"
"msg['To'] = ', '.join(family)\n"
"msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"# 以二进制模式打开文件。 你也可以忽略子类型\n"
"# 如果你想要 MIMEImage 自动猜测的话。\n"
"for file in pngfiles:\n"
"    with open(file, 'rb') as fp:\n"
"        img_data = fp.read()\n"
"    msg.add_attachment(img_data, maintype='image',\n"
"                                 subtype='png')\n"
"\n"
"# 通过我们自己的 SMTP 服务器发送 email。\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"

#: ../../library/email.examples.rst:27
msgid ""
"Here's an example of how to send the entire contents of a directory as an "
"email message: [1]_"
msgstr "以下是如何将目录的全部内容作为电子邮件消息发送的示例： [1]_"

#: ../../library/email.examples.rst:30
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Send the contents of a directory as a MIME message.\"\"\"\n"
"\n"
"import os\n"
"import smtplib\n"
"# For guessing MIME type based on file name extension\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"from email.message import EmailMessage\n"
"from email.policy import SMTP\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Send the contents of a directory as a MIME message.\n"
"Unless the -o option is given, the email is sent by forwarding to your local\n"
"SMTP server, which then does the normal delivery process.  Your local machine\n"
"must be running an SMTP server.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory',\n"
"                        help=\"\"\"Mail the contents of the specified directory,\n"
"                        otherwise use the current directory.  Only the regular\n"
"                        files in the directory are sent, and we don't recurse to\n"
"                        subdirectories.\"\"\")\n"
"    parser.add_argument('-o', '--output',\n"
"                        metavar='FILE',\n"
"                        help=\"\"\"Print the composed message to FILE instead of\n"
"                        sending the message to the SMTP server.\"\"\")\n"
"    parser.add_argument('-s', '--sender', required=True,\n"
"                        help='The value of the From: header (required)')\n"
"    parser.add_argument('-r', '--recipient', required=True,\n"
"                        action='append', metavar='RECIPIENT',\n"
"                        default=[], dest='recipients',\n"
"                        help='A To: header value (at least one required)')\n"
"    args = parser.parse_args()\n"
"    directory = args.directory\n"
"    if not directory:\n"
"        directory = '.'\n"
"    # Create the message\n"
"    msg = EmailMessage()\n"
"    msg['Subject'] = f'Contents of directory {os.path.abspath(directory)}'\n"
"    msg['To'] = ', '.join(args.recipients)\n"
"    msg['From'] = args.sender\n"
"    msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"    for filename in os.listdir(directory):\n"
"        path = os.path.join(directory, filename)\n"
"        if not os.path.isfile(path):\n"
"            continue\n"
"        # Guess the content type based on the file's extension.  Encoding\n"
"        # will be ignored, although we should check for simple things like\n"
"        # gzip'd or compressed files.\n"
"        ctype, encoding = mimetypes.guess_file_type(path)\n"
"        if ctype is None or encoding is not None:\n"
"            # No guess could be made, or the file is encoded (compressed), so\n"
"            # use a generic bag-of-bits type.\n"
"            ctype = 'application/octet-stream'\n"
"        maintype, subtype = ctype.split('/', 1)\n"
"        with open(path, 'rb') as fp:\n"
"            msg.add_attachment(fp.read(),\n"
"                               maintype=maintype,\n"
"                               subtype=subtype,\n"
"                               filename=filename)\n"
"    # Now send or store the message\n"
"    if args.output:\n"
"        with open(args.output, 'wb') as fp:\n"
"            fp.write(msg.as_bytes(policy=SMTP))\n"
"    else:\n"
"        with smtplib.SMTP('localhost') as s:\n"
"            s.send_message(msg)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"将目录的内容作为 MIME 消息来发送。\"\"\"\n"
"\n"
"import os\n"
"import smtplib\n"
"# 用于根据文件扩展名来猜测 MIME 类型\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"from email.message import EmailMessage\n"
"from email.policy import SMTP\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Send the contents of a directory as a MIME message.\n"
"Unless the -o option is given, the email is sent by forwarding to your local\n"
"SMTP server, which then does the normal delivery process.  Your local machine\n"
"must be running an SMTP server.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory',\n"
"                        help=\"\"\"Mail the contents of the specified directory,\n"
"                        otherwise use the current directory.  Only the regular\n"
"                        files in the directory are sent, and we don't recurse to\n"
"                        subdirectories.\"\"\")\n"
"    parser.add_argument('-o', '--output',\n"
"                        metavar='FILE',\n"
"                        help=\"\"\"Print the composed message to FILE instead of\n"
"                        sending the message to the SMTP server.\"\"\")\n"
"    parser.add_argument('-s', '--sender', required=True,\n"
"                        help='The value of the From: header (required)')\n"
"    parser.add_argument('-r', '--recipient', required=True,\n"
"                        action='append', metavar='RECIPIENT',\n"
"                        default=[], dest='recipients',\n"
"                        help='A To: header value (at least one required)')\n"
"    args = parser.parse_args()\n"
"    directory = args.directory\n"
"    if not directory:\n"
"        directory = '.'\n"
"    # 创建消息\n"
"    msg = EmailMessage()\n"
"    msg['Subject'] = f'Contents of directory {os.path.abspath(directory)}'\n"
"    msg['To'] = ', '.join(args.recipients)\n"
"    msg['From'] = args.sender\n"
"    msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"    for filename in os.listdir(directory):\n"
"        path = os.path.join(directory, filename)\n"
"        if not os.path.isfile(path):\n"
"            continue\n"
"        # 根据文件扩展名来猜测内容类型。\n"
"        # 编码格式将被忽略，不过我们应当检查某些简单事务\n"
"        # 例如是否为 gzip 或压缩文件。\n"
"        ctype, encoding = mimetypes.guess_file_type(path)\n"
"        if ctype is None or encoding is not None:\n"
"            # 不可以猜测，或者文件已被编码（压缩），\n"
"            # 因此我们使用基本的比特位数据类型。\n"
"            ctype = 'application/octet-stream'\n"
"        maintype, subtype = ctype.split('/', 1)\n"
"        with open(path, 'rb') as fp:\n"
"            msg.add_attachment(fp.read(),\n"
"                               maintype=maintype,\n"
"                               subtype=subtype,\n"
"                               filename=filename)\n"
"    # 现在执行消息发送或存储\n"
"    if args.output:\n"
"        with open(args.output, 'wb') as fp:\n"
"            fp.write(msg.as_bytes(policy=SMTP))\n"
"    else:\n"
"        with smtplib.SMTP('localhost') as s:\n"
"            s.send_message(msg)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/email.examples.rst:33
msgid ""
"Here's an example of how to unpack a MIME message like the one above, into a"
" directory of files:"
msgstr "以下是如何将上述MIME消息解压缩到文件目录中的示例："

#: ../../library/email.examples.rst:36
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Unpack a MIME message into a directory of files.\"\"\"\n"
"\n"
"import os\n"
"import email\n"
"import mimetypes\n"
"\n"
"from email.policy import default\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Unpack a MIME message into a directory of files.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory', required=True,\n"
"                        help=\"\"\"Unpack the MIME message into the named\n"
"                        directory, which will be created if it doesn't already\n"
"                        exist.\"\"\")\n"
"    parser.add_argument('msgfile')\n"
"    args = parser.parse_args()\n"
"\n"
"    with open(args.msgfile, 'rb') as fp:\n"
"        msg = email.message_from_binary_file(fp, policy=default)\n"
"\n"
"    try:\n"
"        os.mkdir(args.directory)\n"
"    except FileExistsError:\n"
"        pass\n"
"\n"
"    counter = 1\n"
"    for part in msg.walk():\n"
"        # multipart/* are just containers\n"
"        if part.get_content_maintype() == 'multipart':\n"
"            continue\n"
"        # Applications should really sanitize the given filename so that an\n"
"        # email message can't be used to overwrite important files\n"
"        filename = part.get_filename()\n"
"        if not filename:\n"
"            ext = mimetypes.guess_extension(part.get_content_type())\n"
"            if not ext:\n"
"                # Use a generic bag-of-bits extension\n"
"                ext = '.bin'\n"
"            filename = f'part-{counter:03d}{ext}'\n"
"        counter += 1\n"
"        with open(os.path.join(args.directory, filename), 'wb') as fp:\n"
"            fp.write(part.get_payload(decode=True))\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"将 MIME 消息解包到一个文件目录中。\"\"\"\n"
"\n"
"import os\n"
"import email\n"
"import mimetypes\n"
"\n"
"from email.policy import default\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Unpack a MIME message into a directory of files.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory', required=True,\n"
"                        help=\"\"\"Unpack the MIME message into the named\n"
"                        directory, which will be created if it doesn't already\n"
"                        exist.\"\"\")\n"
"    parser.add_argument('msgfile')\n"
"    args = parser.parse_args()\n"
"\n"
"    with open(args.msgfile, 'rb') as fp:\n"
"        msg = email.message_from_binary_file(fp, policy=default)\n"
"\n"
"    try:\n"
"        os.mkdir(args.directory)\n"
"    except FileExistsError:\n"
"        pass\n"
"\n"
"    counter = 1\n"
"    for part in msg.walk():\n"
"        # multipart/* 只是一些容器\n"
"        if part.get_content_maintype() == 'multipart':\n"
"            continue\n"
"        # 应用程序真的应该对所给文件名做无害化处理\n"
"        # 以保证 email 消息不能被用来覆盖重要的文件\n"
"        filename = part.get_filename()\n"
"        if not filename:\n"
"            ext = mimetypes.guess_extension(part.get_content_type())\n"
"            if not ext:\n"
"                # Use a generic bag-of-bits extension\n"
"                ext = '.bin'\n"
"            filename = f'part-{counter:03d}{ext}'\n"
"        counter += 1\n"
"        with open(os.path.join(args.directory, filename), 'wb') as fp:\n"
"            fp.write(part.get_payload(decode=True))\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/email.examples.rst:39
msgid ""
"Here's an example of how to create an HTML message with an alternative plain"
" text version.  To make things a bit more interesting, we include a related "
"image in the html part, and we save a copy of what we are going to send to "
"disk, as well as sending it."
msgstr ""
"以下是如何使用备用纯文本版本创建 HTML 消息的示例。 为了让事情变得更有趣，我们在 html "
"部分中包含了一个相关的图像，我们保存了一份我们要发送的内容到硬盘中，然后发送它。"

#: ../../library/email.examples.rst:44
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.message import EmailMessage\n"
"from email.headerregistry import Address\n"
"from email.utils import make_msgid\n"
"\n"
"# Create the base text message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = \"Pourquoi pas des asperges pour ce midi ?\"\n"
"msg['From'] = Address(\"Pepé Le Pew\", \"pepe\", \"example.com\")\n"
"msg['To'] = (Address(\"Penelope Pussycat\", \"penelope\", \"example.com\"),\n"
"             Address(\"Fabrette Pussycat\", \"fabrette\", \"example.com\"))\n"
"msg.set_content(\"\"\"\\\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas.\n"
"\n"
"[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n"
"\n"
"--Pepé\n"
"\"\"\")\n"
"\n"
"# Add the html version.  This converts the message into a multipart/alternative\n"
"# container, with the original text message as the first part and the new html\n"
"# message as the second part.\n"
"asparagus_cid = make_msgid()\n"
"msg.add_alternative(\"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Salut!</p>\n"
"    <p>Cette\n"
"        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\">\n"
"            recette\n"
"        </a> sera sûrement un très bon repas.\n"
"    </p>\n"
"    <img src=\"cid:{asparagus_cid}\">\n"
"  </body>\n"
"</html>\n"
"\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n"
"# note that we needed to peel the <> off the msgid for use in the html.\n"
"\n"
"# Now add the related image to the html part.\n"
"with open(\"roasted-asparagus.jpg\", 'rb') as img:\n"
"    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n"
"                                     cid=asparagus_cid)\n"
"\n"
"# Make a local copy of what we are going to send.\n"
"with open('outgoing.msg', 'wb') as f:\n"
"    f.write(bytes(msg))\n"
"\n"
"# Send the message via local SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.message import EmailMessage\n"
"from email.headerregistry import Address\n"
"from email.utils import make_msgid\n"
"\n"
"# 创建基本的文本消息。\n"
"msg = EmailMessage()\n"
"msg['Subject'] = \"Pourquoi pas des asperges pour ce midi ?\"\n"
"msg['From'] = Address(\"Pepé Le Pew\", \"pepe\", \"example.com\")\n"
"msg['To'] = (Address(\"Penelope Pussycat\", \"penelope\", \"example.com\"),\n"
"             Address(\"Fabrette Pussycat\", \"fabrette\", \"example.com\"))\n"
"msg.set_content(\"\"\"\\\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas.\n"
"\n"
"[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n"
"\n"
"--Pepé\n"
"\"\"\")\n"
"\n"
"# 增加 html 版本。 这会将消息转换为一个 multipart/alternative 容器，\n"
"# 原始文本消息作为第一部分而新的 html 消息作为第二部分。\n"
"asparagus_cid = make_msgid()\n"
"msg.add_alternative(\"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Salut!</p>\n"
"    <p>Cette\n"
"        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\">\n"
"            recette\n"
"        </a> sera sûrement un très bon repas.\n"
"    </p>\n"
"    <img src=\"cid:{asparagus_cid}\">\n"
"  </body>\n"
"</html>\n"
"\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n"
"# 请注意我们需要将 <> 从 msgid 中去掉以便在 html 中使用。\n"
"\n"
"# 现在添加相关图像到 html 部分中。\n"
"with open(\"roasted-asparagus.jpg\", 'rb') as img:\n"
"    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n"
"                                     cid=asparagus_cid)\n"
"\n"
"# 创建我们将要发送的内容的本地副本。\n"
"with open('outgoing.msg', 'wb') as f:\n"
"    f.write(bytes(msg))\n"
"\n"
"# 通过本地 SMTP 服务器发送消息。\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"

#: ../../library/email.examples.rst:47
msgid ""
"If we were sent the message from the last example, here is one way we could "
"process it:"
msgstr "如果我们发送最后一个示例中的消息，这是我们可以处理它的一种方法："

#: ../../library/email.examples.rst:50
msgid ""
"import os\n"
"import sys\n"
"import tempfile\n"
"import mimetypes\n"
"import webbrowser\n"
"\n"
"# Import the email modules we'll need\n"
"from email import policy\n"
"from email.parser import BytesParser\n"
"\n"
"\n"
"def magic_html_parser(html_text, partfiles):\n"
"    \"\"\"Return safety-sanitized html linked to partfiles.\n"
"\n"
"    Rewrite the href=\"cid:....\" attributes to point to the filenames in partfiles.\n"
"    Though not trivial, this should be possible using html.parser.\n"
"    \"\"\"\n"
"    raise NotImplementedError(\"Add the magic needed\")\n"
"\n"
"\n"
"# In a real program you'd get the filename from the arguments.\n"
"with open('outgoing.msg', 'rb') as fp:\n"
"    msg = BytesParser(policy=policy.default).parse(fp)\n"
"\n"
"# Now the header items can be accessed as a dictionary, and any non-ASCII will\n"
"# be converted to unicode:\n"
"print('To:', msg['to'])\n"
"print('From:', msg['from'])\n"
"print('Subject:', msg['subject'])\n"
"\n"
"# If we want to print a preview of the message content, we can extract whatever\n"
"# the least formatted payload is and print the first three lines.  Of course,\n"
"# if the message has no plain text part printing the first three lines of html\n"
"# is probably useless, but this is just a conceptual example.\n"
"simplest = msg.get_body(preferencelist=('plain', 'html'))\n"
"print()\n"
"print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n"
"\n"
"ans = input(\"View full message?\")\n"
"if ans.lower()[0] == 'n':\n"
"    sys.exit()\n"
"\n"
"# We can extract the richest alternative in order to display it:\n"
"richest = msg.get_body()\n"
"partfiles = {}\n"
"if richest['content-type'].maintype == 'text':\n"
"    if richest['content-type'].subtype == 'plain':\n"
"        for line in richest.get_content().splitlines():\n"
"            print(line)\n"
"        sys.exit()\n"
"    elif richest['content-type'].subtype == 'html':\n"
"        body = richest\n"
"    else:\n"
"        print(\"Don't know how to display {}\".format(richest.get_content_type()))\n"
"        sys.exit()\n"
"elif richest['content-type'].content_type == 'multipart/related':\n"
"    body = richest.get_body(preferencelist=('html'))\n"
"    for part in richest.iter_attachments():\n"
"        fn = part.get_filename()\n"
"        if fn:\n"
"            extension = os.path.splitext(part.get_filename())[1]\n"
"        else:\n"
"            extension = mimetypes.guess_extension(part.get_content_type())\n"
"        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as f:\n"
"            f.write(part.get_content())\n"
"            # again strip the <> to go from email form of cid to html form.\n"
"            partfiles[part['content-id'][1:-1]] = f.name\n"
"else:\n"
"    print(\"Don't know how to display {}\".format(richest.get_content_type()))\n"
"    sys.exit()\n"
"with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n"
"    f.write(magic_html_parser(body.get_content(), partfiles))\n"
"webbrowser.open(f.name)\n"
"os.remove(f.name)\n"
"for fn in partfiles.values():\n"
"    os.remove(fn)\n"
"\n"
"# Of course, there are lots of email messages that could break this simple\n"
"# minded program, but it will handle the most common ones.\n"
msgstr ""
"import os\n"
"import sys\n"
"import tempfile\n"
"import mimetypes\n"
"import webbrowser\n"
"\n"
"# 导入我们需要的 email 模块\n"
"from email import policy\n"
"from email.parser import BytesParser\n"
"\n"
"\n"
"def magic_html_parser(html_text, partfiles):\n"
"    \"\"\"返回链接到 partfiles 的经安全性处理的 html。\n"
"\n"
"    重写 href=\"cid:....\" 属性以指向 partfiles 中的文件名。\n"
"    虽然并非琐碎，这应可使用 html.parser 来实现。\n"
"    \"\"\"\n"
"    raise NotImplementedError(\"Add the magic needed\")\n"
"\n"
"\n"
"# 在真正的程序中你将从参数中获得文件名。\n"
"with open('outgoing.msg', 'rb') as fp:\n"
"    msg = BytesParser(policy=policy.default).parse(fp)\n"
"\n"
"# 现在可通过字典形式访问标头条目，并且任何非 ASCII 内容\n"
"# 都将被转换为 unicode：\n"
"print('To:', msg['to'])\n"
"print('From:', msg['from'])\n"
"print('Subject:', msg['subject'])\n"
"\n"
"# 如果我们想要打印消息内容的预览，可以提取\n"
"# 未经格式化的载荷并打印其中前三行。 当然，\n"
"# 如果消息没有纯文本部分则打印 html 的前三行\n"
"# 可能是无用的，但这只是个概念性的示例。\n"
"simplest = msg.get_body(preferencelist=('plain', 'html'))\n"
"print()\n"
"print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n"
"\n"
"ans = input(\"View full message?\")\n"
"if ans.lower()[0] == 'n':\n"
"    sys.exit()\n"
"\n"
"# 我们可以提取最丰富的替代项用于显示：\n"
"richest = msg.get_body()\n"
"partfiles = {}\n"
"if richest['content-type'].maintype == 'text':\n"
"    if richest['content-type'].subtype == 'plain':\n"
"        for line in richest.get_content().splitlines():\n"
"            print(line)\n"
"        sys.exit()\n"
"    elif richest['content-type'].subtype == 'html':\n"
"        body = richest\n"
"    else:\n"
"        print(\"Don't know how to display {}\".format(richest.get_content_type()))\n"
"        sys.exit()\n"
"elif richest['content-type'].content_type == 'multipart/related':\n"
"    body = richest.get_body(preferencelist=('html'))\n"
"    for part in richest.iter_attachments():\n"
"        fn = part.get_filename()\n"
"        if fn:\n"
"            extension = os.path.splitext(part.get_filename())[1]\n"
"        else:\n"
"            extension = mimetypes.guess_extension(part.get_content_type())\n"
"        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as f:\n"
"            f.write(part.get_content())\n"
"            # 再次去除 <> 以将 cid 的 email 形式转为 html 形式。\n"
"            partfiles[part['content-id'][1:-1]] = f.name\n"
"else:\n"
"    print(\"Don't know how to display {}\".format(richest.get_content_type()))\n"
"    sys.exit()\n"
"with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n"
"    f.write(magic_html_parser(body.get_content(), partfiles))\n"
"webbrowser.open(f.name)\n"
"os.remove(f.name)\n"
"for fn in partfiles.values():\n"
"    os.remove(fn)\n"
"\n"
"# 当然，许多 email 消息都有可能破坏这个简单的程序，\n"
"# 但它将能处理最普通的消息。\n"

#: ../../library/email.examples.rst:52
msgid "Up to the prompt, the output from the above is:"
msgstr "直到输出提示，上面的输出是："

#: ../../library/email.examples.rst:54
msgid ""
"To: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat <fabrette@example.com>\n"
"From: Pepé Le Pew <pepe@example.com>\n"
"Subject: Pourquoi pas des asperges pour ce midi ?\n"
"\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas."
msgstr ""
"To: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat <fabrette@example.com>\n"
"From: Pepé Le Pew <pepe@example.com>\n"
"Subject: Pourquoi pas des asperges pour ce midi ?\n"
"\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas."

#: ../../library/email.examples.rst:66
msgid "Footnotes"
msgstr "备注"

#: ../../library/email.examples.rst:67
msgid ""
"Thanks to Matthew Dixon Cowles for the original inspiration and examples."
msgstr "感谢 Matthew Dixon Cowles 提供最初的灵感和示例。"
