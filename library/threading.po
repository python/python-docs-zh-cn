# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Arisaka97 <solitaire2312@gmail.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# kevin wong <huagang517@126.com>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# TX Lee <litmxs@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# ww song <sww4718168@gmail.com>, 2022
# Dai Xu <daixu61@hotmail.com>, 2022
# ProgramRipper, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:15+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`!threading` --- 基于线程的并行"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**源代码:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower"
" level :mod:`_thread` module."
msgstr "这个模块在低层级的 :mod:`_thread` 模块之上构造了高层级的线程接口。"

#: ../../library/threading.rst:194 ../../library/threading.rst:293
#: ../../library/threading.rst:678 ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/threading.rst:17
msgid "Introduction"
msgstr "概述"

#: ../../library/threading.rst:19
msgid ""
"The :mod:`!threading` module provides a way to run multiple `threads "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_ (smaller units of a "
"process) concurrently within a single process. It allows for the creation "
"and management of threads, making it possible to execute tasks in parallel, "
"sharing memory space. Threads are particularly useful when tasks are I/O "
"bound, such as file operations or making network requests, where much of the"
" time is spent waiting for external resources."
msgstr ""
":mod:`!threading` 模块提供了一种在单个进程内部并发地运行多个 `线程 "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_ (从进程分出的更小单位) 的方式。 "
"它允许创建和管理线程，以便能够平行地执行多个任务，并共享内存空间。 线程特别适用于 I/O "
"密集型的任务，如文件操作或发送网络请求，在此类任务中大部分时间都会消耗于等待外部资源。"

#: ../../library/threading.rst:27
msgid ""
"A typical use case for :mod:`!threading` includes managing a pool of worker "
"threads that can process multiple tasks concurrently.  Here's a basic "
"example of creating and starting threads using :class:`~threading.Thread`::"
msgstr ""
"典型的 :mod:`!threading` 使用场景包括管理一个工作线程池来并发地处理多个任务。 下面是一个使用 "
":class:`~threading.Thread` 创建并启动线程的简单示例::"

#: ../../library/threading.rst:31
msgid ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"crawl started for {link}\")\n"
"    time.sleep(delay)  # Blocking I/O (simulating a network request)\n"
"    print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Start threads for each link\n"
"threads = []\n"
"for link in links:\n"
"    # Using `args` to pass positional arguments and `kwargs` for keyword arguments\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Start each thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Wait for all threads to finish\n"
"for t in threads:\n"
"    t.join()"
msgstr ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"print(f\"crawl started for {link}\")\n"
"time.sleep(delay) # 阻塞 I/O (模拟网络请求)\n"
"print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"\"https://python.org\",\n"
"\"https://docs.python.org\",\n"
"\"https://peps.python.org\",\n"
"]\n"
"\n"
"# 针对每个链接启动线程\n"
"threads = []\n"
"for link in links:\n"
"# 使用 `args` 传入位置参数并使用 `kwargs` 传入关键字参数\n"
"t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"threads.append(t)\n"
"\n"
"# 启动每个线程\n"
"for t in threads:\n"
"t.start()\n"
"\n"
"# 等待所有线程结束\n"
"for t in threads:\n"
"t.join()"

#: ../../library/threading.rst:60
msgid "This module used to be optional, it is now always available."
msgstr "这个模块曾经为可选项，但现在总是可用。"

#: ../../library/threading.rst:65
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of"
" the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` "
"提供了一个高层级接口用来向后台线程推送任务而不会阻塞调用方线程的执行，同时仍然能够在需要时获取任务的结果。"

#: ../../library/threading.rst:69
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ":mod:`queue` 提供了一个线程安全的接口用来在运行中的线程之间交换数据。"

#: ../../library/threading.rst:72
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ":mod:`asyncio` 提供了一个替代方式用来实现任务层级的并发而不要求使用多个操作系统线程。"

#: ../../library/threading.rst:77
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some"
" methods and functions. These are deprecated as of Python 3.10, but they are"
" still supported for compatibility with Python 2.5 and lower."
msgstr ""
"在 Python 2.x 系列中，此模块包含有某些方法和函数 ``camelCase`` 形式的名称。 它们在 Python 3.10 "
"中已弃用，但为了与 Python 2.5 及更旧版本的兼容性而仍受到支持。"

#: ../../library/threading.rst:84
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain"
" performance-oriented libraries might overcome this limitation). If you want"
" your application to make better use of the computational resources of "
"multi-core machines, you are advised to use :mod:`multiprocessing` or "
":class:`concurrent.futures.ProcessPoolExecutor`. However, threading is still"
" an appropriate model if you want to run multiple I/O-bound tasks "
"simultaneously."
msgstr ""
"在 CPython 中，由于存在 :term:`全局解释器锁 <global interpreter lock>`，同一时刻只有一个线程可以执行 "
"Python 代码（虽然某些性能导向的库可能会去除此限制）。 如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用 "
":mod:`multiprocessing` 或 :class:`concurrent.futures.ProcessPoolExecutor`。 "
"但是，如果你想要同时运行多个 I/O 密集型任务，则多线程仍然是一个合适的模型。"

#: ../../library/threading.rst:95
msgid "GIL and performance considerations"
msgstr "GIL 和性能的考量"

#: ../../library/threading.rst:97
msgid ""
"Unlike the :mod:`multiprocessing` module, which uses separate processes to "
"bypass the :term:`global interpreter lock` (GIL), the threading module "
"operates within a single process, meaning that all threads share the same "
"memory space. However, the GIL limits the performance gains of threading "
"when it comes to CPU-bound tasks, as only one thread can execute Python "
"bytecode at a time. Despite this, threads remain a useful tool for achieving"
" concurrency in many scenarios."
msgstr ""
"与使用多个进程来绕过 :term:`global interpreter lock` (GIL) 的 :mod:`multiprocessing` "
"模块不同，threading 模块是在单个进程内部操作的，这意味着所有线程共享相同的内存空间。 不过，对于 CPU 密集型任务来说 GIL 会限制 "
"threading 带来的性能提升，因为在同一时刻只有一个线程能执行 Python 字节码。 尽管如此，在许多场景中线程仍然是实现并发的有用工具。"

#: ../../library/threading.rst:105
msgid ""
"As of Python 3.13, experimental :term:`free-threaded <free threading>` "
"builds can disable the GIL, enabling true parallel execution of threads, but"
" this feature is not available by default (see :pep:`703`)."
msgstr ""
"对于 Python 3.13，实验性的 :term:`自由线程 <free threading>` 构建版可以禁用 "
"GIL，启用真正的线程并行执行，但此特性在默认情况下不可用 (参见 :pep:`703`)。"

#: ../../library/threading.rst:112
msgid "Reference"
msgstr "参考"

#: ../../library/threading.rst:114
msgid "This module defines the following functions:"
msgstr "这个模块定义了以下函数："

#: ../../library/threading.rst:119
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr "返回当前存活的 :class:`Thread` 对象的数量。 返回值与 :func:`.enumerate` 所返回的列表长度一致。"

#: ../../library/threading.rst:122
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "函数 ``activeCount`` 是此函数的已弃用别名。"

#: ../../library/threading.rst:127
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`!threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"返回当前 :class:`Thread` 对象，与调用方的控制线程。 如果调用方的控制线程不是通过 :mod:`!threading` "
"模块创建的，则会返回一个功能受限的假线程对象。"

#: ../../library/threading.rst:132
msgid ""
"The function ``currentThread`` is a deprecated alias for this function."
msgstr "函数 ``currentThread`` 是此函数的已弃用别名。"

#: ../../library/threading.rst:137
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "处理由 :func:`Thread.run` 引发的未捕获异常。"

#: ../../library/threading.rst:139
msgid "The *args* argument has the following attributes:"
msgstr "*args* 参数具有以下属性:"

#: ../../library/threading.rst:141
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: 异常类型"

#: ../../library/threading.rst:142
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: 异常值，可以是 ``None``."

#: ../../library/threading.rst:143
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: 异常回溯，可以是 ``None``."

#: ../../library/threading.rst:144
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*: 引发异常的线程，可以为 ``None``。"

#: ../../library/threading.rst:146
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"如果 *exc_type* 为 :exc:`SystemExit`，则异常会被静默地忽略。 在其他情况下，异常将被打印到 "
":data:`sys.stderr`。"

#: ../../library/threading.rst:149
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr "如果此函数引发了异常，则会调用 :func:`sys.excepthook` 来处理它。"

#: ../../library/threading.rst:152
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` 可以被重载以控制由 :func:`Thread.run` 引发的未捕获异常的处理方式。"

#: ../../library/threading.rst:155
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception"
" is no longer needed."
msgstr "使用定制钩子存放 *exc_value* 可能会创建引用循环。 它应当在不再需要异常时被显式地清空以打破引用循环。"

#: ../../library/threading.rst:159
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"如果一个对象正在被销毁，那么使用自定义的钩子储存 *thread* 可能会将其复活。请在自定义钩子生效后避免储存 *thread*，以避免对象的复活。"

#: ../../library/threading.rst:164
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` 处理未捕获的异常。"

#: ../../library/threading.rst:170
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"保存 :func:`threading.excepthook` 的原始值。 它被保存以便在原始值碰巧被已损坏或替代对象所替换的情况下可被恢复。"

#: ../../library/threading.rst:178
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic "
"cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。"

#: ../../library/threading.rst:189
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 "
"OS 回收再利用）。"

#: ../../library/threading.rst:198
msgid "Added support for GNU/kFreeBSD."
msgstr "增加了对 GNU/kFreeBSD 的支持。"

#: ../../library/threading.rst:204
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by "
":func:`current_thread`.  It excludes terminated threads and threads that "
"have not yet been started.  However, the main thread is always part of the "
"result, even when terminated."
msgstr ""
"返回当前所有存活的 :class:`Thread` 对象的列表。 该列表包括守护线程以及 :func:`current_thread` 创建的空线程。 "
"它不包括已终结的和尚未开始的线程。 但是，主线程将总是结果的一部分，即使是在已终结的时候。"

#: ../../library/threading.rst:213
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr "返回主 :class:`Thread` 对象。一般情况下，主线程是Python解释器开始时创建的线程。"

#: ../../library/threading.rst:224
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"为所有从 :mod:`!threading` 模块启动的线程设置追踪函数，在每个线程的 :meth:`~Thread.run` "
"方法被调用前，*func* 会被传递给 :func:`sys.settrace`。"

#: ../../library/threading.rst:230
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr "为从 :mod:`!threading` 模块启动的所有线程以及当前正在执行的所有 Python 线程设置追踪函数。"

#: ../../library/threading.rst:233
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"*func* 将为每个线程传递给  :func:`sys.settrace`，在其 :meth:`~Thread.run` 方法被调用之前。"

#: ../../library/threading.rst:244
msgid "Get the trace function as set by :func:`settrace`."
msgstr "返回由 :func:`settrace` 设置的跟踪函数。"

#: ../../library/threading.rst:253
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"为从 :mod:`!threading` 模块启动的所有线程设置性能分析函数。 在每个线程的 :meth:`~Thread.run` "
"方法被调用前，*func* 会被传递给 :func:`sys.setprofile`。"

#: ../../library/threading.rst:259
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr "为从 :mod:`!threading` 模块启动的所有线程和当前正在执行和的所有 Python 线程设置性能分析函数。"

#: ../../library/threading.rst:262
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before"
" its :meth:`~Thread.run` method is called."
msgstr ""
"*func* 将为每个线程传递给 :func:`sys.setprofile`，在其 :meth:`~Thread.run` 方法被调用之前。"

#: ../../library/threading.rst:271
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "返回由 :func:`setprofile` 设置的性能分析函数。"

#: ../../library/threading.rst:278
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created"
" threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a "
":exc:`RuntimeError` is raised.  If the specified stack size is invalid, a "
":exc:`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"返回创建线程时使用的堆栈大小。可选参数 *size* "
"指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 *size* "
"没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 :exc:`RuntimeError` 错误。如果指定的堆栈大小不合法，会抛出 "
":exc:`ValueError` "
"错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配"
" - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。"

#: ../../library/threading.rst:295
msgid "Unix platforms with POSIX threads support."
msgstr "带有 POSIX 线程支持的 Unix 平台。"

#: ../../library/threading.rst:298
msgid "This module also defines the following constant:"
msgstr "这个模块同时定义了以下常量："

#: ../../library/threading.rst:302
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.)."
" Specifying a timeout greater than this value will raise an "
":exc:`OverflowError`."
msgstr ""
"阻塞函数（ :meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, "
"...）中形参 *timeout* 允许的最大值。传入超过这个值的 timeout 会抛出 :exc:`OverflowError` 异常。"

#: ../../library/threading.rst:310
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr "这个模块定义了许多类，详见以下部分。"

#: ../../library/threading.rst:313
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread`"
" class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"该模块的设计基于 Java的线程模型。 但是，在Java里面，锁和条件变量是每个对象的基础特性，而在Python里面，这些被独立成了单独的对象。 "
"Python 的 :class:`Thread` 类只是 Java 的 Thread "
"类的一个子集；目前还没有优先级，没有线程组，线程还不能被销毁、停止、暂停、恢复或中断。 Java 的 Thread "
"类的静态方法在实现时会映射为模块级函数。"

#: ../../library/threading.rst:321
msgid "All of the methods described below are executed atomically."
msgstr "下述方法的执行都是原子性的。"

#: ../../library/threading.rst:325
msgid "Thread-local data"
msgstr "线程局部数据"

#: ../../library/threading.rst:327
msgid ""
"Thread-local data is data whose values are thread specific. If you have data"
" that you want to be local to a thread, create a :class:`local` object and "
"use its attributes::"
msgstr "线程局部数据是指具有线程专属值的数据。 如果你希望某些数据是线程局部数据，则创建一个 :class:`local` 对象并使用其属性::"

#: ../../library/threading.rst:331
msgid ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:336
msgid "You can also access the :class:`local`-object's dictionary::"
msgstr "你也可以访问 :class:`local` 对象的字典::"

#: ../../library/threading.rst:338
msgid ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"
msgstr ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"

#: ../../library/threading.rst:345
msgid "If we access the data in a different thread::"
msgstr "如果我们在另一个线程中访问此数据::"

#: ../../library/threading.rst:347
msgid ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"
msgstr ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"

#: ../../library/threading.rst:361
msgid ""
"we get different data.  Furthermore, changes made in the other thread don't "
"affect data seen in this thread::"
msgstr "我们将得到不同的数据。 此外，在其他线程中进行的修改也不会影响在本线程中看到的数据::"

#: ../../library/threading.rst:364
msgid ""
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:367
msgid ""
"Of course, values you get from a :class:`local` object, including their "
":attr:`~object.__dict__` attribute, are for whatever thread was current at "
"the time the attribute was read.  For that reason, you generally don't want "
"to save these values across threads, as they apply only to the thread they "
"came from."
msgstr ""
"当然，你从 :class:`local` 对象获取的值，包括其 :attr:`~object.__dict__` 属性，都只针对属性被读取时的当前线程。"
" 出于此理由，通常你不会跨线程保存这些值，因为它们仅适用于它们所在的线程。"

#: ../../library/threading.rst:373
msgid ""
"You can create custom :class:`local` objects by subclassing the "
":class:`local` class::"
msgstr "你可以通过子类化 :class:`local` 类来创建自定义的 :class:`local` 对象::"

#: ../../library/threading.rst:376
msgid ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"
msgstr ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"

#: ../../library/threading.rst:383
msgid ""
"This can be useful to support default values, methods and initialization.  "
"Note that if you define an :py:meth:`~object.__init__` method, it will be "
"called each time the :class:`local` object is used in a separate thread.  "
"This is necessary to initialize each thread's dictionary."
msgstr ""
"这适用于提供默认值、方法和初始化支持。 请注意如果你定义了 :py:meth:`~object.__init__` 方法，则每当该 "
":class:`local` 对象在不同线程中被使用时都将调用它。 这对于初始化每个线程的字典是必要的。"

#: ../../library/threading.rst:389
msgid "Now if we create a :class:`local` object::"
msgstr "现在如果我们创建一个 :class:`local` 对象::"

#: ../../library/threading.rst:391
msgid ">>> mydata = MyLocal(color='red')"
msgstr ">>> mydata = MyLocal(color='red')"

#: ../../library/threading.rst:393
msgid "we have a default number::"
msgstr "我们将有一个默认的 number 值::"

#: ../../library/threading.rst:395
msgid ""
">>> mydata.number\n"
"2"
msgstr ""
">>> mydata.number\n"
"2"

#: ../../library/threading.rst:398
msgid "an initial color::"
msgstr "一个初始的 color 值::"

#: ../../library/threading.rst:400
msgid ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"
msgstr ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"

#: ../../library/threading.rst:404
msgid "And a method that operates on the data::"
msgstr "以及一个操作数据的方法::"

#: ../../library/threading.rst:406
msgid ""
">>> mydata.squared()\n"
"4"
msgstr ""
">>> mydata.squared()\n"
"4"

#: ../../library/threading.rst:409
msgid "As before, we can access the data in a separate thread::"
msgstr "像之前一样，我们可以在不同的线程中访问该数据::"

#: ../../library/threading.rst:411
msgid ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"
msgstr ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"

#: ../../library/threading.rst:418
msgid "without affecting this thread's data::"
msgstr "而不会影响本线程的数据::"

#: ../../library/threading.rst:420
msgid ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"
msgstr ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"

#: ../../library/threading.rst:427
msgid ""
"Note that subclasses can define :term:`__slots__`, but they are not thread "
"local. They are shared across threads::"
msgstr "请注意子类可以定义 :term:`__slots__`，但它们不是线程局部的。 它们会被跨线程共享::"

#: ../../library/threading.rst:430
msgid ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"
msgstr ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"

#: ../../library/threading.rst:437
msgid "So, the separate thread::"
msgstr "因此，不同的线程::"

#: ../../library/threading.rst:439
msgid ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"
msgstr ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"

#: ../../library/threading.rst:443
msgid "affects what we see::"
msgstr "会影响我们的值::"

#: ../../library/threading.rst:445
msgid ""
">>> mydata.number\n"
"11"
msgstr ""
">>> mydata.number\n"
"11"

#: ../../library/threading.rst:451
msgid "A class that represents thread-local data."
msgstr "一个代表线程本地数据的类。"

#: ../../library/threading.rst:457
msgid "Thread objects"
msgstr "线程对象"

#: ../../library/threading.rst:459
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a"
" callable object to the constructor, or by overriding the "
":meth:`~Thread.run` method in a subclass.  No other methods (except for the "
"constructor) should be overridden in a subclass.  In other words, *only*  "
"override the ``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
":class:`Thread` 类代表一个在独立控制线程中运行的活动。 指定活动有两种方式：向构造器传递一个可调用对象，或在子类中重载 "
":meth:`~Thread.run` 方法。 其他方法不应在子类中重载（除了构造器）。 换句话说，*只能* 重载这个类的 ``__init__()``"
" 和 :meth:`~Thread.run` 方法。"

#: ../../library/threading.rst:466
msgid ""
"Once a thread object is created, its activity must be started by calling the"
" thread's :meth:`~Thread.start` method.  This invokes the "
":meth:`~Thread.run` method in a separate thread of control."
msgstr ""
"当线程对象一旦被创建，其活动必须通过调用线程的 :meth:`~Thread.start` 方法开始。 这会在独立的控制线程中唤起 "
":meth:`~Thread.run` 方法。"

#: ../../library/threading.rst:470
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The "
":meth:`~Thread.is_alive` method tests whether the thread is alive."
msgstr ""
"一旦线程活动开始，该线程会被认为是 '存活的' 。当它的 :meth:`~Thread.run` "
"方法终结了（不管是正常的还是抛出未被处理的异常），就不是'存活的'。 :meth:`~Thread.is_alive` 方法用于检查线程是否存活。"

#: ../../library/threading.rst:475
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"其他线程可以调用一个线程的 :meth:`~Thread.join` 方法。这会阻塞调用该方法的线程，直到被调用 "
":meth:`~Thread.join` 方法的线程终结。"

#: ../../library/threading.rst:479
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or"
" changed through the :attr:`~Thread.name` attribute."
msgstr "线程有名字。名字可以传递给构造函数，也可以通过 :attr:`~Thread.name` 属性读取或者修改。"

#: ../../library/threading.rst:482
msgid ""
"If the :meth:`~Thread.run` method raises an exception, "
":func:`threading.excepthook` is called to handle it. By default, "
":func:`threading.excepthook` ignores silently :exc:`SystemExit`."
msgstr ""
"如果 :meth:`~Thread.run` 方法引发了异常，则会调用 :func:`threading.excepthook` 来处理它。 "
"在默认情况下，:func:`threading.excepthook` 会静默地忽略 :exc:`SystemExit`。"

#: ../../library/threading.rst:486
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"一个线程可以被标记成一个“守护线程”。 这个标识的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 "
"这个标识可以通过 :attr:`~Thread.daemon` 特征属性或者 *daemon* 构造器参数来设置。"

#: ../../library/threading.rst:493
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如："
" :class:`Event`。"

#: ../../library/threading.rst:498
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of"
" control in the Python program.  It is not a daemon thread."
msgstr "有个 \"主线程\" 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。"

#: ../../library/threading.rst:501
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code."
"  Dummy thread objects have limited functionality; they are always "
"considered alive and daemonic, and cannot be :ref:`joined <meth-thread-"
"join>`.  They are never deleted, since it is impossible to detect the "
"termination of alien threads."
msgstr ""
"创建“虚拟线程对象”是有可能的。 它们是与“外部线程”相对应 的线程对象，是在 threading 模块之外启动的控制线程，例如直接来自 C 代码。 "
"虚拟线程对象的功能是受限的；它们总是会被视为处于激活和守护状态，且无法被 :ref:`合并 <meth-thread-join>`。 "
"它们绝不会被删除，因为检测外部线程的终结是不可能做到的。"

#: ../../library/threading.rst:512
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr "应当始终使用关键字参数调用此构造函数。 参数如下："

#: ../../library/threading.rst:515
msgid ""
"*group* should be ``None``; reserved for future extension when a "
":class:`!ThreadGroup` class is implemented."
msgstr "*group* 应为 ``None``；保留给将来实现 :class:`!ThreadGroup` 类的扩展使用。"

#: ../../library/threading.rst:518
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr "*target* 是用于 :meth:`run` 方法调用的可调用对象。默认是 ``None``，表示不需要调用任何方法。"

#: ../../library/threading.rst:521
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* 是线程名称。 在默认情况下，会以 \"Thread-*N*\" 的形式构造唯一名称，其中 *N* 为一个较小的十进制数值，或是 "
"\"Thread-*N* (target)\" 的形式，其中 \"target\" 为 ``target.__name__``，如果指定了 "
"*target* 参数的话。"

#: ../../library/threading.rst:526
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr "*args* 是用于唤起目标函数的参数列表或元组。 默认为 ``()``。"

#: ../../library/threading.rst:528
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr "*kwargs* 是用于调用目标函数的关键字参数字典。默认是 ``{}``。"

#: ../../library/threading.rst:531
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If"
" ``None`` (the default), the daemonic property is inherited from the current"
" thread."
msgstr ""
"如果不是 ``None``，*daemon* 参数将显式地设置该线程是否为守护模式。 如果是 ``None`` "
"(默认值)，线程将继承当前线程的守护模式属性。"

#: ../../library/threading.rst:535
msgid ""
"*context* is the :class:`~contextvars.Context` value to use when starting "
"the thread.  The default value is ``None`` which indicates that the "
":data:`sys.flags.thread_inherit_context` flag controls the behaviour.  If "
"the flag is true, threads will start with a copy of the context of the "
"caller of :meth:`~Thread.start`.  If false, they will start with an empty "
"context.  To explicitly start with an empty context, pass a new instance of "
":class:`~contextvars.Context()`.  To explicitly start with a copy of the "
"current context, pass the value from :func:`~contextvars.copy_context`. The "
"flag defaults true on free-threaded builds and false otherwise."
msgstr ""

#: ../../library/threading.rst:545
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to"
" the thread."
msgstr "如果子类型重载了构造函数，它一定要确保在做任何事前，先唤起基类构造器(``Thread.__init__()``)。"

#: ../../library/threading.rst:549
msgid "Added the *daemon* parameter."
msgstr "增加了 *daemon* 形参。"

#: ../../library/threading.rst:552
msgid "Use the *target* name if *name* argument is omitted."
msgstr "使用 *target* 名称，如果 *name* 参数被省略的话。"

#: ../../library/threading.rst:555
msgid "Added the *context* parameter."
msgstr "增加了 *context* 形参。"

#: ../../library/threading.rst:560
msgid "Start the thread's activity."
msgstr "开始线程活动。"

#: ../../library/threading.rst:562
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr "它在一个线程里最多只能被调用一次。 它安排对象的 :meth:`~Thread.run` 方法在一个独立的控制线程中被调用。"

#: ../../library/threading.rst:566
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the"
" same thread object."
msgstr "如果同一个线程对象中调用这个方法的次数大于一次，会抛出 :exc:`RuntimeError` 。"

#: ../../library/threading.rst:569
msgid ""
"If supported, set the operating system thread name to "
":attr:`threading.Thread.name`. The name can be truncated depending on the "
"operating system thread name limits."
msgstr ""

#: ../../library/threading.rst:573
msgid "Set the operating system thread name."
msgstr "设置操作系统线程名称。"

#: ../../library/threading.rst:578
msgid "Method representing the thread's activity."
msgstr "代表线程活动的方法。"

#: ../../library/threading.rst:580
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"你可以在子类型里重载这个方法。 标准的 :meth:`run` 方法会对作为 *target* "
"参数传递给该对象构造器的可调用对象（如果存在）被唤起，并附带从 *args* 和 *kwargs* 参数分别获取的位置和关键字参数。"

#: ../../library/threading.rst:585
msgid ""
"Using list or tuple as the *args* argument which passed to the "
":class:`Thread` could achieve the same effect."
msgstr "使用列表或元组作为传给 :class:`Thread` 的 *args* 参数可以达成同样的效果。"

#: ../../library/threading.rst:588
msgid "Example::"
msgstr "示例："

#: ../../library/threading.rst:590
msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"

#: ../../library/threading.rst:602
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 :meth:`~Thread.join` 的线程终结 -- 不管是正常终结还是抛出未处理异常"
" -- 或者直到发生超时，超时选项是可选的。"

#: ../../library/threading.rst:607
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the "
":meth:`~Thread.join` call timed out."
msgstr ""
"当 *timeout* 参数存在而且不是 ``None`` 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 "
":meth:`~Thread.join` 总是返回 ``None`` ，所以你一定要在 :meth:`~Thread.join` 后调用 "
":meth:`~Thread.is_alive` 才能判断是否发生超时 -- 如果线程仍然存活，则 :meth:`~Thread.join` 超时。"

#: ../../library/threading.rst:614
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr "当 *timeout* 参数不存在或者是 ``None`` ，这个操作会阻塞直到线程终结。"

#: ../../library/threading.rst:617
msgid "A thread can be joined many times."
msgstr "一个线程可以被合并多次。"

#: ../../library/threading.rst:619
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
"如果尝试加入当前线程会导致死锁， :meth:`~Thread.join` 会引起 :exc:`RuntimeError`  异常。如果尝试 "
":meth:`~Thread.join` 一个尚未开始的线程，也会抛出相同的异常。"

#: ../../library/threading.rst:624
msgid ""
"If an attempt is made to join a running daemonic thread in in late stages of"
" :term:`Python finalization <interpreter shutdown>` :meth:`!join` raises a "
":exc:`PythonFinalizationError`."
msgstr ""

#: ../../library/threading.rst:630
msgid "May raise :exc:`PythonFinalizationError`."
msgstr "可能引发 :exc:`PythonFinalizationError`。"

#: ../../library/threading.rst:634
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the"
" constructor."
msgstr "只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。"

#: ../../library/threading.rst:638
msgid ""
"On some platforms, the thread name is set at the operating system level when"
" the thread starts, so that it is visible in task managers. This name may be"
" truncated to fit in a system-specific limit (for example, 15 bytes on Linux"
" or 63 bytes on macOS)."
msgstr ""

#: ../../library/threading.rst:643
msgid ""
"Changes to *name* are only reflected at the OS level when the currently "
"running thread is renamed. (Setting the *name* attribute of a different "
"thread only updates the Python Thread object.)"
msgstr ""

#: ../../library/threading.rst:650
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr "已被弃用的 :attr:`~Thread.name` 的取值/设值 API；请改为直接以特征属性方式使用它。"

#: ../../library/threading.rst:657
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"这个线程的 '线程标识符'，如果线程尚未开始则为 ``None`` 。这是个非零整数。参见  "
":func:`get_ident` 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。"

#: ../../library/threading.rst:665
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This"
" is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"此线程的线程 ID (``TID``)，由 OS (内核) 分配。 这是一个非负整数，或者如果线程还未启动则为 ``None``。 请参阅 "
":func:`get_native_id` 函数。 这个值可被用来在全系统范围内唯一地标识这个特定线程 (直到线程终结，在那之后该值可能会被 OS "
"回收再利用)。"

#: ../../library/threading.rst:674
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr "类似于进程 ID，线程 ID 的有效期（全系统范围内保证唯一）将从线程被创建开始直到线程被终结。"

#: ../../library/threading.rst:684
msgid "Return whether the thread is alive."
msgstr "返回线程是否存活。"

#: ../../library/threading.rst:686
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"当 :meth:`~Thread.run` 方法刚开始直到 :meth:`~Thread.run` 方法刚结束，这个方法返回 ``True`` "
"。模块函数 :func:`.enumerate` 返回包含所有存活线程的列表。"

#: ../../library/threading.rst:692
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``)"
" or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to "
":attr:`~Thread.daemon` = ``False``."
msgstr ""
"一个布尔值，表示这个线程是否是一个守护线程（``True``）或不是（``False``）。 这个值必须在调用 "
":meth:`~Thread.start` 之前设置，否则会引发 :exc:`RuntimeError` "
"。它的初始值继承自创建线程；主线程不是一个守护线程，因此所有在主线程中创建的线程默认为 :attr:`~Thread.daemon` = "
"``False``。"

#: ../../library/threading.rst:699
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr "当没有存活的非守护线程时，整个Python程序才会退出。"

#: ../../library/threading.rst:704
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr "已被弃用的 :attr:`~Thread.daemon` 的取值/设值 API；请改为直接以特征属性方式使用它。"

#: ../../library/threading.rst:713
msgid "Lock objects"
msgstr "Lock 对象"

#: ../../library/threading.rst:715
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the "
":mod:`_thread` extension module."
msgstr ""
"原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 :mod:`_thread`  "
"扩展模块直接实现。"

#: ../../library/threading.rst:720
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, "
":meth:`~Lock.acquire` and :meth:`~Lock.release`.  When the state is "
"unlocked, :meth:`~Lock.acquire` changes the state to locked and returns "
"immediately.  When the state is locked, :meth:`~Lock.acquire` blocks until a"
" call to :meth:`~Lock.release` in another thread changes it to unlocked, "
"then the :meth:`~Lock.acquire` call resets it to locked and returns.  The "
":meth:`~Lock.release` method should only be called in the locked state; it "
"changes the state to unlocked and returns immediately. If an attempt is made"
" to release an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"原始锁处于 \"锁定\" 或者 \"非锁定\" 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， :meth:`~Lock.acquire` 和"
" :meth:`~Lock.release` 。当状态为非锁定时， :meth:`~Lock.acquire`  将状态改为 锁定 "
"并立即返回。当状态是锁定时， :meth:`~Lock.acquire` 将阻塞至其他线程调用 :meth:`~Lock.release`  "
"将其改为非锁定状态，然后 :meth:`~Lock.acquire` 调用重置其为锁定状态并返回。  :meth:`~Lock.release` "
"只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 :exc:`RuntimeError`  异常。"

#: ../../library/threading.rst:731
msgid ""
"Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "锁同样支持 :ref:`上下文管理协议 <with-locks>`。"

#: ../../library/threading.rst:733
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a "
":meth:`~Lock.release` call resets the state to unlocked; which one of the "
"waiting threads proceeds is not defined, and may vary across "
"implementations."
msgstr ""
"当多个线程在 :meth:`~Lock.acquire` 等待状态转变为未锁定被阻塞，然后 :meth:`~Lock.release` "
"重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。"

#: ../../library/threading.rst:738
msgid "All methods are executed atomically."
msgstr "所有方法的执行都是原子性的。"

#: ../../library/threading.rst:743
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a"
" lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr "实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。"

#: ../../library/threading.rst:747
msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory function"
" which returned an instance of the underlying private lock type."
msgstr "现在 ``Lock`` 是一个类。 在更早的 Python 版本中，``Lock`` 是一个返回下层私有锁类型的实例的工厂函数。"

#: ../../library/threading.rst:755 ../../library/threading.rst:849
msgid "Acquire a lock, blocking or non-blocking."
msgstr "可以阻塞或非阻塞地获得锁。"

#: ../../library/threading.rst:757
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr "当调用时参数 *blocking* 设置为 ``True`` （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 ``True`` 。"

#: ../../library/threading.rst:760
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If"
" a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"在参数 *blocking* 被设置为 ``False`` 的情况下调用，将不会发生阻塞。如果调用时 *blocking* 设为 ``True`` "
"会阻塞，并立即返回 ``False`` ；否则，将锁锁定并返回 ``True``。"

#: ../../library/threading.rst:764
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as"
" long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"当参数 *timeout* 使用设置为正值的浮点数调用时，最多阻塞 *timeout* 指定的秒数，在此期间锁不能被获取。设置 *timeout* "
"参数为  ``-1`` specifies an unbounded wait. It is forbidden to specify a "
"*timeout* when *blocking* is ``False`` 。"

#: ../../library/threading.rst:770
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False``"
" if not (for example if the *timeout* expired)."
msgstr "如果成功获得锁，则返回 ``True``，否则返回 ``False`` (例如发生 *超时* 的时候)。"

#: ../../library/threading.rst:773 ../../library/threading.rst:887
#: ../../library/threading.rst:1147
msgid "The *timeout* parameter is new."
msgstr "新的 *timeout* 形参。"

#: ../../library/threading.rst:776
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr "现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。"

#: ../../library/threading.rst:780
msgid "Lock acquisition can now be interrupted by signals on Windows."
msgstr "在 Windows 上现在可以通过信号来中断锁的获取。"

#: ../../library/threading.rst:786
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr "释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。"

#: ../../library/threading.rst:789
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr "当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。"

#: ../../library/threading.rst:793
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "当在未锁定的锁上唤起时，会引发 :exc:`RuntimeError`。"

#: ../../library/threading.rst:795 ../../library/threading.rst:903
msgid "There is no return value."
msgstr "没有返回值。"

#: ../../library/threading.rst:799
msgid "Return ``True`` if the lock is acquired."
msgstr "当锁被获取时，返回 ``True``。"

#: ../../library/threading.rst:806
msgid "RLock objects"
msgstr "RLock 对象"

#: ../../library/threading.rst:808
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked"
" state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 \"所属线程\" 和 \"递归等级\" "
"的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。"

#: ../../library/threading.rst:814
msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its "
":meth:`~Lock.release` method to unlock it."
msgstr "线程调用锁的 :meth:`~RLock.acquire` 方法来锁定它，并调用 :meth:`~Lock.release` 方法来解锁。"

#: ../../library/threading.rst:819
msgid ""
"Reentrant locks support the :ref:`context management protocol <with-locks>`,"
" so it is recommended to use :keyword:`with` instead of manually calling "
":meth:`~RLock.acquire` and :meth:`~RLock.release` to handle acquiring and "
"releasing the lock for a block of code."
msgstr ""
"重入型锁支持 :ref:`上下文管理协议 <with-locks>`，因此推荐使用 :keyword:`with` 而不是手动调用 "
":meth:`~RLock.acquire` 和 :meth:`~RLock.release` 来针对一个代码块处理锁的获取和释放。"

#: ../../library/threading.rst:824
msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only the "
"final :meth:`~RLock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to an unlocked state and allows another thread blocked"
" in :meth:`~RLock.acquire` to proceed."
msgstr ""
"RLock 的 :meth:`~RLock.acquire`/:meth:`~RLock.release` 调用对可以嵌套，这不同于 Lock 的 "
":meth:`~Lock.acquire`/:meth:`~Lock.release`。 只有最终的 :meth:`~RLock.release` "
"(最外面一对的 :meth:`~Lock.release`) 会将锁重置为已解锁状态并允许在 :meth:`~RLock.acquire` "
"中被阻塞的其他线程继续执行。"

#: ../../library/threading.rst:830
msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each "
"acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead to"
" deadlock."
msgstr ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` 必须成对使用：每个 acquire "
"必须在获取锁的线程中有对应的 release。 如果锁调用 release 的次数未能与 acquire 的次数一致则会导致死锁。"

#: ../../library/threading.rst:837
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr "此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。"

#: ../../library/threading.rst:842
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance"
" of the most efficient version of the concrete RLock class that is supported"
" by the platform."
msgstr "需要注意的是 ``RLock`` 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。"

#: ../../library/threading.rst:853
msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ":ref:`将 RLock 用作上下文管理器 <with-locks>`"

#: ../../library/threading.rst:854
msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls whenever "
"practical."
msgstr "在大多数场合下相比手动的 :meth:`!acquire` 和 :meth:`release` 调用更为推荐。"

#: ../../library/threading.rst:858
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr "当被唤起时将 *blocking* 参数设为 ``True`` (默认值):"

#: ../../library/threading.rst:860 ../../library/threading.rst:872
msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr "如无任何线程持有锁，则获取锁并立即返回。"

#: ../../library/threading.rst:862
msgid ""
"If another thread owns the lock, block until we are able to acquire lock, or"
" *timeout*, if set to a positive float value."
msgstr "如有其他线程持有锁，则阻塞执行直至能够获取锁，或直至 *timeout*，如果将其设为一个正浮点数值的话。"

#: ../../library/threading.rst:865
msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and "
":class:`!RLock`; :class:`Lock` handles this case the same as the previous, "
"blocking until the lock can be acquired."
msgstr ""
"如同一线程持有锁，则再次获取该锁，并立即返回。 这是 :class:`Lock` 和 :class:`!RLock` "
"之间的区别；:class:`Lock` 将以与之前相同的方式处理此情况，即阻塞执行直至能够获取锁。"

#: ../../library/threading.rst:870
msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "当被唤起时将 *blocking* 参数设为 ``False``:"

#: ../../library/threading.rst:874
msgid "If another thread owns the lock, return immediately."
msgstr "如有其他线程持有锁，则立即返回。"

#: ../../library/threading.rst:876
msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr "如同一线程持有锁，则再次获取该锁并立即返回。"

#: ../../library/threading.rst:879
msgid ""
"In all cases, if the thread was able to acquire the lock, return ``True``. "
"If the thread was unable to acquire the lock (i.e. if not blocking or the "
"timeout was reached) return ``False``."
msgstr "在所有情况下，如果线程能够获取锁，则返回 ``True``。 如果线程不能获取锁（即未阻塞执行或达到超时限制）则返回 ``False``。"

#: ../../library/threading.rst:883
msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""
"如果被多次调用，则未能调用相同次数的 :meth:`~RLock.release` 可能导致死锁。 请考虑将 :class:`!RLock` "
"用作上下文管理器而不是直接调用 acquire/release。"

#: ../../library/threading.rst:893
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it"
" is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。"

#: ../../library/threading.rst:899
msgid ""
"Only call this method when the calling thread owns the lock. A "
":exc:`RuntimeError` is raised if this method is called when the lock is not "
"acquired."
msgstr "只有在调用方线程持有锁时才能调用此方法。 如果在未获取锁的情况下调用此方法则会引发 :exc:`RuntimeError`。"

#: ../../library/threading.rst:908 ../../library/threading.rst:1007
msgid "Return a boolean indicating whether this object is locked right now."
msgstr "返回一个指明该对象目前是否被锁定的布尔值。"

#: ../../library/threading.rst:916
msgid "Condition objects"
msgstr "Condition 对象"

#: ../../library/threading.rst:918
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part"
" of the condition object: you don't have to track it separately."
msgstr ""
"条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。"

#: ../../library/threading.rst:923
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and "
":meth:`~Condition.release` methods also call the corresponding methods of "
"the associated lock."
msgstr ""
"条件变量遵循 :ref:`上下文管理协议 <with-locks>` ：使用 ``with`` 语句会在它包围的代码块内获取关联的锁。  "
":meth:`~Condition.acquire` 和 :meth:`~Condition.release` 方法也能调用关联锁的相关方法。"

#: ../../library/threading.rst:929
msgid ""
"Other methods must be called with the associated lock held.  The "
":meth:`~Condition.wait` method releases the lock, and then blocks until "
"another thread awakens it by calling :meth:`~Condition.notify` or "
":meth:`~Condition.notify_all`.  Once awakened, :meth:`~Condition.wait` re-"
"acquires the lock and returns.  It is also possible to specify a timeout."
msgstr ""
"其它方法必须在持有关联的锁的情况下调用。 :meth:`~Condition.wait` 方法释放锁，然后阻塞直到其它线程调用 "
":meth:`~Condition.notify` 方法或 :meth:`~Condition.notify_all` 方法唤醒它。一旦被唤醒， "
":meth:`~Condition.wait` 方法重新获取锁并返回。它也可以指定超时时间。"

#: ../../library/threading.rst:935
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for"
" the condition variable, if any are waiting.  The "
":meth:`~Condition.notify_all` method wakes up all threads waiting for the "
"condition variable."
msgstr ""
" :meth:`~Condition.notify` 方法唤醒正在等待此条件变量的线程之中的一个。 "
":meth:`~Condition.notify_all` 方法唤醒正在等待此条件变量的所有线程。"

#: ../../library/threading.rst:939
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"注意： :meth:`~Condition.notify` 方法和 :meth:`~Condition.notify_all` "
"方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 :meth:`~Condition.wait` 方法调用中返回，而是会在调用了 "
":meth:`~Condition.notify` 方法或 :meth:`~Condition.notify_all` "
"方法的线程最终放弃了锁的所有权后返回。"

#: ../../library/threading.rst:945
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call "
":meth:`~Condition.notify` or :meth:`~Condition.notify_all` when they change "
"the state in such a way that it could possibly be a desired state for one of"
" the waiters.  For example, the following code is a generic producer-"
"consumer situation with unlimited buffer capacity::"
msgstr ""
"使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 "
":meth:`~Condition.wait` "
"方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 "
":meth:`~Condition.notify` 方法或者 :meth:`~Condition.notify_all` "
"方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形："

#: ../../library/threading.rst:954
msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""
"# 消费一个条目\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# 生产一个条目\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"

#: ../../library/threading.rst:965
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and"
" the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The "
":meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"使用 ``while`` 循环检查所要求的条件成立与否是有必要的，因为 :meth:`~Condition.wait` "
"方法可能要经过不确定长度的时间后才会返回，而此时导致 :meth:`~Condition.notify` "
"方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 "
":meth:`~Condition.wait_for` 方法可自动化条件检查，并简化超时计算。"

#: ../../library/threading.rst:972
msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""
"# 消费一个条目\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"

#: ../../library/threading.rst:977
msgid ""
"To choose between :meth:`~Condition.notify` and "
":meth:`~Condition.notify_all`, consider whether one state change can be "
"interesting for only one or several waiting threads.  E.g. in a typical "
"producer-consumer situation, adding one item to the buffer only needs to "
"wake up one consumer thread."
msgstr ""
"选择 :meth:`~Condition.notify` 还是 :meth:`~Condition.notify_all` "
"，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。"

#: ../../library/threading.rst:985
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another "
"thread."
msgstr "实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。"

#: ../../library/threading.rst:988
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock`"
" or :class:`RLock` object, and it is used as the underlying lock.  "
"Otherwise, a new :class:`RLock` object is created and used as the underlying"
" lock."
msgstr ""
"如果给出了非 ``None`` 的 *lock* 参数，则它必须为 :class:`Lock` 或者 :class:`RLock` "
"对象，并且它将被用作底层锁。否则，将会创建新的 :class:`RLock` 对象，并将其用作底层锁。"

#: ../../library/threading.rst:992 ../../library/threading.rst:1122
#: ../../library/threading.rst:1168 ../../library/threading.rst:1220
#: ../../library/threading.rst:1288
msgid "changed from a factory function to a class."
msgstr "从工厂函数变为类。"

#: ../../library/threading.rst:997
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr "请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。"

#: ../../library/threading.rst:1002
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr "释放底层锁。此方法调用底层锁的相应方法。没有返回值。"

#: ../../library/threading.rst:1013
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not"
" acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr "等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 :exc:`RuntimeError` 异常。"

#: ../../library/threading.rst:1017
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs."
"  Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 :meth:`notify` 或 :meth:`notify_all` "
"唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。"

#: ../../library/threading.rst:1022
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr "当提供了 *timeout* 参数且不是 ``None`` 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。"

#: ../../library/threading.rst:1026
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its "
":meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"当底层锁是个 :class:`RLock` ，不会使用它的 :meth:`release` "
"方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 :class:`RLock` 类的内部接口，即使多次递归获取它也能解锁它。 "
"然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。"

#: ../../library/threading.rst:1034
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case"
" it is ``False``."
msgstr "返回 ``True`` ，除非提供的 *timeout* 过期，这种情况下返回 ``False``。"

#: ../../library/threading.rst:1037 ../../library/threading.rst:1253
msgid "Previously, the method always returned ``None``."
msgstr "在此之前，方法总是返回 ``None``。"

#: ../../library/threading.rst:1042
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"等待，直到条件计算为真。 *predicate* 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 *timeout* "
"参数给出最大等待时间。"

#: ../../library/threading.rst:1046
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"这个实用方法会重复地调用 :meth:`wait` 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 "
"``False`` 。"

#: ../../library/threading.rst:1051
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr "忽略超时功能，调用此方法大致相当于编写::"

#: ../../library/threading.rst:1054
msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""
"while not predicate():\n"
"    cv.wait()"

#: ../../library/threading.rst:1057
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr "因此，规则同样适用于 :meth:`wait` ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。"

#: ../../library/threading.rst:1065
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr "默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 :exc:`RuntimeError` 异常。"

#: ../../library/threading.rst:1069
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr "这个方法唤醒最多 *n* 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。"

#: ../../library/threading.rst:1072
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"当前实现中，如果至少有 *n* 个线程正在等待，准确唤醒 *n* 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 *n* 个线程。"

#: ../../library/threading.rst:1077
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call"
" until it can reacquire the lock.  Since :meth:`notify` does not release the"
" lock, its caller should."
msgstr ""
"注意：被唤醒的线程并没有真正恢复到它调用的 :meth:`wait` ，直到它可以重新获得锁。 因为 :meth:`notify` "
"不释放锁，其调用者才应该这样做。"

#: ../../library/threading.rst:1083
msgid ""
"Wake up all threads waiting on this condition.  This method acts like "
":meth:`notify`, but wakes up all waiting threads instead of one. If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"唤醒所有正在等待这个条件的线程。这个方法行为与 :meth:`notify` "
"相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 :exc:`RuntimeError` 异常。"

#: ../../library/threading.rst:1088
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "``notifyAll`` 方法是此方法的已弃用别名。"

#: ../../library/threading.rst:1094
msgid "Semaphore objects"
msgstr "Semaphore 对象"

#: ../../library/threading.rst:1096
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of "
":meth:`~Semaphore.acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 ``P()`` 和 "
"``V()`` 而不是 :meth:`~Semaphore.acquire` 和 :meth:`~Semaphore.release` ）。"

#: ../../library/threading.rst:1101
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`~Semaphore.acquire` call and incremented by each "
":meth:`~Semaphore.release` call.  The counter can never go below zero; when "
":meth:`~Semaphore.acquire` finds that it is zero, it blocks, waiting until "
"some other thread calls :meth:`~Semaphore.release`."
msgstr ""
"一个信号量管理一个内部计数器，该计数器因 :meth:`~Semaphore.acquire` 方法的调用而递减，因 "
":meth:`~Semaphore.release` 方法的调用而递增。 计数器的值永远不会小于零；当 "
":meth:`~Semaphore.acquire` 方法发现计数器为零时，将会阻塞，直到其它线程调用 "
":meth:`~Semaphore.release` 方法。"

#: ../../library/threading.rst:1107
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr "信号量对象也支持 :ref:`上下文管理协议 <with-locks>` 。"

#: ../../library/threading.rst:1112
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number of"
" :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative."
" If not given, *value* defaults to 1."
msgstr ""
"该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 :meth:`release` 方法的调用次数减去 :meth:`acquire` "
"的调用次数再加上一个初始值。如果需要， :meth:`acquire` 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 *value*"
" 的值时，默认为1。"

#: ../../library/threading.rst:1118
msgid ""
"The optional argument gives the initial *value* for the internal counter; it"
" defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` "
"is raised."
msgstr ""
"可选参数 *value* 赋予内部计数器初始值，默认值为 ``1`` 。如果 *value* 被赋予小于0的值，将会引发 "
":exc:`ValueError` 异常。"

#: ../../library/threading.rst:1127
msgid "Acquire a semaphore."
msgstr "获取一个信号量。"

#: ../../library/threading.rst:1129
msgid "When invoked without arguments:"
msgstr "在不带参数的情况下调用时："

#: ../../library/threading.rst:1131
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr "如果在进入时内部计数器的值大于零，则将其减一并立即返回 ``True``。"

#: ../../library/threading.rst:1133
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to "
":meth:`~Semaphore.release`.  Once awoken (and the counter is greater than "
"0), decrement the counter by 1 and return ``True``.  Exactly one thread will"
" be awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"如果在进入时内部计数器的值为零，则将会阻塞直到被对 :meth:`~Semaphore.release` 的调用唤醒。 一旦被唤醒（并且计数器的值大于 "
"0），则将计数器减 1 并返回 ``True``。 每次对 :meth:`~Semaphore.release` 的调用将只唤醒一个线程。 "
"线程被唤醒的次序是不可确定的。"

#: ../../library/threading.rst:1139
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do"
" the same thing as when called without arguments, and return ``True``."
msgstr ""
"当 *blocking* 设置为 ``False`` 时调用，不会阻塞。 如果没有参数的调用会阻塞，立即返回 "
"``False``；否则，做与无参数调用相同的事情时返回 ``True``。"

#: ../../library/threading.rst:1143
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most"
" *timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"当被唤起时如果 *timeout* 不为 ``None``，则它将阻塞最多 *timeout* 秒。 请求在此时段时未能成功完成获取则将返回 "
"``False``。 在其他情况下返回 ``True``。"

#: ../../library/threading.rst:1152
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr "释放一个信号量，将内部计数器的值增加 *n*。 当进入时值为零且有其他线程正在等待它再次变为大于零时，则唤醒那 *n* 个线程。"

#: ../../library/threading.rst:1156
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr "增加了 *n* 形参以一次性释放多个等待线程。"

#: ../../library/threading.rst:1162
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to"
" make sure its current value doesn't exceed its initial value.  If it does, "
":exc:`ValueError` is raised. In most situations semaphores are used to guard"
" resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 :exc:`ValueError` "
"异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， *value* 的值默认为1。"

#: ../../library/threading.rst:1175
msgid ":class:`Semaphore` example"
msgstr ":class:`Semaphore` 示例"

#: ../../library/threading.rst:1177
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource"
" is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。"

#: ../../library/threading.rst:1182
msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"

#: ../../library/threading.rst:1186
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr "工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法："

#: ../../library/threading.rst:1189
msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... 使用连接 ...\n"
"    finally:\n"
"        conn.close()"

#: ../../library/threading.rst:1196
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr "使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。"

#: ../../library/threading.rst:1203
msgid "Event objects"
msgstr "Event 对象"

#: ../../library/threading.rst:1205
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr "这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。"

#: ../../library/threading.rst:1208
msgid ""
"An event object manages an internal flag that can be set to true with the "
":meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"一个事件对象管理一个内部标识，调用 :meth:`~Event.set` 方法可将其设置为 true ，调用  :meth:`~Event.clear`"
" 方法可将其设置为 false ，调用 :meth:`~Event.wait` 方法将进入阻塞直到标识为 true 。"

#: ../../library/threading.rst:1215
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the "
":meth:`clear` method.  The :meth:`wait` method blocks until the flag is "
"true. The flag is initially false."
msgstr ""
"实现事件对象的类。事件对象管理一个内部标识，调用 :meth:`~Event.set` 方法可将其设置为true。调用  "
":meth:`~Event.clear` 方法可将其设置为 false 。调用 :meth:`~Event.wait` "
"方法将进入阻塞直到标识为true。这个标识初始时为 false 。"

#: ../../library/threading.rst:1225
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "当且仅当内部标识为 true 时返回 ``True`` 。"

#: ../../library/threading.rst:1227
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "``isSet`` 方法是此方法的已弃用别名。"

#: ../../library/threading.rst:1231
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are"
" awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"将内部标识设置为 true 。所有正在等待这个事件的线程将被唤醒。当标识为 true 时，调用 :meth:`wait` 方法的线程不会被被阻塞。"

#: ../../library/threading.rst:1237
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait`"
" will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"将内部标识设置为 false 。之后调用 :meth:`wait` 方法的线程将会被阻塞，直到调用 :meth:`.set` 方法将内部标识再次设置为 "
"true 。"

#: ../../library/threading.rst:1243
msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the internal flag did not "
"become true within the given wait time."
msgstr ""
"只要内部旗标为假值且未超出所给出的 timeout 值就保持阻塞。 返回值表示阻塞方法返回的原因；如果返回是因为内部旗标被设为真值则为 "
"``True``，或者如果给出了 timeout 值而内部旗标在给定的等待时间内没有变成真值则为 ``False``。"

#: ../../library/threading.rst:1249
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr "当提供了 timeout 参数且不为 ``None`` 时，它应当为一个指定操作的超时限制秒数的浮点值，也可以为分数。"

#: ../../library/threading.rst:1260
msgid "Timer objects"
msgstr "Timer 对象"

#: ../../library/threading.rst:1262
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of "
":class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"此类表示一个操作应该在等待一定的时间之后运行 --- 相当于一个定时器。 :class:`Timer` 类是 :class:`Thread` "
"类的子类，因此可以像一个自定义线程一样工作。"

#: ../../library/threading.rst:1266
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"与线程一样，定时器也是通过调用其 :meth:`Timer.start <Thread.start>` 方法来启动的。 定时器可以通过调用 "
":meth:`~Timer.cancel` 方法来停止（在其动作开始之前）。 定时器在执行其行动之前要等待的时间间隔可能与用户指定的时间间隔不完全相同。"

#: ../../library/threading.rst:1272
msgid "For example::"
msgstr "例如："

#: ../../library/threading.rst:1274
msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # 30 秒之后，将打印 \"hello, world\""

#: ../../library/threading.rst:1283
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"创建一个定时器，在经过 *interval* 秒的间隔事件后，将会用参数 *args* 和关键字参数 *kwargs* 调用 *function*。如果"
" *args* 为 ``None`` （默认值），则会使用一个空列表。如果 *kwargs* 为 ``None`` （默认值），则会使用一个空字典。"

#: ../../library/threading.rst:1293
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr "停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。"

#: ../../library/threading.rst:1298
msgid "Barrier objects"
msgstr "Barrier 对象"

#: ../../library/threading.rst:1302
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 :meth:`~Barrier.wait` "
"方法后将阻塞，直到所有线程都调用了 :meth:`~Barrier.wait` 方法。此时所有线程将被同时释放。"

#: ../../library/threading.rst:1308
msgid ""
"The barrier can be reused any number of times for the same number of "
"threads."
msgstr "栅栏对象可以被多次使用，但进程的数量不能改变。"

#: ../../library/threading.rst:1310
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr "这是一个使用简便的方法实现客户端进程与服务端进程同步的例子："

#: ../../library/threading.rst:1312
msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"

#: ../../library/threading.rst:1330
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"创建一个需要 *parties* 个线程的栅栏对象。如果提供了可调用的 *action* 参数，它会在所有线程被释放时在其中一个线程中自动调用。 "
"*timeout* 是默认的超时时间，如果没有在 :meth:`wait` 方法中指定超时时间的话。"

#: ../../library/threading.rst:1337
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 *timeout* 参数，这里的 *timeout* "
"参数优先于创建栅栏对象时提供的 *timeout* 参数。"

#: ../../library/threading.rst:1342
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"函数返回值是一个整数，取值范围在0到 *parties* -- "
"1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如："

#: ../../library/threading.rst:1346
msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # 只有一个线程需要打印此文本\n"
"    print(\"passed the barrier\")"

#: ../../library/threading.rst:1351
msgid ""
"If an *action* was provided to the constructor, one of the threads will have"
" called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr "如果创建栅栏对象时在构造函数中提供了 *action* 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。"

#: ../../library/threading.rst:1355
msgid "If the call times out, the barrier is put into the broken state."
msgstr "如果发生了超时，栅栏对象将进入破损态。"

#: ../../library/threading.rst:1357
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier"
" is broken or reset while a thread is waiting."
msgstr "如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 :class:`BrokenBarrierError` 异常。"

#: ../../library/threading.rst:1362
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr "重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 :class:`BrokenBarrierError` 异常。"

#: ../../library/threading.rst:1365
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr "请注意使用此函数时，如果存在状态未知的其他线程，则可能需要执行外部同步。 如果栅栏已损坏则最好将其废弃并新建一个。"

#: ../../library/threading.rst:1371
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls"
" to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for"
" example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"使栅栏处于损坏状态。 这将导致任何现有和未来对 :meth:`wait` 的调用失败并引发 :class:`BrokenBarrierError`。 "
"例如可以在需要中止某个线程时使用此方法，以避免应用程序的死锁。"

#: ../../library/threading.rst:1376
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr "更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。"

#: ../../library/threading.rst:1382
msgid "The number of threads required to pass the barrier."
msgstr "冲出栅栏所需要的线程数量。"

#: ../../library/threading.rst:1386
msgid "The number of threads currently waiting in the barrier."
msgstr "当前时刻正在栅栏中阻塞的线程数量。"

#: ../../library/threading.rst:1390
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "一个布尔值，值为 ``True`` 表明栅栏为破损态。"

#: ../../library/threading.rst:1395
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the "
":class:`Barrier` object is reset or broken."
msgstr ""
"异常类，是 :exc:`RuntimeError` 异常的子类，在 :class:`Barrier` 对象重置时仍有线程阻塞时和对象进入破损态时被引发。"

#: ../../library/threading.rst:1402
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "在 :keyword:`!with` 语句中使用锁、条件和信号量"

#: ../../library/threading.rst:1404
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered,"
" and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"本模块提供的所有具有 ``acquire`` 和 ``release`` 方法的对象都可用作 :keyword:`with` 语句的上下文管理器。 "
"进入语句块时将调用 ``acquire`` 方法，退出语句块时将调用 ``release`` 方法。 因此，下面的代码段::"

#: ../../library/threading.rst:1410
msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""
"with some_lock:\n"
"    # 执行某种操作..."

#: ../../library/threading.rst:1413
msgid "is equivalent to::"
msgstr "相当于::"

#: ../../library/threading.rst:1415
msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""
"some_lock.acquire()\n"
"try:\n"
"    # 执行某种操作...\n"
"finally:\n"
"    some_lock.release()"

#: ../../library/threading.rst:1421
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, "
":class:`Semaphore`, and :class:`BoundedSemaphore` objects may be used as "
":keyword:`with` statement context managers."
msgstr ""
"现在 :class:`Lock` 、 :class:`RLock` 、 :class:`Condition` 、 :class:`Semaphore` "
"和 :class:`BoundedSemaphore` 对象可以用作 :keyword:`with` 语句的上下文管理器。"

#: ../../library/threading.rst:222 ../../library/threading.rst:240
msgid "trace function"
msgstr "追踪函数"

#: ../../library/threading.rst:240
msgid "debugger"
msgstr "调试器"

#: ../../library/threading.rst:251 ../../library/threading.rst:269
msgid "profile function"
msgstr "性能分析函数"
