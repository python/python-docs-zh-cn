# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/socket.rst:2
msgid ":mod:`!socket` --- Low-level networking interface"
msgstr ":mod:`!socket` --- 低层级的网络接口"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**源代码:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr "这个模块提供了访问 BSD *套接字* 的接口。在所有现代 Unix 系统、Windows、macOS 和其他一些平台上可用。"

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr "一些行为可能因平台不同而异，因为调用的是操作系统的套接字API。"

#: ../../library/socket.rst:171 ../../library/socket.rst:181
#: ../../library/socket.rst:209 ../../library/socket.rst:216
#: ../../library/socket.rst:233 ../../library/socket.rst:383
#: ../../library/socket.rst:456 ../../library/socket.rst:470
#: ../../library/socket.rst:485 ../../library/socket.rst:496
#: ../../library/socket.rst:505 ../../library/socket.rst:514
#: ../../library/socket.rst:525 ../../library/socket.rst:537
#: ../../library/socket.rst:548 ../../library/socket.rst:561
#: ../../library/socket.rst:589 ../../library/socket.rst:601
#: ../../library/socket.rst:607 ../../library/socket.rst:638
#: ../../library/socket.rst:653 ../../library/socket.rst:662
#: ../../library/socket.rst:679 ../../library/socket.rst:694
#: ../../library/socket.rst:704 ../../library/socket.rst:893
#: ../../library/socket.rst:1018 ../../library/socket.rst:1034
#: ../../library/socket.rst:1047 ../../library/socket.rst:1062
#: ../../library/socket.rst:1079 ../../library/socket.rst:1090
#: ../../library/socket.rst:1101 ../../library/socket.rst:1112
#: ../../library/socket.rst:1201 ../../library/socket.rst:1221
#: ../../library/socket.rst:1247 ../../library/socket.rst:1270
#: ../../library/socket.rst:1299 ../../library/socket.rst:1310
#: ../../library/socket.rst:1337 ../../library/socket.rst:1354
#: ../../library/socket.rst:1371 ../../library/socket.rst:1385
#: ../../library/socket.rst:1436 ../../library/socket.rst:1483
#: ../../library/socket.rst:1497 ../../library/socket.rst:1517
#: ../../library/socket.rst:1564 ../../library/socket.rst:1609
#: ../../library/socket.rst:1734 ../../library/socket.rst:1778
#: ../../library/socket.rst:1886 ../../library/socket.rst:1904
#: ../../library/socket.rst:1988 ../../library/socket.rst:1998
#: ../../library/socket.rst:2010 ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模块在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不适用或不可用。 请参阅 "
":ref:`wasm-availability` 了解详情。"

#: ../../library/socket.rst:24
msgid ""
"The Python interface is a straightforward transliteration of the Unix system"
" call and library interface for sockets to Python's object-oriented style: "
"the :func:`~socket.socket` function returns a :dfn:`socket object` whose "
"methods implement the various socket system calls.  Parameter types are "
"somewhat higher-level than in the C interface: as with :meth:`read` and "
":meth:`write` operations on Python files, buffer allocation on receive "
"operations is automatic, and buffer length is implicit on send operations."
msgstr ""
"这个 Python 接口是将 Unix 系统调用和套接字库接口直接转写为 Python 的面向对象风格：函数 "
":func:`~socket.socket` 返回一个 :dfn:`套接字对象`，其方法是对各种套接字系统调用的实现。 形参类型相比 C "
"接口更高级一些：如同在 Python 文件上的 :meth:`read` 和 :meth:`write` "
"操作那样，接受操作的缓冲区分配是自动进行的，发送操作的缓冲区长度则是隐式的。"

#: ../../library/socket.rst:35
msgid "Module :mod:`socketserver`"
msgstr "模块 :mod:`socketserver`"

#: ../../library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "用于简化网络服务端编写的类。"

#: ../../library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "模块 :mod:`ssl`"

#: ../../library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "套接字对象的TLS/SSL封装。"

#: ../../library/socket.rst:43
msgid "Socket families"
msgstr "套接字协议族"

#: ../../library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr "根据系统以及构建选项，此模块提供了各种套接字协议簇。"

#: ../../library/socket.rst:48
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr "特定的套接字对象需要的地址格式将根据此套接字对象被创建时指定的地址族被自动选择。套接字地址表示如下："

#: ../../library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's"
" abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to"
" deal with both types of address.  A string or bytes-like object can be used"
" for either type of address when passing it as an argument."
msgstr ""
"一个绑定在文件系统节点上的 :const:`AF_UNIX` 套接字的地址表示为一个字符串，使用文件系统字符编码和 "
"``'surrogateescape'`` 错误回调方法（see :pep:`383`）。一个地址在 Linux 的抽象命名空间被返回为带有初始的 "
"null 字节的 :term:`字节类对象 <bytes-like object>` "
"；注意在这个命名空间种的套接字可能与普通文件系统套接字通信，所以打算运行在 Linux "
"上的程序可能需要解决两种地址类型。当传递为参数时，一个字符串或字节类对象可以用于任一类型的地址。"

#: ../../library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 "
"encoding."
msgstr "之前，:const:`AF_UNIX` 套接字路径被假设使用 UTF-8 编码。"

#: ../../library/socket.rst:66 ../../library/socket.rst:1184
#: ../../library/socket.rst:1226 ../../library/socket.rst:1982
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "现在接受可写的 :term:`字节类对象 <bytes-like object>`。"

#: ../../library/socket.rst:71
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"一对 ``(host, port)`` 被用作 :const:`AF_INET` 地址族，其中 *host* 是一个表示互联网域名标记形式的主机名例如 "
"``'daring.cwi.nl'`` 或者 IPv4 地址例如 ``'100.50.200.5'`` 的字符串，而 *port* 是一个整数值。"

#: ../../library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all"
" interfaces, and the string ``'<broadcast>'`` represents "
":const:`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, "
"therefore, you may want to avoid these if you intend to support IPv6 with "
"your Python programs."
msgstr ""
"对于 IPv4 地址，有两种可接受的特殊形式被用来代替一个主机地址： ``''`` 代表 "
":const:`INADDR_ANY`，用来绑定到所有接口；字符串 ``'<broadcast>'`` 代表 "
":const:`INADDR_BROADCAST`。此行为不兼容 IPv6，因此，如果你的 Python 程序打算支持 IPv6，则可能需要避开这些。"

#: ../../library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"对于 :const:`AF_INET6` 地址族，使用一个四元组 ``(host, port, flowinfo, scope_id)``，其中 "
"*flowinfo* 和 *scope_id* 代表了 C 库 :const:`struct sockaddr_in6` 中的 "
"``sin6_flowinfo`` 和 ``sin6_scope_id`` 成员。对于 :mod:`socket` 模块中的方法， *flowinfo*"
" 和 *scope_id* 可以被省略，只为了向后兼容。注意，省略 *scope_id* 可能会导致操作带有领域 (Scope) 的 IPv6 "
"地址时出错。"

#: ../../library/socket.rst:90
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous"
" and may be safely omitted (recommended)."
msgstr ""
"对于多播地址（其 *scope_id* 起作用），*地址* 中可以不包含 ``%scope_id`` （或 ``zone id`` "
"）部分，这部分是多余的，可以放心省略（推荐）。"

#: ../../library/socket.rst:95
msgid ""
":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` 套接字由一对 ``(pid, groups)`` 表示。"

#: ../../library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"指定 :const:`AF_TIPC` 地址族可以使用仅 Linux 支持的 TIPC 协议。TIPC 是一种开放的、非基于 IP "
"的网络协议，旨在用于集群计算环境。其地址用元组表示，其中的字段取决于地址类型。一般元组形式为 ``(addr_type, v1, v2, v3 [, "
"scope])``，其中："

#: ../../library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* 取 :const:`TIPC_ADDR_NAMESEQ`、:const:`TIPC_ADDR_NAME` 或 "
":const:`TIPC_ADDR_ID` 中的一个。"

#: ../../library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, and"
" :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* 取 :const:`TIPC_ZONE_SCOPE`、:const:`TIPC_CLUSTER_SCOPE` 和 "
":const:`TIPC_NODE_SCOPE` 中的一个。"

#: ../../library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"如果 *addr_type* 为 :const:`TIPC_ADDR_NAME`，那么 *v1* 是服务器类型，*v2* 是端口标识符，*v3* 应为 "
"0。"

#: ../../library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"如果 *addr_type* 为 :const:`TIPC_ADDR_NAMESEQ`，那么 *v1* 是服务器类型，*v2* 是端口号下限，而 "
"*v3* 是端口号上限。"

#: ../../library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"如果 *addr_type* 为 :const:`TIPC_ADDR_ID`，那么 *v1* 是节点 (node)，*v2* 是 ref，*v3* 应为"
" 0。"

#: ../../library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets"
" from all network interfaces of this family."
msgstr ""
":const:`AF_CAN` 地址族使用元组 ``(interface, )``，其中 *interface* 是表示网络接口名称的字符串，如 "
"``'can0'``。网络接口名 ``''`` 可以用于接收本族所有网络接口的数据包。"

#: ../../library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
":const:`CAN_ISOTP` 协议接受一个元组 ``(interface, rx_addr, "
"tx_addr)``，其中两个额外参数都是无符号长整数，都表示 CAN 标识符（标准或扩展标识符）。"

#: ../../library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)``"
" where additional parameters are 64-bit unsigned integer representing the "
"ECU name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
":const:`CAN_J1939` 协议接受一个元组 ``(interface, name, pgn, addr)``，其中额外参数有：表示 ECU "
"名称的 64 位无符号整数，表示参数组号 (Parameter Group Number, PGN) 的 32 位无符号整数，以及表示地址的 8 "
"位整数。"

#: ../../library/socket.rst:129
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL`"
" protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
":const:`PF_SYSTEM` 协议族的 :const:`SYSPROTO_CONTROL` 协议使用一个字符串或元组 ``(id, "
"unit)``。 这个字符串是使用动态分配 ID 的内核控件名称。 如果 ID 和内核控件的单元编号都已知或者使用了已注册的 ID 则可以使用元组。"

#: ../../library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` 支持以下协议和地址格式："

#: ../../library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` 接受 ``(bdaddr, psm)``，其中 ``bdaddr`` "
"为字符串格式的蓝牙地址，``psm`` 是一个整数。"

#: ../../library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` 接受 ``(bdaddr, channel)``，其中 ``bdaddr`` "
"为字符串格式的蓝牙地址，``channel`` 是一个整数。"

#: ../../library/socket.rst:146
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while"
" everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` 接受 ``(device_id,)``，其中 ``device_id`` "
"为整数或字符串，它表示接口对应的蓝牙地址（具体取决于你的系统，NetBSD 和 DragonFlyBSD 需要蓝牙地址字符串，其他系统需要整数）。"

#: ../../library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "添加了对 NetBSD 和 DragonFlyBSD 的支持。"

#: ../../library/socket.rst:154
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes`"
" object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` 接受 ``bdaddr``，其中 ``bdaddr`` 是 :class:`bytes` "
"对象，其中含有字符串格式的蓝牙地址（如 ``b'12:23:34:45:56:67'`` ），FreeBSD 不支持此协议。"

#: ../../library/socket.rst:159
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` 是一个仅 Linux 可用的、基于套接字的接口，用于连接内核加密算法。算法套接字可用包括 2 至 4 个元素的元组来配置"
" ``(type, name [, feat [, mask]])``，其中："

#: ../../library/socket.rst:163
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr "*type* 是表示算法类型的字符串，如 ``aead``、``hash``、``skcipher`` 或 ``rng``。"

#: ../../library/socket.rst:166
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* 是表示算法类型和操作模式的字符串，如 ``sha256``、``hmac(sha256)``、``cbc(aes)`` 或 "
"``drbg_nopr_ctr_aes256``。"

#: ../../library/socket.rst:169
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* 和 *mask* 是无符号 32 位整数。"

#: ../../library/socket.rst:173
msgid "Some algorithm types require more recent Kernels."
msgstr "某些算法类型需要更新的内核。"

#: ../../library/socket.rst:177
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` 用于支持虚拟机与宿主机之间的通讯。该套接字用 ``(CID, port)`` 元组表示，其中 Context ID "
"(CID) 和 port 都是整数。"

#: ../../library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr "参见 :manpage:`vsock(7)`"

#: ../../library/socket.rst:187
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The"
" addresses are represented by the tuple ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` 是一个直接连接网络设备的低层级接口。 地址以元组 ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])`` 表示，其中："

#: ../../library/socket.rst:191
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - 指定设备名称的字符串。"

#: ../../library/socket.rst:192
msgid ""
"*proto* - The Ethernet protocol number. May be :data:`ETH_P_ALL` to capture "
"all protocols, one of the :ref:`ETHERTYPE_* constants <socket-ethernet-"
"types>` or any other Ethernet protocol number."
msgstr ""
"*proto* - 以太网协议号。 可以为 :data:`ETH_P_ALL` 表示捕获所有协议，某个 :ref:`ETHERTYPE_* 常量 "
"<socket-ethernet-types>` 或者任何其他以太网协议号。"

#: ../../library/socket.rst:196
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - 指定数据包类型的整数（可选）："

#: ../../library/socket.rst:198
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST`` （默认） - 寻址到本地主机的数据包。"

#: ../../library/socket.rst:199
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - 物理层广播的数据包。"

#: ../../library/socket.rst:200
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr "``PACKET_MULTICAST`` - 发送到物理层多播地址的数据包。"

#: ../../library/socket.rst:201
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr "``PACKET_OTHERHOST`` - 被（处于混杂模式的）网卡驱动捕获的、发送到其他主机的数据包。"

#: ../../library/socket.rst:203
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr "``PACKET_OUTGOING`` - 来自本地主机的、回环到一个套接字的数据包。"

#: ../../library/socket.rst:205
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* - 可选整数，指定 ARP 硬件地址类型。"

#: ../../library/socket.rst:206
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr "*addr* - 可选的类字节串对象，用于指定硬件物理地址，其解释取决于各设备。"

#: ../../library/socket.rst:211
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating"
" with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` 是一个仅 Linux 可用的、基于套接字的接口，用于与高通平台中协处理器上运行的服务进行通信。该地址簇用一个 "
"``(node, port)`` 元组表示，其中 *node* 和 *port* 为非负整数。"

#: ../../library/socket.rst:220
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little"
" of their data. In both cases ``length`` should be in ``range(8, 2**16, "
"8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` 是一种 UDP "
"的变体，允许指定数据包的哪一部分计算入校验码内。它添加了两个可以修改的套接字选项。``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` 修改传出数据包的哪一部分计算入校验码内，而 "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` "
"将过滤掉计算入校验码的数据太少的数据包。在这两种情况下，``length`` 都应在 ``range(8, 2**16, 8)`` 范围内。"

#: ../../library/socket.rst:229
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"对于 IPv4，应使用 ``socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE)`` 来构造这样的套接字；对于 "
"IPv6，应使用 ``socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE)`` 来构造这样的套接字。"

#: ../../library/socket.rst:237
msgid ""
":const:`AF_HYPERV` is a Windows-only socket based interface for "
"communicating with Hyper-V hosts and guests. The address family is "
"represented as a ``(vm_id, service_id)`` tuple where the ``vm_id`` and "
"``service_id`` are UUID strings."
msgstr ""
":const:`AF_HYPERV` 是 Windows 专属的用于同 Hyper-V 主机和客户机通信的基于套接字的接口。 其地址族以一个 "
"``(vm_id, service_id)`` 元组表示，其中 ``vm_id`` 和 ``service_id`` 均为 UUID 字符串。"

#: ../../library/socket.rst:242
msgid ""
"The ``vm_id`` is the virtual machine identifier or a set of known VMID "
"values if the target is not a specific virtual machine. Known VMID constants"
" defined on ``socket`` are:"
msgstr ""
"``vm_id`` 为虚拟机标识号或者如果目标不是一台特定的虚拟机则为已知 VMID 值的集合。 在 ``socket`` 上定义的已知 VMID "
"常量有:"

#: ../../library/socket.rst:246
msgid "``HV_GUID_ZERO``"
msgstr "``HV_GUID_ZERO``"

#: ../../library/socket.rst:247
msgid "``HV_GUID_BROADCAST``"
msgstr "``HV_GUID_BROADCAST``"

#: ../../library/socket.rst:248
msgid ""
"``HV_GUID_WILDCARD`` - Used to bind on itself and accept connections from "
"all partitions."
msgstr "``HV_GUID_WILDCARD`` - 用于绑定自身并接受来自所有分区的连接。"

#: ../../library/socket.rst:250
msgid ""
"``HV_GUID_CHILDREN`` - Used to bind on itself and accept connection from "
"child partitions."
msgstr "``HV_GUID_CHILDREN`` - 用于绑定自身并接受来自子分区的连接。"

#: ../../library/socket.rst:252
msgid "``HV_GUID_LOOPBACK`` - Used as a target to itself."
msgstr "``HV_GUID_LOOPBACK`` - 用作指向自身的目标。"

#: ../../library/socket.rst:253
msgid ""
"``HV_GUID_PARENT`` - When used as a bind accepts connection from the parent "
"partition. When used as an address target it will connect to the parent "
"partition."
msgstr ""
"``HV_GUID_PARENT`` - 当用作绑定时接受来自父分区的连接。 当用作地址目标时它将连接到父分区。will connect to the "
"parent partition."

#: ../../library/socket.rst:256
msgid ""
"The ``service_id`` is the service identifier of the registered service."
msgstr "``service_id`` 是已注册服务的服务标识号。"

#: ../../library/socket.rst:260
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"如果你在 IPv4/v6 套接字地址的 *host* 部分中使用了一个主机名，此程序可能会表现不确定行为，因为 Python 使用 DNS "
"解析返回的第一个地址。套接字地址在实际的 IPv4/v6 中以不同方式解析，根据 DNS 解析和/或 host 配置。为了确定行为，在 *host* "
"部分中使用数字的地址。"

#: ../../library/socket.rst:267
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"所有错误都会引发异常。 普通异常将针对无效的参数类型和内存不足等情况被引发。 与套接字或地址语义有关的错误则会引发 :exc:`OSError` "
"或它的某个子类。"

#: ../../library/socket.rst:272
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through "
":meth:`~socket.settimeout`."
msgstr ""
"可以用 :meth:`~socket.setblocking` 设置非阻塞模式。一个基于超时的 generalization 通过 "
":meth:`~socket.settimeout` 支持。"

#: ../../library/socket.rst:278
msgid "Module contents"
msgstr "模块内容"

#: ../../library/socket.rst:280
msgid "The module :mod:`socket` exports the following elements."
msgstr ":mod:`socket` 模块包含下列元素。"

#: ../../library/socket.rst:284
msgid "Exceptions"
msgstr "异常"

#: ../../library/socket.rst:288
msgid "A deprecated alias of :exc:`OSError`."
msgstr "一个被弃用的 :exc:`OSError` 的别名。"

#: ../../library/socket.rst:290
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr "根据 :pep:`3151`，这个类是 :exc:`OSError` 的别名。"

#: ../../library/socket.rst:296
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including "
":func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value "
"is a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
":exc:`OSError` 的子类，本异常通常表示与地址相关的错误，比如那些在 POSIX C API 中使用了 *h_errno* 的函数，包括 "
":func:`gethostbyname_ex` 和 :func:`gethostbyaddr`。附带的值是一对 ``(h_errno, "
"string)``，代表库调用返回的错误。*h_errno* 是一个数字，而 *string* 表示 *h_errno* 的描述，它们由 C 函数 "
":c:func:`hstrerror` 返回。"

#: ../../library/socket.rst:304 ../../library/socket.rst:317
#: ../../library/socket.rst:330
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "此类是 :exc:`OSError` 的子类。"

#: ../../library/socket.rst:309
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`!EAI_\\*` constants defined in this module."
msgstr ""
":exc:`OSError` 的子类，该异常由 :func:`getaddrinfo` 和 :func:`getnameinfo` "
"引发以表示与地址相关的错误。 附带的值是一个 ``(error, string)`` 对，代表库调用所返回的错误。 *string* 代表 "
"*error* 的描述，如 :c:func:`gai_strerror` C 函数所返回的值。 数字值 *error* 将与本模块中定义的某个 "
":const:`!EAI_\\*` 常量相匹配。"

#: ../../library/socket.rst:322
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr ":exc:`TimeoutError` 的已被弃用的别名。"

#: ../../library/socket.rst:324
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs"
" on a socket which has had timeouts enabled via a prior call to "
":meth:`~socket.settimeout` (or implicitly through "
":func:`~socket.setdefaulttimeout`).  The accompanying value is a string "
"whose value is currently always \"timed out\"."
msgstr ""
":exc:`OSError` 的子类，当套接字发生超时，且事先已调用过 :meth:`~socket.settimeout` （或隐式地通过 "
":func:`~socket.setdefaulttimeout` ）启用了超时，则会抛出此异常。附带的值是一个字符串，其值总是 \"timed "
"out\"。"

#: ../../library/socket.rst:333
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "这个类是 :exc:`TimeoutError` 的别名。"

#: ../../library/socket.rst:338
msgid "Constants"
msgstr "常量"

#: ../../library/socket.rst:340
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and "
":class:`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"AF_* 和 SOCK_* 常量现在都在 :class:`AddressFamily` 和 :class:`SocketKind` 这两个 "
":class:`.IntEnum` 集合内。"

#: ../../library/socket.rst:349
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`~socket.socket`.  If the :const:`AF_UNIX` constant "
"is not defined then this protocol is unsupported.  More constants may be "
"available depending on the system."
msgstr ""
"这些常量表示地址（和协议）族，被用作传给 :func:`~socket.socket` 的第一个参数。 如果 :const:`AF_UNIX` "
"常量未定义则该协议将不受支持。 根据具体系统可能会有更多的常量可用。"

#: ../../library/socket.rst:356
msgid ""
":const:`AF_UNSPEC` means that :func:`getaddrinfo` should return socket "
"addresses for any address family (either IPv4, IPv6, or any other) that can "
"be used."
msgstr ""
":const:`AF_UNSPEC` 表示 :func:`getaddrinfo` 应当为任何可被使用的地址族返回套接字地址（无论是 IPv4, "
"IPv6 还是其他）。"

#: ../../library/socket.rst:366
msgid ""
"These constants represent the socket types, used for the second argument to "
":func:`~socket.socket`.  More constants may be available depending on the "
"system. (Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be "
"generally useful.)"
msgstr ""
"这些常量表示套接字类型，被用作传给 :func:`~socket.socket` 的第二个参数。 根据具体系统可能会有更多的常量可用。 （只有 "
":const:`SOCK_STREAM` 和 :const:`SOCK_DGRAM` 是普遍适用的。）"

#: ../../library/socket.rst:374
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr "这两个常量（如果已定义）可以与上述套接字类型结合使用，允许你设置这些原子性相关的 flags （从而避免可能的竞争条件和单独调用的需要）。"

#: ../../library/socket.rst:380
msgid ""
"`Secure File Descriptor Handling "
"<https://udrepper.livejournal.com/20407.html>`_ for a more thorough "
"explanation."
msgstr "`安全文件描述符处理 <https://udrepper.livejournal.com/20407.html>`_ 提供了更详尽的解释。"

#: ../../library/socket.rst:404
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`~socket.setsockopt` and "
":meth:`~socket.getsockopt` methods of socket objects.  In most cases, only "
"those symbols that are defined in the Unix header files are defined; for a "
"few symbols, default values are provided."
msgstr ""
"许多这样的常量，记录在 Unix 有关套接字和/或 IP 协议的文档中，也在 socket 模块中有定义。 它们通常被用于传给套接字对象的 "
":meth:`~socket.setsockopt` 和 :meth:`~socket.getsockopt` 等方法的参数中。 "
"在大多数情况下，只有那些在 Unix 头文件中有定义的符号会在本模块中定义；对于部分符号，还提供了默认值。"

#: ../../library/socket.rst:411
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"添加了 ``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION``。"

#: ../../library/socket.rst:415
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr "在 Windows 上，如果 Windows 运行时支持，则 ``TCP_FASTOPEN``、``TCP_KEEPCNT`` 可用。"

#: ../../library/socket.rst:419
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "添加了 ``TCP_NOTSENT_LOWAT``。"

#: ../../library/socket.rst:422
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr "在 Windows 上，如果 Windows 运行时支持，则 ``TCP_KEEPIDLE``、``TCP_KEEPINTVL`` 可用。"

#: ../../library/socket.rst:425
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"添加了 ``IP_RECVTOS``。 还添加了 ``TCP_KEEPALIVE``。 这个常量在 MacOS 上可以与在 Linux 上使用 "
"``TCP_KEEPIDLE`` 的相同方式被使用。"

#: ../../library/socket.rst:430
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"添加了 ``TCP_CONNECTION_INFO``。 在 MacOS 上此常量可以与在 Linux 和 BSD 上使用 ``TCP_INFO`` "
"的相同方式来使用。"

#: ../../library/socket.rst:434
msgid ""
"Added ``SO_RTABLE`` and ``SO_USER_COOKIE``. On OpenBSD and FreeBSD "
"respectively those constants can be used in the same way that ``SO_MARK`` is"
" used on Linux. Also added missing TCP socket options from Linux: "
"``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, "
"``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, "
"``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, ``TCP_CC_INFO``, "
"``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, ``TCP_ZEROCOPY_RECEIVE``, "
"``TCP_INQ``, ``TCP_TX_DELAY``. Added ``IP_PKTINFO``, ``IP_UNBLOCK_SOURCE``, "
"``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``."
msgstr ""
"增加了 ``SO_RTABLE`` 和 ``SO_USER_COOKIE``。 这些常量分别在 OpenBSD 和 FreeBSD 可按与 "
"``SO_MARK`` 在 Linux 上相同的方式被使用。 还增加了来自 Linux 的缺失的 TCP 套接字选项: ``TCP_MD5SIG``, "
"``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, ``TCP_REPAIR``, "
"``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, ``TCP_REPAIR_OPTIONS``, "
"``TCP_TIMESTAMP``, ``TCP_CC_INFO``, ``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, "
"``TCP_REPAIR_WINDOW``, ``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, "
"``TCP_MD5SIG_EXT``, ``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, "
"``TCP_ZEROCOPY_RECEIVE``, ``TCP_INQ``, ``TCP_TX_DELAY``。 增加了 ``IP_PKTINFO``,"
" ``IP_UNBLOCK_SOURCE``, ``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``。"

#: ../../library/socket.rst:453 ../../library/socket.rst:534
#: ../../library/socket.rst:558
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr "此列表内的许多常量，记载在 Linux 文档中，同时也定义在本 socket 模块中。"

#: ../../library/socket.rst:460
msgid "NetBSD support was added."
msgstr "添加了 NetBSD 支持。"

#: ../../library/socket.rst:466
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN 协议簇内的 CAN_BCM 是广播管理器（Bbroadcast Manager -- BCM）协议，广播管理器常量在 Linux "
"文档中有所记载，在本 socket 模块中也有定义。"

#: ../../library/socket.rst:473
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ":data:`CAN_BCM_CAN_FD_FRAME` 旗标仅在 Linux >= 4.8 时可用。"

#: ../../library/socket.rst:479
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"在 CAN_RAW 套接字中启用 CAN FD 支持，默认是禁用的。它使应用程序可以发送 CAN 和 CAN FD "
"帧。但是，从套接字读取时，也必须同时接受 CAN 和 CAN FD 帧。"

#: ../../library/socket.rst:483 ../../library/socket.rst:494
msgid "This constant is documented in the Linux documentation."
msgstr "此常量在 Linux 文档中有所记载。"

#: ../../library/socket.rst:491
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given"
" CAN filters are passed to user space."
msgstr "加入已应用的 CAN 过滤器，这样只有与所有 CAN 过滤器匹配的 CAN 帧才能传递到用户空间。"

#: ../../library/socket.rst:502
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol."
" ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN 协议簇中的 CAN_ISOTP 就是 ISO-TP (ISO 15765-2) 协议。ISO-TP 常量在 Linux 文档中有所记载。"

#: ../../library/socket.rst:511
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr "CAN 协议族中的 CAN_J1939 即 SAE J1939 协议。 J1939 常量记录在 Linux 文档中。"

#: ../../library/socket.rst:522
msgid ""
"These two constants, documented in the FreeBSD divert(4) manual page, are "
"also defined in the socket module."
msgstr "这两个常量，记录在 FreeBSD divert(4) 手册页中，同样已在 socket 模块中定义。"

#: ../../library/socket.rst:542
msgid ""
":data:`!ETH_P_ALL` can be used in the :class:`~socket.socket` constructor as"
" *proto* for the :const:`AF_PACKET` family in order to capture every packet,"
" regardless of protocol."
msgstr ""
":data:`!ETH_P_ALL` 可在 :class:`~socket.socket` 构造器中用作 :const:`AF_PACKET` 族的 "
"*proto* 以便捕获每个包，无论是使用什么协议。"

#: ../../library/socket.rst:546
msgid "For more information, see the :manpage:`packet(7)` manpage."
msgstr "要了解详情，请参阅 :manpage:`packet(7)` 手册页。"

#: ../../library/socket.rst:571
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Windows 的 WSAIoctl() 的常量。这些常量用于套接字对象的 :meth:`~socket.socket.ioctl` 方法的参数。"

#: ../../library/socket.rst:574 ../../library/socket.rst:1599
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "添加了 ``SIO_LOOPBACK_FAST_PATH``。"

#: ../../library/socket.rst:580
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr "TIPC 相关常量，与 C socket API 导出的常量一致。更多信息请参阅 TIPC 文档。"

#: ../../library/socket.rst:587
msgid "Constants for Linux Kernel cryptography."
msgstr "用于 Linux 内核加密算法的常量。"

#: ../../library/socket.rst:599
msgid "Constants for Linux host/guest communication."
msgstr "用于 Linux 宿主机/虚拟机通讯的常量。"

#: ../../library/socket.rst:613
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr "本常量为一个布尔值，该值指示当前平台是否支持 IPv6。"

#: ../../library/socket.rst:619
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"这些是字符串常量，包含蓝牙地址，这些地址具有特殊含义。例如，当用 :const:`BTPROTO_RFCOMM` 指定绑定套接字时， "
":const:`BDADDR_ANY` 表示“任何地址”。"

#: ../../library/socket.rst:628
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"与 :const:`BTPROTO_HCI` 一起使用。 :const:`HCI_FILTER` 在 NetBSD 或 DragonFlyBSD "
"上不可用。 :const:`HCI_TIME_STAMP` 和 :const:`HCI_DATA_DIR` 在 FreeBSD、NetBSD 或 "
"DragonFlyBSD 上不可用。"

#: ../../library/socket.rst:635
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr "高通 IPC 路由协议的常数，用于与提供远程处理器的服务进行通信。"

#: ../../library/socket.rst:644
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS 和 LOCAL_CREDS_PERSISTENT 可与 SOCK_DGRAM, SOCK_STREAM 套接字一起使用，等价于 "
"Linux/DragonFlyBSD SO_PASSCRED，其中 LOCAL_CREDS "
"会在首次读取时发送凭证，LOCAL_CREDS_PERSISTENT 会在每次读取时发送，随后必须为后者使用 SCM_CREDS2 作为消息类型。"

#: ../../library/socket.rst:657
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with "
":data:`SO_REUSEPORT`."
msgstr "用于优化 CPU 定位的常量，应与 :data:`SO_REUSEPORT` 配合使用。"

#: ../../library/socket.rst:677
msgid "Constants for Windows Hyper-V sockets for host/guest communications."
msgstr "用于 Windows Hyper-V 宿主机/客户机通信的套接字的常量。"

#: ../../library/socket.rst:690
msgid ""
"`IEEE 802.3 protocol number "
"<https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt>`_. "
"constants."
msgstr ""
"`IEEE 802.3 协议号 "
"<https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt>`_ "
"常量。"

#: ../../library/socket.rst:702
msgid ""
"These constants are used by the :meth:`~socket.socket.shutdown` method of "
"socket objects."
msgstr "这些常量将由套接字对象的 :meth:`~socket.socket.shutdown` 方法使用。"

#: ../../library/socket.rst:707
msgid "Functions"
msgstr "函数"

#: ../../library/socket.rst:710
msgid "Creating sockets"
msgstr "创建套接字"

#: ../../library/socket.rst:712
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "下列函数都能创建 :ref:`套接字对象 <socket-objects>`."

#: ../../library/socket.rst:717
msgid ""
"Create a new socket using the given address family, socket type and protocol"
" number.  The address family should be :const:`AF_INET` (the default), "
":const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or"
" :const:`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the "
"default), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other"
" ``SOCK_`` constants. The protocol number is usually zero and may be omitted"
" or in the case where the address family is :const:`AF_CAN` the protocol "
"should be one of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or "
":const:`CAN_J1939`."
msgstr ""
"使用给定的地址族、套接字类型和协议号创建一个新的套接字。 地址族应为 :const:`AF_INET` (默认值), "
":const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET` 或 "
":const:`AF_RDS` 之一。 套接字类型应为 :const:`SOCK_STREAM` (默认值), :const:`SOCK_DGRAM`,"
" :const:`SOCK_RAW` 或其他可能的 ``SOCK_`` 常量之一。 协议号通常为零并且可以省略，或在协议族为 "
":const:`AF_CAN` 的情况下，协议应为 :const:`CAN_RAW`, :const:`CAN_BCM`, "
":const:`CAN_ISOTP` 或 :const:`CAN_J1939` 之一。"

#: ../../library/socket.rst:727
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto*"
" arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike "
":func:`socket.fromfd`, *fileno* will return the same socket and not a "
"duplicate. This may help close a detached socket using :meth:`socket.close`."
msgstr ""
"如果指定了 *fileno*，那么将从指定的文件描述符中自动检测 *family*, *type* 和 *proto* 的值。 "
"自动检测可被调用此函数时显式传入的 *family*, *type* 或 *proto* 参数所覆盖。 这只会影响 Python 表示诸如 "
":meth:`socket.getpeername` 函数的返回值的方式而不会影响实际的 OS 资源。 与 :func:`socket.fromfd` "
"不同，*fileno* 将返回同样的套接字而不是其副本。 这将有助于使用 :meth:`socket.close` 来关闭已分离的套接字。"

#: ../../library/socket.rst:736 ../../library/socket.rst:882
#: ../../library/socket.rst:1418 ../../library/socket.rst:1512
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新创建的套接字是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/socket.rst:738
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments"
" ``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.__new__`` 并附带参数 ``self``, ``family``, "
"``type``, ``protocol``。"

#: ../../library/socket.rst:740
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "添加了 AF_CAN 簇。添加了 AF_RDS 簇。"

#: ../../library/socket.rst:744
msgid "The CAN_BCM protocol was added."
msgstr "添加了 CAN_BCM 协议。"

#: ../../library/socket.rst:747 ../../library/socket.rst:884
msgid "The returned socket is now non-inheritable."
msgstr "返回的套接字现在是不可继承的。"

#: ../../library/socket.rst:750
msgid "The CAN_ISOTP protocol was added."
msgstr "添加了 CAN_ISOTP 协议。"

#: ../../library/socket.rst:753
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  "
"Therefore,"
msgstr ""
"当将 :const:`SOCK_NONBLOCK` 或 :const:`SOCK_CLOEXEC` 旗标位应用于 *type* 时它们将被清除，且 "
":attr:`socket.type` 将不会反映它们。 它们仍然会被传递给底层的系统 ``socket()`` 调用。 因而，"

#: ../../library/socket.rst:761
msgid ""
"sock = socket.socket(\n"
"    socket.AF_INET,\n"
"    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)"
msgstr ""
"sock = socket.socket(\n"
"    socket.AF_INET,\n"
"    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)"

#: ../../library/socket.rst:765
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"仍将在支持 ``SOCK_NONBLOCK`` 的系统上创建一个非阻塞的套接字，但是 ``sock.type`` 会被置为 "
"``socket.SOCK_STREAM``。"

#: ../../library/socket.rst:769
msgid "The CAN_J1939 protocol was added."
msgstr "添加了 CAN_J1939 协议。"

#: ../../library/socket.rst:772
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "添加了 IPPROTO_MPTCP 协议。"

#: ../../library/socket.rst:777
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol"
" number are as for the :func:`~socket.socket` function above. The default "
"family is :const:`AF_UNIX` if defined on the platform; otherwise, the "
"default is :const:`AF_INET`."
msgstr ""
"使用给定的地址族、套接字类型和协议号构建一对已连接的套接字对象。 地址族、套接字类型和协议号与上述 :func:`~socket.socket` "
"函数中的相同。 默认地址族为定义于平台中的 :const:`AF_UNIX`；如未定义，则默认为 :const:`AF_INET`。"

#: ../../library/socket.rst:782
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "新创建的套接字都是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/socket.rst:784
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr "现在，返回的套接字对象支持全部套接字 API，而不是全部 API 的一个子集。"

#: ../../library/socket.rst:788
msgid "The returned sockets are now non-inheritable."
msgstr "返回的套接字现在都是不可继承的。"

#: ../../library/socket.rst:791
msgid "Windows support added."
msgstr "添加了 Windows 支持。"

#: ../../library/socket.rst:797
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and"
" then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"连接到一个在互联网 *address* (以 ``(host, port)`` 2 元组表示) 上侦听的 TCP 服务，并返回套接字对象。 这是一个相比"
" :meth:`socket.connect` 层级更高的函数：如果 *host* 是非数字的主机名，它将尝试将其解析为 :data:`AF_INET`"
" 和 :data:`AF_INET6`，然后依次尝试连接到所有可能的地址直到连接成功。 这使编写兼容 IPv4 和 IPv6 的客户端变得很容易。"

#: ../../library/socket.rst:805
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is "
"used."
msgstr ""
"传入可选参数 *timeout* 可以在套接字实例上设置超时（在尝试连接前）。如果未提供 *timeout*，则使用由 "
":func:`getdefaulttimeout` 返回的全局默认超时设置。"

#: ../../library/socket.rst:810
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"如果提供了 *source_address*，它必须为二元组 ``(host, port)``，以便套接字在连接之前绑定为其源地址。如果 host 或 "
"port 分别为 '' 或 0，则使用操作系统默认行为。"

#: ../../library/socket.rst:814
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"当无法创建连接时，将会引发一个异常。 在默认情况下，它将是来自列表中最后一个地址的异常。 如果 *all_errors* 为 "
"``True``，它将是一个包含所有尝试错误的 :exc:`ExceptionGroup`。"

#: ../../library/socket.rst:819
msgid "*source_address* was added."
msgstr "添加了*source_address* 参数"

#: ../../library/socket.rst:822
msgid "*all_errors* was added."
msgstr "添加了 *all_errors*。"

#: ../../library/socket.rst:828
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a "
"2-tuple ``(host, port)``) and returns the socket object."
msgstr "创建绑定到 *address* 的 TCP 套接字（一个 ``(host, port)`` 2 元组）并返回该套接字对象的便捷函数。"

#: ../../library/socket.rst:831
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default"
" reasonable value is chosen. *reuse_port* dictates whether to set the "
":data:`SO_REUSEPORT` socket option."
msgstr ""
"*family* 应当为 :data:`AF_INET` 或 :data:`AF_INET6`。 *backlog* 是传递给 "
":meth:`socket.listen` 的队列大小；当未指定时，将选择一个合理的默认值。 *reuse_port* 指定是否要设置 "
":data:`SO_REUSEPORT` 套接字选项。"

#: ../../library/socket.rst:836
msgid ""
"If *dualstack_ipv6* is true, *family* is :data:`AF_INET6` and the platform "
"supports it the socket will be able to accept both IPv4 and IPv6 "
"connections, else it will raise :exc:`ValueError`. Most POSIX platforms and "
"Windows are supposed to support this functionality. When this functionality "
"is enabled the address returned by :meth:`socket.getpeername` when an IPv4 "
"connection occurs will be an IPv6 address represented as an IPv4-mapped IPv6"
" address. If *dualstack_ipv6* is false it will explicitly disable this "
"functionality on platforms that enable it by default (e.g. Linux). This "
"parameter can be used in conjunction with :func:`has_dualstack_ipv6`:"
msgstr ""
"如果 *dualstack_ipv6* 为真值，*family* 为 :data:`AF_INET6` 并且平台支持则套接字将能同时接受 IPv4 和 "
"IPv6 连接，否则它将引发 :exc:`ValueError`。 大多数 POSIX 平台和 Windows 都应该支持此功能。 当此功能被启用时 "
":meth:`socket.getpeername` 在进行 IPv4 连接时返回的将是一个被表示为映射到 IPv4 的 IPv6 地址的 IPv6 "
"地址。 如果 *dualstack_ipv6* 为假值则它将在默认启用此功能的平台上（例如 Linux）显式禁用此功能。 该形参可与 "
":func:`has_dualstack_ipv6` 结合使用："

#: ../../library/socket.rst:849
msgid ""
"import socket\n"
"\n"
"addr = (\"\", 8080)  # all interfaces, port 8080\n"
"if socket.has_dualstack_ipv6():\n"
"    s = socket.create_server(addr, family=socket.AF_INET6, dualstack_ipv6=True)\n"
"else:\n"
"    s = socket.create_server(addr)"
msgstr ""
"import socket\n"
"\n"
"addr = (\"\", 8080)  # 所有接口，端口 8080\n"
"if socket.has_dualstack_ipv6():\n"
"    s = socket.create_server(addr, family=socket.AF_INET6, dualstack_ipv6=True)\n"
"else:\n"
"    s = socket.create_server(addr)"

#: ../../library/socket.rst:858
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to"
" immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"在 POSIX 平台上，设置 :data:`SO_REUSEADDR` 套接字选项是为了立即重用以前绑定在同一 *address* 上并保持 "
"TIME_WAIT 状态的套接字。"

#: ../../library/socket.rst:866
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr "如果平台支持创建 IPv4 和 IPv6 连接都可以处理的 TCP 套接字，则返回 ``True``。"

#: ../../library/socket.rst:873
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`~io.IOBase.fileno` method) and build a socket object from "
"the result.  Address family, socket type and protocol number are as for the "
":func:`~socket.socket` function above. The file descriptor should refer to a"
" socket, but this is not checked --- subsequent operations on the object may"
" fail if the file descriptor is invalid. This function is rarely needed, but"
" can be used to get or set socket options on a socket passed to a program as"
" standard input or output (such as a server started by the Unix inet "
"daemon).  The socket is assumed to be in blocking mode."
msgstr ""
"复制文件描述符 *fd* (由文件对象的 :meth:`~io.IOBase.fileno` 方法返回的整数) 并根据结果构建一个套接字对象。 "
"地址族、套接字类型和协议号与上述 :func:`~socket.socket` 函数中的相同。 文件描述符应指向一个套接字，但不会检查这一点 --- "
"如果文件描述符是无效的则对该对象的后续操作可能会失败。 本函数很少被用到，但在将套接字作为标准输入或输出传给给程序 (如 Unix inet "
"进程启动的服务器) 时可以用来获取或设置套接字选项。 套接字将被假定为阻塞模式。"

#: ../../library/socket.rst:890
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr "根据 :meth:`socket.share` 方法获得的数据实例化套接字。套接字将处于阻塞模式。"

#: ../../library/socket.rst:900
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr "这是一个 Python 类型对象，表示套接字对象的类型。它等同于 ``type(socket(...))``。"

#: ../../library/socket.rst:905
msgid "Other functions"
msgstr "其他功能"

#: ../../library/socket.rst:907
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ":mod:`socket` 模块还提供多种网络相关服务："

#: ../../library/socket.rst:912
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"关闭一个套接字文件描述符。它类似于 :func:`os.close`，但专用于套接字。在某些平台上（特别是在 Windows "
"上），:func:`os.close` 对套接字文件描述符无效。"

#: ../../library/socket.rst:920
msgid ""
"This function wraps the C function ``getaddrinfo`` of the underlying system."
msgstr "此函数对下层系统的 C 函数 ``getaddrinfo`` 进行了包装。"

#: ../../library/socket.rst:922
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host*"
" and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"将 *host*/*port* 参数转换为 5 元组的序列，其中包含创建（连接到某服务的）套接字所需的所有参数。*host* 是域名，是字符串格式的 "
"IPv4/v6 地址或 ``None``。*port* 是字符串格式的服务名称，如 ``'http'`` 、端口号（数字）或 ``None``。传入 "
"``None`` 作为 *host* 和 *port* 的值，相当于将 ``NULL`` 传递给底层 C API。"

#: ../../library/socket.rst:929
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to provide options and limit the list of addresses returned. Pass "
"their default values (:data:`AF_UNSPEC`, 0, and 0, respectively) to not "
"limit the results. See the note below for details."
msgstr ""
"可以选择指定 *family*, *type* 和 *proto* 参数以提供选项并对所返回的地址列表进行限制。 为其传入默认值（分别为 "
":data:`AF_UNSPEC`, 0 和 0）则不会对结果进行限制。 请参阅下面的注释了解详情。"

#: ../../library/socket.rst:934
msgid ""
"The *flags* argument can be one or several of the ``AI_*`` constants, and "
"will influence how results are computed and returned. For example, "
":const:`AI_NUMERICHOST` will disable domain name resolution and will raise "
"an error if *host* is a domain name."
msgstr ""
"*flags* 参数可以是 ``AI_*`` 常量中的一个或多个，并会影响结果的计算和返回。 例如，:const:`AI_NUMERICHOST` "
"将禁用域名解析并将在 *host* 为域名时引发错误。"

#: ../../library/socket.rst:939
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "本函数返回一个列表，其中的 5 元组具有以下结构："

#: ../../library/socket.rst:941
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:943
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to"
" be passed to the :func:`~socket.socket` function.  *canonname* will be a "
"string representing the canonical name of the *host* if "
":const:`AI_CANONNAME` is part of the *flags* argument; else *canonname* will"
" be empty.  *sockaddr* is a tuple describing a socket address, whose format "
"depends on the returned *family* (a ``(address, port)`` 2-tuple for "
":const:`AF_INET`, a ``(address, port, flowinfo, scope_id)`` 4-tuple for "
":const:`AF_INET6`), and is meant to be passed to the :meth:`socket.connect` "
"method."
msgstr ""
"在这些元组中，*family*, *type*, *proto* 都是整数且其作用是被传给 :func:`~socket.socket` 函数。 如果 "
":const:`AI_CANONNAME` 是 *flags* 参数的一部分则 *canonname* 将为表示 *host* 的规范名称的字符串；否则"
" *canonname* 将为空。 *sockaddr* 是一个描述套接字地址的元组，其具体格式取决于返回的 *family* (对于 "
":const:`AF_INET` 将为 ``(address, port)`` 2 元组，对于 :const:`AF_INET6` 将为 "
"``(address, port, flowinfo, scope_id)`` 4 元组)，其作用是被传给 :meth:`socket.connect`"
" 方法。"

#: ../../library/socket.rst:955
msgid ""
"If you intend to use results from :func:`!getaddrinfo` to create a socket "
"(rather than, for example, retrieve *canonname*), consider limiting the "
"results by *type* (e.g. :data:`SOCK_STREAM` or :data:`SOCK_DGRAM`) and/or "
"*proto* (e.g. :data:`IPPROTO_TCP` or :data:`IPPROTO_UDP`) that your "
"application can handle."
msgstr ""
"如果你想要使用来自 :func:`!getaddrinfo` 的结果创建套接字（而不是使用提取 *canonname* 等方式），可以考虑通过 "
"*type* (例如 :data:`SOCK_STREAM` 或 :data:`SOCK_DGRAM`) 和/或你的应用程序能处理的 *proto* "
"(例如 :data:`IPPROTO_TCP` 或 :data:`IPPROTO_UDP`) 来限制结果。"

#: ../../library/socket.rst:961
msgid ""
"The behavior with default values of *family*, *type*, *proto* and *flags* is"
" system-specific."
msgstr "对于 *family*, *type*, *proto* 和 *flags* 使用默认值时的行为取决于具体的系统。"

#: ../../library/socket.rst:964
msgid ""
"Many systems (for example, most Linux configurations) will return a sorted "
"list of all matching addresses. These addresses should generally be tried in"
" order until a connection succeeds (possibly tried in parallel, for example,"
" using a `Happy Eyeballs`_ algorithm). In these cases, limiting the *type* "
"and/or *proto* can help eliminate unsuccessful or unusable connection "
"attempts."
msgstr ""
"许多系统（例如，大多数 Linux 配置）将返回一个由所有匹配的地址组成的已排序列表。 "
"这些地址通常应按顺序被尝试直到有一个连接成功（可能是并行尝试，例如使用 `Happy Eyeballs`_ 算法）。 在这些情况下，限制 *type* "
"和/或 *proto* 有助于消除不成功或不可用的连接尝试。"

#: ../../library/socket.rst:971
msgid ""
"Some systems will, however, only return a single address. (For example, this"
" was reported on Solaris and AIX configurations.) On these systems, limiting"
" the *type* and/or *proto* helps ensure that this address is usable."
msgstr ""
"但是，某些系统将只返回一个地址。 （例如，在 Solaris 和 AIX 配置上即有报告此种情况。） 在这些系统上，限制 *type* 和/或 "
"*proto* 有助于确保此地址是可用的。"

#: ../../library/socket.rst:976
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.getaddrinfo`` 并附带参数 ``host``, ``port``,"
" ``family``, ``type``, ``protocol``。"

#: ../../library/socket.rst:978
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"下面的示例获取了 TCP 连接地址信息，假设该连接通过 80 端口连接至 ``example.org`` （如果系统未启用 "
"IPv6，则结果可能会不同）::"

#: ../../library/socket.rst:982
msgid ""
">>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n"
"[(socket.AF_INET6, socket.SOCK_STREAM,\n"
" 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n"
" (socket.AF_INET, socket.SOCK_STREAM,\n"
" 6, '', ('93.184.216.34', 80))]"
msgstr ""
">>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n"
"[(socket.AF_INET6, socket.SOCK_STREAM,\n"
" 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n"
" (socket.AF_INET, socket.SOCK_STREAM,\n"
" 6, '', ('93.184.216.34', 80))]"

#: ../../library/socket.rst:988
msgid "parameters can now be passed using keyword arguments."
msgstr "现在可以使用关键字参数的形式来传递参数。"

#: ../../library/socket.rst:991
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr "对于 IPv6 多播地址，表示地址的字符串将不包含 ``%scope_id`` 部分。"

#: ../../library/socket.rst:999
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by"
" aliases for the host, if available.  The first name which includes a period"
" is selected.  In case no fully qualified domain name is available and "
"*name* was provided, it is returned unchanged.  If *name* was empty or equal"
" to ``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"返回 *name* 的完整限定域名。 如果 *name* 被省略或为空，则将其解读为本地主机。 要查找完整限定名称，将先检查 "
":func:`gethostbyaddr` 所返回的主机名，然后是主机的别名（如果存在）。 包括句点的第一个名称将会被选择。 "
"对于没有完整限定域名而提供了 *name* 的情况，则会将其原样返回。 如果 *name* 为空或等于 ``'0.0.0.0'``，则返回来自 "
":func:`gethostname` 的主机名。"

#: ../../library/socket.rst:1010
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a"
" more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"将主机名转换为 IPv4 地址格式。IPv4 地址以字符串格式返回，如 ``'100.50.200.5'``。如果主机名本身是 IPv4 "
"地址，则原样返回。更完整的接口请参考 :func:`gethostbyname_ex`。 :func:`gethostbyname` 不支持 IPv6 "
"名称解析，应使用 :func:`getaddrinfo` 来支持 IPv4/v6 双协议栈。"

#: ../../library/socket.rst:1016 ../../library/socket.rst:1032
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.gethostbyname`` 并附带参数 ``hostname``。"

#: ../../library/socket.rst:1023
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's"
" primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"将一个主机名转换为 IPv4 地址格式的扩展接口。 返回一个 3 元组 ``(hostname, aliaslist, ipaddrlist)`` 其中"
" *hostname* 是主机的首选主机名，*aliaslist* 是同一地址的备选主机名列表（可能为空），而 *ipaddrlist* "
"是同一主机上同一接口的 IPv4 地址列表（通常为单个地址但并不总是如此）。 :func:`gethostbyname_ex` 不支持 IPv6 "
"名称解析，应当改用 :func:`getaddrinfo` 来提供 IPv4/v6 双栈支持。"

#: ../../library/socket.rst:1039
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr "返回一个字符串，包含当前正在运行 Python 解释器的机器的主机名。"

#: ../../library/socket.rst:1042
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``socket.gethostname``。"

#: ../../library/socket.rst:1044
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr "注意： :func:`gethostname` 并不总是返回全限定域名，必要的话请使用 :func:`getfqdn`。"

#: ../../library/socket.rst:1052
msgid ""
"Return a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a"
" (possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. "
":func:`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"返回一个 3 元组 ``(hostname, aliaslist, ipaddrlist)`` 其中 *hostname* 是响应给定 "
"*ip_address* 的首选主机名，*aliaslist* 是同一地址的备选主机名列表（可能为空），而 *ipaddrlist* "
"是同一主机上同一接口的 IPv4/v6 地址列表（很可能仅包含一个地址）。 要查询完整限定域名，请使用函数 :func:`getfqdn`。 "
":func:`gethostbyaddr` 同时支持 IPv4 和 IPv6。"

#: ../../library/socket.rst:1060
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.gethostbyaddr`` 并附带参数 ``ip_address``。"

#: ../../library/socket.rst:1067
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"将套接字地址 *sockaddr* 转换为一个 2 元组 ``(host, port)``。 根据 *flags* 的设置，结果可能包含 *host* "
"中的完整限定域名或数字形式的地址。 类似地，*port* 可以包含字符串形式的端口名或数字形式的端口号。"

#: ../../library/socket.rst:1072
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr*"
" contains meaningful *scope_id*. Usually this happens for multicast "
"addresses."
msgstr ""
"对于 IPv6 地址，如果 *sockaddr* 包含有意义的 *scope_id*，则 ``%scope_id`` 会被附加到主机部分。 "
"这种情况通常发生在多播地址上。"

#: ../../library/socket.rst:1075
msgid ""
"For more information about *flags* you can consult "
":manpage:`getnameinfo(3)`."
msgstr "关于 *flags* 的更多信息可参阅 :manpage:`getnameinfo(3)`。"

#: ../../library/socket.rst:1077
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.getnameinfo`` 并附带参数 ``sockaddr``。"

#: ../../library/socket.rst:1084
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the "
":func:`~socket.socket` function.  This is usually only needed for sockets "
"opened in \"raw\" mode (:const:`SOCK_RAW`); for the normal socket modes, the"
" correct protocol is chosen automatically if the protocol is omitted or "
"zero."
msgstr ""
"将一个互联网协议名称 (如 ``'icmp'``) 转写为能被作为 (可选的) 第三个参数传给 :func:`~socket.socket` "
"函数的常量。 这通常仅对以 \"raw\" 模式 (:const:`SOCK_RAW`) "
"打开的套接字来说是必要的；对于正常的套接字模式，当协议名称被省略或为零时会自动选择正确的协议。"

#: ../../library/socket.rst:1095
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"将一个互联网服务名称和协议名称转换为该服务的端口号。 如果给出了可选的协议名称，它应为 ``'tcp'`` 或 "
"``'udp'``，否则将匹配任意的协议。"

#: ../../library/socket.rst:1099
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.getservbyname`` 并附带参数 ``servicename``, "
"``protocolname``。"

#: ../../library/socket.rst:1106
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"将一个互联网端口号和协议名称转换为该服务的服务名称。 如果给出了可选的协议名称，它应为 ``'tcp'`` 或 "
"``'udp'``，否则将匹配任意的协议。"

#: ../../library/socket.rst:1110
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.getservbyport`` 并附带参数 ``port``, "
"``protocolname``。"

#: ../../library/socket.rst:1117
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"将 32 位正整数从网络字节序转换为主机字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 4 字节交换操作。"

#: ../../library/socket.rst:1124
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"将 16 位正整数从网络字节序转换为主机字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 2 字节交换操作。"

#: ../../library/socket.rst:1128 ../../library/socket.rst:1146
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned "
"integer."
msgstr "如果 *x* 不能转为 16 位无符号整数则会引发 :exc:`OverflowError`。"

#: ../../library/socket.rst:1135
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"将 32 位正整数从主机字节序转换为网络字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 4 字节交换操作。"

#: ../../library/socket.rst:1142
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"将 16 位正整数从主机字节序转换为网络字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 2 字节交换操作。"

#: ../../library/socket.rst:1153
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"将一个 IPv4 地址从以点号分为四段的字符串格式（例如 '123.45.67.89'）转换为 32 位的紧凑二进制格式，长度为四个字符的字节串对象。 "
"这在与使用标准 C 库并且需要 :c:struct:`in_addr` 类型对象的程序通信时很有用处，该类型就是此函数所返回的 32 位的紧凑二进制格式"
" C 类型。"

#: ../../library/socket.rst:1159
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ":func:`inet_aton` 也接受句点数少于三的字符串，详情请参阅 Unix 手册 :manpage:`inet(3)`。"

#: ../../library/socket.rst:1162
msgid ""
"If the IPv4 address string passed to this function is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on "
"the underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"如果传入本函数的 IPv4 地址字符串无效，则抛出 :exc:`OSError`。注意，具体什么样的地址有效取决于 "
":c:func:`inet_aton` 的底层 C 实现。"

#: ../../library/socket.rst:1166
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ":func:`inet_aton` 不支持 IPv6，在 IPv4/v6 双协议栈下应使用 :func:`inet_pton` 来代替。"

#: ../../library/socket.rst:1172
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes"
" in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"将一个 32 位紧凑 IPv4 地址 (长度为四个字节的 :term:`bytes-like object`) 转换为标准的以点号四分段字符串表示形式 "
"(例如 '123.45.67.89')。 这在与使用标准 C 库并且需要 :c:struct:`in_addr` "
"类型对象的程序通信时很有用处，该类型就是此函数接受作为参数的 32 位的紧凑二进制格式 C 类型。"

#: ../../library/socket.rst:1179
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"如果传入本函数的字节序列长度不是 4 个字节，则抛出 :exc:`OSError`。:func:`inet_ntoa` 不支持 IPv6，在 "
"IPv4/v6 双协议栈下应使用 :func:`inet_ntop` 来代替。"

#: ../../library/socket.rst:1190
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to "
":func:`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"将基于特定地址族字符串格式的 IP 地址转换为紧凑的二进制格式。 :func:`inet_pton` 在一个库或网络协议需要 "
":c:struct:`in_addr` (类似于 :func:`inet_aton`) 或 :c:struct:`in6_addr` "
"类型的对象时很有用处。"

#: ../../library/socket.rst:1195
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the IP address string *ip_string* is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on "
"both the value of *address_family* and the underlying implementation of "
":c:func:`inet_pton`."
msgstr ""
"目前 *address_family* 支持 :const:`AF_INET` 和 :const:`AF_INET6`。如果 IP 地址字符串 "
"*ip_string* 无效，则抛出 :exc:`OSError`。注意，具体什么地址有效取决于 *address_family* 的值和 "
":c:func:`inet_pton` 的底层实现。"

#: ../../library/socket.rst:1203 ../../library/socket.rst:1223
msgid "Windows support added"
msgstr "添加了 Windows 支持"

#: ../../library/socket.rst:1209
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"将一个紧凑的 IP 地址 (长度为多个字节的 :term:`bytes-like object`) 转换为标准的基于特定地址族的字符串表示形式 (例如 "
"``'7.10.0.5'`` 或 ``'5aef:2b::8'``)。 :func:`inet_ntop` 在一个库或网络协议返回 "
":c:struct:`in_addr` (类似于 :func:`inet_ntoa`) 或 :c:struct:`in6_addr` "
"类型的对象时很有用处。"

#: ../../library/socket.rst:1216
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length"
" for the specified address family, :exc:`ValueError` will be raised. "
":exc:`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"目前 *address_family* 支持 :const:`AF_INET` 和 :const:`AF_INET6`。如果字节对象 "
"*packed_ip* 与指定的地址簇长度不符，则抛出 :exc:`ValueError`。针对 :func:`inet_ntop` 调用的错误则抛出 "
":exc:`OSError`。"

#: ../../library/socket.rst:1238
msgid ""
"Return the total length, without trailing padding, of an ancillary data item"
" with associated data of the given *length*.  This value can often be used "
"as the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use "
":func:`CMSG_SPACE` and thus include space for padding, even when the item "
"will be the last in the buffer.  Raises :exc:`OverflowError` if *length* is "
"outside the permissible range of values."
msgstr ""
"返回给定 *length* 所关联数据的辅助数据项的总长度（不带尾部填充）。此值通常用作 :meth:`~socket.recvmsg` "
"接收一个辅助数据项的缓冲区大小，但是 :rfc:`3542` 要求可移植应用程序使用 "
":func:`CMSG_SPACE`，以此将尾部填充的空间计入，即使该项在缓冲区的最后。如果 *length* 超出允许范围，则抛出 "
":exc:`OverflowError`。"

#: ../../library/socket.rst:1249 ../../library/socket.rst:1736
#: ../../library/socket.rst:1780 ../../library/socket.rst:1888
msgid "Most Unix platforms."
msgstr "大多数 Unix 平台。"

#: ../../library/socket.rst:1256
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths."
"  Raises :exc:`OverflowError` if *length* is outside the permissible range "
"of values."
msgstr ""
"返回 :meth:`~socket.recvmsg` 所需的缓冲区大小，以接收给定 *length* "
"所关联数据的辅助数据项，带有尾部填充。接收多个项目所需的缓冲区空间是关联数据长度的 :func:`CMSG_SPACE` 值的总和。如果 "
"*length* 超出允许范围，则抛出 :exc:`OverflowError`。"

#: ../../library/socket.rst:1264
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"请注意，某些系统可能支持辅助数据，但不提供本函数。还需注意，如果使用本函数的结果来设置缓冲区大小，可能无法精确限制可接收的辅助数据量，因为可能会有其他数据写入尾部填充区域。"

#: ../../library/socket.rst:1272
msgid "most Unix platforms."
msgstr "大多数 Unix 平台。"

#: ../../library/socket.rst:1279
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"返回用于新套接字对象的默认超时（以秒为单位的浮点数）。值 ``None`` 表示新套接字对象没有超时。首次导入 socket 模块时，默认值为 "
"``None``。"

#: ../../library/socket.rst:1286
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the"
" socket module is first imported, the default is ``None``.  See "
":meth:`~socket.settimeout` for possible values and their respective "
"meanings."
msgstr ""
"设置用于新套接字对象的默认超时（以秒为单位的浮点数）。首次导入 socket 模块时，默认值为 ``None``。可能的取值及其各自的含义请参阅 "
":meth:`~socket.settimeout`。"

#: ../../library/socket.rst:1294
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr "将计算机的主机名设置为 *name*。如果权限不足将抛出 :exc:`OSError`。"

#: ../../library/socket.rst:1297
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``socket.sethostname`` 并附带参数 ``name``。"

#: ../../library/socket.rst:1306
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr "返回一个列表，包含网络接口（网卡）信息二元组（整数索引，名称字符串）。系统调用失败则抛出 :exc:`OSError`。"

#: ../../library/socket.rst:1314 ../../library/socket.rst:1341
#: ../../library/socket.rst:1358
msgid "Windows support was added."
msgstr "添加了 Windows 支持。"

#: ../../library/socket.rst:1319
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr "在 Windows 中网络接口在不同上下文中具有不同的名称（所有名称见对应示例）:"

#: ../../library/socket.rst:1322
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1323
msgid "name: ``ethernet_32770``"
msgstr "名称: ``ethernet_32770``"

#: ../../library/socket.rst:1324
msgid "friendly name: ``vEthernet (nat)``"
msgstr "友好名称: ``vEthernet (nat)``"

#: ../../library/socket.rst:1325
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "描述: ``Hyper-V Virtual Ethernet Adapter``"

#: ../../library/socket.rst:1327
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr "此函数返回列表中第二种形式的名称，在此示例中为 ``ethernet_32770``。"

#: ../../library/socket.rst:1333
msgid ""
"Return a network interface index number corresponding to an interface name. "
":exc:`OSError` if no interface with the given name exists."
msgstr "返回网络接口名称相对应的索引号。如果没有所给名称的接口，则抛出 :exc:`OSError`。"

#: ../../library/socket.rst:1345 ../../library/socket.rst:1362
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr "\"Interface name\" 为 :func:`if_nameindex` 中所描述的名称。"

#: ../../library/socket.rst:1350
msgid ""
"Return a network interface name corresponding to an interface index number. "
":exc:`OSError` if no interface with the given index exists."
msgstr "返回网络接口索引号相对应的接口名称。如果没有所给索引号的接口，则抛出 :exc:`OSError`。"

#: ../../library/socket.rst:1367
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult "
":meth:`~socket.sendmsg` for the documentation of these parameters."
msgstr ""
"将文件描述符列表 *fds* 通过一个 :const:`AF_UNIX` 套接字 *sock* 进行发送。 *fds* 形参是由文件描述符组成的序列。 "
"请查看 :meth:`~socket.sendmsg` 获取这些形参的文档说明。"

#: ../../library/socket.rst:1373 ../../library/socket.rst:1387
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr "支持 :meth:`~socket.sendmsg` 和 :const:`SCM_RIGHTS` 机制的 Unix 平台。"

#: ../../library/socket.rst:1381
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult "
":meth:`~socket.recvmsg` for the documentation of these parameters."
msgstr ""
"接收至多 *maxfds* 个来自 :const:`AF_UNIX` 套接字 *sock* 的文件描述符。 返回 ``(msg, list(fds), "
"flags, addr)``。 请查看 :meth:`~socket.recvmsg` 获取这些形参的文档说明。"

#: ../../library/socket.rst:1394
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "位于文件描述符列表末尾的任何被截断整数。"

#: ../../library/socket.rst:1400
msgid "Socket Objects"
msgstr "套接字对象"

#: ../../library/socket.rst:1402
msgid ""
"Socket objects have the following methods.  Except for "
":meth:`~socket.makefile`, these correspond to Unix system calls applicable "
"to sockets."
msgstr "套接字对象具有以下方法。除了 :meth:`~socket.makefile`，其他都与套接字专用的 Unix 系统调用相对应。"

#: ../../library/socket.rst:1406
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"添加了对 :term:`上下文管理器 <context manager>` 协议的支持。退出上下文管理器与调用 "
":meth:`~socket.close` 等效。"

#: ../../library/socket.rst:1413
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn*"
" is a *new* socket object usable to send and receive data on the connection,"
" and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"接受一个连接。此 socket 必须绑定到一个地址上并且监听连接。返回值是一个 ``(conn, address)`` 对，其中 *conn* 是一个 "
"*新* 的套接字对象，用于在此连接上收发数据，*address* 是连接另一端的套接字所绑定的地址。"

#: ../../library/socket.rst:1420 ../../library/socket.rst:1514
msgid "The socket is now non-inheritable."
msgstr "该套接字现在是不可继承的。"

#: ../../library/socket.rst:1423 ../../library/socket.rst:1649
#: ../../library/socket.rst:1663 ../../library/socket.rst:1740
#: ../../library/socket.rst:1813 ../../library/socket.rst:1832
#: ../../library/socket.rst:1849 ../../library/socket.rst:1894
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an "
":exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 :exc:`InterruptedError` 异常 (原因详见 "
":pep:`475`)。"

#: ../../library/socket.rst:1431
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr "将套接字绑定到 *address*。套接字必须尚未绑定。（ *address* 的格式取决于地址簇 —— 参见上文）"

#: ../../library/socket.rst:1434
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.bind`` 并附带参数 ``self``、``address``。"

#: ../../library/socket.rst:1441
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"将套接字标记为已关闭。 底层的系统资源（例如文件描述符）也将在 :meth:`makefile` 创建的所有文件对象关闭时被关闭。 "
"一旦上述情况发生，将来对该套接字对象的所有操作都将失败。 远端将不会接收到新的数据（在队列中的数据被清空之后）。"

#: ../../library/socket.rst:1447
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr "垃圾回收时，套接字会自动关闭，但建议显式 :meth:`close` 它们，或在它们周围使用 :keyword:`with` 语句。"

#: ../../library/socket.rst:1451
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying "
":c:func:`close` call is made."
msgstr "现在，如果底层的 :c:func:`close` 调用出错，会抛出 :exc:`OSError`。"

#: ../../library/socket.rst:1457
msgid ""
":meth:`close` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown` before :meth:`close`."
msgstr ""
":meth:`close` 会释放与连接相关联的资源但不一定立即关闭连接。 如果你想要及时关闭连接，请在 :meth:`close` 之前调用 "
":meth:`shutdown`。"

#: ../../library/socket.rst:1465
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on"
" the address family --- see above.)"
msgstr "连接到 *address* 处的远程套接字。（ *address* 的格式取决于地址簇 —— 参见上文）"

#: ../../library/socket.rst:1468
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an "
":exc:`InterruptedError` exception if the connection is interrupted by a "
"signal (or the exception raised by the signal handler)."
msgstr ""
"如果连接被信号中断，则本方法将等待直至连接完成，或者如果信号处理器未引发异常并且套接字被阻塞或已超时则会在超时后引发 "
":exc:`TimeoutError`。 对于非阻塞型套接字，如果连接被信号中断则本方法将引发 :exc:`InterruptedError` "
"异常（或信号处理器所引发的异常）。"

#: ../../library/socket.rst:1475 ../../library/socket.rst:1495
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments"
" ``self``, ``address``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.connect`` 并附带参数 ``self``、``address``。"

#: ../../library/socket.rst:1477
msgid ""
"The method now waits until the connection completes instead of raising an "
":exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"本方法现在将等待，直到连接完成，而不是在以下情况抛出 :exc:`InterruptedError` "
"异常。该情况为，连接被信号中断，信号处理程序未抛出异常，且套接字阻塞中或已超时（具体解释请参阅 :pep:`475` ）。"

#: ../../library/socket.rst:1488
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value"
" of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"类似于 ``connect(address)``，但是对于 C 级别的 :c:func:`connect` "
"调用返回的错误，本函数将返回错误指示器，而不是抛出异常（对于其他问题，如“找不到主机”，仍然可以抛出异常）。如果操作成功，则错误指示器为 "
"``0``，否则为 :c:data:`errno` 变量的值。这对支持如异步连接很有用。"

#: ../../library/socket.rst:1501
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr "将套接字对象置于关闭状态，而底层的文件描述符实际并不关闭。返回该文件描述符，使其可以重新用于其他目的。"

#: ../../library/socket.rst:1510
msgid "Duplicate the socket."
msgstr "创建套接字的副本。"

#: ../../library/socket.rst:1522
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr "返回套接字的文件描述符（一个小整数），失败返回 -1。配合 :func:`select.select` 使用很有用。"

#: ../../library/socket.rst:1525
msgid ""
"Under Windows the small integer returned by this method cannot be used where"
" a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"在 Windows 下，此方法返回的小整数在允许使用文件描述符的地方无法使用（如 :func:`os.fdopen` ）。Unix 无此限制。"

#: ../../library/socket.rst:1531
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"获取套接字文件描述符或套接字句柄的 :ref:`可继承标志 <fd_inheritance>` ：如果子进程可以继承套接字则为 ``True``，否则为"
" ``False``。"

#: ../../library/socket.rst:1540
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see above.)"
"  On some systems this function is not supported."
msgstr ""
"返回套接字连接到的远程地址。举例而言，这可以用于查找远程 IPv4/v6 套接字的端口号。（返回的地址格式取决于地址簇 —— "
"参见上文。）部分系统不支持此函数。"

#: ../../library/socket.rst:1548
msgid ""
"Return the socket's own address.  This is useful to find out the port number"
" of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr "返回套接字本身的地址。举例而言，这可以用于查找 IPv4/v6 套接字的端口号。（返回的地址格式取决于地址簇 —— 参见上文。）"

#: ../../library/socket.rst:1555
msgid ""
"Return the value of the given socket option (see the Unix man page "
":manpage:`getsockopt(2)`).  The needed symbolic constants (:ref:`SO_\\* etc."
" <socket-unix-constants>`) are defined in this module.  If *buflen* is "
"absent, an integer option is assumed and its integer value is returned by "
"the function.  If *buflen* is present, it specifies the maximum length of "
"the buffer used to receive the option in, and this buffer is returned as a "
"bytes object.  It is up to the caller to decode the contents of the buffer "
"(see the optional built-in module :mod:`struct` for a way to decode C "
"structures encoded as byte strings)."
msgstr ""
"返回给定套接字选项的值 (参见 Unix 手册页 :manpage:`getsockopt(2)`)。 所需的符号常量 (:ref:`SO_\\* 等 "
"<socket-unix-constants>`) 在本模块中定义。 如果未指定 *buflen*，则会假定该选项为整数值并且将由此函数返回其整数值。 "
"如果指定了 *buflen*，则它定义了用于存放选项值的缓冲区的最大长度，且该缓冲区将作为字节对象返回。 "
"调用方需要执行对缓冲区内容的解码（请参阅可选的内置模块 :mod:`struct` 了解如何对编码为字节串的 C 结构体进行解码）。"

#: ../../library/socket.rst:1569
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr "如果套接字处于阻塞模式，返回 ``True``，非阻塞模式返回 ``False``。"

#: ../../library/socket.rst:1572
msgid "This is equivalent to checking ``socket.gettimeout() != 0``."
msgstr "这等价于检测 ``socket.gettimeout() != 0``。"

#: ../../library/socket.rst:1579
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to "
":meth:`setblocking` or :meth:`settimeout`."
msgstr ""
"返回套接字操作相关的超时秒数（浮点数），未设置超时则返回 ``None``。它反映最后一次调用 :meth:`setblocking` 或 "
":meth:`settimeout` 后的设置。"

#: ../../library/socket.rst:0
msgid "platform"
msgstr "平台"

#: ../../library/socket.rst:1586
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1588
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ for "
"more information."
msgstr ""
":meth:`ioctl` 方法是 WSAIoctl 系统接口的有限接口。请参考 `Win32 文档 "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ "
"以获取更多信息。"

#: ../../library/socket.rst:1593
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"在其他平台上，可以使用通用的 :func:`fcntl.fcntl` 和 :func:`fcntl.ioctl` "
"函数，它们接受套接字对象作为第一个参数。"

#: ../../library/socket.rst:1596
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"当前仅支持以下控制码： ``SIO_RCVALL``、``SIO_KEEPALIVE_VALS`` 和 "
"``SIO_LOOPBACK_FAST_PATH``。"

#: ../../library/socket.rst:1604
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"启动一个服务器用于接受连接。如果指定 *backlog*，则它最低为 0（小于 0 会被置为 0），它指定系统允许暂未 accept "
"的连接数，超过后将拒绝新连接。未指定则自动设为合理的默认值。"

#: ../../library/socket.rst:1611
msgid "The *backlog* parameter is now optional."
msgstr "*backlog* 参数现在是可选的。"

#: ../../library/socket.rst:1620
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned"
" type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'``, "
"``'b'``, or a combination of those."
msgstr ""
"返回一个与套接字相关联的 :term:`file object`。 返回对象的具体类型取决于传给 :meth:`makefile` 的参数。 "
"这些参数的解读方式与内置的 :func:`open` 函数相同，区别在于 *mode* 值仅支持 ``'r'`` (默认), ``'w'``, "
"``'b'`` 或它们的组合。"

#: ../../library/socket.rst:1626
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr "套接字必须处于阻塞模式，它可以有超时，但是如果发生超时，文件对象的内部缓冲区可能会以不一致的状态结尾。"

#: ../../library/socket.rst:1630
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and "
":meth:`socket.close` has been called on the socket object."
msgstr ""
"关闭 :meth:`makefile` 返回的文件对象不会关闭原始套接字，除非所有其他文件对象都已关闭且在套接字对象上调用了 "
":meth:`socket.close`。"

#: ../../library/socket.rst:1636
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"在 Windows 上，由 :meth:`makefile` 创建的文件型对象无法作为带文件描述符的文件对象使用，如无法作为 "
":meth:`subprocess.Popen` 的流参数。"

#: ../../library/socket.rst:1643
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*. A returned empty bytes object indicates "
"that the client has disconnected. See the Unix manual page "
":manpage:`recv(2)` for the meaning of the optional argument *flags*; it "
"defaults to zero."
msgstr ""
"从套接字接收数据。 返回值是一个代表所接收数据的字节串对象。 可一次性接收的最大数据量由 *bufsize* 指定。 "
"返回空字节串对象表示客户端已断开连接。 请参阅 Unix 手册页 :manpage:`recv(2)` 了解可选参数 *flags* "
"的含义；它默认为零。"

#: ../../library/socket.rst:1657
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"从套接字接收数据。返回值是一对 ``(bytes, address)``，其中 *bytes* 是字节对象，表示接收到的数据，*address* "
"是发送端套接字的地址。可选参数 *flags* 的含义请参阅 Unix 手册页 :manpage:`recv(2)`，它默认为零。（ *address*"
" 的格式取决于地址簇 —— 参见上文）"

#: ../../library/socket.rst:1668
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use "
":func:`getnameinfo`."
msgstr ""
"对于多播 IPv6 地址，*address* 的第一项不会再包含 ``%scope_id`` 部分。 要获得完整的 IPv6 地址请使用 "
":func:`getnameinfo`。"

#: ../../library/socket.rst:1675
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no"
" ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The"
" *flags* argument defaults to 0 and has the same meaning as for "
":meth:`recv`."
msgstr ""
"从套接字接收普通数据（至多 *bufsize* 字节）和辅助数据。*ancbufsize* "
"参数设置用于接收辅助数据的内部缓冲区的大小（以字节为单位），默认为 0，表示不接收辅助数据。可以使用 :func:`CMSG_SPACE` 或 "
":func:`CMSG_LEN` 计算辅助数据缓冲区的合适大小，无法放入缓冲区的项目可能会被截断或丢弃。*flags* 参数默认为 0，其含义与 "
":meth:`recv` 中的相同。"

#: ../../library/socket.rst:1685
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The"
" *data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on"
" the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"返回值是一个四元组： ``(data, ancdata, msg_flags, address)``。*data* 项是一个 "
":class:`bytes` 对象，用于保存接收到的非辅助数据。*ancdata* 项是零个或多个元组 ``(cmsg_level, "
"cmsg_type, cmsg_data)`` 组成的列表，表示接收到的辅助数据（控制消息）：*cmsg_level* 和 *cmsg_type* "
"是分别表示协议级别和协议类型的整数，而 *cmsg_data* 是保存相关数据的 :class:`bytes` 对象。*msg_flags* "
"项由各种标志按位或组成，表示接收消息的情况，详细信息请参阅系统文档。如果接收端套接字断开连接，则 *address* "
"是发送端套接字的地址（如果有），否则该值无指定。"

#: ../../library/socket.rst:1699
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a "
":class:`bytes` object representing the new file descriptors as a binary "
"array of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an "
"exception after the system call returns, it will first attempt to close any "
"file descriptors received via this mechanism."
msgstr ""
"在某些系统上，可以使用 :meth:`sendmsg` 和 :meth:`recvmsg` 通过 :const:`AF_UNIX` "
"套接字在进程之间传递文件描述符。 当使用此功能时 (通常仅限于 :const:`SOCK_STREAM` 套接字), :meth:`recvmsg` "
"将在其附带数据中返回 ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)`` 形式的项，其中 *fds* "
"是一个代表新文件描述符的原生as a binary array of the native C :c:expr:`int` 类型的二进制数组形式的 "
":class:`bytes` 对象。 如果 :meth:`recvmsg` "
"在系统调用返回后引发了异常，它将首先尝试关闭通过此机制接收到的任何文件描述符。"

#: ../../library/socket.rst:1710
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a "
":exc:`RuntimeWarning`, and will return the part of it which is inside the "
"buffer provided it has not been truncated before the start of its associated"
" data."
msgstr ""
"对于仅接收到一部分的辅助数据项，一些系统没有指示其截断长度。如果某个项目可能超出了缓冲区的末尾，:meth:`recvmsg` 将发出 "
":exc:`RuntimeWarning`，并返回其在缓冲区内的部分，前提是该对象被截断于关联数据开始后。"

#: ../../library/socket.rst:1717
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message"
" data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also "
":meth:`sendmsg`. ::"
msgstr ""
"在支持 :const:`SCM_RIGHTS` 机制的系统上，下方的函数将最多接收 *maxfds* "
"个文件描述符，返回消息数据和包含描述符的列表（同时忽略意外情况，如接收到无关的控制消息）。另请参阅 :meth:`sendmsg`。 ::"

#: ../../library/socket.rst:1723
msgid ""
"import socket, array\n"
"\n"
"def recv_fds(sock, msglen, maxfds):\n"
"    fds = array.array(\"i\")   # Array of ints\n"
"    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))\n"
"    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n"
"        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:\n"
"            # Append data, ignoring any truncated integers at the end.\n"
"            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])\n"
"    return msg, list(fds)"
msgstr ""
"import socket, array\n"
"\n"
"def recv_fds(sock, msglen, maxfds):\n"
"    fds = array.array(\"i\")   # 整数数组\n"
"    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))\n"
"    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n"
"        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:\n"
"            # 添加数据，忽略任何在末尾被截断的整数。\n"
"            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])\n"
"    return msg, list(fds)"

#: ../../library/socket.rst:1748
msgid ""
"Receive normal data and ancillary data from the socket, behaving as "
":meth:`recvmsg` would, but scatter the non-ancillary data into a series of "
"buffers instead of returning a new bytes object.  The *buffers* argument "
"must be an iterable of objects that export writable buffers (e.g. "
":class:`bytearray` objects); these will be filled with successive chunks of "
"the non-ancillary data until it has all been written or there are no more "
"buffers.  The operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancbufsize*"
" and *flags* arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"从套接字接收普通数据和辅助数据，其行为与 :meth:`recvmsg` "
"相同，但将非辅助数据分散到一系列缓冲区中，而不是返回新的字节对象。*buffers* 参数必须是可迭代对象，它迭代出可供写入的缓冲区（如 "
":class:`bytearray` "
"对象），这些缓冲区将被连续的非辅助数据块填充，直到数据全部写完或缓冲区用完为止。在允许使用的缓冲区数量上，操作系统可能会有限制（ "
":func:`~os.sysconf` 的 ``SC_IOV_MAX`` 值）。*ancbufsize* 和 *flags* 参数的含义与 "
":meth:`recvmsg` 中的相同。"

#: ../../library/socket.rst:1759
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"返回值为四元组： ``(nbytes, ancdata, msg_flags, address)``，其中 *nbytes* "
"是写入缓冲区的非辅助数据的字节总数，而 *ancdata*、*msg_flags* 和 *address* 与 :meth:`recvmsg` "
"中的相同。"

#: ../../library/socket.rst:1764
msgid "Example::"
msgstr "示例::"

#: ../../library/socket.rst:1766
msgid ""
">>> import socket\n"
">>> s1, s2 = socket.socketpair()\n"
">>> b1 = bytearray(b'----')\n"
">>> b2 = bytearray(b'0123456789')\n"
">>> b3 = bytearray(b'--------------')\n"
">>> s1.send(b'Mary had a little lamb')\n"
"22\n"
">>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n"
"(22, [], 0, None)\n"
">>> [b1, b2, b3]\n"
"[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]"
msgstr ""
">>> import socket\n"
">>> s1, s2 = socket.socketpair()\n"
">>> b1 = bytearray(b'----')\n"
">>> b2 = bytearray(b'0123456789')\n"
">>> b3 = bytearray(b'--------------')\n"
">>> s1.send(b'Mary had a little lamb')\n"
"22\n"
">>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n"
"(22, [], 0, None)\n"
">>> [b1, b2, b3]\n"
"[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]"

#: ../../library/socket.rst:1787
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a"
" new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the"
" socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"从套接字接收数据，将其写入 *buffer* 而不是创建新的字节串。返回值是一对 ``(nbytes, address)``，其中 *nbytes* "
"是收到的字节数，*address* 是发送端套接字的地址。可选参数 *flags* 的含义请参阅 Unix 手册页 "
":manpage:`recv(2)`，它默认为零。（ *address* 的格式取决于地址簇 —— 参见上文）"

#: ../../library/socket.rst:1797
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer"
" rather than creating a new bytestring.  If *nbytes* is not specified (or "
"0), receive up to the size available in the given buffer.  Returns the "
"number of bytes received.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero."
msgstr ""
"从套接字接收至多 *nbytes* 个字节，将其写入缓冲区而不是创建新的字节串。如果 *nbytes* 未指定（或指定为 "
"0），则接收至所给缓冲区的最大可用大小。返回接收到的字节数。可选参数 *flags* 的含义请参阅 Unix 手册页 "
":manpage:`recv(2)`，它默认为零。"

#: ../../library/socket.rst:1806
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-"
"howto`."
msgstr ""
"发送数据给套接字。本套接字必须已连接到远程套接字。可选参数 *flags* 的含义与上述 :meth:`recv` "
"中的相同。本方法返回已发送的字节数。应用程序要负责检查所有数据是否已发送，如果仅传输了部分数据，程序需要自行尝试传输其余数据。有关该主题的更多信息，请参考"
" :ref:`socket-howto`。"

#: ../../library/socket.rst:1821
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"发送数据给套接字。本套接字必须已连接到远程套接字。可选参数 *flags* 的含义与上述 :meth:`recv` 中的相同。与 "
":meth:`send` 不同，本方法持续从 *bytes* 发送数据，直到所有数据都已发送或发生错误为止。成功后会返回 "
"``None``。出错后会抛出一个异常，此时并没有办法确定成功发送了多少数据。"

#: ../../library/socket.rst:1828
msgid ""
"The socket timeout is no longer reset each time data is sent successfully. "
"The socket timeout is now the maximum total duration to send all data."
msgstr "每次成员发送数据后，套接字超时将不再重置。 目前的套接字超时是发送所有数据的最大总持续时间。"

#: ../../library/socket.rst:1841
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"发送数据给套接字。本套接字不应连接到远程套接字，而应由 *address* 指定目标套接字。可选参数 *flags* 的含义与上述 "
":meth:`recv` 中的相同。本方法返回已发送的字节数。（ *address* 的格式取决于地址簇 —— 参见上文。）"

#: ../../library/socket.rst:1847
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.sendto`` 并附带参数 ``self``, ``address``。"

#: ../../library/socket.rst:1857
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of "
":term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` "
"objects); the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems"
" without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"将普通数据和辅助数据发送给套接字，将从一系列缓冲区中收集非辅助数据，并将其拼接为一条消息。*buffers* 参数指定的非辅助数据应为可迭代的 "
":term:`字节类对象 <bytes-like object>` （如 :class:`bytes` "
"对象），在允许使用的缓冲区数量上，操作系统可能会有限制（ :func:`~os.sysconf` 的 ``SC_IOV_MAX`` "
"值）。*ancdata* 参数指定的辅助数据（控制消息）应为可迭代对象，迭代出零个或多个 ``(cmsg_level, cmsg_type, "
"cmsg_data)`` 元组，其中 *cmsg_level* 和 *cmsg_type* 是分别指定协议级别和协议类型的整数，而 "
"*cmsg_data* 是保存相关数据的字节类对象。请注意，某些系统（特别是没有 :func:`CMSG_SPACE` "
"的系统）可能每次调用仅支持发送一条控制消息。*flags* 参数默认为 0，与 :meth:`send` 中的含义相同。如果 *address* "
"指定为除 ``None`` 以外的值，它将作为消息的目标地址。返回值是已发送的非辅助数据的字节数。"

#: ../../library/socket.rst:1877
msgid ""
"The following function sends the list of file descriptors *fds* over an "
":const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"在支持 :const:`SCM_RIGHTS` 机制的系统上，下方的函数通过一个 :const:`AF_UNIX` 套接字来发送文件描述符列表 "
"*fds*。另请参阅 :meth:`recvmsg`。 ::"

#: ../../library/socket.rst:1881
msgid ""
"import socket, array\n"
"\n"
"def send_fds(sock, msg, fds):\n"
"    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(\"i\", fds))])"
msgstr ""
"import socket, array\n"
"\n"
"def send_fds(sock, msg, fds):\n"
"    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(\"i\", fds))])"

#: ../../library/socket.rst:1890
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments"
" ``self``, ``address``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``socket.sendmsg`` 并附带参数 ``self``, ``address``。"

#: ../../library/socket.rst:1901
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"为 :const:`AF_ALG` 套接字定制的 :meth:`~socket.sendmsg` 版本。可为 :const:`AF_ALG` "
"套接字设置模式、IV、AEAD 关联数据的长度和标志位。"

#: ../../library/socket.rst:1910
msgid ""
"Send a file until EOF is reached by using high-performance "
":mod:`os.sendfile` and return the total number of bytes which were sent. "
"*file* must be a regular file object opened in binary mode. If "
":mod:`os.sendfile` is not available (e.g. Windows) or *file* is not a "
"regular file :meth:`send` will be used instead. *offset* tells from where to"
" start reading the file. If specified, *count* is the total number of bytes "
"to transmit as opposed to sending the file until EOF is reached. File "
"position is updated on return or also in case of error in which case "
":meth:`file.tell() <io.IOBase.tell>` can be used to figure out the number of"
" bytes which were sent. The socket must be of :const:`SOCK_STREAM` type. "
"Non-blocking sockets are not supported."
msgstr ""
"使用高性能的 :mod:`os.sendfile` 发送文件，直到达到文件的 EOF 为止，返回已发送的字节总数。*file* "
"必须是一个以二进制模式打开的常规文件对象。如果 :mod:`os.sendfile` 不可用（如 Windows）或 *file* 不是常规文件，将使用"
" :meth:`send` 代替。*offset* 指示从哪里开始读取文件。如果指定了 "
"*count*，它确定了要发送的字节总数，而不会持续发送直到达到文件的 "
"EOF。返回时或发生错误时，文件位置将更新，在这种情况下，:meth:`file.tell() <io.IOBase.tell>` "
"可用于确定已发送的字节数。套接字必须为 :const:`SOCK_STREAM` 类型。不支持非阻塞的套接字。"

#: ../../library/socket.rst:1926
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr "设置套接字文件描述符或套接字句柄的 :ref:`可继承标志 <fd_inheritance>`。"

#: ../../library/socket.rst:1934
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr "设置套接字为阻塞或非阻塞模式：如果 *flag* 为 false，则将套接字设置为非阻塞，否则设置为阻塞。"

#: ../../library/socket.rst:1937
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "本方法是某些 :meth:`~socket.settimeout` 调用的简写："

#: ../../library/socket.rst:1939
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` 相当于 ``sock.settimeout(None)``"

#: ../../library/socket.rst:1941
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` 相当于 ``sock.settimeout(0.0)``"

#: ../../library/socket.rst:1943
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on "
":attr:`socket.type`."
msgstr "本方法不再对 :attr:`socket.type` 属性设置 :const:`SOCK_NONBLOCK` 标志。"

#: ../../library/socket.rst:1950
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating-point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a "
":exc:`timeout` exception if the timeout period *value* has elapsed before "
"the operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"为阻塞套接字的操作设置超时。 *value* 参数可以是非负浮点数，表示秒，也可以是 ``None``。 "
"如果赋为一个非零值，那么如果在操作完成前超过了超时时间 *value*，后续的套接字操作将抛出 :exc:`timeout` 异常。 如果赋为 "
"0，则套接字将处于非阻塞模式。 如果指定为 ``None``，则套接字将处于阻塞模式。"

#: ../../library/socket.rst:1957
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr "更多信息请查阅 :ref:`关于套接字超时的说明 <socket-timeouts>`。"

#: ../../library/socket.rst:1959
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on "
":attr:`socket.type`."
msgstr "本方法不再修改 :attr:`socket.type` 属性的 :const:`SOCK_NONBLOCK` 标志。"

#: ../../library/socket.rst:1972
msgid ""
"Set the value of the given socket option (see the Unix manual page "
":manpage:`setsockopt(2)`).  The needed symbolic constants are defined in "
"this module (:ref:`!SO_\\* etc. <socket-unix-constants>`).  The value can be"
" an integer, ``None`` or a :term:`bytes-like object` representing a buffer. "
"In the later case it is up to the caller to ensure that the bytestring "
"contains the proper bits (see the optional built-in module :mod:`struct` for"
" a way to encode C structures as bytestrings). When *value* is set to "
"``None``, *optlen* argument is required. It's equivalent to call "
":c:func:`setsockopt` C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"设置给定套接字选项的值 (参见 Unix 手册页 :manpage:`setsockopt(2)`)。 所需的符号常量已定义在本模块中 "
"(:ref:`!SO_\\* 等 <socket-unix-constants>`)。 该值可以是整数、``None`` 或表示缓冲区的 "
":term:`bytes-like object`。 在后一种情况下将由调用者确保字节串中包含正确的数据位 (请参阅可选的内置模块 "
":mod:`struct` 了解如何将 C 结构体编码为字节串)。 当 *value* 设为 ``None`` 时，*optlen* 参数是必须的。 "
"这等价于调用 :c:func:`setsockopt` C 函数并设置 ``optval=NULL`` 和 ``optlen=optlen``。"

#: ../../library/socket.rst:1985
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "添加了 setsockopt(level, optname, None, optlen: int) 调用形式。"

#: ../../library/socket.rst:1993
msgid ""
"Shut down one or both halves of the connection.  If *how* is "
":const:`SHUT_RD`, further receives are disallowed.  If *how* is "
":const:`SHUT_WR`, further sends are disallowed.  If *how* is "
":const:`SHUT_RDWR`, further sends and receives are disallowed."
msgstr ""
"关闭一半或全部的连接。如果 *how* 为 :const:`SHUT_RD`，则后续不再允许接收。如果 *how* 为 "
":const:`SHUT_WR`，则后续不再允许发送。如果 *how* 为 :const:`SHUT_RDWR`，则后续的发送和接收都不允许。"

#: ../../library/socket.rst:2003
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using "
":func:`fromshare`. Once this method has been called, it is safe to close the"
" socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"复制套接字，并准备将其与目标进程共享。目标进程必须以 *process_id* "
"形式提供。然后可以利用某种形式的进程间通信，将返回的字节对象传递给目标进程，还可以使用 :func:`fromshare` "
"在新进程中重新创建套接字。一旦本方法调用完毕，就可以安全地将套接字关闭，因为操作系统已经为目标进程复制了该套接字。"

#: ../../library/socket.rst:2015
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use "
":meth:`~socket.recv` and :meth:`~socket.send` without *flags* argument "
"instead."
msgstr ""
"注意此处没有 :meth:`read` 或 :meth:`write` 方法，请使用不带 *flags* 参数的 "
":meth:`~socket.recv` 和 :meth:`~socket.send` 来替代。"

#: ../../library/socket.rst:2018
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the"
" values given to the :class:`~socket.socket` constructor."
msgstr "套接字对象还具有以下（只读）属性，这些属性与传入 :class:`~socket.socket` 构造函数的值相对应。"

#: ../../library/socket.rst:2024
msgid "The socket family."
msgstr "套接字的协议簇。"

#: ../../library/socket.rst:2029
msgid "The socket type."
msgstr "套接字的类型。"

#: ../../library/socket.rst:2034
msgid "The socket protocol."
msgstr "套接字的协议。"

#: ../../library/socket.rst:2041
msgid "Notes on socket timeouts"
msgstr "关于套接字超时的说明"

#: ../../library/socket.rst:2043
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"一个套接字对象可以处于以下三种模式之一：阻塞、非阻塞或超时。套接字默认以阻塞模式创建，但是可以调用 :func:`setdefaulttimeout` "
"来更改。"

#: ../../library/socket.rst:2047
msgid ""
"In *blocking mode*, operations block until complete or the system returns an"
" error (such as connection timed out)."
msgstr "在 *blocking mode* （阻塞模式）中，操作将阻塞，直到操作完成或系统返回错误（如连接超时）。"

#: ../../library/socket.rst:2050
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately"
" system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` module can be used to know when and whether a socket is "
"available for reading or writing."
msgstr ""
"在 *非阻塞模式* 中，如果操作无法立即完成则该操作将失败（不幸的是它所附带的错误将依赖于具体系统）: 来自 :mod:`select` "
"模块的函数可被用来获知一个套接字是否可以读取或写入。"

#: ../../library/socket.rst:2055
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"在 *timeout mode* （超时模式）下，如果无法在指定的超时内完成操作（抛出 :exc:`timeout` "
"异常），或如果系统返回错误，则操作将失败。"

#: ../../library/socket.rst:2060
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno` of a socket."
msgstr ""
"在操作系统层级，*超时模式* 下的套接字在内部都被设为非阻塞模式。 同时，阻塞和超时模式会在指向同一个网络端点的文件描述符和套接字对象之间共享。 "
"这一实现细节可能导致明显的后果，例如当你决定使用套接字的 :meth:`~socket.fileno` 的时候。"

#: ../../library/socket.rst:2067
msgid "Timeouts and the ``connect`` method"
msgstr "超时与 ``connect`` 方法"

#: ../../library/socket.rst:2069
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout`"
" before calling :meth:`~socket.connect` or pass a timeout parameter to "
":meth:`create_connection`.  However, the system network stack may also "
"return a connection timeout error of its own regardless of any Python socket"
" timeout setting."
msgstr ""
":meth:`~socket.connect` 操作也受超时设置的约束，通常建议在调用 :meth:`~socket.connect` 之前调用 "
":meth:`~socket.settimeout`，或将超时参数直接传递给 :meth:`create_connection`。但是，无论 "
"Python 套接字超时设置如何，系统网络栈都有可能返回自带的连接超时错误。"

#: ../../library/socket.rst:2077
msgid "Timeouts and the ``accept`` method"
msgstr "超时与 ``accept`` 方法"

#: ../../library/socket.rst:2079
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the "
":meth:`~socket.accept` method inherit that timeout.  Otherwise, the "
"behaviour depends on settings of the listening socket:"
msgstr ""
"如果 :func:`getdefaulttimeout` 的值不是 :const:`None`，则 :meth:`~socket.accept` "
"方法返回的套接字将继承该超时值。若是 None，返回的套接字行为取决于侦听套接字的设置："

#: ../../library/socket.rst:2083
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr "如果侦听套接字处于 *阻塞模式* 或 *超时模式*，则 :meth:`~socket.accept` 返回的套接字处于 *阻塞模式*；"

#: ../../library/socket.rst:2086
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour,"
" it is recommended you manually override this setting."
msgstr ""
"如果侦听套接字处于 *非阻塞模式*，那么 :meth:`~socket.accept` "
"返回的套接字是阻塞还是非阻塞取决于操作系统。如果要确保跨平台时的正确行为，建议手动覆盖此设置。"

#: ../../library/socket.rst:2095
msgid "Example"
msgstr "示例"

#: ../../library/socket.rst:2097
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence "
":func:`~socket.socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, "
":meth:`~socket.accept` (possibly repeating the :meth:`~socket.accept` to "
"service more than one client), while a client only needs the sequence "
":func:`~socket.socket`, :meth:`~socket.connect`.  Also note that the server "
"does not :meth:`~socket.sendall`/:meth:`~socket.recv` on the socket it is "
"listening on but on the new socket returned by :meth:`~socket.accept`."
msgstr ""
"以下是四个使用 TCP/IP 协议的最小示例程序：一个将收到的所有数据原样回馈的服务器（仅服务一个客户端），和一个使用该服务器的客户端。 "
"请注意服务器必须按 :func:`~socket.socket`, :meth:`~socket.bind`, "
":meth:`~socket.listen`, :meth:`~socket.accept` 的顺序执行（可能需要重复执行 "
":meth:`~socket.accept` 以便 服务多个客户端），而客户端仅需要按 :func:`~socket.socket`, "
":meth:`~socket.connect` 的顺序执行。 还要注意服务器不是在侦听的套接字上发送 "
":meth:`~socket.sendall`/:meth:`~socket.recv` 而是在由 :meth:`~socket.accept` "
"返回的新套接字上发送。"

#: ../../library/socket.rst:2107
msgid "The first two examples support IPv4 only. ::"
msgstr "前两个示例仅支持 IPv4。 ::"

#: ../../library/socket.rst:2109
msgid ""
"# Echo server program\n"
"import socket\n"
"\n"
"HOST = ''                 # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.bind((HOST, PORT))\n"
"    s.listen(1)\n"
"    conn, addr = s.accept()\n"
"    with conn:\n"
"        print('Connected by', addr)\n"
"        while True:\n"
"            data = conn.recv(1024)\n"
"            if not data: break\n"
"            conn.sendall(data)"
msgstr ""
"# Echo server program\n"
"import socket\n"
"\n"
"HOST = ''                 # 该符号名表示所有可用接口\n"
"PORT = 50007              # 任意非特权端口\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.bind((HOST, PORT))\n"
"    s.listen(1)\n"
"    conn, addr = s.accept()\n"
"    with conn:\n"
"        print('Connected by', addr)\n"
"        while True:\n"
"            data = conn.recv(1024)\n"
"            if not data: break\n"
"            conn.sendall(data)"

#: ../../library/socket.rst:2127
msgid ""
"# Echo client program\n"
"import socket\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.connect((HOST, PORT))\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""
"# 回显客户端程序\n"
"import socket\n"
"\n"
"HOST = 'daring.cwi.nl'    # 远端主机\n"
"PORT = 50007              # 与服务器所用端口相同\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.connect((HOST, PORT))\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"

#: ../../library/socket.rst:2138
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will"
" take precedence and the server may not accept IPv4 traffic. The client side"
" will try to connect to all the addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"接下来的两个例子与上面两个很想像，但同时支持 IPv4 和 IPv6。 服务端将监听第一个可用的地址族（它本应同时监听两个地址族）。 在大多数支持 "
"IPv6 的系统中，IPv6 将有优先权并且服务端可能不会接受 IPv4 流量。 "
"客户端将尝试连接到作为名称解析结果被返回的所有地址，并将流量发送给第一个成功连接的地址。 ::"

#: ../../library/socket.rst:2145
msgid ""
"# Echo server program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = None               # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n"
"                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.bind(sa)\n"
"        s.listen(1)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"conn, addr = s.accept()\n"
"with conn:\n"
"    print('Connected by', addr)\n"
"    while True:\n"
"        data = conn.recv(1024)\n"
"        if not data: break\n"
"        conn.send(data)"
msgstr ""
"# 回显服务端程序\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = None               # 该符号名表示所有可用接口\n"
"PORT = 50007              # 任意非特权端口\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n"
"                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.bind(sa)\n"
"        s.listen(1)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"conn, addr = s.accept()\n"
"with conn:\n"
"    print('Connected by', addr)\n"
"    while True:\n"
"        data = conn.recv(1024)\n"
"        if not data: break\n"
"        conn.send(data)"

#: ../../library/socket.rst:2181
msgid ""
"# Echo client program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.connect(sa)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"with s:\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""
"# 回显客户端程序\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = 'daring.cwi.nl'    # 远端主机\n"
"PORT = 50007              # 与服务器所用端口相同\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.connect(sa)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"with s:\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"

#: ../../library/socket.rst:2210
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr "下面的例子演示了如何在 Windows 上使用原始套接字编写一个非常简单的网络嗅探器。 这个例子需要管理员权限来修改接口::"

#: ../../library/socket.rst:2214
msgid ""
"import socket\n"
"\n"
"# the public network interface\n"
"HOST = socket.gethostbyname(socket.gethostname())\n"
"\n"
"# create a raw socket and bind it to the public interface\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n"
"s.bind((HOST, 0))\n"
"\n"
"# Include IP headers\n"
"s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n"
"\n"
"# receive all packets\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n"
"\n"
"# receive a packet\n"
"print(s.recvfrom(65565))\n"
"\n"
"# disabled promiscuous mode\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)"
msgstr ""
"import socket\n"
"\n"
"# 公共网络接口\n"
"HOST = socket.gethostbyname(socket.gethostname())\n"
"\n"
"# 创建一个原始套接字并将其绑定到公共接口\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n"
"s.bind((HOST, 0))\n"
"\n"
"# 包括 IP 标头\n"
"s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n"
"\n"
"# 接收所有数据包\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n"
"\n"
"# 接收一个数据包\n"
"print(s.recvfrom(65565))\n"
"\n"
"# 禁用混杂模式\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)"

#: ../../library/socket.rst:2235
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"下面的例子演示了如何使用 socket 接口与采用原始套接字协议的 CAN 网络进行通信。 要改为通过广播管理器协议来使用 "
"CAN，则要用以下方式打开一个 socket::"

#: ../../library/socket.rst:2239
msgid "socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)"
msgstr "socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)"

#: ../../library/socket.rst:2241
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"在绑定 (:const:`CAN_RAW`) 或连接 (:const:`CAN_BCM`) 套接字之后，你将可以在套接字对象上正常地使用 "
":meth:`socket.send` 和 :meth:`socket.recv` 操作（及其同类操作）。"

#: ../../library/socket.rst:2245
msgid "This last example might require special privileges::"
msgstr "最后一个例子可能需要特别的权限::"

#: ../../library/socket.rst:2247
msgid ""
"import socket\n"
"import struct\n"
"\n"
"\n"
"# CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n"
"\n"
"can_frame_fmt = \"=IB3x8s\"\n"
"can_frame_size = struct.calcsize(can_frame_fmt)\n"
"\n"
"def build_can_frame(can_id, data):\n"
"    can_dlc = len(data)\n"
"    data = data.ljust(8, b'\\x00')\n"
"    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n"
"\n"
"def dissect_can_frame(frame):\n"
"    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n"
"    return (can_id, can_dlc, data[:can_dlc])\n"
"\n"
"\n"
"# create a raw socket and bind it to the 'vcan0' interface\n"
"s = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n"
"s.bind(('vcan0',))\n"
"\n"
"while True:\n"
"    cf, addr = s.recvfrom(can_frame_size)\n"
"\n"
"    print('Received: can_id=%x, can_dlc=%x, data=%s' % dissect_can_frame(cf))\n"
"\n"
"    try:\n"
"        s.send(cf)\n"
"    except OSError:\n"
"        print('Error sending CAN frame')\n"
"\n"
"    try:\n"
"        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n"
"    except OSError:\n"
"        print('Error sending CAN frame')"
msgstr ""
"import socket\n"
"import struct\n"
"\n"
"\n"
"# CAN 帧打包/解包 (参见 <linux/can.h> 中的 'struct can_frame')\n"
"\n"
"can_frame_fmt = \"=IB3x8s\"\n"
"can_frame_size = struct.calcsize(can_frame_fmt)\n"
"\n"
"def build_can_frame(can_id, data):\n"
"    can_dlc = len(data)\n"
"    data = data.ljust(8, b'\\x00')\n"
"    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n"
"\n"
"def dissect_can_frame(frame):\n"
"    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n"
"    return (can_id, can_dlc, data[:can_dlc])\n"
"\n"
"\n"
"# 创建一个原始套接字并将其绑定到 'vcan0' 接口\n"
"s = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n"
"s.bind(('vcan0',))\n"
"\n"
"while True:\n"
"    cf, addr = s.recvfrom(can_frame_size)\n"
"\n"
"    print('Received: can_id=%x, can_dlc=%x, data=%s' % dissect_can_frame(cf))\n"
"\n"
"    try:\n"
"        s.send(cf)\n"
"    except OSError:\n"
"        print('Error sending CAN frame')\n"
"\n"
"    try:\n"
"        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n"
"    except OSError:\n"
"        print('Error sending CAN frame')"

#: ../../library/socket.rst:2285
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr "多次运行一个示例，且每次执行之间等待时间过短，可能导致这个错误::"

#: ../../library/socket.rst:2288
msgid "OSError: [Errno 98] Address already in use"
msgstr "OSError: [Errno 98] Address already in use"

#: ../../library/socket.rst:2290
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr "这是因为前一次运行使套接字处于 ``TIME_WAIT`` 状态，无法立即重用。"

#: ../../library/socket.rst:2293
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, "
":const:`socket.SO_REUSEADDR`::"
msgstr "要防止这种情况，需要设置一个 :mod:`socket` 旗标 :const:`socket.SO_REUSEADDR`::"

#: ../../library/socket.rst:2296
msgid ""
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n"
"s.bind((HOST, PORT))"
msgstr ""
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n"
"s.bind((HOST, PORT))"

#: ../../library/socket.rst:2300
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
":data:`SO_REUSEADDR` 标志告诉内核将处于 ``TIME_WAIT`` 状态的本地套接字重新使用，而不必等到固有的超时到期。"

#: ../../library/socket.rst:2306
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr "关于套接字编程（C 语言）的介绍，请参阅以下文章："

#: ../../library/socket.rst:2308
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*，作者 Stuart "
"Sechrest"

#: ../../library/socket.rst:2310
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*，作者 Samuel J.  "
"Leffler et al,"

#: ../../library/socket.rst:2313
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the"
" details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs,"
" readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"两篇文章都在 UNIX 开发者手册，补充文档 1（第 PS1:7 和 PS1:8 "
"节）中。那些特定于平台的参考资料，它们包含与套接字有关的各种系统调用，也是套接字语义细节的宝贵信息来源。对于 Unix，请参考手册页。对于 "
"Windows，请参阅 WinSock（或 Winsock 2）规范。如果需要支持 IPv6 的 API，读者可能希望参考 "
":rfc:`3493`，标题为 Basic Socket Interface Extensions for IPv6。"

#: ../../library/socket.rst:22
msgid "object"
msgstr "object -- 对象"

#: ../../library/socket.rst:22
msgid "socket"
msgstr "socket"

#: ../../library/socket.rst:1618
msgid "I/O control"
msgstr "I/O 控制"

#: ../../library/socket.rst:1618
msgid "buffering"
msgstr "缓冲"

#: ../../library/socket.rst:1970
msgid "module"
msgstr "module"

#: ../../library/socket.rst:1970
msgid "struct"
msgstr "struct"
