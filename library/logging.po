# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-21 15:15+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.rst:2
msgid ":mod:`!logging` --- Logging facility for Python"
msgstr ":mod:`!logging` --- Python 的日志记录工具"

#: ../../library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**源代码：** :source:`Lib/logging/__init__.py`"

#: ../../library/logging.rst:16
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr "此页面仅包含 API 参考信息。教程信息和更多高级用法的讨论，请参阅"

#: ../../library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基础教程 <logging-basic-tutorial>`"

#: ../../library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`进阶教程 <logging-advanced-tutorial>`"

#: ../../library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`日志记录操作手册 <logging-cookbook>`"

#: ../../library/logging.rst:25
msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr "这个模块为应用与库实现了灵活的事件日志系统的函数与类。"

#: ../../library/logging.rst:28
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"使用标准库提供的 logging API 最主要的好处是，所有的 Python 模块都可能参与日志输出，包括你自己的日志消息和第三方模块的日志消息。"

#: ../../library/logging.rst:33
msgid "Here's a simple example of idiomatic usage: ::"
msgstr "这是一个惯例用法的简单示例: ::"

#: ../../library/logging.rst:35
msgid ""
"# myapp.py\n"
"import logging\n"
"import mylib\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def main():\n"
"    logging.basicConfig(filename='myapp.log', level=logging.INFO)\n"
"    logger.info('Started')\n"
"    mylib.do_something()\n"
"    logger.info('Finished')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"# myapp.py\n"
"import logging\n"
"import mylib\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def main():\n"
"    logging.basicConfig(filename='myapp.log', level=logging.INFO)\n"
"    logger.info('Started')\n"
"    mylib.do_something()\n"
"    logger.info('Finished')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../library/logging.rst:51
msgid ""
"# mylib.py\n"
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def do_something():\n"
"    logger.info('Doing something')"
msgstr ""
"# mylib.py\n"
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def do_something():\n"
"    logger.info('Doing something')"

#: ../../library/logging.rst:58
msgid "If you run *myapp.py*, you should see this in *myapp.log*:"
msgstr "如果你运行 *myapp.py* ，你应该在 *myapp.log* 中看到："

#: ../../library/logging.rst:60
msgid ""
"INFO:__main__:Started\n"
"INFO:mylib:Doing something\n"
"INFO:__main__:Finished"
msgstr ""
"INFO:__main__:Started\n"
"INFO:mylib:Doing something\n"
"INFO:__main__:Finished"

#: ../../library/logging.rst:66
msgid ""
"The key feature of this idiomatic usage is that the majority of code is "
"simply creating a module level logger with ``getLogger(__name__)``, and "
"using that logger to do any needed logging. This is concise, while allowing "
"downstream code fine-grained control if needed. Logged messages to the "
"module-level logger get forwarded to handlers of loggers in higher-level "
"modules, all the way up to the highest-level logger known as the root "
"logger; this approach is known as hierarchical logging."
msgstr ""
"这种惯常用法的一个关键特性在于大部分代码都是简单地通过 ``getLogger(__name__)`` "
"创建一个模块级别的日志记录器，并使用该日志记录器来完成任何需要的日志记录。 这样既简洁明了，又能根据需要对下游代码进行细粒度的控制。 "
"记录到模块级日志记录器的消息会被转发给更高级别模块的日志记录器的处理器，一直到最高层级的日志记录器既根日志记录器；这种方式被称为分级日志记录。"

#: ../../library/logging.rst:74
msgid ""
"For logging to be useful, it needs to be configured: setting the levels and "
"destinations for each logger, potentially changing how specific modules log,"
" often based on command-line arguments or application configuration. In most"
" cases, like the one above, only the root logger needs to be so configured, "
"since all the lower level loggers at module level eventually forward their "
"messages to its handlers.  :func:`~logging.basicConfig` provides a quick way"
" to configure the root logger that handles many use cases."
msgstr ""
"要使日志记录有用，就需要对其进行配置：为每个日志记录器设置级别和目标，还可能改变特定模块的日志记录方式，通常是基于命令行参数或应用配置来实现。 "
"在大多数情况下，如上文所述，只有根日志记录器需要如此配置，因为所有在模块层级上的低级别日志记录器最终都会将消息转发给它的处理器。 "
":func:`~logging.basicConfig` 提供了一种配置根日志记录器的快捷方式，它可以处理多种应用场景。"

#: ../../library/logging.rst:82
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to view the"
" tutorials (**see the links above and on the right**)."
msgstr "这个模块提供许多强大而灵活的功能。如果对 logging 不太熟悉， 掌握它最好的方式就是查看它对应的教程（**详见右侧的链接**）。"

#: ../../library/logging.rst:86
msgid ""
"The basic classes defined by the module, together with their attributes and "
"methods, are listed in the sections below."
msgstr "该模块定义的基础类，以及它们的属性和方法都在下面的小节中列出。"

#: ../../library/logging.rst:89
msgid "Loggers expose the interface that application code directly uses."
msgstr "记录器暴露了应用程序代码直接使用的接口。"

#: ../../library/logging.rst:90
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "处理器将日志记录（由记录器创建）发送到适当的目标。"

#: ../../library/logging.rst:92
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr "过滤器提供了更细粒度的功能，用于确定要输出的日志记录。"

#: ../../library/logging.rst:94
msgid "Formatters specify the layout of log records in the final output."
msgstr "格式器指定最终输出中日志记录的样式。"

#: ../../library/logging.rst:100
msgid "Logger Objects"
msgstr "记录器对象"

#: ../../library/logging.rst:102
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should"
" *NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"记录器有以下的属性和方法。注意 *永远* 不要直接实例化记录器，应当通过模块级别的函数 ``logging.getLogger(name)`` "
"。多次使用相同的名字调用 :func:`getLogger` 会一直返回相同的 Logger 对象的引用。"

#: ../../library/logging.rst:107
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam``"
" are all descendants of ``foo``.  In addition, all loggers are descendants "
"of the root logger. The logger name hierarchy is analogous to the Python "
"package hierarchy, and identical to it if you organise your loggers on a "
"per-module basis using the recommended construction "
"``logging.getLogger(__name__)``.  That's because in a module, ``__name__`` "
"is the module's name in the Python package namespace."
msgstr ""
"``name`` 一般是以句点分割的层级值，如 ``foo.bar.baz`` (尽管也可以是简单形式，例如 ``foo``)。 "
"层级结构列表中位于下方的日志记录器是列表中较高位置的日志记录器的子级。 例如，假定有一个名叫 ``foo`` 的日志记录器，则名字为 "
"``foo.bar``, ``foo.bar.baz`` 和 ``foo.bam`` 的日志记录器都是 ``foo`` 的子级。 "
"而且，所有日志记录器都是根日志记录器的子级。 日志记录器名称的层级结构类似于 Python 包的层级结构，如果你使用建议的构造 "
"``logging.getLogger(__name__)`` 以每个模块为基础来组织你的日志记录器则将与后者完全一致。 "
"这是因为在一个模块中，``__name__`` 是该模块在 Python 包命名空间中的名字。"

#: ../../library/logging.rst:123
msgid ""
"This is the logger's name, and is the value that was passed to "
":func:`getLogger` to obtain the logger."
msgstr "这是日志记录器的名称，也是传给 :func:`getLogger` 用以获取日志记录器的值。"

#: ../../library/logging.rst:126 ../../library/logging.rst:186
msgid "This attribute should be treated as read-only."
msgstr "该属性应当被视为是只读的。"

#: ../../library/logging.rst:130
msgid "The threshold of this logger, as set by the :meth:`setLevel` method."
msgstr "该日志记录器的阈值，由 :meth:`setLevel` 方法设置。"

#: ../../library/logging.rst:132
msgid ""
"Do not set this attribute directly - always use :meth:`setLevel`, which has "
"checks for the level passed to it."
msgstr "请不要直接设置该值 —— 应当始终使用 :meth:`setLevel`，它会检查传入的级别。"

#: ../../library/logging.rst:137
msgid ""
"The parent logger of this logger. It may change based on later instantiation"
" of loggers which are higher up in the namespace hierarchy."
msgstr "此日志记录器的父日志记录器。它可能会根据命名空间层次结构中更高日志记录器的实例化而发生变化。"

#: ../../library/logging.rst:140
msgid "This value should be treated as read-only."
msgstr "该值应被视为只读 。"

#: ../../library/logging.rst:144
msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"如果这个属性为真，记录到这个记录器的事件除了会发送到此记录器的所有处理程序外，还会传递给更高级别（祖先）记录器的处理器，此外任何关联到这个记录器的处理器。消息会直接传递给祖先记录器的处理器"
" —— 不考虑祖先记录器的级别和过滤器。"

#: ../../library/logging.rst:150
msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr "如果为假，记录消息将不会传递给当前记录器的祖先记录器的处理器。"

#: ../../library/logging.rst:153
msgid ""
"Spelling it out with an example: If the propagate attribute of the logger "
"named ``A.B.C`` evaluates to true, any event logged to ``A.B.C`` via a "
"method call such as ``logging.getLogger('A.B.C').error(...)`` will [subject "
"to passing that logger's level and filter settings] be passed in turn to any"
" handlers attached to loggers named ``A.B``, ``A`` and the root logger, "
"after first being passed to any handlers attached to ``A.B.C``. If any "
"logger in the chain ``A.B.C``, ``A.B``, ``A`` has its ``propagate`` "
"attribute set to false, then that is the last logger whose handlers are "
"offered the event to handle, and propagation stops at that point."
msgstr ""
"举例说明：如果名为 ``A.B.C`` 的记录器的传播属性求值为真，则任何通过调用诸如 "
"``logging.getLogger('A.B.C').error(...)`` 之类的方法记录到 ``A.B.C`` 的事件，在第一次被传递到 "
"``A.B.C`` 上附加的处理器后，将[取决于传递该记录器的级别和过滤器设置]依次传递给附加到名为 ``A.B``，``A`` "
"的记录器和根记录器的所有处理器。如果 ``A.B.C``、``A.B``、``A`` 组成的链中，任一记录器的 ``propagate`` "
"属性设置为假，那么这将是最后一个其处理器会收到事件的记录器，此后传播在该点停止。"

#: ../../library/logging.rst:162
msgid "The constructor sets this attribute to ``True``."
msgstr "构造器将这个属性初始化为 ``True``。"

#: ../../library/logging.rst:164
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"如果你将一个处理器附加到一个记录器 *和* 其一个或多个祖先记录器，它可能发出多次相同的记录。通常，您不需要将一个处理器附加到一个以上的记录器上 —— "
"如果您将它附加到记录器层次结构中最高的适当记录器上，则它将看到所有后代记录器记录的所有事件，前提是它们的传播设置保留为 "
"``True``。一种常见的方案是仅将处理器附加到根记录器，通过传播来处理其余部分。"

#: ../../library/logging.rst:175
msgid "The list of handlers directly attached to this logger instance."
msgstr "直接连接到此记录器的处理程序列表实例。"

#: ../../library/logging.rst:177
msgid ""
"This attribute should be treated as read-only; it is normally changed via "
"the :meth:`addHandler` and :meth:`removeHandler` methods, which use locks to"
" ensure thread-safe operation."
msgstr ""
"该属性应被视为只读 ；通常通过 :meth:`addHandler` 和 :meth:`removeHandler` "
"方法进行更改，它们使用锁来确保线程安全的操作。"

#: ../../library/logging.rst:183
msgid ""
"This attribute disables handling of any events. It is set to ``False`` in "
"the initializer, and only changed by logging configuration code."
msgstr "该属性禁用对任何事件的处理。初始化程序将其设置为 ``False`` ，只有日志配置代码才能更改。"

#: ../../library/logging.rst:190
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"给记录器设置阈值为 *level* 。日志等级小于 *level* 会被忽略。严重性为 *level* "
"或更高的日志消息将由该记录器的任何一个或多个处理器发出，除非将处理器的级别设置为比 *level* 更高的级别。"

#: ../../library/logging.rst:195
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"创建记录器时，级别默认设置为 :const:`NOTSET` "
"（当记录器是根记录器时，将处理所有消息；如果记录器不是根记录器，则将委托给父级）。请注意，根记录器的默认级别为 :const:`WARNING` 。"

#: ../../library/logging.rst:200
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr ""
"委派给父级的意思是如果一个记录器的级别设置为 NOTSET，将遍历其祖先记录器，直到找到级别不是 NOTSET 的记录器，或者到根记录器为止。"

#: ../../library/logging.rst:204
msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's"
" level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr "如果发现某个父级的级别不是 NOTSET ，那么该父级的级别将被视为发起搜索的记录器的有效级别，并用于确定如何处理日志事件。"

#: ../../library/logging.rst:208
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will"
" be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr "如果搜索到达根记录器，并且其级别为 NOTSET，则将处理所有消息。否则，将使用根记录器的级别作为有效级别。"

#: ../../library/logging.rst:211 ../../library/logging.rst:555
msgid "See :ref:`levels` for a list of levels."
msgstr "参见 :ref:`levels` 级别列表。"

#: ../../library/logging.rst:213
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will "
"return/expect to be passed integers."
msgstr ""
"现在 *level* 参数可以接受形如 'INFO' 的级别字符串表示形式，以代替形如 :const:`INFO` 的整数常量。 "
"但是请注意，级别在内部存储为整数，并且 :meth:`getEffectiveLevel` 和 :meth:`isEnabledFor` "
"等方法的传入/返回值也为整数。"

#: ../../library/logging.rst:223
msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by "
"``logging.disable(level)`` and then the logger's effective level as "
"determined by :meth:`getEffectiveLevel`."
msgstr ""
"指示此记录器是否将处理级别为 *level* 的消息。此方法首先检查由 ``logging.disable(level)`` "
"设置的模块级的级别，然后检查由 :meth:`getEffectiveLevel` 确定的记录器的有效级别。"

#: ../../library/logging.rst:231
msgid ""
"Indicates the effective level for this logger. If a value other than "
":const:`NOTSET` has been set using :meth:`setLevel`, it is returned. "
"Otherwise, the hierarchy is traversed towards the root until a value other "
"than :const:`NOTSET` is found, and that value is returned. The value "
"returned is an integer, typically one of :const:`logging.DEBUG`, "
":const:`logging.INFO` etc."
msgstr ""
"指示此记录器的有效级别。如果通过 :meth:`setLevel` 设置了除 :const:`NOTSET` "
"以外的值，则返回该值。否则，将层次结构遍历到根，直到找到除 :const:`NOTSET` 以外的其他值，然后返回该值。返回的值是一个整数，通常为 "
":const:`logging.DEBUG`、 :const:`logging.INFO` 等等。"

#: ../../library/logging.rst:241
msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by "
"``logging.getLogger('abc.def.ghi')``. This is a convenience method, useful "
"when the parent logger is named using e.g. ``__name__`` rather than a "
"literal string."
msgstr ""
"返回由后缀确定的该记录器的后代记录器。 因此，``logging.getLogger('abc').getChild('def.ghi')`` 与 "
"``logging.getLogger('abc.def.ghi')`` 将返回相同的记录器。 这是一个便捷方法，当使用如 ``__name__`` "
"而不是字符串字面值命名父记录器时很有用。"

#: ../../library/logging.rst:252
msgid ""
"Returns a set of loggers which are immediate children of this logger. So for"
" example ``logging.getLogger().getChildren()`` might return a set containing"
" loggers named ``foo`` and ``bar``, but a logger named ``foo.bar`` wouldn't "
"be included in the set. Likewise, ``logging.getLogger('foo').getChildren()``"
" might return a set including a logger named ``foo.bar``, but it wouldn't "
"include one named ``foo.bar.baz``."
msgstr ""
"返回由该日志记录器的直接下级日志记录器组成的集合。 举例来说 ``logging.getLogger().getChildren()`` 将返回包含名为"
" ``foo`` 和 ``bar`` 的日志记录器的集合，但名为 ``foo.bar`` 的日志记录器则不会包括在集合中。 "
"类似地，``logging.getLogger('foo').getChildren()`` 将返回包括名为 ``foo.bar`` "
"的日志记录器的集合，但不会包括名为 ``foo.bar.baz`` 的日志记录器。"

#: ../../library/logging.rst:264
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary"
" argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"在此记录器上记录 :const:`DEBUG` 级别的消息。 *msg* 是消息格式字符串，而 *args* 是用于字符串格式化操作合并到 *msg* "
"的参数。（请注意，这意味着您可以在格式字符串中使用关键字以及单个字典参数。）当未提供 *args* 时，不会对 *msg* 执行 ％ 格式化操作。"

#: ../../library/logging.rst:270
msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr ""
"在 *kwargs* 中会检查四个关键字参数： *exc_info* ，*stack_info* ，*stacklevel* 和 *extra* 。"

#: ../../library/logging.rst:273
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to"
" be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"如果 *exc_info* 的求值结果不为 false ，则它将异常信息添加到日志消息中。如果提供了一个异常元组（按照 "
":func:`sys.exc_info` 返回的格式）或一个异常实例，则它将被使用；否则，调用 :func:`sys.exc_info` "
"以获取异常信息。"

#: ../../library/logging.rst:278
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"第二个可选关键字参数是 *stack_info*，默认为 ``False``。如果为  "
"True，则将堆栈信息添加到日志消息中，包括实际的日志调用。请注意，这与通过指定 *exc_info* "
"显示的堆栈信息不同：前者是从堆栈底部到当前线程中的日志记录调用的堆栈帧，而后者是在搜索异常处理程序时，跟踪异常而打开的堆栈帧的信息。"

#: ../../library/logging.rst:287
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"您可以独立于 *exc_info* 来指定 "
"*stack_info*，例如，即使在未引发任何异常的情况下，也可以显示如何到达代码中的特定点。堆栈帧在标题行之后打印："

#: ../../library/logging.rst:291
msgid "Stack (most recent call last):"
msgstr "Stack (most recent call last):"

#: ../../library/logging.rst:295
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr "这模仿了显示异常帧时所使用的 ``Traceback (most recent call last):`` 。"

#: ../../library/logging.rst:298
msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the "
":class:`LogRecord` created for the logging event. This can be used in "
"logging helpers so that the function name, filename and line number recorded"
" are not the information for the helper function/method, but rather its "
"caller. The name of this parameter mirrors the equivalent one in the "
":mod:`warnings` module."
msgstr ""
"第三个可选关键字参数是 *stacklevel* ，默认为 ``1`` 。如果大于 1 ，则在为日志记录事件创建的 :class:`LogRecord`"
" "
"中计算行号和函数名时，将跳过相应数量的堆栈帧。可以在记录帮助器时使用它，以便记录的函数名称，文件名和行号不是帮助器的函数/方法的信息，而是其调用方的信息。此参数是"
" :mod:`warnings` 模块中的同名等效参数。"

#: ../../library/logging.rst:306
msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the :attr:`~object.__dict__` of the "
":class:`LogRecord` created for the logging event with user-defined "
"attributes. These custom attributes can then be used as you like. For "
"example, they could be incorporated into logged messages. For example::"
msgstr ""
"第四个关键字参数 *extra* 被用于传递一个字典，该字典将被用来将为日志记录事件创建的 :class:`LogRecord` 中的 "
":attr:`~object.__dict__` 填充为用户自定义的属性。 然后你将可以随意使用这些自定义的属性。 "
"举例来说，它们可以被加入到已记录的日志消息中。 例如::"

#: ../../library/logging.rst:313
msgid ""
"FORMAT = '%(asctime)s %(clientip)-15s %(user)-8s %(message)s'\n"
"logging.basicConfig(format=FORMAT)\n"
"d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}\n"
"logger = logging.getLogger('tcpserver')\n"
"logger.warning('Protocol problem: %s', 'connection reset', extra=d)"
msgstr ""
"FORMAT = '%(asctime)s %(clientip)-15s %(user)-8s %(message)s'\n"
"logging.basicConfig(format=FORMAT)\n"
"d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}\n"
"logger = logging.getLogger('tcpserver')\n"
"logger.warning('Protocol problem: %s', 'connection reset', extra=d)"

#: ../../library/logging.rst:319
msgid "would print something like"
msgstr "输出类似于"

#: ../../library/logging.rst:321
msgid ""
"2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection "
"reset"
msgstr ""
"2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection "
"reset"

#: ../../library/logging.rst:325
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the section on :ref:`logrecord-attributes` "
"for more information on which keys are used by the logging system.)"
msgstr ""
"在The keys in the dictionary passed in *extra* 传入的字典的键不应与日志系统所使用的键相冲突。 （请参阅 "
":ref:`logrecord-attributes` 一节了解有关日志系统所使用的键的更多信息。）"

#: ../../library/logging.rst:329
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the "
":class:`Formatter` has been set up with a format string which expects "
"'clientip' and 'user' in the attribute dictionary of the :class:`LogRecord`."
" If these are missing, the message will not be logged because a string "
"formatting exception will occur. So in this case, you always need to pass "
"the *extra* dictionary with these keys."
msgstr ""
"如果在已记录的消息中使用这些属性，则需要格外小心。例如，在上面的示例中，:class:`Formatter` 已设置了格式字符串，其在 "
":class:`LogRecord` 的属性字典中键值为 “clientip” 和 "
"“user”。如果缺少这些内容，则将不会记录该消息，因为会引发字符串格式化异常。因此，在这种情况下，您始终需要使用 *extra* 字典传递这些键。"

#: ../../library/logging.rst:336
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is"
" likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"尽管这可能很烦人，但此功能旨在用于特殊情况，例如在多个上下文中执行相同代码的多线程服务器，并且出现的有趣条件取决于此上下文（例如在上面的示例中就是远程客户端IP地址和已验证用户名）。在这种情况下，很可能将专门的"
" :class:`Formatter` 与特定的 :class:`Handler` 一起使用。"

#: ../../library/logging.rst:343
msgid ""
"If no handler is attached to this logger (or any of its ancestors, taking "
"into account the relevant :attr:`Logger.propagate` attributes), the message "
"will be sent to the handler set on :data:`lastResort`."
msgstr ""
"如果没有处理器附加到这个记录器（或它的任何上级，会将相关的 :attr:`Logger.propagate` 属性也纳入考虑），消息将被发送到在 "
":data:`lastResort` 上设置的处理器。"

#: ../../library/logging.rst:347
msgid "The *stack_info* parameter was added."
msgstr "增加了 *stack_info* 参数。"

#: ../../library/logging.rst:350
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "*exc_info* 参数现在可以接受异常实例。"

#: ../../library/logging.rst:353
msgid "The *stacklevel* parameter was added."
msgstr "增加了 *stacklevel* 参数。"

#: ../../library/logging.rst:359
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr "在此记录器上记录 :const:`INFO` 级别的消息。参数解释同 :meth:`debug`。"

#: ../../library/logging.rst:365
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are"
" interpreted as for :meth:`debug`."
msgstr "在此记录器上记录 :const:`WARNING` 级别的消息。参数解释同 :meth:`debug`。"

#: ../../library/logging.rst:368
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"有一个功能上与 ``warning`` 一致的方法 ``warn``。由于 ``warn`` 已被弃用，请不要使用它 —— 改为使用 "
"``warning``。"

#: ../../library/logging.rst:374
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr "在此记录器上记录 :const:`ERROR` 级别的消息。参数解释同 :meth:`debug`。"

#: ../../library/logging.rst:380
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "在此记录器上记录 :const:`CRITICAL` 级别的消息。参数解释同 :meth:`debug`。"

#: ../../library/logging.rst:386
msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr "在此记录器上记录 *level* 整数代表的级别的消息。参数解释同 :meth:`debug`。"

#: ../../library/logging.rst:392
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"在此记录器上记录 :const:`ERROR` 级别的消息。参数解释同 "
":meth:`debug`。异常信息将添加到日志消息中。仅应从异常处理程序中调用此方法。"

#: ../../library/logging.rst:399
msgid "Adds the specified filter *filter* to this logger."
msgstr "将指定的过滤器 *filter* 添加到此记录器。"

#: ../../library/logging.rst:404
msgid "Removes the specified filter *filter* from this logger."
msgstr "从此记录器中删除指定的过滤器 *filter*。"

#: ../../library/logging.rst:409
msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will"
" be processed (passed to handlers). If one returns a false value, no further"
" processing of the record occurs."
msgstr ""
"将此记录器的过滤器应用于记录，如果记录能被处理则返回 "
"``True``。过滤器会被依次使用，直到其中一个返回假值为止。如果它们都不返回假值，则记录将被处理（传递给处理器）。如果返回任一为假值，则不会对该记录做进一步处理。"

#: ../../library/logging.rst:418
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "将指定的处理器 *hdlr* 添加到此记录器。"

#: ../../library/logging.rst:423
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "从此记录器中删除指定的处理器 *hdlr*。"

#: ../../library/logging.rst:428
msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"查找调用源的文件名和行号，以 文件名，行号，函数名称和堆栈信息 4元素元组的形式返回。堆栈信息将返回 ``None``，除非 *stack_info* "
"为 ``True``。"

#: ../../library/logging.rst:432
msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and"
" other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that"
" calls it."
msgstr ""
"*stacklevel* 参数用于调用 :meth:`debug` 和其他 API。如果大于 "
"1，则多余部分将用于跳过堆栈帧，然后再确定要返回的值。当从帮助器/包装器代码调用日志记录 API "
"时，这通常很有用，以便事件日志中的信息不是来自帮助器/包装器代码，而是来自调用它的代码。"

#: ../../library/logging.rst:442
msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method"
" is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using "
":meth:`~Logger.filter`."
msgstr ""
"通过将记录传递给与此记录器及其祖先关联的所有处理器来处理（直到某个 *propagate* 值为 "
"false）。此方法用于从套接字接收的未序列化的以及在本地创建的记录。使用 :meth:`~Logger.filter` 进行记录器级别过滤。"

#: ../../library/logging.rst:450
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr "这是一种工厂方法，可以在子类中对其进行重写以创建专门的 :class:`LogRecord` 实例。"

#: ../../library/logging.rst:455
msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy."
" Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"检查此记录器是否配置了任何处理器。通过在此记录器及其记录器层次结构中的父级中查找处理器完成此操作。如果找到处理器则返回 ``True``，否则返回 "
"``False``。只要找到 “propagate” 属性设置为假值的记录器，该方法就会停止搜索层次结构 —— "
"其将是最后一个检查处理器是否存在的记录器。"

#: ../../library/logging.rst:464
msgid "Loggers can now be pickled and unpickled."
msgstr "现在可以对处理器进行序列化和反序列化。"

#: ../../library/logging.rst:470
msgid "Logging Levels"
msgstr "日志级别"

#: ../../library/logging.rst:472
msgid ""
"The numeric values of logging levels are given in the following table. These"
" are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值，那么这你可能对以下内容感兴趣。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称将失效。"

#: ../../library/logging.rst:479
msgid "Level"
msgstr "级别"

#: ../../library/logging.rst:479
msgid "Numeric value"
msgstr "数值"

#: ../../library/logging.rst:479
msgid "What it means / When to use it"
msgstr "何种含义 / 何时使用"

#: ../../library/logging.rst:481
msgid "0"
msgstr "0"

#: ../../library/logging.rst:481
msgid ""
"When set on a logger, indicates that ancestor loggers are to be consulted to"
" determine the effective level. If that still resolves to :const:`!NOTSET`, "
"then all events are logged. When set on a handler, all events are handled."
msgstr ""
"当在日志记录器上设置时，表示将查询上级日志记录器以确定生效的级别。 如果仍被解析为 :const:`!NOTSET`，则会记录所有事件。 "
"在处理器上设置时，所有事件都将被处理。"

#: ../../library/logging.rst:489
msgid "10"
msgstr "10"

#: ../../library/logging.rst:489
msgid ""
"Detailed information, typically only of interest to a developer trying to "
"diagnose a problem."
msgstr "详细的信息，通常只有试图诊断问题的开发人员才会感兴趣。"

#: ../../library/logging.rst:493
msgid "20"
msgstr "20"

#: ../../library/logging.rst:493
msgid "Confirmation that things are working as expected."
msgstr "确认程序按预期运行。"

#: ../../library/logging.rst:496
msgid "30"
msgstr "30"

#: ../../library/logging.rst:496
msgid ""
"An indication that something unexpected happened, or that a problem might "
"occur in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr "表明发生了意外情况，或近期有可能发生问题（例如‘磁盘空间不足’）。 软件仍会按预期工作。"

#: ../../library/logging.rst:503
msgid "40"
msgstr "40"

#: ../../library/logging.rst:503
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr "由于严重的问题，程序的某些功能已经不能正常执行"

#: ../../library/logging.rst:507
msgid "50"
msgstr "50"

#: ../../library/logging.rst:507
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr "严重的错误，表明程序已不能继续执行"

#: ../../library/logging.rst:516
msgid "Handler Objects"
msgstr "处理器对象"

#: ../../library/logging.rst:518
msgid ""
"Handlers have the following attributes and methods. Note that "
":class:`Handler` is never instantiated directly; this class acts as a base "
"for more useful subclasses. However, the :meth:`!__init__` method in "
"subclasses needs to call :meth:`Handler.__init__`."
msgstr ""
"处理器具有以下属性和方法。 请注意 :class:`Handler` 不可直接实例化；该类是被作为更有用的子类的基类。 不过，子类中的 "
":meth:`!__init__` 方法需要调用 :meth:`Handler.__init__`。"

#: ../../library/logging.rst:527
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using "
":meth:`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"初始化 :class:`Handler` 实例时，需要设置它的级别，将过滤列表置为空，并且创建锁（通过 :meth:`createLock` "
"）来序列化对 I/O 的访问。"

#: ../../library/logging.rst:534
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr "初始化一个线程锁，用来序列化对底层的 I/O 功能的访问，底层的 I/O 功能可能不是线程安全的。"

#: ../../library/logging.rst:540
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr "获取由 :meth:`createLock` 创建的线程锁。"

#: ../../library/logging.rst:545
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr "释放由 :meth:`acquire` 获取的线程锁。"

#: ../../library/logging.rst:550
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"给处理器设置阈值为 *level* 。日志级别小于 *level* 将被忽略。创建处理器时，日志级别被设置为 :const:`NOTSET` "
"（所有的消息都会被处理）。"

#: ../../library/logging.rst:557
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr "*level* 形参现在接受像 'INFO' 这样的字符串形式的级别表达方式，也可以使用像 :const:`INFO` 这样的整数常量。"

#: ../../library/logging.rst:565
msgid ""
"Sets the formatter for this handler to *fmt*. The *fmt* argument must be a "
":class:`Formatter` instance or ``None``."
msgstr "将处理器的格式设为 *fmt*。 *fmt* 参数必须为 :class:`Formatter` 实例或 ``None``。"

#: ../../library/logging.rst:571
msgid "Adds the specified filter *filter* to this handler."
msgstr "将指定的过滤器 *filter* 添加到此处理器。"

#: ../../library/logging.rst:576
msgid "Removes the specified filter *filter* from this handler."
msgstr "从此处理器中删除指定的过滤器 *filter* 。"

#: ../../library/logging.rst:581
msgid ""
"Apply this handler's filters to the record and return ``True`` if the record"
" is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will"
" be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"将此处理器的过滤器应用于记录，在要处理记录时返回 ``True`` "
"。依次查询过滤器，直到其中一个返回假值为止。如果它们都不返回假值，则将发出记录。如果返回一个假值，则处理器将不会发出记录。"

#: ../../library/logging.rst:590
msgid ""
"Ensure all logging output has been flushed. This version does nothing and is"
" intended to be implemented by subclasses."
msgstr "确保所有日志记录从缓存输出。此版本不执行任何操作，并且应由子类实现。"

#: ../../library/logging.rst:596
msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal map of handlers, which is used for "
"handler lookup by name."
msgstr "清理处理器使用的所有资源。 此版本没有输出但会从内部处理器映射中移除处理器，该映射被用来按名称查找处理器。"

#: ../../library/logging.rst:600
msgid ""
"Subclasses should ensure that this gets called from overridden :meth:`close`"
" methods."
msgstr "子类应当通过重写 :meth:`close` 方法确保它会被调用。"

#: ../../library/logging.rst:606
msgid ""
"Conditionally emits the specified logging record, depending on filters which"
" may have been added to the handler. Wraps the actual emission of the record"
" with acquisition/release of the I/O thread lock."
msgstr "经已添加到处理器的过滤器过滤后，有条件地发出指定的日志记录。用获取/释放 I/O 线程锁包装了记录的实际发出行为。"

#: ../../library/logging.rst:613
msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute "
":data:`raiseExceptions` is ``False``, exceptions get silently ignored. This "
"is what is mostly wanted for a logging system - most users will not care "
"about errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception"
" occurred. (The default value of :data:`raiseExceptions` is ``True``, as "
"that is more useful during development)."
msgstr ""
"此方法应当在 :meth:`emit` 调用期间遇到异常时从处理器中调用。 如果模块级属性 :data:`raiseExceptions` 为 "
"``False``，则异常将被静默地忽略。 这是大多数情况下日志系统所需要的 —— 大多数用户不会关心日志系统中的错误，他们对应用程序错误更感兴趣。 "
"但是，你可以根据需要将其替换为自定义处理器。 指定的记录是发生异常时正在处理的记录。  (:data:`raiseExceptions` 的默认值是 "
"``True``，因为这在开发过程中更有用处）。"

#: ../../library/logging.rst:626
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr "如果设置了格式器则用其对记录进行格式化。否则，使用模块的默认格式器。"

#: ../../library/logging.rst:632
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a "
":exc:`NotImplementedError`."
msgstr "执行实际记录给定日志记录所需的操作。这个版本应由子类实现，因此这里直接引发 :exc:`NotImplementedError` 异常。"

#: ../../library/logging.rst:636
msgid ""
"This method is called after a handler-level lock is acquired, which is "
"released after this method returns. When you override this method, note that"
" you should be careful when calling anything that invokes other parts of the"
" logging API which might do locking, because that might result in a "
"deadlock. Specifically:"
msgstr ""
"此方法会在获得一个处理器层级的锁之后被调用，在此方法返回之后锁将被释放。 当你重写此方法时，请注意在调用任何可能执行锁定操作的日志记录 API "
"的其他部分的方法时务必小心谨慎，因为这可能会导致死锁。 具体来说:"

#: ../../library/logging.rst:642
msgid ""
"Logging configuration APIs acquire the module-level lock, and then "
"individual handler-level locks as those handlers are configured."
msgstr "日志记录配置 API 会获取模块层级锁，然后还会在配置处理器时获取处理器层级锁。"

#: ../../library/logging.rst:645
msgid ""
"Many logging APIs lock the module-level lock. If such an API is called from "
"this method, it could cause a deadlock if a configuration call is made on "
"another thread, because that thread will try to acquire the module-level "
"lock *before* the handler-level lock, whereas this thread tries to acquire "
"the module-level lock *after* the handler-level lock (because in this "
"method, the handler-level lock has already been acquired)."
msgstr ""
"许多日志记录 API 都会锁定模块级锁。 如果这样的 API "
"在此方法中被调用，则它可能会在另一个线程执行配置调用时导致死锁，因为那个线程将试图在处理器级锁 *之前* 获取模块级锁，而这个线程将试图在处理器级锁 "
"*之后* 获取模块级锁（因为在此方法中，处理器级锁已经被获取了）。"

#: ../../library/logging.rst:652
msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "有关作为标准随附的处理器列表，请参见 :mod:`logging.handlers`。"

#: ../../library/logging.rst:657
msgid "Formatter Objects"
msgstr "格式器对象"

#: ../../library/logging.rst:663
msgid ""
"Responsible for converting a :class:`LogRecord` to an output string to be "
"interpreted by a human or external system."
msgstr "负责将一个 :class:`LogRecord` 转换为可供人类或外部系统解读的输出字符串。"

#: ../../library/logging.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/logging.rst:666
msgid ""
"A format string in the given *style* for the logged output as a whole. The "
"possible mapping keys are drawn from the :class:`LogRecord` object's "
":ref:`logrecord-attributes`. If not specified, ``'%(message)s'`` is used, "
"which is just the logged message."
msgstr ""
"用于日志记录整体输出的给定 *style* 形式的格式字符串。 可用的映射键将从 :class:`LogRecord` 对象的 "
":ref:`logrecord-attributes` 中提取。 如果未指定，则将使用 ``'%(message)s'``，即已记录的日志消息。"

#: ../../library/logging.rst:674
msgid ""
"A format string in the given *style* for the date/time portion of the logged"
" output. If not specified, the default described in :meth:`formatTime` is "
"used."
msgstr ""
"用于日志记录输出的日期/时间部分的给定 *style* 形式的格式字符串。 如果未指定，则将使用 :meth:`formatTime` 中描述的默认值。"

#: ../../library/logging.rst:679
msgid ""
"Can be one of ``'%'``, ``'{'`` or ``'$'`` and determines how the format "
"string will be merged with its data: using one of :ref:`old-string-"
"formatting` (``%``), :meth:`str.format` (``{``) or :class:`string.Template` "
"(``$``). This only applies to *fmt* and *datefmt* (e.g. ``'%(message)s'`` "
"versus ``'{message}'``), not to the actual log messages passed to the "
"logging methods. However, there are :ref:`other ways <formatting-styles>` to"
" use ``{``- and ``$``-formatting for log messages."
msgstr ""
"可以是 ``'%'``, ``'{'`` 或 ``'$'`` 之一并决定格式字符串将如何与数据合并: 使用 :ref:`old-string-"
"formatting` (``%``), :meth:`str.format` (``{``) 或 :class:`string.Template` "
"(``$``) 之一。 这将只应用于 *fmt* 和 *datefmt* (例如 ``'%(message)s'`` 或 "
"``'{message}'``)，而不会应用于传给日志记录方法的实际日志消息。 但是，也存在 :ref:`其他方式 <formatting-"
"styles>` 可以为日志消息使用 ``{`` 和 ``$`` 格式化。"

#: ../../library/logging.rst:689
msgid ""
"If ``True`` (the default), incorrect or mismatched *fmt* and *style* will "
"raise a :exc:`ValueError`; for example, ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"如果为 ``True`` (默认值)，则不正确或不匹配的 *fmt* 和 *style* 将引发 :exc:`ValueError`；例如 "
"``logging.Formatter('%(asctime)s - %(message)s', style='{')``。"

#: ../../library/logging.rst:694
msgid ""
"A dictionary with default values to use in custom fields. For example, "
"``logging.Formatter('%(ip)s %(message)s', defaults={\"ip\": None})``"
msgstr ""
"一个由在自定义字段中使用的默认值组成的字典。 例如 ``logging.Formatter('%(ip)s %(message)s', "
"defaults={\"ip\": None})``"

#: ../../library/logging.rst:699
msgid "Added the *style* parameter."
msgstr "增加了 *style* 形参。"

#: ../../library/logging.rst:702
msgid "Added the *validate* parameter."
msgstr "增加了 *validate* 形参。"

#: ../../library/logging.rst:705
msgid "Added the *defaults* parameter."
msgstr "增加了 *defaults* 形参。"

#: ../../library/logging.rst:711
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using "
":meth:`formatException` and appended to the message. Note that the formatted"
" exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value (by setting the *exc_text* "
"attribute to ``None``) after a formatter has done its formatting, so that "
"the next formatter to handle the event doesn't use the cached value, but "
"recalculates it afresh."
msgstr ""
"记录的属性字典被用作字符串格式化操作的操作数。 返回结果字符串。 在格式化该字典之前，会执行几个预备步骤。 记录的 *message* 属性是用 "
"*msg* % *args* 来计算的。 如果格式化字符串包含 ``'(asctime)'``，则会调用 :meth:`formatTime` "
"来格式化事件时间。 如果有异常信息，则使用 :meth:`formatException` 将其格式化并添加到消息中。 请注意已格式化的异常信息会缓存在"
" *exc_text* 属性中。 这很有用因为异常信息可以被 pickle 并通过网络发送，但是如果你有不止一个对异常信息进行定制的 "
":class:`Formatter` 子类则应当小心。 在这种情况下，你必须在一个格式化器完成格式化后清空缓存的值 (通过将 *exc_text* "
"属性设为 ``None``)，以便下一个处理事件的格式化器不会使用缓存的值，而是重新计算它。"

#: ../../library/logging.rst:727
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr "如果栈信息可用，它将被添加在异常信息之后，如有必要请使用 :meth:`formatStack` 来转换它。"

#: ../../library/logging.rst:733
msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters"
" to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with "
":func:`time.strftime` to format the creation time of the record. Otherwise, "
"the format '%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a "
"millisecond value and the other letters are as per the :func:`time.strftime`"
" documentation.  An example time in this format is ``2003-01-23 "
"00:29:50,411``.  The resulting string is returned."
msgstr ""
"此方法应由想要使用格式化时间的格式器中的 :meth:`format` 调用。可以在格式器中重写此方法以提供任何特定要求，但是基本行为如下：如果指定了 "
"*datefmt* （字符串），则将其用于 :func:`time.strftime` 来格式化记录的创建时间。否则，使用格式 '%Y-%m-%d "
"%H:%M:%S,uuu'，其中 uuu 部分是毫秒值，其他字母根据 :func:`time.strftime` 文档。这种时间格式的示例为 "
"``2003-01-23 00:29:50,411``。返回结果字符串。"

#: ../../library/logging.rst:743
msgid ""
"This function uses a user-configurable function to convert the creation time"
" to a tuple. By default, :func:`time.localtime` is used; to change this for "
"a particular formatter instance, set the ``converter`` attribute to a "
"function with the same signature as :func:`time.localtime` or "
":func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` attribute "
"in the ``Formatter`` class."
msgstr ""
"此函数使用一个用户可配置函数将创建时间转换为元组。 默认情况下，使用 "
":func:`time.localtime`；要为特定格式化程序实例更改此项，请将实例的 ``converter`` 属性设为具有与 "
":func:`time.localtime` 或 :func:`time.gmtime` 相同签名的函数。 "
"要为所有格式化程序更改此项，例如当你希望所有日志时间都显示为 GMT，请在 ``Formatter`` 类中设置 ``converter`` 属性。"

#: ../../library/logging.rst:751
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"在之前版本中，默认格式是被硬编码的，例如这个例子: ``2010-09-06 22:38:15,292`` 其中逗号之前的部分由 strptime "
"格式字符串 (``'%Y-%m-%d %H:%M:%S'``) 处理，而逗号之后的部分为毫秒值。 因为 strptime "
"没有表示毫秒的占位符，毫秒值使用了另外的格式字符串来添加 ``'%s,%03d'`` --- 这两个格式字符串代码都是硬编码在该方法中的。 "
"经过修改，这些字符串被定义为类层级的属性，当需要时可以在实例层级上被重写。 属性的名称为 ``default_time_format`` (用于 "
"strptime 格式字符串) 和 ``default_msec_format`` (用于添加毫秒值)。"

#: ../../library/logging.rst:764
msgid "The ``default_msec_format`` can be ``None``."
msgstr "``default_msec_format`` 可以为 ``None``。"

#: ../../library/logging.rst:769
msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"将指定的异常信息（由 :func:`sys.exc_info` 返回的标准异常元组）格式化为字符串。默认实现只是使用了 "
":func:`traceback.print_exception`。 结果字符串将被返回。"

#: ../../library/logging.rst:776
msgid ""
"Formats the specified stack information (a string as returned by "
":func:`traceback.print_stack`, but with the last newline removed) as a "
"string. This default implementation just returns the input value."
msgstr ""
"将指定的堆栈信息（由 :func:`traceback.print_stack` 返回的字符串，但移除末尾的换行符）格式化为字符串。 "
"默认实现只是返回输入值。"

#: ../../library/logging.rst:782
msgid ""
"A base formatter class suitable for subclassing when you want to format a "
"number of records. You can pass a :class:`Formatter` instance which you want"
" to use to format each line (that corresponds to a single record). If not "
"specified, the default formatter (which just outputs the event message) is "
"used as the line formatter."
msgstr ""
"适合用来在你想要格式化多条记录时进行子类化的格式化器。 你可以传入一个 :class:`Formatter` "
"实例用来格式化每一行（每一行对应一条记录）。 如果未被指定，则会使用默认的格式化器（仅输出事件消息）作为行格式化器。"

#: ../../library/logging.rst:790
msgid ""
"Return a header for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records, a title or a "
"separator line."
msgstr ""
"为 *records* 列表返回一个标头。 基本实现只是返回空字符串。 如果你想要指明特定行为则需要重写此方法，例如显示记录条数、标题或分隔行等。"

#: ../../library/logging.rst:797
msgid ""
"Return a footer for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records or a separator line."
msgstr ""
"为 *records* 列表返回一个结束标记。 基本实现只是返回空字符串。 如果你想要指明特定行为则需要重写此方法，例如显示记录条数或分隔行等。"

#: ../../library/logging.rst:804
msgid ""
"Return formatted text for a list of *records*. The base implementation just "
"returns the empty string if there are no records; otherwise, it returns the "
"concatenation of the header, each record formatted with the line formatter, "
"and the footer."
msgstr ""
"为 *records* 列表返回已格式化文本。 "
"基本实现在没有记录时只是返回空字符串；在其他情况下，它将返回标头、使用行格式化器执行格式化的每行记录以及结束标记。"

#: ../../library/logging.rst:812
msgid "Filter Objects"
msgstr "过滤器对象"

#: ../../library/logging.rst:814
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc."
" If initialized with the empty string, all events are passed."
msgstr ""
"``Filters`` 可被 ``Handlers`` 和 ``Loggers`` 用来实现比按层级提供更复杂的过滤操作。 "
"基本过滤器类只允许低于日志记录器层级结构中低于特定层级的事件。 例如，一个用 'A.B' 初始化的过滤器将允许 'A.B', 'A.B.C', "
"'A.B.C.D', 'A.B.D' 等日志记录器所记录的事件。 但 'A.BB', 'B.A.B' 等则不允许。 "
"如果用空字符串初始化，则所有事件都会通过。"

#: ../../library/logging.rst:824
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it"
" names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""
"返回一个 :class:`Filter` 类的实例。 如果指定了 "
"*name*，则它将被用来为日志记录器命名，该类及其子类将通过该过滤器允许指定事件通过。 如果 *name* 为空字符串，则允许所有事件通过。"

#: ../../library/logging.rst:831
msgid ""
"Is the specified record to be logged? Returns false for no, true for yes. "
"Filters can either modify log records in-place or return a completely "
"different record instance which will replace the original log record in any "
"future processing of the event."
msgstr ""
"指定的记录是否会被写入日志？否则返回假值，是则返回真值。 "
"过滤器可以原地修改日志记录或者返回完全不同的记录实例并在该事件未来的任何处理过程中用它来替代原始日志记录。"

#: ../../library/logging.rst:836
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant "
"loggers."
msgstr ""
"请注意关联到处理器的过滤器会在事件由处理器发出之前被查询，而关联到日志记录器的过滤器则会在有事件被记录的的任何时候（使用 :meth:`debug`, "
":meth:`info` 等等）在将事件发送给处理器之前被查询。 "
"这意味着由后代日志记录器生成的事件将不会被父代日志记录器的过滤器设置所过滤，除非该过滤器也已被应用于后代日志记录器。"

#: ../../library/logging.rst:843
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr "你实际上不需要子类化 ``Filter`` ：你可以传入任何一个包含有相同语义的 ``filter`` 方法的实例。"

#: ../../library/logging.rst:846
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable)"
" as a filter. The filtering logic will check to see if the filter object has"
" a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its"
" :meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""
"你不需要创建专门的 ``Filter`` 类，或使用具有 ``filter`` 方法的其他类：你可以使用一个函数（或其他可调用对象）作为过滤器。 "
"过滤逻辑将检查过滤器对象是否具有 ``filter`` 属性：如果有，就会将它当作是 ``Filter`` 并调用它的 "
":meth:`~Filter.filter` 方法。 在其他情况下，则会将它当作是可调用对象并将记录作为唯一的形参进行调用。 返回值应当与 "
":meth:`~Filter.filter` 的返回值相一致。"

#: ../../library/logging.rst:856
msgid ""
"You can now return a :class:`LogRecord` instance from filters to replace the"
" log record rather than modifying it in place. This allows filters attached "
"to a :class:`Handler` to modify the log record before it is emitted, without"
" having side effects on other handlers."
msgstr ""
"现在你可以从过滤器返回一个 :class:`LogRecord` 实例来替代日志记录而不是原地修改它。 这允许附加到特定 "
":class:`Handler` 的过滤器在日志记录发出之前修改它，而不会对其他处理器产生附带影响。"

#: ../../library/logging.rst:862
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""
"尽管过滤器主要被用来构造比层级更复杂的规则以过滤记录，但它们可以查看由它们关联的处理器或记录器所处理的每条记录：当你想要执行统计特定记录器或处理器共处理了多少条记录，或是在所处理的"
" :class:`LogRecord` 中添加、修改或移除属性这样的任务时该特性将很有用处。 显然改变 LogRecord "
"时需要相当小心，但将上下文信息注入日志确实是被允许的 (参见 :ref:`filters-contextual`)。"

#: ../../library/logging.rst:875
msgid "LogRecord Objects"
msgstr "LogRecord 属性"

#: ../../library/logging.rst:877
msgid ""
":class:`LogRecord` instances are created automatically by the "
":class:`Logger` every time something is logged, and can be created manually "
"via :func:`makeLogRecord` (for example, from a pickled event received over "
"the wire)."
msgstr ""
":class:`LogRecord` 实例是每当有日志被记录时由 :class:`Logger` 自动创建的，并且可通过 "
":func:`makeLogRecord` 手动创建（例如根据从网络接收的已封存事件创建）。"

#: ../../library/logging.rst:885
msgid "Contains all the information pertinent to the event being logged."
msgstr "包含与被记录的事件相关的所有信息。"

#: ../../library/logging.rst:887
msgid ""
"The primary information is passed in *msg* and *args*, which are combined "
"using ``msg % args`` to create the :attr:`!message` attribute of the record."
msgstr ""
"主要信息是在 *msg* 中 *args* 传递的，它们使用 ``msg % args`` 组合到一起以创建记录的 :attr:`!message` "
"属性。"

#: ../../library/logging.rst:891
msgid ""
"The name of the logger used to log the event represented by this "
":class:`!LogRecord`. Note that the logger name in the :class:`!LogRecord` "
"will always have this value, even though it may be emitted by a handler "
"attached to a different (ancestor) logger."
msgstr ""
"用于记录此 :class:`!LogRecord` 所表示事件的记录器名称。 请注意 :class:`!LogRecord` "
"中的记录器名称将始终为该值，即使它可能是由附加到不同（上级）日志记录器的处理器所发出的。"

#: ../../library/logging.rst:899
msgid ""
"The :ref:`numeric level <levels>` of the logging event (such as ``10`` for "
"``DEBUG``, ``20`` for ``INFO``, etc). Note that this is converted to *two* "
"attributes of the LogRecord: :attr:`!levelno` for the numeric value and "
":attr:`!levelname` for the corresponding level name."
msgstr ""
"日志记录事件的 :ref:`数字层级 <levels>` (如 ``10`` 表示 ``DEBUG``, ``20`` 表示 ``INFO`` 等等)。"
" 请注意这会转换为 LogRecord 的 *两个* 属性: :attr:`!levelno` 表示数字值而 :attr:`!levelname` "
"表示对应的层级名。"

#: ../../library/logging.rst:906
msgid ""
"The full string path of the source file where the logging call was made."
msgstr "日志记录调用所在源文件的完整路径字符串。"

#: ../../library/logging.rst:910
msgid "The line number in the source file where the logging call was made."
msgstr "记录调用所在源文件中的行号。"

#: ../../library/logging.rst:914
msgid ""
"The event description message, which can be a %-format string with "
"placeholders for variable data, or an arbitrary object (see :ref:`arbitrary-"
"object-messages`)."
msgstr ""
"事件描述消息，这可以是一个带有 % 形式可变数据占位符的格式字符串，或是任意对象 (参见 :ref:`arbitrary-object-"
"messages`)。"

#: ../../library/logging.rst:919
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr "要合并到 *msg* 参数以获得事件描述的可变数据。"

#: ../../library/logging.rst:923
msgid ""
"An exception tuple with the current exception information, as returned by "
":func:`sys.exc_info`, or ``None`` if no exception information is available."
msgstr "包含当前异常信息的异常元组，就如 :func:`sys.exc_info` 所返回的，或者如果没有可用异常信息则为 ``None``。"

#: ../../library/logging.rst:928
msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr "唤起日志记录调用的函数或方法名称。"

#: ../../library/logging.rst:932
msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr "一个文本字符串，表示当前线程中从堆栈底部直到日志记录调用的堆栈信息。"

#: ../../library/logging.rst:939
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to"
" convert it to a string. This allows use of user-defined classes as "
"messages, whose ``__str__`` method can return the actual format string to be"
" used."
msgstr ""
"在将 :class:`LogRecord` 实例与任何用户提供的参数合并之后，返回此实例的消息。 "
"如果用户提供给日志记录调用的消息参数不是字符串，则会在其上调用 :func:`str` 以将它转换为字符串。 此方法允许将用户定义的类用作消息，类的 "
"``__str__`` 方法可以返回要使用的实际格式字符串。"

#: ../../library/logging.rst:946
msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""
"通过提供用于创建记录的工厂方法已使得 :class:`LogRecord` 的创建更易于配置。 该工厂方法可使用 "
":func:`getLogRecordFactory` 和 :func:`setLogRecordFactory` （在此可查看工厂方法的签名）来设置。"

#: ../../library/logging.rst:952
msgid ""
"This functionality can be used to inject your own values into a "
":class:`LogRecord` at creation time. You can use the following pattern::"
msgstr "在创建时可使用此功能将你自己的值注入 :class:`LogRecord`。 你可以使用以下模式::"

#: ../../library/logging.rst:955
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"

#: ../../library/logging.rst:964
msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr "通过此模式，多个工厂方法可以被链接起来，并且只要它们不重写彼此的属性或是在无意中覆盖了上面列出的标准属性，就不会发生意外。"

#: ../../library/logging.rst:973
msgid "LogRecord attributes"
msgstr "LogRecord 属性"

#: ../../library/logging.rst:975
msgid ""
"The LogRecord has a number of attributes, most of which are derived from the"
" parameters to the constructor. (Note that the names do not always "
"correspond exactly between the LogRecord constructor parameters and the "
"LogRecord attributes.) These attributes can be used to merge data from the "
"record into the format string. The following table lists (in alphabetical "
"order) the attribute names, their meanings and the corresponding placeholder"
" in a %-style format string."
msgstr ""
"LogRecord 具有许多属性，它们大多数来自于传递给构造器的形参。 （请注意 LogRecord 构造器形参与 LogRecord "
"属性的名称并不总是完全彼此对应的。） 这些属性可被用于将来自记录的数据合并到格式字符串中。 下面的表格（按字母顺序）列出了属性名称、它们的含义以及相应的"
" %-style 格式字符串内占位符。"

#: ../../library/logging.rst:983
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use "
"``{attrname}`` as the placeholder in the format string. If you are using "
"$-formatting (:class:`string.Template`), use the form ``${attrname}``. In "
"both cases, of course, replace ``attrname`` with the actual attribute name "
"you want to use."
msgstr ""
"如果是使用 {}-格式化（:func:`str.format`），你可以将 ``{attrname}`` 用作格式字符串内的占位符。 如果是使用 "
"$-格式化（:class:`string.Template`），则会使用 ``${attrname}`` 的形式。 当然在这两种情况下，都应当将 "
"``attrname`` 替换为你想要使用的实际属性名称。"

#: ../../library/logging.rst:989
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03.0f}`` would format a millisecond value of ``4``"
" as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""
"在 {}-格式化的情况下，你可以在属性名称之后放置指定的格式化旗标，并用冒号来分隔。 例如：占位符 ``{msecs:03.0f}`` 会将毫秒值 "
"``4`` 格式化为 ``004``。 有参看 :meth:`str.format` 文档了解你可以使用的选项的详情。"

#: ../../library/logging.rst:996
msgid "Attribute name"
msgstr "属性名称"

#: ../../library/logging.rst:996 ../../library/logging.rst:1366
msgid "Format"
msgstr "格式"

#: ../../library/logging.rst:996 ../../library/logging.rst:1366
msgid "Description"
msgstr "描述"

#: ../../library/logging.rst:0 ../../library/logging.rst:998
msgid "args"
msgstr "args"

#: ../../library/logging.rst:998 ../../library/logging.rst:1012
#: ../../library/logging.rst:1040 ../../library/logging.rst:1058
msgid "You shouldn't need to format this yourself."
msgstr "此属性不需要用户进行格式化。"

#: ../../library/logging.rst:998
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict"
" whose values are used for the merge (when there is only one argument, and "
"it is a dictionary)."
msgstr ""
"合并到 ``msg`` 以产生 ``message`` 的包含参数的元组，或是其中的值将被用于合并的字典（当只有一个参数且其类型为字典时）。"

#: ../../library/logging.rst:1003
msgid "asctime"
msgstr "asctime"

#: ../../library/logging.rst:1003
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../../library/logging.rst:1003
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""
"表示人类易读的 :class:`LogRecord` 生成时间。 默认形式为 '2003-07-08 16:49:45,896' "
"（逗号之后的数字为时间的毫秒部分）。"

#: ../../library/logging.rst:1009
msgid "created"
msgstr "created"

#: ../../library/logging.rst:1009
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../../library/logging.rst:1009
msgid ""
"Time when the :class:`LogRecord` was created (as returned by "
":func:`time.time_ns` / 1e9)."
msgstr "当 :class:`LogRecord` 被创建的时间（即 :func:`time.time_ns` / 1e9 所返回的值）。"

#: ../../library/logging.rst:0 ../../library/logging.rst:1012
msgid "exc_info"
msgstr "exc_info"

#: ../../library/logging.rst:1012
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr "异常元组（例如 ``sys.exc_info``）或者如未发生异常则为 ``None``。"

#: ../../library/logging.rst:1015
msgid "filename"
msgstr "filename"

#: ../../library/logging.rst:1015
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../../library/logging.rst:1015
msgid "Filename portion of ``pathname``."
msgstr "``pathname`` 的文件名部分。"

#: ../../library/logging.rst:1017
msgid "funcName"
msgstr "funcName"

#: ../../library/logging.rst:1017
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../../library/logging.rst:1017
msgid "Name of function containing the logging call."
msgstr "函数名包括调用日志记录."

#: ../../library/logging.rst:1019
msgid "levelname"
msgstr "levelname"

#: ../../library/logging.rst:1019
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../../library/logging.rst:1019
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"消息文本记录级别（``'DEBUG'``，``'INFO'``，``'WARNING'``，``'ERROR'``，``'CRITICAL'``）。"

#: ../../library/logging.rst:1023
msgid "levelno"
msgstr "levelno"

#: ../../library/logging.rst:1023
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../../library/logging.rst:1023
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"消息数字的记录级别 (:const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR`, "
":const:`CRITICAL`)."

#: ../../library/logging.rst:1028
msgid "lineno"
msgstr "lineno"

#: ../../library/logging.rst:1028
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../../library/logging.rst:1028
msgid "Source line number where the logging call was issued (if available)."
msgstr "发出日志记录调用所在的源行号（如果可用）。"

#: ../../library/logging.rst:1031
msgid "message"
msgstr "message"

#: ../../library/logging.rst:1031
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../../library/logging.rst:1031
msgid ""
"The logged message, computed as ``msg % args``. This is set when "
":meth:`Formatter.format` is invoked."
msgstr "记入日志的消息，即 ``msg % args`` 的结果。 这是在唤起 :meth:`Formatter.format` 时设置的。"

#: ../../library/logging.rst:1035
msgid "module"
msgstr "module"

#: ../../library/logging.rst:1035
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../../library/logging.rst:1035
msgid "Module (name portion of ``filename``)."
msgstr "模块 (``filename`` 的名称部分)。"

#: ../../library/logging.rst:1037
msgid "msecs"
msgstr "msecs"

#: ../../library/logging.rst:1037
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../../library/logging.rst:1037
msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr ":class:`LogRecord` 被创建的时间的毫秒部分。"

#: ../../library/logging.rst:0 ../../library/logging.rst:1040
msgid "msg"
msgstr "msg"

#: ../../library/logging.rst:1040
msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""
"在原始日志记录调用中传入的格式字符串。 与 ``args`` 合并以产生 ``message``，或是一个任意对象 (参见 "
":ref:`arbitrary-object-messages`)。"

#: ../../library/logging.rst:0 ../../library/logging.rst:1045
msgid "name"
msgstr "name"

#: ../../library/logging.rst:1045
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../../library/logging.rst:1045
msgid "Name of the logger used to log the call."
msgstr "用于记录调用的日志记录器名称。"

#: ../../library/logging.rst:1047
msgid "pathname"
msgstr "pathname"

#: ../../library/logging.rst:1047
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../../library/logging.rst:1047
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr "发出日志记录调用的源文件的完整路径名（如果可用）。"

#: ../../library/logging.rst:1050
msgid "process"
msgstr "process"

#: ../../library/logging.rst:1050
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../../library/logging.rst:1050
msgid "Process ID (if available)."
msgstr "进程ID（如果可用）"

#: ../../library/logging.rst:1052
msgid "processName"
msgstr "processName"

#: ../../library/logging.rst:1052
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../../library/logging.rst:1052
msgid "Process name (if available)."
msgstr "进程名（如果可用）"

#: ../../library/logging.rst:1054
msgid "relativeCreated"
msgstr "relativeCreated"

#: ../../library/logging.rst:1054
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../../library/logging.rst:1054
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr "以毫秒数表示的 LogRecord 被创建的时间，即相对于 logging 模块被加载时间的差值。"

#: ../../library/logging.rst:1058
msgid "stack_info"
msgstr "stack_info"

#: ../../library/logging.rst:1058
msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr "当前线程中从堆栈底部起向上直到包括日志记录调用并引发创建当前记录堆栈帧创建的堆栈帧信息（如果可用）。"

#: ../../library/logging.rst:1064
msgid "thread"
msgstr "thread"

#: ../../library/logging.rst:1064
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../../library/logging.rst:1064
msgid "Thread ID (if available)."
msgstr "线程ID（如果可用）"

#: ../../library/logging.rst:1066
msgid "threadName"
msgstr "threadName"

#: ../../library/logging.rst:1066
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../../library/logging.rst:1066
msgid "Thread name (if available)."
msgstr "线程名（如果可用）"

#: ../../library/logging.rst:1068
msgid "taskName"
msgstr "taskName"

#: ../../library/logging.rst:1068
msgid "``%(taskName)s``"
msgstr "``%(taskName)s``"

#: ../../library/logging.rst:1068
msgid ":class:`asyncio.Task` name (if available)."
msgstr ":class:`asyncio.Task` 名称（如果可用）。"

#: ../../library/logging.rst:1071
msgid "*processName* was added."
msgstr "添加了 *processName* "

#: ../../library/logging.rst:1074
msgid "*taskName* was added."
msgstr "添加了 *taskName*。"

#: ../../library/logging.rst:1080
msgid "LoggerAdapter Objects"
msgstr "LoggerAdapter 对象"

#: ../../library/logging.rst:1082
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on "
":ref:`adding contextual information to your logging output <context-info>`."
msgstr ""
":class:`LoggerAdapter` 实例会被用来方便地将上下文信息传入日志记录调用。 要获取用法示例，请参阅 "
":ref:`添加上下文信息到你的日志记录输出 <context-info>` 部分。"

#: ../../library/logging.rst:1088
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an underlying"
" :class:`Logger` instance, a dict-like object (*extra*), and a boolean "
"(*merge_extra*) indicating whether or not the *extra* argument of individual"
" log calls should be merged with the :class:`LoggerAdapter` extra. The "
"default behavior is to ignore the *extra* argument of individual log calls "
"and only use the one of the :class:`LoggerAdapter` instance"
msgstr ""
"返回使用一个下层 :class:`Logger` 实例、一个字典型对象 (*extra*) 和一个指明单独日志调用的 *extra* 参数是否要与 "
":class:`LoggerAdapter` 的 extra 值合并的布尔值 (*merge_extra*) 进行初始化的 "
":class:`LoggerAdapter` 的实例。 其默认行为将忽略单独日志调用的 *extra* 参数并只使用 "
":class:`LoggerAdapter` 实例中的相应参数值。"

#: ../../library/logging.rst:1097
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object"
" passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""
"修改传递给日志记录调用的消息和/或关键字参数以便插入上下文信息。 此实现接受以 *extra* 形式传给构造器的对象并使用 'extra' 键名将其加入"
" *kwargs*。 返回值为一个 (*msg*, *kwargs*) 元组，其包含（可能经过修改的）传入参数。"

#: ../../library/logging.rst:1105
msgid "Delegates to the underlying :attr:`!manager` on *logger*."
msgstr "在 *logger* 中委托给下层的 :attr:`!manager`。"

#: ../../library/logging.rst:1109
msgid "Delegates to the underlying :meth:`!_log` method on *logger*."
msgstr "在 *logger* 中委托给下层的 :meth:`!_log` 方法。"

#: ../../library/logging.rst:1111
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, "
":meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, "
":meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`,"
" :meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and "
":meth:`~Logger.hasHandlers`. These methods have the same signatures as their"
" counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""
"在上述方法之外，:class:`LoggerAdapter` 还支持 :class:`Logger` 的下列方法: "
":meth:`~Logger.debug`, "
":meth:`~Logger.info`，:meth:`~Logger.warning`，:meth:`~Logger.error`, "
":meth:`~Logger.exception`, "
":meth:`~Logger.critical`，:meth:`~Logger.log`，:meth:`~Logger.isEnabledFor`，:meth:`~Logger.getEffectiveLevel`，:meth:`~Logger.setLevel`"
" 以及 :meth:`~Logger.hasHandlers`。 这些方法具有与它们在 :class:`Logger` "
"中的对应方法相同的签名，因此你可以互换使用这两种类型的实例。"

#: ../../library/logging.rst:1122
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added "
"to :class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""
":meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` 和 :meth:`~Logger.hasHandlers` 方法已被添加到 "
":class:`LoggerAdapter`。 这些方法会委托给下层的日志记录器。"

#: ../../library/logging.rst:1128
msgid ""
"Attribute :attr:`!manager` and method :meth:`!_log` were added, which "
"delegate to the underlying logger and allow adapters to be nested."
msgstr "增加了 :attr:`!manager` 属性和 :meth:`!_log` 方法，它们会委托给下层的日志记录器并允许适配器嵌套。"

#: ../../library/logging.rst:1133
msgid "The *merge_extra* argument was added."
msgstr "增加了 *merge_extra* 参数。"

#: ../../library/logging.rst:1137
msgid "Thread Safety"
msgstr "线程安全"

#: ../../library/logging.rst:1139
msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this through using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying "
"I/O."
msgstr ""

#: ../../library/logging.rst:1144
msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal`"
" module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""
"如果你要使用 :mod:`signal` 模块来实现异步信号处理程序，则可能无法在这些处理程序中使用 logging。 这是因为 "
":mod:`threading` 模块中的锁实现并非总是可重入的，所以无法从此类信号处理程序唤起。"

#: ../../library/logging.rst:1151
msgid "Module-Level Functions"
msgstr "模块级函数"

#: ../../library/logging.rst:1153
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr "在上述的类之外，还有一些模块级的函数。"

#: ../../library/logging.rst:1159
msgid ""
"Return a logger with the specified name or, if name is ``None``, return the "
"root logger of the hierarchy. If specified, the name is typically a dot-"
"separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c.d'*. Choice of "
"these names is entirely up to the developer who is using logging, though it "
"is recommended that ``__name__`` be used unless you have a specific reason "
"for not doing that, as mentioned in :ref:`logger`."
msgstr ""
"返回一个由 name 指定名称的日志记录器，或者如果 name 为 ``None`` 则返回层级结构中的根日志记录器。 如果指定了 "
"name，它通常是以点号分隔的带层级结构的名称如 *'a'*, *'a.b'* 或 *'a.b.c.d'*。 这些名称的选择完全取决于使用 "
"logging 的开发者，不过就如在 :ref:`logger` 中提到的那样建议使用 ``__name__``，除非你有不这样做的特别理由。"

#: ../../library/logging.rst:1166
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr "所有用给定的 name 对该函数的调用都将返回相同的日志记录器实例。 这意味着日志记录器实例不需要在应用的各部分间传递。"

#: ../../library/logging.rst:1173
msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""
"返回标准的 :class:`Logger` 类，或是最近传给 :func:`setLoggerClass` 的类。 "
"此函数可以从一个新的类定义中调用，以确保安装自定义的 :class:`Logger` 类不会撤销其他代码已经应用的自定义操作。 例如::"

#: ../../library/logging.rst:1178
msgid ""
"class MyLogger(logging.getLoggerClass()):\n"
"    # ... override behaviour here"
msgstr ""
"class MyLogger(logging.getLoggerClass()):\n"
"    # ... 在这里重写行为"

#: ../../library/logging.rst:1184
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr "返回一个被用来创建 :class:`LogRecord` 的可调用对象。"

#: ../../library/logging.rst:1186
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a"
" logging event is constructed."
msgstr ""
"此函数与 :func:`setLogRecordFactory` 一起提供，以允许开发者对表示日志记录事件的 :class:`LogRecord` "
"的构造有更好的控制。"

#: ../../library/logging.rst:1191
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr "请参阅 :func:`setLogRecordFactory` 了解有关如何调用该工厂方法的更多信息。"

#: ../../library/logging.rst:1196
msgid ""
"This is a convenience function that calls :meth:`Logger.debug`, on the root "
"logger. The handling of the arguments is in every way identical to what is "
"described in that method."
msgstr "这是在根日志记录器上调用 :meth:`Logger.debug` 的便捷函数。 其参数的处理方式与该方法中的描述完全一致。"

#: ../../library/logging.rst:1200
msgid ""
"The only difference is that if the root logger has no handlers, then "
":func:`basicConfig` is called, prior to calling ``debug`` on the root "
"logger."
msgstr ""
"唯一的区别在于如果根日志记录器没有处理器，则在根日志记录器上调用 ``debug`` 之前会先调用 :func:`basicConfig`。"

#: ../../library/logging.rst:1203
msgid ""
"For very short scripts or quick demonstrations of ``logging`` facilities, "
"``debug`` and the other module-level functions may be convenient. However, "
"most programs will want to carefully and explicitly control the logging "
"configuration, and should therefore prefer creating a module-level logger "
"and calling :meth:`Logger.debug` (or other level-specific methods) on it, as"
" described at the beginnning of this documentation."
msgstr ""
"对于非常简短的脚本或 ``logging`` 功能的快速演示，``debug`` 和其他模块级函数可能会很方便。 "
"不过，大多数程序都会想要仔细和显式地控制日志记录配置，所以应当更倾向于创建一个模块级的日志记录器并在其上调用 :meth:`Logger.debug` "
"(或其他特定级别的方法)，如本文档的开头所描述的那样。"

#: ../../library/logging.rst:1213
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`."
msgstr "在根日志记录器上记录一条 :const:`INFO` 级别的消息。 其他参数与行为均与 :func:`debug` 的相同。"

#: ../../library/logging.rst:1219
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments"
" and behavior are otherwise the same as for :func:`debug`."
msgstr "在根日志记录器上记录一条 :const:`WARNING` 级别的消息。 其他参数与行为均与 :func:`debug` 的相同。"

#: ../../library/logging.rst:1222
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"有一个已过时方法 ``warn`` 其功能与 ``warning`` 一致。 由于 ``warn`` 已被弃用，请不要使用它 —— 而是改用 "
"``warning``。"

#: ../../library/logging.rst:1229
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`."
msgstr "在根日志记录器上记录一条 :const:`ERROR` 级别的消息。 其他参数与行为均与 :func:`debug` 的相同。"

#: ../../library/logging.rst:1235
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments and behavior are otherwise the same as for :func:`debug`."
msgstr "在根日志记录器上记录一条 :const:`CRITICAL` 级别的消息。 其他参数与行为均与 :func:`debug` 的相同。"

#: ../../library/logging.rst:1241
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`. Exception info is "
"added to the logging message. This function should only be called from an "
"exception handler."
msgstr ""
"在根日志记录器上记录一条 :const:`ERROR` 级别的消息。 其他参数与行为均与 :func:`debug` 的相同。 "
"异常信息会被添加到日志记录消息中。 此函数应当仅从异常处理器中调用。"

#: ../../library/logging.rst:1247
msgid ""
"Logs a message with level *level* on the root logger. The arguments and "
"behavior are otherwise the same as for :func:`debug`."
msgstr "在根日志记录器上记录一条 *level* 级别的消息。 其他参数与行为均与 :func:`debug` 相同。"

#: ../../library/logging.rst:1252
msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would"
" be processed according to the logger's effective level. If "
"``logging.disable(logging.NOTSET)`` is called, it effectively removes this "
"overriding level, so that logging output again depends on the effective "
"levels of individual loggers."
msgstr ""
"为所有日志记录器提供重写的级别 *level*，其优先级高于日志记录器自己的级别。 当需要临时限制整个应用程序中的日志记录输出时，此功能会很有用。 "
"它的效果是禁用所有重要程度为 *level* 及以下的日志记录调用，因此如果你附带 INFO 值调用它，则所有 INFO 和 DEBUG "
"事件就会被丢弃，而重要程度为 WARNING 以及上的事件将根据日志记录器的当前有效级别来处理。 如果 "
"``logging.disable(logging.NOTSET)`` "
"被调用，它将移除这个重写的级别，因此日志记录输出会再次取决于单个日志记录器的有效级别。"

#: ../../library/logging.rst:1263
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""
"请注意如果你定义了任何高于 ``CRITICAL`` 的自定义日志级别（并不建议这样做），你就将无法沿用 *level* "
"形参的默认值，而必须显式地提供适当的值。"

#: ../../library/logging.rst:1268
msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See "
":issue:`28524` for more information about this change."
msgstr "*level* 形参默认级别为 ``CRITICAL``。 请参阅 :issue:`28524` 了解此项改变的更多细节。"

#: ../../library/logging.rst:1274
msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example"
" when a :class:`Formatter` formats a message. This function can also be used"
" to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""
"在一个内部字典中关联级别 *level* 与文本 *levelName*，该字典会被用来将数字级别映射为文本表示形式，例如在 "
":class:`Formatter` 格式化消息的时候。 此函数也可被用来定义你自己的级别。 "
"唯一的限制是自定义的所有级别必须使用此函数来注册，级别值必须为正整数并且其应随严重程度而递增。"

#: ../../library/logging.rst:1281
msgid ""
"If you are thinking of defining your own levels, please see the section on "
":ref:`custom-levels`."
msgstr "如果你考虑要定义你自己的级别，请参阅 :ref:`custom-levels` 部分。"

#: ../../library/logging.rst:1286
msgid ""
"Returns a mapping from level names to their corresponding logging levels. "
"For example, the string \"CRITICAL\" maps to :const:`CRITICAL`. The returned"
" mapping is copied from an internal mapping on each call to this function."
msgstr ""
"返回一个级别名到其对应日志记录级别的映射。 例如，字符串 \"CRITICAL\" 将映射到 :const:`CRITICAL`。 "
"所返回的映射是从每个对此函数的调用的内部映射拷贝的。"

#: ../../library/logging.rst:1294
msgid ""
"Returns the textual or numeric representation of logging level *level*."
msgstr "返回日志记录级别 *level* 的字符串表示。"

#: ../../library/logging.rst:1296
msgid ""
"If *level* is one of the predefined levels :const:`CRITICAL`, "
":const:`ERROR`, :const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you "
"get the corresponding string. If you have associated levels with names using"
" :func:`addLevelName` then the name you have associated with *level* is "
"returned. If a numeric value corresponding to one of the defined levels is "
"passed in, the corresponding string representation is returned."
msgstr ""
"如果 *level* 为预定义的级别 :const:`CRITICAL`, :const:`ERROR`, :const:`WARNING`, "
":const:`INFO` 或 :const:`DEBUG` 之一则你会得到相应的字符串。 如果你使用 :func:`addLevelName` "
"将级别关联到名称则返回你为 *level* 所关联的名称。 如果传入了与已定义级别相对应的数字值，则返回对应的字符串表示。"

#: ../../library/logging.rst:1303
msgid ""
"The *level* parameter also accepts a string representation of the level such"
" as 'INFO'. In such cases, this functions returns the corresponding numeric "
"value of the level."
msgstr "*level* 形参也接受级别的字符串表示例如 'INFO'。 在这种情况下，此函数将返回级别所对应的数字值。"

#: ../../library/logging.rst:1307
msgid ""
"If no matching numeric or string value is passed in, the string 'Level %s' %"
" level is returned."
msgstr "如果未传入可匹配的数字或字符串值，则返回字符串 'Level %s' % level。"

#: ../../library/logging.rst:1310
msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the "
"``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`), and "
"vice versa."
msgstr ""
"级别在内部以整数表示（因为它们在日志记录逻辑中需要进行比较）。 此函数被用于在整数级别与通过 ``%(levelname)s`` "
"格式描述符方式在格式化日志输出中显示的级别名称之间进行相互的转换 (参见 :ref:`logrecord-attributes`)。"

#: ../../library/logging.rst:1316
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""
"在早于 3.4 的 Python 版本中，此函数也可传入一个字符串形式的级别名称，并将返回对应的级别数字值。 此未记入文档的行为被视为是一个错误，并在 "
"Python 3.4 中被移除，但又在 3.4.2 中被恢复以保持向下兼容性。"

#: ../../library/logging.rst:1324
msgid ""
"Returns a handler with the specified *name*, or ``None`` if there is no "
"handler with that name."
msgstr "返回具有指定 *name* 的处理器，或者如果指定名称的处理器不存在则返回 ``None``。"

#: ../../library/logging.rst:1331
msgid "Returns an immutable set of all known handler names."
msgstr "返回一个由所有已知处理器名称组成的不可变集合。"

#: ../../library/logging.rst:1337
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled "
":class:`LogRecord` attribute dictionary, sent over a socket, and "
"reconstituting it as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"创建并返回一个新的 :class:`LogRecord` 实例，实例属性由 *attrdict* 定义。 此函数适用于接受一个通过套接字传输的封存好的 "
":class:`LogRecord` 属性字典，并在接收端将其重建为一个 :class:`LogRecord` 实例。"

#: ../../library/logging.rst:1345
msgid ""
"Does basic configuration for the logging system by creating a "
":class:`StreamHandler` with a default :class:`Formatter` and adding it to "
"the root logger. The functions :func:`debug`, :func:`info`, :func:`warning`,"
" :func:`error` and :func:`critical` will call :func:`basicConfig` "
"automatically if no handlers are defined for the root logger."
msgstr ""
"通过使用默认的 :class:`Formatter` 创建一个 :class:`StreamHandler` "
"并将其加入根日志记录器来为日志记录系统执行基本配置。 如果没有为根日志记录器定义处理器则 :func:`debug`, :func:`info`, "
":func:`warning`, :func:`error` 和 :func:`critical` 等函数将自动调用 "
":func:`basicConfig`。"

#: ../../library/logging.rst:1351
msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr "如果根日志记录器已配置了处理器则此函数将不执行任何操作，除非关键字参数 *force* 被设为 ``True``。"

#: ../../library/logging.rst:1354
msgid ""
"This function should be called from the main thread before other threads are"
" started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""
"此函数应当在其他线程启动之前从主线程被调用。 在 2.7.1 和 3.2 之前的 Python "
"版本中，如果此函数从多个线程被调用，一个处理器（在极少的情况下）有可能被多次加入根日志记录器，导致非预期的结果例如日志中的消息出现重复。"

#: ../../library/logging.rst:1361
msgid "The following keyword arguments are supported."
msgstr "支持以下关键字参数。"

#: ../../library/logging.rst:1368
msgid "*filename*"
msgstr "*filename*"

#: ../../library/logging.rst:1368
msgid ""
"Specifies that a :class:`FileHandler` be created, using the specified "
"filename, rather than a :class:`StreamHandler`."
msgstr "使用指定的文件名创建一个 :class:`FileHandler`，而不是 :class:`StreamHandler`。"

#: ../../library/logging.rst:1372
msgid "*filemode*"
msgstr "*filemode*"

#: ../../library/logging.rst:1372
msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr "如果指定了 *filename*，则用此 :ref:`模式 <filemodes>` 打开该文件。 默认模式为 ``'a'``。"

#: ../../library/logging.rst:1376
msgid "*format*"
msgstr "*format*"

#: ../../library/logging.rst:1376
msgid ""
"Use the specified format string for the handler. Defaults to attributes "
"``levelname``, ``name`` and ``message`` separated by colons."
msgstr "使用指定的格式字符串作为处理器。 默认为属性以冒号分隔的 ``levelname``, ``name`` 和 ``message``。"

#: ../../library/logging.rst:1381
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../../library/logging.rst:1381
msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr "使用指定的日期/时间格式，与 :func:`time.strftime` 所接受的格式相同。"

#: ../../library/logging.rst:1384
msgid "*style*"
msgstr "*style*"

#: ../../library/logging.rst:1384
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-formatting>`,"
" :meth:`str.format` or :class:`string.Template` respectively. Defaults to "
"``'%'``."
msgstr ""
"如果指定了 *format*，将为格式字符串使用此风格。 ``'%'``, ``'{'`` 或 ``'$'`` 分别对应于 :ref:`printf "
"风格 <old-string-formatting>`, :meth:`str.format` 或 :class:`string.Template`。 "
"默认为 ``'%'``。"

#: ../../library/logging.rst:1392
msgid "*level*"
msgstr "*level*"

#: ../../library/logging.rst:1392
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr "设置根记录器级别为指定的 :ref:`level <levels>`."

#: ../../library/logging.rst:1395
msgid "*stream*"
msgstr "*stream*"

#: ../../library/logging.rst:1395
msgid ""
"Use the specified stream to initialize the :class:`StreamHandler`. Note that"
" this argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"使用指定的流初始化 :class:`StreamHandler`。 请注意此参数与 *filename* 不兼容 —— 如果两者同时存在，则会引发 "
"``ValueError``。"

#: ../../library/logging.rst:1401
msgid "*handlers*"
msgstr "*handlers*"

#: ../../library/logging.rst:1401
msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""
"如果指定，这应为一个包含要加入根日志记录器的已创建处理器的可迭代对象。 任何尚未设置格式描述符的处理器将被设置为在此函数中创建的默认格式描述符。 "
"请注意此参数与 *filename* 或 *stream* 不兼容 —— 如果两者同时存在，则会引发 ``ValueError``。"

#: ../../library/logging.rst:1410
msgid "*force*"
msgstr "*force*"

#: ../../library/logging.rst:1410
msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr "如果将此关键字参数指定为 true，则在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。"

#: ../../library/logging.rst:1416
msgid "*encoding*"
msgstr "*encoding*"

#: ../../library/logging.rst:1416
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file."
msgstr ""
"如果此关键字参数与 *filename* 一同被指定，则其值会在创建 :class:`FileHandler` "
"时被使用，因而也会在打开输出文件时被使用。"

#: ../../library/logging.rst:1421
msgid "*errors*"
msgstr "*errors*"

#: ../../library/logging.rst:1421
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file. If not specified, the value 'backslashreplace' is used. "
"Note that if ``None`` is specified, it will be passed as such to "
":func:`open`, which means that it will be treated the same as passing "
"'errors'."
msgstr ""
"如果此关键字参数与 *filename* 一同被指定，则其值会在创建 :class:`FileHandler` "
"时被使用，因而也会在打开输出文件时被使用。 如果未指定，则会使用值 'backslashreplace'。 请注意如果指定为 "
"``None``，它将被原样传给 :func:`open`，这意味着它将会当作传入 'errors' 一样处理。"

#: ../../library/logging.rst:1432
msgid "The *style* argument was added."
msgstr "增加了 *style* 参数。"

#: ../../library/logging.rst:1435
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""
"增加了 *handlers* 参数。 增加了额外的检查来捕获指定不兼容参数的情况 (例如同时指定 *handlers* 与 *stream*  或 "
"*filename*，或者同时指定 *stream* 与 *filename*)。"

#: ../../library/logging.rst:1441
msgid "The *force* argument was added."
msgstr "增加了 *force* 参数。"

#: ../../library/logging.rst:1444
msgid "The *encoding* and *errors* arguments were added."
msgstr "增加了 *encoding* 和 *errors* 参数。"

#: ../../library/logging.rst:1449
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr "通过刷新和关闭所有处理程序来通知日志记录系统执行有序停止。 此函数应当在应用退出时被调用并且在此调用之后不应再使用日志记录系统。"

#: ../../library/logging.rst:1453
msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that "
"manually."
msgstr "当 logging 模块被导入时，它会将此函数注册为退出处理程序 (参见 :mod:`atexit`)，因此通常不需要手动执行该操作。"

#: ../../library/logging.rst:1460
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`!__init__` such that only a name "
"argument is required, and the :meth:`!__init__` should call "
":meth:`!Logger.__init__`. This function is typically called before any "
"loggers are instantiated by applications which need to use custom logger "
"behavior. After this call, as at any other time, do not instantiate loggers "
"directly using the subclass: continue to use the :func:`logging.getLogger` "
"API to get your loggers."
msgstr ""
"通知日志记录系统在实例化日志记录器时使用 *klass* 类。 该类应当定义 :meth:`!__init__` 使其只需要一个 name 参数，并且 "
":meth:`!__init__` 应当调用 :meth:`!Logger.__init__`。 "
"此函数通常会在需要使用自定义日志记录器行为的应用程序实例化任何日志记录器之前被调用。 "
"在此调用之后，在其他任何时候都不要直接使用该子类来实例化日志记录器：请继续使用 :func:`logging.getLogger` API "
"来获取你的日志记录器。"

#: ../../library/logging.rst:1471
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr "设置一个用来创建 :class:`LogRecord` 的可调用对象。"

#: ../../library/logging.rst:1473
msgid "The factory callable to be used to instantiate a log record."
msgstr "用来实例化日志记录的工厂可调用对象。"

#: ../../library/logging.rst:1475
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a"
" logging event is constructed."
msgstr ""
"此函数与 :func:`getLogRecordFactory` 一起提供，以便允许开发者对如何构造表示日志记录事件的 "
":class:`LogRecord` 有更好的控制。"

#: ../../library/logging.rst:1480
msgid "The factory has the following signature:"
msgstr "可调用对象 factory 具有如下签名:"

#: ../../library/logging.rst:1482
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"

#: ../../library/logging.rst:1484
msgid "The logger name."
msgstr "日志记录器名称"

#: ../../library/logging.rst:0
msgid "level"
msgstr "level"

#: ../../library/logging.rst:1485
msgid "The logging level (numeric)."
msgstr "日志记录级别（数字）。"

#: ../../library/logging.rst:0
msgid "fn"
msgstr "fn"

#: ../../library/logging.rst:1486
msgid "The full pathname of the file where the logging call was made."
msgstr "进行日志记录调用的文件的完整路径名。"

#: ../../library/logging.rst:0
msgid "lno"
msgstr "lno"

#: ../../library/logging.rst:1487
msgid "The line number in the file where the logging call was made."
msgstr "记录调用所在文件中的行号。"

#: ../../library/logging.rst:1488
msgid "The logging message."
msgstr "日志消息。"

#: ../../library/logging.rst:1489
msgid "The arguments for the logging message."
msgstr "日志记录消息的参数。"

#: ../../library/logging.rst:1490
msgid "An exception tuple, or ``None``."
msgstr "异常元组，或 ``None`` 。"

#: ../../library/logging.rst:0
msgid "func"
msgstr "func"

#: ../../library/logging.rst:1491
msgid "The name of the function or method which invoked the logging call."
msgstr "调用日志记录调用的函数或方法的名称。"

#: ../../library/logging.rst:0
msgid "sinfo"
msgstr "sinfo"

#: ../../library/logging.rst:1493
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr "与 :func:`traceback.print_stack` 所提供的类似的栈回溯信息，显示调用的层级结构。"

#: ../../library/logging.rst:0
msgid "kwargs"
msgstr "kwargs"

#: ../../library/logging.rst:1495
msgid "Additional keyword arguments."
msgstr "其他关键字参数。"

#: ../../library/logging.rst:1499
msgid "Module-Level Attributes"
msgstr "模块级属性"

#: ../../library/logging.rst:1503
msgid ""
"A \"handler of last resort\" is available through this attribute. This is a "
":class:`StreamHandler` writing to ``sys.stderr`` with a level of "
"``WARNING``, and is used to handle logging events in the absence of any "
"logging configuration. The end result is to just print the message to "
"``sys.stderr``. This replaces the earlier error message saying that \"no "
"handlers could be found for logger XYZ\". If you need the earlier behaviour "
"for some reason, ``lastResort`` can be set to ``None``."
msgstr ""
"通过此属性提供的“最后处理者”。 这是一个以 ``WARNING`` 级别写入到 ``sys.stderr`` 的 "
":class:`StreamHandler`，用于在没有任何日志记录配置的情况下处理日志记录事件。 最终结果就是将消息打印到 "
"``sys.stderr``，这会替代先前形式为 \"no handlers could be found for logger XYZ\" "
"的错误消息。 如果出于某种原因你需要先前的行为，可将 ``lastResort`` 设为 ``None``。"

#: ../../library/logging.rst:1515
msgid "Used to see if exceptions during handling should be propagated."
msgstr "用于查看在处理过程中异常是否应当被传播。"

#: ../../library/logging.rst:1517
msgid "Default: ``True``."
msgstr "默认值: ``True``。"

#: ../../library/logging.rst:1519
msgid ""
"If :data:`raiseExceptions` is ``False``, exceptions get silently ignored. "
"This is what is mostly wanted for a logging system - most users will not "
"care about errors in the logging system, they are more interested in "
"application errors."
msgstr ""
"如果 :data:`raiseExceptions` 为 ``False``，则异常会被静默地忽略。 这大多数情况下是日志系统所需要的 —— "
"大多数用户不会关心日志系统中的错误，他们对应用程序错误更感兴趣。"

#: ../../library/logging.rst:1526
msgid "Integration with the warnings module"
msgstr "与警告模块集成"

#: ../../library/logging.rst:1528
msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging`"
" with the :mod:`warnings` module."
msgstr ":func:`captureWarnings` 函数可用来将 :mod:`logging` 和 :mod:`warnings` 模块集成。"

#: ../../library/logging.rst:1533
msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr "此函数用于打开和关闭日志系统对警告的捕获。"

#: ../../library/logging.rst:1536
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will"
" be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of "
":const:`WARNING`."
msgstr ""
"如果 *capture* 是 ``True``，则 :mod:`warnings` 模块发出的警告将重定向到日志记录系统。具体来说，将使用 "
":func:`warnings.formatwarning` 格式化警告信息，并将结果字符串使用 :const:`WARNING` 等级记录到名为 "
"``'py.warnings'`` 的记录器中。"

#: ../../library/logging.rst:1541
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system"
" will stop, and warnings will be redirected to their original destinations "
"(i.e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""
"如果 *capture* 是 ``False``，则将停止将警告重定向到日志记录系统，并且将警告重定向到其原始目标（即在  "
"``captureWarnings(True)``  调用之前的有效目标）。"

#: ../../library/logging.rst:1548
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模块"

#: ../../library/logging.rst:1549
msgid "Configuration API for the logging module."
msgstr "日志记录模块的配置 API 。"

#: ../../library/logging.rst:1551
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模块"

#: ../../library/logging.rst:1552
msgid "Useful handlers included with the logging module."
msgstr "日志记录模块附带的有用处理器。"

#: ../../library/logging.rst:1554
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - Logging 系统"

#: ../../library/logging.rst:1555
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "该提案描述了Python标准库中包含的这个特性。"

#: ../../library/logging.rst:1558
msgid ""
"`Original Python logging package <https://old.red-"
"dove.com/python_logging.html>`_"
msgstr ""
"`Original Python logging package <https://old.red-"
"dove.com/python_logging.html>`_"

#: ../../library/logging.rst:1559
msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
"这是该 :mod:`logging` 包的原始来源。该站点提供的软件包版本适用于 Python 1.5.2、2.1.x 和 2.2.x，它们不被 "
":mod:`logging` 包含在标准库中。"

#: ../../library/logging.rst:12
msgid "Errors"
msgstr "错误"

#: ../../library/logging.rst:12
msgid "logging"
msgstr "logging"
