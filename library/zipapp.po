# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`!zipapp` --- Manage executable Python zip archives"
msgstr ":mod:`!zipapp` --- 管理可执行的 Python zip 归档文件"

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**源代码：** :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter"
" <using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"本模块提供了一套管理工具，用于创建包含 Python 代码的压缩文件，这些文件可以 :ref:`直接由 Python 解释器执行 <using-on-"
"interface-options>`。 本模块提供 :ref:`zipapp-command-line-interface` 和 "
":ref:`zipapp-python-api`。"

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "简单示例"

#: ../../library/zipapp.rst:25
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can"
" be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"下述例子展示了用 :ref:`zipapp-command-line-interface` 根据含有 Python 代码的目录创建一个可执行的打包文件。"
" 运行后该打包文件时，将会执行 ``myapp`` 模块中的 ``main`` 函数。"

#: ../../library/zipapp.rst:30
msgid ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "命令行接口"

#: ../../library/zipapp.rst:42
msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "若要从命令行调用，则采用以下形式："

#: ../../library/zipapp.rst:44
msgid "$ python -m zipapp source [options]"
msgstr "$ python -m zipapp source [options]"

#: ../../library/zipapp.rst:48
msgid ""
"If *source* is a directory, this will create an archive from the contents of"
" *source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"如果 *source* 是个目录，将根据 *source* 的内容创建一个打包文件。如果 *source* "
"是个文件，则应为一个打包文件，将会复制到目标打包文件中（如果指定了 -info 选项，将会显示 shebang 行的内容）。"

#: ../../library/zipapp.rst:53
msgid "The following options are understood:"
msgstr "可以接受以下参数："

#: ../../library/zipapp.rst:59
msgid ""
"Write the output to a file named *output*.  If this option is not specified,"
" the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"将程序的输出写入名为 *output* 的文件中。若未指定此参数，输出的文件名将与输入的 *source* 相同，并添加扩展名 "
"``.pyz``。如果显式给出了文件名，将会原样使用（因此必要时应包含扩展名 ``.pyz``）。"

#: ../../library/zipapp.rst:64
msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr "如果 *source* 是个打包文件，必须指定一个输出文件名（这时 *output* 必须与 *source* 不同）。"

#: ../../library/zipapp.rst:69
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"给打包文件加入 ``#!`` 行，以便指定 *解释器* 作为运行的命令行。另外，还让打包文件在 POSIX 平台上可执行。默认不会写入  ``#!`` "
"行，也不让文件可执行。"

#: ../../library/zipapp.rst:75
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"在打包文件中写入一个 ``__main__.py`` 文件，用于执行 *mainfn*。*mainfn* 参数的形式应为 “pkg.mod:fn”，其中"
" “pkg.mod”是打包文件中的某个包/模块，“fn”是该模块中的一个可调用对象。``__main__.py`` 文件将会执行该可调用对象。"

#: ../../library/zipapp.rst:80
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr "在复制打包文件时，不能设置 :option:`--main`  参数。"

#: ../../library/zipapp.rst:84
msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr "利用 deflate 方法压缩文件，减少输出文件的大小。默认情况下，打包文件中的文件是不压缩的。"

#: ../../library/zipapp.rst:87
msgid ":option:`--compress` has no effect when copying an archive."
msgstr "在复制打包文件时，:option:`--compress` 无效。"

#: ../../library/zipapp.rst:93
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr "显示嵌入在打包文件中的解释器程序，以便诊断问题。这时会忽略其他所有参数，SOURCE 必须是个打包文件，而不是目录。"

#: ../../library/zipapp.rst:99
msgid "Print a short usage message and exit."
msgstr "打印简短的用法信息并退出。"

#: ../../library/zipapp.rst:105
msgid "Python API"
msgstr "Python API"

#: ../../library/zipapp.rst:107
msgid "The module defines two convenience functions:"
msgstr "该模块定义了两个快捷函数："

#: ../../library/zipapp.rst:112
msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr "由 *source* 创建一个应用程序打包文件。source 可以是以下形式之一："

#: ../../library/zipapp.rst:115
msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr "一个目录名，或指向目录的 :term:`path-like object` ，这时将根据目录内容新建一个应用程序打包文件。"

#: ../../library/zipapp.rst:118
msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if "
"required."
msgstr ""
"一个已存在的应用程序打包文件名，或指向这类文件的 :term:`path-like object`，这时会将该文件复制为目标文件（会稍作修改以反映出 "
"*interpreter* 参数的值）。必要时文件名中应包括 ``.pyz`` 扩展名。"

#: ../../library/zipapp.rst:122
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr "一个以字节串模式打开的文件对象。该文件的内容应为应用程序打包文件，且假定文件对象定位于打包文件的初始位置。"

#: ../../library/zipapp.rst:126
msgid ""
"The *target* argument determines where the resulting archive will be "
"written:"
msgstr "*target* 参数定义了打包文件的写入位置："

#: ../../library/zipapp.rst:129
msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive will"
" be written to that file."
msgstr "若是个文件名，或是 :term:`path-like object`，打包文件将写入该文件中。"

#: ../../library/zipapp.rst:131
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr "若是个打开的文件对象，打包文件将写入该对象，该文件对象必须在字节串写入模式下打开。"

#: ../../library/zipapp.rst:133
msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr ""
"如果省略了 target （或为 ``None``），则 source 必须为一个目录，target  将是与 source 同名的文件，并加上 "
"``.pyz`` 扩展名。"

#: ../../library/zipapp.rst:137
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with"
" which the archive will be executed.  It is written as a \"shebang\" line at"
" the start of the archive.  On POSIX, this will be interpreted by the OS, "
"and on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target"
" file will be set."
msgstr ""
"参数 *interpreter* 指定了 Python 解释器程序名，用于执行打包文件。这将以 “释伴（shebang）”行的形式写入打包文件的头部。在"
" POSIX 平台上，操作系统会进行解释，而在 Windows 平台则会由 Python 启动器进行处理。省略 *interpreter* "
"参数则不会写入释伴行。如果指定了解释器，且目标为文件名，则会设置目标文件的可执行属性位。"

#: ../../library/zipapp.rst:145
msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is"
" a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"参数 *main* 指定某个可调用程序的名称，用作打包文件的主程序。仅当 source 为目录且不含 ``__main__.py`` "
"文件时，才能指定该参数。*main* 参数应采用 "
"“pkg.module:callable”的形式，通过导入“pkg.module”并不带参数地执行给出的可调用对象，即可执行打包文件。如果 source"
" 是目录且不含 ``__main__.py`` 文件，省略 *main* 将会出错，生成的打包文件将无法执行。"

#: ../../library/zipapp.rst:155
msgid ""
"The optional *filter* argument specifies a callback function that is passed "
"a Path object representing the path to the file being added (relative to the"
" source directory).  It should return ``True`` if the file is to be added."
msgstr ""
"可选参数 *filter* 指定了回调函数，将传给代表被添加文件路径的 Path 对象（相对于源目录）。如若文件需要加入打包文件，则回调函数应返回 "
"``True``。"

#: ../../library/zipapp.rst:160
msgid ""
"The optional *compressed* argument determines whether files are compressed."
"  If set to ``True``, files in the archive are compressed with the deflate "
"method; otherwise, files are stored uncompressed. This argument has no "
"effect when copying an existing archive."
msgstr ""
"可选参数 *compressed* 指定是否要压缩打包文件。若设为 ``True``，则打包中的文件将用 deflate "
"方法进行压缩；否则就不会压缩。本参数在复制现有打包文件时无效。"

#: ../../library/zipapp.rst:165
msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr "若 *source* 或 *target* 指定的是文件对象，则调用者有责任在调用 create_archive 之后关闭这些文件对象。"

#: ../../library/zipapp.rst:168
msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the "
"``zipfile.ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"当复制已有的打包文件时，提供的文件对象只需 ``read`` 和 ``readline`` 方法，或 ``write`` "
"方法。当由目录创建打包文件时，若目标为文件对象，将会将其传给  类，且必须提供 ``zipfile.ZipFile`` 类所需的方法。"

#: ../../library/zipapp.rst:174
msgid "Added the *filter* and *compressed* parameters."
msgstr "增加了 *filter* 和 *compressed* 形参。"

#: ../../library/zipapp.rst:179
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"返回打包文件开头的  行指定的解释器程序。如果没有 ``#!`` 行，则返回 :const:`None`。参数 *archive* "
"可为文件名或在字节串模式下打开以供读取的文件型对象。``#!`` 行假定是在打包文件的开头。"

#: ../../library/zipapp.rst:188
msgid "Examples"
msgstr "例子"

#: ../../library/zipapp.rst:190
msgid "Pack up a directory into an archive, and run it."
msgstr "将目录打包成一个文件并运行它。"

#: ../../library/zipapp.rst:192
msgid ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:198
msgid "The same can be done using the :func:`create_archive` function::"
msgstr "同样还可用 :func:`create_archive` 函数完成："

#: ../../library/zipapp.rst:200
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"

#: ../../library/zipapp.rst:203
msgid ""
"To make the application directly executable on POSIX, specify an interpreter"
" to use."
msgstr "要让应用程序能在 POSIX 平台上直接执行，需要指定所用的解释器。"

#: ../../library/zipapp.rst:206
msgid ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:212
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr "若要替换已有打包文件中的释伴行，请用 :func:`create_archive` 函数另建一个修改好的打包文件："

#: ../../library/zipapp.rst:215
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/python3')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/python3')"

#: ../../library/zipapp.rst:218
msgid ""
"To update the file in place, do the replacement in memory using a "
":class:`~io.BytesIO` object, and then overwrite the source afterwards.  Note"
" that there is a risk when overwriting a file in place that an error will "
"result in the loss of the original file.  This code does not protect against"
" such errors, but production code should do so.  Also, this method will only"
" work if the archive fits in memory::"
msgstr ""
"若要原地更新打包文件，可用 :class:`~io.BytesIO` 对象在内存中进行替换，然后再覆盖源文件。 "
"请注意原地覆盖文件存在发生错误时丢失原始文件的风险。 这段代码没有考虑发生错误的情况，但生产性代码应该要考虑。 "
"另外，此方法将仅在内存能容纳打包文件时才适用::"

#: ../../library/zipapp.rst:225
msgid ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"
msgstr ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"

#: ../../library/zipapp.rst:236
msgid "Specifying the Interpreter"
msgstr "指定解释器程序"

#: ../../library/zipapp.rst:238
msgid ""
"Note that if you specify an interpreter and then distribute your application"
" archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line,"
" but there are other issues to consider:"
msgstr ""
"注意，如果指定了解释器程序再发布应用程序打包文件，需要确保所用到的解释器是可移植的。Windows 的 Python 启动器支持大多数常见的 POSIX"
" ``#!`` 行，但还需要考虑一些其他问题。"

#: ../../library/zipapp.rst:243
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""
"如果采用“/usr/bin/env python”（或其他格式的 python "
"调用命令，比如“/usr/bin/python”)，需要考虑默认版本既可能是 Python 2 又可能是 Python "
"3，应让代码在两个版本下均能正常运行。"

#: ../../library/zipapp.rst:247
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may"
" be what you want if you have not made your code Python 2 compatible)."
msgstr ""
"如果用到的 Python 版本明确，如“/usr/bin/env python3”，则没有该版本的用户将无法运行应用程序。（如果代码不兼容 Python"
" 2，可能正该如此）。"

#: ../../library/zipapp.rst:250
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""
"因为无法指定“python X.Y以上版本”，所以应小心“/usr/bin/env python3.4”这种精确版本的指定方式，因为对于 Python "
"3.5 的用户就得修改释伴行，比如："

#: ../../library/zipapp.rst:254
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"通常应该用“/usr/bin/env python2”或“/usr/bin/env python3”的格式，具体根据代码适用于 Python 2 还是 "
"3 而定。"

#: ../../library/zipapp.rst:259
msgid "Creating Standalone Applications with zipapp"
msgstr "用 zipapp 创建独立运行的应用程序"

#: ../../library/zipapp.rst:261
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have"
" a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""
"利用 :mod:`zipapp` 模块可以创建独立运行的 Python 程序，以便向最终用户发布，仅需在系统中装有合适版本的 Python "
"即可运行。操作的关键就是把应用程序代码和所有依赖项一起放入打包文件中。"

#: ../../library/zipapp.rst:267
msgid "The steps to create a standalone archive are as follows:"
msgstr "创建独立运行打包文件的步骤如下："

#: ../../library/zipapp.rst:269
msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr "照常在某个目录中创建应用程序，于是会有一个 ``myapp`` 目录，里面有个 ``__main__.py`` 文件，以及所有支持性代码。"

#: ../../library/zipapp.rst:273
msgid ""
"Install all of your application's dependencies into the ``myapp`` directory,"
" using pip:"
msgstr "用 pip 将应用程序的所有依赖项装入 ``myapp`` 目录。"

#: ../../library/zipapp.rst:276
msgid "$ python -m pip install -r requirements.txt --target myapp"
msgstr "$ python -m pip install -r requirements.txt --target myapp"

#: ../../library/zipapp.rst:280
msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr "（这里假定在 ``requirements.txt`` 文件中列出了项目所需的依赖项，也可以在 pip 命令行中列出依赖项）。"

#: ../../library/zipapp.rst:284
msgid "Package the application using:"
msgstr "用以下命令打包："

#: ../../library/zipapp.rst:286
msgid "$ python -m zipapp -p \"interpreter\" myapp"
msgstr "$ python -m zipapp -p \"interpreter\" myapp"

#: ../../library/zipapp.rst:290
msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""
"这会生成一个独立的可执行文件，可在任何装有合适解释器的机器上运行。详情参见 :ref:`zipapp-specifying-the-"
"interpreter`。可以单个文件的形式分发给用户。"

#: ../../library/zipapp.rst:294
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""
"在 Unix 系统中， ``myapp.pyz`` 文件将以原有文件名执行。如果喜欢 “普通”的命令名，可以重命名该文件，去掉扩展名 ``.pyz`` "
"。在 Windows 系统中， ``myapp.pyz[w]`` 是可执行文件，因为 Python 解释器在安装时注册了扩展名 ``.pyz`` 和 "
"``.pyzw`` 。"

#: ../../library/zipapp.rst:302
msgid "Caveats"
msgstr "注意事项"

#: ../../library/zipapp.rst:304
msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime,"
" based on the user's machine)."
msgstr ""
"如果应用程序依赖某个带有 C "
"扩展的包，则此程序包无法由打包文件运行（这是操作系统的限制，因为可执行代码必须存在于文件系统中，操作系统才能加载）。这时可去除打包文件中的依赖关系，然后要求用户事先安装好该程序包，或者与打包文件一起发布并在"
" ``__main__.py`` 中增加代码，将未打包模块的目录加入 ``sys.path`` "
"中。采用增加代码方式时，一定要为目标架构提供合适的二进制文件（可能还需在运行时根据用户的机器选择正确的版本加入 ``sys.path``）。"

#: ../../library/zipapp.rst:316
msgid "The Python Zip Application Archive Format"
msgstr "Python 打包应用程序的格式"

#: ../../library/zipapp.rst:318
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for"
" any Python script, the parent of the script (in this case the zip file) "
"will be placed on :data:`sys.path` and thus further modules can be imported "
"from the zip file."
msgstr ""
"自 2.6 版开始，Python 即能够执行包含  文件的打包文件了。为了能被 Python 执行，应用程序的打包文件必须为包含 "
"``__main__.py`` 文件的标准 zip 文件，``__main__.py`` 文件将作为应用程序的入口运行。类似于常规的 Python "
"脚本，父级（这里指打包文件）将放入 :data:`sys.path` ，因此可从打包文件中导入更多的模块。"

#: ../../library/zipapp.rst:325
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"zip 文件格式允许在文件中预置任意数据。利用这种能力，zip 应用程序格式在文件中预置了一个标准的 POSIX "
"“释伴”行（``#!/path/to/interpreter``）。"

#: ../../library/zipapp.rst:329
msgid "Formally, the Python zip application format is therefore:"
msgstr "因此，Python zip 应用程序的格式会如下所示："

#: ../../library/zipapp.rst:331
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an"
" interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding` on "
"POSIX."
msgstr ""
"可选的 shebang 行，包含字符 ``b'#!'`` 后面跟一个解释器名，再带一个换行符 (``b'\\n'``)。 解释器名可以是 OS "
"\"shebang\" 处理所能接受的任何名称，或为 Windows 上的 Python 启动器。 解释器名在 Windows 上应当使用 UTF-8 "
"编码，而在 POSIX 上则使用 :func:`sys.getfilesystemencoding`。"

#: ../../library/zipapp.rst:336
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The"
" zipfile data can be compressed or uncompressed."
msgstr ""
"标准的打包文件由 :mod:`zipfile` 模块生成。其中 *必须* 包含一个名为 ``__main__.py`` "
"的文件（必须位于打包文件的“根”目录——不能位于某个子目录中）。打包文件中的数据可以是压缩或未压缩的。"

#: ../../library/zipapp.rst:341
msgid ""
"If an application archive has a shebang line, it may have the executable bit"
" set on POSIX systems, to allow it to be executed directly."
msgstr "如果应用程序的打包文件带有释伴行，则在 POSIX 系统中可能需要启用可执行属性，以允许直接执行。"

#: ../../library/zipapp.rst:344
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr "不一定非要用本模块中的工具创建应用程序打包文件，本模块只是提供了便捷方案，上述格式的打包文件可用任何方式创建，均可被 Python 接受。"

#: ../../library/zipapp.rst:11
msgid "Executable Zip Files"
msgstr "可执行的 Zip 文件"
