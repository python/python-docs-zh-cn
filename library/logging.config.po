# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alpha Du <alphanow@gmail.com>, 2021
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2022
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`!logging.config` --- Logging configuration"
msgstr ":mod:`!logging.config` --- 日志记录配置"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**源代码：** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr "此页面仅包含参考信息。有关教程，请参阅"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基础教程 <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`进阶教程 <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`日志记录操作手册 <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "这一节描述了用于配置 logging 模块的 API。"

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "配置函数"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the"
" main API (defined in :mod:`logging` itself) and defining handlers which are"
" declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"下列函数可配置 logging 模块。 它们位于 :mod:`logging.config` 模块中。 它们的使用是可选的 --- 要配置 "
"logging 模块你可以使用这些函数，也可以通过调用主 API (在 :mod:`logging` 本身定义) 并定义在 :mod:`logging`"
" 或 :mod:`logging.handlers` 中声明的处理器。"

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr "从一个字典获取日志记录配置。 字典的内容描述见下文的 :ref:`logging-config-dictschema`。"

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a "
":exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or "
":exc:`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"如果在配置期间遇到错误，此函数将引发 :exc:`ValueError`, :exc:`TypeError`, "
":exc:`AttributeError` 或 :exc:`ImportError` 并附带适当的描述性消息。 "
"下面是将会引发错误的（可能不完整的）条件列表:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr "``level`` 不是字符串或者不是对应于实际日志记录级别的字符串。"

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "``propagate`` 值不是布尔类型。"

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "id 没有对应的目标。"

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr "在增量调用期间发现不存在的处理器 id。"

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "无效的日志记录器名称。"

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "无法解析为内部或外部对象。"

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a "
":meth:`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to "
":class:`DictConfigurator`. You can replace the value of "
":attr:`dictConfigClass` with a suitable implementation of your own."
msgstr ""
"解析由 :class:`DictConfigurator` 类执行，该类的构造器可传入用于配置的字典，并且具有 :meth:`configure` "
"方法。 :mod:`logging.config` 模块具有可调用属性 :attr:`dictConfigClass`，其初始值设为 "
":class:`DictConfigurator`。 你可以使用你自己的适当实现来替换 :attr:`dictConfigClass` 的值。"

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` 会调用 :attr:`dictConfigClass` 并传入指定的字典，然后在所返回的对象上调用 "
":meth:`configure` 方法以使配置生效::"

#: ../../library/logging.config.rst:68
msgid ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"
msgstr ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"

#: ../../library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then "
":func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"例如，:class:`DictConfigurator` 的子类可以在它自己的 :meth:`__init__` 中调用 "
"``DictConfigurator.__init__()``，然后设置可以在后续 :meth:`configure` 调用中使用的自定义前缀。 "
":attr:`dictConfigClass` 将被绑定到这个新的子类，然后就能以与在默认的未定制状态下完全相同的方式调用 "
":func:`dictConfig`。"

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"从一个 :mod:`configparser` 格式文件中读取日志记录配置。 文件格式应当与 :ref:`logging-config-"
"fileformat` 中的描述一致。 "
"此函数可在应用程序中被多次调用，以允许最终用户在多个预设配置中进行选择（如果开发者提供了展示选项并加载选定配置的机制）。"

#: ../../library/logging.config.rst:90
msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and "
":exc:`RuntimeError` if the file is invalid or empty."
msgstr ""
"如果文件不存在将引发 :exc:`FileNotFoundError` 而如果文件无效或为空则将引发 :exc:`RuntimeError`。"

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/logging.config.rst:94
msgid ""
"A filename, or a file-like object, or an instance derived from "
":class:`~configparser.RawConfigParser`. If a "
":class:`!RawConfigParser`-derived instance is passed, it is used as is. "
"Otherwise, a :class:`~configparser.ConfigParser` is instantiated, and the "
"configuration read by it from the object passed in ``fname``. If that has a "
":meth:`readline` method, it is assumed to be a file-like object and read "
"using :meth:`~configparser.ConfigParser.read_file`; otherwise, it is assumed"
" to be a filename and passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"一个文件名，或一个文件型对象，或是一个派生自 :class:`~configparser.RawConfigParser` 的实例。 "
"如果传入了一个派生自 :class:`!RawConfigParser` 的实例，它会被原样使用。 否则，将会实例化一个 "
":class:`~configparser.ConfigParser`，并且它会从作为 ``fname`` 传入的对象中读取配置。 如果存在 "
":meth:`readline` 方法，则它会被当作一个文件型对象并使用 "
":meth:`~configparser.ConfigParser.read_file` 来读取；在其他情况下，它会被当作一个文件名并传递给 "
":meth:`~configparser.ConfigParser.read`。"

#: ../../library/logging.config.rst:106
msgid ""
"Defaults to be passed to the :class:`!ConfigParser` can be specified in this"
" argument."
msgstr "要传给 :class:`!ConfigParser` 的默认值可在此参数中指定。"

#: ../../library/logging.config.rst:109
msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""
"如果指定为 ``False``，则当执行此调用时已存在的日志记录器会保持启用。 默认值为 ``True`` 因为这将以向下兼容方式启用旧行为。 "
"此行为是禁用任何现有的非根日志记录器除非它们或它们的上级在日志记录配置中被显式地命名。"

#: ../../library/logging.config.rst:118
msgid "The encoding used to open file when *fname* is filename."
msgstr "当 *fname* 为文件名时被用于打开文件的编码格式。"

#: ../../library/logging.config.rst:120
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now"
" accepted as a value for ``fname``. This facilitates:"
msgstr ""
"现在接受 :class:`~configparser.RawConfigParser` 子类的实例作为 ``fname`` 的值。 这有助于:"

#: ../../library/logging.config.rst:124
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr "使用一个配置文件，其中日志记录配置只是全部应用程序配置的一部分。"

#: ../../library/logging.config.rst:126
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"使用从一个文件读取的配置，它随后会在被传给 ``fileConfig`` 之前由使用配置的应用程序来修改（例如基于命令行参数或运行时环境的其他部分）。"

#: ../../library/logging.config.rst:130
msgid "Added the *encoding* parameter."
msgstr "增加了 *encoding* 形参。"

#: ../../library/logging.config.rst:133
msgid ""
"An exception will be thrown if the provided file doesn't exist or is invalid"
" or empty."
msgstr "如果所提供的文件不存在或无效或为空则将抛出一个异常。"

#: ../../library/logging.config.rst:139
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default "
":const:`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be"
" sent as a file suitable for processing by :func:`dictConfig` or "
":func:`fileConfig`. Returns a :class:`~threading.Thread` instance on which "
"you can call :meth:`~threading.Thread.start` to start the server, and which "
"you can :meth:`~threading.Thread.join` when appropriate. To stop the server,"
" call :func:`stopListening`."
msgstr ""
"在指定的端口上启动套接字服务器，并监听新的配置。 如果未指定端口，则会使用模块默认的 "
":const:`DEFAULT_LOGGING_CONFIG_PORT`。 日志记录配置将作为适合由 :func:`dictConfig` 或 "
":func:`fileConfig` 进行处理的文件来发送。 返回一个 :class:`~threading.Thread` 实例，你可以在该实例上调用"
" :meth:`~threading.Thread.start` 来启动服务器，对该服务器你可以在适当的时候执行 "
":meth:`~threading.Thread.join`。 要停止该服务器，请调用 :func:`stopListening`。"

#: ../../library/logging.config.rst:148
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g."
" when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"如果指定 ``verify`` 参数，则它应当是一个可调用对象，该对象应当验证通过套接字接收的字节数据是否有效且应被处理。 "
"这可以通过对通过套接字发送的内容进行加密和/或签名来完成，这样 ``verify`` 可调用对象就能执行签名验证和/或解密。 ``verify`` "
"可调用对象的调用会附带一个参数 —— 通过套接字接收的字节数据 —— 并应当返回要处理的字节数据，或者返回 ``None`` "
"来指明这些字节数据应当被丢弃。 返回的字节数据可以与传入的字节数据相同（例如在只执行验证的时候），或者也可以完全不同（例如在可能执行了解密的时候）。"

#: ../../library/logging.config.rst:159
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"要将配置发送到套接字，请读取配置文件并将其作为字节序列发送到套接字，字节序列要以使用 ``struct.pack('>L', n)`` "
"打包为二进制格式的四字节长度的字符串打头。"

#: ../../library/logging.config.rst:167
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs"
" whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even"
" if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations"
" from being applied."
msgstr ""
"因为配置的各部分是通过 :func:`eval` 传递的，使用此函数可能让用户面临安全风险。虽然此函数仅绑定到 ``localhost`` "
"上的套接字，因此并不接受来自远端机器的连接，但在某些场景中不受信任的代码可以在调用 :func:`listen` "
"的进程的账户下运行。具体来说，如果如果调用 :func:`listen` "
"的进程在用户无法彼此信任的多用户机器上运行，则恶意用户就能简单地通过连接到受害者的 :func:`listen` "
"套接字并发送运行攻击者想在受害者的进程上执行的任何代码的配置的方式，安排运行几乎任意的代码。如果是使用默认端口这会特别容易做到，即便使用了不同端口也不难做到。要避免发生这种情况的风险，请在"
" :func:`listen` 中使用 ``verify`` 参数来防止未经认可的配置被应用。"

#: ../../library/logging.config.rst:183
msgid "The ``verify`` argument was added."
msgstr "添加了 ``verify`` 参数。"

#: ../../library/logging.config.rst:188
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"如果你希望将配置发送给未禁用现有日志记录器的监听器，你将需要使用 JSON 格式的配置，该格式将使用 :func:`dictConfig` 进行配置。 "
"此方法允许你在你发送的配置中将 ``disable_existing_loggers`` 指定为 ``False``。"

#: ../../library/logging.config.rst:197
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"停止通过对 :func:`listen` 的调用所创建的监听服务器。 此函数的调用通常会先于在 :func:`listen` 的返回值上调用 "
":meth:`join`。"

#: ../../library/logging.config.rst:203
msgid "Security considerations"
msgstr "安全考量"

#: ../../library/logging.config.rst:205
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you"
" like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"日志配置功能试图提供便利，从某种角度来说，这是通过将配置文件中的文本转换为日志配置中使用的 Python 对象来完成的 —— 如 "
":ref:`logging-config-dict-userdef` "
"中所述。但是，这些相同的机制（从用户定义的模块中导入可调用对象并使用配置中的参数调用它们）可用于调用您指定的任何代码，因此您应该*非常谨慎*地处理来自非信任源的配置文件。并且在实际加载前，您应该确信加载不会导致坏事情。"

#: ../../library/logging.config.rst:219
msgid "Configuration dictionary schema"
msgstr "配置字典架构"

#: ../../library/logging.config.rst:221
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own"
" formatter or handler class. The parameters to these classes may also need "
"to include external objects such as ``sys.stderr``.  The syntax for "
"describing these objects and connections is defined in :ref:`logging-config-"
"dict-connections` below."
msgstr ""
"描述日志记录配置需要列出要创建的不同对象及它们之间的连接；例如，你可以创建一个名为 'console' 的处理器，然后名为 'startup' "
"的日志记录器将可以把它的消息发送给 'console' 处理器。 这些对象并不仅限于 :mod:`logging` "
"模块所提供的对象，因为你还可以编写你自己的格式化或处理器类。 这些类的形参可能还需要包括 ``sys.stderr`` 这样的外部对象。 "
"描述这些对象和连接的语法会在下面的 :ref:`logging-config-dict-connections` 中定义。"

#: ../../library/logging.config.rst:233
msgid "Dictionary Schema Details"
msgstr "字典架构细节"

#: ../../library/logging.config.rst:235
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr "传给 :func:`dictConfig` 的字典必须包含以下的键:"

#: ../../library/logging.config.rst:238
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr "*version* - 应设为代表架构版本的整数值。 目前唯一有效的值是 1，使用此键可允许架构在继续演化的同时保持向下兼容性。"

#: ../../library/logging.config.rst:243
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in "
":ref:`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"所有其他键都是可选项，但如存在它们将根据下面的描述来解读。 在下面提到 'configuring dict' 的所有情况下，都将检查它的特殊键 "
"``'()'`` 以确定是否需要自定义实例化。 如果需要，则会使用下面 :ref:`logging-config-dict-userdef` "
"所描述的机制来创建一个实例；否则，会使用上下文来确定要实例化的对象。"

#: ../../library/logging.config.rst:252
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a"
" formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - 对应的值将是一个字典，其中每个键是一个格式器 ID 而每个值则是一个描述如何配置相应 "
":class:`~logging.Formatter` 实例的字典。"

#: ../../library/logging.config.rst:256
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr "在配置字典中搜索以下可选键，这些键对应于创建 :class:`~logging.Formatter` 对象时传入的参数。:"

#: ../../library/logging.config.rst:260
msgid "``format``"
msgstr "``format``"

#: ../../library/logging.config.rst:261
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../../library/logging.config.rst:262
msgid "``style``"
msgstr "``style``"

#: ../../library/logging.config.rst:263
msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (从版本 >=3.8 起)"

#: ../../library/logging.config.rst:264
msgid "``defaults`` (since version >=3.12)"
msgstr "``defaults`` (版本 >=3.12)"

#: ../../library/logging.config.rst:266
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for "
":class:`~logging.Formatter`, thus this key is most useful for instantiating "
"a customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"可选的 ``class`` 键指定格式化器类的名称（形式为带点号的模块名和类名）。 实例化的参数与 "
":class:`~logging.Formatter` 的相同，因此这个键对于实例化自定义的 :class:`~logging.Formatter` "
"子类最为有用。 如果，替代类可能 会以扩展和精简格式呈现异常回溯信息。 如果你的格式化器需要不同的或额外的配置键，你应当使用 "
":ref:`logging-config-dict-userdef`。"

#: ../../library/logging.config.rst:275
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr "*filters* - 对应的值将是一个字典，其中每个键是一个过滤器 ID 而每个值则是一个描述如何配置相应 Filter 实例的字典。"

#: ../../library/logging.config.rst:279
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr "将在配置字典中搜索键 ``name`` (默认值为空字符串) 并且该键会被用于构造 :class:`logging.Filter` 实例。"

#: ../../library/logging.config.rst:283
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* - 对应的值将是一个字典，其中每个键是一个处理器 ID 而每个值则是一个描述如何配置相应 Handler 实例的字典。"

#: ../../library/logging.config.rst:287 ../../library/logging.config.rst:332
msgid "The configuring dict is searched for the following keys:"
msgstr "将在配置字典中搜索下列键:"

#: ../../library/logging.config.rst:289
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr "``class`` (强制)。 这是处理器类的完整限定名称。"

#: ../../library/logging.config.rst:292
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (可选)。 处理器的级别。"

#: ../../library/logging.config.rst:294
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (可选)。 处理器所对应格式化器的 ID。"

#: ../../library/logging.config.rst:297
msgid ""
"``filters`` (optional).  A list of ids of the filters for this handler."
msgstr "``filters`` (可选)。 由处理器所对应过滤器的 ID 组成的列表。"

#: ../../library/logging.config.rst:300 ../../library/logging.config.rst:341
msgid "``filters`` can take filter instances in addition to ids."
msgstr "``filters`` 除了 id 以外还能接受 filter 实例。"

#: ../../library/logging.config.rst:303
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr "所有 *其他* 键会被作为关键字参数传递给处理器类的构造器。 例如，给定如下配置:"

#: ../../library/logging.config.rst:306
msgid ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"
msgstr ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"

#: ../../library/logging.config.rst:322
msgid ""
"the handler with id ``console`` is instantiated as a "
":class:`logging.StreamHandler`, using ``sys.stdout`` as the underlying "
"stream.  The handler with id ``file`` is instantiated as a "
":class:`logging.handlers.RotatingFileHandler` with the keyword arguments "
"``filename='logconfig.log', maxBytes=1024, backupCount=3``."
msgstr ""
"ID 为 ``console`` 的处理器会被实例化为 :class:`logging.StreamHandler`，并使用 "
"``sys.stdout`` 作为下层流。 ID 为 ``file`` 的处理器会被实例化为 "
":class:`logging.handlers.RotatingFileHandler`，并附带关键字参数 "
"``filename='logconfig.log', maxBytes=1024, backupCount=3``。"

#: ../../library/logging.config.rst:328
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr "*loggers* - 对应的值将是一个字典，其中每个键是一个日志记录器名称而每个值则是一个描述如何配置相应 Logger 实例的字典。"

#: ../../library/logging.config.rst:334
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (可选)。 日志记录器的级别。"

#: ../../library/logging.config.rst:336
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (可选)。 日志记录器的传播设置。"

#: ../../library/logging.config.rst:338
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr "``filters`` (可选)。 由日志记录器对应过滤器的 ID 组成的列表。"

#: ../../library/logging.config.rst:344
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr "``handlers`` (可选)。 由日志记录器对应处理器的 ID 组成的列表。"

#: ../../library/logging.config.rst:347
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr "指定的记录器将根据指定的级别、传播、过滤器和处理器来配置。"

#: ../../library/logging.config.rst:350
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* - 这将成为根日志记录器对应的配置。 配置的处理方式将与所有日志记录器一致，除了 ``propagate`` 设置将不可用之外。"

#: ../../library/logging.config.rst:354
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing "
":func:`fileConfig` API."
msgstr ""
"*incremental* - 配置是否要被解读为在现有配置上新增。 该值默认为 ``False``，这意味着指定的配置将以与当前 "
":func:`fileConfig` API 所使用的相同语义来替代现有的配置。"

#: ../../library/logging.config.rst:360
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"如果指定的值为 ``True``，配置会按照 :ref:`logging-config-dict-incremental` 部分所描述的方式来处理。"

#: ../../library/logging.config.rst:363
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be"
" disabled. This setting mirrors the parameter of the same name in "
":func:`fileConfig`. If absent, this parameter defaults to ``True``. This "
"value is ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - 是否要禁用任何现有的非根日志记录器。 该设置对应于 :func:`fileConfig` "
"中的同名形参。 如果省略，则此形参默认为 ``True``。 如果 *incremental* 为 ``True`` 则该省会被忽略。"

#: ../../library/logging.config.rst:371
msgid "Incremental Configuration"
msgstr "增量配置"

#: ../../library/logging.config.rst:373
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr "为增量配置提供完全的灵活性是很困难的。 例如，由于过滤器和格式化器这样的对象是匿名的，一旦完成配置，在增加配置时就不可能引用这些匿名对象。"

#: ../../library/logging.config.rst:379
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"此外，一旦完成了配置，在运行时任意改变日志记录器、处理器、过滤器、格式化器的对象图就不是很有必要；日志记录器和处理器的详细程度只需通过设置级别即可实现控制（对于日志记录器则可设置传播旗标）。"
" 在多线程环境中以安全的方式任意改变对象图也许会导致问题；虽然并非不可能，但这样做的好处不足以抵销其所增加的实现复杂度。"

#: ../../library/logging.config.rst:388
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is"
" ``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"这样，当配置字典的 ``incremental`` 键存在且为 ``True`` 时，系统将完全忽略任何 ``formatters`` 和 "
"``filters`` 条目，并仅会处理 ``handlers`` 条目中的 ``level`` 设置，以及 ``loggers`` 和 "
"``root`` 条目中的 ``level`` 和 ``propagate`` 设置。"

#: ../../library/logging.config.rst:394
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"使用配置字典中的值可让配置以封存字典对象的形式通过线路传送给套接字监听器。 "
"这样，长时间运行的应用程序的日志记录的详细程度可随时间改变而无须停止并重新启动应用程序。"

#: ../../library/logging.config.rst:402
msgid "Object connections"
msgstr "对象连接"

#: ../../library/logging.config.rst:404
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph."
"  Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a"
" particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"该架构描述了一组日志记录对象 —— 日志记录器、处理器、格式化器、过滤器 —— 它们在对象图中彼此连接。 因此，该架构需要能表示对象之间的连接。 "
"例如，在配置完成后，一个特定的日志记录器关联到了一个特定的处理器。 "
"出于讨论的目的，我们可以说该日志记录器代表两者间连接的源头，而处理器则代表对应的目标。 当然在已配置对象中这是由包含对处理器的引用的日志记录器来代表的。"
" 在配置字典中，这是通过给每个目标对象一个 ID 来无歧义地标识它，然后在源头对象中使用该 ID 来实现的。"

#: ../../library/logging.config.rst:418
msgid "So, for example, consider the following YAML snippet:"
msgstr "因此，举例来说，考虑以下 YAML 代码段:"

#: ../../library/logging.config.rst:420
msgid ""
"formatters:\n"
"  brief:\n"
"    # configuration for formatter with id 'brief' goes here\n"
"  precise:\n"
"    # configuration for formatter with id 'precise' goes here\n"
"handlers:\n"
"  h1: #This is an id\n"
"   # configuration of handler with id 'h1' goes here\n"
"   formatter: brief\n"
"  h2: #This is another id\n"
"   # configuration of handler with id 'h2' goes here\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # other configuration for logger 'foo.bar.baz'\n"
"    handlers: [h1, h2]"
msgstr ""
"formatters:\n"
"  brief:\n"
"    # 以下为针对格式化器 id 'brief' 的配置\n"
"  precise:\n"
"    # 以下为针对格式化器 'precise' 的配置\n"
"handlers:\n"
"  h1: # 这是一个 id\n"
"   # 以下是针对处理器 id 'h1' 的配置\n"
"   formatter: brief\n"
"  h2: # 这是另一个 id\n"
"   # 以下是针对处理器 id 'h2' 的配置\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # 针对日志记录器 'foo.bar.baz' 的其它配置\n"
"    handlers: [h1, h2]"

#: ../../library/logging.config.rst:439
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr "（注：这里使用 YAML 是因为它的可读性比表示字典的等价 Python 源码形式更好。）"

#: ../../library/logging.config.rst:442
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. "
"``foo.bar.baz``.  The ids for Formatters and Filters can be any string value"
" (such as ``brief``, ``precise`` above) and they are transient, in that they"
" are only meaningful for processing the configuration dictionary and used to"
" determine connections between objects, and are not persisted anywhere when "
"the configuration call is complete."
msgstr ""
"日志记录器 ID 就是日志记录器的名称，它会在程序中被用来获取对日志记录器的引用，例如 ``foo.bar.baz``。 格式化器和过滤器的 ID "
"可以是任意字符串值 (例如上面的 ``brief``, ``precise``) "
"并且它们是瞬态的，因为它们仅对处理配置字典有意义并会被用来确定对象之间的连接，而当配置调用完成时不会在任何地方保留。"

#: ../../library/logging.config.rst:450
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"上面的代码片段指明名为 ``foo.bar.baz`` 的日志记录器应当关联到两个处理器，它们的 ID 是 ``h1`` 和 ``h2``。 "
"``h1`` 的格式化器的 ID 是 ``brief``，而 ``h2`` 的格式化器的 ID 是 ``precise``。"

#: ../../library/logging.config.rst:460
msgid "User-defined objects"
msgstr "用户定义对象"

#: ../../library/logging.config.rst:462
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"此架构支持用户定义对象作为处理器、过滤器和格式化器。 （日志记录器的不同实例不需要具有不同类型，因此这个配置架构并不支持用户定义日志记录器类。）"

#: ../../library/logging.config.rst:467
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"要配置的对象是由字典描述的，其中包含它们的配置详情。 "
"在某些地方，日志记录系统将能够从上下文中推断出如何实例化一个对象，但是当要实例化一个用户自定义对象时，系统将不知道要如何做。 "
"为了提供用户自定义对象实例化的完全灵活性，用户需要提供一个‘工厂’函数 —— 即在调用时传入配置字典并返回实例化对象的可调用对象。 这是用一个通过特殊键"
" ``'()'`` 来访问的工厂函数的绝对导入路径来标示的。 下面是一个实际的例子:"

#: ../../library/logging.config.rst:479
msgid ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"
msgstr ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"

#: ../../library/logging.config.rst:493
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a "
":class:`logging.Formatter` initialized with those two format strings.  Shown"
" in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"上面的 YAML 代码片段定义了三个格式化器。 第一个的 ID 为 ``brief``，是带有特殊格式字符串的标准 "
":class:`logging.Formatter` 实例。 第二个的 ID 为 "
"``default``，具有更长的格式同时还显式地定义了时间格式，并将最终实例化一个带有这两个格式字符串的 "
":class:`logging.Formatter`。 以 Python 源代码形式显示的 ``brief`` 和 ``default`` "
"格式化器分别具有下列配置子字典::"

#: ../../library/logging.config.rst:501
msgid ""
"{\n"
"  'format' : '%(message)s'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(message)s'\n"
"}"

#: ../../library/logging.config.rst:505
msgid "and::"
msgstr "和::"

#: ../../library/logging.config.rst:507
msgid ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"

#: ../../library/logging.config.rst:512
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"并且由于这些字典不包含特殊键 ``'()'``，实例化方式是从上下文中推断出来的：结果会创建标准的 :class:`logging.Formatter`"
" 实例。 第三个格式器的 ID 为 ``custom``，对应配置子字典为::"

#: ../../library/logging.config.rst:518
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"

#: ../../library/logging.config.rst:525
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the"
" **remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"并且它包含特殊键 ``'()'``，这意味着需要用户自定义实例化方式。 在此情况下，将使用指定的工厂可调用对象。 "
"如果它本身就是一个可调用对象则将被直接使用 —— 否则如果你指定了一个字符串（如这个例子所示）则将使用正常的导入机制来定位实例的可调用对象。 "
"调用该可调用对象将传入配置子字典中 **剩余的** 条目作为关键字参数。 在上面的例子中，调用将预期返回 ID 为 ``custom`` 的格式化器::"

#: ../../library/logging.config.rst:535
msgid "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"
msgstr "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"

#: ../../library/logging.config.rst:537
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""
"上面示例中 ``bar``, ``spam`` 和 ``answer`` 等键的值不应是配置目录或引用如 ``cfg://foo`` 或 "
"``ext://bar``，因为它们将不会被配置机制所处理，而是被原样传给可调用对象。"

#: ../../library/logging.config.rst:542
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the"
" corresponding value is a callable."
msgstr ""
"将 ``'()'`` 用作特殊键是因为它不是一个有效的关键字形参名称，这样就不会与调用中使用的关键字参数发生冲突。 ``'()'`` "
"还被用作表明对应值为可调用对象的助记符。"

#: ../../library/logging.config.rst:547
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr "``handlers`` 和 ``loggers`` 的 ``filters`` 成员除了 id 以外还能接受 filter 实例。"

#: ../../library/logging.config.rst:551
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the"
" following configuration::"
msgstr ""
"你还可以指定一个特殊键 ``'.'`` 其值应为一个将属性名称映射到对应值的字典。 如果找到，则指定的属性在被返回之前将在用户定义的对象上设置。 "
"因此，使用以下配置::"

#: ../../library/logging.config.rst:556
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"

#: ../../library/logging.config.rst:567
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr "被返回的格式化器的 ``foo`` 属性将设为 ``'bar'`` 而 ``baz`` 属性将设为 ``'bozz'``。"

#: ../../library/logging.config.rst:570
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo``"
" or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""
"上面示例中 ``foo`` 和 ``baz`` 等属性的值不应是配置目录或引用如 ``cfg://foo`` 或 "
"``ext://bar``，因为它们将不会被配置机制所处理，而是被原样设置为属性。"

#: ../../library/logging.config.rst:579
msgid "Handler configuration order"
msgstr "处理器配置顺序"

#: ../../library/logging.config.rst:581
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that"
" handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that"
" dependent handlers are configured _after_ any handlers they depend on; that"
" allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it"
" would be configured after ``foo``, with the result that "
"``cfg://handlers.foo`` would resolve to configured handler ``foo``, and not "
"its configuration dictionary."
msgstr ""
"处理器按其键的字母顺序进行配置，而已配置的处理器将替换配置方案内部 ``handlers`` 字典（的一个工作副本）中的配置字典。 如果你使用 "
"``cfg://handlers.foo`` 这样的构造，那么在初始状态下 ``handlers['foo']`` 会指向名为 ``foo`` "
"的处理器的配置字典，随后（一旦配置了该处理器）它将指向已配置的处理器实例。 因此，``cfg://handlers.foo`` "
"可以解析为一个字典或处理器实例。 通常来说，对于带依赖的处理器采用在它们所依赖的任何处理器完成配置 _之后_ "
"再进行配置的方式来命名处理器是一种明智的做法；这将允许使用 ``cfg://handlers.foo`` 这样的构造来配置依赖于处理器 ``foo`` "
"的处理器。 如果这个带依赖的处理器被命名为 ``bar``，则会导致问题，因为 ``bar`` 的配置将在 ``foo`` 的配置之前被尝试使用，而 "
"``foo`` 将尚未配置完成。 但是，如果带依赖的处理器被命名为 ``foobar``，则它将在 ``foo`` 之后被配置，结果就是 "
"``cfg://handlers.foo`` 将被解析为已配置的处理器 ``foo``，而不是其配置字典。"

#: ../../library/logging.config.rst:602
msgid "Access to external objects"
msgstr "访问外部对象"

#: ../../library/logging.config.rst:604
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is"
" constructed using Python code, this is straightforward, but a problem "
"arises when the configuration is provided via a text file (e.g. JSON, YAML)."
"  In a text file, there is no standard way to distinguish ``sys.stderr`` "
"from the literal string ``'sys.stderr'``.  To facilitate this distinction, "
"the configuration system looks for certain special prefixes in string values"
" and treat them specially.  For example, if the literal string "
"``'ext://sys.stderr'`` is provided as a value in the configuration, then the"
" ``ext://`` will be stripped off and the remainder of the value processed "
"using normal import mechanisms."
msgstr ""
"有时一个配置需要引用配置以外的对象，例如 ``sys.stderr``。 如果配置字典是使用 Python "
"代码构造的，这会很直观，但是当配置是通过文本文件（例如 JSON, YAML）提供的时候就会引发问题。 在一个文本文件中，没有将 "
"``sys.stderr`` 与字符串字面值 ``'sys.stderr'`` 区分开来的标准方式。  "
"为了实现这种区分，配置系统会在字符串值中查找规定的特殊前缀并对其做特殊处理。 例如，如果在配置中将字符串字面值 "
"``'ext://sys.stderr'`` 作为一个值来提供，则 ``ext://`` 将被去除而该值的剩余部分将使用正常导入机制来处理。"

#: ../../library/logging.config.rst:617
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the"
" ``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent"
" manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"此类前缀的处理方式类似于协议处理：存在一种通用机制来查找与正则表达式 ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$``"
" 相匹配的前缀，如果识别出了 ``prefix``，则 ``suffix`` 会以与前缀相对应的方式来处理并且处理的结果将替代原字符串值。 "
"如果未识别出前缀，则原字符串将保持不变。"

#: ../../library/logging.config.rst:629
msgid "Access to internal objects"
msgstr "访问内部对象"

#: ../../library/logging.config.rst:631
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"除了外部对象，有时还需要引用配置中的对象。 这将由配置系统针对它所了解的内容隐式地完成。 例如，在日志记录器或处理器中表示 ``level`` "
"的字符串值 ``'DEBUG'`` 将被自动转换为值 ``logging.DEBUG``，而 ``handlers``, ``filters`` 和 "
"``formatter`` 条目将接受一个对象 ID 并解析为适当的目标对象。"

#: ../../library/logging.config.rst:639
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider "
":class:`logging.handlers.MemoryHandler`, which takes a ``target`` argument "
"which is another handler to delegate to. Since the system already knows "
"about this class, then in the configuration, the given ``target`` just needs"
" to be the object id of the relevant target handler, and the system will "
"resolve to the handler from the id.  If, however, a user defines a "
"``my.package.MyHandler`` which has an ``alternate`` handler, the "
"configuration system would not know that the ``alternate`` referred to a "
"handler.  To cater for this, a generic resolution system allows the user to "
"specify:"
msgstr ""
"但是，对于 :mod:`logging` 模块所不了解的用户自定义对象则需要一种更通用的机制。 例如，考虑 "
":class:`logging.handlers.MemoryHandler`，它接受一个 ``target`` 参数即其所委托的另一个处理器。 "
"由于系统已经知道存在该类，因而在配置中，给定的 ``target`` 只需为相应目标处理器的的对象 ID 即可，而系统将根据该 ID 解析出处理器。 "
"但是，如果用户定义了一个具有 ``alternate`` 处理器的 ``my.package.MyHandler``，则配置程序将不知道 "
"``alternate`` 指向的是一个处理器。 为了应对这种情况，通用解析系统允许用户指定:"

#: ../../library/logging.config.rst:651
msgid ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"
msgstr ""
"handlers:\n"
"  file:\n"
"    # 以下是文件处理器的配置\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"

#: ../../library/logging.config.rst:661
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows"
" access by dot or by index, in a similar way to that provided by "
"``str.format``.  Thus, given the following snippet:"
msgstr ""
"字符串字面值 ``'cfg://handlers.file'`` 将按照与 ``ext://`` "
"前缀类似的方式被解析为结果字符串，但查找操作是在配置自身而不是在导入命名空间中进行。 该机制允许按点号或按索引来访问，与 ``str.format`` "
"所提供的方式类似。 这样，给定以下代码段:"

#: ../../library/logging.config.rst:667
msgid ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."
msgstr ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."

#: ../../library/logging.config.rst:679
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on."
"  The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string "
"``'cfg://handlers.email.toaddrs[0]'`` would resolve to the value "
"``'support_team@domain.tld'``. The ``subject`` value could be accessed using"
" either ``'cfg://handlers.email.subject'`` or, equivalently, "
"``'cfg://handlers.email[subject]'``.  The latter form only needs to be used "
"if the key contains spaces or non-alphanumeric characters. Please note that "
"the characters ``[`` and ``]`` are not allowed in the keys. If an index "
"value consists only of decimal digits, access will be attempted using the "
"corresponding integer value, falling back to the string value if needed."
msgstr ""
"在该配置中，字符串 ``'cfg://handlers'`` 将解析为包含 ``handlers`` 键的字典，字符串 "
"``'cfg://handlers.email`` 将解析为 ``handlers`` 字典中包含 ``email`` 键的字典，依此类推。 字符串 "
"``'cfg://handlers.email.toaddrs[1]`` 将解析为 ``'dev_team@domain.tld'`` 而字符串 "
"``'cfg://handlers.email.toaddrs[0]'`` 将解析为值 ``'support_team@domain.tld'``。 "
"``subject`` 值可以使用 ``'cfg://handlers.email.subject'`` 或者等价的 "
"``'cfg://handlers.email[subject]'`` 来访问。 后一种形式仅在键包含空格或非字母数字类字符的情况下才需要使用。 "
"请注意字符 ``[`` 和 ``]`` 不允许在键中使用。 如果一个索引仅由十进制数码构成，则将尝试使用相应的整数值来访问，如有必要则将回退为字符串值。"

#: ../../library/logging.config.rst:694
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from "
"``config_dict['handlers']['myhandler']['mykey'][123]``, and fall back to "
"``config_dict['handlers']['myhandler']['mykey']['123']`` if that fails."
msgstr ""
"给定字符串 ``cfg://handlers.myhandler.mykey.123``，这将解析为 "
"``config_dict['handlers']['myhandler']['mykey']['123']``。 如果字符串被指定为 "
"``cfg://handlers.myhandler.mykey[123]``，系统将尝试从 "
"``config_dict['handlers']['myhandler']['mykey'][123]`` 中提取值，并在尝试失败时回退为 "
"``config_dict['handlers']['myhandler']['mykey']['123']``。"

#: ../../library/logging.config.rst:706
msgid "Import resolution and custom importers"
msgstr "导入解析与定制导入器"

#: ../../library/logging.config.rst:708
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the "
":class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to"
" do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"导入解析默认使用内置的 :func:`__import__` 函数来执行导入。 你可能想要将其替换为你自己的导入机制：如果是这样的话，你可以替换 "
":class:`DictConfigurator` 或其超类 :class:`BaseConfigurator` 类的 :attr:`importer`"
" 属性。 但是你必须小心谨慎，因为函数是从类中通过描述器方式来访问的。 如果你使用 Python "
"可调用对象来执行导入，并且你希望在类层级而不是在实例层级上定义它，则你需要用 :func:`staticmethod` 来装饰它。 例如::"

#: ../../library/logging.config.rst:718
msgid ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"
msgstr ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"

#: ../../library/logging.config.rst:723
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr "如果你是在一个配置器的 *实例* 上设置导入可调用对象则你不需要用 :func:`staticmethod` 来装饰。"

#: ../../library/logging.config.rst:729
msgid "Configuring QueueHandler and QueueListener"
msgstr "配置 QueueHandler 和 QueueListener"

#: ../../library/logging.config.rst:731
msgid ""
"If you want to configure a :class:`~logging.handlers.QueueHandler`, noting "
"that this is normally used in conjunction with a "
":class:`~logging.handlers.QueueListener`, you can configure both together. "
"After the configuration, the ``QueueListener`` instance will be available as"
" the :attr:`~logging.handlers.QueueHandler.listener` attribute of the "
"created handler, and that in turn will be available to you using "
":func:`~logging.getHandlerByName` and passing the name you have used for the"
" ``QueueHandler`` in your configuration. The dictionary schema for "
"configuring the pair is shown in the example YAML snippet below."
msgstr ""
"如果你想要配置一个 :class:`~logging.handlers.QueueHandler`，请注意它通常是与 "
":class:`~logging.handlers.QueueListener` 一起使用的，你可以同时配置这两者。 "
"配置完成之后，``QueueListener`` 实例将可作为所创建的处理器的 "
":attr:`~logging.handlers.QueueHandler.listener` 属性来访问，而你也将可以使用 "
":func:`~logging.getHandlerByName` 来访问它并将你所使用的名称作为配置中的 ``QueueHandler`` 传入。 "
"用于配置这两者的字典规格显示在下面的 YAML 实例代码段中。"

#: ../../library/logging.config.rst:740
msgid ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."
msgstr ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."

#: ../../library/logging.config.rst:752
msgid "The ``queue`` and ``listener`` keys are optional."
msgstr "``queue`` 和 ``listener`` 键是可选的。"

#: ../../library/logging.config.rst:754
msgid ""
"If the ``queue`` key is present, the corresponding value can be one of the "
"following:"
msgstr "如果存在 ``queue`` 键，相应的值可以是下列几项之一:"

#: ../../library/logging.config.rst:756
msgid ""
"An object implementing the :meth:`Queue.put_nowait <queue.Queue.put_nowait>`"
" and :meth:`Queue.get <queue.Queue.get>` public API. For instance, this may "
"be an actual instance of :class:`queue.Queue` or a subclass thereof, or a "
"proxy obtained by :meth:`multiprocessing.managers.SyncManager.Queue`."
msgstr ""
"一个实现 :meth:`Queue.put_nowait <queue.Queue.put_nowait>` 和 :meth:`Queue.get "
"<queue.Queue.get>` 公有 API 的对象。 例如，这可以是一个 :class:`queue.Queue` "
"或其子类的具体实例，或者是一个由 :meth:`multiprocessing.managers.SyncManager.Queue` 获取的代理对象。"

#: ../../library/logging.config.rst:761
msgid ""
"This is of course only possible if you are constructing or modifying the "
"configuration dictionary in code."
msgstr "这当然仅在你通过代码中构造或修改配置字典时才是可能的。"

#: ../../library/logging.config.rst:764
msgid ""
"A string that resolves to a callable which, when called with no arguments, "
"returns the queue instance to use. That callable could be a "
":class:`queue.Queue` subclass or a function which returns a suitable queue "
"instance, such as ``my.module.queue_factory()``."
msgstr ""
"一个将被求值为可调用对象的字符串，当不带任何参数被调用时，它将返回要使用的队列实例。 该可调用对象可以是一个 :class:`queue.Queue` "
"子类或是一个返回适当的队列实例的函数，如 ``my.module.queue_factory()``。"

#: ../../library/logging.config.rst:769
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a :class:`queue.Queue` instance."
msgstr ""
"一个带有 ``'()'`` 键的字典，它使用 :ref:`logging-config-dict-userdef` 中所介绍的通常方式构造。 "
"这样构造的结果应当是一个 :class:`queue.Queue` 实例。"

#: ../../library/logging.config.rst:773
msgid ""
"If the  ``queue`` key is absent, a standard unbounded :class:`queue.Queue` "
"instance is created and used."
msgstr "如果没有  ``queue`` 键，则会创建并使用一个标准的未绑定 :class:`queue.Queue` 实例。"

#: ../../library/logging.config.rst:776
msgid ""
"If the ``listener`` key is present, the corresponding value can be one of "
"the following:"
msgstr "如果存在 ``listener`` 键，则相应的值可以是下列几项中的一个:"

#: ../../library/logging.config.rst:778
msgid ""
"A subclass of :class:`logging.handlers.QueueListener`. This is of course "
"only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""
"一个 :class:`logging.handlers.QueueListener` 的子类。 这当然仅在你通过代码构造或修改配置字典时才是可能的。"

#: ../../library/logging.config.rst:782
msgid ""
"A string which resolves to a class which is a subclass of ``QueueListener``,"
" such as ``'my.package.CustomListener'``."
msgstr ""
"一个将被求值为属于 ``QueueListener`` 的子类的类的字符串，例如 ``'my.package.CustomListener'``。"

#: ../../library/logging.config.rst:785
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a callable with the same signature as the "
"``QueueListener`` initializer."
msgstr ""
"一个带有 ``'()'`` 键的字典，它使用 :ref:`logging-config-dict-userdef` 中所介绍的通常方式构造。 "
"这样构造的结果应当是一个与 ``QueueListener`` 初始化器具有相同签名的可调用对象。"

#: ../../library/logging.config.rst:789
msgid ""
"If the ``listener`` key is absent, :class:`logging.handlers.QueueListener` "
"is used."
msgstr "如果不存在 ``listener`` 键，则会使用 :class:`logging.handlers.QueueListener`。"

#: ../../library/logging.config.rst:791
msgid ""
"The values under the ``handlers`` key are the names of other handlers in the"
" configuration (not shown in the above snippet) which will be passed to the "
"queue listener."
msgstr "在 ``handlers`` 键之下的值是配置中其他处理器的名称（未显示在上面的代码片段中），它们将被传给队列监听器。"

#: ../../library/logging.config.rst:795
msgid ""
"Any custom queue handler and listener classes will need to be defined with "
"the same initialization signatures as "
":class:`~logging.handlers.QueueHandler` and "
":class:`~logging.handlers.QueueListener`."
msgstr ""
"任何队列处理器和监听器类都需要定义为具有与 :class:`~logging.handlers.QueueHandler` 和 "
":class:`~logging.handlers.QueueListener` 相同的初始化签名。"

#: ../../library/logging.config.rst:804
msgid "Configuration file format"
msgstr "配置文件格式"

#: ../../library/logging.config.rst:806
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on "
":mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
":func:`fileConfig` 所能理解的配置文件格式是基于 :mod:`configparser` 功能的。 该文件必须包含 "
"``[loggers]``, ``[handlers]`` 和 ``[formatters]`` 等小节，它们通过名称来标识文件中定义的每种类型的实体。"
" 对于每个这样的实体，都有单独的小节来标识实体的配置方式。 因此，对于 ``[loggers]`` 小节中名为 ``log01`` "
"的日志记录器，相应的配置详情保存在 ``[logger_log01]`` 小节中。 类似地，对于 ``[handlers]`` 小节中名为 "
"``hand01`` 的处理器，其配置将保存在名为 ``[handler_hand01]`` 的小节中，而对于 ``[formatters]`` "
"小节中名为 ``form01`` 的格式化器，其配置将在名为 ``[formatter_form01]`` 的小节中指定。 根日志记录器的配置必须在名为"
" ``[logger_root]`` 的小节中指定。"

#: ../../library/logging.config.rst:821
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does"
" not provide functionality to cover certain aspects of logging. For example,"
" you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using "
":func:`fileConfig`. If you need to have instances of "
":class:`~logging.Filter` in your logging configuration, you will need to use"
" :func:`dictConfig`. Note that future enhancements to configuration "
"functionality will be added to :func:`dictConfig`, so it's worth considering"
" transitioning to this newer API when it's convenient to do so."
msgstr ""
":func:`fileConfig` API 比 :func:`dictConfig` API 更旧因而没有提供涵盖日志记录特定方面的功能。 "
"例如，你无法配置 :class:`~logging.Filter` 对象，该对象使用 :func:`fileConfig` "
"提供超出简单整数级别的消息过滤功能。 如果你想要在你的日志记录配置中包含 :class:`~logging.Filter` 的实例，你将必须使用 "
":func:`dictConfig`。 请注意未来还将向 :func:`dictConfig` "
"添加对配置功能的强化，因此值得考虑在方便的时候转换到这个新 API。"

#: ../../library/logging.config.rst:831
msgid "Examples of these sections in the file are given below."
msgstr "在文件中这些小节的例子如下所示。"

#: ../../library/logging.config.rst:833
msgid ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"
msgstr ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"

#: ../../library/logging.config.rst:844
msgid ""
"The root logger must specify a level and a list of handlers. An example of a"
" root logger section is given below."
msgstr "根日志记录器必须指定一个级别和一个处理器列表。 根日志小节的例子如下所示。"

#: ../../library/logging.config.rst:847
msgid ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"
msgstr ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"

#: ../../library/logging.config.rst:853
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context"
" of the ``logging`` package's namespace."
msgstr ""
"``level`` 条目可以为 ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` 或 ``NOTSET`` 之一。 "
"作为仅适用于根日志记录器的设置，``NOTSET`` 表示将会记录所有消息。 级别值会在 ``logging`` 包命名空间的上下文中 "
":ref:`进行求值 <func-eval>`。"

#: ../../library/logging.config.rst:858
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr "``handlers`` 条目是以逗号分隔的处理器名称列表，它必须出现于 ``[handlers]`` 小节并且在配置文件中有相应的小节。"

#: ../../library/logging.config.rst:863
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr "对于根日志记录器以外的日志记录器，还需要某些附加信息。 下面的例子演示了这些信息。"

#: ../../library/logging.config.rst:866
msgid ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"
msgstr ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"

#: ../../library/logging.config.rst:874
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``,"
" the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the"
" application to get the logger."
msgstr ""
"``level`` 和 ``handlers`` 条目的解释方式与根日志记录器的一致，不同之处在于如果一个非根日志记录器的级别被指定为 "
"``NOTSET``，则系统会咨询更高层级的日志记录器来确定该日志记录器的有效级别。 ``propagate`` 条目设为 1 "
"表示消息必须从此日志记录器传播到更高层级的处理器，设为 0 表示消息 **不会** 传播到更高层级的处理器。 ``qualname`` "
"条目是日志记录器的层级通道名称，也就是应用程序获取日志记录器所用的名称。"

#: ../../library/logging.config.rst:883
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr "指定处理器配置的小节说明如下。"

#: ../../library/logging.config.rst:885
msgid ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"
msgstr ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"

#: ../../library/logging.config.rst:893
msgid ""
"The ``class`` entry indicates the handler's class (as determined by "
":func:`eval` in the ``logging`` package's namespace). The ``level`` is "
"interpreted as for loggers, and ``NOTSET`` is taken to mean 'log "
"everything'."
msgstr ""
"``class`` 条目指明处理器的类（由 ``logging`` 包命名空间中的 :func:`eval` 来确定）。 ``level`` "
"会以与日志记录器相同的方式来解读，``NOTSET`` 会被视为表示‘记录一切消息’。"

#: ../../library/logging.config.rst:897
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section"
" and have a corresponding section in the configuration file."
msgstr ""
"``formatter`` 条目指明此处理器的格式化器的键名称。 如为空白，则会使用默认的格式化器 "
"(``logging._defaultFormatter``)。 如果指定了名称，则它必须出现于 ``[formatters]`` "
"小节并且在配置文件中有相应的小节。"

#: ../../library/logging.config.rst:902
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor"
" for the handler class. Refer to the constructors for the relevant handlers,"
" or to the examples below, to see how typical entries are constructed. If "
"not provided, it defaults to ``()``."
msgstr ""
"``args`` 条目，当在 ``logging`` 包命名空间的上下文中被 :ref:`求值 <func-eval>` "
"时，将是传给处理器类构造器的参数列表。 请参阅相应处理器的构造器说明，或是下面的示例，以了解典型的条目是如何构造的。 如果未提供，则其默认值为 "
"``()``。"

#: ../../library/logging.config.rst:908
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict"
" to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"可选的 ``kwargs`` 条目，当在 ``logging`` 包命名空间的上下文中被 :ref:`求值 <func-eval>` "
"时，将是传给处理器的构造器的关键字参数字典。 如果未提供，则其默认值为 ``{}``。"

#: ../../library/logging.config.rst:912
msgid ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"
msgstr ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"

#: ../../library/logging.config.rst:965
msgid ""
"Sections which specify formatter configuration are typified by the "
"following."
msgstr "指定格式化器配置的小节说明如下。"

#: ../../library/logging.config.rst:967
msgid ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"
msgstr ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"

#: ../../library/logging.config.rst:977
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"用于格式化器配置的参数与字典规范 :ref:`格式化器部分 <logging-config-dictschema-formatters>` 中的键相同。"

#: ../../library/logging.config.rst:981
msgid ""
"The ``defaults`` entry, when :ref:`evaluated <func-eval>` in the context of "
"the ``logging`` package's namespace, is a dictionary of default values for "
"custom formatting fields. If not provided, it defaults to ``None``."
msgstr ""
"``defaults`` 条目，当在 ``logging`` 包的命名空间的上下文中 :ref:`求值 <func-eval>` "
"时，将是一个由自定义格式化字段的默认值组成的字典。 如果未提供，则默认为 ``None``。"

#: ../../library/logging.config.rst:988
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the "
":func:`listen` documentation for more information."
msgstr ""
"由于如上所述使用了 :func:`eval`，因此使用 :func:`listen` 通过套接字来发送和接收配置会导致潜在的安全风险。 "
"此风险仅限于相互间没有信任的多个用户在同一台机器上运行代码的情况；请参阅 :func:`listen` 了解更多信息。"

#: ../../library/logging.config.rst:996
msgid "Module :mod:`logging`"
msgstr "模块 :mod:`logging`"

#: ../../library/logging.config.rst:997
msgid "API reference for the logging module."
msgstr "日志记录模块的 API 参考。"

#: ../../library/logging.config.rst:999
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模块"

#: ../../library/logging.config.rst:1000
msgid "Useful handlers included with the logging module."
msgstr "日志记录模块附带的有用处理器。"
