# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-29 15:18+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/shutil.rst:2
msgid ":mod:`!shutil` --- High-level file operations"
msgstr ":mod:`!shutil` --- 高层级文件操作"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**源代码：** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
":mod:`shutil` 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 "
":mod:`os` 模块。"

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, "
":func:`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"即便是高阶文件拷贝函数 (:func:`shutil.copy`, :func:`shutil.copy2`) 也无法拷贝所有的文件元数据。"

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as"
" ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not"
" copied."
msgstr ""
"在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 "
"这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。"

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "目录和文件操作"

#: ../../library/shutil.rst:42
msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to "
"the file-like object *fdst*. The integer *length*, if given, is the buffer "
"size. In particular, a negative *length* value means to copy the data "
"without looping over the source data in chunks; by default the data is read "
"in chunks to avoid uncontrolled memory consumption. Note that if the current"
" file position of the *fsrc* object is not 0, only the contents from the "
"current file position to the end of the file will be copied."
msgstr ""
"将 :term:`文件型对象 <file object>` *fsrc* 的内容拷贝到文件型对象 *fdst*。 如果给出了整数值 "
"*length*，即为缓冲区大小。 特别地，*length* "
"为负值表示拷贝数据时不对源数据进行分块循环处理；在默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 *fsrc* 对象的当前文件位置不为 "
"0，只有从当前文件位置到文件末尾的内容会被拷贝。"

#: ../../library/shutil.rst:53
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are :term:`path-like objects <path-like object>` or path names given as "
"strings."
msgstr ""
"将名为 *src* 的文件的内容（不带元数据）拷贝到名为 *dst* 的文件并以尽可能高效的方式返回 *dst*。 *src* 和 *dst* 均为 "
":term:`数据型对象 <path-like object>` 或字符串形式的路径名。"

#: ../../library/shutil.rst:57
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify"
" the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 :func:`~shutil.copy`。 如果 *src* 和 *dst* "
"指定了同一个文件，则将引发 :exc:`SameFileError`。"

#: ../../library/shutil.rst:61
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"目标位置必须是可写的；否则将引发 :exc:`OSError` 异常。 如果 *dst* 已经存在，它将被替换。 "
"特殊文件如字符或块设备以及管道无法用此函数来拷贝。"

#: ../../library/shutil.rst:66
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr "如果 *follow_symlinks* 为假值且 *src* 为符号链接，则将创建一个新的符号链接而不是拷贝 *src* 所指向的文件。"

#: ../../library/shutil.rst:70 ../../library/shutil.rst:177
#: ../../library/shutil.rst:208
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.copyfile`` 并附带参数 ``src``, ``dst``。"

#: ../../library/shutil.rst:72
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"曾经是引发 :exc:`IOError` 而不是 :exc:`OSError`。 增加了 *follow_symlinks* 参数。 现在是返回 "
"*dst*。"

#: ../../library/shutil.rst:77
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr "引发 :exc:`SameFileError` 而不是 :exc:`Error`。 由于前者是后者的子类，此改变是向后兼容的。"

#: ../../library/shutil.rst:81 ../../library/shutil.rst:185
#: ../../library/shutil.rst:217 ../../library/shutil.rst:287
#: ../../library/shutil.rst:400
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy"
" the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 :ref:`shutil-platform-dependent-"
"efficient-copy-operations` 一节。"

#: ../../library/shutil.rst:88
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr "此异常会在 :func:`copyfile` 中的源和目标为同一文件时被引发。"

#: ../../library/shutil.rst:96
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and"
" group are unaffected.  *src* and *dst* are :term:`path-like objects <path-"
"like object>` or path names given as strings. If *follow_symlinks* is false,"
" and both *src* and *dst* are symbolic links, :func:`copymode` will attempt "
"to modify the mode of *dst* itself (rather than the file it points to).  "
"This functionality is not available on every platform; please see "
":func:`copystat` for more information.  If :func:`copymode` cannot modify "
"symbolic links on the local platform, and it is asked to do so, it will do "
"nothing and return."
msgstr ""
"将权限位从 *src* 拷贝到 *dst*。 文件的内容、所有者和分组将不受影响。 *src* 和 *dst* 均为 :term:`路径型对象 "
"<path-like object>` 或字符串形式的路径名。 如果 *follow_symlinks* 为假值，并且 *src* 和 *dst* "
"均为符号链接，则 :func:`copymode` 将尝试修改 *dst* 本身的模式（而不是它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅"
" :func:`copystat` 了解详情。 如果 :func:`copymode` "
"无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。"

#: ../../library/shutil.rst:106 ../../library/shutil.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.copymode`` 并附带参数 ``src``, ``dst``。"

#: ../../library/shutil.rst:108
msgid "Added *follow_symlinks* argument."
msgstr "加入 *follow_symlinks* 参数。"

#: ../../library/shutil.rst:113
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group"
" are unaffected.  *src* and *dst* are :term:`path-like objects <path-like "
"object>` or path names given as strings."
msgstr ""
"将权限位、最近访问时间、最近修改时间和旗标从 *src* 拷贝到 *dst*。 在 Linux 上，:func:`copystat` "
"还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 *src* 和 *dst* 均为 :term:`路径型对象 <path-"
"like object>` 或字符串形式的路径名。"

#: ../../library/shutil.rst:119
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather"
" than the files the symbolic links refer to—reading the information from the"
" *src* symbolic link, and writing the information to the *dst* symbolic "
"link."
msgstr ""
"如果 *follow_symlinks* 为假值，并且 *src* 和 *dst* 均指向符号链接，:func:`copystat` "
"将作用于符号链接本身而非该符号链接所指向的文件 — 从 *src* 符号链接读取信息，并将信息写入 *dst* 符号链接。"

#: ../../library/shutil.rst:128
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links."
"  Python itself can tell you what functionality is locally available."
msgstr "并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。"

#: ../../library/shutil.rst:132
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the permission bits of a symbolic link."
msgstr ""
"如果 ``os.chmod in os.supports_follow_symlinks`` 为 ``True``，则 :func:`copystat`"
" 可以修改符号链接的权限位。"

#: ../../library/shutil.rst:136
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the last access and modification times of a symbolic link."
msgstr ""
"如果 ``os.utime in os.supports_follow_symlinks`` 为 ``True``，则 :func:`copystat`"
" 可以修改符号链接的最近访问和修改时间。"

#: ../../library/shutil.rst:140
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the flags of a symbolic link.  (``os.chflags`` "
"is not available on all platforms.)"
msgstr ""
"如果 ``os.chflags in os.supports_follow_symlinks`` 为 ``True``，则 "
":func:`copystat` 可以修改符号链接的旗标。 (``os.chflags`` 不是在所有平台上均可用。)"

#: ../../library/shutil.rst:145
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，:func:`copystat` 将尽量拷贝所有内容。 :func:`copystat` "
"一定不会返回失败信息。"

#: ../../library/shutil.rst:150
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "更多信息请参阅 :data:`os.supports_follow_symlinks`。"

#: ../../library/shutil.rst:153 ../../library/shutil.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.copystat`` 并附带参数 ``src``, ``dst``。"

#: ../../library/shutil.rst:155
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr "添加了 *follow_symlinks* 参数并且支持 Linux 扩展属性。"

#: ../../library/shutil.rst:160
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst*"
" specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"将文件 *src* 拷贝到文件或目录 *dst*。 *src* 和 *dst* 应为 :term:`路径类对象 <path-like object>` "
"或字符串。 如果 *dst* 指定了一个目录，文件将使用 *src* 中的基准文件名拷贝到 *dst* 中。  如果 *dst* "
"指定了一个已存在的文件，它将被替换。 返回新创建文件所对应的路径。"

#: ../../library/shutil.rst:166
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"如果 *follow_symlinks* 为假值且 *src* 为符号链接，则 *dst* 也将被创建为符号链接。 如果 "
"*follow_symlinks* 为真值且 *src* 为符号链接，*dst* 将成为 *src* 所指向的文件的一个副本。"

#: ../../library/shutil.rst:171
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the"
" original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` 会拷贝文件数据和文件的权限模式 (参见 :func:`os.chmod`)。 "
"其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 :func:`~shutil.copy2` 。"

#: ../../library/shutil.rst:181
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created "
"file."
msgstr "添加了 *follow_symlinks* 参数。 现在会返回新创建文件的路径。"

#: ../../library/shutil.rst:192
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to"
" preserve file metadata."
msgstr "类似于 :func:`~shutil.copy`，区别在于 :func:`copy2` 还会尝试保留文件的元数据。"

#: ../../library/shutil.rst:195
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2`"
" attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on"
" all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; "
":func:`copy2` never raises an exception because it cannot preserve file "
"metadata."
msgstr ""
"当 *follow_symlinks* 为假值，并且 *src* 为符号链接时，:func:`copy2` 会尝试将来自 *src* "
"符号链接的所有元数据拷贝到新创建的 *dst* 符号链接。 但是，此功能不是在所有平台上均可用。 "
"在此功能部分或全部不可用的平台上，:func:`copy2` 将尽量保留所有元数据，:func:`copy2` "
"一定不会由于无法保留文件元数据而引发异常。"

#: ../../library/shutil.rst:204
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see "
":func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` 会使用 :func:`copystat` 来拷贝文件元数据。 请参阅 :func:`copystat` "
"了解有关修改符号链接元数据的平台支持的更多信息。"

#: ../../library/shutil.rst:212
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created"
" file."
msgstr "添加了 *follow_symlinks* 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。"

#: ../../library/shutil.rst:224
msgid ""
"This factory function creates a function that can be used as a callable for "
":func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"这个工厂函数会创建一个函数，它可被用作 :func:`copytree` 的 *ignore* 可调用对象参数，以忽略那些匹配所提供的 glob 风格的"
" *patterns* 之一的文件和目录。 参见以下示例。"

#: ../../library/shutil.rst:233
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"递归地将以 *src* 为根起点的整个目录树拷贝到名为 *dst* 的目录并返回目标目录。 所需的包含 *dst* 的中间目录在默认情况下也将被创建。"

#: ../../library/shutil.rst:237
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr "目录的权限和时间会通过 :func:`copystat` 来拷贝，单个文件则会使用 :func:`~shutil.copy2` 来拷贝。"

#: ../../library/shutil.rst:240
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"如果 *symlinks* "
"为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。"

#: ../../library/shutil.rst:245
msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an "
":exc:`Error` exception at the end of the copy process. You can set the "
"optional *ignore_dangling_symlinks* flag to true if you want to silence this"
" exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"当 *symlinks* 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 :exc:`Error` "
"异常中的被引发错误列表。 如果你希望屏蔽此异常则可以将可选的 *ignore_dangling_symlinks* 旗标设为真值。 请注意此选项在不支持"
" :func:`os.symlink` 的平台上将不起作用。"

#: ../../library/shutil.rst:252
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its"
" contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items"
" in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that"
" ignores names based on glob-style patterns."
msgstr ""
"如果给出了 *ignore*，它必须是一个可调用对象，该对象将接受 :func:`copytree` 所访问的目录以及 "
":func:`os.listdir` 所返回的目录内容列表作为其参数。 由于 :func:`copytree` 是递归地被调用的，*ignore* "
"可调用对象对于每个被拷贝目录都将被调用一次。 "
"该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 "
":func:`ignore_patterns` 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。"

#: ../../library/shutil.rst:262
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr "如果发生了（一个或多个）异常，将引发一个附带原因列表的 :exc:`Error`。"

#: ../../library/shutil.rst:264
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy"
" each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"如果给出了 *copy_function*，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 "
"默认情况下，:func:`~shutil.copy2` 将被使用，但任何支持同样签名（与 :func:`~shutil.copy` 一致）都可以使用。"

#: ../../library/shutil.rst:269
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a "
":exc:`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"如果 *dirs_exist_ok* 为（默认的）假值且 *dst* 已存在，则会引发 :exc:`FileExistsError`。 如果 "
"*dirs_exist_ok* 为真值，则如果拷贝操作遇到已存在的目录时将继续执行，并且在 *dst* 目录树中的文件将被 *src* "
"目录树中对应的文件所覆盖。"

#: ../../library/shutil.rst:275
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.copytree`` 并附带参数 ``src``, ``dst``。"

#: ../../library/shutil.rst:277
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"添加了 *copy_function* 参数以允许提供定制的拷贝函数。 添加了 *ignore_dangling_symlinks* 参数以便在 "
"*symlinks* 为假值时屏蔽目标不存在的符号链接。"

#: ../../library/shutil.rst:283
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "当 *symlinks* 为假值时拷贝元数据。 现在会返回 *dst*。"

#: ../../library/shutil.rst:292
msgid "Added the *dirs_exist_ok* parameter."
msgstr "增加了 *dirs_exist_ok* 形参。"

#: ../../library/shutil.rst:299
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a"
" symbolic link to a directory).  If *ignore_errors* is true, errors "
"resulting from failed removals will be ignored; if false or omitted, such "
"errors are handled by calling a handler specified by *onexc* or *onerror* "
"or, if both are omitted, exceptions are propagated to the caller."
msgstr ""
"删除一个完整的目录树；*path* 必须指向一个目录（但不能是一个目录的符号链接）。 如果 *ignore_errors* "
"为真值，则删除失败导致的错误将被忽略；如果为假值或被省略，则此类错误将通过调用由 *onexc* 或 *onerror* "
"所指定的处理器来处理，或者如果此参数被省略，异常将被传播给调用方。"

#: ../../library/shutil.rst:305
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr "本函数支持 :ref:`基于目录描述符的相对路径 <dir_fd>`。"

#: ../../library/shutil.rst:310
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms,"
" the :func:`rmtree` implementation is susceptible to a symlink attack: given"
" proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"在支持必要的基于 fd 的函数的平台上，默认会使用 :func:`rmtree` 的可防御符号链接攻击的版本。 "
"在其他平台上，:func:`rmtree` "
"较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 "
":data:`rmtree.avoids_symlink_attacks` 函数属性来确定此类情况具体是哪一些。"

#: ../../library/shutil.rst:318
msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters:"
" *function*, *path*, and *excinfo*."
msgstr "如果提供了 *onexc*，它必须为接受三个形参的可调用对象: *function*, *path* 和 *excinfo*。"

#: ../../library/shutil.rst:321
msgid ""
"The first parameter, *function*, is the function which raised the exception;"
" it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""
"第一个形参 *function* 是引发异常的函数；它依赖于具体的平台和实现。 第二个形参 *path* 将为传递给 *function* 的路径名称。"
" 第三个形参 *excinfo* 是被引发的异常。 由 *onexc* 所引发的异常将不会被捕获。"

#: ../../library/shutil.rst:327
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""
"已弃用的 *onerror* 与 *onexc* 类似，区别在于它接受的第三个形参是从 :func:`sys.exc_info` 返回的元组。"

#: ../../library/shutil.rst:331
msgid ""
":ref:`shutil-rmtree-example` for an example of handling the removal of a "
"directory tree that contains read-only files."
msgstr ":ref:`shutil-rmtree-example` 是一个处理删除包含只读文件的目录树的示例。"

#: ../../library/shutil.rst:334
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.rmtree`` 并附带参数 ``path``, ``dir_fd``。"

#: ../../library/shutil.rst:336
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr "添加了一个防御符号链接攻击的版本，如果平台支持基于 fd 的函数就会被使用。"

#: ../../library/shutil.rst:340
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr "在 Windows 上将不会再在移除连接之前删除目录连接中的内容。"

#: ../../library/shutil.rst:344
msgid "Added the *dir_fd* parameter."
msgstr "添加了 *dir_fd* 参数。"

#: ../../library/shutil.rst:347
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr "增加了 *onexc* 形参，弃用了 *onerror*。"

#: ../../library/shutil.rst:350
msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all but "
"the top-level path. Exceptions other than :exc:`OSError` and subclasses of "
":exc:`!OSError` are now always propagated to the caller."
msgstr ""
"现在 :func:`!rmtree` 会忽略最高层级路径以外所有路径的 :exc:`FileNotFoundError` 异常。 "
":exc:`OSError` 和 :exc:`!OSError` 的子类现在总是会被传播给调用方。"

#: ../../library/shutil.rst:358
msgid ""
"Indicates whether the current platform and implementation provides a symlink"
" attack resistant version of :func:`rmtree`.  Currently this is only true "
"for platforms supporting fd-based directory access functions."
msgstr ""
"指明当前平台和实现是否提供防御符号链接攻击的 :func:`rmtree` 版本。 目前它仅在平台支持基于 fd 的目录访问函数时才返回真值。"

#: ../../library/shutil.rst:367
msgid ""
"Recursively move a file or directory (*src*) to another location and return "
"the destination."
msgstr "递归地将一个文件或目录 (*src*) 移到另一位置并返回目标位置。"

#: ../../library/shutil.rst:370
msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src* is"
" moved inside that directory. The destination path in that directory must "
"not already exist."
msgstr "如果 *dst* 为已存在的目录或指向目录的符号链接，则 *src* 将被移到该目录中。 目标路径在该目录中不能已存在。"

#: ../../library/shutil.rst:374
msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr "如果 *dst* 已存在但不是一个目录，则它可能会被覆盖，具体取决于 :func:`os.rename` 的语义。"

#: ../../library/shutil.rst:377
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to the destination using *copy_function* "
"and then removed.  In case of symlinks, a new symlink pointing to the target"
" of *src* will be created as the destination and *src* will be removed."
msgstr ""
"如果目标是在当前文件系统中，则会使用 :func:`os.rename`。 在其他情况下，则使用 *copy_function* 将 *src* "
"拷贝至目标然后移除它。 对于符号链接，则将创建一个指向 *src* 目标的新符号链接作为目标位置而 *src* 将被移除。"

#: ../../library/shutil.rst:382
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments,"
" *src* and the destination, and will be used to copy *src* to the "
"destination if :func:`os.rename` cannot be used.  If the source is a "
"directory, :func:`copytree` is called, passing it the *copy_function*. The "
"default *copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the"
" *copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""
"如果给出了 *copy_function*，则它必须为接受两个参数 *src* 和目标位置的可调用对象，并将在 :func:`os.rename` "
"无法使用时被用来将 *src* 拷贝到目标位置。 如果源是一个目录，则会调用 :func:`copytree`，并向它传入 "
"*copy_function*。 默认的 *copy_function* 是 :func:`copy2`。 使用 "
":func:`~shutil.copy` 作为 *copy_function* "
"将允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。"

#: ../../library/shutil.rst:390
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``shutil.move`` 并附带参数 ``src``, ``dst``。"

#: ../../library/shutil.rst:392
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to"
" the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr "为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 :program:`mv` 的行为。 现在会返回 *dst*。"

#: ../../library/shutil.rst:397
msgid "Added the *copy_function* keyword argument."
msgstr "增加了 *copy_function* 关键字参数。"

#: ../../library/shutil.rst:405
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "接受一个 :term:`path-like object` 作为 *src* 和 *dst*。"

#: ../../library/shutil.rst:410
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"返回给定路径的磁盘使用统计数据，形式为一个 :term:`named tuple`，其中包含 *total*, *used* 和 *free* "
"属性，分别表示总计、已使用和未使用空间的字节数。 *path* 可以是一个文件或是一个目录。"

#: ../../library/shutil.rst:417
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""
"在 Unix 文件系统中，*path* 必须指向一个 **已挂载** 文件系统分区中的路径。 在这些平台上，CPython "
"不会尝试从未挂载的文件系统中获取磁盘使用信息。"

#: ../../library/shutil.rst:423
msgid "On Windows, *path* can now be a file or directory."
msgstr "在 Windows 上，*path* 现在可以是一个文件或目录。"

#: ../../library/shutil.rst:426 ../../library/shutil.rst:440
msgid "Availability"
msgstr "Availability"

#: ../../library/shutil.rst:431
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "修改给定 *path* 的所有者 *user* 和/或 *group*。"

#: ../../library/shutil.rst:433
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr "*user* 可以是一个系统用户名或 uid；*group* 同样如此。 要求至少有一个参数。"

#: ../../library/shutil.rst:436
msgid "See also :func:`os.chown`, the underlying function."
msgstr "另请参阅下层的函数 :func:`os.chown`。"

#: ../../library/shutil.rst:438
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.chown`` 并附带参数 ``path``, ``user``, "
"``group``。"

#: ../../library/shutil.rst:444
msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr "增加了 *dir_fd* 和 *follow_symlinks* 形参。"

#: ../../library/shutil.rst:450
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr "返回当给定的 *cmd* 被调用时将要运行的可执行文件的路径。 如果没有 *cmd* 会被调用则返回 ``None``。"

#: ../../library/shutil.rst:453
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr "*mode* 是一个传递给 :func:`os.access` 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。"

#: ../../library/shutil.rst:456
msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the "
":envvar:`PATH` environment variable is read from :data:`os.environ`, falling"
" back to :data:`os.defpath` if it is not set."
msgstr ""
"*path* 是一个指明要查找的目录的 \"``PATH`` 字符串\"，由 :data:`os.pathsep` 分隔。 当未指定 *path* "
"时，将从 :data:`os.environ` 读取 :envvar:`PATH` 环境变量，如果其未被设置则将回退至 "
":data:`os.defpath`。"

#: ../../library/shutil.rst:461
msgid ""
"If *cmd* contains a directory component, :func:`!which` only checks the "
"specified path directly and does not search the directories listed in *path*"
" or in the system's :envvar:`PATH` environment variable."
msgstr ""
"如果 *cmd* 包含目录部分，则 :func:`!which` 仅直接检查指定的路径而不搜索在 *path* 或系统 :envvar:`PATH` "
"环境变量中列出的目录。"

#: ../../library/shutil.rst:465
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""
"在 Windows 上，如果 *mode* 不包括 ``os.X_OK`` 则会将当前目录添加到 *path* 中。 当 *mode* 包括 "
"``os.X_OK`` 时，则将通过 Windows API ``NeedCurrentDirectoryForExePathW`` "
"来确定当前目录是否应当添加到 *path* 中。 要避免在当前工作目录下查找可执行文件：可设置 "
"``NoDefaultCurrentDirectoryInExePath`` 环境变量。"

#: ../../library/shutil.rst:472
msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, if "
"you call ``shutil.which(\"python\")``, :func:`which` will search ``PATHEXT``"
" to know that it should look for ``python.exe`` within the *path* "
"directories. For example, on Windows::"
msgstr ""
"在 Windows 上，还会使用 :envvar:`PATHEXT` 环境变量来处理可能尚未包括某个扩展的命令。 举例来说，如果你调用 "
"``shutil.which(\"python\")``，:func:`which` 将搜索 ``PATHEXT`` 以获知应当在 *path* "
"的目录中查找 ``python.exe``。 例如，在 Windows 上::"

#: ../../library/shutil.rst:478
msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:481
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr "这也适用于当 *cmd* 是一个包含目录组成部分路径的情况::"

#: ../../library/shutil.rst:484
msgid ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:489
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"现在可以接受 :class:`bytes` 类型。 如果 *cmd* 的类型为 :class:`bytes`，结果的类型也将为 "
":class:`bytes`。"

#: ../../library/shutil.rst:493
msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT``"
" is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""
"在 Windows 上，如果 *mode* 包括 ``os.X_OK`` 且 WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` "
"为假值则不会再将当前目录添加到搜索路径中，否则即使当前目录已经在搜索路径中仍会再次添加它；现在 ``PATHEXT`` 即使当 *cmd* "
"包括目录组成部分或以 ``PATHEXT`` 中的扩展名结束时仍然会被使用；并且没有扩展名的文件名现在也能被找到。"

#: ../../library/shutil.rst:504
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of "
"3-tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"此异常会收集在多文件操作期间所引发的异常。 对于 :func:`copytree`，此异常参数将是一个由三元组 (*srcname*, "
"*dstname*, *exception*) 构成的列表。"

#: ../../library/shutil.rst:511
msgid "Platform-dependent efficient copy operations"
msgstr "依赖于具体平台的高效拷贝操作"

#: ../../library/shutil.rst:513
msgid ""
"Starting from Python 3.8, all functions involving a file copy "
"(:func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, "
"and :func:`move`) may use platform-specific \"fast-copy\" syscalls in order "
"to copy the file more efficiently (see :issue:`33671`). \"fast-copy\" means "
"that the copying operation occurs within the kernel, avoiding the use of "
"userspace buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"从 Python 3.8 开始，所有涉及文件拷贝的函数 (:func:`copyfile`, :func:`~shutil.copy`, "
":func:`copy2`, :func:`copytree` 以及 :func:`move`) 将会使用平台专属的 \"fast-copy\" "
"系统调用以便更高效地拷贝文件 (参见 :issue:`33671`)。 \"fast-copy\" 意味着拷贝操作将发生于内核之中，避免像在 "
"\"``outfd.write(infd.read())``\" 中那样使用 Python 用户空间的缓冲区。"

#: ../../library/shutil.rst:521
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr "在 macOS 上将会使用 `fcopyfile`_ 来拷贝文件内容（不含元数据）。"

#: ../../library/shutil.rst:523
msgid "On Linux :func:`os.sendfile` is used."
msgstr "在 Linux 上将会使用 :func:`os.sendfile`。"

#: ../../library/shutil.rst:525
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of "
":func:`shutil.copyfileobj` is used."
msgstr ""
"在 Windows 上 :func:`shutil.copyfile` 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 "
":func:`memoryview` 的 :func:`shutil.copyfileobj` 变种形式。"

#: ../../library/shutil.rst:529
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient "
":func:`copyfileobj` function internally."
msgstr ""
"如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 :func:`copyfileobj` 函数。"

#: ../../library/shutil.rst:538
msgid "copytree example"
msgstr "copytree 示例"

#: ../../library/shutil.rst:540
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "一个使用 :func:`ignore_patterns` 辅助函数的例子::"

#: ../../library/shutil.rst:542
msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"

#: ../../library/shutil.rst:546
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr "这将会拷贝除 ``.pyc`` 文件和以 ``tmp`` 打头的文件或目录以外的所有条目."

#: ../../library/shutil.rst:549
msgid ""
"Another example that uses the *ignore* argument to add a logging call::"
msgstr "另一个使用 *ignore* 参数来添加记录调用的例子::"

#: ../../library/shutil.rst:551
msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"

#: ../../library/shutil.rst:564
msgid "rmtree example"
msgstr "rmtree 示例"

#: ../../library/shutil.rst:566
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onexc 回调函数来清除只读属性并再次尝试删除。 "
"任何后续的失败都将被传播。 ::"

#: ../../library/shutil.rst:571
msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"

#: ../../library/shutil.rst:584
msgid "Archiving operations"
msgstr "归档操作"

#: ../../library/shutil.rst:588
msgid "Added support for the *xztar* format."
msgstr "添加了对 *xztar* 格式的支持。"

#: ../../library/shutil.rst:592
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 :mod:`zipfile` 和 :mod:`tarfile` 模块。"

#: ../../library/shutil.rst:597
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "创建一个归档文件（例如 zip 或 tar）并返回其名称。"

#: ../../library/shutil.rst:599
msgid ""
"*base_name* is the name of the file to create, including the path, minus any"
" format-specific extension."
msgstr "*base_name* 是要创建的文件的名称，包括路径，去除任何格式专属的扩展名。"

#: ../../library/shutil.rst:602
msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module is"
" available), \"tar\", \"gztar\" (if the :mod:`zlib` module is available), "
"\"bztar\" (if the :mod:`bz2` module is available), or \"xztar\" (if the "
":mod:`lzma` module is available)."
msgstr ""
"*format* 是归档格式：为 \"zip\" (如果 :mod:`zlib` 模块可用), \"tar\", \"gztar\" (如果 "
":mod:`zlib` 模块可用), \"bztar\" (如果 :mod:`bz2` 模块可用) 或 \"xztar\" (如果 "
":mod:`lzma` 模块可用) 中的一个。"

#: ../../library/shutil.rst:607
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* 是一个目录，它将作为归档文件的根目录，归档中的所有路径都将是它的相对路径；例如，我们通常会在创建归档之前用 chdir 命令切换到"
" *root_dir*。"

#: ../../library/shutil.rst:611
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-"
"archiving-example-with-basedir` for how to use *base_dir* and *root_dir* "
"together."
msgstr ""
"*base_dir* 是我们要执行归档的起始目录；也就是说 *base_dir* 将成为归档中所有文件和目录共有的路径前缀。 *base_dir* "
"必须相对于 *root_dir* 给出。 请参阅 :ref:`shutil-archiving-example-with-basedir` "
"了解如何同时使用 *base_dir* 和 *root_dir*。"

#: ../../library/shutil.rst:617
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* 和 *base_dir* 默认均为当前目录。"

#: ../../library/shutil.rst:619
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr "如果 *dry_run* 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 *logger*。"

#: ../../library/shutil.rst:622
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr "*owner* 和 *group* 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。"

#: ../../library/shutil.rst:625
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr "*logger* 必须是一个兼容 :pep:`282` 的对象，通常为 :class:`logging.Logger` 的实例。"

#: ../../library/shutil.rst:628
msgid "The *verbose* argument is unused and deprecated."
msgstr "*verbose* 参数已不再使用并进入弃用状态。"

#: ../../library/shutil.rst:630
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.make_archive`` 并附带参数 ``base_name``, "
"``format``, ``root_dir``, ``base_dir``。"

#: ../../library/shutil.rst:634
msgid ""
"This function is not thread-safe when custom archivers registered with "
":func:`register_archive_format` do not support the *root_dir* argument.  In "
"this case it temporarily changes the current working directory of the "
"process to *root_dir* to perform archiving."
msgstr ""
"此函数在通过 :func:`register_archive_format` 注册的自定义归档程序不支持 *root_dir* 参数时时不是线程安全的。"
" 在这种情况下它会临时改变进程的当前工作目录到 *root_dir* 来执行归档操作。"

#: ../../library/shutil.rst:640
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"现在对于通过 ``format=\"tar\"`` 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。"

#: ../../library/shutil.rst:644
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr "目前此函数在创建标准 ``.zip`` 和 tar 归档文件期间会确保是线程安全的。"

#: ../../library/shutil.rst:650
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr "返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 ``(name, description)``。"

#: ../../library/shutil.rst:653 ../../library/shutil.rst:764
msgid "By default :mod:`shutil` provides these formats:"
msgstr "默认情况下 :mod:`shutil` 提供以下格式:"

#: ../../library/shutil.rst:655
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP 文件（如果 :mod:`zlib` 模块可用）。"

#: ../../library/shutil.rst:656
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr "*tar*: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。"

#: ../../library/shutil.rst:657 ../../library/shutil.rst:769
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: gzip 压缩的 tar 文件（如果 :mod:`zlib` 模块可用）。"

#: ../../library/shutil.rst:658 ../../library/shutil.rst:770
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*: bzip2 压缩的 tar 文件（如果 :mod:`bz2` 模块可用）。"

#: ../../library/shutil.rst:659 ../../library/shutil.rst:771
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz 压缩的 tar 文件（如果 :mod:`lzma` 模块可用）。"

#: ../../library/shutil.rst:661
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr "你可以通过使用 :func:`register_archive_format` 注册新的格式或为任何现有格式提供你自己的归档器。"

#: ../../library/shutil.rst:667
msgid "Register an archiver for the format *name*."
msgstr "为 *name* 格式注册一个归档器。"

#: ../../library/shutil.rst:669
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the"
" *base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 *base_name*，再加上要归档内容的 "
"*base_dir* (其默认值为 :data:`os.curdir`)。 更多参数会被作为关键字参数传入: *owner*, *group*, "
"*dry_run* 和 *logger* (与向 :func:`make_archive` 传入的参数一致)。"

#: ../../library/shutil.rst:675
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to"
" ``True``, the *root_dir* argument is passed as a keyword argument. "
"Otherwise the current working directory of the process is temporarily "
"changed to *root_dir* before calling *function*. In this case "
":func:`make_archive` is not thread-safe."
msgstr ""
"如果 *function* 将自定义属性 ``function.supports_root_dir`` 设为 ``True``，则会以关键字参数形式传递"
" *root_dir* 参数。 否则进程的当前工作目录将在调用 *function* 之前被临时更改为 *root_dir*。 在此情况下 "
":func:`make_archive` 将不是线程安全的。"

#: ../../library/shutil.rst:681
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be"
" used as extra keywords arguments when the archiver callable is used."
msgstr ""
"如果给出了 *extra_args*，则其应为一个 ``(name, value)`` 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。"

#: ../../library/shutil.rst:684
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* 由 :func:`get_archive_formats` 使用，它将返回归档器的列表。 默认值为一个空字符串。"

#: ../../library/shutil.rst:687
msgid "Added support for functions supporting the *root_dir* argument."
msgstr "增加了对支持 *root_dir* 参数的函数的支持。"

#: ../../library/shutil.rst:693
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "从支持的格式中移除归档格式 *name*。"

#: ../../library/shutil.rst:698
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "解包一个归档文件。 *filename* 是归档文件的完整路径。"

#: ../../library/shutil.rst:700
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr "*extract_dir* 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。"

#: ../../library/shutil.rst:703
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with "
":func:`register_unpack_format`.  If not provided, :func:`unpack_archive` "
"will use the archive file name extension and see if an unpacker was "
"registered for that extension.  In case none is found, a :exc:`ValueError` "
"is raised."
msgstr ""
"*format* 是归档格式：应为 \"zip\", \"tar\", \"gztar\", \"bztar\" 或 \"xztar\" 之一。 "
"或者任何通过 :func:`register_unpack_format` 注册的其他格式。 如果未提供，:func:`unpack_archive` "
"将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 :exc:`ValueError`。"

#: ../../library/shutil.rst:710
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to set it to ``'data'``, unless using features specific to tar "
"and UNIX-like filesystems. (See :ref:`tarfile-extraction-filter` for "
"details.) The ``'data'`` filter will become the default for tar files in "
"Python 3.14."
msgstr ""
"仅限关键字参数 *filter* 将被传给下层的解包函数。 对于 zip 文件，*filter* 将不被接受。 对于 tar 文件，推荐将其设为 "
"``'data'``，除非使用了 tar 专属的特征且为 UNIX 类文件系统。 （请参阅 :ref:`tarfile-extraction-"
"filter` 了解详情。） ``'data'`` 将在 Python 3.14 中成为 tar 文件的默认过滤器。"

#: ../../library/shutil.rst:718
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``shutil.unpack_archive`` 并附带参数 ``filename``, "
"``extract_dir``, ``format``。"

#: ../../library/shutil.rst:722
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能会在 *extract_dir* 参数所指定的路径之外创建文件，例如某些成员具有以 "
"\"/\" 打头的绝对路径文件名或是以两个点号 \"..\" 打头的文件名。"

#: ../../library/shutil.rst:727
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr "接受一个 :term:`path-like object` 作为 *filename* 和 *extract_dir*。"

#: ../../library/shutil.rst:730
msgid "Added the *filter* argument."
msgstr "增加了 *filter* 参数。"

#: ../../library/shutil.rst:735
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like "
"``.zip`` for Zip files."
msgstr ""
"注册一个解包格式。 *name* 为格式名称而 *extensions* 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 ``.zip``。"

#: ../../library/shutil.rst:739
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr "*function* 是将被用于解包归档的可调用对象。 该可调用对象将接受:"

#: ../../library/shutil.rst:742
msgid "the path of the archive, as a positional argument;"
msgstr "归档的路径，为位置参数;"

#: ../../library/shutil.rst:743
msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr "归档要提取到的目录，为位置参数;"

#: ../../library/shutil.rst:744
msgid ""
"possibly a *filter* keyword argument, if it was given to "
":func:`unpack_archive`;"
msgstr "可选的 *filter* 关键字参数，如果有提供给 :func:`unpack_archive` 的话;"

#: ../../library/shutil.rst:746
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr "额外的关键字参数，由 ``(name, value)`` 元组组成的序列 *extra_args* 指明。"

#: ../../library/shutil.rst:749
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr "可以提供 *description* 来描述该格式，它将被 :func:`get_unpack_formats` 返回。"

#: ../../library/shutil.rst:755
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "撤销注册一个解包格式。 *name* 为格式的名称。"

#: ../../library/shutil.rst:760
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr "返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 ``(name, extensions, description)``。"

#: ../../library/shutil.rst:766
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr "*zip*: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。"

#: ../../library/shutil.rst:768
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: 未压缩的 tar 文件。"

#: ../../library/shutil.rst:773
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr "你可以通过使用 :func:`register_unpack_format` 注册新的格式或为任何现有格式提供你自己的解包器。"

#: ../../library/shutil.rst:780
msgid "Archiving example"
msgstr "归档程序示例"

#: ../../library/shutil.rst:782
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr "在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 :file:`.ssh` 目录下的所有文件::"

#: ../../library/shutil.rst:785
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"

#: ../../library/shutil.rst:792
msgid "The resulting archive contains:"
msgstr "结果归档文件中包含有:"

#: ../../library/shutil.rst:794
msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"

#: ../../library/shutil.rst:810
msgid "Archiving example with *base_dir*"
msgstr "使用 *base_dir* 的归档程序示例"

#: ../../library/shutil.rst:812
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we"
" show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"在这个例子中，与 `上面的例子 <shutil-archiving-example_>`_ 类似，我们演示了如何使用 "
":func:`make_archive`，但这次是使用 *base_dir*。 我们现在具有如下的目录结构:"

#: ../../library/shutil.rst:816
msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"

#: ../../library/shutil.rst:826
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but "
":file:`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"在最终的归档中，应当会包括 :file:`please_add.txt`，但不应当包括 :file:`do_not_add.txt`。 "
"因此我们使用以下代码::"

#: ../../library/shutil.rst:829
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/myarchive.tar'"
msgstr ""

#: ../../library/shutil.rst:840
msgid "Listing the files in the resulting archive gives us:"
msgstr "列出结果归档中的文件我们将会得到:"

#: ../../library/shutil.rst:842
msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"

#: ../../library/shutil.rst:850
msgid "Querying the size of the output terminal"
msgstr "查询输出终端的尺寸"

#: ../../library/shutil.rst:854
msgid "Get the size of the terminal window."
msgstr "获取终端窗口的尺寸。"

#: ../../library/shutil.rst:856
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value"
" is a positive integer, it is used."
msgstr ""
"对于两个维度中的每一个，会分别检查环境变量 ``COLUMNS`` 和 ``LINES``。 如果定义了这些变量并且其值为正整数，则将使用这些值。"

#: ../../library/shutil.rst:860
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking "
":func:`os.get_terminal_size`."
msgstr ""
"如果未定义 ``COLUMNS`` 或 ``LINES``，这是通常的情况，则连接到 :data:`sys.__stdout__` 的终端将通过唤起 "
":func:`os.get_terminal_size` 被查询。"

#: ../../library/shutil.rst:864
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 ``fallback`` 形参中给出的值。 "
"``fallback`` 默认为 ``(80, 24)``，这是许多终端模拟器所使用的默认尺寸。"

#: ../../library/shutil.rst:870
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr "返回的值是一个 :class:`os.terminal_size` 类型的具名元组。"

#: ../../library/shutil.rst:872
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"另请参阅: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."

#: ../../library/shutil.rst:877
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr "如果 :func:`os.get_terminal_size` 返回零值则 ``fallback`` 值也将被使用。"

#: ../../library/shutil.rst:12
msgid "file"
msgstr "文件"

#: ../../library/shutil.rst:12
msgid "copying"
msgstr "拷贝"

#: ../../library/shutil.rst:12
msgid "copying files"
msgstr "拷贝文件"

#: ../../library/shutil.rst:297
msgid "directory"
msgstr "directory"

#: ../../library/shutil.rst:297
msgid "deleting"
msgstr "删除"
