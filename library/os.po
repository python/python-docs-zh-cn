# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# isombyt <isombyt@isombyt.me>, 2021
# Steve Ni <wincss@gmail.com>, 2021
# Zombie110year <zombie110year@gmail.com>, 2021
# SKY H. <sky19960802@gmail.com>, 2021
# 1lin24 <1lin24@sina.com>, 2021
# sunsol s <sunsolzn@gmail.com>, 2021
# ChenYuan <github@qiushi.ac.cn>, 2021
# Kade For, 2021
# sgqy <sgqyzh@gmail.com>, 2021
# cdarlint <cdarling@126.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# Trim21 <i@trim21.me>, 2021
# 96ea86b025a96effe58335f7b3bef4bc_e6c340d <e08e1f6a23a9b48bf97be6e67771cdbc_822089>, 2021
# Arisaka97 <solitaire2312@gmail.com>, 2021
# 林行众 <linxzh1989@gmail.com>, 2021
# CCXXXI <ccxxxi@qq.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# ProgramRipper, 2023
# Dai Xu <daixu61@hotmail.com>, 2023
# WH-2099 <wh2099@outlook.com>, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# starklin, 2023
# Sefank <sefank@foxmail.com>, 2023
# lit, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/os.rst:2
msgid ":mod:`!os` --- Miscellaneous operating system interfaces"
msgstr ":mod:`!os` --- 多种操作系统接口"

#: ../../library/os.rst:7
msgid "**Source code:** :source:`Lib/os.py`"
msgstr "**源代码：** :source:`Lib/os.py`"

#: ../../library/os.rst:11
msgid ""
"This module provides a portable way of using operating system dependent "
"functionality.  If you just want to read or write a file see :func:`open`, "
"if you want to manipulate paths, see the :mod:`os.path` module, and if you "
"want to read all the lines in all the files on the command line see the "
":mod:`fileinput` module.  For creating temporary files and directories see "
"the :mod:`tempfile` module, and for high-level file and directory handling "
"see the :mod:`shutil` module."
msgstr ""
"本模块提供了一种使用与操作系统相关的功能的便捷式途径。 如果你只是想读写一个文件，请参阅 :func:`open`，如果你想操作文件路径，请参阅 "
":mod:`os.path` 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 :mod:`fileinput` 模块。 "
"为了创建临时文件和目录，请参阅 :mod:`tempfile` 模块，对于高级文件和目录处理，请参阅 :mod:`shutil` 模块。"

#: ../../library/os.rst:19
msgid "Notes on the availability of these functions:"
msgstr "关于这些函数的适用性的说明："

#: ../../library/os.rst:21
msgid ""
"The design of all built-in operating system dependent modules of Python is "
"such that as long as the same functionality is available, it uses the same "
"interface; for example, the function ``os.stat(path)`` returns stat "
"information about *path* in the same format (which happens to have "
"originated with the POSIX interface)."
msgstr ""
"Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系统某一相同的功能可用，它就使用相同的接口。例如，函数 "
"``os.stat(path)`` 以相同的格式返回关于 *path* 的状态信息（该格式源于 POSIX 接口）。"

#: ../../library/os.rst:27
msgid ""
"Extensions peculiar to a particular operating system are also available "
"through the :mod:`os` module, but using them is of course a threat to "
"portability."
msgstr "特定于某一操作系统的扩展通过操作 :mod:`os` 模块也是可用的，但是使用它们当然是对可移植性的一种威胁。"

#: ../../library/os.rst:31
msgid ""
"All functions accepting path or file names accept both bytes and string "
"objects, and result in an object of the same type, if a path or file name is"
" returned."
msgstr "所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径或文件名时使用相应类型的对象作为结果。"

#: ../../library/os.rst:35
msgid ""
"On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported."
msgstr "在 VxWorks 系统上，os.popen, os.fork, os.execv 和 os.spawn*p* 都未支持。"

#: ../../library/os.rst:37
msgid ""
"On WebAssembly platforms, Android and iOS, large parts of the :mod:`os` "
"module are not available or behave differently. APIs related to processes "
"(e.g. :func:`~os.fork`, :func:`~os.execve`) and resources (e.g. "
":func:`~os.nice`) are not available. Others like :func:`~os.getuid` and "
":func:`~os.getpid` are emulated or stubs. WebAssembly platforms also lack "
"support for signals (e.g. :func:`~os.kill`, :func:`~os.wait`)."
msgstr ""
"在 WebAssembly 平台、Android 和 iOS 上，:mod:`os` 模块的很大一部分都不可用或具有不同的行为。 与进程相关联的 API"
" (例如 :func:`~os.fork`, :func:`~os.execve`) 和资源 (例如 :func:`~os.nice`) 都不可用。 "
"其他诸如 :func:`~os.getuid` 和 :func:`~os.getpid` 等则为模拟或空盒。 WebAssembly 平台还缺少对信号 "
"(例如 :func:`~os.kill`, :func:`~os.wait`) 的支持。"

#: ../../library/os.rst:47
msgid ""
"All functions in this module raise :exc:`OSError` (or subclasses thereof) in"
" the case of invalid or inaccessible file names and paths, or other "
"arguments that have the correct type, but are not accepted by the operating "
"system."
msgstr ""
"如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接受的参数，此模块的所有函数都抛出 :exc:`OSError` （或者它的子类）。"

#: ../../library/os.rst:53
msgid "An alias for the built-in :exc:`OSError` exception."
msgstr "内建的 :exc:`OSError` 异常的一个别名。"

#: ../../library/os.rst:58
msgid ""
"The name of the operating system dependent module imported.  The following "
"names have currently been registered: ``'posix'``, ``'nt'``, ``'java'``."
msgstr "导入的依赖特定操作系统的模块的名称。以下名称目前已注册: ``'posix'``, ``'nt'``, ``'java'``."

#: ../../library/os.rst:63
msgid ""
":data:`sys.platform` has a finer granularity.  :func:`os.uname` gives "
"system-dependent version information."
msgstr ":data:`sys.platform` 具有更细的粒度。 :func:`os.uname` 将给出基于不同系统的版本信息。"

#: ../../library/os.rst:66
msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ":mod:`platform` 模块对系统的标识有更详细的检查。"

#: ../../library/os.rst:74
msgid "File Names, Command Line Arguments, and Environment Variables"
msgstr "文件名，命令行参数，以及环境变量。"

#: ../../library/os.rst:76
msgid ""
"In Python, file names, command line arguments, and environment variables are"
" represented using the string type. On some systems, decoding these strings "
"to and from bytes is necessary before passing them to the operating system. "
"Python uses the :term:`filesystem encoding and error handler` to perform "
"this conversion (see :func:`sys.getfilesystemencoding`)."
msgstr ""
"在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。 "
"Python 使用 :term:`filesystem encoding and error handler` 来执行此转换（请参阅 "
":func:`sys.getfilesystemencoding` ）。"

#: ../../library/os.rst:82
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` 是在 Python 启动时通过 "
":c:func:`PyConfig_Read` 函数来配置的：请参阅 :c:type:`PyConfig` 的 "
":c:member:`~PyConfig.filesystem_encoding` 和 "
":c:member:`~PyConfig.filesystem_errors` 等成员。"

#: ../../library/os.rst:87
msgid ""
"On some systems, conversion using the file system encoding may fail. In this"
" case, Python uses the :ref:`surrogateescape encoding error handler "
"<surrogateescape>`, which means that undecodable bytes are replaced by a "
"Unicode character U+DC\\ *xx* on decoding, and these are again translated to"
" the original byte on encoding."
msgstr ""
"在某些系统上，使用文件系统编码格式进行转换可能会失败。 在这种情况下，Python 会使用 :ref:`surrogateescape 编码错误处理器 "
"<surrogateescape>`，这意味着不可解码的字节在解码时会被 Unicode 字符 U+DC\\ *xx* "
"替换，并且这些字节在编码时又会再次被转换为原始字节。"

#: ../../library/os.rst:95
msgid ""
"The :term:`file system encoding <filesystem encoding and error handler>` "
"must guarantee to successfully decode all bytes below 128. If the file "
"system encoding fails to provide this guarantee, API functions can raise "
":exc:`UnicodeError`."
msgstr ""
":term:`文件系统编码器 <filesystem encoding and error handler>` 必须保证能成功解码所有 128 "
"以内的字节。如果不能保证，API 函数可能触发 :exc:`UnicodeError` 。"

#: ../../library/os.rst:100
msgid "See also the :term:`locale encoding`."
msgstr "另请参见 :term:`locale encoding`。"

#: ../../library/os.rst:106
msgid "Python UTF-8 Mode"
msgstr "Python UTF-8 模式"

#: ../../library/os.rst:108
msgid "See :pep:`540` for more details."
msgstr "有关更多详细信息，请参阅 :pep:`540` 。"

#: ../../library/os.rst:111
msgid ""
"The Python UTF-8 Mode ignores the :term:`locale encoding` and forces the "
"usage of the UTF-8 encoding:"
msgstr "Python UTF-8 模式会忽略 :term:`locale encoding` 并强制使用 UTF-8 编码。"

#: ../../library/os.rst:114
msgid ""
"Use UTF-8 as the :term:`filesystem encoding <filesystem encoding and error "
"handler>`."
msgstr "用 UTF-8 作为 :term:`文件系统编码 <filesystem encoding and error handler>`。"

#: ../../library/os.rst:116
msgid ":func:`sys.getfilesystemencoding` returns ``'utf-8'``."
msgstr ":func:`sys.getfilesystemencoding` 返回 ``'utf-8'``。"

#: ../../library/os.rst:117
msgid ""
":func:`locale.getpreferredencoding` returns ``'utf-8'`` (the *do_setlocale* "
"argument has no effect)."
msgstr ""
":func:`locale.getpreferredencoding` 返回 ``'utf-8'`` (*do_setlocale* 参数不起作用)。"

#: ../../library/os.rst:119
msgid ""
":data:`sys.stdin`, :data:`sys.stdout`, and :data:`sys.stderr` all use UTF-8 "
"as their text encoding, with the ``surrogateescape`` :ref:`error handler "
"<error-handlers>` being enabled for :data:`sys.stdin` and :data:`sys.stdout`"
" (:data:`sys.stderr` continues to use ``backslashreplace`` as it does in the"
" default locale-aware mode)"
msgstr ""
":data:`sys.stdin`, :data:`sys.stdout` 和 :data:`sys.stderr` 都将 UTF-8 "
"用作它们的文本编码，并且为 :data:`sys.stdin` 和 :data:`sys.stdout` 启用 ``surrogateescape`` "
":ref:`错误处理器 <error-handlers>` (:data:`sys.stderr` 会继续使用 ``backslashreplace``"
" 如同在默认的局部感知模式下一样)"

#: ../../library/os.rst:124
msgid ""
"On Unix, :func:`os.device_encoding` returns ``'utf-8'`` rather than the "
"device encoding."
msgstr "在 Unix 上，:func:`os.device_encoding` 返回 ``'utf-8'`` 而不是设备的编码格式。"

#: ../../library/os.rst:127
msgid ""
"Note that the standard stream settings in UTF-8 mode can be overridden by "
":envvar:`PYTHONIOENCODING` (just as they can be in the default locale-aware "
"mode)."
msgstr ""
"请注意 UTF-8 模式下的标准流设置可以被 :envvar:`PYTHONIOENCODING` 所覆盖（在默认的区域感知模式下也同样如此）。"

#: ../../library/os.rst:131
msgid ""
"As a consequence of the changes in those lower level APIs, other higher "
"level APIs also exhibit different default behaviours:"
msgstr "作为低层级 API 发生改变的结果，其他高层级 API 也会表现出不同的默认行为："

#: ../../library/os.rst:134
msgid ""
"Command line arguments, environment variables and filenames are decoded to "
"text using the UTF-8 encoding."
msgstr "命令行参数，环境变量和文件名会使用 UTF-8 编码来解码为文本。"

#: ../../library/os.rst:136
msgid ":func:`os.fsdecode` and :func:`os.fsencode` use the UTF-8 encoding."
msgstr ":func:`os.fsdecode` 和 :func:`os.fsencode` 使用 UTF-8 编码格式。"

#: ../../library/os.rst:137
msgid ""
":func:`open`, :func:`io.open`, and :func:`codecs.open` use the UTF-8 "
"encoding by default. However, they still use the strict error handler by "
"default so that attempting to open a binary file in text mode is likely to "
"raise an exception rather than producing nonsense data."
msgstr ""
":func:`open`, :func:`io.open` 和 :func:`codecs.open` 默认会使用 UTF-8 编码格式。 "
"但是，它们默认仍将使用 strict 错误处理器因此试图在文本模式下打开二进制文件可能会引发异常而不是产生无意义的数据。"

#: ../../library/os.rst:142
msgid ""
"The :ref:`Python UTF-8 Mode <utf8-mode>` is enabled if the LC_CTYPE locale "
"is ``C`` or ``POSIX`` at Python startup (see the :c:func:`PyConfig_Read` "
"function)."
msgstr ""
"如果在 Python 启动时 LC_CTYPE 区域设为 ``C`` 或 ``POSIX`` ，则启用 :ref:`Python UTF-8 模式 "
"<utf8-mode>` (参见 :c:func:`PyConfig_Read` 函数)。"

#: ../../library/os.rst:146
msgid ""
"It can be enabled or disabled using the :option:`-X utf8 <-X>` command line "
"option and the :envvar:`PYTHONUTF8` environment variable."
msgstr "它可以通过命令行选项 :option:`-X utf8 <-X>` 和环境变量 :envvar:`PYTHONUTF8`，来启用或禁用。"

#: ../../library/os.rst:149
msgid ""
"If the :envvar:`PYTHONUTF8` environment variable is not set at all, then the"
" interpreter defaults to using the current locale settings, *unless* the "
"current locale is identified as a legacy ASCII-based locale (as described "
"for :envvar:`PYTHONCOERCECLOCALE`), and locale coercion is either disabled "
"or fails. In such legacy locales, the interpreter will default to enabling "
"UTF-8 mode unless explicitly instructed not to do so."
msgstr ""
"如果没有设置 :envvar:`PYTHONUTF8` 环境变量，那么解释器默认使用当前的地区设置，*除非* 当前地区识别为基于 ASCII "
"的传统地区（如 :envvar:`PYTHONCOERCECLOCALE` 所述），并且 locale coercion "
"被禁用或失败。在这种传统地区，除非显式指明不要如此，解释器将默认启用 UTF-8 模式。"

#: ../../library/os.rst:156
msgid ""
"The Python UTF-8 Mode can only be enabled at the Python startup. Its value "
"can be read from :data:`sys.flags.utf8_mode <sys.flags>`."
msgstr ""
"Python UTF-8 模式只能在 Python 启动时启用。其值可以从 :data:`sys.flags.utf8_mode "
"<sys.flags>` 读取。"

#: ../../library/os.rst:159
msgid ""
"See also the :ref:`UTF-8 mode on Windows <win-utf8-mode>` and the "
":term:`filesystem encoding and error handler`."
msgstr ""
"另请参阅 :ref:`在 Windows 中的 UTF-8 模式 <win-utf8-mode>` 和 :term:`filesystem "
"encoding and error handler`。"

#: ../../library/os.rst:164
msgid ":pep:`686`"
msgstr ":pep:`686`"

#: ../../library/os.rst:165
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr "Python 3.15 将把 :ref:`utf8-mode` 设为默认值。"

#: ../../library/os.rst:171
msgid "Process Parameters"
msgstr "进程参数"

#: ../../library/os.rst:173
msgid ""
"These functions and data items provide information and operate on the "
"current process and user."
msgstr "这些函数和数据项提供了操作当前进程和用户的信息。"

#: ../../library/os.rst:179
msgid ""
"Return the filename corresponding to the controlling terminal of the "
"process."
msgstr "返回与进程控制终端对应的文件名。"

#: ../../library/os.rst:181 ../../library/os.rst:345 ../../library/os.rst:360
#: ../../library/os.rst:381 ../../library/os.rst:390 ../../library/os.rst:399
#: ../../library/os.rst:412 ../../library/os.rst:421 ../../library/os.rst:449
#: ../../library/os.rst:457 ../../library/os.rst:465 ../../library/os.rst:485
#: ../../library/os.rst:503 ../../library/os.rst:514 ../../library/os.rst:526
#: ../../library/os.rst:535 ../../library/os.rst:545 ../../library/os.rst:556
#: ../../library/os.rst:568 ../../library/os.rst:604 ../../library/os.rst:611
#: ../../library/os.rst:618 ../../library/os.rst:627 ../../library/os.rst:664
#: ../../library/os.rst:677 ../../library/os.rst:686 ../../library/os.rst:703
#: ../../library/os.rst:712 ../../library/os.rst:719 ../../library/os.rst:728
#: ../../library/os.rst:737 ../../library/os.rst:744 ../../library/os.rst:751
#: ../../library/os.rst:760 ../../library/os.rst:817 ../../library/os.rst:858
#: ../../library/os.rst:980 ../../library/os.rst:1006
#: ../../library/os.rst:1019 ../../library/os.rst:1036
#: ../../library/os.rst:1054 ../../library/os.rst:1065
#: ../../library/os.rst:1088 ../../library/os.rst:1109
#: ../../library/os.rst:1121 ../../library/os.rst:1132
#: ../../library/os.rst:1145 ../../library/os.rst:1166
#: ../../library/os.rst:1187 ../../library/os.rst:1199
#: ../../library/os.rst:1210 ../../library/os.rst:1271
#: ../../library/os.rst:1394 ../../library/os.rst:1406
#: ../../library/os.rst:1420 ../../library/os.rst:1430
#: ../../library/os.rst:1445 ../../library/os.rst:1460
#: ../../library/os.rst:1473 ../../library/os.rst:1490
#: ../../library/os.rst:1516 ../../library/os.rst:1533
#: ../../library/os.rst:1547 ../../library/os.rst:1562
#: ../../library/os.rst:1574 ../../library/os.rst:1601
#: ../../library/os.rst:1613 ../../library/os.rst:1623
#: ../../library/os.rst:1637 ../../library/os.rst:1716
#: ../../library/os.rst:1736 ../../library/os.rst:1745
#: ../../library/os.rst:1757 ../../library/os.rst:1811
#: ../../library/os.rst:1835 ../../library/os.rst:1845
#: ../../library/os.rst:1853 ../../library/os.rst:1862
#: ../../library/os.rst:1873 ../../library/os.rst:1910
#: ../../library/os.rst:1937 ../../library/os.rst:1988
#: ../../library/os.rst:1994 ../../library/os.rst:2160
#: ../../library/os.rst:2237 ../../library/os.rst:2254
#: ../../library/os.rst:2268 ../../library/os.rst:2294
#: ../../library/os.rst:2312 ../../library/os.rst:2328
#: ../../library/os.rst:2345 ../../library/os.rst:2408
#: ../../library/os.rst:2432 ../../library/os.rst:2452
#: ../../library/os.rst:2588 ../../library/os.rst:2610
#: ../../library/os.rst:2654 ../../library/os.rst:2666
#: ../../library/os.rst:2688 ../../library/os.rst:3396
#: ../../library/os.rst:3530 ../../library/os.rst:3553
#: ../../library/os.rst:3567 ../../library/os.rst:3787
#: ../../library/os.rst:3812 ../../library/os.rst:3837
#: ../../library/os.rst:3891 ../../library/os.rst:3900
#: ../../library/os.rst:3909 ../../library/os.rst:3917
#: ../../library/os.rst:3926 ../../library/os.rst:3935
#: ../../library/os.rst:4007 ../../library/os.rst:4070
#: ../../library/os.rst:4080 ../../library/os.rst:4098
#: ../../library/os.rst:4107 ../../library/os.rst:4117
#: ../../library/os.rst:4127 ../../library/os.rst:4137
#: ../../library/os.rst:4148 ../../library/os.rst:4293
#: ../../library/os.rst:4362 ../../library/os.rst:4397
#: ../../library/os.rst:4405 ../../library/os.rst:4412
#: ../../library/os.rst:4419 ../../library/os.rst:4426
#: ../../library/os.rst:4433 ../../library/os.rst:4440
#: ../../library/os.rst:4447 ../../library/os.rst:4455
#: ../../library/os.rst:4463 ../../library/os.rst:4470
#: ../../library/os.rst:4477 ../../library/os.rst:4486
#: ../../library/os.rst:4494 ../../library/os.rst:4502
#: ../../library/os.rst:4509 ../../library/os.rst:4516
#: ../../library/os.rst:4565 ../../library/os.rst:4592
#: ../../library/os.rst:4615 ../../library/os.rst:4631
#: ../../library/os.rst:4638 ../../library/os.rst:4649
#: ../../library/os.rst:4659 ../../library/os.rst:4668
#: ../../library/os.rst:4700 ../../library/os.rst:4812
#: ../../library/os.rst:4828 ../../library/os.rst:4861
#: ../../library/os.rst:4930 ../../library/os.rst:4953
#: ../../library/os.rst:4964 ../../library/os.rst:4976
#: ../../library/os.rst:5021 ../../library/os.rst:5058
#: ../../library/os.rst:5081 ../../library/os.rst:5102
#: ../../library/os.rst:5136 ../../library/os.rst:5177
#: ../../library/os.rst:5197 ../../library/os.rst:5211
#: ../../library/os.rst:5228 ../../library/os.rst:5243
#: ../../library/os.rst:5254 ../../library/os.rst:5266
#: ../../library/os.rst:5279 ../../library/os.rst:5288
#: ../../library/os.rst:5298 ../../library/os.rst:5311
#: ../../library/os.rst:5346 ../../library/os.rst:5362
#: ../../library/os.rst:5373 ../../library/os.rst:5385
#: ../../library/os.rst:5392 ../../library/os.rst:5401
#: ../../library/os.rst:5410 ../../library/os.rst:5419
#: ../../library/os.rst:5428 ../../library/os.rst:5592
#: ../../library/os.rst:5601 ../../library/os.rst:5625
#: ../../library/os.rst:5652 ../../library/os.rst:5661
#: ../../library/os.rst:5784
msgid "Availability"
msgstr "Availability"

#: ../../library/os.rst:186
msgid ""
"A :term:`mapping` object where keys and values are strings that represent "
"the process environment.  For example, ``environ['HOME']`` is the pathname "
"of your home directory (on some platforms), and is equivalent to "
"``getenv(\"HOME\")`` in C."
msgstr ""
"一个 :term:`mapping` 对象，其中键值是代表进程环境的字符串。 例如，``environ['HOME']`` "
"是你的主目录（在某些平台上）的路径名，相当于 C 中的 ``getenv(\"HOME\")``。"

#: ../../library/os.rst:191
msgid ""
"This mapping is captured the first time the :mod:`os` module is imported, "
"typically during Python startup as part of processing :file:`site.py`.  "
"Changes to the environment made after this time are not reflected in "
":data:`os.environ`, except for changes made by modifying :data:`os.environ` "
"directly."
msgstr ""
"这个映射是在第一次导入 :mod:`os` 模块时捕获的，通常作为 Python 启动时处理 :file:`site.py` 的一部分。除了通过直接修改"
" :data:`os.environ` 之外，在此之后对环境所做的更改不会反映在 :data:`os.environ` 中。"

#: ../../library/os.rst:196
msgid ""
"This mapping may be used to modify the environment as well as query the "
"environment.  :func:`putenv` will be called automatically when the mapping "
"is modified."
msgstr "该映射除了可以用于查询环境外，还能用于修改环境。当该映射被修改时，将自动调用 :func:`putenv`。"

#: ../../library/os.rst:200
msgid ""
"On Unix, keys and values use :func:`sys.getfilesystemencoding` and "
"``'surrogateescape'`` error handler. Use :data:`environb` if you would like "
"to use a different encoding."
msgstr ""
"在Unix系统上，键和值会使用 :func:`sys.getfilesystemencoding` 和 ``'surrogateescape'`` "
"的错误处理。如果你想使用其他的编码，使用 :data:`environb`。"

#: ../../library/os.rst:204
msgid ""
"On Windows, the keys are converted to uppercase. This also applies when "
"getting, setting, or deleting an item. For example, ``environ['monty'] = "
"'python'`` maps the key ``'MONTY'`` to the value ``'python'``."
msgstr ""
"在 Windows 上，这些键会被转换为大写形式。 这也会在获取、设备或删除条目时被应用。 例如，``environ['monty'] = "
"'python'`` 会将键 ``'MONTY'`` 映射到值 ``'python'``。"

#: ../../library/os.rst:211
msgid ""
"Calling :func:`putenv` directly does not change :data:`os.environ`, so it's "
"better to modify :data:`os.environ`."
msgstr ""
"直接调用 :func:`putenv` 并不会影响 :data:`os.environ` ，所以推荐直接修改 :data:`os.environ` 。"

#: ../../library/os.rst:216
msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks.  Refer to the system documentation for "
":c:func:`!putenv`."
msgstr ""
"在某些平台上，包括 FreeBSD 和 macOS 等，设置 ``environ`` 可能会导致内存泄漏。 请参阅有关 "
":c:func:`!putenv` 的系统文档。"

#: ../../library/os.rst:220
msgid ""
"You can delete items in this mapping to unset environment variables. "
":func:`unsetenv` will be called automatically when an item is deleted from "
":data:`os.environ`, and when one of the :meth:`pop` or :meth:`clear` methods"
" is called."
msgstr ""
"可以删除映射中的元素来删除对应的环境变量。当从 :data:`os.environ` 删除元素时，以及调用 :meth:`pop` 或 "
":meth:`clear` 之一时，将自动调用 :func:`unsetenv`。"

#: ../../library/os.rst:227
msgid "The :func:`os.reload_environ` function."
msgstr ":func:`os.reload_environ` 函数。"

#: ../../library/os.rst:229 ../../library/os.rst:245
msgid ""
"Updated to support :pep:`584`'s merge (``|``) and update (``|=``) operators."
msgstr "已更新并支持了 :pep:`584` 的合并 (``|``) 和更新 (``|=``) 运算符。"

#: ../../library/os.rst:235
msgid ""
"Bytes version of :data:`environ`: a :term:`mapping` object where both keys "
"and values are :class:`bytes` objects representing the process environment. "
":data:`environ` and :data:`environb` are synchronized (modifying "
":data:`environb` updates :data:`environ`, and vice versa)."
msgstr ""
":data:`environ` 的字节版本：一个 :term:`mapping` 对象，其中键值都是 :class:`bytes` 对象，代表进程环境。"
" :data:`environ` 和 :data:`environb` 是同步的（修改 :data:`environb` 会更新 "
":data:`environ`，反之亦然）。"

#: ../../library/os.rst:240
msgid ""
":data:`environb` is only available if :const:`supports_bytes_environ` is "
"``True``."
msgstr ":data:`environb` 仅在 :const:`supports_bytes_environ` 为 ``True`` 时可用。"

#: ../../library/os.rst:251
msgid ""
"The :data:`os.environ` and :data:`os.environb` mappings are a cache of "
"environment variables at the time that Python started. As such, changes to "
"the current process environment are not reflected if made outside Python, or"
" by :func:`os.putenv` or :func:`os.unsetenv`. Use :func:`!os.reload_environ`"
" to update :data:`os.environ` and :data:`os.environb` with any such changes "
"to the current process environment."
msgstr ""

#: ../../library/os.rst:259
msgid ""
"This function is not thread-safe. Calling it while the environment is being "
"modified in an other thread is an undefined behavior. Reading from "
":data:`os.environ` or :data:`os.environb`, or calling :func:`os.getenv` "
"while reloading, may return an empty result."
msgstr ""

#: ../../library/os.rst:272
msgid "These functions are described in :ref:`os-file-dir`."
msgstr "以上函数请参阅 :ref:`os-file-dir` 。"

#: ../../library/os.rst:277
msgid ""
"Encode :term:`path-like <path-like object>` *filename* to the "
":term:`filesystem encoding and error handler`; return :class:`bytes` "
"unchanged."
msgstr ""
"将 :term:`类似路径形式的 <path-like object>` *filename* 编码为 :term:`filesystem "
"encoding and error handler`；原样返回 :class:`bytes`。"

#: ../../library/os.rst:281
msgid ":func:`fsdecode` is the reverse function."
msgstr ":func:`fsdecode` 是此函数的逆向函数。"

#: ../../library/os.rst:285 ../../library/os.rst:300
msgid ""
"Support added to accept objects implementing the :class:`os.PathLike` "
"interface."
msgstr "增加对实现了 :class:`os.PathLike` 接口的对象的支持。"

#: ../../library/os.rst:292
msgid ""
"Decode the :term:`path-like <path-like object>` *filename* from the "
":term:`filesystem encoding and error handler`; return :class:`str` "
"unchanged."
msgstr ""
"根据 :term:`filesystem encoding and error handler` 来解码 :term:`类似路径形式的 <path-"
"like object>` *filename*；原样返回 :class:`str`。"

#: ../../library/os.rst:296
msgid ":func:`fsencode` is the reverse function."
msgstr ":func:`fsencode` 是此函数的逆向函数。"

#: ../../library/os.rst:307
msgid "Return the file system representation of the path."
msgstr "返回路径的文件系统表示。"

#: ../../library/os.rst:309
msgid ""
"If :class:`str` or :class:`bytes` is passed in, it is returned unchanged. "
"Otherwise :meth:`~os.PathLike.__fspath__` is called and its value is "
"returned as long as it is a :class:`str` or :class:`bytes` object. In all "
"other cases, :exc:`TypeError` is raised."
msgstr ""
"如果传入的是 :class:`str` 或 :class:`bytes` 类型的字符串，将原样返回。否则 "
":meth:`~os.PathLike.__fspath__` 将被调用，如果得到的是一个 :class:`str` 或 :class:`bytes` "
"类型的对象，那就返回这个值。其他所有情况则会抛出 :exc:`TypeError`  异常。"

#: ../../library/os.rst:319
msgid ""
"An :term:`abstract base class` for objects representing a file system path, "
"e.g. :class:`pathlib.PurePath`."
msgstr ""
"某些对象用于表示文件系统中的路径（如 :class:`pathlib.PurePath` 对象），本类是这些对象的 :term:`抽象基类 "
"<abstract base class>`。"

#: ../../library/os.rst:327
msgid "Return the file system path representation of the object."
msgstr "返回当前对象的文件系统表示。"

#: ../../library/os.rst:329
msgid ""
"The method should only return a :class:`str` or :class:`bytes` object, with "
"the preference being for :class:`str`."
msgstr ""
"这个方法只应该返回一个 :class:`str` 字符串或 :class:`bytes` 字节串，请优先选择 :class:`str` 字符串。"

#: ../../library/os.rst:335
msgid ""
"Return the value of the environment variable *key* as a string if it exists,"
" or *default* if it doesn't. *key* is a string. Note that since "
":func:`getenv` uses :data:`os.environ`, the mapping of :func:`getenv` is "
"similarly also captured on import, and the function may not reflect future "
"environment changes."
msgstr ""
"如果环境变量 *key* 存在则将其值作为字符串返回，如果不存在则返回 *default*。 *key* 是一个字符串。 请注意由于 "
":func:`getenv` 使用了 :data:`os.environ`，因此 :func:`getenv` "
"的映射同样也会在导入时被捕获，并且该函数可能无法反映未来的环境变化。"

#: ../../library/os.rst:341
msgid ""
"On Unix, keys and values are decoded with :func:`sys.getfilesystemencoding` "
"and ``'surrogateescape'`` error handler. Use :func:`os.getenvb` if you would"
" like to use a different encoding."
msgstr ""
"在Unix系统上，键和值会使用 :func:`sys.getfilesystemencoding` 和 ``'surrogateescape'`` "
"错误处理进行解码。如果你想使用其他的编码，使用 :func:`os.getenvb`。"

#: ../../library/os.rst:350
msgid ""
"Return the value of the environment variable *key* as bytes if it exists, or"
" *default* if it doesn't. *key* must be bytes. Note that since "
":func:`getenvb` uses :data:`os.environb`, the mapping of :func:`getenvb` is "
"similarly also captured on import, and the function may not reflect future "
"environment changes."
msgstr ""
"如果环境变量 *key* 存在则将其值作为字节串返回，如果不存在则返回 *default*。 *key* 必须为字节串。 请注意由于 "
":func:`getenvb` 使用了 :data:`os.environb`，因此 :func:`getenvb` "
"的映射同样也会在导入时被捕获，并且该函数可能无法反映未来的环境变化。"

#: ../../library/os.rst:357
msgid ""
":func:`getenvb` is only available if :const:`supports_bytes_environ` is "
"``True``."
msgstr ":func:`getenvb` 仅在 :const:`supports_bytes_environ` 为 ``True`` 时可用。"

#: ../../library/os.rst:367
msgid ""
"Returns the list of directories that will be searched for a named "
"executable, similar to a shell, when launching a process. *env*, when "
"specified, should be an environment variable dictionary to lookup the PATH "
"in. By default, when *env* is ``None``, :data:`environ` is used."
msgstr ""
"返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。指定的 *env* 应为用于搜索 PATH 的环境变量字典。默认情况下，当 "
"*env* 为 ``None`` 时，将会使用 :data:`environ` 。"

#: ../../library/os.rst:378
msgid ""
"Return the effective group id of the current process.  This corresponds to "
"the \"set id\" bit on the file being executed in the current process."
msgstr "返回当前进程的有效组ID。对应当前进程执行文件的 \"set id\" 位。"

#: ../../library/os.rst:388
msgid "Return the current process's effective user id."
msgstr "返回当前进程的有效用户ID。"

#: ../../library/os.rst:397
msgid "Return the real group id of the current process."
msgstr "返回当前进程的实际组ID。"

#: ../../library/os.rst:401 ../../library/os.rst:474 ../../library/os.rst:558
#: ../../library/os.rst:783
msgid ""
"The function is a stub on WASI, see :ref:`wasm-availability` for more "
"information."
msgstr "该函数在 WASI 上为空代码段，请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/os.rst:407
msgid ""
"Return list of group ids that *user* belongs to. If *group* is not in the "
"list, it is included; typically, *group* is specified as the group ID field "
"from the password record for *user*, because that group ID will otherwise be"
" potentially omitted."
msgstr ""
"返回 *user* 所属的组 ID 列表。 如果 *group* 不在该列表中，它将被包括在内；通常，*group* 将会被指定为来自 *user* "
"的密码记录文件的组 ID 字段，因为在其他情况下该组 ID 有可能会被略去。"

#: ../../library/os.rst:419
msgid ""
"Return list of supplemental group ids associated with the current process."
msgstr "返回当前进程关联的附加组ID列表"

#: ../../library/os.rst:425
msgid ""
"On macOS, :func:`getgroups` behavior differs somewhat from other Unix "
"platforms. If the Python interpreter was built with a deployment target of "
"``10.5`` or earlier, :func:`getgroups` returns the list of effective group "
"ids associated with the current user process; this list is limited to a "
"system-defined number of entries, typically 16, and may be modified by calls"
" to :func:`setgroups` if suitably privileged. If built with a deployment "
"target greater than ``10.5``, :func:`getgroups` returns the current group "
"access list for the user associated with the effective user id of the "
"process; the group access list may change over the lifetime of the process, "
"it is not affected by calls to :func:`setgroups`, and its length is not "
"limited to 16.  The deployment target value, "
":const:`MACOSX_DEPLOYMENT_TARGET`, can be obtained with "
":func:`sysconfig.get_config_var`."
msgstr ""
"在 macOS 上，:func:`getgroups` 的行为与其他 Unix 平台有所不同。 如果 Python 解释器是以 ``10.5`` "
"或更早版本作为部署目标的，则 :func:`getgroups` 会返回与当前用户进程相关联的有效组 ID "
"列表；该列表受限于系统预定义的条目数量，通常为 16，并且在适当的权限下还可通过调用 :func:`setgroups` 来修改。 "
"如果所用的部署目标版本大于 ``10.5``，则 :func:`getgroups` 会返回与进程的有效用户 ID "
"相关联的当前组访问列表；组访问列表可能会在进程的生命周期之内发生改变，它不会受对 :func:`setgroups` 的调用影响，且其长度也不会被限制为"
" 16。 部署目标值 :const:`MACOSX_DEPLOYMENT_TARGET` 可以通过 "
":func:`sysconfig.get_config_var` 来获取。"

#: ../../library/os.rst:442
msgid ""
"Return the name of the user logged in on the controlling terminal of the "
"process.  For most purposes, it is more useful to use "
":func:`getpass.getuser` since the latter checks the environment variables "
":envvar:`LOGNAME` or :envvar:`USERNAME` to find out who the user is, and "
"falls back to ``pwd.getpwuid(os.getuid())[0]`` to get the login name of the "
"current real user id."
msgstr ""
"返回通过控制终端进程进行登录的用户名。在多数情况下，使用 :func:`getpass.getuser` 会更有效，因为后者会通过检查环境变量 "
":envvar:`LOGNAME` 或 :envvar:`USERNAME` 来查找用户，再由 "
"``pwd.getpwuid(os.getuid())[0]`` 来获取当前用户 ID 的登录名。"

#: ../../library/os.rst:454
msgid ""
"Return the process group id of the process with process id *pid*. If *pid* "
"is 0, the process group id of the current process is returned."
msgstr "根据进程id *pid* 返回进程的组 ID 列表。如果 *pid* 为 0，则返回当前进程的进程组 ID 列表"

#: ../../library/os.rst:463
msgid "Return the id of the current process group."
msgstr "返回当时进程组的ID"

#: ../../library/os.rst:472
msgid "Return the current process id."
msgstr "返回当前进程ID"

#: ../../library/os.rst:481
msgid ""
"Return the parent's process id.  When the parent process has exited, on Unix"
" the id returned is the one of the init process (1), on Windows it is still "
"the same id, which may be already reused by another process."
msgstr ""
"返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占用。"

#: ../../library/os.rst:487
msgid "Added support for Windows."
msgstr "添加WIndows的支持。"

#: ../../library/os.rst:495
msgid ""
"Get program scheduling priority.  The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and *who* "
"is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, and "
"a user ID for :const:`PRIO_USER`).  A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process."
msgstr ""
"获取程序调度优先级。*which* 参数值可以是 :const:`PRIO_PROCESS`，:const:`PRIO_PGRP`，或 "
":const:`PRIO_USER` 中的一个，*who* 是相对于 *which* (:const:`PRIO_PROCESS` "
"的进程标识符，:const:`PRIO_PGRP` 的进程组标识符和 :const:`PRIO_USER` 的用户ID)。当 *who* 为 0 "
"时（分别）表示调用的进程，调用进程的进程组或调用进程所属的真实用户 ID。"

#: ../../library/os.rst:512 ../../library/os.rst:524
msgid ""
"Parameters for the :func:`getpriority` and :func:`setpriority` functions."
msgstr "函数 :func:`getpriority` 和 :func:`setpriority` 的参数。"

#: ../../library/os.rst:532
msgid ""
"Return a tuple (ruid, euid, suid) denoting the current process's real, "
"effective, and saved user ids."
msgstr "返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和暂存用户ID。"

#: ../../library/os.rst:542
msgid ""
"Return a tuple (rgid, egid, sgid) denoting the current process's real, "
"effective, and saved group ids."
msgstr "返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。"

#: ../../library/os.rst:554
msgid "Return the current process's real user id."
msgstr "返回当前进程的真实用户ID。"

#: ../../library/os.rst:564
msgid ""
"Call the system initgroups() to initialize the group access list with all of"
" the groups of which the specified username is a member, plus the specified "
"group id."
msgstr "调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID。"

#: ../../library/os.rst:577
msgid ""
"Set the environment variable named *key* to the string *value*.  Such "
"changes to the environment affect subprocesses started with "
":func:`os.system`, :func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"将名为 *key* 的环境变量值设置为 *value*。该变量名修改会影响由 :func:`os.system`， :func:`popen` "
"，:func:`fork` 和 :func:`execv` 发起的子进程。"

#: ../../library/os.rst:581
msgid ""
"Assignments to items in :data:`os.environ` are automatically translated into"
" corresponding calls to :func:`putenv`; however, calls to :func:`putenv` "
"don't update :data:`os.environ`, so it is actually preferable to assign to "
"items of :data:`os.environ`. This also applies to :func:`getenv` and "
":func:`getenvb`, which respectively use :data:`os.environ` and "
":data:`os.environb` in their implementations."
msgstr ""
"对 :data:`os.environ` 中的项目的赋值会自动转化为对 :func:`putenv` 的相应调用；然而，对 :func:`putenv`"
" 的调用并不更新 :data:`os.environ` ，所以实际上最好是赋值到 :data:`os.environ` 的项目。这也适用于 "
":func:`getenv` 和 :func:`getenvb` ，它们分别使用 :data:`os.environ` 和 "
":data:`os.environb` 在它们的实现中。"

#: ../../library/os.rst:587 ../../library/os.rst:837
msgid "See also the :func:`os.reload_environ` function."
msgstr ""

#: ../../library/os.rst:591
msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks. Refer to the system documentation for :c:func:`!putenv`."
msgstr ""
"在某些平台上，包括 FreeBSD 和 macOS 等，设置 ``environ`` 可能会导致内存泄漏。 请参阅有关 "
":c:func:`!putenv` 的系统文档。"

#: ../../library/os.rst:594
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.putenv`` with arguments "
"``key``, ``value``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.putenv`` 并附带参数 ``key``, ``value``。"

#: ../../library/os.rst:596
msgid "The function is now always available."
msgstr "该函数现在总是可用。"

#: ../../library/os.rst:602
msgid "Set the current process's effective group id."
msgstr "设置当前进程的有效组ID。"

#: ../../library/os.rst:609
msgid "Set the current process's effective user id."
msgstr "设置当前进程的有效用户ID。"

#: ../../library/os.rst:616
msgid "Set the current process' group id."
msgstr "设置当前进程的组ID。"

#: ../../library/os.rst:623
msgid ""
"Set the list of supplemental group ids associated with the current process "
"to *groups*. *groups* must be a sequence, and each element must be an "
"integer identifying a group. This operation is typically available only to "
"the superuser."
msgstr ""
"将 *group* 参数值设置为与当进程相关联的附加组ID列表。*group* "
"参数必须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用户。"

#: ../../library/os.rst:629
msgid ""
"On macOS, the length of *groups* may not exceed the system-defined maximum "
"number of effective group ids, typically 16. See the documentation for "
":func:`getgroups` for cases where it may not return the same group list set "
"by calling setgroups()."
msgstr ""
"在 macOS 中，*groups* 的长度不能超过系统定义的最大有效组 ID 数量，通常为 16。 对于未返回与调用 setgroups() "
"产生的相同组列表的情况，请参阅 :func:`getgroups` 的文档。"

#: ../../library/os.rst:636
msgid ""
"Reassociate the current thread with a Linux namespace. See the "
":manpage:`setns(2)` and :manpage:`namespaces(7)` man pages for more details."
msgstr ""
"将当前线程与 Linux 命名空间重新关联。 详情参见 :manpage:`setns(2)` 和 :manpage:`namespaces(7)` "
"手册页面。"

#: ../../library/os.rst:640
msgid ""
"If *fd* refers to a :file:`/proc/{pid}/ns/` link, ``setns()`` reassociates "
"the calling thread with the namespace associated with that link, and "
"*nstype* may be set to one of the :ref:`CLONE_NEW* constants <os-unshare-"
"clone-flags>` to impose constraints on the operation (``0`` means no "
"constraints)."
msgstr ""
"如果 *fd* 是指向一个 :file:`/proc/{pid}/ns/` 链接，``setns()`` "
"会将调用线程与该链接所关联的命名空间重新关联起来，并且 *nstype* 可以设为某个 :ref:`CLONE_NEW* 常量 <os-unshare-"
"clone-flags>` 以便对操作施加约束 (``0`` 表示没有任何约束)。"

#: ../../library/os.rst:647
msgid ""
"Since Linux 5.8, *fd* may refer to a PID file descriptor obtained from "
":func:`~os.pidfd_open`. In this case, ``setns()`` reassociates the calling "
"thread into one or more of the same namespaces as the thread referred to by "
"*fd*. This is subject to any constraints imposed by *nstype*, which is a bit"
" mask combining one or more of the :ref:`CLONE_NEW* constants <os-unshare-"
"clone-flags>`, e.g. ``setns(fd, os.CLONE_NEWUTS | os.CLONE_NEWPID)``. The "
"caller's memberships in unspecified namespaces are left unchanged."
msgstr ""
"自 Linux 5.8 起，*fd* 可以是通过 :func:`~os.pidfd_open` 获取的 PID "
"文件描述符。在这种情况下，``setns()`` 会将调用线程重新关联到与 *fd* 引用的线程相同的一个或多个命名空间。位掩码 *nstype* "
"通常会结合一个或多个 :ref:`CLONE_NEW* 常量 <os-unshare-clone-flags>` ，例如 ``setns(fd, "
"os.CLONE_NEWUTS | os.CLONE_NEWPID)``，其施加的任何约束限制仍然保留，调用者在未指定的命名空间中的成员资格保持不变。"

#: ../../library/os.rst:656
msgid ""
"*fd* can be any object with a :meth:`~io.IOBase.fileno` method, or a raw "
"file descriptor."
msgstr "*fd* 可以是任何带有 :meth:`~io.IOBase.fileno` 方法的对象，或是一个原始文件描述符。"

#: ../../library/os.rst:658
msgid ""
"This example reassociates the thread with the ``init`` process's network "
"namespace::"
msgstr "此示例将线程与 ``init`` 进程的网络命名空间进行了重新关联::"

#: ../../library/os.rst:660
msgid ""
"fd = os.open(\"/proc/1/ns/net\", os.O_RDONLY)\n"
"os.setns(fd, os.CLONE_NEWNET)\n"
"os.close(fd)"
msgstr ""
"fd = os.open(\"/proc/1/ns/net\", os.O_RDONLY)\n"
"os.setns(fd, os.CLONE_NEWNET)\n"
"os.close(fd)"

#: ../../library/os.rst:670
msgid "The :func:`~os.unshare` function."
msgstr ":func:`~os.unshare` 函数。"

#: ../../library/os.rst:674
msgid ""
"Call the system call :c:func:`!setpgrp` or ``setpgrp(0, 0)`` depending on "
"which version is implemented (if any).  See the Unix manual for the "
"semantics."
msgstr ""
"在系统调用 :c:func:`!setpgrp` 和 ``setpgrp(0, 0)`` "
"中择一调用，具体取决于何种实现版本可用（如果任一实现存在的话）。请参阅 Unix 手册以了解语义。"

#: ../../library/os.rst:682
msgid ""
"Call the system call :c:func:`!setpgid` to set the process group id of the "
"process with id *pid* to the process group with id *pgrp*.  See the Unix "
"manual for the semantics."
msgstr ""
"使用系统调用 :c:func:`!setpgid` 将 *pid* 对应进程的组 ID 设置为 *pgrp*。请参阅 Unix 手册以了解语义。"

#: ../../library/os.rst:693
msgid ""
"Set program scheduling priority. The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and *who* "
"is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, and "
"a user ID for :const:`PRIO_USER`). A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process. *priority* is a value "
"in the range -20 to 19. The default priority is 0; lower priorities cause "
"more favorable scheduling."
msgstr ""
"设置程序调度优先级。 *which* 的值为 :const:`PRIO_PROCESS`, :const:`PRIO_PGRP` 或 "
":const:`PRIO_USER` 之一，而 *who* 会相对于 *which* (:const:`PRIO_PROCESS` 的进程标识符, "
":const:`PRIO_PGRP` 的进程组标识符和 :const:`PRIO_USER` 的用户 ID) 被解析。 *who* 值为零 (分别) "
"表示调用进程，调用进程的进程组或调用进程的真实用户 ID。 *priority* 是范围在 -20 至 19 的值。 默认优先级为 "
"0；较小的优先级数值会更优先被调度。"

#: ../../library/os.rst:710
msgid "Set the current process's real and effective group ids."
msgstr "设置当前进程的真实和有效组ID。"

#: ../../library/os.rst:717
msgid "Set the current process's real, effective, and saved group ids."
msgstr "设置当前进程的真实，有效和暂存组ID。"

#: ../../library/os.rst:726
msgid "Set the current process's real, effective, and saved user ids."
msgstr "设置当前进程的真实，有效和暂存用户ID。"

#: ../../library/os.rst:735
msgid "Set the current process's real and effective user ids."
msgstr "设置当前进程的真实和有效用户ID。"

#: ../../library/os.rst:742
msgid ""
"Call the system call :c:func:`!getsid`.  See the Unix manual for the "
"semantics."
msgstr "调用系统调用 :c:func:`!getsid`。 其语义请参见 Unix 手册。"

#: ../../library/os.rst:749
msgid ""
"Call the system call :c:func:`!setsid`.  See the Unix manual for the "
"semantics."
msgstr "调用系统调用 :c:func:`!setsid`。 其语义请参见 Unix 手册。"

#: ../../library/os.rst:758
msgid "Set the current process's user id."
msgstr "设置当前进程的用户ID。"

#: ../../library/os.rst:766
msgid ""
"Return the error message corresponding to the error code in *code*. On "
"platforms where :c:func:`!strerror` returns ``NULL`` when given an unknown "
"error number, :exc:`ValueError` is raised."
msgstr ""
"根据 *code* 中的错误码返回错误消息。如果 :c:func:`!strerror` 返回 ``NULL`` ，说明给出的是未知错误码，则会引发 "
":exc:`ValueError`。"

#: ../../library/os.rst:773
msgid ""
"``True`` if the native OS type of the environment is bytes (eg. ``False`` on"
" Windows)."
msgstr "如果操作系统上原生环境类型是字节型则为 ``True`` (例如在 Windows 上为 ``False``)。"

#: ../../library/os.rst:781
msgid "Set the current numeric umask and return the previous umask."
msgstr "设定当前数值掩码并返回之前的掩码。"

#: ../../library/os.rst:793
msgid ""
"Returns information identifying the current operating system. The return "
"value is an object with five attributes:"
msgstr "返回当前操作系统的识别信息。返回值是一个有5个属性的对象："

#: ../../library/os.rst:796
msgid ":attr:`sysname` - operating system name"
msgstr ":attr:`sysname` - 操作系统名"

#: ../../library/os.rst:797
msgid ":attr:`nodename` - name of machine on network (implementation-defined)"
msgstr ":attr:`nodename` - 机器在网络上的名称（需要先设定）"

#: ../../library/os.rst:798
msgid ":attr:`release` - operating system release"
msgstr ":attr:`release` - 操作系统发行信息"

#: ../../library/os.rst:799
msgid ":attr:`version` - operating system version"
msgstr ":attr:`version` - 操作系统版本信息"

#: ../../library/os.rst:800
msgid ":attr:`machine` - hardware identifier"
msgstr ":attr:`machine` - 硬件标识符"

#: ../../library/os.rst:802
msgid ""
"For backwards compatibility, this object is also iterable, behaving like a "
"five-tuple containing :attr:`sysname`, :attr:`nodename`, :attr:`release`, "
":attr:`version`, and :attr:`machine` in that order."
msgstr ""
"为了向后兼容，该对象也是可迭代的，像是一个按照 "
":attr:`sysname`，:attr:`nodename`，:attr:`release`，:attr:`version`，和 "
":attr:`machine` 顺序组成的元组。"

#: ../../library/os.rst:807
msgid ""
"Some systems truncate :attr:`nodename` to 8 characters or to the leading "
"component; a better way to get the hostname is :func:`socket.gethostname`  "
"or even ``socket.gethostbyaddr(socket.gethostname())``."
msgstr ""
"有些系统会将 :attr:`nodename` 截短为 8 个字符或截短至前缀部分；获取主机名的一个更好方式是 "
":func:`socket.gethostname`  或甚至可以用 "
"``socket.gethostbyaddr(socket.gethostname())``。"

#: ../../library/os.rst:812
msgid ""
"On macOS, iOS and Android, this returns the *kernel* name and version (i.e.,"
" ``'Darwin'`` on macOS and iOS; ``'Linux'`` on Android). "
":func:`platform.uname` can be used to get the user-facing operating system "
"name and version on iOS and Android."
msgstr ""
"在 macOS, iOS 和 Android 上，这将返回 *内核* 名称和版本 (即在 macOS 和 iOS 上为 ``'Darwin'``; 在 "
"Android 上为 ``'Linux'``)。 :func:`platform.uname` 可被用来在 iOS 和 Android "
"上获取面向用户的操作系统名称和版本。"

#: ../../library/os.rst:819 ../../library/os.rst:5083
msgid ""
"Return type changed from a tuple to a tuple-like object with named "
"attributes."
msgstr "返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。"

#: ../../library/os.rst:828
msgid ""
"Unset (delete) the environment variable named *key*. Such changes to the "
"environment affect subprocesses started with :func:`os.system`, "
":func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"取消设置（删除）名为 *key* 的环境变量。变量名的改变会影响由 "
":func:`os.system`，:func:`popen`，:func:`fork` 和 :func:`execv` 触发的子进程。"

#: ../../library/os.rst:832
msgid ""
"Deletion of items in :data:`os.environ` is automatically translated into a "
"corresponding call to :func:`unsetenv`; however, calls to :func:`unsetenv` "
"don't update :data:`os.environ`, so it is actually preferable to delete "
"items of :data:`os.environ`."
msgstr ""
"删除 :data:`os.environ` 中的项目会自动转化为对 :func:`unsetenv` 的相应调用；然而，对 "
":func:`unsetenv` 的调用并不更新 :data:`os.environ` ，所以实际上最好是删除 :data:`os.environ` "
"的项目。"

#: ../../library/os.rst:839
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.unsetenv`` with argument "
"``key``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.unsetenv`` 并附带参数 ``key``。"

#: ../../library/os.rst:841
msgid "The function is now always available and is also available on Windows."
msgstr "该函数现在总是可用，并且在 Windows 上也可用。"

#: ../../library/os.rst:847
msgid ""
"Disassociate parts of the process execution context, and move them into a "
"newly created namespace. See the :manpage:`unshare(2)` man page for more "
"details. The *flags* argument is a bit mask, combining zero or more of the "
":ref:`CLONE_* constants <os-unshare-clone-flags>`, that specifies which "
"parts of the execution context should be unshared from their existing "
"associations and moved to a new namespace. If the *flags* argument is ``0``,"
" no changes are made to the calling process's execution context."
msgstr ""
"拆分进程执行上下文的部分内容，并将其移入新创建的命名空间中。 请参阅 :manpage:`unshare(2)` 手册页了解详情。 *flags* "
"参数是一个位掩码，它组合了零个或多个 :ref:`CLONE_* 常量 <os-unshare-clone-"
"flags>`，用于指定执行上下文中的哪些部分应从现有关联中解除共享并移动到新的命名空间。 如果 *flags* 参数为 "
"``0``，则不会对调用方进程的执行上下文进行任何更改。"

#: ../../library/os.rst:864
msgid "The :func:`~os.setns` function."
msgstr ":func:`~os.setns` 函数。"

#: ../../library/os.rst:868
msgid ""
"Flags to the :func:`unshare` function, if the implementation supports them. "
"See :manpage:`unshare(2)` in the Linux manual for their exact effect and "
"availability."
msgstr ""
":func:`unshare` 函数的旗标，如果实现支持。 访问 Linux 手册中的 :manpage:`unshare(2)` "
"以获取关于实际影响和可用性的信息。"

#: ../../library/os.rst:891
msgid "File Object Creation"
msgstr "创建文件对象"

#: ../../library/os.rst:893
msgid ""
"These functions create new :term:`file objects <file object>`.  (See also "
":func:`~os.open` for opening file descriptors.)"
msgstr ""
"这些函数创建新的 :term:`file objects <file object>` 。（参见 :func:`~os.open` "
"以获取打开文件描述符的相关信息。）"

#: ../../library/os.rst:899
msgid ""
"Return an open file object connected to the file descriptor *fd*.  This is "
"an alias of the :func:`open` built-in function and accepts the same "
"arguments. The only difference is that the first argument of :func:`fdopen` "
"must always be an integer."
msgstr ""
"返回打开文件描述符 *fd* 对应文件的对象。类似内建 :func:`open` 函数，二者接受同样的参数。不同之处在于 :func:`fdopen` "
"第一个参数应该为整数。"

#: ../../library/os.rst:908
msgid "File Descriptor Operations"
msgstr "文件描述符操作"

#: ../../library/os.rst:910
msgid ""
"These functions operate on I/O streams referenced using file descriptors."
msgstr "这些函数对文件描述符所引用的 I/O 流进行操作。"

#: ../../library/os.rst:912
msgid ""
"File descriptors are small integers corresponding to a file that has been "
"opened by the current process.  For example, standard input is usually file "
"descriptor 0, standard output is 1, and standard error is 2.  Further files "
"opened by a process will then be assigned 3, 4, 5, and so forth.  The name "
"\"file descriptor\" is slightly deceptive; on Unix platforms, sockets and "
"pipes are also referenced by file descriptors."
msgstr ""
"文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在"
" Unix 平台中套接字和管道也被文件描述符所引用。"

#: ../../library/os.rst:919
msgid ""
"The :meth:`~io.IOBase.fileno` method can be used to obtain the file "
"descriptor associated with a :term:`file object` when required.  Note that "
"using the file descriptor directly will bypass the file object methods, "
"ignoring aspects such as internal buffering of data."
msgstr ""
"当需要时，可以用 :meth:`~io.IOBase.fileno` 可以获得 :term:`file object` "
"所对应的文件描述符。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内部缓冲等情况。"

#: ../../library/os.rst:927
msgid "Close file descriptor *fd*."
msgstr "关闭文件描述符 *fd*。"

#: ../../library/os.rst:931
msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To close a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, use its :meth:`~io.IOBase.close` method."
msgstr ""
"该功能适用于低级 I/O 操作，必须用于 :func:`os.open` 或 :func:`pipe` 返回的文件描述符。若要关闭由内建函数 "
":func:`open`、:func:`popen` 或 :func:`fdopen` 返回的 \"文件对象\"，则应使用其相应的 "
":meth:`~io.IOBase.close` 方法。"

#: ../../library/os.rst:939
msgid ""
"Close all file descriptors from *fd_low* (inclusive) to *fd_high* "
"(exclusive), ignoring errors. Equivalent to (but much faster than)::"
msgstr "关闭从 *fd_low* （包括）到 *fd_high* （排除）间的文件描述符，并忽略错误。类似（但快于）::"

#: ../../library/os.rst:942
msgid ""
"for fd in range(fd_low, fd_high):\n"
"    try:\n"
"        os.close(fd)\n"
"    except OSError:\n"
"        pass"
msgstr ""
"for fd in range(fd_low, fd_high):\n"
"    try:\n"
"        os.close(fd)\n"
"    except OSError:\n"
"        pass"

#: ../../library/os.rst:951
msgid ""
"Copy *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset *offset_dst*. "
"If *offset_src* is ``None``, then *src* is read from the current position; "
"respectively for *offset_dst*."
msgstr ""
"从文件描述符 *src* 自偏移量 *offset_src* 起的位置拷贝 *count* 个字节到文件描述符 *dst* 自偏移量 "
"*offset_dst* 起的位置。 如果 *offset_src* 为 ``None``，则从当前位置读取 *src*；相应地 "
"*offset_dst* 也是如此。"

#: ../../library/os.rst:956
msgid ""
"In Linux kernel older than 5.3, the files pointed to by *src* and *dst* must"
" reside in the same filesystem, otherwise an :exc:`OSError` is raised with "
":attr:`~OSError.errno` set to :const:`errno.EXDEV`."
msgstr ""
"在早于 5.3 版的 Linux 内核中，*src* 和 *dst* 指向的文件必须位于相同的文件系统中，否则会引发 :exc:`OSError` 并将"
" :attr:`~OSError.errno` 设为 :const:`errno.EXDEV`。"

#: ../../library/os.rst:960
msgid ""
"This copy is done without the additional cost of transferring data from the "
"kernel to user space and then back into the kernel. Additionally, some "
"filesystems could implement extra optimizations, such as the use of reflinks"
" (i.e., two or more inodes that share pointers to the same copy-on-write "
"disk blocks; supported file systems include btrfs and XFS) and server-side "
"copy (in the case of NFS)."
msgstr ""
"执行这种拷贝无需付出将数据从内核传输到用户空间再返回内核的额外耗费。 "
"此外，某些文件系统还可以实现进一步的优化，例如使用引用链接（即两个或多个共享指向相同写入时复制磁盘块的指针的 inode；支持的文件系统包括 btrfs"
" 和 XFS）和服务器端拷贝（对于 NFS）。"

#: ../../library/os.rst:967
msgid ""
"The function copies bytes between two file descriptors. Text options, like "
"the encoding and the line ending, are ignored."
msgstr "此函数在两个文件描述符之间拷贝字节数据。 文本选项，如编码格式和行结束符等将被忽略。"

#: ../../library/os.rst:970
msgid ""
"The return value is the amount of bytes copied. This could be less than the "
"amount requested."
msgstr "返回值是复制的字节的数目。这可能低于需求的数目。"

#: ../../library/os.rst:975
msgid ""
"On Linux, :func:`os.copy_file_range` should not be used for copying a range "
"of a pseudo file from a special filesystem like procfs and sysfs. It will "
"always copy no bytes and return 0 as if the file was empty because of a "
"known Linux kernel issue."
msgstr ""
"在 Linux 上，:func:`os.copy_file_range` 不应被用于从特殊的文件系统如 procfs 和 sysfs "
"复制特定范围的伪文件。 因为已知的 Linux 内核问题它将总是不复制任何字节并返回 0 就像文件是空的一样。"

#: ../../library/os.rst:987
msgid ""
"Return a string describing the encoding of the device associated with *fd* "
"if it is connected to a terminal; else return :const:`None`."
msgstr "如果连接到终端，则返回一个与 *fd* 关联的设备描述字符，否则返回 :const:`None`。"

#: ../../library/os.rst:990
msgid ""
"On Unix, if the :ref:`Python UTF-8 Mode <utf8-mode>` is enabled, return "
"``'UTF-8'`` rather than the device encoding."
msgstr ""
"在 Unix 上，如果启用了 :ref:`Python UTF-8 模式 <utf8-mode>`，则返回 ``'UTF-8'`` "
"而不是设备的编码格式。"

#: ../../library/os.rst:993
msgid "On Unix, the function now implements the Python UTF-8 Mode."
msgstr "在 Unix 上，该函数现在实现了 Python UTF-8 模式。"

#: ../../library/os.rst:999
msgid ""
"Return a duplicate of file descriptor *fd*. The new file descriptor is "
":ref:`non-inheritable <fd_inheritance>`."
msgstr "返回一个文件描述符 *fd* 的副本。该文件描述符的副本是 :ref:`不可继承的<fd_inheritance>`。"

#: ../../library/os.rst:1002
msgid ""
"On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: "
"stderr), the new file descriptor is :ref:`inheritable <fd_inheritance>`."
msgstr ""
"在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时，新的文件描述符是 "
":ref:`可继承的<fd_inheritance>`。"

#: ../../library/os.rst:1008 ../../library/os.rst:1293
msgid "The new file descriptor is now non-inheritable."
msgstr "新的文件描述符现在是不可继承的。"

#: ../../library/os.rst:1014
msgid ""
"Duplicate file descriptor *fd* to *fd2*, closing the latter first if "
"necessary. Return *fd2*. The new file descriptor is :ref:`inheritable "
"<fd_inheritance>` by default or non-inheritable if *inheritable* is "
"``False``."
msgstr ""
"把文件描述符 *fd* 复制为 *fd2*，必要时先关闭后者。返回 *fd2*。新的文件描述符默认是 "
":ref:`可继承的<fd_inheritance>`，除非在 *inheritable* 为 ``False`` 时，是不可继承的。"

#: ../../library/os.rst:1021
msgid "Add the optional *inheritable* parameter."
msgstr "添加可选参数 *inheritable*。"

#: ../../library/os.rst:1024
msgid "Return *fd2* on success. Previously, ``None`` was always returned."
msgstr "成功时返回 *fd2*，以过去的版本中，总是返回 ``None``。"

#: ../../library/os.rst:1030
msgid ""
"Change the mode of the file given by *fd* to the numeric *mode*.  See the "
"docs for :func:`chmod` for possible values of *mode*.  As of Python 3.3, "
"this is equivalent to ``os.chmod(fd, mode)``."
msgstr ""
"将 *fd* 指定文件的权限状态修改为 *mode*。可以参考 :func:`chmod` 中列出 *mode* 的可用值。从Python "
"3.3开始，这相当于 ``os.chmod(fd, mode)``。"

#: ../../library/os.rst:1034 ../../library/os.rst:2209
#: ../../library/os.rst:2310
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chmod`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.chmod`` 并附带参数 ``path``, ``mode``, "
"``dir_fd``。"

#: ../../library/os.rst:1038 ../../library/os.rst:1056
#: ../../library/os.rst:1147 ../../library/os.rst:1759
#: ../../library/os.rst:2206 ../../library/os.rst:2239
#: ../../library/os.rst:3532
msgid ""
"The function is limited on WASI, see :ref:`wasm-availability` for more "
"information."
msgstr "此函数在 WASI 是受限的，请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/os.rst:1041 ../../library/os.rst:2317
msgid "Added support on Windows."
msgstr "增加 Windows 上的支持。"

#: ../../library/os.rst:1047
msgid ""
"Change the owner and group id of the file given by *fd* to the numeric *uid*"
" and *gid*.  To leave one of the ids unchanged, set it to -1.  See "
":func:`chown`.  As of Python 3.3, this is equivalent to ``os.chown(fd, uid, "
"gid)``."
msgstr ""
"分别将 *fd* 指定文件的所有者和组 ID 修改为 *uid* 和 *gid* 的值。若不想变更其中的某个 ID，可将相应值设为 -1。参考  "
":func:`chown`。从 Python 3.3 开始，这相当于 ``os.chown(fd, uid, gid)``。"

#: ../../library/os.rst:1052 ../../library/os.rst:2235
#: ../../library/os.rst:2326
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chown`` with arguments "
"``path``, ``uid``, ``gid``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.chown`` 并附带参数 ``path``, ``uid``, ``gid``, "
"``dir_fd``。"

#: ../../library/os.rst:1062
msgid ""
"Force write of file with filedescriptor *fd* to disk. Does not force update "
"of metadata."
msgstr "强制将文件描述符 *fd* 指定文件写入磁盘。不强制更新元数据。"

#: ../../library/os.rst:1068
msgid "This function is not available on MacOS."
msgstr "该功能在 MacOS 中不可用。"

#: ../../library/os.rst:1073
msgid ""
"Return system configuration information relevant to an open file. *name* "
"specifies the configuration value to retrieve; it may be a string which is "
"the name of a defined system value; these names are specified in a number of"
" standards (POSIX.1, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well.  The names known to the host operating system are "
"given in the ``pathconf_names`` dictionary.  For configuration variables not"
" included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"返回与打开的文件有关的系统配置信息。*name* "
"指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 "
"等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 ``pathconf_names`` "
"字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 *name*。"

#: ../../library/os.rst:1081 ../../library/os.rst:2646
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If a "
"specific value for *name* is not supported by the host system, even if it is"
" included in ``pathconf_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"如果 *name* 是一个字符串且不是已定义的名称，将抛出 :exc:`ValueError` 异常。如果当前系统不支持 *name* "
"指定的配置名称，即使该名称存在于 ``pathconf_names``，也会抛出 :exc:`OSError` 异常，错误码为 "
":const:`errno.EINVAL`。"

#: ../../library/os.rst:1086
msgid "As of Python 3.3, this is equivalent to ``os.pathconf(fd, name)``."
msgstr "从 Python 3.3 起，此功能等价于 ``os.pathconf(fd, name)``。"

#: ../../library/os.rst:1093
msgid ""
"Get the status of the file descriptor *fd*. Return a :class:`stat_result` "
"object."
msgstr "获取文件描述符 *fd* 的状态. 返回一个 :class:`stat_result` 对象。"

#: ../../library/os.rst:1096
msgid "As of Python 3.3, this is equivalent to ``os.stat(fd)``."
msgstr "从 Python 3.3 起，此功能等价于 ``os.stat(fd)``。"

#: ../../library/os.rst:1100 ../../library/os.rst:2474
msgid "The :func:`.stat` function."
msgstr ":func:`.stat` 函数。"

#: ../../library/os.rst:1105
msgid ""
"Return information about the filesystem containing the file associated with "
"file descriptor *fd*, like :func:`statvfs`.  As of Python 3.3, this is "
"equivalent to ``os.statvfs(fd)``."
msgstr ""
"返回文件系统的信息，该文件系统是文件描述符 *fd* 指向的文件所在的文件系统，与 :func:`statvfs` 一样。从 Python 3.3 "
"开始，它等效于 ``os.statvfs(fd)``。"

#: ../../library/os.rst:1114
msgid ""
"Force write of file with filedescriptor *fd* to disk.  On Unix, this calls "
"the native :c:func:`!fsync` function; on Windows, the MS :c:func:`!_commit` "
"function."
msgstr ""
"强制将文件描述符 *fd* 指向的文件写入磁盘。 在 Unix 上，这将调用原生 :c:func:`!fsync` 函数；在 Windows 上，则是 "
"MS :c:func:`!_commit` 函数。"

#: ../../library/os.rst:1117
msgid ""
"If you're starting with a buffered Python :term:`file object` *f*, first do "
"``f.flush()``, and then do ``os.fsync(f.fileno())``, to ensure that all "
"internal buffers associated with *f* are written to disk."
msgstr ""
"如果要写入的是缓冲区内的 Python :term:`文件对象 <file object>` *f*，请先执行 ``f.flush()``，然后执行 "
"``os.fsync(f.fileno())``，以确保与 *f* 关联的所有内部缓冲区都写入磁盘。"

#: ../../library/os.rst:1126
msgid ""
"Truncate the file corresponding to file descriptor *fd*, so that it is at "
"most *length* bytes in size.  As of Python 3.3, this is equivalent to "
"``os.truncate(fd, length)``."
msgstr ""
"截断文件描述符 *fd* 指向的文件，以使其最大为 *length* 字节。从 Python 3.3 开始，它等效于 ``os.truncate(fd,"
" length)``。"

#: ../../library/os.rst:1130
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments "
"``fd``, ``length``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.truncate`` 并附带参数 ``fd``, ``length``。"

#: ../../library/os.rst:1134 ../../library/os.rst:3571
msgid "Added support for Windows"
msgstr "添加了 Windows 支持"

#: ../../library/os.rst:1140
msgid ""
"Get the blocking mode of the file descriptor: ``False`` if the "
":data:`O_NONBLOCK` flag is set, ``True`` if the flag is cleared."
msgstr ""
"获取文件描述符的阻塞模式：如果设置了 :data:`O_NONBLOCK` 标志位，返回 ``False``，如果该标志位被清除，返回 "
"``True``。"

#: ../../library/os.rst:1143
msgid "See also :func:`set_blocking` and :meth:`socket.socket.setblocking`."
msgstr "参见 :func:`set_blocking` 和 :meth:`socket.socket.setblocking`。"

#: ../../library/os.rst:1150 ../../library/os.rst:1762
msgid "On Windows, this function is limited to pipes."
msgstr "在 Windows 上，此函数仅限于管道。"

#: ../../library/os.rst:1154 ../../library/os.rst:1766
msgid "Added support for pipes on Windows."
msgstr "增加了在Windows上对于管道的支持。"

#: ../../library/os.rst:1160
msgid ""
"Grant access to the slave pseudo-terminal device associated with the master "
"pseudo-terminal device to which the file descriptor *fd* refers. The file "
"descriptor *fd* is not closed upon failure."
msgstr "允许访问与文件描述符 *fd* 所指向的主伪终端设备相关联的从伪终端设备。 文件描述符 *fd* 在失败时不会被关闭。"

#: ../../library/os.rst:1164
msgid "Calls the C standard library function :c:func:`grantpt`."
msgstr "调用 C 标准库函数 :c:func:`grantpt`。"

#: ../../library/os.rst:1173
msgid ""
"Return ``True`` if the file descriptor *fd* is open and connected to a "
"tty(-like) device, else ``False``."
msgstr "如果文件描述符 *fd* 打开且已连接至 tty 设备（或类 tty 设备），返回 ``True``，否则返回 ``False``。"

#: ../../library/os.rst:1179
msgid ""
"Apply, test or remove a POSIX lock on an open file descriptor. *fd* is an "
"open file descriptor. *cmd* specifies the command to use - one of "
":data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` or :data:`F_TEST`. *len* "
"specifies the section of the file to lock."
msgstr ""
"在打开的文件描述符上，使用、测试或删除 POSIX 锁。*fd* 是一个打开的文件描述符。*cmd* 指定要进行的操作，它们是 "
":data:`F_LOCK`、:data:`F_TLOCK`、:data:`F_ULOCK` 或 :data:`F_TEST` 中的一个。*len* "
"指定哪部分文件需要锁定。"

#: ../../library/os.rst:1185
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.lockf`` with arguments "
"``fd``, ``cmd``, ``len``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.lockf`` 并附带参数 ``fd``, ``cmd``, ``len``。"

#: ../../library/os.rst:1197
msgid "Flags that specify what action :func:`lockf` will take."
msgstr "标志位，用于指定 :func:`lockf` 进行哪一种操作。"

#: ../../library/os.rst:1206
msgid ""
"Prepare the tty of which fd is a file descriptor for a new login session. "
"Make the calling process a session leader; make the tty the controlling tty,"
" the stdin, the stdout, and the stderr of the calling process; close fd."
msgstr ""
"准备 tty 设置 fd 为新登录会话的文件描述符。 设置调用方进程为会话主进程；设置该 tty 为主控 tty，调用方进程使用其 stdin, "
"stdout 和 stderr；关闭 fd。"

#: ../../library/os.rst:1217
msgid ""
"Set the current position of file descriptor *fd* to position *pos*, modified"
" by *whence*, and return the new position in bytes relative to the start of "
"the file. Valid values for *whence* are:"
msgstr ""
"将文件描述符 *fd* 的当前位置设为位置 *pos*，经 *whence* 修正，并返回相对于文件开头的以字节为单位的新位置。 *whence* "
"的有效值为："

#: ../../library/os.rst:1222
msgid ""
":const:`SEEK_SET` or ``0`` -- set *pos* relative to the beginning of the "
"file"
msgstr ":const:`SEEK_SET` 或 ``0`` -- 相对于文件开头设置 *pos*"

#: ../../library/os.rst:1223
msgid ""
":const:`SEEK_CUR` or ``1`` -- set *pos* relative to the current file "
"position"
msgstr ":const:`SEEK_CUR` 或 ``1`` -- 相对于当前文件位置设置 *pos*"

#: ../../library/os.rst:1224
msgid ""
":const:`SEEK_END` or ``2`` -- set *pos* relative to the end of the file"
msgstr ":const:`SEEK_END` 或 ``2`` -- 相对于文件末尾设置 *pos*"

#: ../../library/os.rst:1225
msgid ""
":const:`SEEK_HOLE` -- set *pos* to the next data location, relative to *pos*"
msgstr ":const:`SEEK_HOLE` -- 将 *pos* 设置为相对于 *pos* 的下一个数据位置"

#: ../../library/os.rst:1226
msgid ""
":const:`SEEK_DATA` -- set *pos* to the next data hole, relative to *pos*"
msgstr ":const:`SEEK_DATA` -- 将 *pos* 设为相对于 *pos* 的下一个数据空位"

#: ../../library/os.rst:1230
msgid "Add support for :const:`!SEEK_HOLE` and :const:`!SEEK_DATA`."
msgstr "增加对 :const:`!SEEK_HOLE` 和 :const:`!SEEK_DATA` 的支持。"

#: ../../library/os.rst:1237
msgid ""
"Parameters to the :func:`lseek` function and the :meth:`~io.IOBase.seek` "
"method on :term:`file-like objects <file object>`, for whence to adjust the "
"file position indicator."
msgstr ""
"传给 :func:`lseek` 函数和 :term:`文件型对象 <file object>` 上 :meth:`~io.IOBase.seek` "
"方法的形参，用于调整文件位置指示器。"

#: ../../library/os.rst:1241
msgid ":const:`SEEK_SET`"
msgstr ":const:`SEEK_SET`"

#: ../../library/os.rst:1242
msgid "Adjust the file position relative to the beginning of the file."
msgstr "相对于文件的开头调整文件位置。"

#: ../../library/os.rst:1243
msgid ":const:`SEEK_CUR`"
msgstr ":const:`SEEK_CUR`"

#: ../../library/os.rst:1244
msgid "Adjust the file position relative to the current file position."
msgstr "相对于当前文件位置调整文件位置。"

#: ../../library/os.rst:1245
msgid ":const:`SEEK_END`"
msgstr ":const:`SEEK_END`"

#: ../../library/os.rst:1246
msgid "Adjust the file position relative to the end of the file."
msgstr "相对于文件的末尾调整文件位置。"

#: ../../library/os.rst:1248
msgid "Their values are 0, 1, and 2, respectively."
msgstr "它们的值分别为 0, 1 和 2。"

#: ../../library/os.rst:1254
msgid ""
"Parameters to the :func:`lseek` function and the :meth:`~io.IOBase.seek` "
"method on :term:`file-like objects <file object>`, for seeking file data and"
" holes on sparsely allocated files."
msgstr ""
"传给 :func:`lseek` 函数和 :term:`文件型对象 <file object>` 上 :meth:`~io.IOBase.seek` "
"方法的形参，用于查找文件数据和稀疏分配的文件中的空洞。"

#: ../../library/os.rst:1258
msgid ":data:`!SEEK_DATA`"
msgstr ":data:`!SEEK_DATA`"

#: ../../library/os.rst:1259
msgid ""
"Adjust the file offset to the next location containing data, relative to the"
" seek position."
msgstr "相对于查找位置调整到下一个包含数据的位置的文件偏移量。"

#: ../../library/os.rst:1262
msgid ":data:`!SEEK_HOLE`"
msgstr ":data:`!SEEK_HOLE`"

#: ../../library/os.rst:1263
msgid ""
"Adjust the file offset to the next location containing a hole, relative to "
"the seek position. A hole is defined as a sequence of zeros."
msgstr "相对于查找位置调整到下一个包含空洞的位置的文件偏移量。 空洞被定义为零值的序列。"

#: ../../library/os.rst:1269
msgid "These operations only make sense for filesystems that support them."
msgstr "这些操作只对支持它们的文件系统具有意义。"

#: ../../library/os.rst:1278
msgid ""
"Open the file *path* and set various flags according to *flags* and possibly"
" its mode according to *mode*.  When computing *mode*, the current umask "
"value is first masked out.  Return the file descriptor for the newly opened "
"file. The new file descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"打开文件 *path*，根据 *flags* 设置各种标志位，并根据 *mode* 设置其权限状态。当计算 *mode* 时，会首先根据当前 umask"
" 值将部分权限去除。本方法返回新文件的描述符。新的文件描述符是 :ref:`不可继承 <fd_inheritance>` 的。"

#: ../../library/os.rst:1283
msgid ""
"For a description of the flag and mode values, see the C run-time "
"documentation; flag constants (like :const:`O_RDONLY` and :const:`O_WRONLY`)"
" are defined in the :mod:`os` module.  In particular, on Windows adding "
":const:`O_BINARY` is needed to open files in binary mode."
msgstr ""
"有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如 :const:`O_RDONLY` 和 "
":const:`O_WRONLY`）在 :mod:`os` 模块中定义。特别地，在 Windows 上需要添加 :const:`O_BINARY` "
"才能以二进制模式打开文件。"

#: ../../library/os.rst:1288
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>` with the *dir_fd* parameter."
msgstr "本函数带有 *dir_fd* 参数，支持 :ref:`基于目录描述符的相对路径 <dir_fd>`。"

#: ../../library/os.rst:1291
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``,"
" ``mode``, ``flags``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``open`` 并附带参数 ``path``, ``mode``, ``flags``。"

#: ../../library/os.rst:1298
msgid ""
"This function is intended for low-level I/O.  For normal usage, use the "
"built-in function :func:`open`, which returns a :term:`file object` with "
":meth:`~file.read` and :meth:`~file.write` methods (and many more).  To wrap"
" a file descriptor in a file object, use :func:`fdopen`."
msgstr ""
"本函数适用于底层的 I/O。常规用途请使用内置函数 :func:`open`，该函数的 :meth:`~file.read` 和 "
":meth:`~file.write` 方法（及其他方法）会返回 :term:`文件对象 <file "
"object>`。要将文件描述符包装在文件对象中，请使用 :func:`fdopen`。"

#: ../../library/os.rst:1303 ../../library/os.rst:2479
#: ../../library/os.rst:2519 ../../library/os.rst:2590
#: ../../library/os.rst:2612 ../../library/os.rst:2693
#: ../../library/os.rst:2723 ../../library/os.rst:2830
#: ../../library/os.rst:3587
msgid "Added the *dir_fd* parameter."
msgstr "添加了 *dir_fd* 参数。"

#: ../../library/os.rst:1306 ../../library/os.rst:1657
#: ../../library/os.rst:1892 ../../library/os.rst:5179
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an "
":exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 :exc:`InterruptedError` 异常 (原因详见 "
":pep:`475`)。"

#: ../../library/os.rst:1311 ../../library/os.rst:2102
#: ../../library/os.rst:2134 ../../library/os.rst:2165
#: ../../library/os.rst:2215 ../../library/os.rst:2256
#: ../../library/os.rst:2296 ../../library/os.rst:2314
#: ../../library/os.rst:2330 ../../library/os.rst:2390
#: ../../library/os.rst:2482 ../../library/os.rst:2522
#: ../../library/os.rst:2566 ../../library/os.rst:2593
#: ../../library/os.rst:2615 ../../library/os.rst:2656
#: ../../library/os.rst:2726 ../../library/os.rst:2745
#: ../../library/os.rst:2833 ../../library/os.rst:3123
#: ../../library/os.rst:3410 ../../library/os.rst:3574
#: ../../library/os.rst:3590 ../../library/os.rst:3630
#: ../../library/os.rst:3730 ../../library/os.rst:3791
#: ../../library/os.rst:4188 ../../library/os.rst:4368
#: ../../library/os.rst:4937
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../library/os.rst:1314
msgid ""
"The following constants are options for the *flags* parameter to the "
":func:`~os.open` function.  They can be combined using the bitwise OR "
"operator ``|``.  Some of them are not available on all platforms.  For "
"descriptions of their availability and use, consult the :manpage:`open(2)` "
"manual page on Unix or `the MSDN <https://msdn.microsoft.com/en-"
"us/library/z0kc8e3z.aspx>`_ on Windows."
msgstr ""
"以下常量是 :func:`~os.open` 函数 *flags* 参数的选项。可以用按位或运算符 ``|`` "
"将它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明，请参阅 :manpage:`open(2)` 手册（Unix 上）或 "
"`MSDN <https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx>`_ （Windows "
"上）。"

#: ../../library/os.rst:1329
msgid "The above constants are available on Unix and Windows."
msgstr "上述常量在 Unix 和 Windows 上均可用。"

#: ../../library/os.rst:1340
msgid "The above constants are only available on Unix."
msgstr "这个常数仅在 Unix 系统中可用。"

#: ../../library/os.rst:1342
msgid "Add :data:`O_CLOEXEC` constant."
msgstr "增加 :data:`O_CLOEXEC` 常量。"

#: ../../library/os.rst:1353
msgid "The above constants are only available on Windows."
msgstr "这个常数仅在 Windows 系统中可用。"

#: ../../library/os.rst:1360
msgid "The above constants are only available on macOS."
msgstr "以上常量仅适用于 macOS。"

#: ../../library/os.rst:1362
msgid ""
"Add :data:`O_EVTONLY`, :data:`O_FSYNC`, :data:`O_SYMLINK` and "
":data:`O_NOFOLLOW_ANY` constants."
msgstr ""
"加入 :data:`O_EVTONLY` 、 :data:`O_FSYNC` 、 :data:`O_SYMLINK` 和 "
":data:`O_NOFOLLOW_ANY` 常量。"

#: ../../library/os.rst:1376
msgid ""
"The above constants are extensions and not present if they are not defined "
"by the C library."
msgstr "上述常量是扩展常量，如果 C 库未定义它们，则不存在。"

#: ../../library/os.rst:1379
msgid ""
"Add :data:`O_PATH` on systems that support it. Add :data:`O_TMPFILE`, only "
"available on Linux Kernel 3.11   or newer."
msgstr ""
"在支持的系统上增加 :data:`O_PATH`。增加 :data:`O_TMPFILE`，仅在 Linux Kernel 3.11 或更高版本可用。"

#: ../../library/os.rst:1389
msgid ""
"Open a new pseudo-terminal pair. Return a pair of file descriptors "
"``(master, slave)`` for the pty and the tty, respectively. The new file "
"descriptors are :ref:`non-inheritable <fd_inheritance>`. For a (slightly) "
"more portable approach, use the :mod:`pty` module."
msgstr ""
"打开一对新的伪终端，返回一对文件描述符 ``（主，从）``，分别为 pty 和 tty。新的文件描述符是 :ref:`不可继承 "
"<fd_inheritance>` 的。对于（稍微）轻量一些的方法，请使用 :mod:`pty` 模块。"

#: ../../library/os.rst:1396 ../../library/os.rst:1408
msgid "The new file descriptors are now non-inheritable."
msgstr "新的文件描述符不再可继承。"

#: ../../library/os.rst:1402
msgid ""
"Create a pipe.  Return a pair of file descriptors ``(r, w)`` usable for "
"reading and writing, respectively. The new file descriptor is :ref:`non-"
"inheritable <fd_inheritance>`."
msgstr ""
"创建一个管道，返回一对分别用于读取和写入的文件描述符 ``(r, w)``。新的文件描述符是 :ref:`不可继承 <fd_inheritance>` "
"的。"

#: ../../library/os.rst:1414
msgid ""
"Create a pipe with *flags* set atomically. *flags* can be constructed by "
"ORing together one or more of these values: :data:`O_NONBLOCK`, "
":data:`O_CLOEXEC`. Return a pair of file descriptors ``(r, w)`` usable for "
"reading and writing, respectively."
msgstr ""
"创建带有 *flags* 标志位的管道。可通过对以下一个或多个值进行“或”运算来构造这些 "
"*flags*：:data:`O_NONBLOCK`、:data:`O_CLOEXEC`。返回一对分别用于读取和写入的文件描述符 ``(r, w)``。"

#: ../../library/os.rst:1427
msgid ""
"Ensures that enough disk space is allocated for the file specified by *fd* "
"starting from *offset* and continuing for *len* bytes."
msgstr "确保为 *fd* 指向的文件分配了足够的磁盘空间，该空间从偏移量 *offset* 开始，到 *len* 字节为止。"

#: ../../library/os.rst:1437
msgid ""
"Announces an intention to access data in a specific pattern thus allowing "
"the kernel to make optimizations. The advice applies to the region of the "
"file specified by *fd* starting at *offset* and continuing for *len* bytes. "
"*advice* is one of :data:`POSIX_FADV_NORMAL`, :data:`POSIX_FADV_SEQUENTIAL`,"
" :data:`POSIX_FADV_RANDOM`, :data:`POSIX_FADV_NOREUSE`, "
":data:`POSIX_FADV_WILLNEED` or :data:`POSIX_FADV_DONTNEED`."
msgstr ""
"声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从 *fd* 所指向文件的 *offset* 开始，持续 *len* "
"个字节。*advice* 的取值是如下之一：:data:`POSIX_FADV_NORMAL`, "
":data:`POSIX_FADV_SEQUENTIAL`, :data:`POSIX_FADV_RANDOM`, "
":data:`POSIX_FADV_NOREUSE`, :data:`POSIX_FADV_WILLNEED` 或 "
":data:`POSIX_FADV_DONTNEED`。"

#: ../../library/os.rst:1457
msgid ""
"Flags that can be used in *advice* in :func:`posix_fadvise` that specify the"
" access pattern that is likely to be used."
msgstr "用于 :func:`posix_fadvise` 的 *advice* 参数的标志位，指定可能使用的访问模式。"

#: ../../library/os.rst:1467
msgid ""
"Read at most *n* bytes from file descriptor *fd* at a position of *offset*, "
"leaving the file offset unchanged."
msgstr "从文件描述符 *fd* 所指向文件的偏移位置 *offset* 开始，读取至多 *n* 个字节，而保持文件偏移量不变。"

#: ../../library/os.rst:1470 ../../library/os.rst:1646
msgid ""
"Return a bytestring containing the bytes read. If the end of the file "
"referred to by *fd* has been reached, an empty bytes object is returned."
msgstr "返回所读取字节的字节串 (bytestring)。如果到达了 *fd* 指向的文件末尾，则返回空字节对象。"

#: ../../library/os.rst:1480
msgid "Open and return a file descriptor for a master pseudo-terminal device."
msgstr "打开并返回一个代表主要伪终端设备的文件描述符。"

#: ../../library/os.rst:1482
msgid ""
"Calls the C standard library function :c:func:`posix_openpt`. The *oflag* "
"argument is used to set file status flags and file access modes as specified"
" in the manual page of :c:func:`posix_openpt` of your system."
msgstr ""
"调用 C 标准库函数 :c:func:`posix_openpt`。 *oflag* 参数用于设置文件状态旗标和文件访问模式，如你所用系统的 "
":c:func:`posix_openpt` 帮助页中所指明的那样。"

#: ../../library/os.rst:1486
msgid ""
"The returned file descriptor is :ref:`non-inheritable <fd_inheritance>`. If "
"the value :data:`O_CLOEXEC` is available on the system, it is added to "
"*oflag*."
msgstr ""
"返回的文件描述符是 :ref:`非不可继承的 <fd_inheritance>`。 如果所在系统上 :data:`O_CLOEXEC` "
"值是可用的，它将被添加到 *oflag*。"

#: ../../library/os.rst:1497
msgid ""
"Read from a file descriptor *fd* at a position of *offset* into mutable "
":term:`bytes-like objects <bytes-like object>` *buffers*, leaving the file "
"offset unchanged.  Transfer data into each buffer until it is full and then "
"move on to the next buffer in the sequence to hold the rest of the data."
msgstr ""
"从文件描述符 *fd* 所指向文件的偏移位置 *offset* 开始，将数据读取至可变 :term:`字节类对象 <bytes-like "
"object>` 缓冲区 *buffers* "
"中，保持文件偏移量不变。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。"

#: ../../library/os.rst:1502 ../../library/os.rst:1587
msgid ""
"The flags argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr "flags 参数可以由零个或多个标志位进行按位或运算来得到："

#: ../../library/os.rst:1505
msgid ":data:`RWF_HIPRI`"
msgstr ":data:`RWF_HIPRI`"

#: ../../library/os.rst:1506
msgid ":data:`RWF_NOWAIT`"
msgstr ":data:`RWF_NOWAIT`"

#: ../../library/os.rst:1508 ../../library/os.rst:1829
msgid ""
"Return the total number of bytes actually read which can be less than the "
"total capacity of all the objects."
msgstr "返回实际读取的字节总数，该总数可以小于所有对象的总容量。"

#: ../../library/os.rst:1511 ../../library/os.rst:1596
#: ../../library/os.rst:1832 ../../library/os.rst:1907
msgid ""
"The operating system may set a limit (:func:`sysconf` value "
"``'SC_IOV_MAX'``) on the number of buffers that can be used."
msgstr "操作系统可能对允许使用的缓冲区数量有限制（使用 :func:`sysconf` 获取 ``'SC_IOV_MAX'`` 值）。"

#: ../../library/os.rst:1514
msgid "Combine the functionality of :func:`os.readv` and :func:`os.pread`."
msgstr "本方法结合了 :func:`os.readv` 和 :func:`os.pread` 的功能。"

#: ../../library/os.rst:1518 ../../library/os.rst:1603
msgid "Using flags requires Linux >= 4.6."
msgstr "使用旗标需要 Linux >= 4.6。"

#: ../../library/os.rst:1525
msgid ""
"Do not wait for data which is not immediately available. If this flag is "
"specified, the system call will return instantly if it would have to read "
"data from the backing storage or wait for a lock."
msgstr "不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储器中读取数据，或等待文件锁时，系统调用将立即返回。"

#: ../../library/os.rst:1529
msgid ""
"If some data was successfully read, it will return the number of bytes read."
" If no bytes were read, it will return ``-1`` and set errno to "
":const:`errno.EAGAIN`."
msgstr ""
"如果成功读取了数据，将返回读取的字节数。 如果未读取到数据，将返回 ``-1`` 并将 errno 设为 :const:`errno.EAGAIN`。"

#: ../../library/os.rst:1540
msgid ""
"High priority read/write. Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources."
msgstr "高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟，但可能会占用更多资源。"

#: ../../library/os.rst:1544
msgid ""
"Currently, on Linux, this feature is usable only on a file descriptor opened"
" using the :data:`O_DIRECT` flag."
msgstr "目前在 Linux 上，此功能仅在使用 :data:`O_DIRECT` 标志打开的文件描述符上可用。"

#: ../../library/os.rst:1554
msgid ""
"Return the name of the slave pseudo-terminal device associated with the "
"master pseudo-terminal device to which the file descriptor *fd* refers. The "
"file descriptor *fd* is not closed upon failure."
msgstr "返回与文件描述符 *fd* 所指向的主伪终端设备相关联的从伪终端设备。 文件描述符 *fd* 在失败时不会被关闭。"

#: ../../library/os.rst:1558
msgid ""
"Calls the reentrant C standard library function :c:func:`ptsname_r` if it is"
" available; otherwise, the C standard library function :c:func:`ptsname`, "
"which is not guaranteed to be thread-safe, is called."
msgstr ""
"如果可重入 C 标准库函数 :c:func:`ptsname_r` 可用则调用它；在其他情况下，则调用 C 标准库函数 "
":c:func:`ptsname`，该函数不保证线程安全。"

#: ../../library/os.rst:1569
msgid ""
"Write the bytestring in *str* to file descriptor *fd* at position of "
"*offset*, leaving the file offset unchanged."
msgstr "将 *str* 中的字节串 (bytestring) 写入文件描述符 *fd* 的偏移位置 *offset* 处，保持文件偏移量不变。"

#: ../../library/os.rst:1572 ../../library/os.rst:1882
msgid "Return the number of bytes actually written."
msgstr "返回实际写入的字节数。"

#: ../../library/os.rst:1581
msgid ""
"Write the *buffers* contents to file descriptor *fd* at an offset *offset*, "
"leaving the file offset unchanged.  *buffers* must be a sequence of "
":term:`bytes-like objects <bytes-like object>`. Buffers are processed in "
"array order. Entire contents of the first buffer is written before "
"proceeding to the second, and so on."
msgstr ""
"将 *buffers* 内容写入文件描述符 *fd* 的偏移位置 *offset* 处，保持文件偏移位置不变。 *buffers* 必须是由 "
":term:`字节型对象 <bytes-like object>` 组成的序列。 缓冲区以数组顺序处理。 "
"先写入第一个缓冲区的全部内容再写入第二个，依此类推。"

#: ../../library/os.rst:1590
msgid ":data:`RWF_DSYNC`"
msgstr ":data:`RWF_DSYNC`"

#: ../../library/os.rst:1591
msgid ":data:`RWF_SYNC`"
msgstr ":data:`RWF_SYNC`"

#: ../../library/os.rst:1592
msgid ":data:`RWF_APPEND`"
msgstr ":data:`RWF_APPEND`"

#: ../../library/os.rst:1594
msgid "Return the total number of bytes actually written."
msgstr "返回实际写入的字节总数。"

#: ../../library/os.rst:1599
msgid "Combine the functionality of :func:`os.writev` and :func:`os.pwrite`."
msgstr "本方法结合了 :func:`os.writev` 和 :func:`os.pwrite` 的功能。"

#: ../../library/os.rst:1610
msgid ""
"Provide a per-write equivalent of the :data:`O_DSYNC` :func:`os.open` flag. "
"This flag effect applies only to the data range written by the system call."
msgstr "提供预写功能，等效于带 :data:`O_DSYNC` 标志的 :func:`os.open` 。本标志只作用于通过系统调用写入的数据。"

#: ../../library/os.rst:1620
msgid ""
"Provide a per-write equivalent of the :data:`O_SYNC` :func:`os.open` flag. "
"This flag effect applies only to the data range written by the system call."
msgstr "提供预写功能，等效于带 :data:`O_SYNC` 标志的 :func:`os.open` 。本标志只作用于通过系统调用写入的数据。"

#: ../../library/os.rst:1630
msgid ""
"Provide a per-write equivalent of the :data:`O_APPEND` :func:`os.open` flag."
" This flag is meaningful only for :func:`os.pwritev`, and its effect applies"
" only to the data range written by the system call. The *offset* argument "
"does not affect the write operation; the data is always appended to the end "
"of the file. However, if the *offset* argument is ``-1``, the current file "
"*offset* is updated."
msgstr ""
"提供预写功能，等效于带 :data:`O_APPEND` 标志的 :func:`os.open` 。本标志只对 :func:`os.pwritev` "
"有意义，只作用于通过系统调用写入的数据。参数 *offset* 对写入操作无效；数据总是会添加到文件的末尾。但如果 *offset* 参数为 "
"``-1``，则会刷新当前文件的 *offset* 。"

#: ../../library/os.rst:1644
msgid "Read at most *n* bytes from file descriptor *fd*."
msgstr "从文件描述符 *fd* 中读取至多 *n* 个字节。"

#: ../../library/os.rst:1651
msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To read a \"file"
" object\" returned by the built-in function :func:`open` or by :func:`popen`"
" or :func:`fdopen`, or :data:`sys.stdin`, use its :meth:`~file.read` or "
":meth:`~file.readline` methods."
msgstr ""
"该功能适用于低级 I/O 操作，必须用于 :func:`os.open` 或 :func:`pipe` 返回的文件描述符。若要读取由内建函数 "
":func:`open`、:func:`popen`、:func:`fdopen` 或 :data:`sys.stdin` 返回的 "
"\"文件对象\"，则应使用其相应的 :meth:`~file.read` 或 :meth:`~file.readline` 方法。"

#: ../../library/os.rst:1665
msgid ""
"Read from a file descriptor *fd* into a mutable :ref:`buffer object "
"<bufferobjects>` *buffer*."
msgstr ""

#: ../../library/os.rst:1668
msgid ""
"The *buffer* should be mutable and :term:`bytes-like <bytes-like object>`. "
"On success, returns the number of bytes read. Less bytes may be read than "
"the size of the buffer. The underlying system call will be retried when "
"interrupted by a signal, unless the signal handler raises an exception. "
"Other errors will not be retried and an error will be raised."
msgstr ""

#: ../../library/os.rst:1674
msgid ""
"Returns 0 if *fd* is at end of file or if the provided *buffer* has length 0"
" (which can be used to check for errors without reading data). Never returns"
" negative."
msgstr ""

#: ../../library/os.rst:1680
msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`os.pipe`.  To read a "
"\"file object\" returned by the built-in function :func:`open`, or "
":data:`sys.stdin`, use its member functions, for example "
":meth:`io.BufferedIOBase.readinto`, :meth:`io.BufferedIOBase.read`, or "
":meth:`io.TextIOBase.read`"
msgstr ""

#: ../../library/os.rst:1693
msgid ""
"Copy *count* bytes from file descriptor *in_fd* to file descriptor *out_fd* "
"starting at *offset*. Return the number of bytes sent. When EOF is reached "
"return ``0``."
msgstr ""
"将文件描述符 *in_fd* 中的 *count* 字节复制到文件描述符 *out_fd* 的偏移位置 *offset* 处。返回复制的字节数，如果到达"
" EOF，返回 ``0``。"

#: ../../library/os.rst:1697
msgid ""
"The first function notation is supported by all platforms that define "
":func:`sendfile`."
msgstr "定义了 :func:`sendfile` 的所有平台均支持第一种函数用法。"

#: ../../library/os.rst:1700
msgid ""
"On Linux, if *offset* is given as ``None``, the bytes are read from the "
"current position of *in_fd* and the position of *in_fd* is updated."
msgstr ""
"在 Linux 上，将 *offset* 设置为 ``None``，则从 *in_fd* 的当前位置开始读取，并更新 *in_fd* 的位置。"

#: ../../library/os.rst:1703
msgid ""
"The second case may be used on macOS and FreeBSD where *headers* and "
"*trailers* are arbitrary sequences of buffers that are written before and "
"after the data from *in_fd* is written. It returns the same as the first "
"case."
msgstr ""
"第二种情况可以被用于 macOS 和 FreeBSD，其中 *headers* 和 *trailers* 是任意的缓冲区序列，它们会在写入来自 "
"*in_fd* 的数据之前被写入。 它的返回内容与第一种情况相同。"

#: ../../library/os.rst:1707
msgid ""
"On macOS and FreeBSD, a value of ``0`` for *count* specifies to send until "
"the end of *in_fd* is reached."
msgstr "在 macOS 和 FreeBSD 上，传入 ``0`` 值作为 *count* 将指定持续发送直至到达 *in_fd* 的末尾。"

#: ../../library/os.rst:1710
msgid ""
"All platforms support sockets as *out_fd* file descriptor, and some "
"platforms allow other types (e.g. regular file, pipe) as well."
msgstr "所有平台都支持将套接字作为 *out_fd* 文件描述符，有些平台也支持其他类型（如常规文件或管道）。"

#: ../../library/os.rst:1713
msgid ""
"Cross-platform applications should not use *headers*, *trailers* and *flags*"
" arguments."
msgstr "跨平台应用程序不应使用 *headers*、*trailers* 和 *flags* 参数。"

#: ../../library/os.rst:1720
msgid ""
"For a higher-level wrapper of :func:`sendfile`, see "
":meth:`socket.socket.sendfile`."
msgstr "有关 :func:`sendfile` 的高级封装，参见 :meth:`socket.socket.sendfile`。"

#: ../../library/os.rst:1725
msgid "Parameters *out* and *in* was renamed to *out_fd* and *in_fd*."
msgstr "*out* 和 *in* 参数被重命名为 *out_fd* 和 *in_fd*。"

#: ../../library/os.rst:1733
msgid ""
"Parameters to the :func:`sendfile` function, if the implementation supports "
"them."
msgstr ":func:`sendfile` 函数的参数（假设当前实现支持这些参数）。"

#: ../../library/os.rst:1742
msgid ""
"Parameter to the :func:`sendfile` function, if the implementation supports "
"it. The data won't be cached in the virtual memory and will be freed "
"afterwards."
msgstr "传给 :func:`sendfile` 函数的形参，如果具体实现支持的话。 数据不会缓存在虚拟内存中并将随即被释放。"

#: ../../library/os.rst:1752
msgid ""
"Set the blocking mode of the specified file descriptor. Set the "
":data:`O_NONBLOCK` flag if blocking is ``False``, clear the flag otherwise."
msgstr ""
"设置指定文件描述符的阻塞模式：如果 blocking 为 ``False``，则为该描述符设置 :data:`O_NONBLOCK` "
"标志位，反之则清除该标志位。"

#: ../../library/os.rst:1755
msgid "See also :func:`get_blocking` and :meth:`socket.socket.setblocking`."
msgstr "参见 :func:`get_blocking` 和 :meth:`socket.socket.setblocking`。"

#: ../../library/os.rst:1772
msgid ""
"Transfer *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset *offset_dst*."
msgstr ""

#: ../../library/os.rst:1775
msgid ""
"The splicing behaviour can be modified by specifying a *flags* value. Any of"
" the following variables may used, combined using bitwise OR (the ``|`` "
"operator):"
msgstr ""

#: ../../library/os.rst:1779
msgid ""
"If :const:`SPLICE_F_MOVE` is specified, the kernel is asked to move pages "
"instead of copying, but pages may still be copied if the kernel cannot move "
"the pages from the pipe."
msgstr ""

#: ../../library/os.rst:1783
msgid ""
"If :const:`SPLICE_F_NONBLOCK` is specified, the kernel is asked to not block"
" on I/O. This makes the splice pipe operations nonblocking, but splice may "
"nevertheless block because the spliced file descriptors may block."
msgstr ""

#: ../../library/os.rst:1788
msgid ""
"If :const:`SPLICE_F_MORE` is specified, it hints to the kernel that more "
"data will be coming in a subsequent splice."
msgstr ""

#: ../../library/os.rst:1791
msgid ""
"At least one of the file descriptors must refer to a pipe. If *offset_src* "
"is ``None``, then *src* is read from the current position; respectively for "
"*offset_dst*. The offset associated to the file descriptor that refers to a "
"pipe must be ``None``. The files pointed to by *src* and *dst* must reside "
"in the same filesystem, otherwise an :exc:`OSError` is raised with "
":attr:`~OSError.errno` set to :const:`errno.EXDEV`."
msgstr ""

#: ../../library/os.rst:1798
msgid ""
"This copy is done without the additional cost of transferring data from the "
"kernel to user space and then back into the kernel. Additionally, some "
"filesystems could implement extra optimizations. The copy is done as if both"
" files are opened as binary."
msgstr ""
"此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。"

#: ../../library/os.rst:1803
msgid ""
"Upon successful completion, returns the number of bytes spliced to or from "
"the pipe. A return value of 0 means end of input. If *src* refers to a pipe,"
" then this means that there was no data to transfer, and it would not make "
"sense to block because there are no writers connected to the write end of "
"the pipe."
msgstr ""
"调用成功后，返回拼接到管道的字节数或从管道拼接出来的字节数。返回值为 0 意味着输入结束。如果 *src* "
"指向一个管道，则意味着没有数据需要传输，而且由于没有写入程序连到管道的写入端，所以将不会阻塞。"

#: ../../library/os.rst:1809
msgid "The :manpage:`splice(2)` man page."
msgstr ""

#: ../../library/os.rst:1824
msgid ""
"Read from a file descriptor *fd* into a number of mutable :term:`bytes-like "
"objects <bytes-like object>` *buffers*. Transfer data into each buffer until"
" it is full and then move on to the next buffer in the sequence to hold the "
"rest of the data."
msgstr ""
"从文件描述符 *fd* 将数据读取至多个可变的 :term:`字节类对象 <bytes-like object>` 缓冲区 *buffers* "
"中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。"

#: ../../library/os.rst:1842
msgid ""
"Return the process group associated with the terminal given by *fd* (an open"
" file descriptor as returned by :func:`os.open`)."
msgstr "返回与 *fd* 指定的终端相关联的进程组（*fd* 是由 :func:`os.open` 返回的已打开的文件描述符）。"

#: ../../library/os.rst:1850
msgid ""
"Set the process group associated with the terminal given by *fd* (an open "
"file descriptor as returned by :func:`os.open`) to *pg*."
msgstr "设置与 *fd* 指定的终端相关联的进程组为 *pg*（*fd* 是由 :func:`os.open` 返回的已打开的文件描述符）。"

#: ../../library/os.rst:1858
msgid ""
"Return a string which specifies the terminal device associated with file "
"descriptor *fd*.  If *fd* is not associated with a terminal device, an "
"exception is raised."
msgstr "返回一个字符串，该字符串表示与文件描述符 *fd* 关联的终端。如果 *fd* 没有与终端关联，则抛出异常。"

#: ../../library/os.rst:1867
msgid ""
"Unlock the slave pseudo-terminal device associated with the master pseudo-"
"terminal device to which the file descriptor *fd* refers. The file "
"descriptor *fd* is not closed upon failure."
msgstr "解锁与文件描述符 *fd* 所指向的主伪终端设备相关联的从伪终端设备。 文件描述符 *fd* 在失败时不会被关闭。"

#: ../../library/os.rst:1871
msgid "Calls the C standard library function :c:func:`unlockpt`."
msgstr "调用 C 标准库函数 :c:func:`unlockpt`。"

#: ../../library/os.rst:1880
msgid "Write the bytestring in *str* to file descriptor *fd*."
msgstr "将 *str* 中的字节串 (bytestring) 写入文件描述符 *fd*。"

#: ../../library/os.rst:1886
msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To write a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, or :data:`sys.stdout` or "
":data:`sys.stderr`, use its :meth:`~file.write` method."
msgstr ""
"该功能适用于低级 I/O 操作，必须用于 :func:`os.open` 或 :func:`pipe` 返回的文件描述符。若要写入由内建函数 "
":func:`open`、:func:`popen`、:func:`fdopen`、:data:`sys.stdout` 或 "
":data:`sys.stderr` 返回的 \"文件对象\"，则应使用其相应的 :meth:`~file.write` 方法。"

#: ../../library/os.rst:1900
msgid ""
"Write the contents of *buffers* to file descriptor *fd*. *buffers* must be a"
" sequence of :term:`bytes-like objects <bytes-like object>`. Buffers are "
"processed in array order. Entire contents of the first buffer is written "
"before proceeding to the second, and so on."
msgstr ""
"将缓冲区 *buffers* 的内容写入文件描述符 *fd*。缓冲区 *buffers* 必须是由 :term:`字节类对象 <bytes-like "
"object>` 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。"

#: ../../library/os.rst:1905
msgid "Returns the total number of bytes actually written."
msgstr "返回实际写入的字节总数。"

#: ../../library/os.rst:1918
msgid "Querying the size of a terminal"
msgstr "查询终端的尺寸"

#: ../../library/os.rst:1924
msgid ""
"Return the size of the terminal window as ``(columns, lines)``, tuple of "
"type :class:`terminal_size`."
msgstr "返回终端窗口的尺寸，格式为 ``(columns, lines)``，它是类型为 :class:`terminal_size` 的元组。"

#: ../../library/os.rst:1927
msgid ""
"The optional argument ``fd`` (default ``STDOUT_FILENO``, or standard output)"
" specifies which file descriptor should be queried."
msgstr "可选参数 ``fd`` （默认为 ``STDOUT_FILENO`` 或标准输出）指定应查询的文件描述符。"

#: ../../library/os.rst:1930
msgid ""
"If the file descriptor is not connected to a terminal, an :exc:`OSError` is "
"raised."
msgstr "如果文件描述符未连接到终端，则抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:1933
msgid ""
":func:`shutil.get_terminal_size` is the high-level function which should "
"normally be used, ``os.get_terminal_size`` is the low-level implementation."
msgstr ""
":func:`shutil.get_terminal_size` 是供常规使用的高阶函数，``os.get_terminal_size`` "
"是其底层的实现。"

#: ../../library/os.rst:1941
msgid ""
"A subclass of tuple, holding ``(columns, lines)`` of the terminal window "
"size."
msgstr "元组的子类，存储终端窗口尺寸 ``(columns, lines)``。"

#: ../../library/os.rst:1945
msgid "Width of the terminal window in characters."
msgstr "终端窗口的宽度，单位为字符。"

#: ../../library/os.rst:1949
msgid "Height of the terminal window in characters."
msgstr "终端窗口的高度，单位为字符。"

#: ../../library/os.rst:1955
msgid "Inheritance of File Descriptors"
msgstr "文件描述符的继承"

#: ../../library/os.rst:1959
msgid ""
"A file descriptor has an \"inheritable\" flag which indicates if the file "
"descriptor can be inherited by child processes.  Since Python 3.4, file "
"descriptors created by Python are non-inheritable by default."
msgstr ""
"每个文件描述符都有一个 \"inheritable\"（可继承）标志位，该标志位控制了文件描述符是否可以由子进程继承。从 Python 3.4 开始，由"
" Python 创建的文件描述符默认是不可继承的。"

#: ../../library/os.rst:1963
msgid ""
"On UNIX, non-inheritable file descriptors are closed in child processes at "
"the execution of a new program, other file descriptors are inherited."
msgstr "在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他文件描述符将被继承。"

#: ../../library/os.rst:1966
msgid ""
"On Windows, non-inheritable handles and file descriptors are closed in child"
" processes, except for standard streams (file descriptors 0, 1 and 2: stdin,"
" stdout and stderr), which are always inherited.  Using :func:`spawn\\* "
"<spawnl>` functions, all inheritable handles and all inheritable file "
"descriptors are inherited. Using the :mod:`subprocess` module, all file "
"descriptors except standard streams are closed, and inheritable handles are "
"only inherited if the *close_fds* parameter is ``False``."
msgstr ""
"在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流（文件描述符 0、1 和 2 "
"即标准输入、标准输出和标准错误）是始终继承的。如果使用 :func:`spawn\\* <spawnl>` "
"函数，所有可继承的句柄和文件描述符都将被继承。如果使用 :mod:`subprocess` 模块，将关闭除标准流以外的所有文件描述符，并且仅当 "
"*close_fds* 参数为 ``False`` 时才继承可继承的句柄。"

#: ../../library/os.rst:1974
msgid "On WebAssembly platforms, the file descriptor cannot be modified."
msgstr "在 WebAssembly 平台上，文件描述符无法被修改。"

#: ../../library/os.rst:1978
msgid "Get the \"inheritable\" flag of the specified file descriptor (a boolean)."
msgstr "获取指定文件描述符的“可继承”标志位（为布尔值）。"

#: ../../library/os.rst:1982
msgid "Set the \"inheritable\" flag of the specified file descriptor."
msgstr "设置指定文件描述符的“可继承”标志位。"

#: ../../library/os.rst:1986
msgid "Get the \"inheritable\" flag of the specified handle (a boolean)."
msgstr "获取指定句柄的“可继承”标志位（为布尔值）。"

#: ../../library/os.rst:1992
msgid "Set the \"inheritable\" flag of the specified handle."
msgstr "设置指定句柄的“可继承”标志位。"

#: ../../library/os.rst:2000
msgid "Files and Directories"
msgstr "文件和目录"

#: ../../library/os.rst:2002
msgid ""
"On some Unix platforms, many of these functions support one or more of these"
" features:"
msgstr "在某些 Unix 平台上，许多函数支持以下一项或多项功能："

#: ../../library/os.rst:2007
msgid ""
"**specifying a file descriptor:** Normally the *path* argument provided to "
"functions in the :mod:`os` module must be a string specifying a file path.  "
"However, some functions now alternatively accept an open file descriptor for"
" their *path* argument. The function will then operate on the file referred "
"to by the descriptor. (For POSIX systems, Python will call the variant of "
"the function prefixed with ``f`` (e.g. call ``fchdir`` instead of "
"``chdir``).)"
msgstr ""
"**指定文件描述符为参数：** 通常在 :mod:`os` 模块中提供给函数的 *path* "
"参数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 *path* 参数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX"
" 系统，Python 将调用以 ``f`` 开头的函数变体（如调用 ``fchdir`` 而不是 ``chdir``）。）"

#: ../../library/os.rst:2015
msgid ""
"You can check whether or not *path* can be specified as a file descriptor "
"for a particular function on your platform using :data:`os.supports_fd`. If "
"this functionality is unavailable, using it will raise a "
":exc:`NotImplementedError`."
msgstr ""
"可以用 :data:`os.supports_fd` 检查某个函数在你的平台上是否支持将 *path* "
"参数指定为文件描述符。如果不支持，使用该功能将抛出 :exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:2020
msgid ""
"If the function also supports *dir_fd* or *follow_symlinks* arguments, it's "
"an error to specify one of those when supplying *path* as a file descriptor."
msgstr ""
"如果该函数还支持 *dir_fd* 或 *follow_symlinks* 参数，那么用文件描述符作为 *path* 后就不能再指定上述参数了。"

#: ../../library/os.rst:2025
msgid ""
"**paths relative to directory descriptors:** If *dir_fd* is not ``None``, it"
" should be a file descriptor referring to a directory, and the path to "
"operate on should be relative; path will then be relative to that directory."
"  If the path is absolute, *dir_fd* is ignored.  (For POSIX systems, Python "
"will call the variant of the function with an ``at`` suffix and possibly "
"prefixed with ``f`` (e.g. call ``faccessat`` instead of ``access``)."
msgstr ""
"**基于目录描述符的相对路径：** 如果 *dir_fd* 不是 ``None``，它就应该是一个指向目录的文件描述符，这时待操作的 path "
"应该是相对路径，相对路径是相对于前述目录的。如果 path 是绝对路径，则 *dir_fd* 将被忽略。（对于 POSIX 系统，Python "
"将调用该函数的变体，变体以 ``at`` 结尾，可能以 ``f`` 开头（如调用 ``faccessat`` 而不是 ``access``）。"

#: ../../library/os.rst:2032
msgid ""
"You can check whether or not *dir_fd* is supported for a particular function"
" on your platform using :data:`os.supports_dir_fd`.  If it's unavailable, "
"using it will raise a :exc:`NotImplementedError`."
msgstr ""
"可以用 :data:`os.supports_dir_fd` 检查某个函数在你的平台上是否支持 *dir_fd*。如果不支持，使用该功能将抛出 "
":exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:2038
msgid ""
"**not following symlinks:** If *follow_symlinks* is ``False``, and the last "
"element of the path to operate on is a symbolic link, the function will "
"operate on the symbolic link itself rather than the file pointed to by the "
"link.  (For POSIX systems, Python will call the ``l...`` variant of the "
"function.)"
msgstr ""
"**不跟踪符号链接：** 如果 *follow_symlinks* 为 "
"``False``，并且待操作路径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向的文件上操作。（对于 POSIX 系统，Python"
" 将调用该函数的 ``l...`` 变体。）"

#: ../../library/os.rst:2044
msgid ""
"You can check whether or not *follow_symlinks* is supported for a particular"
" function on your platform using :data:`os.supports_follow_symlinks`. If "
"it's unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"可以用 :data:`os.supports_follow_symlinks` 检查某个函数在你的平台上是否支持 "
"*follow_symlinks*。如果不支持，使用该功能将抛出 :exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:2052
msgid ""
"Use the real uid/gid to test for access to *path*.  Note that most "
"operations will use the effective uid/gid, therefore this routine can be "
"used in a suid/sgid environment to test if the invoking user has the "
"specified access to *path*.  *mode* should be :const:`F_OK` to test the "
"existence of *path*, or it can be the inclusive OR of one or more of "
":const:`R_OK`, :const:`W_OK`, and :const:`X_OK` to test permissions.  Return"
" :const:`True` if access is allowed, :const:`False` if not. See the Unix man"
" page :manpage:`access(2)` for more information."
msgstr ""
"使用 实际用户ID/用户组ID 测试对 *path* 的访问。请注意，大多数测试操作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid "
"环境中运用此例程，来测试调用用户是否具有对 *path* 的指定访问权限。*mode* 为 :const:`F_OK` 时用于测试 *path* "
"是否存在，也可以对 :const:`R_OK`、:const:`W_OK` 和 :const:`X_OK` "
"中的一个或多个进行“或”运算来测试指定权限。允许访问则返回 :const:`True`，否则返回 :const:`False`。更多信息请参见 Unix"
" 手册页 :manpage:`access(2)`。"

#: ../../library/os.rst:2061
msgid ""
"This function can support specifying :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"本函数支持指定 :ref:`基于目录描述符的相对路径 <dir_fd>` 和 :ref:`不跟踪符号链接 <follow_symlinks>`。"

#: ../../library/os.rst:2064
msgid ""
"If *effective_ids* is ``True``, :func:`access` will perform its access "
"checks using the effective uid/gid instead of the real uid/gid. "
"*effective_ids* may not be supported on your platform; you can check whether"
" or not it is available using :data:`os.supports_effective_ids`.  If it is "
"unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"如果 *effective_ids* 为 ``True``，:func:`access` 将使用 有效用户ID/用户组ID 而非 "
"实际用户ID/用户组ID 进行访问检查。您的平台可能不支持 *effective_ids*，您可以使用 "
":data:`os.supports_effective_ids` 检查它是否可用。如果不可用，使用它时会抛出 "
":exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:2072
msgid ""
"Using :func:`access` to check if a user is authorized to e.g. open a file "
"before actually doing so using :func:`open` creates a security hole, because"
" the user might exploit the short time interval between checking and opening"
" the file to manipulate it. It's preferable to use :term:`EAFP` techniques. "
"For example::"
msgstr ""
"使用 :func:`access` 来检查用户是否具有某项权限（如打开文件的权限），然后再使用 :func:`open` "
"打开文件，这样做存在一个安全漏洞，因为用户可能会在检查和打开文件之间的时间里做其他操作。推荐使用 :term:`EAFP` 技术。如::"

#: ../../library/os.rst:2078
msgid ""
"if os.access(\"myfile\", os.R_OK):\n"
"    with open(\"myfile\") as fp:\n"
"        return fp.read()\n"
"return \"some default data\""
msgstr ""
"if os.access(\"myfile\", os.R_OK):\n"
"    with open(\"myfile\") as fp:\n"
"        return fp.read()\n"
"return \"some default data\""

#: ../../library/os.rst:2083
msgid "is better written as::"
msgstr "最好写成::"

#: ../../library/os.rst:2085
msgid ""
"try:\n"
"    fp = open(\"myfile\")\n"
"except PermissionError:\n"
"    return \"some default data\"\n"
"else:\n"
"    with fp:\n"
"        return fp.read()"
msgstr ""
"try:\n"
"    fp = open(\"myfile\")\n"
"except PermissionError:\n"
"    return \"some default data\"\n"
"else:\n"
"    with fp:\n"
"        return fp.read()"

#: ../../library/os.rst:2095
msgid ""
"I/O operations may fail even when :func:`access` indicates that they would "
"succeed, particularly for operations on network filesystems which may have "
"permissions semantics beyond the usual POSIX permission-bit model."
msgstr ""
"即使 :func:`access` 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是对网络文件系统的操作，其权限语义可能超出常规的 POSIX "
"权限位模型。"

#: ../../library/os.rst:2099
msgid "Added the *dir_fd*, *effective_ids*, and *follow_symlinks* parameters."
msgstr "添加 *dir_fd*、*effective_ids* 和 *follow_symlinks* 参数。"

#: ../../library/os.rst:2111
msgid ""
"Values to pass as the *mode* parameter of :func:`access` to test the "
"existence, readability, writability and executability of *path*, "
"respectively."
msgstr "作为 :func:`access` 的 *mode* 参数的可选值，分别测试 *path* 的存在性、可读性、可写性和可执行性。"

#: ../../library/os.rst:2120
msgid "Change the current working directory to *path*."
msgstr "将当前工作目录更改为 *path*。"

#: ../../library/os.rst:2122
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`.  "
"The descriptor must refer to an opened directory, not an open file."
msgstr "本函数支持 :ref:`指定文件描述符为参数 <path_fd>`。其中，描述符必须指向打开的目录，不能是打开的文件。"

#: ../../library/os.rst:2125
msgid ""
"This function can raise :exc:`OSError` and subclasses such as "
":exc:`FileNotFoundError`, :exc:`PermissionError`, and "
":exc:`NotADirectoryError`."
msgstr ""
"本函数可以抛出 :exc:`OSError` 及其子类的异常，如 "
":exc:`FileNotFoundError`、:exc:`PermissionError` 和 :exc:`NotADirectoryError` "
"异常。"

#: ../../library/os.rst:2128 ../../library/os.rst:2266
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chdir`` with argument "
"``path``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.chdir`` 并附带参数 ``path``。"

#: ../../library/os.rst:2130
msgid ""
"Added support for specifying *path* as a file descriptor on some platforms."
msgstr "在某些平台上新增支持将 *path* 参数指定为文件描述符。"

#: ../../library/os.rst:2140
msgid ""
"Set the flags of *path* to the numeric *flags*. *flags* may take a "
"combination (bitwise OR) of the following values (as defined in the "
":mod:`stat` module):"
msgstr ""
"将 *path* 的 flags 设置为其他由数字表示的 *flags*。*flags* 可以用以下值按位或组合起来（以下值在 :mod:`stat` "
"模块中定义）："

#: ../../library/os.rst:2143
msgid ":const:`stat.UF_NODUMP`"
msgstr ":const:`stat.UF_NODUMP`"

#: ../../library/os.rst:2144
msgid ":const:`stat.UF_IMMUTABLE`"
msgstr ":const:`stat.UF_IMMUTABLE`"

#: ../../library/os.rst:2145
msgid ":const:`stat.UF_APPEND`"
msgstr ":const:`stat.UF_APPEND`"

#: ../../library/os.rst:2146
msgid ":const:`stat.UF_OPAQUE`"
msgstr ":const:`stat.UF_OPAQUE`"

#: ../../library/os.rst:2147
msgid ":const:`stat.UF_NOUNLINK`"
msgstr ":const:`stat.UF_NOUNLINK`"

#: ../../library/os.rst:2148
msgid ":const:`stat.UF_COMPRESSED`"
msgstr ":const:`stat.UF_COMPRESSED`"

#: ../../library/os.rst:2149
msgid ":const:`stat.UF_HIDDEN`"
msgstr ":const:`stat.UF_HIDDEN`"

#: ../../library/os.rst:2150
msgid ":const:`stat.SF_ARCHIVED`"
msgstr ":const:`stat.SF_ARCHIVED`"

#: ../../library/os.rst:2151
msgid ":const:`stat.SF_IMMUTABLE`"
msgstr ":const:`stat.SF_IMMUTABLE`"

#: ../../library/os.rst:2152
msgid ":const:`stat.SF_APPEND`"
msgstr ":const:`stat.SF_APPEND`"

#: ../../library/os.rst:2153
msgid ":const:`stat.SF_NOUNLINK`"
msgstr ":const:`stat.SF_NOUNLINK`"

#: ../../library/os.rst:2154
msgid ":const:`stat.SF_SNAPSHOT`"
msgstr ":const:`stat.SF_SNAPSHOT`"

#: ../../library/os.rst:2156
msgid ""
"This function can support :ref:`not following symlinks <follow_symlinks>`."
msgstr "本函数支持 :ref:`不跟踪符号链接 <follow_symlinks>`。"

#: ../../library/os.rst:2158 ../../library/os.rst:2292
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chflags`` with arguments "
"``path``, ``flags``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.chflags`` 并附带参数 ``path``, ``flags``。"

#: ../../library/os.rst:2162
msgid "Added the *follow_symlinks* parameter."
msgstr "增加了 *follow_symlinks* 形参。"

#: ../../library/os.rst:2171
msgid ""
"Change the mode of *path* to the numeric *mode*. *mode* may take one of the "
"following values (as defined in the :mod:`stat` module) or bitwise ORed "
"combinations of them:"
msgstr ""
"将 *path* 的 mode 更改为其他由数字表示的 *mode*。*mode* 可以用以下值之一，也可以将它们按位或组合起来（以下值在 "
":mod:`stat` 模块中定义）："

#: ../../library/os.rst:2175
msgid ":const:`stat.S_ISUID`"
msgstr ":const:`stat.S_ISUID`"

#: ../../library/os.rst:2176
msgid ":const:`stat.S_ISGID`"
msgstr ":const:`stat.S_ISGID`"

#: ../../library/os.rst:2177
msgid ":const:`stat.S_ENFMT`"
msgstr ":const:`stat.S_ENFMT`"

#: ../../library/os.rst:2178
msgid ":const:`stat.S_ISVTX`"
msgstr ":const:`stat.S_ISVTX`"

#: ../../library/os.rst:2179
msgid ":const:`stat.S_IREAD`"
msgstr ":const:`stat.S_IREAD`"

#: ../../library/os.rst:2180
msgid ":const:`stat.S_IWRITE`"
msgstr ":const:`stat.S_IWRITE`"

#: ../../library/os.rst:2181
msgid ":const:`stat.S_IEXEC`"
msgstr ":const:`stat.S_IEXEC`"

#: ../../library/os.rst:2182
msgid ":const:`stat.S_IRWXU`"
msgstr ":const:`stat.S_IRWXU`"

#: ../../library/os.rst:2183
msgid ":const:`stat.S_IRUSR`"
msgstr ":const:`stat.S_IRUSR`"

#: ../../library/os.rst:2184
msgid ":const:`stat.S_IWUSR`"
msgstr ":const:`stat.S_IWUSR`"

#: ../../library/os.rst:2185
msgid ":const:`stat.S_IXUSR`"
msgstr ":const:`stat.S_IXUSR`"

#: ../../library/os.rst:2186
msgid ":const:`stat.S_IRWXG`"
msgstr ":const:`stat.S_IRWXG`"

#: ../../library/os.rst:2187
msgid ":const:`stat.S_IRGRP`"
msgstr ":const:`stat.S_IRGRP`"

#: ../../library/os.rst:2188
msgid ":const:`stat.S_IWGRP`"
msgstr ":const:`stat.S_IWGRP`"

#: ../../library/os.rst:2189
msgid ":const:`stat.S_IXGRP`"
msgstr ":const:`stat.S_IXGRP`"

#: ../../library/os.rst:2190
msgid ":const:`stat.S_IRWXO`"
msgstr ":const:`stat.S_IRWXO`"

#: ../../library/os.rst:2191
msgid ":const:`stat.S_IROTH`"
msgstr ":const:`stat.S_IROTH`"

#: ../../library/os.rst:2192
msgid ":const:`stat.S_IWOTH`"
msgstr ":const:`stat.S_IWOTH`"

#: ../../library/os.rst:2193
msgid ":const:`stat.S_IXOTH`"
msgstr ":const:`stat.S_IXOTH`"

#: ../../library/os.rst:2195 ../../library/os.rst:2228
#: ../../library/os.rst:3620
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`, "
":ref:`paths relative to directory descriptors <dir_fd>` and :ref:`not "
"following symlinks <follow_symlinks>`."
msgstr ""
"本函数支持 :ref:`指定文件描述符 <path_fd>`、:ref:`指定基于目录描述符的相对路径 <dir_fd>` 和 "
":ref:`不跟踪符号链接 <follow_symlinks>`。"

#: ../../library/os.rst:2201
msgid ""
"Although Windows supports :func:`chmod`, you can only set the file's read-"
"only flag with it (via the ``stat.S_IWRITE`` and ``stat.S_IREAD`` constants "
"or a corresponding integer value).  All other bits are ignored. The default "
"value of *follow_symlinks* is ``False`` on Windows."
msgstr ""
"尽管 Windows 支持 :func:`chmod`，但你只能用它设置文件的只读旗标（通过 ``stat.S_IWRITE`` 和 "
"``stat.S_IREAD`` 常量或对应的整数值）。 所有其他旗标位都会被忽略。 在 Windows 上 *follow_symlinks* "
"的默认值为 ``False``。"

#: ../../library/os.rst:2211 ../../library/os.rst:2242
msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd* and *follow_symlinks* arguments."
msgstr "添加了指定 *path* 为文件描述符的支持，以及 *dir_fd* 和 *follow_symlinks* 参数。"

#: ../../library/os.rst:2218
msgid ""
"Added support for a file descriptor and the *follow_symlinks* argument on "
"Windows."
msgstr "在 Windows 上增加了对文件描述符和 *follow_symlinks* 参数的支持。"

#: ../../library/os.rst:2225
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  To "
"leave one of the ids unchanged, set it to -1."
msgstr "将 *path* 的用户和组 ID 分别修改为数字形式的 *uid* 和 *gid*。若要使其中某个 ID 保持不变，请将其置为 -1。"

#: ../../library/os.rst:2232
msgid ""
"See :func:`shutil.chown` for a higher-level function that accepts names in "
"addition to numeric ids."
msgstr "参见更高阶的函数 :func:`shutil.chown`，除了数字 ID 之外，它也接受名称。"

#: ../../library/os.rst:2246
msgid "Supports a :term:`path-like object`."
msgstr "支持 :term:`类路径对象 <path-like object>`。"

#: ../../library/os.rst:2252
msgid "Change the root directory of the current process to *path*."
msgstr "将当前进程的根目录更改为 *path*。"

#: ../../library/os.rst:2262
msgid ""
"Change the current working directory to the directory represented by the "
"file descriptor *fd*.  The descriptor must refer to an opened directory, not"
" an open file.  As of Python 3.3, this is equivalent to ``os.chdir(fd)``."
msgstr ""
"将当前工作目录更改为文件描述符 *fd* 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 "
"``os.chdir(fd)``。"

#: ../../library/os.rst:2273
msgid "Return a string representing the current working directory."
msgstr "返回表示当前工作目录的字符串。"

#: ../../library/os.rst:2278
msgid "Return a bytestring representing the current working directory."
msgstr "返回表示当前工作目录的字节串 (bytestring)。"

#: ../../library/os.rst:2280
msgid ""
"The function now uses the UTF-8 encoding on Windows, rather than the ANSI "
"code page: see :pep:`529` for the rationale. The function is no longer "
"deprecated on Windows."
msgstr ""
"在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是 ANSI 代码页：请参看 :pep:`529` 了解具体原因。 该函数在 "
"Windows 上不再被弃用。"

#: ../../library/os.rst:2288
msgid ""
"Set the flags of *path* to the numeric *flags*, like :func:`chflags`, but do"
" not follow symbolic links.  As of Python 3.3, this is equivalent to "
"``os.chflags(path, flags, follow_symlinks=False)``."
msgstr ""
"将 *path* 的 flags 设置为其他由数字表示的 *flags*，与 :func:`chflags` 类似，但不跟踪符号链接。从 Python "
"3.3 开始，它等效于 ``os.chflags(path, flags, follow_symlinks=False)``。"

#: ../../library/os.rst:2302
msgid ""
"Change the mode of *path* to the numeric *mode*. If path is a symlink, this "
"affects the symlink rather than the target.  See the docs for :func:`chmod` "
"for possible values of *mode*.  As of Python 3.3, this is equivalent to "
"``os.chmod(path, mode, follow_symlinks=False)``."
msgstr ""
"将 *path* 的权限状态修改为 *mode*。如果 path 是符号链接，则影响符号链接本身而非链接目标。可以参考 :func:`chmod` "
"中列出 *mode* 的可用值。从 Python 3.3 开始，它等效于 ``os.chmod(path, mode, "
"follow_symlinks=False)``。"

#: ../../library/os.rst:2307
msgid ""
"``lchmod()`` is not part of POSIX, but Unix implementations may have it if "
"changing the mode of symbolic links is supported."
msgstr "``lchmod()`` 不是 POSIX 的一部分，但 Unix 实现如果支持修改符号链接的模式则可能包含它。"

#: ../../library/os.rst:2322
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"This function will not follow symbolic links.  As of Python 3.3, this is "
"equivalent to ``os.chown(path, uid, gid, follow_symlinks=False)``."
msgstr ""
"将 *path* 的用户和组 ID 分别修改为数字形式的 *uid* 和 *gid*，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 "
"``os.chown(path, uid, gid, follow_symlinks=False)``。"

#: ../../library/os.rst:2336
msgid "Create a hard link pointing to *src* named *dst*."
msgstr "创建一个指向 *src* 的硬链接，名为 *dst*。"

#: ../../library/os.rst:2338
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`, and "
":ref:`not following symlinks <follow_symlinks>`. The default value of "
"*follow_symlinks* is ``False`` on Windows."
msgstr ""

#: ../../library/os.rst:2343
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.link`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.link`` 并附带参数 "
"``src``、``dst``、``src_dir_fd``、``dst_dir_fd``。"

#: ../../library/os.rst:2347 ../../library/os.rst:4617
msgid "Added Windows support."
msgstr "添加了对 Windows 的支持。"

#: ../../library/os.rst:2350
msgid ""
"Added the *src_dir_fd*, *dst_dir_fd*, and *follow_symlinks* parameters."
msgstr "增加了 *src_dir_fd*, *dst_dir_fd* 和 *follow_symlinks* 形参。"

#: ../../library/os.rst:2353 ../../library/os.rst:2777
#: ../../library/os.rst:2814 ../../library/os.rst:3542
msgid "Accepts a :term:`path-like object` for *src* and *dst*."
msgstr "接受一个 :term:`类路径对象 <path-like object>` 作为 *src* 和 *dst*。"

#: ../../library/os.rst:2359
msgid ""
"Return a list containing the names of the entries in the directory given by "
"*path*.  The list is in arbitrary order, and does not include the special "
"entries ``'.'`` and ``'..'`` even if they are present in the directory. If a"
" file is removed from or added to the directory during the call of this "
"function, whether a name for that file be included is unspecified."
msgstr ""
"返回一个包含由 *path* 指定目录中条目名称组成的列表。 该列表按任意顺序排列，并且不包括特殊条目 ``'.'`` 和 "
"``'..'``，即使它们存在于目录中。 如果有文件在调用此函数期间在被移除或添加到目录中，是否要包括该文件的名称并没有规定。"

#: ../../library/os.rst:2365
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes`` "
"(directly or indirectly through the :class:`PathLike` interface), the "
"filenames returned will also be of type ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path* 可以是 :term:`类路径对象 <path-like object>`。如果 *path* 是（直接传入或通过 "
":class:`PathLike` 接口间接传入） ``bytes`` 类型，则返回的文件名也将是 ``bytes`` 类型，其他情况下是 "
"``str`` 类型。"

#: ../../library/os.rst:2370 ../../library/os.rst:2862
msgid ""
"This function can also support :ref:`specifying a file descriptor "
"<path_fd>`; the file descriptor must refer to a directory."
msgstr "本函数也支持 :ref:`指定文件描述符为参数 <path_fd>`，其中描述符必须指向目录。"

#: ../../library/os.rst:2373
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listdir`` with argument "
"``path``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.listdir`` 并附带参数 ``path``。"

#: ../../library/os.rst:2376
msgid "To encode ``str`` filenames to ``bytes``, use :func:`~os.fsencode`."
msgstr "要将 ``str`` 类型的文件名编码为 ``bytes``，请使用 :func:`~os.fsencode`。"

#: ../../library/os.rst:2380
msgid ""
"The :func:`scandir` function returns directory entries along with file "
"attribute information, giving better performance for many common use cases."
msgstr ":func:`scandir` 函数返回目录内文件名的同时，也返回文件属性信息，它在某些具体情况下能提供更好的性能。"

#: ../../library/os.rst:2384
msgid "The *path* parameter became optional."
msgstr "*path* 变为可选参数。"

#: ../../library/os.rst:2387 ../../library/os.rst:3401
msgid "Added support for specifying *path* as an open file descriptor."
msgstr "新增支持将 *path* 参数指定为打开的文件描述符。"

#: ../../library/os.rst:2396
msgid "Return a list containing the names of drives on a Windows system."
msgstr "返回一个包括Windows系统上驱动名称的列表。"

#: ../../library/os.rst:2398
msgid ""
"A drive name typically looks like ``'C:\\\\'``. Not every drive name will be"
" associated with a volume, and some may be inaccessible for a variety of "
"reasons, including permissions, network connectivity or missing media. This "
"function does not test for access."
msgstr ""
"驱动器名称通常的形式如 ``'C:\\\\'``。 "
"并非每个驱动器名都会关联到特定的卷，有些驱动器名可能出于各种原因而无法访问，包括权限、网络连接或介质丢失等。 本函数不会测试可访问性。"

#: ../../library/os.rst:2403
msgid ""
"May raise :exc:`OSError` if an error occurs collecting the drive names."
msgstr "如果在收集驱动器名时发生错误则可能引发 :exc:`OSError`。"

#: ../../library/os.rst:2406
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listdrives`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``os.listdrives``。"

#: ../../library/os.rst:2415
msgid ""
"Return a list containing the mount points for a volume on a Windows system."
msgstr "返回一个包含 Windows 系统上指向卷的加载点的列表。"

#: ../../library/os.rst:2418
msgid ""
"*volume* must be represented as a GUID path, like those returned by "
":func:`os.listvolumes`. Volumes may be mounted in multiple locations or not "
"at all. In the latter case, the list will be empty. Mount points that are "
"not associated with a volume will not be returned by this function."
msgstr ""
"*volume* 必须表示为 GUID 路径，如 :func:`os.listvolumes` 所返回的值。 卷可能被挂载到多个位置也可能根本未挂载。 "
"在后一种情况下，该列表将为空。 此函数不会返回没有关联到卷的挂载点。"

#: ../../library/os.rst:2424
msgid ""
"The mount points return by this function will be absolute paths, and may be "
"longer than the drive name."
msgstr "此函数返回的挂载点将为绝对路径，并可能比驱动器名称更长。"

#: ../../library/os.rst:2427
msgid ""
"Raises :exc:`OSError` if the volume is not recognized or if an error occurs "
"collecting the paths."
msgstr "如果卷未被识别或者如果在获取路径时发生错误则会引发 :exc:`OSError`。"

#: ../../library/os.rst:2430
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listmounts`` with argument "
"``volume``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.listmounts`` 并附带参数 ``volume``。"

#: ../../library/os.rst:2439
msgid "Return a list containing the volumes in the system."
msgstr "返回一个包含系统中的卷的列表。"

#: ../../library/os.rst:2441
msgid ""
"Volumes are typically represented as a GUID path that looks like "
"``\\\\?\\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\\``. Files can usually"
" be accessed through a GUID path, permissions allowing. However, users are "
"generally not familiar with them, and so the recommended use of this "
"function is to retrieve mount points using :func:`os.listmounts`."
msgstr ""
"卷通常被表示为一个 GUID 路径如 ``\\\\?\\Volume{xxxxxxxx-xxxx-xxxx-xxxx-"
"xxxxxxxxxxxx}\\``。 文件通常可通过 GUID 路径来访问，如果权限允许的话。 "
"但是，用户往往并不熟悉这种路径，所以此函数的推荐用法是使用 :func:`os.listmounts` 来获取加载点。"

#: ../../library/os.rst:2448
msgid "May raise :exc:`OSError` if an error occurs collecting the volumes."
msgstr "如果在收集卷时发生错误则可能引发 :exc:`OSError`。"

#: ../../library/os.rst:2450
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listvolumes`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``os.listvolumes``。"

#: ../../library/os.rst:2459
msgid ""
"Perform the equivalent of an :c:func:`!lstat` system call on the given path."
" Similar to :func:`~os.stat`, but does not follow symbolic links. Return a "
":class:`stat_result` object."
msgstr ""
"在给定的路径上执行 :c:func:`!lstat` 系统调用的等价物。 类似于 :func:`~os.stat`，但不会跟随符号链接。 返回一个 "
":class:`stat_result` 对象。"

#: ../../library/os.rst:2463
msgid ""
"On platforms that do not support symbolic links, this is an alias for "
":func:`~os.stat`."
msgstr "在不支持符号链接的平台上，本函数是 :func:`~os.stat` 的别名。"

#: ../../library/os.rst:2466
msgid ""
"As of Python 3.3, this is equivalent to ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``."
msgstr ""
"从 Python 3.3 起，此功能等价于 ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``。"

#: ../../library/os.rst:2469 ../../library/os.rst:2511
#: ../../library/os.rst:2579 ../../library/os.rst:2607
#: ../../library/os.rst:2681
msgid ""
"This function can also support :ref:`paths relative to directory descriptors"
" <dir_fd>`."
msgstr "本函数支持 :ref:`基于目录描述符的相对路径 <dir_fd>`。"

#: ../../library/os.rst:2476 ../../library/os.rst:2690
#: ../../library/os.rst:3535
msgid "Added support for Windows 6.0 (Vista) symbolic links."
msgstr "添加对 Windows 6.0 (Vista) 符号链接的支持。"

#: ../../library/os.rst:2485
msgid ""
"On Windows, now opens reparse points that represent another path (name "
"surrogates), including symbolic links and directory junctions. Other kinds "
"of reparse points are resolved by the operating system as for "
":func:`~os.stat`."
msgstr ""
"目前在 Windows 上，遇到表示另一个路径的重解析点（即名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解析点由 "
":func:`~os.stat` 交由操作系统解析。"

#: ../../library/os.rst:2494
msgid "Create a directory named *path* with numeric mode *mode*."
msgstr "创建一个名为 *path* 的目录，应用以数字表示的权限模式 *mode*。"

#: ../../library/os.rst:2496
msgid ""
"If the directory already exists, :exc:`FileExistsError` is raised. If a "
"parent directory in the path does not exist, :exc:`FileNotFoundError` is "
"raised."
msgstr ""
"如果目录已经存在， :exc:`FileExistsError` 会被提出。如果路径中的父目录不存在，则会引发 "
":exc:`FileNotFoundError` 。"

#: ../../library/os.rst:2501
msgid ""
"On some systems, *mode* is ignored.  Where it is used, the current umask "
"value is first masked out.  If bits other than the last 9 (i.e. the last 3 "
"digits of the octal representation of the *mode*) are set, their meaning is "
"platform-dependent.  On some platforms, they are ignored and you should call"
" :func:`chmod` explicitly to set them."
msgstr ""
"某些系统会忽略 *mode*。如果没有忽略它，那么将首先从它中减去当前的 umask 值。如果除最后 9 位（即 *mode* 八进制的最后 3 "
"位）之外，还设置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽略，应显式调用 :func:`chmod` 进行设置。"

#: ../../library/os.rst:2507
msgid ""
"On Windows, a *mode* of ``0o700`` is specifically handled to apply access "
"control to the new directory such that only the current user and "
"administrators have access. Other values of *mode* are ignored."
msgstr ""
"在 Windows 系统中，*mode* 值 ``0o700`` 被专门用于对新目录实施访问控制，使其只有当前用户和管理员才能访问。 其他值的 "
"*mode* 将被忽略。"

#: ../../library/os.rst:2514
msgid ""
"It is also possible to create temporary directories; see the :mod:`tempfile`"
" module's :func:`tempfile.mkdtemp` function."
msgstr "如果需要创建临时目录，请参阅 :mod:`tempfile` 模块中的 :func:`tempfile.mkdtemp` 函数。"

#: ../../library/os.rst:2517 ../../library/os.rst:2554
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.mkdir`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.mkdir`` 并附带参数 ``path``, ``mode``, "
"``dir_fd``。"

#: ../../library/os.rst:2525
msgid "Windows now handles a *mode* of ``0o700``."
msgstr "Windows 系统现在使用 *mode* 值 ``0o700``"

#: ../../library/os.rst:2535
msgid ""
"Recursive directory creation function.  Like :func:`mkdir`, but makes all "
"intermediate-level directories needed to contain the leaf directory."
msgstr "递归目录创建函数。与 :func:`mkdir` 类似，但会自动创建到达最后一级目录所需要的中间目录。"

#: ../../library/os.rst:2538
msgid ""
"The *mode* parameter is passed to :func:`mkdir` for creating the leaf "
"directory; see :ref:`the mkdir() description <mkdir_modebits>` for how it is"
" interpreted.  To set the file permission bits of any newly created parent "
"directories you can set the umask before invoking :func:`makedirs`.  The "
"file permission bits of existing parent directories are not changed."
msgstr ""
"*mode* 形参会被传递给 :func:`mkdir` 用来创建最后一级目录；请参阅 :ref:`mkdir() 的说明 "
"<mkdir_modebits>` 了解其解读方式。 要设置任何新建父目录的权限你可以在唤起 :func:`makedirs` 之前设置掩码。 "
"现有父目录的文件权限不会被更改。"

#: ../../library/os.rst:2544
msgid ""
"If *exist_ok* is ``False`` (the default), a :exc:`FileExistsError` is raised"
" if the target directory already exists."
msgstr ""
"如果 *exist_ok* 为 ``False`` (默认值)，则如果目标目录已存在将会引发 :exc:`FileExistsError`。"

#: ../../library/os.rst:2549
msgid ""
":func:`makedirs` will become confused if the path elements to create include"
" :data:`pardir` (eg. \"..\" on UNIX systems)."
msgstr ""
"如果要创建的路径元素包含 :data:`pardir` (如 UNIX 系统中的 \"..\") :func:`makedirs` 将无法明确目标。"

#: ../../library/os.rst:2552
msgid "This function handles UNC paths correctly."
msgstr "本函数能正确处理 UNC 路径。"

#: ../../library/os.rst:2556
msgid "Added the *exist_ok* parameter."
msgstr "增加了 *exist_ok* 形参。"

#: ../../library/os.rst:2561
msgid ""
"Before Python 3.4.1, if *exist_ok* was ``True`` and the directory existed, "
":func:`makedirs` would still raise an error if *mode* did not match the mode"
" of the existing directory. Since this behavior was impossible to implement "
"safely, it was removed in Python 3.4.1. See :issue:`21082`."
msgstr ""
"在 Python 3.4.1 以前，如果 *exist_ok* 为 ``True``，且目录已存在，且 *mode* "
"与现有目录的权限不匹配，:func:`makedirs` 仍会抛出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 "
"中将该行为删除。请参阅 :issue:`21082`。"

#: ../../library/os.rst:2569
msgid ""
"The *mode* argument no longer affects the file permission bits of newly "
"created intermediate-level directories."
msgstr "*mode* 参数不会再影响新创建的中间目录的文件权限位。"

#: ../../library/os.rst:2576
msgid ""
"Create a FIFO (a named pipe) named *path* with numeric mode *mode*. The "
"current umask value is first masked out from the mode."
msgstr ""
"创建一个名为 *path* 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 *mode*。将从 mode 中首先减去当前的 "
"umask 值。"

#: ../../library/os.rst:2582
msgid ""
"FIFOs are pipes that can be accessed like regular files.  FIFOs exist until "
"they are deleted (for example with :func:`os.unlink`). Generally, FIFOs are "
"used as rendezvous between \"client\" and \"server\" type processes: the "
"server opens the FIFO for reading, and the client opens it for writing.  "
"Note that :func:`mkfifo` doesn't open the FIFO --- it just creates the "
"rendezvous point."
msgstr ""
"FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用 :func:`os.unlink`），会一直存在。通常，FIFO "
"用作“客户端”和“服务器”进程之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入。请注意，:func:`mkfifo` "
"不会打开 FIFO --- 它只是创建汇合点。"

#: ../../library/os.rst:2599
msgid ""
"Create a filesystem node (file, device special file or named pipe) named "
"*path*. *mode* specifies both the permissions to use and the type of node to"
" be created, being combined (bitwise OR) with one of ``stat.S_IFREG``, "
"``stat.S_IFCHR``, ``stat.S_IFBLK``, and ``stat.S_IFIFO`` (those constants "
"are available in :mod:`stat`).  For ``stat.S_IFCHR`` and ``stat.S_IFBLK``, "
"*device* defines the newly created device special file (probably using "
":func:`os.makedev`), otherwise it is ignored."
msgstr ""
"创建一个名为 *path* 的文件系统节点（文件，设备专用文件或命名管道）。*mode* 指定权限和节点类型，方法是将权限与下列节点类型 "
"``stat.S_IFREG``、``stat.S_IFCHR``、``stat.S_IFBLK`` 和 ``stat.S_IFIFO`` "
"之一（按位或）组合（这些常量可以在 :mod:`stat` 模块中找到）。对于 ``stat.S_IFCHR`` 和 "
"``stat.S_IFBLK``，*device* 参数指定了新创建的设备专用文件（可能会用到 "
":func:`os.makedev`），否则该参数将被忽略。"

#: ../../library/os.rst:2621
msgid ""
"Extract the device major number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`)."
msgstr ""
"根据原始设备编号提取设备主编号（通常为来自 :c:struct:`stat` 的 :attr:`st_dev` 或 :attr:`st_rdev` "
"字段）。"

#: ../../library/os.rst:2627
msgid ""
"Extract the device minor number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`)."
msgstr ""
"根据原始设备编号提取设备次编号（通常为来自 :c:struct:`stat` 的 :attr:`st_dev` 或 :attr:`st_rdev` "
"字段）。"

#: ../../library/os.rst:2633
msgid "Compose a raw device number from the major and minor device numbers."
msgstr "将主设备号和次设备号组合成原始设备号。"

#: ../../library/os.rst:2638
msgid ""
"Return system configuration information relevant to a named file. *name* "
"specifies the configuration value to retrieve; it may be a string which is "
"the name of a defined system value; these names are specified in a number of"
" standards (POSIX.1, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well.  The names known to the host operating system are "
"given in the ``pathconf_names`` dictionary.  For configuration variables not"
" included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"返回所给名称的文件有关的系统配置信息。*name* "
"指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 "
"等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 ``pathconf_names`` "
"字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 *name*。"

#: ../../library/os.rst:2651 ../../library/os.rst:3394
#: ../../library/os.rst:3563
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`."
msgstr "本函数支持 :ref:`指定文件描述符为参数 <path_fd>`。"

#: ../../library/os.rst:2662
msgid ""
"Dictionary mapping names accepted by :func:`pathconf` and :func:`fpathconf` "
"to the integer values defined for those names by the host operating system."
"  This can be used to determine the set of names known to the system."
msgstr ""
"字典，表示映射关系，为 :func:`pathconf` 和 :func:`fpathconf` "
"可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。"

#: ../../library/os.rst:2671
msgid ""
"Return a string representing the path to which the symbolic link points.  "
"The result may be either an absolute or relative pathname; if it is "
"relative, it may be converted to an absolute pathname using "
"``os.path.join(os.path.dirname(path), result)``."
msgstr ""
"返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 "
"``os.path.join(os.path.dirname(path), result)`` 转换为绝对路径。"

#: ../../library/os.rst:2676
msgid ""
"If the *path* is a string object (directly or indirectly through a "
":class:`PathLike` interface), the result will also be a string object, and "
"the call may raise a UnicodeDecodeError. If the *path* is a bytes object "
"(direct or indirectly), the result will be a bytes object."
msgstr ""
"如果 *path* 是字符串对象（直接传入或通过 :class:`PathLike` 接口间接传入），则结果也将是字符串对象，且此类调用可能会引发 "
"UnicodeDecodeError。如果 *path* 是字节对象（直接传入或间接传入），则结果将会是字节对象。"

#: ../../library/os.rst:2684
msgid ""
"When trying to resolve a path that may contain links, use "
":func:`~os.path.realpath` to properly handle recursion and platform "
"differences."
msgstr "当尝试解析的路径可能含有链接时，请改用 :func:`~os.path.realpath` 以正确处理递归和平台差异。"

#: ../../library/os.rst:2696
msgid "Accepts a :term:`path-like object` on Unix."
msgstr "在 Unix 上可以接受一个 :term:`类路径对象 <path-like object>`。"

#: ../../library/os.rst:2699
msgid "Accepts a :term:`path-like object` and a bytes object on Windows."
msgstr "在 Windows 上接受 :term:`类路径对象 <path-like object>` 和字节对象。"

#: ../../library/os.rst:2702
msgid ""
"Added support for directory junctions, and changed to return the "
"substitution path (which typically includes ``\\\\?\\`` prefix) rather than "
"the optional \"print name\" field that was previously returned."
msgstr ""
"增加了对目录链接的支持，且返回值改为了“替换路径”的形式（通常带有 ``\\\\?\\`` 前缀），而不是先前那样返回可选的 \"print "
"name\" 字段。"

#: ../../library/os.rst:2708
msgid ""
"Remove (delete) the file *path*.  If *path* is a directory, an "
":exc:`OSError` is raised.  Use :func:`rmdir` to remove directories. If the "
"file does not exist, a :exc:`FileNotFoundError` is raised."
msgstr ""
"移除（删除）文件 *path*。 如果 *path* 是目录，则会引发 :exc:`OSError`。 请使用 :func:`rmdir` 来移除目录。"
" 如果文件不存在，则会引发 :exc:`FileNotFoundError`。"

#: ../../library/os.rst:2712 ../../library/os.rst:2825
#: ../../library/os.rst:3514
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr "本函数支持 :ref:`基于目录描述符的相对路径 <dir_fd>`。"

#: ../../library/os.rst:2715
msgid ""
"On Windows, attempting to remove a file that is in use causes an exception "
"to be raised; on Unix, the directory entry is removed but the storage "
"allocated to the file is not made available until the original file is no "
"longer in use."
msgstr ""
"在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix "
"上，虽然该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文件不再使用为止。"

#: ../../library/os.rst:2719
msgid "This function is semantically identical to :func:`unlink`."
msgstr "本函数在语义上与 :func:`unlink` 相同。"

#: ../../library/os.rst:2721 ../../library/os.rst:2743
#: ../../library/os.rst:3585
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.remove`` with arguments "
"``path``, ``dir_fd``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.remove`` 并附带参数 ``path``, ``dir_fd``。"

#: ../../library/os.rst:2734
msgid ""
"Remove directories recursively.  Works like :func:`rmdir` except that, if "
"the leaf directory is successfully removed, :func:`removedirs`  tries to "
"successively remove every parent directory mentioned in  *path* until an "
"error is raised (which is ignored, because it generally means that a parent "
"directory is not empty). For example, ``os.removedirs('foo/bar/baz')`` will "
"first remove the directory ``'foo/bar/baz'``, and then remove ``'foo/bar'`` "
"and ``'foo'`` if they are empty. Raises :exc:`OSError` if the leaf directory"
" could not be successfully removed."
msgstr ""
"递归删除目录。工作方式类似于 :func:`rmdir`，不同之处在于，如果成功删除了末尾一级目录，:func:`removedirs` 会尝试依次删除"
" *path* "
"中提到的每个父目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是空目录）。例如，``os.removedirs('foo/bar/baz')``"
" 将首先删除目录 ``'foo/bar/baz'``，然后如果 ``'foo/bar'`` 和 ``'foo'`` "
"为空，则继续删除它们。如果无法成功删除末尾一级目录，则抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:2751
msgid ""
"Rename the file or directory *src* to *dst*. If *dst* exists, the operation "
"will fail with an :exc:`OSError` subclass in a number of cases:"
msgstr ""
"将文件或目录 *src* 重命名为 *dst*。如果 *dst* 已存在，则下列情况下将会操作失败，并抛出 :exc:`OSError` 的子类："

#: ../../library/os.rst:2754
msgid ""
"On Windows, if *dst* exists a :exc:`FileExistsError` is always raised. The "
"operation may fail if *src* and *dst* are on different filesystems. Use "
":func:`shutil.move` to support moves to a different filesystem."
msgstr ""
"在 Windows 上，如果 *dst* 存在则总是会引发 :exc:`FileExistsError`。 如果 *src* 和 *dst* "
"是在不同的文件系统上则此操作可能会失败。 请使用 :func:`shutil.move` 以支持移动到不同的文件系统。"

#: ../../library/os.rst:2758
msgid ""
"On Unix, if *src* is a file and *dst* is a directory or vice-versa, an "
":exc:`IsADirectoryError` or a :exc:`NotADirectoryError` will be raised "
"respectively.  If both are directories and *dst* is empty, *dst* will be "
"silently replaced.  If *dst* is a non-empty directory, an :exc:`OSError` is "
"raised. If both are files, *dst* will be replaced silently if the user has "
"permission.  The operation may fail on some Unix flavors if *src* and *dst* "
"are on different filesystems.  If successful, the renaming will be an atomic"
" operation (this is a POSIX requirement)."
msgstr ""
"在 Unix 上，如果 *src* 是文件而 *dst* 是目录，将抛出 :exc:`IsADirectoryError` 异常，反之则抛出 "
":exc:`NotADirectoryError` 异常。如果两者都是目录且 *dst* 为空，则 *dst* 将被静默替换。如果 *dst* "
"是非空目录，则抛出 :exc:`OSError` 异常。如果两者都是文件，则在用户具有权限的情况下，将对 *dst* 进行静默替换。如果 *src* 和"
" *dst* 在不同的文件系统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。"

#: ../../library/os.rst:2767 ../../library/os.rst:2807
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`."
msgstr ""
"本函数支持将 *src_dir_fd* 和 *dst_dir_fd* 中的一个或两个指定为 :ref:`基于目录描述符的相对路径 <dir_fd>`。"

#: ../../library/os.rst:2770
msgid ""
"If you want cross-platform overwriting of the destination, use "
":func:`replace`."
msgstr "如果需要在不同平台上都能替换目标，请使用 :func:`replace`。"

#: ../../library/os.rst:2772 ../../library/os.rst:2793
#: ../../library/os.rst:2810
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rename`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.rename`` 并附带参数 ``src``, ``dst``, "
"``src_dir_fd``, ``dst_dir_fd``。"

#: ../../library/os.rst:2774
msgid "Added the *src_dir_fd* and *dst_dir_fd* parameters."
msgstr "增加了 *src_dir_fd* 和 *dst_dir_fd* 形参。"

#: ../../library/os.rst:2783
msgid ""
"Recursive directory or file renaming function. Works like :func:`rename`, "
"except creation of any intermediate directories needed to make the new "
"pathname good is attempted first. After the rename, directories "
"corresponding to rightmost path segments of the old name will be pruned away"
" using :func:`removedirs`."
msgstr ""
"递归重命名目录或文件。工作方式类似 :func:`rename`，除了会首先创建新路径所需的中间目录。重命名后，将调用 "
":func:`removedirs` 删除旧路径中不需要的目录。"

#: ../../library/os.rst:2790
msgid ""
"This function can fail with the new directory structure made if you lack "
"permissions needed to remove the leaf directory or file."
msgstr "如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的目录结构。"

#: ../../library/os.rst:2795
msgid "Accepts a :term:`path-like object` for *old* and *new*."
msgstr "接受一个 :term:`类路径对象 <path-like object>` 作为 *old* 和 *new*。"

#: ../../library/os.rst:2801
msgid ""
"Rename the file or directory *src* to *dst*.  If *dst* is a non-empty "
"directory, :exc:`OSError` will be raised.  If *dst* exists and is a file, it"
" will be replaced silently if the user has permission.  The operation may "
"fail if *src* and *dst* are on different filesystems.  If successful, the "
"renaming will be an atomic operation (this is a POSIX requirement)."
msgstr ""
"将文件或目录 *src* 重命名为 *dst*。如果 *dst* 是非空目录，将抛出 :exc:`OSError` 异常。如果 *dst* "
"已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。如果 *src* 和 *dst* "
"在不同的文件系统上，本操作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。"

#: ../../library/os.rst:2820
msgid ""
"Remove (delete) the directory *path*.  If the directory does not exist or is"
" not empty, a :exc:`FileNotFoundError` or an :exc:`OSError` is raised "
"respectively.  In order to remove whole directory trees, "
":func:`shutil.rmtree` can be used."
msgstr ""
"移除（删除）目录 *path*。 如果目录不存在或不为空，则会分别引发 :exc:`FileNotFoundError` 或 "
":exc:`OSError`。 要移除整个目录树，可以使用 :func:`shutil.rmtree`。"

#: ../../library/os.rst:2828
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rmdir`` with arguments "
"``path``, ``dir_fd``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.rmdir`` 并附带参数 ``path``, ``dir_fd``。"

#: ../../library/os.rst:2839
msgid ""
"Return an iterator of :class:`os.DirEntry` objects corresponding to the "
"entries in the directory given by *path*. The entries are yielded in "
"arbitrary order, and the special entries ``'.'`` and ``'..'`` are not "
"included.  If a file is removed from or added to the directory after "
"creating the iterator, whether an entry for that file be included is "
"unspecified."
msgstr ""
"返回一个 :class:`os.DirEntry` 对象的迭代器，它们对应于由 *path* 指定目录中的条目。 "
"这些条目会以任意顺序生成，并且不包括特殊条目 ``'.'`` 和 ``'..'``。 "
"如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括该文件对应的条目并没有规定。"

#: ../../library/os.rst:2846
msgid ""
"Using :func:`scandir` instead of :func:`listdir` can significantly increase "
"the performance of code that also needs file type or file attribute "
"information, because :class:`os.DirEntry` objects expose this information if"
" the operating system provides it when scanning a directory. All "
":class:`os.DirEntry` methods may perform a system call, but "
":func:`~os.DirEntry.is_dir` and :func:`~os.DirEntry.is_file` usually only "
"require a system call for symbolic links; :func:`os.DirEntry.stat` always "
"requires a system call on Unix but only requires one for symbolic links on "
"Windows."
msgstr ""
"如果需要文件类型或文件属性信息，使用 :func:`scandir` 代替 :func:`listdir` "
"可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是 :class:`os.DirEntry` 对象，则该对象包含了这些信息。所有 "
":class:`os.DirEntry` 的方法都可能执行一次系统调用，但是 :func:`~os.DirEntry.is_dir` 和 "
":func:`~os.DirEntry.is_file` 通常只在有符号链接时才执行一次系统调用。:func:`os.DirEntry.stat` 在 "
"Unix 上始终需要一次系统调用，而在 Windows 上只在有符号链接时才需要。"

#: ../../library/os.rst:2856
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes`` "
"(directly or indirectly through the :class:`PathLike` interface), the type "
"of the :attr:`~os.DirEntry.name` and :attr:`~os.DirEntry.path` attributes of"
" each :class:`os.DirEntry` will be ``bytes``; in all other circumstances, "
"they will be of type ``str``."
msgstr ""
"*path* 可以是 :term:`类路径对象 <path-like object>`。如果 *path* 是（直接传入或通过 "
":class:`PathLike` 接口间接传入的） ``bytes`` 类型，那么每个 :class:`os.DirEntry` 的 "
":attr:`~os.DirEntry.name` 和 :attr:`~os.DirEntry.path` 属性将是 ``bytes`` "
"类型，其他情况下是 ``str`` 类型。"

#: ../../library/os.rst:2865
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.scandir`` with argument "
"``path``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.scandir`` 并附带参数 ``path``。"

#: ../../library/os.rst:2867
msgid ""
"The :func:`scandir` iterator supports the :term:`context manager` protocol "
"and has the following method:"
msgstr ":func:`scandir` 迭代器支持 :term:`上下文管理 <context manager>` 协议，并具有以下方法："

#: ../../library/os.rst:2872
msgid "Close the iterator and free acquired resources."
msgstr "关闭迭代器并释放占用的资源。"

#: ../../library/os.rst:2874
msgid ""
"This is called automatically when the iterator is exhausted or garbage "
"collected, or when an error happens during iterating.  However it is "
"advisable to call it explicitly or use the :keyword:`with` statement."
msgstr "当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法。但仍建议显式调用它或使用 :keyword:`with` 语句。"

#: ../../library/os.rst:2881
msgid ""
"The following example shows a simple use of :func:`scandir` to display all "
"the files (excluding directories) in the given *path* that don't start with "
"``'.'``. The ``entry.is_file()`` call will generally not make an additional "
"system call::"
msgstr ""
"下面的例子演示了 :func:`scandir` 的简单用法，用来显示给定 *path* 中所有不以 ``'.'`` "
"开头的文件（不包括目录）。``entry.is_file()`` 通常不会增加一次额外的系统调用::"

#: ../../library/os.rst:2886
msgid ""
"with os.scandir(path) as it:\n"
"    for entry in it:\n"
"        if not entry.name.startswith('.') and entry.is_file():\n"
"            print(entry.name)"
msgstr ""
"with os.scandir(path) as it:\n"
"    for entry in it:\n"
"        if not entry.name.startswith('.') and entry.is_file():\n"
"            print(entry.name)"

#: ../../library/os.rst:2893
msgid ""
"On Unix-based systems, :func:`scandir` uses the system's `opendir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_ "
"and `readdir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" functions. On Windows, it uses the Win32 `FindFirstFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ and `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ functions."
msgstr ""
"在基于 Unix 的系统上，:func:`scandir` 使用系统的 `opendir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_ 和"
" `readdir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" 函数。 在 Windows 上，它使用 Win32 `FindFirstFileW <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ 和 `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ 函数。"

#: ../../library/os.rst:2905
msgid ""
"Added support for the :term:`context manager` protocol and the "
":func:`~scandir.close` method.  If a :func:`scandir` iterator is neither "
"exhausted nor explicitly closed a :exc:`ResourceWarning` will be emitted in "
"its destructor."
msgstr ""
"增加了对 :term:`context manager` 协议和 :func:`~scandir.close` 方法的支持。 如果 "
":func:`scandir` 迭代器没有耗尽也没有被显式地关闭则将在其析构器中发出 :exc:`ResourceWarning`。"

#: ../../library/os.rst:2911
msgid "The function accepts a :term:`path-like object`."
msgstr "本函数接受一个 :term:`类路径对象 <path-like object>`。"

#: ../../library/os.rst:2913
msgid "Added support for :ref:`file descriptors <path_fd>` on Unix."
msgstr "在 Unix 上新增支持 :ref:`指定文件描述符为参数 <path_fd>`。"

#: ../../library/os.rst:2919
msgid ""
"Object yielded by :func:`scandir` to expose the file path and other file "
"attributes of a directory entry."
msgstr "由 :func:`scandir` 生成的对象，用于显示目录内某个条目的文件路径和其他文件属性。"

#: ../../library/os.rst:2922
msgid ""
":func:`scandir` will provide as much of this information as possible without"
" making additional system calls. When a ``stat()`` or ``lstat()`` system "
"call is made, the ``os.DirEntry`` object will cache the result."
msgstr ""
":func:`scandir` 将在不进行额外系统调用的情况下，提供尽可能多的此类信息。每次进行 ``stat()`` 或 ``lstat()`` "
"系统调用时，``os.DirEntry`` 对象会将结果缓存下来。"

#: ../../library/os.rst:2926
msgid ""
"``os.DirEntry`` instances are not intended to be stored in long-lived data "
"structures; if you know the file metadata has changed or if a long time has "
"elapsed since calling :func:`scandir`, call ``os.stat(entry.path)`` to fetch"
" up-to-date information."
msgstr ""
"``os.DirEntry`` 实例不适合存储在长期存在的数据结构中，如果你知道文件元数据已更改，或者自调用 :func:`scandir` "
"以来已经经过了很长时间，请调用 ``os.stat(entry.path)`` 来获取最新信息。"

#: ../../library/os.rst:2931
msgid ""
"Because the ``os.DirEntry`` methods can make operating system calls, they "
"may also raise :exc:`OSError`. If you need very fine-grained control over "
"errors, you can catch :exc:`OSError` when calling one of the ``os.DirEntry``"
" methods and handle as appropriate."
msgstr ""
"因为 ``os.DirEntry`` 方法可以进行系统调用，所以它也可能抛出 :exc:`OSError` 异常。如需精确定位错误，可以逐个调用 "
"``os.DirEntry`` 中的方法来捕获 :exc:`OSError`，并适当处理。"

#: ../../library/os.rst:2936
msgid ""
"To be directly usable as a :term:`path-like object`, ``os.DirEntry`` "
"implements the :class:`PathLike` interface."
msgstr ""
"为了能直接用作 :term:`类路径对象 <path-like object>`，``os.DirEntry`` 实现了 "
":class:`PathLike` 接口。"

#: ../../library/os.rst:2939
msgid "Attributes and methods on a ``os.DirEntry`` instance are as follows:"
msgstr "``os.DirEntry`` 实例所包含的属性和方法如下："

#: ../../library/os.rst:2943
msgid ""
"The entry's base filename, relative to the :func:`scandir` *path* argument."
msgstr "本条目的基本文件名，是根据 :func:`scandir` 的 *path* 参数得出的相对路径。"

#: ../../library/os.rst:2946
msgid ""
"The :attr:`name` attribute will be ``bytes`` if the :func:`scandir` *path* "
"argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
"如果 :func:`scandir` 的 *path* 参数是 ``bytes`` 类型，则 :attr:`name` 属性也是 ``bytes`` "
"类型，否则为 ``str``。使用 :func:`~os.fsdecode` 解码 byte 类型的文件名。"

#: ../../library/os.rst:2952
msgid ""
"The entry's full path name: equivalent to ``os.path.join(scandir_path, "
"entry.name)`` where *scandir_path* is the :func:`scandir` *path* argument.  "
"The path is only absolute if the :func:`scandir` *path* argument was "
"absolute.  If the :func:`scandir` *path* argument was a :ref:`file "
"descriptor <path_fd>`, the :attr:`path` attribute is the same as the "
":attr:`name` attribute."
msgstr ""
"本条目的完整路径：等效于 ``os.path.join(scandir_path, entry.name)``，其中 *scandir_path* 就是"
" :func:`scandir` 的 *path* 参数。仅当 :func:`scandir` 的 *path* "
"参数为绝对路径时，本路径才是绝对路径。如果 :func:`scandir` 的 *path* 参数是 :ref:`文件描述符 <path_fd>`，则 "
":attr:`path` 属性与上述 :attr:`name` 属性相同。"

#: ../../library/os.rst:2959
msgid ""
"The :attr:`path` attribute will be ``bytes`` if the :func:`scandir` *path* "
"argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
"如果 :func:`scandir` 的 *path* 参数是 ``bytes`` 类型，则 :attr:`path` 属性也是 ``bytes`` "
"类型，否则为 ``str``。使用 :func:`~os.fsdecode` 解码 byte 类型的文件名。"

#: ../../library/os.rst:2965
msgid "Return the inode number of the entry."
msgstr "返回本条目的索引节点号 (inode number)。"

#: ../../library/os.rst:2967
msgid ""
"The result is cached on the ``os.DirEntry`` object. Use "
"``os.stat(entry.path, follow_symlinks=False).st_ino`` to fetch up-to-date "
"information."
msgstr ""
"这一结果是缓存在 ``os.DirEntry`` 对象中的，请调用 ``os.stat(entry.path, "
"follow_symlinks=False).st_ino`` 来获取最新信息。"

#: ../../library/os.rst:2971
msgid ""
"On the first, uncached call, a system call is required on Windows but not on"
" Unix."
msgstr "一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不需要。"

#: ../../library/os.rst:2976
msgid ""
"Return ``True`` if this entry is a directory or a symbolic link pointing to "
"a directory; return ``False`` if the entry is or points to any other kind of"
" file, or if it doesn't exist anymore."
msgstr ""
"如果本条目是目录，或是指向目录的符号链接，则返回 ``True``。如果本条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回 "
"``False``。"

#: ../../library/os.rst:2980
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is a "
"directory (without following symlinks); return ``False`` if the entry is any"
" other kind of file or if it doesn't exist anymore."
msgstr ""
"如果 *follow_symlinks* 是 ``False``，那么仅当本条目为目录时返回 ``True`` "
"（不跟踪符号链接），如果本条目是任何类型的文件，或该文件不再存在，则返回 ``False``。"

#: ../../library/os.rst:2984
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache "
"for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` along "
"with :func:`stat.S_ISDIR` to fetch up-to-date information."
msgstr ""
"这一结果是缓存在 ``os.DirEntry`` 对象中的，且 *follow_symlinks* 为 ``True`` 和 ``False`` "
"时的缓存是分开的。请调用 :func:`os.stat` 和 :func:`stat.S_ISDIR` 来获取最新信息。"

#: ../../library/os.rst:2988
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, for non-symlinks, neither Windows or Unix require a system "
"call, except on certain Unix file systems, such as network file systems, "
"that return ``dirent.d_type == DT_UNKNOWN``. If the entry is a symlink, a "
"system call will be required to follow the symlink unless *follow_symlinks* "
"is ``False``."
msgstr ""
"一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链接，Windows 和 Unix 都不需要系统调用，除非某些 Unix "
"文件系统（如网络文件系统）返回了 ``dirent.d_type == DT_UNKNOWN``。如果本条目是符号链接，则需要一次系统调用来跟踪它（除非"
" *follow_symlinks* 为 ``False``）。"

#: ../../library/os.rst:2995 ../../library/os.rst:3025
msgid ""
"This method can raise :exc:`OSError`, such as :exc:`PermissionError`, but "
":exc:`FileNotFoundError` is caught and not raised."
msgstr ""
"本方法可能抛出 :exc:`OSError` 异常，如 :exc:`PermissionError` 异常，但 "
":exc:`FileNotFoundError` 异常会被内部捕获且不会抛出。"

#: ../../library/os.rst:3000
msgid ""
"Return ``True`` if this entry is a file or a symbolic link pointing to a "
"file; return ``False`` if the entry is or points to a directory or other "
"non-file entry, or if it doesn't exist anymore."
msgstr ""
"如果本条目是文件，或是指向文件的符号链接，则返回 ``True``。如果本条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，则返回 "
"``False``。"

#: ../../library/os.rst:3004
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is a "
"file (without following symlinks); return ``False`` if the entry is a "
"directory or other non-file entry, or if it doesn't exist anymore."
msgstr ""
"如果 *follow_symlinks* 是 ``False``，那么仅当本条目为文件时返回 ``True`` "
"（不跟踪符号链接），如果本条目是目录或其他非文件条目，或该文件不再存在，则返回 ``False``。"

#: ../../library/os.rst:3008
msgid ""
"The result is cached on the ``os.DirEntry`` object. Caching, system calls "
"made, and exceptions raised are as per :func:`~os.DirEntry.is_dir`."
msgstr ""
"这一结果是缓存在 ``os.DirEntry`` 对象中的。缓存、系统调用、异常抛出都与 :func:`~os.DirEntry.is_dir` 一致。"

#: ../../library/os.rst:3013
msgid ""
"Return ``True`` if this entry is a symbolic link (even if broken); return "
"``False`` if the entry points to a directory or any kind of file, or if it "
"doesn't exist anymore."
msgstr "如果本条目是符号链接（即使是断开的链接），返回 ``True``。如果是目录或任何类型的文件，或本条目不再存在，返回 ``False``。"

#: ../../library/os.rst:3017
msgid ""
"The result is cached on the ``os.DirEntry`` object. Call "
":func:`os.path.islink` to fetch up-to-date information."
msgstr "这一结果是缓存在 ``os.DirEntry`` 对象中的，请调用 :func:`os.path.islink` 来获取最新信息。"

#: ../../library/os.rst:3020
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, neither Windows or Unix require a system call, except on "
"certain Unix file systems, such as network file systems, that return "
"``dirent.d_type == DT_UNKNOWN``."
msgstr ""
"一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了"
" ``dirent.d_type == DT_UNKNOWN``。"

#: ../../library/os.rst:3030
msgid ""
"Return ``True`` if this entry is a junction (even if broken); return "
"``False`` if the entry points to a regular directory, any kind of file, a "
"symlink, or if it doesn't exist anymore."
msgstr ""
"如果本条目是接合点（即使已断开）则返回 ``True``；如果条目指向常规目录、任何种类的文件、符号链接或者已不存在则返回 ``False``。"

#: ../../library/os.rst:3034
msgid ""
"The result is cached on the ``os.DirEntry`` object. Call "
":func:`os.path.isjunction` to fetch up-to-date information."
msgstr "结果是缓存在 ``os.DirEntry`` 对象中的。 调用 :func:`os.path.isjunction` 来获取更新信息。"

#: ../../library/os.rst:3041
msgid ""
"Return a :class:`stat_result` object for this entry. This method follows "
"symbolic links by default; to stat a symbolic link add the "
"``follow_symlinks=False`` argument."
msgstr ""
"返回本条目对应的 :class:`stat_result` 对象。本方法默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 "
"``follow_symlinks=False`` 参数。"

#: ../../library/os.rst:3045
msgid ""
"On Unix, this method always requires a system call. On Windows, it only "
"requires a system call if *follow_symlinks* is ``True`` and the entry is a "
"reparse point (for example, a symbolic link or directory junction)."
msgstr ""
"在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在 *follow_symlinks* 为 ``True`` "
"且该条目是一个重解析点（如符号链接或目录结点）时，才需要一次系统调用。"

#: ../../library/os.rst:3050
msgid ""
"On Windows, the ``st_ino``, ``st_dev`` and ``st_nlink`` attributes of the "
":class:`stat_result` are always set to zero. Call :func:`os.stat` to get "
"these attributes."
msgstr ""
"在 Windows 上，:class:`stat_result` 的 ``st_ino``、``st_dev`` 和 ``st_nlink`` "
"属性总是为零。请调用 :func:`os.stat` 以获得这些属性。"

#: ../../library/os.rst:3054
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache "
"for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` to fetch "
"up-to-date information."
msgstr ""
"这一结果是缓存在 ``os.DirEntry`` 对象中的，且 *follow_symlinks* 为 ``True`` 和 ``False`` "
"时的缓存是分开的。请调用 :func:`os.stat` 来获取最新信息。"

#: ../../library/os.rst:3058
msgid ""
"Note that there is a nice correspondence between several attributes and "
"methods of ``os.DirEntry`` and of :class:`pathlib.Path`.  In particular, the"
" ``name`` attribute has the same meaning, as do the ``is_dir()``, "
"``is_file()``, ``is_symlink()``, ``is_junction()``, and ``stat()`` methods."
msgstr ""
"请注意 ``os.DirEntry`` 和 :class:`pathlib.Path` 的几个属性和方法之间存在很好的对应关系。 "
"具体来说，``name`` 属性具有相同的含义，``is_dir()``, ``is_file()``, ``is_symlink()``, "
"``is_junction()`` 和 ``stat()`` 方法也是如此。"

#: ../../library/os.rst:3066
msgid ""
"Added support for the :class:`~os.PathLike` interface.  Added support for "
":class:`bytes` paths on Windows."
msgstr ""
"添加了对 :class:`~os.PathLike` 接口的支持。在 Windows 上添加了对 :class:`bytes` 类型路径的支持。"

#: ../../library/os.rst:3070
msgid ""
"The ``st_ctime`` attribute of a stat result is deprecated on Windows. The "
"file creation time is properly available as ``st_birthtime``, and in the "
"future ``st_ctime`` may be changed to return zero or the metadata change "
"time, if available."
msgstr ""
"统计结果的 ``st_ctime`` 属性在 Windows 上已被弃用。 文件创建时间可通过 ``st_birthtime`` 来访问，在未来 "
"``st_ctime`` 可能会改为返回零或元数据的修改时间，如果可用的话。"

#: ../../library/os.rst:3079
msgid ""
"Get the status of a file or a file descriptor. Perform the equivalent of a "
":c:func:`stat` system call on the given path. *path* may be specified as "
"either a string or bytes -- directly or indirectly through the "
":class:`PathLike` interface -- or as an open file descriptor. Return a "
":class:`stat_result` object."
msgstr ""
"获取文件或文件描述符的状态。在所给路径上执行等效于 :c:func:`stat` 系统调用的操作。*path* 可以是字符串类型，或（直接传入或通过 "
":class:`PathLike` 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 :class:`stat_result` 对象。"

#: ../../library/os.rst:3085
msgid ""
"This function normally follows symlinks; to stat a symlink add the argument "
"``follow_symlinks=False``, or use :func:`lstat`."
msgstr ""
"本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 ``follow_symlinks=False`` 参数，或使用 "
":func:`lstat`。"

#: ../../library/os.rst:3088 ../../library/os.rst:4167
#: ../../library/os.rst:4183 ../../library/os.rst:4199
#: ../../library/os.rst:4219
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>` and "
":ref:`not following symlinks <follow_symlinks>`."
msgstr "本函数支持 :ref:`指定文件描述符为参数 <path_fd>` 和 :ref:`不跟踪符号链接 <follow_symlinks>`。"

#: ../../library/os.rst:3091
msgid ""
"On Windows, passing ``follow_symlinks=False`` will disable following all "
"name-surrogate reparse points, which includes symlinks and directory "
"junctions. Other types of reparse points that do not resemble links or that "
"the operating system is unable to follow will be opened directly. When "
"following a chain of multiple links, this may result in the original link "
"being returned instead of the non-link that prevented full traversal. To "
"obtain stat results for the final path in this case, use the "
":func:`os.path.realpath` function to resolve the path name as far as "
"possible and call :func:`lstat` on the result. This does not apply to "
"dangling symlinks or junction points, which will raise the usual exceptions."
msgstr ""
"在 Windows 上，传入 ``follow_symlinks=False`` "
"将禁用所有名称代理重解析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方法可能会返回原始链接的"
" stat，无法完整遍历到非链接的对象。在这种情况下，要获取最终路径的 stat，请使用 :func:`os.path.realpath` "
"函数尽可能地解析路径，并在解析结果上调用 :func:`lstat`。这不适用于空链接或交接点，否则会抛出异常。"

#: ../../library/os.rst:3104 ../../library/os.rst:3874
msgid "Example::"
msgstr "示例::"

#: ../../library/os.rst:3106
msgid ""
">>> import os\n"
">>> statinfo = os.stat('somefile.txt')\n"
">>> statinfo\n"
"os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,\n"
"st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,\n"
"st_mtime=1297230027, st_ctime=1297230027)\n"
">>> statinfo.st_size\n"
"264"
msgstr ""
">>> import os\n"
">>> statinfo = os.stat('somefile.txt')\n"
">>> statinfo\n"
"os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,\n"
"st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,\n"
"st_mtime=1297230027, st_ctime=1297230027)\n"
">>> statinfo.st_size\n"
"264"

#: ../../library/os.rst:3117
msgid ":func:`fstat` and :func:`lstat` functions."
msgstr ":func:`fstat` 和 :func:`lstat` 函数。"

#: ../../library/os.rst:3119
msgid ""
"Added the *dir_fd* and *follow_symlinks* parameters, specifying a file "
"descriptor instead of a path."
msgstr "增加了 *dir_fd* 和 *follow_symlinks* 形参，用于指定一个文件描述符而不是路径。"

#: ../../library/os.rst:3126
msgid ""
"On Windows, all reparse points that can be resolved by the operating system "
"are now followed, and passing ``follow_symlinks=False`` disables following "
"all name surrogate reparse points. If the operating system reaches a reparse"
" point that it is not able to follow, *stat* now returns the information for"
" the original path as if ``follow_symlinks=False`` had been specified "
"instead of raising an error."
msgstr ""
"在 Windows 上，本方法将跟踪系统能解析的所有重解析点，并且传入 ``follow_symlinks=False`` "
"会停止跟踪所有名称代理重解析点。现在，如果操作系统遇到无法跟踪的重解析点，*stat* 将返回原始路径的信息，就像已指定 "
"``follow_symlinks=False`` 一样，而不会抛出异常。"

#: ../../library/os.rst:3137
msgid ""
"Object whose attributes correspond roughly to the members of the "
":c:struct:`stat` structure. It is used for the result of :func:`os.stat`, "
":func:`os.fstat` and :func:`os.lstat`."
msgstr ""
"对象的属性大致对应于 :c:struct:`stat` 结构体的成员。 它将被用作 :func:`os.stat`, :func:`os.fstat` "
"和 :func:`os.lstat` 的输出结果。"

#: ../../library/os.rst:3141
msgid "Attributes:"
msgstr "属性："

#: ../../library/os.rst:3145
msgid "File mode: file type and file mode bits (permissions)."
msgstr "文件模式：包括文件类型和文件模式位（即权限位）。"

#: ../../library/os.rst:3149
msgid ""
"Platform dependent, but if non-zero, uniquely identifies the file for a "
"given value of ``st_dev``. Typically:"
msgstr "与平台有关，但如果不为零，则根据 ``st_dev`` 值唯一地标识文件。通常："

#: ../../library/os.rst:3152
msgid "the inode number on Unix,"
msgstr "在 Unix 上该值表示索引节点号 (inode number)。"

#: ../../library/os.rst:3153
msgid ""
"the `file index <https://msdn.microsoft.com/en-us/library/aa363788>`_ on "
"Windows"
msgstr ""
"在 Windows 上该值表示 `文件索引号 <https://msdn.microsoft.com/en-us/library/aa363788>`_"
" 。"

#: ../../library/os.rst:3159
msgid "Identifier of the device on which this file resides."
msgstr "该文件所在设备的标识符。"

#: ../../library/os.rst:3163
msgid "Number of hard links."
msgstr "硬链接的数量。"

#: ../../library/os.rst:3167
msgid "User identifier of the file owner."
msgstr "文件所有者的用户 ID。"

#: ../../library/os.rst:3171
msgid "Group identifier of the file owner."
msgstr "文件所有者的用户组 ID。"

#: ../../library/os.rst:3175
msgid ""
"Size of the file in bytes, if it is a regular file or a symbolic link. The "
"size of a symbolic link is the length of the pathname it contains, without a"
" terminating null byte."
msgstr "文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接的大小是它包含的路径的长度，不包括末尾的空字节。"

#: ../../library/os.rst:3179
msgid "Timestamps:"
msgstr "时间戳："

#: ../../library/os.rst:3183
msgid "Time of most recent access expressed in seconds."
msgstr "最近的访问时间，以秒为单位。"

#: ../../library/os.rst:3187
msgid "Time of most recent content modification expressed in seconds."
msgstr "最近的修改时间，以秒为单位。"

#: ../../library/os.rst:3191
msgid "Time of most recent metadata change expressed in seconds."
msgstr "以秒数表示的元数据最近更改的时间。"

#: ../../library/os.rst:3193
msgid ""
"``st_ctime`` is deprecated on Windows. Use ``st_birthtime`` for the file "
"creation time. In the future, ``st_ctime`` will contain the time of the most"
" recent metadata change, as for other platforms."
msgstr ""
"``st_ctime`` 在 Windows 上已被弃用。 请使用 ``st_birthtime`` 获取文件创建时间。 "
"在未来，``st_ctime`` 将包含最近的元数据修改时间，与其他平台一样。"

#: ../../library/os.rst:3200
msgid "Time of most recent access expressed in nanoseconds as an integer."
msgstr "最近的访问时间，以纳秒表示，为整数。"

#: ../../library/os.rst:3206
msgid ""
"Time of most recent content modification expressed in nanoseconds as an "
"integer."
msgstr "最近的修改时间，以纳秒表示，为整数。"

#: ../../library/os.rst:3213
msgid ""
"Time of most recent metadata change expressed in nanoseconds as an integer."
msgstr "最近的元数据修改时间，表示为一个以纳秒为单位的整数。"

#: ../../library/os.rst:3218
msgid ""
"``st_ctime_ns`` is deprecated on Windows. Use ``st_birthtime_ns`` for the "
"file creation time. In the future, ``st_ctime`` will contain the time of the"
" most recent metadata change, as for other platforms."
msgstr ""
"``st_ctime_ns`` 在 Windows 上已被弃用。 请使用 ``st_birthtime_ns`` 获取文件创建时间。 "
"在未来，``st_ctime`` 将包含最近的元数据修改时间，与其他平台一样。"

#: ../../library/os.rst:3225
msgid ""
"Time of file creation expressed in seconds. This attribute is not always "
"available, and may raise :exc:`AttributeError`."
msgstr "以秒为单位的文件创建时间。 该属性并不总是可用的，并可能引发 :exc:`AttributeError`。"

#: ../../library/os.rst:3228
msgid "``st_birthtime`` is now available on Windows."
msgstr "目前 ``st_birthtime`` 已在 Windows 上可用。"

#: ../../library/os.rst:3233
msgid ""
"Time of file creation expressed in nanoseconds as an integer. This attribute"
" is not always available, and may raise :exc:`AttributeError`."
msgstr "表示为一个以纳秒为单位的整数的文件创建时间。 该属性并不总是可用，并可能引发 :exc:`AttributeError`。"

#: ../../library/os.rst:3241
msgid ""
"The exact meaning and resolution of the :attr:`st_atime`, :attr:`st_mtime`, "
":attr:`st_ctime` and :attr:`st_birthtime` attributes depend on the operating"
" system and the file system. For example, on Windows systems using the FAT32"
" file systems, :attr:`st_mtime` has 2-second resolution, and "
":attr:`st_atime` has only 1-day resolution. See your operating system "
"documentation for details."
msgstr ""
":attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime` 和 :attr:`st_birthtime` "
"等属性的确切含义和精度依赖于操作系统和文件系统。 例如，在使用 FAT32 文件系统的 Windows 系统上，:attr:`st_mtime` "
"的精度为 2 秒，而 :attr:`st_atime` 的精度只有 1 天。 请参阅你的操作系统文档了解详情。"

#: ../../library/os.rst:3248
msgid ""
"Similarly, although :attr:`st_atime_ns`, :attr:`st_mtime_ns`, "
":attr:`st_ctime_ns` and :attr:`st_birthtime_ns` are always expressed in "
"nanoseconds, many systems do not provide nanosecond precision.  On systems "
"that do provide nanosecond precision, the floating-point object used to "
"store :attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime` and "
":attr:`st_birthtime` cannot preserve all of it, and as such will be slightly"
" inexact. If you need the exact timestamps you should always use "
":attr:`st_atime_ns`, :attr:`st_mtime_ns`, :attr:`st_ctime_ns` and "
":attr:`st_birthtime_ns`."
msgstr ""
"类似地，尽管 :attr:`st_atime_ns`, :attr:`st_mtime_ns`, :attr:`st_ctime_ns` 和 "
":attr:`st_birthtime_ns` 始终以纳秒表示，但许多系统并不提供纳秒级精度。 在确实提供纳秒级精度的系统上，用于存储 "
":attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime` 和 :attr:`st_birthtime` "
"的浮点数对象无法保留所有精度，因此不是完全准确的。 如果你需要准确的时间戳你应始终使用 :attr:`st_atime_ns`, "
":attr:`st_mtime_ns`, :attr:`st_ctime_ns` 和 :attr:`st_birthtime_ns`。"

#: ../../library/os.rst:3258
msgid ""
"On some Unix systems (such as Linux), the following attributes may also be "
"available:"
msgstr "在某些 Unix 系统上（如 Linux 上），以下属性可能也可用："

#: ../../library/os.rst:3263
msgid ""
"Number of 512-byte blocks allocated for file. This may be smaller than "
":attr:`st_size`/512 when the file has holes."
msgstr "为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小于 :attr:`st_size`/512。"

#: ../../library/os.rst:3268
msgid ""
"\"Preferred\" blocksize for efficient file system I/O. Writing to a file in "
"smaller chunks may cause an inefficient read-modify-rewrite."
msgstr "“首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小可能会导致读取-修改-重写效率低下。"

#: ../../library/os.rst:3273
msgid "Type of device if an inode device."
msgstr "设备类型（如果是 inode 设备）。"

#: ../../library/os.rst:3277
msgid "User defined flags for file."
msgstr "用户定义的文件标志位。"

#: ../../library/os.rst:3279
msgid ""
"On other Unix systems (such as FreeBSD), the following attributes may be "
"available (but may be only filled out if root tries to use them):"
msgstr "在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root 使用它们时才被填充）："

#: ../../library/os.rst:3284
msgid "File generation number."
msgstr "文件生成号。"

#: ../../library/os.rst:3286
msgid ""
"On Solaris and derivatives, the following attributes may also be available:"
msgstr "在 Solaris 及其衍生版本上，以下属性可能也可用："

#: ../../library/os.rst:3291
msgid ""
"String that uniquely identifies the type of the filesystem that contains the"
" file."
msgstr "文件所在文件系统的类型的唯一标识，为字符串。"

#: ../../library/os.rst:3294
msgid "On macOS systems, the following attributes may also be available:"
msgstr "在 macOS 系统上，以下属性可能也可用："

#: ../../library/os.rst:3298
msgid "Real size of the file."
msgstr "文件的实际大小。"

#: ../../library/os.rst:3302
msgid "Creator of the file."
msgstr "文件的创建者。"

#: ../../library/os.rst:3306
msgid "File type."
msgstr "文件类型。"

#: ../../library/os.rst:3308
msgid "On Windows systems, the following attributes are also available:"
msgstr "在 Windows 系统上，以下属性也可用："

#: ../../library/os.rst:3312
msgid ""
"Windows file attributes: ``dwFileAttributes`` member of the "
"``BY_HANDLE_FILE_INFORMATION`` structure returned by "
":c:func:`!GetFileInformationByHandle`. See the :const:`!FILE_ATTRIBUTE_* "
"<stat.FILE_ATTRIBUTE_ARCHIVE>` constants in the :mod:`stat` module."
msgstr ""
"Windows 文件属性：由 :c:func:`!GetFileInformationByHandle` 返回的 "
"``BY_HANDLE_FILE_INFORMATION`` 结构体的 ``dwFileAttributes`` 成员。 参见 :mod:`stat` "
"模块中的 :const:`!FILE_ATTRIBUTE_* <stat.FILE_ATTRIBUTE_ARCHIVE>` 常量。"

#: ../../library/os.rst:3322
msgid ""
"When :attr:`st_file_attributes` has the "
":const:`~stat.FILE_ATTRIBUTE_REPARSE_POINT` set, this field contains the tag"
" identifying the type of reparse point. See the :const:`IO_REPARSE_TAG_* "
"<stat.IO_REPARSE_TAG_SYMLINK>` constants in the :mod:`stat` module."
msgstr ""
"当 :attr:`st_file_attributes` 存在 :const:`~stat.FILE_ATTRIBUTE_REPARSE_POINT` "
"集合时，本字段将包含标识重解析点的类型的标签。 请参阅 :mod:`stat` 模块中的 :const:`IO_REPARSE_TAG_* "
"<stat.IO_REPARSE_TAG_SYMLINK>` 常量。"

#: ../../library/os.rst:3327
msgid ""
"The standard module :mod:`stat` defines functions and constants that are "
"useful for extracting information from a :c:struct:`stat` structure. (On "
"Windows, some items are filled with dummy values.)"
msgstr ""
"标准模块 :mod:`stat` 定义了一些可用于从 :c:struct:`stat` 结构体中提取信息的函数和常量。 （在 Windows "
"上，某些项填充了虚拟值。）"

#: ../../library/os.rst:3331
msgid ""
"For backward compatibility, a :class:`stat_result` instance is also "
"accessible as a tuple of at least 10 integers giving the most important (and"
" portable) members of the :c:struct:`stat` structure, in the order "
":attr:`st_mode`, :attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, "
":attr:`st_uid`, :attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, "
":attr:`st_mtime`, :attr:`st_ctime`. More items may be added at the end by "
"some implementations. For compatibility with older Python versions, "
"accessing :class:`stat_result` as a tuple always returns integers."
msgstr ""
"为了向下兼容，:class:`stat_result` 实例还可以作为至少包含 10 个整数的元组来访问以提供 :c:struct:`stat` "
"结构体中最重要（且可移植）的成员，其顺序为 :attr:`st_mode`, :attr:`st_ino`, :attr:`st_dev`, "
":attr:`st_nlink`, :attr:`st_uid`, :attr:`st_gid`, :attr:`st_size`, "
":attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime`。 某些实现还可能在末尾添加更多条目。 "
"为了与旧版 Python 兼容，以元组形式访问 :class:`stat_result` 将始终返回整数。"

#: ../../library/os.rst:3340
msgid "Windows now returns the file index as :attr:`st_ino` when available."
msgstr "在 Windows 上，如果可用，会返回文件索引作为 :attr:`st_ino` 的值。"

#: ../../library/os.rst:3344
msgid "Added the :attr:`st_fstype` member to Solaris/derivatives."
msgstr "在 Solaris 及其衍生版本上添加了 :attr:`st_fstype` 成员。"

#: ../../library/os.rst:3347
msgid "Added the :attr:`st_reparse_tag` member on Windows."
msgstr "在 Windows 上添加了 :attr:`st_reparse_tag` 成员。"

#: ../../library/os.rst:3350
msgid ""
"On Windows, the :attr:`st_mode` member now identifies special files as "
":const:`S_IFCHR`, :const:`S_IFIFO` or :const:`S_IFBLK` as appropriate."
msgstr ""
"在 Windows 上，:attr:`st_mode` 成员现在可以根据需要将特殊文件标识为 "
":const:`S_IFCHR`、:const:`S_IFIFO` 或 :const:`S_IFBLK`。"

#: ../../library/os.rst:3355
msgid ""
"On Windows, :attr:`st_ctime` is deprecated. Eventually, it will contain the "
"last metadata change time, for consistency with other platforms, but for now"
" still contains creation time. Use :attr:`st_birthtime` for the creation "
"time."
msgstr ""
"在 Windows 上，:attr:`st_ctime` 已被弃用。 最终，它将包含元数据的最后修改时间，以与其他平台保持一致，但目前仍包含创建时间。 "
"请使用 :attr:`st_birthtime` 来获取创建时间。"

#: ../../library/os.rst:3361
msgid ""
"On Windows, :attr:`st_ino` may now be up to 128 bits, depending on the file "
"system. Previously it would not be above 64 bits, and larger file "
"identifiers would be arbitrarily packed."
msgstr ""
"在 Windows 上，现在 :attr:`st_ino` 最多可为 128 比特位，具体取决于文件系统。 在之前它不会超过 64 "
"比特位，更长的文件标识符会被强制缩减。"

#: ../../library/os.rst:3365
msgid ""
"On Windows, :attr:`st_rdev` no longer returns a value. Previously it would "
"contain the same as :attr:`st_dev`, which was incorrect."
msgstr ""
"在 Windows 上，:attr:`st_rdev` 将不再返回值。 在之前它将包含与 :attr:`st_dev` 相同的值，这是不正确的。"

#: ../../library/os.rst:3368
msgid "Added the :attr:`st_birthtime` member on Windows."
msgstr "在 Windows 上增加了 :attr:`st_birthtime` 成员。"

#: ../../library/os.rst:3373
msgid ""
"Perform a :c:func:`!statvfs` system call on the given path.  The return "
"value is an object whose attributes describe the filesystem on the given "
"path, and correspond to the members of the :c:struct:`statvfs` structure, "
"namely: :attr:`f_bsize`, :attr:`f_frsize`, :attr:`f_blocks`, "
":attr:`f_bfree`, :attr:`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, "
":attr:`f_favail`, :attr:`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`."
msgstr ""
"在给定的路径上执行 :c:func:`!statvfs` 系统调用。 返回值是一个对象，其属性描述了所给路径上的文件系统，并且与 "
":c:struct:`statvfs` 结构体的成员相对应，即: :attr:`f_bsize`, :attr:`f_frsize`, "
":attr:`f_blocks`, :attr:`f_bfree`, :attr:`f_bavail`, :attr:`f_files`, "
":attr:`f_ffree`, :attr:`f_favail`, :attr:`f_flag`, :attr:`f_namemax`, "
":attr:`f_fsid`。"

#: ../../library/os.rst:3380
msgid ""
"Two module-level constants are defined for the :attr:`f_flag` attribute's "
"bit-flags: if :const:`ST_RDONLY` is set, the filesystem is mounted read-"
"only, and if :const:`ST_NOSUID` is set, the semantics of setuid/setgid bits "
"are disabled or not supported."
msgstr ""
"为 :attr:`f_flag` 属性位定义了两个模块级常量：如果存在 :const:`ST_RDONLY` 位，则文件系统以只读挂载；如果存在 "
":const:`ST_NOSUID` 位，则文件系统禁用或不支持 setuid/setgid 位。"

#: ../../library/os.rst:3385
msgid ""
"Additional module-level constants are defined for GNU/glibc based systems. "
"These are :const:`ST_NODEV` (disallow access to device special files), "
":const:`ST_NOEXEC` (disallow program execution), :const:`ST_SYNCHRONOUS` "
"(writes are synced at once), :const:`ST_MANDLOCK` (allow mandatory locks on "
"an FS), :const:`ST_WRITE` (write on file/directory/symlink), "
":const:`ST_APPEND` (append-only file), :const:`ST_IMMUTABLE` (immutable "
"file), :const:`ST_NOATIME` (do not update access times), "
":const:`ST_NODIRATIME` (do not update directory access times), "
":const:`ST_RELATIME` (update atime relative to mtime/ctime)."
msgstr ""
"为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 :const:`ST_NODEV` "
"（禁止访问设备专用文件），:const:`ST_NOEXEC` （禁止执行程序），:const:`ST_SYNCHRONOUS` "
"（写入后立即同步），:const:`ST_MANDLOCK` （允许文件系统上的强制锁定），:const:`ST_WRITE` "
"（写入文件/目录/符号链接），:const:`ST_APPEND` （仅追加文件），:const:`ST_IMMUTABLE` "
"（不可变文件），:const:`ST_NOATIME` （不更新访问时间），:const:`ST_NODIRATIME` "
"（不更新目录访问时间），:const:`ST_RELATIME` （相对于 mtime/ctime 更新访问时间）。"

#: ../../library/os.rst:3398
msgid "The :const:`ST_RDONLY` and :const:`ST_NOSUID` constants were added."
msgstr "添加了 :const:`ST_RDONLY` 和 :const:`ST_NOSUID` 常量。"

#: ../../library/os.rst:3404
msgid ""
"The :const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, "
":const:`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, "
":const:`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME`, and "
":const:`ST_RELATIME` constants were added."
msgstr ""
"添加了 "
":const:`ST_NODEV`、:const:`ST_NOEXEC`、:const:`ST_SYNCHRONOUS`、:const:`ST_MANDLOCK`、:const:`ST_WRITE`、:const:`ST_APPEND`、:const:`ST_IMMUTABLE`、:const:`ST_NOATIME`、:const:`ST_NODIRATIME`"
" 和 :const:`ST_RELATIME` 常量。"

#: ../../library/os.rst:3413
msgid "Added the :attr:`f_fsid` attribute."
msgstr "增加了 :attr:`f_fsid` 属性。"

#: ../../library/os.rst:3419
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept an open file descriptor for their *dir_fd* parameter. Different "
"platforms provide different features, and the underlying functionality "
"Python uses to implement the *dir_fd* parameter is not available on all "
"platforms Python supports.  For consistency's sake, functions that may "
"support *dir_fd* always allow specifying the parameter, but will throw an "
"exception if the functionality is used when it's not locally available. "
"(Specifying ``None`` for *dir_fd* is always supported on all platforms.)"
msgstr ""
"一个 :class:`set` 对象，指示 :mod:`os` 模块中的哪些函数接受一个打开的文件描述符作为 *dir_fd* "
"参数。不同平台提供的功能不同，且 Python 用于实现 *dir_fd* 参数的底层函数并非在 Python "
"支持的所有平台上都可用。考虑到一致性，支持 *dir_fd* "
"的函数始终允许指定描述符，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 *dir_fd* 指定为 ``None``。）"

#: ../../library/os.rst:3429
msgid ""
"To check whether a particular function accepts an open file descriptor for "
"its *dir_fd* parameter, use the ``in`` operator on ``supports_dir_fd``. As "
"an example, this expression evaluates to ``True`` if :func:`os.stat` accepts"
" open file descriptors for *dir_fd* on the local platform::"
msgstr ""
"要检查某个函数是否接受打开的文件描述符作为 *dir_fd* 参数，请在 ``supports_dir_fd`` 前使用 ``in`` "
"运算符。例如，如果 :func:`os.stat` 在当前平台上接受打开的文件描述符作为 *dir_fd* 参数，则此表达式的计算结果为 "
"``True``::"

#: ../../library/os.rst:3434
msgid "os.stat in os.supports_dir_fd"
msgstr "os.stat in os.supports_dir_fd"

#: ../../library/os.rst:3436
msgid ""
"Currently *dir_fd* parameters only work on Unix platforms; none of them work"
" on Windows."
msgstr "目前 *dir_fd* 参数仅在 Unix 平台上有效，在 Windows 上均无效。"

#: ../../library/os.rst:3444
msgid ""
"A :class:`set` object indicating whether :func:`os.access` permits "
"specifying ``True`` for its *effective_ids* parameter on the local platform."
" (Specifying ``False`` for *effective_ids* is always supported on all "
"platforms.)  If the local platform supports it, the collection will contain "
":func:`os.access`; otherwise it will be empty."
msgstr ""
"一个 :class:`set` 对象，指示 :func:`os.access` 是否允许在当前平台上将其 *effective_ids* 参数指定为 "
"``True``。（所有平台都支持将 *effective_ids* 指定为 ``False``。）如果当前平台支持，则集合将包含 "
":func:`os.access`，否则集合为空。"

#: ../../library/os.rst:3450
msgid ""
"This expression evaluates to ``True`` if :func:`os.access` supports "
"``effective_ids=True`` on the local platform::"
msgstr ""
"如果当前平台上的 :func:`os.access` 支持 ``effective_ids=True``，则此表达式的计算结果为 ``True``::"

#: ../../library/os.rst:3453
msgid "os.access in os.supports_effective_ids"
msgstr "os.access in os.supports_effective_ids"

#: ../../library/os.rst:3455
msgid ""
"Currently *effective_ids* is only supported on Unix platforms; it does not "
"work on Windows."
msgstr "目前仅 Unix 平台支持 *effective_ids*，Windows 不支持。"

#: ../../library/os.rst:3463
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"permit specifying their *path* parameter as an open file descriptor on the "
"local platform.  Different platforms provide different features, and the "
"underlying functionality Python uses to accept open file descriptors as "
"*path* arguments is not available on all platforms Python supports."
msgstr ""
"一个 :class:`set` 对象，指示在当前平台上 :mod:`os` 模块中的哪些函数接受一个打开的文件描述符作为 *path* "
"参数。不同平台提供的功能不同，且 Python 所使用到的底层函数（用于实现接受描述符作为 *path*）并非在 Python 支持的所有平台上都可用。"

#: ../../library/os.rst:3470
msgid ""
"To determine whether a particular function permits specifying an open file "
"descriptor for its *path* parameter, use the ``in`` operator on "
"``supports_fd``. As an example, this expression evaluates to ``True`` if "
":func:`os.chdir` accepts open file descriptors for *path* on your local "
"platform::"
msgstr ""
"要判断某个函数是否接受打开的文件描述符作为 *path* 参数，请在 ``supports_fd`` 前使用 ``in`` 运算符。例如，如果 "
":func:`os.chdir` 在当前平台上接受打开的文件描述符作为 *path* 参数，则此表达式的计算结果为 ``True``::"

#: ../../library/os.rst:3476
msgid "os.chdir in os.supports_fd"
msgstr "os.chdir in os.supports_fd"

#: ../../library/os.rst:3483
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept ``False`` for their *follow_symlinks* parameter on the local "
"platform. Different platforms provide different features, and the underlying"
" functionality Python uses to implement *follow_symlinks* is not available "
"on all platforms Python supports.  For consistency's sake, functions that "
"may support *follow_symlinks* always allow specifying the parameter, but "
"will throw an exception if the functionality is used when it's not locally "
"available.  (Specifying ``True`` for *follow_symlinks* is always supported "
"on all platforms.)"
msgstr ""
"一个 :class:`set` 对象，指示在当前平台上 :mod:`os` 模块中的哪些函数的 *follow_symlinks* 参数可指定为 "
"``False``。不同平台提供的功能不同，且 Python 用于实现 *follow_symlinks* 的底层函数并非在 Python "
"支持的所有平台上都可用。考虑到一致性，支持 *follow_symlinks* 的函数始终允许将其指定为 "
"``False``，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 *follow_symlinks* 指定为 "
"``True``。）"

#: ../../library/os.rst:3493
msgid ""
"To check whether a particular function accepts ``False`` for its "
"*follow_symlinks* parameter, use the ``in`` operator on "
"``supports_follow_symlinks``.  As an example, this expression evaluates to "
"``True`` if you may specify ``follow_symlinks=False`` when calling "
":func:`os.stat` on the local platform::"
msgstr ""
"要检查某个函数的 *follow_symlinks* 参数是否可以指定为 ``False``，请在 "
"``supports_follow_symlinks`` 前使用 ``in`` 运算符。例如，如果在当前平台上调用 :func:`os.stat` "
"时可以指定 ``follow_symlinks=False``，则此表达式的计算结果为 ``True``::"

#: ../../library/os.rst:3499
msgid "os.stat in os.supports_follow_symlinks"
msgstr "os.stat in os.supports_follow_symlinks"

#: ../../library/os.rst:3506
msgid "Create a symbolic link pointing to *src* named *dst*."
msgstr "创建一个指向 *src* 的符号链接，名为 *dst*。"

#: ../../library/os.rst:3508
msgid ""
"On Windows, a symlink represents either a file or a directory, and does not "
"morph to the target dynamically.  If the target is present, the type of the "
"symlink will be created to match. Otherwise, the symlink will be created as "
"a directory if *target_is_directory* is ``True`` or a file symlink (the "
"default) otherwise.  On non-Windows platforms, *target_is_directory* is "
"ignored."
msgstr ""
"在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果 "
"*target_is_directory* 为 ``True``，则符号链接将创建为目录链接，为 ``False`` （默认）将创建为文件链接。在非 "
"Windows 平台上，*target_is_directory* 被忽略。"

#: ../../library/os.rst:3519
msgid ""
"On newer versions of Windows 10, unprivileged accounts can create symlinks "
"if Developer Mode is enabled. When Developer Mode is not available/enabled, "
"the *SeCreateSymbolicLinkPrivilege* privilege is required, or the process "
"must be run as an administrator."
msgstr ""
"在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可以创建符号链接。如果开发人员模式不可用/未启用，则需要 "
"*SeCreateSymbolicLinkPrivilege* 权限，或者该进程必须以管理员身份运行。"

#: ../../library/os.rst:3525
msgid ""
":exc:`OSError` is raised when the function is called by an unprivileged "
"user."
msgstr "当本函数由非特权账户调用时，抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:3528
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.symlink`` with arguments "
"``src``, ``dst``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.symlink`` 并附带参数 ``src``, ``dst``, "
"``dir_fd``。"

#: ../../library/os.rst:3538
msgid ""
"Added the *dir_fd* parameter, and now allow *target_is_directory* on non-"
"Windows platforms."
msgstr "增加了 *dir_fd* 形参，现在将在非 Windows 平台上允许 *target_is_directory*。"

#: ../../library/os.rst:3545
msgid "Added support for unelevated symlinks on Windows with Developer Mode."
msgstr "针对启用了开发人员模式的 Windows，添加了非特权账户创建符号链接的支持。"

#: ../../library/os.rst:3551
msgid "Force write of everything to disk."
msgstr "强制将所有内容写入磁盘。"

#: ../../library/os.rst:3560
msgid ""
"Truncate the file corresponding to *path*, so that it is at most *length* "
"bytes in size."
msgstr "截断 *path* 对应的文件，以使其最大为 *length* 字节。"

#: ../../library/os.rst:3565
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments "
"``path``, ``length``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.truncate`` 并附带参数 ``path``, ``length``。"

#: ../../library/os.rst:3580
msgid ""
"Remove (delete) the file *path*.  This function is semantically identical to"
" :func:`remove`; the ``unlink`` name is its traditional Unix name.  Please "
"see the documentation for :func:`remove` for further information."
msgstr ""
"移除（删除）文件 *path*。该函数在语义上与 :func:`remove` 相同，``unlink`` 是其传统的 Unix 名称。请参阅 "
":func:`remove` 的文档以获取更多信息。"

#: ../../library/os.rst:3596
msgid "Set the access and modified times of the file specified by *path*."
msgstr "设置文件 *path* 的访问时间和修改时间。"

#: ../../library/os.rst:3598
msgid ""
":func:`utime` takes two optional parameters, *times* and *ns*. These specify"
" the times set on *path* and are used as follows:"
msgstr ":func:`utime` 有 *times* 和 *ns* 两个可选参数，它们指定了设置给 *path* 的时间，用法如下："

#: ../../library/os.rst:3601
msgid ""
"If *ns* is specified, it must be a 2-tuple of the form ``(atime_ns, "
"mtime_ns)`` where each member is an int expressing nanoseconds."
msgstr "如果指定 *ns*，它必须是一个 ``(atime_ns, mtime_ns)`` 形式的二元组，其中每个成员都是一个表示纳秒的整数。"

#: ../../library/os.rst:3604
msgid ""
"If *times* is not ``None``, it must be a 2-tuple of the form ``(atime, "
"mtime)`` where each member is an int or float expressing seconds."
msgstr ""
"如果 *times* 不为 ``None``，则它必须是 ``(atime, mtime)`` 形式的二元组，其中每个成员都是一个表示秒的 int 或 "
"float。"

#: ../../library/os.rst:3607
msgid ""
"If *times* is ``None`` and *ns* is unspecified, this is equivalent to "
"specifying ``ns=(atime_ns, mtime_ns)`` where both times are the current "
"time."
msgstr ""
"如果 *times* 为 ``None`` 且未指定 *ns*，则相当于指定 ``ns=(atime_ns, "
"mtime_ns)``，其中两个时间均为当前时间。"

#: ../../library/os.rst:3611
msgid "It is an error to specify tuples for both *times* and *ns*."
msgstr "同时为 *times* 和 *ns* 指定元组会出错。"

#: ../../library/os.rst:3613
msgid ""
"Note that the exact times you set here may not be returned by a subsequent "
":func:`~os.stat` call, depending on the resolution with which your operating"
" system records access and modification times; see :func:`~os.stat`. The "
"best way to preserve exact times is to use the *st_atime_ns* and "
"*st_mtime_ns* fields from the :func:`os.stat` result object with the *ns* "
"parameter to :func:`utime`."
msgstr ""
"请注意你在此处设置的确切时间可能不会被后续的 :func:`~os.stat` 调用所返回，具体取决于你的操作系统记录访问和修改时间的分辨率；请参阅 "
":func:`~os.stat`。 保留准确时间的最佳方式是使用来自于将 *ns* 形参设为 :func:`utime` 的 "
":func:`os.stat` 结果对象的 *st_atime_ns* 和 *st_mtime_ns* 字段。"

#: ../../library/os.rst:3624
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.utime`` with arguments "
"``path``, ``times``, ``ns``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.utime`` 并附带参数 ``path``, ``times``, ``ns``, "
"``dir_fd``。"

#: ../../library/os.rst:3626
msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd*, *follow_symlinks*, and *ns* parameters."
msgstr "新增支持将 *path* 参数指定为打开的文件描述符，以及支持 *dir_fd*、*follow_symlinks* 和 *ns* 参数。"

#: ../../library/os.rst:3640
msgid ""
"Generate the file names in a directory tree by walking the tree either top-"
"down or bottom-up. For each directory in the tree rooted at directory *top* "
"(including *top* itself), it yields a 3-tuple ``(dirpath, dirnames, "
"filenames)``."
msgstr ""
"生成目录树中的文件名，方式是按上->下或下->上顺序浏览目录树。对于以 *top* 为根的目录树中的每个目录（包括 *top* "
"本身），它都会生成一个三元组 ``(dirpath, dirnames, filenames)``。"

#: ../../library/os.rst:3645
msgid ""
"*dirpath* is a string, the path to the directory.  *dirnames* is a list of "
"the names of the subdirectories in *dirpath* (including symlinks to "
"directories, and excluding ``'.'`` and ``'..'``). *filenames* is a list of "
"the names of the non-directory files in *dirpath*. Note that the names in "
"the lists contain no path components.  To get a full path (which begins with"
" *top*) to a file or directory in *dirpath*, do ``os.path.join(dirpath, "
"name)``.  Whether or not the lists are sorted depends on the file system.  "
"If a file is removed from or added to the *dirpath* directory during "
"generating the lists, whether a name for that file be included is "
"unspecified."
msgstr ""
"*dirpath* 是一个字符串，表示目录的路径。 *dirnames* 是由 *dirpath* 中的子目录名称组成的列表 "
"(包括指向目录的符号链接，不包括 ``'.'`` 和 ``'..'``)。 *filenames* 是由 *dirpath* "
"中非目录文件名称组成的列表。 请注意列表中的名称不包含路径部分。 要获取 *dirpath* 中文件或目录的完整路径 (以 *top* 打头，请执行 "
"``os.path.join(dirpath, name)``。 列表是否排序取决于具体文件系统。 如果有文件在列表生成期间被移除或添加到 "
"*dirpath*，是否要包括该文件的名称并没有规定。"

#: ../../library/os.rst:3656
msgid ""
"If optional argument *topdown* is ``True`` or not specified, the triple for "
"a directory is generated before the triples for any of its subdirectories "
"(directories are generated top-down).  If *topdown* is ``False``, the triple"
" for a directory is generated after the triples for all of its "
"subdirectories (directories are generated bottom-up). No matter the value of"
" *topdown*, the list of subdirectories is retrieved before the tuples for "
"the directory and its subdirectories are generated."
msgstr ""
"如果可选参数 *topdown* 为 ``True`` 或未指定，则在所有子目录的三元组之前生成父目录的三元组（目录是自上而下生成的）。如果 "
"*topdown* 为 ``False``，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是自下而上生成的）。无论 *topdown* "
"为何值，在生成目录及其子目录的元组之前，都将检索全部子目录列表。"

#: ../../library/os.rst:3664
msgid ""
"When *topdown* is ``True``, the caller can modify the *dirnames* list in-"
"place (perhaps using :keyword:`del` or slice assignment), and :func:`walk` "
"will only recurse into the subdirectories whose names remain in *dirnames*; "
"this can be used to prune the search, impose a specific order of visiting, "
"or even to inform :func:`walk` about directories the caller creates or "
"renames before it resumes :func:`walk` again.  Modifying *dirnames* when "
"*topdown* is ``False`` has no effect on the behavior of the walk, because in"
" bottom-up mode the directories in *dirnames* are generated before *dirpath*"
" itself is generated."
msgstr ""
"当 *topdown* 为 ``True`` 时，调用者可以就地修改 *dirnames* 列表（也许用到了 :keyword:`del` 或切片），而"
" :func:`walk` 将仅仅递归到仍保留在 *dirnames* 中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续 "
":func:`walk` 之前告知 :func:`walk` 由调用者新建或重命名的目录的信息。当 *topdown* 为 ``False`` 时，修改"
" *dirnames* 对 walk 的行为没有影响，因为在自下而上模式中，*dirnames* 中的目录是在 *dirpath* 本身之前生成的。"

#: ../../library/os.rst:3673
msgid ""
"By default, errors from the :func:`scandir` call are ignored.  If optional "
"argument *onerror* is specified, it should be a function; it will be called "
"with one argument, an :exc:`OSError` instance.  It can report the error to "
"continue with the walk, or raise the exception to abort the walk.  Note that"
" the filename is available as the ``filename`` attribute of the exception "
"object."
msgstr ""
"默认将忽略 :func:`scandir` 调用中的错误。如果指定了可选参数 *onerror*，它应该是一个函数。出错时它会被调用，参数是一个 "
":exc:`OSError` 实例。它可以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常对象的 ``filename`` "
"属性中获取出错的文件名。"

#: ../../library/os.rst:3679
msgid ""
"By default, :func:`walk` will not walk down into symbolic links that resolve"
" to directories. Set *followlinks* to ``True`` to visit directories pointed "
"to by symlinks, on systems that support them."
msgstr ""
":func:`walk` 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统上将 *followlinks* 设置为 "
"``True``，以访问符号链接指向的目录。"

#: ../../library/os.rst:3685
msgid ""
"Be aware that setting *followlinks* to ``True`` can lead to infinite "
"recursion if a link points to a parent directory of itself. :func:`walk` "
"does not keep track of the directories it visited already."
msgstr ""
"注意，如果链接指向自身的父目录，则将 *followlinks* 设置为 ``True`` 可能导致无限递归。:func:`walk` "
"不会记录它已经访问过的目录。"

#: ../../library/os.rst:3691
msgid ""
"If you pass a relative pathname, don't change the current working directory "
"between resumptions of :func:`walk`.  :func:`walk` never changes the current"
" directory, and assumes that its caller doesn't either."
msgstr ""
"如果传入的是相对路径，请不要在恢复 :func:`walk` 之间更改当前工作目录。:func:`walk` "
"不会更改当前目录，并假定其调用者也不会更改当前目录。"

#: ../../library/os.rst:3695 ../../library/os.rst:3757
msgid ""
"This example displays the number of bytes taken by non-directory files in "
"each directory under the starting directory, except that it doesn't look "
"under any ``__pycache__`` subdirectory::"
msgstr ""
"下面的例子显示了起始目录下的每个子目录内非目录文件所占用的字节数，例外情况是它不会在任何 ``__pycache__`` 子目录内进行查找::"

#: ../../library/os.rst:3699
msgid ""
"import os\n"
"from os.path import join, getsize\n"
"for root, dirs, files in os.walk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\" \")\n"
"    print(sum(getsize(join(root, name)) for name in files), end=\" \")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # don't visit __pycache__ directories"
msgstr ""
"import os\n"
"from os.path import join, getsize\n"
"for root, dirs, files in os.walk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\" \")\n"
"    print(sum(getsize(join(root, name)) for name in files), end=\" \")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # 不访问 __pycache__ 目录"

#: ../../library/os.rst:3708
msgid ""
"In the next example (simple implementation of :func:`shutil.rmtree`), "
"walking the tree bottom-up is essential, :func:`rmdir` doesn't allow "
"deleting a directory before the directory is empty::"
msgstr ""
"在下一个示例（:func:`shutil.rmtree` 的简单实现）中，必须使树自下而上遍历，因为 :func:`rmdir` "
"只允许在目录为空时删除目录::"

#: ../../library/os.rst:3712
msgid ""
"# Delete everything reachable from the directory named in \"top\",\n"
"# assuming there are no symbolic links.\n"
"# CAUTION:  This is dangerous!  For example, if top == '/', it\n"
"# could delete all your disk files.\n"
"import os\n"
"for root, dirs, files in os.walk(top, topdown=False):\n"
"    for name in files:\n"
"        os.remove(os.path.join(root, name))\n"
"    for name in dirs:\n"
"        os.rmdir(os.path.join(root, name))\n"
"os.rmdir(top)"
msgstr ""
"# 删除可从 \"top\" 指定的目录进入的所有东西，\n"
"# 假定其中没有符号连接。\n"
"# 注意：这很危险！举例来说，如果 top == '/'，\n"
"# 它可能删除你所有的硬盘文件。\n"
"import os\n"
"for root, dirs, files in os.walk(top, topdown=False):\n"
"    for name in files:\n"
"        os.remove(os.path.join(root, name))\n"
"    for name in dirs:\n"
"        os.rmdir(os.path.join(root, name))\n"
"os.rmdir(top)"

#: ../../library/os.rst:3724
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.walk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``followlinks``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.walk`` 并附带参数 ``top``, ``topdown``, "
"``onerror``, ``followlinks``。"

#: ../../library/os.rst:3726
msgid ""
"This function now calls :func:`os.scandir` instead of :func:`os.listdir`, "
"making it faster by reducing the number of calls to :func:`os.stat`."
msgstr ""
"现在，本函数调用的是 :func:`os.scandir` 而不是 :func:`os.listdir`，从而减少了调用 :func:`os.stat`"
" 的次数而变得更快。"

#: ../../library/os.rst:3740
msgid ""
"This behaves exactly like :func:`walk`, except that it yields a 4-tuple "
"``(dirpath, dirnames, filenames, dirfd)``, and it supports ``dir_fd``."
msgstr ""
"本方法的行为与 :func:`walk` 完全一样，除了它产生的是 4 元组 ``(dirpath, dirnames, filenames, "
"dirfd)``，并且它支持 ``dir_fd``。"

#: ../../library/os.rst:3743
msgid ""
"*dirpath*, *dirnames* and *filenames* are identical to :func:`walk` output, "
"and *dirfd* is a file descriptor referring to the directory *dirpath*."
msgstr ""
"*dirpath*、*dirnames* 和 *filenames* 与 :func:`walk` 输出的相同，*dirfd* 是指向目录 "
"*dirpath* 的文件描述符。"

#: ../../library/os.rst:3746
msgid ""
"This function always supports :ref:`paths relative to directory descriptors "
"<dir_fd>` and :ref:`not following symlinks <follow_symlinks>`.  Note however"
" that, unlike other functions, the :func:`fwalk` default value for "
"*follow_symlinks* is ``False``."
msgstr ""
"本函数始终支持 :ref:`基于目录描述符的相对路径 <dir_fd>` 和 :ref:`不跟踪符号链接 "
"<follow_symlinks>`。但是请注意，与其他函数不同，:func:`fwalk` 的 *follow_symlinks* 的默认值为 "
"``False``。"

#: ../../library/os.rst:3753
msgid ""
"Since :func:`fwalk` yields file descriptors, those are only valid until the "
"next iteration step, so you should duplicate them (e.g. with :func:`dup`) if"
" you want to keep them longer."
msgstr ""
"由于 :func:`fwalk` 会生成文件描述符，而它们仅在下一个迭代步骤前有效，因此如果要将描述符保留更久，则应复制它们（比如使用 "
":func:`dup`）。"

#: ../../library/os.rst:3761
msgid ""
"import os\n"
"for root, dirs, files, rootfd in os.fwalk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\"\")\n"
"    print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),\n"
"          end=\"\")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # don't visit __pycache__ directories"
msgstr ""
"import os\n"
"for root, dirs, files, rootfd in os.fwalk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\"\")\n"
"    print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),\n"
"          end=\"\")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # 不访问 __pycache__ 目录"

#: ../../library/os.rst:3770
msgid ""
"In the next example, walking the tree bottom-up is essential: :func:`rmdir` "
"doesn't allow deleting a directory before the directory is empty::"
msgstr "在下一个示例中，必须使树自下而上遍历，因为 :func:`rmdir` 只允许在目录为空时删除目录::"

#: ../../library/os.rst:3774
msgid ""
"# Delete everything reachable from the directory named in \"top\",\n"
"# assuming there are no symbolic links.\n"
"# CAUTION:  This is dangerous!  For example, if top == '/', it\n"
"# could delete all your disk files.\n"
"import os\n"
"for root, dirs, files, rootfd in os.fwalk(top, topdown=False):\n"
"    for name in files:\n"
"        os.unlink(name, dir_fd=rootfd)\n"
"    for name in dirs:\n"
"        os.rmdir(name, dir_fd=rootfd)"
msgstr ""
"# 删除可从 \"top\" 指定的目录进入的所有东西，\n"
"# 假定其中没有符号链接。\n"
"# 注意：这很危险！举例来说，如果 top == '/'，\n"
"# 它会删除你所有的磁盘文件。\n"
"import os\n"
"for root, dirs, files, rootfd in os.fwalk(top, topdown=False):\n"
"    for name in files:\n"
"        os.unlink(name, dir_fd=rootfd)\n"
"    for name in dirs:\n"
"        os.rmdir(name, dir_fd=rootfd)"

#: ../../library/os.rst:3785
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.fwalk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``follow_symlinks``, ``dir_fd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.fwalk`` 并附带参数 ``top``, ``topdown``, "
"``onerror``, ``follow_symlinks``, ``dir_fd``。"

#: ../../library/os.rst:3794
msgid "Added support for :class:`bytes` paths."
msgstr "添加了对 :class:`bytes` 类型路径的支持。"

#: ../../library/os.rst:3800
msgid ""
"Create an anonymous file and return a file descriptor that refers to it. "
"*flags* must be one of the ``os.MFD_*`` constants available on the system "
"(or a bitwise ORed combination of them).  By default, the new file "
"descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"创建一个匿名文件，返回指向该文件的文件描述符。*flags* 必须是系统上可用的 ``os.MFD_*`` "
"常量之一（或将它们按位“或”组合起来）。新文件描述符默认是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/os.rst:3805
msgid ""
"The name supplied in *name* is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory "
"``/proc/self/fd/``. The displayed name is always prefixed with ``memfd:`` "
"and serves only for debugging purposes. Names do not affect the behavior of "
"the file descriptor, and as such multiple files can have the same name "
"without any side effects."
msgstr ""
"*name* 提供的名称会被用作文件名，并且 ``/proc/self/fd/`` 目录中相应符号链接的目标将显示为该名称。显示的名称始终以 "
"``memfd:`` 为前缀，并且仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相同的名称，不会有副作用。"

#: ../../library/os.rst:3835
msgid "These flags can be passed to :func:`memfd_create`."
msgstr "以上标志位可以传递给 :func:`memfd_create`。"

#: ../../library/os.rst:3839
msgid "The ``MFD_HUGE*`` flags are only available since Linux 4.14."
msgstr "``MFD_HUGE*`` 旗标仅从 Linux 4.14 开始可用。"

#: ../../library/os.rst:3846
msgid ""
"Create and return an event file descriptor. The file descriptors supports "
"raw :func:`read` and :func:`write` with a buffer size of 8, "
":func:`~select.select`, :func:`~select.poll` and similar. See man page "
":manpage:`eventfd(2)` for more information.  By default, the new file "
"descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"创建并返回一个事件文件描述符。此文件描述符支持缓冲区大小为 8 的原生 :func:`read` 和  :func:`write` "
"操作、:func:`~select.select` 、:func:`~select.poll` 等类似操作。更多信息请参阅 man 文档 "
":manpage:`eventfd(2)`。默认情况下，新的文件描述符是 :ref:`non-inheritable "
"<fd_inheritance>`。"

#: ../../library/os.rst:3852
msgid ""
"*initval* is the initial value of the event counter. The initial value must "
"be a 32 bit unsigned integer. Please note that the initial value is limited "
"to a 32 bit unsigned int although the event counter is an unsigned 64 bit "
"integer with a maximum value of 2\\ :sup:`64`\\ -\\ 2."
msgstr ""
"*initval* 是事件计数哭喊的初始值。 该初始值必须是一个 32 位无符号整数。 请注意虽然事件计数器是一个最大值为 2\\ "
":sup:`64`\\ -\\ 2 的无符号 64 位整数但初始值仍被限制为 32 位无符号整数。"

#: ../../library/os.rst:3857
msgid ""
"*flags* can be constructed from :const:`EFD_CLOEXEC`, :const:`EFD_NONBLOCK`,"
" and :const:`EFD_SEMAPHORE`."
msgstr ""
"*flags* 可由 :const:`EFD_CLOEXEC` 、 :const:`EFD_NONBLOCK` 和  "
":const:`EFD_SEMAPHORE` 组合而成。"

#: ../../library/os.rst:3860
msgid ""
"If :const:`EFD_SEMAPHORE` is specified and the event counter is non-zero, "
":func:`eventfd_read` returns 1 and decrements the counter by one."
msgstr ""
"如果设置了 :const:`EFD_SEMAPHORE`，并且事件计数器非零，那么 :func:`eventfd_read` 将返回 1 并将计数器递减"
" 1。"

#: ../../library/os.rst:3863
msgid ""
"If :const:`EFD_SEMAPHORE` is not specified and the event counter is non-"
"zero, :func:`eventfd_read` returns the current event counter value and "
"resets the counter to zero."
msgstr ""
"如果未设置 :const:`EFD_SEMAPHORE`，并且事件计数器非零，那么 :func:`eventfd_read` "
"返回当前的事件计数器值，并将计数器重置为零。"

#: ../../library/os.rst:3867
msgid ""
"If the event counter is zero and :const:`EFD_NONBLOCK` is not specified, "
":func:`eventfd_read` blocks."
msgstr "如果事件计数器为 0，并且未设置 :const:`EFD_NONBLOCK`，那么 :func:`eventfd_read` 会阻塞。"

#: ../../library/os.rst:3870
msgid ""
":func:`eventfd_write` increments the event counter. Write blocks if the "
"write operation would increment the counter to a value larger than 2\\ "
":sup:`64`\\ -\\ 2."
msgstr ""
":func:`eventfd_write` 会递增事件计数器。如果写操作会让计数器的增量大于2\\ :sup:`64`\\ -\\ 2，则写入会被阻止。"

#: ../../library/os.rst:3876
msgid ""
"import os\n"
"\n"
"# semaphore with start value '1'\n"
"fd = os.eventfd(1, os.EFD_SEMAPHORE | os.EFC_CLOEXEC)\n"
"try:\n"
"    # acquire semaphore\n"
"    v = os.eventfd_read(fd)\n"
"    try:\n"
"        do_work()\n"
"    finally:\n"
"        # release semaphore\n"
"        os.eventfd_write(fd, v)\n"
"finally:\n"
"    os.close(fd)"
msgstr ""
"import os\n"
"\n"
"# 取值从 '1' 开始的信号量\n"
"fd = os.eventfd(1, os.EFD_SEMAPHORE | os.EFC_CLOEXEC)\n"
"try:\n"
"    # 获取信号量\n"
"    v = os.eventfd_read(fd)\n"
"    try:\n"
"        do_work()\n"
"    finally:\n"
"        # 释放信号量\n"
"        os.eventfd_write(fd, v)\n"
"finally:\n"
"    os.close(fd)"

#: ../../library/os.rst:3897
msgid ""
"Read value from an :func:`eventfd` file descriptor and return a 64 bit "
"unsigned int. The function does not verify that *fd* is an :func:`eventfd`."
msgstr ""
"从一个 :func:`eventfd` 文件描述符中读取数据，并返回一个 64 位无符号整数。该函数不会校验 *fd* 是否为 "
":func:`eventfd`。"

#: ../../library/os.rst:3906
msgid ""
"Add value to an :func:`eventfd` file descriptor. *value* must be a 64 bit "
"unsigned int. The function does not verify that *fd* is an :func:`eventfd`."
msgstr ""
"向一个 :func:`eventfd` 文件描述符加入数据。*value* 必须是一个 64 位无符号整数。本函数不会校验 *fd* 是否为 "
":func:`eventfd`。"

#: ../../library/os.rst:3915
msgid "Set close-on-exec flag for new :func:`eventfd` file descriptor."
msgstr "为新的 :func:`eventfd` 文件描述符设置 close-on-exec 标志。"

#: ../../library/os.rst:3923
msgid ""
"Set :const:`O_NONBLOCK` status flag for new :func:`eventfd` file descriptor."
msgstr "为新的 :func:`eventfd` 文件描述符设置 :const:`O_NONBLOCK` 状态标志。"

#: ../../library/os.rst:3932
msgid ""
"Provide semaphore-like semantics for reads from an :func:`eventfd` file "
"descriptor. On read the internal counter is decremented by one."
msgstr "为从 :func:`eventfd` 文件描述符进行读取提供类似信号量的语法。 在读取时内部计数器将递减一。"

#: ../../library/os.rst:3943
msgid "Timer File Descriptors"
msgstr "计时器文件描述符"

#: ../../library/os.rst:3947
msgid ""
"These functions provide support for Linux's *timer file descriptor* API. "
"Naturally, they are all only available on Linux."
msgstr "这些函数提供了对 Linux 的 *计时器文件描述符* API 的支持。 当然，它们仅在 Linux 上可用。"

#: ../../library/os.rst:3952
msgid "Create and return a timer file descriptor (*timerfd*)."
msgstr "创建并返回一个计时器文件描述符 (*timerfd*)。"

#: ../../library/os.rst:3954
msgid "The file descriptor returned by :func:`timerfd_create` supports:"
msgstr "由 :func:`timerfd_create` 返回的文件描述符可支持："

#: ../../library/os.rst:3956
msgid ":func:`read`"
msgstr ":func:`read`"

#: ../../library/os.rst:3957
msgid ":func:`~select.select`"
msgstr ":func:`~select.select`"

#: ../../library/os.rst:3958
msgid ":func:`~select.poll`"
msgstr ":func:`~select.poll`"

#: ../../library/os.rst:3960
msgid ""
"The file descriptor's :func:`read` method can be called with a buffer size "
"of 8. If the timer has already expired one or more times, :func:`read` "
"returns the number of expirations with the host's endianness, which may be "
"converted to an :class:`int` by ``int.from_bytes(x, "
"byteorder=sys.byteorder)``."
msgstr ""
"文件描述符的 :func:`read` 方法被调用时可附带大小为 8 的缓冲区。 如果计时器已到期一次或多次，:func:`read` "
"将返回以主机端序表示的到期次数，它可通过 ``int.from_bytes(x, byteorder=sys.byteorder)`` 转换为 "
":class:`int`。"

#: ../../library/os.rst:3965
msgid ""
":func:`~select.select` and :func:`~select.poll` can be used to wait until "
"timer expires and the file descriptor is readable."
msgstr ""
":func:`~select.select` 和 :func:`~select.poll` 可被用于等待直至计时器到期并且文件描述符为可读状态。"

#: ../../library/os.rst:3968
msgid ""
"*clockid* must be a valid :ref:`clock ID <time-clock-id-constants>`, as "
"defined in the :py:mod:`time` module:"
msgstr ""
"*clockid* 必须是一个有效的 :ref:`时钟 ID <time-clock-id-constants>`，如 :py:mod:`time` "
"模块中所定义的："

#: ../../library/os.rst:3971
msgid ":const:`time.CLOCK_REALTIME`"
msgstr ":const:`time.CLOCK_REALTIME`"

#: ../../library/os.rst:3972
msgid ":const:`time.CLOCK_MONOTONIC`"
msgstr ":const:`time.CLOCK_MONOTONIC`"

#: ../../library/os.rst:3973
msgid ":const:`time.CLOCK_BOOTTIME` (Since Linux 3.15 for timerfd_create)"
msgstr ":const:`time.CLOCK_BOOTTIME` (自 Linux 3.15 起用于 timerfd_create)"

#: ../../library/os.rst:3975
msgid ""
"If *clockid* is :const:`time.CLOCK_REALTIME`, a settable system-wide real-"
"time clock is used. If system clock is changed, timer setting need to be "
"updated. To cancel timer when system clock is changed, see "
":const:`TFD_TIMER_CANCEL_ON_SET`."
msgstr ""
"如果 *clockid* 为 :const:`time.CLOCK_REALTIME`，则将使用一个可设置的系统级实时时钟。 "
"如果系统时钟发生改变，计时器设置将需要被更新。 要在系统时钟发生改变时取消计时器，请参阅 "
":const:`TFD_TIMER_CANCEL_ON_SET`。"

#: ../../library/os.rst:3980
msgid ""
"If *clockid* is :const:`time.CLOCK_MONOTONIC`, a non-settable monotonically "
"increasing clock is used. Even if the system clock is changed, the timer "
"setting will not be affected."
msgstr ""
"如果 *clockid* 为 :const:`time.CLOCK_MONOTONIC`，将使用一个不可设置的单调递增时钟。 "
"即使系统时钟发生改变，计时器设置也不会受影响。"

#: ../../library/os.rst:3984
msgid ""
"If *clockid* is :const:`time.CLOCK_BOOTTIME`, same as "
":const:`time.CLOCK_MONOTONIC` except it includes any time that the system is"
" suspended."
msgstr ""
"如果 *clockid* 为 :const:`time.CLOCK_BOOTTIME`，将与 :const:`time.CLOCK_MONOTONIC`"
" 相似，不同之处在于它还包括任何系统挂起的时间。"

#: ../../library/os.rst:3987
msgid ""
"The file descriptor's behaviour can be modified by specifying a *flags* "
"value. Any of the following variables may used, combined using bitwise OR "
"(the ``|`` operator):"
msgstr ""
"这个文件描述符的行为可以通过指定 *flags* 值来改变。 可以使用以下任意变量，可以使用按位 OR (``|`` 运算符) 来进行组合："

#: ../../library/os.rst:3991
msgid ":const:`TFD_NONBLOCK`"
msgstr ":const:`TFD_NONBLOCK`"

#: ../../library/os.rst:3992
msgid ":const:`TFD_CLOEXEC`"
msgstr ":const:`TFD_CLOEXEC`"

#: ../../library/os.rst:3994
msgid ""
"If :const:`TFD_NONBLOCK` is not set as a flag, :func:`read` blocks until the"
" timer expires. If it is set as a flag, :func:`read` doesn't block, but If "
"there hasn't been an expiration since the last call to read, :func:`read` "
"raises :class:`OSError` with ``errno`` is set to :const:`errno.EAGAIN`."
msgstr ""
"如果未将 :const:`TFD_NONBLOCK` 设为一个旗标，:func:`read` 将会阻塞直至计时器到期。 如果它被设为旗标，则 "
":func:`read` 不会阻塞，但是如果自从上次对 read 的调用以来尚未有一次到期，:func:`read` 将引发 "
":class:`OSError` 并将 ``errno`` 设为 :const:`errno.EAGAIN`。"

#: ../../library/os.rst:4000
msgid ":const:`TFD_CLOEXEC` is always set by Python automatically."
msgstr ":const:`TFD_CLOEXEC` 总是会由 Python 自动设置。"

#: ../../library/os.rst:4002
msgid ""
"The file descriptor must be closed with :func:`os.close` when it is no "
"longer needed, or else the file descriptor will be leaked."
msgstr "该文件描述符在其不再需要时必须通过 :func:`os.close` 来关闭，否则文件描述符将被泄漏。"

#: ../../library/os.rst:4005
msgid "The :manpage:`timerfd_create(2)` man page."
msgstr ":manpage:`timerfd_create(2)` 帮助页。"

#: ../../library/os.rst:4014
msgid ""
"Alter a timer file descriptor's internal timer. This function operates the "
"same interval timer as :func:`timerfd_settime_ns`."
msgstr "修改一个计时器文件描述符的内部计时器。 此函数将操作与 :func:`timerfd_settime_ns` 相同的间隔计时器。"

#: ../../library/os.rst:4017
msgid "*fd* must be a valid timer file descriptor."
msgstr "*fd* 必须是一个有效的计时器文件描述符。"

#: ../../library/os.rst:4019
msgid ""
"The timer's behaviour can be modified by specifying a *flags* value. Any of "
"the following variables may used, combined using bitwise OR (the ``|`` "
"operator):"
msgstr "该计时器的行为可以通过指定 *flags* 值来改变。 可以使用以下任意变量，可以使用按位 OR (``|`` 运算符) 来进行组合："

#: ../../library/os.rst:4023
msgid ":const:`TFD_TIMER_ABSTIME`"
msgstr ":const:`TFD_TIMER_ABSTIME`"

#: ../../library/os.rst:4024
msgid ":const:`TFD_TIMER_CANCEL_ON_SET`"
msgstr ":const:`TFD_TIMER_CANCEL_ON_SET`"

#: ../../library/os.rst:4026
msgid ""
"The timer is disabled by setting *initial* to zero (``0``). If *initial* is "
"equal to or greater than zero, the timer is enabled. If *initial* is less "
"than zero, it raises an :class:`OSError` exception with ``errno`` set to "
":const:`errno.EINVAL`"
msgstr ""
"该计时器可通过将 *initial* 设为零 (``0``) 来禁用。 如果 *initial* 大于零，计时器将被启用。 如果 *initial* "
"小于零，它将引发 :class:`OSError` 异常并将 ``errno`` 设为 :const:`errno.EINVAL`"

#: ../../library/os.rst:4031
msgid ""
"By default the timer will fire when *initial* seconds have elapsed. (If "
"*initial* is zero, timer will fire immediately.)"
msgstr "在默认情况下计时器将在经过 *initial* 秒后启动。 （如果 *initial* 为零，计时器将立即启动。）"

#: ../../library/os.rst:4034
msgid ""
"However, if the :const:`TFD_TIMER_ABSTIME` flag is set, the timer will fire "
"when the timer's clock (set by *clockid* in :func:`timerfd_create`) reaches "
"*initial* seconds."
msgstr ""
"但是，如果设置了 :const:`TFD_TIMER_ABSTIME` 旗标，计时器将在计时器时钟 (由 :func:`timerfd_create` "
"中的 *clockid* 设置) 达到 *initial* 秒时启动。"

#: ../../library/os.rst:4038
msgid ""
"The timer's interval is set by the *interval* :py:class:`float`. If "
"*interval* is zero, the timer only fires once, on the initial expiration. If"
" *interval* is greater than zero, the timer fires every time *interval* "
"seconds have elapsed since the previous expiration. If *interval* is less "
"than zero, it raises :class:`OSError` with ``errno`` set to "
":const:`errno.EINVAL`"
msgstr ""
"计时器的间隔时间是通过 *interval* :py:class:`float` 设置的。 如果 *interval* "
"为零，计时器将只在初始到期时启动一次。 如果 *interval* 大于零，计时器将从上一次到期后每经过 *interval* 秒启动一次。 如果 "
"*interval* 小于零，它将引发 :class:`OSError` 并将 ``errno`` 设为 :const:`errno.EINVAL`"

#: ../../library/os.rst:4045
msgid ""
"If the :const:`TFD_TIMER_CANCEL_ON_SET` flag is set along with "
":const:`TFD_TIMER_ABSTIME` and the clock for this timer is "
":const:`time.CLOCK_REALTIME`, the timer is marked as cancelable if the real-"
"time clock is changed discontinuously. Reading the descriptor is aborted "
"with the error ECANCELED."
msgstr ""
"如果 :const:`TFD_TIMER_CANCEL_ON_SET` 旗标与 :const:`TFD_TIMER_ABSTIME` "
"一起被设置并且用于此计时器的时钟为 :const:`time.CLOCK_REALTIME`，则当实时计时器发生不连续改变时计时器将被标记为可取消的。 "
"对描述符的读取将被取消并设置 ECANCELED 错误。"

#: ../../library/os.rst:4051
msgid ""
"Linux manages system clock as UTC. A daylight-savings time transition is "
"done by changing time offset only and doesn't cause discontinuous system "
"clock change."
msgstr "Linux 将以 UTC 来管理系统时钟。 夏令时调整是仅通过修改时差完成的而不会导致不连续的系统时钟改变。"

#: ../../library/os.rst:4055
msgid ""
"Discontinuous system clock change will be caused by the following events:"
msgstr "下列事件会导致不连续的系统时钟变化："

#: ../../library/os.rst:4057
msgid "``settimeofday``"
msgstr "``settimeofday``"

#: ../../library/os.rst:4058
msgid "``clock_settime``"
msgstr "``clock_settime``"

#: ../../library/os.rst:4059
msgid "set the system date and time by ``date`` command"
msgstr "通过 ``date`` 命令设置系统日期和时间"

#: ../../library/os.rst:4061
msgid ""
"Return a two-item tuple of (``next_expiration``, ``interval``) from the "
"previous timer state, before this function executed."
msgstr "根据此函数执行之前的计时器状态，返回一个二元组 (``next_expiration``, ``interval``)。"

#: ../../library/os.rst:4066
msgid ""
":manpage:`timerfd_create(2)`, :manpage:`timerfd_settime(2)`, "
":manpage:`settimeofday(2)`, :manpage:`clock_settime(2)`, and "
":manpage:`date(1)`."
msgstr ""
":manpage:`timerfd_create(2)`, :manpage:`timerfd_settime(2)`, "
":manpage:`settimeofday(2)`, :manpage:`clock_settime(2)` 以及 "
":manpage:`date(1)`。"

#: ../../library/os.rst:4077
msgid ""
"Similar to :func:`timerfd_settime`, but use time as nanoseconds. This "
"function operates the same interval timer as :func:`timerfd_settime`."
msgstr ""
"与 :func:`timerfd_settime` 类似，但使用纳秒形式的时间。 此函数将操作与 :func:`timerfd_settime` "
"相同的间隔计时器。"

#: ../../library/os.rst:4087
msgid "Return a two-item tuple of floats (``next_expiration``, ``interval``)."
msgstr "返回一个浮点数形式的二元组 (``next_expiration``, ``interval``)。"

#: ../../library/os.rst:4089
msgid ""
"``next_expiration`` denotes the relative time until next the timer next "
"fires, regardless of if the :const:`TFD_TIMER_ABSTIME` flag is set."
msgstr ""
"``next_expiration`` 表示距离定时器下一次启动的相对时间，无论是否设置了 :const:`TFD_TIMER_ABSTIME` 旗标。"

#: ../../library/os.rst:4092
msgid ""
"``interval`` denotes the timer's interval. If zero, the timer will only fire"
" once, after ``next_expiration`` seconds have elapsed."
msgstr "``interval`` 表示计时器的间隔。 如果为零，该计时器将只启动一次，即在经过了 ``next_expiration`` 秒之后。"

#: ../../library/os.rst:4096
msgid ":manpage:`timerfd_gettime(2)`"
msgstr ":manpage:`timerfd_gettime(2)`"

#: ../../library/os.rst:4105
msgid "Similar to :func:`timerfd_gettime`, but return time as nanoseconds."
msgstr "与 :func:`timerfd_gettime` 类似，但返回以纳秒为单位的时间。"

#: ../../library/os.rst:4113
msgid ""
"A flag for the :func:`timerfd_create` function, which sets the "
":const:`O_NONBLOCK` status flag for the new timer file descriptor. If "
":const:`TFD_NONBLOCK` is not set as a flag, :func:`read` blocks."
msgstr ""
"一个用于 :func:`timerfd_create` 函数的旗标，它将为新的计时器文件描述符设置 :const:`O_NONBLOCK` 状态旗标。 "
"如果未将 :const:`TFD_NONBLOCK` 设为旗标，:func:`read` 将会阻塞。"

#: ../../library/os.rst:4123
msgid ""
"A flag for the :func:`timerfd_create` function, If :const:`TFD_CLOEXEC` is "
"set as a flag, set close-on-exec flag for new file descriptor."
msgstr ""
"一个用于 :func:`timerfd_create` 函数的旗标，如果将 :const:`TFD_CLOEXEC` 设为旗标，将为新的文件描述符设置 "
"close-on-exec 旗标。"

#: ../../library/os.rst:4133
msgid ""
"A flag for the :func:`timerfd_settime` and :func:`timerfd_settime_ns` "
"functions. If this flag is set, *initial* is interpreted as an absolute "
"value on the timer's clock (in UTC seconds or nanoseconds since the Unix "
"Epoch)."
msgstr ""
"一个用于 :func:`timerfd_settime` 和 :func:`timerfd_settime_ns` 函数的旗标。 "
"如果设置了此旗标，*initial* 将被解读为计时器时钟上的一个绝对数值（即自 Unix 纪元开始的 UTC 秒数或纳秒数）。"

#: ../../library/os.rst:4143
msgid ""
"A flag for the :func:`timerfd_settime` and :func:`timerfd_settime_ns` "
"functions along with :const:`TFD_TIMER_ABSTIME`. The timer is cancelled when"
" the time of the underlying clock changes discontinuously."
msgstr ""
"一个配合 :const:`TFD_TIMER_ABSTIME` 用于 :func:`timerfd_settime` 和 "
":func:`timerfd_settime_ns` 函数的旗标。 当下层时钟发生不连续改变时计时器将被取消。"

#: ../../library/os.rst:4154
msgid "Linux extended attributes"
msgstr "Linux 扩展属性"

#: ../../library/os.rst:4158
msgid "These functions are all available on Linux only."
msgstr "这些函数仅在 Linux 上可用。"

#: ../../library/os.rst:4162
msgid ""
"Return the value of the extended filesystem attribute *attribute* for "
"*path*. *attribute* can be bytes or str (directly or indirectly through the "
":class:`PathLike` interface). If it is str, it is encoded with the "
"filesystem encoding."
msgstr ""
"返回 *path* 的扩展文件系统属性 *attribute* 的值。*attribute* 可以是 bytes 或 str （直接传入或通过 "
":class:`PathLike` 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。"

#: ../../library/os.rst:4170
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.getxattr`` with arguments "
"``path``, ``attribute``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.getxattr`` 并附带参数 ``path``, ``attribute``。"

#: ../../library/os.rst:4172 ../../library/os.rst:4204
#: ../../library/os.rst:4229
msgid "Accepts a :term:`path-like object` for *path* and *attribute*."
msgstr "接受一个 :term:`类路径对象 <path-like object>` 作为 *path* 和 *attribute*。"

#: ../../library/os.rst:4178
msgid ""
"Return a list of the extended filesystem attributes on *path*.  The "
"attributes in the list are represented as strings decoded with the "
"filesystem encoding.  If *path* is ``None``, :func:`listxattr` will examine "
"the current directory."
msgstr ""
"返回一个列表，包含 *path* 的所有扩展文件系统属性。列表中的属性都表示为字符串，它们是根据文件系统编码解码出来的。如果 *path* 为 "
"``None``，则 :func:`listxattr` 将检查当前目录。"

#: ../../library/os.rst:4186
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listxattr`` with argument "
"``path``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.listxattr`` 并附带参数 ``path``。"

#: ../../library/os.rst:4194
msgid ""
"Removes the extended filesystem attribute *attribute* from *path*. "
"*attribute* should be bytes or str (directly or indirectly through the "
":class:`PathLike` interface). If it is a string, it is encoded with the "
":term:`filesystem encoding and error handler`."
msgstr ""
"移除 *path* 中的扩展文件系统属性 *attribute*。 *attribute* 应为字节串或字符串类型（通过 "
":class:`PathLike` 接口直接或间接得到）。 若为字符串类型，则用 :term:`filesystem encoding and "
"error handler` 进行编码。"

#: ../../library/os.rst:4202
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.removexattr`` with arguments"
" ``path``, ``attribute``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.removexattr`` 并附带参数 ``path``, "
"``attribute``。"

#: ../../library/os.rst:4210
msgid ""
"Set the extended filesystem attribute *attribute* on *path* to *value*. "
"*attribute* must be a bytes or str with no embedded NULs (directly or "
"indirectly through the :class:`PathLike` interface). If it is a str, it is "
"encoded with the :term:`filesystem encoding and error handler`.  *flags* may"
" be :data:`XATTR_REPLACE` or :data:`XATTR_CREATE`. If :data:`XATTR_REPLACE` "
"is given and the attribute does not exist, ``ENODATA`` will be raised. If "
":data:`XATTR_CREATE` is given and the attribute already exists, the "
"attribute will not be created and ``EEXISTS`` will be raised."
msgstr ""
"将 *path* 的文件系统扩展属性 *attribute* 设为 *value*。 *attribute* 必须是一个字节串或字符串，不含 "
"NUL（通过 :class:`PathLike` 接口直接或间接得到）。 若为字符串，将用 :term:`filesystem encoding and"
" error handler` 进行编码。 *flags* 可以是 :data:`XATTR_REPLACE` 或 "
":data:`XATTR_CREATE`。 如果给出 :data:`XATTR_REPLACE` 而属性不存在，则会触发 ``ENODATA``。 "
"如果给出了 :data:`XATTR_CREATE` 而属性已存在，则不会创建属性并将触发 ``EEXISTS``。"

#: ../../library/os.rst:4224
msgid ""
"A bug in Linux kernel versions less than 2.6.39 caused the flags argument to"
" be ignored on some filesystems."
msgstr "Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，flags 参数会被忽略。"

#: ../../library/os.rst:4227
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.setxattr`` with arguments "
"``path``, ``attribute``, ``value``, ``flags``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.setxattr`` 并附带参数 ``path``, ``attribute``, "
"``value``, ``flags``。"

#: ../../library/os.rst:4235
msgid ""
"The maximum size the value of an extended attribute can be. Currently, this "
"is 64 KiB on Linux."
msgstr "一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。"

#: ../../library/os.rst:4241
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must create an attribute."
msgstr "这是 :func:`setxattr` 的 flags 参数的可取值，它表示该操作必须创建一个属性。"

#: ../../library/os.rst:4247
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must replace an existing attribute."
msgstr "这是 :func:`setxattr` 的 flags 参数的可取值，它表示该操作必须替换现有属性。"

#: ../../library/os.rst:4254
msgid "Process Management"
msgstr "进程管理"

#: ../../library/os.rst:4256
msgid "These functions may be used to create and manage processes."
msgstr "下列函数可用于创建和管理进程。"

#: ../../library/os.rst:4258
msgid ""
"The various :func:`exec\\* <execl>` functions take a list of arguments for "
"the new program loaded into the process.  In each case, the first of these "
"arguments is passed to the new program as its own name rather than as an "
"argument a user may have typed on a command line.  For the C programmer, "
"this is the ``argv[0]`` passed to a program's :c:func:`main`.  For example, "
"``os.execv('/bin/echo', ['foo', 'bar'])`` will only print ``bar`` on "
"standard output; ``foo`` will seem to be ignored."
msgstr ""
"所有 :func:`exec\\* <execl>` "
"函数都接受一个参数列表，用来给新程序加载到它的进程中。在所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令行上输入的参数。对于 C "
"程序员来说，这就是传递给 :c:func:`main` 函数的 ``argv[0]``。例如，``os.execv('/bin/echo', "
"['foo', 'bar'])`` 只会在标准输出上打印 ``bar``，而 ``foo`` 会被忽略。"

#: ../../library/os.rst:4269
msgid ""
"Generate a :const:`SIGABRT` signal to the current process.  On Unix, the "
"default behavior is to produce a core dump; on Windows, the process "
"immediately returns an exit code of ``3``.  Be aware that calling this "
"function will not call the Python signal handler registered for "
":const:`SIGABRT` with :func:`signal.signal`."
msgstr ""
"发送 :const:`SIGABRT` 信号到当前进程。在 Unix 上，默认行为是生成一个核心转储。在 Windows 上，该进程立即返回退出代码 "
"``3``。请注意，使用 :func:`signal.signal` 可以为 :const:`SIGABRT` 注册 Python "
"信号处理程序，而调用本函数将不会调用按前述方法注册的程序。"

#: ../../library/os.rst:4278
msgid "Add a path to the DLL search path."
msgstr "将路径添加到 DLL 搜索路径。"

#: ../../library/os.rst:4280
msgid ""
"This search path is used when resolving dependencies for imported extension "
"modules (the module itself is resolved through :data:`sys.path`), and also "
"by :mod:`ctypes`."
msgstr ""
"当需要解析扩展模块的依赖时（扩展模块本身通过 :data:`sys.path` 解析），会使用该搜索路径，:mod:`ctypes` "
"也会使用该搜索路径。"

#: ../../library/os.rst:4284
msgid ""
"Remove the directory by calling **close()** on the returned object or using "
"it in a :keyword:`with` statement."
msgstr "要移除目录，可以在返回的对象上调用 **close()**，也可以在 :keyword:`with` 语句内使用本方法。"

#: ../../library/os.rst:4287
msgid ""
"See the `Microsoft documentation "
"<https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_ for more"
" information about how DLLs are loaded."
msgstr ""
"参阅 `Microsoft 文档 "
"<https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_ 获取如何加载 "
"DLL 的信息。"

#: ../../library/os.rst:4291
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.add_dll_directory`` with "
"argument ``path``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.add_dll_directory`` 并附带参数 ``path``。"

#: ../../library/os.rst:4295
msgid ""
"Previous versions of CPython would resolve DLLs using the default behavior "
"for the current process. This led to inconsistencies, such as only sometimes"
" searching :envvar:`PATH` or the current working directory, and OS functions"
" such as ``AddDllDirectory`` having no effect."
msgstr ""
"早期版本的 CPython 解析 DLL 时用的是当前进程的默认行为。这会导致不一致，比如不是每次都会去搜索 :envvar:`PATH` "
"和当前工作目录，且系统函数（如 ``AddDllDirectory`` ）失效。"

#: ../../library/os.rst:4302
msgid ""
"In 3.8, the two primary ways DLLs are loaded now explicitly override the "
"process-wide behavior to ensure consistency. See the :ref:`porting notes "
"<bpo-36085-whatsnew>` for information on updating libraries."
msgstr ""
"在 3.8 中，DLL 的两种主要加载方式现在可以显式覆盖进程的行为，以确保一致性。请参阅 :ref:`移植说明 "
"<bpo-36085-whatsnew>` 了解如何更新你的库。"

#: ../../library/os.rst:4317
msgid ""
"These functions all execute a new program, replacing the current process; "
"they do not return.  On Unix, the new executable is loaded into the current "
"process, and will have the same process id as the caller.  Errors will be "
"reported as :exc:`OSError` exceptions."
msgstr ""
"这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 "
":exc:`OSError` 异常。"

#: ../../library/os.rst:4322
msgid ""
"The current process is replaced immediately. Open file objects and "
"descriptors are not flushed, so if there may be data buffered on these open "
"files, you should flush them using :func:`sys.stdout.flush` or "
":func:`os.fsync` before calling an :func:`exec\\* <execl>` function."
msgstr ""
"当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这些文件上可能缓冲了数据，则应在调用 :func:`exec\\* <execl>` "
"函数之前使用 :func:`sys.stdout.flush` 或 :func:`os.fsync` 刷新它们。"

#: ../../library/os.rst:4328
msgid ""
"The \"l\" and \"v\" variants of the :func:`exec\\* <execl>` functions differ"
" in how command-line arguments are passed.  The \"l\" variants are perhaps "
"the easiest to work with if the number of parameters is fixed when the code "
"is written; the individual parameters simply become additional parameters to"
" the :func:`!execl\\*` functions.  The \"v\" variants are good when the "
"number of parameters is variable, with the arguments being passed in a list "
"or tuple as the *args* parameter.  In either case, the arguments to the "
"child process should start with the name of the command being run, but this "
"is not enforced."
msgstr ""
":func:`exec\\* <execl>` 函数的 \"l\" 和 \"v\" 变体的不同在于命令行参数的传递方式。 "
"如果在编写代码时形参数量是固定的，则 \"l\" 变体可能是最方便的；单个形参简单地作为传给 :func:`!execl\\*` 函数的额外形参即可。 "
"当形参数量可变时则 \"v\" 变体更为好用，参数将以列表或元组的形式作为 *args* 形参传入。 "
"在这两种情况下，传给子进程的参数应当以要运行的命令名称开头，但这不是强制性的。"

#: ../../library/os.rst:4337
msgid ""
"The variants which include a \"p\" near the end (:func:`execlp`, "
":func:`execlpe`, :func:`execvp`, and :func:`execvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When the "
"environment is being replaced (using one of the :func:`exec\\*e <execl>` "
"variants, discussed in the next paragraph), the new environment is used as "
"the source of the :envvar:`PATH` variable. The other variants, "
":func:`execl`, :func:`execle`, :func:`execv`, and :func:`execve`, will not "
"use the :envvar:`PATH` variable to locate the executable; *path* must "
"contain an appropriate absolute or relative path. Relative paths must "
"include at least one slash, even on Windows, as plain names will not be "
"resolved."
msgstr ""
"在结尾位置包括 \"p\" 的变体形式 (:func:`execlp`, :func:`execlpe`, :func:`execvp` 和 "
":func:`execvpe`) 将使用 :envvar:`PATH` 环境变量来定位程序 *file*。 当环境被替换时 (使用某个 "
":func:`exec\\*e <execl>` 变体形式，将在下一段中讨论)，将使用新环境作为 :envvar:`PATH` 变量的来源。 "
"其他的变体形式 :func:`execl`, :func:`execle`, :func:`execv` 和 :func:`execve` 将不使用 "
":envvar:`PATH` 变量来定位可执行程序；*path* 必须包含正确的绝对或相对路径。 相对路径必须包括至少一个斜杠，即使是在 Windows"
" 上，因为简单名称将不会被解析。"

#: ../../library/os.rst:4348
msgid ""
"For :func:`execle`, :func:`execlpe`, :func:`execve`, and :func:`execvpe` "
"(note that these all end in \"e\"), the *env* parameter must be a mapping "
"which is used to define the environment variables for the new process (these"
" are used instead of the current process' environment); the functions "
":func:`execl`, :func:`execlp`, :func:`execv`, and :func:`execvp` all cause "
"the new process to inherit the environment of the current process."
msgstr ""
"对于 :func:`execle`、:func:`execlpe`、:func:`execve` 和 :func:`execvpe` （都以 \"e\""
" 结尾），*env* 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 "
":func:`execl`、:func:`execlp`、:func:`execv` 和 :func:`execvp` "
"会将当前进程的环境变量过继给新进程。"

#: ../../library/os.rst:4355
msgid ""
"For :func:`execve` on some platforms, *path* may also be specified as an "
"open file descriptor.  This functionality may not be supported on your "
"platform; you can check whether or not it is available using "
":data:`os.supports_fd`. If it is unavailable, using it will raise a "
":exc:`NotImplementedError`."
msgstr ""
"某些平台上的 :func:`execve` 可以将 *path* 指定为打开的文件描述符。当前平台可能不支持此功能，可以使用 "
":data:`os.supports_fd` 检查它是否支持。如果不可用，则使用它会抛出 :exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:4360
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.exec`` with arguments "
"``path``, ``args``, ``env``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.exec`` 并附带参数 ``path``, ``args``, ``env``。"

#: ../../library/os.rst:4364
msgid ""
"Added support for specifying *path* as an open file descriptor for "
":func:`execve`."
msgstr "新增支持将 :func:`execve` 的 *path* 参数指定为打开的文件描述符。"

#: ../../library/os.rst:4373
msgid ""
"Exit the process with status *n*, without calling cleanup handlers, flushing"
" stdio buffers, etc."
msgstr "以状态码 *n* 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。"

#: ../../library/os.rst:4378
msgid ""
"The standard way to exit is :func:`sys.exit(n) <sys.exit>`.  :func:`!_exit` "
"should normally only be used in the child process after a :func:`fork`."
msgstr ""
"退出的标准方式是使用 :func:`sys.exit(n) <sys.exit>`。 :func:`!_exit` 通常只应在 :func:`fork`"
" 所生成的子进程中使用。"

#: ../../library/os.rst:4381
msgid ""
"The following exit codes are defined and can be used with :func:`_exit`, "
"although they are not required.  These are typically used for system "
"programs written in Python, such as a mail server's external command "
"delivery program."
msgstr ""
"以下是已定义的退出代码，可以用于 :func:`_exit`，尽管它们不是必需的。这些退出代码通常用于 Python "
"编写的系统程序，例如邮件服务器的外部命令传递程序。"

#: ../../library/os.rst:4387
msgid ""
"Some of these may not be available on all Unix platforms, since there is "
"some variation.  These constants are defined where they are defined by the "
"underlying platform."
msgstr "其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如果底层平台定义了这些常量，那上层也会定义。"

#: ../../library/os.rst:4394
msgid ""
"Exit code that means no error occurred. May be taken from the defined value "
"of ``EXIT_SUCCESS`` on some platforms. Generally has a value of zero."
msgstr "表示没有发生错误的退出码。 在某些平台上可能会从 ``EXIT_SUCCESS`` 定义的值中选取。 通常其值为零。"

#: ../../library/os.rst:4402
msgid ""
"Exit code that means the command was used incorrectly, such as when the "
"wrong number of arguments are given."
msgstr "退出代码，表示命令使用不正确，如给出的参数数量有误。"

#: ../../library/os.rst:4410
msgid "Exit code that means the input data was incorrect."
msgstr "退出代码，表示输入数据不正确。"

#: ../../library/os.rst:4417
msgid "Exit code that means an input file did not exist or was not readable."
msgstr "退出代码，表示某个输入文件不存在或不可读。"

#: ../../library/os.rst:4424
msgid "Exit code that means a specified user did not exist."
msgstr "退出代码，表示指定的用户不存在。"

#: ../../library/os.rst:4431
msgid "Exit code that means a specified host did not exist."
msgstr "退出代码，表示指定的主机不存在。"

#: ../../library/os.rst:4438
msgid "Exit code that means that a required service is unavailable."
msgstr "退出代码，表示所需的服务不可用。"

#: ../../library/os.rst:4445
msgid "Exit code that means an internal software error was detected."
msgstr "退出代码，表示检测到内部软件错误。"

#: ../../library/os.rst:4452
msgid ""
"Exit code that means an operating system error was detected, such as the "
"inability to fork or create a pipe."
msgstr "退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。"

#: ../../library/os.rst:4460
msgid ""
"Exit code that means some system file did not exist, could not be opened, or"
" had some other kind of error."
msgstr "退出代码，表示某些系统文件不存在、无法打开或发生其他错误。"

#: ../../library/os.rst:4468
msgid ""
"Exit code that means a user specified output file could not be created."
msgstr "退出代码，表示无法创建用户指定的输出文件。"

#: ../../library/os.rst:4475
msgid ""
"Exit code that means that an error occurred while doing I/O on some file."
msgstr "退出代码，表示对某些文件进行读写时发生错误。"

#: ../../library/os.rst:4482
msgid ""
"Exit code that means a temporary failure occurred.  This indicates something"
" that may not really be an error, such as a network connection that couldn't"
" be made during a retryable operation."
msgstr "退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在可重试的情况下无法建立网络连接。"

#: ../../library/os.rst:4491
msgid ""
"Exit code that means that a protocol exchange was illegal, invalid, or not "
"understood."
msgstr "退出代码，表示协议交换是非法的、无效的或无法解读的。"

#: ../../library/os.rst:4499
msgid ""
"Exit code that means that there were insufficient permissions to perform the"
" operation (but not intended for file system problems)."
msgstr "退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。"

#: ../../library/os.rst:4507
msgid "Exit code that means that some kind of configuration error occurred."
msgstr "退出代码，表示发生某种配置错误。"

#: ../../library/os.rst:4514
msgid "Exit code that means something like \"an entry was not found\"."
msgstr "退出代码，表示的内容类似于“找不到条目”。"

#: ../../library/os.rst:4521
msgid ""
"Fork a child process.  Return ``0`` in the child and the child's process id "
"in the parent.  If an error occurs :exc:`OSError` is raised."
msgstr ""
"Fork 出一个子进程。在子进程中返回 ``0``，在父进程中返回子进程的进程号。如果发生错误，则抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:4524
msgid ""
"Note that some platforms including FreeBSD <= 6.3 and Cygwin have known "
"issues when using ``fork()`` from a thread."
msgstr "注意，当从线程中使用 ``fork()`` 时，某些平台（包括 FreeBSD <= 6.3 和 Cygwin）存在已知问题。"

#: ../../library/os.rst:4527
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.fork`` with no arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``os.fork``。"

#: ../../library/os.rst:4531
msgid ""
"If you use TLS sockets in an application calling ``fork()``, see the warning"
" in the :mod:`ssl` documentation."
msgstr "如果你在调用 ``fork()`` 的应用程序中使用 TLS 套接字，请参阅 :mod:`ssl` 文档中的警告信息。"

#: ../../library/os.rst:4536 ../../library/os.rst:4580
msgid ""
"On macOS the use of this function is unsafe when mixed with using higher-"
"level system APIs, and that includes using :mod:`urllib.request`."
msgstr "在 macOS 上将此函数与高层级的系统 API 混用是不安全的，包括 :mod:`urllib.request`。"

#: ../../library/os.rst:4539
msgid ""
"Calling ``fork()`` in a subinterpreter is no longer supported "
"(:exc:`RuntimeError` is raised)."
msgstr "不再支持在子解释器中调用 ``fork()`` （将抛出 :exc:`RuntimeError` 异常）。"

#: ../../library/os.rst:4543
msgid ""
"If Python is able to detect that your process has multiple threads, "
":func:`os.fork` now raises a :exc:`DeprecationWarning`."
msgstr ""
"如果 Python 能够检测到你的进程有多个线程，则 :func:`os.fork` 现在会引发 :exc:`DeprecationWarning`。"

#: ../../library/os.rst:4547
msgid ""
"We chose to surface this as a warning, when detectable, to better inform "
"developers of a design problem that the POSIX platform specifically notes as"
" not supported. Even in code that *appears* to work, it has never been safe "
"to mix threading with :func:`os.fork` on POSIX platforms. The CPython "
"runtime itself has always made API calls that are not safe for use in the "
"child process when threads existed in the parent (such as ``malloc`` and "
"``free``)."
msgstr ""
"在可以检测时，我们选择将此显示为警告，以便更好地告知开发人员 POSIX 平台明确指出不支持的设计问题。 在 POSIX 平台上即使在 *看起来* "
"可行的代码中，将线程与 :func:`os.fork` 混用也是不安全的。 当父进程中存在线程时 CPython 运行时本身总是会在子进程中执行不安全的"
" API 调用 (如 ``malloc`` 和 ``free``)。"

#: ../../library/os.rst:4556
msgid ""
"Users of macOS or users of libc or malloc implementations other than those "
"typically found in glibc to date are among those already more likely to "
"experience deadlocks running such code."
msgstr ""
"使用 macOS 的用户或使用 glibc 中可找到的典型实现以外的 libc 或 malloc 实现的用户在运行此类代码时更容易发生死锁现象。"

#: ../../library/os.rst:4560
msgid ""
"See `this discussion on fork being incompatible with threads "
"<https://discuss.python.org/t/33555>`_ for technical details of why we're "
"surfacing this longstanding platform compatibility problem to developers."
msgstr ""
"请参阅 `有关 fork 与线程不兼容的讨论 <https://discuss.python.org/t/33555>`_ "
"了解我们为何向开发者公开这个长期存在的平台不兼容性问题的技术细节。"

#: ../../library/os.rst:4570
msgid ""
"Fork a child process, using a new pseudo-terminal as the child's controlling"
" terminal. Return a pair of ``(pid, fd)``, where *pid* is ``0`` in the "
"child, the new child's process id in the parent, and *fd* is the file "
"descriptor of the master end of the pseudo-terminal.  For a more portable "
"approach, use the :mod:`pty` module.  If an error occurs :exc:`OSError` is "
"raised."
msgstr ""
"Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对 ``(pid, fd)``，其中 *pid* 在子进程中为 "
"``0``，这是父进程中新子进程的进程号，而 *fd* 是伪终端主设备的文件描述符。对于更便于移植的方法，请使用 :mod:`pty` "
"模块。如果发生错误，则抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:4576
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.forkpty`` with no arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``os.forkpty``。"

#: ../../library/os.rst:4583
msgid ""
"Calling ``forkpty()`` in a subinterpreter is no longer supported "
"(:exc:`RuntimeError` is raised)."
msgstr "不再支持在子解释器中调用 ``forkpty()`` （将抛出 :exc:`RuntimeError` 异常）。"

#: ../../library/os.rst:4587
msgid ""
"If Python is able to detect that your process has multiple threads, this now"
" raises a :exc:`DeprecationWarning`. See the longer explanation on "
":func:`os.fork`."
msgstr ""
"现在如果 Python 能够检测到你的进程有多个线程，此函数将引发 :exc:`DeprecationWarning`。 请参阅有关 "
":func:`os.fork` 的更详细解释。"

#: ../../library/os.rst:4601
msgid ""
"Send signal *sig* to the process *pid*.  Constants for the specific signals "
"available on the host platform are defined in the :mod:`signal` module."
msgstr "将信号 *sig* 发送至进程 *pid*。特定平台上可用的信号常量定义在 :mod:`signal` 模块中。"

#: ../../library/os.rst:4604
msgid ""
"Windows: The :const:`signal.CTRL_C_EVENT` and "
":const:`signal.CTRL_BREAK_EVENT` signals are special signals which can only "
"be sent to console processes which share a common console window, e.g., some"
" subprocesses. Any other value for *sig* will cause the process to be "
"unconditionally killed by the TerminateProcess API, and the exit code will "
"be set to *sig*."
msgstr ""
"Windows: :const:`signal.CTRL_C_EVENT` 和 :const:`signal.CTRL_BREAK_EVENT` "
"信号是只能被发送给共享同一个控制台窗口的控制台进程例如某些子进程的特殊信号。 任何其他的 *sig* 值都将导致进程被 TerminateProcess"
" API 无条件地杀掉，且退出码将被设为 *sig*。"

#: ../../library/os.rst:4611
msgid "See also :func:`signal.pthread_kill`."
msgstr "另请参阅 :func:`signal.pthread_kill`。"

#: ../../library/os.rst:4613
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.kill`` with arguments "
"``pid``, ``sig``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.kill`` 并附带参数 ``pid``, ``sig``。"

#: ../../library/os.rst:4627
msgid "Send the signal *sig* to the process group *pgid*."
msgstr "将信号 *sig* 发送给进程组 *pgid*。"

#: ../../library/os.rst:4629
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.killpg`` with arguments "
"``pgid``, ``sig``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.killpg`` 并附带参数 ``pgid``, ``sig``。"

#: ../../library/os.rst:4636
msgid "Add *increment* to the process's \"niceness\".  Return the new niceness."
msgstr "将进程的优先级（nice 值）增加 *increment*，返回新的 nice 值。"

#: ../../library/os.rst:4643
msgid ""
"Return a file descriptor referring to the process *pid* with *flags* set. "
"This descriptor can be used to perform process management without races and "
"signals."
msgstr "返回一个指向设置了 *flags* 的进程 *pid* 的文件描述符。 该描述符可用于执行无需竞争和信号的进程管理。"

#: ../../library/os.rst:4647
msgid "See the :manpage:`pidfd_open(2)` man page for more details."
msgstr "更多详细信息请参阅 :manpage:`pidfd_open(2)` 手册页。"

#: ../../library/os.rst:4654
msgid ""
"This flag indicates that the file descriptor will be non-blocking. If the "
"process referred to by the file descriptor has not yet terminated, then an "
"attempt to wait on the file descriptor using :manpage:`waitid(2)` will "
"immediately return the error :const:`~errno.EAGAIN` rather than blocking."
msgstr ""
"该旗标表示文件描述符将是非阻塞的。 如果文件描述符所引用的进程尚未终止，那么尝试使用 :manpage:`waitid(2)` "
"等待文件描述符将立即返回错误 :const:`~errno.EAGAIN` 而不是阻塞。"

#: ../../library/os.rst:4665
msgid ""
"Lock program segments into memory.  The value of *op* (defined in "
"``<sys/lock.h>``) determines which segments are locked."
msgstr "将程序段锁定到内存中。*op* 的值（定义在 ``<sys/lock.h>`` 中）决定了哪些段被锁定。"

#: ../../library/os.rst:4673
msgid ""
"Open a pipe to or from command *cmd*. The return value is an open file "
"object connected to the pipe, which can be read or written depending on "
"whether *mode* is ``'r'`` (default) or ``'w'``. The *buffering* argument "
"have the same meaning as the corresponding argument to the built-in "
":func:`open` function. The returned file object reads or writes text strings"
" rather than bytes."
msgstr ""
"打开一个通往或接受命令 *cmd* 的管道。 返回值是连接到该管道的已打开文件对象，它可读取还是可写入取决于其 *mode* 是 ``'r'`` "
"(默认) 还是 ``'w'``。 *buffering* 参数与内置 :func:`open` 函数相应的参数含义相同。 "
"返回的文件对象只能读写文本字符串而不是字节串。"

#: ../../library/os.rst:4681
msgid ""
"The ``close`` method returns :const:`None` if the subprocess exited "
"successfully, or the subprocess's return code if there was an error. On "
"POSIX systems, if the return code is positive it represents the return value"
" of the process left-shifted by one byte.  If the return code is negative, "
"the process was terminated by the signal given by the negated value of the "
"return code.  (For example, the return value might be ``- signal.SIGKILL`` "
"if the subprocess was killed.)  On Windows systems, the return value "
"contains the signed integer return code from the child process."
msgstr ""
"如果子进程成功退出，则 ``close`` 方法返回 :const:`None`。如果发生错误，则返回子进程的返回码。在 POSIX "
"系统上，如果返回码为正，则它就是进程返回值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码取反后就是该信号。（例如，如果子进程被终止，则返回值可能是"
" ``- signal.SIGKILL``。）在 Windows 系统上，返回值包含子进程的返回码（有符号整数）。"

#: ../../library/os.rst:4691
msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the ``close``"
" method result (exit status) into an exit code if it is not ``None``. On "
"Windows, the ``close`` method result is directly the exit code (or "
"``None``)."
msgstr ""
"在 Unix 上，:func:`waitstatus_to_exitcode` 可以将 ``close`` 方法的返回值（即退出状态，不能是 "
"``None``）转换为退出码。在 Windows 上，``close`` 方法的结果直接就是退出码（或 ``None`` ）。"

#: ../../library/os.rst:4696
msgid ""
"This is implemented using :class:`subprocess.Popen`; see that class's "
"documentation for more powerful ways to manage and communicate with "
"subprocesses."
msgstr "本方法是使用 :class:`subprocess.Popen` 实现的，如需更强大的方法来管理和沟通子进程，请参阅该类的文档。"

#: ../../library/os.rst:4703
msgid ""
"The :ref:`Python UTF-8 Mode <utf8-mode>` affects encodings used for *cmd* "
"and pipe contents."
msgstr ":ref:`Python UTF-8 模型 <utf8-mode>` 影响 *cmd* 和管道内容所使用的编码格式。"

#: ../../library/os.rst:4706
msgid ""
":func:`popen` is a simple wrapper around :class:`subprocess.Popen`. Use "
":class:`subprocess.Popen` or :func:`subprocess.run` to control options like "
"encodings."
msgstr ""
":func:`popen` 是针对 :class:`subprocess.Popen` 的简单包装器。 请使用 "
":class:`subprocess.Popen` 或 :func:`subprocess.run` 来控制编码格式等选项。"

#: ../../library/os.rst:4710
msgid ""
"The function is :term:`soft deprecated` and should no longer be used to "
"write new code. The :mod:`subprocess` module is recommended instead."
msgstr ""

#: ../../library/os.rst:4719
msgid "Wraps the :c:func:`!posix_spawn` C library API for use from Python."
msgstr "包装 :c:func:`!posix_spawn` C 库 API 以供 Python 使用。"

#: ../../library/os.rst:4721
msgid ""
"Most users should use :func:`subprocess.run` instead of :func:`posix_spawn`."
msgstr "大多数用户应使用 :func:`subprocess.run` 代替 :func:`posix_spawn`。"

#: ../../library/os.rst:4723
msgid ""
"The positional-only arguments *path*, *args*, and *env* are similar to "
":func:`execve`. *env* is allowed to be ``None``, in which case current "
"process' environment is used."
msgstr ""
"位置参数 *path*, *args* 和 *env* 与 :func:`execve` 类似。 *env* 允许为 "
"``None``，在此情况下将使用当前进程的环境。"

#: ../../library/os.rst:4727
msgid ""
"The *path* parameter is the path to the executable file.  The *path* should "
"contain a directory.  Use :func:`posix_spawnp` to pass an executable file "
"without directory."
msgstr ""
"*path* 形参是可执行文件的路径，*path* 中应当包含目录。 使用 :func:`posix_spawnp` 可传入不带目录的可执行文件。"

#: ../../library/os.rst:4731
msgid ""
"The *file_actions* argument may be a sequence of tuples describing actions "
"to take on specific file descriptors in the child process between the C "
"library implementation's :c:func:`fork` and :c:func:`exec` steps. The first "
"item in each tuple must be one of the three type indicator listed below "
"describing the remaining tuple elements:"
msgstr ""
"*file_actions* 参数可以是由元组组成的序列，序列描述了对子进程中指定文件描述符采取的操作，这些操作会在 C 库实现的 "
":c:func:`fork` 和 :c:func:`exec` "
"步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一，用于描述元组剩余的元素："

#: ../../library/os.rst:4739
msgid "(``os.POSIX_SPAWN_OPEN``, *fd*, *path*, *flags*, *mode*)"
msgstr "(``os.POSIX_SPAWN_OPEN``, *fd*, *path*, *flags*, *mode*)"

#: ../../library/os.rst:4741
msgid "Performs ``os.dup2(os.open(path, flags, mode), fd)``."
msgstr "执行 ``os.dup2(os.open(path, flags, mode), fd)``。"

#: ../../library/os.rst:4745
msgid "(``os.POSIX_SPAWN_CLOSE``, *fd*)"
msgstr "(``os.POSIX_SPAWN_CLOSE``, *fd*)"

#: ../../library/os.rst:4747
msgid "Performs ``os.close(fd)``."
msgstr "执行 ``os.close(fd)``。"

#: ../../library/os.rst:4751
msgid "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"
msgstr "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"

#: ../../library/os.rst:4753
msgid "Performs ``os.dup2(fd, new_fd)``."
msgstr "执行 ``os.dup2(fd, new_fd)``。"

#: ../../library/os.rst:4757
msgid "(``os.POSIX_SPAWN_CLOSEFROM``, *fd*)"
msgstr "(``os.POSIX_SPAWN_CLOSEFROM``, *fd*)"

#: ../../library/os.rst:4759
msgid "Performs ``os.closerange(fd, INF)``."
msgstr "执行  ``os.closerange(fd, INF)`` 。"

#: ../../library/os.rst:4761
msgid ""
"These tuples correspond to the C library "
":c:func:`!posix_spawn_file_actions_addopen`, "
":c:func:`!posix_spawn_file_actions_addclose`, "
":c:func:`!posix_spawn_file_actions_adddup2`, and "
":c:func:`!posix_spawn_file_actions_addclosefrom_np` API calls used to "
"prepare for the :c:func:`!posix_spawn` call itself."
msgstr ""
"这些元组对应于 C 库 :c:func:`!posix_spawn_file_actions_addopen`, "
":c:func:`!posix_spawn_file_actions_addclose`, "
":c:func:`!posix_spawn_file_actions_adddup2` 和 "
":c:func:`!posix_spawn_file_actions_addclosefrom_np` API 调用，用于为 "
":c:func:`!posix_spawn` 调用本身做准备。"

#: ../../library/os.rst:4768
msgid ""
"The *setpgroup* argument will set the process group of the child to the "
"value specified. If the value specified is 0, the child's process group ID "
"will be made the same as its process ID. If the value of *setpgroup* is not "
"set, the child will inherit the parent's process group ID. This argument "
"corresponds to the C library :c:macro:`!POSIX_SPAWN_SETPGROUP` flag."
msgstr ""
"*setpgroup* 参数将把子进程的进程组设置为指定值。 如果指定值为 0，则子进程的进程组 ID 将与其进程 ID 相同。 如果未设置 "
"*setpgroup* 的值，则子进程将继承父进程的进程组 ID。 本参数对应于 C 库的 "
":c:macro:`!POSIX_SPAWN_SETPGROUP` 旗标。"

#: ../../library/os.rst:4774
msgid ""
"If the *resetids* argument is ``True`` it will reset the effective UID and "
"GID of the child to the real UID and GID of the parent process. If the "
"argument is ``False``, then the child retains the effective UID and GID of "
"the parent. In either case, if the set-user-ID and set-group-ID permission "
"bits are enabled on the executable file, their effect will override the "
"setting of the effective UID and GID. This argument corresponds to the C "
"library :c:macro:`!POSIX_SPAWN_RESETIDS` flag."
msgstr ""
"如果 *resetids* 参数为 ``True`` 则它会将子进程的有效 UID 和 GID 重置为父进程的实际 UID 和 GID。 如果该参数为 "
"``False``，则子进程会保留父进程的有效 UID 和 GID。 无论哪种情况，如果在可执行文件上启用了设置用户 ID 和设置组 ID "
"权限位，它们的效果将覆盖有效 UID 和 GID 的设置。 本参数对应于 C 库的 :c:macro:`!POSIX_SPAWN_RESETIDS` "
"旗标。"

#: ../../library/os.rst:4782
msgid ""
"If the *setsid* argument is ``True``, it will create a new session ID for "
"``posix_spawn``. *setsid* requires :c:macro:`!POSIX_SPAWN_SETSID` or "
":c:macro:`!POSIX_SPAWN_SETSID_NP` flag. Otherwise, "
":exc:`NotImplementedError` is raised."
msgstr ""
"如果 *setsid* 参数为 ``True``，它将为 ``posix_spawn`` 新建一个会话 ID。 *setsid* 需要 "
":c:macro:`!POSIX_SPAWN_SETSID` 或 :c:macro:`!POSIX_SPAWN_SETSID_NP` 旗标。 "
"否则，将会引发 :exc:`NotImplementedError`。"

#: ../../library/os.rst:4787
msgid ""
"The *setsigmask* argument will set the signal mask to the signal set "
"specified. If the parameter is not used, then the child inherits the "
"parent's signal mask. This argument corresponds to the C library "
":c:macro:`!POSIX_SPAWN_SETSIGMASK` flag."
msgstr ""
"*setsigmask* 参数会将信号掩码设置为指定的信号集合。 如果未使用该参数，则子进程将继承父进程的信号掩码。 本参数对应于 C 库的 "
":c:macro:`!POSIX_SPAWN_SETSIGMASK` 旗标。"

#: ../../library/os.rst:4792
msgid ""
"The *sigdef* argument will reset the disposition of all signals in the set "
"specified. This argument corresponds to the C library "
":c:macro:`!POSIX_SPAWN_SETSIGDEF` flag."
msgstr ""
"*sigdef* 参数会将集合中所有信号的操作全部重置为默认。 本参数对应于 C 库的 "
":c:macro:`!POSIX_SPAWN_SETSIGDEF` 旗标。"

#: ../../library/os.rst:4796
msgid ""
"The *scheduler* argument must be a tuple containing the (optional) scheduler"
" policy and an instance of :class:`sched_param` with the scheduler "
"parameters. A value of ``None`` in the place of the scheduler policy "
"indicates that is not being provided. This argument is a combination of the "
"C library :c:macro:`!POSIX_SPAWN_SETSCHEDPARAM` and "
":c:macro:`!POSIX_SPAWN_SETSCHEDULER` flags."
msgstr ""
"*scheduler* 参数必须是一个元组，其中包含（可选的）调度器策略以及携带了调度器参数的 :class:`sched_param` 实例。 "
"在调度器策略所在位置的值为 ``None`` 表示未提供该值。 本参数是 C 库的 "
":c:macro:`!POSIX_SPAWN_SETSCHEDPARAM` 和 :c:macro:`!POSIX_SPAWN_SETSCHEDULER`"
" 旗标的组合。"

#: ../../library/os.rst:4803 ../../library/os.rst:4824
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.posix_spawn`` with arguments"
" ``path``, ``argv``, ``env``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.posix_spawn`` 并附带参数 ``path``, ``argv``, "
"``env``。"

#: ../../library/os.rst:4807
msgid ""
"*env* parameter accepts ``None``. ``os.POSIX_SPAWN_CLOSEFROM`` is available "
"on platforms where :c:func:`!posix_spawn_file_actions_addclosefrom_np` "
"exists."
msgstr ""
"*env* 形参可接受 ``None``。 ``os.POSIX_SPAWN_CLOSEFROM`` 在具有 "
":c:func:`!posix_spawn_file_actions_addclosefrom_np` 的平台上可用。"

#: ../../library/os.rst:4818
msgid "Wraps the :c:func:`!posix_spawnp` C library API for use from Python."
msgstr "包装 :c:func:`!posix_spawnp` C 库 API 以供 Python 使用。"

#: ../../library/os.rst:4820
msgid ""
"Similar to :func:`posix_spawn` except that the system searches for the "
"*executable* file in the list of directories specified by the :envvar:`PATH`"
" environment variable (in the same way as for ``execvp(3)``)."
msgstr ""
"与 :func:`posix_spawn` 相似，但是系统会在 :envvar:`PATH` 环境变量指定的目录列表中搜索可执行文件 "
"*executable* （与 ``execvp(3)`` 相同）。"

#: ../../library/os.rst:4830
msgid "See :func:`posix_spawn` documentation."
msgstr "参见 :func:`posix_spawn` 文档。"

#: ../../library/os.rst:4836
msgid ""
"Register callables to be executed when a new child process is forked using "
":func:`os.fork` or similar process cloning APIs. The parameters are optional"
" and keyword-only. Each specifies a different call point."
msgstr ""
"注册可调用对象，在使用 :func:`os.fork` 或类似的进程克隆 API 派生新的子进程时，这些对象会运行。参数是可选的，且为仅关键字 "
"(Keyword-only) 参数。每个参数指定一个不同的调用点。"

#: ../../library/os.rst:4841
msgid "*before* is a function called before forking a child process."
msgstr "*before* 是一个函数，在 fork 子进程前调用。"

#: ../../library/os.rst:4842
msgid ""
"*after_in_parent* is a function called from the parent process after forking"
" a child process."
msgstr "*after_in_parent* 是一个函数，在 fork 子进程后从父进程调用。"

#: ../../library/os.rst:4844
msgid "*after_in_child* is a function called from the child process."
msgstr "*after_in_child* 是一个函数，从子进程中调用。"

#: ../../library/os.rst:4846
msgid ""
"These calls are only made if control is expected to return to the Python "
"interpreter.  A typical :mod:`subprocess` launch will not trigger them as "
"the child is not going to re-enter the interpreter."
msgstr ""
"只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 :mod:`子进程 <subprocess>` "
"启动时不会触发它们，因为子进程不会重新进入解释器。"

#: ../../library/os.rst:4850
msgid ""
"Functions registered for execution before forking are called in reverse "
"registration order.  Functions registered for execution after forking "
"(either in the parent or in the child) are called in registration order."
msgstr "在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。"

#: ../../library/os.rst:4855
msgid ""
"Note that :c:func:`fork` calls made by third-party C code may not call those"
" functions, unless it explicitly calls :c:func:`PyOS_BeforeFork`, "
":c:func:`PyOS_AfterFork_Parent` and :c:func:`PyOS_AfterFork_Child`."
msgstr ""
"注意，第三方 C 代码的 :c:func:`fork` 调用可能不会调用这些函数，除非它显式调用了 "
":c:func:`PyOS_BeforeFork`、:c:func:`PyOS_AfterFork_Parent` 和 "
":c:func:`PyOS_AfterFork_Child`。"

#: ../../library/os.rst:4859
msgid "There is no way to unregister a function."
msgstr "函数注册后无法注销。"

#: ../../library/os.rst:4875
msgid "Execute the program *path* in a new process."
msgstr "在新进程中执行程序 *path*。"

#: ../../library/os.rst:4877
msgid ""
"(Note that the :mod:`subprocess` module provides more powerful facilities "
"for spawning new processes and retrieving their results; using that module "
"is preferable to using these functions.  Check especially the "
":ref:`subprocess-replacements` section.)"
msgstr ""
"（注意，:mod:`subprocess` 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用这些函数更好。尤其应当检查 "
":ref:`subprocess-replacements` 部分。）"

#: ../../library/os.rst:4882
msgid ""
"If *mode* is :const:`P_NOWAIT`, this function returns the process id of the "
"new process; if *mode* is :const:`P_WAIT`, returns the process's exit code "
"if it exits normally, or ``-signal``, where *signal* is the signal that "
"killed the process.  On Windows, the process id will actually be the process"
" handle, so can be used with the :func:`waitpid` function."
msgstr ""
"*mode* 为 :const:`P_NOWAIT` 时，本函数返回新进程的进程号。*mode* 为 :const:`P_WAIT` "
"时，如果进程正常退出，返回退出代码，如果被终止，返回 ``-signal``，其中 *signal* 是终止进程的信号。在 Windows "
"上，进程号实际上是进程句柄，因此可以与 :func:`waitpid` 函数一起使用。"

#: ../../library/os.rst:4888
msgid ""
"Note on VxWorks, this function doesn't return ``-signal`` when the new "
"process is killed. Instead it raises OSError exception."
msgstr "注意在 VxWorks 上，新进程被终止时，本函数不会返回 ``-signal``，而是会抛出 OSError 异常。"

#: ../../library/os.rst:4891
msgid ""
"The \"l\" and \"v\" variants of the :func:`spawn\\* <spawnl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed when "
"the code is written; the individual parameters simply become additional "
"parameters to the :func:`!spawnl\\*` functions.  The \"v\" variants are good"
" when the number of parameters is variable, with the arguments being passed "
"in a list or tuple as the *args* parameter.  In either case, the arguments "
"to the child process must start with the name of the command being run."
msgstr ""
":func:`spawn\\* <spawnl>` 函数的 \"l\" 和 \"v\" 变体的不同在于命令行参数的传递方式。  "
"如果在编写代码时形参数量是固定的，则 \"l\" 变体可能是最方便的；单个形参简单地作为传给 :func:`!spawnl\\*` 函数的额外形参即可。"
" 当形参数量可变时 \"v\" 变体更为好用，参数将以列表或元组的形式作为 *args* 形参传入。 "
"在这两种情况下，传给子进程的参数应当以要运行的命令名称开头。"

#: ../../library/os.rst:4900
msgid ""
"The variants which include a second \"p\" near the end (:func:`spawnlp`, "
":func:`spawnlpe`, :func:`spawnvp`, and :func:`spawnvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When the "
"environment is being replaced (using one of the :func:`spawn\\*e <spawnl>` "
"variants, discussed in the next paragraph), the new environment is used as "
"the source of the :envvar:`PATH` variable.  The other variants, "
":func:`spawnl`, :func:`spawnle`, :func:`spawnv`, and :func:`spawnve`, will "
"not use the :envvar:`PATH` variable to locate the executable; *path* must "
"contain an appropriate absolute or relative path."
msgstr ""
"结尾包含第二个 \"p\" 的变体（:func:`spawnlp`、:func:`spawnlpe`、:func:`spawnvp` 和 "
":func:`spawnvpe`）将使用 :envvar:`PATH` 环境变量来查找程序 *file*。当环境被替换时（使用下一段讨论的 "
":func:`spawn\\*e <spawnl>` 变体之一），:envvar:`PATH` 变量将来自于新环境。其他变体 "
":func:`spawnl`、:func:`spawnle`、:func:`spawnv` 和 :func:`spawnve` 不使用 "
":envvar:`PATH` 变量来查找程序，因此 *path* 必须包含正确的绝对或相对路径。"

#: ../../library/os.rst:4910
msgid ""
"For :func:`spawnle`, :func:`spawnlpe`, :func:`spawnve`, and :func:`spawnvpe`"
" (note that these all end in \"e\"), the *env* parameter must be a mapping "
"which is used to define the environment variables for the new process (they "
"are used instead of the current process' environment); the functions "
":func:`spawnl`, :func:`spawnlp`, :func:`spawnv`, and :func:`spawnvp` all "
"cause the new process to inherit the environment of the current process.  "
"Note that keys and values in the *env* dictionary must be strings; invalid "
"keys or values will cause the function to fail, with a return value of "
"``127``."
msgstr ""
"对于 :func:`spawnle`、:func:`spawnlpe`、:func:`spawnve` 和 :func:`spawnvpe` （都以 "
"\"e\" 结尾），*env* 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 "
":func:`spawnl`、:func:`spawnlp`、:func:`spawnv` 和 :func:`spawnvp` "
"会将当前进程的环境变量过继给新进程。注意，*env* 字典中的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 ``127``。"

#: ../../library/os.rst:4919
msgid ""
"As an example, the following calls to :func:`spawnlp` and :func:`spawnvpe` "
"are equivalent::"
msgstr "例如，以下对 :func:`spawnlp` 和 :func:`spawnvpe` 的调用是等效的::"

#: ../../library/os.rst:4922
msgid ""
"import os\n"
"os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n"
"\n"
"L = ['cp', 'index.html', '/dev/null']\n"
"os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)"
msgstr ""
"import os\n"
"os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n"
"\n"
"L = ['cp', 'index.html', '/dev/null']\n"
"os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)"

#: ../../library/os.rst:4928
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.spawn`` with arguments "
"``mode``, ``path``, ``args``, ``env``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.spawn`` 并附带参数 ``mode``, ``path``, ``args``,"
" ``env``。"

#: ../../library/os.rst:4932
msgid ""
":func:`spawnlp`, :func:`spawnlpe`, :func:`spawnvp` and :func:`spawnvpe` are "
"not available on Windows.  :func:`spawnle` and :func:`spawnve` are not "
"thread-safe on Windows; we advise you to use the :mod:`subprocess` module "
"instead."
msgstr ""
":func:`spawnlp`, :func:`spawnlpe`, :func:`spawnvp` 和 :func:`spawnvpe` 在 "
"Windows 上不可用。 :func:`spawnle` 和 :func:`spawnve` 在 Windows 上不是线程安全的；我们建议你用 "
":mod:`subprocess` 模块来代替。"

#: ../../library/os.rst:4940
msgid ""
"These functions are :term:`soft deprecated` and should no longer be used to "
"write new code. The :mod:`subprocess` module is recommended instead."
msgstr ""

#: ../../library/os.rst:4948
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If either of these values is given, the "
":func:`spawn\\* <spawnl>` functions will return as soon as the new process "
"has been created, with the process id as the return value."
msgstr ""
"传给 :func:`spawn\\* <spawnl>` 函数族的 *mode* 形参可能的值。 如果给出这些值中的某一个，则 "
":func:`spawn\\* <spawnl>` 函数将在新进程创建后立即返回，并将进程 ID 作为返回值。"

#: ../../library/os.rst:4958
msgid ""
"Possible value for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If this is given as *mode*, the :func:`spawn\\* "
"<spawnl>` functions will not return until the new process has run to "
"completion and will return the exit code of the process the run is "
"successful, or ``-signal`` if a signal kills the process."
msgstr ""
"传给 :func:`spawn\\* <spawnl>` 函数族的 *mode* 形参可能的值。 如果作为 *mode* 给出，则 "
":func:`spawn\\* <spawnl>` 函数将在新进程运行完毕后才返回，并在进程运行成功时返回退出码，或者如果进程被信号杀掉则返回 "
"``-signal``。"

#: ../../library/os.rst:4970
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  These are less portable than those listed above. "
":const:`P_DETACH` is similar to :const:`P_NOWAIT`, but the new process is "
"detached from the console of the calling process. If :const:`P_OVERLAY` is "
"used, the current process will be replaced; the :func:`spawn\\* <spawnl>` "
"function will not return."
msgstr ""
":func:`spawn\\* <spawnl>` 系列函数的 *mode* "
"参数的可取值。它们比上面列出的值可移植性差。:const:`P_DETACH` 与 :const:`P_NOWAIT` "
"相似，但是新进程会与父进程的控制台脱离。使用 :const:`P_OVERLAY` 则会替换当前进程，:func:`spawn\\* <spawnl>`"
" 函数将不会返回。"

#: ../../library/os.rst:4981
msgid "Start a file with its associated application."
msgstr "使用已关联的应用程序打开文件。"

#: ../../library/os.rst:4983
msgid ""
"When *operation* is not specified, this acts like double-clicking the file "
"in Windows Explorer, or giving the file name as an argument to the "
":program:`start` command from the interactive command shell: the file is "
"opened with whatever application (if any) its extension is associated."
msgstr ""
"当未指定 *operation* 时，这类似于在 Windows 资源管理器中双击文件，或在交互式命令行中将文件名作为 :program:`start`"
" 命令的参数：通过扩展名所关联的应用程序（如果有的话）来打开文件。"

#: ../../library/os.rst:4988
msgid ""
"When another *operation* is given, it must be a \"command verb\" that "
"specifies what should be done with the file. Common verbs documented by "
"Microsoft are ``'open'``, ``'print'`` and  ``'edit'`` (to be used on files) "
"as well as ``'explore'`` and ``'find'`` (to be used on directories)."
msgstr ""
"当指定其他 *operation* 时，它必须是一个对该文件执行操作的“命令动词”。 Microsoft 文档中记录的常用动词有 ``'open'``,"
" ``'print'`` 和  ``'edit'`` (用于文件) 以及 ``'explore'`` 和 ``'find'`` (用于目录)。"

#: ../../library/os.rst:4993
msgid ""
"When launching an application, specify *arguments* to be passed as a single "
"string. This argument may have no effect when using this function to launch "
"a document."
msgstr "在启动某个应用程序时，*arguments* 将作为一个字符串传入。若是打开某个文档，此参数可能没什么效果。"

#: ../../library/os.rst:4997
msgid ""
"The default working directory is inherited, but may be overridden by the "
"*cwd* argument. This should be an absolute path. A relative *path* will be "
"resolved against this argument."
msgstr "默认工作目录是继承而来的，但可以通过 *cwd* 参数进行覆盖。且应为绝对路径。相对路径 *path* 将据此参数进行解析。"

#: ../../library/os.rst:5001
msgid ""
"Use *show_cmd* to override the default window style. Whether this has any "
"effect will depend on the application being launched. Values are integers as"
" supported by the Win32 :c:func:`!ShellExecute` function."
msgstr ""
"使用 *show_cmd* 覆盖默认的窗口样式。 这是否生效则取决于被启动的应用程序。 其值应为 Win32 "
":c:func:`!ShellExecute` 函数所支持的整数形式。"

#: ../../library/os.rst:5005
msgid ""
":func:`startfile` returns as soon as the associated application is launched."
" There is no option to wait for the application to close, and no way to "
"retrieve the application's exit status.  The *path* parameter is relative to"
" the current directory or *cwd*.  If you want to use an absolute path, make "
"sure the first character is not a slash (``'/'``)  Use :mod:`pathlib` or the"
" :func:`os.path.normpath` function to ensure that paths are properly encoded"
" for Win32."
msgstr ""
"在关联的应用程序启动后，:func:`startfile` 就会立即返回。 没有提供等待应用程序关闭的选项，也没有办法获得应用程序的退出状态。 "
"*path* 形参是基于当前目录或 *cwd* 的相对路径。 如果要使用绝对路径，请确保第一个字符不为斜杠 (``'/'``) 。 请用 "
":mod:`pathlib` 或 :func:`os.path.normpath` 函数来保证路径已按照 Win32 的要求进行了正确的编码。"

#: ../../library/os.rst:5013
msgid ""
"To reduce interpreter startup overhead, the Win32 :c:func:`!ShellExecute` "
"function is not resolved until this function is first called.  If the "
"function cannot be resolved, :exc:`NotImplementedError` will be raised."
msgstr ""
"为了减少解释器的启动开销，Win32 :c:func:`!ShellExecute` 函数将不会被解析直到该函数首次被调用。 "
"如果该函数无法被解析，则将引发 :exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:5017
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile`` with arguments "
"``path``, ``operation``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.startfile`` 并附带参数 ``path``, ``operation``。"

#: ../../library/os.rst:5019
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile/2`` with arguments"
" ``path``, ``operation``, ``arguments``, ``cwd``, ``show_cmd``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``os.startfile/2`` 并附带参数 ``path``, "
"``operation``, ``arguments``, ``cwd``, ``show_cmd``。"

#: ../../library/os.rst:5023
msgid ""
"Added the *arguments*, *cwd* and *show_cmd* arguments, and the "
"``os.startfile/2`` audit event."
msgstr "加入了 *arguments*、*cwd* 和 *show_cmd* 参数，以及 ``os.startfile/2`` 审计事件。"

#: ../../library/os.rst:5030
msgid ""
"Execute the command (a string) in a subshell.  This is implemented by "
"calling the Standard C function :c:func:`system`, and has the same "
"limitations. Changes to :data:`sys.stdin`, etc. are not reflected in the "
"environment of the executed command. If *command* generates any output, it "
"will be sent to the interpreter standard output stream. The C standard does "
"not specify the meaning of the return value of the C function, so the return"
" value of the Python function is system-dependent."
msgstr ""
"在子外壳程序中执行此命令（一个字符串）。 这是通过调用标准 C 函数 :c:func:`system` 来实现的，并受到同样的限制。 对 "
":data:`sys.stdin` 的更改等不会反映在所执行命令的环境中。 如果 *command* 生成了任何输出，它将被发送到解释器的标准输出流。 "
"C 标准没有指明这个 C 函数返回值的含义，因此这个 Python 函数的返回值取决于具体系统。"

#: ../../library/os.rst:5038
msgid ""
"On Unix, the return value is the exit status of the process encoded in the "
"format specified for :func:`wait`."
msgstr "在 Unix 上，返回值为进程的退出状态，以针对 :func:`wait` 而指定的格式进行编码。"

#: ../../library/os.rst:5041
msgid ""
"On Windows, the return value is that returned by the system shell after "
"running *command*.  The shell is given by the Windows environment variable "
":envvar:`COMSPEC`: it is usually :program:`cmd.exe`, which returns the exit "
"status of the command run; on systems using a non-native shell, consult your"
" shell documentation."
msgstr ""
"在 Windows 上，返回值是运行 *command* 后系统 Shell 返回的值。该 Shell 由 Windows 环境变量 "
":envvar:`COMSPEC`: 给出：通常是 :program:`cmd.exe`，它会返回命令的退出状态。在使用非原生 Shell "
"的系统上，请查阅 Shell 的文档。"

#: ../../library/os.rst:5047
msgid ""
"The :mod:`subprocess` module provides more powerful facilities for spawning "
"new processes and retrieving their results; using that module is recommended"
" to using this function.  See the :ref:`subprocess-replacements` section in "
"the :mod:`subprocess` documentation for some helpful recipes."
msgstr ""

#: ../../library/os.rst:5052
msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the result "
"(exit status) into an exit code. On Windows, the result is directly the exit"
" code."
msgstr ""
"在 Unix 上，:func:`waitstatus_to_exitcode` 可以将返回值（即退出状态）转换为退出码。在 Windows "
"上，返回值就是退出码。"

#: ../../library/os.rst:5056
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.system`` with argument "
"``command``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``os.system`` 并附带参数 ``command``。"

#: ../../library/os.rst:5063
msgid ""
"Returns the current global process times. The return value is an object with"
" five attributes:"
msgstr "返回当前的全局进程时间。返回值是一个有 5 个属性的对象："

#: ../../library/os.rst:5066
msgid ":attr:`!user` - user time"
msgstr ":attr:`!user` - 用户时间"

#: ../../library/os.rst:5067
msgid ":attr:`!system` - system time"
msgstr ":attr:`!system` - 系统时间"

#: ../../library/os.rst:5068
msgid ":attr:`!children_user` - user time of all child processes"
msgstr ":attr:`!children_user` - 所有子进程的用户时间"

#: ../../library/os.rst:5069
msgid ":attr:`!children_system` - system time of all child processes"
msgstr ":attr:`!children_system` - 所有子进程的系统时间"

#: ../../library/os.rst:5070
msgid ":attr:`!elapsed` - elapsed real time since a fixed point in the past"
msgstr ":attr:`!elapsed` - 从过去的固定时间点起，经过的真实时间"

#: ../../library/os.rst:5072
msgid ""
"For backwards compatibility, this object also behaves like a five-tuple "
"containing :attr:`!user`, :attr:`!system`, :attr:`!children_user`, "
":attr:`!children_system`, and :attr:`!elapsed` in that order."
msgstr ""
"为了向后兼容，该对象的行为也类似于五元组，按照 "
":attr:`!user`，:attr:`!system`，:attr:`!children_user`，:attr:`!children_system`"
" 和 :attr:`!elapsed` 顺序组成。"

#: ../../library/os.rst:5076
msgid ""
"See the Unix manual page :manpage:`times(2)` and `times(3) "
"<https://man.freebsd.org/cgi/man.cgi?time(3)>`_ manual page on Unix or `the "
"GetProcessTimes MSDN "
"<https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-"
"processthreadsapi-getprocesstimes>`_ on Windows. On Windows, only "
":attr:`!user` and :attr:`!system` are known; the other attributes are zero."
msgstr ""
"在 Unix 上请参阅 Unix 手册页 :manpage:`times(2)` 和 `times(3) "
"<https://man.freebsd.org/cgi/man.cgi?time(3)>`_ 而在 Windows 上请参阅 "
"`GetProcessTimes MSDN "
"<https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-"
"processthreadsapi-getprocesstimes>`_。 在 Windows 上，只有 :attr:`!user` 和 "
":attr:`!system` 是已知的；其他属性均为零。"

#: ../../library/os.rst:5090
msgid ""
"Wait for completion of a child process, and return a tuple containing its "
"pid and exit status indication: a 16-bit number, whose low byte is the "
"signal number that killed the process, and whose high byte is the exit "
"status (if the signal number is zero); the high bit of the low byte is set "
"if a core file was produced."
msgstr ""
"等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个 16 "
"位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。"

#: ../../library/os.rst:5096
msgid ""
"If there are no children that could be waited for, :exc:`ChildProcessError` "
"is raised."
msgstr "如果不存在可被等待的子进程，则将引发 :exc:`ChildProcessError`。"

#: ../../library/os.rst:5099 ../../library/os.rst:5174
msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status into "
"an exit code."
msgstr "可以使用 :func:`waitstatus_to_exitcode` 来将退出状态转换为退出码。"

#: ../../library/os.rst:5106
msgid ""
"The other :func:`!wait*` functions documented below can be used to wait for "
"the completion of a specific child process and have more options. "
":func:`waitpid` is the only one also available on Windows."
msgstr ""
"下面列出的其他 :func:`!wait*` 函数可被用于等待特定子进程完成并具有更多的选项。 :func:`waitpid` 是其中唯一在 "
"Windows 上也可用的。"

#: ../../library/os.rst:5113
msgid "Wait for the completion of a child process."
msgstr "等待一个子进程完成。"

#: ../../library/os.rst:5115
msgid ""
"*idtype* can be :data:`P_PID`, :data:`P_PGID`, :data:`P_ALL`, or (on Linux) "
":data:`P_PIDFD`. The interpretation of *id* depends on it; see their "
"individual descriptions."
msgstr ""
"*idtype* 可以为 :data:`P_PID`, :data:`P_PGID`, :data:`P_ALL` 或 (在 Linux 上) "
":data:`P_PIDFD`。 对于 *id* 的解读由它来决定；请参阅它们各自的说明。"

#: ../../library/os.rst:5118
msgid ""
"*options* is an OR combination of flags.  At least one of :data:`WEXITED`, "
":data:`WSTOPPED` or :data:`WCONTINUED` is required; :data:`WNOHANG` and "
":data:`WNOWAIT` are additional optional flags."
msgstr ""
"*options* 是多个旗标的 OR 组合。 要求至少有 :data:`WEXITED`, :data:`WSTOPPED` 或 "
":data:`WCONTINUED` 中的一个；:data:`WNOHANG` 和 :data:`WNOWAIT` 是附加的可选旗标。"

#: ../../library/os.rst:5122
msgid ""
"The return value is an object representing the data contained in the "
":c:type:`siginfo_t` structure with the following attributes:"
msgstr "返回值是一个代表 :c:type:`siginfo_t` 结构体所包含数据的对象，具有以下属性:"

#: ../../library/os.rst:5125
msgid ":attr:`!si_pid` (process ID)"
msgstr ":attr:`!si_pid` (进程 ID)"

#: ../../library/os.rst:5126
msgid ":attr:`!si_uid` (real user ID of the child)"
msgstr ":attr:`!si_uid` (子进程的实际用户 ID)"

#: ../../library/os.rst:5127
msgid ":attr:`!si_signo` (always :const:`~signal.SIGCHLD`)"
msgstr ":attr:`!si_signo` (始终为 :const:`~signal.SIGCHLD`)"

#: ../../library/os.rst:5128
msgid ""
":attr:`!si_status` (the exit status or signal number, depending on "
":attr:`!si_code`)"
msgstr ":attr:`!si_status` (退出状态或信号编号，具体取决于 :attr:`!si_code`)"

#: ../../library/os.rst:5129
msgid ":attr:`!si_code` (see :data:`CLD_EXITED` for possible values)"
msgstr ":attr:`!si_code` (可能的值参见 :data:`CLD_EXITED`)"

#: ../../library/os.rst:5131
msgid ""
"If :data:`WNOHANG` is specified and there are no matching children in the "
"requested state, ``None`` is returned. Otherwise, if there are no matching "
"children that could be waited for, :exc:`ChildProcessError` is raised."
msgstr ""
"如果指定了 :data:`WNOHANG` 而在所请求的状态中没有匹配的子进程，则将返回 ``None``。 "
"在其他情况下，如果没有匹配的子进程可被等待，则将引发 :exc:`ChildProcessError`。"

#: ../../library/os.rst:5140
msgid "This function is now available on macOS as well."
msgstr "现在该函数在 macOS 同样可用。"

#: ../../library/os.rst:5146
msgid "The details of this function differ on Unix and Windows."
msgstr "本函数的细节在 Unix 和 Windows 上有不同之处。"

#: ../../library/os.rst:5148
msgid ""
"On Unix: Wait for completion of a child process given by process id *pid*, "
"and return a tuple containing its process id and exit status indication "
"(encoded as for :func:`wait`).  The semantics of the call are affected by "
"the value of the integer *options*, which should be ``0`` for normal "
"operation."
msgstr ""
"在 Unix 上：等待进程号为 *pid* 的子进程执行完毕，返回一个元组，内含其进程 ID 和退出状态指示（编码与 :func:`wait` "
"相同）。调用的语义受整数 *options* 的影响，常规操作下该值应为 ``0``。"

#: ../../library/os.rst:5153
msgid ""
"If *pid* is greater than ``0``, :func:`waitpid` requests status information "
"for that specific process.  If *pid* is ``0``, the request is for the status"
" of any child in the process group of the current process.  If *pid* is "
"``-1``, the request pertains to any child of the current process.  If *pid* "
"is less than ``-1``, status is requested for any process in the process "
"group ``-pid`` (the absolute value of *pid*)."
msgstr ""
"如果 *pid* 大于 ``0``，则 :func:`waitpid` 会获取该指定进程的状态信息。如果 *pid* 为 "
"``0``，则获取当前进程所在进程组中的所有子进程的状态。如果 *pid* 为 ``-1``，则获取当前进程的子进程状态。如果 *pid* 小于 "
"``-1``，则获取进程组 ``-pid`` （ *pid* 的绝对值）中所有进程的状态。"

#: ../../library/os.rst:5160
msgid ""
"*options* is an OR combination of flags.  If it contains :data:`WNOHANG` and"
" there are no matching children in the requested state, ``(0, 0)`` is "
"returned.  Otherwise, if there are no matching children that could be waited"
" for, :exc:`ChildProcessError` is raised.  Other options that can be used "
"are :data:`WUNTRACED` and :data:`WCONTINUED`."
msgstr ""
"*options* 是多个旗标的 OR 组合。 如果它包含了 :data:`WNOHANG` 并且在所请求的状态中没有匹配的子进程，则将返回 ``(0,"
" 0)``。 在其他情况下，如果没有匹配的子进程可以被等待，则将引发 :exc:`ChildProcessError`。 其他的可用选项还有 "
":data:`WUNTRACED` 和 :data:`WCONTINUED`。"

#: ../../library/os.rst:5166
msgid ""
"On Windows: Wait for completion of a process given by process handle *pid*, "
"and return a tuple containing *pid*, and its exit status shifted left by 8 "
"bits (shifting makes cross-platform use of the function easier). A *pid* "
"less than or equal to ``0`` has no special meaning on Windows, and raises an"
" exception. The value of integer *options* has no effect. *pid* can refer to"
" any process whose id is known, not necessarily a child process. The "
":func:`spawn\\* <spawnl>` functions called with :const:`P_NOWAIT` return "
"suitable process handles."
msgstr ""
"在 Windows 上：等待句柄为 *pid* 的进程执行完毕，返回一个元组，内含 *pid* 以及左移 8 "
"位后的退出状态码（移位简化了跨平台使用本函数）。小于或等于 ``0`` 的 *pid* 在 Windows 上没有特殊含义，且会抛出异常。整数值 "
"*options* 无效。*pid* 可以指向任何 ID 已知的进程，不一定是子进程。调用 :func:`spawn\\* <spawnl>` "
"函数时传入 :const:`P_NOWAIT` 将返回合适的进程句柄。"

#: ../../library/os.rst:5187
msgid ""
"Similar to :func:`waitpid`, except no process id argument is given and a "
"3-element tuple containing the child's process id, exit status indication, "
"and resource usage information is returned.  Refer to "
":func:`resource.getrusage` for details on resource usage information.  The "
"*options* argument is the same as that provided to :func:`waitpid` and "
":func:`wait4`."
msgstr ""
"与 :func:`waitpid` 类似，区别在于没有给出进程 id 参数并且返回一个 3 元组，其中包括子进程的 id、退出状态指示以及资源使用信息。"
" 请参阅 :func:`resource.getrusage` 了解有关资源使用信息的详情。 *options* 参数与提供给 "
":func:`waitpid` 和 :func:`wait4` 的相同。"

#: ../../library/os.rst:5194 ../../library/os.rst:5208
msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status into "
"an exitcode."
msgstr "可以使用 :func:`waitstatus_to_exitcode` 来将退出状态转换为退出码。"

#: ../../library/os.rst:5202
msgid ""
"Similar to :func:`waitpid`, except a 3-element tuple, containing the child's"
" process id, exit status indication, and resource usage information is "
"returned.  Refer to :func:`resource.getrusage` for details on resource usage"
" information.  The arguments to :func:`wait4` are the same as those provided"
" to :func:`waitpid`."
msgstr ""
"与 :func:`waitpid` 类似，区别在于它是返回一个 3 元组，其中包括子进程的 id、退出状态指示以及资源使用信息。 请参阅 "
":func:`resource.getrusage` 了解有关资源使用信息的详情。 :func:`wait4` 的参数与提供给 "
":func:`waitpid` 的相同。"

#: ../../library/os.rst:5219
msgid ""
"These are the possible values for *idtype* in :func:`waitid`. They affect "
"how *id* is interpreted:"
msgstr "这些是 :func:`waitid` 中 *idtype* 可取的值。 它们会影响 *id* 的解读方式:"

#: ../../library/os.rst:5222
msgid ":data:`!P_PID` - wait for the child whose PID is *id*."
msgstr ":data:`!P_PID` - 等待 PID 为 *id* 的子进程。"

#: ../../library/os.rst:5223
msgid ":data:`!P_PGID` - wait for any child whose progress group ID is *id*."
msgstr ":data:`!P_PGID` - 等待进程组 ID 为 *id* 的任何子进程。"

#: ../../library/os.rst:5224
msgid ":data:`!P_ALL` - wait for any child; *id* is ignored."
msgstr ":data:`!P_ALL` - 等待任何子进程；*id* 会被忽略。"

#: ../../library/os.rst:5225
msgid ""
":data:`!P_PIDFD` - wait for the child identified by the file descriptor *id*"
" (a process file descriptor created with :func:`pidfd_open`)."
msgstr ""
":data:`!P_PIDFD` - 等待以文件描述符 *id* 作为标识的子进程（使用a process file descriptor "
"created with :func:`pidfd_open` 创建的进程文件描述符）。"

#: ../../library/os.rst:5230
msgid ":data:`!P_PIDFD` is only available on Linux >= 5.4."
msgstr ":data:`!P_PIDFD` 仅在 Linux >= 5.4 时可用。"

#: ../../library/os.rst:5233
msgid "The :data:`!P_PIDFD` constant."
msgstr ":data:`!P_PIDFD` 常量。"

#: ../../library/os.rst:5239
msgid ""
"This *options* flag for :func:`waitpid`, :func:`wait3`, :func:`wait4`, and "
":func:`waitid` causes child processes to be reported if they have been "
"continued from a job control stop since they were last reported."
msgstr ""
"如果子进程自它们上次被报告之后从作业控制停止位置继续执行，则 :func:`waitpid`, :func:`wait3`, :func:`wait4`"
" 和 :func:`waitid` 的这个 *选项* 旗标将导致子进程被报告。"

#: ../../library/os.rst:5248
msgid ""
"This *options* flag for :func:`waitid` causes child processes that have "
"terminated to be reported."
msgstr ":func:`waitid` 的这个 *选项* 旗标将导致已终结的子进程被报告。"

#: ../../library/os.rst:5251
msgid ""
"The other ``wait*`` functions always report children that have terminated, "
"so this option is not available for them."
msgstr "其他 ``wait*`` 函数总是会报告已终结的子进程，所以此选项对它们不可用。"

#: ../../library/os.rst:5261
msgid ""
"This *options* flag for :func:`waitid` causes child processes that have been"
" stopped by the delivery of a signal to be reported."
msgstr "这个 :func:`waitid` 的 *选项* 旗标将导致被信号发送所停止的子进程被报告。"

#: ../../library/os.rst:5264 ../../library/os.rst:5296
msgid "This option is not available for the other ``wait*`` functions."
msgstr "这个选项对于其他 ``wait*`` 函数不可用。"

#: ../../library/os.rst:5273
msgid ""
"This *options* flag for :func:`waitpid`, :func:`wait3`, and :func:`wait4` "
"causes child processes to also be reported if they have been stopped but "
"their current state has not been reported since they were stopped."
msgstr ""
"如果子进程自它们上次被停止之后再次被停止但它们的当前状态还未被报告，则 :func:`waitpid`, :func:`wait3` 和 "
":func:`wait4` 的这个 *选项* 旗标也将导致子进程被报告。"

#: ../../library/os.rst:5277
msgid "This option is not available for :func:`waitid`."
msgstr "这个选项对于 :func:`waitid` 不可用。"

#: ../../library/os.rst:5284
msgid ""
"This *options* flag causes :func:`waitpid`, :func:`wait3`, :func:`wait4`, "
"and :func:`waitid` to return right away if no child process status is "
"available immediately."
msgstr ""
"如果没有任何子进程状态是立即可用的，则这个 *选项* 旗标将导致 :func:`waitpid`, :func:`wait3`, "
":func:`wait4` 和 :func:`waitid` 立即返回。"

#: ../../library/os.rst:5293
msgid ""
"This *options* flag causes :func:`waitid` to leave the child in a waitable "
"state, so that a later :func:`!wait*` call can be used to retrieve the child"
" status information again."
msgstr ""
"这个 *选项* 旗标将导致 :func:`waitid` 以可等待的状态离开子进程，这样后续的 :func:`!wait*` "
"调用可被用来再次获取子进程状态信息。"

#: ../../library/os.rst:5308
msgid ""
"These are the possible values for :attr:`!si_code` in the result returned by"
" :func:`waitid`."
msgstr "这些是由 :func:`waitid` 所返回的结果中 :attr:`!si_code` 可能的取值。"

#: ../../library/os.rst:5315
msgid "Added :data:`CLD_KILLED` and :data:`CLD_STOPPED` values."
msgstr "添加了 :data:`CLD_KILLED` 和 :data:`CLD_STOPPED` 值。"

#: ../../library/os.rst:5321
msgid "Convert a wait status to an exit code."
msgstr "将等待状态转换为退出码。"

#: ../../library/os.rst:5323
msgid "On Unix:"
msgstr "在 Unix 上："

#: ../../library/os.rst:5325
msgid ""
"If the process exited normally (if ``WIFEXITED(status)`` is true), return "
"the process exit status (return ``WEXITSTATUS(status)``): result greater "
"than or equal to 0."
msgstr ""
"如果进程正常退出（当 ``WIFEXITED(status)`` 为真值），则返回进程退出状态 (返回 "
"``WEXITSTATUS(status)``): 结果值大于等于 0。"

#: ../../library/os.rst:5328
msgid ""
"If the process was terminated by a signal (if ``WIFSIGNALED(status)`` is "
"true), return ``-signum`` where *signum* is the number of the signal that "
"caused the process to terminate (return ``-WTERMSIG(status)``): result less "
"than 0."
msgstr ""
"如果进程被信号终止（当 ``WIFSIGNALED(status)`` 为真值），则返回 ``-signum`` 其中 *signum* "
"为导致进程终止的信号数值 (返回 ``-WTERMSIG(status)``): 结果值小于 0。"

#: ../../library/os.rst:5332
msgid "Otherwise, raise a :exc:`ValueError`."
msgstr "否则将抛出 :exc:`ValueError` 异常。"

#: ../../library/os.rst:5334
msgid "On Windows, return *status* shifted right by 8 bits."
msgstr "在 Windows 上，返回 *status* 右移 8 位的结果。"

#: ../../library/os.rst:5336
msgid ""
"On Unix, if the process is being traced or if :func:`waitpid` was called "
"with :data:`WUNTRACED` option, the caller must first check if "
"``WIFSTOPPED(status)`` is true. This function must not be called if "
"``WIFSTOPPED(status)`` is true."
msgstr ""
"在 Unix 上，如果进程正被追踪或 :func:`waitpid` 附带 :data:`WUNTRACED` 选项被调用，则调用者必须先检查 "
"``WIFSTOPPED(status)`` 是否为真值。 如果 ``WIFSTOPPED(status)`` 为真值则此函数不可被调用。"

#: ../../library/os.rst:5343
msgid ""
":func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, "
":func:`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG` functions."
msgstr ""
":func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, "
":func:`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG` 函数。"

#: ../../library/os.rst:5351
msgid ""
"The following functions take a process status code as returned by "
":func:`system`, :func:`wait`, or :func:`waitpid` as a parameter.  They may "
"be used to determine the disposition of a process."
msgstr ""
"下列函数采用进程状态码作为参数，状态码由 :func:`system`、:func:`wait` 或 :func:`waitpid` "
"返回。它们可用于确定进程上发生的操作。"

#: ../../library/os.rst:5357
msgid ""
"Return ``True`` if a core dump was generated for the process, otherwise "
"return ``False``."
msgstr "如果为该进程生成了核心转储，返回 ``True``，否则返回 ``False``。"

#: ../../library/os.rst:5360 ../../library/os.rst:5426
msgid "This function should be employed only if :func:`WIFSIGNALED` is true."
msgstr "此函数应当仅在 :func:`WIFSIGNALED` 为真值时使用。"

#: ../../library/os.rst:5367
msgid ""
"Return ``True`` if a stopped child has been resumed by delivery of "
":const:`~signal.SIGCONT` (if the process has been continued from a job "
"control stop), otherwise return ``False``."
msgstr ""
"如果一个已停止的子进程通过传送 :const:`~signal.SIGCONT` 获得恢复（如果该进程是从任务控制停止后再继续的）则返回 "
"``True``，否则返回 ``False``。"

#: ../../library/os.rst:5371
msgid "See :data:`WCONTINUED` option."
msgstr "参见 :data:`WCONTINUED` 选项。"

#: ../../library/os.rst:5378
msgid ""
"Return ``True`` if the process was stopped by delivery of a signal, "
"otherwise return ``False``."
msgstr "如果进程是通过传送一个信号来停止的则返回 ``True``，否则返回 ``False``。"

#: ../../library/os.rst:5381
msgid ""
":func:`WIFSTOPPED` only returns ``True`` if the :func:`waitpid` call was "
"done using :data:`WUNTRACED` option or when the process is being traced (see"
" :manpage:`ptrace(2)`)."
msgstr ""
":func:`WIFSTOPPED` 只有在当 :func:`waitpid` 调用是通过使用 :data:`WUNTRACED` "
"选项来完成或者当该进程正被追踪时 (参见 :manpage:`ptrace(2)`) 才返回 ``True``。"

#: ../../library/os.rst:5389
msgid ""
"Return ``True`` if the process was terminated by a signal, otherwise return "
"``False``."
msgstr "如果进程是通过一个信号来终止的则返回 ``True`` ，否则返回 ``False``。"

#: ../../library/os.rst:5397
msgid ""
"Return ``True`` if the process exited terminated normally, that is, by "
"calling ``exit()`` or ``_exit()``, or by returning from ``main()``; "
"otherwise return ``False``."
msgstr ""
"如果进程正常终止退出则返回 ``True``，也就是说通过调用 ``exit()`` 或 ``_exit()``，或者通过从 ``main()`` "
"返回；在其他情况下则返回 ``False``。"

#: ../../library/os.rst:5406
msgid "Return the process exit status."
msgstr "返回进程退出状态。"

#: ../../library/os.rst:5408
msgid "This function should be employed only if :func:`WIFEXITED` is true."
msgstr "此函数应当仅在 :func:`WIFEXITED` 为真值时使用。"

#: ../../library/os.rst:5415
msgid "Return the signal which caused the process to stop."
msgstr "返回导致进程停止的信号。"

#: ../../library/os.rst:5417
msgid "This function should be employed only if :func:`WIFSTOPPED` is true."
msgstr "此函数应当仅在 :func:`WIFSTOPPED` 为真值时使用。"

#: ../../library/os.rst:5424
msgid "Return the number of the signal that caused the process to terminate."
msgstr "返回导致进程终止的信号的编号。"

#: ../../library/os.rst:5432
msgid "Interface to the scheduler"
msgstr "调度器接口"

#: ../../library/os.rst:5434
msgid ""
"These functions control how a process is allocated CPU time by the operating"
" system. They are only available on some Unix platforms. For more detailed "
"information, consult your Unix manpages."
msgstr "这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上可用。 更多细节信息请查阅你所用 Unix 的指南页面。"

#: ../../library/os.rst:5440
msgid ""
"The following scheduling policies are exposed if they are supported by the "
"operating system."
msgstr "以下调度策略如果被操作系统支持就会对外公开。"

#: ../../library/os.rst:5447
msgid "The default scheduling policy."
msgstr "默认调度策略。"

#: ../../library/os.rst:5451
msgid ""
"Scheduling policy for CPU-intensive processes that tries to preserve "
"interactivity on the rest of the computer."
msgstr "用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性。"

#: ../../library/os.rst:5456
msgid "Scheduling policy for tasks with deadline constraints."
msgstr ""

#: ../../library/os.rst:5462
msgid "Scheduling policy for extremely low priority background tasks."
msgstr "用于极低优先级的后台任务的调度策略。"

#: ../../library/os.rst:5466
msgid "Alias for :data:`SCHED_OTHER`."
msgstr ""

#: ../../library/os.rst:5472
msgid "Scheduling policy for sporadic server programs."
msgstr "用于偶发型服务程序的调度策略。"

#: ../../library/os.rst:5476
msgid "A First In First Out scheduling policy."
msgstr "先进先出的调度策略。"

#: ../../library/os.rst:5480
msgid "A round-robin scheduling policy."
msgstr "循环式的调度策略。"

#: ../../library/os.rst:5484
msgid ""
"This flag can be OR'ed with any other scheduling policy. When a process with"
" this flag set forks, its child's scheduling policy and priority are reset "
"to the default."
msgstr "此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。"

#: ../../library/os.rst:5491
msgid ""
"This class represents tunable scheduling parameters used in "
":func:`sched_setparam`, :func:`sched_setscheduler`, and "
":func:`sched_getparam`. It is immutable."
msgstr ""
"这个类表示在 :func:`sched_setparam`, :func:`sched_setscheduler` 和 "
":func:`sched_getparam` 中使用的可修改调度形参。 它属于不可变对象。"

#: ../../library/os.rst:5495
msgid "At the moment, there is only one possible parameter:"
msgstr "目前它只有一个可能的形参："

#: ../../library/os.rst:5499
msgid "The scheduling priority for a scheduling policy."
msgstr "一个调度策略的调度优先级。"

#: ../../library/os.rst:5504
msgid ""
"Get the minimum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "获取 *policy* 的最低优先级数值。 *policy* 是以上调度策略常量之一。"

#: ../../library/os.rst:5510
msgid ""
"Get the maximum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "获取 *policy* 的最高优先级数值。 *policy* 是以上调度策略常量之一。"

#: ../../library/os.rst:5516
msgid ""
"Set the scheduling policy for the process with PID *pid*. A *pid* of 0 means"
" the calling process. *policy* is one of the scheduling policy constants "
"above. *param* is a :class:`sched_param` instance."
msgstr ""
"设置 PID 为 *pid* 的进程的调度策略。*pid* 为 0 指的是调用本方法的进程。*policy* 是以上调度策略常量之一。*param* "
"是一个 :class:`sched_param` 实例。"

#: ../../library/os.rst:5523
msgid ""
"Return the scheduling policy for the process with PID *pid*. A *pid* of 0 "
"means the calling process. The result is one of the scheduling policy "
"constants above."
msgstr "返回 PID 为 *pid* 的进程的调度策略。*pid* 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。"

#: ../../library/os.rst:5530
msgid ""
"Set the scheduling parameters for the process with PID *pid*. A *pid* of 0 "
"means the calling process. *param* is a :class:`sched_param` instance."
msgstr ""
"设置 PID 为 *pid* 的进程的调度参数。 *pid* 为 0 表示调用方过程。  *param* 是一个 "
":class:`sched_param` 实例。"

#: ../../library/os.rst:5536
msgid ""
"Return the scheduling parameters as a :class:`sched_param` instance for the "
"process with PID *pid*. A *pid* of 0 means the calling process."
msgstr ""
"返回 PID 为 *pid* 的进程的调度参数为一个 :class:`sched_param` 实例。*pid* 为 0 指的是调用本方法的进程。"

#: ../../library/os.rst:5542
msgid ""
"Return the round-robin quantum in seconds for the process with PID *pid*. A "
"*pid* of 0 means the calling process."
msgstr "返回 PID 为 *pid* 的进程在时间片轮转调度下的时间片长度（单位为秒）。*pid* 为 0 指的是调用本方法的进程。"

#: ../../library/os.rst:5548
msgid ""
"Voluntarily relinquish the CPU. See :manpage:`sched_yield(2)` for details."
msgstr "主动让出 CPU。 请参阅 :manpage:`sched_yield(2)` 了解详情。"

#: ../../library/os.rst:5553
msgid ""
"Restrict the process with PID *pid* (or the current process if zero) to a "
"set of CPUs.  *mask* is an iterable of integers representing the set of CPUs"
" to which the process should be restricted."
msgstr ""
"将 PID 为 *pid* 的进程（为零则为当前进程）限制到一组 CPU 上。*mask* 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。"

#: ../../library/os.rst:5560
msgid "Return the set of CPUs the process with PID *pid* is restricted to."
msgstr "返回 PID 为 *pid* 的进程被限制到的那一组 CPU。"

#: ../../library/os.rst:5562
msgid ""
"If *pid* is zero, return the set of CPUs the calling thread of the current "
"process is restricted to."
msgstr "如果 *pid* 为零，则返回当前进程的调用方线程被限制到的那一组 CPU。"

#: ../../library/os.rst:5565
msgid "See also the :func:`process_cpu_count` function."
msgstr "另请参阅 :func:`process_cpu_count` 函数。"

#: ../../library/os.rst:5571
msgid "Miscellaneous System Information"
msgstr "其他系统信息"

#: ../../library/os.rst:5576
msgid ""
"Return string-valued system configuration values. *name* specifies the "
"configuration value to retrieve; it may be a string which is the name of a "
"defined system value; these names are specified in a number of standards "
"(POSIX, Unix 95, Unix 98, and others).  Some platforms define additional "
"names as well. The names known to the host operating system are given as the"
" keys of the ``confstr_names`` dictionary.  For configuration variables not "
"included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"返回字符串格式的系统配置信息。*name* 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix "
"95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 ``confstr_names`` "
"字典的键中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 *name*。"

#: ../../library/os.rst:5584
msgid ""
"If the configuration value specified by *name* isn't defined, ``None`` is "
"returned."
msgstr "如果 *name* 指定的配置值未定义，返回 ``None``。"

#: ../../library/os.rst:5587
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If a "
"specific value for *name* is not supported by the host system, even if it is"
" included in ``confstr_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"如果 *name* 是一个字符串且不是已定义的名称，将抛出 :exc:`ValueError` 异常。如果当前系统不支持 *name* "
"指定的配置名称，即使该名称存在于 ``confstr_names``，也会抛出 :exc:`OSError` 异常，错误码为 "
":const:`errno.EINVAL`。"

#: ../../library/os.rst:5597
msgid ""
"Dictionary mapping names accepted by :func:`confstr` to the integer values "
"defined for those names by the host operating system. This can be used to "
"determine the set of names known to the system."
msgstr ""
"字典，表示映射关系，为 :func:`confstr` 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。"

#: ../../library/os.rst:5606
msgid ""
"Return the number of logical CPUs in the **system**. Returns ``None`` if "
"undetermined."
msgstr "返回 **系统** 中逻辑 CPU 的数量。 如果无法确定则返回 ``None``。"

#: ../../library/os.rst:5609
msgid ""
"The :func:`process_cpu_count` function can be used to get the number of "
"logical CPUs usable by the calling thread of the **current process**."
msgstr ":func:`process_cpu_count` 函数可被用于获取 **当前进程** 的调用方线程可以使用的逻辑 CPU 数量。"

#: ../../library/os.rst:5614
msgid ""
"If :option:`-X cpu_count <-X>` is given or :envvar:`PYTHON_CPU_COUNT` is "
"set, :func:`cpu_count` returns the overridden value *n*."
msgstr ""
"如果给出了 :option:`-X cpu_count <-X>` 或设置了 :envvar:`PYTHON_CPU_COUNT`，则 "
":func:`cpu_count` 将返回被覆盖的值 *n*。"

#: ../../library/os.rst:5621
msgid ""
"Return the number of processes in the system run queue averaged over the "
"last 1, 5, and 15 minutes or raises :exc:`OSError` if the load average was "
"unobtainable."
msgstr "返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均负载则抛出 :exc:`OSError` 异常。"

#: ../../library/os.rst:5630
msgid ""
"Get the number of logical CPUs usable by the calling thread of the **current"
" process**. Returns ``None`` if undetermined. It can be less than "
":func:`cpu_count` depending on the CPU affinity."
msgstr ""
"获取 **当前进程** 的调用方线程可以使用的逻辑 CPU 数量。 如果无法确定则返回 ``None``。 根据实际 CPU 的关联性它可能会小于 "
":func:`cpu_count`。"

#: ../../library/os.rst:5634
msgid ""
"The :func:`cpu_count` function can be used to get the number of logical CPUs"
" in the **system**."
msgstr ":func:`cpu_count` 函数可被用于获取 **系统** 中逻辑 CPU 的数量。"

#: ../../library/os.rst:5637
msgid ""
"If :option:`-X cpu_count <-X>` is given or :envvar:`PYTHON_CPU_COUNT` is "
"set, :func:`process_cpu_count` returns the overridden value *n*."
msgstr ""
"如果给出了 :option:`-X cpu_count <-X>` 或设置了 :envvar:`PYTHON_CPU_COUNT`，则 "
":func:`process_cpu_count` 将返回被覆盖的值 *n*。"

#: ../../library/os.rst:5640
msgid "See also the :func:`sched_getaffinity` function."
msgstr "另请参阅 :func:`sched_getaffinity` 函数。"

#: ../../library/os.rst:5647
msgid ""
"Return integer-valued system configuration values. If the configuration "
"value specified by *name* isn't defined, ``-1`` is returned.  The comments "
"regarding the *name* parameter for :func:`confstr` apply here as well; the "
"dictionary that provides information on the known names is given by "
"``sysconf_names``."
msgstr ""
"返回整数格式的系统配置信息。如果 *name* 指定的配置值未定义，返回 ``-1``。对 :func:`confstr` 的 *name* "
"参数的注释在此处也适用。当前已知的配置名称在 ``sysconf_names`` 字典中提供。"

#: ../../library/os.rst:5657
msgid ""
"Dictionary mapping names accepted by :func:`sysconf` to the integer values "
"defined for those names by the host operating system. This can be used to "
"determine the set of names known to the system."
msgstr ""
"字典，表示映射关系，为 :func:`sysconf` 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。"

#: ../../library/os.rst:5663
msgid "Add ``'SC_MINSIGSTKSZ'`` name."
msgstr "添加 ``'SC_MINSIGSTKSZ'`` 名称。"

#: ../../library/os.rst:5666
msgid ""
"The following data values are used to support path manipulation operations."
"  These are defined for all platforms."
msgstr "以下数据值用于支持对路径本身的操作。所有平台都有定义。"

#: ../../library/os.rst:5669
msgid ""
"Higher-level operations on pathnames are defined in the :mod:`os.path` "
"module."
msgstr "对路径的高级操作在 :mod:`os.path` 模块中定义。"

#: ../../library/os.rst:5675
msgid ""
"The constant string used by the operating system to refer to the current "
"directory. This is ``'.'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是 ``'.'``。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5683
msgid ""
"The constant string used by the operating system to refer to the parent "
"directory. This is ``'..'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 ``'..'``。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5692
msgid ""
"The character used by the operating system to separate pathname components. "
"This is ``'/'`` for POSIX and ``'\\\\'`` for Windows.  Note that knowing "
"this is not sufficient to be able to parse or concatenate pathnames --- use "
":func:`os.path.split` and :func:`os.path.join` --- but it is occasionally "
"useful. Also available via :mod:`os.path`."
msgstr ""
"操作系统用来分隔路径不同部分的字符。在 POSIX 上是 ``'/'``，在 Windows 上是是 "
"``'\\\\'``。注意，仅了解它不足以能解析或连接路径，请使用 :func:`os.path.split` 和 "
":func:`os.path.join`，但它有时是有用的。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5702
msgid ""
"An alternative character used by the operating system to separate pathname "
"components, or ``None`` if only one separator character exists.  This is set"
" to ``'/'`` on Windows systems where ``sep`` is a backslash. Also available "
"via :mod:`os.path`."
msgstr ""
"操作系统用来分隔路径不同部分的替代字符。如果仅存在一个分隔符，则为 ``None``。在 ``sep`` 是反斜杠的 Windows 系统上，该值被设为"
" ``'/'``。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5711
msgid ""
"The character which separates the base filename from the extension; for "
"example, the ``'.'`` in :file:`os.py`. Also available via :mod:`os.path`."
msgstr "分隔基本文件名与扩展名的字符，如 :file:`os.py` 中的 ``'.'``。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5719
msgid ""
"The character conventionally used by the operating system to separate search"
" path components (as in :envvar:`PATH`), such as ``':'`` for POSIX or "
"``';'`` for Windows. Also available via :mod:`os.path`."
msgstr ""
"操作系统通常用于分隔搜索路径（如 :envvar:`PATH`）中不同部分的字符，如 POSIX 上是 ``':'``，Windows 上是 "
"``';'``。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5726
msgid ""
"The default search path used by :func:`exec\\*p\\* <execl>` and "
":func:`spawn\\*p\\* <spawnl>` if the environment doesn't have a ``'PATH'`` "
"key. Also available via :mod:`os.path`."
msgstr ""
"在环境变量没有 ``'PATH'`` 键的情况下，:func:`exec\\*p\\* <execl>` and :func:`spawn\\*p\\*"
" <spawnl>` 使用的默认搜索路径。在 :mod:`os.path` 中也可用。"

#: ../../library/os.rst:5733
msgid ""
"The string used to separate (or, rather, terminate) lines on the current "
"platform.  This may be a single character, such as ``'\\n'`` for POSIX, or "
"multiple characters, for example, ``'\\r\\n'`` for Windows. Do not use "
"*os.linesep* as a line terminator when writing files opened in text mode "
"(the default); use a single ``'\\n'`` instead, on all platforms."
msgstr ""
"当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上是 ``'\\n'``，也可以是多个字符，如 Windows 上是 "
"``'\\r\\n'``。在写入以文本模式（默认模式）打开的文件时，请不要使用 *os.linesep* 作为行终止符，请在所有平台上都使用一个 "
"``'\\n'`` 代替。"

#: ../../library/os.rst:5742
msgid ""
"The file path of the null device. For example: ``'/dev/null'`` for POSIX, "
"``'nul'`` for Windows.  Also available via :mod:`os.path`."
msgstr ""
"空设备的文件路径。如 POSIX 上为 ``'/dev/null'``，Windows 上为 ``'nul'``。在 :mod:`os.path` "
"中也可用。"

#: ../../library/os.rst:5753
msgid ""
"Flags for use with the :func:`~sys.setdlopenflags` and "
":func:`~sys.getdlopenflags` functions.  See the Unix manual page "
":manpage:`dlopen(3)` for what the different flags mean."
msgstr ""
":func:`~sys.setdlopenflags` 和 :func:`~sys.getdlopenflags` 函数所使用的标志。请参阅 Unix "
"手册页 :manpage:`dlopen(3)` 获取不同标志的含义。"

#: ../../library/os.rst:5761
msgid "Random numbers"
msgstr "随机数"

#: ../../library/os.rst:5766
msgid ""
"Get up to *size* random bytes. The function can return less bytes than "
"requested."
msgstr "获得最多为 *size* 的随机字节。本函数返回的字节数可能少于请求的字节数。"

#: ../../library/os.rst:5769
msgid ""
"These bytes can be used to seed user-space random number generators or for "
"cryptographic purposes."
msgstr "这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。"

#: ../../library/os.rst:5772
msgid ""
"``getrandom()`` relies on entropy gathered from device drivers and other "
"sources of environmental noise. Unnecessarily reading large quantities of "
"data will have a negative impact on  other users  of the ``/dev/random`` and"
" ``/dev/urandom`` devices."
msgstr ""
"``getrandom()`` 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要地读取大量数据将对使用 ``/dev/random`` 和 "
"``/dev/urandom`` 设备的其他用户产生负面影响。"

#: ../../library/os.rst:5777
msgid ""
"The flags argument is a bit mask that can contain zero or more of the "
"following values ORed together: :py:const:`os.GRND_RANDOM` and "
":py:data:`GRND_NONBLOCK`."
msgstr ""
"flags 参数是一个位掩码，它可以包含零个或多个下列值的或运算结果: :py:const:`os.GRND_RANDOM` 和 "
":py:data:`GRND_NONBLOCK`。"

#: ../../library/os.rst:5781
msgid ""
"See also the `Linux getrandom() manual page <https://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_."
msgstr ""
"另请参阅 `Linux getrandom() 手册页 <https://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_。"

#: ../../library/os.rst:5790
msgid ""
"Return a bytestring of *size* random bytes suitable for cryptographic use."
msgstr "返回大小为 *size* 的字节串，它是适合加密使用的随机字节。"

#: ../../library/os.rst:5792
msgid ""
"This function returns random bytes from an OS-specific randomness source.  "
"The returned data should be unpredictable enough for cryptographic "
"applications, though its exact quality depends on the OS implementation."
msgstr "本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。"

#: ../../library/os.rst:5796
msgid ""
"On Linux, if the ``getrandom()`` syscall is available, it is used in "
"blocking mode: block until the system urandom entropy pool is initialized "
"(128 bits of entropy are collected by the kernel). See the :pep:`524` for "
"the rationale. On Linux, the :func:`getrandom` function can be used to get "
"random bytes in non-blocking mode (using the :data:`GRND_NONBLOCK` flag) or "
"to poll until the system urandom entropy pool is initialized."
msgstr ""
"在 Linux 上，如果 ``getrandom()`` 系统调用可用，它将以阻塞模式使用：阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 "
"128 位熵）。原理请参阅 :pep:`524`。在 Linux 上，:func:`getrandom` 可以以非阻塞模式（使用 "
":data:`GRND_NONBLOCK` 标志）获取随机字节，或者轮询直到系统的 urandom 熵池初始化完毕。"

#: ../../library/os.rst:5803
msgid ""
"On a Unix-like system, random bytes are read from the ``/dev/urandom`` "
"device. If the ``/dev/urandom`` device is not available or not readable, the"
" :exc:`NotImplementedError` exception is raised."
msgstr ""
"在类 Unix 系统上，随机字节是从 ``/dev/urandom`` 设备读取的。如果 ``/dev/urandom`` 设备不可用或不可读，则抛出 "
":exc:`NotImplementedError` 异常。"

#: ../../library/os.rst:5807
msgid "On Windows, it will use ``BCryptGenRandom()``."
msgstr "在 Windows 上，它将使用 ``BCryptGenRandom()``。"

#: ../../library/os.rst:5810
msgid ""
"The :mod:`secrets` module provides higher level functions. For an easy-to-"
"use interface to the random number generator provided by your platform, "
"please see :class:`random.SystemRandom`."
msgstr ""
":mod:`secrets` 模块提供了更高级的功能。所在平台会提供随机数生成器，有关其易于使用的接口，请参阅 "
":class:`random.SystemRandom`。"

#: ../../library/os.rst:5814
msgid ""
"On Linux 3.17 and newer, the ``getrandom()`` syscall is now used when "
"available.  On OpenBSD 5.6 and newer, the C ``getentropy()`` function is now"
" used. These functions avoid the usage of an internal file descriptor."
msgstr ""
"在 Linux 3.17 和更高版本上，现在使用 ``getrandom()`` 系统调用（如果可用）。在 OpenBSD 5.6 "
"和更高版本上，现在使用 ``getentropy()`` C 函数。这些函数避免了使用内部文件描述符。"

#: ../../library/os.rst:5820
msgid ""
"On Linux, if the ``getrandom()`` syscall blocks (the urandom entropy pool is"
" not initialized yet), fall back on reading ``/dev/urandom``."
msgstr ""
"在 Linux 上，如果 ``getrandom()`` 系统调用阻塞（urandom 熵池尚未初始化完毕），则退回一步读取 "
"``/dev/urandom``。"

#: ../../library/os.rst:5824
msgid ""
"On Linux, ``getrandom()`` is now used in blocking mode to increase the "
"security."
msgstr "在 Linux 上，``getrandom()`` 现在以阻塞模式使用，以提高安全性。"

#: ../../library/os.rst:5828
msgid ""
"On Windows, ``BCryptGenRandom()`` is used instead of ``CryptGenRandom()`` "
"which is deprecated."
msgstr "在 Windows 上，将使用 ``BCryptGenRandom()`` 而不是已被弃用的 ``CryptGenRandom()``。"

#: ../../library/os.rst:5834
msgid ""
"By  default, when reading from ``/dev/random``, :func:`getrandom` blocks if "
"no random bytes are available, and when reading from ``/dev/urandom``, it "
"blocks if the entropy pool has not yet been initialized."
msgstr ""
"默认情况下，从 ``/dev/random`` 读取时，如果没有可用的随机字节，则 :func:`getrandom` 会阻塞；从 "
"``/dev/urandom`` 读取时，如果熵池尚未初始化，则会阻塞。"

#: ../../library/os.rst:5838
msgid ""
"If the :py:data:`GRND_NONBLOCK` flag is set, then :func:`getrandom` does not"
" block in these cases, but instead immediately raises "
":exc:`BlockingIOError`."
msgstr ""
"如果设置了 :py:data:`GRND_NONBLOCK` 标志，则这些情况下 :func:`getrandom` 不会阻塞，而是立即抛出 "
":exc:`BlockingIOError` 异常。"

#: ../../library/os.rst:5845
msgid ""
"If  this  bit  is  set,  then  random bytes are drawn from the "
"``/dev/random`` pool instead of the ``/dev/urandom`` pool."
msgstr "如果设置了此标志位，那么将从 ``/dev/random`` 池而不是 ``/dev/urandom`` 池中提取随机字节。"

#: ../../library/os.rst:386 ../../library/os.rst:552 ../../library/os.rst:756
msgid "user"
msgstr "user"

#: ../../library/os.rst:386
msgid "effective id"
msgstr "有效 id"

#: ../../library/os.rst:395 ../../library/os.rst:461 ../../library/os.rst:470
#: ../../library/os.rst:479 ../../library/os.rst:493 ../../library/os.rst:691
#: ../../library/os.rst:4597 ../../library/os.rst:4623
msgid "process"
msgstr "process"

#: ../../library/os.rst:395 ../../library/os.rst:461
msgid "group"
msgstr "group"

#: ../../library/os.rst:470 ../../library/os.rst:552
msgid "id"
msgstr "id"

#: ../../library/os.rst:479
msgid "id of parent"
msgstr "父 id"

#: ../../library/os.rst:493 ../../library/os.rst:691
msgid "scheduling priority"
msgstr "调度优先级"

#: ../../library/os.rst:575 ../../library/os.rst:826
msgid "environment variables"
msgstr "环境变量"

#: ../../library/os.rst:575
msgid "setting"
msgstr "设置"

#: ../../library/os.rst:756
msgid "id, setting"
msgstr "id, 设置"

#: ../../library/os.rst:789
msgid "gethostname() (in module socket)"
msgstr "gethostname() (在 socket 模块中)"

#: ../../library/os.rst:789
msgid "gethostbyaddr() (in module socket)"
msgstr "gethostbyaddr() (在 socket 模块中)"

#: ../../library/os.rst:826 ../../library/os.rst:2732
msgid "deleting"
msgstr "删除"

#: ../../library/os.rst:1387 ../../library/os.rst:3102
msgid "module"
msgstr "module"

#: ../../library/os.rst:1387
msgid "pty"
msgstr "pty"

#: ../../library/os.rst:2118 ../../library/os.rst:2531
#: ../../library/os.rst:2732 ../../library/os.rst:3636
#: ../../library/os.rst:3736
msgid "directory"
msgstr "directory"

#: ../../library/os.rst:2118
msgid "changing"
msgstr "修改"

#: ../../library/os.rst:2531
msgid "creating"
msgstr "创建"

#: ../../library/os.rst:2531
msgid "UNC paths"
msgstr "UNC 路径"

#: ../../library/os.rst:2531
msgid "and os.makedirs()"
msgstr "和 os.makedirs()"

#: ../../library/os.rst:3102
msgid "stat"
msgstr "stat"

#: ../../library/os.rst:3636 ../../library/os.rst:3736
msgid "walking"
msgstr "walking"

#: ../../library/os.rst:3636 ../../library/os.rst:3736
msgid "traversal"
msgstr "traversal"

#: ../../library/os.rst:4597 ../../library/os.rst:4623
msgid "killing"
msgstr "killing"

#: ../../library/os.rst:4597 ../../library/os.rst:4623
msgid "signalling"
msgstr "signalling"

#: ../../library/os.rst:5672 ../../library/os.rst:5708
msgid ". (dot)"
msgstr ". (点号)"

#: ../../library/os.rst:5672 ../../library/os.rst:5680
#: ../../library/os.rst:5688 ../../library/os.rst:5699
#: ../../library/os.rst:5708
msgid "in pathnames"
msgstr "在 pathnames 中"

#: ../../library/os.rst:5680
msgid ".."
msgstr ".."

#: ../../library/os.rst:5688 ../../library/os.rst:5699
msgid "/ (slash)"
msgstr "/ (斜杠)"

#: ../../library/os.rst:5689
msgid "\\ (backslash)"
msgstr "\\ (反斜杠)"

#: ../../library/os.rst:5689
msgid "in pathnames (Windows)"
msgstr "在路径名称中 (Windows)"

#: ../../library/os.rst:5715
msgid ": (colon)"
msgstr ": (冒号)"

#: ../../library/os.rst:5715
msgid "path separator (POSIX)"
msgstr "路径分隔符 (POSIX)"

#: ../../library/os.rst:5715
msgid "; (semicolon)"
msgstr "; (分号)"
