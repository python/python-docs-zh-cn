# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alpha Du <alphanow@gmail.com>, 2021
# ProgramRipper, 2023
# Menghua Xiao <arieshout@gmail.com>, 2024
# Nyuan Zhang, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-20 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.metadata.rst:5
msgid ":mod:`!importlib.metadata` -- Accessing package metadata"
msgstr ":mod:`!importlib.metadata` -- 访问软件包元数据"

#: ../../library/importlib.metadata.rst:11
msgid "``importlib.metadata`` is no longer provisional."
msgstr "``importlib.metadata`` 不再是暂定的。"

#: ../../library/importlib.metadata.rst:14
msgid "**Source code:** :source:`Lib/importlib/metadata/__init__.py`"
msgstr "**源代码:** :source:`Lib/importlib/metadata/__init__.py`"

#: ../../library/importlib.metadata.rst:16
msgid ""
"``importlib.metadata`` is a library that provides access to the metadata of "
"an installed `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_, such as its entry points or its top-level names (`Import Package"
" <https://packaging.python.org/en/latest/glossary/#term-Import-"
"Package>`_\\s, modules, if any). Built in part on Python's import system, "
"this library intends to replace similar functionality in the `entry point "
"API`_ and `metadata API`_ of ``pkg_resources``. Along with "
":mod:`importlib.resources`, this package can eliminate the need to use the "
"older and less efficient ``pkg_resources`` package."
msgstr ""
"``importlib.metadata`` 是一个提供对已安装的 `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 的元数据的访问的库，如其入口点或其顶层名称 (`导入包 "
"<https://packaging.python.org/en/latest/glossary/#term-Import-"
"Package>`_，模块等，如果有的话)。 这个库部分构建于 Python 的导入系统之上，其目标是取代 ``pkg_resources`` 的 "
"`entry point API`_ 和 `metadata API`_ 中的类似功能。 配合 "
":mod:`importlib.resources`，这个包让使用较老旧且低效率的 ``pkg_resources`` 包不再必要。"

#: ../../library/importlib.metadata.rst:27
msgid ""
"``importlib.metadata`` operates on third-party *distribution packages* "
"installed into Python's ``site-packages`` directory via tools such as "
":pypi:`pip`. Specifically, it works with distributions with discoverable "
"``dist-info`` or ``egg-info`` directories, and metadata defined by the `Core"
" metadata specifications "
"<https://packaging.python.org/en/latest/specifications/core-metadata/#core-"
"metadata>`_."
msgstr ""
"``importlib.metadata`` 对 :pypi:`pip` 等工具安装到 Python 的 ``site-packages`` "
"目录的第三方 *分发包* 进行操作。 具体来说，适用的分发包应带有可发现的 ``dist-info`` 或 ``egg-info`` 目录，以及 "
"`核心元数据规范说明 <https://packaging.python.org/en/latest/specifications/core-"
"metadata/#core-metadata>`_ 定义的元数据。"

#: ../../library/importlib.metadata.rst:36
msgid ""
"These are *not* necessarily equivalent to or correspond 1:1 with the top-"
"level *import package* names that can be imported inside Python code. One "
"*distribution package* can contain multiple *import packages* (and single "
"modules), and one top-level *import package* may map to multiple "
"*distribution packages* if it is a namespace package. You can use "
":ref:`packages_distributions() <package-distributions>` to get a mapping "
"between them."
msgstr ""
"它们 *不一定* 等同或 1:1 对应于可在 Python 代码中导入的顶层 *导入包* 名称。一个 *分发包* 可以包含多个 *导入包* "
"(和单个模块)，如果是命名空间包，一个顶层 *导入包* 可以映射到多个 *分发包*。您可以使用 "
":ref:`packages_distributions() <package-distributions>` 来获取它们之间的映射。"

#: ../../library/importlib.metadata.rst:47
msgid ""
"By default, distribution metadata can live on the file system or in zip "
"archives on :data:`sys.path`. Through an extension mechanism, the metadata "
"can live almost anywhere."
msgstr ""
"在默认情况下，分发包元数据可存在于 :data:`sys.path` 下的文件系统或 zip 归档文件中。 "
"通过一个扩展机制，元数据可以存在于几乎任何地方。"

#: ../../library/importlib.metadata.rst:55
msgid "https://importlib-metadata.readthedocs.io/"
msgstr "https://importlib-metadata.readthedocs.io/"

#: ../../library/importlib.metadata.rst:56
msgid ""
"The documentation for ``importlib_metadata``, which supplies a backport of "
"``importlib.metadata``. This includes an `API reference <https://importlib-"
"metadata.readthedocs.io/en/latest/api.html>`__ for this module's classes and"
" functions, as well as a `migration guide <https://importlib-"
"metadata.readthedocs.io/en/latest/migration.html>`__ for existing users of "
"``pkg_resources``."
msgstr ""
"``importlib_metadata`` 的文档，它向下移植了 ``importlib.metadata``。它包含该模块的类和函数的 `API "
"参考 <https://importlib-metadata.readthedocs.io/en/latest/api.html>`__，以及针对 "
"``pkg_resources`` 现有用户的 `迁移指南 <https://importlib-"
"metadata.readthedocs.io/en/latest/migration.html>`__。"

#: ../../library/importlib.metadata.rst:67
msgid "Overview"
msgstr "概述"

#: ../../library/importlib.metadata.rst:69
msgid ""
"Let's say you wanted to get the version string for a `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ you've installed using ``pip``. We start by creating a virtual "
"environment and installing something into it:"
msgstr ""
"让我们假设你想要获取你使用 ``pip`` 安装的 `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 的版本字符串。 我们首先创建一个虚拟环境并在其安装一些软件包："

#: ../../library/importlib.metadata.rst:74
msgid ""
"$ python -m venv example\n"
"$ source example/bin/activate\n"
"(example) $ python -m pip install wheel"
msgstr ""
"$ python -m venv example\n"
"$ source example/bin/activate\n"
"(example) $ python -m pip install wheel"

#: ../../library/importlib.metadata.rst:80
msgid "You can get the version string for ``wheel`` by running the following:"
msgstr "你可以通过运行以下代码得到 ``wheel`` 的版本字符串："

#: ../../library/importlib.metadata.rst:82
msgid ""
"(example) $ python\n"
">>> from importlib.metadata import version\n"
">>> version('wheel')\n"
"'0.32.3'"
msgstr ""
"(example) $ python\n"
">>> from importlib.metadata import version\n"
">>> version('wheel')\n"
"'0.32.3'"

#: ../../library/importlib.metadata.rst:89
msgid ""
"You can also get a collection of entry points selectable by properties of "
"the EntryPoint (typically 'group' or 'name'), such as ``console_scripts``, "
"``distutils.commands`` and others. Each group contains a collection of "
":ref:`EntryPoint <entry-points>` objects."
msgstr ""
"你还能获取可通过 EntryPoint 的属性 (通常为 'group' 或 'name') 来选择的入口点多项集，比如 "
"``console_scripts``, ``distutils.commands`` 等等。 每个 group 都包含一个 "
":ref:`EntryPoint <entry-points>` 对象的多项集。"

#: ../../library/importlib.metadata.rst:93
msgid "You can get the :ref:`metadata for a distribution <metadata>`::"
msgstr "你可以获得 :ref:`分发的元数据 <metadata>`："

#: ../../library/importlib.metadata.rst:95
msgid ""
">>> list(metadata('wheel'))\n"
"['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', 'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', 'Requires-Dist']"
msgstr ""
">>> list(metadata('wheel'))\n"
"['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', 'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', 'Requires-Dist']"

#: ../../library/importlib.metadata.rst:98
msgid ""
"You can also get a :ref:`distribution's version number <version>`, list its "
":ref:`constituent files <files>`, and get a list of the distribution's "
":ref:`requirements`."
msgstr ""
"你也可以获得 :ref:`分发包的版本号 <version>`，列出它的 :ref:`构成文件 <files>`，并且得到分发包的 "
":ref:`requirements` 列表。"

#: ../../library/importlib.metadata.rst:105
msgid ""
"Subclass of :class:`ModuleNotFoundError` raised by several functions in this"
" module when queried for a distribution package which is not installed in "
"the current Python environment."
msgstr ""
"当查询未在当前 Python 环境中安装的分发包时由此模块的某些函数所引发的 :class:`ModuleNotFoundError` 子类。"

#: ../../library/importlib.metadata.rst:111
msgid "Functional API"
msgstr "函数式 API"

#: ../../library/importlib.metadata.rst:113
msgid "This package provides the following functionality via its public API."
msgstr "这个包的公开 API 提供了以下功能。"

#: ../../library/importlib.metadata.rst:119
msgid "Entry points"
msgstr "入口点"

#: ../../library/importlib.metadata.rst:123
msgid ""
"Returns a :class:`EntryPoints` instance describing entry points for the "
"current environment. Any given keyword parameters are passed to the "
":meth:`!select` method for comparison to the attributes of the individual "
"entry point definitions."
msgstr ""
"返回一个描述当前环境的入口点的 :class:`EntryPoints` 实例。 所给出的任何关键字形参都将被传给 :meth:`!select` "
"方法以与单独的入口点定义的属性进行比较。"

#: ../../library/importlib.metadata.rst:128
msgid ""
"Note: it is not currently possible to query for entry points based on their "
":attr:`!EntryPoint.dist` attribute (as different :class:`!Distribution` "
"instances do not currently compare equal, even if they have the same "
"attributes)"
msgstr ""
"注意：目前无法基于 :attr:`!EntryPoint.dist` 属性来查询入口点（因为不同的 :class:`!Distribution` "
"实例目前不可能相等，即使它们具有相同的属性）"

#: ../../library/importlib.metadata.rst:134
msgid "Details of a collection of installed entry points."
msgstr "已安装入口点多项集的详情。"

#: ../../library/importlib.metadata.rst:136
msgid ""
"Also provides a ``.groups`` attribute that reports all identified entry "
"point groups, and a ``.names`` attribute that reports all identified entry "
"point names."
msgstr "还提供 ``.groups`` 属性用于报告所有已标识的入口点分组，以及 ``.names`` 属性用于报告所有已标识的入口点名称。"

#: ../../library/importlib.metadata.rst:142
msgid "Details of an installed entry point."
msgstr "一个已安装入口点的详情。"

#: ../../library/importlib.metadata.rst:144
msgid ""
"Each :class:`!EntryPoint` instance has ``.name``, ``.group``, and ``.value``"
" attributes and a ``.load()`` method to resolve the value. There are also "
"``.module``, ``.attr``, and ``.extras`` attributes for getting the "
"components of the ``.value`` attribute, and ``.dist`` for obtaining "
"information regarding the distribution package that provides the entry "
"point."
msgstr ""
"每个 :class:`!EntryPoint` 实例都有 ``.name``, ``.group`` 和 ``.value`` 属性以及 "
"``.load()`` 方法用于求值。 此外还有 ``.module``, ``.attr`` 和 ``.extras`` 属性用于获取 "
"``.value`` 属性的组成部分，以及 ``.dist`` 用于获取有关提供该入口点的分发包的信息。"

#: ../../library/importlib.metadata.rst:150
msgid "Query all entry points::"
msgstr "查询所有的入口点："

#: ../../library/importlib.metadata.rst:152
msgid ">>> eps = entry_points()"
msgstr ">>> eps = entry_points()"

#: ../../library/importlib.metadata.rst:154
msgid ""
"The :func:`!entry_points` function returns a :class:`!EntryPoints` object, a"
" collection of all :class:`!EntryPoint` objects with ``names`` and "
"``groups`` attributes for convenience::"
msgstr ""
":func:`!entry_points` 函数返回一个 :class:`!EntryPoints` 对象，即由带 ``names`` 和 "
"``groups`` 属性的所有 :class:`!EntryPoint` 对象组成的多项集以方便使用::"

#: ../../library/importlib.metadata.rst:158
msgid ""
">>> sorted(eps.groups)\n"
"['console_scripts', 'distutils.commands', 'distutils.setup_keywords', 'egg_info.writers', 'setuptools.installation']"
msgstr ""
">>> sorted(eps.groups)\n"
"['console_scripts', 'distutils.commands', 'distutils.setup_keywords', 'egg_info.writers', 'setuptools.installation']"

#: ../../library/importlib.metadata.rst:161
msgid ""
":class:`!EntryPoints` has a :meth:`!select` method to select entry points "
"matching specific properties. Select entry points in the ``console_scripts``"
" group::"
msgstr ""
":class:`!EntryPoints` 具有 :meth:`!select` 方法用于选择匹配指定特征属性的入口点。 如选择 "
"``console_scripts`` 组中的入口点::"

#: ../../library/importlib.metadata.rst:165
msgid ">>> scripts = eps.select(group='console_scripts')"
msgstr ">>> scripts = eps.select(group='console_scripts')"

#: ../../library/importlib.metadata.rst:167
msgid ""
"Equivalently, since :func:`!entry_points` passes keyword arguments through "
"to select::"
msgstr "效果相同，因为 :func:`!entry_points` 会传递关键字参数来选择::"

#: ../../library/importlib.metadata.rst:170
msgid ">>> scripts = entry_points(group='console_scripts')"
msgstr ">>> scripts = entry_points(group='console_scripts')"

#: ../../library/importlib.metadata.rst:172
msgid "Pick out a specific script named \"wheel\" (found in the wheel project)::"
msgstr "选出命名为 “wheel” 的特定脚本（可以在 wheel 项目中找到）："

#: ../../library/importlib.metadata.rst:174
msgid ""
">>> 'wheel' in scripts.names\n"
"True\n"
">>> wheel = scripts['wheel']"
msgstr ""
">>> 'wheel' in scripts.names\n"
"True\n"
">>> wheel = scripts['wheel']"

#: ../../library/importlib.metadata.rst:178
msgid "Equivalently, query for that entry point during selection::"
msgstr "等价地，在选择过程中查询对应的入口点："

#: ../../library/importlib.metadata.rst:180
msgid ""
">>> (wheel,) = entry_points(group='console_scripts', name='wheel')\n"
">>> (wheel,) = entry_points().select(group='console_scripts', name='wheel')"
msgstr ""
">>> (wheel,) = entry_points(group='console_scripts', name='wheel')\n"
">>> (wheel,) = entry_points().select(group='console_scripts', name='wheel')"

#: ../../library/importlib.metadata.rst:183
msgid "Inspect the resolved entry point::"
msgstr "检查解析得到的入口点："

#: ../../library/importlib.metadata.rst:185
msgid ""
">>> wheel\n"
"EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')\n"
">>> wheel.module\n"
"'wheel.cli'\n"
">>> wheel.attr\n"
"'main'\n"
">>> wheel.extras\n"
"[]\n"
">>> main = wheel.load()\n"
">>> main\n"
"<function main at 0x103528488>"
msgstr ""
">>> wheel\n"
"EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')\n"
">>> wheel.module\n"
"'wheel.cli'\n"
">>> wheel.attr\n"
"'main'\n"
">>> wheel.extras\n"
"[]\n"
">>> main = wheel.load()\n"
">>> main\n"
"<function main at 0x103528488>"

#: ../../library/importlib.metadata.rst:197
msgid ""
"The ``group`` and ``name`` are arbitrary values defined by the package "
"author and usually a client will wish to resolve all entry points for a "
"particular group. Read `the setuptools docs "
"<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_ for more"
" information on entry points, their definition, and usage."
msgstr ""
"``group`` 和 ``name`` 是由软件包作业定义的任意值并且通常来说客户端会想要解析特定 group 的所有入口点。 请参阅 "
"`setuptools 文档 "
"<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_ "
"了解有关入口点及其定义和用法的详情。"

#: ../../library/importlib.metadata.rst:203
msgid ""
"The \"selectable\" entry points were introduced in ``importlib_metadata`` "
"3.6 and Python 3.10. Prior to those changes, ``entry_points`` accepted no "
"parameters and always returned a dictionary of entry points, keyed by group."
" With ``importlib_metadata`` 5.0 and Python 3.12, ``entry_points`` always "
"returns an ``EntryPoints`` object. See "
":pypi:`backports.entry_points_selectable` for compatibility options."
msgstr ""
"\"selectable\" 入口点是在 ``importlib_metadata`` 3.6 和 Python 3.10 中引入的。 "
"在这项改变之前，``entry_points`` 不接受任何形参并且总是返回一个由入口点组成的字典，字典的键为分组名。 在 "
"``importlib_metadata`` 5.0 和 Python 3.12 中，``entry_points`` 总是返回一个 "
"``EntryPoints`` 对象。 请参阅 :pypi:`backports.entry_points_selectable` 了解相关兼容性选项。"

#: ../../library/importlib.metadata.rst:212
msgid ""
"``EntryPoint`` objects no longer present a tuple-like interface "
"(:meth:`~object.__getitem__`)."
msgstr "``EntryPoint`` 对象不再提供类似于元组的接口（:meth:`~object.__getitem__`）。"

#: ../../library/importlib.metadata.rst:219
msgid "Distribution metadata"
msgstr "分发的元数据"

#: ../../library/importlib.metadata.rst:223
msgid ""
"Return the distribution metadata corresponding to the named distribution "
"package as a :class:`PackageMetadata` instance."
msgstr "将对应于指定分发包的分发元数据作为 :class:`PackageMetadata` 实例返回。"

#: ../../library/importlib.metadata.rst:226
#: ../../library/importlib.metadata.rst:275
#: ../../library/importlib.metadata.rst:296
#: ../../library/importlib.metadata.rst:359
#: ../../library/importlib.metadata.rst:410
msgid ""
"Raises :exc:`PackageNotFoundError` if the named distribution package is not "
"installed in the current Python environment."
msgstr "如果指定的发布包未在当前 Python 环境中安装则会引发 :exc:`PackageNotFoundError`。"

#: ../../library/importlib.metadata.rst:231
msgid ""
"A concrete implementation of the `PackageMetadata protocol "
"<https://importlib-"
"metadata.readthedocs.io/en/latest/api.html#importlib_metadata.PackageMetadata>`_."
msgstr ""
"`PackageMetadata 协议 <https://importlib-"
"metadata.readthedocs.io/en/latest/api.html#importlib_metadata.PackageMetadata>`_"
" 的一个具体实现。"

#: ../../library/importlib.metadata.rst:234
msgid ""
"In addition to providing the defined protocol methods and attributes, "
"subscripting the instance is equivalent to calling the :meth:`!get` method."
msgstr "除了提供已定义的协议方法和属性，对实例的下标操作就相当于调用 :meth:`!get` 方法。"

#: ../../library/importlib.metadata.rst:237
msgid ""
"Every `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ includes some metadata, which you can extract using the "
":func:`!metadata` function::"
msgstr ""
"每个 `分发包 <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 都包括一些元数据，你可以使用 :func:`!metadata` 函数来获取::"

#: ../../library/importlib.metadata.rst:240
msgid ">>> wheel_metadata = metadata('wheel')"
msgstr ">>> wheel_metadata = metadata('wheel')"

#: ../../library/importlib.metadata.rst:242
msgid ""
"The keys of the returned data structure name the metadata keywords, and the "
"values are returned unparsed from the distribution metadata::"
msgstr "所返回数据结构的键指明了元数据关键字，而值将从分发的元数据中不加解析地返回::"

#: ../../library/importlib.metadata.rst:245
msgid ""
">>> wheel_metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"
msgstr ""
">>> wheel_metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"

#: ../../library/importlib.metadata.rst:248
msgid ""
":class:`PackageMetadata` also presents a :attr:`!json` attribute that "
"returns all the metadata in a JSON-compatible form per :PEP:`566`::"
msgstr ""
":class:`PackageMetadata` 也还提供了一个按照 :PEP:`566` 将所有元数据以 JSON 兼容形式返回的 "
":attr:`!json`::"

#: ../../library/importlib.metadata.rst:251
msgid ""
">>> wheel_metadata.json['requires_python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"
msgstr ""
">>> wheel_metadata.json['requires_python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"

#: ../../library/importlib.metadata.rst:254
#: ../../library/importlib.metadata.rst:453
msgid ""
"The full set of available metadata is not described here. See the PyPA `Core"
" metadata specification "
"<https://packaging.python.org/en/latest/specifications/core-metadata/#core-"
"metadata>`_ for additional details."
msgstr ""
"此处并未描述可用元数据的完整集合。 更多详情参见 PyPA `核心元数据规格说明 "
"<https://packaging.python.org/en/latest/specifications/core-metadata/#core-"
"metadata>`_。"

#: ../../library/importlib.metadata.rst:257
msgid ""
"The ``Description`` is now included in the metadata when presented through "
"the payload. Line continuation characters have been removed."
msgstr "当有效载荷中包含时，``Description`` 以去除续行符的形式被包含于元数据中。"

#: ../../library/importlib.metadata.rst:261
msgid "The ``json`` attribute was added."
msgstr "添加了 ``json`` 属性。"

#: ../../library/importlib.metadata.rst:267
msgid "Distribution versions"
msgstr "分发包的版本"

#: ../../library/importlib.metadata.rst:271
msgid ""
"Return the installed distribution package `version "
"<https://packaging.python.org/en/latest/specifications/core-"
"metadata/#version>`__ for the named distribution package."
msgstr ""
"返回对应指定发布包的已安装发布包 `版本 "
"<https://packaging.python.org/en/latest/specifications/core-"
"metadata/#version>`__。"

#: ../../library/importlib.metadata.rst:278
msgid ""
"The :func:`!version` function is the quickest way to get a `Distribution "
"Package <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_'s version number, as a string::"
msgstr ""
":func:`!version` 函数是获取字符串形式的 `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 版本号的最快速方式::"

#: ../../library/importlib.metadata.rst:282
msgid ""
">>> version('wheel')\n"
"'0.32.3'"
msgstr ""
">>> version('wheel')\n"
"'0.32.3'"

#: ../../library/importlib.metadata.rst:289
msgid "Distribution files"
msgstr "分发包的文件"

#: ../../library/importlib.metadata.rst:293
msgid ""
"Return the full set of files contained within the named distribution "
"package."
msgstr "返回包含在指定分发包内的完整文件集合。"

#: ../../library/importlib.metadata.rst:299
msgid ""
"Returns :const:`None` if the distribution is found but the installation "
"database records reporting the files associated with the distribution "
"package are missing."
msgstr "如果找到了分发包但未找到报告与分发包相关联的文件的安装数据库记录则返回 :const:`None`。"

#: ../../library/importlib.metadata.rst:305
msgid ""
"A :class:`pathlib.PurePath` derived object with additional ``dist``, "
"``size``, and ``hash`` properties corresponding to the distribution "
"package's installation metadata for that file."
msgstr ""
"一个 :class:`pathlib.PurePath` 的派生对象，增加了对应于指定文件的分发包的安装元数据的 ``dist``, ``size`` "
"和 ``hash`` 特征属性。"

#: ../../library/importlib.metadata.rst:309
msgid ""
"The :func:`!files` function takes a `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ name and returns all of the files installed by this distribution."
" Each file is reported as a :class:`PackagePath` instance. For example::"
msgstr ""
":func:`!files` 函数接受一个 `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 名称并返回此分发包所安装的全部文件。 每个文件均报告为一个 :class:`PackagePath` 实例。 例如::"

#: ../../library/importlib.metadata.rst:314
msgid ""
">>> util = [p for p in files('wheel') if 'util.py' in str(p)][0]\n"
">>> util\n"
"PackagePath('wheel/util.py')\n"
">>> util.size\n"
"859\n"
">>> util.dist\n"
"<importlib.metadata._hooks.PathDistribution object at 0x101e0cef0>\n"
">>> util.hash\n"
"<FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI>"
msgstr ""
">>> util = [p for p in files('wheel') if 'util.py' in str(p)][0]\n"
">>> util\n"
"PackagePath('wheel/util.py')\n"
">>> util.size\n"
"859\n"
">>> util.dist\n"
"<importlib.metadata._hooks.PathDistribution object at 0x101e0cef0>\n"
">>> util.hash\n"
"<FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI>"

#: ../../library/importlib.metadata.rst:324
msgid "Once you have the file, you can also read its contents::"
msgstr "当你获得了文件对象，你可以读取其内容："

#: ../../library/importlib.metadata.rst:326
msgid ""
">>> print(util.read_text())\n"
"import base64\n"
"import sys\n"
"...\n"
"def as_bytes(s):\n"
"    if isinstance(s, text_type):\n"
"        return s.encode('utf-8')\n"
"    return s"
msgstr ""
">>> print(util.read_text())\n"
"import base64\n"
"import sys\n"
"...\n"
"def as_bytes(s):\n"
"    if isinstance(s, text_type):\n"
"        return s.encode('utf-8')\n"
"    return s"

#: ../../library/importlib.metadata.rst:335
msgid ""
"You can also use the :meth:`!locate` method to get the absolute path to the "
"file::"
msgstr "你也可以使用 :meth:`!locate` 方法来获取文件的绝对路径::"

#: ../../library/importlib.metadata.rst:338
msgid ""
">>> util.locate()\n"
"PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')"
msgstr ""
">>> util.locate()\n"
"PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')"

#: ../../library/importlib.metadata.rst:341
msgid ""
"In the case where the metadata file listing files (``RECORD`` or "
"``SOURCES.txt``) is missing, :func:`!files` will return :const:`None`. The "
"caller may wish to wrap calls to :func:`!files` in `always_iterable "
"<https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable>`_"
" or otherwise guard against this condition if the target distribution is not"
" known to have the metadata present."
msgstr ""
"对于列出文件的元数据文件 (``RECORD`` 或 ``SOURCES.txt``) 缺失的情况，:func:`!files` 将返回 "
":const:`None`。 调用者可能会想要把对 :func:`!files` 的调用包装在 `always_iterable "
"<https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable>`_"
" 中或是用其他方式在尚未知晓目标分发元数据存在性时应对此情况。"

#: ../../library/importlib.metadata.rst:352
msgid "Distribution requirements"
msgstr "分发包的依赖"

#: ../../library/importlib.metadata.rst:356
msgid ""
"Return the declared dependency specifiers for the named distribution "
"package."
msgstr "返回指定分发包已声明的依赖描述。"

#: ../../library/importlib.metadata.rst:362
msgid ""
"To get the full set of requirements for a `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_, use the :func:`!requires` function::"
msgstr ""
"要获取一个 `分发包 <https://packaging.python.org/en/latest/glossary/#term-"
"Distribution-Package>`_ 的完整需求集，请使用 :func:`!requires` 函数::"

#: ../../library/importlib.metadata.rst:366
msgid ""
">>> requires('wheel')\n"
"[\"pytest (>=3.0.0) ; extra == 'test'\", \"pytest-cov ; extra == 'test'\"]"
msgstr ""
">>> requires('wheel')\n"
"[\"pytest (>=3.0.0) ; extra == 'test'\", \"pytest-cov ; extra == 'test'\"]"

#: ../../library/importlib.metadata.rst:374
msgid "Mapping import to distribution packages"
msgstr "将导入映射到分发包"

#: ../../library/importlib.metadata.rst:378
msgid ""
"Return a mapping from the top level module and import package names found "
"via :data:`sys.meta_path` to the names of the distribution packages (if any)"
" that provide the corresponding files."
msgstr "返回一个从最高层级模块和通过 :data:`sys.meta_path` 找到的导入包名称到提供相应文件的分发包名称（如果存在）的映射。"

#: ../../library/importlib.metadata.rst:382
msgid ""
"To allow for namespace packages (which may have members provided by multiple"
" distribution packages), each top level import name maps to a list of "
"distribution names rather than mapping directly to a single name."
msgstr "为了允许使用命名空间包（它可能包含由多个分发包所提供的成员），每个最高层级导入名称都映射到一个分发名称的列表而不是直接映射单个名称。"

#: ../../library/importlib.metadata.rst:386
msgid ""
"A convenience method to resolve the `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ name (or names, in the case of a namespace package) that provide "
"each importable top-level Python module or `Import Package "
"<https://packaging.python.org/en/latest/glossary/#term-Import-Package>`_::"
msgstr ""
"解析每个提供可导入的最高层级 Python 模块或 `导入包 "
"<https://packaging.python.org/en/latest/glossary/#term-Import-Package>`_ 对应的"
" `分发包 <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 名称（对于命名空间包可能有多个名称）的快捷方法::"

#: ../../library/importlib.metadata.rst:391
msgid ""
">>> packages_distributions()\n"
"{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': ['jaraco.classes', 'jaraco.functools'], ...}"
msgstr ""
">>> packages_distributions()\n"
"{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': ['jaraco.classes', 'jaraco.functools'], ...}"

#: ../../library/importlib.metadata.rst:394
msgid ""
"Some editable installs, `do not supply top-level names "
"<https://github.com/pypa/packaging-problems/issues/609>`_, and thus this "
"function is not reliable with such installs."
msgstr ""
"某些可编辑的安装 `没有提供最高层级名称 <https://github.com/pypa/packaging-"
"problems/issues/609>`_，因而此函数不适用于这样的安装。"

#: ../../library/importlib.metadata.rst:403
msgid "Distributions"
msgstr "分发包对象"

#: ../../library/importlib.metadata.rst:407
msgid ""
"Return a :class:`Distribution` instance describing the named distribution "
"package."
msgstr ""
"返回一个描述指定分发包的 :class:`Distribution` 实例。instance describing the named "
"distribution package."

#: ../../library/importlib.metadata.rst:415
msgid "Details of an installed distribution package."
msgstr "一个已安装分发包的详情。"

#: ../../library/importlib.metadata.rst:417
msgid ""
"Note: different :class:`!Distribution` instances do not currently compare "
"equal, even if they relate to the same installed distribution and "
"accordingly have the same attributes."
msgstr ""
"注意：目前不同的 :class:`!Distribution` 实例在比较时肯定不相等，即使它们是关联到相同的已安装发布版因而具有相同的属性。"

#: ../../library/importlib.metadata.rst:421
msgid ""
"While the module level API described above is the most common and convenient"
" usage, you can get all of that information from the :class:`!Distribution` "
"class. :class:`!Distribution` is an abstract object that represents the "
"metadata for a Python `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_. You can get the concrete :class:`!Distribution` subclass "
"instance for an installed distribution package by calling the "
":func:`distribution` function::"
msgstr ""
"虽然上面描述的模块级 API 是最常见且便捷的用法，但你也可以从 :class:`!Distribution` 类获取所有信息。 "
":class:`!Distribution` 是一个代表 Python `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 元数据的抽象对象。 你可以通过调用 :func:`distribution` 函数来获取对应某个已安装分发包的具体 "
":class:`!Distribution` 子类实例::"

#: ../../library/importlib.metadata.rst:428
msgid ""
">>> from importlib.metadata import distribution\n"
">>> dist = distribution('wheel')\n"
">>> type(dist)\n"
"<class 'importlib.metadata.PathDistribution'>"
msgstr ""
">>> from importlib.metadata import distribution\n"
">>> dist = distribution('wheel')\n"
">>> type(dist)\n"
"<class 'importlib.metadata.PathDistribution'>"

#: ../../library/importlib.metadata.rst:433
msgid ""
"Thus, an alternative way to get the version number is through the "
":class:`!Distribution` instance::"
msgstr "因此，一个获取版本号的替代方式是通过 :class:`!Distribution` 实例::"

#: ../../library/importlib.metadata.rst:436
msgid ""
">>> dist.version\n"
"'0.32.3'"
msgstr ""
">>> dist.version\n"
"'0.32.3'"

#: ../../library/importlib.metadata.rst:439
msgid ""
"There are all kinds of additional metadata available on "
":class:`!Distribution` instances::"
msgstr "在 :class:`!Distribution` 实例上提供了所有类别的附加元数据::"

#: ../../library/importlib.metadata.rst:442
msgid ""
">>> dist.metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'\n"
">>> dist.metadata['License']\n"
"'MIT'"
msgstr ""
">>> dist.metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'\n"
">>> dist.metadata['License']\n"
"'MIT'"

#: ../../library/importlib.metadata.rst:447
msgid ""
"For editable packages, an ``origin`` property may present :pep:`610` "
"metadata::"
msgstr "对于可编辑包，``origin`` 属性可能表示 :pep:`610` 元数据："

#: ../../library/importlib.metadata.rst:450
msgid ""
">>> dist.origin.url\n"
"'file:///path/to/wheel-0.32.3.editable-py3-none-any.whl'"
msgstr ""
">>> dist.origin.url\n"
"'file:///path/to/wheel-0.32.3.editable-py3-none-any.whl'"

#: ../../library/importlib.metadata.rst:456
msgid "The ``.origin`` property was added."
msgstr "增加了 ``.origin`` 特征属性。"

#: ../../library/importlib.metadata.rst:460
msgid "Distribution Discovery"
msgstr "分发包的发现"

#: ../../library/importlib.metadata.rst:462
msgid ""
"By default, this package provides built-in support for discovery of metadata"
" for file system and zip file `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_\\s. This metadata finder search defaults to ``sys.path``, but "
"varies slightly in how it interprets those values from how other import "
"machinery does. In particular:"
msgstr ""
"在默认情况下，这个包针对文件系统和 zip 文件 `分发包 "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 的元数据发现提供了内置支持。 这个元数据查找器的搜索目标默认为 "
"``sys.path``，但它对来自其他导入机制行为方式的解读会略有变化。 特别地:"

#: ../../library/importlib.metadata.rst:466
msgid ""
"``importlib.metadata`` does not honor :class:`bytes` objects on "
"``sys.path``."
msgstr "``importlib.metadata`` 不会识别  ``sys.path`` 上的 :class:`bytes` 对象。"

#: ../../library/importlib.metadata.rst:467
msgid ""
"``importlib.metadata`` will incidentally honor :py:class:`pathlib.Path` "
"objects on ``sys.path`` even though such values will be ignored for imports."
msgstr ""
"``importlib.metadata`` 将顺带识别 ``sys.path`` 上的 :py:class:`pathlib.Path` "
"对象，即使这些值会被导入操作所忽略。"

#: ../../library/importlib.metadata.rst:471
msgid "Implementing Custom Providers"
msgstr "实现自定义 Provider"

#: ../../library/importlib.metadata.rst:473
msgid ""
"``importlib.metadata`` address two API surfaces, one for *consumers* and "
"another for *providers*. Most users are consumers, consuming metadata "
"provided by the packages. There are other use-cases, however, where users "
"wish to expose metadata through some other mechanism, such as alongside a "
"custom importer. Such a use case calls for a *custom provider*."
msgstr ""
"``importlib.metadata`` 会处理两种 API 表层，一个用于 *消费方* 而另一个用于 *供给方*。 "
"大部分用户属于消费方，他们将消费由软件包提供的元数据。 不过也存在其他的用例，其中的用户会想要通过某些其他机制来暴露元数据，比如配合自定义的导入器。 "
"这样的用例就需要 *自定义供给方*。"

#: ../../library/importlib.metadata.rst:480
msgid ""
"Because `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ metadata is not available through :data:`sys.path` searches, or "
"package loaders directly, the metadata for a distribution is found through "
"import system :ref:`finders <finders-and-loaders>`. To find a distribution "
"package's metadata, ``importlib.metadata`` queries the list of :term:`meta "
"path finders <meta path finder>` on :data:`sys.meta_path`."
msgstr ""
"由于 `分发包 <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ 元数据不能通过 :data:`sys.path` 搜索或是直接通过包加载器来获得，一个分发包的元数据是通过导入系统的 "
":ref:`查找器 <finders-and-loaders>` 来找到的。 要找到分发包的元数据，``importlib.metadata`` 会在 "
":data:`sys.meta_path` 上查询 :term:`元路径查找器 <meta path finder>` 的列表。"

#: ../../library/importlib.metadata.rst:488
msgid ""
"The implementation has hooks integrated into the ``PathFinder``, serving "
"metadata for distribution packages found on the file system."
msgstr "该实现具有集成到 ``PathFinder`` 中的钩子，为在文件系统中找到的分发包提供元数据。"

#: ../../library/importlib.metadata.rst:491
msgid ""
"The abstract class :py:class:`importlib.abc.MetaPathFinder` defines the "
"interface expected of finders by Python's import system. "
"``importlib.metadata`` extends this protocol by looking for an optional "
"``find_distributions`` callable on the finders from :data:`sys.meta_path` "
"and presents this extended interface as the ``DistributionFinder`` abstract "
"base class, which defines this abstract method::"
msgstr ""
"抽象基类 :py:class:`importlib.abc.MetaPathFinder` 定义了 Python 导入系统期望的查找器接口。 "
"``importlib.metadata`` 通过寻找 :data:`sys.meta_path` 上查找器可选的 "
"``find_distributions`` 可调用的属性扩展这个协议，并将这个扩展接口作为 ``DistributionFinder`` "
"抽象基类提供，它定义了这个抽象方法："

#: ../../library/importlib.metadata.rst:499
msgid ""
"@abc.abstractmethod\n"
"def find_distributions(context=DistributionFinder.Context()) -> Iterable[Distribution]:\n"
"    \"\"\"Return an iterable of all Distribution instances capable of\n"
"    loading the metadata for packages for the indicated ``context``.\n"
"    \"\"\""
msgstr ""
"@abc.abstractmethod\n"
"def find_distributions(context=DistributionFinder.Context()) -> Iterable[Distribution]:\n"
"    \"\"\"返回一个由所有能够为指定 ``context`` 加载包的元数据的\n"
"    Distribution 实例组成的可迭代对象。\n"
"    \"\"\""

#: ../../library/importlib.metadata.rst:505
msgid ""
"The ``DistributionFinder.Context`` object provides ``.path`` and ``.name`` "
"properties indicating the path to search and name to match and may supply "
"other relevant context sought by the consumer."
msgstr ""
"``DistributionFinder.Context`` 对象提供了指示搜索路径和匹配名称的属性 ``.path`` 和 ``.name`` "
"并可能提供其他的由消费方查找的相关上下文。"

#: ../../library/importlib.metadata.rst:509
msgid ""
"In practice, to support finding distribution package metadata in locations "
"other than the file system, subclass ``Distribution`` and implement the "
"abstract methods. Then from a custom finder, return instances of this "
"derived ``Distribution`` in the ``find_distributions()`` method."
msgstr ""
"在实践中，为了支持在文件系统以外的其他位置查找分发包的元数据，可以子类化 ``Distribution`` 并实现其抽象方法。 然后从一个自定义查找器的"
" ``find_distributions()`` 方法返回这个派生的 ``Distribution`` 的实例。"

#: ../../library/importlib.metadata.rst:516
msgid "Example"
msgstr "示例"

#: ../../library/importlib.metadata.rst:518
msgid "Imagine a custom finder that loads Python modules from a database::"
msgstr "设想一个从数据库中加载 Python 模块的自定义查找器::"

#: ../../library/importlib.metadata.rst:520
msgid ""
"class DatabaseImporter(importlib.abc.MetaPathFinder):\n"
"    def __init__(self, db):\n"
"        self.db = db\n"
"\n"
"    def find_spec(self, fullname, target=None) -> ModuleSpec:\n"
"        return self.db.spec_from_name(fullname)\n"
"\n"
"sys.meta_path.append(DatabaseImporter(connect_db(...)))"
msgstr ""
"class DatabaseImporter(importlib.abc.MetaPathFinder):\n"
"    def __init__(self, db):\n"
"        self.db = db\n"
"\n"
"    def find_spec(self, fullname, target=None) -> ModuleSpec:\n"
"        return self.db.spec_from_name(fullname)\n"
"\n"
"sys.meta_path.append(DatabaseImporter(connect_db(...)))"

#: ../../library/importlib.metadata.rst:529
msgid ""
"That importer now presumably provides importable modules from a database, "
"but it provides no metadata or entry points. For this custom importer to "
"provide metadata, it would also need to implement ``DistributionFinder``::"
msgstr ""
"该导入器现在大概可以从数据库中导入模块，但它不提供元数据或入口点。这个自定义导入器如果要提供元数据，它还需要实现 "
"``DistributionFinder``："

#: ../../library/importlib.metadata.rst:534
msgid ""
"from importlib.metadata import DistributionFinder\n"
"\n"
"class DatabaseImporter(DistributionFinder):\n"
"    ...\n"
"\n"
"    def find_distributions(self, context=DistributionFinder.Context()):\n"
"        query = dict(name=context.name) if context.name else {}\n"
"        for dist_record in self.db.query_distributions(query):\n"
"            yield DatabaseDistribution(dist_record)"
msgstr ""
"from importlib.metadata import DistributionFinder\n"
"\n"
"class DatabaseImporter(DistributionFinder):\n"
"    ...\n"
"\n"
"    def find_distributions(self, context=DistributionFinder.Context()):\n"
"        query = dict(name=context.name) if context.name else {}\n"
"        for dist_record in self.db.query_distributions(query):\n"
"            yield DatabaseDistribution(dist_record)"

#: ../../library/importlib.metadata.rst:544
msgid ""
"In this way, ``query_distributions`` would return records for each "
"distribution served by the database matching the query. For example, if "
"``requests-1.0`` is in the database, ``find_distributions`` would yield a "
"``DatabaseDistribution`` for ``Context(name='requests')`` or "
"``Context(name=None)``."
msgstr ""
"这样一来，``query_distributions`` 就会返回数据库中与查询匹配的每个分发包的记录。例如，如果数据库中有 "
"``requests-1.0``，``find_distributions`` 就会为 ``Context(name='requests')`` 或 "
"``Context(name=None)`` 产生 ``DatabaseDistribution``。"

#: ../../library/importlib.metadata.rst:550
msgid ""
"For the sake of simplicity, this example ignores ``context.path``\\. The "
"``path`` attribute defaults to ``sys.path`` and is the set of import paths "
"to be considered in the search. A ``DatabaseImporter`` could potentially "
"function without any concern for a search path. Assuming the importer does "
"no partitioning, the \"path\" would be irrelevant. In order to illustrate "
"the purpose of ``path``, the example would need to illustrate a more complex"
" ``DatabaseImporter`` whose behavior varied depending on "
"``sys.path``/``PYTHONPATH``. In that case, the ``find_distributions`` should"
" honor the ``context.path`` and only yield ``Distribution``\\ s pertinent to"
" that path."
msgstr ""
"为简单起见，本例忽略了 ``context.path``。``path`` 属性默认为 ``sys.path``，是搜索中考虑的导入路径集。一个 "
"``DatabaseImporter`` 可以在不考虑搜索路径的情况下运作。假设导入器不进行分区，那么 \"path\" 就无关紧要了。为了说明 "
"``path`` 的作用，示例需要展示一个更复杂的 ``DatabaseImporter``，它的行为随 "
"``sys.path``/``PYTHONPATH`` 而变化。在这种情况下，``find_distributions`` 应该尊重 "
"``context.path``，并且只产生与该路径相关的 ``Distribution``。"

#: ../../library/importlib.metadata.rst:561
msgid "``DatabaseDistribution``, then, would look something like::"
msgstr "那么，``DatabaseDistribution`` 看起来就像是这样："

#: ../../library/importlib.metadata.rst:563
msgid ""
"class DatabaseDistribution(importlib.metadata.Distribution):\n"
"    def __init__(self, record):\n"
"        self.record = record\n"
"\n"
"    def read_text(self, filename):\n"
"        \"\"\"\n"
"        Read a file like \"METADATA\" for the current distribution.\n"
"        \"\"\"\n"
"        if filename == \"METADATA\":\n"
"            return f\"\"\"Name: {self.record.name}\n"
"Version: {self.record.version}\n"
"\"\"\"\n"
"        if filename == \"entry_points.txt\":\n"
"            return \"\\n\".join(\n"
"              f\"\"\"[{ep.group}]\\n{ep.name}={ep.value}\"\"\"\n"
"              for ep in self.record.entry_points)\n"
"\n"
"    def locate_file(self, path):\n"
"        raise RuntimeError(\"This distribution has no file system\")"
msgstr ""
"class DatabaseDistribution(importlib.metadata.Distribution):\n"
"    def __init__(self, record):\n"
"        self.record = record\n"
"\n"
"    def read_text(self, filename):\n"
"        \"\"\"\n"
"        为当前分发版读取文件型的 \"METADATA\"。\n"
"        \"\"\"\n"
"        if filename == \"METADATA\":\n"
"            return f\"\"\"Name: {self.record.name}\n"
"Version: {self.record.version}\n"
"\"\"\"\n"
"        if filename == \"entry_points.txt\":\n"
"            return \"\\n\".join(\n"
"              f\"\"\"[{ep.group}]\\n{ep.name}={ep.value}\"\"\"\n"
"              for ep in self.record.entry_points)\n"
"\n"
"    def locate_file(self, path):\n"
"        raise RuntimeError(\"This distribution has no file system\")"

#: ../../library/importlib.metadata.rst:583
msgid ""
"This basic implementation should provide metadata and entry points for "
"packages served by the ``DatabaseImporter``, assuming that the ``record`` "
"supplies suitable ``.name``, ``.version``, and ``.entry_points`` attributes."
msgstr ""
"这个基本实现应当为由 ``DatabaseImporter`` 进行服务的包提供元数据和入口点，假定 ``record`` 提供了适当的 "
"``.name``, ``.version`` 和 ``.entry_points`` 属性。"

#: ../../library/importlib.metadata.rst:588
msgid ""
"The ``DatabaseDistribution`` may also provide other metadata files, like "
"``RECORD`` (required for ``Distribution.files``) or override the "
"implementation of ``Distribution.files``. See the source for more "
"inspiration."
msgstr ""
"``DatabaseDistribution`` 还可能提供其他元数据文件，比如 ``RECORD`` (对 "
"``Distribution.files`` 来说需要) 或重写 ``Distribution.files`` 的实现。 请参看源代码深入了解。"
