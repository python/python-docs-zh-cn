# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ppcfish <ppcfish@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Arisaka97 <solitaire2312@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:14+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/tempfile.rst:2
msgid ":mod:`!tempfile` --- Generate temporary files and directories"
msgstr ":mod:`!tempfile` --- 生成临时文件和目录"

#: ../../library/tempfile.rst:9
msgid "**Source code:** :source:`Lib/tempfile.py`"
msgstr "**源代码：** :source:`Lib/tempfile.py`"

#: ../../library/tempfile.rst:17
msgid ""
"This module creates temporary files and directories.  It works on all "
"supported platforms. :class:`TemporaryFile`, :class:`NamedTemporaryFile`, "
":class:`TemporaryDirectory`, and :class:`SpooledTemporaryFile` are high-"
"level interfaces which provide automatic cleanup and can be used as "
":term:`context managers <context manager>`. :func:`mkstemp` and "
":func:`mkdtemp` are lower-level functions which require manual cleanup."
msgstr ""
"该模块可以创建临时文件和目录。 它适用于所有受支持的平台。 :class:`TemporaryFile`, "
":class:`NamedTemporaryFile`, :class:`TemporaryDirectory` 和 "
":class:`SpooledTemporaryFile` 是提供自动清理功能的高层级接口并可用作 :term:`上下文管理器 <context "
"manager>`。 :func:`mkstemp` 和 :func:`mkdtemp` 是需要执行手动清理的低层级函数。"

#: ../../library/tempfile.rst:24
msgid ""
"All the user-callable functions and constructors take additional arguments "
"which allow direct control over the location and name of temporary files and"
" directories. Files names used by this module include a string of random "
"characters which allows those files to be securely created in shared "
"temporary directories. To maintain backward compatibility, the argument "
"order is somewhat odd; it is recommended to use keyword arguments for "
"clarity."
msgstr ""
"所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。"

#: ../../library/tempfile.rst:32
msgid "The module defines the following user-callable items:"
msgstr "这个模块定义了以下内容供用户调用："

#: ../../library/tempfile.rst:36
msgid ""
"Return a :term:`file-like object` that can be used as a temporary storage "
"area. The file is created securely, using the same rules as :func:`mkstemp`."
" It will be destroyed as soon as it is closed (including an implicit close "
"when the object is garbage collected).  Under Unix, the directory entry for "
"the file is either not created at all or is removed immediately after the "
"file is created.  Other platforms do not support this; your code should not "
"rely on a temporary file created using this function having or not having a "
"visible name in the file system."
msgstr ""
"返回一个 :term:`file-like object` 作为临时存储区域。创建该文件使用了与 :func:`mkstemp` "
"相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix "
"下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。"

#: ../../library/tempfile.rst:44
msgid ""
"The resulting object can be used as a :term:`context manager` (see "
":ref:`tempfile-examples`).  On completion of the context or destruction of "
"the file object the temporary file will be removed from the filesystem."
msgstr ""
"结果对象可以用作 :term:`context manager` (参见 :ref:`tempfile-examples`)。 "
"上下文结束或文件对象销毁后会将临时文件从文件系统中移除。"

#: ../../library/tempfile.rst:49
msgid ""
"The *mode* parameter defaults to ``'w+b'`` so that the file created can be "
"read and written without being closed.  Binary mode is used so that it "
"behaves consistently on all platforms without regard for the data that is "
"stored.  *buffering*, *encoding*, *errors* and *newline* are interpreted as "
"for :func:`open`."
msgstr ""
"*mode* 参数默认值为 "
"``'w+b'``，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。*buffering*、*encoding*、*errors*"
" 和 *newline* 的含义与 :func:`open` 中的相同。"

#: ../../library/tempfile.rst:55
msgid ""
"The *dir*, *prefix* and *suffix* parameters have the same meaning and "
"defaults as with :func:`mkstemp`."
msgstr "参数 *dir*、*prefix* 和 *suffix* 的含义和默认值都与它们在 :func:`mkstemp` 中的相同。"

#: ../../library/tempfile.rst:58
msgid ""
"The returned object is a true file object on POSIX platforms.  On other "
"platforms, it is a file-like object whose :attr:`!file` attribute is the "
"underlying true file object."
msgstr ""
"在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件型对象，它的 :attr:`!file` 属性是底层的真实文件对象。"

#: ../../library/tempfile.rst:62
msgid ""
"The :py:const:`os.O_TMPFILE` flag is used if it is available and works "
"(Linux-specific, requires Linux kernel 3.11 or later)."
msgstr ""
"在可用且有效时将使用 :py:const:`os.O_TMPFILE` 旗标（Linux 专属，需要 Linux 内核版本为 3.11 或更高）。"

#: ../../library/tempfile.rst:65
msgid ""
"On platforms that are neither Posix nor Cygwin, TemporaryFile is an alias "
"for NamedTemporaryFile."
msgstr "在 Posix 或 Cygwin 以外的平台上，TemporaryFile 是 NamedTemporaryFile 的别名。"

#: ../../library/tempfile.rst:68 ../../library/tempfile.rst:137
#: ../../library/tempfile.rst:264
msgid ""
"Raises an :ref:`auditing event <auditing>` ``tempfile.mkstemp`` with "
"argument ``fullpath``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``tempfile.mkstemp`` 并附带参数 ``fullpath``。"

#: ../../library/tempfile.rst:72
msgid "The :py:const:`os.O_TMPFILE` flag is now used if available."
msgstr "在可以时现在将使用 :py:const:`os.O_TMPFILE` 旗标。"

#: ../../library/tempfile.rst:74 ../../library/tempfile.rst:139
#: ../../library/tempfile.rst:169
msgid "Added *errors* parameter."
msgstr "添加了 *errors* 参数。"

#: ../../library/tempfile.rst:80
msgid ""
"This function operates exactly as :func:`TemporaryFile` does, except the "
"following differences:"
msgstr "此函数的操作与 :func:`TemporaryFile` 所做的完全相同，除了存在下列差异:"

#: ../../library/tempfile.rst:83
msgid ""
"This function returns a file that is guaranteed to have a visible name in "
"the file system."
msgstr "此函数将返回一个肯定具有在文件系统中的可见名称的文件。"

#: ../../library/tempfile.rst:85
msgid ""
"To manage the named file, it extends the parameters of :func:`TemporaryFile`"
" with *delete* and *delete_on_close* parameters that determine whether and "
"how the named file should be automatically deleted."
msgstr ""
"为管理指定名称的文件，它将为 :func:`TemporaryFile` 扩展 *delete* 和 *delete_on_close* "
"形参来确定指定名称的文件是否要被自动删除以及要如何执行删除。"

#: ../../library/tempfile.rst:89
msgid ""
"The returned object is always a :term:`file-like object` whose :attr:`!file`"
" attribute is the underlying true file object. This file-like object can be "
"used in a :keyword:`with` statement, just like a normal file.  The name of "
"the temporary file can be retrieved from the :attr:`!name` attribute of the "
"returned file-like object. On Unix, unlike with the :func:`TemporaryFile`, "
"the directory entry does not get unlinked immediately after the file "
"creation."
msgstr ""
"返回的对象将总是一个 :term:`file-like object` 并且其 :attr:`!file` 属性为底层的实际文件对象。 "
"这个文件型对象可在 :keyword:`with` 语句中使用，就像普通的文件一样。 该临时文件的文件名可从被返回的文件型对象的 "
":attr:`!name` 属性中提取。 在 Unix 上，不同于 "
":func:`TemporaryFile`，其目录项不会在创建文件之后立即被取消链接。"

#: ../../library/tempfile.rst:97
msgid ""
"If *delete* is true (the default) and *delete_on_close* is true (the "
"default), the file is deleted as soon as it is closed. If *delete* is true "
"and *delete_on_close* is false, the file is deleted on context manager exit "
"only, or else when the :term:`file-like object` is finalized. Deletion is "
"not always guaranteed in this case (see :meth:`object.__del__`). If *delete*"
" is false, the value of *delete_on_close* is ignored."
msgstr ""
"如果 *delete* 为（默认的）真值且 *delete_on_close* 也为（默认的）真值，则文件将在关闭后立即被删除。 如果 *delete*"
" 为真值而 *delete_on_close* 为假值，则文件将在退出上下文管理器，或者当 :term:`file-like object` "
"被终结时才会被删除。 在此情况下将不保证总是能删除文件（参见 :meth:`object.__del__` 文档）。 如果 *delete* 为假值，则"
" *delete_on_close* 的值将被忽略。"

#: ../../library/tempfile.rst:104
msgid ""
"Therefore to use the name of the temporary file to reopen the file after "
"closing it, either make sure not to delete the file upon closure (set the "
"*delete* parameter to be false) or, in case the temporary file is created in"
" a :keyword:`with` statement, set the *delete_on_close* parameter to be "
"false. The latter approach is recommended as it provides assistance in "
"automatic cleaning of the temporary file upon the context manager exit."
msgstr ""
"因此要使用该临时文件的名称在关闭文件之后重新打开它，那么注意在关闭时不要删除文件（将 *delete* 形参设为假值），或者如果该临时文件是在 "
":keyword:`with` 语句中创建的，则要将 *delete_on_close* 形参设为假值。 "
"更推荐后一种方式因为它在上下文管理器退出时提供了自动清理协助。"

#: ../../library/tempfile.rst:111
msgid ""
"Opening the temporary file again by its name while it is still open works as"
" follows:"
msgstr "临时文件仍然打开时使用其名称再次打开它的操作如下所示:"

#: ../../library/tempfile.rst:114
msgid "On POSIX the file can always be opened again."
msgstr "在 POSIX 上该文件总是可以被再次打开。the file can always be opened again."

#: ../../library/tempfile.rst:115
msgid ""
"On Windows, make sure that at least one of the following conditions are "
"fulfilled:"
msgstr "在 Windows 上，要确保至少满足下列条件之一:"

#: ../../library/tempfile.rst:118
msgid "*delete* is false"
msgstr "*delete* 为假值"

#: ../../library/tempfile.rst:119
msgid ""
"additional open shares delete access (e.g. by calling :func:`os.open` with "
"the flag ``O_TEMPORARY``)"
msgstr "额外的打开将共享删除操作（例如调用 :func:`os.open` 时附带了 ``O_TEMPORARY`` 旗标）"

#: ../../library/tempfile.rst:121
msgid ""
"*delete* is true but *delete_on_close* is false. Note, that in this case the"
" additional opens that do not share delete access (e.g. created via builtin "
":func:`open`) must be closed before exiting the context manager, else the "
":func:`os.unlink` call on context manager exit will fail with a "
":exc:`PermissionError`."
msgstr ""
"*delete* 为真值但 *delete_on_close* 为假值。 注意，在此情况下没有共享删除操作的额外的打开（例如通过内置的 "
":func:`open` 创建）必须在退出上下文管理器之前被关闭，否则在退出上下文管理器时的 :func:`os.unlink` 调用将失败并引发 "
":exc:`PermissionError`。"

#: ../../library/tempfile.rst:127
msgid ""
"On Windows, if *delete_on_close* is false, and the file is created in a "
"directory for which the user lacks delete access, then the :func:`os.unlink`"
" call on exit of the context manager will fail with a "
":exc:`PermissionError`. This cannot happen when *delete_on_close* is true "
"because delete access is requested by the open, which fails immediately if "
"the requested access is not granted."
msgstr ""
"在 Windows 上，如果 *delete_on_close* 为假值，并且文件是在用户没有删除权限的目录中创建的，则退出上下文管理器时的 "
":func:`os.unlink` 调用将失败并引发 :exc:`PermissionError`。 这在 *delete_on_close* "
"为真值时不会发生因为删除权限是由打开操作所请求的，如果未获得所请求的权限此操作将立即失败。"

#: ../../library/tempfile.rst:134
msgid ""
"On POSIX (only), a process that is terminated abruptly with SIGKILL cannot "
"automatically delete any NamedTemporaryFiles it created."
msgstr "（只有）在 POSIX 上，一个用 SIGKILL 突然终止的进程无法自动删除它所创建的任何 NamedTemporaryFiles。"

#: ../../library/tempfile.rst:142
msgid "Added *delete_on_close* parameter."
msgstr "增加了 *delete_on_close* 形参。"

#: ../../library/tempfile.rst:148
msgid ""
"This class operates exactly as :func:`TemporaryFile` does, except that data "
"is spooled in memory until the file size exceeds *max_size*, or until the "
"file's :func:`~io.IOBase.fileno` method is called, at which point the "
"contents are written to disk and operation proceeds as with "
":func:`TemporaryFile`."
msgstr ""
"这个类执行的操作与 :func:`TemporaryFile` 完全相同，但会将数据放入内存池直到文件大小超过 *max_size*，或者直到文件的 "
":func:`~io.IOBase.fileno` 方法被调用，这时文件内容会被写入磁盘并如使用 :func:`TemporaryFile` "
"时一样执行后续操作。"

#: ../../library/tempfile.rst:156
msgid ""
"The resulting file has one additional method, :meth:`!rollover`, which "
"causes the file to roll over to an on-disk file regardless of its size."
msgstr "结果文件有一个额外的方法 :meth:`!rollover`，它可以忽略文件大小将其立即写入到磁盘文件。"

#: ../../library/tempfile.rst:159
msgid ""
"The returned object is a file-like object whose :attr:`!_file` attribute is "
"either an :class:`io.BytesIO` or :class:`io.TextIOWrapper` object (depending"
" on whether binary or text *mode* was specified) or a true file object, "
"depending on whether :meth:`rollover` has been called.  This file-like "
"object can be used in a :keyword:`with` statement, just like a normal file."
msgstr ""
"返回的对象是一个文件型对象，它的 :attr:`!_file` 属性是 :class:`io.BytesIO` 或 "
":class:`io.TextIOWrapper` 对象（这取决于所指定的 *mode* 是二进制还是文本）或真实的文件对象，这取决于 "
":meth:`rollover` 是否已被调用。 这个文件型对象可以像普通文件一样在 :keyword:`with` 语句中使用。"

#: ../../library/tempfile.rst:166
msgid "the truncate method now accepts a *size* argument."
msgstr "现在 truncate 方法可接受一个 *size* 参数。"

#: ../../library/tempfile.rst:172
msgid ""
"Fully implements the :class:`io.BufferedIOBase` and :class:`io.TextIOBase` "
"abstract base classes (depending on whether binary or text *mode* was "
"specified)."
msgstr ""
"完整实现 :class:`io.BufferedIOBase` 和 :class:`io.TextIOBase` 抽象基类（取决于二进制或文本 "
"*mode* 是否已指定）。"

#: ../../library/tempfile.rst:180
msgid ""
"This class securely creates a temporary directory using the same rules as "
":func:`mkdtemp`. The resulting object can be used as a :term:`context "
"manager` (see :ref:`tempfile-examples`).  On completion of the context or "
"destruction of the temporary directory object, the newly created temporary "
"directory and all its contents are removed from the filesystem."
msgstr ""
"这个类会使用与 :func:`mkdtemp` 相同的规则安全地创建一个临时目录。 结果对象可以被用作 :term:`context manager` "
"(参见 :ref:`tempfile-examples`)。 在完成上下文或销毁临时目录对象时，新创建的临时目录及其所有内容会从文件系统中被移除。"

#: ../../library/tempfile.rst:188
msgid ""
"The directory name can be retrieved from the :attr:`!name` attribute of the "
"returned object.  When the returned object is used as a :term:`context "
"manager`, the :attr:`!name` will be assigned to the target of the "
":keyword:`!as` clause in the :keyword:`with` statement, if there is one."
msgstr ""
"可以从所返回对象的 :attr:`!name` 属性中提取目录名称。 当返回的对象被用作 :term:`context manager` 时，这个 "
":attr:`!name` 将被作为 :keyword:`with` 语句中 :keyword:`!as` 子句的目标，如果存在该子句的话。"

#: ../../library/tempfile.rst:195
msgid ""
"The directory can be explicitly cleaned up by calling the :meth:`!cleanup` "
"method. If *ignore_cleanup_errors* is true, any unhandled exceptions during "
"explicit or implicit cleanup (such as a :exc:`PermissionError` removing open"
" files on Windows) will be ignored, and the remaining removable items "
"deleted on a \"best-effort\" basis. Otherwise, errors will be raised in "
"whatever context cleanup occurs (the :meth:`!cleanup` call, exiting the "
"context manager, when the object is garbage-collected or during interpreter "
"shutdown)."
msgstr ""
"此目录可通过调用 :meth:`!cleanup` 方法来显式地清理。 如果 *ignore_cleanup_errors* "
"为真值，则在显式或隐式清理（例如在 Windows 上 :exc:`PermissionError` "
"移除打开的文件）期间出现的未处理异常将被忽略，并且剩余的可移除条目会被“尽可能”地删除。 在其他情况下，错误将在任何上下文清理发生时被引发（如 "
":meth:`!cleanup` 调用，退出上下文管理器、对象被作为垃圾回收或解释器关闭等情况）。"

#: ../../library/tempfile.rst:204
msgid ""
"The *delete* parameter can be used to disable cleanup of the directory tree "
"upon exiting the context.  While it may seem unusual for a context manager "
"to disable the action taken when exiting the context, it can be useful "
"during debugging or when you need your cleanup behavior to be conditional "
"based on other logic."
msgstr ""
"*delete* 可被用于禁止在退出上下文时清理目录树。 "
"虽然在退出上下文时禁止此操作看起来可能很不常见，但这在进行调试或在你的清理行为需要以其他逻辑为条件时将会很有用处。"

#: ../../library/tempfile.rst:210 ../../library/tempfile.rst:290
msgid ""
"Raises an :ref:`auditing event <auditing>` ``tempfile.mkdtemp`` with "
"argument ``fullpath``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``tempfile.mkdtemp`` 并附带参数 ``fullpath``。"

#: ../../library/tempfile.rst:214
msgid "Added *ignore_cleanup_errors* parameter."
msgstr "添加了 *ignore_cleanup_errors* 形参。"

#: ../../library/tempfile.rst:217
msgid "Added the *delete* parameter."
msgstr "增加了 *delete* 形参。"

#: ../../library/tempfile.rst:223
msgid ""
"Creates a temporary file in the most secure manner possible.  There are no "
"race conditions in the file's creation, assuming that the platform properly "
"implements the :const:`os.O_EXCL` flag for :func:`os.open`.  The file is "
"readable and writable only by the creating user ID.  If the platform uses "
"permission bits to indicate whether a file is executable, the file is "
"executable by no one.  The file descriptor is not inherited by child "
"processes."
msgstr ""
"以最安全的方式创建一个临时文件。假设所在平台正确实现了 :func:`os.open` 的 :const:`os.O_EXCL` "
"标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。"

#: ../../library/tempfile.rst:231
msgid ""
"Unlike :func:`TemporaryFile`, the user of :func:`mkstemp` is responsible for"
" deleting the temporary file when done with it."
msgstr "与 :func:`TemporaryFile` 不同，:func:`mkstemp` 用户用完临时文件后需要自行将其删除。"

#: ../../library/tempfile.rst:234
msgid ""
"If *suffix* is not ``None``, the file name will end with that suffix, "
"otherwise there will be no suffix.  :func:`mkstemp` does not put a dot "
"between the file name and the suffix; if you need one, put it at the "
"beginning of *suffix*."
msgstr ""
"如果 *suffix* 不是 ``None`` 则文件名将以该后缀结尾，是 ``None`` 则没有后缀。:func:`mkstemp` "
"不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 *suffix* 的开头。"

#: ../../library/tempfile.rst:239
msgid ""
"If *prefix* is not ``None``, the file name will begin with that prefix; "
"otherwise, a default prefix is used.  The default is the return value of "
":func:`gettempprefix` or :func:`gettempprefixb`, as appropriate."
msgstr ""
"如果 *prefix* 不是 ``None``，则文件名将以该前缀开头，是 ``None``      则使用默认前缀。默认前缀是 "
":func:`gettempprefix` 或 :func:`gettempprefixb` 函数的返回值（自动调用合适的函数）。"

#: ../../library/tempfile.rst:243
msgid ""
"If *dir* is not ``None``, the file will be created in that directory; "
"otherwise, a default directory is used.  The default directory is chosen "
"from a platform-dependent list, but the user of the application can control "
"the directory location by setting the *TMPDIR*, *TEMP* or *TMP* environment "
"variables.  There is thus no guarantee that the generated filename will have"
" any nice properties, such as not requiring quoting when passed to external "
"commands via ``os.popen()``."
msgstr ""
"如果 *dir* 不为 ``None``，则在指定的目录创建文件，是 ``None`` "
"则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 *TMPDIR*、*TEMP* 或 *TMP* "
"环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 ``os.popen()`` 将路径传递给外部命令时仍需要加引号。"

#: ../../library/tempfile.rst:251
msgid ""
"If any of *suffix*, *prefix*, and *dir* are not ``None``, they must be the "
"same type. If they are bytes, the returned name will be bytes instead of "
"str. If you want to force a bytes return value with otherwise default "
"behavior, pass ``suffix=b''``."
msgstr ""
"如果 *suffix*、*prefix* 和 *dir* 中的任何一个不是 ``None``，就要保证它们是同一数据类型。如果它们是 "
"bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 "
"``suffix=b''``。"

#: ../../library/tempfile.rst:257
msgid ""
"If *text* is specified and true, the file is opened in text mode. Otherwise,"
" (the default) the file is opened in binary mode."
msgstr "如果指定了 *text* 且为真值，文件会以文本模式打开。 否则，文件（默认）会以二进制模式打开。"

#: ../../library/tempfile.rst:260
msgid ""
":func:`mkstemp` returns a tuple containing an OS-level handle to an open "
"file (as would be returned by :func:`os.open`) and the absolute pathname of "
"that file, in that order."
msgstr ""
":func:`mkstemp` 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 :func:`os.open` "
"的返回值），第二元素是该文件的绝对路径。"

#: ../../library/tempfile.rst:266 ../../library/tempfile.rst:292
msgid ""
"*suffix*, *prefix*, and *dir* may now be supplied in bytes in order to "
"obtain a bytes return value.  Prior to this, only str was allowed. *suffix* "
"and *prefix* now accept and default to ``None`` to cause an appropriate "
"default value to be used."
msgstr ""
"现在，*suffix*、*prefix* 和 *dir* 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 "
"str。*suffix* 和 *prefix* 现在可以接受 ``None``，并且默认为 ``None`` 以使用合适的默认值。"

#: ../../library/tempfile.rst:272 ../../library/tempfile.rst:298
msgid "The *dir* parameter now accepts a :term:`path-like object`."
msgstr "*dir* 参数现在可接受一个路径类对象 (:term:`path-like object`)。"

#: ../../library/tempfile.rst:278
msgid ""
"Creates a temporary directory in the most secure manner possible. There are "
"no race conditions in the directory's creation.  The directory is readable, "
"writable, and searchable only by the creating user ID."
msgstr "以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。"

#: ../../library/tempfile.rst:282
msgid ""
"The user of :func:`mkdtemp` is responsible for deleting the temporary "
"directory and its contents when done with it."
msgstr ":func:`mkdtemp` 用户用完临时目录后需要自行将其删除。"

#: ../../library/tempfile.rst:285
msgid ""
"The *prefix*, *suffix*, and *dir* arguments are the same as for "
":func:`mkstemp`."
msgstr "*prefix*、*suffix* 和 *dir* 的含义与它们在 :func:`mkstemp` 中的相同。"

#: ../../library/tempfile.rst:288
msgid ":func:`mkdtemp` returns the absolute pathname of the new directory."
msgstr ":func:`mkdtemp` 返回新目录的绝对路径。"

#: ../../library/tempfile.rst:301
msgid ""
":func:`mkdtemp` now always returns an absolute path, even if *dir* is "
"relative."
msgstr ":func:`mkdtemp` 现在将始终返回绝对路径，即使 *dir* 为相对路径。"

#: ../../library/tempfile.rst:307
msgid ""
"Return the name of the directory used for temporary files. This defines the "
"default value for the *dir* argument to all functions in this module."
msgstr "返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 *dir* 参数的默认值。"

#: ../../library/tempfile.rst:311
msgid ""
"Python searches a standard list of directories to find one which the calling"
" user can create files in.  The list is:"
msgstr "Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是："

#: ../../library/tempfile.rst:314
msgid "The directory named by the :envvar:`TMPDIR` environment variable."
msgstr ":envvar:`TMPDIR` 环境变量指向的目录。"

#: ../../library/tempfile.rst:316
msgid "The directory named by the :envvar:`TEMP` environment variable."
msgstr ":envvar:`TEMP` 环境变量指向的目录。"

#: ../../library/tempfile.rst:318
msgid "The directory named by the :envvar:`TMP` environment variable."
msgstr ":envvar:`TMP` 环境变量指向的目录。"

#: ../../library/tempfile.rst:320
msgid "A platform-specific location:"
msgstr "与平台相关的位置："

#: ../../library/tempfile.rst:322
msgid ""
"On Windows, the directories :file:`C:\\\\TEMP`, :file:`C:\\\\TMP`, "
":file:`\\\\TEMP`, and :file:`\\\\TMP`, in that order."
msgstr ""
"在 Windows 上，依次为 :file:`C:\\\\TEMP`、:file:`C:\\\\TMP`、:file:`\\\\TEMP` 和 "
":file:`\\\\TMP`。"

#: ../../library/tempfile.rst:325
msgid ""
"On all other platforms, the directories :file:`/tmp`, :file:`/var/tmp`, and "
":file:`/usr/tmp`, in that order."
msgstr "在所有其他平台上，依次为 :file:`/tmp`、:file:`/var/tmp` 和 :file:`/usr/tmp`。"

#: ../../library/tempfile.rst:328
msgid "As a last resort, the current working directory."
msgstr "不得已时，使用当前工作目录。"

#: ../../library/tempfile.rst:330
msgid ""
"The result of this search is cached, see the description of :data:`tempdir` "
"below."
msgstr "搜索的结果会缓存起来，参见下面 :data:`tempdir` 的描述。"

#: ../../library/tempfile.rst:335
msgid ""
"Always returns a str.  Previously it would return any :data:`tempdir` value "
"regardless of type so long as it was not ``None``."
msgstr "总是返回一个字符串。 在之前的版本中它会返回任意 :data:`tempdir` 值而不考虑它的类型，只要它不为 ``None``。"

#: ../../library/tempfile.rst:340
msgid "Same as :func:`gettempdir` but the return value is in bytes."
msgstr "与 :func:`gettempdir` 相同，但返回值为字节类型。"

#: ../../library/tempfile.rst:346
msgid ""
"Return the filename prefix used to create temporary files.  This does not "
"contain the directory component."
msgstr "返回用于创建临时文件的文件名前缀，它不包含目录部分。"

#: ../../library/tempfile.rst:351
msgid "Same as :func:`gettempprefix` but the return value is in bytes."
msgstr "与 :func:`gettempprefix` 相同，但返回值为字节类型。"

#: ../../library/tempfile.rst:355
msgid ""
"The module uses a global variable to store the name of the directory used "
"for temporary files returned by :func:`gettempdir`.  It can be set directly "
"to override the selection process, but this is discouraged. All functions in"
" this module take a *dir* argument which can be used to specify the "
"directory. This is the recommended approach that does not surprise other "
"unsuspecting code by changing global API behavior."
msgstr ""
"本模块使用一个全局变量来存储由 :func:`gettempdir` 返回的临时文件使用的目录路径。 它可被直接设置以覆盖选择过程，但不建议这样做。 "
"本模块中的所有函数都接受一个 *dir* 参数，它可被用于指定目录。 这是不会通过改变全局 API 行为对其他无准备代码造成影响的推荐做法。"

#: ../../library/tempfile.rst:364
msgid ""
"When set to a value other than ``None``, this variable defines the default "
"value for the *dir* argument to the functions defined in this module, "
"including its type, bytes or str.  It cannot be a :term:`path-like object`."
msgstr ""
"当设为 ``None`` 以外的值时，此变量会为本模块中定义的函数的 *dir* 参数定义默认值，包括确定其类型为字节串还是字符串。 它不可以为 "
":term:`path-like object`。"

#: ../../library/tempfile.rst:369
msgid ""
"If ``tempdir`` is ``None`` (the default) at any call to any of the above "
"functions except :func:`gettempprefix` it is initialized following the "
"algorithm described in :func:`gettempdir`."
msgstr ""
"如果在调用除 :func:`gettempprefix` 外的上述任何函数时 ``tempdir`` 为 ``None`` (默认值) 则它会按照 "
":func:`gettempdir` 中所描述的算法来初始化。"

#: ../../library/tempfile.rst:375
msgid ""
"Beware that if you set ``tempdir`` to a bytes value, there is a nasty side "
"effect: The global default return type of :func:`mkstemp` and "
":func:`mkdtemp` changes to bytes when no explicit ``prefix``, ``suffix``, or"
" ``dir`` arguments of type str are supplied. Please do not write code "
"expecting or depending on this. This awkward behavior is maintained for "
"compatibility with the historical implementation."
msgstr ""
"请注意如果你将 ``tempdir`` 设为字节串值，会有一个麻烦的副作用: :func:`mkstemp` 和 :func:`mkdtemp` "
"的全局默认返回类型会在没有显式提供字符串类型的when no explicit ``prefix``, ``suffix`` 或 ``dir`` "
"的时候被改为字节串。 请不要编写预期或依赖于此入围的代码。  这个笨拙行为是为了保持与历史实现的兼容性。"

#: ../../library/tempfile.rst:386
msgid "Examples"
msgstr "例子"

#: ../../library/tempfile.rst:388
msgid ""
"Here are some examples of typical usage of the :mod:`tempfile` module::"
msgstr "以下是 :mod:`tempfile` 模块典型用法的一些示例::"

#: ../../library/tempfile.rst:390
msgid ""
">>> import tempfile\n"
"\n"
"# create a temporary file and write some data to it\n"
">>> fp = tempfile.TemporaryFile()\n"
">>> fp.write(b'Hello world!')\n"
"# read data from file\n"
">>> fp.seek(0)\n"
">>> fp.read()\n"
"b'Hello world!'\n"
"# close the file, it will be removed\n"
">>> fp.close()\n"
"\n"
"# create a temporary file using a context manager\n"
">>> with tempfile.TemporaryFile() as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.seek(0)\n"
"...     fp.read()\n"
"b'Hello world!'\n"
">>>\n"
"# file is now closed and removed\n"
"\n"
"# create a temporary file using a context manager\n"
"# close the file, use the name to open the file again\n"
">>> with tempfile.NamedTemporaryFile(delete_on_close=False) as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.close()\n"
"... # the file is closed, but not removed\n"
"... # open the file again by using its name\n"
"...     with open(fp.name, mode='rb') as f:\n"
"...         f.read()\n"
"b'Hello world!'\n"
">>>\n"
"# file is now removed\n"
"\n"
"# create a temporary directory using the context manager\n"
">>> with tempfile.TemporaryDirectory() as tmpdirname:\n"
"...     print('created temporary directory', tmpdirname)\n"
">>>\n"
"# directory and contents have been removed"
msgstr ""
">>> import tempfile\n"
"\n"
"# 创建一个临时文件并向其写入一些数据\n"
">>> fp = tempfile.TemporaryFile()\n"
">>> fp.write(b'Hello world!')\n"
"# 从文件读取数据\n"
">>> fp.seek(0)\n"
">>> fp.read()\n"
"b'Hello world!'\n"
"# 关闭文件，它将被移除\n"
">>> fp.close()\n"
"\n"
"# 使用上下文管理器创建一个临时文件\n"
">>> with tempfile.TemporaryFile() as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.seek(0)\n"
"...     fp.read()\n"
"b'Hello world!'\n"
">>>\n"
"# 现在文件已被关闭并移除\n"
"\n"
"# 使用上下文管理器创建一个临时文件\n"
"# 关闭该文件，再使用文件名再次打开该文件\n"
">>> with tempfile.NamedTemporaryFile(delete_on_close=False) as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.close()\n"
"... # 文件已被关闭，但未被移除\n"
"... # 使用文件名再次打开该文件\n"
"...     with open(fp.name, mode='rb') as f:\n"
"...         f.read()\n"
"b'Hello world!'\n"
">>>\n"
"# 现在文件已被移除\n"
"\n"
"# 使用上下文管理器创建一个临时目录\n"
">>> with tempfile.TemporaryDirectory() as tmpdirname:\n"
"...     print('created temporary directory', tmpdirname)\n"
">>>\n"
"# 目录及其内容已被移除"

#: ../../library/tempfile.rst:433
msgid "Deprecated functions and variables"
msgstr "已弃用的函数和变量"

#: ../../library/tempfile.rst:435
msgid ""
"A historical way to create temporary files was to first generate a file name"
" with the :func:`mktemp` function and then create a file using this name. "
"Unfortunately this is not secure, because a different process may create a "
"file with this name in the time between the call to :func:`mktemp` and the "
"subsequent attempt to create the file by the first process. The solution is "
"to combine the two steps and create the file immediately. This approach is "
"used by :func:`mkstemp` and the other functions described above."
msgstr ""
"创建临时文件有一种历史方法，首先使用 :func:`mktemp` 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 "
":func:`mktemp` "
"与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 "
":func:`mkstemp` 和上述其他函数所采用。"

#: ../../library/tempfile.rst:446
msgid "Use :func:`mkstemp` instead."
msgstr "使用 :func:`mkstemp` 来代替。"

#: ../../library/tempfile.rst:449
msgid ""
"Return an absolute pathname of a file that did not exist at the time the "
"call is made.  The *prefix*, *suffix*, and *dir* arguments are similar to "
"those of :func:`mkstemp`, except that bytes file names, ``suffix=None`` and "
"``prefix=None`` are not supported."
msgstr ""
"返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。*prefix*、*suffix* 和 *dir* 参数与 :func:`mkstemp` "
"中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 ``suffix=None`` 和 ``prefix=None``。"

#: ../../library/tempfile.rst:456
msgid ""
"Use of this function may introduce a security hole in your program.  By the "
"time you get around to doing anything with the file name it returns, someone"
" else may have beaten you to the punch.  :func:`mktemp` usage can be "
"replaced easily with :func:`NamedTemporaryFile`, passing it the "
"``delete=False`` parameter::"
msgstr ""
"使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。:func:`mktemp` "
"的功能可以很轻松地用 :func:`NamedTemporaryFile` 代替，当然需要传递 ``delete=False`` 参数::"

#: ../../library/tempfile.rst:462
msgid ""
">>> f = NamedTemporaryFile(delete=False)\n"
">>> f.name\n"
"'/tmp/tmptjujjt'\n"
">>> f.write(b\"Hello World!\\n\")\n"
"13\n"
">>> f.close()\n"
">>> os.unlink(f.name)\n"
">>> os.path.exists(f.name)\n"
"False"
msgstr ""
">>> f = NamedTemporaryFile(delete=False)\n"
">>> f.name\n"
"'/tmp/tmptjujjt'\n"
">>> f.write(b\"Hello World!\\n\")\n"
"13\n"
">>> f.close()\n"
">>> os.unlink(f.name)\n"
">>> os.path.exists(f.name)\n"
"False"

#: ../../library/tempfile.rst:11
msgid "temporary"
msgstr "临时"

#: ../../library/tempfile.rst:11
msgid "file name"
msgstr "文件名"

#: ../../library/tempfile.rst:11
msgid "file"
msgstr "文件"
