# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-29 14:17+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/concurrent.interpreters.rst:2
msgid ""
":mod:`!concurrent.interpreters` --- Multiple interpreters in the same "
"process"
msgstr ":mod:`!concurrent.interpreters` --- 同一进程中的多个解释器"

#: ../../library/concurrent.interpreters.rst:12
msgid "**Source code:** :source:`Lib/concurrent/interpreters`"
msgstr "**源代码:** :source:`Lib/concurrent/interpreters`"

#: ../../library/concurrent.interpreters.rst:16
msgid ""
"The :mod:`!concurrent.interpreters` module constructs higher-level "
"interfaces on top of the lower level :mod:`!_interpreters` module."
msgstr ""
":mod:`!concurrent.interpreters` 模块在低层级的 :mod:`!_interpreters` "
"模块之上构造了更高层级的接口。"

#: ../../library/concurrent.interpreters.rst:19
msgid ""
"The module is primarily meant to provide a basic API for managing "
"interpreters (AKA \"subinterpreters\") and running things in them. Running "
"mostly involves switching to an interpreter (in the current thread) and "
"calling a function in that execution context."
msgstr ""
"本模块的最初目标是提供一个基本 API 来管理解释器（也称“子解释器”）并在其中运行任务。 "
"运行过程涉及（在当前线程中）切换解释器并在执行上下文中调用函数。"

#: ../../library/concurrent.interpreters.rst:24
msgid ""
"For concurrency, interpreters themselves (and this module) don't provide "
"much more than isolation, which on its own isn't useful. Actual concurrency "
"is available separately through :mod:`threads <threading>`  See `below "
"<interp-concurrency_>`_"
msgstr ""
"对于并发操作，解释器本身（以及本模块）并未提供状态隔离以外的更多手段，对其自身而言用处不大。 实际的并发是通过 :mod:`线程 "
"<threading>` 单独提供的。 参见 `below <interp-concurrency_>`_"

#: ../../library/concurrent.interpreters.rst:31
msgid ":class:`~concurrent.futures.InterpreterPoolExecutor`"
msgstr ":class:`~concurrent.futures.InterpreterPoolExecutor`"

#: ../../library/concurrent.interpreters.rst:32
msgid "combines threads with interpreters in a familiar interface."
msgstr "通过熟悉的接口实现线程与解释器的结合。"

#: ../../library/concurrent.interpreters.rst:36
msgid ":ref:`isolating-extensions-howto`"
msgstr ":ref:`isolating-extensions-howto`"

#: ../../library/concurrent.interpreters.rst:37
msgid "how to update an extension module to support multiple interpreters"
msgstr "如何将扩展模块更新为支持多解释器"

#: ../../library/concurrent.interpreters.rst:39
msgid ":pep:`554`"
msgstr ":pep:`554`"

#: ../../library/concurrent.interpreters.rst:41
msgid ":pep:`734`"
msgstr ":pep:`734`"

#: ../../library/concurrent.interpreters.rst:43
msgid ":pep:`684`"
msgstr ":pep:`684`"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/concurrent.interpreters.rst:51
msgid "Key details"
msgstr "关键细节"

#: ../../library/concurrent.interpreters.rst:53
msgid ""
"Before we dive in further, there are a small number of details to keep in "
"mind about using multiple interpreters:"
msgstr "在进一步深入之前，关于多解释器的使用需要注意以下几个要点："

#: ../../library/concurrent.interpreters.rst:56
msgid "`isolated <interp-isolation_>`_, by default"
msgstr "默认情况下为 `解释器隔离 <interp-isolation_>`_"

#: ../../library/concurrent.interpreters.rst:57
msgid "no implicit threads"
msgstr "没有隐式线程"

#: ../../library/concurrent.interpreters.rst:58
msgid "not all PyPI packages support use in multiple interpreters yet"
msgstr "并不是所有的PyPI包都支持在多个解释器中使用"

#: ../../library/concurrent.interpreters.rst:66
msgid "Introduction"
msgstr "概述"

#: ../../library/concurrent.interpreters.rst:68
msgid ""
"An \"interpreter\" is effectively the execution context of the Python "
"runtime.  It contains all of the state the runtime needs to execute a "
"program.  This includes things like the import state and builtins. (Each "
"thread, even if there's only the main thread, has some extra runtime state, "
"in addition to the current interpreter, related to the current exception and"
" the bytecode eval loop.)"
msgstr ""
"\"解释器\"本质上是 Python "
"运行时的执行上下文，它包含了运行时执行程序所需的所有状态，包括导入状态和内置对象等。（每个线程——即使只有主线程——除了当前解释器外，还拥有一些额外的运行时状态，这些状态与当前异常和字节码求值循环相关。）"

#: ../../library/concurrent.interpreters.rst:75
msgid ""
"The concept and functionality of the interpreter have been a part of Python "
"since version 2.2, but the feature was only available through the C-API and "
"not well known, and the `isolation <interp-isolation_>`_ was relatively "
"incomplete until version 3.12."
msgstr ""
"解释器的概念和功能自 Python 2.2 版本起便已存在，但该特性此前仅能通过 C-API 使用且鲜为人知，同时 `隔离 <interp-"
"isolation_>`_ 功能在 3.12 版本前相对不够完善。"

#: ../../library/concurrent.interpreters.rst:83
msgid "Multiple Interpreters and Isolation"
msgstr "多解释器与隔离"

#: ../../library/concurrent.interpreters.rst:85
msgid ""
"A Python implementation may support using multiple interpreters in the same "
"process.  CPython has this support.  Each interpreter is effectively "
"isolated from the others (with a limited number of carefully managed "
"process-global exceptions to the rule)."
msgstr ""
"Python 实现方案可能支持在同一进程中使用多个解释器，CPython "
"就具备此功能。每个解释器实际上都是相互隔离的（仅有少量经过严格管控的进程级全局例外情况）。"

#: ../../library/concurrent.interpreters.rst:90
msgid ""
"That isolation is primarily useful as a strong separation between distinct "
"logical components of a program, where you want to have careful control of "
"how those components interact."
msgstr "这种隔离机制的主要价值在于为程序的不同逻辑组件提供严格隔离，使开发者能够精准控制这些组件之间的交互方式。"

#: ../../library/concurrent.interpreters.rst:96
msgid ""
"Interpreters in the same process can technically never be strictly isolated "
"from one another since there are few restrictions on memory access within "
"the same process.  The Python runtime makes a best effort at isolation but "
"extension modules may easily violate that. Therefore, do not use multiple "
"interpreters in security-sensitive situations, where they shouldn't have "
"access to each other's data."
msgstr ""
"从技术上讲，同一进程中的解释器永远无法实现严格隔离，因为在同一进程内对内存访问几乎没有任何限制。Python "
"运行时会尽力确保隔离性，但扩展模块很容易破坏这种隔离。因此，在安全敏感场景下——当不同解释器之间本不应相互访问数据时——请勿使用多解释器模式。"

#: ../../library/concurrent.interpreters.rst:104
msgid "Running in an Interpreter"
msgstr "在一个解释器中运行"

#: ../../library/concurrent.interpreters.rst:106
msgid ""
"Running in a different interpreter involves switching to it in the current "
"thread and then calling some function.  The runtime will execute the "
"function using the current interpreter's state.  The "
":mod:`!concurrent.interpreters` module provides a basic API for creating and"
" managing interpreters, as well as the switch-and-call operation."
msgstr ""
"在另一个解释器中运行涉及两个步骤：首先在当前线程切换至目标解释器，然后调用目标函数。运行时将基于当前解释器的状态执行该函数。:mod:`!concurrent.interpreters`"
" 模块提供了一套基础API，用于创建和管理解释器，以及执行这种\"切换-调用\"操作。"

#: ../../library/concurrent.interpreters.rst:113
msgid ""
"No other threads are automatically started for the operation. There is `a "
"helper <interp-call-in-thread_>`_ for that though. There is another "
"dedicated helper for calling the builtin :func:`exec` in an interpreter."
msgstr ""
"该操作不会自动启动其他线程，但可通过 `一个辅助工具 <interp-call-in-thread_>`_ "
"实现此功能。此外还提供了专用辅助工具，用于在解释器中调用内置函数 :func:`exec`。"

#: ../../library/concurrent.interpreters.rst:118
msgid ""
"When :func:`exec` (or :func:`eval`) are called in an interpreter, they run "
"using the interpreter's :mod:`!__main__` module as the \"globals\" "
"namespace.  The same is true for functions that aren't associated with any "
"module.  This is the same as how scripts invoked from the command-line run "
"in the :mod:`!__main__` module."
msgstr ""
"当在解释器中调用 :func:`exec` (或 :func:`eval`) 时，它们会使用该解释器的 :mod:`!__main__` "
"模块作为\"全局\"命名空间来运行。对于未关联任何模块的函数也是如此。这与从命令行调用脚本时在 :mod:`!__main__` 模块中运行的方式相同。"

#: ../../library/concurrent.interpreters.rst:128
msgid "Concurrency and Parallelism"
msgstr "并发与并行"

#: ../../library/concurrent.interpreters.rst:130
msgid ""
"As noted earlier, interpreters do not provide any concurrency on their own."
"  They strictly represent the isolated execution context the runtime will "
"use *in the current thread*.  That isolation makes them similar to "
"processes, but they still enjoy in-process efficiency, like threads."
msgstr ""
"如前所述，解释器本身并不提供任何并发能力。它们严格代表了运行时 *在当前线程* "
"中将使用的隔离执行上下文。这种隔离特性使解释器与进程相似，但同时又能像线程一样享受进程内的高效性。"

#: ../../library/concurrent.interpreters.rst:136
msgid ""
"All that said, interpreters do naturally support certain flavors of "
"concurrency. There's a powerful side effect of that isolation.  It enables a"
" different approach to concurrency than you can take with async or threads."
"  It's a similar concurrency model to CSP or the actor model, a model which "
"is relatively easy to reason about."
msgstr ""
"综上所述，解释器确实天然支持某些形式的并发。这种隔离性带来了一个重要的特性：它支持一种不同于异步编程或线程模型的并发实现方式，其并发模型与CSP（通信顺序进程）或Actor模型相似——而这类模型通常更易于推理分析。"

#: ../../library/concurrent.interpreters.rst:143
msgid ""
"You can take advantage of that concurrency model in a single thread, "
"switching back and forth between interpreters, Stackless-style. However, "
"this model is more useful when you combine interpreters with multiple "
"threads.  This mostly involves starting a new thread, where you switch to "
"another interpreter and run what you want there."
msgstr ""
"开发者可以在单线程中利用这种并发模型，以无栈式风格在解释器之间来回切换。然而，当将多解释器与多线程结合使用时，该模型才更能体现其价值。这种结合主要涉及：启动新线程"
" → 切换至目标解释器 → 执行所需操作。"

#: ../../library/concurrent.interpreters.rst:149
msgid ""
"Each actual thread in Python, even if you're only running in the main "
"thread, has its own *current* execution context.  Multiple threads can use "
"the same interpreter or different ones."
msgstr ""
"在Python中，每个实际线程（即使仅运行主线程）都拥有自己的 *当前* 执行上下文。多个线程可以共享同一个解释器，也可以使用不同的解释器。"

#: ../../library/concurrent.interpreters.rst:153
msgid ""
"At a high level, you can think of the combination of threads and "
"interpreters as threads with opt-in sharing."
msgstr "从高层次来看，可以将线程与解释器的组合理解为可选共享的线程模型。"

#: ../../library/concurrent.interpreters.rst:156
msgid ""
"As a significant bonus, interpreters are sufficiently isolated that they do "
"not share the :term:`GIL`, which means combining threads with multiple "
"interpreters enables full multi-core parallelism. (This has been the case "
"since Python 3.12.)"
msgstr ""
"一个重要优势是：解释器之间的隔离足够彻底，它们不共享 "
":term:`GIL`，这意味着将多线程与多解释器结合使用时，可以实现真正的多核并行处理。（该特性自 Python 3.12 起支持。）"

#: ../../library/concurrent.interpreters.rst:162
msgid "Communication Between Interpreters"
msgstr "解释器间通信"

#: ../../library/concurrent.interpreters.rst:164
msgid ""
"In practice, multiple interpreters are useful only if we have a way to "
"communicate between them.  This usually involves some form of message "
"passing, but can even mean sharing data in some carefully managed way."
msgstr "在实际应用中，多解释器模式的价值取决于是否存在有效的通信机制。通常采用消息传递方式实现交互，但在严格管控条件下也可共享数据。"

#: ../../library/concurrent.interpreters.rst:169
msgid ""
"With this in mind, the :mod:`!concurrent.interpreters` module provides a "
":class:`queue.Queue` implementation, available through :func:`create_queue`."
msgstr ""
"基于此，:mod:`!concurrent.interpreters` 模块提供了通过 :func:`create_queue` 访问的 "
":class:`queue.Queue` 实现。"

#: ../../library/concurrent.interpreters.rst:176
msgid "\"Sharing\" Objects"
msgstr "\"共享\"对象"

#: ../../library/concurrent.interpreters.rst:178
msgid ""
"Any data actually shared between interpreters loses the thread-safety "
"provided by the :term:`GIL`.  There are various options for dealing with "
"this in extension modules.  However, from Python code the lack of thread-"
"safety means objects can't actually be shared, with a few exceptions.  "
"Instead, a copy must be created, which means mutable objects won't stay in "
"sync."
msgstr ""
"在解释器间实际共享的任何数据都会丧失由 :term:`GIL` "
"提供的线程安全性。扩展模块可通过多种方案处理此问题，但在纯Python代码中，由于缺乏线程安全机制，对象实际上无法真正共享（仅有少数例外）。这种情况下必须创建对象副本，意味着可变对象无法保持同步状态。"

#: ../../library/concurrent.interpreters.rst:185
msgid ""
"By default, most objects are copied with :mod:`pickle` when they are passed "
"to another interpreter.  Nearly all of the immutable builtin objects are "
"either directly shared or copied efficiently.  For example:"
msgstr ""
"默认情况下，当对象传递给其他解释器时，多数对象会通过 :mod:`pickle` "
"模块进行复制。几乎所有不可变内置对象要么直接共享，要么会高效复制。例如："

#: ../../library/concurrent.interpreters.rst:189
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/concurrent.interpreters.rst:190
msgid ":class:`bool` (:const:`True` and :const:`False`)"
msgstr ":class:`bool` (:const:`True`  和 :const:`False`)"

#: ../../library/concurrent.interpreters.rst:191
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/concurrent.interpreters.rst:192
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/concurrent.interpreters.rst:193
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/concurrent.interpreters.rst:194
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/concurrent.interpreters.rst:195
msgid ":class:`tuple` (of similarly supported objects)"
msgstr ":class:`tuple` (仅限包含同类可支持对象时)"

#: ../../library/concurrent.interpreters.rst:197
msgid ""
"There is a small number of Python types that actually share mutable data "
"between interpreters:"
msgstr "仅有少数Python类型能够真正在解释器间共享可变数据："

#: ../../library/concurrent.interpreters.rst:200
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../library/concurrent.interpreters.rst:201
msgid ":class:`Queue`"
msgstr ":class:`Queue`"

#: ../../library/concurrent.interpreters.rst:205
msgid "Reference"
msgstr "参考"

#: ../../library/concurrent.interpreters.rst:207
msgid "This module defines the following functions:"
msgstr "这个模块定义了以下函数："

#: ../../library/concurrent.interpreters.rst:211
msgid ""
"Return a :class:`list` of :class:`Interpreter` objects, one for each "
"existing interpreter."
msgstr "返回一个 :class:`Interpreter` 对象的 :class:`list`，每个对象对应一个现有的解释器。"

#: ../../library/concurrent.interpreters.rst:216
msgid ""
"Return an :class:`Interpreter` object for the currently running interpreter."
msgstr "为当前运行的解释器返回一个 :class:`Interpreter` 对象。"

#: ../../library/concurrent.interpreters.rst:221
msgid ""
"Return an :class:`Interpreter` object for the main interpreter. This is the "
"interpreter the runtime created to run the :term:`REPL` or the script given "
"at the command-line.  It is usually the only one."
msgstr ""
"返回主解释器的 :class:`Interpreter` 对象。该解释器是运行时为执行 :term:`REPL` "
"或命令行脚本而创建的，通常也是唯一存在的解释器实例。"

#: ../../library/concurrent.interpreters.rst:227
msgid ""
"Initialize a new (idle) Python interpreter and return a :class:`Interpreter`"
" object for it."
msgstr "初始化一个新的（空闲的）Python解释器并为其返回一个 :class:`Interpreter` 对象。"

#: ../../library/concurrent.interpreters.rst:232
msgid ""
"Initialize a new cross-interpreter queue and return a :class:`Queue` object "
"for it."
msgstr "初始化一个新的跨解释器队列，并返回其对应的 :class:`Queue` 对象。"

#: ../../library/concurrent.interpreters.rst:237
msgid "Interpreter objects"
msgstr "解释器对象"

#: ../../library/concurrent.interpreters.rst:241
msgid "A single interpreter in the current process."
msgstr "当前进程中的单个解释器。"

#: ../../library/concurrent.interpreters.rst:243
msgid ""
"Generally, :class:`Interpreter` shouldn't be called directly. Instead, use "
":func:`create` or one of the other module functions."
msgstr "一般来说，不应该直接调用 :class:`Interpreter`。 相反，使用 :func:`create` 或其他模块函数之一。"

#: ../../library/concurrent.interpreters.rst:248
#: ../../library/concurrent.interpreters.rst:254
#: ../../library/concurrent.interpreters.rst:333
msgid "(read-only)"
msgstr "（只读）"

#: ../../library/concurrent.interpreters.rst:250
msgid "The underlying interpreter's ID."
msgstr "底层解释器的 ID。"

#: ../../library/concurrent.interpreters.rst:256
msgid "A string describing where the interpreter came from."
msgstr "描述解释器来源的字符串。"

#: ../../library/concurrent.interpreters.rst:260
msgid ""
"Return ``True`` if the interpreter is currently executing code in its "
":mod:`!__main__` module and ``False`` otherwise."
msgstr "如果解释器当前正在执行其:mod:`!__main__`模块中的代码，则返回``True``，否则返回``False``。"

#: ../../library/concurrent.interpreters.rst:265
msgid "Finalize and destroy the interpreter."
msgstr "完成和销毁解释器。"

#: ../../library/concurrent.interpreters.rst:269
msgid "Bind objects in the interpreter's :mod:`!__main__` module."
msgstr "将对象绑定到解释器的 :mod:`!__main__` 模块中。"

#: ../../library/concurrent.interpreters.rst:271
#: ../../library/concurrent.interpreters.rst:328
msgid ""
"Some objects are actually shared and some are copied efficiently, but most "
"are copied via :mod:`pickle`.  See :ref:`interp-object-sharing`."
msgstr ""
"部分对象会实际共享，部分对象可高效复制，但大多数对象仍需通过 :mod:`pickle` 模块进行复制。具体参见 :ref:`interp-"
"object-sharing` 。"

#: ../../library/concurrent.interpreters.rst:276
msgid "Run the given source code in the interpreter (in the current thread)."
msgstr "在解释器中运行给定的源代码（在当前线程中）。"

#: ../../library/concurrent.interpreters.rst:280
msgid ""
"Return the result of calling running the given function in the interpreter "
"(in the current thread)."
msgstr "返回在解释器中（在当前线程中）调用运行给定函数的结果。"

#: ../../library/concurrent.interpreters.rst:287
msgid "Run the given function in the interpreter (in a new thread)."
msgstr "在解释器中运行给定的函数（在一个新的线程中）。"

#: ../../library/concurrent.interpreters.rst:290
msgid "Exceptions"
msgstr "异常"

#: ../../library/concurrent.interpreters.rst:294
msgid ""
"This exception, a subclass of :exc:`Exception`, is raised when an "
"interpreter-related error happens."
msgstr "此异常是 :exc:`Exception` 的子类，在发生解释器相关错误时引发。"

#: ../../library/concurrent.interpreters.rst:299
msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"targeted interpreter no longer exists."
msgstr "此异常是 :exc:`InterpreterError` 的子类，当目标解释器不再存在时引发。"

#: ../../library/concurrent.interpreters.rst:304
msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"running code raised an uncaught exception."
msgstr "此异常是 :exc:`InterpreterError` 的子类，当运行的代码引发未捕获的异常时引发。"

#: ../../library/concurrent.interpreters.rst:309
msgid "A basic snapshot of the exception raised in the other interpreter."
msgstr "在其他解释器中引发的异常的基本快照。"

#: ../../library/concurrent.interpreters.rst:315
msgid ""
"This exception, a subclass of :exc:`TypeError`, is raised when an object "
"cannot be sent to another interpreter."
msgstr "此异常是 :exc:`TypeError` 的子类，当一个对象无法发送到另一个解释器时引发。"

#: ../../library/concurrent.interpreters.rst:320
msgid "Communicating Between Interpreters"
msgstr "解释器间通信"

#: ../../library/concurrent.interpreters.rst:324
msgid ""
"A wrapper around a low-level, cross-interpreter queue, which implements the "
":class:`queue.Queue` interface.  The underlying queue can only be created "
"through :func:`create_queue`."
msgstr ""
"这是一个对底层跨解释器队列的封装，实现了标准的 :class:`queue.Queue` 接口。底层队列只能通过 "
":func:`create_queue` 函数创建。"

#: ../../library/concurrent.interpreters.rst:335
msgid "The queue's ID."
msgstr "队列的ID。"

#: ../../library/concurrent.interpreters.rst:340
msgid ""
"This exception, a subclass of :exc:`queue.Empty`, is raised from "
":meth:`!Queue.get` and :meth:`!Queue.get_nowait` when the queue is empty."
msgstr ""
"此异常继承自 :exc:`queue.Empty`，当队列为空时，会由 :meth:`!Queue.get` 和 "
":meth:`!Queue.get_nowait` 方法引发。"

#: ../../library/concurrent.interpreters.rst:346
msgid ""
"This exception, a subclass of :exc:`queue.Full`, is raised from "
":meth:`!Queue.put` and :meth:`!Queue.put_nowait` when the queue is full."
msgstr ""
"此异常继承自 :exc:`queue.Full`，当队列已满时，会由 :meth:`!Queue.put` 和 "
":meth:`!Queue.put_nowait` 方法引发。"

#: ../../library/concurrent.interpreters.rst:352
msgid "Basic usage"
msgstr "基本使用"

#: ../../library/concurrent.interpreters.rst:354
msgid "Creating an interpreter and running code in it::"
msgstr "创建一个解释器并在其中运行代码：："

#: ../../library/concurrent.interpreters.rst:356
msgid ""
"from concurrent import interpreters\n"
"\n"
"interp = interpreters.create()\n"
"\n"
"# Run in the current OS thread.\n"
"\n"
"interp.exec('print(\"spam!\")')\n"
"\n"
"interp.exec(\"\"\"if True:\n"
"    print('spam!')\n"
"    \"\"\")\n"
"\n"
"from textwrap import dedent\n"
"interp.exec(dedent(\"\"\"\n"
"    print('spam!')\n"
"    \"\"\"))\n"
"\n"
"def run(arg):\n"
"    return arg\n"
"\n"
"res = interp.call(run, 'spam!')\n"
"print(res)\n"
"\n"
"def run():\n"
"    print('spam!')\n"
"\n"
"interp.call(run)\n"
"\n"
"# Run in new OS thread.\n"
"\n"
"t = interp.call_in_thread(run)\n"
"t.join()"
msgstr ""
"from concurrent import interpreters\n"
"\n"
"interp = interpreters.create()\n"
"\n"
"# 在当前操作系统线程中运行。\n"
"\n"
"interp.exec('print(\"spam!\")')\n"
"\n"
"interp.exec(\"\"\"if True:\n"
"    print('spam!')\n"
"    \"\"\")\n"
"\n"
"from textwrap import dedent\n"
"interp.exec(dedent(\"\"\"\n"
"    print('spam!')\n"
"    \"\"\"))\n"
"\n"
"def run(arg):\n"
"    return arg\n"
"\n"
"res = interp.call(run, 'spam!')\n"
"print(res)\n"
"\n"
"def run():\n"
"    print('spam!')\n"
"\n"
"interp.call(run)\n"
"\n"
"# 在新的操作系统线程中运行\n"
"\n"
"t = interp.call_in_thread(run)\n"
"t.join()"
