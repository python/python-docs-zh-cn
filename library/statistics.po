# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/statistics.rst:2
msgid ":mod:`!statistics` --- Mathematical statistics functions"
msgstr ":mod:`!statistics` --- 数字统计函数"

#: ../../library/statistics.rst:12
msgid "**Source code:** :source:`Lib/statistics.py`"
msgstr "**源代码:** :source:`Lib/statistics.py`"

#: ../../library/statistics.rst:22
msgid ""
"This module provides functions for calculating mathematical statistics of "
"numeric (:class:`~numbers.Real`-valued) data."
msgstr "该模块提供了用于计算数字 (:class:`~numbers.Real`-valued) 数据的数理统计量的函数。"

#: ../../library/statistics.rst:25
msgid ""
"The module is not intended to be a competitor to third-party libraries such "
"as `NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, or "
"proprietary full-featured statistics packages aimed at professional "
"statisticians such as Minitab, SAS and Matlab. It is aimed at the level of "
"graphing and scientific calculators."
msgstr ""
"此模块并不是诸如 `NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_ "
"等第三方库或者诸如 Minitab, SAS 和 Matlab 等针对专业统计学家的专有全功能统计软件包的竞品。 此模块针对图形和科学计算器的水平。"

#: ../../library/statistics.rst:31
msgid ""
"Unless explicitly noted, these functions support :class:`int`, "
":class:`float`, :class:`~decimal.Decimal` and :class:`~fractions.Fraction`. "
"Behaviour with other types (whether in the numeric tower or not) is "
"currently unsupported.  Collections with a mix of types are also undefined "
"and implementation-dependent.  If your input data consists of mixed types, "
"you may be able to use :func:`map` to ensure a consistent result, for "
"example: ``map(float, input_data)``."
msgstr ""
"除非明确注释，这些函数支持 :class:`int` ， :class:`float` ， :class:`~decimal.Decimal` 和 "
":class:`~fractions.Fraction` "
"。当前不支持同其他类型（是否在数字塔中）的行为。混合类型的集合也是未定义的，并且依赖于实现。如果你输入的数据由混合类型组成，你应该能够使用 "
":func:`map` 来确保一个一致的结果，比如： ``map(float, input_data)`` 。"

#: ../../library/statistics.rst:39
msgid ""
"Some datasets use ``NaN`` (not a number) values to represent missing data. "
"Since NaNs have unusual comparison semantics, they cause surprising or "
"undefined behaviors in the statistics functions that sort data or that count"
" occurrences.  The functions affected are ``median()``, ``median_low()``, "
"``median_high()``, ``median_grouped()``, ``mode()``, ``multimode()``, and "
"``quantiles()``.  The ``NaN`` values should be stripped before calling these"
" functions::"
msgstr ""
"某些数据集合类型使用 ``NaN`` (not a number) 值来代表缺失的数据。 由于 NaN "
"具有特殊的比较语义，它们会在数据排序或计数等统计函数中产生怪异或未定义的行为。 受影响的函数有 ``median()``, "
"``median_low()``, ``median_high()``, ``median_grouped()``, ``mode()``, "
"``multimode()`` 和 ``quantiles()``。 ``NaN`` 值应当在调用这些函数之前被去除::"

#: ../../library/statistics.rst:47
msgid ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"
msgstr ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # 这将有令人惊讶的行为\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # 这个结果不符合预期\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # 缺失值的数量\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # 去除 NaN 值\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # 现在排序将符合预期\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # 现在这个结果有良好定义的\n"
"18.75"

#: ../../library/statistics.rst:69
msgid "Averages and measures of central location"
msgstr "平均值以及对中心位置的评估"

#: ../../library/statistics.rst:71
msgid ""
"These functions calculate an average or typical value from a population or "
"sample."
msgstr "这些函数用于计算一个总体或样本的平均值或者典型值。"

#: ../../library/statistics.rst:75
msgid ":func:`mean`"
msgstr ":func:`mean`"

#: ../../library/statistics.rst:75
msgid "Arithmetic mean (\"average\") of data."
msgstr "数据的算术平均数（“平均数”）。"

#: ../../library/statistics.rst:76
msgid ":func:`fmean`"
msgstr ":func:`fmean`"

#: ../../library/statistics.rst:76
msgid "Fast, floating-point arithmetic mean, with optional weighting."
msgstr "快速的浮点算术平均值，带有可选的权重设置。"

#: ../../library/statistics.rst:77
msgid ":func:`geometric_mean`"
msgstr ":func:`geometric_mean`"

#: ../../library/statistics.rst:77
msgid "Geometric mean of data."
msgstr "数据的几何平均数"

#: ../../library/statistics.rst:78
msgid ":func:`harmonic_mean`"
msgstr ":func:`harmonic_mean`"

#: ../../library/statistics.rst:78
msgid "Harmonic mean of data."
msgstr "数据的调和均值"

#: ../../library/statistics.rst:79
msgid ":func:`median`"
msgstr ":func:`median`"

#: ../../library/statistics.rst:79
msgid "Median (middle value) of data."
msgstr "数据的中位数（中间值）"

#: ../../library/statistics.rst:80
msgid ":func:`median_low`"
msgstr ":func:`median_low`"

#: ../../library/statistics.rst:80
msgid "Low median of data."
msgstr "数据的低中位数"

#: ../../library/statistics.rst:81
msgid ":func:`median_high`"
msgstr ":func:`median_high`"

#: ../../library/statistics.rst:81
msgid "High median of data."
msgstr "数据的高中位数"

#: ../../library/statistics.rst:82
msgid ":func:`median_grouped`"
msgstr ":func:`median_grouped`"

#: ../../library/statistics.rst:82
msgid "Median (50th percentile) of grouped data."
msgstr "分组数据的中位数（即第 50 个百分点的位置）。"

#: ../../library/statistics.rst:83
msgid ":func:`mode`"
msgstr ":func:`mode`"

#: ../../library/statistics.rst:83
msgid "Single mode (most common value) of discrete or nominal data."
msgstr "离散的或标称的数据的单个众数（出现最多的值）。"

#: ../../library/statistics.rst:84
msgid ":func:`multimode`"
msgstr ":func:`multimode`"

#: ../../library/statistics.rst:84
msgid "List of modes (most common values) of discrete or nominal data."
msgstr "离散的或标称的数据的众数（出现最多的值）列表。"

#: ../../library/statistics.rst:85
msgid ":func:`quantiles`"
msgstr ":func:`quantiles`"

#: ../../library/statistics.rst:85
msgid "Divide data into intervals with equal probability."
msgstr "将数据以相等的概率分为多个间隔。"

#: ../../library/statistics.rst:89
msgid "Measures of spread"
msgstr "对分散程度的评估"

#: ../../library/statistics.rst:91
msgid ""
"These functions calculate a measure of how much the population or sample "
"tends to deviate from the typical or average values."
msgstr "这些函数用于计算总体或样本与典型值或平均值的偏离程度。"

#: ../../library/statistics.rst:95
msgid ":func:`pstdev`"
msgstr ":func:`pstdev`"

#: ../../library/statistics.rst:95
msgid "Population standard deviation of data."
msgstr "数据的总体标准差"

#: ../../library/statistics.rst:96
msgid ":func:`pvariance`"
msgstr ":func:`pvariance`"

#: ../../library/statistics.rst:96
msgid "Population variance of data."
msgstr "数据的总体方差"

#: ../../library/statistics.rst:97
msgid ":func:`stdev`"
msgstr ":func:`stdev`"

#: ../../library/statistics.rst:97
msgid "Sample standard deviation of data."
msgstr "数据的样本标准差"

#: ../../library/statistics.rst:98
msgid ":func:`variance`"
msgstr ":func:`variance`"

#: ../../library/statistics.rst:98
msgid "Sample variance of data."
msgstr "数据的样本方差"

#: ../../library/statistics.rst:102
msgid "Statistics for relations between two inputs"
msgstr "对两个输入之间关系的统计"

#: ../../library/statistics.rst:104
msgid ""
"These functions calculate statistics regarding relations between two inputs."
msgstr "这些函数计算两个输入之间关系的统计值。"

#: ../../library/statistics.rst:107
msgid ":func:`covariance`"
msgstr ":func:`covariance`"

#: ../../library/statistics.rst:107
msgid "Sample covariance for two variables."
msgstr "两个变量的样本协方差。"

#: ../../library/statistics.rst:108
msgid ":func:`correlation`"
msgstr ":func:`correlation`"

#: ../../library/statistics.rst:108
msgid "Pearson and Spearman's correlation coefficients."
msgstr "皮尔逊和斯皮尔曼相关系数。"

#: ../../library/statistics.rst:109
msgid ":func:`linear_regression`"
msgstr ":func:`linear_regression`"

#: ../../library/statistics.rst:109
msgid "Slope and intercept for simple linear regression."
msgstr "简单线性回归的斜率和截距。"

#: ../../library/statistics.rst:114
msgid "Function details"
msgstr "函数细节"

#: ../../library/statistics.rst:116
msgid ""
"Note: The functions do not require the data given to them to be sorted. "
"However, for reading convenience, most of the examples show sorted "
"sequences."
msgstr "注释：这些函数不需要对提供给它们的数据进行排序。但是，为了方便阅读，大多数例子展示的是已排序的序列。"

#: ../../library/statistics.rst:121
msgid ""
"Return the sample arithmetic mean of *data* which can be a sequence or "
"iterable."
msgstr "返回 *data* 的样本算术平均数，形式为序列或迭代器。"

#: ../../library/statistics.rst:123
msgid ""
"The arithmetic mean is the sum of the data divided by the number of data "
"points.  It is commonly called \"the average\", although it is only one of "
"many different mathematical averages.  It is a measure of the central "
"location of the data."
msgstr "算术平均数是数据之和与数据点个数的商。通常称作“平均数”，尽管它指示诸多数学平均数之一。它是数据的中心位置的度量。"

#: ../../library/statistics.rst:128
msgid "If *data* is empty, :exc:`StatisticsError` will be raised."
msgstr "若 *data* 为空，将会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:130
msgid "Some examples of use:"
msgstr "一些用法示例："

#: ../../library/statistics.rst:132
msgid ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"
msgstr ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"

#: ../../library/statistics.rst:149
msgid ""
"The mean is strongly affected by `outliers "
"<https://en.wikipedia.org/wiki/Outlier>`_ and is not necessarily a typical "
"example of the data points. For a more robust, although less efficient, "
"measure of `central tendency "
"<https://en.wikipedia.org/wiki/Central_tendency>`_, see :func:`median`."
msgstr ""
"平均数会受到 `异常值 <https://en.wikipedia.org/wiki/Outlier>`_ 的强烈影响因而不一定能作为数据点的典型样本。"
" 想获得对于 `集中趋势 <https://en.wikipedia.org/wiki/Central_tendency>`_ 的更可靠的度量，可以参看"
" :func:`median`，但其效率要低一些。"

#: ../../library/statistics.rst:155
msgid ""
"The sample mean gives an unbiased estimate of the true population mean, so "
"that when taken on average over all the possible samples, ``mean(sample)`` "
"converges on the true mean of the entire population.  If *data* represents "
"the entire population rather than a sample, then ``mean(data)`` is "
"equivalent to calculating the true population mean μ."
msgstr ""
"样本均值给出了一个无偏向的真实总体均值的估计，因此当平均抽取所有可能的样本， ``mean(sample)`` 收敛于整个总体的真实均值。如果 "
"*data* 代表整个总体而不是样本，那么 ``mean(data)`` 等同于计算真实整体均值 μ 。"

#: ../../library/statistics.rst:164
msgid "Convert *data* to floats and compute the arithmetic mean."
msgstr "将 *data* 转换成浮点数并且计算算术平均数。"

#: ../../library/statistics.rst:166
msgid ""
"This runs faster than the :func:`mean` function and it always returns a "
":class:`float`.  The *data* may be a sequence or iterable.  If the input "
"dataset is empty, raises a :exc:`StatisticsError`."
msgstr ""
"此函数的运行速度比 :func:`mean` 函数快并且它总是返回一个 :class:`float`。 *data* 可以为序列或可迭代对象。 "
"如果输入数据集为空，则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:170
msgid ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"
msgstr ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"

#: ../../library/statistics.rst:175
msgid ""
"Optional weighting is supported.  For example, a professor assigns a grade "
"for a course by weighting quizzes at 20%, homework at 20%, a midterm exam at"
" 30%, and a final exam at 30%:"
msgstr "支持可选的权重参数。 例如，某位教授在为课程打分时可设置权重为测验 20%, 作业 20%, 期中考试 30%, 期末考试 30%:"

#: ../../library/statistics.rst:179
msgid ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"
msgstr ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"

#: ../../library/statistics.rst:186
msgid ""
"If *weights* is supplied, it must be the same length as the *data* or a "
":exc:`ValueError` will be raised."
msgstr "如果提供了 *weights*，它必须与 *data* 的长度相同否则将引发 :exc:`ValueError`。"

#: ../../library/statistics.rst:191 ../../library/statistics.rst:259
msgid "Added support for *weights*."
msgstr "添加了对 *weights* 的支持。"

#: ../../library/statistics.rst:197
msgid "Convert *data* to floats and compute the geometric mean."
msgstr "将 *data* 转换成浮点数并且计算几何平均数。"

#: ../../library/statistics.rst:199
msgid ""
"The geometric mean indicates the central tendency or typical value of the "
"*data* using the product of the values (as opposed to the arithmetic mean "
"which uses their sum)."
msgstr "几何平均值使用值的乘积表示 *数据* 的中心趋势或典型值（与使用它们的总和的算术平均值相反）。"

#: ../../library/statistics.rst:203
msgid ""
"Raises a :exc:`StatisticsError` if the input dataset is empty, if it "
"contains a zero, or if it contains a negative value. The *data* may be a "
"sequence or iterable."
msgstr "如果输入数据集为空、包含零或包含负值则将引发 :exc:`StatisticsError`。 *data* 可以是序列或可迭代对象。"

#: ../../library/statistics.rst:207
msgid ""
"No special efforts are made to achieve exact results. (However, this may "
"change in the future.)"
msgstr "无需做出特殊努力即可获得准确的结果。（但是，将来或许会修改。）"

#: ../../library/statistics.rst:210
msgid ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"
msgstr ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"

#: ../../library/statistics.rst:220
msgid ""
"Return the harmonic mean of *data*, a sequence or iterable of real-valued "
"numbers.  If *weights* is omitted or ``None``, then equal weighting is "
"assumed."
msgstr "返回包含实数的序列或可迭代对象 *data* 的调和平均值。 如果 *weights* 被省略或为 ``None``，则会假定为相等权重。"

#: ../../library/statistics.rst:224
msgid ""
"The harmonic mean is the reciprocal of the arithmetic :func:`mean` of the "
"reciprocals of the data. For example, the harmonic mean of three values *a*,"
" *b* and *c* will be equivalent to ``3/(1/a + 1/b + 1/c)``.  If one of the "
"values is zero, the result will be zero."
msgstr ""
"调和平均数是数据的倒数的算术平均值 :func:`mean` 的倒数。 例如，三个数值 *a*, *b* 和 *c* 的调和平均数将等于 "
"``3/(1/a + 1/b + 1/c)``。 如果其中一个值为零，则结果也将为零。"

#: ../../library/statistics.rst:229
msgid ""
"The harmonic mean is a type of average, a measure of the central location of"
" the data.  It is often appropriate when averaging ratios or rates, for "
"example speeds."
msgstr "调和平均数是均值的一种，是对数据的中心位置的度量。 它通常适用于求比率和比例（如速度）的均值。"

#: ../../library/statistics.rst:233
msgid ""
"Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. "
"What is the average speed?"
msgstr ""
"假设一辆车在 40 km/hr 的速度下行驶了 10 km ，然后又以 60 km/hr 的速度行驶了 10 km 。车辆的平均速率是多少？"

#: ../../library/statistics.rst:236
msgid ""
">>> harmonic_mean([40, 60])\n"
"48.0"
msgstr ""
">>> harmonic_mean([40, 60])\n"
"48.0"

#: ../../library/statistics.rst:241
msgid ""
"Suppose a car travels 40 km/hr for 5 km, and when traffic clears, speeds-up "
"to 60 km/hr for the remaining 30 km of the journey. What is the average "
"speed?"
msgstr ""
"假设一辆汽车以速度 40 公里/小时行驶了 5 公里，当道路变得畅通后，提速到 60 公里/小时行驶了行程中剩余的 30 km。 请问其平均速度是多少？"

#: ../../library/statistics.rst:245
msgid ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"
msgstr ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"

#: ../../library/statistics.rst:250
msgid ""
":exc:`StatisticsError` is raised if *data* is empty, any element is less "
"than zero, or if the weighted sum isn't positive."
msgstr "如果 *data* 为空、任意元素小于零，或者加权汇总值不为正数则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:253
msgid ""
"The current algorithm has an early-out when it encounters a zero in the "
"input.  This means that the subsequent inputs are not tested for validity.  "
"(This behavior may change in the future.)"
msgstr "当前算法在输入中遇到零时会提前退出。这意味着不会测试后续输入的有效性。（此行为将来可能会更改。）"

#: ../../library/statistics.rst:264
msgid ""
"Return the median (middle value) of numeric data, using the common \"mean of"
" middle two\" method.  If *data* is empty, :exc:`StatisticsError` is raised."
" *data* can be a sequence or iterable."
msgstr ""
"使用普通的“取中间两数平均值”方法返回数值数据的中位数（中间值）。 如果 *data* 为空，则将引发 :exc:`StatisticsError`。 "
"*data* 可以是序列或可迭代对象。"

#: ../../library/statistics.rst:268
msgid ""
"The median is a robust measure of central location and is less affected by "
"the presence of outliers.  When the number of data points is odd, the middle"
" data point is returned:"
msgstr "中位数是衡量中间位置的可靠方式，并且较少受到极端值的影响。 当数据点的总数为奇数时，将返回中间数据点："

#: ../../library/statistics.rst:272
msgid ""
">>> median([1, 3, 5])\n"
"3"
msgstr ""
">>> median([1, 3, 5])\n"
"3"

#: ../../library/statistics.rst:277
msgid ""
"When the number of data points is even, the median is interpolated by taking"
" the average of the two middle values:"
msgstr "当数据点的总数为偶数时，中位数将通过对两个中间值求平均进行插值得出："

#: ../../library/statistics.rst:280
msgid ""
">>> median([1, 3, 5, 7])\n"
"4.0"
msgstr ""
">>> median([1, 3, 5, 7])\n"
"4.0"

#: ../../library/statistics.rst:285
msgid ""
"This is suited for when your data is discrete, and you don't mind that the "
"median may not be an actual data point."
msgstr "这适用于当你的数据是离散的，并且你不介意中位数不是实际数据点的情况。"

#: ../../library/statistics.rst:288
msgid ""
"If the data is ordinal (supports order operations) but not numeric (doesn't "
"support addition), consider using :func:`median_low` or :func:`median_high` "
"instead."
msgstr ""
"如果数据是有序的（支持排序操作）但不是数字（不支持加法），请考虑改用 :func:`median_low` 或 :func:`median_high`。"

#: ../../library/statistics.rst:294
msgid ""
"Return the low median of numeric data.  If *data* is empty, "
":exc:`StatisticsError` is raised.  *data* can be a sequence or iterable."
msgstr ""
"返回数值数据的低中位数。 如果 *data* 为空则将引发 :exc:`StatisticsError`。 *data* 可以是序列或可迭代对象。"

#: ../../library/statistics.rst:297
msgid ""
"The low median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the smaller "
"of the two middle values is returned."
msgstr "低中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较小的那个。"

#: ../../library/statistics.rst:301
msgid ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"
msgstr ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"

#: ../../library/statistics.rst:308
msgid ""
"Use the low median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr "当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用低中位数。"

#: ../../library/statistics.rst:314
msgid ""
"Return the high median of data.  If *data* is empty, :exc:`StatisticsError` "
"is raised.  *data* can be a sequence or iterable."
msgstr ""
"返回数据的高中位数。 如果 *data* 为空则将引发 :exc:`StatisticsError`。 *data* 可以是序列或可迭代对象。"

#: ../../library/statistics.rst:317
msgid ""
"The high median is always a member of the data set.  When the number of data"
" points is odd, the middle value is returned.  When it is even, the larger "
"of the two middle values is returned."
msgstr "高中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较大的那个。"

#: ../../library/statistics.rst:321
msgid ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"
msgstr ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"

#: ../../library/statistics.rst:328
msgid ""
"Use the high median when your data are discrete and you prefer the median to"
" be an actual data point rather than interpolated."
msgstr "当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用高中位数。"

#: ../../library/statistics.rst:334
msgid ""
"Estimates the median for numeric data that has been `grouped or binned "
"<https://en.wikipedia.org/wiki/Data_binning>`_ around the midpoints of "
"consecutive, fixed-width intervals."
msgstr ""
"针对围绕连续的、固定宽度区间的中点进行了 `分组或分档 <https://en.wikipedia.org/wiki/Data_binning>`_ "
"的数值数据估算中位数。"

#: ../../library/statistics.rst:338
msgid ""
"The *data* can be any iterable of numeric data with each value being exactly"
" the midpoint of a bin.  At least one value must be present."
msgstr "*data* 可以是任意数值数据的可迭代对象，其中每个值都恰好为分档的中点。 至少必须有一个值。"

#: ../../library/statistics.rst:341
msgid "The *interval* is the width of each bin."
msgstr "*interval* 是每个分档的宽度。"

#: ../../library/statistics.rst:343
msgid ""
"For example, demographic information may have been summarized into "
"consecutive ten-year age groups with each group being represented by the "
"5-year midpoints of the intervals:"
msgstr "例如，人口信息可能被归纳为按 10 年划分的连续年龄分组，每个分组由各区间的 5 年中点来表示："

#: ../../library/statistics.rst:347
msgid ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 to 30 years old\n"
"...    35: 484,   # 30 to 40 years old\n"
"...    45: 387,   # 40 to 50 years old\n"
"...    55:  22,   # 50 to 60 years old\n"
"...    65:   6,   # 60 to 70 years old\n"
"... })\n"
"..."
msgstr ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 至 30 岁\n"
"...    35: 484,   # 30 至 40 岁\n"
"...    45: 387,   # 40 至 50 岁\n"
"...    55:  22,   # 50 至 60 岁\n"
"...    65:   6,   # 60 至 70 岁\n"
"... })\n"
"..."

#: ../../library/statistics.rst:359
msgid ""
"The 50th percentile (median) is the 536th person out of the 1071 member "
"cohort.  That person is in the 30 to 40 year old age group."
msgstr "第 50 个百分点位置（中位数）就是 1071 名成员中的第 536 人。 此人属于 30 至 40 岁年龄分组。"

#: ../../library/statistics.rst:362
msgid ""
"The regular :func:`median` function would assume that everyone in the "
"tricenarian age group was exactly 35 years old.  A more tenable assumption "
"is that the 484 members of that age group are evenly distributed between 30 "
"and 40.  For that, we use :func:`median_grouped`:"
msgstr ""
"常规的 :func:`median` 函数会假定三十至四十岁年龄组中的每个人都正好是 35 岁。 一个更站得住脚的假设则是该年龄组的 484 "
"名成员均匀分布在 30 岁到 40 岁之间。 为此，我们会使用 :func:`median_grouped`:"

#: ../../library/statistics.rst:368
msgid ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"
msgstr ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"

#: ../../library/statistics.rst:376
msgid ""
"The caller is responsible for making sure the data points are separated by "
"exact multiples of *interval*.  This is essential for getting a correct "
"result.  The function does not check this precondition."
msgstr "调用者有责任确保数据点之间以 *interval* 的精确倍数分隔。 这对于获得正确结果至关重要。 该函数不会检查这一前提条件。"

#: ../../library/statistics.rst:380
msgid ""
"Inputs may be any numeric type that can be coerced to a float during the "
"interpolation step."
msgstr "输入可以是任何可在插值步骤中强制转换为浮点数的数值类型。"

#: ../../library/statistics.rst:386
msgid ""
"Return the single most common data point from discrete or nominal *data*. "
"The mode (when it exists) is the most typical value and serves as a measure "
"of central location."
msgstr "从离散或标称的 *data* 返回单个出现最多的数据点。 此众数（如果存在）是最典型的值，并可用来度量中心的位置。"

#: ../../library/statistics.rst:390
msgid ""
"If there are multiple modes with the same frequency, returns the first one "
"encountered in the *data*.  If the smallest or largest of those is desired "
"instead, use ``min(multimode(data))`` or ``max(multimode(data))``. If the "
"input *data* is empty, :exc:`StatisticsError` is raised."
msgstr ""
"如果存在具有相同频率的多个众数，则返回在 *data* 中遇到的第一个。 如果想要其中最小或最大的一个，请使用 "
"``min(multimode(data))`` 或 ``max(multimode(data))``。 如果输入的 *data* 为空，则会引发 "
":exc:`StatisticsError`。"

#: ../../library/statistics.rst:395
msgid ""
"``mode`` assumes discrete data and returns a single value. This is the "
"standard treatment of the mode as commonly taught in schools:"
msgstr "``mode`` 将假定是离散数据并返回一个单一的值。 这是通常的学校教学中标准的处理方式："

#: ../../library/statistics.rst:398
msgid ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"
msgstr ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"

#: ../../library/statistics.rst:403
msgid ""
"The mode is unique in that it is the only statistic in this package that "
"also applies to nominal (non-numeric) data:"
msgstr "此众数的独特之处在于它是这个包中唯一还可应用于标称（非数字）数据的统计信息："

#: ../../library/statistics.rst:406
msgid ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"])\n"
"'red'"
msgstr ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"])\n"
"'red'"

#: ../../library/statistics.rst:411
msgid ""
"Only hashable inputs are supported.  To handle type :class:`set`, consider "
"casting to :class:`frozenset`.  To handle type :class:`list`, consider "
"casting to :class:`tuple`.  For mixed or nested inputs, consider using this "
"slower quadratic algorithm that only depends on equality tests: ``max(data, "
"key=data.count)``."
msgstr ""
"仅支持输入可哈希对象。 要处理 :class:`set` 类型，可将其转换为 :class:`frozenset`。 要处理 :class:`list`"
" 类型，可将其转换为 :class:`tuple`。 对于混合的或嵌套的输入，可使用这个仅依赖于相等性检测的速度较慢的二次方复杂度算法: "
"``max(data, key=data.count)``。"

#: ../../library/statistics.rst:417
msgid ""
"Now handles multimodal datasets by returning the first mode encountered. "
"Formerly, it raised :exc:`StatisticsError` when more than one mode was "
"found."
msgstr "现在会通过返回所遇到的第一个众数来处理多模数据集。 之前它会在遇到超过一个的众数时引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:425
msgid ""
"Return a list of the most frequently occurring values in the order they were"
" first encountered in the *data*.  Will return more than one result if there"
" are multiple modes or an empty list if the *data* is empty:"
msgstr ""
"返回最频繁出现的值的列表，并按它们在 *data* 中首次出现的位置排序。 如果存在多个众数则将返回一个以上的众数，或者如果 *data* "
"为空则将返回空列表："

#: ../../library/statistics.rst:429
msgid ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"
msgstr ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"

#: ../../library/statistics.rst:441
msgid ""
"Return the population standard deviation (the square root of the population "
"variance).  See :func:`pvariance` for arguments and other details."
msgstr "返回总体标准差（总体方差的平方根）。 请参阅 :func:`pvariance` 了解参数和其他细节。"

#: ../../library/statistics.rst:444
msgid ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"
msgstr ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"

#: ../../library/statistics.rst:452
msgid ""
"Return the population variance of *data*, a non-empty sequence or iterable "
"of real-valued numbers.  Variance, or second moment about the mean, is a "
"measure of the variability (spread or dispersion) of data.  A large variance"
" indicates that the data is spread out; a small variance indicates it is "
"clustered closely around the mean."
msgstr ""
"返回非空序列或包含实数值的可迭代对象 *data* 的总体方差。 方差或称相对于均值的二阶距，是对数据变化幅度（延展度或分散度）的度量。 "
"方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。"

#: ../../library/statistics.rst:458
msgid ""
"If the optional second argument *mu* is given, it should be the *population*"
" mean of the *data*.  It can also be used to compute the second moment "
"around a point that is not the mean.  If it is missing or ``None`` (the "
"default), the arithmetic mean is automatically calculated."
msgstr ""
"如果给出了可选的第二个参数 *mu*，它应为 *data* 的 *众数* 均值。 它也可以被用来计算一个非均值点的二阶距。 如果该参数被省略或为 "
"``None`` (默认值)，则会自动进行算术均值计算。"

#: ../../library/statistics.rst:463
msgid ""
"Use this function to calculate the variance from the entire population.  To "
"estimate the variance from a sample, the :func:`variance` function is "
"usually a better choice."
msgstr "使用此函数可根据所有数值来计算方差。 要根据一个样本来估算方差，通常 :func:`variance` 函数是更好的选择。"

#: ../../library/statistics.rst:467
msgid "Raises :exc:`StatisticsError` if *data* is empty."
msgstr "如果 *data* 为空则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:469 ../../library/statistics.rst:539
#: ../../library/statistics.rst:643
msgid "Examples:"
msgstr "示例："

#: ../../library/statistics.rst:471
msgid ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"
msgstr ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"

#: ../../library/statistics.rst:477
msgid ""
"If you have already calculated the mean of your data, you can pass it as the"
" optional second argument *mu* to avoid recalculation:"
msgstr "如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 *mu* 传入以避免重复计算："

#: ../../library/statistics.rst:480
msgid ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"
msgstr ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"

#: ../../library/statistics.rst:486
msgid "Decimals and Fractions are supported:"
msgstr "同样也支持使用 Decimal 和 Fraction 值："

#: ../../library/statistics.rst:488
msgid ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"

#: ../../library/statistics.rst:500
msgid ""
"When called with the entire population, this gives the population variance "
"σ².  When called on a sample instead, this is the biased sample variance s²,"
" also known as variance with N degrees of freedom."
msgstr ""
"当调用时附带完整的总体数据时，这将给出总体方差 σ²。 而当调用时只附带一个样本时，这将给出偏置样本方差 s²，也被称为带有 N 个自由度的方差。"

#: ../../library/statistics.rst:504
msgid ""
"If you somehow know the true population mean μ, you may use this function to"
" calculate the variance of a sample, giving the known population mean as the"
" second argument.  Provided the data points are a random sample of the "
"population, the result will be an unbiased estimate of the population "
"variance."
msgstr ""
"如果你通过某种方式知道了真实的总体平均值 μ，则可以使用此函数来计算一个样本的方差，并将已知的总体平均值作为第二个参数。 "
"假设数据点是总体的一个随机样本，则结果将为总体方差的无偏估计值。"

#: ../../library/statistics.rst:513
msgid ""
"Return the sample standard deviation (the square root of the sample "
"variance).  See :func:`variance` for arguments and other details."
msgstr "返回样本标准差（样本方差的平方根）。 请参阅 :func:`variance` 了解参数和其他细节。"

#: ../../library/statistics.rst:516
msgid ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"
msgstr ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"

#: ../../library/statistics.rst:524
msgid ""
"Return the sample variance of *data*, an iterable of at least two real-"
"valued numbers.  Variance, or second moment about the mean, is a measure of "
"the variability (spread or dispersion) of data.  A large variance indicates "
"that the data is spread out; a small variance indicates it is clustered "
"closely around the mean."
msgstr ""
"返回包含至少两个实数值的可迭代对象 *data* 的样本方差。 方差或称相对于均值的二阶矩，是对数据变化幅度（延展度或分散度）的度量。 "
"方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。"

#: ../../library/statistics.rst:530
msgid ""
"If the optional second argument *xbar* is given, it should be the *sample* "
"mean of *data*.  If it is missing or ``None`` (the default), the mean is "
"automatically calculated."
msgstr ""
"如果给出了可选的第二个参数 *xbar*，它应为 *data* 的 *样本* 均值。 如果该参数省略或为 ``None`` "
"(默认值)，则会自动进行均值计算。"

#: ../../library/statistics.rst:534
msgid ""
"Use this function when your data is a sample from a population. To calculate"
" the variance from the entire population, see :func:`pvariance`."
msgstr "当你的数据是总体数据的样本时请使用此函数。 要根据整个总体数据来计算方差，请参见 :func:`pvariance`。"

#: ../../library/statistics.rst:537
msgid "Raises :exc:`StatisticsError` if *data* has fewer than two values."
msgstr "如果 *data* 包含的值少于两个则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:541
msgid ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"
msgstr ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"

#: ../../library/statistics.rst:547
msgid ""
"If you have already calculated the sample mean of your data, you can pass it"
" as the optional second argument *xbar* to avoid recalculation:"
msgstr "如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 *xbar* 传入以避免重复计算："

#: ../../library/statistics.rst:550
msgid ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"
msgstr ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"

#: ../../library/statistics.rst:556
msgid ""
"This function does not attempt to verify that you have passed the actual "
"mean as *xbar*.  Using arbitrary values for *xbar* can lead to invalid or "
"impossible results."
msgstr "此函数不会试图检查你所传入的 *xbar* 是否为真实的平均值。 使用任意值作为 *xbar* 可能导致无效或不可能的结果。"

#: ../../library/statistics.rst:560
msgid "Decimal and Fraction values are supported:"
msgstr "同样也支持使用 Decimal 和 Fraction 值："

#: ../../library/statistics.rst:562
msgid ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"

#: ../../library/statistics.rst:574
msgid ""
"This is the sample variance s² with Bessel's correction, also known as "
"variance with N-1 degrees of freedom.  Provided that the data points are "
"representative (e.g. independent and identically distributed), the result "
"should be an unbiased estimate of the true population variance."
msgstr ""
"这是附带贝塞尔校正的样本方差 s²，也称为具有 N-1 自由度的方差。 假设数据点具有代表性（即为独立且均匀的分布），则结果应当是对总体方差的无偏估计。"

#: ../../library/statistics.rst:579
msgid ""
"If you somehow know the actual population mean μ you should pass it to the "
":func:`pvariance` function as the *mu* parameter to get the variance of a "
"sample."
msgstr ""
"如果你通过某种方式知道了真实的总体平均值 μ 则应当调用 :func:`pvariance` 函数并将该值作为 *mu* 形参传入以得到一个样本的方差。"

#: ../../library/statistics.rst:585
msgid ""
"Divide *data* into *n* continuous intervals with equal probability. Returns "
"a list of ``n - 1`` cut points separating the intervals."
msgstr "将 *data* 分隔为具有相等概率的 *n* 个连续区间。 返回分隔这些区间的 ``n - 1`` 个分隔点的列表。"

#: ../../library/statistics.rst:588
msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.  Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate "
"*data* into 100 equal sized groups.  Raises :exc:`StatisticsError` if *n* is"
" not least 1."
msgstr ""
"将 *n* 设为 4 以使用四分位（默认值）。 将 *n* 设为 10 以使用十分位。 将 *n* 设为 100 以使用百分位，即给出 99 "
"个分隔点来将 *data* 分隔为 100 个大小相等的组。 如果 *n* 小于 1 则将引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:593
msgid ""
"The *data* can be any iterable containing sample data.  For meaningful "
"results, the number of data points in *data* should be larger than *n*. "
"Raises :exc:`StatisticsError` if there are not at least two data points."
msgstr ""
"*data* 可以是包含样本数据的任意可迭代对象。 为了获得有意义的结果，*data* 中数据点的数量应当大于 *n*。 "
"如果数据点的数量小于两个则将引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:597
msgid ""
"The cut points are linearly interpolated from the two nearest data points.  "
"For example, if a cut point falls one-third of the distance between two "
"sample values, ``100`` and ``112``, the cut-point will evaluate to ``104``."
msgstr ""
"分隔点是通过对两个最接近的数据点进行线性插值得到的。 例如，如果一个分隔点落在两个样本值 ``100`` 和 ``112`` "
"之间距离三分之一的位置，则分隔点的取值将为 ``104``。"

#: ../../library/statistics.rst:602
msgid ""
"The *method* for computing quantiles can be varied depending on whether the "
"*data* includes or excludes the lowest and highest possible values from the "
"population."
msgstr "*method* 用于计算分位值，它会由于 *data* 是包含还是排除总体的最低和最高可能值而有所不同。"

#: ../../library/statistics.rst:606
msgid ""
"The default *method* is \"exclusive\" and is used for data sampled from a "
"population that can have more extreme values than found in the samples.  The"
" portion of the population falling below the *i-th* of *m* sorted data "
"points is computed as ``i / (m + 1)``.  Given nine sample values, the method"
" sorts them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, "
"60%, 70%, 80%, 90%."
msgstr ""
"默认 *method* 是 “唯一的” 并且被用于在总体中数据采样这样可以有比样本中找到的更多的极端值。落在 *m* 个排序数据点的第 *i-th* "
"个以下的总体部分被计算为 ``i / (m + 1)`` 。给定九个样本值，方法排序它们并且分配一下的百分位： 10%, 20%, 30%, 40%, "
"50%, 60%, 70%, 80%, 90% 。"

#: ../../library/statistics.rst:613
msgid ""
"Setting the *method* to \"inclusive\" is used for describing population data"
" or for samples that are known to include the most extreme values from the "
"population.  The minimum value in *data* is treated as the 0th percentile "
"and the maximum value is treated as the 100th percentile. The portion of the"
" population falling below the *i-th* of *m* sorted data points is computed "
"as ``(i - 1) / (m - 1)``.  Given 11 sample values, the method sorts them and"
" assigns the following percentiles: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, "
"80%, 90%, 100%."
msgstr ""
"将 *method* 设为 \"inclusive\" 可用于描述总体数据或已明确知道包含有总体数据中最极端值的样本。 *data* "
"中的最小值会被作为第 0 个百分位而最大值会被作为第 100 个百分位。 总体数据里处于 *m* 个已排序数据点中 *第 i 个* 以下的部分会以 "
"``(i - 1) / (m - 1)`` 来计算。 给定 11 个样本值，该方法会对它们进行排序并赋予以下百分位: 0%, 10%, 20%, "
"30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%。"

#: ../../library/statistics.rst:622
msgid ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"
msgstr ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"

#: ../../library/statistics.rst:637
msgid ""
"Return the sample covariance of two inputs *x* and *y*. Covariance is a "
"measure of the joint variability of two inputs."
msgstr "返回两个输入 *x* 和 *y* 的样本协方差。 样本协方差是对两个输入的同步变化性的度量。"

#: ../../library/statistics.rst:640
msgid ""
"Both inputs must be of the same length (no less than two), otherwise "
":exc:`StatisticsError` is raised."
msgstr "两个输入必须具有相同的长度（不少于两个元素），否则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:645
msgid ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"
msgstr ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"

#: ../../library/statistics.rst:661
msgid ""
"Return the `Pearson's correlation coefficient "
"<https://en.wikipedia.org/wiki/Pearson_correlation_coefficient>`_ for two "
"inputs. Pearson's correlation coefficient *r* takes values between -1 and "
"+1. It measures the strength and direction of a linear relationship."
msgstr ""
"返回两个输入的 `皮尔逊相关系数 "
"<https://en.wikipedia.org/wiki/Pearson_correlation_coefficient>`_。 皮尔逊相关系数 "
"*r* 的取值在 -1 到 +1 之间。 它衡量线性相关的强度和方向。"

#: ../../library/statistics.rst:667
msgid ""
"If *method* is \"ranked\", computes `Spearman's rank correlation coefficient"
" <https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_"
" for two inputs. The data is replaced by ranks.  Ties are averaged so that "
"equal values receive the same rank.  The resulting coefficient measures the "
"strength of a monotonic relationship."
msgstr ""
"如果 *method* 为 \"ranked\"，则计算两个输入的 `斯皮尔曼等级相关系数 "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_。"
" 数据将被替换为等级。 同级的值将被平均因此相同的值将得到相同的等级。 结果系数衡量的是单调关系的强度。"

#: ../../library/statistics.rst:673
msgid ""
"Spearman's correlation coefficient is appropriate for ordinal data or for "
"continuous data that doesn't meet the linear proportion requirement for "
"Pearson's correlation coefficient."
msgstr "斯皮尔曼相关系数适用于有序数据或不满足皮尔逊相关系数的线性比例要求的连续数据。"

#: ../../library/statistics.rst:677
msgid ""
"Both inputs must be of the same length (no less than two), and need not to "
"be constant, otherwise :exc:`StatisticsError` is raised."
msgstr "两个输入必须具有相同的长度（不少于两个元素），并且不必为常量，否则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:680
msgid ""
"Example with `Kepler's laws of planetary motion "
"<https://en.wikipedia.org/wiki/Kepler's_laws_of_planetary_motion>`_:"
msgstr ""
"使用 `开普勒行星运动定律 "
"<https://en.wikipedia.org/wiki/Kepler's_laws_of_planetary_motion>`_ 的示例:"

#: ../../library/statistics.rst:683
msgid ""
">>> # Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and  Neptune\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # days\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # million km\n"
"\n"
">>> # Show that a perfect monotonic relationship exists\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observe that a linear relationship is imperfect\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrate Kepler's third law: There is a linear correlation\n"
">>> # between the square of the orbital period and the cube of the\n"
">>> # distance from the sun.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"
msgstr ""
">>> # 水星、金星、地球、火星、木星、土星、天王星和海王星\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # 天\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # 百万公里\n"
"\n"
">>> # 显示存在完美的单调关系\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # 表明存在不完美的线性关系\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # 体现开普勒第三定律：自转周期的\n"
">>> # 平方和与太阳距离的立方之间存在\n"
">>> # 线性对应关系\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"

#: ../../library/statistics.rst:707
msgid "Added support for Spearman's rank correlation coefficient."
msgstr "增加了对斯皮尔曼等级相关系数的支持。"

#: ../../library/statistics.rst:712
msgid ""
"Return the slope and intercept of `simple linear regression "
"<https://en.wikipedia.org/wiki/Simple_linear_regression>`_ parameters "
"estimated using ordinary least squares. Simple linear regression describes "
"the relationship between an independent variable *x* and a dependent "
"variable *y* in terms of this linear function:"
msgstr ""
"返回使用普通最小二乘法估计得到的 `简单线性回归 "
"<https://en.wikipedia.org/wiki/Simple_linear_regression>`_ 参数的斜率和截距。 "
"简单纯属回归通过此线性函数来描述自变量 *x* 和因变量 *y* 之间的关系。"

#: ../../library/statistics.rst:718
msgid "*y = slope \\* x + intercept + noise*"
msgstr "*y = slope \\* x + intercept + noise*"

#: ../../library/statistics.rst:720
msgid ""
"where ``slope`` and ``intercept`` are the regression parameters that are "
"estimated, and ``noise`` represents the variability of the data that was not"
" explained by the linear regression (it is equal to the difference between "
"predicted and actual values of the dependent variable)."
msgstr ""
"其中 ``slope`` 和 ``intercept`` 是估计得到的回归参数，而 ``noise`` "
"代表不可由线性回归解释的数据变异性（它等于因变量的预测值和实际值之间的差异）。"

#: ../../library/statistics.rst:726
msgid ""
"Both inputs must be of the same length (no less than two), and the "
"independent variable *x* cannot be constant; otherwise a "
":exc:`StatisticsError` is raised."
msgstr "两个输入必须具有相同的长度（不少于两个元素），并且自变量 *x* 不可为常量；否则会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:730
msgid ""
"For example, we can use the `release dates of the Monty Python films "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ to predict the "
"cumulative number of Monty Python films that would have been produced by "
"2019 assuming that they had kept the pace."
msgstr ""
"例如，我们可以使用 `Monty Python 系列电影的发布日期 "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ 在假定出品方保持现有步调的情况下预测到 "
"2019 年时产出的 Monty Python 电影的累计数量。"

#: ../../library/statistics.rst:736
msgid ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"
msgstr ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"

#: ../../library/statistics.rst:744
msgid ""
"If *proportional* is true, the independent variable *x* and the dependent "
"variable *y* are assumed to be directly proportional. The data is fit to a "
"line passing through the origin. Since the *intercept* will always be 0.0, "
"the underlying linear function simplifies to:"
msgstr ""
"如果 *proportional* 为真值，则自变量 *x* 和因变量 *y* 将被视为成正比关系。 数据会被拟合到一条通过原点的直线上。 由于 "
"*intercept* 将始终为 0.0，因此下层的线性函数会简化为:"

#: ../../library/statistics.rst:750
msgid "*y = slope \\* x + noise*"
msgstr "*y = slope \\* x + noise*"

#: ../../library/statistics.rst:752
msgid ""
"Continuing the example from :func:`correlation`, we look to see how well a "
"model based on major planets can predict the orbital distances for dwarf "
"planets:"
msgstr "继续 :func:`correlation` 的例子，我们来看看基于大行星的模型是否能很好地预测矮行星的轨道距离："

#: ../../library/statistics.rst:756
msgid ""
">>> model = linear_regression(period_squared, dist_cubed, proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Dwarf planets:   Pluto,  Eris,    Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # actual distance in million km\n"
"[5906, 10152, 6796, 6450, 414]"
msgstr ""
">>> model = linear_regression(period_squared, dist_cubed, proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # 矮行星：冥王星、阋神星、鸟神星、妊神星、谷神星\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # 以百万公里表示的实际距离\n"
"[5906, 10152, 6796, 6450, 414]"

#: ../../library/statistics.rst:772
msgid "Added support for *proportional*."
msgstr "添加了对 *proportional* 的支持。"

#: ../../library/statistics.rst:776
msgid "Exceptions"
msgstr "异常"

#: ../../library/statistics.rst:778
msgid "A single exception is defined:"
msgstr "只定义了一个异常："

#: ../../library/statistics.rst:782
msgid "Subclass of :exc:`ValueError` for statistics-related exceptions."
msgstr ":exc:`ValueError` 的子类，表示统计相关的异常。"

#: ../../library/statistics.rst:786
msgid ":class:`NormalDist` objects"
msgstr ":class:`NormalDist` 对象"

#: ../../library/statistics.rst:788
msgid ""
":class:`NormalDist` is a tool for creating and manipulating normal "
"distributions of a `random variable "
"<http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm>`_.  It is a class "
"that treats the mean and standard deviation of data measurements as a single"
" entity."
msgstr ""
":class:`NormalDist` 工具可用于创建和操纵 `随机变量 "
"<http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm>`_ 的正态分布。 "
"这个类将数据度量值的平均值和标准差作为单一实体来处理。"

#: ../../library/statistics.rst:794
msgid ""
"Normal distributions arise from the `Central Limit Theorem "
"<https://en.wikipedia.org/wiki/Central_limit_theorem>`_ and have a wide "
"range of applications in statistics."
msgstr ""
"正态分布的概念来自于 `中央极限定理 <https://en.wikipedia.org/wiki/Central_limit_theorem>`_ "
"并且在统计学中有广泛的应用。"

#: ../../library/statistics.rst:800
msgid ""
"Returns a new *NormalDist* object where *mu* represents the `arithmetic mean"
" <https://en.wikipedia.org/wiki/Arithmetic_mean>`_ and *sigma* represents "
"the `standard deviation "
"<https://en.wikipedia.org/wiki/Standard_deviation>`_."
msgstr ""
"返回一个新的 *NormalDist* 对象，其中 *mu* 代表 `算术平均值 "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ 而 *sigma* 代表 `标准差 "
"<https://en.wikipedia.org/wiki/Standard_deviation>`_。"

#: ../../library/statistics.rst:805
msgid "If *sigma* is negative, raises :exc:`StatisticsError`."
msgstr "若 *sigma* 为负数，将会引发 :exc:`StatisticsError`。"

#: ../../library/statistics.rst:809
msgid ""
"A read-only property for the `arithmetic mean "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ of a normal distribution."
msgstr ""
"一个只读特征属性，表示特定正态分布的 `算术平均值 <https://en.wikipedia.org/wiki/Arithmetic_mean>`_。"

#: ../../library/statistics.rst:815
msgid ""
"A read-only property for the `median "
"<https://en.wikipedia.org/wiki/Median>`_ of a normal distribution."
msgstr "一个只读特征属性，表示特定正态分布的 `中位数 <https://en.wikipedia.org/wiki/Median>`_。"

#: ../../library/statistics.rst:821
msgid ""
"A read-only property for the `mode "
"<https://en.wikipedia.org/wiki/Mode_(statistics)>`_ of a normal "
"distribution."
msgstr ""
"一个只读特征属性，表示特定正态分布的 `众数 <https://en.wikipedia.org/wiki/Mode_(statistics)>`_。"

#: ../../library/statistics.rst:827
msgid ""
"A read-only property for the `standard deviation "
"<https://en.wikipedia.org/wiki/Standard_deviation>`_ of a normal "
"distribution."
msgstr ""
"一个只读特征属性，表示特定正态分布的 `标准差 "
"<https://en.wikipedia.org/wiki/Standard_deviation>`_。"

#: ../../library/statistics.rst:833
msgid ""
"A read-only property for the `variance "
"<https://en.wikipedia.org/wiki/Variance>`_ of a normal distribution. Equal "
"to the square of the standard deviation."
msgstr ""
"一个只读特征属性，表示特定正态分布的 `方差 <https://en.wikipedia.org/wiki/Variance>`_。 等于标准差的平方。"

#: ../../library/statistics.rst:839
msgid ""
"Makes a normal distribution instance with *mu* and *sigma* parameters "
"estimated from the *data* using :func:`fmean` and :func:`stdev`."
msgstr ""
"传入使用 :func:`fmean` 和 :func:`stdev` 基于 *data* 估算出的 *mu* 和 *sigma* "
"形参创建一个正态分布实例。"

#: ../../library/statistics.rst:842
msgid ""
"The *data* can be any :term:`iterable` and should consist of values that can"
" be converted to type :class:`float`.  If *data* does not contain at least "
"two elements, raises :exc:`StatisticsError` because it takes at least one "
"point to estimate a central value and at least two points to estimate "
"dispersion."
msgstr ""
"*data* 可以是任何 :term:`iterable` 并且应当包含能被转换为 :class:`float` 类型的值。 如果 *data* "
"不包含至少两个元素，则会引发 :exc:`StatisticsError`，因为估算中心值至少需要一个点而估算分散度至少需要两个点。"

#: ../../library/statistics.rst:850
msgid ""
"Generates *n* random samples for a given mean and standard deviation. "
"Returns a :class:`list` of :class:`float` values."
msgstr "对于给定的平均值和标准差生成 *n* 个随机样本。 返回一个由 :class:`float` 值组成的 :class:`list`。"

#: ../../library/statistics.rst:853
msgid ""
"If *seed* is given, creates a new instance of the underlying random number "
"generator.  This is useful for creating reproducible results, even in a "
"multi-threading context."
msgstr "当给定 *seed* 时，创建一个新的底层随机数生成器实例。 这适用于创建可重现的结果，即使对于多线程上下文也有效。"

#: ../../library/statistics.rst:859
msgid ""
"Using a `probability density function (pdf) "
"<https://en.wikipedia.org/wiki/Probability_density_function>`_, compute the "
"relative likelihood that a random variable *X* will be near the given value "
"*x*.  Mathematically, it is the limit of the ratio ``P(x <= X < x+dx) / dx``"
" as *dx* approaches zero."
msgstr ""
"使用 `概率密度函数 (pdf) "
"<https://en.wikipedia.org/wiki/Probability_density_function>`_，计算一个随机变量 *X* "
"趋向于给定值 *x* 的相对可能性。 在数学意义上，它是当 *dx* 趋向于零时比率 ``P(x <= X < x+dx) / dx`` 的极限。"

#: ../../library/statistics.rst:865
msgid ""
"The relative likelihood is computed as the probability of a sample occurring"
" in a narrow range divided by the width of the range (hence the word "
"\"density\").  Since the likelihood is relative to other points, its value "
"can be greater than ``1.0``."
msgstr ""
"相对可能性的计算方法是用一个狭窄区间内某个样本出现的概率除以区间的宽度（因此使用 \"density\" 一词）。 "
"由于可能性是相对于其他点的，因此它的值可以大于 ``1.0``。"

#: ../../library/statistics.rst:872
msgid ""
"Using a `cumulative distribution function (cdf) "
"<https://en.wikipedia.org/wiki/Cumulative_distribution_function>`_, compute "
"the probability that a random variable *X* will be less than or equal to "
"*x*.  Mathematically, it is written ``P(X <= x)``."
msgstr ""
"使用 `累积分布函数 (cdf) "
"<https://en.wikipedia.org/wiki/Cumulative_distribution_function>`_，计算一个随机变量 "
"*X* 小于等于 *x* 的概率。 在数学上，它表示为 ``P(X <= x)``。"

#: ../../library/statistics.rst:879
msgid ""
"Compute the inverse cumulative distribution function, also known as the "
"`quantile function <https://en.wikipedia.org/wiki/Quantile_function>`_ or "
"the `percent-point "
"<https://web.archive.org/web/20190203145224/https://www.statisticshowto.datasciencecentral.com/inverse-"
"distribution-function/>`_ function.  Mathematically, it is written ``x : P(X"
" <= x) = p``."
msgstr ""
"计算反射累积分布函数，也称为 `分位数函数 <https://en.wikipedia.org/wiki/Quantile_function>`_ 或 "
"`百分点 "
"<https://web.archive.org/web/20190203145224/https://www.statisticshowto.datasciencecentral.com/inverse-"
"distribution-function/>`_ 函数。 在数学上，它表示为 ``x : P(X <= x) = p``。"

#: ../../library/statistics.rst:885
msgid ""
"Finds the value *x* of the random variable *X* such that the probability of "
"the variable being less than or equal to that value equals the given "
"probability *p*."
msgstr "找出随机变量 *X* 的值 *x* 使得该变量小于等于该值的概率等于给定的概率 *p*。"

#: ../../library/statistics.rst:891
msgid ""
"Measures the agreement between two normal probability distributions. Returns"
" a value between 0.0 and 1.0 giving `the overlapping area for the two "
"probability density functions <https://www.rasch.org/rmt/rmt101r.htm>`_."
msgstr ""
"测量两个正态概率分布之间的一致性。 返回介于 0.0 和 1.0 之间的值，给出 `两个概率密度函数的重叠区域 "
"<https://www.rasch.org/rmt/rmt101r.htm>`_。"

#: ../../library/statistics.rst:898
msgid ""
"Divide the normal distribution into *n* continuous intervals with equal "
"probability.  Returns a list of (n - 1) cut points separating the intervals."
msgstr "将指定正态分布划分为 *n* 个相等概率的连续分隔区。 返回这些分隔区对应的 (n - 1) 个分隔点的列表。"

#: ../../library/statistics.rst:902
msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles. Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate the "
"normal distribution into 100 equal sized groups."
msgstr ""
"将 *n* 设为 4 以使用四分位（默认值）。 将 *n* 设为 10 以使用十分位。将 *n* 设为 100 以使用百分位，即给出 99 "
"个分隔点来将正态分布分隔为 100 个大小相等的组。"

#: ../../library/statistics.rst:908
msgid ""
"Compute the `Standard Score <https://www.statisticshowto.com/probability-"
"and-statistics/z-score/>`_ describing *x* in terms of the number of standard"
" deviations above or below the mean of the normal distribution: ``(x - mean)"
" / stdev``."
msgstr ""
"计算 `标准分 <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ 即以高于或低于正态分布的平均值的标准差数值的形式来描述 *x*: ``(x - mean) / "
"stdev``."

#: ../../library/statistics.rst:916
msgid ""
"Instances of :class:`NormalDist` support addition, subtraction, "
"multiplication and division by a constant.  These operations are used for "
"translation and scaling.  For example:"
msgstr ":class:`NormalDist` 的实例支持加上、减去、乘以或除以一个常量。 这些运算被用于转换和缩放。 例如："

#: ../../library/statistics.rst:920
msgid ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"
msgstr ""
">>> temperature_february = NormalDist(5, 2.5)             # 摄氏度\n"
">>> temperature_february * (9/5) + 32                     # 华氏度\n"
"NormalDist(mu=41.0, sigma=4.5)"

#: ../../library/statistics.rst:926
msgid ""
"Dividing a constant by an instance of :class:`NormalDist` is not supported "
"because the result wouldn't be normally distributed."
msgstr "不允许一个常量除以 :class:`NormalDist` 的实例，因为结果将不是正态分布。"

#: ../../library/statistics.rst:929
msgid ""
"Since normal distributions arise from additive effects of independent "
"variables, it is possible to `add and subtract two independent normally "
"distributed random variables "
"<https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables>`_"
" represented as instances of :class:`NormalDist`.  For example:"
msgstr ""
"由于正态分布是由独立变量的累加效应产生的，因此允许表示为 :class:`NormalDist` 实例的 `两组独立正态分布的随机变量相加和相减 "
"<https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables>`_。"
" 例如："

#: ../../library/statistics.rst:935
msgid ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"
msgstr ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"

#: ../../library/statistics.rst:949
msgid "Examples and Recipes"
msgstr "例子和配方"

#: ../../library/statistics.rst:953
msgid "Classic probability problems"
msgstr "经典概率问题"

#: ../../library/statistics.rst:955
msgid ":class:`NormalDist` readily solves classic probability problems."
msgstr ":class:`NormalDist` 适合用来解决经典概率问题。"

#: ../../library/statistics.rst:957
msgid ""
"For example, given `historical data for SAT exams "
"<https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp>`_ showing "
"that scores are normally distributed with a mean of 1060 and a standard "
"deviation of 195, determine the percentage of students with test scores "
"between 1100 and 1200, after rounding to the nearest whole number:"
msgstr ""
"举例来说，如果 `SAT 考试的历史数据 "
"<https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp>`_ 显示分数呈平均值为"
" 1060 且标准差为 195 的正态分布，则可以确定考试分数处于 1100 和 1200 之间的学生的百分比舍入到最接近的整数应为："

#: ../../library/statistics.rst:963
msgid ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"
msgstr ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"

#: ../../library/statistics.rst:970
msgid ""
"Find the `quartiles <https://en.wikipedia.org/wiki/Quartile>`_ and `deciles "
"<https://en.wikipedia.org/wiki/Decile>`_ for the SAT scores:"
msgstr ""
"求 SAT 分数的 `四分位 <https://en.wikipedia.org/wiki/Quartile>`_ 和 `十分位 "
"<https://en.wikipedia.org/wiki/Decile>`_："

#: ../../library/statistics.rst:973
msgid ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"
msgstr ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"

#: ../../library/statistics.rst:982
msgid "Monte Carlo inputs for simulations"
msgstr "蒙特卡罗模拟输入"

#: ../../library/statistics.rst:984
msgid ""
"To estimate the distribution for a model that isn't easy to solve "
"analytically, :class:`NormalDist` can generate input samples for a `Monte "
"Carlo simulation <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"
msgstr ""
"为了估算一个不易获得解析解的模型分布，:class:`NormalDist` 可以生成用于 `蒙特卡洛模拟 "
"<https://en.wikipedia.org/wiki/Monte_Carlo_method>`_ 的输入样本："

#: ../../library/statistics.rst:988
msgid ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"
msgstr ""

#: ../../library/statistics.rst:1001
msgid "Approximating binomial distributions"
msgstr "近似二项分布"

#: ../../library/statistics.rst:1003
msgid ""
"Normal distributions can be used to approximate `Binomial distributions "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ when the sample "
"size is large and when the probability of a successful trial is near 50%."
msgstr ""
"当样本量较大且成功试验的可能性接近 50% 时，正态分布可以被用来模拟 `二项式分布 "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ 。"

#: ../../library/statistics.rst:1008
msgid ""
"For example, an open source conference has 750 attendees and two rooms with "
"a 500 person capacity.  There is a talk about Python and another about Ruby."
" In previous conferences, 65% of the attendees preferred to listen to Python"
" talks.  Assuming the population preferences haven't changed, what is the "
"probability that the Python room will stay within its capacity limits?"
msgstr ""
"例如，一次开源会议有 750 名与会者和两个可分别容纳 500 人的会议厅。 会上有一场关于 Python 的演讲和一场关于 Ruby 的演讲。 "
"在往届会议中，65% 的与会者更愿意去听关于 Python 的演讲。 假定人群的偏好没有发生改变，那么 Python "
"演讲的会议厅不超出其容量上限的可能性是多少？"

#: ../../library/statistics.rst:1014
msgid ""
">>> n = 750             # Sample size\n"
">>> p = 0.65            # Preference for Python\n"
">>> q = 1.0 - p         # Preference for Ruby\n"
">>> k = 500             # Room capacity\n"
"\n"
">>> # Approximation using the cumulative normal distribution\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Exact solution using the cumulative binomial distribution\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation using a simulation\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"
msgstr ""
">>> n = 750             # 样本大小\n"
">>> p = 0.65            # 对 Python 的偏好\n"
">>> q = 1.0 - p         # 对 Ruby 的偏好\n"
">>> k = 500             # 空间容量\n"
"\n"
">>> # 使用积累正态分布的近似解\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # 使用积累二项分布的精确解\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # 使用随机模拟的近似解\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"

#: ../../library/statistics.rst:1039
msgid "Naive bayesian classifier"
msgstr "朴素贝叶斯分类器"

#: ../../library/statistics.rst:1041
msgid "Normal distributions commonly arise in machine learning problems."
msgstr "在机器学习问题中也经常会出现正态分布。"

#: ../../library/statistics.rst:1043
msgid ""
"Wikipedia has a `nice example of a Naive Bayesian Classifier "
"<https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_."
" The challenge is to predict a person's gender from measurements of normally"
" distributed features including height, weight, and foot size."
msgstr ""
"维基百科上有一个 `朴素贝叶斯分类器的良好样例 "
"<https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_。"
" 要处理的问题是根据对多个分布的特征测量值包括身高、体重和足部尺码来预测一个人的性别。"

#: ../../library/statistics.rst:1048
msgid ""
"We're given a training dataset with measurements for eight people.  The "
"measurements are assumed to be normally distributed, so we summarize the "
"data with :class:`NormalDist`:"
msgstr "我们得到了由八个人的测量值组成的训练数据集。 假定这些测量值是正态分布的，因此我们用 :class:`NormalDist` 来总结数据："

#: ../../library/statistics.rst:1052
msgid ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"
msgstr ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"

#: ../../library/statistics.rst:1061
msgid ""
"Next, we encounter a new person whose feature measurements are known but "
"whose gender is unknown:"
msgstr "接下来，我们遇到一个特征测量值已知但性别未知的新人："

#: ../../library/statistics.rst:1064
msgid ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"
msgstr ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"

#: ../../library/statistics.rst:1070
msgid ""
"Starting with a 50% `prior probability "
"<https://en.wikipedia.org/wiki/Prior_probability>`_ of being male or female,"
" we compute the posterior as the prior times the product of likelihoods for "
"the feature measurements given the gender:"
msgstr ""
"从是男是女各 50% 的 `先验概率 <https://en.wikipedia.org/wiki/Prior_probability>`_ "
"出发，我们通过将该先验概率乘以给定性别的特征度量值的可能性累积值来计算后验概率："

#: ../../library/statistics.rst:1075
msgid ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"
msgstr ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"

#: ../../library/statistics.rst:1085
msgid ""
"The final prediction goes to the largest posterior. This is known as the "
"`maximum a posteriori "
"<https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation>`_ or MAP:"
msgstr ""
"最终预测值应为最大后验概率值。 这种算法被称为 `maximum a posteriori "
"<https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation>`_ 或 MAP："

#: ../../library/statistics.rst:1089
msgid ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
msgstr ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"

#: ../../library/statistics.rst:1096
msgid "Kernel density estimation"
msgstr "核密度估计"

#: ../../library/statistics.rst:1098
msgid ""
"It is possible to estimate a continuous probability distribution from a "
"fixed number of discrete samples."
msgstr ""

#: ../../library/statistics.rst:1101
msgid ""
"The basic idea is to smooth the data using `a kernel function such as a "
"normal distribution, triangular distribution, or uniform distribution "
"<https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use>`_."
" The degree of smoothing is controlled by a scaling parameter, ``h``, which "
"is called the *bandwidth*."
msgstr ""
"基本思路是使用 `一个核函数如正态分布、三角形分布或均匀分布 "
"<https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use>`_"
" 来平滑数据。 平滑程度由一个调节形参 ``h`` 来控制，它被称为 *带宽*。"

#: ../../library/statistics.rst:1107
msgid ""
"from random import choice, random\n"
"\n"
"def kde_normal(data, h):\n"
"    \"Create a continuous probability distribution from discrete samples.\"\n"
"\n"
"    # Smooth the data with a normal distribution kernel scaled by h.\n"
"    K_h = NormalDist(0.0, h)\n"
"\n"
"    def pdf(x):\n"
"        'Probability density function.  P(x <= X < x+dx) / dx'\n"
"        return sum(K_h.pdf(x - x_i) for x_i in data) / len(data)\n"
"\n"
"    def cdf(x):\n"
"        'Cumulative distribution function.  P(X <= x)'\n"
"        return sum(K_h.cdf(x - x_i) for x_i in data) / len(data)\n"
"\n"
"    def rand():\n"
"        'Random selection from the probability distribution.'\n"
"        return choice(data) + K_h.inv_cdf(random())\n"
"\n"
"    return pdf, cdf, rand"
msgstr ""

#: ../../library/statistics.rst:1131
msgid ""
"`Wikipedia has an example "
"<https://en.wikipedia.org/wiki/Kernel_density_estimation#Example>`_ where we"
" can use the ``kde_normal()`` recipe to generate and plot a probability "
"density function estimated from a small sample:"
msgstr ""
"在 `Wikipedia 提供的示例 "
"<https://en.wikipedia.org/wiki/Kernel_density_estimation#Example>`_ 中我们可以使用 "
"``kde_normal()`` 预设步骤生成并绘制从小样本中估算出的概率密度函数:"

#: ../../library/statistics.rst:1136
msgid ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> pdf, cdf, rand = kde_normal(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [pdf(x) for x in xarr]"
msgstr ""

#: ../../library/statistics.rst:1143
msgid "The points in ``xarr`` and ``yarr`` can be used to make a PDF plot:"
msgstr "``xarr`` 和 ``yarr`` 中的点可被用来绘制一个 PDF 图形:"

#: ../../library/statistics.rst:1145
msgid "Scatter plot of the estimated probability density function."
msgstr "估计概率密度函数的散点图。"

#: ../../library/statistics.rst:1148
msgid ""
"`Resample <https://en.wikipedia.org/wiki/Resampling_(statistics)>`_ the data"
" to produce 100 new selections:"
msgstr ""

#: ../../library/statistics.rst:1151
msgid ">>> new_selections = [rand() for i in range(100)]"
msgstr ""

#: ../../library/statistics.rst:1155
msgid "Determine the probability of a new selection being below ``2.0``:"
msgstr ""

#: ../../library/statistics.rst:1157
msgid ""
">>> round(cdf(2.0), 4)\n"
"0.5794"
msgstr ""

#: ../../library/statistics.rst:1162
msgid "Add a new sample data point and find the new CDF at ``2.0``:"
msgstr ""

#: ../../library/statistics.rst:1164
msgid ""
">>> sample.append(4.9)\n"
">>> round(cdf(2.0), 4)\n"
"0.5005"
msgstr ""
