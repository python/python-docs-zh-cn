# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dai Xu <daixu61@hotmail.com>, 2022
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2022-11-05 19:48+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-runner.rst:6
msgid "Runners"
msgstr "运行器"

#: ../../library/asyncio-runner.rst:8
msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**源代码:** :source:`Lib/asyncio/runners.py`"

#: ../../library/asyncio-runner.rst:11
msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr "本节将简述用于运行异步代码的高层级异步原语。"

#: ../../library/asyncio-runner.rst:13
msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr "它们构建于 :ref:`事件循环 <asyncio-event-loop>` 之上，其目标是简化针对常见通用场景的异步代码的用法。"

#: ../../library/asyncio-runner.rst:23
msgid "Running an asyncio Program"
msgstr "运行 asyncio 程序"

#: ../../library/asyncio-runner.rst:27
msgid "Execute *coro* in an asyncio event loop and return the result."
msgstr "在 asyncio 事件循环中执行 *coro* 并返回结果。"

#: ../../library/asyncio-runner.rst:29 ../../library/asyncio-runner.rst:121
msgid "The argument can be any awaitable object."
msgstr "参数可以是任意可等待对象。"

#: ../../library/asyncio-runner.rst:31
msgid ""
"This function runs the awaitable, taking care of managing the asyncio event "
"loop, *finalizing asynchronous generators*, and closing the executor."
msgstr "此函数会运行该可等待对象，负责管理 asyncio 事件循环，*终结化异步生成器*，并关闭执行器。"

#: ../../library/asyncio-runner.rst:35 ../../library/asyncio-runner.rst:131
msgid ""
"This function cannot be called when another asyncio event loop is running in"
" the same thread."
msgstr "当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。"

#: ../../library/asyncio-runner.rst:38 ../../library/asyncio-runner.rst:97
msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global "
":ref:`asyncio-debug-mode` settings."
msgstr ""
"如果 *debug* 为 ``True``，事件循环将运行于调试模式。 ``False`` 将显式地禁用调试模式。 使用 ``None`` 将沿用全局 "
":ref:`asyncio-debug-mode` 设置。"

#: ../../library/asyncio-runner.rst:42
msgid ""
"If *loop_factory* is not ``None``, it is used to create a new event loop; "
"otherwise :func:`asyncio.new_event_loop` is used. The loop is closed at the "
"end. This function should be used as a main entry point for asyncio "
"programs, and should ideally only be called once. It is recommended to use "
"*loop_factory* to configure the event loop instead of policies. Passing "
":class:`asyncio.EventLoop` allows running asyncio without the policy system."
msgstr ""
"如果 *loop_factory* 不为 ``None``，它将被用来创建一个新的事件循环；否则将会使用 "
":func:`asyncio.new_event_loop`。 最终该循环将被关闭。 此函数应当被用作 asyncio "
"程序的主入口点，在理想情况下应当只被调用一次。 建议使用 *loop_factory* 来配置事件循环而不是使用策略。 传入 "
":class:`asyncio.EventLoop` 将允许不带策略系统地运行 asyncio。"

#: ../../library/asyncio-runner.rst:50
msgid ""
"The executor is given a timeout duration of 5 minutes to shutdown. If the "
"executor hasn't finished within that duration, a warning is emitted and the "
"executor is closed."
msgstr "执行器的关闭有 5 分钟的超时限制。 如果执行器未在时限之内结束，将发出警告消息并关闭执行器。"

#: ../../library/asyncio-runner.rst:54
msgid "Example::"
msgstr "示例："

#: ../../library/asyncio-runner.rst:56
msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-runner.rst:64
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "更新为使用 :meth:`loop.shutdown_default_executor`。"

#: ../../library/asyncio-runner.rst:69
msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr "默认情况下 *debug* 为 ``None`` 即沿用全局调试模式设置。"

#: ../../library/asyncio-runner.rst:73
msgid "Added *loop_factory* parameter."
msgstr "增加了 *loop_factory* 形参。"

#: ../../library/asyncio-runner.rst:77 ../../library/asyncio-runner.rst:136
msgid "*coro* can be any awaitable object."
msgstr "*coro* 可以是任意可等待对象。"

#: ../../library/asyncio-runner.rst:81
msgid ""
"The :mod:`!asyncio` policy system is deprecated and will be removed in "
"Python 3.16; from there on, an explicit *loop_factory* is needed to "
"configure the event loop."
msgstr ""

#: ../../library/asyncio-runner.rst:87
msgid "Runner context manager"
msgstr "运行器上下文管理器"

#: ../../library/asyncio-runner.rst:91
msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr "对在相同上下文中 *多个* 异步函数调用进行简化的上下文管理器。"

#: ../../library/asyncio-runner.rst:94
msgid ""
"Sometimes several top-level async functions should be called in the same "
":ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"有时多个最高层级异步函数应当在同一个 :ref:`事件循环 <asyncio-event-loop>` 和 "
":class:`contextvars.Context` 中被调用。"

#: ../../library/asyncio-runner.rst:101
msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is "
"``None``."
msgstr ""
"*loop_factory* 可被用来重载循环的创建。 *loop_factory* 要负责将所创建的循环设置为当前事件循环。 在默认情况下如果 "
"*loop_factory* 为 ``None`` 则会使用 :func:`asyncio.new_event_loop` 并通过 "
":func:`asyncio.set_event_loop` 将其设置为当前事件循环。"

#: ../../library/asyncio-runner.rst:106
msgid ""
"Basically, :func:`asyncio.run` example can be rewritten with the runner "
"usage::"
msgstr "基本上，:func:`asyncio.run` 示例可以通过运行器的用法来重写::"

#: ../../library/asyncio-runner.rst:108
msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"

#: ../../library/asyncio-runner.rst:119
msgid "Execute *coro* in the embedded event loop."
msgstr ""

#: ../../library/asyncio-runner.rst:123
msgid "If the argument is a coroutine, it is wrapped in a Task."
msgstr ""

#: ../../library/asyncio-runner.rst:125
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the code to run in. The runner's default "
"context is used if context is ``None``."
msgstr ""

#: ../../library/asyncio-runner.rst:129
msgid "Returns the awaitable's result or raises an exception."
msgstr ""

#: ../../library/asyncio-runner.rst:140
msgid "Close the runner."
msgstr "关闭运行器。"

#: ../../library/asyncio-runner.rst:142
msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event"
" loop and release embedded :class:`contextvars.Context`."
msgstr "最终化异步生成器，停止默认执行器，关闭事件循环并释放嵌入的 :class:`contextvars.Context`。"

#: ../../library/asyncio-runner.rst:147
msgid "Return the event loop associated with the runner instance."
msgstr "返回关联到运行器实例的事件循环。"

#: ../../library/asyncio-runner.rst:151
msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ":class:`Runner` 会使用惰性初始化策略，它的构造器不会初始化下层的低层级结构体。"

#: ../../library/asyncio-runner.rst:154
msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"嵌入的 *loop* 和 *context* 是在进入 :keyword:`with` 语句体或者对 :meth:`run` 或 "
":meth:`get_loop` 的首次调用时被创建的。"

#: ../../library/asyncio-runner.rst:159
msgid "Handling Keyboard Interruption"
msgstr "处理键盘中断"

#: ../../library/asyncio-runner.rst:163
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, "
":exc:`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"当 :const:`signal.SIGINT` 被 :kbd:`Ctrl-C` 引发时，默认将在主线程中引发 "
":exc:`KeyboardInterrupt`。 但是这并不适用于 :mod:`asyncio` 因为它可以中断异步的内部操作并能挂起要退出的程序。"

#: ../../library/asyncio-runner.rst:168
msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr "为解决此问题，:mod:`asyncio` 将按以下步骤处理 :const:`signal.SIGINT`:"

#: ../../library/asyncio-runner.rst:170
msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` 在任何用户代码被执行之前安装一个自定义的 :const:`signal.SIGINT` "
"处理器并在从该函数退出时将其移除。"

#: ../../library/asyncio-runner.rst:172
msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
":class:`~asyncio.Runner` 为所传入的协程创建主任务供其执行。creates the main task for the "
"passed coroutine for its execution."

#: ../../library/asyncio-runner.rst:174
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, "
":meth:`asyncio.Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"当 :const:`signal.SIGINT` 被 :kbd:`Ctrl-C` 引发时，自定义的信号处理器将通过调用 "
":meth:`asyncio.Task.cancel` 在主任务内部引发 :exc:`asyncio.CancelledError` 来取消主任务。  "
"这将导致 Python 栈回退，``try/except`` 和 ``try/finally`` 代码块可被用于资源清理。 "
"在主任务被取消之后，:meth:`asyncio.Runner.run` 将引发 :exc:`KeyboardInterrupt`。"

#: ../../library/asyncio-runner.rst:180
msgid ""
"A user could write a tight loop which cannot be interrupted by "
":meth:`asyncio.Task.cancel`, in which case the second following "
":kbd:`Ctrl-C` immediately raises the :exc:`KeyboardInterrupt` without "
"cancelling the main task."
msgstr ""
"用户可以编写无法通过 :meth:`asyncio.Task.cancel` 来中断的紧密循环，在这种情况下后续的第二次 :kbd:`Ctrl-C` "
"将立即引发 :exc:`KeyboardInterrupt` 而不会取消主任务。"
