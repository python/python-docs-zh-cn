# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# jaystone776 <1732865113@qq.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# zeroswan <zeroswan@outlook.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 01:14+0000\n"
"Last-Translator: zeroswan <zeroswan@outlook.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/symtable.rst:2
msgid ":mod:`!symtable` --- Access to the compiler's symbol tables"
msgstr ":mod:`!symtable` --- 访问编译器的符号表"

#: ../../library/symtable.rst:7
msgid "**Source code:** :source:`Lib/symtable.py`"
msgstr "**Source code：** :source:`Lib/symtable.py`"

#: ../../library/symtable.rst:15
msgid ""
"Symbol tables are generated by the compiler from AST just before bytecode is"
" generated.  The symbol table is responsible for calculating the scope of "
"every identifier in the code.  :mod:`symtable` provides an interface to "
"examine these tables."
msgstr ""
"符号表由编译器在生成字节码之前根据 AST 生成。符号表负责计算代码中每个标识符的作用域。 :mod:`symtable` 提供了一个查看这些表的接口。"

#: ../../library/symtable.rst:22
msgid "Generating Symbol Tables"
msgstr "符号表的生成"

#: ../../library/symtable.rst:26
msgid ""
"Return the toplevel :class:`SymbolTable` for the Python source *code*. "
"*filename* is the name of the file containing the code.  *compile_type* is "
"like the *mode* argument to :func:`compile`."
msgstr ""
"返回 Python 源 *代码* 顶层的 :class:`SymbolTable`。*filename* 是代码文件名。 *compile_type* "
"的含义类似 :func:`compile` 的 *mode* 参数。"

#: ../../library/symtable.rst:32
msgid "Examining Symbol Tables"
msgstr "符号表的查看"

#: ../../library/symtable.rst:36
msgid "An enumeration indicating the type of a :class:`SymbolTable` object."
msgstr "一个指明 :class:`SymbolTable` 对象的类型的枚举。"

#: ../../library/symtable.rst:41
msgid "Used for the symbol table of a module."
msgstr "用于模块的符号表。"

#: ../../library/symtable.rst:46
msgid "Used for the symbol table of a function."
msgstr "用于函数的符号表。"

#: ../../library/symtable.rst:51
msgid "Used for the symbol table of a class."
msgstr "用于类的符号表。"

#: ../../library/symtable.rst:53
msgid ""
"The following members refer to different flavors of :ref:`annotation scopes "
"<annotation-scopes>`."
msgstr "以下成员指向不同风格的 :ref:`标注作用域 <annotation-scopes>`。"

#: ../../library/symtable.rst:59
msgid ""
"Used for annotations if ``from __future__ import annotations`` is active."
msgstr "当 ``from __future__ import annotations`` 被激活时用于标注。"

#: ../../library/symtable.rst:64
msgid "Used for the symbol table of :keyword:`type` constructions."
msgstr "用于 :keyword:`type` 构造的符号表。"

#: ../../library/symtable.rst:69
msgid ""
"Used for the symbol table of :ref:`generic functions <generic-functions>` or"
" :ref:`generic classes <generic-classes>`."
msgstr ""
"用于 :ref:`泛型函数 <generic-functions>` 或 :ref:`泛型类 <generic-classes>` 的符号表。"

#: ../../library/symtable.rst:75
msgid ""
"Used for the symbol table of the bound, the constraint tuple or the default "
"value of a single type variable in the formal sense, i.e., a TypeVar, a "
"TypeVarTuple or a ParamSpec object (the latter two do not support a bound or"
" a constraint tuple)."
msgstr ""
"用于正式意义下的绑定、约束元组或单个类型变量的默认值的符号变量的符号表，即 TypeVar, TypeVarTuple 或 ParamSpec "
"对象（后两者不支持绑定或约束元组）。"

#: ../../library/symtable.rst:84
msgid "A namespace table for a block.  The constructor is not public."
msgstr "某个代码块的命名空间表。构造函数不公开。"

#: ../../library/symtable.rst:88
msgid ""
"Return the type of the symbol table.  Possible values are members of the "
":class:`SymbolTableType` enumeration."
msgstr "返回符号表的类型。 可能的值为 :class:`SymbolTableType` 枚举的成员。"

#: ../../library/symtable.rst:91
msgid ""
"Added ``'annotation'``,  ``'TypeVar bound'``, ``'type alias'``, and ``'type "
"parameter'`` as possible return values."
msgstr ""
"增加 ``'annotation'``, ``'TypeVar bound'``, ``'type alias'`` 和 ``'type "
"parameter'`` 作为可能的返回值。"

#: ../../library/symtable.rst:95
msgid "Return values are members of the :class:`SymbolTableType` enumeration."
msgstr "返回值为 :class:`SymbolTableType` 枚举的成员。"

#: ../../library/symtable.rst:98
msgid ""
"The exact values of the returned string may change in the future, and thus, "
"it is recommended to use :class:`SymbolTableType` members instead of hard-"
"coded strings."
msgstr "返回字符串的实际值可能在未来发生变化，因此，建议使用 :class:`SymbolTableType` 成员而不是硬编码的字符串。"

#: ../../library/symtable.rst:104
msgid "Return the table's identifier."
msgstr "返回符号表的标识符"

#: ../../library/symtable.rst:108
msgid ""
"Return the table's name.  This is the name of the class if the table is for "
"a class, the name of the function if the table is for a function, or "
"``'top'`` if the table is global (:meth:`get_type` returns ``'module'``). "
"For type parameter scopes (which are used for generic classes, functions, "
"and type aliases), it is the name of the underlying class, function, or type"
" alias. For type alias scopes, it is the name of the type alias. For "
":class:`~typing.TypeVar` bound scopes, it is the name of the ``TypeVar``."
msgstr ""
"返回表名称。 如果表是针对类的则为类名；如果是针对函数的则为函数名；或者如果表是全局的 (:meth:`get_type` 返回 "
"``'module'``) 则为 ``'top'``。 对于类型形参作用域 (用于泛型类、函数和类型别名)，它将为底层类、函数或类型别名的名称。 "
"对于类型别名作用域，它将为类型别名的名称。 对于 :class:`~typing.TypeVar` 绑定作用域，它将为 ``TypeVar`` 的名称。"

#: ../../library/symtable.rst:118
msgid ""
"Return the number of the first line in the block this table represents."
msgstr "返回符号表所代表代码块的第一行编号。"

#: ../../library/symtable.rst:122
msgid "Return ``True`` if the locals in this table can be optimized."
msgstr "如果符号表中的局部变量可能被优化过，则返回 ``True``。"

#: ../../library/symtable.rst:126
msgid "Return ``True`` if the block is a nested class or function."
msgstr "如果代码块是嵌套类或函数，则返回 ``True``。"

#: ../../library/symtable.rst:130
msgid ""
"Return ``True`` if the block has nested namespaces within it.  These can be "
"obtained with :meth:`get_children`."
msgstr "如果代码块中有嵌套的命名空间，则返回 ``True``。可通过  :meth:`get_children` 读取。"

#: ../../library/symtable.rst:135
msgid ""
"Return a view object containing the names of symbols in the table. See the "
":ref:`documentation of view objects <dict-views>`."
msgstr "返回一个包含表中符号名称的视图对象。 参见 :ref:`视图对象文档 <dict-views>`。"

#: ../../library/symtable.rst:140
msgid "Lookup *name* in the table and return a :class:`Symbol` instance."
msgstr "在符号表中查找 *name* 并返回一个 :class:`Symbol` 实例。"

#: ../../library/symtable.rst:144
msgid "Return a list of :class:`Symbol` instances for names in the table."
msgstr "返回符号表中所有符号的 :class:`Symbol` 实例的列表。"

#: ../../library/symtable.rst:148
msgid "Return a list of the nested symbol tables."
msgstr "返回嵌套符号表的列表。"

#: ../../library/symtable.rst:153
msgid ""
"A namespace for a function or method.  This class inherits from "
":class:`SymbolTable`."
msgstr "函数或方法的命名空间。 该类继承自 :class:`SymbolTable`。"

#: ../../library/symtable.rst:158
msgid "Return a tuple containing names of parameters to this function."
msgstr "返回由函数的参数名组成的元组。"

#: ../../library/symtable.rst:162
msgid "Return a tuple containing names of locals in this function."
msgstr "返回函数中局部变量名组成的元组。"

#: ../../library/symtable.rst:166
msgid "Return a tuple containing names of globals in this function."
msgstr "返回函数中全局变量名组成的元组。"

#: ../../library/symtable.rst:170
msgid ""
"Return a tuple containing names of explicitly declared nonlocals in this "
"function."
msgstr "返回一个包含在此函数中显式声明的非局部变量名称的元组。"

#: ../../library/symtable.rst:174
msgid ""
"Return a tuple containing names of :term:`free (closure) variables <closure "
"variable>` in this function."
msgstr "返回一个包含在此函数中的 :term:`自由（闭包）变量 <closure variable>` 名称的元组。"

#: ../../library/symtable.rst:180
msgid ""
"A namespace of a class.  This class inherits from :class:`SymbolTable`."
msgstr "类的命名空间。 该类继承自 :class:`SymbolTable`。"

#: ../../library/symtable.rst:184
msgid ""
"Return a tuple containing the names of method-like functions declared in the"
" class."
msgstr "返回一个包含类中声明的方法型函数的名称的元组。"

#: ../../library/symtable.rst:187
msgid ""
"Here, the term 'method' designates *any* function defined in the class body "
"via :keyword:`def` or :keyword:`async def`."
msgstr ""
"在这里，术语 '方法' 是指 *任何* 在 class 语句体中通过 :keyword:`def` 或 :keyword:`async def` "
"定义的函数。"

#: ../../library/symtable.rst:190
msgid ""
"Functions defined in a deeper scope (e.g., in an inner class) are not picked"
" up by :meth:`get_methods`."
msgstr "在更深的作用域（例如内部类）中定义的函数不会被 :meth:`get_methods` 所获取。"

#: ../../library/symtable.rst:193
msgid "For example:"
msgstr "例如:"

#: ../../library/symtable.rst:206
msgid ""
">>> import symtable\n"
">>> st = symtable.symtable('''\n"
"... def outer(): pass\n"
"...\n"
"... class A:\n"
"...    def f():\n"
"...        def w(): pass\n"
"...\n"
"...    def g(self): pass\n"
"...\n"
"...    @classmethod\n"
"...    async def h(cls): pass\n"
"...\n"
"...    global outer\n"
"...    def outer(self): pass\n"
"... ''', 'test', 'exec')\n"
">>> class_A = st.get_children()[2]\n"
">>> class_A.get_methods()\n"
"('f', 'g', 'h')"
msgstr ""

#: ../../library/symtable.rst:228
msgid ""
"Although ``A().f()`` raises :exc:`TypeError` at runtime, ``A.f`` is still "
"considered as a method-like function."
msgstr "虽然 ``A().f()`` 在运行时会引发 :exc:`TypeError`，但 ``A.f`` 仍然被视为是方法型函数。"

#: ../../library/symtable.rst:236
msgid ""
"An entry in a :class:`SymbolTable` corresponding to an identifier in the "
"source.  The constructor is not public."
msgstr ":class:`SymbolTable` 中的数据项，对应于源码中的某个标识符。构造函数不公开。"

#: ../../library/symtable.rst:241
msgid "Return the symbol's name."
msgstr "返回符号名"

#: ../../library/symtable.rst:245
msgid "Return ``True`` if the symbol is used in its block."
msgstr "如果符号在代码块中被引用了，则返回 ``True``。"

#: ../../library/symtable.rst:249
msgid "Return ``True`` if the symbol is created from an import statement."
msgstr "如果符号是由导入语句创建的，则返回 ``True``。"

#: ../../library/symtable.rst:253
msgid "Return ``True`` if the symbol is a parameter."
msgstr "如果符号是参数，返回 ``True``。"

#: ../../library/symtable.rst:257
msgid "Return ``True`` if the symbol is a type parameter."
msgstr ""

#: ../../library/symtable.rst:263
msgid "Return ``True`` if the symbol is global."
msgstr "如果符号是全局变量，则返回 ``True``。"

#: ../../library/symtable.rst:267
msgid "Return ``True`` if the symbol is nonlocal."
msgstr "如果符号为非局部变量，则返回 ``True``。"

#: ../../library/symtable.rst:271
msgid ""
"Return ``True`` if the symbol is declared global with a global statement."
msgstr "如果符号用 global 声明为全局变量，则返回 ``True``。"

#: ../../library/symtable.rst:275
msgid "Return ``True`` if the symbol is local to its block."
msgstr "如果符号是代码块内的局部变量，则返回 ``True``。"

#: ../../library/symtable.rst:279
msgid "Return ``True`` if the symbol is annotated."
msgstr "如果符号带有注解，则返回 ``True``。"

#: ../../library/symtable.rst:285
msgid ""
"Return ``True`` if the symbol is referenced in its block, but not assigned "
"to."
msgstr "如果符号在代码块中被引用，但未赋值，则返回 ``True``。"

#: ../../library/symtable.rst:290
msgid ""
"Return *True* if a class-scoped symbol is free from the perspective of a "
"method."
msgstr ""

#: ../../library/symtable.rst:293
msgid "Consider the following example::"
msgstr "比如下面的例子::"

#: ../../library/symtable.rst:295
msgid ""
"def f():\n"
"    x = 1  # function-scoped\n"
"    class C:\n"
"        x = 2  # class-scoped\n"
"        def method(self):\n"
"            return x"
msgstr ""

#: ../../library/symtable.rst:302
msgid ""
"In this example, the class-scoped symbol ``x`` is considered to be free from"
" the perspective of ``C.method``, thereby allowing the latter to return *1* "
"at runtime and not *2*."
msgstr ""

#: ../../library/symtable.rst:310
msgid "Return ``True`` if the symbol is assigned to in its block."
msgstr "如果符号在代码块中赋值，则返回 ``True``。"

#: ../../library/symtable.rst:314
msgid "Return ``True`` if the symbol is a comprehension iteration variable."
msgstr ""

#: ../../library/symtable.rst:320
msgid "Return ``True`` if the symbol is a cell in an inlined comprehension."
msgstr ""

#: ../../library/symtable.rst:326
msgid "Return ``True`` if name binding introduces new namespace."
msgstr "如果符号名绑定引入了新的命名空间，则返回 ``True``。"

#: ../../library/symtable.rst:328
msgid ""
"If the name is used as the target of a function or class statement, this "
"will be true."
msgstr "如果符号名用于函数或类定义语句，则为 True。"

#: ../../library/symtable.rst:331
msgid "For example::"
msgstr "例如："

#: ../../library/symtable.rst:333
msgid ""
">>> table = symtable.symtable(\"def some_func(): pass\", \"string\", \"exec\")\n"
">>> table.lookup(\"some_func\").is_namespace()\n"
"True"
msgstr ""
">>> table = symtable.symtable(\"def some_func(): pass\", \"string\", \"exec\")\n"
">>> table.lookup(\"some_func\").is_namespace()\n"
"True"

#: ../../library/symtable.rst:337
msgid ""
"Note that a single name can be bound to multiple objects.  If the result is "
"``True``, the name may also be bound to other objects, like an int or list, "
"that does not introduce a new namespace."
msgstr ""
"注意，一个符号名可以与多个对象绑定。如果结果为 ``True``，则该符号名还可以绑定到其他对象上，比如 int 或 list "
"，且不会引入新的命名空间。"

#: ../../library/symtable.rst:343
msgid "Return a list of namespaces bound to this name."
msgstr "返回与符号名绑定的命名空间的列表。"

#: ../../library/symtable.rst:347
msgid ""
"Return the namespace bound to this name. If more than one or no namespace is"
" bound to this name, a :exc:`ValueError` is raised."
msgstr "返回绑定到这个名称的命名空间。 如果有多个命名空间或没有命名空间被绑定到这个名称，则会引发 :exc:`ValueError`。"

#: ../../library/symtable.rst:354
msgid "Command-Line Usage"
msgstr "命令行用法"

#: ../../library/symtable.rst:358
msgid ""
"The :mod:`symtable` module can be executed as a script from the command "
"line."
msgstr ":mod:`symtable` 模块可以在命令行下作为脚本来执行。"

#: ../../library/symtable.rst:360
msgid "python -m symtable [infile...]"
msgstr "python -m symtable [infile...]"

#: ../../library/symtable.rst:364
msgid ""
"Symbol tables are generated for the specified Python source files and dumped"
" to stdout. If no input file is specified, the content is read from stdin."
msgstr "符号表将针对指定的 Python 文件生成并转储至 stdout。 如果未指定输入文件，将从 stdin 读取内容。"
