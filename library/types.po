# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# nick <2330458484@qq.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/types.rst:2
msgid ":mod:`!types` --- Dynamic type creation and names for built-in types"
msgstr ":mod:`!types` --- 动态类型创建和内置类型名称"

#: ../../library/types.rst:7
msgid "**Source code:** :source:`Lib/types.py`"
msgstr "**源代码:** :source:`Lib/types.py`"

#: ../../library/types.rst:11
msgid ""
"This module defines utility functions to assist in dynamic creation of new "
"types."
msgstr "此模块定义了一些工具函数，用于协助动态创建新的类型。"

#: ../../library/types.rst:14
msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or "
":class:`str` are."
msgstr ""
"它还为某些对象类型定义了名称，这些名称由标准 Python 解释器所使用，但并不像内置的 :class:`int` 或 :class:`str` "
"那样对外公开。"

#: ../../library/types.rst:18
msgid ""
"Finally, it provides some additional type-related utility classes and "
"functions that are not fundamental enough to be builtins."
msgstr "最后，它还额外提供了一些类型相关但重要程度不足以作为内置对象的工具类和函数。"

#: ../../library/types.rst:23
msgid "Dynamic Type Creation"
msgstr "动态类型创建"

#: ../../library/types.rst:27
msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr "使用适当的元类动态地创建一个类对象。"

#: ../../library/types.rst:29
msgid ""
"The first three arguments are the components that make up a class definition"
" header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr "前三个参数是组成类定义头的部件：类名称，基类 (有序排列)，关键字参数 (例如 ``metaclass``)。"

#: ../../library/types.rst:33
msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: "
"None``."
msgstr ""
"*exec_body* 参数是一个回调函数，用于填充新创建类的命名空间。 它应当接受类命名空间作为其唯一的参数并使用类内容直接更新命名空间。  "
"如果未提供回调函数，则它就等效于传入 ``lambda ns: None``。"

#: ../../library/types.rst:43
msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr "计算适当的元类并创建类命名空间。"

#: ../../library/types.rst:45
msgid ""
"The arguments are the components that make up a class definition header: the"
" class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr "参数是组成类定义头的部件：类名称，基类 (有序排列) 以及关键字参数 (例如 ``metaclass``)。"

#: ../../library/types.rst:49
msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr "返回值是一个 3 元组: ``metaclass, namespace, kwds``"

#: ../../library/types.rst:51
msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""
"*metaclass* 是适当的元类，*namespace* 是预备好的类命名空间而 *kwds* 是所传入 *kwds* 参数移除每个 "
"``'metaclass'`` 条目后的已更新副本。 如果未传入 *kwds* 参数，这将为一个空字典。"

#: ../../library/types.rst:60
msgid ""
"The default value for the ``namespace`` element of the returned tuple has "
"changed.  Now an insertion-order-preserving mapping is used when the "
"metaclass does not have a ``__prepare__`` method."
msgstr ""
"所返回元组中 ``namespace`` 元素的默认值已被改变。 现在当元类没有 ``__prepare__`` 方法时将会使用一个保留插入顺序的映射。"

#: ../../library/types.rst:66
msgid ":ref:`metaclasses`"
msgstr ":ref:`metaclasses`"

#: ../../library/types.rst:67
msgid ""
"Full details of the class creation process supported by these functions"
msgstr "这些函数所支持的类创建过程的完整细节"

#: ../../library/types.rst:69
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Python 3000 中的元类"

#: ../../library/types.rst:70
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "引入 ``__prepare__`` 命名空间钩子"

#: ../../library/types.rst:74
msgid "Resolve MRO entries dynamically as specified by :pep:`560`."
msgstr "动态地解析 MRO 条目，具体描述见 :pep:`560`。"

#: ../../library/types.rst:76
msgid ""
"This function looks for items in *bases* that are not instances of "
":class:`type`, and returns a tuple where each such object that has an "
":meth:`~object.__mro_entries__` method is replaced with an unpacked result "
"of calling this method.  If a *bases* item is an instance of :class:`type`, "
"or it doesn't have an :meth:`!__mro_entries__` method, then it is included "
"in the return tuple unchanged."
msgstr ""
"此函数会在 *bases* 中查找不是 :class:`type` 的实例的项，并返回一个元组，其中每个具有 "
":meth:`~object.__mro_entries__` 方法的此种对象将被替换为调用该方法解包后的结果。 如果一个 *bases* 项是 "
":class:`type` 的实例，或它不具有 :meth:`!__mro_entries__` 方法 ，则它将不加改变地被包括在返回的元组中。"

#: ../../library/types.rst:87
msgid ""
"Return the tuple of objects originally given as the bases of *cls* before "
"the :meth:`~object.__mro_entries__` method has been called on any bases "
"(following the mechanisms laid out in :pep:`560`). This is useful for "
"introspecting :ref:`Generics <user-defined-generics>`."
msgstr ""
"在 :meth:`~object.__mro_entries__` 方法在任何基类上被调用之前返回最初是作为 *cls* 的基类给出的对象元组（根据 "
":pep:`560` 所描述的机制）。 这在对 :ref:`泛型 <user-defined-generics>` 进行内省时很有用处。"

#: ../../library/types.rst:92
msgid ""
"For classes that have an ``__orig_bases__`` attribute, this function returns"
" the value of ``cls.__orig_bases__``. For classes without the "
"``__orig_bases__`` attribute, :attr:`cls.__bases__ <type.__bases__>` is "
"returned."
msgstr ""
"对于具有 ``__orig_bases__`` 属性的类，此函数将返回 ``cls.__orig_bases__`` 的值。 对于没有 "
"``__orig_bases__`` 属性的类，则将返回 :attr:`cls.__bases__ <type.__bases__>`。"

#: ../../library/types.rst:97
msgid "Examples::"
msgstr "示例::"

#: ../../library/types.rst:99
msgid ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"
msgstr ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"

#: ../../library/types.rst:127
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - 对 typing 模块和泛型类型的核心支持"

#: ../../library/types.rst:131
msgid "Standard Interpreter Types"
msgstr "标准解释器类型"

#: ../../library/types.rst:133
msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the"
" types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""
"此模块为许多类型提供了实现 Python 解释器所要求的名称。 它刻意地避免了包含某些仅在处理过程中偶然出现的类型，例如 "
"``listiterator`` 类型。"

#: ../../library/types.rst:138
msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr "此种名称的典型应用如 :func:`isinstance` 或 :func:`issubclass` 检测。"

#: ../../library/types.rst:142
msgid ""
"If you instantiate any of these types, note that signatures may vary between"
" Python versions."
msgstr "如果你要实例化这些类型中的任何一种，请注意其签名在不同 Python 版本之间可能出现变化。"

#: ../../library/types.rst:144
msgid "Standard names are defined for the following types:"
msgstr "以下类型有相应的标准名称定义："

#: ../../library/types.rst:148
msgid "The type of :data:`None`."
msgstr ":data:`None` 的类型。"

#: ../../library/types.rst:156
msgid ""
"The type of user-defined functions and functions created by "
":keyword:`lambda`  expressions."
msgstr "用户自定义函数以及由 :keyword:`lambda`  表达式所创建函数的类型。"

#: ../../library/types.rst:159
msgid ""
"Raises an :ref:`auditing event <auditing>` ``function.__new__`` with "
"argument ``code``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``function.__new__`` 并附带参数 ``code``。"

#: ../../library/types.rst:161
msgid ""
"The audit event only occurs for direct instantiation of function objects, "
"and is not raised for normal compilation."
msgstr "此审计事件只会被函数对象的直接实例化引发，而不会被普通编译所引发。"

#: ../../library/types.rst:167
msgid ""
"The type of :term:`generator`-iterator objects, created by generator "
"functions."
msgstr ":term:`generator` 迭代器对象的类型，由生成器函数创建。"

#: ../../library/types.rst:173
msgid ""
"The type of :term:`coroutine` objects, created by :keyword:`async def` "
"functions."
msgstr ":term:`coroutine` 对象的类型，由 :keyword:`async def` 函数创建。"

#: ../../library/types.rst:181
msgid ""
"The type of :term:`asynchronous generator`-iterator objects, created by "
"asynchronous generator functions."
msgstr ":term:`asynchronous generator` 迭代器对象的类型，由异步生成器函数创建。"

#: ../../library/types.rst:191
msgid ""
"The type of :ref:`code objects <code-objects>` such as returned by "
":func:`compile`."
msgstr ":ref:`代码对象 <code-objects>` 例如 :func:`compile` 返回值的类型。"

#: ../../library/types.rst:193
msgid ""
"Raises an :ref:`auditing event <auditing>` ``code.__new__`` with arguments "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``, "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``code.__new__`` 并附带参数 ``code``, ``filename``, "
"``name``, ``argcount``, ``posonlyargcount``, ``kwonlyargcount``, "
"``nlocals``, ``stacksize``, ``flags``。"

#: ../../library/types.rst:195
msgid ""
"Note that the audited arguments may not match the names or positions "
"required by the initializer.  The audit event only occurs for direct "
"instantiation of code objects, and is not raised for normal compilation."
msgstr "请注意被审计的参数可能与初始化代码所要求的名称或位置不相匹配。 审计事件只会被代码对象的直接实例化引发，而不会被普通编译所引发。"

#: ../../library/types.rst:201
msgid ""
"The type for cell objects: such objects are used as containers for a "
"function's :term:`closure variables <closure variable>`."
msgstr "单元对象的类型：这种对象被用作函数中 :term:`闭包变量 <closure variable>` 的容器。"

#: ../../library/types.rst:209
msgid "The type of methods of user-defined class instances."
msgstr "用户自定义类实例方法的类型。"

#: ../../library/types.rst:215
msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""
"内置函数例如 :func:`len` 或 :func:`sys.exit` 以及内置类方法的类型。 （这里所说的“内置”是指“以 C 语言编写”。）"

#: ../../library/types.rst:222
msgid ""
"The type of methods of some built-in data types and base classes such as "
":meth:`object.__init__` or :meth:`object.__lt__`."
msgstr "某些内置数据类型和基类的方法的类型，例如 :meth:`object.__init__` 或 :meth:`object.__lt__`。"

#: ../../library/types.rst:230
msgid ""
"The type of *bound* methods of some built-in data types and base classes. "
"For example it is the type of :code:`object().__str__`."
msgstr "某些内置数据类型和基类的 *绑定* 方法的类型。 例如 :code:`object().__str__` 所属的类型。"

#: ../../library/types.rst:238
msgid "The type of :data:`NotImplemented`."
msgstr ":data:`NotImplemented` 的类型。"

#: ../../library/types.rst:245
msgid ""
"The type of methods of some built-in data types such as :meth:`str.join`."
msgstr "某些内置数据类型方法例如 :meth:`str.join` 的类型。"

#: ../../library/types.rst:252
msgid ""
"The type of *unbound* class methods of some built-in data types such as "
"``dict.__dict__['fromkeys']``."
msgstr "某些内置数据类型 *非绑定* 类方法例如 ``dict.__dict__['fromkeys']`` 的类型。"

#: ../../library/types.rst:260
msgid ""
"The type of :term:`modules <module>`. The constructor takes the name of the "
"module to be created and optionally its :term:`docstring`."
msgstr ":term:`模块 <module>` 的类型。 构造器接受待创建模块的名称并以其 :term:`docstring` 作为可选参数。"

#: ../../library/types.rst:265
msgid ":ref:`Documentation on module objects <module-objects>`"
msgstr ":ref:`模块对象的文档 <module-objects>`"

#: ../../library/types.rst:266
msgid ""
"Provides details on the special attributes that can be found on instances of"
" :class:`!ModuleType`."
msgstr "提供了有关可在 :class:`!ModuleType` 的实例上找到的特殊属性的详情。"

#: ../../library/types.rst:269
msgid ":func:`importlib.util.module_from_spec`"
msgstr ":func:`importlib.util.module_from_spec`"

#: ../../library/types.rst:270
msgid ""
"Modules created using the :class:`!ModuleType` constructor are created with "
"many of their special attributes unset or set to default values. "
":func:`!module_from_spec` provides a more robust way of creating "
":class:`!ModuleType` instances which ensures the various attributes are set "
"appropriately."
msgstr ""
"使用 :class:`!ModuleType` 构造器创建的模块在被创建时将有许多特殊属性被设置或重设其默认值。 "
":func:`!module_from_spec` 提供了一种创建 :class:`!ModuleType` "
"实例的更健壮方式，可确保各个属性被正确地设置。"

#: ../../library/types.rst:278
msgid "The type of :data:`Ellipsis`."
msgstr ":data:`Ellipsis` 的类型。"

#: ../../library/types.rst:284
msgid ""
"The type of :ref:`parameterized generics <types-genericalias>` such as "
"``list[int]``."
msgstr ":ref:`形参化泛型 <types-genericalias>` 的类型，例如 ``list[int]``。"

#: ../../library/types.rst:287
msgid ""
"``t_origin`` should be a non-parameterized generic class, such as ``list``, "
"``tuple`` or ``dict``.  ``t_args`` should be a :class:`tuple` (possibly of "
"length 1) of types which parameterize ``t_origin``::"
msgstr ""
"``t_origin`` 应当是一个非形参化的泛型类，例如 ``list``, ``tuple`` 或 ``dict``。 ``t_args`` "
"应当是一个形参化 ``t_origin`` 的 :class:`tuple` (长度可以为 1)::"

#: ../../library/types.rst:291
msgid ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"
msgstr ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"

#: ../../library/types.rst:300
msgid "This type can now be subclassed."
msgstr "此类型现在可以被子类化。"

#: ../../library/types.rst:305
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`泛用别名类型<types-genericalias>`"

#: ../../library/types.rst:306
msgid "In-depth documentation on instances of :class:`!types.GenericAlias`"
msgstr "有关 :class:`!types.GenericAlias` 实例的详细文档"

#: ../../library/types.rst:308
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - 标准多项集中的类型提示泛型"

#: ../../library/types.rst:309
msgid "Introducing the :class:`!types.GenericAlias` class"
msgstr "引入 :class:`!types.GenericAlias` 类"

#: ../../library/types.rst:313
msgid "The type of :ref:`union type expressions<types-union>`."
msgstr ":ref:`合并类型表达式 <types-union>` 的类型。"

#: ../../library/types.rst:319
msgid "This is now an alias for :class:`typing.Union`."
msgstr ""

#: ../../library/types.rst:323
msgid ""
"The type of traceback objects such as found in "
"``sys.exception().__traceback__``."
msgstr "回溯对象的类型，如在 ``sys.exception().__traceback__`` 中找到的一样。"

#: ../../library/types.rst:325
msgid ""
"See :ref:`the language reference <traceback-objects>` for details of the "
"available attributes and operations, and guidance on creating tracebacks "
"dynamically."
msgstr "请查看 :ref:`语言参考 <traceback-objects>` 了解可用属性和操作的细节，以及动态地创建回溯对象的指南。"

#: ../../library/types.rst:332
msgid ""
"The type of :ref:`frame objects <frame-objects>` such as found in "
":attr:`tb.tb_frame <traceback.tb_frame>` if ``tb`` is a traceback object."
msgstr ""
":ref:`帧对象 <frame-objects>` 的类型，例如当 ``tb`` 是一个回溯对象时 :attr:`tb.tb_frame "
"<traceback.tb_frame>` 中的对象。"

#: ../../library/types.rst:338
msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as :attr:`FrameType.f_locals <frame.f_locals>` or ``array.array.typecode``. "
"This type is used as descriptor for object attributes; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"使用 ``PyGetSetDef`` 在扩展模块中定义的对象的类型，例如 :attr:`FrameType.f_locals "
"<frame.f_locals>` 或 ``array.array.typecode``。 此类型被用作对象属性的描述器；它的目的与 "
":class:`property` 类型相同，但专门针对在扩展模块中定义的类。"

#: ../../library/types.rst:347
msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"使用 ``PyMemberDef`` 在扩展模块中定义的对象的类型，例如 ``datetime.timedelta.days``。 "
"此类型被用作使用标准转换函数的简单 C 数据成员的描述器；它的目的与 :class:`property` 类型相同，但专门针对在扩展模块中定义的类。"

#: ../../library/types.rst:352
msgid ""
"In addition, when a class is defined with a :attr:`~object.__slots__` "
"attribute, then for each slot, an instance of :class:`!MemberDescriptorType`"
" will be added as an attribute on the class. This allows the slot to appear "
"in the class's :attr:`~type.__dict__`."
msgstr ""
"此外，当一个类定义了 :attr:`~object.__slots__` 属性时，对于每个槽位，都将添加一个 "
":class:`!MemberDescriptorType` 的实例作为该类上的属性。 这将允许槽位显示在类的 "
":attr:`~type.__dict__` 中。"

#: ../../library/types.rst:358
msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr "在 Python 的其它实现中，此类型可能与 ``GetSetDescriptorType`` 完全相同。"

#: ../../library/types.rst:363
msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr "一个映射的只读代理。 它提供了对映射条目的动态视图，这意味着当映射发生改变时，视图会反映这些改变。"

#: ../../library/types.rst:371
msgid ""
"Updated to support the new union (``|``) operator from :pep:`584`, which "
"simply delegates to the underlying mapping."
msgstr "更新为支持 :pep:`584` 所新增的合并 (``|``) 运算符，它会简单地委托给下层的映射。"

#: ../../library/types.rst:376
msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr "如果下层的映射中存在键 *key* 则返回 ``True``，否则返回 ``False``。"

#: ../../library/types.rst:381
msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a "
":exc:`KeyError` if *key* is not in the underlying mapping."
msgstr "返回下层的映射中以 *key* 为键的项。 如果下层的映射中不存在键 *key* 则引发 :exc:`KeyError`。"

#: ../../library/types.rst:386
msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr "返回由下层映射的键为元素的迭代器。 这是 ``iter(proxy.keys())`` 的快捷方式。"

#: ../../library/types.rst:391
msgid "Return the number of items in the underlying mapping."
msgstr "返回下层映射中的项数。"

#: ../../library/types.rst:395
msgid "Return a shallow copy of the underlying mapping."
msgstr "返回下层映射的浅拷贝。"

#: ../../library/types.rst:399
msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this"
" method never raises a :exc:`KeyError`."
msgstr ""
"如果 *key* 存在于下层映射中则返回 *key* 的值，否则返回 *default*。 如果 *default* 未给出则默认为 "
"``None``，因而此方法绝不会引发 :exc:`KeyError`。"

#: ../../library/types.rst:405
msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` "
"pairs)."
msgstr "返回由下层映射的项 (``(键, 值)`` 对) 组成的一个新视图。"

#: ../../library/types.rst:410
msgid "Return a new view of the underlying mapping's keys."
msgstr "返回由下层映射的键组成的一个新视图。"

#: ../../library/types.rst:414
msgid "Return a new view of the underlying mapping's values."
msgstr "返回由下层映射的值组成的一个新视图。"

#: ../../library/types.rst:418
msgid "Return a reverse iterator over the keys of the underlying mapping."
msgstr "返回一个包含下层映射的键的反向迭代器。"

#: ../../library/types.rst:424
msgid "Return a hash of the underlying mapping."
msgstr "返回下层映射的哈希值。"

#: ../../library/types.rst:430
msgid "The type of :ref:`capsule objects <capsules>`."
msgstr ":ref:`capsule 对象 <capsules>` 的类型。"

#: ../../library/types.rst:436
msgid "Additional Utility Classes and Functions"
msgstr "附加工具类和函数"

#: ../../library/types.rst:440
msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr "一个简单的 :class:`object` 子类，提供了访问其命名空间的属性，以及一个有意义的 repr。"

#: ../../library/types.rst:443
msgid ""
"Unlike :class:`object`, with :class:`!SimpleNamespace` you can add and "
"remove attributes."
msgstr "与 :class:`object` 不同的是，对于 :class:`!SimpleNamespace` 你可以添加和移除属性。"

#: ../../library/types.rst:446
msgid ""
":py:class:`SimpleNamespace` objects may be initialized in the same way as "
":class:`dict`: either with keyword arguments, with a single positional "
"argument, or with both. When initialized with keyword arguments, those are "
"directly added to the underlying namespace. Alternatively, when initialized "
"with a positional argument, the underlying namespace will be updated with "
"key-value pairs from that argument (either a mapping object or an "
":term:`iterable` object producing key-value pairs). All such keys must be "
"strings."
msgstr ""
":py:class:`SimpleNamespace` 对象可以使用与 :class:`dict` "
"相同的方式来初始化：关键字参数、单个位置参数或者两者兼有。 当使用关键字参数来初始化时，参数值会被直接加入到下层的命名空间。 "
"而当使用一个位置参数来初始化时，下层的命名空间将以来自该参数（为一个映射对象或是产生键值对的 :term:`iterable` 对象）的键值对来更新。 "
"所有这样的键都必须为字符串。"

#: ../../library/types.rst:457
msgid "The type is roughly equivalent to the following code::"
msgstr "此类型大致等价于以下代码::"

#: ../../library/types.rst:459
msgid ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"
msgstr ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"

#: ../../library/types.rst:473
msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""
"``SimpleNamespace`` 可被用于替代 ``class NS: pass``。 但是，对于结构化记录类型则应改用 "
":func:`~collections.namedtuple`。"

#: ../../library/types.rst:477
msgid ""
":class:`!SimpleNamespace` objects are supported by :func:`copy.replace`."
msgstr ":class:`!SimpleNamespace` 对象受到 :func:`copy.replace` 的支持。"

#: ../../library/types.rst:481
msgid ""
"Attribute order in the repr changed from alphabetical to insertion (like "
"``dict``)."
msgstr "repr 中的属性顺序由字母顺序改为插入顺序 (类似 ``dict``)。"

#: ../../library/types.rst:485
msgid "Added support for an optional positional argument."
msgstr "增加了对可选的位置参数的支持。"

#: ../../library/types.rst:490
msgid "Route attribute access on a class to __getattr__."
msgstr "在类上访问 __getattr__ 的路由属性。"

#: ../../library/types.rst:492
msgid ""
"This is a descriptor, used to define attributes that act differently when "
"accessed through an instance and through a class.  Instance access remains "
"normal, but access to an attribute through a class will be routed to the "
"class's __getattr__ method; this is done by raising AttributeError."
msgstr ""
"这是一个描述器，用于定义通过实例与通过类访问时具有不同行为的属性。 当实例访问时保持正常行为，但当类访问属性时将被路由至类的 __getattr__ "
"方法；这是通过引发 AttributeError 来完成的。"

#: ../../library/types.rst:497
msgid ""
"This allows one to have properties active on an instance, and have virtual "
"attributes on the class with the same name (see :class:`enum.Enum` for an "
"example)."
msgstr "这允许有在实例上激活的特性属性，同时又有在类上的同名虚拟属性 (一个例子请参见 :class:`enum.Enum`)。"

#: ../../library/types.rst:504
msgid "Coroutine Utility Functions"
msgstr "协程工具函数"

#: ../../library/types.rst:508
msgid ""
"This function transforms a :term:`generator` function into a "
":term:`coroutine function` which returns a generator-based coroutine. The "
"generator-based coroutine is still a :term:`generator iterator`, but is also"
" considered to be a :term:`coroutine` object and is :term:`awaitable`.  "
"However, it may not necessarily implement the :meth:`~object.__await__` "
"method."
msgstr ""
"此函数可将 :term:`generator` 函数转换为一个返回基于生成器的协程的 :term:`coroutine function`。 "
"基于生成器的协程仍然属于 :term:`generator iterator`，但同时又可被视为 :term:`coroutine` 对象兼 "
":term:`awaitable`。 不过，它没有必要实现 :meth:`~object.__await__` 方法。"

#: ../../library/types.rst:515
msgid "If *gen_func* is a generator function, it will be modified in-place."
msgstr "如果 *gen_func* 是一个生成器函数，它将被原地修改。"

#: ../../library/types.rst:517
msgid ""
"If *gen_func* is not a generator function, it will be wrapped. If it returns"
" an instance of :class:`collections.abc.Generator`, the instance will be "
"wrapped in an *awaitable* proxy object.  All other types of objects will be "
"returned as is."
msgstr ""
"如果 *gen_func* 不是一个生成器函数，则它会被包装。 如果它返回一个 :class:`collections.abc.Generator` "
"的实例，该实例将被包装在一个 *awaitable* 代理对象中。 所有其他对象类型将被原样返回。"

#: ../../library/types.rst:189
msgid "built-in function"
msgstr "内置函数"

#: ../../library/types.rst:189
msgid "compile"
msgstr "编译"
