# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- 日志处理程序"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**源代码:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr "此页面仅包含参考信息。有关教程，请参阅"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基础教程 <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`进阶教程 <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`日志记录操作手册 <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and "
":class:`NullHandler`) are actually defined in the :mod:`logging` module "
"itself, but have been documented here along with the other handlers."
msgstr ""
"这个包提供了以下有用的处理程序。 请注意有三个处理程序类 (:class:`StreamHandler`, :class:`FileHandler` 和"
" :class:`NullHandler`) 实际上是在 :mod:`logging` 模块本身定义的，但其文档与其他处理程序一同记录在此。"

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports "
":meth:`write` and :meth:`flush` methods)."
msgstr ""
":class:`StreamHandler` 类位于核心 :mod:`logging` 包，它可将日志记录输出发送到数据流例如 "
"*sys.stdout*, *sys.stderr* 或任何文件型对象（或者更精确地说，任何支持 :meth:`write` 和 "
":meth:`flush` 方法的对象）。"

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, "
"*sys.stderr* will be used."
msgstr ""
"返回一个新的 :class:`StreamHandler` 类。 如果指定了 *stream*，则实例将用它作为日志记录输出；在其他情况下将使用 "
"*sys.stderr*。"

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using "
":func:`traceback.print_exception` and appended to the stream."
msgstr ""
"如果指定了一个格式化器，它会被用来格式化记录。 随后记录会被写入到 :attr:`terminator` 之后的流中。 如果存在异常信息，则会使用 "
":func:`traceback.print_exception` 来格式化并添加到流中。"

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the "
":meth:`close` method is inherited from :class:`~logging.Handler` and so does"
" no output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"通过调用流的 :meth:`flush` 方法来刷新它。 请注意 :meth:`close` 方法是继承自 "
":class:`~logging.Handler` 的所以没有输出，因此有时可能需要显式地调用 :meth:`flush`。"

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr "将实例的流设为指定值，如果两者不一致的话。 旧的流会在设置新的流之前被刷新。"

#: ../../library/logging.handlers.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "处理程序应当使用的流。"

#: ../../library/logging.handlers.rst:0
msgid "Returns"
msgstr "返回"

#: ../../library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "旧的流，如果流已被改变的话，如果未被改变则为 *None*。"

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr "当将已格式化的记录写入到流时被用作终止符的字符串。 默认值为 ``'\\n'``。"

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr "如果你不希望以换行符终止，你可以将处理程序类实例的 ``terminator`` 属性设为空字符串。"

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr "在较早的版本中，终止符被硬编码为 ``'\\n'``。"

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
":class:`FileHandler` 类位于核心 :mod:`logging` 包，它可将日志记录输出到磁盘文件中。 它从 "
":class:`StreamHandler` 继承了输出功能。"

#: ../../library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file"
" is opened and used as the stream for logging. If *mode* is not specified, "
"``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file"
" with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"返回一个 :class:`FileHandler` 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 *mode*，则会使用 "
"``'a'``。 如果 *encoding* 不为 ``None``，则会将其用作打开文件的编码格式。 如果 *delay* "
"为真值，则文件打开会被推迟至第一次调用 :meth:`emit` 时。 默认情况下，文件会无限增长。 如果指定了 "
"*errors*，它会被用于确定编码格式错误的处理方式。"

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr "除了字符串值，也接受 :class:`~pathlib.Path` 对象作为 *filename* 参数。"

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "增加了 *errors* 形参。"

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "关闭文件。"

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "将记录输出到文件。"

#: ../../library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr "请注意如果文件因日志记录在退出后终止而被关闭并且文件打开模式为 'w'，则记录将不会被发送 (参见 :issue:`42378`)。"

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
":class:`NullHandler` 类位于核心 :mod:`logging` 包，它不执行任何格式化或输出。 "
"它实际上是一个供库开发者使用的‘无操作’处理程序。"

#: ../../library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "返回一个 :class:`NullHandler` 类的新实例。"

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "此方法不执行任何操作。"

#: ../../library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr "此方法会对锁返回 ``None``，因为没有下层 I/O 的访问需要被序列化。"

#: ../../library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use "
":class:`NullHandler`."
msgstr "请参阅 :ref:`library-config` 了解有关如何使用 :class:`NullHandler` 的更多信息。"

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the "
":mod:`logging.handlers` module, is a :class:`FileHandler` which watches the "
"file it is logging to. If the file changes, it is closed and reopened using "
"the file name."
msgstr ""
":class:`WatchedFileHandler` 类位于 :mod:`logging.handlers` 模块，这个 "
":class:`FileHandler` 用于监视它所写入日志记录的文件。 如果文件发生变化，它会被关闭并使用文件名重新打开。"

#: ../../library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"发生文件更改可能是由于使用了执行文件轮换的程序例如 *newsyslog* 和 *logrotate*。 这个处理程序在 Unix/Linux "
"下使用，它会监视文件来查看自上次发出数据后是否有更改。 （如果文件的设备或 inode 发生变化就认为已被更改。） "
"如果文件被更改，则会关闭旧文件流，并再打开文件以获得新文件流。"

#: ../../library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows"
" open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"这个处理程序不适合在 Windows 下使用，因为在 Windows 下打开的日志文件无法被移动或改名 —— 日志记录会使用排他的锁来打开文件 —— "
"因此这样的处理程序是没有必要的。 此外，*ST_INO* 在 Windows 下不受支持；:func:`~os.stat` 将总是为该值返回零。"

#: ../../library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"返回一个 :class:`WatchedFileHandler` 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 "
"*mode*，则会使用 ``'a'``。 如果 *encoding* 不为 ``None``，则会将其用作打开文件的编码格式。 如果 *delay* "
"为真值，则文件打开会被推迟至第一次调用 :meth:`emit` 时。 默认情况下，文件会无限增长。 如果提供了 "
"*errors*，它会被用于确定编码格式错误的处理方式。"

#: ../../library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr "检查文件是否已更改。 如果已更改，则会刷新并关闭现有流然后重新打开文件，这通常是将记录输出到文件的先导操作。"

#: ../../library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr "将记录输出到文件，但如果文件已更改则会先调用 :meth:`reopenIfNeeded` 来重新打开它。"

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the "
":mod:`logging.handlers` module, is the base class for the rotating file "
"handlers, :class:`RotatingFileHandler` and "
":class:`TimedRotatingFileHandler`. You should not need to instantiate this "
"class, but it has attributes and methods you may need to override."
msgstr ""
":class:`BaseRotatingHandler` 类位于 :mod:`logging.handlers` 模块中，它是轮换文件处理程序类 "
":class:`RotatingFileHandler` 和 :class:`TimedRotatingFileHandler` 的基类。 "
"你不需要实例化此类，但它具有你可能需要重写的属性和方法。"

#: ../../library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "类的形参与 :class:`FileHandler` 的相同。 其属性有:"

#: ../../library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method"
" delegates to this callable. The parameters passed to the callable are those"
" passed to :meth:`rotation_filename`."
msgstr ""
"如果此属性被设为一个可调用对象，则 :meth:`rotation_filename` 方法会委托给该可调用对象。 传给该可调用对象的形参与传给 "
":meth:`rotation_filename` 的相同。"

#: ../../library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should"
" be as simple and as fast as possible. It should also return the same output"
" every time for a given input, otherwise the rollover behaviour may not work"
" as expected."
msgstr ""
"namer 函数会在轮换期间被多次调用，因此它应当尽可能的简单快速。 它还应当对给定的输入每次都返回相同的输出，否则轮换行为可能无法按预期工作。"

#: ../../library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files"
" whose names contain successive integers, so that rotation works as "
"expected, and :class:`TimedRotatingFileHandler` deletes old log files (based"
" on the ``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of "
":class:`TimedRotatingFileHandler` which overrides the "
":meth:`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the"
" custom naming scheme.)"
msgstr ""
"还有一点值得注意的是当使用命名器来保存文件名中要在轮换中使用的特定属性时必须小心处理。 例如，:class:`RotatingFileHandler` "
"会要求有一组名称中包含连续整数的日志文件，以便轮换的效果能满足预期，而 :class:`TimedRotatingFileHandler` "
"会通过确定要删除的最旧文件（根据传递纵使中处理器的初始化器的 ``backupCount`` 形参）来删除旧的日志文件。 "
"为了达成这样的效果，文件名应当是可以使用文件名的日期/时间部分来排序的，而且命名器需要遵循此排序。 （如果想使用不遵循此规则的命名器，则需要在一个重写了"
" :meth:`~TimedRotatingFileHandler.getFilesToDelete` 方法的 "
":class:`TimedRotatingFileHandler` 的子类中使用它以便与自定义的命名规则进行配合。）"

#: ../../library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed to"
" :meth:`rotate`."
msgstr ""
"如果此属性被设为一个可调用对象，则 :meth:`rotate` 方法会委托给该可调用对象。 传给该可调用对象的形参与传给 :meth:`rotate`"
" 的相同。"

#: ../../library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "当轮换时修改日志文件的文件名。"

#: ../../library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "提供该属性以便可以提供自定义文件名。"

#: ../../library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"默认实现会调用处理程序的 'namer' 属性，如果它是可调用对象的话，并传给它默认的名称。 如果该属性不是可调用对象 (默认值为 "
"``None``)，则将名称原样返回。"

#: ../../library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "日志文件的默认名称。"

#: ../../library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "当执行轮换时，轮换当前日志。"

#: ../../library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute"
" isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"默认实现会调用处理程序的 'rotator' 属性，如果它是可调用对象的话，并传给它 source 和 dest 参数。 如果该属性不是可调用对象 "
"(默认值为 ``None``)，则将源简单地重命名为目标。"

#: ../../library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr "源文件名。 这通常为基本文件名，例如 'test.log'。"

#: ../../library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, "
"e.g. 'test.log.1'."
msgstr "目标文件名。 这通常是源被轮换后的名称，例如 'test.log.1'。"

#: ../../library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and "
":class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"该属性存在的理由是让你不必进行子类化 —— 你可以使用与 :class:`RotatingFileHandler` 和 "
":class:`TimedRotatingFileHandler` 的实例相同的可调用对象。 如果 namer 或 rotator "
"可调用对象引发了异常，将会按照与 :meth:`emit` 调用期间的任何其他异常相同的方式来处理，例如通过处理程序的 "
":meth:`handleError` 方法。"

#: ../../library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can"
" override the methods."
msgstr "如果你需要对轮换进程执行更多的修改，你可以重写这些方法。"

#: ../../library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "请参阅 :ref:`cookbook-rotator-namer` 获取具体示例。"

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the "
":mod:`logging.handlers` module, supports rotation of disk log files."
msgstr ""
":class:`RotatingFileHandler` 类位于 :mod:`logging.handlers` 模块，它支持磁盘日志文件的轮换。"

#: ../../library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"返回一个 :class:`RotatingFileHandler` 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 "
"*mode*，则会使用 ``'a'``。 如果 *encoding* 不为 ``None``，则会将其用作打开文件的编码格式。 如果 *delay* "
"为真值，则文件打开会被推迟至第一次调用 :meth:`emit`。 默认情况下，文件会无限增长。 如果提供了 "
"*errors*，它会被用于确定编码格式错误的处理方式。"

#: ../../library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to "
":dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never"
" occurs, so you generally want to set *backupCount* to at least 1, and have "
"a non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of "
":file:`app.log`, you would get :file:`app.log`, :file:`app.log.1`, "
":file:`app.log.2`, up to :file:`app.log.5`. The file being written to is "
"always :file:`app.log`.  When this file is filled, it is closed and renamed "
"to :file:`app.log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, "
"etc. exist, then they are renamed to :file:`app.log.2`, :file:`app.log.3` "
"etc. respectively."
msgstr ""
"你可以使用 *maxBytes* 和 *backupCount* 值来允许文件以预定的大小执行 :dfn:`rollover`。 "
"当即将超出预定大小时，将关闭旧文件并打开一个新文件用于输出。 只要当前日志文件长度接近 *maxBytes* 就会发生轮换；但是如果 "
"*maxBytes* 或 *backupCount* 两者之一的值为零，就不会发生轮换，因此你通常要设置 *backupCount* 至少为 1，而 "
"*maxBytes* 不能为零。 当 *backupCount* 为非零值时，系统将通过为原文件名添加扩展名 '.1', '.2' 等来保存旧日志文件。"
" 例如，当 *backupCount* 为 5 而基本文件名为 :file:`app.log` 时，你将得到 :file:`app.log`, "
":file:`app.log.1`, :file:`app.log.2` 直至 :file:`app.log.5`。 当前被写入的文件总是 "
":file:`app.log`。 当此文件写满时，它会被关闭并重户名为 :file:`app.log.1`，而如果文件 "
":file:`app.log.1`, :file:`app.log.2` 等存在，则它们会被分别重命名为 :file:`app.log.2`, "
":file:`app.log.3` 等等。"

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "执行上文所描述的轮换。"

#: ../../library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "将记录输出到文件，以适应上文所描述的轮换。"

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the "
":mod:`logging.handlers` module, supports rotation of disk log files at "
"certain timed intervals."
msgstr ""
":class:`TimedRotatingFileHandler` 类位于 :mod:`logging.handlers` "
"模块，它支持基于特定时间间隔的磁盘日志文件轮换。"

#: ../../library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"返回一个新的 :class:`TimedRotatingFileHandler` 类实例。 指定的文件会被打开并用作日志记录的流。 "
"对于轮换操作它还会设置文件名前缀。 轮换的发生是基于 *when* 和 *interval* 的积。"

#: ../../library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr "你可以使用 *when* 来指定 *interval* 的类型。 可能的值列表如下。 请注意它们不是大小写敏感的。"

#: ../../library/logging.handlers.rst:376
msgid "Value"
msgstr "值"

#: ../../library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "间隔类型"

#: ../../library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "如果/如何使用 *atTime*"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
msgid "Seconds"
msgstr "秒"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
msgid "Ignored"
msgstr "忽略"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
msgid "Minutes"
msgstr "分钟"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
msgid "Hours"
msgstr "小时"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
msgid "Days"
msgstr "天"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "工作日(0=星期一)"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "用于计算初始轮换时间"

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
msgid ""
"Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "如果未指定 *atTime* 则在午夜执行轮换，否则将使用 *atTime*。"

#: ../../library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for"
" *interval* isn't used."
msgstr ""
"当使用基于星期的轮换时，星期一为 'W0'，星期二为 'W1'，以此类推直至星期日为 'W6'。 在这种情况下，传入的 *interval* "
"值不会被使用。"

#: ../../library/logging.handlers.rst:398
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format "
"``%Y-%m-%d_%H-%M-%S`` or a leading portion thereof, depending on the "
"rollover interval."
msgstr ""
"系统将通过为文件名添加扩展名来保存旧日志文件。 扩展名是基于日期和时间的，根据轮换间隔的长短使用 strftime 格式 "
"``%Y-%m-%d_%H-%M-%S`` 或是其中有变动的部分。"

#: ../../library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the"
" current time, is used to compute when the next rotation will occur."
msgstr "当首次计算下次轮换的时间时（即当处理程序被创建时），现有日志文件的上次被修改时间或者当前时间会被用来计算下次轮换的发生时间。"

#: ../../library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr "如果 *utc* 参数为真值，将使用 UTC 时间；否则会使用本地时间。"

#: ../../library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"如果 *backupCount* 不为零，则最多将保留 *backupCount* 个文件，而如果当轮换发生时创建了更多的文件，则最旧的文件会被删除。 "
"删除逻辑使用间隔时间来确定要删除的文件，因此改变间隔时间可能导致旧文件被继续保留。"

#: ../../library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to "
":meth:`emit`."
msgstr "如果 *delay* 为真值，则会将文件打开延迟到首次调用 :meth:`emit` 的时候。"

#: ../../library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover"
" is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"如果 *atTime* 不为 ``None``，则它必须是一个 ``datetime.time`` "
"的实例，该实例指定轮换在一天内的发生时间，用于轮换被设为“在午夜”或“在每星期的某一天”之类的情况。 请注意在这些情况下，*atTime* "
"值实际上会被用于计算 *初始* 轮换，而后续轮换将会通过正常的间隔时间计算来得出。"

#: ../../library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr "如果指定了 *errors*，它会被用来确定编码错误的处理方式。"

#: ../../library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once"
" a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"初始轮换时间的计算是在处理程序被初始化时执行的。 后续轮换时间的计算则仅在轮换发生时执行，而只有当提交输出时轮换才会发生。 "
"如果不记住这一点，你就可能会感到困惑。 "
"例如，如果设置时间间隔为“每分钟”，那并不意味着你总会看到（文件名中）带有间隔一分钟时间的日志文件；如果在应用程序执行期间，日志记录输出的生成频率高于每分钟一次，*那么*"
" 你可以预期看到间隔一分钟时间的日志文件。 "
"另一方面，如果（假设）日志记录消息每五分钟才输出一次，那么文件时间将会存在对应于没有输出（因而没有轮换）的缺失。"

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "添加了 *atTime* 形参。"

#: ../../library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr "将记录输出到文件，以适应上文所描述的轮换。"

#: ../../library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr "返回由应当作为轮转的一部分被删除的文件名组成的列表。 它们是由处理程序写入的最旧的备份日志文件的绝对路径。"

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
":class:`SocketHandler` 类位于 :mod:`logging.handlers` 模块，它会将日志记录输出发送到网络套接字。 "
"基类所使用的是 TCP 套接字。"

#: ../../library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"返回一个 :class:`SocketHandler` 类的新实例，该实例旨在与使用 *host* 与 *port* 给定地址的远程主机进行通信。"

#: ../../library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"如果 ``port`` 指定为 ``None``，会使用 ``host`` 中的值来创建一个 Unix 域套接字 —— 在其他情况下，则会创建一个 "
"TCP 套接字。"

#: ../../library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "关闭套接字。"

#: ../../library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a "
":class:`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` "
"function."
msgstr ""
"对记录的属性字典执行封存并以二进制格式将其写入套接字。 如果套接字存在错误，则静默地丢弃数据包。 如果连接在此之前丢失，则重新建立连接。 "
"要在接收端将记录解封并输出到 :class:`~logging.LogRecord`，请使用 "
":func:`~logging.makeLogRecord` 函数。"

#: ../../library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr "处理在 :meth:`emit` 期间发生的错误。 最可能的原因是连接丢失。 关闭套接字以便我们能在下次事件时重新尝试。"

#: ../../library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket "
"(:const:`socket.SOCK_STREAM`)."
msgstr ""
"这是一个工厂方法，它允许子类定义它们想要的套接字的准确类型。 默认实现会创建一个 TCP 套接字 "
"(:const:`socket.SOCK_STREAM`)。"

#: ../../library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details"
" of this operation are equivalent to::"
msgstr "将记录的属性字典封存为带有长度前缀的二进制格式，并将其返回以准备通过套接字进行传输。 此操作在细节上相当于::"

#: ../../library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them"
" on the receiving end, or alternatively you can disable unpickling of global"
" objects on the receiving end."
msgstr ""
"请注意封存操作不是绝对安全的。 如果你关心安全问题，你可能会想要重写此方法以实现更安全的机制。 例如，你可以使用 HMAC "
"对封存对象进行签名然后在接收端验证它们，或者你也可以在接收端禁用全局对象的解封操作。"

#: ../../library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for "
":meth:`~SocketHandler.makePickle`."
msgstr ""
"将封存后的字节串 *packet* 发送到套接字。 所发送字节串的格式与 :meth:`~SocketHandler.makePickle` "
"文档中的描述一致。"

#: ../../library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is"
" busy."
msgstr "此函数允许部分发送，这可能会在网络繁忙时发生。"

#: ../../library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"尝试创建一个套接字；失败时将使用指数化回退算法处理。 在失败初次发生时，处理程序将丢弃它正尝试发送的消息。 "
"当后续消息交由同一实例处理时，它将不会尝试连接直到经过一段时间以后。 "
"默认形参设置为初始延迟一秒，如果在延迟之后连接仍然无法建立，处理程序将每次把延迟翻倍直至达到 30 秒的最大值。"

#: ../../library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "此行为由下列处理程序属性控制:"

#: ../../library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (初始延迟，默认为 1.0 秒)。"

#: ../../library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (倍数，默认为 2.0)。"

#: ../../library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (最大延迟，默认为 30.0 秒)。"

#: ../../library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"这意味着如果远程监听器在处理程序被使用 *之后* 启动，你可能会丢失消息（因为处理程序在延迟结束之前甚至不会尝试连接，而在延迟期间静默地丢弃消息）。"

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
":class:`DatagramHandler` 类位于 :mod:`logging.handlers` 模块，它继承自 "
":class:`SocketHandler`，支持通过 UDP 套接字发送日志记录消息。"

#: ../../library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"返回一个 :class:`DatagramHandler` 类的新实例，该实例旨在与使用 *host* 与 *port* 给定地址的远程主机进行通信。"

#: ../../library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"由于 UDP 不是流式协议，在该处理器与 *host* 之前不存在持久连接。 因为这个原因，当使用网络套接字时，每当有事件被写入日志时都可能要进行 "
"DNS 查询，这会给系统带来一些延迟。 如果这对你有影响，你可以自己执行查询并使用已查询到的 IP 地址而不是主机名来初始化这个处理器。"

#: ../../library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"如果 ``port`` 指定为 ``None``，会使用 ``host`` 中的值来创建一个 Unix 域套接字 —— 在其他情况下，则会创建一个 "
"UDP 套接字。"

#: ../../library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a "
":class:`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` "
"function."
msgstr ""
"对记录的属性字典执行封存并以二进制格式将其写入套接字。 如果套接字存在错误，则静默地丢弃数据包。 要在接收端将记录解封并输出到 "
":class:`~logging.LogRecord`，请使用 :func:`~logging.makeLogRecord` 函数。"

#: ../../library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
":class:`SocketHandler` 的工厂方法会在此被重写以创建一个 UDP 套接字 "
"(:const:`socket.SOCK_DGRAM`)。"

#: ../../library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr "将封存后的字节串发送到套接字。 所发送字节串的格式与 :meth:`SocketHandler.makePickle` 文档中的描述一致。"

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
":class:`SysLogHandler` 类位于 :mod:`logging.handlers` 模块，它支持将日志记录消息发送到远程或本地 "
"Unix syslog。"

#: ../../library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as"
" a string, for example '/dev/log'. In this case, a Unix domain socket is "
"used to send the message to the syslog. If *facility* is not specified, "
":const:`LOG_USER` is used. The type of socket opened depends on the "
"*socktype* argument, which defaults to :const:`socket.SOCK_DGRAM` and thus "
"opens a UDP socket. To open a TCP socket (for use with the newer syslog "
"daemons such as rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"返回一个 :class:`SysLogHandler` 类的新实例用来与通过 *address* 以 ``(host, port)`` "
"元组形式给出地址的远程 Unix 机器进行通讯。 如果未指定 *address*，则使用 ``('localhost', 514)``。 "
"该地址会被用于打开套接字。 提供 ``(host, port)`` 元组的一种替代方式是提供字符串形式的地址，例如 '/dev/log'。 "
"在这种情况下，会使用 Unix 域套接字将消息发送到 syslog。 如果未指定 *facility*，则使用 :const:`LOG_USER`。 "
"打开的套接字类型取决于 *socktype* 参数，该参数的默认值为 :const:`socket.SOCK_DGRAM` 即打开一个 UDP 套接字。"
" 要打开一个 TCP 套接字（用来配合较新的 syslog 守护程序例如 rsyslog 使用），请指定值为 "
":const:`socket.SOCK_STREAM`。"

#: ../../library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, "
":class:`SysLogHandler` may appear not to work. In that case, check what "
"address you should be using for a domain socket - it's system dependent. For"
" example, on Linux it's usually '/dev/log' but on OS/X it's "
"'/var/run/syslog'. You'll need to check your platform and use the "
"appropriate address (you may need to do this check at runtime if your "
"application needs to run on several platforms). On Windows, you pretty much "
"have to use the UDP option."
msgstr ""
"请注意如果你的服务器不是在 UDP 端口 514 上进行侦听，则 :class:`SysLogHandler` 可能无法正常工作。 "
"在这种情况下，请检查你应当为域套接字所使用的地址 —— 它依赖于具体的系统。 例如，在 Linux 上通常为 '/dev/log' 而在 OS/X "
"上则为 '/var/run/syslog'。 "
"你需要检查你的系统平台并使用适当的地址（如果你的应用程序需要在多个平台上运行则可能需要在运行时进行这样的检查）。 在 Windows "
"上，你大概必须要使用 UDP 选项。"

#: ../../library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"在 macOS 12.x (Monterey) 上，Apple 修改了其 syslog 守护进程的行为 —— 它不再监听某个域套接字。 "
"因此，你不能再预期 :class:`SysLogHandler` 在此系统上有效。"

#: ../../library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr "请参阅 :gh:`91070` 了解更多信息。"

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "添加了 *socktype*。"

#: ../../library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "关闭连接远程主机的套接字。"

#: ../../library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's"
" not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if there is no "
"socket at that point."
msgstr ""
"尝试创建一个套接字，如果它不是一个数据报套接字，则将其连接到另一端。 此方法会在处理器初始化期间被调用，但是如果此时另一端还没有监听则它不会被视为出错 "
"—— 如果此时套接字还不存在，此方法将在发出事伯时再次被调用。"

#: ../../library/logging.handlers.rst:665
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr "记录会被格式化，然后发送到 syslog 服务器。 如果存在异常信息，则它 *不会* 被发送到服务器。"

#: ../../library/logging.handlers.rst:668
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(参见: :issue:`12168`。) 在较早的版本中，发送至 syslog 守护程序的消息总是以一个 NUL "
"字节结束，因为守护程序的早期版本期望接收一个以 NUL 结束的消息 —— 即使它不包含于对应的规范说明 (:rfc:`5424`)。 "
"这些守护程序的较新版本不再期望接收 NUL 字节，如果其存在则会将其去除，而最新的守护程序（更紧密地遵循 RFC 5424）会将 NUL "
"字节作为消息的一部分传递出去。"

#: ../../library/logging.handlers.rst:677
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set"
" to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"为了在面对所有这些不同守护程序行为时能够更方便地处理 syslog 消息，通过使用类层级属性 ``append_nul``，添加 NUL "
"字节的操作已被作为可配置项。 该属性默认为 ``True`` (保留现有行为) 但可在 ``SysLogHandler`` 实例上设为 "
"``False`` 以便让实例 *不会* 添加 NUL 结束符。"

#: ../../library/logging.handlers.rst:684
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(参见: :issue:`12419`。) 在较早的版本中，没有 \"ident\" 或 \"tag\" 前缀工具可以用来标识消息的来源。 "
"现在则可以使用一个类层级属性来设置它，该属性默认为 ``\"\"`` 表示保留现有行为，但可在 ``SysLogHandler`` "
"实例上重写以便让实例不会为所处理的每条消息添加标识。 请注意所提供的标识必须为文本而非字节串，并且它会被原封不动地添加到消息中。"

#: ../../library/logging.handlers.rst:695
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr "将功能和优先级编码为一个整数。 你可以传入字符串或者整数 —— 如果传入的是字符串，则会使用内部的映射字典将其转换为整数。"

#: ../../library/logging.handlers.rst:699
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"符号 ``LOG_`` 的值在 :class:`SysLogHandler` 中定义并且是 ``sys/syslog.h`` 头文件中所定义值的镜像。"

#: ../../library/logging.handlers.rst:702
msgid "**Priorities**"
msgstr "**优先级**"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Name (string)"
msgstr "名称（字符串）"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Symbolic value"
msgstr "符号值"

#: ../../library/logging.handlers.rst:707
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:707
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:709
msgid "``crit`` or ``critical``"
msgstr "``crit`` 或 ``critical``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:711
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:713
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` 或 ``panic``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:715
msgid "``err`` or ``error``"
msgstr "``err`` 或 ``error``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:717
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:719
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:721
msgid "``warn`` or ``warning``"
msgstr "``warn`` 或 ``warning``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:724
msgid "**Facilities**"
msgstr "**设备**"

#: ../../library/logging.handlers.rst:729
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:729
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:731
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:733
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:735
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:737
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:739
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:741
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:743
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:745
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:747
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:749
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:751
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:753
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:755
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:757
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:759
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:761
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:763
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:765
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:767
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:772
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is"
" not suitable for your needs. The default algorithm maps ``DEBUG``, "
"``INFO``, ``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog "
"names, and all other level names to 'warning'."
msgstr ""
"将日志记录级别名称映射到 syslog 优先级名称。 如果你使用自定义级别，或者如果默认算法不适合你的需要，你可能需要重写此方法。 默认算法将 "
"``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` 和 ``CRITICAL`` 映射到等价的 syslog "
"名称，并将所有其他级别名称映射到 'warning'。"

#: ../../library/logging.handlers.rst:782
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:784
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers`"
" module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's"
" Win32 extensions for Python installed."
msgstr ""
":class:`NTEventLogHandler` 类位于 :mod:`logging.handlers` 模块，它支持将日志记录消息发送到本地 "
"Windows NT, Windows 2000 或 Windows XP 事件日志。 在你使用它之前，你需要安装 Mark Hammond 的 "
"Python Win32 扩展。"

#: ../../library/logging.handlers.rst:792
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname*"
" should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, "
"``'win32service.pyd'`` is used - this is installed with the Win32 extensions"
" and contains some basic placeholder message definitions. Note that use of "
"these placeholders will make your event logs big, as the entire message "
"source is held in the log. If you want slimmer logs, you have to pass in the"
" name of your own .dll or .exe which contains the message definitions you "
"want to use in the event log). The *logtype* is one of ``'Application'``, "
"``'System'`` or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"返回一个 :class:`NTEventLogHandler` 类的新实例。 *appname* 用来定义出现在事件日志中的应用名称。 "
"将使用此名称创建适当的注册表条目。 *dllname* 应当给出要包含在日志中的消息定义的 .dll 或 .exe 的完整限定路径名称（如未指定则会使用"
" ``'win32service.pyd'`` —— 此文件随 Win32 扩展安装且包含一些基本的消息定义占位符。 "
"请注意使用这些占位符将使你的事件日志变得很大，因为整个消息源都会被放入日志。 "
"如果你希望有较小的日志，你必须自行传入包含你想要在事件日志中使用的消息定义的 .dll 或 .exe 名称）。 *logtype* 为 "
"``'Application'``, ``'System'`` 或 ``'Security'`` 之一，且默认值为 ``'Application'``。"

#: ../../library/logging.handlers.rst:808
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"这时，你就可以从注册表中移除作为事件日志条目来源的应用名称。 但是，如果你这样做，你将无法如你所预期的那样在事件日志查看器中看到这些事件 —— "
"它必须能访问注册表来获取 .dll 名称。 当前版本并不会这样做。"

#: ../../library/logging.handlers.rst:817
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr "确定消息 ID，事件类别和事件类型，然后将消息记录到 NT 事件日志中。"

#: ../../library/logging.handlers.rst:823
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr "返回记录的事件类别。 如果你希望指定你自己的类别就要重写此方法。 此版本将返回 0。"

#: ../../library/logging.handlers.rst:829
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, "
":const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"返回记录的事件类型。 如果你希望指定你自己的类型就要重写此方法。 此版本将使用处理程序的 typemap 属性来执行映射，该属性在 "
":meth:`__init__` 被设置为一个字典，其中包含 :const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR` 和 :const:`CRITICAL` 的映射。 "
"如果你使用你自己的级别，你将需要重写此方法或者在处理程序的 *typemap* 属性中放置一个合适的字典。"

#: ../../library/logging.handlers.rst:840
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"返回记录的消息 ID。 如果你使用你自己的消息，你可以通过将 *msg* 传给日志记录器作为 ID 而非格式字符串实现此功能。 "
"然后，你可以在这里使用字典查找来获取消息 ID。 此版本将返回 1，是 :file:`win32service.pyd` 中的基本消息 ID。"

#: ../../library/logging.handlers.rst:849
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:851
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
":class:`SMTPHandler` 类位于 :mod:`logging.handlers` 模块，它支持将日志记录消息通过 SMTP "
"发送到一个电子邮件地址。"

#: ../../library/logging.handlers.rst:857
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"返回一个 :class:`SMTPHandler` 类的新实例。 该实例使用电子邮件的发件人、收件人地址和主题行进行初始化。 *toaddrs* "
"应当为字符串列表。 要指定一个非标准 SMTP 端口，请使用 (host, port) 元组格式作为 *mailhost* 参数。 "
"如果你使用一个字符串，则会使用标准 SMTP 端口。 如果你的 SMTP 服务器要求验证，你可以指定一个 (username, password) "
"元组作为 *credentials* 参数。"

#: ../../library/logging.handlers.rst:864
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the "
":meth:`smtplib.SMTP.starttls` method.)"
msgstr ""
"要指定使用安全协议 (TLS)，请传入一个元组作为 *secure* 参数。 这将仅在提供了验证凭据时才能被使用。 "
"元组应当或是一个空元组，或是一个包含密钥文件名的单值元组，或是一个包含密钥文件和证书文件的 2 值元组。 （此元组会被传给 "
":meth:`smtplib.SMTP.starttls` 方法。）"

#: ../../library/logging.handlers.rst:871
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr "可以使用 *timeout* 参数为与 SMTP 服务器的通信指定超时限制。"

#: ../../library/logging.handlers.rst:874
msgid "Added the *timeout* parameter."
msgstr "增加了 *timeout* 形参。"

#: ../../library/logging.handlers.rst:879
msgid "Formats the record and sends it to the specified addressees."
msgstr "对记录执行格式化并将其发送到指定的地址。"

#: ../../library/logging.handlers.rst:884
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr "如果你想要指定一个基于记录的主题行，请重写此方法。"

#: ../../library/logging.handlers.rst:890
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:892
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
":class:`MemoryHandler` 类位于 :mod:`logging.handlers` 模块，它支持在内存中缓冲日志记录，并定期将其刷新到"
" :dfn:`target` 处理程序中。 刷新会在缓冲区满的时候，或是在遇到特定或更高严重程度事件的时候发生。"

#: ../../library/logging.handlers.rst:897
msgid ""
":class:`MemoryHandler` is a subclass of the more general "
":class:`BufferingHandler`, which is an abstract class. This buffers logging "
"records in memory. Whenever each record is added to the buffer, a check is "
"made by calling :meth:`shouldFlush` to see if the buffer should be flushed."
"  If it should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` 是更通用的 :class:`BufferingHandler` 的子类，后者属于抽象类。 "
"它会在内存中缓冲日志记录。 当每条记录被添加到缓冲区时，会通过调用 :meth:`shouldFlush` 来检查缓冲区是否应当刷新。 "
"如果应当刷新，则要使用 :meth:`flush` 来执行刷新。"

#: ../../library/logging.handlers.rst:906
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr "使用指定容量的缓冲区初始化处理程序。 这里，*capacity* 是指缓冲的日志记录数量。"

#: ../../library/logging.handlers.rst:912
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call "
":meth:`flush` to process the buffer."
msgstr "将记录添加到缓冲区。 如果 :meth:`shouldFlush` 返回真值，则会调用 :meth:`flush` 来处理缓冲区。"

#: ../../library/logging.handlers.rst:918
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the "
"buffer to an empty list. This method can be overwritten to implement more "
"useful flushing behavior."
msgstr ""
"对于 :class:`BufferingHandler` 的实例，刷新意味着将缓冲区设为一个空列表。 此方法可被覆盖以实现更有用的刷新行为。"

#: ../../library/logging.handlers.rst:925
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr "如果缓冲区容量已满则返回 ``True``。 可以重写此方法以实现自定义的刷新策略。"

#: ../../library/logging.handlers.rst:931
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"返回一个 :class:`MemoryHandler` 类的新实例。 该实例使用 *capacity* 指定的缓冲区大小（要缓冲的记录数量）来初始化。 "
"如果 *flushLevel* 未指定，则使用 :const:`ERROR`。 如果未指定 *target*，则需要在此处理程序执行任何实际操作之前使用"
" :meth:`setTarget` 来设置目标。 如果 *flushOnClose* 指定为 ``False``，则当处理程序被关闭时 *不会* "
"刷新缓冲区。 如果未指定或指定为 ``True``，则当处理程序被关闭时将会发生之前的缓冲区刷新行为。"

#: ../../library/logging.handlers.rst:940
msgid "The *flushOnClose* parameter was added."
msgstr "增加了 *flushOnClose* 形参。"

#: ../../library/logging.handlers.rst:946
msgid ""
"Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr "调用 :meth:`flush`，设置目标为 ``None`` 并清空缓冲区。"

#: ../../library/logging.handlers.rst:952
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also cleared "
"when buffered records are sent to the target. Override if you want different"
" behavior."
msgstr ""
"对于 :class:`MemoryHandler` 的实例，刷新意味着将缓冲的记录发送到目标，如果目标存在的话。 "
"当缓冲的记录被发送到目标时缓冲区也将被清空。 如果你想要不同的行为请重写此方法。"

#: ../../library/logging.handlers.rst:959
msgid "Sets the target handler for this handler."
msgstr "设置此处理程序的目标处理程序。"

#: ../../library/logging.handlers.rst:964
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr "检测缓冲区是否已满或是有记录为 *flushLevel* 或更高级别。"

#: ../../library/logging.handlers.rst:970
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:972
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
":class:`HTTPHandler` 类位于 :mod:`logging.handlers` 模块，它支持使用 ``GET`` 或 ``POST``"
" 语义将日志记录消息发送到 Web 服务器。"

#: ../../library/logging.handlers.rst:979
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a "
":class:`ssl.SSLContext` instance to configure the SSL settings used for the "
"HTTPS connection. If *credentials* is specified, it should be a 2-tuple "
"consisting of userid and password, which will be placed in a HTTP "
"'Authorization' header using Basic authentication. If you specify "
"credentials, you should also specify secure=True so that your userid and "
"password are not passed in cleartext across the wire."
msgstr ""
"返回一个 :class:`HTTPHandler` 类的新实例。 *host* 可以为 ``host:port`` "
"的形式，如果你需要使用指定端口号的话。 如果没有指定 *method*，则会使用 ``GET``。 如果 *secure* 为真值，则将使用 HTTPS"
" 连接。 *context* 形参可以设为一个 :class:`ssl.SSLContext` 实例以配置用于 HTTPS 连接的 SSL 设置。 "
"如果指定了 *credentials*，它应当为包含 userid 和 password 的二元组，该元组将被放入使用 Basic 验证的 HTTP "
"'Authorization' 标头中。 如果你指定了 credentials，你还应当指定 secure=True 这样你的 userid 和 "
"password 就不会以明文在线路上传输。"

#: ../../library/logging.handlers.rst:990
msgid "The *context* parameter was added."
msgstr "增加了 *context* 形参。"

#: ../../library/logging.handlers.rst:995
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns "
"``record.__dict__``. This method can be overridden if e.g. only a subset of "
":class:`~logging.LogRecord` is to be sent to the web server, or if more "
"specific customization of what's sent to the server is required."
msgstr ""
"基于 ``record`` 提供一个字典，它将被执行 URL 编码并发送至 Web 服务器。 默认实现仅返回 ``record.__dict__``。 "
"在只需将 :class:`~logging.LogRecord` 的某个子集发送至 Web "
"服务器，或者需要对发送至服务器的内容进行更多定制时可以重写此方法。"

#: ../../library/logging.handlers.rst:1003
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The "
":meth:`mapLogRecord` method is used to convert the record to the dictionary "
"to be sent."
msgstr "将记录以 URL 编码字典的形式发送至 Web 服务器。 :meth:`mapLogRecord` 方法会被用来将要发送的记录转换为字典。"

#: ../../library/logging.handlers.rst:1007
msgid ""
"Since preparing a record for sending it to a web server is not the same as a"
" generic formatting operation, using :meth:`~logging.Handler.setFormatter` "
"to specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode"
" the dictionary in a form suitable for sending to a web server."
msgstr ""
"由于记录发送至 Web 服务器所需的预处理与通用的格式化操作不同，使用 :meth:`~logging.Handler.setFormatter` "
"来指定一个 :class:`~logging.Formatter` 用于 :class:`HTTPHandler` 是没有效果的。 此处理程序不会调用 "
":meth:`~logging.Handler.format`，而是调用 :meth:`mapLogRecord` 然后再调用 "
":func:`urllib.parse.urlencode` 来以适合发送至 Web 服务器的形式对字典进行编码。"

#: ../../library/logging.handlers.rst:1020
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1024
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":class:`QueueHandler` 类位于 :mod:`logging.handlers` 模块，它支持将日志记录消息发送到一个队列，例如在 "
":mod:`queue` 或 :mod:`multiprocessing` 模块中实现的队列。"

#: ../../library/logging.handlers.rst:1028
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"配合 :class:`QueueListener` 类使用，:class:`QueueHandler` "
"可被用来使处理程序在与执行日志记录的线程不同的线程上完成工作。 这对 Web "
"应用程序以及其他服务于客户端的线程需要尽可能快地响应的服务应用程序来说很重要，任何潜在的慢速操作（例如通过 :class:`SMTPHandler` "
"发送邮件）都要在单独的线程上完成。"

#: ../../library/logging.handlers.rst:1037
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any "
"queue-like object; it's used as-is by the :meth:`enqueue` method, which "
"needs to know how to send messages to it. The queue is not *required* to "
"have the task tracking API, which means that you can use "
":class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"返回一个 :class:`QueueHandler` 类的新实例。 该实例使用队列来初始化以向其发送消息。 *queue* 可以为任何队列类对象；它由 "
":meth:`enqueue` 方法来使用，该方法需要知道如何向其发送消息。 队列 *不要求* 具有任务跟踪 API，这意味着你可以为 *queue* "
"使用 :class:`~queue.SimpleQueue` 实例。"

#: ../../library/logging.handlers.rst:1044
#: ../../library/logging.handlers.rst:1127
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using "
":class:`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
"如果你在使用 :mod:`multiprocessing`，则你应当避免使用 :class:`~queue.SimpleQueue` 而要改用 "
":class:`multiprocessing.Queue`。"

#: ../../library/logging.handlers.rst:1049
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur "
"(e.g. because a bounded queue has filled up), the "
":meth:`~logging.Handler.handleError` method is called to handle the error. "
"This can result in the record silently being dropped (if "
":data:`logging.raiseExceptions` is ``False``) or a message printed to "
"``sys.stderr`` (if :data:`logging.raiseExceptions` is ``True``)."
msgstr ""
"将准备 LogRecord 的结果排入队列。 如果发生了异常（例如由于有界队列已满），则会调用 "
":meth:`~logging.Handler.handleError` 方法来处理错误。 这可能导致记录被静默地丢弃 (当 "
":data:`logging.raiseExceptions` 为 ``False`` 时) 或者消息被打印到 ``sys.stderr`` (当 "
":data:`logging.raiseExceptions` 为 ``True`` 时)。"

#: ../../library/logging.handlers.rst:1058
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr "准备用于队列的记录。 此方法返回的对象会被排入队列。"

#: ../../library/logging.handlers.rst:1061
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's "
":attr:`msg` and :attr:`message` attributes with the merged message (obtained"
" by calling the handler's :meth:`format` method), and sets the :attr:`args`,"
" :attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"该基本实现会对记录进行格式化以合并消息、参数、异常和栈信息，如果它们存在的话。 它还会从记录中原地移除不可 pickle 的条目。 "
"具体来说，它会用合并后的消息（通过调用处理器的 :meth:`format` 方法获得）覆盖记录的 :attr:`msg` 和 "
":attr:`message` 属性，并将 :attr:`args`, :attr:`exc_info` 和 :attr:`exc_text` "
"属性设置为 ``None``。"

#: ../../library/logging.handlers.rst:1069
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr "如果你想要将记录转换为 dict 或 JSON 字符串，或者发送记录被修改后的副本而让初始记录保持原样，则你可能会想要重写此方法。"

#: ../../library/logging.handlers.rst:1073
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the "
":class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"该基本实现会使用这些参数对消息进行格式化，将 ``message`` 和 ``msg`` 属性设置为已格式化的消息并将 ``args`` 和 "
"``exc_text`` 属性设置为 ``None`` 以允许 pickle 操作并防止更多的格式化尝试。 这意味着 "
":class:`QueueListener` 一方的处理器将没有自定义格式化所需的信息，例如异常信息等。 你可能会想要子类化 "
"``QueueHandler`` 并重写此方法以便避免将 ``exc_text`` 设置为 ``None``。 请注意对 ``message`` / "
"``msg`` / ``args`` 的改变与确保记录可以 pickle 是相关联的，根据你的 ``args`` 是否可以 pickle "
"你将可能或不可能避免这样做。 （请注意你可能必须不仅要考虑你自己的代码还要考虑你所使用的任何库中的代码。）"

#: ../../library/logging.handlers.rst:1089
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr "使用 ``put_nowait()`` 将记录排入队列；如果你想要使用阻塞行为，或超时设置，或自定义的队列实现，则你可能会想要重写此方法。"

#: ../../library/logging.handlers.rst:1098
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1102
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While "
":class:`QueueListener` is not itself a handler, it is documented here "
"because it works hand-in-hand with :class:`QueueHandler`."
msgstr ""
":class:`QueueListener` 类位于 :mod:`logging.handlers` 模块，它支持从一个队列接收日志记录消息，例如在 "
":mod:`queue` 或 :mod:`multiprocessing` 模块中实现的队列。 "
"消息是在内部线程中从队列接收并在同一线程上传递到一个或多个处理程序进行处理的。 尽管 :class:`QueueListener` "
"本身并不是一个处理程序，但由于它要与 :class:`QueueHandler` 配合工作，因此也在此处介绍。"

#: ../../library/logging.handlers.rst:1110
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"配合 :class:`QueueHandler` 类使用，:class:`QueueListener` "
"可被用来使处理程序在与执行日志记录的线程不同的线程上完成工作。 这对 Web "
"应用程序以及其他服务于客户端的线程需要尽可能快地响应的服务应用程序来说很重要，任何潜在的慢速动作（例如通过 :class:`SMTPHandler` "
"发送邮件）都要在单独的线程上完成。"

#: ../../library/logging.handlers.rst:1119
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know"
" how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use "
":class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"返回一个 :class:`QueueListener` 类的新实例。 "
"该实例初始化时要传入一个队列以向其发送消息，还要传入一个处理程序列表用来处理放置在队列中的条目。 队列可以是任何队列类对象；它会被原样传给 "
":meth:`dequeue` 方法，该方法需要知道如何从其获取消息。 队列 *不要求* 具有任务跟踪 API（但如提供则会使用它），这意味着你可以为 "
"*queue* 使用 :class:`~queue.SimpleQueue` 实例。"

#: ../../library/logging.handlers.rst:1130
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"如果 ``respect_handler_level`` 为 "
"``True``，则在决定是否将消息传递给处理程序之前会遵循处理程序的级别（与消息的级别进行比较）；在其他情况下，其行为与之前的 Python 版本一致"
" —— 总是将每条消息传递给每个处理程序。"

#: ../../library/logging.handlers.rst:1135
msgid "The ``respect_handler_level`` argument was added."
msgstr "增加了 ``respect_handler_level`` 参数。"

#: ../../library/logging.handlers.rst:1140
msgid "Dequeues a record and return it, optionally blocking."
msgstr "从队列移出一条记录并将其返回，可以选择阻塞。"

#: ../../library/logging.handlers.rst:1142
msgid ""
"The base implementation uses ``get()``. You may want to override this method"
" if you want to use timeouts or work with custom queue implementations."
msgstr "基本实现使用 ``get()``。 如果你想要使用超时设置或自定义的队列实现，则你可能会想要重写此方法。"

#: ../../library/logging.handlers.rst:1148
msgid "Prepare a record for handling."
msgstr "准备一条要处理的记录。"

#: ../../library/logging.handlers.rst:1150
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"该实现只是返回传入的记录。 如果你想要对记录执行任何自定义的 marshal 操作或在将其传给处理程序之前进行调整，则你可能会想要重写此方法。"

#: ../../library/logging.handlers.rst:1156
msgid "Handle a record."
msgstr "处理一条记录。"

#: ../../library/logging.handlers.rst:1158
msgid ""
"This just loops through the handlers offering them the record to handle. The"
" actual object passed to the handlers is that which is returned from "
":meth:`prepare`."
msgstr "此方法简单地循环遍历处理程序，向它们提供要处理的记录。 实际传给处理程序的对象就是从 :meth:`prepare` 返回的对象。"

#: ../../library/logging.handlers.rst:1164
msgid "Starts the listener."
msgstr "启动监听器。"

#: ../../library/logging.handlers.rst:1166
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr "此方法启动一个后台线程来监视 LogRecords 队列以进行处理。"

#: ../../library/logging.handlers.rst:1171
msgid "Stops the listener."
msgstr "停止监听器。"

#: ../../library/logging.handlers.rst:1173
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that"
" if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"此方法要求线程终止，然后等待它完成终止操作。 请注意在你的应用程序退出之前如果你没有调用此方法，则可能会有一些记录在留在队列中，它们将不会被处理。"

#: ../../library/logging.handlers.rst:1179
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"将一个标记写入队列以通知监听器退出。 此实现会使用 ``put_nowait()``。 "
"如果你想要使得超时设置或自定义的队列实现，则你可能会想要重写此方法。"

#: ../../library/logging.handlers.rst:1190
msgid "Module :mod:`logging`"
msgstr "模块 :mod:`logging`"

#: ../../library/logging.handlers.rst:1190
msgid "API reference for the logging module."
msgstr "日志记录模块的 API 参考。"

#: ../../library/logging.handlers.rst:1192
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模块"

#: ../../library/logging.handlers.rst:1193
msgid "Configuration API for the logging module."
msgstr "日志记录模块的配置 API 。"
