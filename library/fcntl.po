# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# nick <2330458484@qq.com>, 2021
# allenjuly7 <allenjuly7@astu.fun>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2024
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/fcntl.rst:2
msgid ":mod:`!fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ":mod:`!fcntl` --- ``fcntl`` 和 ``ioctl`` 系统调用"

#: ../../library/fcntl.rst:16
msgid ""
"This module performs file and I/O control on file descriptors. It is an "
"interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines. See the "
":manpage:`fcntl(2)` and :manpage:`ioctl(2)` Unix manual pages for full "
"details."
msgstr ""
"本模块基于文件描述符来执行文件和 I/O 控制。 它是 :c:func:`fcntl` 和 :c:func:`ioctl` Unix 例程的接口。 "
"请参阅 :manpage:`fcntl(2)` 和 :manpage:`ioctl(2)` Unix 手册页了解详情。"

#: ../../library/fcntl.rst:21
msgid "Availability"
msgstr "Availability"

#: ../../library/fcntl.rst:23
msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by "
"``sys.stdin.fileno()``, or an :class:`io.IOBase` object, such as "
"``sys.stdin`` itself, which provides a :meth:`~io.IOBase.fileno` that "
"returns a genuine file descriptor."
msgstr ""
"本模块的所有函数都接受文件描述符 *fd* 作为第一个参数。可以是一个整数形式的文件描述符，比如 ``sys.stdin.fileno()`` "
"的返回结果，或为 :class:`io.IOBase` 对象，比如 ``sys.stdin`` 提供一个 "
":meth:`~io.IOBase.fileno`，可返回一个真正的文件描述符。"

#: ../../library/fcntl.rst:29
msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr "本模块的操作以前触发的是 :exc:`IOError`，现在则会触发 :exc:`OSError`。"

#: ../../library/fcntl.rst:33
msgid ""
"The :mod:`!fcntl` module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, and "
"``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
":mod:`!fcntl` 模块现在包含 ``F_ADD_SEALS``, ``F_GET_SEALS`` 和 ``F_SEAL_*`` 常量用于 "
":func:`os.memfd_create` 文件描述符的封包。"

#: ../../library/fcntl.rst:38
msgid ""
"On macOS, the :mod:`!fcntl` module exposes the ``F_GETPATH`` constant, which"
" obtains the path of a file from a file descriptor. On Linux(>=3.15), the "
":mod:`!fcntl` module exposes the ``F_OFD_GETLK``, ``F_OFD_SETLK`` and "
"``F_OFD_SETLKW`` constants, which are used when working with open file "
"description locks."
msgstr ""
"在 macOS 上，:mod:`!fcntl` 模块暴露了 ``F_GETPATH`` 常量，它可从文件描述符获取文件的路径。 在 "
"Linux(>=3.15) 上，:mod:`!fcntl` 模块暴露了 ``F_OFD_GETLK``, ``F_OFD_SETLK`` 和 "
"``F_OFD_SETLKW`` 常量，它们将在处理打开文件描述锁时被使用。"

#: ../../library/fcntl.rst:45
msgid ""
"On Linux >= 2.6.11, the :mod:`!fcntl` module exposes the ``F_GETPIPE_SZ`` "
"and ``F_SETPIPE_SZ`` constants, which allow to check and modify a pipe's "
"size respectively."
msgstr ""
"在 Linux >= 2.6.11 中，:mod:`!fcntl` 模块暴露了 ``F_GETPIPE_SZ`` 和 ``F_SETPIPE_SZ`` "
"常量，它们分别允许检查和修改管道的大小。"

#: ../../library/fcntl.rst:50
msgid ""
"On FreeBSD, the :mod:`!fcntl` module exposes the ``F_DUP2FD`` and "
"``F_DUP2FD_CLOEXEC`` constants, which allow to duplicate a file descriptor, "
"the latter setting ``FD_CLOEXEC`` flag in addition."
msgstr ""
"在 FreeBSD 上，:mod:`!fcntl` 模块会暴露 ``F_DUP2FD`` 和 ``F_DUP2FD_CLOEXEC`` "
"常量，它们允许复制文件描述符，后者还额外设置了 ``FD_CLOEXEC`` 旗标。"

#: ../../library/fcntl.rst:55
msgid ""
"On Linux >= 4.5, the :mod:`fcntl` module exposes the ``FICLONE`` and "
"``FICLONERANGE`` constants, which allow to share some data of one file with "
"another file by reflinking on some filesystems (e.g., btrfs, OCFS2, and "
"XFS). This behavior is commonly referred to as \"copy-on-write\"."
msgstr ""
"在 Linux >= 4.5 上，:mod:`fcntl` 模块将公开 ``FICLONE`` 和 ``FICLONERANGE`` "
"常量，这允许在某些系统上（例如 btrfs, OCFS2, 和 XFS）通过将一个文件引用链接到另一个文件来共享某些数据。 "
"此行为通常被称为“写入时拷贝”。"

#: ../../library/fcntl.rst:61
msgid ""
"On Linux >= 2.6.32, the :mod:`!fcntl` module exposes the ``F_GETOWN_EX``, "
"``F_SETOWN_EX``, ``F_OWNER_TID``, ``F_OWNER_PID``, ``F_OWNER_PGRP`` "
"constants, which allow to direct I/O availability signals to a specific "
"thread, process, or process group. On Linux >= 4.13, the :mod:`!fcntl` "
"module exposes the ``F_GET_RW_HINT``, ``F_SET_RW_HINT``, "
"``F_GET_FILE_RW_HINT``, ``F_SET_FILE_RW_HINT``, and ``RWH_WRITE_LIFE_*`` "
"constants, which allow to inform the kernel about the relative expected "
"lifetime of writes on a given inode or via a particular open file "
"description. On Linux >= 5.1 and NetBSD, the :mod:`!fcntl` module exposes "
"the ``F_SEAL_FUTURE_WRITE`` constant for use with ``F_ADD_SEALS`` and "
"``F_GET_SEALS`` operations. On FreeBSD, the :mod:`!fcntl` module exposes the"
" ``F_READAHEAD``, ``F_ISUNIONSTACK``, and ``F_KINFO`` constants. On macOS "
"and FreeBSD, the :mod:`!fcntl` module exposes the ``F_RDAHEAD`` constant. On"
" NetBSD and AIX, the :mod:`!fcntl` module exposes the ``F_CLOSEM`` constant."
" On NetBSD, the :mod:`!fcntl` module exposes the ``F_MAXFD`` constant. On "
"macOS and NetBSD, the :mod:`!fcntl` module exposes the ``F_GETNOSIGPIPE`` "
"and ``F_SETNOSIGPIPE`` constant."
msgstr ""
"在 Linux >= 2.6.32 上，:mod:`!fcntl` 模块会暴露 ``F_GETOWN_EX``, ``F_SETOWN_EX``, "
"``F_OWNER_TID``, ``F_OWNER_PID``, ``F_OWNER_PGRP`` 常量，它们允许针对特定线程、进程或进程组的直接 "
"I/O 可用性信号。 在 Linux >= 4.13 上，:mod:`!fcntl` 模块会暴露 ``F_GET_RW_HINT``, "
"``F_SET_RW_HINT``, ``F_GET_FILE_RW_HINT``, ``F_SET_FILE_RW_HINT`` 和 "
"``RWH_WRITE_LIFE_*`` 常量，它们允许向内核通知有关在给定 inode 上或通过特定的打开文件描述符写入的相对预计生命期。 在 "
"Linux >= 5.1 和 NetBSD 上，:mod:`!fcntl` 模块会暴露 ``F_SEAL_FUTURE_WRITE`` 常量供 "
"``F_ADD_SEALS`` 和 ``F_GET_SEALS`` 操作使用。 在 FreeBSD 上，:mod:`!fcntl` 模块会暴露 "
"``F_READAHEAD``, ``F_ISUNIONSTACK`` 和 ``F_KINFO`` 常量。 在 macOS 和 FreeBSD "
"上，:mod:`!fcntl` 模块会暴露 ``F_RDAHEAD`` 常量。 在 NetBSD 和 AIX 上，:mod:`!fcntl` 模块会暴露"
" ``F_CLOSEM`` 常量。 在 NetBSD 上，:mod:`!fcntl` 模块会暴露 ``F_MAXFD`` 常量。 在 macOS 和 "
"NetBSD 上，:mod:`!fcntl` 模块会暴露 ``F_GETNOSIGPIPE`` 和 ``F_SETNOSIGPIPE`` 常量。"

#: ../../library/fcntl.rst:82
msgid ""
"On Linux >= 6.1, the :mod:`!fcntl` module exposes the ``F_DUPFD_QUERY`` to "
"query a file descriptor pointing to the same file."
msgstr ""
"在 Linux >= 6.1 上，:mod:`!fcntl` 模块暴露了 ``F_DUPFD_QUERY`` 以查询指向同一文件的文件描述符。"

#: ../../library/fcntl.rst:86
msgid "The module defines the following functions:"
msgstr "这个模块定义了以下函数："

#: ../../library/fcntl.rst:91
msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used "
"for *cmd* are operating system dependent, and are available as constants in "
"the :mod:`fcntl` module, using the same names as used in the relevant C "
"header files. The argument *arg* can either be an integer value, a "
":term:`bytes-like object`, or a string. The type and size of *arg* must "
"match the type and size of the argument of the operation as specified in the"
" relevant C documentation."
msgstr ""
"对文件描述符 *fd* 执行操作 *cmd* (也接受提供 :meth:`~io.IOBase.fileno` 方法的文件对象)。 用于 *cmd* "
"的值取决于操作系统，可以在 :mod:`fcntl` 模块中作为常量使用，使用与相关 C 头文件中使用的名称相同的名称。参数 *arg* "
"可以是整数值、:term:`bytes-like object` 或字符串。 *arg* 的类型和大小必须与相关 C "
"文档中指定的操作参数的类型和大小相匹配。"

#: ../../library/fcntl.rst:100
msgid ""
"When *arg* is an integer, the function returns the integer return value of "
"the C :c:func:`fcntl` call."
msgstr "当 *arg* 是一个整数时，该函数将返回 C :c:func:`fcntl` 调用的整数返回值。"

#: ../../library/fcntl.rst:103
msgid ""
"When the argument is bytes-like object, it represents a binary structure, "
"for example, created by :func:`struct.pack`. A string value is encoded to "
"binary using the UTF-8 encoding. The binary data is copied to a buffer whose"
" address is passed to the C :c:func:`fcntl` call.  The return value after a "
"successful call is the contents of the buffer, converted to a :class:`bytes`"
" object. The length of the returned object will be the same as the length of"
" the *arg* argument. This is limited to 1024 bytes."
msgstr ""
"当参数是字节型的对象时，它表示一个二进制结构，例如，由 :func:`struct.pack` 创建。使用 UTF-8 编码格式将字符串值编码为二进制。"
" 二进制数据被复制到一个缓冲区，该缓冲区的地址被传递给 C :c:func:`fcntl` 调用。 成功调用后的返回值是缓冲区的内容，转换为 "
":class:`bytes` 对象。返回对象的长度将与 *arg* 参数的长度相同。 这限制为 1024 字节。"

#: ../../library/fcntl.rst:112
msgid "If the :c:func:`fcntl` call fails, an :exc:`OSError` is raised."
msgstr "如果 :c:func:`fcntl` 调用失败，将引发 :exc:`OSError`。"

#: ../../library/fcntl.rst:115
msgid ""
"If the type or the size of *arg* does not match the type or size of the "
"argument of the operation (for example, if an integer is passed when a "
"pointer is expected, or the information returned in the buffer by the "
"operating system is larger than 1024 bytes), this is most likely to result "
"in a segmentation violation or a more subtle data corruption."
msgstr ""
"如果 *arg* 的类型和大小与相应操作的类型和大小不匹配（例如，如果预期传入一个指针却传入了一个整数，或者操作系统返回的缓冲区中的信息大于 1024 "
"字节），这就很可能导致段错误或更微妙的数据损坏。"

#: ../../library/fcntl.rst:122
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments "
"``fd``, ``cmd``, ``arg``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``fcntl.fcntl`` 并附带参数 ``fd``, ``cmd``, ``arg``。"

#: ../../library/fcntl.rst:124
msgid ""
"Add support of arbitrary :term:`bytes-like objects <bytes-like object>`, not"
" only :class:`bytes`."
msgstr "添加对任意 :term:`字节型对象 <bytes-like object>` 的支持，而不仅是 :class:`bytes`。"

#: ../../library/fcntl.rst:131
msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except that"
" the argument handling is even more complicated."
msgstr "本函数与 :func:`~fcntl.fcntl` 函数相同，只是参数的处理更加复杂。"

#: ../../library/fcntl.rst:134
msgid ""
"The *request* parameter is limited to values that can fit in 32-bits or "
"64-bits, depending on the platform. Additional constants of interest for use"
" as the *request* argument can be found in the :mod:`termios` module, under "
"the same names as used in the relevant C header files."
msgstr ""
"*request* 形参被限制为能被放入 32 或 64 个比特位的值，具体取决于所在的平台。 在 :mod:`termios` "
"模块中还包含一些可被用作 *request* 参数的额外常量，其名称与相关 C 语言头文件中所使用的相同。"

#: ../../library/fcntl.rst:140
msgid ""
"The parameter *arg* can be an integer, a :term:`bytes-like object`, or a "
"string. The type and size of *arg* must match the type and size of the "
"argument of the operation as specified in the relevant C documentation."
msgstr ""
"形参 *arg* 可以是一个整数, :term:`bytes-like object` 或者字符串。 *arg* 的类型和大小必须与对应 C "
"文档中规定的参数的类型和大小相匹配。"

#: ../../library/fcntl.rst:145
msgid ""
"If *arg* does not support the read-write buffer interface or the "
"*mutate_flag* is false, behavior is as for the :func:`~fcntl.fcntl` "
"function."
msgstr ""
"如果 *arg* 不支持读写缓冲区接口或者 *mutate_flag* 为假值，则其行为与 :func:`~fcntl.fcntl` 函数一样。"

#: ../../library/fcntl.rst:149
msgid ""
"If *arg* supports the read-write buffer interface (like :class:`bytearray`) "
"and *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :c:func:`!ioctl` system call, the latter's return "
"code is passed back to the calling Python, and the buffer's new contents "
"reflect the action of the :c:func:`ioctl`.  This is a slight simplification,"
" because if the supplied buffer is less than 1024 bytes long it is first "
"copied into a static buffer 1024 bytes long which is then passed to "
":func:`ioctl` and copied back into the supplied buffer."
msgstr ""
"如果 *arg* 支持读写缓冲区接口 (就像 :class:`bytearray`) 并且 *mutate_flag* "
"为（默认的）真值，那么缓冲区（实际上）会被传给下层的 :c:func:`!ioctl` 系统调用，后者的返回代码则会回传给调用方 Python "
"对象，而缓冲区的新内容将反映 :c:func:`ioctl` 的动作。 这里做了一点简化，因为如果给出的缓冲区长度小于 1024 "
"字节则它会先被拷贝到一个长度为 1024 字节的静态缓冲区然后再传给 :func:`ioctl` 并把结果拷贝回给出的缓冲区。"

#: ../../library/fcntl.rst:158
msgid ""
"If the :c:func:`ioctl` call fails, an :exc:`OSError` exception is raised."
msgstr "如果 :c:func:`ioctl` 调用失败，将引发 :exc:`OSError` 异常。"

#: ../../library/fcntl.rst:161
msgid ""
"If the type or size of *arg* does not match the type or size of the "
"operation's argument (for example, if an integer is passed when a pointer is"
" expected, or the information returned in the buffer by the operating system"
" is larger than 1024 bytes, or the size of the mutable bytes-like object is "
"too small), this is most likely to result in a segmentation violation or a "
"more subtle data corruption."
msgstr ""
"如果 *arg* 的类型和大小与对应操作的参数的类型和大小不相匹配（例如，如果预期传入一个指针却传入了一个整数，或者由操作系统返回的缓冲区中的信息大于 "
"1024 字节），这就很有可能导致段错误或更微妙的数据损坏。"

#: ../../library/fcntl.rst:169
msgid "An example::"
msgstr "举个例子："

#: ../../library/fcntl.rst:171
msgid ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"
msgstr ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"

#: ../../library/fcntl.rst:182
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments "
"``fd``, ``request``, ``arg``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``fcntl.ioctl`` 并附带参数 ``fd``, ``request``, "
"``arg``。"

#: ../../library/fcntl.rst:184
msgid ""
"The GIL is always released during a system call. System calls failing with "
"EINTR are automatically retried."
msgstr "GIL总是在系统调用期间被释放。返回EINTR（即Errno 4）的失败的系统调用将自动重试。"

#: ../../library/fcntl.rst:190
msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file objects"
" providing a :meth:`~io.IOBase.fileno` method are accepted as well). See the"
" Unix manual :manpage:`flock(2)` for details.  (On some systems, this "
"function is emulated using :c:func:`fcntl`.)"
msgstr ""
"在文件描述符 *fd* 上执行加锁操作 *operation* (也接受能提供 :meth:`~io.IOBase.fileno` 方法的文件对象)。 "
"详见 Unix 手册  :manpage:`flock(2)`。 (在某些系统中，此函数是用 :c:func:`fcntl` 模拟出来的。)"

#: ../../library/fcntl.rst:195
msgid ""
"If the :c:func:`flock` call fails, an :exc:`OSError` exception is raised."
msgstr "如果 :c:func:`flock` 调用失败，将引发 :exc:`OSError` 异常。"

#: ../../library/fcntl.rst:197
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments "
"``fd``, ``operation``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``fcntl.flock`` 并附带参数 ``fd``, ``operation``。"

#: ../../library/fcntl.rst:202
msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking calls."
" *fd* is the file descriptor (file objects providing a "
":meth:`~io.IOBase.fileno` method are accepted as well) of the file to lock "
"or unlock, and *cmd* is one of the following values:"
msgstr ""
"本质上是对 :func:`~fcntl.fcntl` 加锁调用的封装。*fd* 是要加解锁的文件描述符（也接受能提供 "
":meth:`~io.IOBase.fileno` 方法的文件对象），*cmd* 是以下值之一："

#: ../../library/fcntl.rst:209
msgid "Release an existing lock."
msgstr "释放一个已存在的锁 。"

#: ../../library/fcntl.rst:213
msgid "Acquire a shared lock."
msgstr "获取一个共享的锁。"

#: ../../library/fcntl.rst:217
msgid "Acquire an exclusive lock."
msgstr "获得一个独占的锁。"

#: ../../library/fcntl.rst:221
msgid ""
"Bitwise OR with any of the other three ``LOCK_*`` constants to make the "
"request non-blocking."
msgstr "与其他三个 ``LOCK_*`` 常量中的任何一个进行位或操作，使请求不阻塞。"

#: ../../library/fcntl.rst:224
msgid ""
"If :const:`!LOCK_NB` is used and the lock cannot be acquired, an "
":exc:`OSError` will be raised and the exception will have an *errno* "
"attribute set to :const:`~errno.EACCES` or :const:`~errno.EAGAIN` (depending"
" on the operating system; for portability, check for both values).  On at "
"least some systems, :const:`!LOCK_EX` can only be used if the file "
"descriptor refers to a file opened for writing."
msgstr ""
"如果使用了 :const:`!LOCK_NB` ，但无法获取锁 ，则 :exc:`OSError` 将被引发 ，异常将被 *errno* 属性 设置为 "
":const:`~errno.EACCES` 或 :const:`~errno.EAGAIN` （取决于操作系统；为便于移植，请检查这两个值）。 "
"至少在某些系统中，只有当文件描述符指向一个已打开供写入的文件时，才能使用:const:`!LOCK_EX` 。"

#: ../../library/fcntl.rst:231
msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which "
"the lock starts, relative to *whence*, and *whence* is as with "
":func:`io.IOBase.seek`, specifically:"
msgstr ""
"*len* 是要锁定的字节数，*start* 是自 *whence* 开始锁定的字节偏移量，*whence* 与 "
":func:`io.IOBase.seek` 的定义一样。"

#: ../../library/fcntl.rst:235
msgid "``0`` -- relative to the start of the file (:const:`os.SEEK_SET`)"
msgstr "``0`` -- 相对于文件开头 (:const:`os.SEEK_SET`)"

#: ../../library/fcntl.rst:236
msgid ""
"``1`` -- relative to the current buffer position (:const:`os.SEEK_CUR`)"
msgstr "``1`` -- 相对于当前缓冲区位置 (:const:`os.SEEK_CUR`)"

#: ../../library/fcntl.rst:237
msgid "``2`` -- relative to the end of the file (:const:`os.SEEK_END`)"
msgstr "``2`` -- 相对于文件末尾 (:const:`os.SEEK_END`)"

#: ../../library/fcntl.rst:239
msgid ""
"The default for *start* is 0, which means to start at the beginning of the "
"file. The default for *len* is 0 which means to lock to the end of the file."
"  The default for *whence* is also 0."
msgstr ""
"*start* 的默认值为 0，表示从文件起始位置开始。*len* 的默认值是 0，表示加锁至文件末尾。 *whence* 的默认值也是 0。"

#: ../../library/fcntl.rst:243
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``fcntl.lockf`` 并附带参数 ``fd``, ``cmd``, ``len``, "
"``start``, ``whence``。"

#: ../../library/fcntl.rst:245
msgid "Examples (all on a SVR4 compliant system)::"
msgstr "示例（都是运行于符合 SVR4 的系统）："

#: ../../library/fcntl.rst:247
msgid ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"
msgstr ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"

#: ../../library/fcntl.rst:255
msgid ""
"Note that in the first example the return value variable *rv* will hold an "
"integer value; in the second example it will hold a :class:`bytes` object.  "
"The structure lay-out for the *lockdata* variable is system dependent --- "
"therefore using the :func:`flock` call may be better."
msgstr ""
"注意，在第一个例子中，返回值变量 *rv* 将存有整数；在第二个例子中，该变量中将存有一个 :class:`bytes` 对象。*lockdata* "
"变量的结构布局视系统而定——因此采用 :func:`flock` 调用可能会更好。"

#: ../../library/fcntl.rst:263
msgid "Module :mod:`os`"
msgstr "模块 :mod:`os`"

#: ../../library/fcntl.rst:264
msgid ""
"If the locking flags :const:`~os.O_SHLOCK` and :const:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` function "
"provides an alternative to the :func:`lockf` and :func:`flock` functions."
msgstr ""
"如果加锁旗标 :const:`~os.O_SHLOCK` 和 :const:`~os.O_EXLOCK` 存在于 :mod:`os` 模块中（仅 BSD"
" 专属），则 :func:`os.open` 函数提供了对 :func:`lockf` 和 :func:`flock` 函数的替代。"

#: ../../library/fcntl.rst:10
msgid "UNIX"
msgstr "UNIX"

#: ../../library/fcntl.rst:10
msgid "file control"
msgstr "文件控制"

#: ../../library/fcntl.rst:10
msgid "I/O control"
msgstr "I/O 控制"
