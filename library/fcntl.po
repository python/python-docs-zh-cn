# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alpha Du <alphanow@gmail.com>, 2020
# nick <2330458484@qq.com>, 2020
# allenjuly7 <allenjuly7@astu.fun>, 2020
# Dai Xu <daixu61@hotmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 12:02+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/fcntl.rst:2
msgid ":mod:`fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ":mod:`fcntl` —— 系统调用 ``fcntl`` 和 ``ioctl`` "

#: ../../library/fcntl.rst:16
msgid ""
"This module performs file control and I/O control on file descriptors. It is"
" an interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines.  For"
" a complete description of these calls, see :manpage:`fcntl(2)` and "
":manpage:`ioctl(2)` Unix manual pages."
msgstr ""
"本模块基于文件描述符来进行文件控制和 I/O 控制。它是 Unix 系统调用  :c:func:`fcntl` 和 :c:func:`ioctl` "
"的接口。关于这些调用的完整描述，请参阅 Unix 手册的 :manpage:`fcntl(2)` 和 :manpage:`ioctl(2)` 页面。"

#: ../../library/fcntl.rst:21
msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by "
"``sys.stdin.fileno()``, or an :class:`io.IOBase` object, such as "
"``sys.stdin`` itself, which provides a :meth:`~io.IOBase.fileno` that "
"returns a genuine file descriptor."
msgstr ""
"本模块的所有函数都接受文件描述符 *fd* 作为第一个参数。可以是一个整数形式的文件描述符，比如 ``sys.stdin.fileno()`` "
"的返回结果，或为 :class:`io.IOBase` 对象，比如 ``sys.stdin`` 提供一个 "
":meth:`~io.IOBase.fileno`，可返回一个真正的文件描述符。"

#: ../../library/fcntl.rst:27
msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr "本模块的操作以前触发的是 :exc:`IOError`，现在则会触发 :exc:`OSError`。"

#: ../../library/fcntl.rst:31
msgid ""
"The fcntl module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, and "
"``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
"fcntl 模块现在有了 ``F_ADD_SEALS`` 、``F_GET_SEALS``  和 ``F_SEAL_*`` 常量，用于文件描述符 "
":func:`os.memfd_create` 的封装。"

#: ../../library/fcntl.rst:36
msgid "The module defines the following functions:"
msgstr "这个模块定义了以下函数："

#: ../../library/fcntl.rst:41
msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used "
"for *cmd* are operating system dependent, and are available as constants in "
"the :mod:`fcntl` module, using the same names as used in the relevant C "
"header files. The argument *arg* can either be an integer value, or a "
":class:`bytes` object. With an integer value, the return value of this "
"function is the integer return value of the C :c:func:`fcntl` call.  When "
"the argument is bytes it represents a binary structure, e.g. created by "
":func:`struct.pack`. The binary data is copied to a buffer whose address is "
"passed to the C :c:func:`fcntl` call.  The return value after a successful "
"call is the contents of the buffer, converted to a :class:`bytes` object. "
"The length of the returned object will be the same as the length of the "
"*arg* argument. This is limited to 1024 bytes. If the information returned "
"in the buffer by the operating system is larger than 1024 bytes, this is "
"most likely to result in a segmentation violation or a more subtle data "
"corruption."
msgstr ""
"对文件描述符 *fd* 执行 *cmd* 操作（能够提供 :meth:`~io.IOBase.fileno` 方法的文件对象也可以接受）。 *cmd* "
"可用的值与操作系统有关，在 :mod:`fcntl` 模块中可作为常量使用，名称与相关 C 语言头文件中的一样。参数 *arg* 可以是整数或 "
":class:`bytes` 对象。若为整数值，则本函数的返回值是 C 语言  :c:func:`fcntl` "
"调用的整数返回值。若为字节串，则其代表一个二进制结构，比如由 :func:`struct.pack` "
"创建的数据。该二进制数据将被复制到一个缓冲区，缓冲区地址传给 C 调用 :c:func:`fcntl`。调用成功后的返回值位于缓冲区内，转换为一个 "
":class:`bytes` 对象。返回的对象长度将与 *arg* 参数的长度相同。上限为 1024 字节。如果操作系统在缓冲区中返回的信息大于 "
"1024 字节，很可能导致内存段冲突，或更为不易察觉的数据错误。"

#: ../../library/fcntl.rst:58
msgid "If the :c:func:`fcntl` fails, an :exc:`OSError` is raised."
msgstr "如果 :c:func:`fcntl` 调用失败，会触发 :exc:`OSError`。"

#: ../../library/fcntl.rst:60
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments "
"``fd``, ``cmd``, ``arg``."
msgstr ""
"引发一条 :ref:`auditing 事件 <auditing>` ``fcntl.fcntl``，参数为 ``fd`` "
"、``cmd``、``arg``。"

#: ../../library/fcntl.rst:65
msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except that"
" the argument handling is even more complicated."
msgstr "本函数与 :func:`~fcntl.fcntl` 函数相同，只是参数的处理更加复杂。"

#: ../../library/fcntl.rst:68
msgid ""
"The *request* parameter is limited to values that can fit in 32-bits. "
"Additional constants of interest for use as the *request* argument can be "
"found in the :mod:`termios` module, under the same names as used in the "
"relevant C header files."
msgstr ""
"*request* 参数的上限是 32位。:mod:`termios` 模块中包含了可用作 *request* 参数其他常量，名称与相关 C "
"头文件中定义的相同。"

#: ../../library/fcntl.rst:73
msgid ""
"The parameter *arg* can be one of an integer, an object supporting the read-"
"only buffer interface (like :class:`bytes`) or an object supporting the "
"read-write buffer interface (like :class:`bytearray`)."
msgstr ""
"参数 *arg* 可为整数、支持只读缓冲区接口的对象（如 :class:`bytes` ）或支持读写缓冲区接口的对象（如 "
":class:`bytearray` ）。"

#: ../../library/fcntl.rst:77
msgid ""
"In all but the last case, behaviour is as for the :func:`~fcntl.fcntl` "
"function."
msgstr "除了最后一种情况，其他情况下的行为都与 :func:`~fcntl.fcntl` 函数一样。"

#: ../../library/fcntl.rst:80
msgid ""
"If a mutable buffer is passed, then the behaviour is determined by the value"
" of the *mutate_flag* parameter."
msgstr "如果传入的是个可变缓冲区，那么行为就由 *mutate_flag* 参数决定。"

#: ../../library/fcntl.rst:83
msgid ""
"If it is false, the buffer's mutability is ignored and behaviour is as for a"
" read-only buffer, except that the 1024 byte limit mentioned above is "
"avoided -- so long as the buffer you pass is at least as long as what the "
"operating system wants to put there, things should work."
msgstr ""
"如果为 False，缓冲区的可变性将被忽略，行为与只读缓冲区一样，只是没有了上述 1024 字节的上限——只要传入的缓冲区能容纳操作系统放入的数据即可。"

#: ../../library/fcntl.rst:88
msgid ""
"If *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :func:`ioctl` system call, the latter's return code"
" is passed back to the calling Python, and the buffer's new contents reflect"
" the action of the :func:`ioctl`.  This is a slight simplification, because "
"if the supplied buffer is less than 1024 bytes long it is first copied into "
"a static buffer 1024 bytes long which is then passed to :func:`ioctl` and "
"copied back into the supplied buffer."
msgstr ""
"如果 *mutate_flag* 为 True（默认值），那么缓冲区（实际上）会传给底层的 系统调用 :func:`ioctl` "
"，其返回代码则会回传给调用它的 Python，而缓冲区的新数据则反映了 :func:`ioctl` "
"的运行结果。这里做了一点简化，因为若是给出的缓冲区少于 1024 字节，首先会被复制到一个 1024 字节长的静态缓冲区再传给  "
":func:`ioctl` ，然后把结果复制回给出的缓冲区去。"

#: ../../library/fcntl.rst:96
msgid "If the :c:func:`ioctl` fails, an :exc:`OSError` exception is raised."
msgstr "如果 :c:func:`ioctl` 调用失败，则会触发 :exc:`OSError` 异常。"

#: ../../library/fcntl.rst:98
msgid "An example::"
msgstr "举个例子："

#: ../../library/fcntl.rst:111
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments "
"``fd``, ``request``, ``arg``."
msgstr ""
"触发一条 :ref:`auditing 事件 <auditing>` ``fcntl.ioctl``，参数为 ``fd`` 、``request`` "
"、``arg``。"

#: ../../library/fcntl.rst:116
msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file objects"
" providing a :meth:`~io.IOBase.fileno` method are accepted as well). See the"
" Unix manual :manpage:`flock(2)` for details.  (On some systems, this "
"function is emulated using :c:func:`fcntl`.)"
msgstr ""
"在文件描述符 *fd* 上执行加锁操作 *operation* (也接受能提供 :meth:`~io.IOBase.fileno` 方法的文件对象)。 "
"详见 Unix 手册  :manpage:`flock(2)`。 (在某些系统中，此函数是用 :c:func:`fcntl` 模拟出来的。)"

#: ../../library/fcntl.rst:121
msgid "If the :c:func:`flock` fails, an :exc:`OSError` exception is raised."
msgstr "如果 :c:func:`flock` 调用失败，就会触发 :exc:`OSError` 异常。"

#: ../../library/fcntl.rst:123
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments "
"``fd``, ``operation``."
msgstr ""
"触发一条 :ref:`审计事件 <auditing>` ``fcntl.flock``，参数为 ``fd`` 、``operation``。"

#: ../../library/fcntl.rst:128
msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking calls."
" *fd* is the file descriptor (file objects providing a "
":meth:`~io.IOBase.fileno` method are accepted as well) of the file to lock "
"or unlock, and *cmd* is one of the following values:"
msgstr ""
"本质上是对 :func:`~fcntl.fcntl` 加锁调用的封装。*fd* 是要加解锁的文件描述符（也接受能提供 "
":meth:`~io.IOBase.fileno` 方法的文件对象），*cmd* 是以下值之一："

#: ../../library/fcntl.rst:133
msgid ":const:`LOCK_UN` -- unlock"
msgstr ":const:`LOCK_UN` ——解锁"

#: ../../library/fcntl.rst:134
msgid ":const:`LOCK_SH` -- acquire a shared lock"
msgstr ":const:`LOCK_SH` —— 获取一个共享锁"

#: ../../library/fcntl.rst:135
msgid ":const:`LOCK_EX` -- acquire an exclusive lock"
msgstr ":const:`LOCK_EX` —— 获取一个独占锁"

#: ../../library/fcntl.rst:137
msgid ""
"When *cmd* is :const:`LOCK_SH` or :const:`LOCK_EX`, it can also be bitwise "
"ORed with :const:`LOCK_NB` to avoid blocking on lock acquisition. If "
":const:`LOCK_NB` is used and the lock cannot be acquired, an :exc:`OSError` "
"will be raised and the exception will have an *errno* attribute set to "
":const:`EACCES` or :const:`EAGAIN` (depending on the operating system; for "
"portability, check for both values).  On at least some systems, "
":const:`LOCK_EX` can only be used if the file descriptor refers to a file "
"opened for writing."
msgstr ""
"如果 *cmd* 为 :const:`LOCK_SH` 或 :const:`LOCK_EX`，则还可以与 :const:`LOCK_NB` "
"进行按位或运算，以避免在获取锁时出现阻塞。 如果用了 :const:`LOCK_NB`，无法获取锁时将触发 :exc:`OSError`，此异常的 "
"*errno* 属性将被设为 :const:`EACCES` 或 :const:`EAGAIN` (视操作系统而定；为了保证可移植性，请检查这两个值)。"
" 至少在某些系统上，只有当文件描述符指向需要写入而打开的文件时，才可以使用 :const:`LOCK_EX`。"

#: ../../library/fcntl.rst:146
msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which "
"the lock starts, relative to *whence*, and *whence* is as with "
":func:`io.IOBase.seek`, specifically:"
msgstr ""
"*len* 是要锁定的字节数，*start* 是自 *whence* 开始锁定的字节偏移量，*whence* 与 "
":func:`io.IOBase.seek` 的定义一样。"

#: ../../library/fcntl.rst:150
msgid ":const:`0` -- relative to the start of the file (:data:`os.SEEK_SET`)"
msgstr ":const:`0` —— 自文件起始位置（:data:`os.SEEK_SET`）。"

#: ../../library/fcntl.rst:151
msgid ""
":const:`1` -- relative to the current buffer position (:data:`os.SEEK_CUR`)"
msgstr ":const:`1` —— 自缓冲区当前位置（ :data:`os.SEEK_CUR` ）"

#: ../../library/fcntl.rst:152
msgid ":const:`2` -- relative to the end of the file (:data:`os.SEEK_END`)"
msgstr ":const:`2`—— 自文件末尾（:data:`os.SEEK_END`)"

#: ../../library/fcntl.rst:154
msgid ""
"The default for *start* is 0, which means to start at the beginning of the "
"file. The default for *len* is 0 which means to lock to the end of the file."
"  The default for *whence* is also 0."
msgstr ""
"*start* 的默认值为 0，表示从文件起始位置开始。*len* 的默认值是 0，表示加锁至文件末尾。 *whence* 的默认值也是 0。"

#: ../../library/fcntl.rst:158
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"触发一条 :ref:`审计事件 <auditing>` ``fcntl.lockf``，参数为 ``fd`` 、 ``cmd``、 ``len``、 "
"``start``、 ``whence``。"

#: ../../library/fcntl.rst:160
msgid "Examples (all on a SVR4 compliant system)::"
msgstr "示例（都是运行于符合 SVR4 的系统）："

#: ../../library/fcntl.rst:170
msgid ""
"Note that in the first example the return value variable *rv* will hold an "
"integer value; in the second example it will hold a :class:`bytes` object.  "
"The structure lay-out for the *lockdata* variable is system dependent --- "
"therefore using the :func:`flock` call may be better."
msgstr ""
"注意，在第一个例子中，返回值变量 *rv* 将存有整数；在第二个例子中，该变量中将存有一个 :class:`bytes` 对象。*lockdata* "
"变量的结构布局视系统而定——因此可能采用 :func:`flock` 调用会更好。"

#: ../../library/fcntl.rst:181
msgid "Module :mod:`os`"
msgstr "模块 :mod:`os`"

#: ../../library/fcntl.rst:179
msgid ""
"If the locking flags :data:`~os.O_SHLOCK` and :data:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` function "
"provides an alternative to the :func:`lockf` and :func:`flock` functions."
msgstr ""
"如果 :mod:`os` 模块中存在加锁标志 :data:`~os.O_SHLOCK` 和 :data:`~os.O_EXLOCK` "
"（仅在BSD上），那么 :func:`os.open` 函数提供了 :func:`lockf` 和 :func:`flock` 函数的替代方案。"
