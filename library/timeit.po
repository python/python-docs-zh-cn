# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/timeit.rst:2
msgid ":mod:`!timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`!timeit` --- 测量小代码片段的执行时间"

#: ../../library/timeit.rst:7
msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**源码：** :source:`Lib/timeit.py`"

#: ../../library/timeit.rst:15
msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"此模块提供了一种简单的方法来计算一小段 Python 代码的耗时。 它有 :ref:`timeit-command-line-interface` "
"以及一个 :ref:`可调用 <python-interface>` 方法。 它避免了许多测量时间的常见陷阱。 另见 Tim Peter 在 "
"O'Reilly 出版的 *Python Cookbook* 第二版中“算法”章节的概述。"

#: ../../library/timeit.rst:23
msgid "Basic Examples"
msgstr "基本示例"

#: ../../library/timeit.rst:25
msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can"
" be used to compare three different expressions:"
msgstr "以下示例显示了如何使用 :ref:`timeit-command-line-interface` 来比较三个不同的表达式："

#: ../../library/timeit.rst:28
msgid ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"
msgstr ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"

#: ../../library/timeit.rst:37
msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr "这可以通过 :ref:`python-interface` 实现 ::"

#: ../../library/timeit.rst:39
msgid ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"

#: ../../library/timeit.rst:47
msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "从 :ref:`python-interface` 还可以传出一个可调用对象::"

#: ../../library/timeit.rst:49
msgid ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)\n"
"0.19665591977536678"
msgstr ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)\n"
"0.19665591977536678"

#: ../../library/timeit.rst:52
msgid ""
"Note however that :func:`.timeit` will automatically determine the number of"
" repetitions only when the command-line interface is used.  In the "
":ref:`timeit-examples` section you can find more advanced examples."
msgstr ""
"但请注意 :func:`.timeit` 仅在使用命令行界面时会自动确定重复次数。 在 :ref:`timeit-examples` "
"一节你可以找到更多的进阶示例。"

#: ../../library/timeit.rst:60
msgid "Python Interface"
msgstr "Python 接口"

#: ../../library/timeit.rst:62
msgid "The module defines three convenience functions and a public class:"
msgstr "该模块定义了三个便利函数和一个公共类："

#: ../../library/timeit.rst:67
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"使用给定语句、 *setup* 代码和 *timer* 函数创建一个 :class:`Timer` 实例，并执行 *number* 次其 "
":meth:`.timeit` 方法。可选的 *globals* 参数指定用于执行代码的命名空间。"

#: ../../library/timeit.rst:72 ../../library/timeit.rst:83
#: ../../library/timeit.rst:122
msgid "The optional *globals* parameter was added."
msgstr "添加可选参数 *globals* 。"

#: ../../library/timeit.rst:78
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"使用给定语句、 *setup* 代码和 *timer* 函数创建一个 :class:`Timer` 实例，并使用给定的 *repeat* 计数和 "
"*number* 执行运行其 :meth:`.repeat` 方法。可选的 *globals* 参数指定用于执行代码的命名空间。"

#: ../../library/timeit.rst:86 ../../library/timeit.rst:183
msgid "Default value of *repeat* changed from 3 to 5."
msgstr "*repeat* 的默认值由 3 更改为 5 。"

#: ../../library/timeit.rst:92
msgid ""
"The default timer, which is always time.perf_counter(), returns float "
"seconds. An alternative, time.perf_counter_ns, returns integer nanoseconds."
msgstr ""
"默认计时器始终为 time.perf_counter()，它返回浮点形式的秒数。 另一个选择是 "
"time.perf_counter_ns，它返回整数形式的纳秒数。"

#: ../../library/timeit.rst:95
msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` 现在是默认计时器。"

#: ../../library/timeit.rst:101
msgid "Class for timing execution speed of small code snippets."
msgstr "用于小代码片段的计数执行速度的类。"

#: ../../library/timeit.rst:103
msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the"
" timer function is platform-dependent (see the module doc string). *stmt* "
"and *setup* may also contain multiple statements separated by ``;`` or "
"newlines, as long as they don't contain multi-line string literals.  The "
"statement will by default be executed within timeit's namespace; this "
"behavior can be controlled by passing a namespace to *globals*."
msgstr ""
"构造函数接受一个将计时的语句、一个用于设置的附加语句和一个定时器函数。两个语句都默认为 ``'pass'`` "
"；计时器函数与平台有关（请参阅模块文档字符串）。 *stmt* 和 *setup* 也可能包含多个以 ``;`` "
"或换行符分隔的语句，只要它们不包含多行字符串文字即可。该语句默认在 timeit 的命名空间内执行；可以通过将命名空间传递给 *globals* "
"来控制此行为。"

#: ../../library/timeit.rst:111
msgid ""
"To measure the execution time of the first statement, use the "
":meth:`.timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods "
"are convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"要测量第一个语句的执行时间，请使用 :meth:`.timeit` 方法。 :meth:`.repeat` 和 :meth:`.autorange` "
"方法是方便的方法来调用 :meth:`.timeit` 多次。"

#: ../../library/timeit.rst:115
msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr "*setup* 的执行时间从总体计时执行中排除。"

#: ../../library/timeit.rst:117
msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"*stmt* 和 *setup* 参数也可以使用不带参数的可调用对象。这将在一个计时器函数中嵌入对它们的调用，然后由 :meth:`.timeit` "
"执行。请注意，由于额外的函数调用，在这种情况下，计时开销会略大一些。"

#: ../../library/timeit.rst:127
msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times.  The default timer returns seconds as a float. "
"The argument is the number of times through the loop, defaulting to one "
"million.  The main statement, the setup statement and the timer function to "
"be used are passed to the constructor."
msgstr ""
"主语句执行次数 *number*。 这会执行一次设置语句，然后返回执行主语句若干次所需的时间。 默认计时器以浮点形式返回秒数。 "
"参数是循环的次数，默认为一百万次。 主语句、设置语句和要使用的定时器函数都将被传递给构造器。"

#: ../../library/timeit.rst:136
msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection`"
" during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"默认情况下， :meth:`.timeit` 暂时关闭 :term:`garbage collection` "
"。这种方法的优点在于它使独立时序更具可比性。缺点是GC可能是所测量功能性能的重要组成部分。如果是这样，可以在 *setup* "
"字符串中的第一个语句重新启用GC。例如::"

#: ../../library/timeit.rst:143
msgid "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"
msgstr "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"

#: ../../library/timeit.rst:148
msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "自动决定调用多少次 :meth:`.timeit` 。"

#: ../../library/timeit.rst:150
msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that"
" the total time >= 0.2 second, returning the eventual (number of loops, time"
" taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 seconds."
msgstr ""
"这是一个便利函数，它反复调用 :meth:`.timeit` 以使总耗时 >= 0.2 秒，返回最终结果（循环次数、循环的总耗时）。 它调用 "
":meth:`.timeit` 的次数以序列 1, 2, 5, 10, 20, 50, ... 递增，直到所用时间至少为 0.2 秒。"

#: ../../library/timeit.rst:156
msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"如果给出 *callback* 并且不是 ``None`` ，则在每次试验后将使用两个参数调用它： ``callback(number, "
"time_taken)`` 。"

#: ../../library/timeit.rst:164
msgid "Call :meth:`.timeit` a few times."
msgstr "调用 :meth:`.timeit` 几次。"

#: ../../library/timeit.rst:166
msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to"
" call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"这是一个方便的函数，它反复调用 :meth:`.timeit` ，返回结果列表。第一个参数指定调用 :meth:`.timeit` "
"的次数。第二个参数指定 :meth:`.timeit` 的 *number* 参数。"

#: ../../library/timeit.rst:173
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run"
" the given code snippet; higher values in the result vector are typically "
"not caused by variability in Python's speed, but by other processes "
"interfering with your timing accuracy. So the :func:`min` of the result is "
"probably the only number you should be interested in.  After that, you "
"should look at the entire vector and apply common sense rather than "
"statistics."
msgstr ""
"从结果向量计算并报告平均值和标准差这些是很诱人的。但是，这不是很有用。在典型情况下，最低值给出了机器运行给定代码段的速度的下限；结果向量中较高的值通常不是由Python的速度变化引起的，而是由于其他过程干扰你的计时准确性。所以结果的"
" :func:`min` 可能是你应该感兴趣的唯一数字。之后，你应该看看整个向量并应用常识而不是统计。"

#: ../../library/timeit.rst:189
msgid "Helper to print a traceback from the timed code."
msgstr "帮助程序从计时代码中打印回溯。"

#: ../../library/timeit.rst:191
msgid "Typical use::"
msgstr "典型使用::"

#: ../../library/timeit.rst:193
msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"
msgstr ""
"t = Timer(...)       # 在 try/except 之外\n"
"try:\n"
"    t.timeit(...)    # 或 t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"

#: ../../library/timeit.rst:199
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"与标准回溯相比，优势在于将显示已编译模板中的源行。可选的 *file* 参数指向发送回溯的位置；它默认为 :data:`sys.stderr` 。"

#: ../../library/timeit.rst:207
msgid "Command-Line Interface"
msgstr "命令行接口"

#: ../../library/timeit.rst:209
msgid ""
"When called as a program from the command line, the following form is used::"
msgstr "从命令行调用程序时，使用以下表单::"

#: ../../library/timeit.rst:211
msgid ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement ...]"
msgstr ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement ...]"

#: ../../library/timeit.rst:213
msgid "Where the following options are understood:"
msgstr "如果了解以下选项："

#: ../../library/timeit.rst:219
msgid "how many times to execute 'statement'"
msgstr "执行 '语句' 多少次"

#: ../../library/timeit.rst:223
msgid "how many times to repeat the timer (default 5)"
msgstr "重复计时器的次数（默认为5）"

#: ../../library/timeit.rst:227
msgid "statement to be executed once initially (default ``pass``)"
msgstr "最初要执行一次的语句（默认为 ``pass`` ）"

#: ../../library/timeit.rst:231
msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"测量进程时间，而不是 wallclock 时间，使用 :func:`time.process_time` 而不是 "
":func:`time.perf_counter` ，这是默认值"

#: ../../library/timeit.rst:238
msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr "为定时器输出指定一个时间单位；可以选择 ``nsec``, ``usec``, ``msec`` 或 ``sec``"

#: ../../library/timeit.rst:244
msgid "print raw timing results; repeat for more digits precision"
msgstr "打印原始计时结果；重复更多位数精度"

#: ../../library/timeit.rst:248
msgid "print a short usage message and exit"
msgstr "打印一条简短的使用信息并退出"

#: ../../library/timeit.rst:250
msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"可以通过将每一行指定为单独的语句参数来给出多行语句；通过在引号中包含参数并使用前导空格可以缩进行。多个 :option:`-s` 选项的处理方式相似。"

#: ../../library/timeit.rst:255
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr ""
"如果未给出 :option:`-n`，则会通过尝试按序列 1, 2, 5, 10, 20, 50, ... "
"递增的数值来计算合适的循环次数，直到总计时间至少为 0.2 秒。"

#: ../../library/timeit.rst:259
msgid ""
":func:`default_timer` measurements can be affected by other programs running"
" on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The "
":option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
":func:`default_timer` 测量可能受到在同一台机器上运行的其他程序的影响，因此在需要精确计时时最好的做法是重复几次计时并使用最佳时间。"
" :option:`-r` 选项对此有利；在大多数情况下，默认的 5 次重复可能就足够了。 你可以使用 "
":func:`time.process_time` 来测量CPU时间。"

#: ../../library/timeit.rst:267
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"执行 pass "
"语句会产生一定的基线开销。这里的代码不会试图隐藏它，但你应该知道它。可以通过不带参数调用程序来测量基线开销，并且Python版本之间可能会有所不同。"

#: ../../library/timeit.rst:276
msgid "Examples"
msgstr "例子"

#: ../../library/timeit.rst:278
msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr "可以提供一个在开头只执行一次的 setup 语句："

#: ../../library/timeit.rst:280
msgid ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"text.find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"
msgstr ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"text.find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"

#: ../../library/timeit.rst:287
msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest"
" repetition took divided by the loop count."
msgstr ""
"在输出信息中，共有三个字段。 首先是 loop count，它告诉你每个计时循环重复运行了多少次语句体。 然后是 repetition count "
"('best of 5')，它告诉你计时循环重复了多少次，最后是语句体在计时循环重复中最好的平均耗时。 即最快一次重复的耗时除以循环计数。"

#: ../../library/timeit.rst:296
msgid ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char = \"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; char = \"g\"')\n"
"1.7246671520006203"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char = \"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; char = \"g\"')\n"
"1.7246671520006203"

#: ../../library/timeit.rst:302
msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr "使用 :class:`Timer` 类及其方法可以完成同样的操作::"

#: ../../library/timeit.rst:304
msgid ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; char = \"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, 0.3712595970846668, 0.37866875250654886]"
msgstr ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; char = \"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, 0.3712595970846668, 0.37866875250654886]"

#: ../../library/timeit.rst:312
msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. "
":keyword:`try`/:keyword:`except` to test for missing and present object "
"attributes:"
msgstr ""
"以下示例显示如何计算包含多行的表达式。 在这里我们对比使用 :func:`hasattr` 与 "
":keyword:`try`/:keyword:`except` 的开销来测试缺失与提供对象属性:"

#: ../../library/timeit.rst:316
msgid ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\" \"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\" \"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"
msgstr ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\" \"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\" \"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"

#: ../../library/timeit.rst:330
msgid ""
">>> import timeit\n"
">>> # attribute is missing\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"
msgstr ""
">>> import timeit\n"
">>> # 属性缺失\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"

#: ../../library/timeit.rst:358
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr "要让 :mod:`timeit` 模块访问你定义的函数，你可以传递一个包含 import 语句的 *setup* 参数::"

#: ../../library/timeit.rst:361
msgid ""
"def test():\n"
"    \"\"\"Stupid test function\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"
msgstr ""
"def test():\n"
"    \"\"\"愚笨的测试函数\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"

#: ../../library/timeit.rst:369
msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which"
" will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"另一种选择是将 :func:`globals` 传递给 *globals* 参数，这将导致代码在当前的全局命名空间中执行。这比单独指定 import "
"更方便 ::"

#: ../../library/timeit.rst:373
msgid ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"
msgstr ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"

#: ../../library/timeit.rst:9
msgid "Benchmarking"
msgstr "基准测试"

#: ../../library/timeit.rst:9
msgid "Performance"
msgstr "性能"
