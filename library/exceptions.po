# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alpha Du <alphanow@gmail.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 01:05+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/exceptions.rst:4
msgid "Built-in Exceptions"
msgstr "内置异常"

#: ../../library/exceptions.rst:10
msgid ""
"In Python, all exceptions must be instances of a class that derives from "
":class:`BaseException`.  In a :keyword:`try` statement with an "
":keyword:`except` clause that mentions a particular class, that clause also "
"handles any exception classes derived from that class (but not exception "
"classes from which *it* is derived).  Two exception classes that are not "
"related via subclassing are never equivalent, even if they have the same "
"name."
msgstr ""
"在 Python 中，所有异常必须为一个派生自 :class:`BaseException` 的类的实例。 在带有提及一个特定类的 "
":keyword:`except` 子句的 :keyword:`try` 语句中，该子句也会处理任何派生自该类的异常类（但不处理 *它* "
"所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。"

#: ../../library/exceptions.rst:19
msgid ""
"The built-in exceptions listed in this chapter can be generated by the "
"interpreter or built-in functions.  Except where mentioned, they have an "
"\"associated value\" indicating the detailed cause of the error.  This may "
"be a string or a tuple of several items of information (e.g., an error code "
"and a string explaining the code).  The associated value is usually passed "
"as arguments to the exception class's constructor."
msgstr ""
"本章中列出的内置异常可由解释器或内置函数来生成。 除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 "
"这可以是一个字符串或由多个信息项（例如一个错误码和一个解释该错误码的字符串）。 关联值通常会作为参数被传给异常类的构造器。"

#: ../../library/exceptions.rst:26
msgid ""
"User code can raise built-in exceptions.  This can be used to test an "
"exception handler or to report an error condition \"just like\" the "
"situation in which the interpreter raises the same exception; but beware "
"that there is nothing to prevent user code from raising an inappropriate "
"error."
msgstr ""
"用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” "
"在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。"

#: ../../library/exceptions.rst:31
msgid ""
"The built-in exception classes can be subclassed to define new exceptions; "
"programmers are encouraged to derive new exceptions from the "
":exc:`Exception` class or one of its subclasses, and not from "
":exc:`BaseException`.  More information on defining exceptions is available "
"in the Python Tutorial under :ref:`tut-userexceptions`."
msgstr ""
"内置异常类可以被子类化以定义新的异常；鼓励程序员从 :exc:`Exception` 类或它的某个子类而不是从 :exc:`BaseException`"
" 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 :ref:`tut-userexceptions` 部分查看。"

#: ../../library/exceptions.rst:39
msgid "Exception context"
msgstr "异常上下文"

#: ../../library/exceptions.rst:46
msgid ""
"Three attributes on exception objects provide information about the context "
"in which the exception was raised:"
msgstr "异常对象上的三个属性提供了有关引发异常所在上下文的信息："

#: ../../library/exceptions.rst:53
msgid ""
"When raising a new exception while another exception is already being "
"handled, the new exception's :attr:`!__context__` attribute is automatically"
" set to the handled exception.  An exception may be handled when an "
":keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used."
msgstr ""
"当有其他异常已经被处理的情况下又引发一个新异常的时候，新异常的 :attr:`!__context__` 属性会被自动设为已经被处理的异常。 "
"异常可以在使用了 :keyword:`except` 或 :keyword:`finally` 子句，或者 :keyword:`with` "
"语句的时候被处理。"

#: ../../library/exceptions.rst:59
msgid ""
"This implicit exception context can be supplemented with an explicit cause "
"by using :keyword:`!from` with :keyword:`raise`::"
msgstr "这个隐式异常上下文可以通过使用 :keyword:`!from` 配合 :keyword:`raise` 来补充一个显式的原因::"

#: ../../library/exceptions.rst:63
msgid "raise new_exc from original_exc"
msgstr "raise new_exc from original_exc"

#: ../../library/exceptions.rst:65
msgid ""
"The expression following :keyword:`from<raise>` must be an exception or "
"``None``. It will be set as :attr:`!__cause__` on the raised exception. "
"Setting :attr:`!__cause__` also implicitly sets the "
":attr:`!__suppress_context__` attribute to ``True``, so that using ``raise "
"new_exc from None`` effectively replaces the old exception with the new one "
"for display purposes (e.g. converting :exc:`KeyError` to "
":exc:`AttributeError`), while leaving the old exception available in "
":attr:`!__context__` for introspection when debugging."
msgstr ""
"跟在 :keyword:`from<raise>` 之后的表达式必须为一个异常或 ``None``。 它将在所引发的异常上被设为 "
":attr:`!__cause__`。 设置 :attr:`!__cause__` 还会隐式地将 "
":attr:`!__suppress_context__` 属性设为 ``True``，这样使用 ``raise new_exc from None``"
" 可以有效地将旧异常替换为新异常来显示其目的 (例如将 :exc:`KeyError` 转换为 "
":exc:`AttributeError`)，同时让旧异常在 :attr:`!__context__` 中保持可用以便在调试时执行内省。"

#: ../../library/exceptions.rst:74
msgid ""
"The default traceback display code shows these chained exceptions in "
"addition to the traceback for the exception itself. An explicitly chained "
"exception in :attr:`!__cause__` is always shown when present. An implicitly "
"chained exception in :attr:`!__context__` is shown only if "
":attr:`!__cause__` is :const:`None` and :attr:`!__suppress_context__` is "
"false."
msgstr ""
"除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 :attr:`!__cause__` 中的显式串连异常如果存在将总是显示。 "
":attr:`!__context__` 中的隐式串连异常仅在 :attr:`!__cause__` 为 :const:`None` 且 "
":attr:`!__suppress_context__` 为假值时显示。"

#: ../../library/exceptions.rst:80
msgid ""
"In either case, the exception itself is always shown after any chained "
"exceptions so that the final line of the traceback always shows the last "
"exception that was raised."
msgstr "不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。"

#: ../../library/exceptions.rst:86
msgid "Inheriting from built-in exceptions"
msgstr "从内置异常继承"

#: ../../library/exceptions.rst:88
msgid ""
"User code can create subclasses that inherit from an exception type. It's "
"recommended to only subclass one exception type at a time to avoid any "
"possible conflicts between how the bases handle the ``args`` attribute, as "
"well as due to possible memory layout incompatibilities."
msgstr ""
"用户代码可以创建继承自某个异常类型的子类。 建议每次仅子类化一个异常类型以避免多个基类处理 ``args`` "
"属性的不同方式，以及内存布局不兼容可能导致的冲突。"

#: ../../library/exceptions.rst:95
msgid ""
"Most built-in exceptions are implemented in C for efficiency, see: "
":source:`Objects/exceptions.c`.  Some have custom memory layouts which makes"
" it impossible to create a subclass that inherits from multiple exception "
"types. The memory layout of a type is an implementation detail and might "
"change between Python versions, leading to new conflicts in the future.  "
"Therefore, it's recommended to avoid subclassing multiple exception types "
"altogether."
msgstr ""
"大多数内置异常都用 C 实现以保证运行效率，参见: :source:`Objects/exceptions.c`。 "
"其中一些具有自定义内存布局，这使得创建继承自多个异常类型的子类成为不可能。 一个类型的内存布局属于实现细节并可能随着 Python "
"版本升级而改变，导致在未来可能产生新的冲突。 因此，建议完全避免子类化多个异常类型。"

#: ../../library/exceptions.rst:105
msgid "Base classes"
msgstr "基类"

#: ../../library/exceptions.rst:107
msgid ""
"The following exceptions are used mostly as base classes for other "
"exceptions."
msgstr "下列异常主要被用作其他异常的基类。"

#: ../../library/exceptions.rst:111
msgid ""
"The base class for all built-in exceptions.  It is not meant to be directly "
"inherited by user-defined classes (for that, use :exc:`Exception`).  If "
":func:`str` is called on an instance of this class, the representation of "
"the argument(s) to the instance are returned, or the empty string when there"
" were no arguments."
msgstr ""
"所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 :exc:`Exception`)。 如果在此类的实例上调用 "
":func:`str`，则会返回实例的参数表示，或者当没有参数时返回空字符串。"

#: ../../library/exceptions.rst:119
msgid ""
"The tuple of arguments given to the exception constructor.  Some built-in "
"exceptions (like :exc:`OSError`) expect a certain number of arguments and "
"assign a special meaning to the elements of this tuple, while others are "
"usually called only with a single string giving an error message."
msgstr ""
"传给异常构造器的参数元组。 某些内置异常 (例如 :exc:`OSError`) "
"接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。"

#: ../../library/exceptions.rst:126
msgid ""
"This method sets *tb* as the new traceback for the exception and returns the"
" exception object.  It was more commonly used before the exception chaining "
"features of :pep:`3134` became available.  The following example shows how "
"we can convert an instance of ``SomeException`` into an instance of "
"``OtherException`` while preserving the traceback.  Once raised, the current"
" frame is pushed onto the traceback of the ``OtherException``, as would have"
" happened to the traceback of the original ``SomeException`` had we allowed "
"it to propagate to the caller. ::"
msgstr ""
"此方法会将 *tb* 设为新的异常回溯信息并返回异常对象。 它在 :pep:`3134` 的异常链特性可用之前更为常用。 下面的例子演示了我们如何将一个"
" ``SomeException`` 实例转换为 ``OtherException`` 实例而保留回溯信息。  异常一旦被引发，当前帧会被推至 "
"``OtherException`` 的回溯栈顶端，就像当我们允许原始 ``SomeException`` "
"被传播给调用方时它的回溯栈将会发生的情形一样。::"

#: ../../library/exceptions.rst:135
msgid ""
"try:\n"
"    ...\n"
"except SomeException:\n"
"    tb = sys.exception().__traceback__\n"
"    raise OtherException(...).with_traceback(tb)"
msgstr ""
"try:\n"
"    ...\n"
"except SomeException:\n"
"    tb = sys.exception().__traceback__\n"
"    raise OtherException(...).with_traceback(tb)"

#: ../../library/exceptions.rst:143
msgid ""
"A writable field that holds the :ref:`traceback object <traceback-objects>` "
"associated with this exception. See also: :ref:`raise`."
msgstr "保存关联到该异常的 :ref:`回溯对象 <traceback-objects>` 的可写字段。 另请参阅: :ref:`raise`。"

#: ../../library/exceptions.rst:149
msgid ""
"Add the string ``note`` to the exception's notes which appear in the "
"standard traceback after the exception string. A :exc:`TypeError` is raised "
"if ``note`` is not a string."
msgstr ""
"将字符串 ``note`` 添加到在异常字符串之后的标准回溯中显示的注释中。 如果 ``note`` 不是一个字符串则会引发 "
":exc:`TypeError`。"

#: ../../library/exceptions.rst:157
msgid ""
"A list of the notes of this exception, which were added with "
":meth:`add_note`. This attribute is created when :meth:`add_note` is called."
msgstr ""
"由此异常的注释组成的列表，它是通过 :meth:`add_note` 添加的。 该属性是在调用 :meth:`add_note` 时创建的。"

#: ../../library/exceptions.rst:165
msgid ""
"All built-in, non-system-exiting exceptions are derived from this class.  "
"All user-defined exceptions should also be derived from this class."
msgstr "所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。"

#: ../../library/exceptions.rst:171
msgid ""
"The base class for those built-in exceptions that are raised for various "
"arithmetic errors: :exc:`OverflowError`, :exc:`ZeroDivisionError`, "
":exc:`FloatingPointError`."
msgstr ""
"此基类用于派生针对各种算术类错误而引发的内置异常: :exc:`OverflowError`, :exc:`ZeroDivisionError`, "
":exc:`FloatingPointError`。"

#: ../../library/exceptions.rst:178
msgid ""
"Raised when a :ref:`buffer <bufferobjects>` related operation cannot be "
"performed."
msgstr "当与 :ref:`缓冲区 <bufferobjects>` 相关的操作无法执行时将被引发。"

#: ../../library/exceptions.rst:184
msgid ""
"The base class for the exceptions that are raised when a key or index used "
"on a mapping or sequence is invalid: :exc:`IndexError`, :exc:`KeyError`.  "
"This can be raised directly by :func:`codecs.lookup`."
msgstr ""
"此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: :exc:`IndexError`, :exc:`KeyError`。 这可以通过 "
":func:`codecs.lookup` 来直接引发。"

#: ../../library/exceptions.rst:190
msgid "Concrete exceptions"
msgstr "具体异常"

#: ../../library/exceptions.rst:192
msgid "The following exceptions are the exceptions that are usually raised."
msgstr "以下异常属于经常被引发的异常。"

#: ../../library/exceptions.rst:198
msgid "Raised when an :keyword:`assert` statement fails."
msgstr "当 :keyword:`assert` 语句失败时将被引发。"

#: ../../library/exceptions.rst:203
msgid ""
"Raised when an attribute reference (see :ref:`attribute-references`) or "
"assignment fails.  (When an object does not support attribute references or "
"attribute assignments at all, :exc:`TypeError` is raised.)"
msgstr ""
"当属性引用 (参见 :ref:`attribute-references`) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发"
" :exc:`TypeError`。）"

#: ../../library/exceptions.rst:207
msgid ""
"The optional *name* and *obj* keyword-only arguments set the corresponding "
"attributes:"
msgstr ""

#: ../../library/exceptions.rst:212
msgid "The name of the attribute that was attempted to be accessed."
msgstr ""

#: ../../library/exceptions.rst:216
msgid "The object that was accessed for the named attribute."
msgstr ""

#: ../../library/exceptions.rst:218
msgid "Added the :attr:`name` and :attr:`obj` attributes."
msgstr "增加了 :attr:`name` 和 :attr:`obj` 属性。"

#: ../../library/exceptions.rst:223
msgid ""
"Raised when the :func:`input` function hits an end-of-file condition (EOF) "
"without reading any data. (Note: the :meth:`!io.IOBase.read` and "
":meth:`io.IOBase.readline` methods return an empty string when they hit "
"EOF.)"
msgstr ""

#: ../../library/exceptions.rst:230
msgid "Not currently used."
msgstr "目前未被使用。"

#: ../../library/exceptions.rst:235
msgid ""
"Raised when a :term:`generator` or :term:`coroutine` is closed; see "
":meth:`generator.close` and :meth:`coroutine.close`.  It directly inherits "
"from :exc:`BaseException` instead of :exc:`Exception` since it is "
"technically not an error."
msgstr ""
"当一个 :term:`generator` 或 :term:`coroutine` 被关闭时将被引发；参见 "
":meth:`generator.close` 和 :meth:`coroutine.close`。 它直接继承自 "
":exc:`BaseException` 而不是 :exc:`Exception`，因为从技术上来说它并不是一个错误。"

#: ../../library/exceptions.rst:243
msgid ""
"Raised when the :keyword:`import` statement has troubles trying to load a "
"module.  Also raised when the \"from list\" in ``from ... import`` has a "
"name that cannot be found."
msgstr ""
"当 :keyword:`import` 语句尝试加载模块遇到麻烦时将被引发。 并且当 ``from ... import`` 中的 \"from "
"list\" 存在无法找到的名称时也会被引发。"

#: ../../library/exceptions.rst:247
msgid ""
"The optional *name* and *path* keyword-only arguments set the corresponding "
"attributes:"
msgstr "可选的 *name* 和 *path* 仅限关键字参数设置相应的属性："

#: ../../library/exceptions.rst:252
msgid "The name of the module that was attempted to be imported."
msgstr "尝试导入的模块的名称。"

#: ../../library/exceptions.rst:256
msgid "The path to any file which triggered the exception."
msgstr "指向任何触发异常的文件的路径。"

#: ../../library/exceptions.rst:258
msgid "Added the :attr:`name` and :attr:`path` attributes."
msgstr "添加了 :attr:`name` 与 :attr:`path` 属性。"

#: ../../library/exceptions.rst:263
msgid ""
"A subclass of :exc:`ImportError` which is raised by :keyword:`import` when a"
" module could not be located.  It is also raised when ``None`` is found in "
":data:`sys.modules`."
msgstr ""
":exc:`ImportError` 的子类，当一个模块无法被定位时将由 :keyword:`import` 引发。 当在 "
":data:`sys.modules` 中找到 ``None`` 时也会被引发。"

#: ../../library/exceptions.rst:272
msgid ""
"Raised when a sequence subscript is out of range.  (Slice indices are "
"silently truncated to fall in the allowed range; if an index is not an "
"integer, :exc:`TypeError` is raised.)"
msgstr "当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 :exc:`TypeError` 会被引发。）"

#: ../../library/exceptions.rst:281
msgid ""
"Raised when a mapping (dictionary) key is not found in the set of existing "
"keys."
msgstr "当在现有键集合中找不到指定的映射（字典）键时将被引发。"

#: ../../library/exceptions.rst:288
msgid ""
"Raised when the user hits the interrupt key (normally :kbd:`Control-C` or "
":kbd:`Delete`).  During execution, a check for interrupts is made regularly."
" The exception inherits from :exc:`BaseException` so as to not be "
"accidentally caught by code that catches :exc:`Exception` and thus prevent "
"the interpreter from exiting."
msgstr ""
"当用户按下中断键 (通常为 :kbd:`Control-C` 或 :kbd:`Delete`) 时将被引发。 在执行期间，会定期检测中断信号。 "
"该异常继承自 :exc:`BaseException` 以确保不会被处理 :exc:`Exception` 的代码意外捕获，这样可以避免退出解释器。"

#: ../../library/exceptions.rst:296
msgid ""
"Catching a :exc:`KeyboardInterrupt` requires special consideration. Because "
"it can be raised at unpredictable points, it may, in some circumstances, "
"leave the running program in an inconsistent state. It is generally best to "
"allow :exc:`KeyboardInterrupt` to end the program as quickly as possible or "
"avoid raising it entirely. (See :ref:`handlers-and-exceptions`.)"
msgstr ""
"捕获 :exc:`KeyboardInterrupt` 需要特别考虑。 "
"因为它可能会在不可预知的点位被引发，在某些情况下，它可能使运行中的程序陷入不一致的状态。 通常最好是让 :exc:`KeyboardInterrupt`"
" 尽快结束程序或者完全避免引发它。 (参见 :ref:`handlers-and-exceptions`。)"

#: ../../library/exceptions.rst:306
msgid ""
"Raised when an operation runs out of memory but the situation may still be "
"rescued (by deleting some objects).  The associated value is a string "
"indicating what kind of (internal) operation ran out of memory. Note that "
"because of the underlying memory management architecture (C's "
":c:func:`malloc` function), the interpreter may not always be able to "
"completely recover from this situation; it nevertheless raises an exception "
"so that a stack traceback can be printed, in case a run-away program was the"
" cause."
msgstr ""
"当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 "
"请注意由于底层的内存管理架构（C 的 :c:func:`malloc` "
"函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。"

#: ../../library/exceptions.rst:317
msgid ""
"Raised when a local or global name is not found.  This applies only to "
"unqualified names.  The associated value is an error message that includes "
"the name that could not be found."
msgstr "当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。"

#: ../../library/exceptions.rst:321
msgid "The optional *name* keyword-only argument sets the attribute:"
msgstr ""

#: ../../library/exceptions.rst:325
msgid "The name of the variable that was attempted to be accessed."
msgstr ""

#: ../../library/exceptions.rst:327
msgid "Added the :attr:`name` attribute."
msgstr "增加了 :attr:`name` 属性。"

#: ../../library/exceptions.rst:333
msgid ""
"This exception is derived from :exc:`RuntimeError`.  In user defined base "
"classes, abstract methods should raise this exception when they require "
"derived classes to override the method, or while the class is being "
"developed to indicate that the real implementation still needs to be added."
msgstr ""
"此异常派生自 :exc:`RuntimeError`。 "
"在用户自定义的基类中，抽象方法应当在其要求所派生类重写该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。"

#: ../../library/exceptions.rst:340
msgid ""
"It should not be used to indicate that an operator or method is not meant to"
" be supported at all -- in that case either leave the operator / method "
"undefined or, if a subclass, set it to :data:`None`."
msgstr ""
"它不应当用来表示一个运算符或方法根本不能被支持 -- 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 :data:`None`。"

#: ../../library/exceptions.rst:346
msgid ""
":exc:`!NotImplementedError` and :data:`!NotImplemented` are not "
"interchangeable. This exception should only be used as described above; see "
":data:`NotImplemented` for details on correct usage of the built-in "
"constant."
msgstr ""
":exc:`!NotImplementedError` 和 :data:`!NotImplemented` 不能互相替代。 "
"此异常应当仅以上文所描述的方式使用；请参阅 :data:`NotImplemented` 了解正确使用该内置常量的相关细节。"

#: ../../library/exceptions.rst:357
msgid ""
"This exception is raised when a system function returns a system-related "
"error, including I/O failures such as \"file not found\" or \"disk full\" "
"(not for illegal argument types or other incidental errors)."
msgstr ""
"此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 \"文件未找到\" 或 \"磁盘已满\" "
"等（不包括非法参数类型或其他偶然性错误）。"

#: ../../library/exceptions.rst:361
msgid ""
"The second form of the constructor sets the corresponding attributes, "
"described below.  The attributes default to :const:`None` if not specified."
"  For backwards compatibility, if three arguments are passed, the "
":attr:`~BaseException.args` attribute contains only a 2-tuple of the first "
"two constructor arguments."
msgstr ""
"构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 :const:`None`。 为了能向下兼容，如果传入了三个参数，则 "
":attr:`~BaseException.args` 属性将仅包含由前两个构造器参数组成的 2 元组。"

#: ../../library/exceptions.rst:367
msgid ""
"The constructor often actually returns a subclass of :exc:`OSError`, as "
"described in `OS exceptions`_ below.  The particular subclass depends on the"
" final :attr:`.errno` value.  This behaviour only occurs when constructing "
":exc:`OSError` directly or via an alias, and is not inherited when "
"subclassing."
msgstr ""
"构造器实际返回的往往是 :exc:`OSError` 的某个子类，如下文 `OS exceptions`_ 中所描述的。 具体的子类取决于最终的 "
":attr:`.errno` 值。 此行为仅在直接或通过别名来构造 :exc:`OSError` 时发生，并且在子类化时不会被继承。"

#: ../../library/exceptions.rst:375
msgid "A numeric error code from the C variable :c:data:`errno`."
msgstr "来自于 C 变量 :c:data:`errno` 的数字错误码。"

#: ../../library/exceptions.rst:379
msgid ""
"Under Windows, this gives you the native Windows error code.  The "
":attr:`.errno` attribute is then an approximate translation, in POSIX terms,"
" of that native error code."
msgstr ""
"在 Windows 下，此参数将给出原生的 Windows 错误码。 而 :attr:`.errno` 属性将是该原生错误码在 POSIX "
"平台下的近似转换形式。"

#: ../../library/exceptions.rst:383
msgid ""
"Under Windows, if the *winerror* constructor argument is an integer, the "
":attr:`.errno` attribute is determined from the Windows error code, and the "
"*errno* argument is ignored.  On other platforms, the *winerror* argument is"
" ignored, and the :attr:`winerror` attribute does not exist."
msgstr ""
"在 Windows 下，如果 *winerror* 构造器参数是一个整数，则 :attr:`.errno` 属性会根据 Windows 错误码来确定，而"
" *errno* 参数会被忽略。 在其他平台上，*winerror* 参数会被忽略，并且 :attr:`winerror` 属性将不存在。"

#: ../../library/exceptions.rst:391
msgid ""
"The corresponding error message, as provided by the operating system.  It is"
" formatted by the C functions :c:func:`!perror` under POSIX, and "
":c:func:`!FormatMessage` under Windows."
msgstr ""

#: ../../library/exceptions.rst:399
msgid ""
"For exceptions that involve a file system path (such as :func:`open` or "
":func:`os.unlink`), :attr:`filename` is the file name passed to the "
"function. For functions that involve two file system paths (such as "
":func:`os.rename`), :attr:`filename2` corresponds to the second file name "
"passed to the function."
msgstr ""
"对于与文件系统路径有关 (例如 :func:`open` 或 :func:`os.unlink`) 的异常，:attr:`filename` "
"是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 :func:`os.rename`)，:attr:`filename2` "
"将是传给函数的第二个文件名。"

#: ../../library/exceptions.rst:406
msgid ""
":exc:`EnvironmentError`, :exc:`IOError`, :exc:`WindowsError`, "
":exc:`socket.error`, :exc:`select.error` and :exc:`!mmap.error` have been "
"merged into :exc:`OSError`, and the constructor may return a subclass."
msgstr ""

#: ../../library/exceptions.rst:412
msgid ""
"The :attr:`filename` attribute is now the original file name passed to the "
"function, instead of the name encoded to or decoded from the "
":term:`filesystem encoding and error handler`. Also, the *filename2* "
"constructor argument and attribute was added."
msgstr ""
":attr:`filename` 属性现在是传给函数的原始文件名，而不是基于 :term:`filesystem encoding and error "
"handler` 进行编码或解码之后的名称。 此外，还添加了 *filename2* 构造器参数和属性。"

#: ../../library/exceptions.rst:421
msgid ""
"Raised when the result of an arithmetic operation is too large to be "
"represented.  This cannot occur for integers (which would rather raise "
":exc:`MemoryError` than give up).  However, for historical reasons, "
"OverflowError is sometimes raised for integers that are outside a required "
"range.   Because of the lack of standardization of floating-point exception "
"handling in C, most floating-point operations are not checked."
msgstr ""
"当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 :exc:`MemoryError` 也不会放弃尝试）。 "
"但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C "
"中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。"

#: ../../library/exceptions.rst:431
msgid ""
"This exception is derived from :exc:`RuntimeError`.  It is raised when an "
"operation is blocked during interpreter shutdown also known as :term:`Python"
" finalization <interpreter shutdown>`."
msgstr ""
"该异常派生自 :exc:`RuntimeError`。 它会在解释器关闭或称 :term:`Python 终结化 <interpreter "
"shutdown>` 期间当有操作被阻止时被引发。"

#: ../../library/exceptions.rst:435
msgid ""
"Examples of operations which can be blocked with a "
":exc:`PythonFinalizationError` during the Python finalization:"
msgstr "在 Python 终结化期间操作被阻止并引发 :exc:`PythonFinalizationError` 的例子："

#: ../../library/exceptions.rst:438
msgid "Creating a new Python thread."
msgstr "新建一个 Python 线程。"

#: ../../library/exceptions.rst:439
msgid ":meth:`Joining <threading.Thread.join>` a running daemon thread."
msgstr ":meth:`并入 <threading.Thread.join>` 一个正在运行的守护线程。"

#: ../../library/exceptions.rst:440
msgid ":func:`os.fork`."
msgstr ":func:`os.fork`。"

#: ../../library/exceptions.rst:442
msgid "See also the :func:`sys.is_finalizing` function."
msgstr "另请参阅 :func:`sys.is_finalizing` 函数。"

#: ../../library/exceptions.rst:444 ../../library/exceptions.rst:457
msgid "Previously, a plain :exc:`RuntimeError` was raised."
msgstr "在此之前将只引发 :exc:`RuntimeError`。"

#: ../../library/exceptions.rst:449
msgid ":meth:`threading.Thread.join` can now raise this exception."
msgstr "现在 :meth:`threading.Thread.join` 可以引发该异常。"

#: ../../library/exceptions.rst:453
msgid ""
"This exception is derived from :exc:`RuntimeError`.  It is raised when the "
"interpreter detects that the maximum recursion depth (see "
":func:`sys.getrecursionlimit`) is exceeded."
msgstr ""
"此异常派生自 :exc:`RuntimeError`。 它会在解释器检测发现超过最大递归深度 (参见 "
":func:`sys.getrecursionlimit`) 时被引发。"

#: ../../library/exceptions.rst:463
msgid ""
"This exception is raised when a weak reference proxy, created by the "
":func:`weakref.proxy` function, is used to access an attribute of the "
"referent after it has been garbage collected. For more information on weak "
"references, see the :mod:`weakref` module."
msgstr ""
"此异常将在使用 :func:`weakref.proxy` 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 "
"有关弱引用的更多信息请参阅 :mod:`weakref` 模块。"

#: ../../library/exceptions.rst:471
msgid ""
"Raised when an error is detected that doesn't fall in any of the other "
"categories.  The associated value is a string indicating what precisely went"
" wrong."
msgstr "当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。"

#: ../../library/exceptions.rst:478
msgid ""
"Raised by built-in function :func:`next` and an :term:`iterator`\\'s "
":meth:`~iterator.__next__` method to signal that there are no further items "
"produced by the iterator."
msgstr ""
"由内置函数 :func:`next` 和 :term:`iterator` 的 :meth:`~iterator.__next__` "
"方法所引发，用来表示该迭代器不能产生下一项。"

#: ../../library/exceptions.rst:484
msgid ""
"The exception object has a single attribute :attr:`!value`, which is given "
"as an argument when constructing the exception, and defaults to "
":const:`None`."
msgstr "该异常对象只有一个属性 :attr:`!value`，它在构造该异常时作为参数给出，默认值为 :const:`None`。"

#: ../../library/exceptions.rst:488
msgid ""
"When a :term:`generator` or :term:`coroutine` function returns, a new "
":exc:`StopIteration` instance is raised, and the value returned by the "
"function is used as the :attr:`value` parameter to the constructor of the "
"exception."
msgstr ""
"当一个 :term:`generator` 或 :term:`coroutine` 函数返回时，将引发一个新的 :exc:`StopIteration`"
" 实例，函数返回的值将被用作异常构造器的 :attr:`value` 形参。"

#: ../../library/exceptions.rst:493
msgid ""
"If a generator code directly or indirectly raises :exc:`StopIteration`, it "
"is converted into a :exc:`RuntimeError` (retaining the :exc:`StopIteration` "
"as the new exception's cause)."
msgstr ""
"如果某个生成器代码直接或间接地引发了 :exc:`StopIteration`，它会被转换为 :exc:`RuntimeError` (并将 "
":exc:`StopIteration` 保留为导致新异常的原因)。"

#: ../../library/exceptions.rst:497
msgid ""
"Added ``value`` attribute and the ability for generator functions to use it "
"to return a value."
msgstr "添加了 ``value`` 属性及其被生成器函数用作返回值的功能。"

#: ../../library/exceptions.rst:501
msgid ""
"Introduced the RuntimeError transformation via ``from __future__ import "
"generator_stop``, see :pep:`479`."
msgstr ""
"引入了通过 ``from __future__ import generator_stop`` 来实现 RuntimeError 转换，参见 "
":pep:`479`。"

#: ../../library/exceptions.rst:505
msgid ""
"Enable :pep:`479` for all code by default: a :exc:`StopIteration` error "
"raised in a generator is transformed into a :exc:`RuntimeError`."
msgstr ""
"默认对所有代码启用 :pep:`479`: 在生成器中引发的 :exc:`StopIteration` 错误将被转换为 "
":exc:`RuntimeError`。"

#: ../../library/exceptions.rst:511
msgid ""
"Must be raised by :meth:`~object.__anext__` method of an :term:`asynchronous"
" iterator` object to stop the iteration."
msgstr ""
"必须由一个 :term:`asynchronous iterator` 对象的 :meth:`~object.__anext__` "
"方法来引发以停止迭代操作。"

#: ../../library/exceptions.rst:518
msgid ""
"Raised when the parser encounters a syntax error.  This may occur in an "
":keyword:`import` statement, in a call to the built-in functions "
":func:`compile`, :func:`exec`, or :func:`eval`, or when reading the initial "
"script or standard input (also interactively)."
msgstr ""
"当解析器遇到语法错误时引发。 这可以发生在 :keyword:`import` 语句，对内置函数 :func:`compile`, "
":func:`exec` 或 :func:`eval` 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。"

#: ../../library/exceptions.rst:524
msgid ""
"The :func:`str` of the exception instance returns only the error message. "
"Details is a tuple whose members are also available as separate attributes."
msgstr "异常实例的 :func:`str` 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获取。"

#: ../../library/exceptions.rst:529
msgid "The name of the file the syntax error occurred in."
msgstr "发生语法错误所在文件的名称。"

#: ../../library/exceptions.rst:533
msgid ""
"Which line number in the file the error occurred in. This is 1-indexed: the "
"first line in the file has a ``lineno`` of 1."
msgstr "发生错误所在文件中的行号。  行号索引从 1 开始：文件中首行的 ``lineno`` 为 1。"

#: ../../library/exceptions.rst:538
msgid ""
"The column in the line where the error occurred. This is 1-indexed: the "
"first character in the line has an ``offset`` of 1."
msgstr "发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 ``offset`` 为 1。"

#: ../../library/exceptions.rst:543
msgid "The source code text involved in the error."
msgstr "错误所涉及的源代码文本。"

#: ../../library/exceptions.rst:547
msgid ""
"Which line number in the file the error occurred ends in. This is 1-indexed:"
" the first line in the file has a ``lineno`` of 1."
msgstr "发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 ``lineno`` 为 1。"

#: ../../library/exceptions.rst:552
msgid ""
"The column in the end line where the error occurred finishes. This is "
"1-indexed: the first character in the line has an ``offset`` of 1."
msgstr "发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 ``offset`` 为 1。"

#: ../../library/exceptions.rst:555
msgid ""
"For errors in f-string fields, the message is prefixed by \"f-string: \" and"
" the offsets are offsets in a text constructed from the replacement "
"expression.  For example, compiling f'Bad {a b} field' results in this args "
"attribute: ('f-string: ...', ('', 1, 2, '(a b)\\n', 1, 5))."
msgstr ""
"对于 f-字符串字段中的错误，消息会带有 \"f-string: \" 前缀并且其位置是基于替换表达式构建的文本中的位置。 例如，编译 f'Bad {a"
" b} field' 将产生这样的 args 属性: ('f-string: ...', ('', 1, 2, '(a b)\\n', 1, 5))。"

#: ../../library/exceptions.rst:560
msgid "Added the :attr:`end_lineno` and :attr:`end_offset` attributes."
msgstr "增加了 :attr:`end_lineno` 和 :attr:`end_offset` 属性。"

#: ../../library/exceptions.rst:565
msgid ""
"Base class for syntax errors related to incorrect indentation.  This is a "
"subclass of :exc:`SyntaxError`."
msgstr "与不正确的缩进相关的语法错误的基类。 这是 :exc:`SyntaxError` 的一个子类。"

#: ../../library/exceptions.rst:571
msgid ""
"Raised when indentation contains an inconsistent use of tabs and spaces. "
"This is a subclass of :exc:`IndentationError`."
msgstr "当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 :exc:`IndentationError` 的一个子类。"

#: ../../library/exceptions.rst:577
msgid ""
"Raised when the interpreter finds an internal error, but the situation does "
"not look so serious to cause it to abandon all hope. The associated value is"
" a string indicating what went wrong (in low-level terms). In "
":term:`CPython`, this could be raised by incorrectly using Python's C API, "
"such as returning a ``NULL`` value without an exception set."
msgstr ""
"当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（使用低层级的表示形式）。 在 "
":term:`CPython` 中，这可能会因不正确地使用 Python 的 C API 而引发，例如返回 ``NULL`` 值而不设置一个异常。"

#: ../../library/exceptions.rst:583
msgid ""
"If you're confident that this exception wasn't your fault, or the fault of a"
" package you're using, you should report this to the author or maintainer of"
" your Python interpreter. Be sure to report the version of the Python "
"interpreter (``sys.version``; it is also printed at the start of an "
"interactive Python session), the exact error message (the exception's "
"associated value) and if possible the source of the program that triggered "
"the error."
msgstr ""
"如果你确信此异常不是你的问题，或你所使用的软件包的问题，你应当将此问题报告给你所用 Python 解释器的作者或维护者。 请确保报告 Python "
"解释器的版本 (``sys.version``；它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息 (异常所关联的值) "
"以及可能触发该错误的程序的源代码。"

#: ../../library/exceptions.rst:594
msgid ""
"This exception is raised by the :func:`sys.exit` function.  It inherits from"
" :exc:`BaseException` instead of :exc:`Exception` so that it is not "
"accidentally caught by code that catches :exc:`Exception`.  This allows the "
"exception to properly propagate up and cause the interpreter to exit.  When "
"it is not handled, the Python interpreter exits; no stack traceback is "
"printed.  The constructor accepts the same optional argument passed to "
":func:`sys.exit`. If the value is an integer, it specifies the system exit "
"status (passed to C's :c:func:`!exit` function); if it is ``None``, the exit"
" status is zero; if it has another type (such as a string), the object's "
"value is printed and the exit status is one."
msgstr ""

#: ../../library/exceptions.rst:605
msgid ""
"A call to :func:`sys.exit` is translated into an exception so that clean-up "
"handlers (:keyword:`finally` clauses of :keyword:`try` statements) can be "
"executed, and so that a debugger can execute a script without running the "
"risk of losing control.  The :func:`os._exit` function can be used if it is "
"absolutely positively necessary to exit immediately (for example, in the "
"child process after a call to :func:`os.fork`)."
msgstr ""
"对 :func:`sys.exit` 的调用会被转换为一个异常以便能执行清理处理程序 (:keyword:`try` 语句的 "
":keyword:`finally` 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 "
":func:`os.fork` 之后的子进程中）则可使用 :func:`os._exit`."

#: ../../library/exceptions.rst:614
msgid ""
"The exit status or error message that is passed to the constructor. "
"(Defaults to ``None``.)"
msgstr "传给构造器的退出状态码或错误信息（默认为 ``None``。）"

#: ../../library/exceptions.rst:620
msgid ""
"Raised when an operation or function is applied to an object of "
"inappropriate type.  The associated value is a string giving details about "
"the type mismatch."
msgstr "当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。"

#: ../../library/exceptions.rst:623
msgid ""
"This exception may be raised by user code to indicate that an attempted "
"operation on an object is not supported, and is not meant to be. If an "
"object is meant to support a given operation but has not yet provided an "
"implementation, :exc:`NotImplementedError` is the proper exception to raise."
msgstr ""
"此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 "
"如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 :exc:`NotImplementedError`。"

#: ../../library/exceptions.rst:628
msgid ""
"Passing arguments of the wrong type (e.g. passing a :class:`list` when an "
":class:`int` is expected) should result in a :exc:`TypeError`, but passing "
"arguments with the wrong value (e.g. a number outside expected boundaries) "
"should result in a :exc:`ValueError`."
msgstr ""
"传入参数的类型错误 (例如在要求 :class:`int` 时却传入了 :class:`list`) 应当导致 "
":exc:`TypeError`，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 :exc:`ValueError`。"

#: ../../library/exceptions.rst:635
msgid ""
"Raised when a reference is made to a local variable in a function or method,"
" but no value has been bound to that variable.  This is a subclass of "
":exc:`NameError`."
msgstr "当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 :exc:`NameError` 的一个子类。"

#: ../../library/exceptions.rst:642
msgid ""
"Raised when a Unicode-related encoding or decoding error occurs.  It is a "
"subclass of :exc:`ValueError`."
msgstr "当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 :exc:`ValueError` 的一个子类。"

#: ../../library/exceptions.rst:645
msgid ""
":exc:`UnicodeError` has attributes that describe the encoding or decoding "
"error.  For example, ``err.object[err.start:err.end]`` gives the particular "
"invalid input that the codec failed on."
msgstr ""
":exc:`UnicodeError` 具有一些描述编码或解码错误的属性。 例如 ``err.object[err.start:err.end]`` "
"会给出导致编解码器失败的特定无效输入。"

#: ../../library/exceptions.rst:651
msgid "The name of the encoding that raised the error."
msgstr "引发错误的编码名称。"

#: ../../library/exceptions.rst:655
msgid "A string describing the specific codec error."
msgstr "描述特定编解码器错误的字符串。"

#: ../../library/exceptions.rst:659
msgid "The object the codec was attempting to encode or decode."
msgstr "编解码器试图要编码或解码的对象。"

#: ../../library/exceptions.rst:663
msgid "The first index of invalid data in :attr:`object`."
msgstr ":attr:`object` 中无效数据的开始位置索引。"

#: ../../library/exceptions.rst:665 ../../library/exceptions.rst:672
msgid ""
"This value should not be negative as it is interpreted as an absolute offset"
" but this constraint is not enforced at runtime."
msgstr "该值将被解读为绝对偏移量所以它不应为负数但是该项约束不会在运行时强制执行。"

#: ../../library/exceptions.rst:670
msgid "The index after the last invalid data in :attr:`object`."
msgstr ":attr:`object` 中无效数据的末尾位置索引（不含）。"

#: ../../library/exceptions.rst:678
msgid ""
"Raised when a Unicode-related error occurs during encoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 :exc:`UnicodeError` 的一个子类。"

#: ../../library/exceptions.rst:684
msgid ""
"Raised when a Unicode-related error occurs during decoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 :exc:`UnicodeError` 的一个子类。"

#: ../../library/exceptions.rst:690
msgid ""
"Raised when a Unicode-related error occurs during translating.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 :exc:`UnicodeError` 的一个子类。"

#: ../../library/exceptions.rst:696
msgid ""
"Raised when an operation or function receives an argument that has the right"
" type but an inappropriate value, and the situation is not described by a "
"more precise exception such as :exc:`IndexError`."
msgstr "当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 :exc:`IndexError` 来描述时将被引发。"

#: ../../library/exceptions.rst:703
msgid ""
"Raised when the second argument of a division or modulo operation is zero.  "
"The associated value is a string indicating the type of the operands and the"
" operation."
msgstr "当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。"

#: ../../library/exceptions.rst:708
msgid ""
"The following exceptions are kept for compatibility with previous versions; "
"starting from Python 3.3, they are aliases of :exc:`OSError`."
msgstr "下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 :exc:`OSError` 的别名。"

#: ../../library/exceptions.rst:717
msgid "Only available on Windows."
msgstr "限在 Windows 中可用。"

#: ../../library/exceptions.rst:721
msgid "OS exceptions"
msgstr "OS 异常"

#: ../../library/exceptions.rst:723
msgid ""
"The following exceptions are subclasses of :exc:`OSError`, they get raised "
"depending on the system error code."
msgstr "下列异常均为 :exc:`OSError` 的子类，它们将根据系统错误代码被引发。"

#: ../../library/exceptions.rst:728
msgid ""
"Raised when an operation would block on an object (e.g. socket) set for non-"
"blocking operation. Corresponds to :c:data:`errno` "
":py:const:`~errno.EAGAIN`, :py:const:`~errno.EALREADY`, "
":py:const:`~errno.EWOULDBLOCK` and :py:const:`~errno.EINPROGRESS`."
msgstr ""
"当一个操作将在设置为非阻塞操作的对象（例如套接字）上发生阻塞时将被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.EAGAIN`, :py:const:`~errno.EALREADY`, "
":py:const:`~errno.EWOULDBLOCK` 和 :py:const:`~errno.EINPROGRESS`。"

#: ../../library/exceptions.rst:733
msgid ""
"In addition to those of :exc:`OSError`, :exc:`BlockingIOError` can have one "
"more attribute:"
msgstr "除了 :exc:`OSError` 已有的属性，:exc:`BlockingIOError` 还有一个额外属性："

#: ../../library/exceptions.rst:738
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked.  This attribute is available when using the buffered I/O classes"
" from the :mod:`io` module."
msgstr "一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 :mod:`io` 模块的带缓冲 I/O 类时此属性可用。"

#: ../../library/exceptions.rst:744
msgid ""
"Raised when an operation on a child process failed. Corresponds to "
":c:data:`errno` :py:const:`~errno.ECHILD`."
msgstr "当一个子进程上的操作失败时将被引发。 对应于 :c:data:`errno` :py:const:`~errno.ECHILD`。"

#: ../../library/exceptions.rst:749
msgid "A base class for connection-related issues."
msgstr "与连接相关问题的基类。"

#: ../../library/exceptions.rst:751
msgid ""
"Subclasses are :exc:`BrokenPipeError`, :exc:`ConnectionAbortedError`, "
":exc:`ConnectionRefusedError` and :exc:`ConnectionResetError`."
msgstr ""
"其子类有 :exc:`BrokenPipeError`, :exc:`ConnectionAbortedError`, "
":exc:`ConnectionRefusedError` 和 :exc:`ConnectionResetError`。"

#: ../../library/exceptions.rst:756
msgid ""
"A subclass of :exc:`ConnectionError`, raised when trying to write on a pipe "
"while the other end has been closed, or trying to write on a socket which "
"has been shutdown for writing. Corresponds to :c:data:`errno` "
":py:const:`~errno.EPIPE` and :py:const:`~errno.ESHUTDOWN`."
msgstr ""
":exc:`ConnectionError` 的子类，当试图写入一个管道而其另一端已关闭，或者试图写入一个套接字而其已关闭写入时将被引发。 对应于 "
":c:data:`errno` :py:const:`~errno.EPIPE` 和 :py:const:`~errno.ESHUTDOWN`。"

#: ../../library/exceptions.rst:763
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is "
"aborted by the peer. Corresponds to :c:data:`errno` "
":py:const:`~errno.ECONNABORTED`."
msgstr ""
":exc:`ConnectionError` 的子类，当一个连接尝试被对端中止时将被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.ECONNABORTED`。"

#: ../../library/exceptions.rst:769
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is "
"refused by the peer. Corresponds to :c:data:`errno` "
":py:const:`~errno.ECONNREFUSED`."
msgstr ""
":exc:`ConnectionError` 的子类，当一个连接尝试被对端拒绝时将被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.ECONNREFUSED`。"

#: ../../library/exceptions.rst:775
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection is reset by "
"the peer. Corresponds to :c:data:`errno` :py:const:`~errno.ECONNRESET`."
msgstr ""
":exc:`ConnectionError` 的子类，当一个连接尝试被对端重置时将被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.ECONNRESET`。"

#: ../../library/exceptions.rst:781
msgid ""
"Raised when trying to create a file or directory which already exists. "
"Corresponds to :c:data:`errno` :py:const:`~errno.EEXIST`."
msgstr "当试图创建一个已存在的文件或目录时将被引发。 对应于 :c:data:`errno` :py:const:`~errno.EEXIST`。"

#: ../../library/exceptions.rst:786
msgid ""
"Raised when a file or directory is requested but doesn't exist. Corresponds "
"to :c:data:`errno` :py:const:`~errno.ENOENT`."
msgstr "当所请求的文件或目录不存在时将被引发。 对应于 :c:data:`errno` :py:const:`~errno.ENOENT`。"

#: ../../library/exceptions.rst:791
msgid ""
"Raised when a system call is interrupted by an incoming signal. Corresponds "
"to :c:data:`errno` :py:const:`~errno.EINTR`."
msgstr "当一个系统调用被传入的信号中断时将被引发。 对应于 :c:data:`errno` :py:const:`~errno.EINTR`。"

#: ../../library/exceptions.rst:794
msgid ""
"Python now retries system calls when a syscall is interrupted by a signal, "
"except if the signal handler raises an exception (see :pep:`475` for the "
"rationale), instead of raising :exc:`InterruptedError`."
msgstr ""
"当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 :pep:`475`) 而不是引发 "
":exc:`InterruptedError`。"

#: ../../library/exceptions.rst:801
msgid ""
"Raised when a file operation (such as :func:`os.remove`) is requested on a "
"directory. Corresponds to :c:data:`errno` :py:const:`~errno.EISDIR`."
msgstr ""
"当请求对一个目录执行文件操作 (如 :func:`os.remove`) 时将被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.EISDIR`。"

#: ../../library/exceptions.rst:807
msgid ""
"Raised when a directory operation (such as :func:`os.listdir`) is requested "
"on something which is not a directory.  On most POSIX platforms, it may also"
" be raised if an operation attempts to open or traverse a non-directory file"
" as if it were a directory. Corresponds to :c:data:`errno` "
":py:const:`~errno.ENOTDIR`."
msgstr ""
"当请求对一个非目录执行目录操作 (如 :func:`os.listdir`) 时将被引发。 在大多数 POSIX "
"平台上，它还可能在某个操作试图将一个非目录作为目录打开或遍历时被引发。 对应于 :c:data:`errno` "
":py:const:`~errno.ENOTDIR`。"

#: ../../library/exceptions.rst:815
msgid ""
"Raised when trying to run an operation without the adequate access rights - "
"for example filesystem permissions. Corresponds to :c:data:`errno` "
":py:const:`~errno.EACCES`, :py:const:`~errno.EPERM`, and "
":py:const:`~errno.ENOTCAPABLE`."
msgstr ""
"当在没有足够访问权限的情况下试图运行某个操作时将被引发 —— 例如文件系统权限。 对应于 :c:data:`errno` "
":py:const:`~errno.EACCES`, :py:const:`~errno.EPERM` 和 "
":py:const:`~errno.ENOTCAPABLE`。"

#: ../../library/exceptions.rst:820
msgid ""
"WASI's :py:const:`~errno.ENOTCAPABLE` is now mapped to "
":exc:`PermissionError`."
msgstr "WASI 的 :py:const:`~errno.ENOTCAPABLE` 现在被映射至 :exc:`PermissionError`。"

#: ../../library/exceptions.rst:826
msgid ""
"Raised when a given process doesn't exist. Corresponds to :c:data:`errno` "
":py:const:`~errno.ESRCH`."
msgstr "当给定的进程不存在时将被引发。 对应于 :c:data:`errno` :py:const:`~errno.ESRCH`。"

#: ../../library/exceptions.rst:831
msgid ""
"Raised when a system function timed out at the system level. Corresponds to "
":c:data:`errno` :py:const:`~errno.ETIMEDOUT`."
msgstr ""
"当一个系统函数在系统层级发生超时的情况下将被引发。 对应于 :c:data:`errno` :py:const:`~errno.ETIMEDOUT`。"

#: ../../library/exceptions.rst:834
msgid "All the above :exc:`OSError` subclasses were added."
msgstr "添加了以上所有 :exc:`OSError` 的子类。"

#: ../../library/exceptions.rst:840
msgid ":pep:`3151` - Reworking the OS and IO exception hierarchy"
msgstr ":pep:`3151` - 重写 OS 和 IO 异常的层次结构"

#: ../../library/exceptions.rst:846
msgid "Warnings"
msgstr "警告"

#: ../../library/exceptions.rst:848
msgid ""
"The following exceptions are used as warning categories; see the "
":ref:`warning-categories` documentation for more details."
msgstr "下列异常被用作警告类别；请参阅 :ref:`warning-categories` 文档了解详情。"

#: ../../library/exceptions.rst:853
msgid "Base class for warning categories."
msgstr "警告类别的基类。"

#: ../../library/exceptions.rst:858
msgid "Base class for warnings generated by user code."
msgstr "用户代码所产生警告的基类。"

#: ../../library/exceptions.rst:863
msgid ""
"Base class for warnings about deprecated features when those warnings are "
"intended for other Python developers."
msgstr "如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。"

#: ../../library/exceptions.rst:866
msgid ""
"Ignored by the default warning filters, except in the ``__main__`` module "
"(:pep:`565`). Enabling the :ref:`Python Development Mode <devmode>` shows "
"this warning."
msgstr ""
"会被默认警告过滤器忽略，在 ``__main__`` 模块中的情况除外 (:pep:`565`)。 启用 :ref:`Python 开发模式 "
"<devmode>` 时会显示此警告。"

#: ../../library/exceptions.rst:870 ../../library/exceptions.rst:886
msgid "The deprecation policy is described in :pep:`387`."
msgstr "这个弃用政策是在 :pep:`387` 中描述的。"

#: ../../library/exceptions.rst:875
msgid ""
"Base class for warnings about features which are obsolete and expected to be"
" deprecated in the future, but are not deprecated at the moment."
msgstr "对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。"

#: ../../library/exceptions.rst:879
msgid ""
"This class is rarely used as emitting a warning about a possible upcoming "
"deprecation is unusual, and :exc:`DeprecationWarning` is preferred for "
"already active deprecations."
msgstr ""
"这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 :exc:`DeprecationWarning`。"

#: ../../library/exceptions.rst:883 ../../library/exceptions.rst:909
#: ../../library/exceptions.rst:936
msgid ""
"Ignored by the default warning filters. Enabling the :ref:`Python "
"Development Mode <devmode>` shows this warning."
msgstr "会被默认警告过滤器忽略。 启用 :ref:`Python 开发模式 <devmode>` 时会显示此警告。"

#: ../../library/exceptions.rst:891
msgid "Base class for warnings about dubious syntax."
msgstr "与模糊的语法相关的警告的基类。"

#: ../../library/exceptions.rst:896
msgid "Base class for warnings about dubious runtime behavior."
msgstr "与模糊的运行时行为相关的警告的基类。"

#: ../../library/exceptions.rst:901
msgid ""
"Base class for warnings about deprecated features when those warnings are "
"intended for end users of applications that are written in Python."
msgstr "如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。"

#: ../../library/exceptions.rst:907
msgid "Base class for warnings about probable mistakes in module imports."
msgstr "与在模块导入中可能的错误相关的警告的基类。"

#: ../../library/exceptions.rst:915
msgid "Base class for warnings related to Unicode."
msgstr "与 Unicode 相关的警告的基类。"

#: ../../library/exceptions.rst:920
msgid "Base class for warnings related to encodings."
msgstr "与编码格式相关的警告的基类。"

#: ../../library/exceptions.rst:922
msgid "See :ref:`io-encoding-warning` for details."
msgstr "请参阅 :ref:`io-encoding-warning` 来了解详情。"

#: ../../library/exceptions.rst:929
msgid ""
"Base class for warnings related to :class:`bytes` and :class:`bytearray`."
msgstr "与 :class:`bytes` 和 :class:`bytearray` 相关的警告的基类。"

#: ../../library/exceptions.rst:934
msgid "Base class for warnings related to resource usage."
msgstr "资源使用相关警告的基类。"

#: ../../library/exceptions.rst:945
msgid "Exception groups"
msgstr "异常组"

#: ../../library/exceptions.rst:947
msgid ""
"The following are used when it is necessary to raise multiple unrelated "
"exceptions. They are part of the exception hierarchy so they can be handled "
"with :keyword:`except` like all other exceptions. In addition, they are "
"recognised by :keyword:`except*<except_star>`, which matches their subgroups"
" based on the types of the contained exceptions."
msgstr ""
"下列异常是在有必要引发多个不相关联的异常时使用的。 它们是异常层级结构的一部分因此它们可以像所有其他异常一样通过 :keyword:`except` "
"来处理。 此外，它们还可被 :keyword:`except*<except_star>` 所识别，此语法将基于所包含异常的类型来匹配其子分组。"

#: ../../library/exceptions.rst:956
msgid ""
"Both of these exception types wrap the exceptions in the sequence ``excs``. "
"The ``msg`` parameter must be a string. The difference between the two "
"classes is that :exc:`BaseExceptionGroup` extends :exc:`BaseException` and "
"it can wrap any exception, while :exc:`ExceptionGroup` extends "
":exc:`Exception` and it can only wrap subclasses of :exc:`Exception`. This "
"design is so that ``except Exception`` catches an :exc:`ExceptionGroup` but "
"not :exc:`BaseExceptionGroup`."
msgstr ""
"这两个异常类型都将多个异常包装在序列 ``excs`` 中。 ``msg`` 形参必须为一个字符串。 这两个类之间的区别在于 "
":exc:`BaseExceptionGroup` 扩展了 :exc:`BaseException` 并且它可以包装任何异常，而 "
":exc:`ExceptionGroup` 则扩展了 :exc:`Exception` 并且它只能包装 :exc:`Exception` 的子类。 "
"这样的设计是为了使得 ``except Exception`` 只捕获 :exc:`ExceptionGroup` 而不捕获 "
":exc:`BaseExceptionGroup`。"

#: ../../library/exceptions.rst:964
msgid ""
"The :exc:`BaseExceptionGroup` constructor returns an :exc:`ExceptionGroup` "
"rather than a :exc:`BaseExceptionGroup` if all contained exceptions are "
":exc:`Exception` instances, so it can be used to make the selection "
"automatic. The :exc:`ExceptionGroup` constructor, on the other hand, raises "
"a :exc:`TypeError` if any contained exception is not an :exc:`Exception` "
"subclass."
msgstr ""
":exc:`BaseExceptionGroup` 构造器返回一个 :exc:`ExceptionGroup` 而不是 "
":exc:`BaseExceptionGroup`，如果所包含的全部异常都是 :exc:`Exception` "
"的实例的话，因此它可以被用来制造自动化的选择。 在另一方面，:exc:`ExceptionGroup` 构造器则会引发 "
":exc:`TypeError`，如果所包含的任何异常不是 :exc:`Exception` 的子类的话。"

#: ../../library/exceptions.rst:973
msgid ""
"The ``msg`` argument to the constructor. This is a read-only attribute."
msgstr "传给构造器的 ``msg`` 参数。 这是一个只读属性。"

#: ../../library/exceptions.rst:977
msgid ""
"A tuple of the exceptions in the ``excs`` sequence given to the constructor."
" This is a read-only attribute."
msgstr "传给构造器的 ``excs`` 序列中的由异常组成的元组。 这是一个只读属性。"

#: ../../library/exceptions.rst:982
msgid ""
"Returns an exception group that contains only the exceptions from the "
"current group that match *condition*, or ``None`` if the result is empty."
msgstr "返回一个只包含来自当前组的匹配 *condition* 的异常的异常组，或者如果结果为空则返回 ``None``。"

#: ../../library/exceptions.rst:985
msgid ""
"The condition can be an exception type or tuple of exception types, in which"
" case each exception is checked for a match using the same check that is "
"used in an ``except`` clause.  The condition can also be a callable (other "
"than a type object) that accepts an exception as its single argument and "
"returns true for the exceptions that should be in the subgroup."
msgstr ""
"该条件可以是一个异常类型或由异常类型组成的元组，在后一种情况中将对每个异常使用在 ``except`` 子句中所使用的相同检测方式来检测是否匹配。 "
"该条件也可以是一个可调用对象（而非类型对象），它接受一个异常作为其唯一参数并会针对应当属于特定子分组的异常返回真值。"

#: ../../library/exceptions.rst:991
msgid ""
"The nesting structure of the current exception is preserved in the result, "
"as are the values of its :attr:`message`, "
":attr:`~BaseException.__traceback__`, :attr:`~BaseException.__cause__`, "
":attr:`~BaseException.__context__` and :attr:`~BaseException.__notes__` "
"fields. Empty nested groups are omitted from the result."
msgstr ""
"当前异常的嵌套结构会在结果中保留，就如其 :attr:`message`, :attr:`~BaseException.__traceback__`, "
":attr:`~BaseException.__cause__`, :attr:`~BaseException.__context__` 和 "
":attr:`~BaseException.__notes__` 字段的值一样。 空的嵌套组会在结果中被略去。"

#: ../../library/exceptions.rst:998
msgid ""
"The condition is checked for all exceptions in the nested exception group, "
"including the top-level and any nested exception groups. If the condition is"
" true for such an exception group, it is included in the result in full."
msgstr "条件检测会针对嵌套异常组中的所有异常执行，包括最高层级的和任何嵌套的异常组。 如果针对此类异常组的条件为真值，它将被完整包括在结果中。"

#: ../../library/exceptions.rst:1002
msgid "``condition`` can be any callable which is not a type object."
msgstr "``condition`` 可以是任意不为类型对象的可调用对象。"

#: ../../library/exceptions.rst:1007
msgid ""
"Like :meth:`subgroup`, but returns the pair ``(match, rest)`` where "
"``match`` is ``subgroup(condition)`` and ``rest`` is the remaining non-"
"matching part."
msgstr ""
"类似于 :meth:`subgroup`，但将返回 ``(match, rest)`` 对，其中 ``match`` 为 "
"``subgroup(condition)`` 而 ``rest`` 为剩余的非匹配部分。"

#: ../../library/exceptions.rst:1013
msgid ""
"Returns an exception group with the same :attr:`message`, but which wraps "
"the exceptions in ``excs``."
msgstr "返回一个具有相同 :attr:`message` 的异常组，但会将异常包装在 ``excs`` 中。"

#: ../../library/exceptions.rst:1016
msgid ""
"This method is used by :meth:`subgroup` and :meth:`split`, which are used in"
" various contexts to break up an exception group. A subclass needs to "
"override it in order to make :meth:`subgroup` and :meth:`split` return "
"instances of the subclass rather than :exc:`ExceptionGroup`."
msgstr ""
"此方法是由 :meth:`subgroup` 和 :meth:`split` 使用的，它们被用于在各种上下文中拆分异常组。 子类需要重写它以便让 "
":meth:`subgroup` 和 :meth:`split` 返回子类的实例而不是 :exc:`ExceptionGroup`。"

#: ../../library/exceptions.rst:1022
msgid ""
":meth:`subgroup` and :meth:`split` copy the "
":attr:`~BaseException.__traceback__`, :attr:`~BaseException.__cause__`, "
":attr:`~BaseException.__context__` and :attr:`~BaseException.__notes__` "
"fields from the original exception group to the one returned by "
":meth:`derive`, so these fields do not need to be updated by :meth:`derive`."
msgstr ""
":meth:`subgroup` 和 :meth:`split` 会从原始异常组拷贝 "
":attr:`~BaseException.__traceback__`, :attr:`~BaseException.__cause__`, "
":attr:`~BaseException.__context__` 和 :attr:`~BaseException.__notes__` 字段到 "
":meth:`derive` 所返回的异常组，这样这些字段就不需要被 :meth:`derive` 更新。"

#: ../../library/exceptions.rst:1029
msgid ""
">>> class MyGroup(ExceptionGroup):\n"
"...     def derive(self, excs):\n"
"...         return MyGroup(self.message, excs)\n"
"...\n"
">>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n"
">>> e.add_note(\"a note\")\n"
">>> e.__context__ = Exception(\"context\")\n"
">>> e.__cause__ = Exception(\"cause\")\n"
">>> try:\n"
"...    raise e\n"
"... except Exception as e:\n"
"...    exc = e\n"
"...\n"
">>> match, rest = exc.split(ValueError)\n"
">>> exc, exc.__context__, exc.__cause__, exc.__notes__\n"
"(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> match, match.__context__, match.__cause__, match.__notes__\n"
"(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> rest, rest.__context__, rest.__cause__, rest.__notes__\n"
"(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\n"
"True"
msgstr ""
">>> class MyGroup(ExceptionGroup):\n"
"...     def derive(self, excs):\n"
"...         return MyGroup(self.message, excs)\n"
"...\n"
">>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n"
">>> e.add_note(\"a note\")\n"
">>> e.__context__ = Exception(\"context\")\n"
">>> e.__cause__ = Exception(\"cause\")\n"
">>> try:\n"
"...    raise e\n"
"... except Exception as e:\n"
"...    exc = e\n"
"...\n"
">>> match, rest = exc.split(ValueError)\n"
">>> exc, exc.__context__, exc.__cause__, exc.__notes__\n"
"(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> match, match.__context__, match.__cause__, match.__notes__\n"
"(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> rest, rest.__context__, rest.__cause__, rest.__notes__\n"
"(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n"
">>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\n"
"True"

#: ../../library/exceptions.rst:1055
msgid ""
"Note that :exc:`BaseExceptionGroup` defines :meth:`~object.__new__`, so "
"subclasses that need a different constructor signature need to override that"
" rather than :meth:`~object.__init__`. For example, the following defines an"
" exception group subclass which accepts an exit_code and constructs the "
"group's message from it. ::"
msgstr ""
"请注意 :exc:`BaseExceptionGroup` 定义了 "
":meth:`~object.__new__`，因此需要不同构造器签名的子类必须重写该方法而不是 :meth:`~object.__init__`。 "
"例如，下面定义了一个接受 exit_code 并根据它来构造分组消息的异常组子类。 ::"

#: ../../library/exceptions.rst:1061
msgid ""
"class Errors(ExceptionGroup):\n"
"   def __new__(cls, errors, exit_code):\n"
"      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n"
"      self.exit_code = exit_code\n"
"      return self\n"
"\n"
"   def derive(self, excs):\n"
"      return Errors(excs, self.exit_code)"
msgstr ""
"class Errors(ExceptionGroup):\n"
"   def __new__(cls, errors, exit_code):\n"
"      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n"
"      self.exit_code = exit_code\n"
"      return self\n"
"\n"
"   def derive(self, excs):\n"
"      return Errors(excs, self.exit_code)"

#: ../../library/exceptions.rst:1070
msgid ""
"Like :exc:`ExceptionGroup`, any subclass of :exc:`BaseExceptionGroup` which "
"is also a subclass of :exc:`Exception` can only wrap instances of "
":exc:`Exception`."
msgstr ""
"类似于 :exc:`ExceptionGroup`，任何 :exc:`BaseExceptionGroup` 的子类也是 "
":exc:`Exception` 的子类，只能包装 :exc:`Exception` 的实例。"

#: ../../library/exceptions.rst:1078
msgid "Exception hierarchy"
msgstr "异常层次结构"

#: ../../library/exceptions.rst:1080
msgid "The class hierarchy for built-in exceptions is:"
msgstr "内置异常的类层级结构如下："

#: ../../library/exceptions.rst:1082
msgid ""
"BaseException\n"
" ├── BaseExceptionGroup\n"
" ├── GeneratorExit\n"
" ├── KeyboardInterrupt\n"
" ├── SystemExit\n"
" └── Exception\n"
"      ├── ArithmeticError\n"
"      │    ├── FloatingPointError\n"
"      │    ├── OverflowError\n"
"      │    └── ZeroDivisionError\n"
"      ├── AssertionError\n"
"      ├── AttributeError\n"
"      ├── BufferError\n"
"      ├── EOFError\n"
"      ├── ExceptionGroup [BaseExceptionGroup]\n"
"      ├── ImportError\n"
"      │    └── ModuleNotFoundError\n"
"      ├── LookupError\n"
"      │    ├── IndexError\n"
"      │    └── KeyError\n"
"      ├── MemoryError\n"
"      ├── NameError\n"
"      │    └── UnboundLocalError\n"
"      ├── OSError\n"
"      │    ├── BlockingIOError\n"
"      │    ├── ChildProcessError\n"
"      │    ├── ConnectionError\n"
"      │    │    ├── BrokenPipeError\n"
"      │    │    ├── ConnectionAbortedError\n"
"      │    │    ├── ConnectionRefusedError\n"
"      │    │    └── ConnectionResetError\n"
"      │    ├── FileExistsError\n"
"      │    ├── FileNotFoundError\n"
"      │    ├── InterruptedError\n"
"      │    ├── IsADirectoryError\n"
"      │    ├── NotADirectoryError\n"
"      │    ├── PermissionError\n"
"      │    ├── ProcessLookupError\n"
"      │    └── TimeoutError\n"
"      ├── ReferenceError\n"
"      ├── RuntimeError\n"
"      │    ├── NotImplementedError\n"
"      │    ├── PythonFinalizationError\n"
"      │    └── RecursionError\n"
"      ├── StopAsyncIteration\n"
"      ├── StopIteration\n"
"      ├── SyntaxError\n"
"      │    └── IndentationError\n"
"      │         └── TabError\n"
"      ├── SystemError\n"
"      ├── TypeError\n"
"      ├── ValueError\n"
"      │    └── UnicodeError\n"
"      │         ├── UnicodeDecodeError\n"
"      │         ├── UnicodeEncodeError\n"
"      │         └── UnicodeTranslateError\n"
"      └── Warning\n"
"           ├── BytesWarning\n"
"           ├── DeprecationWarning\n"
"           ├── EncodingWarning\n"
"           ├── FutureWarning\n"
"           ├── ImportWarning\n"
"           ├── PendingDeprecationWarning\n"
"           ├── ResourceWarning\n"
"           ├── RuntimeWarning\n"
"           ├── SyntaxWarning\n"
"           ├── UnicodeWarning\n"
"           └── UserWarning\n"
msgstr ""
"BaseException\n"
" ├── BaseExceptionGroup\n"
" ├── GeneratorExit\n"
" ├── KeyboardInterrupt\n"
" ├── SystemExit\n"
" └── Exception\n"
"      ├── ArithmeticError\n"
"      │    ├── FloatingPointError\n"
"      │    ├── OverflowError\n"
"      │    └── ZeroDivisionError\n"
"      ├── AssertionError\n"
"      ├── AttributeError\n"
"      ├── BufferError\n"
"      ├── EOFError\n"
"      ├── ExceptionGroup [BaseExceptionGroup]\n"
"      ├── ImportError\n"
"      │    └── ModuleNotFoundError\n"
"      ├── LookupError\n"
"      │    ├── IndexError\n"
"      │    └── KeyError\n"
"      ├── MemoryError\n"
"      ├── NameError\n"
"      │    └── UnboundLocalError\n"
"      ├── OSError\n"
"      │    ├── BlockingIOError\n"
"      │    ├── ChildProcessError\n"
"      │    ├── ConnectionError\n"
"      │    │    ├── BrokenPipeError\n"
"      │    │    ├── ConnectionAbortedError\n"
"      │    │    ├── ConnectionRefusedError\n"
"      │    │    └── ConnectionResetError\n"
"      │    ├── FileExistsError\n"
"      │    ├── FileNotFoundError\n"
"      │    ├── InterruptedError\n"
"      │    ├── IsADirectoryError\n"
"      │    ├── NotADirectoryError\n"
"      │    ├── PermissionError\n"
"      │    ├── ProcessLookupError\n"
"      │    └── TimeoutError\n"
"      ├── ReferenceError\n"
"      ├── RuntimeError\n"
"      │    ├── NotImplementedError\n"
"      │    ├── PythonFinalizationError\n"
"      │    └── RecursionError\n"
"      ├── StopAsyncIteration\n"
"      ├── StopIteration\n"
"      ├── SyntaxError\n"
"      │    └── IndentationError\n"
"      │         └── TabError\n"
"      ├── SystemError\n"
"      ├── TypeError\n"
"      ├── ValueError\n"
"      │    └── UnicodeError\n"
"      │         ├── UnicodeDecodeError\n"
"      │         ├── UnicodeEncodeError\n"
"      │         └── UnicodeTranslateError\n"
"      └── Warning\n"
"           ├── BytesWarning\n"
"           ├── DeprecationWarning\n"
"           ├── EncodingWarning\n"
"           ├── FutureWarning\n"
"           ├── ImportWarning\n"
"           ├── PendingDeprecationWarning\n"
"           ├── ResourceWarning\n"
"           ├── RuntimeWarning\n"
"           ├── SyntaxWarning\n"
"           ├── UnicodeWarning\n"
"           └── UserWarning\n"

#: ../../library/exceptions.rst:6 ../../library/exceptions.rst:17
#: ../../library/exceptions.rst:196
msgid "statement"
msgstr "statement -- 语句"

#: ../../library/exceptions.rst:6
msgid "try"
msgstr "try"

#: ../../library/exceptions.rst:6
msgid "except"
msgstr "except"

#: ../../library/exceptions.rst:17
msgid "raise"
msgstr "raise"

#: ../../library/exceptions.rst:41
msgid "exception"
msgstr "异常"

#: ../../library/exceptions.rst:41
msgid "chaining"
msgstr "chaining"

#: ../../library/exceptions.rst:41
msgid "__cause__ (exception attribute)"
msgstr "__cause__ (异常属性)"

#: ../../library/exceptions.rst:41
msgid "__context__ (exception attribute)"
msgstr "__context__ (异常属性)"

#: ../../library/exceptions.rst:41
msgid "__suppress_context__ (exception attribute)"
msgstr "__suppress_context__ (异常属性)"

#: ../../library/exceptions.rst:196
msgid "assert"
msgstr "assert"

#: ../../library/exceptions.rst:355
msgid "module"
msgstr "module"

#: ../../library/exceptions.rst:355
msgid "errno"
msgstr "errno"
