# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:06+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/runpy.rst:2
msgid ":mod:`runpy` --- Locating and executing Python modules"
msgstr ":mod:`runpy` ——查找并执行 Python  模块"

#: ../../library/runpy.rst:9
msgid "**Source code:** :source:`Lib/runpy.py`"
msgstr "**源代码：** :source:`Lib/runpy.py`"

#: ../../library/runpy.rst:13
msgid ""
"The :mod:`runpy` module is used to locate and run Python modules without "
"importing them first. Its main use is to implement the :option:`-m` command "
"line switch that allows scripts to be located using the Python module "
"namespace rather than the filesystem."
msgstr ""
":mod:`runpy` 模块用于找到并运行 Python 的模块，而无需首先导入。主要用于实现 :option:`-m` 命令行开关，以允许用 "
"Python 模块命名空间而不是文件系统来定位脚本。"

#: ../../library/runpy.rst:18
msgid ""
"Note that this is *not* a sandbox module - all code is executed in the "
"current process, and any side effects (such as cached imports of other "
"modules) will remain in place after the functions have returned."
msgstr "请注意，这 *并非* 一个沙盒模块——所有代码都在当前进程中运行，所有副作用（如其他模块对导入操作进行了缓存）在函数返回后都会留存。"

#: ../../library/runpy.rst:22
msgid ""
"Furthermore, any functions and classes defined by the executed code are not "
"guaranteed to work correctly after a :mod:`runpy` function has returned. If "
"that limitation is not acceptable for a given use case, :mod:`importlib` is "
"likely to be a more suitable choice than this module."
msgstr ""
"此外，在 :mod:`runpy` 函数返回后，任何由已执行代码定义的函数和类都不能保证正确工作。如果某使用场景不能接收此限制，那么选用 "
":mod:`importlib` 可能更合适些。"

#: ../../library/runpy.rst:27
msgid "The :mod:`runpy` module provides two functions:"
msgstr ":mod:`runpy` 模块提供两个函数："

#: ../../library/runpy.rst:35
msgid ""
"Execute the code of the specified module and return the resulting module "
"globals dictionary. The module's code is first located using the standard "
"import mechanism (refer to :pep:`302` for details) and then executed in a "
"fresh module namespace."
msgstr ""
"执行给定模块的代码，并返回结果模块的 globals 字典。 该模块的代码首先会用标准的导入机制去查找定位 (详情请参阅 "
":pep:`302`)，然后在全新的模块命名空间中运行。"

#: ../../library/runpy.rst:40
msgid ""
"The *mod_name* argument should be an absolute module name. If the module "
"name refers to a package rather than a normal module, then that package is "
"imported and the :mod:`__main__` submodule within that package is then "
"executed and the resulting module globals dictionary returned."
msgstr ""
"*mod_name* 参数应当是一个绝对模块名。 如果模块名指向一个包而非普通模块，则会导入这个包然后执行这个包中的 :mod:`__main__` "
"子模块再返回模块全局字典。"

#: ../../library/runpy.rst:46
msgid ""
"The optional dictionary argument *init_globals* may be used to pre-populate "
"the module's globals dictionary before the code is executed. The supplied "
"dictionary will not be modified. If any of the special global variables "
"below are defined in the supplied dictionary, those definitions are "
"overridden by :func:`run_module`."
msgstr ""
"可选的字典参数 *init_globals* 可用来在代码执行前预填充模块的 globals "
"字典。给出的字典参数不会被修改。如果字典中定义了以下任意一个特殊全局变量，这些定义都会被 :func:`run_module` 覆盖。"

#: ../../library/runpy.rst:52 ../../library/runpy.rst:122
msgid ""
"The special global variables ``__name__``, ``__spec__``, ``__file__``, "
"``__cached__``, ``__loader__`` and ``__package__`` are set in the globals "
"dictionary before the module code is executed (Note that this is a minimal "
"set of variables - other variables may be set implicitly as an interpreter "
"implementation detail)."
msgstr ""
" 在模块代码执行前，特殊全局变量 ``__name__`` 、``__spec__`` 、``__file__`` "
"、``__cached__````__loader__`` 和 ``__package__`` 会在 globals "
"字典进行设置（注意，这是一个最小集——其他变量可能由解释器的实现代码进行隐式设置）。"

#: ../../library/runpy.rst:58
msgid ""
"``__name__`` is set to *run_name* if this optional argument is not "
":const:`None`, to ``mod_name + '.__main__'`` if the named module is a "
"package and to the *mod_name* argument otherwise."
msgstr ""
"若可选参数 ``__name__`` 不为 :const:`None` 则设为 *run_name*，若此名称的模块是一个包则设为 ``mod_name"
" + '.__main__'``，否则设为 *mod_name* 参数。"

#: ../../library/runpy.rst:62
msgid ""
"``__spec__`` will be set appropriately for the *actually* imported module "
"(that is, ``__spec__.name`` will always be *mod_name* or ``mod_name + "
"'.__main__``, never *run_name*)."
msgstr ""
"``__spec__`` 将设为合适的 *实际* 导入模块（也就是说，``__spec__.name`` 一定是 *mod_name* 或  "
"``mod_name + '.__main__``，而不是 *run_name*）。"

#: ../../library/runpy.rst:66
msgid ""
"``__file__``, ``__cached__``, ``__loader__`` and ``__package__`` are "
":ref:`set as normal <import-mod-attrs>` based on the module spec."
msgstr ""
"``__file__`` 、``__cached__``、 ``__loader__`` 和 ``__package__`` 根据模块规格进行 "
":ref:`常规设置 <import-mod-attrs>`"

#: ../../library/runpy.rst:69
msgid ""
"If the argument *alter_sys* is supplied and evaluates to :const:`True`, then"
" ``sys.argv[0]`` is updated with the value of ``__file__`` and "
"``sys.modules[__name__]`` is updated with a temporary module object for the "
"module being executed. Both ``sys.argv[0]`` and ``sys.modules[__name__]`` "
"are restored to their original values before the function returns."
msgstr ""
"如果给出了参数 *alter_sys* 并且值为 :const:`True`，那么 ``sys.argv[0]`` 将被更新为 ``__file__``"
" 的值，``sys.modules[__name__]`` 将被更新为临时模块对象。在函数返回前， ``sys.argv[0]`` 和 "
"``sys.modules[__name__]`` 将会复原。"

#: ../../library/runpy.rst:75
msgid ""
"Note that this manipulation of :mod:`sys` is not thread-safe. Other threads "
"may see the partially initialised module, as well as the altered list of "
"arguments. It is recommended that the ``sys`` module be left alone when "
"invoking this function from threaded code."
msgstr ""
"请注意对 :mod:`sys` 的这种操作不是线程安全的。 其他线程可能会看到部分初始化的模块，以及更改后的参数列表。 "
"建议当从线程中的代码调用此函数时不要使用 ``sys`` 模块。"

#: ../../library/runpy.rst:81
msgid ""
"The :option:`-m` option offering equivalent functionality from the command "
"line."
msgstr ":option:`-m` 选项由命令行提供相同功能。"

#: ../../library/runpy.rst:84
msgid ""
"Added ability to execute packages by looking for a :mod:`__main__` "
"submodule."
msgstr "增加了通过查找 :mod:`__main__` 子模块来执行包的功能。"

#: ../../library/runpy.rst:87
msgid "Added ``__cached__`` global variable (see :pep:`3147`)."
msgstr "加入了 ``__cached__`` 全局变量（参见  :pep:`3147` ）。"

#: ../../library/runpy.rst:90
msgid ""
"Updated to take advantage of the module spec feature added by :pep:`451`. "
"This allows ``__cached__`` to be set correctly for modules run this way, as "
"well as ensuring the real module name is always accessible as "
"``__spec__.name``."
msgstr ""
"充分利用 :pep:`451` 加入的模块规格功能。使得以这种方式运行的模块能够正确设置 ``__cached__``，并确保真正的模块名称总是可以通过"
" ``__spec__.name`` 的形式访问。"

#: ../../library/runpy.rst:101
msgid ""
"Execute the code at the named filesystem location and return the resulting "
"module globals dictionary. As with a script name supplied to the CPython "
"command line, the supplied path may refer to a Python source file, a "
"compiled bytecode file or a valid :data:`sys.path` entry containing a "
":mod:`__main__` module (e.g. a zipfile containing a top-level "
"``__main__.py`` file)."
msgstr ""
"执行指定文件系统位置上的代码并返回结果模块的 globals 字典。 与提供给 CPython 命令行的脚本名称一样，所提供的路径可以指向 Python"
" 源文件、编译后的字节码文件或包含 :mod:`__main__` 模块的有效 :data:`sys.path` 条目（例如一个包含最高层级 "
"``__main__.py`` 文件的 zip 文件）。"

#: ../../library/runpy.rst:108
msgid ""
"For a simple script, the specified code is simply executed in a fresh module"
" namespace. For a valid :data:`sys.path` entry (typically a zipfile or "
"directory), the entry is first added to the beginning of ``sys.path``. The "
"function then looks for and executes a :mod:`__main__` module using the "
"updated path. Note that there is no special protection against invoking an "
"existing ``__main__`` entry located elsewhere on ``sys.path`` if there is no"
" such module at the specified location."
msgstr ""
"对于简单的脚本而言，只需在新的模块命名空间中执行指定的代码即可。 对于一个有效的 :data:`sys.path` 条目（通常是一个 zip "
"文件或目录），首先会将该条目添加到 ``sys.path`` 的开头。 然后函数会使用更新后的路径查找并执行 :mod:`__main__` 模块。 "
"请注意如果在指定的位置上没有 ``__main__`` 模块那么在唤起位于 ``sys.path`` 中其他位置上的现有条目时也不会受到特殊保护。"

#: ../../library/runpy.rst:116
msgid ""
"The optional dictionary argument *init_globals* may be used to pre-populate "
"the module's globals dictionary before the code is executed. The supplied "
"dictionary will not be modified. If any of the special global variables "
"below are defined in the supplied dictionary, those definitions are "
"overridden by :func:`run_path`."
msgstr ""
"利用可选的字典参数 *init_globals* ，可在代码执行前预填模块的 globals "
"字典。给出的字典参数不会被修改。如果给出的字典中定义了下列特殊全局变量，这些定义均会被 :func:`run_module` 覆盖。"

#: ../../library/runpy.rst:128
msgid ""
"``__name__`` is set to *run_name* if this optional argument is not "
":const:`None` and to ``'<run_path>'`` otherwise."
msgstr ""
"如果该可选参数不为 :const:`None`，则 ``__name__`` 被设为 *run_name*，否则为 ``'<run_path>'``。"

#: ../../library/runpy.rst:131
msgid ""
"If the supplied path directly references a script file (whether as source or"
" as precompiled byte code), then ``__file__`` will be set to the supplied "
"path, and ``__spec__``, ``__cached__``, ``__loader__`` and ``__package__`` "
"will all be set to :const:`None`."
msgstr ""
"如果提供的路径直接引用了一个脚本文件（无论是源码文件还是预编译的字节码），那么 ``__file__`` 将设为给出的路径，而 "
"``__spec__``、``__cached__``、``__loader__`` 和 ``__package__`` 都将设为 "
":const:`None`。"

#: ../../library/runpy.rst:136
msgid ""
"If the supplied path is a reference to a valid :data:`sys.path` entry, then "
"``__spec__`` will be set appropriately for the imported :mod:`__main__` "
"module (that is, ``__spec__.name`` will always be ``__main__``). "
"``__file__``, ``__cached__``, ``__loader__`` and ``__package__`` will be "
":ref:`set as normal <import-mod-attrs>` based on the module spec."
msgstr ""
"如果给出的路径是对有效 :data:`sys.path` 条目的引用，那么 ``__spec__`` 将为导入的 :mod:`__main__` "
"模块进行正确设置 (也就是说，``__spec__.name`` 将总是为 ``__main__``)。 ``__file__``, "
"``__cached__``, ``__loader__`` 和 ``__package__`` 将依据模块规格说明 :ref:`正常设置 "
"<import-mod-attrs>`。"

#: ../../library/runpy.rst:142
msgid ""
"A number of alterations are also made to the :mod:`sys` module. Firstly, "
":data:`sys.path` may be altered as described above. ``sys.argv[0]`` is "
"updated with the value of ``path_name`` and ``sys.modules[__name__]`` is "
"updated with a temporary module object for the module being executed. All "
"modifications to items in :mod:`sys` are reverted before the function "
"returns."
msgstr ""
":mod:`sys` 模块也进行了多处发动。 首先，:data:`sys.path` 可能做上文所述的修改。 ``sys.argv[0]`` 会使用 "
"``path_name`` 的值进行更新而 ``sys.modules[__name__]`` 会使用对应于正在被执行的模块的临时模块对象进行更新。 "
"在函数返回之前对 :mod:`sys` 中条目的所有修改都会被复原。"

#: ../../library/runpy.rst:149
msgid ""
"Note that, unlike :func:`run_module`, the alterations made to :mod:`sys` are"
" not optional in this function as these adjustments are essential to "
"allowing the execution of :data:`sys.path` entries. As the thread-safety "
"limitations still apply, use of this function in threaded code should be "
"either serialised with the import lock or delegated to a separate process."
msgstr ""
"请注意，与 :func:`run_module` 不同，对 :mod:`sys` 的修改在本函数中不是可选项，因为这些调整对于允许执行 "
":data:`sys.path` 条目来说是至关重要的。 "
"由于线程安全限制仍然适用，在线程代码中使用该函数应当使用导入锁进行序列化，或是委托给单独的进程。"

#: ../../library/runpy.rst:156
msgid ""
":ref:`using-on-interface-options` for equivalent functionality on the "
"command line (``python path/to/script``)."
msgstr ""
":ref:`using-on-interface-options` 用于在命令行上实现同等功能（``python path/to/script``）。"

#: ../../library/runpy.rst:161
msgid ""
"Updated to take advantage of the module spec feature added by :pep:`451`. "
"This allows ``__cached__`` to be set correctly in the case where "
"``__main__`` is imported from a valid :data:`sys.path` entry rather than "
"being executed directly."
msgstr ""
"进行更新以便利用 :pep:`451` 加入的模块规格特性。 这允许在 ``__main__`` 是从有效的 :data:`sys.path` "
"条目导入而不是直接执行的情况下能够正确地设置 ``__cached__``。"

#: ../../library/runpy.rst:170
msgid ":pep:`338` -- Executing modules as scripts"
msgstr ":pep:`338` -- 将模块作为脚本执行"

#: ../../library/runpy.rst:170 ../../library/runpy.rst:173
msgid "PEP written and implemented by Nick Coghlan."
msgstr "PEP 由 Nick Coghlan 撰写并实现。"

#: ../../library/runpy.rst:173
msgid ":pep:`366` -- Main module explicit relative imports"
msgstr ":pep:`366` ——主模块的显式相对导入"

#: ../../library/runpy.rst:176
msgid ":pep:`451` -- A ModuleSpec Type for the Import System"
msgstr ":pep:`451` —— 导入系统采用的 ModuleSpec 类型"

#: ../../library/runpy.rst:176
msgid "PEP written and implemented by Eric Snow"
msgstr "PEP 由  Eric Snow 撰写并实现。"

#: ../../library/runpy.rst:178
msgid ":ref:`using-on-general` - CPython command line details"
msgstr ":ref:`using-on-general` —— CPython 命令行详解"

#: ../../library/runpy.rst:180
msgid "The :func:`importlib.import_module` function"
msgstr ":func:`importlib.import_module` 函数"

#: ../../library/runpy.rst:32 ../../library/runpy.rst:98
msgid "module"
msgstr "module"

#: ../../library/runpy.rst:32 ../../library/runpy.rst:98
msgid "__main__"
msgstr "__main__"
