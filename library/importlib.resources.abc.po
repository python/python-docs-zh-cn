# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.resources.abc.rst:2
msgid ":mod:`!importlib.resources.abc` -- Abstract base classes for resources"
msgstr ":mod:`!importlib.resources.abc` -- 资源的抽象基类"

#: ../../library/importlib.resources.abc.rst:7
msgid "**Source code:** :source:`Lib/importlib/resources/abc.py`"
msgstr "**源代码:** :source:`Lib/importlib/resources/abc.py`"

#: ../../library/importlib.resources.abc.rst:15
msgid "*Superseded by TraversableResources*"
msgstr "*被 TraversableResources* 取代"

#: ../../library/importlib.resources.abc.rst:17
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr "提供读取 *resources* 能力的一个 :term:`abstract base class` 。"

#: ../../library/importlib.resources.abc.rst:20
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip"
" file versus on the file system."
msgstr ""
"从这个 ABC 的视角出发，*resource* 指一个包附带的二进制文件。常见的如在包的  ``__init__.py`` "
"文件旁的数据文件。这个类存在的目的是为了将对数据文件的访问进行抽象，这样包就和其数据文件的存储方式无关了。不论这些文件是存放在一个 zip "
"文件里还是直接在文件系统内。"

#: ../../library/importlib.resources.abc.rst:28
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a "
":term:`path-like object` which represents conceptually just a file name. "
"This means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names"
" is packages and resources, respectively. This is also why instances of this"
" class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"对于该类中的任一方法，*resource* 参数的值都需要是一个在概念上表示文件名称的 :term:`path-like object`。 "
"这意味着任何子目录的路径都不该出现在 *resouce* 参数值内。 因为对于阅读器而言，包的位置就代表着「目录」。 "
"因此目录和文件名就分别对应于包和资源。 这也是该类的实例都需要和一个包直接关联（而不是潜在指代很多包或者一整个模块）的原因。"

#: ../../library/importlib.resources.abc.rst:39
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible"
" with this ABC should only be returned when the specified module is a "
"package."
msgstr ""
"想支持资源读取的加载器需要提供一个返回实现了此 ABC 的接口的 ``get_resource_reader(fullname)`` "
"方法。如果通过全名指定的模块不是一个包，这个方法应该返回 :const:`None`。 "
"当指定的模块是一个包时，应该只返回一个与这个抽象类ABC兼容的对象。"

#: ../../library/importlib.resources.abc.rst:46
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr "使用 :class:`importlib.resources.abc.TraversableResources` 代替。"

#: ../../library/importlib.resources.abc.rst:52
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr "返回一个打开的 :term:`file-like object` 用于 *resource* 的二进制读取。"

#: ../../library/importlib.resources.abc.rst:55
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "如果无法找到资源，将会引发 :exc:`FileNotFoundError`。"

#: ../../library/importlib.resources.abc.rst:61
msgid "Returns the file system path to the *resource*."
msgstr "返回 *resource* 的文件系统路径。"

#: ../../library/importlib.resources.abc.rst:63
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr "如果资源并不实际存在于文件系统中，将会引发 :exc:`FileNotFoundError`。"

#: ../../library/importlib.resources.abc.rst:69
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"如果 *name* 被视作资源，则返回True。如果 *name* 不存在，则引发 :exc:`FileNotFoundError` 异常。"

#: ../../library/importlib.resources.abc.rst:75
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""
"反回由字符串组成的 :term:`iterable`，表示这个包的所有内容。 请注意并不要求迭代器返回的所有名称都是实际的资源，例如返回 "
":meth:`is_resource` 为假值的名称也是可接受的。"

#: ../../library/importlib.resources.abc.rst:81
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used "
"directly."
msgstr ""
"允许非资源名字被返回是为了允许存储的一个包和它的资源的方式是已知先验的并且非资源名字会有用的情况。比如，允许返回子目录名字，目的是当得知包和资源存储在文件系统上面的时候，能够直接使用子目录的名字。"

#: ../../library/importlib.resources.abc.rst:89
msgid "The abstract method returns an iterable of no items."
msgstr "这个抽象方法返回了一个不包含任何内容的可迭代对象。"

#: ../../library/importlib.resources.abc.rst:94
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr "一个具有 :class:`pathlib.Path` 中方法的子集并适用于遍历目录和打开文件的对象。"

#: ../../library/importlib.resources.abc.rst:97
msgid ""
"For a representation of the object on the file-system, use "
":meth:`importlib.resources.as_file`."
msgstr "对于该对象在文件系统中的表示形式，请使用 :meth:`importlib.resources.as_file`。"

#: ../../library/importlib.resources.abc.rst:102
msgid "Abstract. The base name of this object without any parent references."
msgstr "抽象属性。 此对象的不带任何父引用的基本名称。"

#: ../../library/importlib.resources.abc.rst:107
msgid "Yield Traversable objects in self."
msgstr "产出自身内部的可遍历对象。"

#: ../../library/importlib.resources.abc.rst:112
msgid "Return ``True`` if self is a directory."
msgstr "如果 self 是一个目录则返回 ``True``。"

#: ../../library/importlib.resources.abc.rst:117
msgid "Return ``True`` if self is a file."
msgstr "如果 self 是一个文件则返回 ``True``。"

#: ../../library/importlib.resources.abc.rst:122
msgid ""
"Traverse directories according to *pathsegments* and return the result as "
":class:`!Traversable`."
msgstr "按照 *pathsegments* 遍历目录并以 :class:`!Traversable` 形式返回结果。"

#: ../../library/importlib.resources.abc.rst:125
msgid ""
"Each *pathsegments* argument may contain multiple names separated by forward"
" slashes (``/``, ``posixpath.sep`` ). For example, the following are "
"equivalent::"
msgstr ""
"每个 *pathsegments* 参数可能包含以正斜杠 (``/``, ``posixpath.sep`` ) 分隔的多个名称。 "
"例如，以下值是等价的::"

#: ../../library/importlib.resources.abc.rst:129
msgid ""
"files.joinpath('subdir', 'subsuddir', 'file.txt')\n"
"files.joinpath('subdir/subsuddir/file.txt')"
msgstr ""
"files.joinpath('subdir', 'subsuddir', 'file.txt')\n"
"files.joinpath('subdir/subsuddir/file.txt')"

#: ../../library/importlib.resources.abc.rst:132
msgid ""
"Note that some :class:`!Traversable` implementations might not be updated to"
" the latest version of the protocol. For compatibility with such "
"implementations, provide a single argument without path separators to each "
"call to ``joinpath``. For example::"
msgstr ""
"请注意某些 :class:`!Traversable` 实现可能没有升级到最新版本的协议。 要与这样的实现保持兼容，可以向每个对 "
"``joinpath`` 的调用提供提供单个不带路径分隔符的参数。 例如::"

#: ../../library/importlib.resources.abc.rst:137
msgid "files.joinpath('subdir').joinpath('subsubdir').joinpath('file.txt')"
msgstr "files.joinpath('subdir').joinpath('subsubdir').joinpath('file.txt')"

#: ../../library/importlib.resources.abc.rst:141
msgid ""
"``joinpath`` accepts multiple *pathsegments*, and these segments may contain"
" forward slashes as path separators. Previously, only a single *child* "
"argument was accepted."
msgstr ""
"``joinpath`` 接受多个 *pathsegments*，这些部分可以包含正斜杠作为路径分隔符。 在之前版本中，只接受单个 *child* "
"参数。"

#: ../../library/importlib.resources.abc.rst:148
msgid "Return Traversable child in self. Equivalent to ``joinpath(child)``."
msgstr "返回可遍历的子对象自身。 等价于 ``joinpath(child)``。"

#: ../../library/importlib.resources.abc.rst:154
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* 可以为 'r' 或 'rb' 即以文本或二进制模式打开。 返回一个适用于读取的句柄（与 :attr:`pathlib.Path.open`"
" 样同）。"

#: ../../library/importlib.resources.abc.rst:157
msgid ""
"When opening as text, accepts encoding parameters such as those accepted by "
":class:`io.TextIOWrapper`."
msgstr "当以文件模式打开时，接受与 :class:`io.TextIOWrapper` 所接受的相同编码格式形参。"

#: ../../library/importlib.resources.abc.rst:162
msgid "Read contents of self as bytes."
msgstr "以字节串形式读取自身的内容。"

#: ../../library/importlib.resources.abc.rst:166
msgid "Read contents of self as text."
msgstr "以文本形式读取自身的内容。"

#: ../../library/importlib.resources.abc.rst:171
msgid ""
"An abstract base class for resource readers capable of serving the "
":meth:`importlib.resources.files` interface. Subclasses "
":class:`ResourceReader` and provides concrete implementations of the "
":class:`!ResourceReader`'s abstract methods. Therefore, any loader supplying"
" :class:`!TraversableResources` also supplies :class:`!ResourceReader`."
msgstr ""
"针对能够为 :meth:`importlib.resources.files` 接口提供服务的资源读取器的抽象基类。 子类化 "
":class:`ResourceReader` 并为 :class:`!ResourceReader` 的抽象方法提供具体实现。 因此 ，任何提供了 "
":class:`!TraversableResources` 的加载器也会提供 :class:`!ResourceReader`。"

#: ../../library/importlib.resources.abc.rst:178
msgid ""
"Loaders that wish to support resource reading are expected to implement this"
" interface."
msgstr "需要支持资源读取的加载器应实现此接口。"

#: ../../library/importlib.resources.abc.rst:184
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded"
" package."
msgstr "为载入的包返回一个 :class:`importlib.resources.abc.Traversable` 对象。"
