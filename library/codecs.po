# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:02+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/codecs.rst:2
msgid ":mod:`!codecs` --- Codec registry and base classes"
msgstr ":mod:`!codecs` --- 编解码器注册和相关基类"

#: ../../library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**源代码：** :source:`Lib/codecs.py`"

#: ../../library/codecs.rst:23
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that"
" encode to :class:`bytes`."
msgstr ""
"这个模块定义了标准 Python 编解码器（编码器和解码器）的基类并提供对内部 Python "
"编解码器注册表的访问，该注册表负责管理编解码器和错误处理的查找过程。 大多数标准编解码器都属于 :term:`文本编码格式 <text "
"encoding>`，它们可将文本编码为字节串（以及将字节串解码为文本），但也提供了一些将文本编码为文本，以及将字节串编码为字节串的编解码器。 "
"自定义编解码器可以在任意类型间进行编码和解码，但某些模块特性被限制为仅适用于 :term:`文本编码格式 <text encoding>` "
"或将数据编码为 :class:`bytes` 的编解码器。"

#: ../../library/codecs.rst:33
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr "该模块定义了以下用于使用任何编解码器进行编码和解码的函数:"

#: ../../library/codecs.rst:38
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "使用为 *encoding* 注册的编解码器对 *obj* 进行编码。"

#: ../../library/codecs.rst:40
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise "
":exc:`ValueError` (or a more codec specific subclass, such as "
":exc:`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"可以给定 *Errors* 以设置所需要的错误处理方案。 默认的错误处理方案 ``'strict'`` 表示编码错误将引发 "
":exc:`ValueError` (或更特定编解码器相关的子类，例如 :exc:`UnicodeEncodeError`)。 请参阅 "
":ref:`codec-base-classes` 了解有关编解码器错误处理的更多信息。"

#: ../../library/codecs.rst:48
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "使用为 *encoding* 注册的编解码器对 *obj* 进行解码。"

#: ../../library/codecs.rst:50
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise "
":exc:`ValueError` (or a more codec specific subclass, such as "
":exc:`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"可以给定 *Errors* 以设置所需要的错误处理方案。 默认的错误处理方案 ``'strict'`` 表示编码错误将引发 "
":exc:`ValueError` (或更特定编解码器相关的子类，例如 :exc:`UnicodeDecodeError`)。 请参阅 "
":ref:`codec-base-classes` 了解有关编解码器错误处理的更多信息。"

#: ../../library/codecs.rst:58
msgid ""
"Return a mapping suitable for encoding with a custom single-byte encoding. "
"Given a :class:`str` *string* of up to 256 characters representing a "
"decoding table, returns either a compact internal mapping object "
"``EncodingMap`` or a :class:`dictionary <dict>` mapping character ordinals "
"to byte values. Raises a :exc:`TypeError` on invalid input."
msgstr ""
"返回一个适用于以自定义单字节编码格式进行编码的映射。 给定一个表示解码表的至多 256 个字符的 :class:`str` "
"*string*，返回一个将字符序号映射到字节值的紧凑内部映射对象 ``EncodingMap`` 或 :class:`字典 <dict>`。 "
"对于不合法的输入将引发 :exc:`TypeError`。"

#: ../../library/codecs.rst:64
msgid "The full details for each codec can also be looked up directly:"
msgstr "每种编解码器的完整细节也可以直接查找获取："

#: ../../library/codecs.rst:68
msgid ""
"Looks up the codec info in the Python codec registry and returns a "
":class:`CodecInfo` object as defined below."
msgstr "在 Python 编解码器注册表中查找编解码器信息，并返回一个 :class:`CodecInfo` 对象，其定义见下文。"

#: ../../library/codecs.rst:71
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the "
":class:`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"首先将会在注册表缓存中查找编码，如果未找到，则会扫描注册的搜索函数列表。 如果没有找到 :class:`CodecInfo` 对象，则将引发 "
":exc:`LookupError`。 否则，:class:`CodecInfo` 对象将被存入缓存并返回给调用者。"

#: ../../library/codecs.rst:78
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr "查找编解码器注册表所得到的编解码器细节信息。 构造器参数将保存为同名的属性："

#: ../../library/codecs.rst:84
msgid "The name of the encoding."
msgstr "编码名称"

#: ../../library/codecs.rst:90
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and "
":meth:`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface "
"<codec-objects>`). The functions or methods are expected to work in a "
"stateless mode."
msgstr ""
"无状态的编码和解码函数。 它们必须是具有与 Codec 的 :meth:`~Codec.encode` 和 :meth:`~Codec.decode` "
"方法相同接口的函数或方法 (参见 :ref:`Codec 接口 <codec-objects>`)。 这些函数或方法应当工作于无状态的模式。"

#: ../../library/codecs.rst:100
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes "
":class:`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"增量式的编码器和解码器类或工厂函数。 这些函数必须分别提供由基类 :class:`IncrementalEncoder` 和 "
":class:`IncrementalDecoder` 所定义的接口。 增量式编解码器可以保持状态。"

#: ../../library/codecs.rst:109
msgid ""
"Stream writer and reader classes or factory functions. These have to provide"
" the interface defined by the base classes :class:`StreamWriter` and "
":class:`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"流式写入器和读取器类或工厂函数。 这些函数必须分别提供由基类 :class:`StreamWriter` 和 :class:`StreamReader`"
" 所定义的接口。 流式编解码器可以保持状态。"

#: ../../library/codecs.rst:114
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr "为了简化对各种编解码器组件的访问，本模块提供了以下附加函数，它们使用 :func:`lookup` 来执行编解码器查找："

#: ../../library/codecs.rst:119
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr "查找给定编码的编解码器并返回其编码器函数。"

#: ../../library/codecs.rst:121 ../../library/codecs.rst:128
#: ../../library/codecs.rst:154 ../../library/codecs.rst:162
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "在编码无法找到时将引发 :exc:`LookupError`。"

#: ../../library/codecs.rst:126
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr "查找给定编码的编解码器并返回其解码器函数。"

#: ../../library/codecs.rst:133
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr "查找给定编码的编解码器并返回其增量式编码器类或工厂函数。"

#: ../../library/codecs.rst:136
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr "在编码无法找到或编解码器不支持增量式编码器时将引发 :exc:`LookupError`。"

#: ../../library/codecs.rst:142
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr "查找给定编码的编解码器并返回其增量式解码器类或工厂函数。"

#: ../../library/codecs.rst:145
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr "在编码无法找到或编解码器不支持增量式解码器时将引发 :exc:`LookupError`。"

#: ../../library/codecs.rst:151
msgid ""
"Look up the codec for the given encoding and return its "
":class:`StreamReader` class or factory function."
msgstr "查找给定编码的编解码器并返回其 :class:`StreamReader` 类或工厂函数。"

#: ../../library/codecs.rst:159
msgid ""
"Look up the codec for the given encoding and return its "
":class:`StreamWriter` class or factory function."
msgstr "查找给定编码的编解码器并返回其 :class:`StreamWriter` 类或工厂函数。"

#: ../../library/codecs.rst:164
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr "自定义编解码器的启用是通过注册适当的编解码器搜索函数："

#: ../../library/codecs.rst:169
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and"
" spaces converted to underscores, and return a :class:`CodecInfo` object. In"
" case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"注册一个编解码器搜索函数。 搜索函数预期接收一个参数，即全部以小写字母表示的编码格式名称，其中中连字符和空格会被转换为下划线，并返回一个 "
":class:`CodecInfo` 对象。 在搜索函数无法找到给定编码格式的情况下，它应当返回 ``None``。"

#: ../../library/codecs.rst:175
msgid "Hyphens and spaces are converted to underscore."
msgstr "连字符和空格会被转换为下划线。"

#: ../../library/codecs.rst:181
msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr "注销一个编解码器搜索函数并清空注册表缓存。 如果指定搜索函数未被注册，则不做任何操作。"

#: ../../library/codecs.rst:187
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"虽然内置的 :func:`open` 和相关联的 :mod:`io` "
"模块是操作已编码文本文件的推荐方式，但本模块也提供了额外的工具函数和类，允许在操作二进制文件时使用更多种类的编解码器："

#: ../../library/codecs.rst:194
msgid ""
"Open an encoded file using the given *mode* and return an instance of "
":class:`StreamReaderWriter`, providing transparent encoding/decoding. The "
"default file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"使用给定的 *mode* 打开已编码的文件并返回一个 :class:`StreamReaderWriter` 的实例，提供透明的编码/解码。 "
"默认的文件模式为 ``'r'``，表示以读取模式打开文件。"

#: ../../library/codecs.rst:200
msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""
"如果 *encoding* 不为 ``None``，则下层的已编码文件总是以二进制模式打开。 在读取和写入时不会自动执行 ``'\\n'`` 的转换。 "
"*mode* 参数可以是内置 :func:`open` 函数所接受的任意二进制模式；``'b'`` 会被自动添加。"

#: ../../library/codecs.rst:206
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* 指定文件所要使用的编码格式。 允许任何编码为字节串或从字节串解码的编码格式，而文件方法所支持的数据类型则取决于所使用的编解码器。"

#: ../../library/codecs.rst:210
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"可以指定 *errors* 来定义错误处理方案。 默认值 ``'strict'`` 表示在出现编码错误时引发 :exc:`ValueError`。"

#: ../../library/codecs.rst:213
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr "*buffering* 的含义与内置 :func:`open` 函数中的相同。 默认值 -1 表示将使用默认的缓冲区大小。"

#: ../../library/codecs.rst:216
msgid "The ``'U'`` mode has been removed."
msgstr "``'U'`` 模式已被移除。"

#: ../../library/codecs.rst:222
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"返回一个 :class:`StreamRecoder` 实例，它提供了 *file* 的透明转码包装版本。 当包装版本被关闭时原始文件也会被关闭。"

#: ../../library/codecs.rst:226
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"写入已包装文件的数据会根据给定的 *data_encoding* 解码，然后以使用 *file_encoding* 的字节形式写入原始文件。 "
"从原始文件读取的字节串将根据 *file_encoding* 解码，其结果将使用 *data_encoding* 进行编码。"

#: ../../library/codecs.rst:232
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "如果 *file_encoding* 未给定，则默认为 *data_encoding*。"

#: ../../library/codecs.rst:234
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"可以指定 *errors* 来定义错误处理方案。 默认值 ``'strict'`` 表示在出现编码错误时引发 :exc:`ValueError`。"

#: ../../library/codecs.rst:241
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. *iterator* must yield :class:`str` objects. This function is a "
":term:`generator`. The *errors* argument (as well as any other keyword "
"argument) is passed through to the incremental encoder."
msgstr ""
"使用增量式编码器通过迭代来编码由 *iterator* 提供的输入。 *iterator* 必须产生 :class:`str` 对象。 此函数属于 "
":term:`generator`。 *errors* 参数（以及任何其他关键字参数）会被传递给增量式编码器。"

#: ../../library/codecs.rst:246
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"此函数要求编解码器接受 :class:`str` 对象形式的文本进行编码。 因此它不支持字节到字节的编码器，例如 ``base64_codec``。"

#: ../../library/codecs.rst:253
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. *iterator* must yield :class:`bytes` objects. This function is a"
" :term:`generator`. The *errors* argument (as well as any other keyword "
"argument) is passed through to the incremental decoder."
msgstr ""
"使用增量式解码器通过迭代来解码由 *iterator* 提供的输入。 *iterator* 必须产生 :class:`bytes` 对象。 此函数属于 "
":term:`generator`。 *errors* 参数（以及任何其他关键字参数）会被传递给增量式解码器。"

#: ../../library/codecs.rst:258
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with "
":func:`iterencode`."
msgstr ""
"此函数要求编解码器接受 :class:`bytes` 对象进行解码。 因此它不支持文本到文本的编码器，例如 ``rot_13``，但是 "
"``rot_13`` 可以通过同样效果的 :func:`iterencode` 来使用。"

#: ../../library/codecs.rst:266
msgid ""
"Return a :class:`tuple` containing the raw bytes of *buffer*, a "
":ref:`buffer-compatible object <bufferobjects>` or :class:`str` (encoded to "
"UTF-8 before processing), and their length in bytes."
msgstr ""
"返回一个包含 *buffer* 中原始字节数据的 :class:`tuple`，一个 :ref:`缓冲区兼容对象 <bufferobjects>` 或 "
":class:`str` (在处理前已编码为 UTF-8)，及其字节长度。"

#: ../../library/codecs.rst:270
msgid "The *errors* argument is ignored."
msgstr "*errors* 参数会被忽略。"

#: ../../library/codecs.rst:272
msgid ""
">>> codecs.readbuffer_encode(b\"Zito\")\n"
"(b'Zito', 4)"
msgstr ""
">>> codecs.readbuffer_encode(b\"Zito\")\n"
"(b'Zito', 4)"

#: ../../library/codecs.rst:278
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr "本模块还提供了以下常量，适用于读取和写入依赖于平台的文件："

#: ../../library/codecs.rst:293
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or "
":const:`BOM_UTF16_LE` depending on the platform's native byte order, "
":const:`BOM` is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for "
":const:`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The "
"others represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"这些常量定义了多种字节序列，即一些编码格式的 Unicode 字节顺序标记（BOM）。 它们在 UTF-16 和 UTF-32 "
"数据流中被用以指明所使用的字节顺序，并在 UTF-8 中被用作 Unicode 签名。 :const:`BOM_UTF16` 是 "
":const:`BOM_UTF16_BE` 或 :const:`BOM_UTF16_LE`，具体取决于平台的本机字节顺序，:const:`BOM` 是 "
":const:`BOM_UTF16` 的别名, :const:`BOM_LE` 是 :const:`BOM_UTF16_LE` "
"的别名，:const:`BOM_BE` 是 :const:`BOM_UTF16_BE` 的别名。 其他序列则表示 UTF-8 和 UTF-32 "
"编码格式中的 BOM。"

#: ../../library/codecs.rst:307
msgid "Codec Base Classes"
msgstr "编解码器基类"

#: ../../library/codecs.rst:309
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis"
" for custom codec implementations."
msgstr ":mod:`codecs` 模块定义了一系列基类用来定义配合编解码器对象进行工作的接口，并且也可用作定制编解码器实现的基础。"

#: ../../library/codecs.rst:313
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless "
"encoder/decoder to implement the file protocols. Codec authors also need to "
"define how the codec will handle encoding and decoding errors."
msgstr ""
"每种编解码器必须定义四个接口以便用作 Python 中的编解码器：无状态编码器、无状态解码器、流读取器和流写入器。 "
"流读取器和写入器通常会重用无状态编码器/解码器来实现文件协议。 编解码器作者还需要定义编解码器将如何处理编码和解码错误。"

#: ../../library/codecs.rst:324
msgid "Error Handlers"
msgstr "错误处理方案"

#: ../../library/codecs.rst:326
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr "为了简化和标准化错误处理，编解码器可以通过接受 *errors* 字符串参数来实现不同的错误处理方案:"

#: ../../library/codecs.rst:346
msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr "以下错误处理器可以用于所有的 Python :ref:`standard-encodings` 编解码器:"

#: ../../library/codecs.rst:352 ../../library/codecs.rst:395
#: ../../library/codecs.rst:415
msgid "Value"
msgstr "值"

#: ../../library/codecs.rst:352 ../../library/codecs.rst:395
#: ../../library/codecs.rst:415 ../../library/codecs.rst:1353
#: ../../library/codecs.rst:1425 ../../library/codecs.rst:1480
msgid "Meaning"
msgstr "含意"

#: ../../library/codecs.rst:354
msgid "``'strict'``"
msgstr "``'strict'``"

#: ../../library/codecs.rst:354
msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr "引发 :exc:`UnicodeError` (或其子类)，这是默认的方案。 在 :func:`strict_errors` 中实现。"

#: ../../library/codecs.rst:358
msgid "``'ignore'``"
msgstr "``'ignore'``"

#: ../../library/codecs.rst:358
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr "忽略错误格式的数据并且不加进一步通知就继续执行。 在 :func:`ignore_errors` 中实现。"

#: ../../library/codecs.rst:362
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../../library/codecs.rst:362
msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character)."
" On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"用一个替代标记来替换。 在编码时，使用 ``?`` (ASCII 字符)。 在解码时，使用 ``�`` (U+FFFD，官方的 REPLACEMENT "
"CHARACTER)。 在 :func:`replace_errors` 中实现。"

#: ../../library/codecs.rst:368
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../../library/codecs.rst:368
msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form"
" of Unicode code point with formats :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` "
":samp:`\\\\U{xxxxxxxx}`. On decoding, use hexadecimal form of byte value "
"with format :samp:`\\\\x{hh}`. Implemented in "
":func:`backslashreplace_errors`."
msgstr ""
"用反斜杠转义序列来替换。 在编码时，使用格式为 :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` "
":samp:`\\\\U{xxxxxxxx}` 的 Unicode 码位十六进制表示形式。 在解码时，使用格式为 :samp:`\\\\x{hh}` "
"的字节值十六进制表示形式。 在 :func:`backslashreplace_errors` 中实现。"

#: ../../library/codecs.rst:377
msgid "``'surrogateescape'``"
msgstr "``'surrogateescape'``"

#: ../../library/codecs.rst:377
msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"在解码时，将字节替换为 ``U+DC80`` 至 ``U+DCFF`` 范围内的单个代理代码。 当在编码数据时使用 "
"``'surrogateescape'`` 错误处理方案时，此代理将被转换回相同的字节。 （请参阅 :pep:`383` 了解详情。）"

#: ../../library/codecs.rst:391
msgid ""
"The following error handlers are only applicable to encoding (within "
":term:`text encodings <text encoding>`):"
msgstr "下列错误处理器仅在编码时适用（在 :term:`文本编码格式 <text encoding>` 类别以内）:"

#: ../../library/codecs.rst:397
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

#: ../../library/codecs.rst:397
msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format :samp:`&#{num};`. Implemented in "
":func:`xmlcharrefreplace_errors`."
msgstr ""
"用 XML/HTML 数字字符引用来替换，即格式为 :samp:`&#{num};` 的 Unicode 码位十进制表示形式。 在 "
":func:`xmlcharrefreplace_errors` 中实现。"

#: ../../library/codecs.rst:403
msgid "``'namereplace'``"
msgstr "``'namereplace'``"

#: ../../library/codecs.rst:403
msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in "
":func:`namereplace_errors`."
msgstr ""
"用 ``\\N{...}`` 转义序列来替换，出现在花括号中的是来自 Unicode 字符数据库的 Name 属性。 在 "
":func:`namereplace_errors` 中实现。"

#: ../../library/codecs.rst:412
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "此外，以下错误处理方案被专门用于指定的编解码器："

#: ../../library/codecs.rst:13 ../../library/codecs.rst:415
msgid "Codecs"
msgstr "编解码器"

#: ../../library/codecs.rst:417
msgid "``'surrogatepass'``"
msgstr "``'surrogatepass'``"

#: ../../library/codecs.rst:417
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../../library/codecs.rst:417
msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate"
" code point in :class:`str` as an error."
msgstr ""
"允许将代理码位 (``U+D800`` - ``U+DFFF``) 作为正常码位来编码和解码。 否则这些编解码器会将 :class:`str` "
"中出现的代理码位视为错误。"

#: ../../library/codecs.rst:424
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "``'surrogateescape'`` 和 ``'surrogatepass'`` 错误处理方案。"

#: ../../library/codecs.rst:427
msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\*"
" codecs."
msgstr "``'surrogatepass'`` 错误处理器现在可适用于 utf-16\\* 和 utf-32\\* 编解码器。"

#: ../../library/codecs.rst:431
msgid "The ``'namereplace'`` error handler."
msgstr "``'namereplace'`` 错误处理方案。"

#: ../../library/codecs.rst:434
msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr "``'backslashreplace'`` 错误处理器现在可适用于解码和转码。"

#: ../../library/codecs.rst:438
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr "允许的值集合可以通过注册新命名的错误处理方案来扩展："

#: ../../library/codecs.rst:443
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"在名称 *name* 之下注册错误处理函数 *error_handler*。 当 *name* 被指定为错误形参时，*error_handler* "
"参数所指定的对象将在编码和解码期间发生错误的情况下被调用，"

#: ../../library/codecs.rst:447
msgid ""
"For encoding, *error_handler* will be called with a "
":exc:`UnicodeEncodeError` instance, which contains information about the "
"location of the error. The error handler must either raise this or a "
"different exception, or return a tuple with a replacement for the "
"unencodable part of the input and a position where encoding should continue."
" The replacement may be either :class:`str` or :class:`bytes`. If the "
"replacement is bytes, the encoder will simply copy them into the output "
"buffer. If the replacement is a string, the encoder will encode the "
"replacement. Encoding continues on original input at the specified position."
" Negative position values will be treated as being relative to the end of "
"the input string. If the resulting position is out of bound an "
":exc:`IndexError` will be raised."
msgstr ""
"对于编码操作，将会调用 *error_handler* 并传入一个 :exc:`UnicodeEncodeError` "
"实例，其中包含有关错误位置的信息。 "
"错误处理程序必须引发此异常或别的异常，或者也可以返回一个元组，其中包含输入的不可编码部分的替换对象，以及应当继续进行编码的位置。 替换对象可以为 "
":class:`str` 或 :class:`bytes` 类型。 如果替换对象为字节串，编码器将简单地将其复制到输出缓冲区。 "
"如果替换对象为字符串，编码器将对替换对象进行编码。 对原始输入的编码操作会在指定位置继续进行。 负的位置值将被视为相对于输入字符串的末尾。 "
"如果结果位置超出范围则将引发 :exc:`IndexError`。"

#: ../../library/codecs.rst:459
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"解码和转换的做法很相似，不同之处在于将把 :exc:`UnicodeDecodeError` 或 "
":exc:`UnicodeTranslateError` 传给处理程序，并且来自错误处理程序的替换对象将被直接放入输出。"

#: ../../library/codecs.rst:464
msgid ""
"Previously registered error handlers (including the standard error handlers)"
" can be looked up by name:"
msgstr "之前注册的错误处理方案（包括标准错误处理方案）可通过名称进行查找："

#: ../../library/codecs.rst:469
msgid "Return the error handler previously registered under the name *name*."
msgstr "返回之前在名称 *name* 之下注册的错误处理方案。"

#: ../../library/codecs.rst:471
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "在处理方案无法找到时将引发 :exc:`LookupError`。"

#: ../../library/codecs.rst:473
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr "以下标准错误处理方案也可通过模块层级函数的方式来使用："

#: ../../library/codecs.rst:478
msgid "Implements the ``'strict'`` error handling."
msgstr "实现了 ``'strict'`` 错误处理。"

#: ../../library/codecs.rst:480
msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr "每个编码或解码错误都将引发 :exc:`UnicodeError`。"

#: ../../library/codecs.rst:485
msgid "Implements the ``'ignore'`` error handling."
msgstr "实现了 ``'ignore'`` 错误处理。"

#: ../../library/codecs.rst:487
msgid ""
"Malformed data is ignored; encoding or decoding is continued without further"
" notice."
msgstr "错误格式的数据会被忽略；编码或解码将继续执行而不再通知。"

#: ../../library/codecs.rst:493
msgid "Implements the ``'replace'`` error handling."
msgstr "实现了 ``'replace'`` 错误处理。"

#: ../../library/codecs.rst:495
msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"替换 ``?`` (ASCII 字符) 表示编码错误或者 ``�`` (U+FFFD，官方的 REPLACEMENT CHARACTER) "
"表示解码错误。"

#: ../../library/codecs.rst:501
msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "实现了 ``'backslashreplace'`` 错误处理。"

#: ../../library/codecs.rst:503
msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats "
":samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. On decoding, "
"use the hexadecimal form of byte value with format :samp:`\\\\x{hh}`."
msgstr ""
"错误格式的数据会用反斜杠转义序列来替换。 在编码时，使用格式为 :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` "
":samp:`\\\\U{xxxxxxxx}` 的 Unicode 码位十六进制表示形式。 在解码时，使用格式为 :samp:`\\\\x{hh}` "
"的字节值 十六进制表示形式。"

#: ../../library/codecs.rst:509
msgid "Works with decoding and translating."
msgstr "适用于解码和转码。"

#: ../../library/codecs.rst:515
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within "
":term:`text encoding` only)."
msgstr "实现 ``'xmlcharrefreplace'`` 错误处理（仅限 :term:`text encoding` 范围内的编码操作）。"

#: ../../library/codecs.rst:518
msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format :samp:`&#{num};` ."
msgstr ""
"不可编码的字符会被替换为适当的 XML/HTML 数值字符引用，即格式为 :samp:`&#{num};` 的十进制形式 Unicode 码位。"

#: ../../library/codecs.rst:525
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within "
":term:`text encoding` only)."
msgstr "实现 ``'namereplace'`` 错误处理（仅限 :term:`text encoding` 范围内的编码操作）。"

#: ../../library/codecs.rst:528
msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The"
" set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'``"
" will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"不可编码的字符会被替换为 ``\\N{...}`` 转义序列。 出现在花括号内的字符集合是来自于 Unicode 字符数据库的 Name 属性。 "
"例如，德语小写字母 ``'ß'`` 将被转换为字符序列 ``\\N{LATIN SMALL LETTER SHARP S}``。"

#: ../../library/codecs.rst:539
msgid "Stateless Encoding and Decoding"
msgstr "无状态的编码和解码"

#: ../../library/codecs.rst:541
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr "基本 :class:`Codec` 类定义了这些方法，同时还定义了无状态编码器和解码器的函数接口："

#: ../../library/codecs.rst:549
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a"
" bytes object using a particular character set encoding (e.g., ``cp1252`` or"
" ``iso-8859-1``)."
msgstr ""
"编码 *input* 对象并返回一个元组 (输出对象, 消耗长度)。 例如，:term:`text encoding` 会使用特定的字符集编码格式 "
"(例如 ``cp1252`` 或 ``iso-8859-1``) 将字符串转换为字节串对象。"

#: ../../library/codecs.rst:554 ../../library/codecs.rst:576
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr "*errors* 参数定义了要应用的错误处理方案。 默认为 ``'strict'`` 处理方案。"

#: ../../library/codecs.rst:557
msgid ""
"The method may not store state in the :class:`Codec` instance. Use "
":class:`StreamWriter` for codecs which have to keep state in order to make "
"encoding efficient."
msgstr ""
"此方法不一定会在 :class:`Codec` 实例中保存状态。 可使用必须保存状态的 :class:`StreamWriter` "
"作为编解码器以便高效地进行编码。"

#: ../../library/codecs.rst:561
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr "编码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。"

#: ../../library/codecs.rst:567
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"解码 *input* 对象并返回一个元组 (输出对象, 消耗长度)。 例如，:term:`text encoding` "
"的解码操作会使用特定的字符集编码格式将字节串对象转换为字符串对象。"

#: ../../library/codecs.rst:572
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object"
" or one which provides the read-only buffer interface -- for example, buffer"
" objects and memory mapped files."
msgstr ""
"对于文本编码格式和字节到字节编解码器，*input* 必须为一个字节串对象或提供了只读缓冲区接口的对象 -- 例如，缓冲区对象和映射到内存的文件。"

#: ../../library/codecs.rst:579
msgid ""
"The method may not store state in the :class:`Codec` instance. Use "
":class:`StreamReader` for codecs which have to keep state in order to make "
"decoding efficient."
msgstr ""
"此方法不一定会在 :class:`Codec` 实例中保存状态。 可使用必须保存状态的 :class:`StreamReader` "
"作为编解码器以便高效地进行解码。"

#: ../../library/codecs.rst:583
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr "解码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。"

#: ../../library/codecs.rst:588
msgid "Incremental Encoding and Decoding"
msgstr "增量式的编码和解码"

#: ../../library/codecs.rst:590
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. "
"Encoding/decoding the input isn't done with one call to the stateless "
"encoder/decoder function, but with multiple calls to the "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` method"
" of the incremental encoder/decoder. The incremental encoder/decoder keeps "
"track of the encoding/decoding process during method calls."
msgstr ""
":class:`IncrementalEncoder` 和 :class:`IncrementalDecoder` 类提供了增量式编码和解码的基本接口。"
" 对输入的编码/解码不是通过对无状态编码器/解码器的一次调用，而是通过对增量式编码器/解码器的 "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` "
"方法的多次调用。 增量式编码器/解码器会在方法调用期间跟踪编码/解码过程。"

#: ../../library/codecs.rst:598
msgid ""
"The joined output of calls to the "
":meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` method"
" is the same as if all the single inputs were joined into one, and this "
"input was encoded/decoded with the stateless encoder/decoder."
msgstr ""
"调用 :meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` "
"方法后的全部输出相当于将所有通过无状态编码器/解码器进行编码/解码的单个输入连接在一起所得到的输出。"

#: ../../library/codecs.rst:607
msgid "IncrementalEncoder Objects"
msgstr "IncrementalEncoder 对象"

#: ../../library/codecs.rst:609
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec "
"registry."
msgstr ""
":class:`IncrementalEncoder` 类用来对一个输入进行分步编码。 它定义了以下方法，每个增量式编码器都必须定义这些方法以便与 "
"Python 编解码器注册表相兼容。"

#: ../../library/codecs.rst:616
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr ":class:`IncrementalEncoder` 实例的构造器。"

#: ../../library/codecs.rst:618
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are"
" used by the Python codec registry."
msgstr ""
"所有增量式编码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。"

#: ../../library/codecs.rst:622
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` 可以通过提供 *errors* 关键字参数来实现不同的错误处理方案。 可用的值请参阅 "
":ref:`error-handlers`。"

#: ../../library/codecs.rst:626
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the "
":class:`IncrementalEncoder` object."
msgstr ""
"*errors* 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 :class:`IncrementalEncoder` "
"对象的生命期内在不同的错误处理策略之间进行切换。"

#: ../../library/codecs.rst:634
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to "
":meth:`encode` *final* must be true (the default is false)."
msgstr ""
"编码 *object* (会将编码器的当前状态纳入考虑) 并返回已编码的结果对象。 如果这是对 :meth:`encode` 的最终调用则 "
"*final* 必须为真值（默认为假值）。"

#: ../../library/codecs.rst:641
msgid ""
"Reset the encoder to the initial state. The output is discarded: call "
"``.encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"将编码器重置为初始状态。 输出将被丢弃：调用 ``.encode(object, "
"final=True)``，在必要时传入一个空字节串或字符串，重置编码器并得到输出。"

#: ../../library/codecs.rst:648
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States"
" that are more complicated than integers can be converted into an integer by"
" marshaling/pickling the state and encoding the bytes of the resulting "
"string into an integer.)"
msgstr ""
"返回编码器的当前状态，该值必须为一个整数。 实现应当确保 ``0`` 是最常见的状态。 "
"（比整数更复杂的状态表示可以通过编组/选择状态并将结果字符串的字节数据编码为整数来转换为一个整数值）。"

#: ../../library/codecs.rst:657
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr "将编码器的状态设为 *state*。 *state* 必须为 :meth:`getstate` 所返回的一个编码器状态。"

#: ../../library/codecs.rst:664
msgid "IncrementalDecoder Objects"
msgstr "IncrementalDecoder 对象"

#: ../../library/codecs.rst:666
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec "
"registry."
msgstr ""
":class:`IncrementalDecoder` 类用来对一个输入进行分步解码。 它定义了以下方法，每个增量式解码器都必须定义这些方法以便与 "
"Python 编解码器注册表相兼容。"

#: ../../library/codecs.rst:673
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr ":class:`IncrementalDecoder` 实例的构造器。"

#: ../../library/codecs.rst:675
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are"
" used by the Python codec registry."
msgstr ""
"所有增量式解码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。"

#: ../../library/codecs.rst:679
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` 可以通过提供 *errors* 关键字参数来实现不同的错误处理方案。 可用的值请参阅 "
":ref:`error-handlers`。"

#: ../../library/codecs.rst:683
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the "
":class:`IncrementalDecoder` object."
msgstr ""
"*errors* 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 :class:`IncrementalDecoder` "
"对象的生命期内在不同的错误处理策略之间进行切换。"

#: ../../library/codecs.rst:691
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to "
":meth:`decode` *final* must be true (the default is false). If *final* is "
"true the decoder must decode the input completely and must flush all "
"buffers. If this isn't possible (e.g. because of incomplete byte sequences "
"at the end of the input) it must initiate error handling just like in the "
"stateless case (which might raise an exception)."
msgstr ""
"解码 *object* (会将解码器的当前状态纳入考虑) 并返回已解码的结果对象。 如果这是对 :meth:`decode` 的最终调用则 "
"*final* 必须为真值（默认为假值）。 如果 *final* 为真值则解码器必须对输入进行完全解码并且必须 刷新所有缓冲区。 "
"如果这无法做到（例如由于在输入结束时字节串序列不完整）则它必须像在无状态的情况下那样初始化错误处理（这可能引发一个异常）。"

#: ../../library/codecs.rst:702
msgid "Reset the decoder to the initial state."
msgstr "将解码器重置为初始状态。"

#: ../../library/codecs.rst:707
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"返回解码器的当前状态。 这必须为一个二元组，第一项必须是包含尚未解码的输入的缓冲区。 第二项必须为一个整数，可以表示附加状态信息。 （实现应当确保 "
"``0`` 是最常见的附加状态信息。） 如果此附加状态信息为 ``0`` 则必须可以将解码器设为没有已缓冲输入并且以 ``0`` "
"作为附加状态信息，以便将先前已缓冲的输入馈送到解码器使其返回到先前的状态而不产生任何输出。 "
"（比整数更复杂的附加状态信息可以通过编组/选择状态信息并将结果字符串的字节数据编码为整数来转换为一个整数值。）"

#: ../../library/codecs.rst:722
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr "将解码器的状态设为 *state*。 *state* 必须为 :meth:`getstate` 所返回的一个解码器状态。"

#: ../../library/codecs.rst:727
msgid "Stream Encoding and Decoding"
msgstr "流式的编码和解码"

#: ../../library/codecs.rst:730
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`!encodings.utf_8` for an example of how this is done."
msgstr ""
"The :class:`StreamWriter` 和 :class:`StreamReader` "
"类提供了一些泛用工作接口，可被用来非常方便地实现新的编码格式子模块。 请参阅 :mod:`!encodings.utf_8` "
"中的示例了解如何做到这一点。"

#: ../../library/codecs.rst:738
msgid "StreamWriter Objects"
msgstr "StreamWriter 对象"

#: ../../library/codecs.rst:740
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
":class:`StreamWriter` 类是 :class:`Codec` 的子类，它定义了以下方法，每个流式写入器都必须定义这些方法以便与 "
"Python 编解码器注册表相兼容。"

#: ../../library/codecs.rst:747
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr ":class:`StreamWriter` 实例的构造器。"

#: ../../library/codecs.rst:749
msgid ""
"All stream writers must provide this constructor interface. They are free to"
" add additional keyword arguments, but only the ones defined here are used "
"by the Python codec registry."
msgstr ""
"所有流式写入器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。"

#: ../../library/codecs.rst:753
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr "*stream* 参数必须为一个基于特定编解码器打开用于写入文本或二进制数据的文件型对象。"

#: ../../library/codecs.rst:756
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamWriter` 可以通过提供 *errors* 关键字参数来实现不同的错误处理方案。 请参阅 :ref:`error-"
"handlers` 了解下层的流式编解码器可支持的标准错误处理方案。"

#: ../../library/codecs.rst:760
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"*errors* 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 :class:`StreamWriter` "
"对象的生命期内在不同的错误处理策略之间进行切换。"

#: ../../library/codecs.rst:766
msgid "Writes the object's contents encoded to the stream."
msgstr "将编码后的对象内容写入到流。"

#: ../../library/codecs.rst:771
msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"将拼接后的字符串可迭代对象写入到流（可能通过重用 :meth:`write` 方法）。 无限长或非常大的可迭代对象不受支持。 "
"标准的字节到字节编解码器不支持此方法。"

#: ../../library/codecs.rst:779 ../../library/codecs.rst:874
msgid "Resets the codec buffers used for keeping internal state."
msgstr "重置用于保持内部状态的编解码器缓冲区。"

#: ../../library/codecs.rst:781
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan"
" the whole stream to recover state."
msgstr "调用此方法应当确保在干净的状态下放入输出数据，以允许直接添加新的干净数据而无须重新扫描整个流来恢复状态。"

#: ../../library/codecs.rst:786
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr "除了上述的方法，:class:`StreamWriter` 还必须继承来自下层流的所有其他方法和属性。"

#: ../../library/codecs.rst:793
msgid "StreamReader Objects"
msgstr "StreamReader 对象"

#: ../../library/codecs.rst:795
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
":class:`StreamReader` 类是 :class:`Codec` 的子类，它定义了以下方法，每个流式读取器都必须定义这些方法以便与 "
"Python 编解码器注册表相兼容。"

#: ../../library/codecs.rst:802
msgid "Constructor for a :class:`StreamReader` instance."
msgstr ":class:`StreamReader` 实例的构造器。"

#: ../../library/codecs.rst:804
msgid ""
"All stream readers must provide this constructor interface. They are free to"
" add additional keyword arguments, but only the ones defined here are used "
"by the Python codec registry."
msgstr ""
"所有流式读取器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。"

#: ../../library/codecs.rst:808
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr "*stream* 参数必须为一个基于特定编解码器打开用于读取文本或二进制数据的文件型对象。"

#: ../../library/codecs.rst:811
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamReader` 可以通过提供 *errors* 关键字参数来实现不同的错误处理方案。 请参阅 :ref:`error-"
"handlers` 了解下层的流式编解码器可支持的标准错误处理方案。"

#: ../../library/codecs.rst:815
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"*errors* 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 :class:`StreamReader` "
"对象的生命期内在不同的错误处理策略之间进行切换。"

#: ../../library/codecs.rst:819
msgid ""
"The set of allowed values for the *errors* argument can be extended with "
":func:`register_error`."
msgstr "*errors* 参数所允许的值集合可以使用 :func:`register_error` 来扩展。"

#: ../../library/codecs.rst:825
msgid "Decodes data from the stream and returns the resulting object."
msgstr "解码来自流的数据并返回结果对象。"

#: ../../library/codecs.rst:827
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to"
" return. The :func:`read` method will never return more data than requested,"
" but it might return less, if there is not enough available."
msgstr ""
"*chars* 参数指明要返回的解码后码位或字节数量。 :func:`read` "
"方法绝不会返回超出请求数量的数据，但如果可用数量不足，它可能返回少于请求数量的数据。"

#: ../../library/codecs.rst:832
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as"
" much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"*size* 参数指明要读取并解码的已编码字节或码位的最大数量近似值。 解码器可以适当地修改此设置。 默认值 -1 表示尽可能多地读取并解码。 "
"此形参的目的是防止一次性解码过于巨大的文件。"

#: ../../library/codecs.rst:839
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr "*firstline* 旗标指明如果在后续行发生解码错误，则仅返回第一行就足够了。"

#: ../../library/codecs.rst:843
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"此方法应当使用“贪婪”读取策略，这意味着它应当在编码格式定义和给定大小所允许的情况下尽可能多地读取数据，例如，如果在流上存在可选的编码结束或状态标记，这些内容也应当被读取。"

#: ../../library/codecs.rst:851
msgid "Read one line from the input stream and return the decoded data."
msgstr "从输入流读取一行并返回解码后的数据。"

#: ../../library/codecs.rst:853
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr "如果给定了 *size*，则将其作为 size 参数传递给流的 :meth:`read` 方法。"

#: ../../library/codecs.rst:856
msgid ""
"If *keepends* is false line-endings will be stripped from the lines "
"returned."
msgstr "如果 *keepends* 为假值，则行结束符将从返回的行中去除。"

#: ../../library/codecs.rst:862
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr "从输入流读取所有行并将其作为一个行列表返回。"

#: ../../library/codecs.rst:865
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are"
" included in the list entries if *keepends* is true."
msgstr "行结束符会使用编解码器的 :meth:`decode` 方法来实现，并且如果 *keepends* 为真值则会将其包含在列表条目中。"

#: ../../library/codecs.rst:868
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's "
":meth:`read` method."
msgstr "如果给定了 *sizehint*，则将其作为 *size* 参数传递给流的 :meth:`read` 方法。"

#: ../../library/codecs.rst:876
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr "请注意不应当对流进行重定位。 使用此方法的主要目的是为了能够从解码错误中恢复。"

#: ../../library/codecs.rst:880
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr "除了上述的方法，:class:`StreamReader` 还必须继承来自下层流的所有其他方法和属性。"

#: ../../library/codecs.rst:886
msgid "StreamReaderWriter Objects"
msgstr "StreamReaderWriter 对象"

#: ../../library/codecs.rst:888
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ":class:`StreamReaderWriter` 是一个方便的类，允许对同时工作于读取和写入模式的流进行包装。"

#: ../../library/codecs.rst:891 ../../library/codecs.rst:915
msgid ""
"The design is such that one can use the factory functions returned by the "
":func:`lookup` function to construct the instance."
msgstr "其设计使得开发者可以使用 :func:`lookup` 函数所返回的工厂函数来构造实例。"

#: ../../library/codecs.rst:897
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like"
" object. *Reader* and *Writer* must be factory functions or classes "
"providing the :class:`StreamReader` and :class:`StreamWriter` interface "
"resp. Error handling is done in the same way as defined for the stream "
"readers and writers."
msgstr ""
"创建一个 :class:`StreamReaderWriter` 实例。 *stream* 必须为一个文件型对象。 *Reader* 和 "
"*Writer* 必须为分别提供了 :class:`StreamReader` 和 :class:`StreamWriter` 接口的工厂函数或类。 "
"错误处理通过与流式读取器和写入器所定义的相同方式来完成。"

#: ../../library/codecs.rst:902
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of "
":class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamReaderWriter` 实例定义了 :class:`StreamReader` 和 "
":class:`StreamWriter` 类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。"

#: ../../library/codecs.rst:910
msgid "StreamRecoder Objects"
msgstr "StreamRecoder 对象"

#: ../../library/codecs.rst:912
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ":class:`StreamRecoder` 将数据从一种编码格式转换为另一种，这对于处理不同编码环境的情况有时会很有用。"

#: ../../library/codecs.rst:921
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to"
" code calling :meth:`~StreamReader.read` and :meth:`~StreamWriter.write`, "
"while *Reader* and *Writer* work on the backend — the data in *stream*."
msgstr ""
"创建一个实现了双向转换的 :class:`StreamRecoder` 实例: *encode* 和 *decode* 工作于前端 —— 调用 "
":meth:`~StreamReader.read` 和 :meth:`~StreamWriter.write` 的代码可见的数据，而 *Reader*"
" 和 *Writer* 工作于后端 —— *stream* 中的数据。"

#: ../../library/codecs.rst:927
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1"
" to UTF-8 and back."
msgstr "你可以使用这些对象来进行透明转码，例如从 Latin-1 转为 UTF-8 以及反向转换。"

#: ../../library/codecs.rst:930
msgid "The *stream* argument must be a file-like object."
msgstr "*stream* 参数必须为一个文件型对象。"

#: ../../library/codecs.rst:932
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"*encode* 和 *decode* 参数必须遵循 :class:`Codec` 接口。 *Reader* 和 *Writer* 必须为分别提供了 "
":class:`StreamReader` 和 :class:`StreamWriter` 接口对象的工厂函数或类。"

#: ../../library/codecs.rst:937
msgid ""
"Error handling is done in the same way as defined for the stream readers and"
" writers."
msgstr "错误处理通过与流式读取器和写入器所定义的相同方式来完成。"

#: ../../library/codecs.rst:941
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of "
":class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamRecoder` 实例定义了 :class:`StreamReader` 和 :class:`StreamWriter` "
"类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。"

#: ../../library/codecs.rst:949
msgid "Encodings and Unicode"
msgstr "编码格式与 Unicode"

#: ../../library/codecs.rst:951
msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with"
" other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as"
" *decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text "
"encoding>`."
msgstr ""
"字符串在系统内部存储为 ``U+0000``--``U+10FFFF`` 范围内的码位序列。 （请参阅 :pep:`393` 了解有关实现的详情。） "
"一旦字符串对象要在 CPU 和内存以外使用，字节的大小端顺序和字节数组的存储方式就成为一个影响因素。 "
"如同使用其他编解码器一样，将字符串序列化为字节序列被称为 *编码*，而从字节序列重建字符串被称为 *解码*。 "
"存在许多不同的文本序列化编解码器，它们被统称为 :term:`文本编码格式 <text encoding>`。"

#: ../../library/codecs.rst:961
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"最简单的文本编码格式 (称为 ``'latin-1'`` 或 ``'iso-8859-1'``) 将码位 0--255 映射为字节值 "
"``0x0``--``0xff``，这意味着包含 ``U+00FF`` 以上码位的字符串对象无法使用此编解码器进行编码。 这样做将引发 "
":exc:`UnicodeEncodeError`，其形式类似下面这样（不过详细的错误信息可能会有所不同）: ``UnicodeEncodeError:"
" 'latin-1' codec can't encode character '\\u1234' in position 3: ordinal not"
" in range(256)``。"

#: ../../library/codecs.rst:969
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"还有另外一组编码格式（所谓的字符映射编码）会选择全部 Unicode 码位的不同子集并设定如何将这些码位映射为字节值 "
"``0x0``--``0xff``。 要查看这是如何实现的，只需简单地打开相应源码例如 :file:`encodings/cp1252.py` "
"(这是一个主要在 Windows 上使用的编码格式)。 其中会有一个包含 256 个字符的字符串常量，指明每个字符所映射的字节值。"

#: ../../library/codecs.rst:976
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE``"
" respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a"
" little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of"
" a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte"
" Order Mark\"). This is the Unicode character ``U+FEFF``. This character can"
" be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a"
" second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO"
" WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine"
" the storage layout of the encoded bytes, and vanishes once the byte "
"sequence has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` "
"it's a normal character that will be decoded like any other."
msgstr ""
"所有这些编码格式只能对 Unicode 所定义的 1114112 个码位中的 256 个进行编码。 一种能够存储每个 Unicode "
"码位的简单而直接的办法就是将每个友们存储为四个连续的字节。 存在两种不同的可能性：以大端序存储或以小端序存储。 这两种编码格式分别被称为 "
"``UTF-32-BE`` 和 ``UTF-32-LE``。 他们共有的缺点可以举例说明：如果你在一台小端序的机器上使用 ``UTF-32-BE`` "
"则你必须在编码和解码时翻转字节。 ``UTF-32`` 避免了这个问题：字节的排列将总是使用自然端序。 当这些字节被具有不同端序的 CPU "
"读取时，则必须进行字节翻转。 为了能够检测 ``UTF-16`` 或 ``UTF-32`` 字节序列的大小端序，可以使用所谓的 BOM "
"(\"字节顺序标记\")。 这对应于 Unicode 字符 ``U+FEFF``。 此字符可被添加到每个 ``UTF-16`` 或 ``UTF-32``"
" 字节序列的开头。 此字符的字节翻转版本 (``0xFFFE``) 是一个不可出现于 Unicode 文本中的非法字符。 因此当发现一个 "
"``UTF-16`` 或 ``UTF-32`` 字节序列的首个字符是 ``U+FFFE`` 时，就必须在解码时进行字节翻转。 不幸的是字符 "
"``U+FEFF`` 还有第二个含义 ``ZERO WIDTH NO-BREAK SPACE``: 即宽度为零并且不允许用来拆分单词的字符。 "
"它可以被用来为语言分析算法提供提示。 在 Unicode 4.0 中使用 ``U+FEFF`` 表示 ``ZERO WIDTH NO-BREAK "
"SPACE`` 已被弃用 (改用 ``U+2060`` (``WORD JOINER``) 负责此任务)。 然而 Unicode 软件仍然必须能够处理 "
"``U+FEFF`` 的两个含义：作为 BOM 它被用来确定已编码字节的存储布局，并在字节序列被解码为字符串后将其去除；作为 ``ZERO WIDTH "
"NO-BREAK SPACE`` 它是一个普通字符，将像其他字符一样被解码。"

#: ../../library/codecs.rst:1002
msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists"
" of two parts: marker bits (the most significant bits) and payload bits. The"
" marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"还有另一种编码格式能够对所有 Unicode 字符进行编码：UTF-8。 UTF-8 是一种 8 位编码，这意味着在 UTF-8 中没有字节顺序问题。 "
"UTF-8 字节序列中的每个字节由两部分组成：标志位（最重要的位）和内容位。 标志位是由零至四个值为 ``1`` 的二进制位加一个值为 ``0`` "
"的二进制位构成的序列。 Unicode 字符会按以下形式进行编码（其中 x 为内容位，当拼接为一体时将给出对应的 Unicode 字符）:"

#: ../../library/codecs.rst:1011
msgid "Range"
msgstr "范围"

#: ../../library/codecs.rst:1011
msgid "Encoding"
msgstr "编码"

#: ../../library/codecs.rst:1013
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../../library/codecs.rst:1013
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../../library/codecs.rst:1015
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../../library/codecs.rst:1015
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../../library/codecs.rst:1017
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../../library/codecs.rst:1017
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:1019
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../../library/codecs.rst:1019
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:1022
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr "Unicode 字符最不重要的一个位就是最右侧的二进制位 x。"

#: ../../library/codecs.rst:1024
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"由于 UTF-8 是一种 8 位编码格式，因此 BOM 是不必要的，并且已编码字符串中的任何 ``U+FEFF`` "
"字符（即使是作为第一个字符）都会被视为是 ``ZERO WIDTH NO-BREAK SPACE``。"

#: ../../library/codecs.rst:1028
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences."
" To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any"
" charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"在没有外部信息的情况下将不可能毫无疑义地确定一个字符串使用了何种编码格式。 每种字符映射编码格式都可以解码任意的随机字节序列。 然而对 UTF-8 "
"来说这却是不可能的，因为 UTF-8 字节序列具有不允许任意字节序列的特别结构。 为了提升 UTF-8 编码格式检测的可靠性，Microsoft "
"发明了一种 UTF-8 的变体形式 (Python 称之为 ``\"utf-8-sig\"``) 专门用于其 Notepad 程序：在任何 "
"Unicode 字节被写入文件之前，会先写入一个 UTF-8 编码的 BOM (它看起来是这样一个字节序列: ``0xef``, ``0xbb``, "
"``0xbf``)。 由于任何字符映射编码后的文件都不大可能以这些字节值开头 (例如它们会映射为"

#: ../../library/codecs.rst:0
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LATIN SMALL LETTER I WITH DIAERESIS"

#: ../../library/codecs.rst:0
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"

#: ../../library/codecs.rst:0
msgid "INVERTED QUESTION MARK"
msgstr "INVERTED QUESTION MARK"

#: ../../library/codecs.rst:1044
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding"
" can be correctly guessed from the byte sequence. So here the BOM is not "
"used to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"对于 iso-8859-1 编码格式来说），这提升了根据字节序列来正确猜测 ``utf-8-sig`` 编码格式的成功率。 所以在这里 BOM "
"的作用并不是帮助确定生成字节序列所使用的字节顺序，而是作为帮助猜测编码格式的记号。 在进行编码时 utf-8-sig 编解码器将把 ``0xef``, "
"``0xbb``, ``0xbf`` 作为头三个字节写入文件。 在进行解码时 ``utf-8-sig`` "
"将跳过这三个字节，如果它们作为文件的头三个字节出现的话。 在 UTF-8 中并不推荐使用 BOM，通常应当避免它们的出现。"

#: ../../library/codecs.rst:1057
msgid "Standard Encodings"
msgstr "标准编码"

#: ../../library/codecs.rst:1059
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""
"Python 自带了许多内置的编解码器，它们的实现或者是通过 C 函数，或者是通过映射表。 "
"以下表格是按名称排序的编解码器列表，并提供了一些常见别名以及编码格式通常针对的语言。 别名和语言列表都不是详尽无遗的。 "
"请注意仅有大小写区别或使用连字符替代下划线的拼写形式也都是有效的别名；因此，``'utf-8'`` 是 ``'utf_8'`` 编解码器的有效别名。"

#: ../../library/codecs.rst:1069
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython"
" for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16,"
" utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower "
"execution."
msgstr ""
"有些常见编码格式可以绕过编解码器查找机制来提升性能。 这些优化机会对于 CPython 来说仅能通过一组有限的别名（大小写不敏感）来识别：utf-8, "
"utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (Windows 专属), ascii, us-"
"ascii, utf-16, utf16, utf-32, utf32, 也包括使用下划线替代连字符的的形式。 "
"使用这些编码格式的其他别名可能会导致更慢的执行速度。"

#: ../../library/codecs.rst:1077
msgid "Optimization opportunity recognized for us-ascii."
msgstr "可识别针对 us-ascii 的优化机会。"

#: ../../library/codecs.rst:1080
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"许多字符集都支持相同的语言。 它们在个别字符（例如是否支持 EURO SIGN 等）以及给字符所分配的码位方面存在差异。 "
"特别是对于欧洲语言来说，通常存在以下几种变体："

#: ../../library/codecs.rst:1085
msgid "an ISO 8859 codeset"
msgstr "某个 ISO 8859 编码集"

#: ../../library/codecs.rst:1087
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr "某个 Microsoft Windows 编码页，通常是派生自某个 8859 编码集，但会用附加的图形字符来替换控制字符。"

#: ../../library/codecs.rst:1090
msgid "an IBM EBCDIC code page"
msgstr "某个 IBM EBCDIC 编码页"

#: ../../library/codecs.rst:1092
msgid "an IBM PC code page, which is ASCII compatible"
msgstr "某个 IBM PC 编码页，通常会兼容 ASCII"

#: ../../library/codecs.rst:1097 ../../library/codecs.rst:1353
#: ../../library/codecs.rst:1425 ../../library/codecs.rst:1480
msgid "Codec"
msgstr "编码"

#: ../../library/codecs.rst:1097 ../../library/codecs.rst:1353
#: ../../library/codecs.rst:1425 ../../library/codecs.rst:1480
msgid "Aliases"
msgstr "别名"

#: ../../library/codecs.rst:1097
msgid "Languages"
msgstr "语言"

#: ../../library/codecs.rst:1099
msgid "ascii"
msgstr "ascii"

#: ../../library/codecs.rst:1099
msgid "646, us-ascii"
msgstr "646, us-ascii"

#: ../../library/codecs.rst:1099 ../../library/codecs.rst:1105
#: ../../library/codecs.rst:1113
msgid "English"
msgstr "英语"

#: ../../library/codecs.rst:1101
msgid "big5"
msgstr "big5"

#: ../../library/codecs.rst:1101
msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

#: ../../library/codecs.rst:1101 ../../library/codecs.rst:1103
#: ../../library/codecs.rst:1162
msgid "Traditional Chinese"
msgstr "繁体中文"

#: ../../library/codecs.rst:1103
msgid "big5hkscs"
msgstr "big5hkscs"

#: ../../library/codecs.rst:1103
msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

#: ../../library/codecs.rst:1105
msgid "cp037"
msgstr "cp037"

#: ../../library/codecs.rst:1105
msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

#: ../../library/codecs.rst:1107
msgid "cp273"
msgstr "cp273"

#: ../../library/codecs.rst:1107
msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

#: ../../library/codecs.rst:1107
msgid "German"
msgstr "德语"

#: ../../library/codecs.rst:1111
msgid "cp424"
msgstr "cp424"

#: ../../library/codecs.rst:1111
msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

#: ../../library/codecs.rst:1111 ../../library/codecs.rst:1131
#: ../../library/codecs.rst:1141 ../../library/codecs.rst:1185
#: ../../library/codecs.rst:1248
msgid "Hebrew"
msgstr "希伯来语"

#: ../../library/codecs.rst:1113
msgid "cp437"
msgstr "cp437"

#: ../../library/codecs.rst:1113
msgid "437, IBM437"
msgstr "437, IBM437"

#: ../../library/codecs.rst:1115
msgid "cp500"
msgstr "cp500"

#: ../../library/codecs.rst:1115
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

#: ../../library/codecs.rst:1115 ../../library/codecs.rst:1124
#: ../../library/codecs.rst:1135 ../../library/codecs.rst:1172
#: ../../library/codecs.rst:1179 ../../library/codecs.rst:1232
#: ../../library/codecs.rst:1260 ../../library/codecs.rst:1288
msgid "Western Europe"
msgstr "西欧"

#: ../../library/codecs.rst:1118
msgid "cp720"
msgstr "cp720"

#: ../../library/codecs.rst:1118 ../../library/codecs.rst:1145
#: ../../library/codecs.rst:1187 ../../library/codecs.rst:1244
msgid "Arabic"
msgstr "阿拉伯语"

#: ../../library/codecs.rst:1120
msgid "cp737"
msgstr "cp737"

#: ../../library/codecs.rst:1120 ../../library/codecs.rst:1151
#: ../../library/codecs.rst:1155 ../../library/codecs.rst:1181
#: ../../library/codecs.rst:1246 ../../library/codecs.rst:1281
msgid "Greek"
msgstr "希腊语"

#: ../../library/codecs.rst:1122
msgid "cp775"
msgstr "cp775"

#: ../../library/codecs.rst:1122
msgid "IBM775"
msgstr "IBM775"

#: ../../library/codecs.rst:1122 ../../library/codecs.rst:1189
#: ../../library/codecs.rst:1239 ../../library/codecs.rst:1256
msgid "Baltic languages"
msgstr "波罗的海语言"

#: ../../library/codecs.rst:1124
msgid "cp850"
msgstr "cp850"

#: ../../library/codecs.rst:1124
msgid "850, IBM850"
msgstr "850, IBM850"

#: ../../library/codecs.rst:1126
msgid "cp852"
msgstr "cp852"

#: ../../library/codecs.rst:1126
msgid "852, IBM852"
msgstr "852, IBM852"

#: ../../library/codecs.rst:1126 ../../library/codecs.rst:1174
#: ../../library/codecs.rst:1235 ../../library/codecs.rst:1285
msgid "Central and Eastern Europe"
msgstr "中欧和东欧"

#: ../../library/codecs.rst:1128
msgid "cp855"
msgstr "cp855"

#: ../../library/codecs.rst:1128
msgid "855, IBM855"
msgstr "855, IBM855"

#: ../../library/codecs.rst:1128 ../../library/codecs.rst:1176
#: ../../library/codecs.rst:1241 ../../library/codecs.rst:1278
msgid "Belarusian, Bulgarian, Macedonian, Russian, Serbian"
msgstr "白俄罗斯语，保加利亚语，马其顿语，俄语，塞尔维亚语"

#: ../../library/codecs.rst:1131
msgid "cp856"
msgstr "cp856"

#: ../../library/codecs.rst:1133
msgid "cp857"
msgstr "cp857"

#: ../../library/codecs.rst:1133
msgid "857, IBM857"
msgstr "857, IBM857"

#: ../../library/codecs.rst:1133 ../../library/codecs.rst:1166
#: ../../library/codecs.rst:1183 ../../library/codecs.rst:1250
#: ../../library/codecs.rst:1290
msgid "Turkish"
msgstr "土耳其语"

#: ../../library/codecs.rst:1135
msgid "cp858"
msgstr "cp858"

#: ../../library/codecs.rst:1135
msgid "858, IBM858"
msgstr "858, IBM858"

#: ../../library/codecs.rst:1137
msgid "cp860"
msgstr "cp860"

#: ../../library/codecs.rst:1137
msgid "860, IBM860"
msgstr "860, IBM860"

#: ../../library/codecs.rst:1137
msgid "Portuguese"
msgstr "葡萄牙语"

#: ../../library/codecs.rst:1139
msgid "cp861"
msgstr "cp861"

#: ../../library/codecs.rst:1139
msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

#: ../../library/codecs.rst:1139 ../../library/codecs.rst:1283
msgid "Icelandic"
msgstr "冰岛语"

#: ../../library/codecs.rst:1141
msgid "cp862"
msgstr "cp862"

#: ../../library/codecs.rst:1141
msgid "862, IBM862"
msgstr "862, IBM862"

#: ../../library/codecs.rst:1143
msgid "cp863"
msgstr "cp863"

#: ../../library/codecs.rst:1143
msgid "863, IBM863"
msgstr "863, IBM863"

#: ../../library/codecs.rst:1143
msgid "Canadian"
msgstr "加拿大语"

#: ../../library/codecs.rst:1145
msgid "cp864"
msgstr "cp864"

#: ../../library/codecs.rst:1145
msgid "IBM864"
msgstr "IBM864"

#: ../../library/codecs.rst:1147
msgid "cp865"
msgstr "cp865"

#: ../../library/codecs.rst:1147
msgid "865, IBM865"
msgstr "865, IBM865"

#: ../../library/codecs.rst:1147
msgid "Danish, Norwegian"
msgstr "丹麦语/挪威语"

#: ../../library/codecs.rst:1149
msgid "cp866"
msgstr "cp866"

#: ../../library/codecs.rst:1149
msgid "866, IBM866"
msgstr "866, IBM866"

#: ../../library/codecs.rst:1149 ../../library/codecs.rst:1266
msgid "Russian"
msgstr "俄语"

#: ../../library/codecs.rst:1151
msgid "cp869"
msgstr "cp869"

#: ../../library/codecs.rst:1151
msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

#: ../../library/codecs.rst:1153
msgid "cp874"
msgstr "cp874"

#: ../../library/codecs.rst:1153
msgid "Thai"
msgstr "泰语"

#: ../../library/codecs.rst:1155
msgid "cp875"
msgstr "cp875"

#: ../../library/codecs.rst:1157
msgid "cp932"
msgstr "cp932"

#: ../../library/codecs.rst:1157
msgid "932, ms932, mskanji, ms-kanji, windows-31j"
msgstr "932, ms932, mskanji, ms-kanji, windows-31j"

#: ../../library/codecs.rst:1157 ../../library/codecs.rst:1193
#: ../../library/codecs.rst:1195 ../../library/codecs.rst:1197
#: ../../library/codecs.rst:1214 ../../library/codecs.rst:1217
#: ../../library/codecs.rst:1222 ../../library/codecs.rst:1225
#: ../../library/codecs.rst:1227 ../../library/codecs.rst:1295
#: ../../library/codecs.rst:1298 ../../library/codecs.rst:1301
msgid "Japanese"
msgstr "日语"

#: ../../library/codecs.rst:1160
msgid "cp949"
msgstr "cp949"

#: ../../library/codecs.rst:1160
msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

#: ../../library/codecs.rst:1160 ../../library/codecs.rst:1199
#: ../../library/codecs.rst:1229 ../../library/codecs.rst:1264
msgid "Korean"
msgstr "韩语"

#: ../../library/codecs.rst:1162
msgid "cp950"
msgstr "cp950"

#: ../../library/codecs.rst:1162
msgid "950, ms950"
msgstr "950, ms950"

#: ../../library/codecs.rst:1164
msgid "cp1006"
msgstr "cp1006"

#: ../../library/codecs.rst:1164
msgid "Urdu"
msgstr "乌尔都语"

#: ../../library/codecs.rst:1166
msgid "cp1026"
msgstr "cp1026"

#: ../../library/codecs.rst:1166
msgid "ibm1026"
msgstr "ibm1026"

#: ../../library/codecs.rst:1168
msgid "cp1125"
msgstr "cp1125"

#: ../../library/codecs.rst:1168
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

#: ../../library/codecs.rst:1168 ../../library/codecs.rst:1272
msgid "Ukrainian"
msgstr "乌克兰语"

#: ../../library/codecs.rst:1172
msgid "cp1140"
msgstr "cp1140"

#: ../../library/codecs.rst:1172
msgid "ibm1140"
msgstr "ibm1140"

#: ../../library/codecs.rst:1174
msgid "cp1250"
msgstr "cp1250"

#: ../../library/codecs.rst:1174
msgid "windows-1250"
msgstr "windows-1250"

#: ../../library/codecs.rst:1176
msgid "cp1251"
msgstr "cp1251"

#: ../../library/codecs.rst:1176
msgid "windows-1251"
msgstr "windows-1251"

#: ../../library/codecs.rst:1179
msgid "cp1252"
msgstr "cp1252"

#: ../../library/codecs.rst:1179
msgid "windows-1252"
msgstr "windows-1252"

#: ../../library/codecs.rst:1181
msgid "cp1253"
msgstr "cp1253"

#: ../../library/codecs.rst:1181
msgid "windows-1253"
msgstr "windows-1253"

#: ../../library/codecs.rst:1183
msgid "cp1254"
msgstr "cp1254"

#: ../../library/codecs.rst:1183
msgid "windows-1254"
msgstr "windows-1254"

#: ../../library/codecs.rst:1185
msgid "cp1255"
msgstr "cp1255"

#: ../../library/codecs.rst:1185
msgid "windows-1255"
msgstr "windows-1255"

#: ../../library/codecs.rst:1187
msgid "cp1256"
msgstr "cp1256"

#: ../../library/codecs.rst:1187
msgid "windows-1256"
msgstr "windows-1256"

#: ../../library/codecs.rst:1189
msgid "cp1257"
msgstr "cp1257"

#: ../../library/codecs.rst:1189
msgid "windows-1257"
msgstr "windows-1257"

#: ../../library/codecs.rst:1191
msgid "cp1258"
msgstr "cp1258"

#: ../../library/codecs.rst:1191
msgid "windows-1258"
msgstr "windows-1258"

#: ../../library/codecs.rst:1191
msgid "Vietnamese"
msgstr "越南语"

#: ../../library/codecs.rst:1193
msgid "euc_jp"
msgstr "euc_jp"

#: ../../library/codecs.rst:1193
msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

#: ../../library/codecs.rst:1195
msgid "euc_jis_2004"
msgstr "euc_jis_2004"

#: ../../library/codecs.rst:1195
msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

#: ../../library/codecs.rst:1197
msgid "euc_jisx0213"
msgstr "euc_jisx0213"

#: ../../library/codecs.rst:1197
msgid "eucjisx0213"
msgstr "eucjisx0213"

#: ../../library/codecs.rst:1199
msgid "euc_kr"
msgstr "euc_kr"

#: ../../library/codecs.rst:1199
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

#: ../../library/codecs.rst:1203
msgid "gb2312"
msgstr "gb2312"

#: ../../library/codecs.rst:1203
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

#: ../../library/codecs.rst:1203 ../../library/codecs.rst:1212
msgid "Simplified Chinese"
msgstr "简体中文"

#: ../../library/codecs.rst:1208
msgid "gbk"
msgstr "gbk"

#: ../../library/codecs.rst:1208
msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

#: ../../library/codecs.rst:1208 ../../library/codecs.rst:1210
msgid "Unified Chinese"
msgstr "统一汉语"

#: ../../library/codecs.rst:1210
msgid "gb18030"
msgstr "gb18030"

#: ../../library/codecs.rst:1210
msgid "gb18030-2000"
msgstr "gb18030-2000"

#: ../../library/codecs.rst:1212
msgid "hz"
msgstr "hz"

#: ../../library/codecs.rst:1212
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

#: ../../library/codecs.rst:1214
msgid "iso2022_jp"
msgstr "iso2022_jp"

#: ../../library/codecs.rst:1214
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

#: ../../library/codecs.rst:1217
msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

#: ../../library/codecs.rst:1217
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

#: ../../library/codecs.rst:1219
msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

#: ../../library/codecs.rst:1219
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

#: ../../library/codecs.rst:1219
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "日语，韩语，简体中文，西欧，希腊语"

#: ../../library/codecs.rst:1222
msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

#: ../../library/codecs.rst:1222
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

#: ../../library/codecs.rst:1225
msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

#: ../../library/codecs.rst:1225
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

#: ../../library/codecs.rst:1227
msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

#: ../../library/codecs.rst:1227
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

#: ../../library/codecs.rst:1229
msgid "iso2022_kr"
msgstr "iso2022_kr"

#: ../../library/codecs.rst:1229
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

#: ../../library/codecs.rst:1232
msgid "latin_1"
msgstr "latin_1"

#: ../../library/codecs.rst:1232
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

#: ../../library/codecs.rst:1235
msgid "iso8859_2"
msgstr "iso8859_2"

#: ../../library/codecs.rst:1235
msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

#: ../../library/codecs.rst:1237
msgid "iso8859_3"
msgstr "iso8859_3"

#: ../../library/codecs.rst:1237
msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

#: ../../library/codecs.rst:1237
msgid "Esperanto, Maltese"
msgstr "世界语，马耳他语"

#: ../../library/codecs.rst:1239
msgid "iso8859_4"
msgstr "iso8859_4"

#: ../../library/codecs.rst:1239
msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

#: ../../library/codecs.rst:1241
msgid "iso8859_5"
msgstr "iso8859_5"

#: ../../library/codecs.rst:1241
msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

#: ../../library/codecs.rst:1244
msgid "iso8859_6"
msgstr "iso8859_6"

#: ../../library/codecs.rst:1244
msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

#: ../../library/codecs.rst:1246
msgid "iso8859_7"
msgstr "iso8859_7"

#: ../../library/codecs.rst:1246
msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

#: ../../library/codecs.rst:1248
msgid "iso8859_8"
msgstr "iso8859_8"

#: ../../library/codecs.rst:1248
msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

#: ../../library/codecs.rst:1250
msgid "iso8859_9"
msgstr "iso8859_9"

#: ../../library/codecs.rst:1250
msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

#: ../../library/codecs.rst:1252
msgid "iso8859_10"
msgstr "iso8859_10"

#: ../../library/codecs.rst:1252
msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

#: ../../library/codecs.rst:1252
msgid "Nordic languages"
msgstr "北欧语言"

#: ../../library/codecs.rst:1254
msgid "iso8859_11"
msgstr "iso8859_11"

#: ../../library/codecs.rst:1254
msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

#: ../../library/codecs.rst:1254
msgid "Thai languages"
msgstr "泰语"

#: ../../library/codecs.rst:1256
msgid "iso8859_13"
msgstr "iso8859_13"

#: ../../library/codecs.rst:1256
msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

#: ../../library/codecs.rst:1258
msgid "iso8859_14"
msgstr "iso8859_14"

#: ../../library/codecs.rst:1258
msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

#: ../../library/codecs.rst:1258
msgid "Celtic languages"
msgstr "凯尔特语"

#: ../../library/codecs.rst:1260
msgid "iso8859_15"
msgstr "iso8859_15"

#: ../../library/codecs.rst:1260
msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

#: ../../library/codecs.rst:1262
msgid "iso8859_16"
msgstr "iso8859_16"

#: ../../library/codecs.rst:1262
msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

#: ../../library/codecs.rst:1262
msgid "South-Eastern Europe"
msgstr "东南欧"

#: ../../library/codecs.rst:1264
msgid "johab"
msgstr "johab"

#: ../../library/codecs.rst:1264
msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

#: ../../library/codecs.rst:1266
msgid "koi8_r"
msgstr "koi8_r"

#: ../../library/codecs.rst:1268
msgid "koi8_t"
msgstr "koi8_t"

#: ../../library/codecs.rst:1268
msgid "Tajik"
msgstr "塔吉克"

#: ../../library/codecs.rst:1272
msgid "koi8_u"
msgstr "koi8_u"

#: ../../library/codecs.rst:1274
msgid "kz1048"
msgstr "kz1048"

#: ../../library/codecs.rst:1274
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

#: ../../library/codecs.rst:1274 ../../library/codecs.rst:1292
msgid "Kazakh"
msgstr "哈萨克语"

#: ../../library/codecs.rst:1278
msgid "mac_cyrillic"
msgstr "mac_cyrillic"

#: ../../library/codecs.rst:1278
msgid "maccyrillic"
msgstr "maccyrillic"

#: ../../library/codecs.rst:1281
msgid "mac_greek"
msgstr "mac_greek"

#: ../../library/codecs.rst:1281
msgid "macgreek"
msgstr "macgreek"

#: ../../library/codecs.rst:1283
msgid "mac_iceland"
msgstr "mac_iceland"

#: ../../library/codecs.rst:1283
msgid "maciceland"
msgstr "maciceland"

#: ../../library/codecs.rst:1285
msgid "mac_latin2"
msgstr "mac_latin2"

#: ../../library/codecs.rst:1285
msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

#: ../../library/codecs.rst:1288
msgid "mac_roman"
msgstr "mac_roman"

#: ../../library/codecs.rst:1288
msgid "macroman, macintosh"
msgstr "macroman, macintosh"

#: ../../library/codecs.rst:1290
msgid "mac_turkish"
msgstr "mac_turkish"

#: ../../library/codecs.rst:1290
msgid "macturkish"
msgstr "macturkish"

#: ../../library/codecs.rst:1292
msgid "ptcp154"
msgstr "ptcp154"

#: ../../library/codecs.rst:1292
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

#: ../../library/codecs.rst:1295
msgid "shift_jis"
msgstr "shift_jis"

#: ../../library/codecs.rst:1295
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

#: ../../library/codecs.rst:1298
msgid "shift_jis_2004"
msgstr "shift_jis_2004"

#: ../../library/codecs.rst:1298
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

#: ../../library/codecs.rst:1301
msgid "shift_jisx0213"
msgstr "shift_jisx0213"

#: ../../library/codecs.rst:1301
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

#: ../../library/codecs.rst:1304
msgid "utf_32"
msgstr "utf_32"

#: ../../library/codecs.rst:1304
msgid "U32, utf32"
msgstr "U32, utf32"

#: ../../library/codecs.rst:1304 ../../library/codecs.rst:1306
#: ../../library/codecs.rst:1308 ../../library/codecs.rst:1310
#: ../../library/codecs.rst:1312 ../../library/codecs.rst:1314
#: ../../library/codecs.rst:1316 ../../library/codecs.rst:1318
#: ../../library/codecs.rst:1320
msgid "all languages"
msgstr "所有语言"

#: ../../library/codecs.rst:1306
msgid "utf_32_be"
msgstr "utf_32_be"

#: ../../library/codecs.rst:1306
msgid "UTF-32BE"
msgstr "UTF-32BE"

#: ../../library/codecs.rst:1308
msgid "utf_32_le"
msgstr "utf_32_le"

#: ../../library/codecs.rst:1308
msgid "UTF-32LE"
msgstr "UTF-32LE"

#: ../../library/codecs.rst:1310
msgid "utf_16"
msgstr "utf_16"

#: ../../library/codecs.rst:1310
msgid "U16, utf16"
msgstr "U16, utf16"

#: ../../library/codecs.rst:1312
msgid "utf_16_be"
msgstr "utf_16_be"

#: ../../library/codecs.rst:1312
msgid "UTF-16BE"
msgstr "UTF-16BE"

#: ../../library/codecs.rst:1314
msgid "utf_16_le"
msgstr "utf_16_le"

#: ../../library/codecs.rst:1314
msgid "UTF-16LE"
msgstr "UTF-16LE"

#: ../../library/codecs.rst:1316
msgid "utf_7"
msgstr "utf_7"

#: ../../library/codecs.rst:1316
msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

#: ../../library/codecs.rst:1318
msgid "utf_8"
msgstr "utf_8"

#: ../../library/codecs.rst:1318
msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

#: ../../library/codecs.rst:1320
msgid "utf_8_sig"
msgstr "utf_8_sig"

#: ../../library/codecs.rst:1323
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"utf-16\\* 和 utf-32\\* 编码器将不再允许编码代理码位 (``U+D800``--``U+DFFF``)。 utf-32\\* "
"解码器将不再解码与代理码位相对应的字节序列。"

#: ../../library/codecs.rst:1329
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` 现在是 ``utf_8`` 的一个别名。"

#: ../../library/codecs.rst:1334
msgid "Python Specific Encodings"
msgstr "Python 专属的编码格式"

#: ../../library/codecs.rst:1336
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"有一些预定义编解码器是 Python 专属的，因此它们在 Python 之外没有意义。 "
"这些编解码器按其所预期的输入和输出类型在下表中列出（请注意虽然文本编码是编解码器最常见的使用场景，但下层的编解码器架构支持任意数据转换而不仅是文本编码）。"
" 对于非对称编解码器，该列描述的含义是编码方向。"

#: ../../library/codecs.rst:1344
msgid "Text Encodings"
msgstr "文字编码"

#: ../../library/codecs.rst:1346
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and "
":term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"以下编解码器提供了 :class:`str` 到 :class:`bytes` 的编码和 :term:`bytes-like object` 到 "
":class:`str` 的解码，类似于 Unicode 文本编码。"

#: ../../library/codecs.rst:1355
msgid "idna"
msgstr "idna"

#: ../../library/codecs.rst:1355
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr "实现 :rfc:`3490`，另请参阅 :mod:`encodings.idna` 。仅支持 ``errors='strict'`` 。"

#: ../../library/codecs.rst:1361
msgid "mbcs"
msgstr "mbcs"

#: ../../library/codecs.rst:1361
msgid "ansi, dbcs"
msgstr "ansi, dbcs"

#: ../../library/codecs.rst:1361
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr "Windows 专属：根据 ANSI 代码页（CP_ACP）对操作数进行编码。"

#: ../../library/codecs.rst:1365
msgid "oem"
msgstr "oem"

#: ../../library/codecs.rst:1365
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr "Windows 专属：根据 OEM 代码页（CP_OEMCP）对操作数进行编码。"

#: ../../library/codecs.rst:1371
msgid "palmos"
msgstr "palmos"

#: ../../library/codecs.rst:1371
msgid "Encoding of PalmOS 3.5."
msgstr "PalmOS 3.5 的编码格式"

#: ../../library/codecs.rst:1373
msgid "punycode"
msgstr "punycode"

#: ../../library/codecs.rst:1373
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "实现 :rfc:`3492`。 不支持有状态编解码器。"

#: ../../library/codecs.rst:1377
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../../library/codecs.rst:1377
msgid ""
"Latin-1 encoding with :samp:`\\\\u{XXXX}` and :samp:`\\\\U{XXXXXXXX}` for "
"other code points. Existing backslashes are not escaped in any way. It is "
"used in the Python pickle protocol."
msgstr ""
"Latin-1 编码格式附带对其他码位以 :samp:`\\\\u{XXXX}` 和 :samp:`\\\\U{XXXXXXXX}` 进行编码。 "
"现有的反斜杠不会以任何方式转义。 它被用于 Python 的 pickle 协议。"

#: ../../library/codecs.rst:1387
msgid "undefined"
msgstr "undefined"

#: ../../library/codecs.rst:1387
msgid "This Codec should only be used for testing purposes."
msgstr "该编解码器应当仅用于测试目的。"

#: ../../library/codecs.rst:1391
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr "所有转换都将引发异常，甚至对空字符串也不例外。 错误处理方案会被忽略。"

#: ../../library/codecs.rst:1396
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../../library/codecs.rst:1396
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"适合用于以 ASCII 编码的 Python 源代码中的 Unicode 字面值内容的编码格式，但引号不会被转义。 对 Latin-1 源代码进行解码。"
" 请注意 Python 源代码实际上默认使用 UTF-8。"

#: ../../library/codecs.rst:1408
msgid "\"unicode_internal\" codec is removed."
msgstr "\"unicode_internal\" 编解码器已被移除。"

#: ../../library/codecs.rst:1415
msgid "Binary Transforms"
msgstr "二进制转换"

#: ../../library/codecs.rst:1417
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` to"
" :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"以下编解码器提供了二进制转换: :term:`bytes-like object` 到 :class:`bytes` 的映射。 它们不被 "
":meth:`bytes.decode` 所支持（该方法只生成 :class:`str` 类型的输出）。"

#: ../../library/codecs.rst:1425
msgid "Encoder / decoder"
msgstr "编码器/解码器"

#: ../../library/codecs.rst:1427
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../../library/codecs.rst:1427
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../../library/codecs.rst:1427
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr "将操作数转换为多行 MIME base64 (结果总是包含一个末尾的 ``'\\n'``)"

#: ../../library/codecs.rst:1432
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr "接受任意 :term:`bytes-like object` 作为输入用于编码和解码"

#: ../../library/codecs.rst:1427
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

#: ../../library/codecs.rst:1438
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../../library/codecs.rst:1438
msgid "bz2"
msgstr "bz2"

#: ../../library/codecs.rst:1438
msgid "Compress the operand using bz2."
msgstr "使用bz2压缩操作数"

#: ../../library/codecs.rst:1438
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

#: ../../library/codecs.rst:1441
msgid "hex_codec"
msgstr "hex_codec"

#: ../../library/codecs.rst:1441
msgid "hex"
msgstr "hex"

#: ../../library/codecs.rst:1441
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr "将操作数转换为十六进制表示，每个字节有两位数"

#: ../../library/codecs.rst:1441
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

#: ../../library/codecs.rst:1446
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../../library/codecs.rst:1446
msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, quotedprintable, quoted_printable"

#: ../../library/codecs.rst:1446
msgid "Convert the operand to MIME quoted printable."
msgstr "将操作数转换为 MIME 带引号的可打印数据"

#: ../../library/codecs.rst:1446
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` 且 ``quotetabs=True`` / :meth:`quopri.decode`"

#: ../../library/codecs.rst:1450
msgid "uu_codec"
msgstr "uu_codec"

#: ../../library/codecs.rst:1450
msgid "uu"
msgstr "uu"

#: ../../library/codecs.rst:1450
msgid "Convert the operand using uuencode."
msgstr "使用uuencode转换操作数"

#: ../../library/codecs.rst:1453
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../../library/codecs.rst:1453
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../../library/codecs.rst:1453
msgid "Compress the operand using gzip."
msgstr "使用gzip压缩操作数"

#: ../../library/codecs.rst:1453
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../../library/codecs.rst:1457
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"除了 :term:`字节类对象 <bytes-like object>`，``'base64_codec'`` 也接受仅包含 ASCII 的 "
":class:`str` 实例用于解码"

#: ../../library/codecs.rst:1461
msgid "Restoration of the binary transforms."
msgstr "恢复二进制转换。"

#: ../../library/codecs.rst:1464
msgid "Restoration of the aliases for the binary transforms."
msgstr "恢复二进制转换的别名。"

#: ../../library/codecs.rst:1471
msgid "Text Transforms"
msgstr "文字转换"

#: ../../library/codecs.rst:1473
msgid ""
"The following codec provides a text transform: a :class:`str` to "
":class:`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"以下编解码器提供了文本转换: :class:`str` 到 :class:`str` 的映射。 它不被 :meth:`str.encode` "
"所支持（该方法只生成 :class:`bytes` 类型的输出）。"

#: ../../library/codecs.rst:1482
msgid "rot_13"
msgstr "rot_13"

#: ../../library/codecs.rst:1482
msgid "rot13"
msgstr "rot13"

#: ../../library/codecs.rst:1482
msgid "Return the Caesar-cypher encryption of the operand."
msgstr "返回操作数的凯撒密码加密结果"

#: ../../library/codecs.rst:1487
msgid "Restoration of the ``rot_13`` text transform."
msgstr "恢复 ``rot_13`` 文本转换。"

#: ../../library/codecs.rst:1490
msgid "Restoration of the ``rot13`` alias."
msgstr "恢复 ``rot13`` 别名。"

#: ../../library/codecs.rst:1495
msgid ":mod:`encodings` --- Encodings package"
msgstr ":mod:`encodings` --- 编码格式包"

#: ../../library/codecs.rst:1500
msgid "This module implements the following functions:"
msgstr "这个模块实现了以下函数："

#: ../../library/codecs.rst:1504
msgid "Normalize encoding name *encoding*."
msgstr "规范化编码格式名称 *encoding*。"

#: ../../library/codecs.rst:1506
msgid ""
"Normalization works as follows: all non-alphanumeric characters except the "
"dot used for Python package names are collapsed and replaced with a single "
"underscore, leading and trailing underscores are removed. For example, ``'  "
"-;#'`` becomes ``'_'``."
msgstr ""
"规范化的运作方式如下：用于 Python 包名称的点号除外的所有非字母数字类字符都会被缩减替换为一个下划线，开头和末尾的下划线将被移除。 例如，``'"
"  -;#'`` 将变为 ``'_'``。"

#: ../../library/codecs.rst:1511
msgid "Note that *encoding* should be ASCII only."
msgstr "请注意 *encoding* 应当仅用 ASCII 字符。"

#: ../../library/codecs.rst:1515
msgid ""
"The following function should not be used directly, except for testing "
"purposes; :func:`codecs.lookup` should be used instead."
msgstr "以下函数不应被直接使用，除非出于测试目的；应当改用 :func:`codecs.lookup`。"

#: ../../library/codecs.rst:1521
msgid ""
"Search for the codec module corresponding to the given encoding name "
"*encoding*."
msgstr "搜索与给定的编码格式名称 *encoding* 对应的编解码器模块。"

#: ../../library/codecs.rst:1524
msgid ""
"This function first normalizes the *encoding* using "
":func:`normalize_encoding`, then looks for a corresponding alias. It "
"attempts to import a codec module from the encodings package using either "
"the alias or the normalized name. If the module is found and defines a valid"
" ``getregentry()`` function that returns a :class:`codecs.CodecInfo` object,"
" the codec is cached and returned."
msgstr ""
"此函数首先会使用 :func:`normalize_encoding` 来规范化 *encoding*，然后查找相应的别名。 "
"它会尝试使用别名或规范化的名称从 encodings 包导入一个编解码器模块。 如果模块被找到并且它定义了有效的返回 "
":class:`codecs.CodecInfo` 对象的 ``getregentry()`` 函数，该编解码器将被缓存并被返回。"

#: ../../library/codecs.rst:1531
msgid ""
"If the codec module defines a ``getaliases()`` function any returned aliases"
" are registered for future use."
msgstr "如果该编解码器模式定义了 ``getaliases()`` 函数则任何被返回的别名都将被注册以供将来使用。"

#: ../../library/codecs.rst:1535
msgid "This module implements the following exception:"
msgstr "这个模块实现了以下异常："

#: ../../library/codecs.rst:1539
msgid "Raised when a codec is invalid or incompatible."
msgstr "当一个编解码器无效或不兼容时将被引发。"

#: ../../library/codecs.rst:1543
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ":mod:`encodings.idna` --- 应用程序中的国际化域名"

#: ../../library/codecs.rst:1549
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"此模块实现了 :rfc:`3490` (应用程序中的国际化域名) 和 :rfc:`3492` (Nameprep: 用于国际化域名 (IDN) 的 "
"Stringprep 配置文件)。 它是在 ``punycode`` 编码格式和 :mod:`stringprep` 的基础上构建的。"

#: ../../library/codecs.rst:1554
msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the"
" third-party :pypi:`idna` module."
msgstr ""
"如果你需要来自 :rfc:`5891` 和 :rfc:`5895` 的 IDNA 2008 标准，请使用第三方的 :pypi:`idna` 模块。"

#: ../../library/codecs.rst:1557
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as "
"``www.Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding"
" (ACE, such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the "
"domain name is then used in all places where arbitrary characters are not "
"allowed by the protocol, such as DNS queries, HTTP :mailheader:`Host` "
"fields, and so on. This conversion is carried out in the application; if "
"possible invisible to the user: The application should transparently convert"
" Unicode domain labels to IDNA on the wire, and convert back ACE labels to "
"Unicode before presenting them to the user."
msgstr ""
"这些 RFC 共同定义了一个在域名中支持非 ASCII 字符的协议。 一个包含非 ASCII 字符的域名 (例如 "
"``www.Alliancefrançaise.nu``) 会被转换为兼容 ASCII 的编码格式 (简称 ACE，例如 ``www.xn--"
"alliancefranaise-npb.nu``)。 随后此域名的 ACE 形式可以用于所有由于特定协议而不允许使用任意字符的场合，例如 DNS "
"查询，HTTP :mailheader:`Host` 字段等等。 此转换是在应用中进行的；如有可能将对用户可见：应用应当透明地将 Unicode "
"域名标签转换为线上的 IDNA，并在 ACE 标签被呈现给用户之前将其转换回 Unicode。"

#: ../../library/codecs.rst:1568
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into"
" labels based on the separator characters defined in :rfc:`section 3.1 of "
"RFC 3490 <3490#section-3.1>` and converting each label to ACE as required, "
"and conversely separating an input byte string into labels based on the "
"``.`` separator and converting any ACE labels found into unicode. "
"Furthermore, the :mod:`socket` module transparently converts Unicode host "
"names to ACE, so that applications need not be concerned about converting "
"host names themselves when they pass them to the socket module. On top of "
"that, modules that have host names as function parameters, such as "
":mod:`http.client` and :mod:`ftplib`, accept Unicode host names "
"(:mod:`http.client` then also transparently sends an IDNA hostname in the "
":mailheader:`Host` field if it sends that field at all)."
msgstr ""
"Python 以多种方式支持这种转换:  ``idna`` 编解码器执行 Unicode 和 ACE 之间的转换，基于在 :rfc:`section "
"3.1 of RFC 3490 <3490#section-3.1>` 中定义的分隔字符将输入字符串拆分为标签，再根据需要将每个标签转换为 "
"ACE，相反地又会基于 ``.`` 分隔符将输入字节串拆分为标签，再将找到的任何 ACE 标签转换为 Unicode。 此外，:mod:`socket`"
" 模块可透明地将 Unicode 主机名转换为 ACE，以便应用在将它们传给 socket 模块时无须自行转换主机名。 "
"除此之外，许多包含以主机名作为函数参数的模块例如 :mod:`http.client` 和 :mod:`ftplib` 都接受 Unicode "
"主机名（并且 :mod:`http.client` 也会在 :mailheader:`Host` 字段中透明地发送 IDNA "
"主机名，如果它需要发送该字段的话）。"

#: ../../library/codecs.rst:1581
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no"
" automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"当从线路接收主机名时（例如反向名称查找），到 Unicode 的转换不会自动被执行：希望向用户提供此种主机名的应用应当将它们解码为 Unicode。"

#: ../../library/codecs.rst:1585
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
":mod:`encodings.idna` 模块还实现了 nameprep "
"过程，该过程会对主机名执行特定的规范化操作，以实现国际域名的大小写不敏感特性与合并相似的字符。 如果有需要可以直接使用 nameprep 函数。"

#: ../../library/codecs.rst:1593
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr "返回 *label* 经过名称处理操作的版本。 该实现目前基于查询字符串，因此 ``AllowUnassigned`` 为真值。"

#: ../../library/codecs.rst:1599
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules``"
" is assumed to be false."
msgstr "将标签转换为 ASCII，规则定义见 :rfc:`3490`。 ``UseSTD3ASCIIRules`` 预设为假值。"

#: ../../library/codecs.rst:1605
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr "将标签转换为 Unicode，规则定义见 :rfc:`3490`。"

#: ../../library/codecs.rst:1609
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- Windows ANSI代码页"

#: ../../library/codecs.rst:1614
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "此模块实现ANSI代码页（CP_ACP）。"

#: ../../library/codecs.rst:1616
msgid "Availability"
msgstr "Availability"

#: ../../library/codecs.rst:1618
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used"
" to encode, and ``'ignore'`` to decode."
msgstr ""
"在 3.2 版之前， *errors* 参数会被忽略；总是会使用 ``'replace'`` 进行编码，并使用 ``'ignore'`` 进行解码。"

#: ../../library/codecs.rst:1622
msgid "Support any error handler."
msgstr "支持任何错误处理"

#: ../../library/codecs.rst:1627
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- 带BOM签名的UTF-8编解码器"

#: ../../library/codecs.rst:1633
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"此模块实现了 UTF-8 编解码器的一个变种：在编码时将把 UTF-8 已编码 BOM 添加到 UTF-8 编码字节数据的开头。 "
"对于有状态编码器此操作只执行一次（当首次写入字节流时）。 在解码时将跳过数据开头作为可选项的 UTF-8 已编码 BOM。"

#: ../../library/codecs.rst:13
msgid "Unicode"
msgstr "Unicode"

#: ../../library/codecs.rst:13
msgid "encode"
msgstr "encode"

#: ../../library/codecs.rst:13
msgid "decode"
msgstr "decode"

#: ../../library/codecs.rst:13
msgid "streams"
msgstr "streams"

#: ../../library/codecs.rst:13
msgid "stackable"
msgstr "stackable"

#: ../../library/codecs.rst:334
msgid "strict"
msgstr "strict"

#: ../../library/codecs.rst:334 ../../library/codecs.rst:386
#: ../../library/codecs.rst:409
msgid "error handler's name"
msgstr "错误处理器名称"

#: ../../library/codecs.rst:334
msgid "ignore"
msgstr "ignore"

#: ../../library/codecs.rst:334
msgid "replace"
msgstr "replace"

#: ../../library/codecs.rst:334
msgid "backslashreplace"
msgstr "backslashreplace"

#: ../../library/codecs.rst:334
msgid "surrogateescape"
msgstr "surrogateescape"

#: ../../library/codecs.rst:334
msgid "? (question mark)"
msgstr "? (问号)"

#: ../../library/codecs.rst:334
msgid "replacement character"
msgstr "替代字符"

#: ../../library/codecs.rst:334
msgid "\\ (backslash)"
msgstr "\\ (反斜杠)"

#: ../../library/codecs.rst:334 ../../library/codecs.rst:386
msgid "escape sequence"
msgstr "转义序列"

#: ../../library/codecs.rst:334
msgid "\\x"
msgstr "\\x"

#: ../../library/codecs.rst:334
msgid "\\u"
msgstr "\\u"

#: ../../library/codecs.rst:334
msgid "\\U"
msgstr "\\U"

#: ../../library/codecs.rst:386
msgid "xmlcharrefreplace"
msgstr "xmlcharrefreplace"

#: ../../library/codecs.rst:386
msgid "namereplace"
msgstr "namereplace"

#: ../../library/codecs.rst:409
msgid "surrogatepass"
msgstr "surrogatepass"
