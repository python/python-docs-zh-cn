# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/tokenize.rst:2
msgid ":mod:`!tokenize` --- Tokenizer for Python source"
msgstr ":mod:`!tokenize` --- Python 源代码的分词器"

#: ../../library/tokenize.rst:10
msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**源码：** :source:`Lib/tokenize.py`"

#: ../../library/tokenize.rst:14
msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as"
" tokens as well, making it useful for implementing \"pretty-printers\", "
"including colorizers for on-screen displays."
msgstr ""
":mod:`tokenize` 模块为 Python 源代码提供了一个词法扫描器，用 Python "
"实现。该模块中的扫描器也将注释作为标记返回，这使得它对于实现“漂亮的输出器”非常有用，包括用于屏幕显示的着色器。"

#: ../../library/tokenize.rst:19
msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and "
":ref:`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned using"
" the generic :data:`~token.OP` token type.  The exact type can be determined"
" by checking the ``exact_type`` property on the :term:`named tuple` returned"
" from :func:`tokenize.tokenize`."
msgstr ""
"为了简化标记流的处理，所有的 :ref:`运算符 <operators>` 和 :ref:`定界符 <delimiters>` 以及 "
":data:`Ellipsis` 返回时都会打上通用的 :data:`~token.OP` 标记。 可以通过 "
":func:`tokenize.tokenize` 返回的 :term:`named tuple` 对象的 ``exact_type`` "
"属性来获得确切的标记类型。"

#: ../../library/tokenize.rst:28
msgid ""
"Note that the functions in this module are only designed to parse "
"syntactically valid Python code (code that does not raise when parsed using "
":func:`ast.parse`).  The behavior of the functions in this module is "
"**undefined** when providing invalid Python code and it can change at any "
"point."
msgstr ""
"请注意本模块中的函数被设计为仅能解析符合语法的 Python 代码（当使用 :func:`ast.parse` 解析代码时不会引发异常）。 在提供无效的"
" Python 代码时本模块中函数的行为是 **未定义** 的并可能在任何时候发生改变。"

#: ../../library/tokenize.rst:35
msgid "Tokenizing Input"
msgstr "对输入进行解析标记"

#: ../../library/tokenize.rst:37
msgid "The primary entry point is a :term:`generator`:"
msgstr "主要的入口是一个 :term:`generator`:"

#: ../../library/tokenize.rst:41
msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the "
":meth:`io.IOBase.readline` method of file objects.  Each call to the "
"function should return one line of input as bytes."
msgstr ""
"生成器 :func:`.tokenize` 需要一个 *readline* 参数，这个参数必须是一个可调用对象，且能提供与文件对象的 "
":meth:`io.IOBase.readline` 方法相同的接口。每次调用这个函数都要 返回字节类型输入的一行数据。"

#: ../../library/tokenize.rst:46
msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item)"
" is the *physical* line.  The 5 tuple is returned as a :term:`named tuple` "
"with the field names: ``type string start end line``."
msgstr ""
"生成器产生 5 个具有这些成员的元组：令牌类型；令牌字符串；指定令牌在源中开始的行和列的 2 元组 ``(srow, scol)`` "
"；指定令牌在源中结束的行和列的 2 元组 ``(erow, ecol)`` ；以及发现令牌的行。所传递的行（最后一个元组项）是 *实际的* 行。 5 "
"个元组以 :term:`named tuple` 的形式返回，字段名是： ``type string start end line`` 。"

#: ../../library/tokenize.rst:55
msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for :data:`~token.OP` "
"tokens.  For all other token types ``exact_type`` equals the named tuple "
"``type`` field."
msgstr ""
"返回的 :term:`named tuple` 有一个额外的属性，名为 ``exact_type`` ，包含了 :data:`~token.OP` "
"标记的确切操作符类型。 对于所有其他标记类型， ``exact_type`` 等于命名元组的 ``type`` 字段。"

#: ../../library/tokenize.rst:60
msgid "Added support for named tuples."
msgstr "增加了对 named tuple 的支持。"

#: ../../library/tokenize.rst:63
msgid "Added support for ``exact_type``."
msgstr "添加了对 ``exact_type`` 的支持。"

#: ../../library/tokenize.rst:66
msgid ""
":func:`.tokenize` determines the source encoding of the file by looking for "
"a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr "根据 :pep:`263` ，:func:`.tokenize` 通过寻找 UTF-8 BOM 或编码 cookie 来确定文件的源编码。"

#: ../../library/tokenize.rst:71
msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "对读取 unicode 字符串而不是字节的源进行标记。"

#: ../../library/tokenize.rst:73
msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a "
"single line of input. However, :func:`generate_tokens` expects *readline* to"
" return a str object rather than bytes."
msgstr ""
"和 :func:`.tokenize` 一样， *readline* 参数是一个返回单行输入的可调用参数。然而， "
":func:`generate_tokens` 希望 *readline* 返回一个 str 对象而不是字节。"

#: ../../library/tokenize.rst:77
msgid ""
"The result is an iterator yielding named tuples, exactly like "
":func:`.tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"其结果是一个产生具名元组的的迭代器，与 :func:`.tokenize` 完全一样。 它不会产生 :data:`~token.ENCODING` "
"标记。"

#: ../../library/tokenize.rst:80
msgid ""
"All constants from the :mod:`token` module are also exported from "
":mod:`tokenize`."
msgstr "所有来自 :mod:`token` 模块的常量也可从 :mod:`tokenize` 导出。"

#: ../../library/tokenize.rst:83
msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr "提供了另一个函数来逆转标记化过程。这对于创建对脚本进行标记、修改标记流并写回修改后脚本的工具很有用。"

#: ../../library/tokenize.rst:90
msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr ""
"将令牌转换为 Python 源代码。 *iterable* 必须返回至少有两个元素的序列，即令牌类型和令牌字符串。任何额外的序列元素都会被忽略。"

#: ../../library/tokenize.rst:94
msgid ""
"The result is guaranteed to tokenize back to match the input so that the "
"conversion is lossless and round-trips are assured.  The guarantee applies "
"only to the token type and token string as the spacing between tokens "
"(column positions) may change."
msgstr ""
"结果将保证会被词元化为与输入相匹配因此转换是无损的并且确保可以来回反复。 此项保证只适用于词元类型和词元字符串因为词元之间的空位（列位置）可能发生改变。"

#: ../../library/tokenize.rst:99
msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which is "
"the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
"它返回字节，使用 :data:`~token.ENCODING` 标记进行编码，这是由 :func:`.tokenize` "
"输出的第一个标记序列。如果输入中没有编码令牌，它将返回一个字符串。"

#: ../../library/tokenize.rst:104
msgid ""
":func:`.tokenize` needs to detect the encoding of source files it tokenizes."
" The function it uses to do this is available:"
msgstr ":func:`.tokenize` 需要检测它所标记源文件的编码。它用来做这件事的函数是可用的："

#: ../../library/tokenize.rst:109
msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
":func:`detect_encoding` 函数用于检测解码 Python 源文件时应使用的编码。它需要一个参数， readline ，与 "
":func:`.tokenize` 生成器的使用方式相同。"

#: ../../library/tokenize.rst:113
msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a"
" string) and a list of any lines (not decoded from bytes) it has read in."
msgstr "它最多调用 readline 两次，并返回所使用的编码（作为一个字符串）和它所读入的任何行（不是从字节解码的）的 list 。"

#: ../../library/tokenize.rst:117
msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are present, "
"but disagree, a :exc:`SyntaxError` will be raised. Note that if the BOM is "
"found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
"它从 UTF-8 BOM 或编码 cookie 的存在中检测编码格式，如 :pep:`263` 所指明的。 如果 BOM 和 cookie "
"都存在，但不一致，将会引发 :exc:`SyntaxError`。 请注意，如果找到 BOM ，将返回 ``'utf-8-sig'`` 作为编码格式。"

#: ../../library/tokenize.rst:122
msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr "如果没有指定编码，那么将返回默认的 ``'utf-8'`` 编码."

#: ../../library/tokenize.rst:125
msgid ""
"Use :func:`.open` to open Python source files: it uses "
":func:`detect_encoding` to detect the file encoding."
msgstr "使用 :func:`.open` 来打开 Python 源文件：它使用 :func:`detect_encoding` 来检测文件编码。"

#: ../../library/tokenize.rst:131
msgid ""
"Open a file in read only mode using the encoding detected by "
":func:`detect_encoding`."
msgstr "使用由 :func:`detect_encoding` 检测到的编码，以只读模式打开一个文件。"

#: ../../library/tokenize.rst:138
msgid ""
"Raised when either a docstring or expression that may be split over several "
"lines is not completed anywhere in the file, for example::"
msgstr "当文件中任何地方没有完成 docstring 或可能被分割成几行的表达式时触发，例如::"

#: ../../library/tokenize.rst:141
msgid ""
"\"\"\"Beginning of\n"
"docstring"
msgstr ""
"\"\"\"Beginning of\n"
"docstring"

#: ../../library/tokenize.rst:144
msgid "or::"
msgstr "或者::"

#: ../../library/tokenize.rst:146
msgid ""
"[1,\n"
" 2,\n"
" 3"
msgstr ""
"[1,\n"
" 2,\n"
" 3"

#: ../../library/tokenize.rst:153
msgid "Command-Line Usage"
msgstr "命令行用法"

#: ../../library/tokenize.rst:157
msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ":mod:`tokenize` 模块可以作为一个脚本从命令行执行。这很简单:"

#: ../../library/tokenize.rst:160
msgid "python -m tokenize [-e] [filename.py]"
msgstr "python -m tokenize [-e] [filename.py]"

#: ../../library/tokenize.rst:164
msgid "The following options are accepted:"
msgstr "可以接受以下选项："

#: ../../library/tokenize.rst:170
msgid "show this help message and exit"
msgstr "显示此帮助信息并退出"

#: ../../library/tokenize.rst:174
msgid "display token names using the exact type"
msgstr "使用确切的类型显示令牌名称"

#: ../../library/tokenize.rst:176
msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout. "
"Otherwise, tokenization is performed on stdin."
msgstr "如果 :file:`filename.py` 被指定，其内容会被标记到 stdout 。否则，标记化将在 stdin 上执行。"

#: ../../library/tokenize.rst:180
msgid "Examples"
msgstr "例子"

#: ../../library/tokenize.rst:182
msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr "脚本改写器的例子，它将 float 文本转换为 Decimal 对象::"

#: ../../library/tokenize.rst:185
msgid ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"Substitute Decimals for floats in a string of statements.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    The format of the exponent is inherited from the platform C library.\n"
"    Known cases are \"e-007\" (Windows) and \"e-07\" (not Windows).  Since\n"
"    we're only showing 12 digits, and the 13th isn't close to 5, the\n"
"    rest of the output should be platform-independent.\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Output from calculations with Decimal should be identical across all\n"
"    platforms.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # tokenize the string\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"
msgstr ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"在一个语句字符串中用 Decimal 替代浮点数。\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    指数的格式继承自平台的 C 库。\n"
"    已知用例有 \"e-007\" (Windows) 和 \"e-07\" (非 Windows)。 \n"
"    由于我们只显示 12 个数位，且第 13 位的值不到 5，因此\n"
"    输出的其余部分应当是依赖于具体平台的。\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    使用 Decimal 进行计算的输出应当在所有平台上保持一致。\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # tokenize the string\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # 替换 NUMBER 形符\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"

#: ../../library/tokenize.rst:224
msgid "Example of tokenizing from the command line.  The script::"
msgstr "从命令行进行标记化的例子。 脚本::"

#: ../../library/tokenize.rst:226
msgid ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"
msgstr ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"

#: ../../library/tokenize.rst:231
msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second "
"column is the name of the token, and the final column is the value of the "
"token (if any)"
msgstr "将被标记为以下输出，其中第一列是发现标记的行 / 列坐标范围，第二列是标记的名称，最后一列是标记的值（如果有）。"

#: ../../library/tokenize.rst:235
msgid ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

#: ../../library/tokenize.rst:259
msgid ""
"The exact token type names can be displayed using the :option:`-e` option:"
msgstr "可以使用 :option:`-e` 选项来显示确切的标记类型名称。"

#: ../../library/tokenize.rst:261
msgid ""
"$ python -m tokenize -e hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"$ python -m tokenize -e hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

#: ../../library/tokenize.rst:285
msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr "以编程方式对文件进行标记的例子，用 :func:`generate_tokens` 读取 unicode 字符串而不是字节::"

#: ../../library/tokenize.rst:288
msgid ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"

#: ../../library/tokenize.rst:295
msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "或者通过 :func:`.tokenize` 直接读取字节数据::"

#: ../../library/tokenize.rst:297
msgid ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
