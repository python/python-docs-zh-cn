# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/profile.rst:5
msgid "The Python Profilers"
msgstr "Python 性能分析器"

#: ../../library/profile.rst:7
msgid "**Source code:** :source:`Lib/profile.py` and :source:`Lib/pstats.py`"
msgstr "**源代码：** :source:`Lib/profile.py` 和 :source:`Lib/pstats.py`"

#: ../../library/profile.rst:14
msgid "Introduction to the profilers"
msgstr "性能分析器简介"

#: ../../library/profile.rst:20
msgid ""
":mod:`cProfile` and :mod:`profile` provide :dfn:`deterministic profiling` of"
" Python programs. A :dfn:`profile` is a set of statistics that describes how"
" often and for how long various parts of the program executed. These "
"statistics can be formatted into reports via the :mod:`pstats` module."
msgstr ""
":mod:`cProfile` 和 :mod:`profile` 提供了 Python 程序的 :dfn:`确定性性能分析` 。 "
":dfn:`profile` 是一组统计数据，描述程序的各个部分执行的频率和时间。这些统计数据可以通过 :mod:`pstats` 模块格式化为报表。"

#: ../../library/profile.rst:25
msgid ""
"The Python standard library provides two different implementations of the "
"same profiling interface:"
msgstr "Python 标准库提供了同一分析接口的两种不同实现："

#: ../../library/profile.rst:28
msgid ""
":mod:`cProfile` is recommended for most users; it's a C extension with "
"reasonable overhead that makes it suitable for profiling long-running "
"programs.  Based on :mod:`lsprof`, contributed by Brett Rosen and Ted "
"Czotter."
msgstr ""
"对于大多数用户，建议使用 :mod:`cProfile` ；这是一个 C 扩展插件，因为其合理的运行开销，所以适合于分析长时间运行的程序。该插件基于 "
":mod:`lsprof` ，由 Brett Rosen 和 Ted Chaotter 贡献。"

#: ../../library/profile.rst:33
msgid ""
":mod:`profile`, a pure Python module whose interface is imitated by "
":mod:`cProfile`, but which adds significant overhead to profiled programs. "
"If you're trying to extend the profiler in some way, the task might be "
"easier with this module.  Originally designed and written by Jim Roskind."
msgstr ""
":mod:`profile` 是一个纯 Python 模块（:mod:`cProfile` 就是模拟其接口的 C "
"语言实现），但它会显著增加配置程序的开销。如果你正在尝试以某种方式扩展分析器，则使用此模块可能会更容易完成任务。该模块最初由 Jim Roskind  "
"设计和编写。"

#: ../../library/profile.rst:40
msgid ""
"The profiler modules are designed to provide an execution profile for a "
"given program, not for benchmarking purposes (for that, there is "
":mod:`timeit` for reasonably accurate results).  This particularly applies "
"to benchmarking Python code against C code: the profilers introduce overhead"
" for Python code, but not for C-level functions, and so the C code would "
"seem faster than any Python one."
msgstr ""
"profiler 分析器模块被设计为给指定的程序提供执行概要文件，而不是用于基准测试目的（ :mod:`timeit` "
"才是用于此目标的，它能获得合理准确的结果）。这特别适用于将 Python 代码与 C 代码进行基准测试：分析器为Python 代码引入开销，但不会为 "
"C级别的函数引入开销，因此 C 代码似乎比任何Python 代码都更快。"

#: ../../library/profile.rst:51
msgid "Instant User's Manual"
msgstr "实时用户手册"

#: ../../library/profile.rst:53
msgid ""
"This section is provided for users that \"don't want to read the manual.\" "
"It provides a very brief overview, and allows a user to rapidly perform "
"profiling on an existing application."
msgstr "本节是为 “不想阅读手册” 的用户提供的。它提供了非常简短的概述，并允许用户快速对现有应用程序执行评测。"

#: ../../library/profile.rst:57
msgid "To profile a function that takes a single argument, you can do::"
msgstr "要分析采用单个参数的函数，可以执行以下操作："

#: ../../library/profile.rst:59
msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")')"
msgstr ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")')"

#: ../../library/profile.rst:63
msgid ""
"(Use :mod:`profile` instead of :mod:`cProfile` if the latter is not "
"available on your system.)"
msgstr "（如果 :mod:`cProfile` 在您的系统上不可用，请使用 :mod:`profile` 。）"

#: ../../library/profile.rst:66
msgid ""
"The above action would run :func:`re.compile` and print profile results like"
" the following::"
msgstr "上述操作将运行 :func:`re.compile` 并打印分析结果，如下所示："

#: ../../library/profile.rst:69
msgid ""
"      214 function calls (207 primitive calls) in 0.002 seconds\n"
"\n"
"Ordered by: cumulative time\n"
"\n"
"ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n"
"     1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\n"
"     1    0.000    0.000    0.001    0.001 <string>:1(<module>)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:250(compile)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:289(_compile)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:759(compile)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:937(parse)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:598(_code)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:435(_parse_sub)"
msgstr ""
"      214 function calls (207 primitive calls) in 0.002 seconds\n"
"\n"
"Ordered by: cumulative time\n"
"\n"
"ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n"
"     1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\n"
"     1    0.000    0.000    0.001    0.001 <string>:1(<module>)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:250(compile)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:289(_compile)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:759(compile)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:937(parse)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:598(_code)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:435(_parse_sub)"

#: ../../library/profile.rst:83
msgid ""
"The first line indicates that 214 calls were monitored.  Of those calls, 207"
" were :dfn:`primitive`, meaning that the call was not induced via recursion."
" The next line: ``Ordered by: cumulative time`` indicates the output is "
"sorted by the ``cumtime`` values. The column headings include:"
msgstr ""
"第一行显示有 214 个调用被监控。 在这些调用中，207 为 :dfn:`primitive`，表示这些调用不是通过递归引起的。 下一行: "
"``Ordered by: cumulative time`` 表示输出是按 ``cumtime`` 值排序的。 列标题包括："

#: ../../library/profile.rst:88
msgid "ncalls"
msgstr "ncalls"

#: ../../library/profile.rst:89
msgid "for the number of calls."
msgstr "调用次数"

#: ../../library/profile.rst:91
msgid "tottime"
msgstr "tottime"

#: ../../library/profile.rst:92
msgid ""
"for the total time spent in the given function (and excluding time made in "
"calls to sub-functions)"
msgstr "在指定函数中消耗的总时间（不包括调用子函数的时间）"

#: ../../library/profile.rst:95 ../../library/profile.rst:102
msgid "percall"
msgstr "percall"

#: ../../library/profile.rst:96
msgid "is the quotient of ``tottime`` divided by ``ncalls``"
msgstr "是 ``tottime`` 除以 ``ncalls`` 的商"

#: ../../library/profile.rst:98
msgid "cumtime"
msgstr "cumtime"

#: ../../library/profile.rst:99
msgid ""
"is the cumulative time spent in this and all subfunctions (from invocation "
"till exit). This figure is accurate *even* for recursive functions."
msgstr "指定的函数及其所有子函数（从调用到退出）消耗的累积时间。这个数字对于递归函数来说是准确的。"

#: ../../library/profile.rst:103
msgid "is the quotient of ``cumtime`` divided by primitive calls"
msgstr "是 ``cumtime`` 除以原始调用（次数）的商（即：函数运行一次的平均时间）"

#: ../../library/profile.rst:105
msgid "filename:lineno(function)"
msgstr "filename:lineno(function)"

#: ../../library/profile.rst:106
msgid "provides the respective data of each function"
msgstr "提供相应数据的每个函数"

#: ../../library/profile.rst:108
msgid ""
"When there are two numbers in the first column (for example ``3/1``), it "
"means that the function recursed.  The second value is the number of "
"primitive calls and the former is the total number of calls.  Note that when"
" the function does not recurse, these two values are the same, and only the "
"single figure is printed."
msgstr ""
"如果第一列中有两个数字（例如3/1），则表示函数递归。第二个值是原始调用次数，第一个是调用的总次数。请注意，当函数不递归时，这两个值是相同的，并且只打印单个数字。"

#: ../../library/profile.rst:114
msgid ""
"Instead of printing the output at the end of the profile run, you can save "
"the results to a file by specifying a filename to the :func:`run` function::"
msgstr "profile 运行结束时，打印输出不是必须的。也可以通过为 :func:`run` 函数指定文件名，将结果保存到文件中："

#: ../../library/profile.rst:117
msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")', 'restats')"
msgstr ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")', 'restats')"

#: ../../library/profile.rst:121
msgid ""
"The :class:`pstats.Stats` class reads profile results from a file and "
"formats them in various ways."
msgstr ":class:`pstats.Stats` 类从文件中读取 profile 结果，并以各种方式对其进行格式化。"

#: ../../library/profile.rst:128
msgid ""
"The files :mod:`cProfile` and :mod:`profile` can also be invoked as a script"
" to profile another script.  For example::"
msgstr ":mod:`cProfile` 和 :mod:`profile` 文件也可以作为脚本调用，以分析另一个脚本。例如："

#: ../../library/profile.rst:131
msgid ""
"python -m cProfile [-o output_file] [-s sort_order] (-m module | "
"myscript.py)"
msgstr ""
"python -m cProfile [-o output_file] [-s sort_order] (-m module | "
"myscript.py)"

#: ../../library/profile.rst:135
msgid "Writes the profile results to a file instead of to stdout."
msgstr "将性能分析结果写入到文件而不是标准输出。"

#: ../../library/profile.rst:139
msgid ""
"Specifies one of the :func:`~pstats.Stats.sort_stats` sort values to sort "
"the output by. This only applies when :option:`-o <cProfile -o>` is not "
"supplied."
msgstr ""
"指定某个 :func:`~pstats.Stats.sort_stats` 排序值以对输出进行排序。 这仅适用于未提供 :option:`-o "
"<cProfile -o>` 的情况。"

#: ../../library/profile.rst:145
msgid "Specifies that a module is being profiled instead of a script."
msgstr "指定要分析的是一个模块而不是脚本。"

#: ../../library/profile.rst:147
msgid "Added the ``-m`` option to :mod:`cProfile`."
msgstr ":mod:`cProfile` 添加 ``-m`` 选项"

#: ../../library/profile.rst:150
msgid "Added the ``-m`` option to :mod:`profile`."
msgstr ":mod:`profile` 添加 ``-m`` 选项"

#: ../../library/profile.rst:153
msgid ""
"The :mod:`pstats` module's :class:`~pstats.Stats` class has a variety of "
"methods for manipulating and printing the data saved into a profile results "
"file::"
msgstr ""
":mod:`pstats` 模块的 :class:`~pstats.Stats` 类具有各种方法用来操纵和打印保存到性能分析结果文件的数据。"

#: ../../library/profile.rst:156
msgid ""
"import pstats\n"
"from pstats import SortKey\n"
"p = pstats.Stats('restats')\n"
"p.strip_dirs().sort_stats(-1).print_stats()"
msgstr ""
"import pstats\n"
"from pstats import SortKey\n"
"p = pstats.Stats('restats')\n"
"p.strip_dirs().sort_stats(-1).print_stats()"

#: ../../library/profile.rst:161
msgid ""
"The :meth:`~pstats.Stats.strip_dirs` method removed the extraneous path from"
" all the module names. The :meth:`~pstats.Stats.sort_stats` method sorted "
"all the entries according to the standard module/line/name string that is "
"printed. The :meth:`~pstats.Stats.print_stats` method printed out all the "
"statistics.  You might try the following sort calls::"
msgstr ""
":meth:`~pstats.Stats.strip_dirs` 方法移除了所有模块名称中的多余路径。 "
":meth:`~pstats.Stats.sort_stats` 方法按照打印出来的标准模块/行/名称对所有条目进行排序。 "
":meth:`~pstats.Stats.print_stats` 方法打印出所有的统计数据。 你可以尝试下列排序调用::"

#: ../../library/profile.rst:167
msgid ""
"p.sort_stats(SortKey.NAME)\n"
"p.print_stats()"
msgstr ""
"p.sort_stats(SortKey.NAME)\n"
"p.print_stats()"

#: ../../library/profile.rst:170
msgid ""
"The first call will actually sort the list by function name, and the second "
"call will print out the statistics.  The following are some interesting "
"calls to experiment with::"
msgstr "第一个调用实际上将按函数名称对列表进行排序，而第二个调用将打印出统计数据。 下面是一些可以尝试的有趣调用::"

#: ../../library/profile.rst:174
msgid "p.sort_stats(SortKey.CUMULATIVE).print_stats(10)"
msgstr "p.sort_stats(SortKey.CUMULATIVE).print_stats(10)"

#: ../../library/profile.rst:176
msgid ""
"This sorts the profile by cumulative time in a function, and then only "
"prints the ten most significant lines.  If you want to understand what "
"algorithms are taking time, the above line is what you would use."
msgstr "这将按一个函数中的累计时间对性能分析数据进行排序，然后只打印出最重要的十行。 如果你了解哪些算法在耗费时间，上面这一行就是你应该使用的。"

#: ../../library/profile.rst:180
msgid ""
"If you were looking to see what functions were looping a lot, and taking a "
"lot of time, you would do::"
msgstr "如果你想要看看哪些函数的循环次数多，且耗费时间长，你应当这样做::"

#: ../../library/profile.rst:183
msgid "p.sort_stats(SortKey.TIME).print_stats(10)"
msgstr "p.sort_stats(SortKey.TIME).print_stats(10)"

#: ../../library/profile.rst:185
msgid ""
"to sort according to time spent within each function, and then print the "
"statistics for the top ten functions."
msgstr "以按照每个函数耗费的时间进行排序，然后打印前十个函数的统计数据。"

#: ../../library/profile.rst:188
msgid "You might also try::"
msgstr "你也可以尝试："

#: ../../library/profile.rst:190
msgid "p.sort_stats(SortKey.FILENAME).print_stats('__init__')"
msgstr "p.sort_stats(SortKey.FILENAME).print_stats('__init__')"

#: ../../library/profile.rst:192
msgid ""
"This will sort all the statistics by file name, and then print out "
"statistics for only the class init methods (since they are spelled with "
"``__init__`` in them).  As one final example, you could try::"
msgstr ""
"这将按照文件名对所有统计数据进行排序，然后只打印出类初始化方法的统计数据 (因为它们的名称中都有 ``__init__``)。 "
"作为最后一个例子，你可以尝试::"

#: ../../library/profile.rst:196
msgid "p.sort_stats(SortKey.TIME, SortKey.CUMULATIVE).print_stats(.5, 'init')"
msgstr ""
"p.sort_stats(SortKey.TIME, SortKey.CUMULATIVE).print_stats(.5, 'init')"

#: ../../library/profile.rst:198
msgid ""
"This line sorts statistics with a primary key of time, and a secondary key "
"of cumulative time, and then prints out some of the statistics. To be "
"specific, the list is first culled down to 50% (re: ``.5``) of its original "
"size, then only lines containing ``init`` are maintained, and that sub-sub-"
"list is printed."
msgstr ""
"这一行以时间为主键，并以累计时间为次键进行排序，然后打印出部分统计数据。 具体来说，该列表首先被缩减至原始大小的 50% (即: "
"``.5``)，然后只保留包含 ``init`` 的行，并打印该子列表。"

#: ../../library/profile.rst:203
msgid ""
"If you wondered what functions called the above functions, you could now "
"(``p`` is still sorted according to the last criteria) do::"
msgstr "如果你想知道有哪些函数调用了上述函数，你现在就可以做 (``p`` 仍然会按照最后一个标准进行排序)::"

#: ../../library/profile.rst:206
msgid "p.print_callers(.5, 'init')"
msgstr "p.print_callers(.5, 'init')"

#: ../../library/profile.rst:208
msgid "and you would get a list of callers for each of the listed functions."
msgstr "这样你将得到每个被列出的函数的调用方列表。"

#: ../../library/profile.rst:210
msgid ""
"If you want more functionality, you're going to have to read the manual, or "
"guess what the following functions do::"
msgstr "如果你想要更多的功能，你就必须阅读手册，或者自行猜测下列函数的作用::"

#: ../../library/profile.rst:213
msgid ""
"p.print_callees()\n"
"p.add('restats')"
msgstr ""
"p.print_callees()\n"
"p.add('restats')"

#: ../../library/profile.rst:216
msgid ""
"Invoked as a script, the :mod:`pstats` module is a statistics browser for "
"reading and examining profile dumps.  It has a simple line-oriented "
"interface (implemented using :mod:`cmd`) and interactive help."
msgstr ""
"作为脚本被唤起，:mod:`pstats` 模块是一个用于读取和性能分析转储文件的统计数据浏览器。 它有一个简单的面向行的界面（使用 "
":mod:`cmd` 实现）和交互式的帮助。"

#: ../../library/profile.rst:221
msgid ":mod:`profile` and :mod:`cProfile` Module Reference"
msgstr ":mod:`profile` 和 :mod:`cProfile` 模块参考"

#: ../../library/profile.rst:227
msgid ""
"Both the :mod:`profile` and :mod:`cProfile` modules provide the following "
"functions:"
msgstr ":mod:`profile` 和 :mod:`cProfile` 模块都提供下列函数："

#: ../../library/profile.rst:232
msgid ""
"This function takes a single argument that can be passed to the :func:`exec`"
" function, and an optional file name.  In all cases this routine executes::"
msgstr "此函数接受一个可被传递给 :func:`exec` 函数的单独参数，以及一个可选的文件名。 在所有情况下这个例程都会执行::"

#: ../../library/profile.rst:235
msgid "exec(command, __main__.__dict__, __main__.__dict__)"
msgstr "exec(command, __main__.__dict__, __main__.__dict__)"

#: ../../library/profile.rst:237
msgid ""
"and gathers profiling statistics from the execution. If no file name is "
"present, then this function automatically creates a :class:`~pstats.Stats` "
"instance and prints a simple profiling report. If the sort value is "
"specified, it is passed to this :class:`~pstats.Stats` instance to control "
"how the results are sorted."
msgstr ""
"并收集执行过程中的性能分析统计数据。 如果未提供文件名，则此函数会自动创建一个 :class:`~pstats.Stats` "
"实例并打印一个简单的性能分析报告。 如果指定了 sort 值，则它会被传递给这个 :class:`~pstats.Stats` "
"实例以控制结果的排序方式。"

#: ../../library/profile.rst:245
msgid ""
"This function is similar to :func:`run`, with added arguments to supply the "
"globals and locals dictionaries for the *command* string. This routine "
"executes::"
msgstr "此函数类似于 :func:`run`，带有为 *command* 字符串提供全局和局部字典的附加参数。 这个例程会执行::"

#: ../../library/profile.rst:249
msgid "exec(command, globals, locals)"
msgstr "exec(command, globals, locals)"

#: ../../library/profile.rst:251
msgid "and gathers profiling statistics as in the :func:`run` function above."
msgstr "并像在上述的 :func:`run` 函数中一样收集性能分析数据。"

#: ../../library/profile.rst:255
msgid ""
"This class is normally only used if more precise control over profiling is "
"needed than what the :func:`cProfile.run` function provides."
msgstr "这个类通常只在需要比 :func:`cProfile.run` 函数所能提供的更精确的性能分析控制时被使用。"

#: ../../library/profile.rst:258
msgid ""
"A custom timer can be supplied for measuring how long code takes to run via "
"the *timer* argument. This must be a function that returns a single number "
"representing the current time. If the number is an integer, the *timeunit* "
"specifies a multiplier that specifies the duration of each unit of time. For"
" example, if the timer returns times measured in thousands of seconds, the "
"time unit would be ``.001``."
msgstr ""
"可以通过 *timer* 参数提供一个自定义计时器来测量代码运行花费了多长时间。 它必须是一个返回代表当前时间的单个数字的函数。 如果该数字为整数，则 "
"*timeunit* 指定一个表示每个时间单位持续时间的乘数。 例如，如果定时器返回以千秒为计量单位的时间值，则时间单位将为 ``.001``。"

#: ../../library/profile.rst:265
msgid ""
"Directly using the :class:`Profile` class allows formatting profile results "
"without writing the profile data to a file::"
msgstr "直接使用 :class:`Profile` 类将允许格式化性能分析结果而无需将性能分析数据写入到文件::"

#: ../../library/profile.rst:268
msgid ""
"import cProfile, pstats, io\n"
"from pstats import SortKey\n"
"pr = cProfile.Profile()\n"
"pr.enable()\n"
"# ... do something ...\n"
"pr.disable()\n"
"s = io.StringIO()\n"
"sortby = SortKey.CUMULATIVE\n"
"ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n"
"ps.print_stats()\n"
"print(s.getvalue())"
msgstr ""
"import cProfile, pstats, io\n"
"from pstats import SortKey\n"
"pr = cProfile.Profile()\n"
"pr.enable()\n"
"# 做些事情……\n"
"pr.disable()\n"
"s = io.StringIO()\n"
"sortby = SortKey.CUMULATIVE\n"
"ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n"
"ps.print_stats()\n"
"print(s.getvalue())"

#: ../../library/profile.rst:280
msgid ""
"The :class:`Profile` class can also be used as a context manager (supported "
"only in :mod:`cProfile` module. see :ref:`typecontextmanager`)::"
msgstr ""
":class:`Profile` 类也可作为上下文管理器使用 (仅在 :mod:`cProfile` 模块中支持。 参见 "
":ref:`typecontextmanager`)::"

#: ../../library/profile.rst:283
msgid ""
"import cProfile\n"
"\n"
"with cProfile.Profile() as pr:\n"
"    # ... do something ...\n"
"\n"
"    pr.print_stats()"
msgstr ""
"import cProfile\n"
"\n"
"with cProfile.Profile() as pr:\n"
"    # 做些事情……\n"
"\n"
"    pr.print_stats()"

#: ../../library/profile.rst:290
msgid "Added context manager support."
msgstr "添加了上下文管理器支持。"

#: ../../library/profile.rst:295
msgid "Start collecting profiling data. Only in :mod:`cProfile`."
msgstr "开始收集分析数据。仅在 :mod:`cProfile` 可用。"

#: ../../library/profile.rst:299
msgid "Stop collecting profiling data. Only in :mod:`cProfile`."
msgstr "停止收集分析数据。仅在 :mod:`cProfile` 可用。"

#: ../../library/profile.rst:303
msgid ""
"Stop collecting profiling data and record the results internally as the "
"current profile."
msgstr "停止收集分析数据，并在内部将结果记录为当前 profile。"

#: ../../library/profile.rst:308
msgid ""
"Create a :class:`~pstats.Stats` object based on the current profile and "
"print the results to stdout."
msgstr "根据当前性能分析数据创建一个 :class:`~pstats.Stats` 对象并将结果打印到 stdout。"

#: ../../library/profile.rst:313
msgid "Write the results of the current profile to *filename*."
msgstr "将当前profile 的结果写入 *filename* 。"

#: ../../library/profile.rst:317
msgid "Profile the cmd via :func:`exec`."
msgstr "通过 :func:`exec` 对该命令进行性能分析。"

#: ../../library/profile.rst:321
msgid ""
"Profile the cmd via :func:`exec` with the specified global and local "
"environment."
msgstr "通过 :func:`exec` 并附带指定的全局和局部环境对该命令进行性能分析。"

#: ../../library/profile.rst:326
msgid "Profile ``func(*args, **kwargs)``"
msgstr "对 ``func(*args, **kwargs)`` 进行性能分析"

#: ../../library/profile.rst:328
msgid ""
"Note that profiling will only work if the called command/function actually "
"returns.  If the interpreter is terminated (e.g. via a :func:`sys.exit` call"
" during the called command/function execution) no profiling results will be "
"printed."
msgstr ""
"请注意性能分析只有在被调用的命令/函数确实能返回时才可用。 如果解释器被终结（例如在被调用的命令/函数执行期间通过 :func:`sys.exit` "
"调用）则将不会打印性能分析结果。"

#: ../../library/profile.rst:336
msgid "The :class:`Stats` Class"
msgstr ":class:`Stats` 类"

#: ../../library/profile.rst:338
msgid ""
"Analysis of the profiler data is done using the :class:`~pstats.Stats` "
"class."
msgstr "性能数据的分析是使用 :class:`~pstats.Stats` 类来完成的。"

#: ../../library/profile.rst:345
msgid ""
"This class constructor creates an instance of a \"statistics object\" from a"
" *filename* (or list of filenames) or from a :class:`Profile` instance. "
"Output will be printed to the stream specified by *stream*."
msgstr ""
"这个类构造器会基于 *filename* (或文件名列表) 或者 :class:`Profile` 实例创建一个“统计对象”。 输出将被打印到由 "
"*stream* 所指定的流。"

#: ../../library/profile.rst:349
msgid ""
"The file selected by the above constructor must have been created by the "
"corresponding version of :mod:`profile` or :mod:`cProfile`.  To be specific,"
" there is *no* file compatibility guaranteed with future versions of this "
"profiler, and there is no compatibility with files produced by other "
"profilers, or the same profiler run on a different operating system.  If "
"several files are provided, all the statistics for identical functions will "
"be coalesced, so that an overall view of several processes can be considered"
" in a single report.  If additional files need to be combined with data in "
"an existing :class:`~pstats.Stats` object, the :meth:`~pstats.Stats.add` "
"method can be used."
msgstr ""
"上述构造器所选择的文件必须由相应版本的 :mod:`profile` 或 :mod:`cProfile` 来创建。 具体来说，*不会* "
"保证文件与此性能分析器的未来版本兼容，也不会保证与其他性能分析器，或运行于不同操作系统的同一性能分析器所产生的文件兼容。 "
"如果提供了几个文件，则相同函数的所有统计数据将被聚合在一起，这样就可以在单个报告中同时考虑几个进程的总体情况。 如果额外的文件需要与现有 "
":class:`~pstats.Stats` 对象中的数据相结合，则可以使用 :meth:`~pstats.Stats.add` 方法。"

#: ../../library/profile.rst:360
msgid ""
"Instead of reading the profile data from a file, a :class:`cProfile.Profile`"
" or :class:`profile.Profile` object can be used as the profile data source."
msgstr ""
"作为从一个文件读取性能分析数据的替代，可以使用 :class:`cProfile.Profile` 或 :class:`profile.Profile`"
" 对象作为性能分析数据源。"

#: ../../library/profile.rst:363
msgid ":class:`Stats` objects have the following methods:"
msgstr ":class:`Stats` 对象有以下方法:"

#: ../../library/profile.rst:367
msgid ""
"This method for the :class:`Stats` class removes all leading path "
"information from file names.  It is very useful in reducing the size of the "
"printout to fit within (close to) 80 columns.  This method modifies the "
"object, and the stripped information is lost.  After performing a strip "
"operation, the object is considered to have its entries in a \"random\" "
"order, as it was just after object initialization and loading. If "
":meth:`~pstats.Stats.strip_dirs` causes two function names to be "
"indistinguishable (they are on the same line of the same filename, and have "
"the same function name), then the statistics for these two entries are "
"accumulated into a single entry."
msgstr ""
"这个用于 :class:`Stats` 类的方法会从文件名中去除所有前导路径信息。 它对于减少打印输出的大小以适应（接近） 80 列限制。 "
"这个方法会修改对象，被去除的信息将会丢失。 在执行去除操作后，可以认为对象拥有的条目将使用“随机”顺序，就像它刚在对象初始化并加载之后一样。 如果 "
":meth:`~pstats.Stats.strip_dirs` "
"导致两个函数名变得无法区分（它们位于相同文件名的相同行，并且具有相同的函数名），那么这两个条目的统计数据将被累积到单个条目中。"

#: ../../library/profile.rst:381
msgid ""
"This method of the :class:`Stats` class accumulates additional profiling "
"information into the current profiling object.  Its arguments should refer "
"to filenames created by the corresponding version of :func:`profile.run` or "
":func:`cProfile.run`. Statistics for identically named (re: file, line, "
"name) functions are automatically accumulated into single function "
"statistics."
msgstr ""
":class:`Stats` 类的这个方法会将额外的性能分析信息累积到当前的性能分析对象中。 它的参数应当指向由相应版本的 "
":func:`profile.run` 或 :func:`cProfile.run` 所创建的文件名。 相同名称（包括 file, line, "
"name）函数的统计信息会自动累积到单个函数的统计信息。"

#: ../../library/profile.rst:391
msgid ""
"Save the data loaded into the :class:`Stats` object to a file named "
"*filename*.  The file is created if it does not exist, and is overwritten if"
" it already exists.  This is equivalent to the method of the same name on "
"the :class:`profile.Profile` and :class:`cProfile.Profile` classes."
msgstr ""
"将加载至 :class:`Stats` 对象内的数据保存到名为 *filename* 的文件。 该文件如果不存在则将被创建，如果已存在则将被覆盖。 "
"这等价于 :class:`profile.Profile` 和 :class:`cProfile.Profile` 类上的同名方法。"

#: ../../library/profile.rst:399
msgid ""
"This method modifies the :class:`Stats` object by sorting it according to "
"the supplied criteria.  The argument can be either a string or a SortKey "
"enum identifying the basis of a sort (example: ``'time'``, ``'name'``, "
"``SortKey.TIME`` or ``SortKey.NAME``). The SortKey enums argument have "
"advantage over the string argument in that it is more robust and less error "
"prone."
msgstr ""
"此方法通过根据所提供的准则修改 :class:`Stats` 对象的排序。 其参数可以是一个字符串或标识排序准则的 SortKey 枚举 (例如: "
"``'time'``, ``'name'``, ``SortKey.TIME`` 或 ``SortKey.NAME``)。 SortKey "
"枚举参数优于字符串参数因为它更为健壮且更不容易出错。"

#: ../../library/profile.rst:406
msgid ""
"When more than one key is provided, then additional keys are used as "
"secondary criteria when there is equality in all keys selected before them."
"  For example, ``sort_stats(SortKey.NAME, SortKey.FILE)`` will sort all the "
"entries according to their function name, and resolve all ties (identical "
"function names) by sorting by file name."
msgstr ""
"当提供一个以上的键时，额外的键将在之前选择的所有键的值相等时被用作次级准则。 例如，``sort_stats(SortKey.NAME, "
"SortKey.FILE)`` 将根据其函数名对所有条目排序，并通过按文件名排序来处理所有平局（即函数名相同）。"

#: ../../library/profile.rst:412
msgid ""
"For the string argument, abbreviations can be used for any key names, as "
"long as the abbreviation is unambiguous."
msgstr "对于字符串参数，可以对任何键名使用缩写形式，只要缩写是无歧义的。"

#: ../../library/profile.rst:415
msgid "The following are the valid string and SortKey:"
msgstr "以下是有效的字符串和 SortKey:"

#: ../../library/profile.rst:418
msgid "Valid String Arg"
msgstr "有效字符串参数"

#: ../../library/profile.rst:418
msgid "Valid enum Arg"
msgstr "有效枚举参数"

#: ../../library/profile.rst:418
msgid "Meaning"
msgstr "含意"

#: ../../library/profile.rst:420
msgid "``'calls'``"
msgstr "``'calls'``"

#: ../../library/profile.rst:420
msgid "SortKey.CALLS"
msgstr "SortKey.CALLS"

#: ../../library/profile.rst:420 ../../library/profile.rst:432
msgid "call count"
msgstr "调用次数"

#: ../../library/profile.rst:422
msgid "``'cumulative'``"
msgstr "``'cumulative'``"

#: ../../library/profile.rst:422
msgid "SortKey.CUMULATIVE"
msgstr "SortKey.CUMULATIVE"

#: ../../library/profile.rst:422 ../../library/profile.rst:424
msgid "cumulative time"
msgstr "累积时间"

#: ../../library/profile.rst:424
msgid "``'cumtime'``"
msgstr "``'cumtime'``"

#: ../../library/profile.rst:424 ../../library/profile.rst:426
#: ../../library/profile.rst:430 ../../library/profile.rst:432
#: ../../library/profile.rst:446
msgid "N/A"
msgstr "N/A"

#: ../../library/profile.rst:426
msgid "``'file'``"
msgstr "``'file'``"

#: ../../library/profile.rst:426 ../../library/profile.rst:428
#: ../../library/profile.rst:430
msgid "file name"
msgstr "文件名"

#: ../../library/profile.rst:428
msgid "``'filename'``"
msgstr "``'filename'``"

#: ../../library/profile.rst:428
msgid "SortKey.FILENAME"
msgstr "SortKey.FILENAME"

#: ../../library/profile.rst:430
msgid "``'module'``"
msgstr "``'module'``"

#: ../../library/profile.rst:432
msgid "``'ncalls'``"
msgstr "``'ncalls'``"

#: ../../library/profile.rst:434
msgid "``'pcalls'``"
msgstr "``'pcalls'``"

#: ../../library/profile.rst:434
msgid "SortKey.PCALLS"
msgstr "SortKey.PCALLS"

#: ../../library/profile.rst:434
msgid "primitive call count"
msgstr "原始调用计数"

#: ../../library/profile.rst:436
msgid "``'line'``"
msgstr "``'line'``"

#: ../../library/profile.rst:436
msgid "SortKey.LINE"
msgstr "SortKey.LINE"

#: ../../library/profile.rst:436
msgid "line number"
msgstr "行号"

#: ../../library/profile.rst:438
msgid "``'name'``"
msgstr "``'name'``"

#: ../../library/profile.rst:438
msgid "SortKey.NAME"
msgstr "SortKey.NAME"

#: ../../library/profile.rst:438
msgid "function name"
msgstr "函数名称"

#: ../../library/profile.rst:440
msgid "``'nfl'``"
msgstr "``'nfl'``"

#: ../../library/profile.rst:440
msgid "SortKey.NFL"
msgstr "SortKey.NFL"

#: ../../library/profile.rst:440
msgid "name/file/line"
msgstr "名称/文件/行"

#: ../../library/profile.rst:442
msgid "``'stdname'``"
msgstr "``'stdname'``"

#: ../../library/profile.rst:442
msgid "SortKey.STDNAME"
msgstr "SortKey.STDNAME"

#: ../../library/profile.rst:442
msgid "standard name"
msgstr "标准名称"

#: ../../library/profile.rst:444
msgid "``'time'``"
msgstr "``'time'``"

#: ../../library/profile.rst:444
msgid "SortKey.TIME"
msgstr "SortKey.TIME"

#: ../../library/profile.rst:444 ../../library/profile.rst:446
msgid "internal time"
msgstr "内部时间"

#: ../../library/profile.rst:446
msgid "``'tottime'``"
msgstr "``'tottime'``"

#: ../../library/profile.rst:449
msgid ""
"Note that all sorts on statistics are in descending order (placing most time"
" consuming items first), where as name, file, and line number searches are "
"in ascending order (alphabetical). The subtle distinction between "
"``SortKey.NFL`` and ``SortKey.STDNAME`` is that the standard name is a sort "
"of the name as printed, which means that the embedded line numbers get "
"compared in an odd way.  For example, lines 3, 20, and 40 would (if the file"
" names were the same) appear in the string order 20, 3 and 40. In contrast, "
"``SortKey.NFL`` does a numeric compare of the line numbers. In fact, "
"``sort_stats(SortKey.NFL)`` is the same as ``sort_stats(SortKey.NAME, "
"SortKey.FILENAME, SortKey.LINE)``."
msgstr ""
"请注意对统计信息的所有排序都是降序的（将最耗时的条目放在最前面），其中名称、文件和行号搜索则是升序的（字母顺序）。 ``SortKey.NFL`` 和 "
"``SortKey.STDNAME`` 之间的细微区别在于标准名称是按打印形式来排序名称的，这意味着嵌入的行号将以一种怪异的方式进行比较。 例如，第 "
"3, 20 和 40 行将会按字符串顺序 20, 3 和 40 显示（如果文件名相同的话）。 相反地，``SortKey.NFL`` "
"则会对行号进行数值比较。 实际上，``sort_stats(SortKey.NFL)`` 就等同于 ``sort_stats(SortKey.NAME,"
" SortKey.FILENAME, SortKey.LINE)``。"

#: ../../library/profile.rst:460
msgid ""
"For backward-compatibility reasons, the numeric arguments ``-1``, ``0``, "
"``1``, and ``2`` are permitted.  They are interpreted as ``'stdname'``, "
"``'calls'``, ``'time'``, and ``'cumulative'`` respectively.  If this old "
"style format (numeric) is used, only one sort key (the numeric key) will be "
"used, and additional arguments will be silently ignored."
msgstr ""
"出于向下兼容的理由，数值参数 ``-1``, ``0``, ``1`` 和 ``2`` 也是被允许的。 它们将被分别解读为 ``'stdname'``,"
" ``'calls'``, ``'time'`` 和 ``'cumulative'``。 "
"如果使用这种老旧格式（数值），则将只使用一个排序键（数字键），额外的参数将被静默地忽略。"

#: ../../library/profile.rst:468
msgid "Added the SortKey enum."
msgstr "增加了 SortKey 枚举。"

#: ../../library/profile.rst:473
msgid ""
"This method for the :class:`Stats` class reverses the ordering of the basic "
"list within the object.  Note that by default ascending vs descending order "
"is properly selected based on the sort key of choice."
msgstr ""
"这个用于 :class:`Stats` 类的方法将会反转对象内基本列表的顺序。 请注意在默认情况下升序和降序排列将基于所选定的排序键来进行适当的选择。"

#: ../../library/profile.rst:483
msgid ""
"This method for the :class:`Stats` class prints out a report as described in"
" the :func:`profile.run` definition."
msgstr "这个用于 :class:`Stats` 类的方法将打印出在 :func:`profile.run` 定义中描述的报告。"

#: ../../library/profile.rst:486
msgid ""
"The order of the printing is based on the last "
":meth:`~pstats.Stats.sort_stats` operation done on the object (subject to "
"caveats in :meth:`~pstats.Stats.add` and :meth:`~pstats.Stats.strip_dirs`)."
msgstr ""
"打印的顺序是基于在对象上执行的最后一次 :meth:`~pstats.Stats.sort_stats` 操作（需要注意 "
":meth:`~pstats.Stats.add` 和 :meth:`~pstats.Stats.strip_dirs` 规则）。"

#: ../../library/profile.rst:491
msgid ""
"The arguments provided (if any) can be used to limit the list down to the "
"significant entries.  Initially, the list is taken to be the complete set of"
" profiled functions.  Each restriction is either an integer (to select a "
"count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to "
"select a percentage of lines), or a string that will interpreted as a "
"regular expression (to pattern match the standard name that is printed). If "
"several restrictions are provided, then they are applied sequentially. For "
"example::"
msgstr ""
"所提供的参数（如果存在）可被用来将列表限制为重要的条目。 在初始状态下，列表将为加入性能分析的函数的完整集合。 "
"每条限制可以是一个整数（用来选择行数），或是一个 0.0 至 1.0 "
"范围内左开右闭的十进制小数（用来选择行数百分比），或是一个将被解读为正则表达式的字符串（用来匹配要打印的标准名称的模式）。 "
"如果提供了多条限制，则它们将逐个被应用。 例如::"

#: ../../library/profile.rst:500
msgid "print_stats(.1, 'foo:')"
msgstr "print_stats(.1, 'foo:')"

#: ../../library/profile.rst:502
msgid ""
"would first limit the printing to first 10% of list, and then only print "
"functions that were part of filename :file:`.\\*foo:`.  In contrast, the "
"command::"
msgstr "将首先限制为打印列表的前 10%，然后再限制为仅打印在名为 :file:`.\\*foo:` 的文件内的函数。 作为对比，以下命令::"

#: ../../library/profile.rst:506
msgid "print_stats('foo:', .1)"
msgstr "print_stats('foo:', .1)"

#: ../../library/profile.rst:508
msgid ""
"would limit the list to all functions having file names :file:`.\\*foo:`, "
"and then proceed to only print the first 10% of them."
msgstr "将列表限制为名为 :file:`.\\*foo:` 的文件内的所有函数，然后再限制为仅打印它们当中的前 10%。"

#: ../../library/profile.rst:514
msgid ""
"This method for the :class:`Stats` class prints a list of all functions that"
" called each function in the profiled database.  The ordering is identical "
"to that provided by :meth:`~pstats.Stats.print_stats`, and the definition of"
" the restricting argument is also identical.  Each caller is reported on its"
" own line.  The format differs slightly depending on the profiler that "
"produced the stats:"
msgstr ""
"这个用于 :class:`Stats` 类的方法将打印调用了加入性能分析数据库的每个函数的所有函数的列表。 打印顺序与 "
":meth:`~pstats.Stats.print_stats` 所提供的相同，受限参数的定义也是相同的。 每个调用方将在单独的行中报告。 "
"具体格式根据产生统计数据的性能分析器的不同而有所差异。"

#: ../../library/profile.rst:521
msgid ""
"With :mod:`profile`, a number is shown in parentheses after each caller to "
"show how many times this specific call was made.  For convenience, a second "
"non-parenthesized number repeats the cumulative time spent in the function "
"at the right."
msgstr ""
"使用 :mod:`profile` 时，将在每个调用方之后的圆括号内显示一个数字来指明相应的调用执行了多少次。 "
"为了方便起见，右侧还有第二个不带圆括号的数字来重复显示该函数累计耗费的时间。"

#: ../../library/profile.rst:526
msgid ""
"With :mod:`cProfile`, each caller is preceded by three numbers: the number "
"of times this specific call was made, and the total and cumulative times "
"spent in the current function while it was invoked by this specific caller."
msgstr ""
"使用 :mod:`cProfile` 时，每个调用方前面将有三个数字：这个调用的执行次数，以及当前函数在被这个调用方唤起期间共计和累计耗费的时间。"

#: ../../library/profile.rst:534
msgid ""
"This method for the :class:`Stats` class prints a list of all function that "
"were called by the indicated function.  Aside from this reversal of "
"direction of calls (re: called vs was called by), the arguments and ordering"
" are identical to the :meth:`~pstats.Stats.print_callers` method."
msgstr ""
"这个用于 :class:`Stats` 类的方法将打印被指定的函数所调用的所有函数的列表。 "
"除了调用方向是逆序的（对应：被调用和被调用方），其参数和顺序与 :meth:`~pstats.Stats.print_callers` 方法相同。"

#: ../../library/profile.rst:542
msgid ""
"This method returns an instance of StatsProfile, which contains a mapping of"
" function names to instances of FunctionProfile. Each FunctionProfile "
"instance holds information related to the function's profile such as how "
"long the function took to run, how many times it was called, etc..."
msgstr ""
"此方法返回一个 StatsProfile 的实例，它包含从函数名称到 FunctionProfile 实例的映射。 每个 FunctionProfile"
" 实例保存了相应函数性能分析的有关信息如函数运行耗费了多长时间，它被调用了多少次等等……"

#: ../../library/profile.rst:547
msgid ""
"Added the following dataclasses: StatsProfile, FunctionProfile. Added the "
"following function: get_stats_profile."
msgstr "添加了以下数据类: StatsProfile, FunctionProfile。 添加了以下函数: get_stats_profile。"

#: ../../library/profile.rst:554
msgid "What Is Deterministic Profiling?"
msgstr "什么是确定性性能分析？"

#: ../../library/profile.rst:556
msgid ""
":dfn:`Deterministic profiling` is meant to reflect the fact that all "
"*function call*, *function return*, and *exception* events are monitored, "
"and precise timings are made for the intervals between these events (during "
"which time the user's code is executing).  In contrast, :dfn:`statistical "
"profiling` (which is not done by this module) randomly samples the effective"
" instruction pointer, and deduces where time is being spent.  The latter "
"technique traditionally involves less overhead (as the code does not need to"
" be instrumented), but provides only relative indications of where time is "
"being spent."
msgstr ""
":dfn:`确定性性能分析` 旨在反映这样一个事实：即所有 *函数调用* 、 *函数返回* 和 *异常* "
"事件都被监控，并且对这些事件之间的间隔（在此期间用户的代码正在执行）进行精确计时。相反，统计分析（不是由该模块完成）随机采样有效指令指针，并推断时间花费在哪里。后一种技术传统上涉及较少的开销（因为代码不需要检测），但只提供了时间花在哪里的相对指示。"

#: ../../library/profile.rst:565
msgid ""
"In Python, since there is an interpreter active during execution, the "
"presence of instrumented code is not required in order to do deterministic "
"profiling. Python automatically provides a :dfn:`hook` (optional callback) "
"for each event. In addition, the interpreted nature of Python tends to add "
"so much overhead to execution, that deterministic profiling tends to only "
"add small processing overhead in typical applications.  The result is that "
"deterministic profiling is not that expensive, yet provides extensive run "
"time statistics about the execution of a Python program."
msgstr ""
"在Python中，由于在执行过程中总有一个活动的解释器，因此执行确定性评测不需要插入指令的代码。Python 自动为每个事件提供一个 :dfn:`钩子`"
" （可选回调）。此外，Python "
"的解释特性往往会给执行增加太多开销，以至于在典型的应用程序中，确定性分析往往只会增加很小的处理开销。结果是，确定性分析并没有那么代价高昂，但是它提供了有关"
" Python 程序执行的大量运行时统计信息。"

#: ../../library/profile.rst:574
msgid ""
"Call count statistics can be used to identify bugs in code (surprising "
"counts), and to identify possible inline-expansion points (high call "
"counts).  Internal time statistics can be used to identify \"hot loops\" "
"that should be carefully optimized.  Cumulative time statistics should be "
"used to identify high level errors in the selection of algorithms.  Note "
"that the unusual handling of cumulative times in this profiler allows "
"statistics for recursive implementations of algorithms to be directly "
"compared to iterative implementations."
msgstr ""
"调用计数统计信息可用于识别代码中的错误（意外计数），并识别可能的内联扩展点（高频调用）。内部时间统计可用于识别应仔细优化的 \"热循环\" "
"。累积时间统计可用于识别算法选择上的高级别错误。请注意，该分析器中对累积时间的异常处理，允许直接比较算法的递归实现与迭代实现的统计信息。"

#: ../../library/profile.rst:587
msgid "Limitations"
msgstr "局限性"

#: ../../library/profile.rst:589
msgid ""
"One limitation has to do with accuracy of timing information. There is a "
"fundamental problem with deterministic profilers involving accuracy.  The "
"most obvious restriction is that the underlying \"clock\" is only ticking at"
" a rate (typically) of about .001 seconds.  Hence no measurements will be "
"more accurate than the underlying clock.  If enough measurements are taken, "
"then the \"error\" will tend to average out. Unfortunately, removing this "
"first error induces a second source of error."
msgstr ""
"一个限制是关于时间信息的准确性。确定性性能分析存在一个涉及精度的基本问题。最明显的限制是，底层的 \"时钟\" "
"周期大约为0.001秒（通常）。因此，没有什么测量会比底层时钟更精确。如果进行了足够的测量，那么 \"误差\" "
"将趋于平均。不幸的是，删除第一个错误会导致第二个错误来源。"

#: ../../library/profile.rst:597
msgid ""
"The second problem is that it \"takes a while\" from when an event is "
"dispatched until the profiler's call to get the time actually *gets* the "
"state of the clock.  Similarly, there is a certain lag when exiting the "
"profiler event handler from the time that the clock's value was obtained "
"(and then squirreled away), until the user's code is once again executing.  "
"As a result, functions that are called many times, or call many functions, "
"will typically accumulate this error. The error that accumulates in this "
"fashion is typically less than the accuracy of the clock (less than one "
"clock tick), but it *can* accumulate and become very significant."
msgstr ""
"第二个问题是，从调度事件到分析器调用获取时间函数实际 *获取* 时钟状态，这需要 \"一段时间\" "
"。类似地，从获取时钟值（然后保存）开始，直到再次执行用户代码为止，退出分析器事件句柄时也存在一定的延迟。因此，多次调用单个函数或调用多个函数通常会累积此错误。尽管这种方式的误差通常小于时钟的精度（小于一个时钟周期），但它"
" *可以* 累积并变得非常可观。"

#: ../../library/profile.rst:607
msgid ""
"The problem is more important with :mod:`profile` than with the lower-"
"overhead :mod:`cProfile`.  For this reason, :mod:`profile` provides a means "
"of calibrating itself for a given platform so that this error can be "
"probabilistically (on the average) removed. After the profiler is "
"calibrated, it will be more accurate (in a least square sense), but it will "
"sometimes produce negative numbers (when call counts are exceptionally low, "
"and the gods of probability work against you :-). )  Do *not* be alarmed by "
"negative numbers in the profile.  They should *only* appear if you have "
"calibrated your profiler, and the results are actually better than without "
"calibration."
msgstr ""
"与开销较低的 :mod:`cProfile` 相比， :mod:`profile` 的问题更为严重。出于这个原因， :mod:`profile` "
"提供了一种针对指定平台的自我校准方法，以便可以在很大程度上（平均地）消除此误差。  "
"校准后，结果将更准确（在最小二乘意义上），但它有时会产生负数（当调用计数异常低，且概率之神对您不利时：-）。因此 *不要* "
"对产生的负数感到惊慌。它们应该只在你手工校准分析器的情况下才会出现，实际上结果比没有校准的情况要好。"

#: ../../library/profile.rst:621
msgid "Calibration"
msgstr "准确估量"

#: ../../library/profile.rst:623
msgid ""
"The profiler of the :mod:`profile` module subtracts a constant from each "
"event handling time to compensate for the overhead of calling the time "
"function, and socking away the results.  By default, the constant is 0. The "
"following procedure can be used to obtain a better constant for a given "
"platform (see :ref:`profile-limitations`). ::"
msgstr ""
":mod:`profile` 模块的 profiler 会从每个事件处理时间中减去一个常量，以补偿调用 time "
"函数和存储结果的开销。默认情况下，常数为0。对于特定的平台，可用以下程序获得更好修正常数（ :ref:`profile-limitations` ）。"

#: ../../library/profile.rst:629
msgid ""
"import profile\n"
"pr = profile.Profile()\n"
"for i in range(5):\n"
"    print(pr.calibrate(10000))"
msgstr ""
"import profile\n"
"pr = profile.Profile()\n"
"for i in range(5):\n"
"    print(pr.calibrate(10000))"

#: ../../library/profile.rst:634
msgid ""
"The method executes the number of Python calls given by the argument, "
"directly and again under the profiler, measuring the time for both. It then "
"computes the hidden overhead per profiler event, and returns that as a "
"float.  For example, on a 1.8Ghz Intel Core i5 running macOS, and using "
"Python's time.process_time() as the timer, the magical number is about "
"4.04e-6."
msgstr ""
"此方法将执行由参数所给定次数的 Python 调用，在性能分析器之下直接和再次地执行，并对两次执行计时。 "
"它将随后计算每个性能分析器事件的隐藏开销，并将其以浮点数的形式返回。 例如，在一台运行 macOS 的 1.8Ghz Intel Core i5 "
"上，使用 Python 的 time.process_time() 作为计时器，魔数大约为 4.04e-6。"

#: ../../library/profile.rst:640
msgid ""
"The object of this exercise is to get a fairly consistent result. If your "
"computer is *very* fast, or your timer function has poor resolution, you "
"might have to pass 100000, or even 1000000, to get consistent results."
msgstr ""
"此操作的目标是获得一个相当稳定的结果。 如果你的计算机 *非常* 快速，或者你的计时器函数的分辨率很差，你可能必须传入 100000，甚至 "
"1000000，才能得到稳定的结果。"

#: ../../library/profile.rst:644
msgid ""
"When you have a consistent answer, there are three ways you can use it::"
msgstr "当你有一个一致的答案时，有三种方法可以使用："

#: ../../library/profile.rst:646
msgid ""
"import profile\n"
"\n"
"# 1. Apply computed bias to all Profile instances created hereafter.\n"
"profile.Profile.bias = your_computed_bias\n"
"\n"
"# 2. Apply computed bias to a specific Profile instance.\n"
"pr = profile.Profile()\n"
"pr.bias = your_computed_bias\n"
"\n"
"# 3. Specify computed bias in instance constructor.\n"
"pr = profile.Profile(bias=your_computed_bias)"
msgstr ""
"import profile\n"
"\n"
"# 1. 将计算出的偏差应用于此后创建的所有 Profile 实例。\n"
"profile.Profile.bias = your_computed_bias\n"
"\n"
"# 2 将计算出的偏差应用于特定的 Profile 实例。\n"
"pr = profile.Profile()\n"
"pr.bias = your_computed_bias\n"
"\n"
"# 3. 在实例构造函数中指定计算出的偏差。\n"
"pr = profile.Profile(bias=your_computed_bias)"

#: ../../library/profile.rst:658
msgid ""
"If you have a choice, you are better off choosing a smaller constant, and "
"then your results will \"less often\" show up as negative in profile "
"statistics."
msgstr "如果你可以选择，那么选择更小的常量会更好，这样你的结果将“更不容易”在性能分析统计中显示负值。"

#: ../../library/profile.rst:664
msgid "Using a custom timer"
msgstr "使用自定义计时器"

#: ../../library/profile.rst:666
msgid ""
"If you want to change how current time is determined (for example, to force "
"use of wall-clock time or elapsed process time), pass the timing function "
"you want to the :class:`Profile` class constructor::"
msgstr ""
"如果你想要改变当前时间的确定方式（例如，强制使用时钟时间或进程持续时间），请向 :class:`Profile` 类构造器传入你想要的计时函数::"

#: ../../library/profile.rst:670
msgid "pr = profile.Profile(your_time_func)"
msgstr "pr = profile.Profile(your_time_func)"

#: ../../library/profile.rst:672
msgid ""
"The resulting profiler will then call ``your_time_func``. Depending on "
"whether you are using :class:`profile.Profile` or :class:`cProfile.Profile`,"
" ``your_time_func``'s return value will be interpreted differently:"
msgstr ""
"结果性能分析器将随后调用 ``your_time_func``。 根据你使用的是 :class:`profile.Profile` 还是 "
":class:`cProfile.Profile`，``your_time_func`` 的返回值将有不同的解读方式:"

#: ../../library/profile.rst:676
msgid ":class:`profile.Profile`"
msgstr ":class:`profile.Profile`"

#: ../../library/profile.rst:677
msgid ""
"``your_time_func`` should return a single number, or a list of numbers whose"
" sum is the current time (like what :func:`os.times` returns).  If the "
"function returns a single time number, or the list of returned numbers has "
"length 2, then you will get an especially fast version of the dispatch "
"routine."
msgstr ""
"``your_time_func`` 应当返回一个数字，或一个总和为当前时间的数字列表（如同 :func:`os.times` 所返回的内容）。 "
"如果该函数返回一个数字，或所返回的数字列表长度为 2，则你将得到一个特别快速的调度例程版本。"

#: ../../library/profile.rst:683
msgid ""
"Be warned that you should calibrate the profiler class for the timer "
"function that you choose (see :ref:`profile-calibration`).  For most "
"machines, a timer that returns a lone integer value will provide the best "
"results in terms of low overhead during profiling.  (:func:`os.times` is "
"*pretty* bad, as it returns a tuple of floating-point values).  If you want "
"to substitute a better timer in the cleanest fashion, derive a class and "
"hardwire a replacement dispatch method that best handles your timer call, "
"along with the appropriate calibration constant."
msgstr ""
"请注意你应当为你选择的计时器函数校准性能分析器类 (参见 :ref:`profile-calibration`)。 "
"对于大多数机器来说，一个返回长整数值的计时器在性能分析期间将提供在低开销方面的最佳结果。 (:func:`os.times` 是 *相当* "
"糟糕的，因为它返回一个浮点数值的元组)。 "
"如果你想以最干净的方式替换一个更好的计时器，请派生一个类并硬连线一个能最佳地处理计时器调用的替换调度方法，并使用适当的校准常量。"

#: ../../library/profile.rst:692
msgid ":class:`cProfile.Profile`"
msgstr ":class:`cProfile.Profile`"

#: ../../library/profile.rst:693
msgid ""
"``your_time_func`` should return a single number.  If it returns integers, "
"you can also invoke the class constructor with a second argument specifying "
"the real duration of one unit of time.  For example, if "
"``your_integer_time_func`` returns times measured in thousands of seconds, "
"you would construct the :class:`Profile` instance as follows::"
msgstr ""
"``your_time_func`` 应当返回一个数字。 如果它返回整数，你还可以通过第二个参数指定一个单位时间的实际持续长度来唤起类构造器。 "
"举例来说，如果 ``your_integer_time_func`` 返回以千秒为单位的时间，则你应当以如下方式构造 :class:`Profile` "
"实例::"

#: ../../library/profile.rst:699
msgid "pr = cProfile.Profile(your_integer_time_func, 0.001)"
msgstr "pr = cProfile.Profile(your_integer_time_func, 0.001)"

#: ../../library/profile.rst:701
msgid ""
"As the :class:`cProfile.Profile` class cannot be calibrated, custom timer "
"functions should be used with care and should be as fast as possible.  For "
"the best results with a custom timer, it might be necessary to hard-code it "
"in the C source of the internal :mod:`!_lsprof` module."
msgstr ""
"由于 :class:`cProfile.Profile` 类无法被校准，因此自定义计时器函数应当要小心地使用并应当尽可能地快速。 "
"为了使自定义计时器获得最佳结果，可能需要在内部 :mod:`!_lsprof` 模块的 C 源代码中对其进行硬编码。"

#: ../../library/profile.rst:706
msgid ""
"Python 3.3 adds several new functions in :mod:`time` that can be used to "
"make precise measurements of process or wall-clock time. For example, see "
":func:`time.perf_counter`."
msgstr ""
"Python 3.3 在 :mod:`time` 中添加了几个可被用来精确测量进程或时钟时间的新函数。 例如，参见 "
":func:`time.perf_counter`。"

#: ../../library/profile.rst:16
msgid "deterministic profiling"
msgstr "确定性性能分析"

#: ../../library/profile.rst:16
msgid "profiling, deterministic"
msgstr "性能分析，确定性的"
