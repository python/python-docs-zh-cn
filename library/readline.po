# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/readline.rst:2
msgid ":mod:`!readline` --- GNU readline interface"
msgstr ":mod:`!readline` --- GNU readline 接口"

#: ../../library/readline.rst:12
msgid ""
"The :mod:`readline` module defines a number of functions to facilitate "
"completion and reading/writing of history files from the Python interpreter."
" This module can be used directly, or via the :mod:`rlcompleter` module, "
"which supports completion of Python identifiers at the interactive prompt.  "
"Settings made using  this module affect the behaviour of both the "
"interpreter's interactive prompt  and the prompts offered by the built-in "
":func:`input` function."
msgstr ""
":mod:`readline` 模块定义了许多方便从 Python 解释器完成和读取/写入历史文件的函数。 "
"此模块可以直接使用，或通过支持在交互提示符下完成 Python 标识符的 :mod:`rlcompleter` 模块使用。 "
"使用此模块进行的设置会同时影响解释器的交互提示符以及内置 :func:`input` 函数提供的提示符。"

#: ../../library/readline.rst:20
msgid ""
"Readline keybindings may be configured via an initialization file, typically"
" ``.inputrc`` in your home directory.  See `Readline Init File "
"<https://tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-"
"File>`_ in the GNU Readline manual for information about the format and "
"allowable constructs of that file, and the capabilities of the Readline "
"library in general."
msgstr ""
"Readline 的按键绑定可以通过一个初始化文件来配置，通常是你的用户目录中的 ``.inputrc``。 请参阅 GNU Readline 手册中的"
" `Readline 初始化文件 "
"<https://tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-"
"File>`_ 来了解有关该文件的格式和允许的结构，以及 Readline 库的一般功能。"

#: ../../library/readline.rst:29
msgid ""
"The underlying Readline library API may be implemented by the ``libedit`` "
"library instead of GNU readline. On macOS the :mod:`readline` module detects"
" which library is being used at run time."
msgstr ""

#: ../../library/readline.rst:34
msgid ""
"The configuration file for ``libedit`` is different from that of GNU "
"readline. If you programmatically load configuration strings you can check "
"for the text \"libedit\" in :const:`readline.__doc__` to differentiate "
"between GNU readline and libedit."
msgstr ""

#: ../../library/readline.rst:39
msgid ""
"If you use *editline*/``libedit`` readline emulation on macOS, the "
"initialization file located in your home directory is named ``.editrc``. For"
" example, the following content in ``~/.editrc`` will turn ON *vi* "
"keybindings and TAB completion::"
msgstr ""

#: ../../library/readline.rst:44
msgid ""
"python:bind -v\n"
"python:bind ^I rl_complete"
msgstr ""
"python:bind -v\n"
"python:bind ^I rl_complete"

#: ../../library/readline.rst:47
msgid ""
"Also note that different libraries may use different history file formats. "
"When switching the underlying library, existing history files may become "
"unusable."
msgstr "另外请注意不同的库可能使用不同的历史文件格式。 当切换下层的库时，现有的历史文件可能会无法使用。"

#: ../../library/readline.rst:53
msgid "Init file"
msgstr "初始化文件"

#: ../../library/readline.rst:55
msgid ""
"The following functions relate to the init file and user configuration:"
msgstr "下列函数与初始化文件和用户配置有关："

#: ../../library/readline.rst:60
msgid ""
"Execute the init line provided in the *string* argument. This calls "
":c:func:`!rl_parse_and_bind` in the underlying library."
msgstr "执行在 *string* 参数中提供的初始化行。 这将调用底层库中的 :c:func:`!rl_parse_and_bind`。"

#: ../../library/readline.rst:66
msgid ""
"Execute a readline initialization file. The default filename is the last "
"filename used. This calls :c:func:`!rl_read_init_file` in the underlying "
"library."
msgstr ""
"执行 readline 初始化文件。 默认的文件名是上一个被使用的文件名。 这将调用底层库中的 "
":c:func:`!rl_read_init_file`。"

#: ../../library/readline.rst:71
msgid "Line buffer"
msgstr "行缓冲区"

#: ../../library/readline.rst:73
msgid "The following functions operate on the line buffer:"
msgstr "下列函数会在行缓冲区上操作。"

#: ../../library/readline.rst:78
msgid ""
"Return the current contents of the line buffer (:c:data:`!rl_line_buffer` in"
" the underlying library)."
msgstr "返回行缓冲区的当前内容 (底层库中的 :c:data:`!rl_line_buffer`)。"

#: ../../library/readline.rst:84
msgid ""
"Insert text into the line buffer at the cursor position.  This calls "
":c:func:`!rl_insert_text` in the underlying library, but ignores the return "
"value."
msgstr "将文本插入到行缓冲区的当前游标位置。 该函数会调用底层库中的 :c:func:`!rl_insert_text`，但会忽略其返回值。"

#: ../../library/readline.rst:91
msgid ""
"Change what's displayed on the screen to reflect the current contents of the"
" line buffer.  This calls :c:func:`!rl_redisplay` in the underlying library."
msgstr "改变屏幕的显示以反映行缓冲区的当前内容。 该函数会调用底层库中的 :c:func:`!rl_redisplay`。"

#: ../../library/readline.rst:96
msgid "History file"
msgstr "历史文件"

#: ../../library/readline.rst:98
msgid "The following functions operate on a history file:"
msgstr "下列函数会在历史文件上操作："

#: ../../library/readline.rst:103
msgid ""
"Load a readline history file, and append it to the history list. The default"
" filename is :file:`~/.history`.  This calls :c:func:`!read_history` in the "
"underlying library."
msgstr ""
"载入一个 readline 历史文件，并将其添加到历史列表。 默认文件名为 :file:`~/.history`。 此函数会调用底层库中的 "
":c:func:`!read_history`。"

#: ../../library/readline.rst:110
msgid ""
"Save the history list to a readline history file, overwriting any existing "
"file.  The default filename is :file:`~/.history`.  This calls "
":c:func:`!write_history` in the underlying library."
msgstr ""
"将历史列表保存到 readline 历史文件，覆盖任何现有的文件。 默认文件名为 :file:`~/.history`。 此函数会调用底层库中的 "
":c:func:`!write_history`。"

#: ../../library/readline.rst:117
msgid ""
"Append the last *nelements* items of history to a file.  The default "
"filename is :file:`~/.history`.  The file must already exist.  This calls "
":c:func:`!append_history` in the underlying library.  This function only "
"exists if Python was compiled for a version of the library that supports it."
msgstr ""
"将历史列表的最后 *nelements* 项添加到历史文件。 默认文件名为 :file:`~/.history`。 该文件必须已存在。 "
"此函数会调用底层库中的 :c:func:`!append_history`。 此函数仅当 Python 是针对支持该功能的库版本编译时才会存在。"

#: ../../library/readline.rst:129
msgid ""
"Set or return the desired number of lines to save in the history file. The "
":func:`write_history_file` function uses this value to truncate the history "
"file, by calling :c:func:`!history_truncate_file` in the underlying library."
"  Negative values imply unlimited history file size."
msgstr ""
"设置或返回需要保存到历史文件的条目行数。 :func:`write_history_file` 函数会通过调用底层库中的 "
":c:func:`!history_truncate_file` 以使用该值来截取历史文件。 负值意味着不限制历史文件的大小。"

#: ../../library/readline.rst:137
msgid "History list"
msgstr "历史列表"

#: ../../library/readline.rst:139
msgid "The following functions operate on a global history list:"
msgstr "以下函数会在全局历史列表上操作："

#: ../../library/readline.rst:144
msgid ""
"Clear the current history.  This calls :c:func:`!clear_history` in the "
"underlying library.  The Python function only exists if Python was compiled "
"for a version of the library that supports it."
msgstr ""
"清空当前历史。 此函数会调用底层库中的 :c:func:`!clear_history`。 此 Python 函数仅当 Python "
"是针对支持该功能的库版本编译时才会存在。"

#: ../../library/readline.rst:151
msgid ""
"Return the number of items currently in the history.  (This is different "
"from :func:`get_history_length`, which returns the maximum number of lines "
"that will be written to a history file.)"
msgstr "返回历史列表的当前项数。 （此函数不同于 :func:`get_history_length`，后者是返回将被写入历史文件的最大行数。）"

#: ../../library/readline.rst:158
msgid ""
"Return the current contents of history item at *index*.  The item index is "
"one-based.  This calls :c:func:`!history_get` in the underlying library."
msgstr ""
"返回 *index* 号位置上的历史条目的当前内容。 条目索引从一开始。 此函数会调用底层库中的 :c:func:`!history_get`。"

#: ../../library/readline.rst:164
msgid ""
"Remove history item specified by its position from the history. The position"
" is zero-based.  This calls :c:func:`!remove_history` in the underlying "
"library."
msgstr "从历史列表中移除指定位置上的历史条目。 条目位置从零开始。 此函数会调用底层库中的 :c:func:`!remove_history`。"

#: ../../library/readline.rst:171
msgid ""
"Replace history item specified by its position with *line*. The position is "
"zero-based.  This calls :c:func:`!replace_history_entry` in the underlying "
"library."
msgstr ""
"将指定位置上的历史条目替换为 *line*。 条目位置是从零开始的。 此函数会调用底层库中的 "
":c:func:`!replace_history_entry`。"

#: ../../library/readline.rst:178
msgid ""
"Append *line* to the history buffer, as if it was the last line typed. This "
"calls :c:func:`!add_history` in the underlying library."
msgstr "将 *line* 添加到历史缓冲区，就像它是最近输入的一行。 此函数会调用底层库中的 :c:func:`!add_history`。"

#: ../../library/readline.rst:184
msgid ""
"Enable or disable automatic calls to :c:func:`!add_history` when reading "
"input via readline.  The *enabled* argument should be a Boolean value that "
"when true, enables auto history, and that when false, disables auto history."
msgstr ""
"启用或禁用当通过 readline 读取输入时对 :c:func:`!add_history` 的自动调用。 *enabled* "
"参数应为一个布尔值，当其为真值时启用自动历史，当其为假值时则禁用自动历史。"

#: ../../library/readline.rst:192
msgid ""
"Auto history is enabled by default, and changes to this do not persist "
"across multiple sessions."
msgstr "自动历史将默认启用，对此设置的改变不会在多个会话中保持。"

#: ../../library/readline.rst:197
msgid "Startup hooks"
msgstr "启动钩子"

#: ../../library/readline.rst:202
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_startup_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments just before "
"readline prints the first prompt."
msgstr ""
"设置或移除底层库的 :c:data:`!rl_startup_hook` 回调所唤起的函数。 如果指定了 "
"*function*，它将被用作新的钩子函数；如果省略或为 ``None``，则任何已安装的函数将被移除。 钩子函数将在 readline "
"打印第一个提示之前不带参数地被调用。"

#: ../../library/readline.rst:211
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_pre_input_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments after the first "
"prompt has been printed and just before readline starts reading input "
"characters.  This function only exists if Python was compiled for a version "
"of the library that supports it."
msgstr ""
"设置或移除底层库的 :c:data:`!rl_pre_input_hook` 回调所唤起的函数。 如果指定了 "
"*function*，它将被用作新的钩子函数；如果省略或为 ``None``，则任何已安装的函数将被移除。 钩子函数将在打印第一个提示之后 "
"readline 开始读取输入字符之前不带参数地被调用。 此函数仅当 Python 为针对支持此功能的库编译时才会存在。"

#: ../../library/readline.rst:223
msgid "Completion"
msgstr "Completion"

#: ../../library/readline.rst:225
msgid ""
"The following functions relate to implementing a custom word completion "
"function.  This is typically operated by the Tab key, and can suggest and "
"automatically complete a word being typed.  By default, Readline is set up "
"to be used by :mod:`rlcompleter` to complete Python identifiers for the "
"interactive interpreter.  If the :mod:`readline` module is to be used with a"
" custom completer, a different set of word delimiters should be set."
msgstr ""
"以下函数与自定义单词补全函数的实现有关。 这通常使用 Tab 键进行操作，能够提示并自动补全正在输入的单词。 默认情况下，Readline 设置为由 "
":mod:`rlcompleter` 来补全交互模式解释器的 Python 标识符。 如果 :mod:`readline` "
"模块要配合自定义的补全函数来使用，则需要设置不同的单词分隔符。"

#: ../../library/readline.rst:235
msgid ""
"Set or remove the completer function.  If *function* is specified, it will "
"be used as the new completer function; if omitted or ``None``, any completer"
" function already installed is removed.  The completer function is called as"
" ``function(text, state)``, for *state* in ``0``, ``1``, ``2``, ..., until "
"it returns a non-string value.  It should return the next possible "
"completion starting with *text*."
msgstr ""
"设置或移除补全函数。 如果指定了 *function*，它将被用作新的补全函数；如果省略或为 ``None``，任何已安装的补全函数将被移除。 "
"补全函数的调用形式为 ``function(text, state)``，其中 *state* 为 ``0``, ``1``, ``2``, ..., "
"直至其返回一个非字符串值。 它应当返回下一个以 *text* 开头的候选补全内容。"

#: ../../library/readline.rst:242
msgid ""
"The installed completer function is invoked by the *entry_func* callback "
"passed to :c:func:`!rl_completion_matches` in the underlying library. The "
"*text* string comes from the first parameter to the "
":c:data:`!rl_attempted_completion_function` callback of the underlying "
"library."
msgstr ""
"已安装的补全函数将由传递给底层库中 :c:func:`!rl_completion_matches` 的 *entry_func* 回调来唤起。 "
"*text* 字符串来自于底层库中 :c:data:`!rl_attempted_completion_function` 回调的第一个形参。"

#: ../../library/readline.rst:251
msgid ""
"Get the completer function, or ``None`` if no completer function has been "
"set."
msgstr "获取补全函数，如果没有设置补全函数则返回 ``None``。"

#: ../../library/readline.rst:256
msgid ""
"Get the type of completion being attempted.  This returns the "
":c:data:`!rl_completion_type` variable in the underlying library as an "
"integer."
msgstr "获取正在尝试的补全的类型。 此函数会将底层库中的 :c:data:`!rl_completion_type` 变量作为一个整数返回。"

#: ../../library/readline.rst:264
msgid ""
"Get the beginning or ending index of the completion scope. These indexes are"
" the *start* and *end* arguments passed to the "
":c:data:`!rl_attempted_completion_function` callback of the underlying "
"library.  The values may be different in the same input editing scenario "
"based on the underlying C readline implementation. Ex: libedit is known to "
"behave differently than libreadline."
msgstr ""
"获取补全域的开始和结束索引。 这些索引就是传递给下层库的 :c:data:`!rl_attempted_completion_function` 回调的"
" *start* 和 *end* 参数。 具体值在同一输入编辑场景中根据下层的 C readline 实现的不同可能会不一样。 例如：已知 "
"libedit 的行为就不同于 libreadline。"

#: ../../library/readline.rst:275
msgid ""
"Set or get the word delimiters for completion.  These determine the start of"
" the word to be considered for completion (the completion scope). These "
"functions access the :c:data:`!rl_completer_word_break_characters` variable "
"in the underlying library."
msgstr ""
"设置或获取补全的单词分隔符。 这些分隔符确定了要考虑补全的单词的开始和结束位置（即补全域）。 这些函数会访问底层库中的 "
":c:data:`!rl_completer_word_break_characters` 变量。"

#: ../../library/readline.rst:283
msgid ""
"Set or remove the completion display function.  If *function* is specified, "
"it will be used as the new completion display function; if omitted or "
"``None``, any completion display function already installed is removed.  "
"This sets or clears the :c:data:`!rl_completion_display_matches_hook` "
"callback in the underlying library.  The completion display function is "
"called as ``function(substitution, [matches], longest_match_length)`` once "
"each time matches need to be displayed."
msgstr ""
"设置或移除补全显示函数。 如果指定了 *function*，它将被用作新的补全显示函数；如果省略或为 "
"``None``，任何已安装的补全显示函数将被移除。 此函数会设置或清除底层库中的 "
":c:data:`!rl_completion_display_matches_hook` 回调。 补全显示函数会在每次需要显示匹配项时以 "
"``function(substitution, [matches], longest_match_length)`` 的形式被调用。"

#: ../../library/readline.rst:296
msgid "Example"
msgstr "示例"

#: ../../library/readline.rst:298
msgid ""
"The following example demonstrates how to use the :mod:`readline` module's "
"history reading and writing functions to automatically load and save a "
"history file named :file:`.python_history` from the user's home directory.  "
"The code below would normally be executed automatically during interactive "
"sessions from the user's :envvar:`PYTHONSTARTUP` file. ::"
msgstr ""
"以下示例演示了如何使用 :mod:`readline` 模块的历史读取或写入函数来自动加载和保存用户主目录下名为 "
":file:`.python_history` 的历史文件。 以下代码通常应当在交互会话期间从用户的 :envvar:`PYTHONSTARTUP` "
"文件自动执行。 ::"

#: ../../library/readline.rst:304
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # 默认的历史长度为 -1 (无限)，这可能导致增长失控\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"

#: ../../library/readline.rst:318
msgid ""
"This code is actually automatically run when Python is run in "
":ref:`interactive mode <tut-interactive>` (see :ref:`rlcompleter-config`)."
msgstr ""
"此代码实际上会在 Python 运行于 :ref:`交互模式 <tut-interactive>` 时自动运行 (参见 "
":ref:`rlcompleter-config`)。"

#: ../../library/readline.rst:321
msgid ""
"The following example achieves the same goal but supports concurrent "
"interactive sessions, by only appending the new history. ::"
msgstr "以下示例实现了同样的目标，但是通过只添加新历史的方式来支持并发的交互会话。 ::"

#: ../../library/readline.rst:324
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"

#: ../../library/readline.rst:342
msgid ""
"The following example extends the :class:`code.InteractiveConsole` class to "
"support history save/restore. ::"
msgstr "以下示例扩展了 :class:`code.InteractiveConsole` 类以支持历史保存/恢复。 ::"

#: ../../library/readline.rst:345
msgid ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
msgstr ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
