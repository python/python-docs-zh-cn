# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/textwrap.rst:2
msgid ":mod:`!textwrap` --- Text wrapping and filling"
msgstr ":mod:`!textwrap` --- 文本自动换行与填充"

#: ../../library/textwrap.rst:10
msgid "**Source code:** :source:`Lib/textwrap.py`"
msgstr "**源代码:** :source:`Lib/textwrap.py`"

#: ../../library/textwrap.rst:14
msgid ""
"The :mod:`textwrap` module provides some convenience functions, as well as "
":class:`TextWrapper`, the class that does all the work. If you're just "
"wrapping or filling one or two text strings, the convenience functions "
"should be good enough; otherwise, you should use an instance of "
":class:`TextWrapper` for efficiency."
msgstr ""
":mod:`textwrap` 模块提供了一些快捷函数，以及可以完成所有工作的类 :class:`TextWrapper`。 "
"如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；否则的话，你应该使用 :class:`TextWrapper` "
"的实例来提高效率。"

#: ../../library/textwrap.rst:27
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most "
"*width* characters long.  Returns a list of output lines, without final "
"newlines."
msgstr "对 *text* (字符串) 中的单独段落自动换行以使每行长度最多为 *width* 个字符。 返回由输出行组成的列表，行尾不带换行符。"

#: ../../library/textwrap.rst:31
msgid ""
"Optional keyword arguments correspond to the instance attributes of "
":class:`TextWrapper`, documented below."
msgstr "与 :class:`TextWrapper` 的实例属性对应的可选的关键字参数，具体文档见下。"

#: ../../library/textwrap.rst:34
msgid ""
"See the :meth:`TextWrapper.wrap` method for additional details on how "
":func:`wrap` behaves."
msgstr "请参阅 :meth:`TextWrapper.wrap` 方法了解有关 :func:`wrap` 行为的详细信息。"

#: ../../library/textwrap.rst:45
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing"
" the wrapped paragraph.  :func:`fill` is shorthand for  ::"
msgstr "对 *text* 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 :func:`fill` 是以下语句的快捷方式  ::"

#: ../../library/textwrap.rst:48
msgid "\"\\n\".join(wrap(text, ...))"
msgstr "\"\\n\".join(wrap(text, ...))"

#: ../../library/textwrap.rst:50
msgid ""
"In particular, :func:`fill` accepts exactly the same keyword arguments as "
":func:`wrap`."
msgstr "特别要说明的是，:func:`fill` 接受与 :func:`wrap` 完全相同的关键字参数。"

#: ../../library/textwrap.rst:58
msgid "Collapse and truncate the given *text* to fit in the given *width*."
msgstr "折叠并截短给定的 *text* 以符合给定的 *width*。"

#: ../../library/textwrap.rst:60
msgid ""
"First the whitespace in *text* is collapsed (all whitespace is replaced by "
"single spaces).  If the result fits in the *width*, it is returned. "
"Otherwise, enough words are dropped from the end so that the remaining words"
" plus the *placeholder* fit within *width*::"
msgstr ""
"首先 *text* 中的空格会被折叠（所有连续会替换为单个空格）。 如果结果能适合 *width*，它将被返回。 "
"在其他情况下，将在末尾丢弃足够数量的单词以使剩余的单词加 *placeholder* 能适合 *width*::"

#: ../../library/textwrap.rst:65
msgid ""
">>> textwrap.shorten(\"Hello  world!\", width=12)\n"
"'Hello world!'\n"
">>> textwrap.shorten(\"Hello  world!\", width=11)\n"
"'Hello [...]'\n"
">>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n"
"'Hello...'"
msgstr ""
">>> textwrap.shorten(\"Hello  world!\", width=12)\n"
"'Hello world!'\n"
">>> textwrap.shorten(\"Hello  world!\", width=11)\n"
"'Hello [...]'\n"
">>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n"
"'Hello...'"

#: ../../library/textwrap.rst:72
msgid ""
"Optional keyword arguments correspond to the instance attributes of "
":class:`TextWrapper`, documented below.  Note that the whitespace is "
"collapsed before the text is passed to the :class:`TextWrapper` :meth:`fill`"
" function, so changing the value of :attr:`.tabsize`, :attr:`.expand_tabs`, "
":attr:`.drop_whitespace`, and :attr:`.replace_whitespace` will have no "
"effect."
msgstr ""
"可选的关键字参数对应于 :class:`TextWrapper` 的实际属性，具体见下文。 请注意文本在被传入 :class:`TextWrapper`"
" 的 :meth:`fill` 函数之前会被折叠，因此改变 :attr:`.tabsize`, :attr:`.expand_tabs`, "
":attr:`.drop_whitespace` 和 :attr:`.replace_whitespace` 的值将没有任何效果。"

#: ../../library/textwrap.rst:82
msgid "Remove any common leading whitespace from every line in *text*."
msgstr "移除 *text* 中每一行的任何相同前缀空白符。"

#: ../../library/textwrap.rst:84
msgid ""
"This can be used to make triple-quoted strings line up with the left edge of"
" the display, while still presenting them in the source code in indented "
"form."
msgstr "这可以用来清除三重引号字符串行左侧空格，而仍然在源码中显示为缩进格式。"

#: ../../library/textwrap.rst:87
msgid ""
"Note that tabs and spaces are both treated as whitespace, but they are not "
"equal: the lines ``\"  hello\"`` and ``\"\\thello\"`` are considered to have"
" no common leading whitespace."
msgstr ""
"请注意制表符和空格符都被视为是空白符，但它们并不相等：以下两行 ``\"  hello\"`` 和 ``\"\\thello\"`` "
"不会被视为具有相同的前缀空白符。"

#: ../../library/textwrap.rst:91
msgid ""
"Lines containing only whitespace are ignored in the input and normalized to "
"a single newline character in the output."
msgstr "只包含空白符的行会在输入时被忽略并在输出时被标准化为单个换行符。"

#: ../../library/textwrap.rst:94 ../../library/textwrap.rst:115
msgid "For example::"
msgstr "例如::"

#: ../../library/textwrap.rst:96
msgid ""
"def test():\n"
"    # end first line with \\ to avoid the empty line!\n"
"    s = '''\\\n"
"    hello\n"
"      world\n"
"    '''\n"
"    print(repr(s))          # prints '    hello\\n      world\\n    '\n"
"    print(repr(dedent(s)))  # prints 'hello\\n  world\\n'"
msgstr ""
"def test():\n"
"    # 第一行以 \\ 结束以避免出现空行！\n"
"    s = '''\\\n"
"    hello\n"
"      world\n"
"    '''\n"
"    print(repr(s))          # prints '    hello\\n      world\\n    '\n"
"    print(repr(dedent(s)))  # prints 'hello\\n  world\\n'"

#: ../../library/textwrap.rst:108
msgid "Add *prefix* to the beginning of selected lines in *text*."
msgstr "将 *prefix* 添加到 *text* 中选定行的开头。"

#: ../../library/textwrap.rst:110
msgid "Lines are separated by calling ``text.splitlines(True)``."
msgstr "通过调用 ``text.splitlines(True)`` 来对行进行拆分。"

#: ../../library/textwrap.rst:112
msgid ""
"By default, *prefix* is added to all lines that do not consist solely of "
"whitespace (including any line endings)."
msgstr "默认情况下，*prefix* 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。"

#: ../../library/textwrap.rst:117
msgid ""
">>> s = 'hello\\n\\n \\nworld'\n"
">>> indent(s, '  ')\n"
"'  hello\\n\\n \\n  world'"
msgstr ""
">>> s = 'hello\\n\\n \\nworld'\n"
">>> indent(s, '  ')\n"
"'  hello\\n\\n \\n  world'"

#: ../../library/textwrap.rst:121
msgid ""
"The optional *predicate* argument can be used to control which lines are "
"indented. For example, it is easy to add *prefix* to even empty and "
"whitespace-only lines::"
msgstr "可选的 *predicate* 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 *prefix*::"

#: ../../library/textwrap.rst:125
msgid ""
">>> print(indent(s, '+ ', lambda line: True))\n"
"+ hello\n"
"+\n"
"+\n"
"+ world"
msgstr ""
">>> print(indent(s, '+ ', lambda line: True))\n"
"+ hello\n"
"+\n"
"+\n"
"+ world"

#: ../../library/textwrap.rst:134
msgid ""
":func:`wrap`, :func:`fill` and :func:`shorten` work by creating a "
":class:`TextWrapper` instance and calling a single method on it.  That "
"instance is not reused, so for applications that process many text strings "
"using :func:`wrap` and/or :func:`fill`, it may be more efficient to create "
"your own :class:`TextWrapper` object."
msgstr ""
":func:`wrap`, :func:`fill` 和 :func:`shorten` 的作用方式为创建一个 :class:`TextWrapper`"
" 实例并在其上调用单个方法。 该实例不会被重用，因此对于要使用 :func:`wrap` 和/或 :func:`fill` "
"来处理许多文本字符串的应用来说，创建你自己的 :class:`TextWrapper` 对象可能会更有效率。"

#: ../../library/textwrap.rst:140
msgid ""
"Text is preferably wrapped on whitespaces and right after the hyphens in "
"hyphenated words; only then will long words be broken if necessary, unless "
":attr:`TextWrapper.break_long_words` is set to false."
msgstr ""
"文本最好在空白符位置自动换行，包括带连字符单词的连字符之后；长单词仅在必要时会被拆分，除非 "
":attr:`TextWrapper.break_long_words` 被设为假值。"

#: ../../library/textwrap.rst:146
msgid ""
"The :class:`TextWrapper` constructor accepts a number of optional keyword "
"arguments.  Each keyword argument corresponds to an instance attribute, so "
"for example ::"
msgstr ":class:`TextWrapper` 构造器接受多个可选的关键字参数。 每个关键字参数对应一个实例属性，比如说 ::"

#: ../../library/textwrap.rst:150
msgid "wrapper = TextWrapper(initial_indent=\"* \")"
msgstr "wrapper = TextWrapper(initial_indent=\"* \")"

#: ../../library/textwrap.rst:152
msgid "is the same as  ::"
msgstr "相当于："

#: ../../library/textwrap.rst:154
msgid ""
"wrapper = TextWrapper()\n"
"wrapper.initial_indent = \"* \""
msgstr ""
"wrapper = TextWrapper()\n"
"wrapper.initial_indent = \"* \""

#: ../../library/textwrap.rst:157
msgid ""
"You can reuse the same :class:`TextWrapper` object many times, and you can "
"change any of its options through direct assignment to instance attributes "
"between uses."
msgstr "你可以多次重用相同的 :class:`TextWrapper` 对象，并且你也可以在使用期间通过直接向实例属性赋值来修改它的任何选项。"

#: ../../library/textwrap.rst:161
msgid ""
"The :class:`TextWrapper` instance attributes (and keyword arguments to the "
"constructor) are as follows:"
msgstr ":class:`TextWrapper` 的实例属性（以及构造器的关键字参数）如下所示："

#: ../../library/textwrap.rst:167
msgid ""
"(default: ``70``) The maximum length of wrapped lines.  As long as there are"
" no individual words in the input text longer than :attr:`width`, "
":class:`TextWrapper` guarantees that no output line will be longer than "
":attr:`width` characters."
msgstr ""
"(默认: ``70``) 自动换行的最大行长度。 只要输入文本中没有长于 :attr:`width` "
"的单个单词，:class:`TextWrapper` 就能保证没有长于 :attr:`width` 个字符的输出行。"

#: ../../library/textwrap.rst:175
msgid ""
"(default: ``True``) If true, then all tab characters in *text* will be "
"expanded to spaces using the :meth:`~str.expandtabs` method of *text*."
msgstr ""
"(默认值: ``True``) 如果为真值，则 *text* 中的所有制表符将使用 *text* 的 :meth:`~str.expandtabs` "
"方法扩展为空格符。"

#: ../../library/textwrap.rst:181
msgid ""
"(default: ``8``) If :attr:`expand_tabs` is true, then all tab characters in "
"*text* will be expanded to zero or more spaces, depending on the current "
"column and the given tab size."
msgstr ""
"(默认: ``8``) 如果 :attr:`expand_tabs` 为真值，则 *text* "
"中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。"

#: ../../library/textwrap.rst:190
msgid ""
"(default: ``True``) If true, after tab expansion but before wrapping, the "
":meth:`wrap` method will replace each whitespace character with a single "
"space.  The whitespace characters replaced are as follows: tab, newline, "
"vertical tab, formfeed, and carriage return (``'\\t\\n\\v\\f\\r'``)."
msgstr ""
"(default: ``True``) 如果为真值，在制表符扩展之后、自动换行之前，:meth:`wrap` 方法将把每个空白字符都替换为单个空格。 "
"会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (``'\\t\\n\\v\\f\\r'``)。"

#: ../../library/textwrap.rst:198
msgid ""
"If :attr:`expand_tabs` is false and :attr:`replace_whitespace` is true, each"
" tab character will be replaced by a single space, which is *not* the same "
"as tab expansion."
msgstr ""
"如果 :attr:`expand_tabs` 为假值且 :attr:`replace_whitespace` "
"为真值，每个制表符将被替换为单个空格，这与制表符扩展是 *不* 一样的。"

#: ../../library/textwrap.rst:204
msgid ""
"If :attr:`replace_whitespace` is false, newlines may appear in the middle of"
" a line and cause strange output. For this reason, text should be split into"
" paragraphs (using :meth:`str.splitlines` or similar) which are wrapped "
"separately."
msgstr ""
"如果 :attr:`replace_whitespace` 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 "
":meth:`str.splitlines` 或类似方法）拆分为段落并分别进行自动换行。"

#: ../../library/textwrap.rst:212
msgid ""
"(default: ``True``) If true, whitespace at the beginning and ending of every"
" line (after wrapping but before indenting) is dropped. Whitespace at the "
"beginning of the paragraph, however, is not dropped if non-whitespace "
"follows it.  If whitespace being dropped takes up an entire line, the whole "
"line is dropped."
msgstr ""
"(默认: ``True``) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 "
"但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。"

#: ../../library/textwrap.rst:221
msgid ""
"(default: ``''``) String that will be prepended to the first line of wrapped"
" output.  Counts towards the length of the first line.  The empty string is "
"not indented."
msgstr "(默认: ``''``) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。"

#: ../../library/textwrap.rst:228
msgid ""
"(default: ``''``) String that will be prepended to all lines of wrapped "
"output except the first.  Counts towards the length of each line except the "
"first."
msgstr "(default: ``''``) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。"

#: ../../library/textwrap.rst:235
msgid ""
"(default: ``False``) If true, :class:`TextWrapper` attempts to detect "
"sentence endings and ensure that sentences are always separated by exactly "
"two spaces.  This is generally desired for text in a monospaced font. "
"However, the sentence detection algorithm is imperfect: it assumes that a "
"sentence ending consists of a lowercase letter followed by one of ``'.'``, "
"``'!'``, or ``'?'``, possibly followed by one of ``'\"'`` or ``\"'\"``, "
"followed by a space.  One problem with this algorithm is that it is unable "
"to detect the difference between \"Dr.\" in ::"
msgstr ""
"(默认: ``False``) 如果为真值，:class:`TextWrapper` 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 "
"对于使用等宽字体的文本来说通常都需要这样。 但是句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 ``'.'``, ``'!'`` 或 "
"``'?'`` 之一，并可能跟一个 ``'\"'`` 或 ``\"'\"``，再跟一个空格。 此算法的一个问题是它无法区分以下文本中的 \"Dr.\" "
"::"

#: ../../library/textwrap.rst:244
msgid "[...] Dr. Frankenstein's monster [...]"
msgstr "[...] Dr. Frankenstein's monster [...]"

#: ../../library/textwrap.rst:246
msgid "and \"Spot.\" in ::"
msgstr "和以下文本中的 \"Spot.\" ::"

#: ../../library/textwrap.rst:248
msgid "[...] See Spot. See Spot run [...]"
msgstr "[...] See Spot. See Spot run [...]"

#: ../../library/textwrap.rst:250
msgid ":attr:`fix_sentence_endings` is false by default."
msgstr ":attr:`fix_sentence_endings` 默认为假值。"

#: ../../library/textwrap.rst:252
msgid ""
"Since the sentence detection algorithm relies on ``string.lowercase`` for "
"the definition of \"lowercase letter\", and a convention of using two spaces"
" after a period to separate sentences on the same line, it is specific to "
"English-language texts."
msgstr ""
"由于句子检测算法依赖于 ``string.lowercase`` "
"来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。"

#: ../../library/textwrap.rst:260
msgid ""
"(default: ``True``) If true, then words longer than :attr:`width` will be "
"broken in order to ensure that no lines are longer than :attr:`width`.  If "
"it is false, long words will not be broken, and some lines may be longer "
"than :attr:`width`.  (Long words will be put on a line by themselves, in "
"order to minimize the amount by which :attr:`width` is exceeded.)"
msgstr ""
"(默认: ``True``) 如果为真值，则长度超过 :attr:`width` 的单词将被分开以保证行的长度不会超过 :attr:`width`。 "
"如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 :attr:`width`。 （超长单词将被单独作为一行，以尽量减少超出 "
":attr:`width` 的情况。）"

#: ../../library/textwrap.rst:269
msgid ""
"(default: ``True``) If true, wrapping will occur preferably on whitespaces "
"and right after hyphens in compound words, as it is customary in English. If"
" false, only whitespaces will be considered as potentially good places for "
"line breaks, but you need to set :attr:`break_long_words` to false if you "
"want truly insecable words.  Default behaviour in previous versions was to "
"always allow breaking hyphenated words."
msgstr ""
"(默认: ``True``) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 "
"如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 :attr:`break_long_words` "
"设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。"

#: ../../library/textwrap.rst:279
msgid ""
"(default: ``None``) If not ``None``, then the output will contain at most "
"*max_lines* lines, with *placeholder* appearing at the end of the output."
msgstr ""
"(默认: ``None``) 如果不为 ``None``，则输出内容将最多包含 *max_lines* 行，并使 *placeholder* "
"出现在输出内容的末尾。"

#: ../../library/textwrap.rst:289
msgid ""
"(default: ``' [...]'``) String that will appear at the end of the output "
"text if it has been truncated."
msgstr "(默认: ``' [...]'``) 该文本将在输出文本被截短时出现在文本末尾。"

#: ../../library/textwrap.rst:295
msgid ""
":class:`TextWrapper` also provides some public methods, analogous to the "
"module-level convenience functions:"
msgstr ":class:`TextWrapper` 还提供了一些公有方法，类似于模块层级的便捷函数："

#: ../../library/textwrap.rst:300
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most "
":attr:`width` characters long.  All wrapping options are taken from instance"
" attributes of the :class:`TextWrapper` instance.  Returns a list of output "
"lines, without final newlines.  If the wrapped output has no content, the "
"returned list is empty."
msgstr ""
"对 *text* (字符串) 中的单独段落自动换行以使每行长度最多为 :attr:`width` 个字符。 所有自动换行选项均获取自 "
":class:`TextWrapper` 实例的实例属性。 返回由输出行组成的列表，行尾不带换行符。 如果自动换行输出结果没有任何内容，则返回空列表。"

#: ../../library/textwrap.rst:309
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing"
" the wrapped paragraph."
msgstr "对 *text* 中的单独段落自动换行并返回包含被自动换行段落的单独字符串。"

#: ../../library/textwrap.rst:285
msgid "..."
msgstr "..."

#: ../../library/textwrap.rst:285
msgid "placeholder"
msgstr "placeholder"
