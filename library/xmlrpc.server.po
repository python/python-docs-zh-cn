# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/xmlrpc.server.rst:2
msgid ":mod:`!xmlrpc.server` --- Basic XML-RPC servers"
msgstr ":mod:`!xmlrpc.server` --- 基本 XML-RPC 服务器"

#: ../../library/xmlrpc.server.rst:10
msgid "**Source code:** :source:`Lib/xmlrpc/server.py`"
msgstr "**源代码:** :source:`Lib/xmlrpc/server.py`"

#: ../../library/xmlrpc.server.rst:14
msgid ""
"The :mod:`xmlrpc.server` module provides a basic server framework for XML-"
"RPC servers written in Python.  Servers can either be free standing, using "
":class:`SimpleXMLRPCServer`, or embedded in a CGI environment, using "
":class:`CGIXMLRPCRequestHandler`."
msgstr ""
":mod:`xmlrpc.server` 模块为以 Python 编写 XML-RPC 服务器提供了一个基本服务器框架。 服务器可以是独立的，使用 "
":class:`SimpleXMLRPCServer`，或是嵌入某个 CGI 环境中，使用 "
":class:`CGIXMLRPCRequestHandler`。"

#: ../../library/xmlrpc.server.rst:22
msgid ""
"The :mod:`xmlrpc.server` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
":mod:`xmlrpc.server` 模块对于恶意构建的数据是不安全的。 如果你需要解析不受信任或未经身份验证的数据，请参阅 :ref:`xml-"
"vulnerabilities`。"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "可用性"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/xmlrpc.server.rst:32
msgid ""
"Create a new server instance.  This class provides methods for registration "
"of functions that can be called by the XML-RPC protocol.  The "
"*requestHandler* parameter should be a factory for request handler "
"instances; it defaults to :class:`SimpleXMLRPCRequestHandler`.  The *addr* "
"and *requestHandler* parameters are passed to the "
":class:`socketserver.TCPServer` constructor.  If *logRequests* is true (the "
"default), requests will be logged; setting this parameter to false will turn"
" off logging.   The *allow_none* and *encoding* parameters are passed on to "
":mod:`xmlrpc.client` and control the XML-RPC responses that will be returned"
" from the server. The *bind_and_activate* parameter controls whether "
":meth:`server_bind` and :meth:`server_activate` are called immediately by "
"the constructor; it defaults to true. Setting it to false allows code to "
"manipulate the *allow_reuse_address* class variable before the address is "
"bound. The *use_builtin_types* parameter is passed to the "
":func:`~xmlrpc.client.loads` function and controls which types are processed"
" when date/times values or binary data are received; it defaults to false."
msgstr ""
"创建一个新的服务器实例。 这个类提供了一些用来注册可以被 XML-RPC 协议所调用的函数的方法。 *requestHandler* "
"形参应该是一个用于请求处理器实例的工厂函数；它默认为 :class:`SimpleXMLRPCRequestHandler`。 *addr* 和 "
"*requestHandler* 形参会被传给 :class:`socketserver.TCPServer` 构造器。 如果 "
"*logRequests* 为真值（默认），请求将被记录到日志；将此形参设为假值将关闭日志记录。 *allow_none* 和 *encoding* "
"形参会被传给 :mod:`xmlrpc.client` 并控制将从服务器返回的 XML-RPC 响应。 *bind_and_activate* 形参控制"
" :meth:`server_bind` 和 :meth:`server_activate` 是否会被构造器立即调用；它默认为真值。 "
"将其设为假值将允许代码在地址被绑定之前操作 *allow_reuse_address* 类变量。 *use_builtin_types* 形参会被传给 "
":func:`~xmlrpc.client.loads` 函数并控制当收到日期/时间值或二进制数据时将处理哪些类型；它默认为假值。"

#: ../../library/xmlrpc.server.rst:48 ../../library/xmlrpc.server.rst:62
#: ../../library/xmlrpc.server.rst:374
msgid "The *use_builtin_types* flag was added."
msgstr "增加了 *use_builtin_types* 旗标。"

#: ../../library/xmlrpc.server.rst:55
msgid ""
"Create a new instance to handle XML-RPC requests in a CGI environment.  The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client`"
" and control the XML-RPC responses that will be returned from the server. "
"The *use_builtin_types* parameter is passed to the "
":func:`~xmlrpc.client.loads` function and controls which types are processed"
" when date/times values or binary data are received; it defaults to false."
msgstr ""
"创建一个新的实例来处理 CGI 环境中的 XML-RPC 请求。 *allow_none* 和 *encoding* 形参会被传递给 "
":mod:`xmlrpc.client` 并控制将要从服务器返回的 XML-RPC 响应。 *use_builtin_types* 形参会被传递给 "
":func:`~xmlrpc.client.loads` 函数并控制当接收到日期/时间值或二进制数据时要处理哪种类型；该形参默认为假值。"

#: ../../library/xmlrpc.server.rst:68
msgid ""
"Create a new request handler instance.  This request handler supports "
"``POST`` requests and modifies logging so that the *logRequests* parameter "
"to the :class:`SimpleXMLRPCServer` constructor parameter is honored."
msgstr ""
"创建一个新的请求处理器实例。 该请求处理器支持 ``POST`` 请求并会修改日志记录操作以便使用传递给 "
":class:`SimpleXMLRPCServer` 构造器形参的 *logRequests* 形参。"

#: ../../library/xmlrpc.server.rst:76
msgid "SimpleXMLRPCServer Objects"
msgstr "SimpleXMLRPCServer 对象"

#: ../../library/xmlrpc.server.rst:78
msgid ""
"The :class:`SimpleXMLRPCServer` class is based on "
":class:`socketserver.TCPServer` and provides a means of creating simple, "
"stand alone XML-RPC servers."
msgstr ""
":class:`SimpleXMLRPCServer` 类是基于 :class:`socketserver.TCPServer` "
"并提供了一个创建简单、独立的 XML-RPC 服务器的方式。"

#: ../../library/xmlrpc.server.rst:85 ../../library/xmlrpc.server.rst:299
msgid ""
"Register a function that can respond to XML-RPC requests.  If *name* is "
"given, it will be the method name associated with *function*, otherwise "
":attr:`function.__name__` will be used.  *name* is a string, and may contain"
" characters not legal in Python identifiers, including the period character."
msgstr ""
"注册一个可以响应 XML-RPC 请求的函数。 如果给出了 *name*，它将成为与 *function* 相关联的方法名，否则将使用 "
":attr:`function.__name__`。 *name* 是一个字符串，并可能包含不能用于 Python 标识符的字符，包括句点符等。"

#: ../../library/xmlrpc.server.rst:90 ../../library/xmlrpc.server.rst:304
msgid ""
"This method can also be used as a decorator.  When used as a decorator, "
"*name* can only be given as a keyword argument to register *function* under "
"*name*.  If no *name* is given, :attr:`function.__name__` will be used."
msgstr ""
"此方法也可用作装饰器。 当被用作装饰器时，*name* 只能被指定为以 *name* 注册的 *function* 的一个关键字参数。 如果没有指定 "
"*name*，则将使用 :attr:`function.__name__`。"

#: ../../library/xmlrpc.server.rst:94 ../../library/xmlrpc.server.rst:308
msgid ":meth:`register_function` can be used as a decorator."
msgstr ":meth:`register_function` 可被用作装饰器。"

#: ../../library/xmlrpc.server.rst:100
msgid ""
"Register an object which is used to expose method names which have not been "
"registered using :meth:`register_function`.  If *instance* contains a "
":meth:`_dispatch` method, it is called with the requested method name and "
"the parameters from the request.  Its API is ``def _dispatch(self, method, "
"params)`` (note that *params* does not represent a variable argument list)."
"  If it calls an underlying function to perform its task, that function is "
"called as ``func(*params)``, expanding the parameter list. The return value "
"from :meth:`_dispatch` is returned to the client as the result.  If "
"*instance* does not have a :meth:`_dispatch` method, it is searched for an "
"attribute matching the name of the requested method."
msgstr ""
"注册一个被用来公开未使用 :meth:`register_function` 注册的方法名的对象。 如果 *instance* 包含 "
":meth:`_dispatch` 方法，它将被调用并附带被请求的方法名和来自请求的形参。 它的 API 是 ``def _dispatch(self,"
" method, params)`` (请注意 *params* 并不表示变量参数列表)。 如果它调用了一个下层函数来执行任务，该函数将以 "
"``func(*params)`` 的形式被调用，即扩展了形参列表。 来自 :meth:`_dispatch` 的返回值将作为结果被返回给客户端。 如果"
" *instance* 不包含 :meth:`_dispatch` 方法，则会在其中搜索与被请求的方法名相匹配的属性。"

#: ../../library/xmlrpc.server.rst:111
msgid ""
"If the optional *allow_dotted_names* argument is true and the instance does "
"not have a :meth:`_dispatch` method, then if the requested method name "
"contains periods, each component of the method name is searched for "
"individually, with the effect that a simple hierarchical search is "
"performed.  The value found from this search is then called with the "
"parameters from the request, and the return value is passed back to the "
"client."
msgstr ""
"如果可选的 *allow_dotted_names* 参数为真值且该实例没有 :meth:`_dispatch` "
"方法，则如果被请求的方法名包含句点符，会单独搜索该方法名的每个组成部分，其效果就是执行了简单的分层级搜索。 "
"通过搜索找到的值将随即附带来自请求的形参被调用，并且返回值会被回传给客户端。"

#: ../../library/xmlrpc.server.rst:120
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this option on a secure, closed network."
msgstr ""
"启用 *allow_dotted_names* 选项将允许入侵者访问你的模块的全局变量并可能允许入侵者在你的机器上执行任意代码。 "
"仅可在安全、封闭的网络中使用此选项。"

#: ../../library/xmlrpc.server.rst:127
msgid ""
"Registers the XML-RPC introspection functions ``system.listMethods``, "
"``system.methodHelp`` and ``system.methodSignature``."
msgstr ""
"注册 XML-RPC 内省函数 ``system.listMethods``, ``system.methodHelp`` 和 "
"``system.methodSignature``。"

#: ../../library/xmlrpc.server.rst:133
msgid "Registers the XML-RPC multicall function system.multicall."
msgstr "注册 XML-RPC 多调用函数 system.multicall。"

#: ../../library/xmlrpc.server.rst:138
msgid ""
"An attribute value that must be a tuple listing valid path portions of the "
"URL for receiving XML-RPC requests.  Requests posted to other paths will "
"result in a 404 \"no such page\" HTTP error.  If this tuple is empty, all "
"paths will be considered valid. The default value is ``('/', '/RPC2')``."
msgstr ""
"一个必须为元组类型的属性值，其中列出所接收 XML-RPC 请求的有效路径部分。 发送到其他路径的请求将导致 404 \"no such page\" "
"HTTP 错误。 如果此元组为空，则所有路径都将被视为有效。 默认值为 ``('/', '/RPC2')``。"

#: ../../library/xmlrpc.server.rst:147
msgid "SimpleXMLRPCServer Example"
msgstr "SimpleXMLRPCServer 示例"

#: ../../library/xmlrpc.server.rst:148
msgid "Server code::"
msgstr "服务器端代码::"

#: ../../library/xmlrpc.server.rst:150
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# 限制为特定的路径。\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# 创建服务器\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # 注册 pow() 函数；这将使用 pow.__name__ 的值\n"
"    # 作为名称，即 'pow'。\n"
"    server.register_function(pow)\n"
"\n"
"    # 以不同的名称注册一个函数\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # 注册一个实例；该实例的所有方法将发布为\n"
"    # XML-RPC 方法 (在本例中，即为 'mul')。\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # 运行服务器的主循环\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:182
msgid ""
"The following client code will call the methods made available by the "
"preceding server::"
msgstr "以下客户端代码将调用上述服务器所提供的方法::"

#: ../../library/xmlrpc.server.rst:185
msgid ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"
msgstr ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # 返回 2**3 = 8\n"
"print(s.add(2,3))  # 返回 5\n"
"print(s.mul(5,2))  # 返回 5*2 = 10\n"
"\n"
"# 打印可用方法的列表\n"
"print(s.system.listMethods())"

#: ../../library/xmlrpc.server.rst:195
msgid ""
":meth:`register_function` can also be used as a decorator. The previous "
"server example can register functions in a decorator way::"
msgstr ":meth:`register_function` 也可被用作装饰器。 上述服务器端示例可以通过装饰器方式来注册函数::"

#: ../../library/xmlrpc.server.rst:198
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # 注册 pow() 函数；这将使用 pow.__name__ 的值\n"
"    # 作为名称，该值即为 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # 以不同的名称注册一个函数，\n"
"    # 使用 register_function 作为装饰器。\n"
"    # *name* 只能作为关键字参数给出。\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # 以 function.__name__ 为名称注册一个函数。\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:226
msgid ""
"The following example included in the :file:`Lib/xmlrpc/server.py` module "
"shows a server allowing dotted names and registering a multicall function."
msgstr "以下包括在 :file:`Lib/xmlrpc/server.py` 模块中的例子演示了一个允许带点号名称并注册有多调用函数的服务器。"

#: ../../library/xmlrpc.server.rst:231
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this example only within a secure, closed "
"network."
msgstr ""
"启用 *allow_dotted_names* 选项将允许入侵者访问你的模块的全局变量并可能允许入侵者在你的机器上执行任意代码。 "
"仅可在安全、封闭的网络中使用此示例。"

#: ../../library/xmlrpc.server.rst:237
msgid ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"
msgstr ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"

#: ../../library/xmlrpc.server.rst:260
msgid "This ExampleService demo can be invoked from the command line::"
msgstr "这个 ExampleService 演示程序可通过命令行发起调用::"

#: ../../library/xmlrpc.server.rst:262
msgid "python -m xmlrpc.server"
msgstr "python -m xmlrpc.server"

#: ../../library/xmlrpc.server.rst:265
msgid ""
"The client that interacts with the above server is included in "
"``Lib/xmlrpc/client.py``::"
msgstr "可与上述服务器进行交互的客户端包括在 ``Lib/xmlrpc/client.py`` 中::"

#: ../../library/xmlrpc.server.rst:268
msgid ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"
msgstr ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"

#: ../../library/xmlrpc.server.rst:285
msgid ""
"This client which interacts with the demo XMLRPC server can be invoked as::"
msgstr "这个可与示例 XMLRPC 服务器进行交互的客户端的启动方式如下::"

#: ../../library/xmlrpc.server.rst:287
msgid "python -m xmlrpc.client"
msgstr "python -m xmlrpc.client"

#: ../../library/xmlrpc.server.rst:291
msgid "CGIXMLRPCRequestHandler"
msgstr "CGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:293
msgid ""
"The :class:`CGIXMLRPCRequestHandler` class can be used to handle XML-RPC "
"requests sent to Python CGI scripts."
msgstr ""
":class:`CGIXMLRPCRequestHandler` 类可被用来处理发送给 Python CGI 脚本的 XML-RPC 请求。"

#: ../../library/xmlrpc.server.rst:314
msgid ""
"Register an object which is used to expose method names  which have not been"
" registered using :meth:`register_function`. If  instance contains a "
":meth:`_dispatch` method, it is called with the  requested method name and "
"the parameters from the  request; the return value is returned to the client"
" as the result. If instance does not have a :meth:`_dispatch` method, it is "
"searched for an attribute matching the name of the requested method; if  the"
" requested method name contains periods, each  component of the method name "
"is searched for individually,  with the effect that a simple hierarchical "
"search is performed. The value found from this search is then called with "
"the  parameters from the request, and the return value is passed  back to "
"the client."
msgstr ""
"注册一个对象用来公开未使用 :meth:`register_function` 进行注册的方法名。 如果实例包含 :meth:`_dispatch` "
"方法，它会附带所请求的方法名和来自请求的形参被调用；返回值会作为结果被返回给客户端。 如果实例不包含 :meth:`_dispatch` "
"方法，则在其中搜索与所请求方法名相匹配的属性；如果所请求方法名包含句点，则会分别搜索方法名的每个部分，其效果就是执行了简单的层级搜索。 "
"搜索找到的值将附带来自请求的形参被调用，其返回值会被返回给客户端。"

#: ../../library/xmlrpc.server.rst:328
msgid ""
"Register the XML-RPC introspection functions  ``system.listMethods``, "
"``system.methodHelp`` and  ``system.methodSignature``."
msgstr ""
"注册 XML-RPC 内海函数 ``system.listMethods``, ``system.methodHelp`` 和  "
"``system.methodSignature``。"

#: ../../library/xmlrpc.server.rst:334
msgid "Register the XML-RPC multicall function ``system.multicall``."
msgstr "注册 XML-RPC 多调用函数 ``system.multicall``。"

#: ../../library/xmlrpc.server.rst:339
msgid ""
"Handle an XML-RPC request. If *request_text* is given, it should be the POST"
" data provided by the HTTP server,  otherwise the contents of stdin will be "
"used."
msgstr ""
"处理一个 XML-RPC 请求。 如果给出了 *request_text*，它应当是 HTTP 服务器所提供的 POST 数据，否则将使用 stdin "
"的内容。"

#: ../../library/xmlrpc.server.rst:342
msgid "Example::"
msgstr "示例::"

#: ../../library/xmlrpc.server.rst:344
msgid ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"
msgstr ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"

#: ../../library/xmlrpc.server.rst:358
msgid "Documenting XMLRPC server"
msgstr "文档 XMLRPC 服务器"

#: ../../library/xmlrpc.server.rst:360
msgid ""
"These classes extend the above classes to serve HTML documentation in "
"response to HTTP GET requests.  Servers can either be free standing, using "
":class:`DocXMLRPCServer`, or embedded in a CGI environment, using "
":class:`DocCGIXMLRPCRequestHandler`."
msgstr ""
"这些类扩展了上面的类以发布响应 HTTP GET 请求的 HTML 文档。 服务器可以是独立的，使用 "
":class:`DocXMLRPCServer`，或是嵌入某个 CGI 环境中，使用 "
":class:`DocCGIXMLRPCRequestHandler`。"

#: ../../library/xmlrpc.server.rst:370
msgid ""
"Create a new server instance. All parameters have the same meaning as for "
":class:`SimpleXMLRPCServer`; *requestHandler* defaults to "
":class:`DocXMLRPCRequestHandler`."
msgstr ""
"创建一个新的服务器实例。 所有形参的含义与 :class:`SimpleXMLRPCServer` 的相同；*requestHandler* 默认为 "
":class:`DocXMLRPCRequestHandler`。"

#: ../../library/xmlrpc.server.rst:380
msgid "Create a new instance to handle XML-RPC requests in a CGI environment."
msgstr "创建一个新的实例来处理 CGI 环境中的 XML-RPC 请求。"

#: ../../library/xmlrpc.server.rst:385
msgid ""
"Create a new request handler instance. This request handler supports XML-RPC"
" POST requests, documentation GET requests, and modifies logging so that the"
" *logRequests* parameter to the :class:`DocXMLRPCServer` constructor "
"parameter is honored."
msgstr ""
"创建一个新的请求处理器实例。 该请求处理器支持 XML-RPC POST 请求、文档 GET 请求并会修改日志记录操作以便使用传递给 "
":class:`DocXMLRPCServer` 构造器形参的 *logRequests* 形参。"

#: ../../library/xmlrpc.server.rst:394
msgid "DocXMLRPCServer Objects"
msgstr "DocXMLRPCServer 对象"

#: ../../library/xmlrpc.server.rst:396
msgid ""
"The :class:`DocXMLRPCServer` class is derived from "
":class:`SimpleXMLRPCServer` and provides a means of creating self-"
"documenting, stand alone XML-RPC servers. HTTP POST requests are handled as "
"XML-RPC method calls. HTTP GET requests are handled by generating pydoc-"
"style HTML documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
":class:`DocXMLRPCServer` 类派生自 :class:`SimpleXMLRPCServer` "
"并提供了一种创建自动记录文档的、独立的 XML-RPC 服务器的方式。 HTTP POST 请求将作为 XML-RPC 方法调用来处理。 HTTP "
"GET 请求将通过生成 pydoc 风格的 HTML 文档来处理。 这将允许服务器自己提供基于 Web 的文档。"

#: ../../library/xmlrpc.server.rst:405 ../../library/xmlrpc.server.rst:433
msgid ""
"Set the title used in the generated HTML documentation. This title will be "
"used inside the HTML \"title\" element."
msgstr "设置所生成 HTML 文档要使用的标题。 此标题将在 HTML \"title\" 元素中使用。"

#: ../../library/xmlrpc.server.rst:411 ../../library/xmlrpc.server.rst:439
msgid ""
"Set the name used in the generated HTML documentation. This name will appear"
" at the top of the generated documentation inside a \"h1\" element."
msgstr "设置所生成 HTML 文档要使用的名称。 此名称将出现在所生成文档顶部的 \"h1\" 元素中。"

#: ../../library/xmlrpc.server.rst:417 ../../library/xmlrpc.server.rst:445
msgid ""
"Set the description used in the generated HTML documentation. This "
"description will appear as a paragraph, below the server name, in the "
"documentation."
msgstr ""
"设置所生成Set the description used in the generated HTML 文档要使用的描述。 "
"此描述将显示为文档中的一个段落，位于服务器名称之下。"

#: ../../library/xmlrpc.server.rst:422
msgid "DocCGIXMLRPCRequestHandler"
msgstr "DocCGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:424
msgid ""
"The :class:`DocCGIXMLRPCRequestHandler` class is derived from "
":class:`CGIXMLRPCRequestHandler` and provides a means of creating self-"
"documenting, XML-RPC CGI scripts. HTTP POST requests are handled as XML-RPC "
"method calls. HTTP GET requests are handled by generating pydoc-style HTML "
"documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
":class:`DocCGIXMLRPCRequestHandler` 类派生自 :class:`CGIXMLRPCRequestHandler` "
"并提供了一种创建自动记录文档的 XML-RPC CGI 脚本的方式。 HTTP POST 请求将作为 XML-RPC 方法调用来处理。 HTTP GET"
" 请求将通过生成 pydoc 风格的 HTML 文档来处理。 这将允许服务器自己提供基于 Web 的文档。"
