# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# Konge <zkonge@outlook.com>, 2021
# Wu Pipi, 2021
# Sean Chao <seanchao0804@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-23 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/io.rst:2
msgid ":mod:`!io` --- Core tools for working with streams"
msgstr ":mod:`!io` --- 处理流的核心工具"

#: ../../library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**源代码:** :source:`Lib/io.py`"

#: ../../library/io.rst:22
msgid "Overview"
msgstr "概述"

#: ../../library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to"
" any of these categories is called a :term:`file object`.  Other common "
"terms are *stream* and *file-like object*."
msgstr ""
":mod:`io` 模块提供了 Python 用于处理各种 I/O 类型的主要工具。三种主要的 I/O类型分别为: *文本 I/O*, *二进制 "
"I/O* 和 *原始 I/O*。这些是泛型类型，有很多种后端存储可以用在他们上面。一个隶属于任何这些类型的具体对象被称作 :term:`file "
"object`。 其他同类的术语还有 *流* 和 *类文件对象*。"

#: ../../library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can"
" also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or"
" pipe)."
msgstr ""
"独立于其类别，每个具体流对象也将具有各种功能：它可以是只读，只写或读写。它还可以允许任意随机访问（向前或向后寻找任何位置），或仅允许顺序访问（例如在套接字或管道的情况下）。"

#: ../../library/io.rst:40
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the :meth:`!write` method of a "
"binary stream will raise a :exc:`TypeError`.  So will giving a "
":class:`bytes` object to the :meth:`!write` method of a text stream."
msgstr ""
"所有流对提供给它们的数据类型都很敏感。 例如将 :class:`str` 对象提供给二进制流的 :meth:`!write` 方法将引发 "
":exc:`TypeError`。 将 :class:`bytes` 对象提供给文本流的 :meth:`!write` 方法也是如此。"

#: ../../library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, since"
" :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"由于 :exc:`IOError` 现在是 :exc:`OSError` 的别名，因此用于引发 :exc:`IOError` 的操作现在会引发 "
":exc:`OSError` 。"

#: ../../library/io.rst:51 ../../library/io.rst:867 ../../library/io.rst:1217
msgid "Text I/O"
msgstr "文本 I/O"

#: ../../library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of"
" a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"文本I/O预期并生成 :class:`str` "
"对象。这意味着，无论何时后台存储是由字节组成的（例如在文件的情况下），数据的编码和解码都是透明的，并且可以选择转换特定于平台的换行符。"

#: ../../library/io.rst:58
msgid ""
"The easiest way to create a text stream is with :meth:`open`, optionally "
"specifying an encoding::"
msgstr "创建文本流的最简单方式是通过 :meth:`open`，并可选择指定编码格式::"

#: ../../library/io.rst:61
msgid "f = open(\"myfile.txt\", \"r\", encoding=\"utf-8\")"
msgstr "f = open(\"myfile.txt\", \"r\", encoding=\"utf-8\")"

#: ../../library/io.rst:63
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr "内存中文本流也可以作为 :class:`StringIO` 对象使用："

#: ../../library/io.rst:65
msgid "f = io.StringIO(\"some initial text data\")"
msgstr "f = io.StringIO(\"some initial text data\")"

#: ../../library/io.rst:69
msgid ""
"When working with a non-blocking stream, be aware that read operations on "
"text I/O objects might raise a :exc:`BlockingIOError` if the stream cannot "
"perform the operation immediately."
msgstr ""

#: ../../library/io.rst:73
msgid ""
"The text stream API is described in detail in the documentation of "
":class:`TextIOBase`."
msgstr ":class:`TextIOBase` 的文档中详细描述了文本流的API"

#: ../../library/io.rst:78 ../../library/io.rst:1205
msgid "Binary I/O"
msgstr "二进制 I/O"

#: ../../library/io.rst:80
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can"
" be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"二进制I/O（也称为缓冲I/O）预期 :term:`bytes-like objects <bytes-like object>` 并生成  "
":class:`bytes` 对象。不执行编码、解码或换行转换。这种类型的流可以用于所有类型的非文本数据，并且还可以在需要手动控制文本数据的处理时使用。"

#: ../../library/io.rst:86
msgid ""
"The easiest way to create a binary stream is with :meth:`open` with ``'b'`` "
"in the mode string::"
msgstr "创建二进制流的最简单方式是通过 :meth:`open` 并在模式字符串中使用 ``'b'``::"

#: ../../library/io.rst:89
msgid "f = open(\"myfile.jpg\", \"rb\")"
msgstr "f = open(\"myfile.jpg\", \"rb\")"

#: ../../library/io.rst:91
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr "内存中二进制流也可以作为 :class:`BytesIO` 对象使用："

#: ../../library/io.rst:93
msgid "f = io.BytesIO(b\"some initial binary data: \\x00\\x01\")"
msgstr "f = io.BytesIO(b\"some initial binary data: \\x00\\x01\")"

#: ../../library/io.rst:95
msgid ""
"The binary stream API is described in detail in the docs of "
":class:`BufferedIOBase`."
msgstr ":class:`BufferedIOBase` 的文档中详细描述了二进制流 API。"

#: ../../library/io.rst:98
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr "其他库模块可以提供额外的方式来创建文本或二进制流。参见 :meth:`socket.socket.makefile` 的示例。"

#: ../../library/io.rst:103
msgid "Raw I/O"
msgstr "原始 I/O"

#: ../../library/io.rst:105
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"原始 I/O（也称为 *非缓冲 "
"I/O*）通常用作二进制和文本流的低级构建块。用户代码直接操作原始流的用法非常罕见。不过，可以通过在禁用缓冲的情况下以二进制模式打开文件来创建原始流："

#: ../../library/io.rst:110
msgid "f = open(\"myfile.jpg\", \"rb\", buffering=0)"
msgstr "f = open(\"myfile.jpg\", \"rb\", buffering=0)"

#: ../../library/io.rst:112
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr ":class:`RawIOBase` 的文档中详细描述了原始流的API"

#: ../../library/io.rst:118
msgid "Text Encoding"
msgstr "文本编码格式"

#: ../../library/io.rst:120
msgid ""
"The default encoding of :class:`TextIOWrapper` and :func:`open` is locale-"
"specific (:func:`locale.getencoding`)."
msgstr ""
":class:`TextIOWrapper` 和 :func:`open` 的默认编码格式取决于语言区域的设置 "
"(:func:`locale.getencoding`)。"

#: ../../library/io.rst:123
msgid ""
"However, many developers forget to specify the encoding when opening text "
"files encoded in UTF-8 (e.g. JSON, TOML, Markdown, etc...) since most Unix "
"platforms use UTF-8 locale by default. This causes bugs because the locale "
"encoding is not UTF-8 for most Windows users. For example::"
msgstr ""
"但是，很多开发者在打开以 UTF-8 编码的文本文件 (例如 JSON, TOML, Markdown 等等...) 时会忘记指定编码格式，因为大多数 "
"Unix 平台默认使用 UTF-8 语言区域。  这会导致各种错误因为大多数 Windows 用户的语言区域编码格式并不是 UTF-8。 例如::"

#: ../../library/io.rst:128
msgid ""
"# May not work on Windows when non-ASCII characters in the file.\n"
"with open(\"README.md\") as f:\n"
"    long_description = f.read()"
msgstr ""
"# 当文件中有非 ASCII 字符时可能无法在 Windows 下使用。\n"
"with open(\"README.md\") as f:\n"
"    long_description = f.read()"

#: ../../library/io.rst:132
msgid ""
"Accordingly, it is highly recommended that you specify the encoding "
"explicitly when opening text files. If you want to use UTF-8, pass "
"``encoding=\"utf-8\"``. To use the current locale encoding, "
"``encoding=\"locale\"`` is supported since Python 3.10."
msgstr ""
"为此，强烈建议你在打开文本文件时显式地指定编码格式。 如果你想要使用 UTF-8，就传入 ``encoding=\"utf-8\"``。 "
"要使用当前语言区域的编码格式，``encoding=\"locale\"`` 自 Python 3.10 开始已被支持。"

#: ../../library/io.rst:139
msgid ":ref:`utf8-mode`"
msgstr ":ref:`utf8-mode`"

#: ../../library/io.rst:140
msgid ""
"Python UTF-8 Mode can be used to change the default encoding to UTF-8 from "
"locale-specific encoding."
msgstr "Python UTF-8 模式可以用来将默认编码格式由语言区域所确定的编码格式改为 UTF-8。"

#: ../../library/io.rst:143
msgid ":pep:`686`"
msgstr ":pep:`686`"

#: ../../library/io.rst:144
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr "Python 3.15 将把 :ref:`utf8-mode` 设为默认值。"

#: ../../library/io.rst:149
msgid "Opt-in EncodingWarning"
msgstr "选择性的 EncodingWarning"

#: ../../library/io.rst:151
msgid "See :pep:`597` for more details."
msgstr "请参阅 :pep:`597` 了解详情。"

#: ../../library/io.rst:154
msgid ""
"To find where the default locale encoding is used, you can enable the "
":option:`-X warn_default_encoding <-X>` command line option or set the "
":envvar:`PYTHONWARNDEFAULTENCODING` environment variable, which will emit an"
" :exc:`EncodingWarning` when the default encoding is used."
msgstr ""
"要找出哪里使用了默认语言区域的编码格式，你可以启用 :option:`-X warn_default_encoding <-X>` 命令行选项或设置 "
":envvar:`PYTHONWARNDEFAULTENCODING` 环境变量，这将在使用默认编码格式时发出 "
":exc:`EncodingWarning`。"

#: ../../library/io.rst:159
msgid ""
"If you are providing an API that uses :func:`open` or :class:`TextIOWrapper`"
" and passes ``encoding=None`` as a parameter, you can use "
":func:`text_encoding` so that callers of the API will emit an "
":exc:`EncodingWarning` if they don't pass an ``encoding``. However, please "
"consider using UTF-8 by default (i.e. ``encoding=\"utf-8\"``) for new APIs."
msgstr ""
"如果你提供了使用 :func:`open` 或 :class:`TextIOWrapper` 的 API 并将 ``encoding=None`` "
"作为形参传入，你可以使用 :func:`text_encoding` 以便  API 的调用方在没有传入 ``encoding`` 的时候将发出 "
":exc:`EncodingWarning`。 但是，对于新的 API 请考虑默认就使用 UTF-8 (即 "
"``encoding=\"utf-8\"``)。"

#: ../../library/io.rst:168
msgid "High-level Module Interface"
msgstr "高阶模块接口"

#: ../../library/io.rst:172
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by "
":func:`os.stat`) if possible."
msgstr ""
"包含模块缓冲 I/O 类使用的默认缓冲区大小的 int。 在可能的情况下 :func:`open` 将使用文件的 blksize（由 "
":func:`os.stat` 获得）。"

#: ../../library/io.rst:179
msgid "This is an alias for the builtin :func:`open` function."
msgstr "这是内置的 :func:`open` 函数的别名。"

#: ../../library/io.rst:181 ../../library/io.rst:183
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments *path*, *mode* and *flags*. The *mode* and *flags* arguments may "
"have been modified or inferred from the original call."
msgstr ""
"此函数将引发一个 :ref:`审计事件 <auditing>` ``open`` 并附带参数 *path*, *mode* 和 *flags*。 "
"*mode* 和 *flags* 参数可能在原始调用的基础上修改或推断得到。"

#: ../../library/io.rst:190
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr "以 ``'rb'`` 模式打开提供的文件。如果目的是将文件内容做为可执行代码，则应使用此函数。"

#: ../../library/io.rst:193
msgid "*path* should be a :class:`str` and an absolute path."
msgstr "*path* 应当为 :class:`str` 类型并且是一个绝对路径。"

#: ../../library/io.rst:195
msgid ""
"The behavior of this function may be overridden by an earlier call to the "
":c:func:`PyFile_SetOpenCodeHook`. However, assuming that *path* is a "
":class:`str` and an absolute path, ``open_code(path)`` should always behave "
"the same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""
"该函数的行为可通过先期调用 :c:func:`PyFile_SetOpenCodeHook` 来重写。 不过，假如 *path* 为 "
":class:`str` 类型并且是一个绝对路径，``open_code(path)`` 的行为应当总是与 ``open(path, 'rb')`` "
"一致。 重写行为的目的是为了给文件附加额外的验证或预处理。"

#: ../../library/io.rst:206
msgid ""
"This is a helper function for callables that use :func:`open` or "
":class:`TextIOWrapper` and have an ``encoding=None`` parameter."
msgstr ""
"这是一个针对使用 :func:`open` 或 :class:`TextIOWrapper` 的可调用对象的辅助函数并且具有 "
"``encoding=None`` 形参。"

#: ../../library/io.rst:209
msgid ""
"This function returns *encoding* if it is not ``None``. Otherwise, it "
"returns ``\"locale\"`` or ``\"utf-8\"`` depending on :ref:`UTF-8 Mode "
"<utf8-mode>`."
msgstr ""
"如果 *encoding* 不为 ``None`` 则将其返回。 还其他情况下，它将根据是否启用了 :ref:`UTF-8 模式 "
"<utf8-mode>` 返回 ``\"locale\"`` 或 ``\"utf-8\"``。"

#: ../../library/io.rst:213
msgid ""
"This function emits an :class:`EncodingWarning` if "
":data:`sys.flags.warn_default_encoding <sys.flags>` is true and *encoding* "
"is ``None``. *stacklevel* specifies where the warning is emitted. For "
"example::"
msgstr ""
"如果 :data:`sys.flags.warn_default_encoding <sys.flags>` 为真值且 *encoding* 为 "
"``None`` 则此函数会发出 :class:`EncodingWarning`。 *stacklevel* 指明警告在哪里发出。 例如::"

#: ../../library/io.rst:218
msgid ""
"def read_text(path, encoding=None):\n"
"    encoding = io.text_encoding(encoding)  # stacklevel=2\n"
"    with open(path, encoding) as f:\n"
"        return f.read()"
msgstr ""
"def read_text(path, encoding=None):\n"
"    encoding = io.text_encoding(encoding)  # stacklevel=2\n"
"    with open(path, encoding) as f:\n"
"        return f.read()"

#: ../../library/io.rst:223
msgid ""
"In this example, an :class:`EncodingWarning` is emitted for the caller of "
"``read_text()``."
msgstr "在这个例子中，将为 ``read_text()`` 的调用方发出 :class:`EncodingWarning`。"

#: ../../library/io.rst:226
msgid "See :ref:`io-text-encoding` for more information."
msgstr "请参阅 :ref:`io-text-encoding` 了解更多信息。"

#: ../../library/io.rst:230
msgid ""
":func:`text_encoding` returns \"utf-8\" when UTF-8 mode is enabled and "
"*encoding* is ``None``."
msgstr ""
"当启用 UTF-8 模式且 *encoding* 为 ``None`` 时 :func:`text_encoding` 将返回 \"utf-8\"。"

#: ../../library/io.rst:237
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr "这是内置的 :exc:`BlockingIOError` 异常的兼容性别名。"

#: ../../library/io.rst:243
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr "在流上调用不支持的操作时引发的继承 :exc:`OSError` 和 :exc:`ValueError` 的异常。"

#: ../../library/io.rst:249
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../../library/io.rst:250
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, and"
" :data:`sys.stderr`."
msgstr "包含标准IO流: :data:`sys.stdin`, :data:`sys.stdout` 和 :data:`sys.stderr` 。"

#: ../../library/io.rst:255
msgid "Class hierarchy"
msgstr "类的层次结构"

#: ../../library/io.rst:257
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"I/O 流被安排为按类的层次结构实现。 首先是 :term:`抽象基类 <abstract base class>` "
"(ABC)，用于指定流的各种类别，然后是提供标准流实现的具体类。"

#: ../../library/io.rst:264
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of "
":meth:`!readinto` and :meth:`!readline`."
msgstr ""
"这些抽象基类还提供了一些方法的默认实现，以帮助实现具体的流类。 例如，:class:`BufferedIOBase` 提供了 "
":meth:`!readinto` 和 :meth:`!readline` 的未优化实现。"

#: ../../library/io.rst:269
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`."
"  It defines the basic interface to a stream.  Note, however, that there is "
"no separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"I/O层次结构的顶部是抽象基类 :class:`IOBase` "
"。它定义了流的基本接口。但是请注意，对流的读取和写入之间没有分离。如果实现不支持指定的操作，则会引发 "
":exc:`UnsupportedOperation` 。"

#: ../../library/io.rst:274
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses "
":class:`RawIOBase` to provide an interface to files in the machine's file "
"system."
msgstr ""
"抽象基类 :class:`RawIOBase` 是 :class:`IOBase` 的子类。它负责将字节读取和写入流中。 "
":class:`RawIOBase` 的子类 :class:`FileIO` 提供计算机文件系统中文件的接口。"

#: ../../library/io.rst:278
msgid ""
"The :class:`BufferedIOBase` ABC extends :class:`IOBase`.  It deals with "
"buffering on a raw binary stream (:class:`RawIOBase`).  Its subclasses, "
":class:`BufferedWriter`, :class:`BufferedReader`, and "
":class:`BufferedRWPair` buffer raw binary streams that are writable, "
"readable, and both readable and writable, respectively. "
":class:`BufferedRandom` provides a buffered interface to seekable streams. "
"Another :class:`BufferedIOBase` subclass, :class:`BytesIO`, is a stream of "
"in-memory bytes."
msgstr ""
"抽象基类 :class:`BufferedIOBase` 扩展了 :class:`IOBase`。 它能处理原始二进制流 "
"(:class:`RawIOBase`) 上的缓冲。 它的子类 :class:`BufferedWriter`, "
":class:`BufferedReader` 和 :class:`BufferedRWPair` 分别缓冲可写、可读以及同时可读写的原始二进制流。 "
":class:`BufferedRandom` 提供了带缓冲的可随机访问接口。 :class:`BufferedIOBase` 的另一子类 "
":class:`BytesIO` 是内存中字节流。"

#: ../../library/io.rst:286
msgid ""
"The :class:`TextIOBase` ABC extends :class:`IOBase`.  It deals with streams "
"whose bytes represent text, and handles encoding and decoding to and from "
"strings.  :class:`TextIOWrapper`, which extends :class:`TextIOBase`, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`)."
"  Finally, :class:`StringIO` is an in-memory stream for text."
msgstr ""
"抽象基类 :class:`TextIOBase` 继承了 :class:`IOBase` 。它处理可表示文本的流，并处理字符串的编码和解码。类 "
":class:`TextIOWrapper` 继承了 :class:`TextIOBase` ，是原始缓冲流（ "
":class:`BufferedIOBase` ）的缓冲文本接口。最后， :class:`StringIO` 是文本的内存流。"

#: ../../library/io.rst:292
msgid ""
"Argument names are not part of the specification, and only the arguments of "
":func:`open` are intended to be used as keyword arguments."
msgstr "参数名不是规范的一部分，只有 :func:`open` 的参数才用作关键字参数。"

#: ../../library/io.rst:295
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr "下表总结了抽象基类提供的 :mod:`io` 模块："

#: ../../library/io.rst:300
msgid "ABC"
msgstr "抽象基类"

#: ../../library/io.rst:300
msgid "Inherits"
msgstr "继承"

#: ../../library/io.rst:300
msgid "Stub Methods"
msgstr "抽象方法"

#: ../../library/io.rst:300
msgid "Mixin Methods and Properties"
msgstr "Mixin方法和属性"

#: ../../library/io.rst:302 ../../library/io.rst:307 ../../library/io.rst:309
#: ../../library/io.rst:311
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../../library/io.rst:302
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``, ``seek``, 和 ``truncate``"

#: ../../library/io.rst:302
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable`` 和 ``writelines``"

#: ../../library/io.rst:307
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../../library/io.rst:307
msgid "``readinto`` and ``write``"
msgstr "``readinto`` 和 ``write``"

#: ../../library/io.rst:307
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "继承 :class:`IOBase` 方法, ``read``, 和 ``readall``"

#: ../../library/io.rst:309
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../../library/io.rst:309
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``, ``read``, ``read1``, 和 ``write``"

#: ../../library/io.rst:309
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "继承 :class:`IOBase` 方法, ``readinto``, 和 ``readinto1``"

#: ../../library/io.rst:311
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../../library/io.rst:311
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``, ``read``, ``readline``, 和 ``write``"

#: ../../library/io.rst:311
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and "
"``newlines``"
msgstr "继承 :class:`IOBase` 方法, ``encoding``, ``errors``, 和 ``newlines``"

#: ../../library/io.rst:318
msgid "I/O Base Classes"
msgstr "I/O 基类"

#: ../../library/io.rst:322
msgid "The abstract base class for all I/O classes."
msgstr "所有 I/O 类的抽象基类。"

#: ../../library/io.rst:324
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr "此类为许多方法提供了空的抽象实现，派生类可以有选择地重写。默认实现代表一个无法读取、写入或查找的文件。"

#: ../../library/io.rst:329
msgid ""
"Even though :class:`IOBase` does not declare :meth:`!read` or :meth:`!write`"
" because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""
"尽管 :class:`IOBase` 并未声明 :meth:`!read` 或 "
":meth:`!write`，因为它们的签名会有所不同，但是实现和客户端应该将这些方法视为接口的一部分。 此外，当调用不支持的操作时实现可能会引发 "
":exc:`ValueError` (或 :exc:`UnsupportedOperation`)。"

#: ../../library/io.rst:335
msgid ""
"The basic type used for binary data read from or written to a file is "
":class:`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are "
"accepted as method arguments too.  Text I/O classes work with :class:`str` "
"data."
msgstr ""
"从文件读取或写入文件的二进制数据的基本类型为 :class:`bytes` 。其他 :term:`bytes-like objects <bytes-"
"like object>` 也可以作为方法参数。文本I/O类使用 :class:`str` 数据。"

#: ../../library/io.rst:339
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"请注意，在关闭的流上调用任何方法（甚至查询）都是未定义的（undefined）。在这种情况下，实现可能会引发 :exc:`ValueError` 。"

#: ../../library/io.rst:342
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning"
" that an :class:`IOBase` object can be iterated over yielding the lines in a"
" stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase` （及其子类）支持迭代器协议，这意味着可以迭代 :class:`IOBase` "
"对象以产生流中的行。根据流是二进制流（产生字节）还是文本流（产生字符串），行的定义略有不同。请参见下面的 "
":meth:`~IOBase.readline` 。"

#: ../../library/io.rst:348
msgid ""
":class:`IOBase` is also a context manager and therefore supports the "
":keyword:`with` statement.  In this example, *file* is closed after the "
":keyword:`!with` statement's suite is finished---even if an exception "
"occurs::"
msgstr ""
":class:`IOBase` 也是一个上下文管理器，因此支持 :keyword:`with` 语句。 在这个示例中，*file* 将在 "
":keyword:`!with` 语句块执行完成之后被关闭 --- 即使是发生了异常::"

#: ../../library/io.rst:352
msgid ""
"with open('spam.txt', 'w') as file:\n"
"    file.write('Spam and eggs!')"
msgstr ""
"with open('spam.txt', 'w') as file:\n"
"    file.write('Spam and eggs!')"

#: ../../library/io.rst:355
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` 提供以下数据属性和方法："

#: ../../library/io.rst:359
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"刷新并关闭此流。如果文件已经关闭，则此方法无效。文件关闭后，对文件的任何操作（例如读取或写入）都会引发 :exc:`ValueError` 。"

#: ../../library/io.rst:363
msgid ""
"As a convenience, it is allowed to call this method more than once; only the"
" first call, however, will have an effect."
msgstr "为方便起见，允许多次调用此方法。但是，只有第一个调用才会生效。"

#: ../../library/io.rst:368
msgid "``True`` if the stream is closed."
msgstr "如果流已关闭，则返回 True。"

#: ../../library/io.rst:372
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr "返回流的底层文件描述符（整数）---如果存在。如果 IO 对象不使用文件描述符，则会引发 :exc:`OSError` 。"

#: ../../library/io.rst:378
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr "刷新流的写入缓冲区（如果适用）。这对只读和非阻塞流不起作用。"

#: ../../library/io.rst:383
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a "
"terminal/tty device)."
msgstr "如果流是交互式的（即连接到终端/tty设备），则返回 ``True`` 。"

#: ../../library/io.rst:388
msgid ""
"Return ``True`` if the stream can be read from. If ``False``, :meth:`!read` "
"will raise :exc:`OSError`."
msgstr ""
"如果可以读取流则返回 ``True``。 如果返回 ``False``，则 :meth:`!read` 将引发 :exc:`OSError`。"

#: ../../library/io.rst:393
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr "从流中读取并返回一行。如果指定了 *size*，将至多读取 *size* 个字节。"

#: ../../library/io.rst:396
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"对于二进制文件行结束符总是 ``b'\\n'``；对于文本文件，可以用将 *newline* 参数传给 :func:`open` "
"的方式来选择要识别的行结束符。"

#: ../../library/io.rst:402
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to"
" control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"从流中读取并返回包含多行的列表。可以指定 *hint* 来控制要读取的行数：如果（以字节/字符数表示的）所有行的总大小超出了 *hint* "
"则将不会读取更多的行。"

#: ../../library/io.rst:406
msgid ""
"*hint* values of ``0`` or less, as well as ``None``, are treated as no hint."
msgstr "``0`` 或更小的 *hint* 值以及 ``None``，会被视为没有 hint。"

#: ../../library/io.rst:409
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling :meth:`!file.readlines`."
msgstr ""
"请注意，在不调用 :meth:`!file.readlines` 的情况下使用 ``for line in file: ...`` "
"来遍历文件对象已经成为可能。"

#: ../../library/io.rst:414
msgid ""
"Change the stream position to the given byte *offset*, interpreted relative "
"to the position indicated by *whence*, and return the new absolute position."
" Values for *whence* are:"
msgstr ""
"将流位置修改到给定的字节 *offset*，它将相对于 *whence* 所指明的位置进行解析，并返回新的绝对位置。 *whence* 的可用值有:"

#: ../../library/io.rst:419
msgid ""
":data:`os.SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ":data:`os.SEEK_SET` 或 ``0`` -- 流的开头（默认值；*offset* 应为零或正值"

#: ../../library/io.rst:421
msgid ""
":data:`os.SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`os.SEEK_CUR` 或 ``1`` -- 当前流位置；*offset* 可以为负值"

#: ../../library/io.rst:423
msgid ""
":data:`os.SEEK_END` or ``2`` -- end of the stream; *offset* is usually "
"negative"
msgstr ":data:`os.SEEK_END` 或 ``2`` -- 流的末尾；*offset* 通常为负值"

#: ../../library/io.rst:426 ../../library/io.rst:943
msgid "The :data:`!SEEK_*` constants."
msgstr ":data:`!SEEK_*` 常量。"

#: ../../library/io.rst:429
msgid ""
"Some operating systems could support additional values, like "
":const:`os.SEEK_HOLE` or :const:`os.SEEK_DATA`. The valid values for a file "
"could depend on it being open in text or binary mode."
msgstr ""
"某些操作系统还可支持其他的值，如 :const:`os.SEEK_HOLE` 或 :const:`os.SEEK_DATA`。 "
"特定文件的可用值还会取决于它是以文本还是二进制模式打开。"

#: ../../library/io.rst:436
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, "
":meth:`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果流支持随机访问则返回 ``True``。 如为 ``False``，则 :meth:`seek`, :meth:`tell` 和 "
":meth:`truncate` 将引发 :exc:`OSError`。"

#: ../../library/io.rst:441
msgid "Return the current stream position."
msgstr "返回当前流的位置。"

#: ../../library/io.rst:445
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"将流的大小调整为给定的 *size* 个字节（如果未指定 *size* 则调整至当前位置）。 当前的流位置不变。 这个调整操作可扩展或减小当前文件大小。"
" 在扩展的情况下，新文件区域的内容取决于具体平台（在大多数系统上，额外的字节会填充为零）。 返回新的文件大小。"

#: ../../library/io.rst:452
msgid "Windows will now zero-fill files when extending."
msgstr "现在Windows在扩展时将文件填充为零。"

#: ../../library/io.rst:457
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, "
":meth:`!write` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果流支持写入则返回 ``True``。 如为 ``False``，则 :meth:`!write` 和 :meth:`truncate` 将引发 "
":exc:`OSError`。"

#: ../../library/io.rst:462
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr "将行列表写入到流。 不会添加行分隔符，因此通常所提供的每一行都带有末尾行分隔符。"

#: ../../library/io.rst:468
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's "
":meth:`~IOBase.close` method."
msgstr ""
"为对象销毁进行准备。 :class:`IOBase` 提供了此方法的默认实现，该实现会调用实例的 :meth:`~IOBase.close` 方法。"

#: ../../library/io.rst:475
msgid "Base class for raw binary streams.  It inherits from :class:`IOBase`."
msgstr "原始二进制流的基类。 它继承自 :class:`IOBase`。"

#: ../../library/io.rst:477
msgid ""
"Raw binary streams typically provide low-level access to an underlying OS "
"device or API, and do not try to encapsulate it in high-level primitives "
"(this functionality is done at a higher-level in buffered binary streams and"
" text streams, described later in this page)."
msgstr ""
"原始二进制流通常会提供对下层 OS 设备或 API "
"的低层级访问，而不是尝试将其封装到高层级的基元中（此功能是在更高层级的缓冲二进制流和文本流中实现的，将在下文中描述）。"

#: ../../library/io.rst:482
msgid ""
":class:`RawIOBase` provides these methods in addition to those from "
":class:`IOBase`:"
msgstr ":class:`RawIOBase` 在 :class:`IOBase` 的现有成员以外还提供了下列方法:"

#: ../../library/io.rst:487
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise,"
" only one system call is ever made.  Fewer than *size* bytes may be returned"
" if the operating system call returns fewer than *size* bytes."
msgstr ""
"从对象中读取 *size* 个字节并将其返回。 作为一个便捷选项，如果 *size* 未指定或为 -1，则返回所有字节直到 EOF。 "
"在其他情况下，仅会执行一次系统调用。 如果操作系统调用返回字节数少于 *size* 则此方法也可能返回少于 *size* 个字节。"

#: ../../library/io.rst:492
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr "如果返回 0 个字节而 *size* 不为零 0，这表明到达文件末尾。 如果处于非阻塞模式并且没有更多字节可用，则返回 ``None``。"

#: ../../library/io.rst:496
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr "默认实现会转至 :meth:`readall` 和 :meth:`readinto`。"

#: ../../library/io.rst:501
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "从流中读取并返回所有字节直到 EOF，如有必要将对流执行多次调用。"

#: ../../library/io.rst:506
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and"
" return the number of bytes read.  For example, *b* might be a "
":class:`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"将字节数据读入预先分配的可写 :term:`bytes-like object` *b*，并返回所读取的字节数。 例如，*b* 可以是一个 "
":class:`bytearray`。 如果对象处理非阻塞模式并且没有更多字节可用，则返回 ``None``。"

#: ../../library/io.rst:514
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream,"
" and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"将给定的 :term:`bytes-like object` *b* 写入到下层的原始流，并返回所写入的字节数。 这可以少于 *b* "
"的总字节数，具体取决于下层原始流的设定，特别是如果它处于非阻塞模式的话。 如果原始流设为非阻塞并且不能真正向其写入单个字节时则返回 ``None``。 "
"调用者可以在此方法返回后释放或改变 *b*，因此该实现应该仅在方法调用期间访问 *b*。"

#: ../../library/io.rst:527
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits from :class:`IOBase`."
msgstr "支持某种缓冲的二进制流的基类。 它继承自 :class:`IOBase`。"

#: ../../library/io.rst:530
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, "
":meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to emit all provided data."
msgstr ""

#: ../../library/io.rst:534
msgid ""
"In addition, if the underlying raw stream is in non-blocking mode, when the "
"system returns would block :meth:`write` will raise :exc:`BlockingIOError` "
"with :attr:`BlockingIOError.characters_written` and :meth:`read` will return"
" data read so far or ``None`` if no data is available."
msgstr ""

#: ../../library/io.rst:539
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that"
" defers to :meth:`readinto`."
msgstr "并且，:meth:`read` 方法也没有转向 :meth:`readinto` 的默认实现。"

#: ../../library/io.rst:542
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a "
":class:`RawIOBase` implementation, but wrap one, like "
":class:`BufferedWriter` and :class:`BufferedReader` do."
msgstr ""
"典型的 :class:`BufferedIOBase` 实现不应当继承自 :class:`RawIOBase` 实现，而要包装一个该实现，正如 "
":class:`BufferedWriter` 和 :class:`BufferedReader` 所做的那样。"

#: ../../library/io.rst:546
msgid ""
":class:`BufferedIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ":class:`BufferedIOBase` 在 :class:`IOBase` 的现有成员以外还提供或重写了下列数据属性和方法:"

#: ../../library/io.rst:551
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that "
":class:`BufferedIOBase` deals with.  This is not part of the "
":class:`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"由 :class:`BufferedIOBase` 处理的下层原始流 (:class:`RawIOBase` 的实例)。 它不是 "
":class:`BufferedIOBase` API 的组成部分并且不存在于某些实现中。"

#: ../../library/io.rst:557
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "从缓冲区分离出下层原始流并将其返回。"

#: ../../library/io.rst:559
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr "在原始流被分离之后，缓冲区将处于不可用的状态。"

#: ../../library/io.rst:562
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw"
" stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"某些缓冲区例如 :class:`BytesIO` 并无可从此方法返回的单独原始流的概念。 它们将会引发 "
":exc:`UnsupportedOperation`。"

#: ../../library/io.rst:570
msgid ""
"Read and return up to *size* bytes. If the argument is omitted, ``None``, or"
" negative read as much as possible."
msgstr ""

#: ../../library/io.rst:573
msgid ""
"Fewer bytes may be returned than requested. An empty :class:`bytes` object "
"is returned if the stream is already at EOF. More than one read may be made "
"and calls may be retried if specific errors are encountered, see "
":meth:`os.read` and :pep:`475` for more details. Less than size bytes being "
"returned does not imply that EOF is imminent."
msgstr ""

#: ../../library/io.rst:579
msgid ""
"When reading as much as possible the default implementation will use "
"``raw.readall`` if available (which should implement "
":meth:`RawIOBase.readall`), otherwise will read in a loop until read returns"
" ``None``, an empty :class:`bytes`, or a non-retryable error. For most "
"streams this is to EOF, but for non-blocking streams more data may become "
"available."
msgstr ""

#: ../../library/io.rst:588 ../../library/io.rst:601
msgid ""
"When the underlying raw stream is non-blocking, implementations may either "
"raise :exc:`BlockingIOError` or return ``None`` if no data is available. "
":mod:`io` implementations return ``None``."
msgstr ""

#: ../../library/io.rst:594
msgid ""
"Read and return up to *size* bytes, calling :meth:`~RawIOBase.readinto` "
"which may retry if :py:const:`~errno.EINTR` is encountered per :pep:`475`. "
"If *size* is ``-1`` or not provided, the implementation will choose an "
"arbitrary value for *size*."
msgstr ""

#: ../../library/io.rst:607
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a "
":class:`bytearray`."
msgstr ""
"将字节数据读入预先分配的可写 :term:`bytes-like object` *b* 并返回所读取的字节数。 例如，*b* 可以是一个 "
":class:`bytearray`。"

#: ../../library/io.rst:611
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr "类似于 :meth:`read`，可能对下层原始流发起多次读取，除非后者为交互式。"

#: ../../library/io.rst:614 ../../library/io.rst:624
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ":exc:`BlockingIOError` 会在下层原始流不处于阻塞模式，并且当前没有可用数据时被引发。"

#: ../../library/io.rst:619
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's "
":meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) method. Return the "
"number of bytes read."
msgstr ""
"将字节数据读入预先分配的可写 :term:`bytes-like object` *b*，其中至多使用一次对下层原始流 "
":meth:`~RawIOBase.read` (或 :meth:`~RawIOBase.readinto`) 方法的调用。 返回所读取的字节数。"

#: ../../library/io.rst:631
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream,"
" or held in a buffer for performance and latency reasons."
msgstr ""
"写入给定的 :term:`bytes-like object` *b*，并返回写入的字节数 (总是等于 *b* 的字节长度，因为如果写入失败则会引发 "
":exc:`OSError`)。 根据具体实现的不同，这些字节可能被实际写入下层流，或是出于运行效率和冗余等考虑而暂存于缓冲区。"

#: ../../library/io.rst:638
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr "当处于非阻塞模式时，如果需要将数据写入原始流但它无法在不阻塞的情况下接受所有数据则将引发 :exc:`BlockingIOError`。"

#: ../../library/io.rst:642
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "调用者可能会在此方法返回后释放或改变 *b*，因此该实现应当仅在方法调用期间访问 *b*。"

#: ../../library/io.rst:647
msgid "Raw File I/O"
msgstr "原始文件 I/O"

#: ../../library/io.rst:651
msgid ""
"A raw binary stream representing an OS-level file containing bytes data.  It"
" inherits from :class:`RawIOBase`."
msgstr "代码一个包含字节数据的 OS 层级文件的原始二进制流。 它继承自 :class:`RawIOBase`。"

#: ../../library/io.rst:654
msgid "The *name* can be one of two things:"
msgstr "*name* 可以是以下两项之一："

#: ../../library/io.rst:656
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"代表将被打开的文件路径的字符串或 :class:`bytes` 对象。 在此情况下 closefd 必须为 ``True`` (默认值) "
"否则将会引发异常。"

#: ../../library/io.rst:659
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""
"代表一个现有 OS 层级文件描述符的号码的整数，作为结果的 :class:`FileIO` 对象将可访问该文件。 当 FileIO 对象被关闭时此 fd"
" 也将被关闭，除非 *closefd* 设为 ``False``。"

#: ../../library/io.rst:664
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be"
" truncated when opened for writing. :exc:`FileExistsError` will be raised if"
" it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""
"*mode* 可以为 ``'r'``, ``'w'``, ``'x'`` 或 ``'a'`` 分别表示读取（默认模式）、写入、独占新建或添加。 "
"如果以写入或添加模式打开的文件不存在将自动新建；当以写入模式打开时文件将先清空。 以新建模式打开时如果文件已存在则将引发 "
":exc:`FileExistsError`。 以新建模式打开文件也意味着要写入，因此该模式的行为与 ``'w'`` 类似。 在模式中附带 "
"``'+'`` 将允许同时读取和写入。"

#: ../../library/io.rst:672
msgid ""
"The :meth:`~RawIOBase.read` (when called with a positive argument), "
":meth:`~RawIOBase.readinto` and :meth:`~RawIOBase.write` methods on this "
"class will only make one system call."
msgstr ""
"该类的 :meth:`~RawIOBase.read` (当附带为正值的参数调用时), :meth:`~RawIOBase.readinto` 和 "
":meth:`~RawIOBase.write` 方法将只执行一次系统调用。"

#: ../../library/io.rst:676
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"可以通过传入一个可调用对象作为 *opener* 来使用自定义文件打开器。 然后通过调用 *opener* 并传入 (*name*, *flags*) "
"来获取文件对象所对应的下层文件描述符。 *opener* 必须返回一个打开文件描述符（传入 :mod:`os.open` 作为 *opener* "
"的结果在功能上将与传入 ``None`` 类似）。"

#: ../../library/io.rst:682
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新创建的文件是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/io.rst:684
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr "有关 opener 参数的示例，请参见内置函数 :func:`open` 。"

#: ../../library/io.rst:687
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "增加了 *opener* 参数。增加了 ``'x'`` 模式。"

#: ../../library/io.rst:691
msgid "The file is now non-inheritable."
msgstr "文件现在禁止继承。"

#: ../../library/io.rst:694
msgid ""
":class:`FileIO` provides these data attributes in addition to those from "
":class:`RawIOBase` and :class:`IOBase`:"
msgstr ""
":class:`FileIO` 在继承自 :class:`RawIOBase` 和 :class:`IOBase` "
"的现有成员以外还提供了以下数据属性和方法:"

#: ../../library/io.rst:699
msgid "The mode as given in the constructor."
msgstr "构造函数中给定的模式。"

#: ../../library/io.rst:703
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr "文件名。当构造函数中没有给定名称时，这是文件的文件描述符。"

#: ../../library/io.rst:708
msgid "Buffered Streams"
msgstr "缓冲流"

#: ../../library/io.rst:710
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr "相比原始 I/O，缓冲 I/O 流提供了针对 I/O 设备的更高层级接口。"

#: ../../library/io.rst:715
msgid ""
"A binary stream using an in-memory bytes buffer.  It inherits from "
":class:`BufferedIOBase`.  The buffer is discarded when the "
":meth:`~IOBase.close` method is called."
msgstr ""
"一个使用内存字节缓冲区的二进制流。 它继承自 :class:`BufferedIOBase`。 当 :meth:`~IOBase.close` "
"方法被调用时缓冲区将被丢弃。"

#: ../../library/io.rst:719
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr "可选参数 *initial_bytes* 是一个包含初始数据的 :term:`bytes-like object`。"

#: ../../library/io.rst:722
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BytesIO` 在继承自 :class:`BufferedIOBase` 和 :class:`IOBase` "
"的成员以外还提供或重写了下列方法:"

#: ../../library/io.rst:727
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr "返回一个对应于缓冲区内容的可读写视图而不必拷贝其数据。 此外，改变视图将透明地更新缓冲区内容::"

#: ../../library/io.rst:731
msgid ""
">>> b = io.BytesIO(b\"abcdef\")\n"
">>> view = b.getbuffer()\n"
">>> view[2:4] = b\"56\"\n"
">>> b.getvalue()\n"
"b'ab56ef'"
msgstr ""
">>> b = io.BytesIO(b\"abcdef\")\n"
">>> view = b.getbuffer()\n"
">>> view[2:4] = b\"56\"\n"
">>> b.getvalue()\n"
"b'ab56ef'"

#: ../../library/io.rst:738
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or"
" closed."
msgstr "只要视图保持存在，:class:`BytesIO` 对象就无法被改变大小或关闭。"

#: ../../library/io.rst:745
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "返回包含整个缓冲区内容的 :class:`bytes`。"

#: ../../library/io.rst:750
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr "在 :class:`BytesIO` 中，这与 :meth:`~BufferedIOBase.read` 相同。"

#: ../../library/io.rst:752 ../../library/io.rst:792
msgid "The *size* argument is now optional."
msgstr "*size* 参数现在是可选的。"

#: ../../library/io.rst:757
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr "在 :class:`BytesIO` 中，这与 :meth:`~BufferedIOBase.readinto` 相同。"

#: ../../library/io.rst:763
msgid ""
"A buffered binary stream providing higher-level access to a readable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedIOBase`."
msgstr ""
"一个提供对可读、不可定位的 :class:`RawIOBase` 原始二进制流的高层级访问的缓冲二进制流。 它继承自 "
":class:`BufferedIOBase`。"

#: ../../library/io.rst:767
msgid ""
"When reading data from this object, a larger amount of data may be requested"
" from the underlying raw stream, and kept in an internal buffer. The "
"buffered data can then be returned directly on subsequent reads."
msgstr "当从此对象读取数据时，可能会从下层原始流请求更大量的数据，并存放到内部缓冲区中。 接下来可以在后续读取时直接返回缓冲数据。"

#: ../../library/io.rst:771
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, "
":data:`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"根据给定的可读 *raw* 流和 *buffer_size* 创建 :class:`BufferedReader` 的构造器。 如果省略 "
"*buffer_size*，则会使用 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:775
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedReader` 在继承自 :class:`BufferedIOBase` 和 :class:`IOBase` "
"的成员以外还提供或重写了下列方法:"

#: ../../library/io.rst:780
msgid ""
"Return bytes from the stream without advancing the position. The number of "
"bytes returned may be less or more than requested. If the underlying raw "
"stream is non-blocking and the operation would block, returns empty bytes."
msgstr ""

#: ../../library/io.rst:786
msgid ""
"In :class:`BufferedReader` this is the same as "
":meth:`io.BufferedIOBase.read`"
msgstr "在 :class:`BufferedReader` 中这与 :meth:`io.BufferedIOBase.read` 相同"

#: ../../library/io.rst:790
msgid ""
"In :class:`BufferedReader` this is the same as "
":meth:`io.BufferedIOBase.read1`"
msgstr "在 :class:`BufferedReader` 中这与 :meth:`io.BufferedIOBase.read1` 相同"

#: ../../library/io.rst:797
msgid ""
"A buffered binary stream providing higher-level access to a writeable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedIOBase`."
msgstr ""
"一个提供对可写、不可定位的 :class:`RawIOBase` 原始二进制流的高层级访问的缓冲二进制流。 它继承自 "
":class:`BufferedIOBase`。"

#: ../../library/io.rst:801
msgid ""
"When writing to this object, data is normally placed into an internal "
"buffer.  The buffer will be written out to the underlying :class:`RawIOBase`"
" object under various conditions, including:"
msgstr ""
"当写入到此对象时，数据通常会被放入到内部缓冲区中。 缓冲区将在满足某些条件的情况下被写到下层的 :class:`RawIOBase` 对象，包括:"

#: ../../library/io.rst:805
msgid "when the buffer gets too small for all pending data;"
msgstr "当缓冲区对于所有挂起数据而言太小时；"

#: ../../library/io.rst:806
msgid "when :meth:`flush` is called;"
msgstr "当 :meth:`flush` 被调用时；"

#: ../../library/io.rst:807
msgid ""
"when a :meth:`~IOBase.seek` is requested (for :class:`BufferedRandom` "
"objects);"
msgstr "当 :meth:`~IOBase.seek` 被请求时（针对 :class:`BufferedRandom` 对象）；"

#: ../../library/io.rst:808
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr "当 :class:`BufferedWriter` 对象被关闭或销毁时。"

#: ../../library/io.rst:810
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"该构造器会为给定的可写 *raw* 流创建一个 :class:`BufferedWriter`。 如果未给定 *buffer_size*，则使用默认的 "
":data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:814
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedWriter` 在继承自 :class:`BufferedIOBase` 和 :class:`IOBase` "
"的成员以外还提供或重写了下列方法:"

#: ../../library/io.rst:819
msgid ""
"Force bytes held in the buffer into the raw stream.  A "
":exc:`BlockingIOError` should be raised if the raw stream blocks."
msgstr "将缓冲区中保存的字节数据强制放入原始流。 如果原始流发生阻塞则应当引发 :exc:`BlockingIOError`。"

#: ../../library/io.rst:824
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` with "
":attr:`BlockingIOError.characters_written` set is raised if the buffer needs"
" to be written out but the raw stream blocks."
msgstr ""

#: ../../library/io.rst:832
msgid ""
"A buffered binary stream providing higher-level access to a seekable "
":class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedReader` and :class:`BufferedWriter`."
msgstr ""
"一个提供对不可定位的 :class:`RawIOBase` 原始二进制流的高层级访问的缓冲二进制流。 它继承自 "
":class:`BufferedReader` 和 :class:`BufferedWriter`。"

#: ../../library/io.rst:836
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given"
" in the first argument.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"该构造器会为在第一个参数中给定的可查找原始流创建一个读取器和写入器。 如果省略 *buffer_size* 则使用默认的 "
":data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:840
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or "
":class:`BufferedWriter` can do.  In addition, :meth:`~IOBase.seek` and "
":meth:`~IOBase.tell` are guaranteed to be implemented."
msgstr ""
":class:`BufferedRandom` 能做到 :class:`BufferedReader` 或 "
":class:`BufferedWriter` 所能做的任何事。 此外，还会确保实现 :meth:`~IOBase.seek` 和 "
":meth:`~IOBase.tell`。"

#: ../../library/io.rst:847
msgid ""
"A buffered binary stream providing higher-level access to two non seekable "
":class:`RawIOBase` raw binary streams---one readable, the other writeable. "
"It inherits from :class:`BufferedIOBase`."
msgstr ""
"一个提供对两个不可定位的 :class:`RawIOBase` 原始二进制流的高层级访问的缓冲二进制流 --- 一个可读，另一个可写。 它继承自 "
":class:`BufferedIOBase`。"

#: ../../library/io.rst:851
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader* 和 *writer* 分别是可读和可写的 :class:`RawIOBase` 对象。 如果省略 *buffer_size* "
"则使用默认的 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:855
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises "
":exc:`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair` 实现了 :class:`BufferedIOBase` 的所有方法，但 "
":meth:`~BufferedIOBase.detach` 除外，调用该方法将引发 :exc:`UnsupportedOperation`。"

#: ../../library/io.rst:861
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""
":class:`BufferedRWPair` 不会尝试同步访问其下层的原始流。 你不应当将传给它与读取器和写入器相同的对象；而要改用 "
":class:`BufferedRandom`。"

#: ../../library/io.rst:871
msgid ""
"Base class for text streams.  This class provides a character and line based"
" interface to stream I/O.  It inherits from :class:`IOBase`."
msgstr "文本流的基类。 该类提供了基于字符和行的流 I/O 的接口。 它继承自 :class:`IOBase`。"

#: ../../library/io.rst:874
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ":class:`TextIOBase` 在来自 :class:`IOBase` 的成员以外还提供或重写了以下数据属性和方法:"

#: ../../library/io.rst:879
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and"
" to encode strings into bytes."
msgstr "用于将流的字节串解码为字符串以及将字符串编码为字节串的编码格式名称。"

#: ../../library/io.rst:884
msgid "The error setting of the decoder or encoder."
msgstr "解码器或编码器的错误设置。"

#: ../../library/io.rst:888
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr "一个字符串、字符串元组或者 ``None``，表示目前已经转写的新行。 根据具体实现和初始构造器旗标的不同，此属性或许会不可用。"

#: ../../library/io.rst:894
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` or "
":class:`RawIOBase` instance) that :class:`TextIOBase` deals with. This is "
"not part of the :class:`TextIOBase` API and may not exist in some "
"implementations."
msgstr ""

#: ../../library/io.rst:901
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "从 :class:`TextIOBase` 分离出下层二进制缓冲区并将其返回。"

#: ../../library/io.rst:904
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in"
" an unusable state."
msgstr "在下层缓冲区被分离后，:class:`TextIOBase` 将处于不可用的状态。"

#: ../../library/io.rst:907
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise "
":exc:`UnsupportedOperation`."
msgstr ""
"某些 :class:`TextIOBase` 的实现，例如 :class:`StringIO` 可能并无下层缓冲区的概念，因此调用此方法将引发 "
":exc:`UnsupportedOperation`。"

#: ../../library/io.rst:915
msgid ""
"Read and return at most *size* characters from the stream as a single "
":class:`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""
"从流中读取至多 *size* 个字符并以单个 :class:`str` 的形式返回。 如果 *size* 为负值或 ``None``，则读取至 EOF。"

#: ../../library/io.rst:920
msgid ""
"Read until newline or EOF and return a single :class:`str`.  If the stream "
"is already at EOF, an empty string is returned."
msgstr ""
"读取至换行符或 EOF 并返回单个 :class:`str`。 如果流已经到达 EOF，则将返回一个空字符串。, an empty string is "
"returned."

#: ../../library/io.rst:923
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "如果指定了 *size* ，最多将读取 *size* 个字符。"

#: ../../library/io.rst:927
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`!SEEK_SET`."
msgstr ""
"将流位置改为给定的 *offset*。 具体行为取决于 *whence* 形参。 *whence* 的默认值为 :data:`!SEEK_SET`。"

#: ../../library/io.rst:931
msgid ""
":data:`!SEEK_SET` or ``0``: seek from the start of the stream (the default);"
" *offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""
":data:`!SEEK_SET` 或 ``0``: 从流的起始位置开始查找（默认值）；*offset* 必须为 "
":meth:`TextIOBase.tell` 所返回的数值或为零。 任何其他 *offset* 值都将导致未定义的行为。"

#: ../../library/io.rst:935
msgid ""
":data:`!SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ":data:`!SEEK_CUR` 或 ``1``: \"查找\" 到当前位置；*offset* 必须为零，表示无操作（所有其他值均不受支持）。"

#: ../../library/io.rst:938
msgid ""
":data:`!SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ":data:`!SEEK_END` 或 ``2``: 查找到流的末尾；*offset* 必须为零（所有其他值均不受支持）。"

#: ../../library/io.rst:941
msgid "Return the new absolute position as an opaque number."
msgstr "以不透明数字形式返回新的绝对位置。"

#: ../../library/io.rst:948
msgid ""
"Return the current stream position as an opaque number.  The number does not"
" usually represent a number of bytes in the underlying binary storage."
msgstr "以不透明数字形式返回当前流的位置。 该数字通常并不代表下层二进制存储中对应的字节数。"

#: ../../library/io.rst:954
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr "将字符串 *s* 写入到流并返回写入的字符数。"

#: ../../library/io.rst:961
msgid ""
"A buffered text stream providing higher-level access to a "
":class:`BufferedIOBase` buffered binary stream.  It inherits from "
":class:`TextIOBase`."
msgstr ""
"一个提供对 :class:`BufferedIOBase` 缓冲二进制流的高层级访问的缓冲文本流。 它继承自 :class:`TextIOBase`。"

#: ../../library/io.rst:965
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or"
" encoded with.  In :ref:`UTF-8 Mode <utf8-mode>`, this defaults to UTF-8. "
"Otherwise, it defaults to :func:`locale.getencoding`. "
"``encoding=\"locale\"`` can be used to specify the current locale's encoding"
" explicitly. See :ref:`io-text-encoding` for more information."
msgstr ""
"*encoding* 给出将被解码或编码的流的编码格式。 在 :ref:`UTF-8 模式 <utf8-mode>` 中，默认为 UTF-8。 "
"否则，默认为 :func:`locale.getencoding`。 ``encoding=\"locale\"`` "
"可以用来显式指定当前语言环境的编码格式。 请参阅 :ref:`io-text-encoding` 了解更多信息。"

#: ../../library/io.rst:971
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed"
" escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with "
"``\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""
"*errors* 是一个可选的字符串，它指明编码格式和编码格式错误的处理方式。 传入 ``'strict'`` 将在出现编码格式错误时引发 "
":exc:`ValueError` (默认值 ``None`` 具有相同的效果)，传入 ``'ignore'`` 将忽略错误。 "
"(请注意忽略编码格式错误会导致数据丢失。)  ``'replace'`` 会在出现错误数据时插入一个替换标记 (例如 ``'?'``)。 "
"``'backslashreplace'`` 将把错误数据替换为一个反斜杠转义序列。 在写入时，还可以使用 "
"``'xmlcharrefreplace'`` (替换为适当的 XML 字符引用)  或 ``'namereplace'`` (替换为 "
"``\\N{...}`` 转义序列)。 任何其他通过 :func:`codecs.register_error` 注册的错误处理方式名称也可以被接受。"

#: ../../library/io.rst:987
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* 控制行结束符处理方式。 它可以为 ``None``, ``''``, ``'\\n'``, ``'\\r'`` 和 "
"``'\\r\\n'``。 其工作原理如下:"

#: ../../library/io.rst:990
msgid ""
"When reading input from the stream, if *newline* is ``None``, "
":term:`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If *newline* is ``''``, "
"universal newlines mode is enabled, but line endings are returned to the "
"caller untranslated.  If *newline* has any of the other legal values, input "
"lines are only terminated by the given string, and the line ending is "
"returned to the caller untranslated."
msgstr ""
"当从流读取输入时，如果 *newline* 为 ``None``，则将启用 :term:`universal newlines` 模式。 "
"输入中的行结束符可以为 ``'\\n'``, ``'\\r'`` 或 ``'\\r\\n'``，在返回给调用者之前它们会被统一转写为 "
"``'\\n'``。 如果 *newline* 为 ``''``，也会启用通用换行模式，但行结束符会不加转写即返回给调用者。 如果 *newline* "
"具有任何其他合法的值，则输入行将仅由给定的字符串结束，并且行结束符会不加转写即返回给调用者。"

#: ../../library/io.rst:999
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, "
":data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"将输出写入流时，如果 *newline* 为 ``None``，则写入的任何 ``'\\n'`` 字符都将转换为系统默认行分隔符 "
":data:`os.linesep`。如果 *newline* 是 ``''`` 或 ``'\\n'``，则不进行翻译。如果 *newline* "
"是任何其他合法值，则写入的任何 ``'\\n'`` 字符将被转换为给定的字符串。"

#: ../../library/io.rst:1005
msgid ""
"If *line_buffering* is ``True``, :meth:`~IOBase.flush` is implied when a "
"call to write contains a newline character or a carriage return."
msgstr ""
"如果 *line_buffering* 为 ``True``，则当一个写入调用包含换行或回车符时将会应用 :meth:`~IOBase.flush`。"

#: ../../library/io.rst:1008
msgid ""
"If *write_through* is ``True``, calls to :meth:`~BufferedIOBase.write` are "
"guaranteed not to be buffered: any data written on the "
":class:`TextIOWrapper` object is immediately handled to its underlying "
"binary *buffer*."
msgstr ""
"如果 *write_through* 为 ``True``，则对 :meth:`~BufferedIOBase.write` 的调用会确保不被缓冲：在 "
":class:`TextIOWrapper` 对象上写入的任何数据会立即交给其下层的 *buffer* 来处理。"

#: ../../library/io.rst:1012
msgid "The *write_through* argument has been added."
msgstr "已添加 *write_through* 参数"

#: ../../library/io.rst:1015
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead"
" of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""
"默认的 *encoding* 现在将为 ``locale.getpreferredencoding(False)`` 而非 "
"``locale.getpreferredencoding()``。 不要使用 :func:`locale.setlocale` "
"来临时改变区域编码格式，要使用当前区域编码格式而不是用户的首选编码格式。"

#: ../../library/io.rst:1021
msgid ""
"The *encoding* argument now supports the ``\"locale\"`` dummy encoding name."
msgstr "*encoding* 参数现在支持 ``\"locale\"`` 作为编码格式名称。"

#: ../../library/io.rst:1026
msgid ""
"When the underlying raw stream is non-blocking, a :exc:`BlockingIOError` may"
" be raised if a read operation cannot be completed immediately."
msgstr ""

#: ../../library/io.rst:1029
msgid ""
":class:`TextIOWrapper` provides these data attributes and methods in "
"addition to those from :class:`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`TextIOWrapper` 在继承自 :class:`TextIOBase` 和 :class:`IOBase` "
"的现有成员以外还提供了以下数据属性和方法:"

#: ../../library/io.rst:1034
msgid "Whether line buffering is enabled."
msgstr "是否启用行缓冲。"

#: ../../library/io.rst:1038
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr "写入是否要立即传给下层的二进制缓冲。"

#: ../../library/io.rst:1046
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""
"使用 *encoding*, *errors*, *newline*, *line_buffering* 和 *write_through* "
"的新设置来重新配置此文本流。"

#: ../../library/io.rst:1049
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr ""
"未指定的形参将保留当前设定，例外情况是当指定了 *encoding* 但未指定 *errors* 时将会使用 ``errors='strict'``。"

#: ../../library/io.rst:1053
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr "如果已经有数据从流中被读取则将无法再改变编码格式或行结束符。 另一方面，在写入数据之后再改变编码格式则是可以的。"

#: ../../library/io.rst:1057
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr "此方法会在设置新的形参之前执行隐式的流刷新。"

#: ../../library/io.rst:1062
msgid "The method supports ``encoding=\"locale\"`` option."
msgstr "此方法支持 ``encoding=\"locale\"`` 选项。"

#: ../../library/io.rst:1067
msgid ""
"Set the stream position. Return the new stream position as an :class:`int`."
msgstr "设置流位置。 以 :class:`int` 的形式返回新的流位置。"

#: ../../library/io.rst:1070
msgid ""
"Four operations are supported, given by the following argument combinations:"
msgstr "支持四种操作，由下列参数组合给出："

#: ../../library/io.rst:1073
msgid "``seek(0, SEEK_SET)``: Rewind to the start of the stream."
msgstr "``seek(0, SEEK_SET)``: 回退到流的开头。"

#: ../../library/io.rst:1074
msgid ""
"``seek(cookie, SEEK_SET)``: Restore a previous position; *cookie* **must "
"be** a number returned by :meth:`tell`."
msgstr ""
"``seek(cookie, SEEK_SET)``: 恢复之前的位置；*cookie* **必须是** 由 :meth:`tell` 返回的数字。"

#: ../../library/io.rst:1076
msgid "``seek(0, SEEK_END)``: Fast-forward to the end of the stream."
msgstr "``seek(0, SEEK_END)``: 快进到流的末尾。"

#: ../../library/io.rst:1077
msgid "``seek(0, SEEK_CUR)``: Leave the current stream position unchanged."
msgstr "``seek(0, SEEK_CUR)``: 保持当前流位置不变。"

#: ../../library/io.rst:1079
msgid "Any other argument combinations are invalid, and may raise exceptions."
msgstr "任何其他参数组合均无效，并可能引发异常。"

#: ../../library/io.rst:1084
msgid ":data:`os.SEEK_SET`, :data:`os.SEEK_CUR`, and :data:`os.SEEK_END`."
msgstr ":data:`os.SEEK_SET`, :data:`os.SEEK_CUR` 和 :data:`os.SEEK_END`。"

#: ../../library/io.rst:1088
msgid ""
"Return the stream position as an opaque number. The return value of "
":meth:`!tell` can be given as input to :meth:`seek`, to restore a previous "
"stream position."
msgstr "以不透明数字的形式返回流位置。 :meth:`!tell` 的返回值可以作为 :meth:`seek` 的输入，以恢复之前的流位置。"

#: ../../library/io.rst:1095
msgid ""
"A text stream using an in-memory text buffer.  It inherits from "
":class:`TextIOBase`."
msgstr "一个使用内存文本缓冲区的文本流。 它继承自 :class:`TextIOBase`。"

#: ../../library/io.rst:1098
msgid ""
"The text buffer is discarded when the :meth:`~IOBase.close` method is "
"called."
msgstr "当 :meth:`~IOBase.close` 方法被调用时将会丢弃文本缓冲区。"

#: ../../library/io.rst:1101
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by "
":meth:`~TextIOBase.write`.  The stream is positioned at the start of the "
"buffer which emulates opening an existing file in a ``w+`` mode, making it "
"ready for an immediate write from the beginning or for a write that would "
"overwrite the initial value.  To emulate opening a file in an ``a+`` mode "
"ready for appending, use ``f.seek(0, io.SEEK_END)`` to reposition the stream"
" at the end of the buffer."
msgstr ""
"缓冲区的初始值可通过提供 *initial_value* 来设置。 如果启用了换行符转写，换行符将以与 "
":meth:`~TextIOBase.write` 相同的方式进行编码。 流将被定位到缓冲区的起点，这模拟了以 ``w+`` "
"模式打开一个现有文件的操作，使其准备好从头开始立即写入或是将要覆盖初始值的写入。 要模拟以 ``a+`` 模式打开一个文件准备好追加内容，请使用 "
"``f.seek(0, io.SEEK_END)`` 来将流重新定位到缓冲区的末尾。"

#: ../../library/io.rst:1110
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`, except "
"that when writing output to the stream, if *newline* is ``None``, newlines "
"are written as ``\\n`` on all platforms."
msgstr ""
"*newline* 参数的规则与 :class:`TextIOWrapper` 所用的一致，不同之处在于当将输出写入到流时，如果 *newline* 为"
" ``None``，则在所有平台上换行符都会被写入为 ``\\n``。"

#: ../../library/io.rst:1114
msgid ""
":class:`StringIO` provides this method in addition to those from "
":class:`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`StringIO` 在继承自 :class:`TextIOBase` 和 :class:`IOBase` "
"的现有成员以外还提供了以下方法:"

#: ../../library/io.rst:1119
msgid ""
"Return a :class:`str` containing the entire contents of the buffer. Newlines"
" are decoded as if by :meth:`~TextIOBase.read`, although the stream position"
" is not changed."
msgstr ""
"返回一个 包含缓冲区全部内容的 :class:`str`。 换行符会以与 :meth:`~TextIOBase.read` "
"相同的方式被编码，但是流位置不会改变。"

#: ../../library/io.rst:1123
msgid "Example usage::"
msgstr "用法示例："

#: ../../library/io.rst:1125
msgid ""
"import io\n"
"\n"
"output = io.StringIO()\n"
"output.write('First line.\\n')\n"
"print('Second line.', file=output)\n"
"\n"
"# Retrieve file contents -- this will be\n"
"# 'First line.\\nSecond line.\\n'\n"
"contents = output.getvalue()\n"
"\n"
"# Close object and discard memory buffer --\n"
"# .getvalue() will now raise an exception.\n"
"output.close()"
msgstr ""
"import io\n"
"\n"
"output = io.StringIO()\n"
"output.write('First line.\\n')\n"
"print('Second line.', file=output)\n"
"\n"
"# 提取文件内容 -- 这将为\n"
"# 'First line.\\nSecond line.\\n'\n"
"contents = output.getvalue()\n"
"\n"
"# 关闭对象并丢弃内存缓冲区 --\n"
"# 现在 .getvalue() 将引发一个异常。\n"
"output.close()"

#: ../../library/io.rst:1145
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It"
" inherits from :class:`codecs.IncrementalDecoder`."
msgstr ""
"用于在 :term:`universal newlines` 模式下解码换行符的辅助编解码器。 它继承自 "
":class:`codecs.IncrementalDecoder`。"

#: ../../library/io.rst:1150
msgid "Static Typing"
msgstr "静态类型"

#: ../../library/io.rst:1152
msgid ""
"The following protocols can be used for annotating function and method "
"arguments for simple stream reading or writing operations. They are "
"decorated with :deco:`typing.runtime_checkable`."
msgstr ""

#: ../../library/io.rst:1158
msgid ""
"Generic protocol for reading from a file or other input stream. ``T`` will "
"usually be :class:`str` or :class:`bytes`, but can be any type that is read "
"from the stream."
msgstr ""

#: ../../library/io.rst:1167
msgid ""
"Read data from the input stream and return it. If *size* is specified, it "
"should be an integer, and at most *size* items (bytes/characters) will be "
"read."
msgstr ""

#: ../../library/io.rst:1171 ../../library/io.rst:1190
msgid "For example::"
msgstr "例如："

#: ../../library/io.rst:1173
msgid ""
"def read_it(reader: Reader[str]):\n"
"    data = reader.read(11)\n"
"    assert isinstance(data, str)"
msgstr ""

#: ../../library/io.rst:1179
msgid ""
"Generic protocol for writing to a file or other output stream. ``T`` will "
"usually be :class:`str` or :class:`bytes`, but can be any type that can be "
"written to the stream."
msgstr ""

#: ../../library/io.rst:1187
msgid ""
"Write *data* to the output stream and return the number of items "
"(bytes/characters) written."
msgstr ""

#: ../../library/io.rst:1192
msgid ""
"def write_binary(writer: Writer[bytes]):\n"
"    writer.write(b\"Hello world!\\n\")"
msgstr ""

#: ../../library/io.rst:1195
msgid ""
"See :ref:`typing-io` for other I/O related protocols and classes that can be"
" used for static type checking."
msgstr ""

#: ../../library/io.rst:1199
msgid "Performance"
msgstr "性能"

#: ../../library/io.rst:1201
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr "本节讨论所提供的具体 I/O 实现的性能。"

#: ../../library/io.rst:1207
msgid ""
"By reading and writing only large chunks of data even when the user asks for"
" a single byte, buffered I/O hides any inefficiency in calling and executing"
" the operating system's unbuffered I/O routines.  The gain depends on the OS"
" and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""
"即使在用户请求单个字节时，也只读取和写入大块数据。通过该方法，缓冲 I/O 隐藏了操作系统调用和执行无缓冲 I/O "
"例程时的任何低效性。增益取决于操作系统和执行的 I/O 类型。例如，在某些现代操作系统上（例如 Linux），无缓冲磁盘 I/O 可以与缓冲 I/O "
"一样快。但最重要的是，无论平台和支持设备如何，缓冲 I/O 都能提供可预测的性能。因此，对于二进制数据，应首选使用缓冲的 I/O 而不是未缓冲的 I/O"
" 。"

#: ../../library/io.rst:1219
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than"
" binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable"
" handling huge amounts of text data like large log files.  Also, "
":meth:`~TextIOBase.tell` and :meth:`~TextIOBase.seek` are both quite slow "
"due to the reconstruction algorithm used."
msgstr ""
"二进制存储（如文件）上的文本 I/O 比同一存储上的二进制 I/O 慢得多，因为它需要使用字符编解码器在 unicode 和二进制数据之间进行转换。 "
"在处理大量文本数据（如大型日志文件）时这种情况会非常明显。 此外，由于使用了重构算法因而 :meth:`~TextIOBase.tell` 和 "
":meth:`~TextIOBase.seek` 的速度都相当慢。"

#: ../../library/io.rst:1226
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will"
" exhibit similar speed to :class:`BytesIO`."
msgstr ":class:`StringIO` 是原生的内存 Unicode 容器，速度与 :class:`BytesIO` 相似。"

#: ../../library/io.rst:1230
msgid "Multi-threading"
msgstr "多线程"

#: ../../library/io.rst:1232
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as :manpage:`read(2)` under Unix) they wrap are thread-"
"safe too."
msgstr ""
":class:`FileIO` 对象在它们封装的操作系统调用 (如 Unix 下的 :manpage:`read(2)`) "
"是线程安全的情况下也是线程安全的。"

#: ../../library/io.rst:1235
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) protect their internal structures using a lock; it "
"is therefore safe to call them from multiple threads at once."
msgstr ""
"二进制缓冲对象（例如 :class:`BufferedReader`, :class:`BufferedWriter`, "
":class:`BufferedRandom` 和 "
":class:`BufferedRWPair`）使用锁来保护其内部结构；因此，可以安全地一次从多个线程中调用它们。"

#: ../../library/io.rst:1240
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ":class:`TextIOWrapper` 对象不再是线程安全的。"

#: ../../library/io.rst:1243
msgid "Reentrancy"
msgstr "可重入性"

#: ../../library/io.rst:1245
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) are not reentrant.  While reentrant calls will not "
"happen in normal situations, they can arise from doing I/O in a "
":mod:`signal` handler.  If a thread tries to re-enter a buffered object "
"which it is already accessing, a :exc:`RuntimeError` is raised.  Note this "
"doesn't prohibit a different thread from entering the buffered object."
msgstr ""
"二进制缓冲对象（ :class:`BufferedReader` ， :class:`BufferedWriter` ， "
":class:`BufferedRandom` 和 :class:`BufferedRWPair` "
"的实例）不是可重入的。虽然在正常情况下不会发生可重入调用，但仍可能会在 :mod:`signal` 处理程序执行 I/O "
"时产生。如果线程尝试重入已经访问的缓冲对象，则会引发 :exc:`RuntimeError` 。注意，这并不禁止其他线程进入缓冲对象。"

#: ../../library/io.rst:1253
msgid ""
"The above implicitly extends to text files, since the :func:`open` function "
"will wrap a buffered object inside a :class:`TextIOWrapper`.  This includes "
"standard streams and therefore affects the built-in :func:`print` function "
"as well."
msgstr ""
"上面的代码将显式地扩展到文本文件，因为 :func:`open` 函数将把缓冲的对象包装在 :class:`TextIOWrapper` 中。 "
"这包括标准流因而也会影响内置的 :func:`print` 函数。"

#: ../../library/io.rst:24
msgid "file object"
msgstr "file object -- 文件对象"

#: ../../library/io.rst:24
msgid "io module"
msgstr "io 模块"

#: ../../library/io.rst:984 ../../library/io.rst:1140
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/io.rst:984
msgid "io.TextIOWrapper class"
msgstr "io.TextIOWrapper 类"

#: ../../library/io.rst:1140
msgid "io.IncrementalNewlineDecoder class"
msgstr "io.IncrementalNewlineDecoder 类"
