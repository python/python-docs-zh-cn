# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2019
# Pan Felix <tinylambda@gmail.com>, 2019
# nick <2330458484@qq.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# MuSheng Chen <sheng.2179@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-10 22:51+0000\n"
"PO-Revision-Date: 2019-09-01 03:30+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "传输和协议"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "前言"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"传输和协议会被像 :meth:`loop.create_connection` 这类 **底层** "
"事件循环接口使用。它们使用基于回调的编程风格支持网络或IPC协议（如HTTP）的高性能实现。"

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr "基本上，传输和协议应只在库和框架上使用，而不应该在高层的异步应用中使用它们。"

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "本文档包含  `Transports`_ 和 `Protocols`_ 。"

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "概述"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to"
" some extent when)."
msgstr "在最顶层，传输只关心 **怎样** 传送字节内容，而协议决定传送 **哪些** 字节内容(还要在一定程度上考虑何时)。"

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an"
" application, from the transport's point of view."
msgstr "也可以这样说：从传输的角度来看，传输是套接字(或类似的I/O终端)的抽象，而协议是应用程序的抽象。"

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an"
" abstract interface for using network I/O and interprocess I/O."
msgstr "换另一种说法，传输和协议一起定义网络I/0和进程间I/O的抽象接口。"

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls"
" protocol methods to pass it data that has been received."
msgstr "传输对象和协议对象总是一对一关系：协议调用传输方法来发送数据，而传输在接收到数据时调用协议方法传递数据。"

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as "
":meth:`loop.create_connection`) usually accept a *protocol_factory* argument"
" used to create a *Protocol* object for an accepted connection, represented "
"by a *Transport* object. Such methods usually return a tuple of "
"``(transport, protocol)``."
msgstr ""
"大部分面向连接的事件循环方法(如 :meth:`loop.create_connection` ) 通常接受  *protocol_factory* "
"参数为接收到的链接创建 *协议* 对象，并用 *传输* 对象来表示。这些方法一般会返回 ``(transport, protocol)`` 元组。"

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "目录"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "本文档包含下列小节:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, "
":class:`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, "
":class:`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"`传输`_ 部分记载异步IO :class:`BaseTransport` 、 :class:`ReadTransport` 、 "
":class:`WriteTransport` 、 :class:`Transport` 、 :class:`DatagramTransport` 和 "
":class:`SubprocessTransport` 等类。"

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, "
":class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and"
" :class:`SubprocessProtocol` classes."
msgstr ""
" `协议`_  部分记载异步IO :class:`BaseProtocol` 、 :class:`Protocol` 、 "
":class:`BufferedProtocol` 、 :class:`DatagramProtocol` 和 "
":class:`SubprocessProtocol` 等类。"

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr "`例子`_ 部分展示怎样使用传输、协议和底层事件循环接口。"

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "传输"

#: ../../library/asyncio-protocol.rst:72
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr "传输属于 :mod:`asyncio` 模块中的类，用来抽象各种通信通道。"

#: ../../library/asyncio-protocol.rst:75
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr "传输对象总是由 :ref:`异步IO事件循环 <asyncio-event-loop>` 实例化。"

#: ../../library/asyncio-protocol.rst:78
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr "异步IO实现TCP、UDP、SSL和子进程管道的传输。传输上可用的方法由传输的类型决定。"

#: ../../library/asyncio-protocol.rst:81
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "传输类属于 :ref:`线程不安全<asyncio-multithreading>` 。"

#: ../../library/asyncio-protocol.rst:85
msgid "Transports Hierarchy"
msgstr "传输层级"

#: ../../library/asyncio-protocol.rst:89
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports"
" share."
msgstr "所有传输的基类。包含所有异步IO传输共用的方法。"

#: ../../library/asyncio-protocol.rst:94
msgid "A base transport for write-only connections."
msgstr "只写链接的基础传输。"

#: ../../library/asyncio-protocol.rst:96
msgid ""
"Instances of the *WriteTransport* class are returned from the "
":meth:`loop.connect_write_pipe` event loop method and are also used by "
"subprocess-related methods like :meth:`loop.subprocess_exec`."
msgstr ""
" *WriteTransport* 类的实例由 :meth:`loop.connect_write_pipe` 事件循环方法返回，也被子进程相关的方法如"
" :meth:`loop.subprocess_exec` 使用。"

#: ../../library/asyncio-protocol.rst:103
msgid "A base transport for read-only connections."
msgstr "只读链接的基础传输。"

#: ../../library/asyncio-protocol.rst:105
msgid ""
"Instances of the *ReadTransport* class are returned from the "
":meth:`loop.connect_read_pipe` event loop method and are also used by "
"subprocess-related methods like :meth:`loop.subprocess_exec`."
msgstr ""
" *ReadTransport* 类的实例由 :meth:`loop.connect_read_pipe` 事件循环方法返回，也被子进程相关的方法如 "
":meth:`loop.subprocess_exec` 使用。"

#: ../../library/asyncio-protocol.rst:112
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr "接口代表一个双向传输，如TCP链接。"

#: ../../library/asyncio-protocol.rst:115
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr "用户不用直接实例化传输；调用一个功能函数，给它传递协议工厂和其它需要的信息就可以创建传输和协议。"

#: ../../library/asyncio-protocol.rst:119
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, "
":meth:`loop.create_unix_connection`, :meth:`loop.create_server`, "
":meth:`loop.sendfile`, etc."
msgstr ""
"*传输* 类实例由如  :meth:`loop.create_connection` 、 "
":meth:`loop.create_unix_connection` 、  :meth:`loop.create_server` 、  "
":meth:`loop.sendfile` 等这类事件循环方法使用或返回。"

#: ../../library/asyncio-protocol.rst:127
msgid "A transport for datagram (UDP) connections."
msgstr "数据报(UDP)传输链接。"

#: ../../library/asyncio-protocol.rst:129
msgid ""
"Instances of the *DatagramTransport* class are returned from the "
":meth:`loop.create_datagram_endpoint` event loop method."
msgstr ""
"*DatagramTransport* 类实例由事件循环方法 :meth:`loop.create_datagram_endpoint` 返回。"

#: ../../library/asyncio-protocol.rst:135
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr "表示父进程和子进程之间连接的抽象。"

#: ../../library/asyncio-protocol.rst:138
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"*SubprocessTransport* 类的实例由事件循环方法 :meth:`loop.subprocess_shell`  和  "
":meth:`loop.subprocess_exec` 返回。"

#: ../../library/asyncio-protocol.rst:144
msgid "Base Transport"
msgstr "基础传输"

#: ../../library/asyncio-protocol.rst:148
msgid "Close the transport."
msgstr "关闭传输。"

#: ../../library/asyncio-protocol.rst:150
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument."
msgstr ""
"如果传输具有发送数据缓冲区，将会异步发送已缓存的数据。在所有已缓存的数据都已处理后，就会将 :const:`None` 作为协议 "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"方法的参数并进行调用。在这之后，传输不再接收任何数据。"

#: ../../library/asyncio-protocol.rst:159
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "返回 ``True`` ，如果传输正在关闭或已经关闭。"

#: ../../library/asyncio-protocol.rst:163
msgid ""
"Return information about the transport or underlying resources it uses."
msgstr "返回 传输或它使用的相关资源信息。"

#: ../../library/asyncio-protocol.rst:166
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr "*name* 是表示要获取传输特定信息的字符串。"

#: ../../library/asyncio-protocol.rst:169
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr "*default* 是在信息不可用或传输不支持第三方事件循环实现或当前平台查询时返回的值。"

#: ../../library/asyncio-protocol.rst:174
msgid ""
"For example, the following code attempts to get the underlying socket object"
" of the transport::"
msgstr "例如下面代码尝试获取传输相关套接字对象::"

#: ../../library/asyncio-protocol.rst:181
msgid "Categories of information that can be queried on some transports:"
msgstr "传输可查询信息类别:"

#: ../../library/asyncio-protocol.rst:183
msgid "socket:"
msgstr "套接字:"

#: ../../library/asyncio-protocol.rst:185
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: 套接字链接时的远端地址，:meth:`socket.socket.getpeername` 方法的结果 (出错时为 "
"``None`` )"

#: ../../library/asyncio-protocol.rst:189
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` 实例"

#: ../../library/asyncio-protocol.rst:191
msgid ""
"``'sockname'``: the socket's own address, result of "
":meth:`socket.socket.getsockname`"
msgstr "``'sockname'``: 套接字本地地址， :meth:`socket.socket.getsockname` 方法的结果"

#: ../../library/asyncio-protocol.rst:194
msgid "SSL socket:"
msgstr "SSL套接字"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of "
":meth:`ssl.SSLSocket.compression`"
msgstr ""
"``'compression'``: 用字符串指定压缩算法，或者链接没有压缩时为 ``None``  "
"；:meth:`ssl.SSLSocket.compression` 的结果。"

#: ../../library/asyncio-protocol.rst:200
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: 一个三值的元组，包含使用密码的名称，定义使用的SSL协议的版本，使用的加密位数。  "
":meth:`ssl.SSLSocket.cipher` 的结果。"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'peercert'``: peer certificate; result of "
":meth:`ssl.SSLSocket.getpeercert`"
msgstr "``'peercert'``: 远端凭证；  :meth:`ssl.SSLSocket.getpeercert` 结果。"

#: ../../library/asyncio-protocol.rst:208
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` 实例"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr "``'ssl_object'``: :class:`ssl.SSLObject` 或 :class:`ssl.SSLSocket` 实例"

#: ../../library/asyncio-protocol.rst:213
msgid "pipe:"
msgstr "管道："

#: ../../library/asyncio-protocol.rst:215
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: 管道对象"

#: ../../library/asyncio-protocol.rst:217
msgid "subprocess:"
msgstr "子进程："

#: ../../library/asyncio-protocol.rst:219
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` 实例"

#: ../../library/asyncio-protocol.rst:223
msgid "Set a new protocol."
msgstr "设置一个新协议。"

#: ../../library/asyncio-protocol.rst:225
msgid ""
"Switching protocol should only be done when both protocols are documented to"
" support the switch."
msgstr "只有两种协议都写明支持切换才能完成切换协议。"

#: ../../library/asyncio-protocol.rst:230
msgid "Return the current protocol."
msgstr "返回当前协议。"

#: ../../library/asyncio-protocol.rst:234
msgid "Read-only Transports"
msgstr "只读传输"

#: ../../library/asyncio-protocol.rst:238
msgid "Return ``True`` if the transport is receiving new data."
msgstr "如果传输接收到新数据时返回 ``True`` 。"

#: ../../library/asyncio-protocol.rst:244
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"暂停传输的接收端。:meth:`protocol.data_received() <Protocol.data_received>` "
"方法将不会收到数据，除非 :meth:`resume_reading`  被调用。"

#: ../../library/asyncio-protocol.rst:248
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr "这个方法幂等的， 它可以在传输已经暂停或关闭时调用。"

#: ../../library/asyncio-protocol.rst:254
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"恢复接收端。如果有数据可读取时，协议方法 :meth:`protocol.data_received() "
"<Protocol.data_received>` 将再次被调用。"

#: ../../library/asyncio-protocol.rst:258
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr "这个方法幂等的， 它可以在传输已经准备好读取数据时调用。"

#: ../../library/asyncio-protocol.rst:264
msgid "Write-only Transports"
msgstr "只写传输"

#: ../../library/asyncio-protocol.rst:268
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>`"
" method will eventually be called with :const:`None` as its argument."
msgstr ""
"立即关闭传输，不会等待已提交的操作处理完毕。已缓存的数据将会丢失。不会接收更多数据。   最终 :const:`None` 将作为协议的 "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>`  方法的参数被调用。"

#: ../../library/asyncio-protocol.rst:276
msgid ""
"Return :const:`True` if the transport supports "
":meth:`~WriteTransport.write_eof`, :const:`False` if not."
msgstr ""
"如果传输支持 :meth:`~WriteTransport.write_eof` 返回  :const:`True` 否则返回  "
":const:`False`  。"

#: ../../library/asyncio-protocol.rst:281
msgid "Return the current size of the output buffer used by the transport."
msgstr "返回传输使用输出缓冲区的当前大小。"

#: ../../library/asyncio-protocol.rst:285
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"获取写入流控制 *high* 和 *low* 高低标记位。返回元组 ``(low, high)`` ， *low* 和 *high* 为正字节数。"

#: ../../library/asyncio-protocol.rst:289
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "使用 :meth:`set_write_buffer_limits` 设置限制。"

#: ../../library/asyncio-protocol.rst:295
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "设置写入流控制 *high* 和 *low* 高低标记位。"

#: ../../library/asyncio-protocol.rst:297
msgid ""
"These two values (measured in number of bytes) control when the protocol's "
":meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and "
":meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"这两个值（以字节数表示）控制何时调用协议的 :meth:`protocol.pause_writing() "
"<BaseProtocol.pause_writing>` 和 :meth:`protocol.resume_writing() "
"<BaseProtocol.resume_writing>` 方法。 如果指明，则低水位必须小于或等于高水位。 *high* 和 *low* "
"都不能为负值。"

#: ../../library/asyncio-protocol.rst:305
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, "
":meth:`~BaseProtocol.resume_writing` is called when the buffer size becomes "
"less than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` 会在缓冲区尺寸大于或等于 *high* 值时被调用。 "
"如果写入已经被暂停，:meth:`~BaseProtocol.resume_writing` 会在缓冲区尺寸小于或等于 *low* 值时被调用。"

#: ../../library/asyncio-protocol.rst:310
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to"
" zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes "
":meth:`~BaseProtocol.resume_writing` to be called only once the buffer is "
"empty. Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"默认值是实现专属的。 如果只给出了高水位值，则低水位值默认为一个小于或等于高水位值的实现传属值。 将 *high* 设为零会强制将 *low* "
"也设为零，并使得 :meth:`~BaseProtocol.pause_writing` 在缓冲区变为非空的任何时刻被调用。 将 *low* "
"设为零会使得 :meth:`~BaseProtocol.resume_writing` 在缓冲区为空时只被调用一次。 "
"对于上下限都使用零值通常是不够优化的，因为它减少了并发执行 I/O 和计算的机会。"

#: ../../library/asyncio-protocol.rst:321
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr "可使用 :meth:`~WriteTransport.get_write_buffer_limits` 来获取上下限值。"

#: ../../library/asyncio-protocol.rst:326
msgid "Write some *data* bytes to the transport."
msgstr "将一些 *data* 字节串写入传输。"

#: ../../library/asyncio-protocol.rst:328
#: ../../library/asyncio-protocol.rst:357
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr "此方法不会阻塞；它会缓冲数据并安排其被异步地发出。"

#: ../../library/asyncio-protocol.rst:333
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"将数据字节串的列表（或任意可迭代对象）写入传输。 这在功能上等价于在可迭代对象产生的每个元素上调用 :meth:`write`，但其实现可能更为高效。"

#: ../../library/asyncio-protocol.rst:340
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr "在刷新所有已缓冲数据之后关闭传输的写入端。 数据仍可以被接收。"

#: ../../library/asyncio-protocol.rst:343
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL)"
" doesn't support half-closed connections."
msgstr "如果传输（例如 SSL）不支持半关闭的连接，此方法会引发 :exc:`NotImplementedError`。"

#: ../../library/asyncio-protocol.rst:348
msgid "Datagram Transports"
msgstr "数据报传输"

#: ../../library/asyncio-protocol.rst:352
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"将 *data* 字节串发送到 *addr* (基于传输的目标地址) 所给定的远端对等方。 如果 *addr* 为 "
":const:`None`，则将数据发送到传输创建时给定的目标地址。"

#: ../../library/asyncio-protocol.rst:362
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>`"
" method will eventually be called with :const:`None` as its argument."
msgstr ""
"立即关闭传输，不会等待已提交的操作执行完毕。 已缓存的数据将会丢失。 不会接收更多的数据。 协议的 "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` 方法最终将附带 "
":const:`None` 作为参数被调用。"

#: ../../library/asyncio-protocol.rst:372
msgid "Subprocess Transports"
msgstr "子进程传输"

#: ../../library/asyncio-protocol.rst:376
msgid "Return the subprocess process id as an integer."
msgstr "将子进程的进程 ID 以整数形式返回。"

#: ../../library/asyncio-protocol.rst:380
msgid ""
"Return the transport for the communication pipe corresponding to the integer"
" file descriptor *fd*:"
msgstr "返回对应于整数文件描述符 *fd* 的通信管道的传输:"

#: ../../library/asyncio-protocol.rst:383
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or "
":const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: 标准输入 (*stdin*) 的可读流式传输，如果子进程创建时未设置 ``stdin=PIPE`` 则为 :const:`None`。"

#: ../../library/asyncio-protocol.rst:385
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or "
":const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: 标准输出writable streaming transport of the standard output (*stdout*) "
"的可写流式传输，如果子进程创建时未设置 ``stdout=PIPE`` 则为 :const:`None`。"

#: ../../library/asyncio-protocol.rst:387
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or "
":const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: 标准错误 (*stderr*) 的可写流式传输，如果子进程创建时未设置 ``stderr=PIPE`` 则为 :const:`None`"

#: ../../library/asyncio-protocol.rst:389
msgid "other *fd*: :const:`None`"
msgstr "其他 *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:393
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode`"
" attribute."
msgstr ""
"返回整数形式的进程返回码，或者如果还未返回则为 :const:`None`，这类似于 "
":attr:`subprocess.Popen.returncode` 属性。"

#: ../../library/asyncio-protocol.rst:399
msgid "Kill the subprocess."
msgstr "杀死子进程。"

#: ../../library/asyncio-protocol.rst:401
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"在 POSIX 系统中，函数会发送 SIGKILL 到子进程。 在 Windows 中，此方法是 :meth:`terminate` 的别名。"

#: ../../library/asyncio-protocol.rst:404
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "另请参见 :meth:`subprocess.Popen.kill`。"

#: ../../library/asyncio-protocol.rst:408
msgid ""
"Send the *signal* number to the subprocess, as in "
":meth:`subprocess.Popen.send_signal`."
msgstr "发送 *signal* 编号到子进程，与 :meth:`subprocess.Popen.send_signal` 一样。"

#: ../../library/asyncio-protocol.rst:413
msgid "Stop the subprocess."
msgstr "停止子进程。"

#: ../../library/asyncio-protocol.rst:415
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the "
"subprocess."
msgstr ""
"在 POSIX 系统中，此方法会发送 SIGTERM 到子进程。 在 Windows 中，则会调用 Windows API 函数 "
"TerminateProcess() 来停止子进程。"

#: ../../library/asyncio-protocol.rst:419
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "另请参见 :meth:`subprocess.Popen.terminate`。"

#: ../../library/asyncio-protocol.rst:423
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "通过调用 :meth:`kill` 方法来杀死子进程。"

#: ../../library/asyncio-protocol.rst:425
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr "如果子进程尚未返回，并关闭 *stdin*, *stdout* 和 *stderr* 管道的传输。"

#: ../../library/asyncio-protocol.rst:432
msgid "Protocols"
msgstr "协议"

#: ../../library/asyncio-protocol.rst:434
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio 提供了一组抽象基类，它们应当被用于实现网络协议。 这些类被设计为与 :ref:`传输 <asyncio-transport>` "
"配合使用。"

#: ../../library/asyncio-protocol.rst:438
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"抽象基础协议类的子类可以实现其中的部分或全部方法。 所有这些方法都是回调：它们由传输或特定事件调用，例如当数据被接收的时候。 "
"基础协议方法应当由相应的传输来调用。"

#: ../../library/asyncio-protocol.rst:445
msgid "Base Protocols"
msgstr "基础协议"

#: ../../library/asyncio-protocol.rst:449
msgid "Base protocol with methods that all protocols share."
msgstr "带有所有协议的共享方法的基础协议。"

#: ../../library/asyncio-protocol.rst:453
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, "
"etc)."
msgstr "用于实现流式协议（TCP, Unix 套接字等等）的基类。"

#: ../../library/asyncio-protocol.rst:458
msgid ""
"A base class for implementing streaming protocols with manual control of the"
" receive buffer."
msgstr "用于实现可对接收缓冲区进行手动控制的流式协议的基类。"

#: ../../library/asyncio-protocol.rst:463
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "用于实现数据报（UDP）协议的基类。"

#: ../../library/asyncio-protocol.rst:467
msgid ""
"The base class for implementing protocols communicating with child processes"
" (unidirectional pipes)."
msgstr "用于实现与子进程通信（单向管道）的协议的基类。"

#: ../../library/asyncio-protocol.rst:472
msgid "Base Protocol"
msgstr "基础协议"

#: ../../library/asyncio-protocol.rst:474
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr "所有 asyncio 协议均可实现基础协议回调。"

#: ../../library/asyncio-protocol.rst:477
msgid "Connection Callbacks"
msgstr "链接回调函数"

#: ../../library/asyncio-protocol.rst:478
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr "连接回调会在所有协议上被调用，每个成功的连接将恰好调用一次。 所有其他协议回调只能在以下两个方法之间被调用。"

#: ../../library/asyncio-protocol.rst:484
msgid "Called when a connection is made."
msgstr "链接建立时被调用。"

#: ../../library/asyncio-protocol.rst:486
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr "*transport* 参数是代表连接的传输。 此协议负责将引用保存至对应的传输。"

#: ../../library/asyncio-protocol.rst:492
msgid "Called when the connection is lost or closed."
msgstr "链接丢失或关闭时被调用。"

#: ../../library/asyncio-protocol.rst:494
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr "方法的参数是一个异常对象或为 :const:`None`。 后者意味着收到了常规的 EOF，或者连接被连接的一端取消或关闭。"

#: ../../library/asyncio-protocol.rst:500
msgid "Flow Control Callbacks"
msgstr "流控制回调函数"

#: ../../library/asyncio-protocol.rst:501
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr "流程控制回调可由传输来调用以暂停或恢复协议所执行的写入操作。"

#: ../../library/asyncio-protocol.rst:504
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits`"
" method for more details."
msgstr "请查看 :meth:`~WriteTransport.set_write_buffer_limits` 方法的文档了解详情。"

#: ../../library/asyncio-protocol.rst:509
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "当传输的缓冲区超出高水位时将被调用。"

#: ../../library/asyncio-protocol.rst:513
msgid "Called when the transport's buffer drains below the low watermark."
msgstr "当传输的缓冲区降到低水位以下时将被调用。"

#: ../../library/asyncio-protocol.rst:515
msgid ""
"If the buffer size equals the high watermark, "
":meth:`~BaseProtocol.pause_writing` is not called: the buffer size must go "
"strictly over."
msgstr ""
"如果缓冲区大小等于高水位值，则 :meth:`~BaseProtocol.pause_writing` 不会被调用：缓冲区大小必须要高于该值。"

#: ../../library/asyncio-protocol.rst:519
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"相反地，:meth:`~BaseProtocol.resume_writing` 会在缓冲区大小等于或小于低水位值时被调用。 "
"这些结束条件对于当两个水位取零值时也能确保符合预期的行为是很重要的。"

#: ../../library/asyncio-protocol.rst:526
msgid "Streaming Protocols"
msgstr "流协议"

#: ../../library/asyncio-protocol.rst:528
msgid ""
"Event methods, such as :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :meth:`loop.create_connection`, "
":meth:`loop.create_unix_connection`, :meth:`loop.connect_accepted_socket`, "
":meth:`loop.connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept "
"factories that return streaming protocols."
msgstr ""
"事件方法，例如 :meth:`loop.create_server`, :meth:`loop.create_unix_server`, "
":meth:`loop.create_connection`, :meth:`loop.create_unix_connection`, "
":meth:`loop.connect_accepted_socket`, :meth:`loop.connect_read_pipe` 和 "
":meth:`loop.connect_write_pipe` 都接受返回流式协议的工厂。"

#: ../../library/asyncio-protocol.rst:536
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr "当收到数据时被调用。 *data* 为包含入站数据的非空字节串对象。"

#: ../../library/asyncio-protocol.rst:539
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead"
" make your parsing generic and flexible. However, data is always received in"
" the correct order."
msgstr ""
"数据是否会被缓冲、分块或重组取决于具体传输。 通常，你不应依赖于特定的语义而应使你的解析具有通用性和灵活性。 但是，数据总是要以正确的顺序被接收。"

#: ../../library/asyncio-protocol.rst:544
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr "此方法在连接打开期间可以被调用任意次数。"

#: ../../library/asyncio-protocol.rst:547
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once `eof_received()` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"但是，:meth:`protocol.eof_received() <Protocol.eof_received>` 最多只会被调用一次。 一旦 "
"`eof_received()` 被调用，``data_received()`` 就不会再被调用。"

#: ../../library/asyncio-protocol.rst:553
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"当发出信号的另一端不再继续发送数据时（例如通过调用 :meth:`transport.write_eof() "
"<WriteTransport.write_eof>`，如果另一端也使用 asyncio 的话）被调用。"

#: ../../library/asyncio-protocol.rst:558
msgid ""
"This method may return a false value (including ``None``), in which case the"
" transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"此方法可能返回假值 (包括 ``None``)，在此情况下传输将会自行关闭。 相反地，如果此方法返回真值，将以所用的协议来确定是否要关闭传输。 "
"由于默认实现是返回 ``None``，因此它会隐式地关闭连接。"

#: ../../library/asyncio-protocol.rst:564
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr "某些传输，包括 SSL 在内，并不支持半关闭的连接，在此情况下从该方法返回真值将导致连接被关闭。"

#: ../../library/asyncio-protocol.rst:569
#: ../../library/asyncio-protocol.rst:630
msgid "State machine:"
msgstr "状态机："

#: ../../library/asyncio-protocol.rst:580
msgid "Buffered Streaming Protocols"
msgstr "缓冲流协议"

#: ../../library/asyncio-protocol.rst:582
msgid ""
"**Important:** this has been added to asyncio in Python 3.7 *on a "
"provisional basis*!  This is as an experimental API that might be changed or"
" removed completely in Python 3.8."
msgstr ""

#: ../../library/asyncio-protocol.rst:587
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr "带缓冲的协议可与任何支持 `流式协议`_ 的事件循环方法配合使用。"

#: ../../library/asyncio-protocol.rst:590
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided"
" by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of"
" data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""

#: ../../library/asyncio-protocol.rst:597
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""

#: ../../library/asyncio-protocol.rst:602
msgid "Called to allocate a new receive buffer."
msgstr "调用后会分配新的接收缓冲区。"

#: ../../library/asyncio-protocol.rst:604
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""

#: ../../library/asyncio-protocol.rst:609
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""

#: ../../library/asyncio-protocol.rst:614
msgid "Called when the buffer was updated with the received data."
msgstr "用接收的数据更新缓冲区时被调用。"

#: ../../library/asyncio-protocol.rst:616
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr ""

#: ../../library/asyncio-protocol.rst:620
msgid ""
"See the documentation of the :meth:`protocol.eof_received() "
"<Protocol.eof_received>` method."
msgstr ""

#: ../../library/asyncio-protocol.rst:624
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, "
":meth:`~BufferedProtocol.get_buffer` and "
":meth:`~BufferedProtocol.buffer_updated` won't be called after it."
msgstr ""

#: ../../library/asyncio-protocol.rst:643
msgid "Datagram Protocols"
msgstr "数据报协议"

#: ../../library/asyncio-protocol.rst:645
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""

#: ../../library/asyncio-protocol.rst:650
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the"
" incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Called when a previous send or receive operation raises an :class:`OSError`."
"  *exc* is the :class:`OSError` instance."
msgstr ""

#: ../../library/asyncio-protocol.rst:659
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""

#: ../../library/asyncio-protocol.rst:666
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures"
" caused by writing too many packets."
msgstr ""

#: ../../library/asyncio-protocol.rst:670
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An "
":class:`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not"
" be raised; if it is raised, it will be reported to "
":meth:`DatagramProtocol.error_received` but otherwise ignored."
msgstr ""

#: ../../library/asyncio-protocol.rst:679
msgid "Subprocess Protocols"
msgstr "子进程协议"

#: ../../library/asyncio-protocol.rst:681
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell`"
" methods."
msgstr ""

#: ../../library/asyncio-protocol.rst:687
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""

#: ../../library/asyncio-protocol.rst:690
msgid "*fd* is the integer file descriptor of the pipe."
msgstr ""

#: ../../library/asyncio-protocol.rst:692
msgid "*data* is a non-empty bytes object containing the received data."
msgstr ""

#: ../../library/asyncio-protocol.rst:696
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr "与子进程通信的其中一个管道关闭时被调用。"

#: ../../library/asyncio-protocol.rst:699
msgid "*fd* is the integer file descriptor that was closed."
msgstr ""

#: ../../library/asyncio-protocol.rst:703
msgid "Called when the child process has exited."
msgstr "子进程退出时被调用。"

#: ../../library/asyncio-protocol.rst:707
msgid "Examples"
msgstr "例子"

#: ../../library/asyncio-protocol.rst:712
msgid "TCP Echo Server"
msgstr "TCP回应服务器"

#: ../../library/asyncio-protocol.rst:714
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""

#: ../../library/asyncio-protocol.rst:755
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""

#: ../../library/asyncio-protocol.rst:761
msgid "TCP Echo Client"
msgstr "TCP回应客户端"

#: ../../library/asyncio-protocol.rst:763
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""

#: ../../library/asyncio-protocol.rst:811
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""

#: ../../library/asyncio-protocol.rst:818
msgid "UDP Echo Server"
msgstr "UDP回应服务器"

#: ../../library/asyncio-protocol.rst:820
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""

#: ../../library/asyncio-protocol.rst:862
msgid "UDP Echo Client"
msgstr "UDP回应客户端"

#: ../../library/asyncio-protocol.rst:864
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""

#: ../../library/asyncio-protocol.rst:919
msgid "Connecting Existing Sockets"
msgstr "链接已存在的套接字"

#: ../../library/asyncio-protocol.rst:921
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""

#: ../../library/asyncio-protocol.rst:975
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level "
":meth:`loop.add_reader` method to register an FD."
msgstr ""

#: ../../library/asyncio-protocol.rst:979
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams"
" created by the :func:`open_connection` function in a coroutine."
msgstr ""

#: ../../library/asyncio-protocol.rst:986
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr ""

#: ../../library/asyncio-protocol.rst:988
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""

#: ../../library/asyncio-protocol.rst:991
msgid "The subprocess is created by th :meth:`loop.subprocess_exec` method::"
msgstr ""

#: ../../library/asyncio-protocol.rst:1041
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
