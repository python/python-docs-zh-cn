# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# walkinrain <walkinrain2008@outlook.com>, 2021
# Josh Ouyang <me@joshoy.org>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/copy.rst:2
msgid ":mod:`!copy` --- Shallow and deep copy operations"
msgstr ":mod:`!copy` --- 浅层及深层拷贝操作"

#: ../../library/copy.rst:7
msgid "**Source code:** :source:`Lib/copy.py`"
msgstr "**源代码:** :source:`Lib/copy.py`"

#: ../../library/copy.rst:11
msgid ""
"Assignment statements in Python do not copy objects, they create bindings "
"between a target and an object. For collections that are mutable or contain "
"mutable items, a copy is sometimes needed so one can change one copy without"
" changing the other. This module provides generic shallow and deep copy "
"operations (explained below)."
msgstr ""
"Python "
"的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。"

#: ../../library/copy.rst:18
msgid "Interface summary:"
msgstr "接口摘要："

#: ../../library/copy.rst:22
msgid "Return a shallow copy of *obj*."
msgstr "返回 *obj* 的浅拷贝。"

#: ../../library/copy.rst:27
msgid "Return a deep copy of *obj*."
msgstr "返回 *obj* 的深拷贝。"

#: ../../library/copy.rst:32
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values"
" from *changes*."
msgstr "新建一个与 *obj* 类型相同的对象，使用来自 *changes* 的值替换字段。"

#: ../../library/copy.rst:40
msgid "Raised for module specific errors."
msgstr "针对模块特定错误引发。"

#: ../../library/copy.rst:44
msgid ""
"The difference between shallow and deep copying is only relevant for "
"compound objects (objects that contain other objects, like lists or class "
"instances):"
msgstr "浅层与深层复制的区别仅与复合对象（即包含列表或类的实例等其他对象的对象）相关："

#: ../../library/copy.rst:47
msgid ""
"A *shallow copy* constructs a new compound object and then (to the extent "
"possible) inserts *references* into it to the objects found in the original."
msgstr "*浅层复制* 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 *引用* 插入其中。"

#: ../../library/copy.rst:50
msgid ""
"A *deep copy* constructs a new compound object and then, recursively, "
"inserts *copies* into it of the objects found in the original."
msgstr "*深层复制* 构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 *副本* 插入其中。"

#: ../../library/copy.rst:53
msgid ""
"Two problems often exist with deep copy operations that don't exist with "
"shallow copy operations:"
msgstr "深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题："

#: ../../library/copy.rst:56
msgid ""
"Recursive objects (compound objects that, directly or indirectly, contain a "
"reference to themselves) may cause a recursive loop."
msgstr "递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。"

#: ../../library/copy.rst:59
msgid ""
"Because deep copy copies everything it may copy too much, such as data which"
" is intended to be shared between copies."
msgstr "由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。"

#: ../../library/copy.rst:62
msgid "The :func:`deepcopy` function avoids these problems by:"
msgstr ":func:`deepcopy` 函数用以下方式避免了这些问题："

#: ../../library/copy.rst:64
msgid ""
"keeping a ``memo`` dictionary of objects already copied during the current "
"copying pass; and"
msgstr "保留在当前复制过程中已复制的对象的 \"备忘录\" （``memo``） 字典；以及"

#: ../../library/copy.rst:67
msgid ""
"letting user-defined classes override the copying operation or the set of "
"components copied."
msgstr "允许用户定义的类重写复制操作或复制的组件集合。"

#: ../../library/copy.rst:70
msgid ""
"This module does not copy types like module, method, stack trace, stack "
"frame, file, socket, window, or any similar types.  It does \"copy\" "
"functions and classes (shallow and deeply), by returning the original object"
" unchanged; this is compatible with the way these are treated by the "
":mod:`pickle` module."
msgstr ""
"此模块不会复制模块、方法、栈追踪、栈帧、文件、套接字、窗口以及任何相似的类型。 它会通过不加修改地返回原始对象来（浅层或深层地）“复制”函数和类；这与 "
":mod:`pickle` 模块处理这类问题的方式是兼容的。"

#: ../../library/copy.rst:75
msgid ""
"Shallow copies of dictionaries can be made using :meth:`dict.copy`, and of "
"lists by assigning a slice of the entire list, for example, ``copied_list = "
"original_list[:]``."
msgstr ""
"制作字典的浅层复制可以使用 :meth:`dict.copy` "
"方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，``copied_list = original_list[:]``。"

#: ../../library/copy.rst:81
msgid ""
"Classes can use the same interfaces to control copying that they use to "
"control pickling.  See the description of module :mod:`pickle` for "
"information on these methods.  In fact, the :mod:`copy` module uses the "
"registered pickle functions from the :mod:`copyreg` module."
msgstr ""
"类可以使用与控制序列化（pickling）操作相同的接口来控制复制操作，关于这些方法的描述信息请参考 :mod:`pickle` "
"模块。实际上，:mod:`copy` 模块使用的正是从 :mod:`copyreg` 模块中注册的 pickle 函数。"

#: ../../library/copy.rst:92
msgid ""
"In order for a class to define its own copy implementation, it can define "
"special methods :meth:`~object.__copy__` and :meth:`~object.__deepcopy__`."
msgstr ""
"为了让一个类能够定义它自己的拷贝实现，它可以定义特殊方法 :meth:`~object.__copy__` 和 "
":meth:`~object.__deepcopy__`。"

#: ../../library/copy.rst:98
msgid ""
"Called to implement the shallow copy operation; no additional arguments are "
"passed."
msgstr "调用以实现浅拷贝操作；无须传入任何额外参数。"

#: ../../library/copy.rst:104
msgid ""
"Called to implement the deep copy operation; it is passed one argument, the "
"*memo* dictionary.  If the ``__deepcopy__`` implementation needs to make a "
"deep copy of a component, it should call the :func:`~copy.deepcopy` function"
" with the component as first argument and the *memo* dictionary as second "
"argument. The *memo* dictionary should be treated as an opaque object."
msgstr ""
"调用以实现深拷贝操作；它将传入一个参数，即 *memo* 字典。 如果 ``__deepcopy__`` 实现需要创建一个组件的深拷贝，它应当调用 "
":func:`~copy.deepcopy` 函数并将该组件作为第一个参数而将 *memo* 字典作为第二个参数。 *memo* "
"字典应当被当作不透明对象来处理。"

#: ../../library/copy.rst:114
msgid ""
"Function :func:`!copy.replace` is more limited than :func:`~copy.copy` and "
":func:`~copy.deepcopy`, and only supports named tuples created by "
":func:`~collections.namedtuple`, :mod:`dataclasses`, and other classes which"
" define method :meth:`~object.__replace__`."
msgstr ""
"函数 :func:`!copy.replace` 相比 :func:`~copy.copy` 和 :func:`~copy.deepcopy` "
"受到更多的限制，并且仅支持由 :func:`~collections.namedtuple` 创建的元组, :mod:`dataclasses` "
"及其他定义了 :meth:`~object.__replace__` 方法的类。"

#: ../../library/copy.rst:122
msgid ""
"This method should create a new object of the same type, replacing fields "
"with values from *changes*."
msgstr "此函数应当新建一个具有相同类型的对象，使用来自 *changes* 的值替换字段。"

#: ../../library/copy.rst:128
msgid "Module :mod:`pickle`"
msgstr "模块 :mod:`pickle`"

#: ../../library/copy.rst:129
msgid ""
"Discussion of the special methods used to support object state retrieval and"
" restoration."
msgstr "讨论了支持对象状态检索和恢复的特殊方法。"

#: ../../library/copy.rst:79
msgid "module"
msgstr "module"

#: ../../library/copy.rst:79
msgid "pickle"
msgstr "pickle"

#: ../../library/copy.rst:86
msgid "__copy__() (copy protocol)"
msgstr "__copy__() (拷贝协议)"

#: ../../library/copy.rst:86
msgid "__deepcopy__() (copy protocol)"
msgstr "__deepcopy__() (拷贝协议)"

#: ../../library/copy.rst:111
msgid "__replace__() (replace protocol)"
msgstr "__replace__() (replace 协议)"
