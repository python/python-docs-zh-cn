# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# jacky <jackylvm@foxmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:05+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.errors.rst:2
msgid ":mod:`email.errors`: Exception and Defect classes"
msgstr ":mod:`email.errors`: 异常和缺陷类"

#: ../../library/email.errors.rst:7
msgid "**Source code:** :source:`Lib/email/errors.py`"
msgstr "**源代码:** :source:`Lib/email/errors.py`"

#: ../../library/email.errors.rst:11
msgid ""
"The following exception classes are defined in the :mod:`email.errors` "
"module:"
msgstr "以下异常类在 :mod:`email.errors` 模块中定义："

#: ../../library/email.errors.rst:16
msgid ""
"This is the base class for all exceptions that the :mod:`email` package can "
"raise.  It is derived from the standard :exc:`Exception` class and defines "
"no additional methods."
msgstr ""
"这是 :mod:`email` 包可以引发的所有异常的基类。 它源自标准异常 :exc:`Exception` 类，这个类没有定义其他方法。"

#: ../../library/email.errors.rst:23
msgid ""
"This is the base class for exceptions raised by the "
":class:`~email.parser.Parser` class.  It is derived from "
":exc:`MessageError`.  This class is also used internally by the parser used "
"by :mod:`~email.headerregistry`."
msgstr ""
"这是由 :class:`~email.parser.Parser` 类引发的异常的基类。它派生自 :exc:`MessageError`。 "
":mod:`~email.headerregistry` 使用的解析器也在内部使用这个类。"

#: ../../library/email.errors.rst:31
msgid ""
"Raised under some error conditions when parsing the :rfc:`5322` headers of a"
" message, this class is derived from :exc:`MessageParseError`.  The "
":meth:`~email.message.EmailMessage.set_boundary` method will raise this "
"error if the content type is unknown when the method is called. "
":class:`~email.header.Header` may raise this error for certain base64 "
"decoding errors, and when an attempt is made to create a header that appears"
" to contain an embedded header (that is, there is what is supposed to be a "
"continuation line that has no leading whitespace and looks like a header)."
msgstr ""
"在解析消息的 :rfc:`5322` 标头时，某些错误条件下会触发，此类派生自 :exc:`MessageParseError`。 "
"如果在调用方法时内容类型未知，则 :meth:`~email.message.EmailMessage.set_boundary` 方法将引发此错误。 "
"当尝试创建一个看起来包含嵌入式标头的标头时 :class:`~email.header.Header` 可能会针对某些 base64 "
"解码错误引发此错误（也就是说，应该是一个 没有前导空格并且看起来像标题的延续行）。"

#: ../../library/email.errors.rst:43
msgid "Deprecated and no longer used."
msgstr "已弃用和不再使用的。"

#: ../../library/email.errors.rst:48
msgid ""
"Raised when a payload is added to a :class:`~email.message.Message` object "
"using :meth:`add_payload`, but the payload is already a scalar and the "
"message's :mailheader:`Content-Type` main type is not either "
":mimetype:`multipart` or missing.  :exc:`MultipartConversionError` multiply "
"inherits from :exc:`MessageError` and the built-in :exc:`TypeError`."
msgstr ""
"当使用 :meth:`add_payload` 将有效负载添加到 :class:`~email.message.Message` "
"对象时，有效负载已经是一个标量，而消息的 :mailheader:`Content-Type` 主类型不是 :mimetype:`multipart` "
"或者缺少时触发该异常。 :exc:`MultipartConversionError` 多重继承自 :exc:`MessageError` 和内置的 "
":exc:`TypeError`。"

#: ../../library/email.errors.rst:54
msgid ""
"Since :meth:`Message.add_payload` is deprecated, this exception is rarely "
"raised in practice.  However the exception may also be raised if the "
":meth:`~email.message.Message.attach` method is called on an instance of a "
"class derived from :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g. "
":class:`~email.mime.image.MIMEImage`)."
msgstr ""
"由于 :meth:`Message.add_payload` 已被弃用，此异常实际上极少会被引发。 但是如果在派生自 "
":class:`~email.mime.nonmultipart.MIMENonMultipart` 的类 (例如 "
":class:`~email.mime.image.MIMEImage`) 的实例上调用 "
":meth:`~email.message.Message.attach` 方法也可以引发此异常。"

#: ../../library/email.errors.rst:62
msgid ""
"Here is the list of the defects that the :class:`~email.parser.FeedParser` "
"can find while parsing messages.  Note that the defects are added to the "
"message where the problem was found, so for example, if a message nested "
"inside a :mimetype:`multipart/alternative` had a malformed header, that "
"nested message object would have a defect, but the containing messages would"
" not."
msgstr ""
"以下是 :class:`~email.parser.FeedParser` 在解析消息时可发现的缺陷列表。 "
"请注意这些缺陷会在问题被发现时加入到消息中，因此举例来说，如果某条嵌套在 :mimetype:`multipart/alternative` "
"中的消息具有错误的标头，该嵌套消息对象就会有一条缺陷，但外层消息对象则没有。"

#: ../../library/email.errors.rst:68
msgid ""
"All defect classes are subclassed from :class:`email.errors.MessageDefect`."
msgstr "所有缺陷类都是 :class:`email.errors.MessageDefect` 的子类。"

#: ../../library/email.errors.rst:70
msgid ""
":class:`NoBoundaryInMultipartDefect` -- A message claimed to be a multipart,"
" but had no :mimetype:`boundary` parameter."
msgstr ""
":class:`NoBoundaryInMultipartDefect` -- 一条消息宣称有多个部分，但却没有 "
":mimetype:`boundary` 形参。"

#: ../../library/email.errors.rst:73
msgid ""
":class:`StartBoundaryNotFoundDefect` -- The start boundary claimed in the "
":mailheader:`Content-Type` header was never found."
msgstr ""
":class:`StartBoundaryNotFoundDefect` -- 在 :mailheader:`Content-Type` "
"标头中宣称的开始边界无法被找到。"

#: ../../library/email.errors.rst:76
msgid ""
":class:`CloseBoundaryNotFoundDefect` -- A start boundary was found, but no "
"corresponding close boundary was ever found."
msgstr ":class:`CloseBoundaryNotFoundDefect` -- 找到了开始边界，但相应的结束边界无法被找到。"

#: ../../library/email.errors.rst:81
msgid ""
":class:`FirstHeaderLineIsContinuationDefect` -- The message had a "
"continuation line as its first header line."
msgstr ":class:`FirstHeaderLineIsContinuationDefect` -- 消息以一个继续行作为其第一个标头行。"

#: ../../library/email.errors.rst:84
msgid ""
":class:`MisplacedEnvelopeHeaderDefect` - A \"Unix From\" header was found in"
" the middle of a header block."
msgstr ":class:`MisplacedEnvelopeHeaderDefect` - 在标头块中间发现了一个 \"Unix From\" 标头。"

#: ../../library/email.errors.rst:87
msgid ""
":class:`MissingHeaderBodySeparatorDefect` - A line was found while parsing "
"headers that had no leading white space but contained no ':'.  Parsing "
"continues assuming that the line represents the first line of the body."
msgstr ""
":class:`MissingHeaderBodySeparatorDefect` - 在解析没有前缀空格但又不包含 ':' 的标头期间找到一行内容。 "
"解析将假定该行表示消息体的第一行以继续执行。"

#: ../../library/email.errors.rst:93
msgid ""
":class:`MalformedHeaderDefect` -- A header was found that was missing a "
"colon, or was otherwise malformed."
msgstr ":class:`MalformedHeaderDefect` -- 找到一个缺失了冒号或格式错误的标头。"

#: ../../library/email.errors.rst:96
msgid "This defect has not been used for several Python versions."
msgstr "此缺陷在近几个 Python 版本中已不再使用。"

#: ../../library/email.errors.rst:99
msgid ""
":class:`MultipartInvariantViolationDefect` -- A message claimed to be a "
":mimetype:`multipart`, but no subparts were found.  Note that when a message"
" has this defect, its :meth:`~email.message.Message.is_multipart` method may"
" return ``False`` even though its content type claims to be "
":mimetype:`multipart`."
msgstr ""
":class:`MultipartInvariantViolationDefect` -- 一条消息宣称为 "
":mimetype:`multipart`，但无法找到任何子部分。 请注意当一条消息有此缺陷时，其 "
":meth:`~email.message.Message.is_multipart` 方法可能返回 ``False``，即使其内容类型宣称为 "
":mimetype:`multipart`。"

#: ../../library/email.errors.rst:104
msgid ""
":class:`InvalidBase64PaddingDefect` -- When decoding a block of base64 "
"encoded bytes, the padding was not correct.  Enough padding is added to "
"perform the decode, but the resulting decoded bytes may be invalid."
msgstr ""
":class:`InvalidBase64PaddingDefect` -- 当解码一个 base64 编码的字节分块时，填充的数据不正确。 "
"虽然添加了足够的填充数据以执行解码，但作为结果的已解码字节串可能无效。"

#: ../../library/email.errors.rst:108
msgid ""
":class:`InvalidBase64CharactersDefect` -- When decoding a block of base64 "
"encoded bytes, characters outside the base64 alphabet were encountered. The "
"characters are ignored, but the resulting decoded bytes may be invalid."
msgstr ""
":class:`InvalidBase64CharactersDefect` -- 当解码一个 base64 编码的字节分块时，遇到了 base64 "
"字符表以外的字符。 这些字符会被忽略，但作为结果的已解码字节串可能无效。"

#: ../../library/email.errors.rst:112
msgid ""
":class:`InvalidBase64LengthDefect` -- When decoding a block of base64 "
"encoded bytes, the number of non-padding base64 characters was invalid (1 "
"more than a multiple of 4).  The encoded block was kept as-is."
msgstr ""
":class:`InvalidBase64LengthDefect` -- 当解码一个 base64 编码的字节分块时，非填充 base64 "
"字符的数量无效（比 4 的倍数多 1）。 已编码分块会保持原样。"

#: ../../library/email.errors.rst:116
msgid ""
":class:`InvalidDateDefect` -- When decoding an invalid or unparsable date "
"field. The original value is kept as-is."
msgstr ":class:`InvalidDateDefect` -- 当解码一个无效或不可解析的数据字段时引发。 原始值会被保持原样。"
