# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/inspect.rst:2
msgid ":mod:`!inspect` --- Inspect live objects"
msgstr ":mod:`!inspect` --- 检查当前对象"

#: ../../library/inspect.rst:15
msgid "**Source code:** :source:`Lib/inspect.py`"
msgstr "**源代码:** :source:`Lib/inspect.py`"

#: ../../library/inspect.rst:19
msgid ""
"The :mod:`inspect` module provides several useful functions to help get "
"information about live objects such as modules, classes, methods, functions,"
" tracebacks, frame objects, and code objects.  For example, it can help you "
"examine the contents of a class, retrieve the source code of a method, "
"extract and format the argument list for a function, or get all the "
"information you need to display a detailed traceback."
msgstr ""
":mod:`inspect` "
"模块提供了一些有用的函数帮助获取对象的信息，例如模块、类、方法、函数、回溯、帧对象以及代码对象。例如它可以帮助你检查类的内容，获取某个方法的源代码，取得并格式化某个函数的参数列表，或者获取你需要显示的回溯的详细信息。"

#: ../../library/inspect.rst:26
msgid ""
"There are four main kinds of services provided by this module: type "
"checking, getting source code, inspecting classes and functions, and "
"examining the interpreter stack."
msgstr "该模块提供了4种主要的功能：类型检查、获取源代码、检查类与函数、检查解释器的调用堆栈。"

#: ../../library/inspect.rst:34
msgid "Types and members"
msgstr "类型和成员"

#: ../../library/inspect.rst:36
msgid ""
"The :func:`getmembers` function retrieves the members of an object such as a"
" class or module. The functions whose names begin with \"is\" are mainly "
"provided as convenient choices for the second argument to "
":func:`getmembers`. They also help you determine when you can expect to find"
" the following special attributes (see :ref:`import-mod-attrs` for module "
"attributes):"
msgstr ""
":func:`getmembers` 函数获取对象如类或模块的成员。 名称以“is”打头的函数主要是作为传给 :func:`getmembers` "
"的第二个参数的便捷选项提供的。 它们还可帮助你确定你是否能找到下列特殊属性（请参阅 :ref:`import-mod-attrs` "
"了解有关模块属性的详情）:"

#: ../../library/inspect.rst:46
msgid "Type"
msgstr "类型"

#: ../../library/inspect.rst:46
msgid "Attribute"
msgstr "属性"

#: ../../library/inspect.rst:46
msgid "Description"
msgstr "描述"

#: ../../library/inspect.rst:48
msgid "class"
msgstr "class -- 类"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:292
msgid "__doc__"
msgstr "__doc__"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:292
msgid "documentation string"
msgstr "文档字符串"

#: ../../library/inspect.rst:50 ../../library/inspect.rst:65
#: ../../library/inspect.rst:83 ../../library/inspect.rst:248
#: ../../library/inspect.rst:262 ../../library/inspect.rst:275
#: ../../library/inspect.rst:294
msgid "__name__"
msgstr "__name__"

#: ../../library/inspect.rst:50
msgid "name with which this class was defined"
msgstr "类定义时所使用的名称"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:250
#: ../../library/inspect.rst:264 ../../library/inspect.rst:277
#: ../../library/inspect.rst:297
msgid "__qualname__"
msgstr "__qualname__"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:250
#: ../../library/inspect.rst:264 ../../library/inspect.rst:277
#: ../../library/inspect.rst:297
msgid "qualified name"
msgstr "qualified name -- 限定名称"

#: ../../library/inspect.rst:55 ../../library/inspect.rst:78
#: ../../library/inspect.rst:116
msgid "__module__"
msgstr "__module__"

#: ../../library/inspect.rst:55
msgid "name of module in which this class was defined"
msgstr "该类型被定义时所在的模块的名称"

#: ../../library/inspect.rst:58 ../../library/inspect.rst:111
msgid "__type_params__"
msgstr "__type_params__"

#: ../../library/inspect.rst:58
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"class"
msgstr "一个包含泛型类的 :ref:`类型形参 <type-params>` 的元组"

#: ../../library/inspect.rst:63
msgid "method"
msgstr "method -- 方法"

#: ../../library/inspect.rst:65
msgid "name with which this method was defined"
msgstr "该方法定义时所使用的名称"

#: ../../library/inspect.rst:70
msgid "__func__"
msgstr "__func__"

#: ../../library/inspect.rst:70
msgid "function object containing implementation of method"
msgstr "实现该方法的函数对象"

#: ../../library/inspect.rst:74 ../../library/inspect.rst:299
msgid "__self__"
msgstr "__self__"

#: ../../library/inspect.rst:74
msgid "instance to which this method is bound, or ``None``"
msgstr "该方法被绑定的实例，若没有绑定则为 ``None``"

#: ../../library/inspect.rst:78
msgid "name of module in which this method was defined"
msgstr "定义此方法的模块的名称"

#: ../../library/inspect.rst:81
msgid "function"
msgstr "function -- 函数"

#: ../../library/inspect.rst:83
msgid "name with which this function was defined"
msgstr "用于定义此函数的名称"

#: ../../library/inspect.rst:88
msgid "__code__"
msgstr "__code__"

#: ../../library/inspect.rst:88
msgid "code object containing compiled function :term:`bytecode`"
msgstr "包含已编译函数的代码对象 :term:`bytecode`"

#: ../../library/inspect.rst:92
msgid "__defaults__"
msgstr "__defaults__"

#: ../../library/inspect.rst:92
msgid "tuple of any default values for positional or keyword parameters"
msgstr "所有位置或关键字参数的默认值的元组"

#: ../../library/inspect.rst:96
msgid "__kwdefaults__"
msgstr "__kwdefaults__"

#: ../../library/inspect.rst:96
msgid "mapping of any default values for keyword-only parameters"
msgstr "保存仅关键字参数的所有默认值的映射"

#: ../../library/inspect.rst:100
msgid "__globals__"
msgstr "__globals__"

#: ../../library/inspect.rst:100
msgid "global namespace in which this function was defined"
msgstr "此函数定义所在的全局命名空间"

#: ../../library/inspect.rst:103
msgid "__builtins__"
msgstr "__builtins__"

#: ../../library/inspect.rst:103
msgid "builtins namespace"
msgstr "builtins 命名空间"

#: ../../library/inspect.rst:105
msgid "__annotations__"
msgstr "__annotations__"

#: ../../library/inspect.rst:105
msgid ""
"mapping of parameters names to annotations; ``\"return\"`` key is reserved "
"for return annotations."
msgstr "参数名称到注解的映射；保留键 ``\"return\"`` 用于返回值注解。"

#: ../../library/inspect.rst:111
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"function"
msgstr "一个包含泛型函数的 :ref:`类型形参 <type-params>` 的元组"

#: ../../library/inspect.rst:116
msgid "name of module in which this function was defined"
msgstr "此函数定义所在的模块名称"

#: ../../library/inspect.rst:119
msgid "traceback"
msgstr "traceback -- 回溯"

#: ../../library/inspect.rst:119
msgid "tb_frame"
msgstr "tb_frame"

#: ../../library/inspect.rst:119
msgid "frame object at this level"
msgstr "此层的帧对象"

#: ../../library/inspect.rst:122
msgid "tb_lasti"
msgstr "tb_lasti"

#: ../../library/inspect.rst:122 ../../library/inspect.rst:144
msgid "index of last attempted instruction in bytecode"
msgstr "在字节码中最后尝试的指令的索引"

#: ../../library/inspect.rst:125
msgid "tb_lineno"
msgstr "tb_lineno"

#: ../../library/inspect.rst:125 ../../library/inspect.rst:147
msgid "current line number in Python source code"
msgstr "当前行在 Python 源代码中的行号"

#: ../../library/inspect.rst:128
msgid "tb_next"
msgstr "tb_next"

#: ../../library/inspect.rst:128
msgid "next inner traceback object (called by this level)"
msgstr "下一个内部回溯对象（由本层调用）"

#: ../../library/inspect.rst:132 ../../library/inspect.rst:252
#: ../../library/inspect.rst:269 ../../library/inspect.rst:282
msgid "frame"
msgstr "frame -- 帧"

#: ../../library/inspect.rst:132
msgid "f_back"
msgstr "f_back"

#: ../../library/inspect.rst:132
msgid "next outer frame object (this frame's caller)"
msgstr "下一个外部帧对象（此帧的调用者）"

#: ../../library/inspect.rst:135
msgid "f_builtins"
msgstr "f_builtins"

#: ../../library/inspect.rst:135
msgid "builtins namespace seen by this frame"
msgstr "此帧执行时所在的 builtins 命名空间"

#: ../../library/inspect.rst:138
msgid "f_code"
msgstr "f_code"

#: ../../library/inspect.rst:138
msgid "code object being executed in this frame"
msgstr "在此帧中执行的代码对象"

#: ../../library/inspect.rst:141
msgid "f_globals"
msgstr "f_globals"

#: ../../library/inspect.rst:141
msgid "global namespace seen by this frame"
msgstr "此帧执行时所在的全局命名空间"

#: ../../library/inspect.rst:144
msgid "f_lasti"
msgstr "f_lasti"

#: ../../library/inspect.rst:147
msgid "f_lineno"
msgstr "f_lineno"

#: ../../library/inspect.rst:150
msgid "f_locals"
msgstr "f_locals"

#: ../../library/inspect.rst:150
msgid "local namespace seen by this frame"
msgstr "此帧所看到的局部命名空间"

#: ../../library/inspect.rst:153
msgid "f_generator"
msgstr "f_generator"

#: ../../library/inspect.rst:153
msgid ""
"returns the generator or coroutine object that owns this frame, or ``None`` "
"if the frame is of a regular function"
msgstr "返回拥有该帧的生成器或协程，或者如果该帧是属于常规函数则返回 ``None``"

#: ../../library/inspect.rst:159
msgid "f_trace"
msgstr "f_trace"

#: ../../library/inspect.rst:159
msgid "tracing function for this frame, or ``None``"
msgstr "此帧的追踪函数，或 ``None``"

#: ../../library/inspect.rst:162
msgid "f_trace_lines"
msgstr "f_trace_lines"

#: ../../library/inspect.rst:162
msgid ""
"indicate whether a tracing event is triggered for each source source line"
msgstr "指明一个追踪事件是否针对每个源代码行触发"

#: ../../library/inspect.rst:167
msgid "f_trace_opcodes"
msgstr "f_trace_opcodes"

#: ../../library/inspect.rst:167
msgid "indicate whether per-opcode events are requested"
msgstr "指示是否请求每个操作码事件"

#: ../../library/inspect.rst:171
msgid "clear()"
msgstr "clear()"

#: ../../library/inspect.rst:171
msgid "used to clear all references to local variables"
msgstr "用于清除对局部变量的所有引用"

#: ../../library/inspect.rst:175 ../../library/inspect.rst:256
#: ../../library/inspect.rst:273 ../../library/inspect.rst:286
msgid "code"
msgstr "code -- 代码"

#: ../../library/inspect.rst:175
msgid "co_argcount"
msgstr "co_argcount"

#: ../../library/inspect.rst:175
msgid ""
"number of arguments (not including keyword only arguments, \\* or \\*\\* "
"args)"
msgstr "参数数量（不包括仅关键字参数、\\* 或 \\*\\* 参数）"

#: ../../library/inspect.rst:180
msgid "co_code"
msgstr "co_code"

#: ../../library/inspect.rst:180
msgid "string of raw compiled bytecode"
msgstr "字符串形式的原始字节码"

#: ../../library/inspect.rst:183
msgid "co_cellvars"
msgstr "co_cellvars"

#: ../../library/inspect.rst:183
msgid "tuple of names of cell variables (referenced by containing scopes)"
msgstr "单元变量名称的元组(通过包含作用域引用)"

#: ../../library/inspect.rst:187
msgid "co_consts"
msgstr "co_consts"

#: ../../library/inspect.rst:187
msgid "tuple of constants used in the bytecode"
msgstr "字节码中使用的常量元组"

#: ../../library/inspect.rst:190
msgid "co_filename"
msgstr "co_filename"

#: ../../library/inspect.rst:190
msgid "name of file in which this code object was created"
msgstr "创建此代码对象的文件的名称"

#: ../../library/inspect.rst:194
msgid "co_firstlineno"
msgstr "co_firstlineno"

#: ../../library/inspect.rst:194
msgid "number of first line in Python source code"
msgstr "第一行在Python源代码中的行号"

#: ../../library/inspect.rst:197
msgid "co_flags"
msgstr "co_flags"

#: ../../library/inspect.rst:197
msgid ""
"bitmap of ``CO_*`` flags, read more :ref:`here <inspect-module-co-flags>`"
msgstr "``CO_*`` 标志的位图，详见 :ref:`此处 <inspect-module-co-flags>`"

#: ../../library/inspect.rst:201
msgid "co_lnotab"
msgstr "co_lnotab"

#: ../../library/inspect.rst:201
msgid "encoded mapping of line numbers to bytecode indices"
msgstr "编码的行号到字节码索引的映射"

#: ../../library/inspect.rst:205
msgid "co_freevars"
msgstr "co_freevars"

#: ../../library/inspect.rst:205
msgid "tuple of names of free variables (referenced via a function's closure)"
msgstr "自由变量的名字组成的元组（通过函数闭包引用）"

#: ../../library/inspect.rst:209
msgid "co_posonlyargcount"
msgstr "co_posonlyargcount"

#: ../../library/inspect.rst:209
msgid "number of positional only arguments"
msgstr "仅限位置参数的数量"

#: ../../library/inspect.rst:212
msgid "co_kwonlyargcount"
msgstr "co_kwonlyargcount"

#: ../../library/inspect.rst:212
msgid "number of keyword only arguments (not including \\*\\* arg)"
msgstr "仅限关键字参数的数量（不包括 \\*\\* 参数）"

#: ../../library/inspect.rst:216
msgid "co_name"
msgstr "co_name"

#: ../../library/inspect.rst:216
msgid "name with which this code object was defined"
msgstr "定义此代码对象的名称"

#: ../../library/inspect.rst:219
msgid "co_qualname"
msgstr "co_qualname"

#: ../../library/inspect.rst:219
msgid "fully qualified name with which this code object was defined"
msgstr "定义此代码对象的完整限定名称"

#: ../../library/inspect.rst:223
msgid "co_names"
msgstr "co_names"

#: ../../library/inspect.rst:223
msgid "tuple of names other than arguments and function locals"
msgstr "除参数和函数局部变量之外的名称元组"

#: ../../library/inspect.rst:227
msgid "co_nlocals"
msgstr "co_nlocals"

#: ../../library/inspect.rst:227
msgid "number of local variables"
msgstr "局部变量的数量"

#: ../../library/inspect.rst:229
msgid "co_stacksize"
msgstr "co_stacksize"

#: ../../library/inspect.rst:229
msgid "virtual machine stack space required"
msgstr "需要虚拟机堆栈空间"

#: ../../library/inspect.rst:232
msgid "co_varnames"
msgstr "co_varnames"

#: ../../library/inspect.rst:232
msgid "tuple of names of arguments and local variables"
msgstr "参数名和局部变量的元组"

#: ../../library/inspect.rst:236
msgid "co_lines()"
msgstr "co_lines()"

#: ../../library/inspect.rst:236
msgid "returns an iterator that yields successive bytecode ranges"
msgstr "返回产生连续字节码范围的迭代器"

#: ../../library/inspect.rst:240
msgid "co_positions()"
msgstr "co_positions()"

#: ../../library/inspect.rst:240
msgid ""
"returns an iterator of source code positions for each bytecode instruction"
msgstr "返回每个字节码指令的源代码位置的迭代器"

#: ../../library/inspect.rst:244
msgid "replace()"
msgstr "replace()"

#: ../../library/inspect.rst:244
msgid "returns a copy of the code object with new values"
msgstr "返回具有新值的代码对象的副本"

#: ../../library/inspect.rst:248
msgid "generator"
msgstr "generator -- 生成器"

#: ../../library/inspect.rst:248 ../../library/inspect.rst:262
#: ../../library/inspect.rst:275
msgid "name"
msgstr "名称"

#: ../../library/inspect.rst:252
msgid "gi_frame"
msgstr "gi_frame"

#: ../../library/inspect.rst:254
msgid "gi_running"
msgstr "gi_running"

#: ../../library/inspect.rst:254 ../../library/inspect.rst:271
msgid "is the generator running?"
msgstr "生成器在运行吗？"

#: ../../library/inspect.rst:256
msgid "gi_code"
msgstr "gi_code"

#: ../../library/inspect.rst:258
msgid "gi_yieldfrom"
msgstr "gi_yieldfrom"

#: ../../library/inspect.rst:258
msgid "object being iterated by ``yield from``, or ``None``"
msgstr "通过 ``yield from``迭代的对象，或``None``"

#: ../../library/inspect.rst:262
msgid "async generator"
msgstr "异步生成器"

#: ../../library/inspect.rst:266
msgid "ag_await"
msgstr "ag_await"

#: ../../library/inspect.rst:266 ../../library/inspect.rst:279
msgid "object being awaited on, or ``None``"
msgstr "正在等待的对象，或 ``None``"

#: ../../library/inspect.rst:269
msgid "ag_frame"
msgstr "ag_frame"

#: ../../library/inspect.rst:271
msgid "ag_running"
msgstr "ag_running"

#: ../../library/inspect.rst:273
msgid "ag_code"
msgstr "ag_code"

#: ../../library/inspect.rst:275
msgid "coroutine"
msgstr "coroutine -- 协程"

#: ../../library/inspect.rst:279
msgid "cr_await"
msgstr "cr_await"

#: ../../library/inspect.rst:282
msgid "cr_frame"
msgstr "cr_frame"

#: ../../library/inspect.rst:284
msgid "cr_running"
msgstr "cr_running"

#: ../../library/inspect.rst:284
msgid "is the coroutine running?"
msgstr "这个协程正在运行吗？"

#: ../../library/inspect.rst:286
msgid "cr_code"
msgstr "cr_code"

#: ../../library/inspect.rst:288
msgid "cr_origin"
msgstr "cr_origin"

#: ../../library/inspect.rst:288
msgid "where coroutine was created, or ``None``. See |coroutine-origin-link|"
msgstr "协程被创建的位置，或 ``None``。参见 |coroutine-origin-link|"

#: ../../library/inspect.rst:292
msgid "builtin"
msgstr "builtin"

#: ../../library/inspect.rst:294
msgid "original name of this function or method"
msgstr "此函数或方法的原始名称"

#: ../../library/inspect.rst:299
msgid "instance to which a method is bound, or ``None``"
msgstr "方法绑定到的实例，或 ``None``"

#: ../../library/inspect.rst:306
msgid "Add ``__qualname__`` and ``gi_yieldfrom`` attributes to generators."
msgstr "为生成器添加 ``__qualname__`` 和 ``gi_yieldfrom`` 属性。"

#: ../../library/inspect.rst:308
msgid ""
"The ``__name__`` attribute of generators is now set from the function name, "
"instead of the code name, and it can now be modified."
msgstr "生成器的 ``__name__`` 属性现在由函数名称设置，而不是代码对象名称，并且现在可以被修改。"

#: ../../library/inspect.rst:313
msgid "Add ``cr_origin`` attribute to coroutines."
msgstr "为协程添加 ``cr_origin`` 属性。"

#: ../../library/inspect.rst:317
msgid "Add ``__builtins__`` attribute to functions."
msgstr "为函数添加 ``__builtins__`` 属性。"

#: ../../library/inspect.rst:321
msgid "Add ``f_generator`` attribute to frames."
msgstr "为帧添加 ``f_generator`` 属性。"

#: ../../library/inspect.rst:325
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name. If the optional *predicate* argument—which will be called "
"with the ``value`` object of each member—is supplied, only members for which"
" the predicate returns a true value are included."
msgstr ""
"返回一个对象上的所有成员，组成以 ``(名称, 值)`` 对为元素的列表，按名称排序。如果提供了可选的 *predicate* 参数（会对每个成员的 "
"``值`` 对象进行一次调用），则仅包含该断言为真的成员。"

#: ../../library/inspect.rst:332
msgid ""
":func:`getmembers` will only return class attributes defined in the "
"metaclass when the argument is a class and those attributes have been listed"
" in the metaclass' custom :meth:`~object.__dir__`."
msgstr ""
"当参数是一个类且这些属性在元类的自定义方法 :meth:`~object.__dir__` 中列出时 :func:`getmembers` "
"将只返回在元类中定义的类属性。"

#: ../../library/inspect.rst:339
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name without triggering dynamic lookup via the descriptor "
"protocol, __getattr__ or __getattribute__. Optionally, only return members "
"that satisfy a given predicate."
msgstr ""
"将一个对象的所有成员作为由 ``(name, value)`` 对组成并按名称排序的列表返回而不触发通过描述器协议 __getattr__ 或 "
"__getattribute__ 执行的动态查找。 或是作为可选项，只返回满足给定预期的成员。"

#: ../../library/inspect.rst:346
msgid ""
":func:`getmembers_static` may not be able to retrieve all members that "
"getmembers can fetch (like dynamically created attributes) and may find "
"members that getmembers can't (like descriptors that raise AttributeError). "
"It can also return descriptor objects instead of instance members in some "
"cases."
msgstr ""
":func:`getmembers_static` 可能无法获得 getmembers 所能获取的所有成员（如动态创建的属性）并且可能会找到一些 "
"getmembers 所不能找到的成员（如会引发 AttributeError 的描述器）。 在某些情况下它还能返回描述器对象而不是实例成员。"

#: ../../library/inspect.rst:357
msgid ""
"Return the name of the module named by the file *path*, without including "
"the names of enclosing packages. The file extension is checked against all "
"of the entries in :func:`importlib.machinery.all_suffixes`. If it matches, "
"the final path component is returned with the extension removed. Otherwise, "
"``None`` is returned."
msgstr ""
"返回由文件名 *path* 表示的模块名字，但不包括外层的包名。文件扩展名会检查是否在 "
":func:`importlib.machinery.all_suffixes` "
"列出的条目中。如果符合，则文件路径的最后一个组成部分会去掉后缀名后被返回；否则返回 ``None``。"

#: ../../library/inspect.rst:363
msgid ""
"Note that this function *only* returns a meaningful name for actual Python "
"modules - paths that potentially refer to Python packages will still return "
"``None``."
msgstr ""
"值得注意的是，这个函数 *仅* 返回可以作为 Python 模块的名字，而有可能指向一个 Python 包的路径仍然会返回 ``None``。"

#: ../../library/inspect.rst:367
msgid "The function is based directly on :mod:`importlib`."
msgstr "该函数直接基于 :mod:`importlib`。"

#: ../../library/inspect.rst:373
msgid "Return ``True`` if the object is a module."
msgstr "当该对象是一个模块时返回 ``True``。"

#: ../../library/inspect.rst:378
msgid ""
"Return ``True`` if the object is a class, whether built-in or created in "
"Python code."
msgstr "当该对象是一个类时返回 ``True``，无论是内置类或者 Python 代码中定义的类。"

#: ../../library/inspect.rst:384
msgid "Return ``True`` if the object is a bound method written in Python."
msgstr "当该对象是一个 Python 写成的绑定方法时返回 ``True``。"

#: ../../library/inspect.rst:389
msgid "Return ``True`` if the object is a :term:`package`."
msgstr "如果该对象是一个 :term:`package` 则返回 ``True``。"

#: ../../library/inspect.rst:396
msgid ""
"Return ``True`` if the object is a Python function, which includes functions"
" created by a :term:`lambda` expression."
msgstr "当该对象是一个 Python 函数时（包括使用 :term:`lambda` 表达式创造的函数），返回 ``True``。"

#: ../../library/inspect.rst:402
msgid "Return ``True`` if the object is a Python generator function."
msgstr "当该对象是一个 Python 生成器函数时返回 ``True``。"

#: ../../library/inspect.rst:404
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is a Python generator function."
msgstr ""
"对于使用 :func:`functools.partial` 封装的函数，如果被封装的函数是一个 Python 生成器函数，现在也会返回 "
"``True``。"

#: ../../library/inspect.rst:408
msgid ""
"Functions wrapped in :func:`functools.partialmethod` now return ``True`` if "
"the wrapped function is a Python generator function."
msgstr ""
"现在对于使用 :func:`functools.partialmethod` 包装的函数，如果被包装的函数是一个 Python 生成器函数则返回 "
"``True``。"

#: ../../library/inspect.rst:414
msgid "Return ``True`` if the object is a generator."
msgstr "当该对象是一个生成器时返回 ``True``。"

#: ../../library/inspect.rst:419
msgid ""
"Return ``True`` if the object is a :term:`coroutine function` (a function "
"defined with an :keyword:`async def` syntax), a :func:`functools.partial` "
"wrapping a :term:`coroutine function`, or a sync function marked with "
":func:`markcoroutinefunction`."
msgstr ""
"如果该对象为 :term:`coroutine function` (使用 :keyword:`async def` 语法定义的函数), 包装了 "
":term:`coroutine function` 的 :func:`functools.partial` 或使用 "
":func:`markcoroutinefunction` 标记的同步函数则返回 ``True``。"

#: ../../library/inspect.rst:426
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is a :term:`coroutine function`."
msgstr ""
"对于使用 :func:`functools.partial` 封装的函数，如果被封装的函数是一个 :term:`协程函数 <coroutine "
"function>` ，现在也会返回 ``True``。"

#: ../../library/inspect.rst:430
msgid ""
"Sync functions marked with :func:`markcoroutinefunction` now return "
"``True``."
msgstr "使用 :func:`markcoroutinefunction` 标记的同步函数现在将返回 ``True``。"

#: ../../library/inspect.rst:434 ../../library/inspect.rst:504
msgid ""
"Functions wrapped in :func:`functools.partialmethod` now return ``True`` if "
"the wrapped function is a :term:`coroutine function`."
msgstr ""
"现在对于使用 :func:`functools.partialmethod` 包装的函数，如果被包装的函数是一个 :term:`coroutine "
"function` 则返回 ``True``。"

#: ../../library/inspect.rst:441
msgid ""
"Decorator to mark a callable as a :term:`coroutine function` if it would not"
" otherwise be detected by :func:`iscoroutinefunction`."
msgstr ""
"将一个可调用对象标记为 :term:`coroutine function` 的装饰器，如果它不会被 "
":func:`iscoroutinefunction` 检测到的话。"

#: ../../library/inspect.rst:444
msgid ""
"This may be of use for sync functions that return a :term:`coroutine`, if "
"the function is passed to an API that requires :func:`iscoroutinefunction`."
msgstr ""
"这可被用于返回 :term:`coroutine` 的同步函数，如果该函数被传给需要 :func:`iscoroutinefunction` 的 API"
" 的话。"

#: ../../library/inspect.rst:447
msgid ""
"When possible, using an :keyword:`async def` function is preferred. Also "
"acceptable is calling the function and testing the return with "
":func:`iscoroutine`."
msgstr ""
"在可能的情况下，更推荐使用 :keyword:`async def` 函数。 调用该函数并使用 :func:`iscoroutine` "
"来检测其返回值也是可接受的。"

#: ../../library/inspect.rst:456
msgid ""
"Return ``True`` if the object is a :term:`coroutine` created by an "
":keyword:`async def` function."
msgstr ""
"当该对象是一个由 :keyword:`async def` 函数创建的 :term:`协程 <coroutine>` 时返回 ``True``。"

#: ../../library/inspect.rst:464
msgid ""
"Return ``True`` if the object can be used in :keyword:`await` expression."
msgstr "如果该对象可以在 :keyword:`await` 表达式中使用时返回 ``True``。"

#: ../../library/inspect.rst:466
msgid ""
"Can also be used to distinguish generator-based coroutines from regular "
"generators:"
msgstr "也可被用于区分基于生成器的协程和常规的生成器："

#: ../../library/inspect.rst:469
msgid ""
"import types\n"
"\n"
"def gen():\n"
"    yield\n"
"@types.coroutine\n"
"def gen_coro():\n"
"    yield\n"
"\n"
"assert not isawaitable(gen())\n"
"assert isawaitable(gen_coro())"
msgstr ""
"import types\n"
"\n"
"def gen():\n"
"    yield\n"
"@types.coroutine\n"
"def gen_coro():\n"
"    yield\n"
"\n"
"assert not isawaitable(gen())\n"
"assert isawaitable(gen_coro())"

#: ../../library/inspect.rst:487
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator` function,"
" for example:"
msgstr "如果对象是一个 :term:`asynchronous generator` 函数则返回 ``True``，例如："

#: ../../library/inspect.rst:490
msgid ""
">>> async def agen():\n"
"...     yield 1\n"
"...\n"
">>> inspect.isasyncgenfunction(agen)\n"
"True"
msgstr ""
">>> async def agen():\n"
"...     yield 1\n"
"...\n"
">>> inspect.isasyncgenfunction(agen)\n"
"True"

#: ../../library/inspect.rst:500
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is an :term:`asynchronous generator` function."
msgstr ""
"对于使用 :func:`functools.partial` 封装的函数，如果被封装的函数是一个 :term:`异步生成器 <asynchronous "
"generator>` 函数现在也会返回 ``True``。"

#: ../../library/inspect.rst:510
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator iterator` "
"created by an :term:`asynchronous generator` function."
msgstr ""
"如果该对象是一个由 :term:`异步生成器 <asynchronous generator>` 函数创建的 :term:`异步生成器迭代器 "
"<asynchronous generator iterator>`，则返回 ``True``。"

#: ../../library/inspect.rst:517
msgid "Return ``True`` if the object is a traceback."
msgstr "如果该对象是一个回溯则返回 ``True``。"

#: ../../library/inspect.rst:522
msgid "Return ``True`` if the object is a frame."
msgstr "如果该对象是一个帧对象则返回 ``True``。"

#: ../../library/inspect.rst:527
msgid "Return ``True`` if the object is a code."
msgstr "如果该对象是一个代码对象则返回 ``True``。"

#: ../../library/inspect.rst:532
msgid ""
"Return ``True`` if the object is a built-in function or a bound built-in "
"method."
msgstr "如果该对象是一个内置函数或一个绑定的内置方法，则返回 ``True``。"

#: ../../library/inspect.rst:537
msgid ""
"Return ``True`` if the type of object is a "
":class:`~types.MethodWrapperType`."
msgstr "如果对象类型为 :class:`~types.MethodWrapperType` 则返回 ``True``。"

#: ../../library/inspect.rst:539
msgid ""
"These are instances of :class:`~types.MethodWrapperType`, such as "
":meth:`~object.__str__`, :meth:`~object.__eq__` and "
":meth:`~object.__repr__`."
msgstr ""
"这些是 :class:`~types.MethodWrapperType` 的实例，如 :meth:`~object.__str__`, "
":meth:`~object.__eq__` 和 :meth:`~object.__repr__`。"

#: ../../library/inspect.rst:547
msgid ""
"Return ``True`` if the object is a user-defined or built-in function or "
"method."
msgstr "如果该对象是一个用户定义的或内置的函数或者方法，则返回 ``True``。"

#: ../../library/inspect.rst:552
msgid "Return ``True`` if the object is an abstract base class."
msgstr "如果该对象是一个抽象基类则返回 ``True``。"

#: ../../library/inspect.rst:557
msgid ""
"Return ``True`` if the object is a method descriptor, but not if "
":func:`ismethod`, :func:`isclass`, :func:`isfunction` or :func:`isbuiltin` "
"are true."
msgstr ""
"如果该对象是一个方法描述器，但 :func:`ismethod` 、 :func:`isclass` 、 :func:`isfunction` 及 "
":func:`isbuiltin` 均不为真，则返回 ``True``。"

#: ../../library/inspect.rst:561
msgid ""
"This, for example, is true of ``int.__add__``.  An object passing this test "
"has a :meth:`~object.__get__` method, but not a :meth:`~object.__set__` "
"method or a :meth:`~object.__delete__` method.  Beyond that, the set of "
"attributes varies.  A :attr:`~definition.__name__` attribute is usually "
"sensible, and :attr:`~definition.__doc__` often is."
msgstr ""
"例如，该函数对于 ``int.__add__`` 为真值。 一个通过此测试的对象会有 :meth:`~object.__get__` 方法，但没有 "
":meth:`~object.__set__` 方法或 :meth:`~object.__delete__` 方法。 除此以外，属性集合是可变的。 一个"
" :attr:`~definition.__name__` 属性通常是合理的，而 :attr:`~definition.__doc__` 通常也是如此。"

#: ../../library/inspect.rst:567
msgid ""
"Methods implemented via descriptors that also pass one of the other tests "
"return ``False`` from the :func:`ismethoddescriptor` test, simply because "
"the other tests promise more -- you can, e.g., count on having the "
":attr:`~method.__func__` attribute (etc) when an object passes "
":func:`ismethod`."
msgstr ""
"以描述器实现的能够通过其他某个测试的函数对于 :func:`ismethoddescriptor` 测试也会返回 "
"``False``，这只是因为其他测试提供了更多保证 —— 比如，当一个对象通过 :func:`ismethod` 时你将能够使用 "
":attr:`~method.__func__` 等属性。"

#: ../../library/inspect.rst:573
msgid ""
"This function no longer incorrectly reports objects with "
":meth:`~object.__get__` and :meth:`~object.__delete__`, but not "
":meth:`~object.__set__`, as being method descriptors (such objects are data "
"descriptors, not method descriptors)."
msgstr ""
"此函数将不再错误地将具有 :meth:`~object.__get__` 和 :meth:`~object.__delete__`，但没有 "
":meth:`~object.__set__` 的对象报告为方法描述器（这样的对象是数据描述器，不是方法描述器）。"

#: ../../library/inspect.rst:581
msgid "Return ``True`` if the object is a data descriptor."
msgstr "如果该对象是一个数据描述器则返回 ``True``。"

#: ../../library/inspect.rst:583
msgid ""
"Data descriptors have a :attr:`~object.__set__` or a "
":attr:`~object.__delete__` method. Examples are properties (defined in "
"Python), getsets, and members.  The latter two are defined in C and there "
"are more specific tests available for those types, which is robust across "
"Python implementations.  Typically, data descriptors will also have "
":attr:`~definition.__name__` and :attr:`!__doc__` attributes (properties, "
"getsets, and members have both of these attributes), but this is not "
"guaranteed."
msgstr ""
"数据描述器具有 :attr:`~object.__set__` 或 :attr:`~object.__delete__` 方法。 例如特征属性（在 "
"Python 中定义）、getset 和成员等。 后两者是在 C 中定义并且有针对这些类型的更具体的测试，它们在不同 Python "
"实现中均能保持健壮性。 通常，数据描述器还具有 :attr:`~definition.__name__` 和 :attr:`!__doc__` "
"属性（特征属性、getset 和成员都同时具有这些属性），但并不保证这一点。"

#: ../../library/inspect.rst:594
msgid "Return ``True`` if the object is a getset descriptor."
msgstr "如果该对象是一个 getset 描述器则返回 ``True``。"

#: ../../library/inspect.rst:598
msgid ""
"getsets are attributes defined in extension modules via "
":c:type:`PyGetSetDef` structures.  For Python implementations without such "
"types, this method will always return ``False``."
msgstr ""
"getset 是在扩展模块中通过 :c:type:`PyGetSetDef` 结构体定义的属性。对于不包含这种类型的 Python "
"实现，这个方法将永远返回 ``False``。"

#: ../../library/inspect.rst:605
msgid "Return ``True`` if the object is a member descriptor."
msgstr "如果该对象是一个成员描述器则返回 ``True``。"

#: ../../library/inspect.rst:609
msgid ""
"Member descriptors are attributes defined in extension modules via "
":c:type:`PyMemberDef` structures.  For Python implementations without such "
"types, this method will always return ``False``."
msgstr ""
"成员描述器是在扩展模块中通过 :c:type:`PyMemberDef` 结构体定义的属性。对于不包含这种类型的 Python 实现，这个方法将永远返回"
" ``False``。"

#: ../../library/inspect.rst:617
msgid "Retrieving source code"
msgstr "获取源代码"

#: ../../library/inspect.rst:621
msgid ""
"Get the documentation string for an object, cleaned up with "
":func:`cleandoc`. If the documentation string for an object is not provided "
"and the object is a class, a method, a property or a descriptor, retrieve "
"the documentation string from the inheritance hierarchy. Return ``None`` if "
"the documentation string is invalid or missing."
msgstr ""
"获取对象的文档字符串并通过 :func:`cleandoc` "
"进行清理。如果对象本身并未提供文档字符串并且这个对象是一个类、一个方法、一个特性或者一个描述器，将通过继承层次结构获取文档字符串。如果文档字符串无效或缺失，则返回"
" ``None``。"

#: ../../library/inspect.rst:627
msgid "Documentation strings are now inherited if not overridden."
msgstr "文档字符串没有被重写的话现在会被继承。"

#: ../../library/inspect.rst:633
msgid ""
"Return in a single string any lines of comments immediately preceding the "
"object's source code (for a class, function, or method), or at the top of "
"the Python source file (if the object is a module).  If the object's source "
"code is unavailable, return ``None``.  This could happen if the object has "
"been defined in C or the interactive shell."
msgstr ""
"任意多行注释作为单一一个字符串返回。对于类、函数和方法，选取紧贴在该对象的源代码之前的注释；对于模块，选取 Python "
"源文件顶部的注释。如果对象的源代码不可获得，返回 ``None``。这可能是因为对象是 C 语言中或者是在交互式命令行中定义的。"

#: ../../library/inspect.rst:642
msgid ""
"Return the name of the (text or binary) file in which an object was defined."
" This will fail with a :exc:`TypeError` if the object is a built-in module, "
"class, or function."
msgstr ""
"返回定义了这个对象的文件名（包括文本文件或二进制文件）。如果该对象是一个内置模块、类或函数则会失败并引发一个 :exc:`TypeError`。"

#: ../../library/inspect.rst:649
msgid ""
"Try to guess which module an object was defined in. Return ``None`` if the "
"module cannot be determined."
msgstr "尝试猜测一个对象是在哪个模块中定义的。 如果无法确定模块则返回 ``None``。"

#: ../../library/inspect.rst:655
msgid ""
"Return the name of the Python source file in which an object was defined or "
"``None`` if no way can be identified to get the source.  This will fail with"
" a :exc:`TypeError` if the object is a built-in module, class, or function."
msgstr ""
"返回一个对象定义所在 Python 源文件的名称，如果无法获取源文件则返回 ``None``。 如果对象是一个内置模块、类或函数则将失败并引发 "
":exc:`TypeError`。"

#: ../../library/inspect.rst:663
msgid ""
"Return a list of source lines and starting line number for an object. The "
"argument may be a module, class, method, function, traceback, frame, or code"
" object.  The source code is returned as a list of the lines corresponding "
"to the object and the line number indicates where in the original source "
"file the first line of code was found.  An :exc:`OSError` is raised if the "
"source code cannot be retrieved. A :exc:`TypeError` is raised if the object "
"is a built-in module, class, or function."
msgstr ""
"返回一个源代码行的列表和对象的起始行号。 参数可以是一个模块、类、方法、函数、回溯或者代码对象。 "
"源代码将以与该对象所对应的行的列表的形式返回并且行号指明其中第一行代码出现在初始源文件的那个位置。 如果源代码无法被获取则会引发 "
":exc:`OSError`。 如果对象是一个内置模块、类或函数则会引发 :exc:`TypeError`。"

#: ../../library/inspect.rst:672 ../../library/inspect.rst:686
msgid ""
":exc:`OSError` is raised instead of :exc:`IOError`, now an alias of the "
"former."
msgstr "现在会引发 :exc:`OSError` 而不是 :exc:`IOError`，后者现在是前者的一个别名。"

#: ../../library/inspect.rst:679
msgid ""
"Return the text of the source code for an object. The argument may be a "
"module, class, method, function, traceback, frame, or code object.  The "
"source code is returned as a single string.  An :exc:`OSError` is raised if "
"the source code cannot be retrieved. A :exc:`TypeError` is raised if the "
"object is a built-in module, class, or function."
msgstr ""
"返回对象的源代码文本。 参数可以是一个模块、类、方法、函数、回溯帧或代码对象。 源代码将以单个字符串的形式被返回。 如果源代码无法被获取则会引发 "
":exc:`OSError`。 如果对象是一个内置模块、类或函数则会引发 :exc:`TypeError`。"

#: ../../library/inspect.rst:693
msgid ""
"Clean up indentation from docstrings that are indented to line up with "
"blocks of code."
msgstr "清理文档字符串中为对齐当前代码块进行的缩进"

#: ../../library/inspect.rst:696
msgid ""
"All leading whitespace is removed from the first line.  Any leading "
"whitespace that can be uniformly removed from the second line onwards is "
"removed.  Empty lines at the beginning and end are subsequently removed.  "
"Also, all tabs are expanded to spaces."
msgstr ""
"第一行的所有前缀空白符会被移除。从第二行开始所有可以被统一去除的空白符也会被去除。之后，首尾的空白行也会被移除。同时，所有制表符会被展开到空格。"

#: ../../library/inspect.rst:705
msgid "Introspecting callables with the Signature object"
msgstr "使用 Signature 对象对可调用对象进行内省"

#: ../../library/inspect.rst:709
msgid ""
"The :class:`Signature` object represents the call signature of a callable "
"object and its return annotation. To retrieve a :class:`!Signature` object, "
"use the :func:`!signature` function."
msgstr ""
":class:`Signature` 对象代表一个可调用对象的调用签名及其返回值标。 要获取一个 :class:`!Signature` 对象，可使用 "
":func:`!signature` 函数。"

#: ../../library/inspect.rst:716
msgid "Return a :class:`Signature` object for the given *callable*:"
msgstr "返回一个给定 *callable* 的 :class:`Signature` 对象："

#: ../../library/inspect.rst:718
msgid ""
">>> from inspect import signature\n"
">>> def foo(a, *, b:int, **kwargs):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
"\n"
">>> str(sig)\n"
"'(a, *, b: int, **kwargs)'\n"
"\n"
">>> str(sig.parameters['b'])\n"
"'b: int'\n"
"\n"
">>> sig.parameters['b'].annotation\n"
"<class 'int'>"
msgstr ""
">>> from inspect import signature\n"
">>> def foo(a, *, b:int, **kwargs):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
"\n"
">>> str(sig)\n"
"'(a, *, b: int, **kwargs)'\n"
"\n"
">>> str(sig.parameters['b'])\n"
"'b: int'\n"
"\n"
">>> sig.parameters['b'].annotation\n"
"<class 'int'>"

#: ../../library/inspect.rst:735
msgid ""
"Accepts a wide range of Python callables, from plain functions and classes "
"to :func:`functools.partial` objects."
msgstr "接受各类的 Python 可调用对象，包括单纯的函数、类，到 :func:`functools.partial` 对象。"

#: ../../library/inspect.rst:738
msgid ""
"If some of the annotations are strings (e.g., because ``from __future__ "
"import annotations`` was used), :func:`signature` will attempt to "
"automatically un-stringize the annotations using "
":func:`annotationlib.get_annotations`.  The *globals*, *locals*, and "
"*eval_str* parameters are passed into :func:`!annotationlib.get_annotations`"
" when resolving the annotations; see the documentation for "
":func:`!annotationlib.get_annotations` for instructions on how to use these "
"parameters. A member of the :class:`annotationlib.Format` enum can be passed"
" to the *annotation_format* parameter to control the format of the returned "
"annotations. For example, use "
"``annotation_format=annotationlib.Format.STRING`` to return annotations in "
"string format."
msgstr ""
"如果某些注解是字符串 (例如，因为使用了 ``from __future__ import "
"annotations``)，:func:`signature` 将尝试使用 :func:`annotationlib.get_annotations`"
" 自动反字符串化该注解。 解析注解时，将 *globals*、*locals* 和 *eval_str* 形参传递给 "
":func:`!annotationlib.get_annotations`；有关如何使用这些参数的说明，请参阅 "
":func:`!annotationlib.get_annotations` 的文档。可以将 :class:`annotationlib.Format`"
" 枚举的成员传递给 *annotation_format* 形参，以控制返回的注解的格式。 例如，使用 "
"``annotation_format=annotationlib.Format.STRING`` 以字符串格式返回注解。"

#: ../../library/inspect.rst:752
msgid ""
"Raises :exc:`ValueError` if no signature can be provided, and "
":exc:`TypeError` if that type of object is not supported.  Also, if the "
"annotations are stringized, and *eval_str* is not false, the ``eval()`` "
"call(s) to un-stringize the annotations in "
":func:`annotationlib.get_annotations` could potentially raise any kind of "
"exception."
msgstr ""
"如果没有可提供的签名则会引发 :exc:`ValueError`，而如果对象类型不受支持则会引发 :exc:`TypeError`。 "
"同时，如果注解被字符串化，并且 *eval_str* 不为假值，则在 :func:`annotationlib.get_annotations` 中调用"
" ``eval()`` 来反字符串化注解可能会引发任何种类的异常。"

#: ../../library/inspect.rst:758
msgid ""
"A slash (/) in the signature of a function denotes that the parameters prior"
" to it are positional-only. For more info, see :ref:`the FAQ entry on "
"positional-only parameters <faq-positional-only-arguments>`."
msgstr ""
"函数签名中的斜杠（/）表示在它之前的形参是仅限位置的。参阅 :ref:`有关仅限位置形参的 FAQ 条目 <faq-positional-only-"
"arguments>`。"

#: ../../library/inspect.rst:762
msgid ""
"The *follow_wrapped* parameter was added. Pass ``False`` to get a signature "
"of *callable* specifically (``callable.__wrapped__`` will not be used to "
"unwrap decorated callables.)"
msgstr ""
"添加了 *follow_wrapped* 形参。 传入 ``False`` 以获得特定 *callable* 的签名 "
"(``callable.__wrapped__`` 将不会被用来解包被装饰的可调用对象。)"

#: ../../library/inspect.rst:768 ../../library/inspect.rst:904
msgid "The *globals*, *locals*, and *eval_str* parameters were added."
msgstr "添加了 *globals*, *locals* 和 *eval_str* 形参。"

#: ../../library/inspect.rst:771
msgid "The *annotation_format* parameter was added."
msgstr "增加了 *annotation_format* 形参。"

#: ../../library/inspect.rst:776
msgid ""
"Some callables may not be introspectable in certain implementations of "
"Python.  For example, in CPython, some built-in functions defined in C "
"provide no metadata about their arguments."
msgstr ""
"一些可调用对象可能在特定 Python 实现中无法被内省。例如，在 CPython 中，部分通过 C 语言定义的内置函数不提供关于其参数的元数据。"

#: ../../library/inspect.rst:782
msgid ""
"If the passed object has a :attr:`!__signature__` attribute, we may use it "
"to create the signature. The exact semantics are an implementation detail "
"and are subject to unannounced changes. Consult the source code for current "
"semantics."
msgstr ""
"如果传递的对象有一个 :attr:`!__signature__` 属性 "
"，我们可以用它来创建签名。确切的语义是实现的一个细节，可能会有未经宣布的更改。有关当前语义，请查阅源代码。"

#: ../../library/inspect.rst:790
msgid ""
"A :class:`!Signature` object represents the call signature of a function and"
" its return annotation.  For each parameter accepted by the function it "
"stores a :class:`Parameter` object in its :attr:`parameters` collection."
msgstr ""
":class:`!Signature` 对象表示一个函数的调用签名及其返回值标注。 对于函数所接受的每个形参它会在其 "
":attr:`parameters` 多项集中存储一个 :class:`Parameter` 对象。"

#: ../../library/inspect.rst:795
msgid ""
"The optional *parameters* argument is a sequence of :class:`Parameter` "
"objects, which is validated to check that there are no parameters with "
"duplicate names, and that the parameters are in the right order, i.e. "
"positional-only first, then positional-or-keyword, and that parameters with "
"defaults follow parameters without defaults."
msgstr ""
"可选参数 *parameters* 是一个 :class:`Parameter` "
"对象组成的序列，它会在之后被验证不存在名字重复的参数，并且参数处于正确的顺序，即仅限位置参数最前，之后紧接着可位置可关键字参数，并且有默认值参数在无默认值参数之前。"

#: ../../library/inspect.rst:801
msgid ""
"The optional *return_annotation* argument can be an arbitrary Python object."
" It represents the \"return\" annotation of the callable."
msgstr "可选的 *return_annotation* 参数可以是任意 Python 对象。 它表示可调用对象的 \"return\" 标注。"

#: ../../library/inspect.rst:804
msgid ""
":class:`!Signature` objects are *immutable*.  Use :meth:`Signature.replace` "
"or :func:`copy.replace` to make a modified copy."
msgstr ""
":class:`!Signature` 对象是 *不可变* 对象。 使用 :meth:`Signature.replace` 或 "
":func:`copy.replace` 来创建经修改的副本。"

#: ../../library/inspect.rst:807
msgid ":class:`!Signature` objects are now picklable and :term:`hashable`."
msgstr ":class:`!Signature` 对象现在是可 pickle 且 :term:`hashable` 的对象。"

#: ../../library/inspect.rst:812
msgid ""
"A special class-level marker to specify absence of a return annotation."
msgstr "该类的一个特殊标记来明确指出返回值标注缺失。"

#: ../../library/inspect.rst:816
msgid ""
"An ordered mapping of parameters' names to the corresponding "
":class:`Parameter` objects.  Parameters appear in strict definition order, "
"including keyword-only parameters."
msgstr "一个参数名字到对应 :class:`Parameter` 对象的有序映射。参数以严格的定义顺序出现，包括仅关键字参数。"

#: ../../library/inspect.rst:820 ../../library/inspect.rst:1184
msgid ""
"Python only explicitly guaranteed that it preserved the declaration order of"
" keyword-only parameters as of version 3.7, although in practice this order "
"had always been preserved in Python 3."
msgstr "Python 从 3.7 版起才显式地保证了它保持仅关键字参数的定义顺序，尽管实践上在 Python 3 中一直保持了这个顺序。"

#: ../../library/inspect.rst:827
msgid ""
"The \"return\" annotation for the callable.  If the callable has no "
"\"return\" annotation, this attribute is set to :attr:`Signature.empty`."
msgstr "可调用对象的“返回值”标注。如果可调用对象没有“返回值”标注，这个属性会被设置为 :attr:`Signature.empty`。"

#: ../../library/inspect.rst:832
msgid ""
"Create a mapping from positional and keyword arguments to parameters. "
"Returns :class:`BoundArguments` if ``*args`` and ``**kwargs`` match the "
"signature, or raises a :exc:`TypeError`."
msgstr ""
"构造一个位置和关键字实参到形参的映射。如果 ``*args`` 和 ``**kwargs`` 符合签名，则返回一个 "
":class:`BoundArguments`；否则引发一个 :exc:`TypeError` 。"

#: ../../library/inspect.rst:838
msgid ""
"Works the same way as :meth:`Signature.bind`, but allows the omission of "
"some required arguments (mimics :func:`functools.partial` behavior.) Returns"
" :class:`BoundArguments`, or raises a :exc:`TypeError` if the passed "
"arguments do not match the signature."
msgstr ""
"与 :meth:`Signature.bind` 作用方式相同，但允许省略部分必要的参数（模仿 :func:`functools.partial` "
"的行为）。返回 :class:`BoundArguments`，或者在传入参数不符合签名的情况下，引发一个 :exc:`TypeError`。"

#: ../../library/inspect.rst:845
msgid ""
"Create a new :class:`Signature` instance based on the instance "
":meth:`replace` was invoked on. It is possible to pass different "
"*parameters* and/or *return_annotation* to override the corresponding "
"properties of the base signature.  To remove ``return_annotation`` from the "
"copied :class:`!Signature`, pass in :attr:`Signature.empty`."
msgstr ""
"根据唤起 :meth:`replace` 的实例新建一个 :class:`Signature` 实例。 可以通过传入不同的 *parameters* "
"和/或 *return_annotation* 来覆盖基类签名的相应特征属性。 要从拷贝的 :class:`!Signature` 中移除 "
"``return_annotation``，可以传入 :attr:`Signature.empty`。"

#: ../../library/inspect.rst:853
msgid ""
">>> def test(a, b):\n"
"...     pass\n"
"...\n"
">>> sig = signature(test)\n"
">>> new_sig = sig.replace(return_annotation=\"new return anno\")\n"
">>> str(new_sig)\n"
"\"(a, b) -> 'new return anno'\""
msgstr ""
">>> def test(a, b):\n"
"...     pass\n"
"...\n"
">>> sig = signature(test)\n"
">>> new_sig = sig.replace(return_annotation=\"new return anno\")\n"
">>> str(new_sig)\n"
"\"(a, b) -> 'new return anno'\""

#: ../../library/inspect.rst:863
msgid ""
":class:`Signature` objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ":class:`Signature` 对象也被泛型函数 :func:`copy.replace` 所支持。"

#: ../../library/inspect.rst:868
msgid "Create a string representation of the :class:`Signature` object."
msgstr "创建一个 :class:`Signature` 对象的字符串表示形式。"

#: ../../library/inspect.rst:870
msgid ""
"If *max_width* is passed, the method will attempt to fit the signature into "
"lines of at most *max_width* characters. If the signature is longer than "
"*max_width*, all parameters will be on separate lines."
msgstr ""
"如果传入了 *max_width*，该方法将尝试将签名调整为每行至多 *max_width* 个字符的多行文本。 如果签名长度超过 "
"*max_width*，所有形参都将位于单独的行。"

#: ../../library/inspect.rst:875
msgid ""
"If *quote_annotation_strings* is False, :term:`annotations <annotation>` in "
"the signature are displayed without opening and closing quotation marks if "
"they are strings. This is useful if the signature was created with the "
":attr:`~annotationlib.Format.STRING` format or if ``from __future__ import "
"annotations`` was used."
msgstr ""
"如果 *quote_annotation_strings* 为 False，签名中的 :term:`注解 <annotation>` "
"如果是字符串，则显示时不带开合引号。 如果签名是用 :attr:`~annotationlib.Format.STRING` 格式创建的，或者使用了 "
"``from __future__ import annotations`` 格式，那么这很有用。"

#: ../../library/inspect.rst:883
msgid "The *unquote_annotations* parameter was added."
msgstr "增加了 *unquote_annotations* 形参。"

#: ../../library/inspect.rst:888
msgid ""
"Return a :class:`Signature` (or its subclass) object for a given callable "
"*obj*."
msgstr "返回给定的可调用对象 *obj* 的 :class:`Signature` (或其子类)。"

#: ../../library/inspect.rst:891
msgid "This method simplifies subclassing of :class:`Signature`:"
msgstr "该方法简化了 :class:`Signature` 的子类化操作："

#: ../../library/inspect.rst:893
msgid ""
"class MySignature(Signature):\n"
"    pass\n"
"sig = MySignature.from_callable(sum)\n"
"assert isinstance(sig, MySignature)"
msgstr ""
"class MySignature(Signature):\n"
"    pass\n"
"sig = MySignature.from_callable(sum)\n"
"assert isinstance(sig, MySignature)"

#: ../../library/inspect.rst:900
msgid "Its behavior is otherwise identical to that of :func:`signature`."
msgstr "其行为在其他方面都与 :func:`signature` 相同。"

#: ../../library/inspect.rst:910
msgid ""
":class:`!Parameter` objects are *immutable*. Instead of modifying a "
":class:`!Parameter` object, you can use :meth:`Parameter.replace` or "
":func:`copy.replace` to create a modified copy."
msgstr ""
":class:`!Parameter` 对象是 *不可变* 对象。 不要直接修改 :class:`!Parameter` 对象，你可以使用 "
":meth:`Parameter.replace` 或 :func:`copy.replace` 来创建一个修改后的副本。"

#: ../../library/inspect.rst:914
msgid "Parameter objects are now picklable and :term:`hashable`."
msgstr "现在 Parameter 对象可以被 pickle 并且为 :term:`hashable`。"

#: ../../library/inspect.rst:919
msgid ""
"A special class-level marker to specify absence of default values and "
"annotations."
msgstr "该类的一个特殊标记来明确指出默认值和标注的缺失。"

#: ../../library/inspect.rst:924
msgid ""
"The name of the parameter as a string.  The name must be a valid Python "
"identifier."
msgstr "参数的名字字符串。这个名字必须是一个合法的 Python 标识符。"

#: ../../library/inspect.rst:929
msgid ""
"CPython generates implicit parameter names of the form ``.0`` on the code "
"objects used to implement comprehensions and generator expressions."
msgstr "CPython 会为用于实现推导式和生成器表达式的代码对象构造形如 ``.0`` 的隐式形参名。"

#: ../../library/inspect.rst:933
msgid ""
"These parameter names are now exposed by this module as names like "
"``implicit0``."
msgstr "这些形参名会被此模块公开为 ``implicit0`` 这样的名字。"

#: ../../library/inspect.rst:939
msgid ""
"The default value for the parameter.  If the parameter has no default value,"
" this attribute is set to :attr:`Parameter.empty`."
msgstr "该参数的默认值。如果该参数没有默认值，这个属性会被设置为 :attr:`Parameter.empty` 。"

#: ../../library/inspect.rst:944
msgid ""
"The annotation for the parameter.  If the parameter has no annotation, this "
"attribute is set to :attr:`Parameter.empty`."
msgstr "该参数的标注。如果该参数没有标注，这个属性会被设置为 :attr:`Parameter.empty` 。"

#: ../../library/inspect.rst:949
msgid ""
"Describes how argument values are bound to the parameter.  The possible "
"values are accessible via :class:`Parameter` (like "
"``Parameter.KEYWORD_ONLY``), and support comparison and ordering, in the "
"following order:"
msgstr ""
"描述参数值要如何绑定到形参。 可能的取值可通过 :class:`Parameter` 获得 (如 "
"``Parameter.KEYWORD_ONLY``)，并支持比较与排序，基于以下顺序:"

#: ../../library/inspect.rst:956
msgid "Name"
msgstr "名称"

#: ../../library/inspect.rst:956
msgid "Meaning"
msgstr "含意"

#: ../../library/inspect.rst:958
msgid "*POSITIONAL_ONLY*"
msgstr "*POSITIONAL_ONLY*"

#: ../../library/inspect.rst:958
msgid ""
"Value must be supplied as a positional argument. Positional only parameters "
"are those which appear before a ``/`` entry (if present) in a Python "
"function definition."
msgstr "值必须以位置参数的方式提供。仅限位置参数是在函数定义中出现在 ``/`` 之前（如果有）的条目。"

#: ../../library/inspect.rst:963
msgid "*POSITIONAL_OR_KEYWORD*"
msgstr "*POSITIONAL_OR_KEYWORD*"

#: ../../library/inspect.rst:963
msgid ""
"Value may be supplied as either a keyword or positional argument (this is "
"the standard binding behaviour for functions implemented in Python.)"
msgstr "值既可以以关键字参数的形式提供，也可以以位置参数的形式提供（这是 Python 写成的函数的标准绑定行为的）。"

#: ../../library/inspect.rst:968
msgid "*VAR_POSITIONAL*"
msgstr "*VAR_POSITIONAL*"

#: ../../library/inspect.rst:968
msgid ""
"A tuple of positional arguments that aren't bound to any other parameter. "
"This corresponds to a ``*args`` parameter in a Python function definition."
msgstr "没有绑定到其他形参的位置实参组成的元组。这对应于 Python 函数定义中的 ``*args`` 形参。"

#: ../../library/inspect.rst:973
msgid "*KEYWORD_ONLY*"
msgstr "*KEYWORD_ONLY*"

#: ../../library/inspect.rst:973
msgid ""
"Value must be supplied as a keyword argument. Keyword only parameters are "
"those which appear after a ``*`` or ``*args`` entry in a Python function "
"definition."
msgstr "值必须以关键字参数的形式提供。仅限关键字形参是在 Python 函数定义中出现在 ``*`` 或 ``*args`` 之后的条目。"

#: ../../library/inspect.rst:978
msgid "*VAR_KEYWORD*"
msgstr "*VAR_KEYWORD*"

#: ../../library/inspect.rst:978
msgid ""
"A dict of keyword arguments that aren't bound to any other parameter. This "
"corresponds to a ``**kwargs`` parameter in a Python function definition."
msgstr "一个未绑定到其他形参的关键字参数的字典。这对应于 Python 函数定义中的 ``**kwargs`` 形参。"

#: ../../library/inspect.rst:984
msgid "Example: print all keyword-only arguments without default values:"
msgstr "示例：打印全部没有默认值的仅限关键字参数："

#: ../../library/inspect.rst:986
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     if (param.kind == param.KEYWORD_ONLY and\n"
"...                        param.default is param.empty):\n"
"...         print('Parameter:', param)\n"
"Parameter: c"
msgstr ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     if (param.kind == param.KEYWORD_ONLY and\n"
"...                        param.default is param.empty):\n"
"...         print('Parameter:', param)\n"
"Parameter: c"

#: ../../library/inspect.rst:1000
msgid "Describes an enum value of :attr:`Parameter.kind`."
msgstr "描述 :attr:`Parameter.kind` 的枚举值。"

#: ../../library/inspect.rst:1004
msgid "Example: print all descriptions of arguments:"
msgstr "示例：打印全部参数的描述："

#: ../../library/inspect.rst:1006
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     print(param.kind.description)\n"
"positional or keyword\n"
"positional or keyword\n"
"keyword-only\n"
"keyword-only"
msgstr ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     print(param.kind.description)\n"
"positional or keyword\n"
"positional or keyword\n"
"keyword-only\n"
"keyword-only"

#: ../../library/inspect.rst:1021
msgid ""
"Create a new :class:`Parameter` instance based on the instance replaced was "
"invoked on.  To override a :class:`!Parameter` attribute, pass the "
"corresponding argument.  To remove a default value or/and an annotation from"
" a :class:`!Parameter`, pass :attr:`Parameter.empty`."
msgstr ""
"根据唤起 replace 的实例新建一个 :class:`Parameter` 实例。 要覆盖一个 :class:`!Parameter` "
"属性，可以传入相应的参数。 要从一个 :class:`!Parameter` 中移除默认值或/和标注，可以传入 "
":attr:`Parameter.empty`。"

#: ../../library/inspect.rst:1026
msgid ""
">>> from inspect import Parameter\n"
">>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n"
">>> str(param)\n"
"'foo=42'\n"
"\n"
">>> str(param.replace()) # Will create a shallow copy of 'param'\n"
"'foo=42'\n"
"\n"
">>> str(param.replace(default=Parameter.empty, annotation='spam'))\n"
"\"foo: 'spam'\""
msgstr ""
">>> from inspect import Parameter\n"
">>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n"
">>> str(param)\n"
"'foo=42'\n"
"\n"
">>> str(param.replace()) # 将创建一个 'param' 的浅拷贝\n"
"'foo=42'\n"
"\n"
">>> str(param.replace(default=Parameter.empty, annotation='spam'))\n"
"\"foo: 'spam'\""

#: ../../library/inspect.rst:1039
msgid ""
":class:`Parameter` objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ":class:`Parameter` 对象也被泛型函数 :func:`copy.replace` 所支持。"

#: ../../library/inspect.rst:1042
msgid ""
"In Python 3.3 :class:`Parameter` objects were allowed to have ``name`` set "
"to ``None`` if their ``kind`` was set to ``POSITIONAL_ONLY``. This is no "
"longer permitted."
msgstr ""
"在 Python 3.3 中 :class:`Parameter` 对象在其 ``kind`` 被设为 ``POSITIONAL_ONLY`` 时允许将"
" ``name`` 设为 ``None``。 现在已不再允许这样做。"

#: ../../library/inspect.rst:1049
msgid ""
"Result of a :meth:`Signature.bind` or :meth:`Signature.bind_partial` call. "
"Holds the mapping of arguments to the function's parameters."
msgstr ""
"调用 :meth:`Signature.bind` 或 :meth:`Signature.bind_partial` "
"的结果。容纳实参到函数的形参的映射。"

#: ../../library/inspect.rst:1054
msgid ""
"A mutable mapping of parameters' names to arguments' values. Contains only "
"explicitly bound arguments.  Changes in :attr:`arguments` will reflect in "
":attr:`args` and :attr:`kwargs`."
msgstr ""
"一个形参名到实参值的可变映射。仅包含显式绑定的参数。对 :attr:`arguments` 的修改会反映到 :attr:`args` 和 "
":attr:`kwargs` 上。"

#: ../../library/inspect.rst:1058
msgid ""
"Should be used in conjunction with :attr:`Signature.parameters` for any "
"argument processing purposes."
msgstr "应当在任何参数处理目的中与 :attr:`Signature.parameters` 结合使用。"

#: ../../library/inspect.rst:1063
msgid ""
"Arguments for which :meth:`Signature.bind` or :meth:`Signature.bind_partial`"
" relied on a default value are skipped. However, if needed, use "
":meth:`BoundArguments.apply_defaults` to add them."
msgstr ""
" :meth:`Signature.bind` 和 :meth:`Signature.bind_partial` "
"中采用默认值的参数被跳过。然而，如果有需要的话，可以使用 :meth:`BoundArguments.apply_defaults` 来添加它们。"

#: ../../library/inspect.rst:1068
msgid ""
":attr:`arguments` is now of type :class:`dict`. Formerly, it was of type "
":class:`collections.OrderedDict`."
msgstr ""
" :attr:`arguments` 现在的类型是 :class:`dict`。之前，它的类型是 "
":class:`collections.OrderedDict`。"

#: ../../library/inspect.rst:1074
msgid ""
"A tuple of positional arguments values.  Dynamically computed from the "
":attr:`arguments` attribute."
msgstr "位置参数的值的元组。由 :attr:`arguments` 属性动态计算。"

#: ../../library/inspect.rst:1079
msgid ""
"A dict of keyword arguments values.  Dynamically computed from the "
":attr:`arguments` attribute.  Arguments that can be passed positionally are "
"included in :attr:`args` instead."
msgstr ""
"由关键字参数值组成的字典。 根据 :attr:`arguments` 属性动态计算得到。 可按位置传入的参数已改为包括在 :attr:`args` 中。"

#: ../../library/inspect.rst:1085
msgid "A reference to the parent :class:`Signature` object."
msgstr "向所属 :class:`Signature` 对象的一个引用。"

#: ../../library/inspect.rst:1089
msgid "Set default values for missing arguments."
msgstr "设置缺失的参数的默认值。"

#: ../../library/inspect.rst:1091
msgid ""
"For variable-positional arguments (``*args``) the default is an empty tuple."
msgstr "对于变长位置参数（``*args``），默认值是一个空元组。"

#: ../../library/inspect.rst:1094
msgid ""
"For variable-keyword arguments (``**kwargs``) the default is an empty dict."
msgstr "对于变长关键字参数（``**kwargs``）默认值是一个空字典。"

#: ../../library/inspect.rst:1097
msgid ""
">>> def foo(a, b='ham', *args): pass\n"
">>> ba = inspect.signature(foo).bind('spam')\n"
">>> ba.apply_defaults()\n"
">>> ba.arguments\n"
"{'a': 'spam', 'b': 'ham', 'args': ()}"
msgstr ""
">>> def foo(a, b='ham', *args): pass\n"
">>> ba = inspect.signature(foo).bind('spam')\n"
">>> ba.apply_defaults()\n"
">>> ba.arguments\n"
"{'a': 'spam', 'b': 'ham', 'args': ()}"

#: ../../library/inspect.rst:1107
msgid ""
"The :attr:`args` and :attr:`kwargs` properties can be used to invoke "
"functions:"
msgstr ":attr:`args` 和 :attr:`kwargs` 特征属性可被用于唤起函数："

#: ../../library/inspect.rst:1110
msgid ""
"def test(a, *, b):\n"
"    ...\n"
"\n"
"sig = signature(test)\n"
"ba = sig.bind(10, b=20)\n"
"test(*ba.args, **ba.kwargs)"
msgstr ""
"def test(a, *, b):\n"
"    ...\n"
"\n"
"sig = signature(test)\n"
"ba = sig.bind(10, b=20)\n"
"test(*ba.args, **ba.kwargs)"

#: ../../library/inspect.rst:1122
msgid ":pep:`362` - Function Signature Object."
msgstr ":pep:`362` - 函数签名对象。"

#: ../../library/inspect.rst:1123
msgid "The detailed specification, implementation details and examples."
msgstr "包含具体的规范，实现细节和样例。"

#: ../../library/inspect.rst:1129
msgid "Classes and functions"
msgstr "类与函数"

#: ../../library/inspect.rst:1133
msgid ""
"Arrange the given list of classes into a hierarchy of nested lists. Where a "
"nested list appears, it contains classes derived from the class whose entry "
"immediately precedes the list.  Each entry is a 2-tuple containing a class "
"and a tuple of its base classes.  If the *unique* argument is true, exactly "
"one entry appears in the returned structure for each class in the given "
"list.  Otherwise, classes using multiple inheritance and their descendants "
"will appear multiple times."
msgstr ""
"将给定的类的列表组织成嵌套列表的层级结构。每当一个内层列表出现时，它包含的类均派生自紧接着该列表之前的条目的类。每个条目均是一个二元组，包含一个类和它的基类组成的元组。如果"
" *unique* 参数为真值，则给定列表中的每个类将恰有一个对应条目。否则，运用了多重继承的类和它们的后代将出现多次。"

#: ../../library/inspect.rst:1144
msgid ""
"Get the names and default values of a Python function's parameters.  A "
":term:`named tuple` is returned:"
msgstr "获取一个 Python 函数的形参的名字和默认值。将返回一个 :term:`具名元组 <named tuple>`："

#: ../../library/inspect.rst:1147
msgid ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, "
"annotations)``"
msgstr ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, "
"annotations)``"

#: ../../library/inspect.rst:1150
msgid ""
"*args* is a list of the positional parameter names. *varargs* is the name of"
" the ``*`` parameter or ``None`` if arbitrary positional arguments are not "
"accepted. *varkw* is the name of the ``**`` parameter or ``None`` if "
"arbitrary keyword arguments are not accepted. *defaults* is an *n*-tuple of "
"default argument values corresponding to the last *n* positional parameters,"
" or ``None`` if there are no such defaults defined. *kwonlyargs* is a list "
"of keyword-only parameter names in declaration order. *kwonlydefaults* is a "
"dictionary mapping parameter names from *kwonlyargs* to the default values "
"used if no argument is supplied. *annotations* is a dictionary mapping "
"parameter names to annotations. The special key ``\"return\"`` is used to "
"report the function return value annotation (if any)."
msgstr ""
"*args* 是一个位置参数的名字的列表。 *varargs* 是 ``*`` 形参的名字或 ``None`` 表示不接受任意长位置参数时。 "
"*varkw* 是 ``**`` 参数的名字，或 ``None`` 表示不接受任意关键字参数。 *defaults* 是一个包含了默认参数值的 *n* "
"元组分别对应最后 *n* 个位置参数，或 ``None`` 则表示没有默认值。 *kwonlyargs* 是一个仅关键词参数列表，保持定义时的顺序。 "
"*kwonlydefaults* 是一个字典映射自 *kwonlyargs* 中包含的形参名。 *annotations* "
"是一个字典，包含形参值到标注的映射。其中包含一个特殊的键 ``\"return\"`` 代表函数返回值的标注（如果有的话）。"

#: ../../library/inspect.rst:1165
msgid ""
"Note that :func:`signature` and :ref:`Signature Object <inspect-signature-"
"object>` provide the recommended API for callable introspection, and support"
" additional behaviours (like positional-only arguments) that are sometimes "
"encountered in extension module APIs. This function is retained primarily "
"for use in code that needs to maintain compatibility with the Python 2 "
"``inspect`` module API."
msgstr ""
"注意： :func:`signature` 和 :ref:`Signature 对象 <inspect-signature-object>` "
"提供可调用对象内省更推荐的 API，并且支持扩展模块 API 中可能出现的额外的行为（比如仅限位置参数）。该函数被保留的主要原因是保持兼容 Python"
" 2 的 ``inspect`` 模块 API。"

#: ../../library/inspect.rst:1172
msgid ""
"This function is now based on :func:`signature`, but still ignores "
"``__wrapped__`` attributes and includes the already bound first parameter in"
" the signature output for bound methods."
msgstr ""
"该函数现在基于 :func:`signature` 但仍然忽略 ``__wrapped__`` 属性，并且在签名中包含绑定方法中的第一个绑定参数。"

#: ../../library/inspect.rst:1177
msgid ""
"This method was previously documented as deprecated in favour of "
":func:`signature` in Python 3.5, but that decision has been reversed in "
"order to restore a clearly supported standard interface for single-source "
"Python 2/3 code migrating away from the legacy :func:`getargspec` API."
msgstr ""
"该方法在 Python 3.5 中曾因 :func:`signature` "
"被文档归为弃用。但该决定已被推翻以恢复一个明确受支持的标准接口，以便运用一份源码通用 Python 2/3 间遗留的 "
":func:`getargspec` API 的迁移。"

#: ../../library/inspect.rst:1192
msgid ""
"Get information about arguments passed into a particular frame.  A "
":term:`named tuple` ``ArgInfo(args, varargs, keywords, locals)`` is "
"returned. *args* is a list of the argument names.  *varargs* and *keywords* "
"are the names of the ``*`` and ``**`` arguments or ``None``.  *locals* is "
"the locals dictionary of the given frame."
msgstr ""
"获取传入特定的帧的实参的信息。将返回一个 :term:`具名元组 <named tuple>` ``ArgInfo(args, varargs, "
"keywords, locals)``。 *args* 是一个参数名字的列表。 *varargs* 和 *keyword* 是 ``*`` 和 "
"``**`` 参数的名字或 ``None``。 *locals* 是给定的帧的局部环境字典。"

#: ../../library/inspect.rst:1199 ../../library/inspect.rst:1209
msgid "This function was inadvertently marked as deprecated in Python 3.5."
msgstr "该函数因疏忽在 Python 3.5 中被错误地标记为弃用。"

#: ../../library/inspect.rst:1204
msgid ""
"Format a pretty argument spec from the four values returned by "
":func:`getargvalues`.  The format\\* arguments are the corresponding "
"optional formatting functions that are called to turn names and values into "
"strings."
msgstr ""
"将 :func:`getargvalues` 返回的四个值格式化为美观的参数规格。 format\\* "
"的参数是对应的可选格式化函数以转化名字和值为字符串。"

#: ../../library/inspect.rst:1214
msgid ""
"Return a tuple of class cls's base classes, including cls, in method "
"resolution order.  No class appears more than once in this tuple. Note that "
"the method resolution order depends on cls's type.  Unless a very peculiar "
"user-defined metatype is in use, cls will be the first element of the tuple."
msgstr ""
"返回由类 cls 的全部基类按方法解析顺序组成的元组，包括 cls 本身。所有类不会在此元组中出现多于一次。注意方法解析顺序取决于 cls "
"的类型。除非使用一个非常奇怪的用户定义元类型，否则 cls 会是元组的第一个元素。"

#: ../../library/inspect.rst:1222
msgid ""
"Bind the *args* and *kwds* to the argument names of the Python function or "
"method *func*, as if it was called with them. For bound methods, bind also "
"the first argument (typically named ``self``) to the associated instance. A "
"dict is returned, mapping the argument names (including the names of the "
"``*`` and ``**`` arguments, if any) to their values from *args* and *kwds*. "
"In case of invoking *func* incorrectly, i.e. whenever ``func(*args, "
"**kwds)`` would raise an exception because of incompatible signature, an "
"exception of the same type and the same or similar message is raised. For "
"example:"
msgstr ""
"将 *args* 和 *kwds* 绑定到 Python 函数或方法 *func* 的参数名称，就像将它们作为调用时传入的参数一样。 "
"对于绑定方法，还会将第一个参数 (通常命名为 ``self``) 绑定到关联的实例。 将返回一个字典，该字典会将参数名称（包括 ``*`` 和 "
"``**`` 参数的名称，如果有的话）绑定到 *args* 和 *kwds* 中的值。 对于不正确地唤起 *func* 的情况，即 "
"``func(*args, **kwds)`` 因函数签名不兼容而引发异常的时候，将引发一个相同类型的异常并附带相同或相似的消息。 例如："

#: ../../library/inspect.rst:1231
msgid ""
">>> from inspect import getcallargs\n"
">>> def f(a, b=1, *pos, **named):\n"
"...     pass\n"
"...\n"
">>> getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}\n"
"True\n"
">>> getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, 'pos': ()}\n"
"True\n"
">>> getcallargs(f)\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: f() missing 1 required positional argument: 'a'"
msgstr ""
">>> from inspect import getcallargs\n"
">>> def f(a, b=1, *pos, **named):\n"
"...     pass\n"
"...\n"
">>> getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}\n"
"True\n"
">>> getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, 'pos': ()}\n"
"True\n"
">>> getcallargs(f)\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: f() missing 1 required positional argument: 'a'"

#: ../../library/inspect.rst:1248
msgid "Use :meth:`Signature.bind` and :meth:`Signature.bind_partial` instead."
msgstr "改使用 :meth:`Signature.bind` 和 :meth:`Signature.bind_partial`。"

#: ../../library/inspect.rst:1254
msgid ""
"Get the mapping of external name references in a Python function or method "
"*func* to their current values. A :term:`named tuple` "
"``ClosureVars(nonlocals, globals, builtins, unbound)`` is returned. "
"*nonlocals* maps referenced names to lexical closure variables, *globals* to"
" the function's module globals and *builtins* to the builtins visible from "
"the function body. *unbound* is the set of names referenced in the function "
"that could not be resolved at all given the current module globals and "
"builtins."
msgstr ""
"获取自 Python 函数或方法 *func* 引用的外部名字到它们的值的映射。返回一个 :term:`具名元组 <named tuple>` "
"``ClosureVars(nonlocals, globals, builtins, unbound)``。 *nonlocals* "
"映射引用的名字到词法闭包变量，*globals* 映射到函数的模块级全局， *builtins* 映射到函数体内可见的内置变量。 *unbound* "
"是在函数中引用但不能解析到给定的模块全局和内置变量的名字的集合。"

#: ../../library/inspect.rst:1263
msgid ""
":exc:`TypeError` is raised if *func* is not a Python function or method."
msgstr "如果 *func* 不是 Python 函数或方法，将引发 :exc:`TypeError`。"

#: ../../library/inspect.rst:1270
msgid ""
"Get the object wrapped by *func*. It follows the chain of "
":attr:`__wrapped__` attributes returning the last object in the chain."
msgstr "获取 *func* 所包装的对象。它追踪 :attr:`__wrapped__` 属性链并返回最后一个对象。"

#: ../../library/inspect.rst:1273
msgid ""
"*stop* is an optional callback accepting an object in the wrapper chain as "
"its sole argument that allows the unwrapping to be terminated early if the "
"callback returns a true value. If the callback never returns a true value, "
"the last object in the chain is returned as usual. For example, "
":func:`signature` uses this to stop unwrapping if any object in the chain "
"has a ``__signature__`` attribute defined."
msgstr ""
"*stop* "
"是一个可选的回调，接受包装链的一个对象作为唯一参数，以允许通过让回调返回真值使解包装更早中止。如果回调不曾返回一个真值，将如常返回链中的最后一个对象。例如，"
" :func:`signature` 使用该参数来在遇到具有 ``__signature__`` 参数的对象时停止解包装。"

#: ../../library/inspect.rst:1280
msgid ":exc:`ValueError` is raised if a cycle is encountered."
msgstr "如果遇到循环，则引发 :exc:`ValueError`。"

#: ../../library/inspect.rst:1287
msgid "Compute the annotations dict for an object."
msgstr "计算一个对象的标注字典。"

#: ../../library/inspect.rst:1289
msgid ""
"This is an alias for :func:`annotationlib.get_annotations`; see the "
"documentation of that function for more information."
msgstr "这是 :func:`annotationlib.get_annotations` 的别名；有关更多信息，请参阅该函数的文档。"

#: ../../library/inspect.rst:1294
msgid ""
"This function is now an alias for :func:`annotationlib.get_annotations`. "
"Calling it as ``inspect.get_annotations`` will continue to work."
msgstr ""
"此函数现在是 :func:`annotationlib.get_annotations` 的别名。 将其调用为 "
"``inspect.get_annotations`` 将继续工作。"

#: ../../library/inspect.rst:1302
msgid "The interpreter stack"
msgstr "解释器栈"

#: ../../library/inspect.rst:1304
msgid ""
"Some of the following functions return :class:`FrameInfo` objects. For "
"backwards compatibility these objects allow tuple-like operations on all "
"attributes except ``positions``. This behavior is considered deprecated and "
"may be removed in the future."
msgstr ""
"下列函数有些将返回 :class:`FrameInfo` 对象。 出于向下兼容性考虑这些对象允许在所有属性上执行元组类操作但 ``positions``"
" 除外。 此行为已被弃用并可能会在未来被移除。"

#: ../../library/inspect.rst:1313
msgid ""
"The :ref:`frame object <frame-objects>` that the record corresponds to."
msgstr "记录所对应的 :ref:`帧对象 <frame-objects>`。"

#: ../../library/inspect.rst:1317
msgid ""
"The file name associated with the code being executed by the frame this "
"record corresponds to."
msgstr "关联到由此记录所对应的帧对象所执行的代码的文件名称。"

#: ../../library/inspect.rst:1322
msgid ""
"The line number of the current line associated with the code being executed "
"by the frame this record corresponds to."
msgstr "关联到由此记录所对应的帧对象所执行的代码的当前行的行号。"

#: ../../library/inspect.rst:1327
msgid ""
"The function name that is being executed by the frame this record "
"corresponds to."
msgstr "由此记录所对应的帧所执行的函数的名称。"

#: ../../library/inspect.rst:1331
msgid ""
"A list of lines of context from the source code that's being executed by the"
" frame this record corresponds to."
msgstr "来自由此记录所对应的帧所执行的源代码的上下文行组成的列表。"

#: ../../library/inspect.rst:1336 ../../library/inspect.rst:1375
msgid ""
"The index of the current line being executed in the :attr:`code_context` "
"list."
msgstr "在 :attr:`code_context` 列表中执行的当前行的索引号。"

#: ../../library/inspect.rst:1340
msgid ""
"A :class:`dis.Positions` object containing the start line number, end line "
"number, start column offset, and end column offset associated with the "
"instruction being executed by the frame this record corresponds to."
msgstr "包含关联到由此记录所对应的指令的起始行号，结束行号，起始列偏移量和结束列偏移量的 :class:`dis.Positions` 对象。"

#: ../../library/inspect.rst:1344
msgid "Return a :term:`named tuple` instead of a :class:`tuple`."
msgstr "返回一个 :term:`named tuple` 而非 :class:`tuple`。"

#: ../../library/inspect.rst:1347
msgid ""
":class:`!FrameInfo` is now a class instance (that is backwards compatible "
"with the previous :term:`named tuple`)."
msgstr ":class:`!FrameInfo` 现在是一个类实例（以便与之前的 :term:`named tuple` 保持向下兼容）。"

#: ../../library/inspect.rst:1356
msgid ""
"The file name associated with the code being executed by the frame this "
"traceback corresponds to."
msgstr "关联到由此回溯所对应的帧所执行的代码的文件名称。"

#: ../../library/inspect.rst:1361
msgid ""
"The line number of the current line associated with the code being executed "
"by the frame this traceback corresponds to."
msgstr "关联到由此回溯所对应的帧所执行的代码的当前行的行号。"

#: ../../library/inspect.rst:1366
msgid ""
"The function name that is being executed by the frame this traceback "
"corresponds to."
msgstr "由此回溯所对应的帧所执行的函数的名称。"

#: ../../library/inspect.rst:1370
msgid ""
"A list of lines of context from the source code that's being executed by the"
" frame this traceback corresponds to."
msgstr "来自由此回溯所对应的帧所执行的源代码的上下文行组成的列表。"

#: ../../library/inspect.rst:1379
msgid ""
"A :class:`dis.Positions` object containing the start line number, end line "
"number, start column offset, and end column offset associated with the "
"instruction being executed by the frame this traceback corresponds to."
msgstr ""
"包含关联到此回溯所对应的帧所执行的指令的起始行号，结束行号，起始列偏移量和结束列偏移量的 :class:`dis.Positions` 对象。"

#: ../../library/inspect.rst:1384
msgid ""
":class:`!Traceback` is now a class instance (that is backwards compatible "
"with the previous :term:`named tuple`)."
msgstr ":class:`!Traceback` 现在是一个类实例（以便与之前的 :term:`named tuple` 保持向下兼容）。"

#: ../../library/inspect.rst:1391
msgid ""
"Keeping references to frame objects, as found in the first element of the "
"frame records these functions return, can cause your program to create "
"reference cycles.  Once a reference cycle has been created, the lifespan of "
"all objects which can be accessed from the objects which form the cycle can "
"become much longer even if Python's optional cycle detector is enabled.  If "
"such cycles must be created, it is important to ensure they are explicitly "
"broken to avoid the delayed destruction of objects and increased memory "
"consumption which occurs."
msgstr ""
"保留帧对象的引用（可见于这些函数返回的帧记录的第一个元素）会导致你的程序产生循环引用。每当一个循环引用被创建，所有可从产生循环的对象访问的对象的生命周期将会被大幅度延长，即便"
" Python 的可选的循环检测器被启用。如果这类循环必须被创建，确保它们会被显式地打破以避免对象销毁被延迟从而导致占用内存增加。"

#: ../../library/inspect.rst:1399
msgid ""
"Though the cycle detector will catch these, destruction of the frames (and "
"local variables) can be made deterministic by removing the cycle in a "
":keyword:`finally` clause.  This is also important if the cycle detector was"
" disabled when Python was compiled or using :func:`gc.disable`.  For "
"example::"
msgstr ""
"尽管循环检测器能够处理这种情况，这些帧（包括其局部变量）的销毁可以通过在 :keyword:`finally` "
"子句中移除循环来产生确定的行为。对于循环检测器在编译 Python 时被禁用或者使用 :func:`gc.disable` "
"时，这样处理更加尤为重要。比如："

#: ../../library/inspect.rst:1404
msgid ""
"def handle_stackframe_without_leak():\n"
"    frame = inspect.currentframe()\n"
"    try:\n"
"        # do something with the frame\n"
"    finally:\n"
"        del frame"
msgstr ""
"def handle_stackframe_without_leak():\n"
"    frame = inspect.currentframe()\n"
"    try:\n"
"        # 对 frame 执行一些操作\n"
"    finally:\n"
"        del frame"

#: ../../library/inspect.rst:1411
msgid ""
"If you want to keep the frame around (for example to print a traceback "
"later), you can also break reference cycles by using the :meth:`frame.clear`"
" method."
msgstr "如果你希望保持帧更长的时间（比如在之后打印回溯），你也可以通过 :meth:`frame.clear` 方法打破循环引用。"

#: ../../library/inspect.rst:1415
msgid ""
"The optional *context* argument supported by most of these functions "
"specifies the number of lines of context to return, which are centered "
"around the current line."
msgstr "大部分这些函数支持的可选的 *context* 参数指定返回时包含的上下文的行数，以当前行为中心。"

#: ../../library/inspect.rst:1422
msgid ""
"Get information about a frame or traceback object.  A :class:`Traceback` "
"object is returned."
msgstr "获取关于帧或回溯对象的信息。 将返回一个 :class:`Traceback` 对象。"

#: ../../library/inspect.rst:1425
msgid "A :class:`Traceback` object is returned instead of a named tuple."
msgstr "将返回一个 :class:`Traceback` 对象而非具名元组。"

#: ../../library/inspect.rst:1430
msgid ""
"Get a list of :class:`FrameInfo` objects for a frame and all outer frames. "
"These frames represent the calls that lead to the creation of *frame*. The "
"first entry in the returned list represents *frame*; the last entry "
"represents the outermost call on *frame*'s stack."
msgstr ""
"获取某个帧及其所有外部帧的 :class:`FrameInfo` 对象的列表。 这些帧代表导致 *frame* 被创建的一系列调用。 "
"返回的列中的第一个条目代表 *frame*；最后一个条目代表在 *frame* 的栈上的最外层调用。"

#: ../../library/inspect.rst:1435 ../../library/inspect.rst:1450
#: ../../library/inspect.rst:1476 ../../library/inspect.rst:1491
msgid ""
"A list of :term:`named tuples <named tuple>` ``FrameInfo(frame, filename, "
"lineno, function, code_context, index)`` is returned."
msgstr ""
"返回一个 :term:`具名元组 <named tuple>` ``FrameInfo(frame, filename, lineno, "
"function, code_context, index)`` 的列表。"

#: ../../library/inspect.rst:1440 ../../library/inspect.rst:1455
#: ../../library/inspect.rst:1481 ../../library/inspect.rst:1496
msgid "A list of :class:`FrameInfo` objects is returned."
msgstr "将返回一个 :class:`FrameInfo` 对象的列表。"

#: ../../library/inspect.rst:1445
msgid ""
"Get a list of :class:`FrameInfo` objects for a traceback's frame and all "
"inner frames.  These frames represent calls made as a consequence of "
"*frame*. The first entry in the list represents *traceback*; the last entry "
"represents where the exception was raised."
msgstr ""
"获取一个回溯所在的帧及其所有内部帧的 :class:`FrameInfo` 对象的列表。 这些帧代表作为 *frame* 的后续所执行的调用。 "
"列表中的第一个条目代表 *traceback*；最后一个条目代表引发异常的位置。"

#: ../../library/inspect.rst:1460
msgid "Return the frame object for the caller's stack frame."
msgstr "返回调用者的栈帧对应的帧对象。"

#: ../../library/inspect.rst:1464
msgid ""
"This function relies on Python stack frame support in the interpreter, which"
" isn't guaranteed to exist in all implementations of Python.  If running in "
"an implementation without Python stack frame support this function returns "
"``None``."
msgstr ""
"该函数依赖于 Python 解释器对于栈帧的支持，这并非在 Python 的所有实现中被保证。该函数在不支持Python 栈帧的实现中运行会返回 "
"``None``。"

#: ../../library/inspect.rst:1472
msgid ""
"Return a list of :class:`FrameInfo` objects for the caller's stack.  The "
"first entry in the returned list represents the caller; the last entry "
"represents the outermost call on the stack."
msgstr ""
"返回调用者的栈的 :class:`FrameInfo` 对象的列表。 返回的列表中的第一个条目代表调用者；最后一个条目代表栈上的最外层调用。"

#: ../../library/inspect.rst:1486
msgid ""
"Return a list of :class:`FrameInfo` objects for the stack between the "
"current frame and the frame in which an exception currently being handled "
"was raised in.  The first entry in the list represents the caller; the last "
"entry represents where the exception was raised."
msgstr ""
"返回介于当前帧和引发了当前正在处理的异常所在的帧之间的栈的 :class:`FrameInfo` 对象的列表。 "
"列表中的第一个条目代表调用者；最后一个条目代表引发异常的位置。"

#: ../../library/inspect.rst:1500
msgid "Fetching attributes statically"
msgstr "静态地获取属性"

#: ../../library/inspect.rst:1502
msgid ""
"Both :func:`getattr` and :func:`hasattr` can trigger code execution when "
"fetching or checking for the existence of attributes. Descriptors, like "
"properties, will be invoked and :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` may be called."
msgstr ""
":func:`getattr` 和 :func:`hasattr` 在获取或检查属性是否存在时可以触发代码执行。 描述器，像特征属性一样，可能会被唤起而"
" :meth:`~object.__getattr__` 和 :meth:`~object.__getattribute__` 也可能会被调用。"

#: ../../library/inspect.rst:1508
msgid ""
"For cases where you want passive introspection, like documentation tools, "
"this can be inconvenient. :func:`getattr_static` has the same signature as "
":func:`getattr` but avoids executing code when it fetches attributes."
msgstr ""
"对于你想要静态地内省的情况，比如文档工具，这会显得不方便。 :func:`getattr_static` 拥有与 :func:`getattr` "
"相同的签名，但避免了获取属性时执行代码。"

#: ../../library/inspect.rst:1514
msgid ""
"Retrieve attributes without triggering dynamic lookup via the descriptor "
"protocol, :meth:`~object.__getattr__` or :meth:`~object.__getattribute__`."
msgstr ""
"获取属性而不触发通过描述器协议、:meth:`~object.__getattr__` 或 "
":meth:`~object.__getattribute__` 的动态查找。"

#: ../../library/inspect.rst:1518
msgid ""
"Note: this function may not be able to retrieve all attributes that getattr "
"can fetch (like dynamically created attributes) and may find attributes that"
" getattr can't (like descriptors that raise AttributeError). It can also "
"return descriptors objects instead of instance members."
msgstr ""
"注意：该函数可能无法获取 getattr 能获取的全部的属性（比如动态地创建的属性），并且可能发现一些 getattr 无法找到的属性（比如描述器会引发"
" AttributeError）。它也能够返回描述器对象本身而非实例成员。"

#: ../../library/inspect.rst:1524
msgid ""
"If the instance :attr:`~object.__dict__` is shadowed by another member (for "
"example a property) then this function will be unable to find instance "
"members."
msgstr "如果实例的 :attr:`~object.__dict__` 被其他成员遮盖（比如一个特性）则该函数无法找到实例成员。"

#: ../../library/inspect.rst:1530
msgid ""
":func:`getattr_static` does not resolve descriptors, for example slot "
"descriptors or getset descriptors on objects implemented in C. The "
"descriptor object is returned instead of the underlying attribute."
msgstr ""
" :func:`getattr_static` 不解析描述器。比如槽描述器或 C 语言中实现的 getset "
"描述器。该描述器对象会被直接返回，而不处理底层属性。"

#: ../../library/inspect.rst:1534
msgid ""
"You can handle these with code like the following. Note that for arbitrary "
"getset descriptors invoking these may trigger code execution::"
msgstr "你可以用类似下方的代码的方法处理此事。注意，对于任意 getset 描述符，使用这段代码仍可能触发代码执行。"

#: ../../library/inspect.rst:1538
msgid ""
"# example code for resolving the builtin descriptor types\n"
"class _foo:\n"
"    __slots__ = ['foo']\n"
"\n"
"slot_descriptor = type(_foo.foo)\n"
"getset_descriptor = type(type(open(__file__)).name)\n"
"wrapper_descriptor = type(str.__dict__['__add__'])\n"
"descriptor_types = (slot_descriptor, getset_descriptor, wrapper_descriptor)\n"
"\n"
"result = getattr_static(some_object, 'foo')\n"
"if type(result) in descriptor_types:\n"
"    try:\n"
"        result = result.__get__()\n"
"    except AttributeError:\n"
"        # descriptors can raise AttributeError to\n"
"        # indicate there is no underlying value\n"
"        # in which case the descriptor itself will\n"
"        # have to do\n"
"        pass"
msgstr ""
"# 解析内置描述器类型的示例代码\n"
"class _foo:\n"
"    __slots__ = ['foo']\n"
"\n"
"slot_descriptor = type(_foo.foo)\n"
"getset_descriptor = type(type(open(__file__)).name)\n"
"wrapper_descriptor = type(str.__dict__['__add__'])\n"
"descriptor_types = (slot_descriptor, getset_descriptor, wrapper_descriptor)\n"
"\n"
"result = getattr_static(some_object, 'foo')\n"
"if type(result) in descriptor_types:\n"
"    try:\n"
"        result = result.__get__()\n"
"    except AttributeError:\n"
"        # 描述器可以引发 AttributeError\n"
"        # 以提示下层的值不存在\n"
"        # 在这种情况下描述器本身必须\n"
"        # 执行处理\n"
"        pass"

#: ../../library/inspect.rst:1560
msgid "Current State of Generators, Coroutines, and Asynchronous Generators"
msgstr "生成器、协程和异步生成器的当前状态"

#: ../../library/inspect.rst:1562
msgid ""
"When implementing coroutine schedulers and for other advanced uses of "
"generators, it is useful to determine whether a generator is currently "
"executing, is waiting to start or resume or execution, or has already "
"terminated. :func:`getgeneratorstate` allows the current state of a "
"generator to be determined easily."
msgstr ""
"当实现协程调度器或其他更高级的生成器用途时，判断一个生成器是正在执行、等待启动或继续或执行，又或者已经被终止是非常有用的。 "
":func:`getgeneratorstate` 允许方便地判断一个生成器的当前状态。"

#: ../../library/inspect.rst:1570
msgid "Get current state of a generator-iterator."
msgstr "获取生成器迭代器的当前状态。"

#: ../../library/inspect.rst:1572 ../../library/inspect.rst:1588
#: ../../library/inspect.rst:1605
msgid "Possible states are:"
msgstr "可能的状态是："

#: ../../library/inspect.rst:1574
msgid "GEN_CREATED: Waiting to start execution."
msgstr "GEN_CREATED：等待开始执行。"

#: ../../library/inspect.rst:1575
msgid "GEN_RUNNING: Currently being executed by the interpreter."
msgstr "GEN_RUNNING：正在被解释器执行。"

#: ../../library/inspect.rst:1576
msgid "GEN_SUSPENDED: Currently suspended at a yield expression."
msgstr "GEN_SUSPENDED：当前挂起于一个 yield 表达式。"

#: ../../library/inspect.rst:1577
msgid "GEN_CLOSED: Execution has completed."
msgstr "GEN_CLOSED：执行已经完成。"

#: ../../library/inspect.rst:1583
msgid ""
"Get current state of a coroutine object.  The function is intended to be "
"used with coroutine objects created by :keyword:`async def` functions, but "
"will accept any coroutine-like object that has ``cr_running`` and "
"``cr_frame`` attributes."
msgstr ""
"获取协程对象的当前状态。该函数设计为用于使用 :keyword:`async def` 函数创建的协程函数，但也能接受任何包括 "
"``cr_running`` 和 ``cr_frame`` 的类似协程的对象。"

#: ../../library/inspect.rst:1590
msgid "CORO_CREATED: Waiting to start execution."
msgstr "CORO_CREATED：等待开始执行。"

#: ../../library/inspect.rst:1591
msgid "CORO_RUNNING: Currently being executed by the interpreter."
msgstr "CORO_RUNNING：当前正在被解释器执行。"

#: ../../library/inspect.rst:1592
msgid "CORO_SUSPENDED: Currently suspended at an await expression."
msgstr "CORO_SUSPENDED：当前挂起于一个 await 表达式。"

#: ../../library/inspect.rst:1593
msgid "CORO_CLOSED: Execution has completed."
msgstr "CORO_CLOSED：执行已经完成。"

#: ../../library/inspect.rst:1599
msgid ""
"Get current state of an asynchronous generator object.  The function is "
"intended to be used with asynchronous iterator objects created by "
":keyword:`async def` functions which use the :keyword:`yield` statement, but"
" will accept any asynchronous generator-like object that has ``ag_running`` "
"and ``ag_frame`` attributes."
msgstr ""
"获取一个异步生成器对象的当前状态。 该函数设计为用于由 :keyword:`async def` 函数创建的使用 :keyword:`yield` "
"语句的异步迭代器对象，但也能接受任何具有 ``ag_running`` 和 ``ag_frame`` 属性的类似异步生成器的对象。"

#: ../../library/inspect.rst:1607
msgid "AGEN_CREATED: Waiting to start execution."
msgstr "AGEN_CREATED: 等待开始执行。"

#: ../../library/inspect.rst:1608
msgid "AGEN_RUNNING: Currently being executed by the interpreter."
msgstr "AGEN_RUNNING: 当前正在被解释器执行。"

#: ../../library/inspect.rst:1609
msgid "AGEN_SUSPENDED: Currently suspended at a yield expression."
msgstr "AGEN_SUSPENDED: 当前在 yield 表达式上挂起。"

#: ../../library/inspect.rst:1610
msgid "AGEN_CLOSED: Execution has completed."
msgstr "AGEN_CLOSED: 执行已经完成。"

#: ../../library/inspect.rst:1614
msgid ""
"The current internal state of the generator can also be queried. This is "
"mostly useful for testing purposes, to ensure that internal state is being "
"updated as expected:"
msgstr "生成器当前的内部状态也可以被查询。这通常在测试目的中最为有用，来保证内部状态如预期一样被更新："

#: ../../library/inspect.rst:1620
msgid ""
"Get the mapping of live local variables in *generator* to their current "
"values.  A dictionary is returned that maps from variable names to values. "
"This is the equivalent of calling :func:`locals` in the body of the "
"generator, and all the same caveats apply."
msgstr ""
"获取 *generator* 里的实时局部变量到当前值的映射。返回一个由名字映射到值的字典。这与在生成器的主体内调用 :func:`locals` "
"是等效的，并且相同的警告也适用。"

#: ../../library/inspect.rst:1625
msgid ""
"If *generator* is a :term:`generator` with no currently associated frame, "
"then an empty dictionary is returned.  :exc:`TypeError` is raised if "
"*generator* is not a Python generator object."
msgstr ""
"如果 *generator* 是一个没有关联帧的 :term:`生成器 <generator>`，则返回一个空字典。如果 *generator* "
"不是一个 Python 生成器对象，则引发 :exc:`TypeError`。"

#: ../../library/inspect.rst:1631
msgid ""
"This function relies on the generator exposing a Python stack frame for "
"introspection, which isn't guaranteed to be the case in all implementations "
"of Python. In such cases, this function will always return an empty "
"dictionary."
msgstr ""
"该函数依赖于生成器为内省暴露一个 Python 栈帧，这并非在 Python 的所有实现中被保证。在这种情况下，该函数将永远返回一个空字典。"

#: ../../library/inspect.rst:1640
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but works"
" for coroutine objects created by :keyword:`async def` functions."
msgstr ""
"该函数可类比于 :func:`~inspect.getgeneratorlocals`，只是作用于由 :keyword:`async def` "
"函数创建的协程。"

#: ../../library/inspect.rst:1647
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but works"
" for asynchronous generator objects created by :keyword:`async def` "
"functions which use the :keyword:`yield` statement."
msgstr ""
"此函数类似于 :func:`~inspect.getgeneratorlocals`，但只适用于由 :keyword:`async def` "
"函数创建的使用 :keyword:`yield` 语句的异步生成器对象。"

#: ../../library/inspect.rst:1657
msgid "Code Objects Bit Flags"
msgstr "代码对象位标志"

#: ../../library/inspect.rst:1659
msgid ""
"Python code objects have a :attr:`~codeobject.co_flags` attribute, which is "
"a bitmap of the following flags:"
msgstr "Python 代码对象有一个 :attr:`~codeobject.co_flags` 属性，它是下列旗标的位映射："

#: ../../library/inspect.rst:1664
msgid "The code object is optimized, using fast locals."
msgstr "代码对象已经经过优化，会采用快速局部变量。"

#: ../../library/inspect.rst:1668
msgid ""
"If set, a new dict will be created for the frame's :attr:`~frame.f_locals` "
"when the code object is executed."
msgstr "如果设置，则当代码对象被执行时会新建一个字典作为帧的 :attr:`~frame.f_locals`。"

#: ../../library/inspect.rst:1673
msgid "The code object has a variable positional parameter (``*args``-like)."
msgstr "代码对象拥有一个变长位置形参（类似 ``*args``）。"

#: ../../library/inspect.rst:1677
msgid "The code object has a variable keyword parameter (``**kwargs``-like)."
msgstr "代码对象拥有一个可变关键字形参 (类似 ``**kwrags``)。"

#: ../../library/inspect.rst:1681
msgid "The flag is set when the code object is a nested function."
msgstr "该标志当代码对象是一个嵌套函数时被置位。"

#: ../../library/inspect.rst:1685
msgid ""
"The flag is set when the code object is a generator function, i.e. a "
"generator object is returned when the code object is executed."
msgstr "当代码对象是一个生成器函数，即调用时会返回一个生成器对象，则该标志被置位。"

#: ../../library/inspect.rst:1690
msgid ""
"The flag is set when the code object is a coroutine function. When the code "
"object is executed it returns a coroutine object. See :pep:`492` for more "
"details."
msgstr "当代码对象是一个协程函数时被置位。当代码对象被执行时它返回一个协程。详见 :pep:`492`。"

#: ../../library/inspect.rst:1698
msgid ""
"The flag is used to transform generators into generator-based coroutines.  "
"Generator objects with this flag can be used in ``await`` expression, and "
"can ``yield from`` coroutine objects. See :pep:`492` for more details."
msgstr ""
"该标志被用于将生成器转变为基于生成器的协程。包含此标志的生成器对象可以被用于 ``await`` 表达式，并可以 ``yield from`` "
"协程对象。详见 :pep:`492`。"

#: ../../library/inspect.rst:1707
msgid ""
"The flag is set when the code object is an asynchronous generator function."
"  When the code object is executed it returns an asynchronous generator "
"object.  See :pep:`525` for more details."
msgstr "当代码对象是一个异步生成器函数时该标志被置位。当代码对象被运行时它将返回一个异步生成器对象。详见 :pep:`525`。"

#: ../../library/inspect.rst:1715
msgid ""
"The flag is set when there is a docstring for the code object in the source "
"code. If set, it will be the first item in :attr:`~codeobject.co_consts`."
msgstr ""
"当源代码中存在代码对象的文档字符串时设置该标志。 如果设置了，它将是 :attr:`~codeobject.co_consts` 中的第一项。"

#: ../../library/inspect.rst:1723
msgid ""
"The flag is set when the code object is a function defined in class scope."
msgstr "当代码对象是在类范围内定义的函数时设置该标志。"

#: ../../library/inspect.rst:1729
msgid ""
"The flags are specific to CPython, and may not be defined in other Python "
"implementations.  Furthermore, the flags are an implementation detail, and "
"can be removed or deprecated in future Python releases. It's recommended to "
"use public APIs from the :mod:`inspect` module for any introspection needs."
msgstr ""
"这些标志特指于 CPython，并且在其他 Python 实现中可能从未被定义。更进一步地说，这些标志是一种实现细节，并且可能在将来的 Python "
"发行中被移除或弃用。推荐使用 :mod:`inspect` 模块的公共 API 来进行任何内省需求。"

#: ../../library/inspect.rst:1737
msgid "Buffer flags"
msgstr "缓冲区旗标"

#: ../../library/inspect.rst:1741
msgid ""
"This is an :class:`enum.IntFlag` that represents the flags that can be "
"passed to the :meth:`~object.__buffer__` method of objects implementing the "
":ref:`buffer protocol <bufferobjects>`."
msgstr ""
"这是一个代表可被传给实现了 :ref:`缓冲区协议 <bufferobjects>` 的对象的 :meth:`~object.__buffer__` "
"方法的旗标的 :class:`enum.IntFlag`。"

#: ../../library/inspect.rst:1745
msgid "The meaning of the flags is explained at :ref:`buffer-request-types`."
msgstr "这些旗标的含义的说明见 :ref:`buffer-request-types`。"

#: ../../library/inspect.rst:1772
msgid "Command Line Interface"
msgstr "命令行界面"

#: ../../library/inspect.rst:1774
msgid ""
"The :mod:`inspect` module also provides a basic introspection capability "
"from the command line."
msgstr ":mod:`inspect` 模块也提供一个从命令行使用基本的内省能力。"

#: ../../library/inspect.rst:1779
msgid ""
"By default, accepts the name of a module and prints the source of that "
"module. A class or function within the module can be printed instead by "
"appended a colon and the qualified name of the target object."
msgstr "默认地，命令行接受一个模块的名字并打印模块的源代码。也可通过后缀一个冒号和目标对象的限定名称来打印一个类或者一个函数。"

#: ../../library/inspect.rst:1785
msgid ""
"Print information about the specified object rather than the source code"
msgstr "打印特定对象的信息而非源码。"
