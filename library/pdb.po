# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Python 的调试器"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**源代码：** :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python"
" programs.  It supports setting (conditional) breakpoints and single "
"stepping at the source line level, inspection of stack frames, source code "
"listing, and evaluation of arbitrary Python code in the context of any stack"
" frame.  It also supports post-mortem debugging and can be called under "
"program control."
msgstr ""
":mod:`pdb` 模块定义了一个交互式源代码调试器，用于 Python "
"程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python "
"代码。它还支持事后调试，可以在程序控制下调用。"

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class "
":class:`Pdb`. This is currently undocumented but easily understood by "
"reading the source.  The extension interface uses the modules :mod:`bdb` and"
" :mod:`cmd`."
msgstr ""
"调试器是可扩展的——调试器实际被定义为 :class:`Pdb` 类。该类目前没有文档，但通过阅读源码很容易理解它。扩展接口使用了 :mod:`bdb`"
" 和 :mod:`cmd` 模块。"

#: ../../library/pdb.rst:32
msgid "Module :mod:`faulthandler`"
msgstr "模块 :mod:`faulthandler`"

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr "用于在发生错误、超时或用户信号时显式地转储 Python 回溯信息。"

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr "模块 :mod:`traceback`"

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr "提取、格式化和打印 Python 程序的栈回溯信息的标准接口。"

#: ../../library/pdb.rst:39
msgid "The typical usage to break into the debugger is to insert::"
msgstr "中断进入调试器的典型用法是插入::"

#: ../../library/pdb.rst:41
msgid "import pdb; pdb.set_trace()"
msgstr "import pdb; pdb.set_trace()"

#: ../../library/pdb.rst:43
msgid "Or::"
msgstr "或者::"

#: ../../library/pdb.rst:45
msgid "breakpoint()"
msgstr "breakpoint()"

#: ../../library/pdb.rst:47
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"到你想进入调试器的位置，再运行程序。 然后你可以单步执行这条语句之后的代码，并使用 :pdbcmd:`continue` 命令来关闭调试器继续运行。"

#: ../../library/pdb.rst:51
msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"内置函数 :func:`breakpoint`，当以默认方式调用时，可被用来代替 ``import pdb; pdb.set_trace()``。"

#: ../../library/pdb.rst:57
msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"

#: ../../library/pdb.rst:63
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr "调试器的提示符为 ``(Pdb)``，这指明你正处于调试模式下::"

#: ../../library/pdb.rst:65
msgid ""
"> ...(3)double()\n"
"-> return x * 2\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""

#: ../../library/pdb.rst:72
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"由 :mod:`readline` 模块实现的 Tab 补全可用于补全本模块的命令和命令的参数，例如，Tab 补全会提供当前的全局变量和局部变量，用作 "
"``p`` 命令的参数。"

#: ../../library/pdb.rst:80
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other scripts."
"  For example::"
msgstr "你还可以从命令行唤起 :mod:`pdb` 来调试其他脚本。 例如::"

#: ../../library/pdb.rst:83
msgid "python -m pdb [-c command] (-m module | pyfile) [args ...]"
msgstr "python -m pdb [-c command] (-m module | pyfile) [args ...]"

#: ../../library/pdb.rst:85
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging"
" if the program being debugged exits abnormally.  After post-mortem "
"debugging (or after normal exit of the program), pdb will restart the "
"program.  Automatic restarting preserves pdb's state (such as breakpoints) "
"and in most cases is more useful than quitting the debugger upon program's "
"exit."
msgstr ""
"当作为模块被唤起时，如果被调试的程序异常退出则 pdb 将自动进入事后调试。 在事后调试之后（或程序正常退出之后），pdb 将重启程序。 自动重启会保留"
" pdb 的状态（如断点）并且在大多数情况下这比在退出程序的同时退出调试器更实用。"

#: ../../library/pdb.rst:93
msgid ""
"To execute commands as if given in a :file:`.pdbrc` file; see "
":ref:`debugger-commands`."
msgstr "要以在 :file:`.pdbrc` 文件中所给出形式来执行命令；请参阅 :ref:`debugger-commands`。"

#: ../../library/pdb.rst:96
msgid "Added the ``-c`` option."
msgstr "增加了 ``-c`` 选项。"

#: ../../library/pdb.rst:101
msgid ""
"To execute modules similar to the way ``python -m`` does. As with a script, "
"the debugger will pause execution just before the first line of the module."
msgstr "要以类似于 ``python -m`` 的方式来执行模块。 就像一个脚本那样，调试器将在模块的第一行之前暂停执行。"

#: ../../library/pdb.rst:104
msgid "Added the ``-m`` option."
msgstr "增加了 ``-m`` 选项。"

#: ../../library/pdb.rst:107
msgid ""
"Typical usage to execute a statement under control of the debugger is::"
msgstr "在调试器控制下执行一条语句的典型用法如下::"

#: ../../library/pdb.rst:109
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"

#: ../../library/pdb.rst:118
msgid "The typical usage to inspect a crashed program is::"
msgstr "检查已崩溃程序的典型用法是::"

#: ../../library/pdb.rst:120
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"

#: ../../library/pdb.rst:136
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr "本模块定义了下列函数，每个函数进入调试器的方式略有不同："

#: ../../library/pdb.rst:141
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the"
" environment in which the code is executed; by default the dictionary of the"
" module :mod:`__main__` is used.  (See the explanation of the built-in "
":func:`exec` or :func:`eval` functions.)"
msgstr ""
"在调试器控制范围内执行 *statement* （以字符串或代码对象的形式提供）。调试器提示符会在执行代码前出现，你可以设置断点并键入 "
":pdbcmd:`continue`，也可以使用 :pdbcmd:`step` 或 :pdbcmd:`next` "
"逐步执行语句（上述所有命令在后文有说明）。可选参数 *globals* 和 *locals* 指定代码执行环境，默认时使用 "
":mod:`__main__` 模块的字典。（请参阅内置函数 :func:`exec` 或 :func:`eval` 的说明。）"

#: ../../library/pdb.rst:153
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the"
" *expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"在调试器控制下对 *expression* (以字符串或代码对象的形式给出) 求值。 当 :func:`runeval` 返回时，它将返回 "
"*expression* 的值。 在其他方面此函数与 :func:`run` 类似。"

#: ../../library/pdb.rst:160
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function"
" is entered."
msgstr ""
"使用给定的参数调用 *function* （以函数或方法对象的形式提供，不能是字符串）。:func:`runcall` "
"返回的是所调用函数的返回值。调试器提示符将在进入函数后立即出现。"

#: ../../library/pdb.rst:168
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header*"
" is printed to the console just before debugging begins."
msgstr ""
"在调用本函数的堆栈帧处进入调试器。用于硬编码一个断点到程序中的固定点处，即使该代码不在调试状态（如断言失败时）。如果传入 "
"*header*，它将在调试开始前被打印到控制台。"

#: ../../library/pdb.rst:173
msgid "The keyword-only argument *header*."
msgstr "仅关键字参数 *header*。"

#: ../../library/pdb.rst:179
msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be "
"used)."
msgstr ""
"进入 *traceback* 对象的事后调试。如果没有给定 *traceback*，默认使用当前正在处理的异常之一（默认时，必须存在正在处理的异常）。"

#: ../../library/pdb.rst:187
msgid ""
"Enter post-mortem debugging of the traceback found in "
":data:`sys.last_traceback`."
msgstr ""

#: ../../library/pdb.rst:191
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want"
" to access further features, you have to do this yourself:"
msgstr ""
"``run*`` 函数和 :func:`set_trace` 都是别名，用于实例化 :class:`Pdb` "
"类和调用同名方法。如果要使用其他功能，则必须自己执行以下操作："

#: ../../library/pdb.rst:198
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` 是调试器类。"

#: ../../library/pdb.rst:200
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"*completekey*、*stdin* 和 *stdout* 参数都会传递给底层的 :class:`cmd.Cmd` 类，请参考相应的描述。"

#: ../../library/pdb.rst:203
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name"
" patterns.  The debugger will not step into frames that originate in a "
"module that matches one of these patterns. [1]_"
msgstr ""
"如果给出 *skip* 参数，则它必须是一个迭代器，可以迭代出 glob-style "
"样式的模块名称。如果遇到匹配上述样式的模块，调试器将不会进入来自该模块的堆栈帧。 [1]_"

#: ../../library/pdb.rst:207
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the"
" user presses :kbd:`Ctrl-C` on the console) when you give a "
":pdbcmd:`continue` command. This allows you to break into the debugger again"
" by pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT "
"handler, set *nosigint* to true."
msgstr ""
"默认情况下，当发出 :pdbcmd:`continue` 命令时，Pdb 将为 SIGINT 信号（信号当用户在控制台按 :kbd:`Ctrl-C` "
"时发出的）设置一个处理器。 这使用户可以通过按 :kbd:`Ctrl-C` 再次进入调试器。 如果你希望 Pdb 不要改变 SIGINT 处理器，请将 "
"*nosigint* 设为真值。to true."

#: ../../library/pdb.rst:212
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load "
".pdbrc files from the filesystem."
msgstr "*readrc* 参数默认为 true，它控制 Pdb 是否从文件系统加载 .pdbrc 文件。"

#: ../../library/pdb.rst:215
msgid "Example call to enable tracing with *skip*::"
msgstr "启用跟踪且带有 *skip* 参数的调用示范::"

#: ../../library/pdb.rst:217
msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"

#: ../../library/pdb.rst:219
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``pdb.Pdb``。"

#: ../../library/pdb.rst:221
msgid "Added the *skip* parameter."
msgstr "增加了 *skip* 形参。"

#: ../../library/pdb.rst:224
msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr "增加了 *nosigint* 形参。 在之前版本中，pdb 绝不会设置 SIGINT 处理器。"

#: ../../library/pdb.rst:228
msgid "The *readrc* argument."
msgstr "*readrc* 参数。"

#: ../../library/pdb.rst:236
msgid "See the documentation for the functions explained above."
msgstr "请参阅上文解释同名函数的文档。"

#: ../../library/pdb.rst:242
msgid "Debugger Commands"
msgstr "调试器命令"

#: ../../library/pdb.rst:244
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can"
" be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not"
" ``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"下方列出的是调试器可接受的命令。如下所示，大多数命令可以缩写为一个或两个字母。如 ``h(elp)`` 表示可以输入 ``h`` 或 ``help`` "
"来输入帮助命令（但不能输入 ``he`` 或 ``hel``，也不能是 ``H`` 或 ``Help`` 或 "
"``HELP``）。命令的参数必须用空格（空格符或制表符）分隔。在命令语法中，可选参数括在方括号 (``[]``) "
"中，使用时请勿输入方括号。命令语法中的选择项由竖线 (``|``) 分隔。"

#: ../../library/pdb.rst:253
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr "输入一个空白行将重复最后输入的命令。例外：如果最后一个命令是 :pdbcmd:`list` 命令，则会列出接下来的 11 行。"

#: ../../library/pdb.rst:256
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"调试器无法识别的命令将被认为是 Python 语句，并在正在调试的程序的上下文中执行。Python 语句也可以用感叹号 (``!``) "
"作为前缀。这是检查正在调试的程序的强大方法，甚至可以修改变量或调用函数。当此类语句发生异常，将打印异常名称，但调试器的状态不会改变。"

#: ../../library/pdb.rst:264
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr "调试器支持 :ref:`别名 <debugger-aliases>`。别名可以有参数，使得调试器对被检查的上下文有一定程度的适应性。"

#: ../../library/pdb.rst:268
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or "
"``\";\"\";\"``."
msgstr ""
"在一行中可以输入多条命令，以 ``;;`` 分隔。 （不能使用单个 ``;``，因为它已被用作传给 Python 解析器的一行中的多条命令的分隔符。） "
"命令切分所用的方式没有任何智能可言；输入总是会在第一个 ``;;`` 对上被切分，即使它位于带引号的字符串中。 "
"对于带有双分号的字符串可以使用隐式字符串拼接 ``';'';'`` 或 ``\";\"\";\"`` 来变通处理。"

#: ../../library/pdb.rst:275
msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program"
" compared to using normal variables like ``foo = 1``."
msgstr ""
"要设置临时全局变量，请使用 *快捷变量*。 *快捷变量* 是名称以 ``$`` 打头的变量。 例如，``$foo = 1`` 将设置一个全局变量 "
"``$foo`` 供你在调试器会话中使用。 *快捷变量* 会在程序恢复执行时被清空因此它不大可能像使用普通变量如 ``foo = 1`` "
"那样影响到你的程序。"

#: ../../library/pdb.rst:282
msgid "There are three preset *convenience variables*:"
msgstr "存在三个预设的 *快捷变量*:"

#: ../../library/pdb.rst:284
msgid "``$_frame``: the current frame you are debugging"
msgstr "``$_frame``: 你正在调试的当前帧"

#: ../../library/pdb.rst:285
msgid "``$_retval``: the return value if the frame is returning"
msgstr "``$_retval``: 当帧返回时的返回值"

#: ../../library/pdb.rst:286
msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr "``$_exception``: 当帧引发异常时的异常值"

#: ../../library/pdb.rst:290
msgid "Added the *convenience variable* feature."
msgstr "增加了 *便捷变量* 特性。"

#: ../../library/pdb.rst:296
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""
"如果文件 :file:`.pdbrc` 存在于用户主目录或当前目录中，则它将以 ``'utf-8'`` "
"编码格式被读入并执行，就像是在调试器提示符下被键入一样，不同之处在于空行和以 ``#`` 开头的行会被忽略。 这对于别名特别有用。 "
"如果两个文件都存在，则会先读取主目录中的文件并且在那里定义的别名可以被本地文件所覆盖。"

#: ../../library/pdb.rst:303
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as "
":pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` 现在可以包含继续调试的命令，如 :pdbcmd:`continue` 或 "
":pdbcmd:`next`。文件中的这些命令以前是无效的。"

#: ../../library/pdb.rst:308
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ":file:`.pdbrc` 现在将以 ``'utf-8'`` 编码格式来读取。 在之前版本中，它是以系统语言区域编码格式来读取的。"

#: ../../library/pdb.rst:315
msgid ""
"Without argument, print the list of available commands.  With a *command* as"
" argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command*"
" argument must be an identifier, ``help exec`` must be entered to get help "
"on the ``!`` command."
msgstr ""
"不带参数时，显示可用的命令列表。参数为 *command* 时，打印有关该命令的帮助。``help pdb`` 显示完整文档（即 :mod:`pdb` "
"模块的文档字符串）。由于 *command* 参数必须是标识符，因此要获取 ``!`` 的帮助必须输入 ``help exec``。"

#: ../../library/pdb.rst:323
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"(``>``) indicates the current frame, which determines the context of most "
"commands."
msgstr "打印栈回溯，最新的帧位于底部。 有一个箭头 (``>``) 指明当前帧，该帧决定了大多数命令的上下文。"

#: ../../library/pdb.rst:328
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr "在堆栈回溯中，将当前帧向下移动 *count* 级（默认为 1 级，移向更新的帧）。"

#: ../../library/pdb.rst:333
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr "在堆栈回溯中，将当前帧向上移动 *count* 级（默认为 1 级，移向更老的帧）。"

#: ../../library/pdb.rst:338
msgid ""
"With a *lineno* argument, set a break there in the current file.  With a "
"*function* argument, set a break at the first executable statement within "
"that function.  The line number may be prefixed with a filename and a colon,"
" to specify a breakpoint in another file (probably one that hasn't been "
"loaded yet).  The file is searched on :data:`sys.path`.  Note that each "
"breakpoint is assigned a number to which all the other breakpoint commands "
"refer."
msgstr ""

#: ../../library/pdb.rst:345
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr "如果第二个参数存在，它应该是一个表达式，且它的计算值为 true 时断点才起作用。"

#: ../../library/pdb.rst:348
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number"
" of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr "如果不带参数执行，将列出所有中断，包括每个断点、命中该断点的次数、当前的忽略次数以及关联的条件（如果有）。"

#: ../../library/pdb.rst:354
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr "临时断点，在第一次命中时会自动删除。它的参数与 :pdbcmd:`break` 相同。"

#: ../../library/pdb.rst:359
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"如果参数是 "
"*filename:lineno*，则清除此行上的所有断点。如果参数是空格分隔的断点编号列表，则清除这些断点。如果不带参数，则清除所有断点（但会先提示确认）。"

#: ../../library/pdb.rst:365
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"禁用断点，断点以空格分隔的断点编号列表给出。禁用断点表示它不会导致程序停止执行，但是与清除断点不同，禁用的断点将保留在断点列表中并且可以（重新）启用。"

#: ../../library/pdb.rst:372
msgid "Enable the breakpoints specified."
msgstr "启用指定的断点。"

#: ../../library/pdb.rst:376
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the"
" ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"为指定的断点编号设置忽略次数。 如果省略 *count*，则忽略次数将设置为 0。 当忽略次数为零时断点将变为活动状态。 "
"如果为非零值，则在每次到达断点且断点未禁用且关联条件取真值时 *count* 就像递减。"

#: ../../library/pdb.rst:384
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"为断点设置一个新 *condition*，它是一个表达式，且它的计算值为 true 时断点才起作用。如果没有给出 "
"*condition*，则删除现有条件，也就是将断点设为无条件。"

#: ../../library/pdb.rst:390
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"为编号是 *bpnumber* 的断点指定一系列命令。命令内容将显示在后续的几行中。输入仅包含 ``end`` 的行来结束命令列表。举个例子::"

#: ../../library/pdb.rst:394
msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"

#: ../../library/pdb.rst:399
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr "要删除断点上的所有命令，请输入 ``commands`` 并立即以 ``end`` 结尾，也就是不指定任何命令。"

#: ../../library/pdb.rst:402
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr "如果不带 *bpnumber* 参数，``commands`` 作用于最后一个被设置的断点。"

#: ../../library/pdb.rst:404
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that"
" resumes execution."
msgstr ""
"可以为断点指定命令来重新启动程序。只需使用 :pdbcmd:`continue` 或 :pdbcmd:`step` 命令或其他可以继续运行程序的命令。"

#: ../../library/pdb.rst:408
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, "
":pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, "
":pdbcmd:`quit` and their abbreviations) terminates the command list (as if "
"that command was immediately followed by end). This is because any time you "
"resume execution (even with a simple next or step), you may encounter "
"another breakpoint—which could have its own command list, leading to "
"ambiguities about which list to execute."
msgstr ""
"如果指定了某个继续运行程序的命令（目前包括 :pdbcmd:`continue`, :pdbcmd:`step`, :pdbcmd:`next`, "
":pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:`quit` 及它们的缩写）将终止命令列表（就像该命令后紧跟着 "
"end）。因为在任何时候继续运行下去（即使是简单的 next 或 "
"step），都可能会遇到另一个断点，该断点可能具有自己的命令列表，这导致要执行的列表含糊不清。"

#: ../../library/pdb.rst:417
msgid ""
"If you use the ``silent`` command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none"
" of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""
"如果在命令列表中使用 ``silent`` 命令，那么在断点处停下时就不会打印常规信息。 这正是要打印特定消息然后继续运行的断点所想要的。 "
"如果没有其他命令来打印任何消息，则你将不会看到已到达断点的迹象。"

#: ../../library/pdb.rst:424
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr "运行当前行，在第一个可以停止的位置（在被调用的函数内部或在当前函数的下一行）停下。"

#: ../../library/pdb.rst:429
msgid ""
"Continue execution until the next line in the current function is reached or"
" it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"继续运行，直到运行到当前函数的下一行，或当前函数返回为止。（ :pdbcmd:`next` 和 :pdbcmd:`step` "
"之间的区别在于，:pdbcmd:`step` 进入被调用函数内部并停止，而 :pdbcmd:`next` "
"（几乎）全速运行被调用函数，仅在当前函数的下一行停止。）"

#: ../../library/pdb.rst:437
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr "如果不带参数，则继续运行，直到行号比当前行大时停止。"

#: ../../library/pdb.rst:440
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr "如果带有 *lineno*，则继续执行直至行号大于或等于 *lineno*。 在这两种情况下，在当前帧返回时也将停止。"

#: ../../library/pdb.rst:444
msgid "Allow giving an explicit line number."
msgstr "允许明确给定行号。"

#: ../../library/pdb.rst:449
msgid "Continue execution until the current function returns."
msgstr "继续运行，直到当前函数返回。"

#: ../../library/pdb.rst:453
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "继续运行，仅在遇到断点时停止。"

#: ../../library/pdb.rst:457
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr "设置即将运行的下一行。仅可用于堆栈最底部的帧。它可以往回跳来再次运行代码，也可以往前跳来跳过不想运行的代码。"

#: ../../library/pdb.rst:461
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a "
":keyword:`finally` clause."
msgstr ""
"需要注意的是，不是所有的跳转都是允许的 -- 例如，不能跳转到 :keyword:`for` 循环的中间或跳出 :keyword:`finally` "
"子句。"

#: ../../library/pdb.rst:467
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11"
" lines around at that line.  With two arguments, list the given range; if "
"the second argument is less than the first, it is interpreted as a count."
msgstr ""
"列出当前文件的源代码。如果不带参数，则列出当前行周围的 11 行，或延续前一次列出。如果用 ``.`` 作为参数，则列出当前行周围的 11 "
"行。如果带有一个参数，则列出那一行周围的 11 "
"行。如果带有两个参数，则列出所给的范围中的代码；如果第二个参数小于第一个参数，则将其解释为列出行数的计数。"

#: ../../library/pdb.rst:473
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr "当前帧中的当前行用 ``->`` 标记。如果正在调试异常，且最早抛出或传递该异常的行不是当前行，则那一行用 ``>>`` 标记。"

#: ../../library/pdb.rst:478
msgid "Added the ``>>`` marker."
msgstr "增加了 ``>>`` 标记。"

#: ../../library/pdb.rst:483
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr "列出当前函数或帧的所有源代码。相关行的标记与 :pdbcmd:`list` 相同。"

#: ../../library/pdb.rst:490
msgid "Print the arguments of the current function and their current values."
msgstr "打印当前函数的参数及其当前的值。"

#: ../../library/pdb.rst:494
msgid "Evaluate *expression* in the current context and print its value."
msgstr "在当前上下文中对 *expression* 求值并打印该值。"

#: ../../library/pdb.rst:498
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr "``print()`` 也可以使用，但它不是一个调试器命令 --- 它执行 Python :func:`print` 函数。"

#: ../../library/pdb.rst:504
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr "与 :pdbcmd:`p` 命令类似，但 *expression* 的值将使用 :mod:`pprint` 模块美观地打印。"

#: ../../library/pdb.rst:509
msgid "Print the type of *expression*."
msgstr "打印 *expression* 的类型。"

#: ../../library/pdb.rst:513
msgid "Try to get source code of *expression* and display it."
msgstr "尝试获取 *expression* 的源代码并显示它。"

#: ../../library/pdb.rst:519
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr "如果 *expression* 的值发生变化则显示它的值，每次都会停止执行当前帧。"

#: ../../library/pdb.rst:522
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr "如果不带 *expression*，则列出当前帧的所有显示表达式。"

#: ../../library/pdb.rst:526
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr "显示 *expression* 的值并与 *expression* 之前的求值结果进行比较，因此当结果可变时，显示可能无法体现变化。"

#: ../../library/pdb.rst:530
msgid "Example::"
msgstr "示例::"

#: ../../library/pdb.rst:532
msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"

#: ../../library/pdb.rst:538
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr "显示将不会发现 ``lst`` 已被改变因为求值结果在执行比较之前已被 ``lst.append(1)`` 原地修改了::"

#: ../../library/pdb.rst:541
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"

#: ../../library/pdb.rst:553
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr "你可以通过拷贝机制巧妙地实现此功能::"

#: ../../library/pdb.rst:555
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"

#: ../../library/pdb.rst:572
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr "不再显示当前帧中的 *expression*。 如果不带 *expression*，则清除当前帧的所有显示表达式。"

#: ../../library/pdb.rst:579
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) whose global"
" namespace contains all the (global and local) names found in the current "
"scope."
msgstr ""

#: ../../library/pdb.rst:589
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, and so on, while ``%*`` is replaced by all the parameters. "
"If *command* is omitted, the current alias for *name* is shown. If no "
"arguments are given, all aliases are listed."
msgstr ""

#: ../../library/pdb.rst:595
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"别名允许嵌套并可包含能在 pdb 提示符下合法输入的任何内容。 请注意内部 pdb 命令 *可以* 被别名所覆盖。 这样的命令将被隐藏直到别名被移除。 "
"别名会递归地应用到命令行的第一个单词；行内的其他单词不会受影响。"

#: ../../library/pdb.rst:601
msgid ""
"As an example, here are two useful aliases (especially when placed in the "
":file:`.pdbrc` file)::"
msgstr "作为示例，这里列出了两个有用的别名（特别适合放在 :file:`.pdbrc` 文件中）::"

#: ../../library/pdb.rst:604
msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""
"# 打印实例变量 (用法 \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# 打印 self 中的实例变量\n"
"alias ps pi self"

#: ../../library/pdb.rst:611
msgid "Delete the specified alias *name*."
msgstr "删除指定的别名 *name*。"

#: ../../library/pdb.rst:615
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr "在当前栈帧的上下文中执行 (单行的) *statement*。 感叹号可以被省略，除非第一个语句的第一个单词与某个调试器命名重名，例如:"

#: ../../library/pdb.rst:619
msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""
"(Pdb) ! n=42\n"
"(Pdb)"

#: ../../library/pdb.rst:624
msgid ""
"To set a global variable, you can prefix the assignment command with a "
":keyword:`global` statement on the same line, e.g.:"
msgstr "要设置全局变量，你可以在同一行上在赋值命令前添加 :keyword:`global` 语句，例如:"

#: ../../library/pdb.rst:627
msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"

#: ../../library/pdb.rst:635
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. "
":pdbcmd:`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"重启被调试的 Python 程序。 如果提供了 *args*，它会用 :mod:`shlex` 来拆分且拆分结果将被用作新的 "
":data:`sys.argv`。 历史、中断点、动作和调试器选项将被保留。 :pdbcmd:`restart` 是 :pdbcmd:`run` "
"的一个别名。"

#: ../../library/pdb.rst:642
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "退出调试器。 被执行的程序将被中止。"

#: ../../library/pdb.rst:646
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr "进入一个对 *code* 执行步进的递归调试器（该参数是在当前环境中执行的任意表达式或语句）。"

#: ../../library/pdb.rst:652
msgid "Print the return value for the last return of the current function."
msgstr "打印当前函数最后一次返回的返回值。"

#: ../../library/pdb.rst:655
msgid "Footnotes"
msgstr "备注"

#: ../../library/pdb.rst:656
msgid ""
"Whether a frame is considered to originate in a certain module is determined"
" by the ``__name__`` in the frame globals."
msgstr "一个帧是否会被认为源自特定模块是由帧全局变量 ``__name__`` 来决定的。"

#: ../../library/pdb.rst:11
msgid "debugging"
msgstr "调试"

#: ../../library/pdb.rst:21
msgid "Pdb (class in pdb)"
msgstr "Pdb (pdb 中的类)"

#: ../../library/pdb.rst:21
msgid "module"
msgstr "module"

#: ../../library/pdb.rst:21
msgid "bdb"
msgstr "bdb"

#: ../../library/pdb.rst:21
msgid "cmd"
msgstr "cmd"

#: ../../library/pdb.rst:292
msgid ".pdbrc"
msgstr ".pdbrc"

#: ../../library/pdb.rst:292
msgid "file"
msgstr "文件"

#: ../../library/pdb.rst:292
msgid "debugger"
msgstr "调试器"

#: ../../library/pdb.rst:292
msgid "configuration"
msgstr "配置"
