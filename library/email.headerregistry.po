# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.headerregistry.rst:2
msgid ":mod:`!email.headerregistry`: Custom Header Objects"
msgstr ":mod:`!email.headerregistry`: 自定义标头对象"

#: ../../library/email.headerregistry.rst:10
msgid "**Source code:** :source:`Lib/email/headerregistry.py`"
msgstr "**源代码:** :source:`Lib/email/headerregistry.py`"

#: ../../library/email.headerregistry.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.headerregistry.rst:16
msgid ""
"Headers are represented by customized subclasses of :class:`str`.  The "
"particular class used to represent a given header is determined by the "
":attr:`~email.policy.EmailPolicy.header_factory` of the :mod:`~email.policy`"
" in effect when the headers are created.  This section documents the "
"particular ``header_factory`` implemented by the email package for handling "
":RFC:`5322` compliant email messages, which not only provides customized "
"header objects for various header types, but also provides an extension "
"mechanism for applications to add their own custom header types."
msgstr ""
"标头是由 :class:`str` 的自定义子类来表示的。 用于表示给定标头的特定类则由创建标头时生效的 :mod:`~email.policy` 的 "
":attr:`~email.policy.EmailPolicy.header_factory` 确定。 这一节记录了 email 包为处理兼容 "
":RFC:`5322` 的电子邮件消息所实现的特定 "
"``header_factory``，它不仅为各种标头类型提供了自定义的标头对象，还为应用程序提供了添加其自定义标头类型的扩展机制。"

#: ../../library/email.headerregistry.rst:25
msgid ""
"When using any of the policy objects derived from "
":data:`~email.policy.EmailPolicy`, all headers are produced by "
":class:`.HeaderRegistry` and have :class:`.BaseHeader` as their last base "
"class.  Each header class has an additional base class that is determined by"
" the type of the header.  For example, many headers have the class "
":class:`.UnstructuredHeader` as their other base class.  The specialized "
"second class for a header is determined by the name of the header, using a "
"lookup table stored in the :class:`.HeaderRegistry`.  All of this is managed"
" transparently for the typical application program, but interfaces are "
"provided for modifying the default behavior for use by more complex "
"applications."
msgstr ""
"当使用派生自 :data:`~email.policy.EmailPolicy` 的任何策略对象时，所有标头都通过 "
":class:`.HeaderRegistry` 产生并且以 :class:`.BaseHeader` 作为其最后一个基类。 "
"每个标头类都有一个由该标头类型确定的附加基类。 例如，许多标头都以 :class:`.UnstructuredHeader` 类作为其另一个基类。 "
"一个标头专用的第二个类是由标头名称使用存储在 :class:`.HeaderRegistry` 中的查找表来确定的。 "
"所有这些都针对典型应用程序进行透明的管理，但也为修改默认行为提供了接口，以便由更复杂的应用使用。"

#: ../../library/email.headerregistry.rst:36
msgid ""
"The sections below first document the header base classes and their "
"attributes, followed by the API for modifying the behavior of "
":class:`.HeaderRegistry`, and finally the support classes used to represent "
"the data parsed from structured headers."
msgstr ""
"以下各节首先记录了标头基类及其属性，然后是用于修改 :class:`.HeaderRegistry` 行为的 "
"API，最后是用于表示从结构化标头解析的数据的支持类。"

#: ../../library/email.headerregistry.rst:44
msgid ""
"*name* and *value* are passed to ``BaseHeader`` from the "
":attr:`~email.policy.EmailPolicy.header_factory` call.  The string value of "
"any header object is the *value* fully decoded to unicode."
msgstr ""
"*name* 和 *value* 会从 :attr:`~email.policy.EmailPolicy.header_factory` 调用传递给 "
"``BaseHeader``。 任何标头对象的字符串值都是完成解码为 unicode 的 *value*。"

#: ../../library/email.headerregistry.rst:48
msgid "This base class defines the following read-only properties:"
msgstr "这个基类定义了下列只读属性:"

#: ../../library/email.headerregistry.rst:53
msgid ""
"The name of the header (the portion of the field before the ':').  This is "
"exactly the value passed in the "
":attr:`~email.policy.EmailPolicy.header_factory` call for *name*; that is, "
"case is preserved."
msgstr ""
"标头的名称（字段在 ':' 之前的部分）。 这就是 *name* 的 "
":attr:`~email.policy.EmailPolicy.header_factory` 调用所传递的值；也就是说会保持大小写形式。"

#: ../../library/email.headerregistry.rst:61
msgid ""
"A tuple of :exc:`~email.errors.HeaderDefect` instances reporting any RFC "
"compliance problems found during parsing.  The email package tries to be "
"complete about detecting compliance issues.  See the :mod:`~email.errors` "
"module for a discussion of the types of defects that may be reported."
msgstr ""
"一个包含 :exc:`~email.errors.HeaderDefect` 实例的元组，这些实例报告了在解析期间发现的任何 RFC 合规性问题。 "
"email 包会尝试尽可能地检测合规性问题。 请参阅 :mod:`~email.errors` 模块了解可能被报告的缺陷类型的相关讨论。"

#: ../../library/email.headerregistry.rst:69
msgid ""
"The maximum number of headers of this type that can have the same ``name``."
"  A value of ``None`` means unlimited.  The ``BaseHeader`` value for this "
"attribute is ``None``; it is expected that specialized header classes will "
"override this value as needed."
msgstr ""
"此类型标头可具有相同 ``name`` 的最大数量。 ``None`` 值表示无限制。 此属性的 ``BaseHeader`` 值为 "
"``None``；专用的标头类预期将根据需要覆盖这个值。"

#: ../../library/email.headerregistry.rst:74
msgid ""
"``BaseHeader`` also provides the following method, which is called by the "
"email library code and should not in general be called by application "
"programs:"
msgstr "``BaseHeader`` 还提供了以下方法，它由 email 库代码调用，通常不应当由应用程序来调用。"

#: ../../library/email.headerregistry.rst:80
msgid ""
"Return a string containing :attr:`~email.policy.Policy.linesep` characters "
"as required to correctly fold the header according to *policy*.  A "
":attr:`~email.policy.Policy.cte_type` of ``8bit`` will be treated as if it "
"were ``7bit``, since headers may not contain arbitrary binary data.  If "
":attr:`~email.policy.EmailPolicy.utf8` is ``False``, non-ASCII data will be "
":rfc:`2047` encoded."
msgstr ""
"返回一个字符串，其中包含用来根据 *policy* 正确地折叠标头的 :attr:`~email.policy.Policy.linesep` 字符。"
"  :attr:`~email.policy.Policy.cte_type` 为 ``8bit`` 时将被作为 ``7bit`` "
"来处理，因为标头不能包含任意二进制数据。 如果 :attr:`~email.policy.EmailPolicy.utf8` 为 "
"``False``，则非 ASCII 数据将根据 :rfc:`2047` 来编码。"

#: ../../library/email.headerregistry.rst:88
msgid ""
"``BaseHeader`` by itself cannot be used to create a header object.  It "
"defines a protocol that each specialized header cooperates with in order to "
"produce the header object.  Specifically, ``BaseHeader`` requires that the "
"specialized class provide a :func:`classmethod` named ``parse``.  This "
"method is called as follows::"
msgstr ""
"``BaseHeader`` 本身不能被用于创建标头对象。 它定义了一个与每个专用标头相配合的协议以便生成标头对象。 "
"具体来说，``BaseHeader`` 要求专用类提供一个名为 ``parse`` 的 :func:`classmethod`。 "
"此方法的调用形式如下::"

#: ../../library/email.headerregistry.rst:94
msgid "parse(string, kwds)"
msgstr "parse(string, kwds)"

#: ../../library/email.headerregistry.rst:96
msgid ""
"``kwds`` is a dictionary containing one pre-initialized key, ``defects``. "
"``defects`` is an empty list.  The parse method should append any detected "
"defects to this list.  On return, the ``kwds`` dictionary *must* contain "
"values for at least the keys ``decoded`` and ``defects``.  ``decoded`` "
"should be the string value for the header (that is, the header value fully "
"decoded to unicode).  The parse method should assume that *string* may "
"contain content-transfer-encoded parts, but should correctly handle all "
"valid unicode characters as well so that it can parse un-encoded header "
"values."
msgstr ""
"``kwds`` 是包含了一个预初始化键 ``defects`` 的字典。 ``defects`` 是一个空列表。 parse "
"方法应当将任何已检测到的缺陷添加到此列表中。 在返回时，``kwds`` 字典 *必须* 至少包含 ``decoded`` 和 ``defects`` "
"等键的值。 ``decoded`` 应当是标头的字符串值（即完全解码为 unicode 的标头值）。 parse 方法应当假定 *string* "
"可能包含 content-transfer-encoded 部分，但也应当正确地处理全部有效的 unicode 字符以便它能解析未经编码的标头值。"

#: ../../library/email.headerregistry.rst:105
msgid ""
"``BaseHeader``'s ``__new__`` then creates the header instance, and calls its"
" ``init`` method.  The specialized class only needs to provide an ``init`` "
"method if it wishes to set additional attributes beyond those provided by "
"``BaseHeader`` itself.  Such an ``init`` method should look like this::"
msgstr ""
"随后 ``BaseHeader`` 的 ``__new__`` 会创建标头实例，并调用其 ``init`` 方法。 专属类如果想要设置 "
"``BaseHeader`` 自身所提供的属性之外的附加属性，只需提供一个 ``init`` 方法。 这样的 ``init`` 看起来应该是这样::"

#: ../../library/email.headerregistry.rst:110
msgid ""
"def init(self, /, *args, **kw):\n"
"    self._myattr = kw.pop('myattr')\n"
"    super().init(*args, **kw)"
msgstr ""
"def init(self, /, *args, **kw):\n"
"    self._myattr = kw.pop('myattr')\n"
"    super().init(*args, **kw)"

#: ../../library/email.headerregistry.rst:114
msgid ""
"That is, anything extra that the specialized class puts in to the ``kwds`` "
"dictionary should be removed and handled, and the remaining contents of "
"``kw`` (and ``args``) passed to the ``BaseHeader`` ``init`` method."
msgstr ""
"也就是说，专属类放入 ``kwds`` 字典的任何额外内容都应当被移除和处理，并且 ``kw`` (和 ``args``) 的剩余内容会被传递给 "
"``BaseHeader`` ``init`` 方法。"

#: ../../library/email.headerregistry.rst:121
msgid ""
"An \"unstructured\" header is the default type of header in :rfc:`5322`. Any"
" header that does not have a specified syntax is treated as unstructured.  "
"The classic example of an unstructured header is the :mailheader:`Subject` "
"header."
msgstr ""
"\"非结构化\" 标头是 :rfc:`5322` 中默认的标头类型。 任何没有指定语法的标头都会被视为是非结构化的。 非结构化标头的经典例子是 "
":mailheader:`Subject` 标头。"

#: ../../library/email.headerregistry.rst:126
msgid ""
"In :rfc:`5322`, an unstructured header is a run of arbitrary text in the "
"ASCII character set.  :rfc:`2047`, however, has an :rfc:`5322` compatible "
"mechanism for encoding non-ASCII text as ASCII characters within a header "
"value.  When a *value* containing encoded words is passed to the "
"constructor, the ``UnstructuredHeader`` parser converts such encoded words "
"into unicode, following the :rfc:`2047` rules for unstructured text.  The "
"parser uses heuristics to attempt to decode certain non-compliant encoded "
"words.  Defects are registered in such cases, as well as defects for issues "
"such as invalid characters within the encoded words or the non-encoded text."
msgstr ""
"在 :rfc:`5322` 中，非结构化标头是指一段以 ASCII 字符集表示的任意文本。 但是 :rfc:`2047` 具有一个 "
":rfc:`5322` 兼容机制用来将标头值中的非 ASCII 文本编码为 ASCII 字符。 当包含已编码字的 *value* "
"被传递给构造器时，``UnstructuredHeader`` 解析器会按照非结构化文本的 :rfc:`2047` 规则将此类已编码字转换为 "
"unicode。 解析器会使用启发式机制来尝试解码一些不合规的已编码字。 "
"在此种情况下各类缺陷，例如已编码字或未编码文本中的无效字符问题等缺陷将会被注册。"

#: ../../library/email.headerregistry.rst:136
msgid "This header type provides no additional attributes."
msgstr "此标头类型未提供附加属性。"

#: ../../library/email.headerregistry.rst:141
msgid ""
":rfc:`5322` specifies a very specific format for dates within email headers."
" The ``DateHeader`` parser recognizes that date format, as well as "
"recognizing a number of variant forms that are sometimes found \"in the "
"wild\"."
msgstr ""
":rfc:`5322` 为电子邮件标头内的日期指定了非常明确的格式。 ``DateHeader`` "
"解析器会识别该日期格式，并且也能识别间或出现的一些“不规范”变种形式。"

#: ../../library/email.headerregistry.rst:146
#: ../../library/email.headerregistry.rst:188
msgid "This header type provides the following additional attributes:"
msgstr "这个标头类型提供了以下附加属性。"

#: ../../library/email.headerregistry.rst:150
msgid ""
"If the header value can be recognized as a valid date of one form or "
"another, this attribute will contain a :class:`~datetime.datetime` instance "
"representing that date.  If the timezone of the input date is specified as "
"``-0000`` (indicating it is in UTC but contains no information about the "
"source timezone), then :attr:`.datetime` will be a naive "
":class:`~datetime.datetime`.  If a specific timezone offset is found "
"(including ``+0000``), then :attr:`.datetime` will contain an aware "
"``datetime`` that uses :class:`datetime.timezone` to record the timezone "
"offset."
msgstr ""
"如果标头值能被识别为某一种有效的日期形式，此属性将包含一个代表该日期的 :class:`~datetime.datetime` 实例。 "
"如果输入日期的时区被指定为 ``-0000`` (表示它是 UTC 但不包含源时区的相关信息)，则 :attr:`.datetime` 将为简单型 "
":class:`~datetime.datetime`。 如果找到了特定的时区时差值 (包括 ``+0000``)，则 "
":attr:`.datetime` 将包含一个使用 :class:`datetime.timezone` 来记录时区时差的感知型 "
"``datetime``。"

#: ../../library/email.headerregistry.rst:160
msgid ""
"The ``decoded`` value of the header is determined by formatting the "
"``datetime`` according to the :rfc:`5322` rules; that is, it is set to::"
msgstr ""
"标头的 ``decoded`` 值是由按照 :rfc:`5322` 对 ``datetime`` 进行格式化来确定的；也就是说，它会被设为::"

#: ../../library/email.headerregistry.rst:163
msgid "email.utils.format_datetime(self.datetime)"
msgstr "email.utils.format_datetime(self.datetime)"

#: ../../library/email.headerregistry.rst:165
msgid ""
"When creating a ``DateHeader``, *value* may be :class:`~datetime.datetime` "
"instance.  This means, for example, that the following code is valid and "
"does what one would expect::"
msgstr ""
"当创建 ``DateHeader`` 时，*value* 可以为 :class:`~datetime.datetime` 实例。 "
"例如这意味着以下代码是有效的并能实现人们预期的行为::"

#: ../../library/email.headerregistry.rst:169
msgid "msg['Date'] = datetime(2011, 7, 15, 21)"
msgstr "msg['Date'] = datetime(2011, 7, 15, 21)"

#: ../../library/email.headerregistry.rst:171
msgid ""
"Because this is a naive ``datetime`` it will be interpreted as a UTC "
"timestamp, and the resulting value will have a timezone of ``-0000``.  Much "
"more useful is to use the :func:`~email.utils.localtime` function from the "
":mod:`~email.utils` module::"
msgstr ""
"因为这是个简单型 ``datetime`` 它将被解读为 UTC 时间戳，并且结果值的时区将为 ``-0000``。 使用来自 "
":mod:`~email.utils` 模块的 :func:`~email.utils.localtime` 函数会更有用::"

#: ../../library/email.headerregistry.rst:176
msgid "msg['Date'] = utils.localtime()"
msgstr "msg['Date'] = utils.localtime()"

#: ../../library/email.headerregistry.rst:178
msgid ""
"This example sets the date header to the current time and date using the "
"current timezone offset."
msgstr "这个例子将日期标头设为使用当前时区时差值的当前时间和日期。"

#: ../../library/email.headerregistry.rst:184
msgid ""
"Address headers are one of the most complex structured header types. The "
"``AddressHeader`` class provides a generic interface to any address header."
msgstr "地址标头是最复杂的结构化标头类型之一。 ``AddressHeader`` 类提供了适合任何地址标头的泛用型接口。"

#: ../../library/email.headerregistry.rst:193
msgid ""
"A tuple of :class:`.Group` objects encoding the addresses and groups found "
"in the header value.  Addresses that are not part of a group are represented"
" in this list as single-address ``Groups`` whose "
":attr:`~.Group.display_name` is ``None``."
msgstr ""
"编码了在标头值中找到的地址和分组的 :class:`.Group` 对象的元组。 非分组成员的地址在此列表中表示为 "
":attr:`~.Group.display_name` 为 ``None`` 的单地址 ``Groups``。"

#: ../../library/email.headerregistry.rst:201
msgid ""
"A tuple of :class:`.Address` objects encoding all of the individual "
"addresses from the header value.  If the header value contains any groups, "
"the individual addresses from the group are included in the list at the "
"point where the group occurs in the value (that is, the list of addresses is"
" \"flattened\" into a one dimensional list)."
msgstr ""
"编码了来自标头值的所有单独地址的 :class:`.Address` 对象的元组。 "
"如果标头值包含任何分组，则来自分组的单个地址将包含在该分组出现在值中的点上列出（也就是说，地址列表会被“展平”为一维列表）。"

#: ../../library/email.headerregistry.rst:207
msgid ""
"The ``decoded`` value of the header will have all encoded words decoded to "
"unicode.  :class:`~encodings.idna` encoded domain names are also decoded to "
"unicode.  The ``decoded`` value is set by :ref:`joining <meth-str-join>` the"
" :class:`str` value of the elements of the ``groups`` attribute with ``', "
"'``."
msgstr ""
"标头的 ``decoded`` 值将把所有已编码字解码为 unicode。 :class:`~encodings.idna` 编码的域名也会被解码为 "
"unicode。 ``decoded`` 值是通过对 ``groups`` 属性的元素的 :class:`str` 值使用 ``', '`` 进行 "
":ref:`合并 <meth-str-join>` 来设置的。"

#: ../../library/email.headerregistry.rst:213
msgid ""
"A list of :class:`.Address` and :class:`.Group` objects in any combination "
"may be used to set the value of an address header.  ``Group`` objects whose "
"``display_name`` is ``None`` will be interpreted as single addresses, which "
"allows an address list to be copied with groups intact by using the list "
"obtained from the ``groups`` attribute of the source header."
msgstr ""
"可以使用 :class:`.Address` 与 :class:`.Group` 对象的任意组合的列表来设置一个地址标头的值。 "
"``display_name`` 为 ``None`` 的 ``Group`` 对象将被解读为单独地址，这允许一个地址列表可以附带通过使用从源标头的 "
"``groups`` 属性获取的列表而保留原分组。"

#: ../../library/email.headerregistry.rst:222
msgid ""
"A subclass of :class:`.AddressHeader` that adds one additional attribute:"
msgstr ":class:`.AddressHeader` 的子类，添加了一个额外的属性:"

#: ../../library/email.headerregistry.rst:228
msgid ""
"The single address encoded by the header value.  If the header value "
"actually contains more than one address (which would be a violation of the "
"RFC under the default :mod:`~email.policy`), accessing this attribute will "
"result in a :exc:`ValueError`."
msgstr ""
"由标头值编码的单个地址。 如果标头值实际上包含一个以上的地址（这在默认 :mod:`~email.policy` 下将违反 RFC），则访问此属性将导致"
" :exc:`ValueError`。"

#: ../../library/email.headerregistry.rst:234
msgid ""
"Many of the above classes also have a ``Unique`` variant (for example, "
"``UniqueUnstructuredHeader``).  The only difference is that in the "
"``Unique`` variant, :attr:`~.BaseHeader.max_count` is set to 1."
msgstr ""
"上述类中许多还具有一个 ``Unique`` 变体 (例如 ``UniqueUnstructuredHeader``)。 其唯一差别是在 "
"``Unique`` 变体中 :attr:`~.BaseHeader.max_count` 被设为 1。"

#: ../../library/email.headerregistry.rst:241
msgid ""
"There is really only one valid value for the :mailheader:`MIME-Version` "
"header, and that is ``1.0``.  For future proofing, this header class "
"supports other valid version numbers.  If a version number has a valid value"
" per :rfc:`2045`, then the header object will have non-``None`` values for "
"the following attributes:"
msgstr ""
"实际上 :mailheader:`MIME-Version` 标头只有一个有效的值，即 ``1.0``。 "
"为了将来的扩展，这个标头类还支持其他的有效版本号。 如果一个版本号是 :rfc:`2045` 的有效值，则标头对象的以下属性将具有不为 ``None``"
" 的值:"

#: ../../library/email.headerregistry.rst:249
msgid ""
"The version number as a string, with any whitespace and/or comments removed."
msgstr "字符串形式的版本号。 任何空格和/或注释都会被移除。"

#: ../../library/email.headerregistry.rst:254
msgid "The major version number as an integer"
msgstr "整数形式的主版本号"

#: ../../library/email.headerregistry.rst:258
msgid "The minor version number as an integer"
msgstr "整数形式的次版本号"

#: ../../library/email.headerregistry.rst:263
msgid ""
"MIME headers all start with the prefix 'Content-'.  Each specific header has"
" a certain value, described under the class for that header.  Some can also "
"take a list of supplemental parameters, which have a common format. This "
"class serves as a base for all the MIME headers that take parameters."
msgstr ""
"MIME 标头都以前缀 'Content-' 打头。 每个特定标头都具有特定的值，其描述在该标头的类之中。 "
"有些也可以接受一个具有通用格式的补充形参形表。 这个类被用作所有接受形参的 MIME 标头的基类。"

#: ../../library/email.headerregistry.rst:270
msgid "A dictionary mapping parameter names to parameter values."
msgstr "一个将形参名映射到形参值的字典。"

#: ../../library/email.headerregistry.rst:275
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the "
":mailheader:`Content-Type` header."
msgstr ""
"处理 :mailheader:`Content-Type` 标头的  :class:`ParameterizedMIMEHeader` 类。"

#: ../../library/email.headerregistry.rst:280
msgid "The content type string, in the form ``maintype/subtype``."
msgstr "``maintype/subtype`` 形式的内容类型字符串。"

#: ../../library/email.headerregistry.rst:289
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the "
":mailheader:`Content-Disposition` header."
msgstr ""
"处理 :mailheader:`Content-Disposition` 标头的 :class:`ParameterizedMIMEHeader` 类。"

#: ../../library/email.headerregistry.rst:294
msgid "``inline`` and ``attachment`` are the only valid values in common use."
msgstr "``inline`` 和 ``attachment`` 是仅有的常用有效值。"

#: ../../library/email.headerregistry.rst:299
msgid "Handles the :mailheader:`Content-Transfer-Encoding` header."
msgstr "处理 :mailheader:`Content-Transfer-Encoding` 标头。"

#: ../../library/email.headerregistry.rst:303
msgid ""
"Valid values are ``7bit``, ``8bit``, ``base64``, and ``quoted-printable``.  "
"See :rfc:`2045` for more information."
msgstr ""
"可用的有效值为 ``7bit``, ``8bit``, ``base64`` 和 ``quoted-printable``。 更多信息请参阅 "
":rfc:`2045`。"

#: ../../library/email.headerregistry.rst:312
msgid ""
"This is the factory used by :class:`~email.policy.EmailPolicy` by default. "
"``HeaderRegistry`` builds the class used to create a header instance "
"dynamically, using *base_class* and a specialized class retrieved from a "
"registry that it holds.  When a given header name does not appear in the "
"registry, the class specified by *default_class* is used as the specialized "
"class.  When *use_default_map* is ``True`` (the default), the standard "
"mapping of header names to classes is copied in to the registry during "
"initialization.  *base_class* is always the last class in the generated "
"class's :class:`~type.__bases__` list."
msgstr ""
"这是由 :class:`~email.policy.EmailPolicy` 在默认情况下使用的工厂函数。 ``HeaderRegistry`` 会使用"
" *base_class* 和从它所保存的注册表中获取的专用类来构建用于动态地创建标头实例的类。 当给定的标头名称未在注册表中出现时，则会使用由 "
"*default_class* 所指定的类作为专用类。 当 *use_default_map* 为 ``True`` (默认值) "
"时，则会在初始化期间把从标头名称到类的标准映射拷贝到注册表中。 *base_class* 始终会是所生成的类的 "
":class:`~type.__bases__` 列表中的最后一个类。"

#: ../../library/email.headerregistry.rst:322
msgid "The default mappings are:"
msgstr "默认的映射有:"

#: ../../library/email.headerregistry.rst:0
msgid "subject"
msgstr "subject"

#: ../../library/email.headerregistry.rst:324
msgid "UniqueUnstructuredHeader"
msgstr "UniqueUnstructuredHeader"

#: ../../library/email.headerregistry.rst:0
msgid "date"
msgstr "date"

#: ../../library/email.headerregistry.rst:325
#: ../../library/email.headerregistry.rst:327
msgid "UniqueDateHeader"
msgstr "UniqueDateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-date"
msgstr "resent-date"

#: ../../library/email.headerregistry.rst:326
msgid "DateHeader"
msgstr "DateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "orig-date"
msgstr "orig-date"

#: ../../library/email.headerregistry.rst:0
msgid "sender"
msgstr "sender"

#: ../../library/email.headerregistry.rst:328
msgid "UniqueSingleAddressHeader"
msgstr "UniqueSingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-sender"
msgstr "resent-sender"

#: ../../library/email.headerregistry.rst:329
msgid "SingleAddressHeader"
msgstr "SingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "to"
msgstr "到"

#: ../../library/email.headerregistry.rst:330
#: ../../library/email.headerregistry.rst:332
#: ../../library/email.headerregistry.rst:334
#: ../../library/email.headerregistry.rst:336
#: ../../library/email.headerregistry.rst:338
msgid "UniqueAddressHeader"
msgstr "UniqueAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-to"
msgstr "resent-to"

#: ../../library/email.headerregistry.rst:331
#: ../../library/email.headerregistry.rst:333
#: ../../library/email.headerregistry.rst:335
#: ../../library/email.headerregistry.rst:337
msgid "AddressHeader"
msgstr "AddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "cc"
msgstr "cc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-cc"
msgstr "resent-cc"

#: ../../library/email.headerregistry.rst:0
msgid "bcc"
msgstr "bcc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-bcc"
msgstr "resent-bcc"

#: ../../library/email.headerregistry.rst:0
msgid "from"
msgstr "从"

#: ../../library/email.headerregistry.rst:0
msgid "resent-from"
msgstr "resent-from"

#: ../../library/email.headerregistry.rst:0
msgid "reply-to"
msgstr "reply-to"

#: ../../library/email.headerregistry.rst:0
msgid "mime-version"
msgstr "mime-version"

#: ../../library/email.headerregistry.rst:339
msgid "MIMEVersionHeader"
msgstr "MIMEVersionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-type"
msgstr "content-type"

#: ../../library/email.headerregistry.rst:340
msgid "ContentTypeHeader"
msgstr "ContentTypeHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-disposition"
msgstr "content-disposition"

#: ../../library/email.headerregistry.rst:341
msgid "ContentDispositionHeader"
msgstr "ContentDispositionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-transfer-encoding"
msgstr "content-transfer-encoding"

#: ../../library/email.headerregistry.rst:342
msgid "ContentTransferEncodingHeader"
msgstr "ContentTransferEncodingHeader"

#: ../../library/email.headerregistry.rst:0
msgid "message-id"
msgstr "message-id"

#: ../../library/email.headerregistry.rst:343
msgid "MessageIDHeader"
msgstr "MessageIDHeader"

#: ../../library/email.headerregistry.rst:345
msgid "``HeaderRegistry`` has the following methods:"
msgstr "``HeaderRegistry`` 具有下列方法:"

#: ../../library/email.headerregistry.rst:350
msgid ""
"*name* is the name of the header to be mapped.  It will be converted to "
"lower case in the registry.  *cls* is the specialized class to be used, "
"along with *base_class*, to create the class used to instantiate headers "
"that match *name*."
msgstr ""
"*name* 是要映射的标头名称。 它将在注册表中被转换为小写形式。 *cls* 是要与 *base_class* 一起被用来创建用于实例化与 "
"*name* 相匹配的标头的类的专用类。"

#: ../../library/email.headerregistry.rst:358
msgid "Construct and return a class to handle creating a *name* header."
msgstr "构造并返回一个类来处理 *name* 标头的创建。"

#: ../../library/email.headerregistry.rst:363
msgid ""
"Retrieves the specialized header associated with *name* from the registry "
"(using *default_class* if *name* does not appear in the registry) and "
"composes it with *base_class* to produce a class, calls the constructed "
"class's constructor, passing it the same argument list, and finally returns "
"the class instance created thereby."
msgstr ""
"从注册表获得与 *name* 相关联的专用标头 (如果 *name* 未在注册表中出现则使用 *default_class*) 并将其与 "
"*base_class* 相组合以产生类，调用被构造类的构造器，传入相同的参数列表，并最终返回由此创建的类实例。"

#: ../../library/email.headerregistry.rst:370
msgid ""
"The following classes are the classes used to represent data parsed from "
"structured headers and can, in general, be used by an application program to"
" construct structured values to assign to specific headers."
msgstr "以下的类是用于表示从结构化标头解析的数据的类，并且通常会由应用程序使用以构造结构化的值并赋给特定的标头。"

#: ../../library/email.headerregistry.rst:377
msgid ""
"The class used to represent an email address.  The general form of an "
"address is::"
msgstr "用于表示电子邮件地址的类。 地址的一般形式为::"

#: ../../library/email.headerregistry.rst:380
msgid "[display_name] <username@domain>"
msgstr "[display_name] <username@domain>"

#: ../../library/email.headerregistry.rst:382
msgid "or::"
msgstr "或者："

#: ../../library/email.headerregistry.rst:384
msgid "username@domain"
msgstr "username@domain"

#: ../../library/email.headerregistry.rst:386
msgid ""
"where each part must conform to specific syntax rules spelled out in "
":rfc:`5322`."
msgstr "其中每个部分都必须符合在 :rfc:`5322` 中阐述的特定语法规则。"

#: ../../library/email.headerregistry.rst:389
msgid ""
"As a convenience *addr_spec* can be specified instead of *username* and "
"*domain*, in which case *username* and *domain* will be parsed from the "
"*addr_spec*.  An *addr_spec* must be a properly RFC quoted string; if it is "
"not ``Address`` will raise an error.  Unicode characters are allowed and "
"will be property encoded when serialized.  However, per the RFCs, unicode is"
" *not* allowed in the username portion of the address."
msgstr ""
"为了方便起见可以指定 *addr_spec* 来替代 *username* 和 *domain*，在此情况下 *username* 和 *domain*"
" 将从 *addr_spec* 中解析。 *addr_spec* 应当是一个正确地引用了 RFC 的字符串；如果它不是 ``Address`` "
"则将引发错误。 Unicode 字符也允许使用并将在序列化时被正确地编码。 但是，根据 RFC，地址的 username 部分 *不允许* 有 "
"unicode。"

#: ../../library/email.headerregistry.rst:398
msgid ""
"The display name portion of the address, if any, with all quoting removed.  "
"If the address does not have a display name, this attribute will be an empty"
" string."
msgstr "地址的显示名称部分（如果有的话）并去除所有引用项。 如果地址没有显示名称，则此属性将为空字符串。"

#: ../../library/email.headerregistry.rst:404
msgid "The ``username`` portion of the address, with all quoting removed."
msgstr "地址的 ``username`` 部分，去除所有引用项。"

#: ../../library/email.headerregistry.rst:408
msgid "The ``domain`` portion of the address."
msgstr "地址的 ``domain`` 部分。"

#: ../../library/email.headerregistry.rst:412
msgid ""
"The ``username@domain`` portion of the address, correctly quoted for use as "
"a bare address (the second form shown above).  This attribute is not "
"mutable."
msgstr "地址的 ``username@domain`` 部分，经过正确引用处理以作为纯地址使用（上面显示的第二种形式）。 此属性不可变。"

#: ../../library/email.headerregistry.rst:418
msgid ""
"The ``str`` value of the object is the address quoted according to "
":rfc:`5322` rules, but with no Content Transfer Encoding of any non-ASCII "
"characters."
msgstr ""
"对象的 ``str`` 值是根据 :rfc:`5322` 规则进行引用处理的地址，但不带任何非 ASCII 字符的 Content Transfer "
"Encoding。"

#: ../../library/email.headerregistry.rst:422
msgid ""
"To support SMTP (:rfc:`5321`), ``Address`` handles one special case: if "
"``username`` and ``domain`` are both the empty string (or ``None``), then "
"the string value of the ``Address`` is ``<>``."
msgstr ""
"为了支持 SMTP (:rfc:`5321`)，``Address`` 会处理一种特殊情况：如果 ``username`` 和 ``domain`` "
"均为空字符串 (或为 ``None``)，则 ``Address`` 的字符串值为 ``<>``。"

#: ../../library/email.headerregistry.rst:429
msgid ""
"The class used to represent an address group.  The general form of an "
"address group is::"
msgstr "用于表示地址组的类。 地址组的一般形式为::"

#: ../../library/email.headerregistry.rst:432
msgid "display_name: [address-list];"
msgstr "display_name: [address-list];"

#: ../../library/email.headerregistry.rst:434
msgid ""
"As a convenience for processing lists of addresses that consist of a mixture"
" of groups and single addresses, a ``Group`` may also be used to represent "
"single addresses that are not part of a group by setting *display_name* to "
"``None`` and providing a list of the single address as *addresses*."
msgstr ""
"作为处理由组和单个地址混合构成的列表的便捷方式，``Group`` 也可以通过将 *display_name* 设为 ``None`` "
"以用来表示不是某个组的一部分的单独地址并提供单独地址的列表作为 *addresses*。"

#: ../../library/email.headerregistry.rst:441
msgid ""
"The ``display_name`` of the group.  If it is ``None`` and there is exactly "
"one ``Address`` in ``addresses``, then the ``Group`` represents a single "
"address that is not in a group."
msgstr ""
"组的 ``display_name``。 如果其为 ``None`` 并且恰好有一个 ``Address`` 在 ``addresses`` 中，则 "
"``Group`` 表示一个不在某个组中的单独地址。"

#: ../../library/email.headerregistry.rst:447
msgid ""
"A possibly empty tuple of :class:`.Address` objects representing the "
"addresses in the group."
msgstr "一个可能为空的表示组中地址的包含 :class:`.Address` 对象的元组。"

#: ../../library/email.headerregistry.rst:452
msgid ""
"The ``str`` value of a ``Group`` is formatted according to :rfc:`5322`, but "
"with no Content Transfer Encoding of any non-ASCII characters.  If "
"``display_name`` is none and there is a single ``Address`` in the "
"``addresses`` list, the ``str`` value will be the same as the ``str`` of "
"that single ``Address``."
msgstr ""
"``Group`` 的 ``str`` 值会根据 :rfc:`5322` 进行格式化，但不带任何非 ASCII 字符的 Content Transfer"
" Encoding。 如果 ``display_name`` 为空值且只有一个单独 ``Address`` 在 ``addresses`` 列表中，则 "
"``str`` 值将与该单独 ``Address`` 的 ``str`` 相同。"

#: ../../library/email.headerregistry.rst:460
msgid "Footnotes"
msgstr "备注"

#: ../../library/email.headerregistry.rst:461
msgid ""
"Originally added in 3.3 as a :term:`provisional module <provisional "
"package>`"
msgstr "最初在 3.3 中作为 :term:`暂定模块 <provisional package>` 添加"
