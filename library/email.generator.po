# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# eric R <trencyclopedia@gmail.com>, 2020
# Kevin Deng <kevindeng55+transifex@gmail.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 12:01+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.generator.rst:2
msgid ":mod:`email.generator`: Generating MIME documents"
msgstr ":mod:`email.generator`: 生成 MIME 文档"

#: ../../library/email.generator.rst:7
msgid "**Source code:** :source:`Lib/email/generator.py`"
msgstr "**源代码:** :source:`Lib/email/generator.py`"

#: ../../library/email.generator.rst:11
msgid ""
"One of the most common tasks is to generate the flat (serialized) version of"
" the email message represented by a message object structure.  You will need"
" to do this if you want to send your message via "
":meth:`smtplib.SMTP.sendmail` or the :mod:`nntplib` module, or print the "
"message on the console.  Taking a message object structure and producing a "
"serialized representation is the job of the generator classes."
msgstr ""
"最普通的一种任务是生成由消息对象结构体表示的电子邮件消息的扁平（序列化）版本。 如果你想通过 :meth:`smtplib.SMTP.sendmail`"
" 或 :mod:`nntplib` 模块来发送你的消息或是将消息打印到控制台就将需要这样做。 "
"接受一个消息对象结构体并生成其序列化表示就是这些生成器类的工作。"

#: ../../library/email.generator.rst:18
msgid ""
"As with the :mod:`email.parser` module, you aren't limited to the "
"functionality of the bundled generator; you could write one from scratch "
"yourself.  However the bundled generator knows how to generate most email in"
" a standards-compliant way, should handle MIME and non-MIME email messages "
"just fine, and is designed so that the bytes-oriented parsing and generation"
" operations are inverses, assuming the same non-transforming "
":mod:`~email.policy` is used for both.  That is, parsing the serialized byte"
" stream via the :class:`~email.parser.BytesParser` class and then "
"regenerating the serialized byte stream using :class:`BytesGenerator` should"
" produce output identical to the input [#]_.  (On the other hand, using the "
"generator on an :class:`~email.message.EmailMessage` constructed by program "
"may result in changes to the :class:`~email.message.EmailMessage` object as "
"defaults are filled in.)"
msgstr ""
"与 :mod:`email.parser` 模块一样，你并不会受限于已捆绑生成器的功能；你可以自己从头写一个。 "
"不过，已捆绑生成器知道如何以符合标准的方式来生成大多数电子邮件，应该能够很好地处理 MIME 和非 MIME "
"电子邮件消息，并且被设计为面向字节的解析和生成操作是互逆的，它假定两者都使用同样的非转换型 :mod:`~email.policy`。 也就是说，通过 "
":class:`~email.parser.BytesParser` 类来解析序列化字节流然后再使用 :class:`BytesGenerator` "
"来重新生成序列化字节流应当得到与输入相同的结果 [#]_。 （而另一方面，在由程序所构造的 "
":class:`~email.message.EmailMessage` 上使用生成器可能导致对默认填入的 "
":class:`~email.message.EmailMessage` 对象的改变。。）"

#: ../../library/email.generator.rst:32
msgid ""
"The :class:`Generator` class can be used to flatten a message into a text "
"(as opposed to binary) serialized representation, but since Unicode cannot "
"represent binary data directly, the message is of necessity transformed into"
" something that contains only ASCII characters, using the standard email RFC"
" Content Transfer Encoding techniques for encoding email messages for "
"transport over channels that are not \"8 bit clean\"."
msgstr ""
"可以使用 :class:`Generator` 类将消息扁平化为文本（而非二进制数据）的序列化表示形式，但是由于 Unicode "
"无法直接表示二进制数据，因此消息有必要被转换为仅包含 ASCII 字符的数据，这将使用标准电子邮件 RFC "
"内容传输编码格式技术来编码电子邮件消息以便通过非 “8 比特位兼容”的信道来传输。"

#: ../../library/email.generator.rst:39
msgid ""
"To accommodate reproducible processing of SMIME-signed messages "
":class:`Generator` disables header folding for message parts of type "
"``multipart/signed`` and all subparts."
msgstr ""
"为了适应 SMIME 签名消息的可重现处理过程，:class:`Generator` 禁用了针对 ``multipart/signed`` "
"类型的消息部分及所有子部分的标头折叠。"

#: ../../library/email.generator.rst:47
msgid ""
"Return a :class:`BytesGenerator` object that will write any message provided"
" to the :meth:`flatten` method, or any surrogateescape encoded text provided"
" to the :meth:`write` method, to the :term:`file-like object` *outfp*. "
"*outfp* must support a ``write`` method that accepts binary data."
msgstr ""
"返回一个 :class:`BytesGenerator` 对象，该对象将把提供给 :meth:`flatten` 方法的任何消息或者提供给 "
":meth:`write` 方法的任何经过代理转义编码的文本写入到 :term:`file-like object` *outfp*。 *outfp* "
"必须支持接受二进制数据的 ``write`` 方法。"

#: ../../library/email.generator.rst:52 ../../library/email.generator.rst:153
msgid ""
"If optional *mangle_from_* is ``True``, put a ``>`` character in front of "
"any line in the body that starts with the exact string ``\"From \"``, that "
"is ``From`` followed by a space at the beginning of a line.  *mangle_from_* "
"defaults to the value of the :attr:`~email.policy.Policy.mangle_from_` "
"setting of the *policy* (which is ``True`` for the "
":data:`~email.policy.compat32` policy and ``False`` for all others). "
"*mangle_from_* is intended for use when messages are stored in unix mbox "
"format (see :mod:`mailbox` and `WHY THE CONTENT-LENGTH FORMAT IS BAD "
"<https://www.jwz.org/doc/content-length.html>`_)."
msgstr ""
"如果可选的 *mangle_from_* 为 ``True``，则会将一个 ``>`` 字符放到恰好以字符串 ``\"From \"`` "
"打头，即开头文本为 ``From`` 加一个空格的的行前面。 *mangle_from_* 默认为 *policy* 的 "
":attr:`~email.policy.Policy.mangle_from_` 设置值 (对于 "
":data:`~email.policy.compat32` 策略为 ``True``，对于所有其他策略则为 ``False``)。 "
"*mangle_from_* 被设计为在当消息以 unix mbox 格式存储时使用 (参见 :mod:`mailbox` 和 `WHY THE "
"CONTENT-LENGTH FORMAT IS BAD <https://www.jwz.org/doc/content-"
"length.html>`_)。"

#: ../../library/email.generator.rst:62 ../../library/email.generator.rst:163
msgid ""
"If *maxheaderlen* is not ``None``, refold any header lines that are longer "
"than *maxheaderlen*, or if ``0``, do not rewrap any headers.  If "
"*manheaderlen* is ``None`` (the default), wrap headers and other message "
"lines according to the *policy* settings."
msgstr ""
"如果 *maxheaderlen* 不为 ``None``，则重新折叠任何长于 *maxheaderlen* 的标头行，或者如果为 "
"``0``，则不重新包装任何标头。 如果 *manheaderlen* 为 ``None`` (默认值)，则根据 *policy* "
"设置包装标头和其他消息行。"

#: ../../library/email.generator.rst:67 ../../library/email.generator.rst:168
msgid ""
"If *policy* is specified, use that policy to control message generation.  If"
" *policy* is ``None`` (the default), use the policy associated with the "
":class:`~email.message.Message` or :class:`~email.message.EmailMessage` "
"object passed to ``flatten`` to control the message generation.  See "
":mod:`email.policy` for details on what *policy* controls."
msgstr ""
"如果指定了 *policy*，则使用该策略来控制消息的生成。 如果 *policy* 为 ``None`` (默认值)，则使用与传递给 "
"``flatten`` 的 :class:`~email.message.Message` 或 "
":class:`~email.message.EmailMessage` 对象相关联的策略来控制消息的生成。 请参阅 "
":mod:`email.policy` 了解有关 *policy* 所控制内容的详情。"

#: ../../library/email.generator.rst:75 ../../library/email.generator.rst:174
msgid "Added the *policy* keyword."
msgstr "添加了*policy*关键字。"

#: ../../library/email.generator.rst:77 ../../library/email.generator.rst:176
msgid ""
"The default behavior of the *mangle_from_* and *maxheaderlen* parameters is "
"to follow the policy."
msgstr "*mangle_from_* 和 *maxheaderlen* 形参的默认行为是遵循策略。"

#: ../../library/email.generator.rst:83
msgid ""
"Print the textual representation of the message object structure rooted at "
"*msg* to the output file specified when the :class:`BytesGenerator` instance"
" was created."
msgstr "将将以 *msg* 为根的消息对象结构体的文本表示形式打印到创建 :class:`BytesGenerator` 实例时指定的输出文件。"

#: ../../library/email.generator.rst:87
msgid ""
"If the :mod:`~email.policy` option :attr:`~email.policy.Policy.cte_type` is "
"``8bit`` (the default), copy any headers in the original parsed message that"
" have not been modified to the output with any bytes with the high bit set "
"reproduced as in the original, and preserve the non-ASCII "
":mailheader:`Content-Transfer-Encoding` of any body parts that have them. If"
" ``cte_type`` is ``7bit``, convert the bytes with the high bit set as needed"
" using an ASCII-compatible :mailheader:`Content-Transfer-Encoding`. That is,"
" transform parts with non-ASCII :mailheader:`Content-Transfer-Encoding` "
"(:mailheader:`Content-Transfer-Encoding: 8bit`) to an ASCII compatible "
":mailheader:`Content-Transfer-Encoding`, and encode RFC-invalid non-ASCII "
"bytes in headers using the MIME ``unknown-8bit`` character set, thus "
"rendering them RFC-compliant."
msgstr ""
"如果 :mod:`~email.policy` 选项 :attr:`~email.policy.Policy.cte_type` 为 ``8bit`` "
"(默认值)，则会将未被修改的原始已解析消息中的任何标头拷贝到输出，其中会重新生成与原始数据相同的高比特位组字节数据，并保留具有它们的任何消息体部分的非 "
"ASCII :mailheader:`Content-Transfer-Encoding`。 如果 ``cte_type`` 为 "
"``7bit``，则会根据需要使用兼容 ASCII 的 :mailheader:`Content-Transfer-Encoding` "
"来转换高比特位组字节数据。 也就是说，将具有非 ASCII :mailheader:`Content-Transfer-Encoding` "
"(:mailheader:`Content-Transfer-Encoding: 8bit`) 的部分转换为兼容 ASCII 的 "
":mailheader:`Content-Transfer-Encoding`，并使用 MIME ``unknown-8bit`` "
"字符集来编码标头中不符合 RFC 的非 ASCII 字节数据，以使其符合 RFC。"

#: ../../library/email.generator.rst:104 ../../library/email.generator.rst:197
msgid ""
"If *unixfrom* is ``True``, print the envelope header delimiter used by the "
"Unix mailbox format (see :mod:`mailbox`) before the first of the :rfc:`5322`"
" headers of the root message object.  If the root object has no envelope "
"header, craft a standard one.  The default is ``False``. Note that for "
"subparts, no envelope header is ever printed."
msgstr ""
"如果 *unixfrom* 为 ``True``，则会在根消息对象的第一个 :rfc:`5322` 标头之前打印 Unix mailbox 格式 (参见"
" :mod:`mailbox`) 所使用的封包标头分隔符。 如果根对象没有封包标头，则会创建一个标准标头。 默认值为 ``False``。 "
"请注意对于子部分来说，不会打印任何封包标头。"

#: ../../library/email.generator.rst:110 ../../library/email.generator.rst:203
msgid ""
"If *linesep* is not ``None``, use it as the separator character between all "
"the lines of the flattened message.  If *linesep* is ``None`` (the default),"
" use the value specified in the *policy*."
msgstr ""
"如果 *linesep* 不为 ``None``，则会将其用作扁平化消息的所有行之间的分隔符。 如果 *linesep* 为 ``None`` "
"(默认值)，则使用在 *policy* 中指定的值。"

#: ../../library/email.generator.rst:119
msgid ""
"Return an independent clone of this :class:`BytesGenerator` instance with "
"the exact same option settings, and *fp* as the new *outfp*."
msgstr ""
"返回此Return an independent clone of this :class:`BytesGenerator` "
"实例的独立克隆，具有完全相同的选项设置，而 *fp* 为新的 *outfp*。"

#: ../../library/email.generator.rst:125
msgid ""
"Encode *s* using the ``ASCII`` codec and the ``surrogateescape`` error "
"handler, and pass it to the *write* method of the *outfp* passed to the "
":class:`BytesGenerator`'s constructor."
msgstr ""
"使用 ``ASCII`` 编解码器和 ``surrogateescape`` 错误处理程序编码 *s*，并将其传递给传入到 "
":class:`BytesGenerator` 的构造器的 *outfp* 的 *write* 方法 。"

#: ../../library/email.generator.rst:130
msgid ""
"As a convenience, :class:`~email.message.EmailMessage` provides the methods "
":meth:`~email.message.EmailMessage.as_bytes` and ``bytes(aMessage)`` (a.k.a."
" :meth:`~email.message.EmailMessage.__bytes__`), which simplify the "
"generation of a serialized binary representation of a message object.  For "
"more detail, see :mod:`email.message`."
msgstr ""
"作为一个便捷工具，:class:`~email.message.EmailMessage` 提供了 "
":meth:`~email.message.EmailMessage.as_bytes` 和 ``bytes(aMessage)`` (即 "
":meth:`~email.message.EmailMessage.__bytes__`) 等方法，它们简单地生成一个消息对象的序列化二进制表示形式。"
" 更多细节请参阅 :mod:`email.message`。"

#: ../../library/email.generator.rst:137
msgid ""
"Because strings cannot represent binary data, the :class:`Generator` class "
"must convert any binary data in any message it flattens to an ASCII "
"compatible format, by converting them to an ASCII compatible "
":mailheader:`Content-Transfer_Encoding`.  Using the terminology of the email"
" RFCs, you can think of this as :class:`Generator` serializing to an I/O "
"stream that is not \"8 bit clean\".  In other words, most applications will "
"want to be using :class:`BytesGenerator`, and not :class:`Generator`."
msgstr ""
"因为字符串无法表示二进制数据，:class:`Generator` 类必须将任何消息中扁平化的任何二进制数据转换为兼容 ASCII "
"的格式，具体将其转换为兼容 ASCII 的 :mailheader:`Content-Transfer_Encoding`。 使用电子邮件 RFC "
"的术语，你可以将其视作 :class:`Generator` 序列化为不 \"支持 8 比特\" 的 I/O 流。 换句话说，大部分应用程序将需要使用 "
":class:`BytesGenerator`，而非 :class:`Generator`。"

#: ../../library/email.generator.rst:148
msgid ""
"Return a :class:`Generator` object that will write any message provided to "
"the :meth:`flatten` method, or any text provided to the :meth:`write` "
"method, to the :term:`file-like object` *outfp*.  *outfp* must support a "
"``write`` method that accepts string data."
msgstr ""
"返回一个 :class:`Generator`，它将把提供给 :meth:`flatten` 方法的任何消息，或者提供给 :meth:`write` "
"方法的任何文本写入到 :term:`file-like object` *outfp*。 *outfp* 必须支持接受字符串数据的 ``write`` "
"方法。"

#: ../../library/email.generator.rst:182
msgid ""
"Print the textual representation of the message object structure rooted at "
"*msg* to the output file specified when the :class:`Generator` instance was "
"created."
msgstr "将以 *msg* 为根的消息对象结构体的文本表示形式打印到当 :class:`Generator` 实例被创建时所指定的输出文件。"

#: ../../library/email.generator.rst:186
msgid ""
"If the :mod:`~email.policy` option :attr:`~email.policy.Policy.cte_type` is "
"``8bit``, generate the message as if the option were set to ``7bit``. (This "
"is required because strings cannot represent non-ASCII bytes.) Convert any "
"bytes with the high bit set as needed using an ASCII-compatible "
":mailheader:`Content-Transfer-Encoding`.  That is, transform parts with non-"
"ASCII :mailheader:`Content-Transfer-Encoding` (:mailheader:`Content-"
"Transfer-Encoding: 8bit`) to an ASCII compatible :mailheader:`Content-"
"Transfer-Encoding`, and encode RFC-invalid non-ASCII bytes in headers using "
"the MIME ``unknown-8bit`` character set, thus rendering them RFC-compliant."
msgstr ""
"如果 :mod:`~email.policy` 选项 :attr:`~email.policy.Policy.cte_type` 为 "
"``8bit``，则视同选项被设为 ``7bit`` 来生成消息。 （这是必需的，因为字符串无法表示非 ASCII 字节数据。） 将使用兼容 ASCII"
" 的 :mailheader:`Content-Transfer-Encoding` 按需转换任何具有高比特位组的字节数据。 也就是说，将具有非 "
"ASCII :mailheader:`Content-Transfer-Encoding` (:mailheader:`Content-"
"Transfer-Encoding: 8bit`) 的部分转换为兼容 ASCII 的 :mailheader:`Content-Transfer-"
"Encoding`，并使用 MIME ``unknown-8bit`` 字符集来编码标头中不符合 RFC 的非 ASCII 字节数据，以使其符合 "
"RFC。"

#: ../../library/email.generator.rst:209
msgid ""
"Added support for re-encoding ``8bit`` message bodies, and the *linesep* "
"argument."
msgstr "添加了对重编码 ``8bit`` 消息体的支持，以及 *linesep* 参数。"

#: ../../library/email.generator.rst:216
msgid ""
"Return an independent clone of this :class:`Generator` instance with the "
"exact same options, and *fp* as the new *outfp*."
msgstr "返回此 :class:`Generator` 实例的独立克隆，具有完全相同的选项设置，而 *fp* 为新的 *outfp*。"

#: ../../library/email.generator.rst:222
msgid ""
"Write *s* to the *write* method of the *outfp* passed to the "
":class:`Generator`'s constructor.  This provides just enough file-like API "
"for :class:`Generator` instances to be used in the :func:`print` function."
msgstr ""
"将 *s* 写入到传给 :class:`Generator` 的构造器的 *outfp* 的 *write* 方法。 这足够为 "
":class:`Generator` 实际提供可用于 :func:`print` 函数的文件类 API。"

#: ../../library/email.generator.rst:228
msgid ""
"As a convenience, :class:`~email.message.EmailMessage` provides the methods "
":meth:`~email.message.EmailMessage.as_string` and ``str(aMessage)`` (a.k.a. "
":meth:`~email.message.EmailMessage.__str__`), which simplify the generation "
"of a formatted string representation of a message object.  For more detail, "
"see :mod:`email.message`."
msgstr ""
"作为一个便捷工具，:class:`~email.message.EmailMessage` 提供了 "
":meth:`~email.message.EmailMessage.as_string` 和 ``str(aMessage)`` (即 "
":meth:`~email.message.EmailMessage.__str__`) 等方法，它们简单地生成一个消息对象的已格式化字符串表示形式。 "
"更多细节请参阅 :mod:`email.message`。"

#: ../../library/email.generator.rst:235
msgid ""
"The :mod:`email.generator` module also provides a derived class, "
":class:`DecodedGenerator`, which is like the :class:`Generator` base class, "
"except that non-\\ :mimetype:`text` parts are not serialized, but are "
"instead represented in the output stream by a string derived from a template"
" filled in with information about the part."
msgstr ""
":mod:`email.generator` 模块还提供了一个派生类 :class:`DecodedGenerator`，它类似于 "
":class:`Generator` 基类，不同之处在于非 :mimetype:`text` 部分不会被序列化，而是被表示为 "
"基于模板并填写了有关该部分的信息的字符串输出流的形式。"

#: ../../library/email.generator.rst:244
msgid ""
"Act like :class:`Generator`, except that for any subpart of the message "
"passed to :meth:`Generator.flatten`, if the subpart is of main type "
":mimetype:`text`, print the decoded payload of the subpart, and if the main "
"type is not :mimetype:`text`, instead of printing it fill in the string "
"*fmt* using information from the part and print the resulting filled-in "
"string."
msgstr ""
"行为类似于 :class:`Generator`，不同之处在于对传给 :meth:`Generator.flatten` "
"的消息的任何子部分，如果该子部分的主类型为 :mimetype:`text`，则打印该子部分的已解码载荷，而如果其主类型不为 "
":mimetype:`text`，则不直接打印它而是使用来自该部分的信息填入字符串 *fmt* 并将填写完成的字符串打印出来。"

#: ../../library/email.generator.rst:251
msgid ""
"To fill in *fmt*, execute ``fmt % part_info``, where ``part_info`` is a "
"dictionary composed of the following keys and values:"
msgstr "要填入 *fmt*，则执行 ``fmt % part_info``，其中 ``part_info`` 是由下列键和值组成的字典:"

#: ../../library/email.generator.rst:254
msgid "``type`` -- Full MIME type of the non-\\ :mimetype:`text` part"
msgstr "``type`` -- 非 :mimetype:`text` 部分的完整 MIME 类型"

#: ../../library/email.generator.rst:256
msgid "``maintype`` -- Main MIME type of the non-\\ :mimetype:`text` part"
msgstr "``maintype`` -- 非 :mimetype:`text` 部分的主 MIME 类型"

#: ../../library/email.generator.rst:258
msgid "``subtype`` -- Sub-MIME type of the non-\\ :mimetype:`text` part"
msgstr "``subtype`` -- 非 :mimetype:`text` 部分的子 MIME 类型"

#: ../../library/email.generator.rst:260
msgid "``filename`` -- Filename of the non-\\ :mimetype:`text` part"
msgstr "``filename`` -- 非 :mimetype:`text` 部分的文件名"

#: ../../library/email.generator.rst:262
msgid ""
"``description`` -- Description associated with the non-\\ :mimetype:`text` "
"part"
msgstr "``description`` -- 与非 :mimetype:`text` 部分相关联的描述"

#: ../../library/email.generator.rst:264
msgid ""
"``encoding`` -- Content transfer encoding of the non-\\ :mimetype:`text` "
"part"
msgstr "``encoding`` -- 非 :mimetype:`text` 部分的内容转换编码格式"

#: ../../library/email.generator.rst:266
msgid "If *fmt* is ``None``, use the following default *fmt*:"
msgstr "如果 *fmt* 为 ``None``，则使用下列默认 *fmt*:"

#: ../../library/email.generator.rst:268
msgid "\"[Non-text (%(type)s) part of message omitted, filename %(filename)s]\""
msgstr "\"[忽略消息的非文本 (%(type)s) 部分，文件名 %(filename)s]\""

#: ../../library/email.generator.rst:270
msgid ""
"Optional *_mangle_from_* and *maxheaderlen* are as with the "
":class:`Generator` base class."
msgstr "可选的 *_mangle_from_* 和 *maxheaderlen* 与 :class:`Generator` 基类的相同。"

#: ../../library/email.generator.rst:275
msgid "Footnotes"
msgstr "备注"

#: ../../library/email.generator.rst:276
msgid ""
"This statement assumes that you use the appropriate setting for "
"``unixfrom``, and that there are no :mod:`policy` settings calling for "
"automatic adjustments (for example, "
":attr:`~email.policy.Policy.refold_source` must be ``none``, which is *not* "
"the default).  It is also not 100% true, since if the message does not "
"conform to the RFC standards occasionally information about the exact "
"original text is lost during parsing error recovery.  It is a goal to fix "
"these latter edge cases when possible."
msgstr ""
"此语句假定你使用了正确的 ``unixfrom`` 设置，并且没有用于自动调整的 :mod:`policy` 设置调用（例如 "
":attr:`~email.policy.Policy.refold_source` 必须为 ``none``，这 *不是* 默认值）。 这也不是 "
"100% 为真，因为如果消息不遵循 RFC 标准则有时实际原始文本的信息会在解析错误恢复时丢失。 它的目标是在可能的情况下修复这些后续边缘情况。"
