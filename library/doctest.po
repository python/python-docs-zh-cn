# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/doctest.rst:2
msgid ":mod:`!doctest` --- Test interactive Python examples"
msgstr ":mod:`!doctest` --- 测试交互式的 Python 示例"

#: ../../library/doctest.rst:12
msgid "**Source code:** :source:`Lib/doctest.py`"
msgstr "**源代码：** :source:`Lib/doctest.py`"

#: ../../library/doctest.rst:16
msgid ""
"The :mod:`doctest` module searches for pieces of text that look like "
"interactive Python sessions, and then executes those sessions to verify that"
" they work exactly as shown.  There are several common ways to use doctest:"
msgstr ""
":mod:`doctest` "
"模块寻找像Python交互式代码的文本，然后执行这些代码来确保它们的确就像展示的那样正确运行，有许多方法来使用doctest："

#: ../../library/doctest.rst:20
msgid ""
"To check that a module's docstrings are up-to-date by verifying that all "
"interactive examples still work as documented."
msgstr "通过验证所有交互式示例仍然按照记录的方式工作，以此来检查模块的文档字符串是否是最新的。"

#: ../../library/doctest.rst:23
msgid ""
"To perform regression testing by verifying that interactive examples from a "
"test file or a test object work as expected."
msgstr "通过验证来自一个测试文件或一个测试对象的交互式示例按预期工作，来进行回归测试。"

#: ../../library/doctest.rst:26
msgid ""
"To write tutorial documentation for a package, liberally illustrated with "
"input-output examples.  Depending on whether the examples or the expository "
"text are emphasized, this has the flavor of \"literate testing\" or "
"\"executable documentation\"."
msgstr "为一个包写指导性的文档，用输入输出的例子来说明。 取决于是强调例子还是说明性的文字，这有一种 \"文本测试 \"或 \"可执行文档 \"的风格。"

#: ../../library/doctest.rst:31
msgid "Here's a complete but small example module::"
msgstr "下面是一个小却完整的示例模块::"

#: ../../library/doctest.rst:33
msgid ""
"\"\"\"\n"
"This is the \"example\" module.\n"
"\n"
"The example module supplies one function, factorial().  For example,\n"
"\n"
">>> factorial(5)\n"
"120\n"
"\"\"\"\n"
"\n"
"def factorial(n):\n"
"    \"\"\"Return the factorial of n, an exact integer >= 0.\n"
"\n"
"    >>> [factorial(n) for n in range(6)]\n"
"    [1, 1, 2, 6, 24, 120]\n"
"    >>> factorial(30)\n"
"    265252859812191058636308480000000\n"
"    >>> factorial(-1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be >= 0\n"
"\n"
"    Factorials of floats are OK, but the float must be an exact integer:\n"
"    >>> factorial(30.1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be exact integer\n"
"    >>> factorial(30.0)\n"
"    265252859812191058636308480000000\n"
"\n"
"    It must also not be ridiculously large:\n"
"    >>> factorial(1e100)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"    \"\"\"\n"
"\n"
"    import math\n"
"    if not n >= 0:\n"
"        raise ValueError(\"n must be >= 0\")\n"
"    if math.floor(n) != n:\n"
"        raise ValueError(\"n must be exact integer\")\n"
"    if n+1 == n:  # catch a value like 1e300\n"
"        raise OverflowError(\"n too large\")\n"
"    result = 1\n"
"    factor = 2\n"
"    while factor <= n:\n"
"        result *= factor\n"
"        factor += 1\n"
"    return result\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"
msgstr ""
"\"\"\"\n"
"This is the \"example\" module.\n"
"\n"
"The example module supplies one function, factorial().  For example,\n"
"\n"
">>> factorial(5)\n"
"120\n"
"\"\"\"\n"
"\n"
"def factorial(n):\n"
"    \"\"\"Return the factorial of n, an exact integer >= 0.\n"
"\n"
"    >>> [factorial(n) for n in range(6)]\n"
"    [1, 1, 2, 6, 24, 120]\n"
"    >>> factorial(30)\n"
"    265252859812191058636308480000000\n"
"    >>> factorial(-1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be >= 0\n"
"\n"
"    Factorials of floats are OK, but the float must be an exact integer:\n"
"    >>> factorial(30.1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be exact integer\n"
"    >>> factorial(30.0)\n"
"    265252859812191058636308480000000\n"
"\n"
"    It must also not be ridiculously large:\n"
"    >>> factorial(1e100)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"    \"\"\"\n"
"\n"
"    import math\n"
"    if not n >= 0:\n"
"        raise ValueError(\"n must be >= 0\")\n"
"    if math.floor(n) != n:\n"
"        raise ValueError(\"n must be exact integer\")\n"
"    if n+1 == n:  # 捕获像 1e300 这样的值\n"
"        raise OverflowError(\"n too large\")\n"
"    result = 1\n"
"    factor = 2\n"
"    while factor <= n:\n"
"        result *= factor\n"
"        factor += 1\n"
"    return result\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"

#: ../../library/doctest.rst:88
msgid ""
"If you run :file:`example.py` directly from the command line, :mod:`doctest`"
" works its magic:"
msgstr "如果你直接在命令行里运行 :file:`example.py` ， :mod:`doctest` 将发挥它的作用。"

#: ../../library/doctest.rst:91
msgid ""
"$ python example.py\n"
"$"
msgstr ""
"$ python example.py\n"
"$"

#: ../../library/doctest.rst:96
msgid ""
"There's no output!  That's normal, and it means all the examples worked.  "
"Pass ``-v`` to the script, and :mod:`doctest` prints a detailed log of what "
"it's trying, and prints a summary at the end:"
msgstr ""
"没有输出！ 这很正常，这意味着所有的例子都成功了。 把 ``-v`` 传给脚本，:mod:`doctest` "
"会打印出它所尝试的详细日志，并在最后打印出一个总结。"

#: ../../library/doctest.rst:100
msgid ""
"$ python example.py -v\n"
"Trying:\n"
"    factorial(5)\n"
"Expecting:\n"
"    120\n"
"ok\n"
"Trying:\n"
"    [factorial(n) for n in range(6)]\n"
"Expecting:\n"
"    [1, 1, 2, 6, 24, 120]\n"
"ok"
msgstr ""
"$ python example.py -v\n"
"Trying:\n"
"    factorial(5)\n"
"Expecting:\n"
"    120\n"
"ok\n"
"Trying:\n"
"    [factorial(n) for n in range(6)]\n"
"Expecting:\n"
"    [1, 1, 2, 6, 24, 120]\n"
"ok"

#: ../../library/doctest.rst:114
msgid "And so on, eventually ending with:"
msgstr "以此类推，最终以："

#: ../../library/doctest.rst:116
msgid ""
"Trying:\n"
"    factorial(1e100)\n"
"Expecting:\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"ok\n"
"2 items passed all tests:\n"
"   1 test in __main__\n"
"   6 tests in __main__.factorial\n"
"7 tests in 2 items.\n"
"7 passed.\n"
"Test passed.\n"
"$"
msgstr ""
"Trying:\n"
"    factorial(1e100)\n"
"Expecting:\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"ok\n"
"2 items passed all tests:\n"
"   1 test in __main__\n"
"   6 tests in __main__.factorial\n"
"7 tests in 2 items.\n"
"7 passed.\n"
"Test passed.\n"
"$"

#: ../../library/doctest.rst:133
msgid ""
"That's all you need to know to start making productive use of "
":mod:`doctest`! Jump in.  The following sections provide full details.  Note"
" that there are many examples of doctests in the standard Python test suite "
"and libraries. Especially useful examples can be found in the standard test "
"file :file:`Lib/test/test_doctest/test_doctest.py`."
msgstr ""
"这就是关于高效使用 :mod:`doctest` 你所需要知道的一切！ 开始上手吧。 下面的小节提供了完整细节。 请注意在标准 Python "
"测试套件和库中有许多 doctest 的例子。 特别有用的例子可以在标准测试文件 "
":file:`Lib/test/test_doctest/test_doctest.py` 中找到。"

#: ../../library/doctest.rst:143
msgid "Simple Usage: Checking Examples in Docstrings"
msgstr "简单用法：检查Docstrings中的示例"

#: ../../library/doctest.rst:145
msgid ""
"The simplest way to start using doctest (but not necessarily the way you'll "
"continue to do it) is to end each module :mod:`!M` with::"
msgstr "开始使用 doctest 的最简单方式（但不一定是你今后沿用的方式）是这样结束每个模块 :mod:`!M`::"

#: ../../library/doctest.rst:148
msgid ""
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"

#: ../../library/doctest.rst:152
msgid ":mod:`!doctest` then examines docstrings in module :mod:`!M`."
msgstr ":mod:`!doctest` 会随后检查模块 :mod:`!M` 中的文档字符串。"

#: ../../library/doctest.rst:154
msgid ""
"Running the module as a script causes the examples in the docstrings to get "
"executed and verified::"
msgstr "以脚本形式运行该模块会使文档中的例子得到执行和验证::"

#: ../../library/doctest.rst:157
msgid "python M.py"
msgstr "python M.py"

#: ../../library/doctest.rst:159
msgid ""
"This won't display anything unless an example fails, in which case the "
"failing example(s) and the cause(s) of the failure(s) are printed to stdout,"
" and the final line of output is ``***Test Failed*** N failures.``, where "
"*N* is the number of examples that failed."
msgstr ""
"这不会显示任何东西，除非一个例子失败了，在这种情况下，失败的例子和失败的原因会被打印到stdout，最后一行的输出是 ``***Test "
"Failed*** N failures.``，其中 *N* 是失败的例子的数量。"

#: ../../library/doctest.rst:164
msgid "Run it with the ``-v`` switch instead::"
msgstr "用 ``-v`` 来运行它来切换，而不是::"

#: ../../library/doctest.rst:166
msgid "python M.py -v"
msgstr "python M.py -v"

#: ../../library/doctest.rst:168
msgid ""
"and a detailed report of all examples tried is printed to standard output, "
"along with assorted summaries at the end."
msgstr "并将所有尝试过的例子的详细报告打印到标准输出，最后还有各种总结。"

#: ../../library/doctest.rst:171
msgid ""
"You can force verbose mode by passing ``verbose=True`` to :func:`testmod`, "
"or prohibit it by passing ``verbose=False``.  In either of those cases, "
":data:`sys.argv` is not examined by :func:`testmod` (so passing ``-v`` or "
"not has no effect)."
msgstr ""
"你可以通过将 ``verbose=True`` 传给 :func:`testmod` 来强制应用详细模式，或者通过传入 "
"``verbose=False`` 来禁止它。 在这两种情况下，:data:`sys.argv` 都不会被 :func:`testmod` "
"检查（所以是否传递 ``-v`` 都不会有影响）。"

#: ../../library/doctest.rst:176
msgid ""
"There is also a command line shortcut for running :func:`testmod`, see "
"section :ref:`doctest-cli`."
msgstr "另外还有一个运行 :func:`testmod` 的命令行快捷方式，参见 :ref:`doctest-cli` 一节。"

#: ../../library/doctest.rst:179
msgid ""
"For more information on :func:`testmod`, see section :ref:`doctest-basic-"
"api`."
msgstr "关于 :func:`testmod` 的更多信息，请参见 :ref:`doctest-basic-api` 部分。"

#: ../../library/doctest.rst:185
msgid "Simple Usage: Checking Examples in a Text File"
msgstr "简单的用法：检查文本文件中的例子"

#: ../../library/doctest.rst:187
msgid ""
"Another simple application of doctest is testing interactive examples in a "
"text file.  This can be done with the :func:`testfile` function::"
msgstr "doctest 的另一个简单应用是测试文本文件中的交互式例子。 这可以用 :func:`testfile` 函数来完成::"

#: ../../library/doctest.rst:190
msgid ""
"import doctest\n"
"doctest.testfile(\"example.txt\")"
msgstr ""
"import doctest\n"
"doctest.testfile(\"example.txt\")"

#: ../../library/doctest.rst:193
msgid ""
"That short script executes and verifies any interactive Python examples "
"contained in the file :file:`example.txt`.  The file content is treated as "
"if it were a single giant docstring; the file doesn't need to contain a "
"Python program!   For example, perhaps :file:`example.txt` contains this:"
msgstr ""
"这个简短的脚本执行并验证文件 :file:`example.txt` 中包含的任何交互式 Python "
"示例。该文件的内容被当作一个巨大的文档串来处理；该文件不需要包含一个Python程序！例如，也许 :file:`example.txt` 包含以下内容:"

#: ../../library/doctest.rst:198
msgid ""
"The ``example`` module\n"
"======================\n"
"\n"
"Using ``factorial``\n"
"-------------------\n"
"\n"
"This is an example text file in reStructuredText format.  First import\n"
"``factorial`` from the ``example`` module:\n"
"\n"
"    >>> from example import factorial\n"
"\n"
"Now use it:\n"
"\n"
"    >>> factorial(6)\n"
"    120"
msgstr ""
"The ``example`` module\n"
"======================\n"
"\n"
"Using ``factorial``\n"
"-------------------\n"
"\n"
"This is an example text file in reStructuredText format.  First import\n"
"``factorial`` from the ``example`` module:\n"
"\n"
"    >>> from example import factorial\n"
"\n"
"Now use it:\n"
"\n"
"    >>> factorial(6)\n"
"    120"

#: ../../library/doctest.rst:216
msgid ""
"Running ``doctest.testfile(\"example.txt\")`` then finds the error in this "
"documentation::"
msgstr "运行 ``doctest.testfile(\"example.txt\")``，然后发现这个文档中的错误::"

#: ../../library/doctest.rst:219
msgid ""
"File \"./example.txt\", line 14, in example.txt\n"
"Failed example:\n"
"    factorial(6)\n"
"Expected:\n"
"    120\n"
"Got:\n"
"    720"
msgstr ""
"File \"./example.txt\", line 14, in example.txt\n"
"Failed example:\n"
"    factorial(6)\n"
"Expected:\n"
"    120\n"
"Got:\n"
"    720"

#: ../../library/doctest.rst:227
msgid ""
"As with :func:`testmod`, :func:`testfile` won't display anything unless an "
"example fails.  If an example does fail, then the failing example(s) and the"
" cause(s) of the failure(s) are printed to stdout, using the same format as "
":func:`!testmod`."
msgstr ""
"与 :func:`testmod` 一样，:func:`testfile` 不会显示任何东西除非一个例子失败。 "
"如果一个例子确实失败了，那么失败的例子和失败的原因将被打印到标准输出，使用的格式与 :func:`!testmod` 相同。"

#: ../../library/doctest.rst:232
msgid ""
"By default, :func:`testfile` looks for files in the calling module's "
"directory. See section :ref:`doctest-basic-api` for a description of the "
"optional arguments that can be used to tell it to look for files in other "
"locations."
msgstr ""
"默认情况下，:func:`testfile` 在调用模块的目录中寻找文件。参见章节 :ref:`doctest-basic-"
"api`，了解可用于告诉它在其他位置寻找文件的可选参数的描述。"

#: ../../library/doctest.rst:236
msgid ""
"Like :func:`testmod`, :func:`testfile`'s verbosity can be set with the "
"``-v`` command-line switch or with the optional keyword argument *verbose*."
msgstr ""
"像 :func:`testmod` 一样，:func:`testfile` 的详细程度可以通过命令行 ``-v`` 切换或可选的关键字参数 "
"*verbose* 来设置。"

#: ../../library/doctest.rst:240
msgid ""
"There is also a command line shortcut for running :func:`testfile`, see "
"section :ref:`doctest-cli`."
msgstr "另外还有一个运行 :func:`testfile` 的命令行快捷方式，参见 :ref:`doctest-cli` 一节。"

#: ../../library/doctest.rst:243
msgid ""
"For more information on :func:`testfile`, see section :ref:`doctest-basic-"
"api`."
msgstr "关于 :func:`testfile` 的更多信息，请参见 :ref:`doctest-basic-api` 一节。"

#: ../../library/doctest.rst:249
msgid "Command-line Usage"
msgstr "命令行用法"

#: ../../library/doctest.rst:251
msgid ""
"The :mod:`doctest` module can be invoked as a script from the command line:"
msgstr ":mod:`doctest` 模块可以在命令行下作为一个脚本来唤起："

#: ../../library/doctest.rst:253
msgid "python -m doctest [-v] [-o OPTION] [-f] file [file ...]"
msgstr "python -m doctest [-v] [-o OPTION] [-f] file [file ...]"

#: ../../library/doctest.rst:261
msgid ""
"Detailed report of all examples tried is printed to standard output, along "
"with assorted summaries at the end::"
msgstr "所有尝试过的例子的详细报告将被打印到标准输出，最后还会带上各种总结::"

#: ../../library/doctest.rst:264
msgid "python -m doctest -v example.py"
msgstr "python -m doctest -v example.py"

#: ../../library/doctest.rst:266
msgid ""
"This will import :file:`example.py` as a standalone module and run "
":func:`testmod` on it. Note that this may not work correctly if the file is "
"part of a package and imports other submodules from that package."
msgstr ""
"这会将 :file:`example.py` 作为独立模块导入并对其运行 :func:`testmod`。 "
"请注意如果文件是某个包的一部分并且从那个包导入了其他子模块则此命令可能无法正确工作。"

#: ../../library/doctest.rst:270
msgid ""
"If the file name does not end with :file:`.py`, :mod:`!doctest` infers that "
"it must be run with :func:`testfile` instead::"
msgstr ""
"如果文件名不是以 :file:`.py` 结尾，:mod:`!doctest` 将推断它必须改用 :func:`testfile` 来运行::"

#: ../../library/doctest.rst:273
msgid "python -m doctest -v example.txt"
msgstr "python -m doctest -v example.txt"

#: ../../library/doctest.rst:277
msgid ""
"Option flags control various aspects of doctest's behavior, see section "
":ref:`doctest-options`."
msgstr "控制 doctest 行为的各种不同方面，参见 :ref:`doctest-options` 一节。"

#: ../../library/doctest.rst:284
msgid "This is shorthand for ``-o FAIL_FAST``."
msgstr "这是 ``-o FAIL_FAST`` 的简写形式。"

#: ../../library/doctest.rst:292
msgid "How It Works"
msgstr "它是如何工作的"

#: ../../library/doctest.rst:294
msgid ""
"This section examines in detail how doctest works: which docstrings it looks"
" at, how it finds interactive examples, what execution context it uses, how "
"it handles exceptions, and how option flags can be used to control its "
"behavior. This is the information that you need to know to write doctest "
"examples; for information about actually running doctest on these examples, "
"see the following sections."
msgstr ""
"这一节详细研究了doctest的工作原理：它查看哪些文档串，它如何找到交互式的用例，它使用什么执行环境，它如何处理异常，以及如何用选项标志来控制其行为。这是你写doctest例子所需要知道的信息；关于在这些例子上实际运行doctest的信息，请看下面的章节。"

#: ../../library/doctest.rst:305
msgid "Which Docstrings Are Examined?"
msgstr "哪些文件串被检查了？"

#: ../../library/doctest.rst:307
msgid ""
"The module docstring, and all function, class and method docstrings are "
"searched.  Objects imported into the module are not searched."
msgstr "模块的文档串以及所有函数、类和方法的文档串都将被搜索。 导入模块的对象不被搜索。"

#: ../../library/doctest.rst:317
msgid ""
"In addition, there are cases when you want tests to be part of a module but "
"not part of the help text, which requires that the tests not be included in "
"the docstring. Doctest looks for a module-level variable called ``__test__``"
" and uses it to locate other tests. If ``M.__test__`` exists, it must be a "
"dict, and each entry maps a (string) name to a function object, class "
"object, or string. Function and class object docstrings found from "
"``M.__test__`` are searched, and strings are treated as if they were "
"docstrings.  In output, a key ``K`` in ``M.__test__`` appears with name "
"``M.__test__.K``."
msgstr ""
"此外，有时你会希望测试成为模块的一部分但不是帮助文本的一部分，这就要求测试不包括在文档字符串中。 在此情况下 doctest 会查找一个名为 "
"``__test__`` 的模块级变量并用它来定位其他测试。 如果 ``M.__test__`` "
"存在，则它必须是一个字典，其中每个条目都是将（字符串）名称映射到函数对象、类对象或字符串。 从 ``M.__test__`` "
"找到的函数和类对象的文档字符串将会被搜索，字符串会被当作文档字符串来处理。 在输出中，``M.__test__`` 中的键 ``K`` 将作为名称 "
"``M.__test__.K`` 出现。"

#: ../../library/doctest.rst:326
msgid ""
"For example, place this block of code at the top of :file:`example.py`:"
msgstr "例如，将这段代码放在 :file:`example.py` 的开头:"

#: ../../library/doctest.rst:328
msgid ""
"__test__ = {\n"
"    'numbers': \"\"\"\n"
">>> factorial(6)\n"
"720\n"
"\n"
">>> [factorial(n) for n in range(6)]\n"
"[1, 1, 2, 6, 24, 120]\n"
"\"\"\"\n"
"}"
msgstr ""
"__test__ = {\n"
"    'numbers': \"\"\"\n"
">>> factorial(6)\n"
"720\n"
"\n"
">>> [factorial(n) for n in range(6)]\n"
"[1, 1, 2, 6, 24, 120]\n"
"\"\"\"\n"
"}"

#: ../../library/doctest.rst:340
msgid ""
"The value of ``example.__test__[\"numbers\"]`` will be treated as a "
"docstring and all the tests inside it will be run. It is important to note "
"that the value can be mapped to a function, class object, or module; if so, "
":mod:`!doctest` searches them recursively for docstrings, which are then "
"scanned for tests."
msgstr ""
"``example.__test__[\"numbers\"]`` 的值将被视为一个文档字符串并且其中的所有测试将被运行。 "
"重要的注意事项是该值可以被映射到一个函数、类对象或模块；如果是这样的话，:mod:`!doctest` "
"会递归地搜索它们的文档字符串，然后扫描其中的测试。"

#: ../../library/doctest.rst:346
msgid ""
"Any classes found are recursively searched similarly, to test docstrings in "
"their contained methods and nested classes."
msgstr "任何发现的类都会以类似的方式进行递归搜索，以测试其包含的方法和嵌套类中的文档串。"

#: ../../library/doctest.rst:353
msgid "How are Docstring Examples Recognized?"
msgstr "文档串的例子是如何被识别的？"

#: ../../library/doctest.rst:355
msgid ""
"In most cases a copy-and-paste of an interactive console session works fine,"
" but doctest isn't trying to do an exact emulation of any specific Python "
"shell."
msgstr ""
"在大多数情况下，对交互式控制台会话的复制和粘贴功能工作得很好，但是 doctest 并不试图对任何特定的 Python shell 进行精确的模拟。"

#: ../../library/doctest.rst:360
msgid ""
">>> # comments are ignored\n"
">>> x = 12\n"
">>> x\n"
"12\n"
">>> if x == 13:\n"
"...     print(\"yes\")\n"
"... else:\n"
"...     print(\"no\")\n"
"...     print(\"NO\")\n"
"...     print(\"NO!!!\")\n"
"...\n"
"no\n"
"NO\n"
"NO!!!\n"
">>>"
msgstr ""
">>> # 注释将被忽略\n"
">>> x = 12\n"
">>> x\n"
"12\n"
">>> if x == 13:\n"
"...     print(\"yes\")\n"
"... else:\n"
"...     print(\"no\")\n"
"...     print(\"NO\")\n"
"...     print(\"NO!!!\")\n"
"...\n"
"no\n"
"NO\n"
"NO!!!\n"
">>>"

#: ../../library/doctest.rst:380
msgid ""
"Any expected output must immediately follow the final ``'>>> '`` or ``'... "
"'`` line containing the code, and the expected output (if any) extends to "
"the next ``'>>> '`` or all-whitespace line."
msgstr ""
"任何预期的输出必须紧随包含代码的最后 ``'>>> '`` 或 ``'... '`` 行，预期的输出（如果有的话）延伸到下一 ``'>>> '`` "
"行或全空白行。"

#: ../../library/doctest.rst:384
msgid "The fine print:"
msgstr "fine输出："

#: ../../library/doctest.rst:386
msgid ""
"Expected output cannot contain an all-whitespace line, since such a line is "
"taken to signal the end of expected output.  If expected output does contain"
" a blank line, put ``<BLANKLINE>`` in your doctest example each place a "
"blank line is expected."
msgstr ""
"预期输出不能包含一个全白的行，因为这样的行被认为是预期输出的结束信号。 如果预期的输出包含一个空行，在你的测试例子中，在每一个预期有空行的地方加上 "
"``<BLANKLINE>``。"

#: ../../library/doctest.rst:391
msgid ""
"All hard tab characters are expanded to spaces, using 8-column tab stops. "
"Tabs in output generated by the tested code are not modified.  Because any "
"hard tabs in the sample output *are* expanded, this means that if the code "
"output includes hard tabs, the only way the doctest can pass is if the "
":const:`NORMALIZE_WHITESPACE` option or :ref:`directive <doctest-"
"directives>` is in effect. Alternatively, the test can be rewritten to "
"capture the output and compare it to an expected value as part of the test."
"  This handling of tabs in the source was arrived at through trial and "
"error, and has proven to be the least error prone way of handling them.  It "
"is possible to use a different algorithm for handling tabs by writing a "
"custom :class:`DocTestParser` class."
msgstr ""
"所有硬制表符都被扩展为空格，使用 8 列的制表符。由测试代码生成的输出中的制表符不会被修改。 "
"因为样本输出中的任何硬制表符都会被扩展，这意味着如果代码输出包括硬制表符，文档测试通过的唯一方法是 "
":const:`NORMALIZE_WHITESPACE` 选项或者 :ref:`指令 <doctest-directives>` 是有效的。 "
"另外，测试可以被重写，以捕获输出并将其与预期值进行比较，作为测试的一部分。这种对源码中标签的处理是通过试错得出的，并被证明是最不容易出错的处理方式。通过编写一个自定义的"
" :class:`DocTestParser` 类，可以使用一个不同的算法来处理标签。"

#: ../../library/doctest.rst:403
msgid ""
"Output to stdout is captured, but not output to stderr (exception tracebacks"
" are captured via a different means)."
msgstr "向stdout的输出被捕获，但不向stderr输出（异常回溯通过不同的方式被捕获）。"

#: ../../library/doctest.rst:406
msgid ""
"If you continue a line via backslashing in an interactive session, or for "
"any other reason use a backslash, you should use a raw docstring, which will"
" preserve your backslashes exactly as you type them::"
msgstr "如果你在交互式会话中通过反斜线续行，或出于任何其他原因使用反斜线，你应该使用原始文件串，它将完全保留你输入的反斜线::"

#: ../../library/doctest.rst:410
msgid ""
">>> def f(x):\n"
"...     r'''Backslashes in a raw docstring: m\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"
msgstr ""
">>> def f(x):\n"
"...     r'''Backslashes in a raw docstring: m\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"

#: ../../library/doctest.rst:416
msgid ""
"Otherwise, the backslash will be interpreted as part of the string. For "
"example, the ``\\n`` above would be interpreted as a newline character.  "
"Alternatively, you can double each backslash in the doctest version (and not"
" use a raw string)::"
msgstr ""
"否则，反斜杠将被解释为字符串的一部分。例如，上面的 ``\\n`` 会被解释为一个换行符。 "
"另外，你可以在doctest版本中把每个反斜杠加倍（而不使用原始字符串）::"

#: ../../library/doctest.rst:420
msgid ""
">>> def f(x):\n"
"...     '''Backslashes in a raw docstring: m\\\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"
msgstr ""
">>> def f(x):\n"
"...     '''Backslashes in a raw docstring: m\\\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"

#: ../../library/doctest.rst:426
msgid "The starting column doesn't matter::"
msgstr "起始列并不重要::"

#: ../../library/doctest.rst:428
msgid ""
">>> assert \"Easy!\"\n"
"      >>> import math\n"
"          >>> math.floor(1.9)\n"
"          1"
msgstr ""
">>> assert \"Easy!\"\n"
"      >>> import math\n"
"          >>> math.floor(1.9)\n"
"          1"

#: ../../library/doctest.rst:433
msgid ""
"and as many leading whitespace characters are stripped from the expected "
"output as appeared in the initial ``'>>> '`` line that started the example."
msgstr "并从预期的输出中剥离出与开始该例子的初始 ``'>>> '`` 行中出现的同样多的前导空白字符。"

#: ../../library/doctest.rst:440
msgid "What's the Execution Context?"
msgstr "什么是执行上下文？"

#: ../../library/doctest.rst:442
msgid ""
"By default, each time :mod:`doctest` finds a docstring to test, it uses a "
"*shallow copy* of :mod:`!M`'s globals, so that running tests doesn't change "
"the module's real globals, and so that one test in :mod:`!M` can't leave "
"behind crumbs that accidentally allow another test to work.  This means "
"examples can freely use any names defined at top-level in :mod:`!M`, and "
"names defined earlier in the docstring being run. Examples cannot see names "
"defined in other docstrings."
msgstr ""
"默认情况下，每次 :mod:`doctest` 找到要测试的文档字符串时，它都会使用 :mod:`!M` 的全局变量的一个 "
"*浅拷贝*，这样运行测试就不会改变模块真正的全局变量，并且 :mod:`!M` 中的一个测试也不会留下任何痕迹从而意外地让另一个测试通过。 "
"这意味着示例可以自由地使用 :mod:`!M` 中任何在最高层级上定义的名称，以及正在运行的文档字符串中之前定义的名称。 "
"示例将无法看到在其他文档字符串中定义的名称。"

#: ../../library/doctest.rst:450
msgid ""
"You can force use of your own dict as the execution context by passing "
"``globs=your_dict`` to :func:`testmod` or :func:`testfile` instead."
msgstr ""
"你可以通过将 ``globs=your_dict`` 传递给 :func:`testmod` 或 :func:`testfile` "
"来强制使用你自己的dict作为执行环境。"

#: ../../library/doctest.rst:457
msgid "What About Exceptions?"
msgstr "异常如何处理？"

#: ../../library/doctest.rst:459
msgid ""
"No problem, provided that the traceback is the only output produced by the "
"example:  just paste in the traceback. [#]_ Since tracebacks contain details"
" that are likely to change rapidly (for example, exact file paths and line "
"numbers), this is one case where doctest works hard to be flexible in what "
"it accepts."
msgstr ""
"没问题，只要回溯是这个例子产生的唯一输出：只要粘贴回溯即可。[#]_ "
"由于回溯所包含的细节可能会迅速变化（例如，确切的文件路径和行号），这是doctest努力使其接受的内容具有灵活性的一种情况。"

#: ../../library/doctest.rst:465
msgid "Simple example::"
msgstr "简单实例::"

#: ../../library/doctest.rst:467
msgid ""
">>> [1, 2, 3].remove(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: list.remove(x): x not in list"
msgstr ""
">>> [1, 2, 3].remove(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: list.remove(x): x not in list"

#: ../../library/doctest.rst:472
msgid ""
"That doctest succeeds if :exc:`ValueError` is raised, with the "
"``list.remove(x): x not in list`` detail as shown."
msgstr ""
"如果 :exc:`ValueError` 被触发，该测试就会成功，``list.remove(x): x not in list`` 的细节如图所示。"

#: ../../library/doctest.rst:475
msgid ""
"The expected output for an exception must start with a traceback header, "
"which may be either of the following two lines, indented the same as the "
"first line of the example::"
msgstr "异常的预期输出必须以回溯头开始，可以是以下两行中的任何一行，缩进程度与例子中的第一行相同::"

#: ../../library/doctest.rst:479
msgid ""
"Traceback (most recent call last):\n"
"Traceback (innermost last):"
msgstr ""
"Traceback (most recent call last):\n"
"Traceback (innermost last):"

#: ../../library/doctest.rst:482
msgid ""
"The traceback header is followed by an optional traceback stack, whose "
"contents are ignored by doctest.  The traceback stack is typically omitted, "
"or copied verbatim from an interactive session."
msgstr "回溯头的后面是一个可选的回溯堆栈，其内容被doctest忽略。 回溯堆栈通常是省略的，或者从交互式会话中逐字复制的。"

#: ../../library/doctest.rst:486
msgid ""
"The traceback stack is followed by the most interesting part: the line(s) "
"containing the exception type and detail.  This is usually the last line of "
"a traceback, but can extend across multiple lines if the exception has a "
"multi-line detail::"
msgstr "回溯堆栈的后面是最有用的部分：包含异常类型和细节的一行（几行）。 这通常是回溯的最后一行，但如果异常有多行细节，则可以延伸到多行::"

#: ../../library/doctest.rst:491
msgid ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: multi\n"
"    line\n"
"detail"
msgstr ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: multi\n"
"    line\n"
"detail"

#: ../../library/doctest.rst:498
msgid ""
"The last three lines (starting with :exc:`ValueError`) are compared against "
"the exception's type and detail, and the rest are ignored."
msgstr "最后三行（以 :exc:`ValueError` 开头）将与异常的类型和细节进行比较，其余的被忽略。"

#: ../../library/doctest.rst:501
msgid ""
"Best practice is to omit the traceback stack, unless it adds significant "
"documentation value to the example.  So the last example is probably better "
"as::"
msgstr "最佳实践是省略回溯栈，除非它为这个例子增加了重要的文档价值。 因此，最后一个例子可能更好，因为::"

#: ../../library/doctest.rst:504
msgid ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: multi\n"
"    line\n"
"detail"
msgstr ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: multi\n"
"    line\n"
"detail"

#: ../../library/doctest.rst:511
msgid ""
"Note that tracebacks are treated very specially.  In particular, in the "
"rewritten example, the use of ``...`` is independent of doctest's "
":const:`ELLIPSIS` option.  The ellipsis in that example could be left out, "
"or could just as well be three (or three hundred) commas or digits, or an "
"indented transcript of a Monty Python skit."
msgstr ""
"请注意，回溯的处理方式非常特别。 特别是，在重写的例子中，``...`` 的使用与 doctest 的 :const:`ELLIPSIS` 选项无关。 "
"该例子中的省略号可以不写，也可以是三个（或三百个）逗号或数字，或者是一个缩进的 Monty Python 短剧的剧本。"

#: ../../library/doctest.rst:517
msgid "Some details you should read once, but won't need to remember:"
msgstr "有些细节你应该读一遍，但不需要记住："

#: ../../library/doctest.rst:519
msgid ""
"Doctest can't guess whether your expected output came from an exception "
"traceback or from ordinary printing.  So, e.g., an example that expects "
"``ValueError: 42 is prime`` will pass whether :exc:`ValueError` is actually "
"raised or if the example merely prints that traceback text.  In practice, "
"ordinary output rarely begins with a traceback header line, so this doesn't "
"create real problems."
msgstr ""
"Doctest 不能猜测你的预期输出是来自异常回溯还是来自普通打印。 因此，例如，一个期望 ``ValueError: 42 is prime`` "
"的用例将通过测试，无论 :exc:`ValueError` 是真的被触发，或者该用例只是打印了该回溯文本。 "
"在实践中，普通输出很少以回溯标题行开始，所以这不会产生真正的问题。"

#: ../../library/doctest.rst:526
msgid ""
"Each line of the traceback stack (if present) must be indented further than "
"the first line of the example, *or* start with a non-alphanumeric character."
" The first line following the traceback header indented the same and "
"starting with an alphanumeric is taken to be the start of the exception "
"detail.  Of course this does the right thing for genuine tracebacks."
msgstr ""
"回溯堆栈的每一行（如果有的话）必须比例子的第一行缩进， *或者* "
"以一个非字母数字的字符开始。回溯头之后的第一行缩进程度相同，并且以字母数字开始，被认为是异常细节的开始。当然，这对真正的回溯来说是正确的事情。"

#: ../../library/doctest.rst:532
msgid ""
"When the :const:`IGNORE_EXCEPTION_DETAIL` doctest option is specified, "
"everything following the leftmost colon and any module information in the "
"exception name is ignored."
msgstr ""
"当 :const:`IGNORE_EXCEPTION_DETAIL` doctest "
"选项被指定时，最左边的冒号后面的所有内容以及异常名称中的任何模块信息都被忽略。"

#: ../../library/doctest.rst:536
msgid ""
"The interactive shell omits the traceback header line for some "
":exc:`SyntaxError`\\ s.  But doctest uses the traceback header line to "
"distinguish exceptions from non-exceptions.  So in the rare case where you "
"need to test a :exc:`!SyntaxError` that omits the traceback header, you will"
" need to manually add the traceback header line to your test example."
msgstr ""
"交互式 shell 省略了某些 :exc:`SyntaxError` 的回溯的标头行。 但 doctest 使用回溯标头行来区分异常和非异常。 "
"所以在你需要测试一个省略了回溯标头的 :exc:`!SyntaxError` 的罕见情况下，你将需要手动添加回溯标头行到你的测试用例中。"

#: ../../library/doctest.rst:544
msgid ""
"For some exceptions, Python displays the position of the error using ``^`` "
"markers and tildes::"
msgstr "对于某些异常，Python 会使用 ``^`` 标记和波浪号来显示错误位置::"

#: ../../library/doctest.rst:547
msgid ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ~~^~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"
msgstr ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ~~^~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"

#: ../../library/doctest.rst:553
msgid ""
"Since the lines showing the position of the error come before the exception "
"type and detail, they are not checked by doctest.  For example, the "
"following test would pass, even though it puts the ``^`` marker in the wrong"
" location::"
msgstr ""
"由于显示错误位置的行在异常类型和细节之前，它们不被doctest检查。 例如，下面的测试会通过，尽管它把 ``^`` 标记放在了错误的位置::"

#: ../../library/doctest.rst:557
msgid ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ^~~~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"
msgstr ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ^~~~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"

#: ../../library/doctest.rst:568
msgid "Option Flags"
msgstr "选项标记"

#: ../../library/doctest.rst:570
msgid ""
"A number of option flags control various aspects of doctest's behavior. "
"Symbolic names for the flags are supplied as module constants, which can be "
":ref:`bitwise ORed <bitwise>` together and passed to various functions. The "
"names can also be used in :ref:`doctest directives <doctest-directives>`, "
"and may be passed to the doctest command line interface via the ``-o`` "
"option."
msgstr ""
"一系列选项旗标控制着 doctest 的各方面行为。 旗标的符号名称以模块常量的形式提供，可以一起 :ref:`bitwise ORed "
"<bitwise>` 并传递给各种函数。 这些名称也可以在 :ref:`doctest directives <doctest-directives>`"
" 中使用，并且可以通过 ``-o`` 选项传递给 doctest 命令行接口。"

#: ../../library/doctest.rst:576
msgid ""
"The first group of options define test semantics, controlling aspects of how"
" doctest decides whether actual output matches an example's expected output:"
msgstr "第一组选项定义了测试语义，控制doctest如何决定实际输出是否与用例的预期输出相匹配方面的问题。"

#: ../../library/doctest.rst:582
msgid ""
"By default, if an expected output block contains just ``1``, an actual "
"output block containing just ``1`` or just ``True`` is considered to be a "
"match, and similarly for ``0`` versus ``False``.  When "
":const:`DONT_ACCEPT_TRUE_FOR_1` is specified, neither substitution is "
"allowed.  The default behavior caters to that Python changed the return type"
" of many functions from integer to boolean; doctests expecting \"little "
"integer\" output still work in these cases.  This option will probably go "
"away, but not for several years."
msgstr ""
"默认情况下，如果一个预期的输出块只包含 ``1``，那么实际的输出块只包含 ``1`` 或只包含 ``True`` 就被认为是匹配的，同样，``0`` "
"与 ``False`` 也是如此。 当  :const:`DONT_ACCEPT_TRUE_FOR_1` 被指定时，两种替换都不允许。 "
"默认行为是为了适应 Python 将许多函数的返回类型从整数改为布尔值；期望 \"小整数\" 输出的测试在这些情况下仍然有效。 "
"这个选项可能会消失，但不会在几年内消失。"

#: ../../library/doctest.rst:594
msgid ""
"By default, if an expected output block contains a line containing only the "
"string ``<BLANKLINE>``, then that line will match a blank line in the actual"
" output.  Because a genuinely blank line delimits the expected output, this "
"is the only way to communicate that a blank line is expected.  When "
":const:`DONT_ACCEPT_BLANKLINE` is specified, this substitution is not "
"allowed."
msgstr ""
"默认情况下，如果一个预期输出块包含一个只包含字符串 ``<BLANKLINE>`` 的行，那么该行将与实际输出中的一个空行相匹配。 "
"因为一个真正的空行是对预期输出的限定，这是传达预期空行的唯一方法。 当 :const:`DONT_ACCEPT_BLANKLINE` "
"被指定时，这种替换是不允许的。"

#: ../../library/doctest.rst:603
msgid ""
"When specified, all sequences of whitespace (blanks and newlines) are "
"treated as equal.  Any sequence of whitespace within the expected output "
"will match any sequence of whitespace within the actual output. By default, "
"whitespace must match exactly. :const:`NORMALIZE_WHITESPACE` is especially "
"useful when a line of expected output is very long, and you want to wrap it "
"across multiple lines in your source."
msgstr ""
"当指定时，所有的空白序列（空白和换行）都被视为相等。预期输出中的任何空白序列将与实际输出中的任何空白序列匹配。默认情况下，空白必须完全匹配。 "
":const:`NORMALIZE_WHITESPACE` 在预期输出非常长的一行，而你想把它包在源代码的多行中时特别有用。"

#: ../../library/doctest.rst:614
msgid ""
"When specified, an ellipsis marker (``...``) in the expected output can "
"match any substring in the actual output.  This includes substrings that "
"span line boundaries, and empty substrings, so it's best to keep usage of "
"this simple. Complicated uses can lead to the same kinds of \"oops, it "
"matched too much!\" surprises that ``.*`` is prone to in regular "
"expressions."
msgstr ""
"当指定时，预期输出中的省略号（ ``...`` ）可以匹配实际输出中的任何子串。这包括跨行的子串和空子串，所以最好保持简单的用法。复杂的用法会导致与 "
"``.*`` 在正则表达式中容易出现的 \"oops, it matched too much!\"相同的意外情况。"

#: ../../library/doctest.rst:623
msgid ""
"When specified, doctests expecting exceptions pass so long as an exception "
"of the expected type is raised, even if the details (message and fully "
"qualified exception name) don't match."
msgstr "当被指定时，只要有预期类型的异常被引发 doctests 就会预期异常测试通过，即使细节（消息和完整限定名称）并不匹配。"

#: ../../library/doctest.rst:627
msgid ""
"For example, an example expecting ``ValueError: 42`` will pass if the actual"
" exception raised is ``ValueError: 3*14``, but will fail if, say, a "
":exc:`TypeError` is raised instead. It will also ignore any fully qualified "
"name included before the exception class, which can vary between "
"implementations and versions of Python and the code/libraries in use. Hence,"
" all three of these variations will work with the flag specified:"
msgstr ""
"举例来说，一个预期 ``ValueError: 42`` 的用例在实际引发的异常为 ``ValueError: 3*14`` 将会通过，但是如果是引发 "
":exc:`TypeError` 则将会失败。 它也将忽略任何包括在异常类前面的完整限定名称，该名称在所使用的不同 Python "
"版本和代码/库中可能会不同。 因此，以下三种形式对于指定的旗标均有效:"

#: ../../library/doctest.rst:635
msgid ""
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"builtins.Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"__main__.Exception: message"
msgstr ""
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"builtins.Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"__main__.Exception: message"

#: ../../library/doctest.rst:649
msgid ""
"Note that :const:`ELLIPSIS` can also be used to ignore the details of the "
"exception message, but such a test may still fail based on whether the "
"module name is present or matches exactly."
msgstr ""
"请注意 :const:`ELLIPSIS` 也可以被用来忽略异常消息中的细节，但这样的测试仍然可能根据特定模块名称是否存在或是否完全匹配而失败。"

#: ../../library/doctest.rst:653
msgid ""
":const:`IGNORE_EXCEPTION_DETAIL` now also ignores any information relating "
"to the module containing the exception under test."
msgstr ":const:`IGNORE_EXCEPTION_DETAIL` 现在也忽略了与包含被测异常的模块有关的任何信息。"

#: ../../library/doctest.rst:660
msgid ""
"When specified, do not run the example at all.  This can be useful in "
"contexts where doctest examples serve as both documentation and test cases, "
"and an example should be included for documentation purposes, but should not"
" be checked.  E.g., the example's output might be random; or the example "
"might depend on resources which would be unavailable to the test driver."
msgstr ""
"当指定时，完全不运行这个用例。 "
"这在doctest用例既是文档又是测试案例的情况下很有用，一个例子应该包括在文档中，但不应该被检查。例如，这个例子的输出可能是随机的；或者这个例子可能依赖于测试驱动程序所不能使用的资源。"

#: ../../library/doctest.rst:666
msgid ""
"The SKIP flag can also be used for temporarily \"commenting out\" examples."
msgstr "SKIP标志也可用于临时 \"注释\" 用例。"

#: ../../library/doctest.rst:671
msgid "A bitmask or'ing together all the comparison flags above."
msgstr "一个比特或运算将上述所有的比较标志放在一起。"

#: ../../library/doctest.rst:673
msgid "The second group of options controls how test failures are reported:"
msgstr "第二组选项控制测试失败的报告方式："

#: ../../library/doctest.rst:678
msgid ""
"When specified, failures that involve multi-line expected and actual outputs"
" are displayed using a unified diff."
msgstr "当指定时，涉及多行预期和实际输出的故障将使用统一的差异来显示。"

#: ../../library/doctest.rst:684
msgid ""
"When specified, failures that involve multi-line expected and actual outputs"
" will be displayed using a context diff."
msgstr "当指定时，涉及多行预期和实际输出的故障将使用上下文差异来显示。"

#: ../../library/doctest.rst:690
msgid ""
"When specified, differences are computed by ``difflib.Differ``, using the "
"same algorithm as the popular :file:`ndiff.py` utility. This is the only "
"method that marks differences within lines as well as across lines.  For "
"example, if a line of expected output contains digit ``1`` where actual "
"output contains letter ``l``, a line is inserted with a caret marking the "
"mismatching column positions."
msgstr ""
"当指定时，差异由 ``difflib.Differ`` 来计算，使用与流行的 :file:`ndiff.py` 工具相同的算法。 "
"这是唯一一种标记行内和行间差异的方法。 例如，如果一行预期输出包含数字 ``1`` ，而实际输出包含字母 ``l`` "
"，那么就会插入一行，用圆点标记不匹配的列位置。"

#: ../../library/doctest.rst:699
msgid ""
"When specified, display the first failing example in each doctest, but "
"suppress output for all remaining examples.  This will prevent doctest from "
"reporting correct examples that break because of earlier failures; but it "
"might also hide incorrect examples that fail independently of the first "
"failure.  When :const:`REPORT_ONLY_FIRST_FAILURE` is specified, the "
"remaining examples are still run, and still count towards the total number "
"of failures reported; only the output is suppressed."
msgstr ""
"当指定时，在每个 doctest 中显示第一个失败的用例，但隐藏所有其余用例的输出。 这将防止 doctest "
"报告由于先前的失败而中断的正确用例；但也可能隐藏独立于第一个失败的不正确用例。 当 :const:`REPORT_ONLY_FIRST_FAILURE`"
" 被指定时，其余的用例仍然被运行，并且仍然计入报告的失败总数；只是输出被隐藏了。"

#: ../../library/doctest.rst:710
msgid ""
"When specified, exit after the first failing example and don't attempt to "
"run the remaining examples. Thus, the number of failures reported will be at"
" most 1.  This flag may be useful during debugging, since examples after the"
" first failure won't even produce debugging output."
msgstr ""
"当指定时，在第一个失败的用例后退出，不尝试运行其余的用例。因此，报告的失败次数最多为1。这个标志在调试时可能很有用，因为第一个失败后的用例甚至不会产生调试输出。"

#: ../../library/doctest.rst:718
msgid "A bitmask or'ing together all the reporting flags above."
msgstr "一个比特或操作将上述所有的报告标志组合在一起。"

#: ../../library/doctest.rst:721
msgid ""
"There is also a way to register new option flag names, though this isn't "
"useful unless you intend to extend :mod:`doctest` internals via subclassing:"
msgstr "还有一种方法可以注册新的选项标志名称，不过这并不有用，除非你打算通过子类来扩展 :mod:`doctest` 内部。"

#: ../../library/doctest.rst:727
msgid ""
"Create a new option flag with a given name, and return the new flag's "
"integer value.  :func:`register_optionflag` can be used when subclassing "
":class:`OutputChecker` or :class:`DocTestRunner` to create new options that "
"are supported by your subclasses.  :func:`register_optionflag` should always"
" be called using the following idiom::"
msgstr ""
"用给定的名称创建一个新的选项标志，并返回新标志的整数值。 :func:`register_optionflag` 可以在继承 "
":class:`OutputChecker` 或 :class:`DocTestRunner` 时使用，以创建子类支持的新选项。 "
":func:`register_optionflag` 应始终使用以下方式调用::"

#: ../../library/doctest.rst:733
msgid "MY_FLAG = register_optionflag('MY_FLAG')"
msgstr "MY_FLAG = register_optionflag('MY_FLAG')"

#: ../../library/doctest.rst:743
msgid "Directives"
msgstr "指令"

#: ../../library/doctest.rst:745
msgid ""
"Doctest directives may be used to modify the :ref:`option flags <doctest-"
"options>` for an individual example.  Doctest directives are special Python "
"comments following an example's source code:"
msgstr ""
"Doctest指令可以用来修改单个例子的 :ref:`option flags <doctest-options>` 。 "
"Doctest指令是在一个用例的源代码后面的特殊Python注释。"

#: ../../library/doctest.rst:756
msgid ""
"Whitespace is not allowed between the ``+`` or ``-`` and the directive "
"option name.  The directive option name can be any of the option flag names "
"explained above."
msgstr "``+`` 或 ``-`` 与指令选项名称之间不允许有空格。 指令选项名称可以是上面解释的任何一个选项标志名称。"

#: ../../library/doctest.rst:760
msgid ""
"An example's doctest directives modify doctest's behavior for that single "
"example.  Use ``+`` to enable the named behavior, or ``-`` to disable it."
msgstr ""
"一个用例的 doctest 指令可以修改 doctest 对该用例的行为。 使用 ``+`` 来启用指定的行为，或者使用 ``-`` 来禁用它。"

#: ../../library/doctest.rst:763
msgid "For example, this test passes:"
msgstr "例如，这个测试将会通过:"

#: ../../library/doctest.rst:765
msgid ""
">>> print(list(range(20)))  # doctest: +NORMALIZE_WHITESPACE\n"
"[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,\n"
"10,  11, 12, 13, 14, 15, 16, 17, 18, 19]"
msgstr ""
">>> print(list(range(20)))  # doctest: +NORMALIZE_WHITESPACE\n"
"[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,\n"
"10,  11, 12, 13, 14, 15, 16, 17, 18, 19]"

#: ../../library/doctest.rst:772
msgid ""
"Without the directive it would fail, both because the actual output doesn't "
"have two blanks before the single-digit list elements, and because the "
"actual output is on a single line.  This test also passes, and also requires"
" a directive to do so:"
msgstr ""
"如果没有这个指令则它将失败，因为实际的输出在只有个位数的列表元素前没有两个空格，也因为实际的输出是单行的。 这个测试也会通过，并且也需要一个指令来完成:"

#: ../../library/doctest.rst:777
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"[0, 1, ..., 18, 19]"
msgstr ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"[0, 1, ..., 18, 19]"

#: ../../library/doctest.rst:783
msgid ""
"Multiple directives can be used on a single physical line, separated by "
"commas:"
msgstr "在单个物理行中可以使用多条指令，以逗号分隔:"

#: ../../library/doctest.rst:786
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"
msgstr ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"

#: ../../library/doctest.rst:792
msgid ""
"If multiple directive comments are used for a single example, then they are "
"combined:"
msgstr "如果在单个用例中使用了多条指令注释，则它们会被合并:"

#: ../../library/doctest.rst:795
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"...                         # doctest: +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"
msgstr ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"...                         # doctest: +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"

#: ../../library/doctest.rst:802
msgid ""
"As the previous example shows, you can add ``...`` lines to your example "
"containing only directives.  This can be useful when an example is too long "
"for a directive to comfortably fit on the same line:"
msgstr "正如前面的例子所示，你可以在你的用例中添加只包含指令的行 ``...``。 当一个用例太长以至于不能方便地放到同一行时这将会很有用:"

#: ../../library/doctest.rst:806
msgid ""
">>> print(list(range(5)) + list(range(10, 20)) + list(range(30, 40)))\n"
"... # doctest: +ELLIPSIS\n"
"[0, ..., 4, 10, ..., 19, 30, ..., 39]"
msgstr ""
">>> print(list(range(5)) + list(range(10, 20)) + list(range(30, 40)))\n"
"... # doctest: +ELLIPSIS\n"
"[0, ..., 4, 10, ..., 19, 30, ..., 39]"

#: ../../library/doctest.rst:813
msgid ""
"Note that since all options are disabled by default, and directives apply "
"only to the example they appear in, enabling options (via ``+`` in a "
"directive) is usually the only meaningful choice.  However, option flags can"
" also be passed to functions that run doctests, establishing different "
"defaults.  In such cases, disabling an option via ``-`` in a directive can "
"be useful."
msgstr ""
"请注意，由于所有的选项都是默认禁用的，而指令只适用于它们出现的用例，所以启用选项 (通过指令中的 ``+``) 通常是唯一有意义的选择。 "
"然而，选项标志也可以被传递给运行测试的函数，建立不同的默认值。 在这种情况下，通过指令中的 ``-`` 来禁用一个选项可能是有用的。"

#: ../../library/doctest.rst:823
msgid "Warnings"
msgstr "警告"

#: ../../library/doctest.rst:825
msgid ""
":mod:`doctest` is serious about requiring exact matches in expected output."
"  If even a single character doesn't match, the test fails.  This will "
"probably surprise you a few times, as you learn exactly what Python does and"
" doesn't guarantee about output.  For example, when printing a set, Python "
"doesn't guarantee that the element is printed in any particular order, so a "
"test like ::"
msgstr ""
":mod:`doctest` 是严格地要求在预期输出中完全匹配。 如果哪怕只有一个字符不匹配，测试就会失败。 这可能会让你吃惊几次，在你确切地了解到 "
"Python 对输出的保证和不保证之前。 例如，当打印一个集合时，Python 不保证元素以任何特定的顺序被打印出来，所以像::"

#: ../../library/doctest.rst:831
msgid ""
">>> foo()\n"
"{\"spam\", \"eggs\"}"
msgstr ""
">>> foo()\n"
"{\"spam\", \"eggs\"}"

#: ../../library/doctest.rst:834
msgid "is vulnerable!  One workaround is to do ::"
msgstr "是不可靠的！一个变通方法是用::"

#: ../../library/doctest.rst:836
msgid ""
">>> foo() == {\"spam\", \"eggs\"}\n"
"True"
msgstr ""
">>> foo() == {\"spam\", \"eggs\"}\n"
"True"

#: ../../library/doctest.rst:839
msgid "instead.  Another is to do ::"
msgstr "来取代。另一个是使用"

#: ../../library/doctest.rst:841
msgid ""
">>> d = sorted(foo())\n"
">>> d\n"
"['eggs', 'spam']"
msgstr ""
">>> d = sorted(foo())\n"
">>> d\n"
"['eggs', 'spam']"

#: ../../library/doctest.rst:845
msgid "There are others, but you get the idea."
msgstr "还有其他的问题，但你会明白的。"

#: ../../library/doctest.rst:847
msgid "Another bad idea is to print things that embed an object address, like"
msgstr "另一个不好的做法是打印嵌入了对象地址的值，例如"

#: ../../library/doctest.rst:849
msgid ""
">>> id(1.0)  # certain to fail some of the time\n"
"7948648\n"
">>> class C: pass\n"
">>> C()  # the default repr() for instances embeds an address\n"
"<C object at 0x00AC18F0>"
msgstr ""
">>> id(1.0)  # 确定有时会失败\n"
"7948648\n"
">>> class C: pass\n"
">>> C()  # 实例的默认 repr() 嵌入了一个地址\n"
"<C object at 0x00AC18F0>"

#: ../../library/doctest.rst:857
msgid ""
"The :const:`ELLIPSIS` directive gives a nice approach for the last example:"
msgstr ":const:`ELLIPSIS` 指令为之前的例子提供了一个不错的方案:"

#: ../../library/doctest.rst:859
msgid ""
">>> C()  # doctest: +ELLIPSIS\n"
"<C object at 0x...>"
msgstr ""
">>> C()  # doctest: +ELLIPSIS\n"
"<C object at 0x...>"

#: ../../library/doctest.rst:865
msgid ""
"Floating-point numbers are also subject to small output variations across "
"platforms, because Python defers to the platform C library for some "
"floating-point calculations, and C libraries vary widely in quality here. ::"
msgstr ""
"浮点数在不同平台上也会有小幅度的输出变化，因为 Python 的某些浮点计算依赖于平台的 C 库，而各种 C 在此方面的质量有很大的差异。 ::"

#: ../../library/doctest.rst:869
msgid ""
">>> 1000**0.1  # risky\n"
"1.9952623149688797\n"
">>> round(1000**0.1, 9) # safer\n"
"1.995262315\n"
">>> print(f'{1000**0.1:.4f}') # much safer\n"
"1.9953"
msgstr ""
">>> 1000**0.1  # 危险\n"
"1.9952623149688797\n"
">>> round(1000**0.1, 9) # 更安全\n"
"1.995262315\n"
">>> print(f'{1000**0.1:.4f}') # 非常安全\n"
"1.9953"

#: ../../library/doctest.rst:876
msgid ""
"Numbers of the form ``I/2.**J`` are safe across all platforms, and I often "
"contrive doctest examples to produce numbers of that form::"
msgstr "形式 ``I/2.**J`` 的数字在所有的平台上都是安全的，我经常设计一些测试的用例来产生该形式的数::"

#: ../../library/doctest.rst:879
msgid ""
">>> 3./4  # utterly safe\n"
"0.75"
msgstr ""
">>> 3./4  # 绝对安全\n"
"0.75"

#: ../../library/doctest.rst:882
msgid ""
"Simple fractions are also easier for people to understand, and that makes "
"for better documentation."
msgstr "简单的分数也更容易让人理解，这也使得文件更加完善。"

#: ../../library/doctest.rst:889
msgid "Basic API"
msgstr "基本API"

#: ../../library/doctest.rst:891
msgid ""
"The functions :func:`testmod` and :func:`testfile` provide a simple "
"interface to doctest that should be sufficient for most basic uses.  For a "
"less formal introduction to these two functions, see sections :ref:`doctest-"
"simple-testmod` and :ref:`doctest-simple-testfile`."
msgstr ""
"函数 :func:`testmod` 和 :func:`testfile` 为 doctest "
"提供了一个简单的接口，应该足以满足大多数基本用途。关于这两个函数的不太正式的介绍，请参见 :ref:`doctest-simple-testmod` 和"
" :ref:`doctest-simple-testfile` 部分。"

#: ../../library/doctest.rst:899
msgid ""
"All arguments except *filename* are optional, and should be specified in "
"keyword form."
msgstr "除了*filename*，所有的参数都是可选的，而且应该以关键字的形式指定。"

#: ../../library/doctest.rst:902
msgid ""
"Test examples in the file named *filename*.  Return ``(failure_count, "
"test_count)``."
msgstr "测试名为 *filename* 的文件中的用例。 返回 ``(failure_count, test_count)``。"

#: ../../library/doctest.rst:905
msgid ""
"Optional argument *module_relative* specifies how the filename should be "
"interpreted:"
msgstr "可选参数 *module_relative* 指定了文件名的解释方式。"

#: ../../library/doctest.rst:908
msgid ""
"If *module_relative* is ``True`` (the default), then *filename* specifies an"
" OS-independent module-relative path.  By default, this path is relative to "
"the calling module's directory; but if the *package* argument is specified, "
"then it is relative to that package.  To ensure OS-independence, *filename* "
"should use ``/`` characters to separate path segments, and may not be an "
"absolute path (i.e., it may not begin with ``/``)."
msgstr ""
"如果 *module_relative* 是 ``True`` (默认)，那么 *filename* 指定一个独立于操作系统的模块相对路径。 "
"默认情况下，这个路径是相对于调用模块的目录的；但是如果指定了 *package* 参数，那么它就是相对于该包的。 为了保证操作系统的独立性， "
"*filename* 应该使用字符来分隔路径段，并且不能是一个绝对路径 (即不能以 ``/`` 开始)。"

#: ../../library/doctest.rst:915
msgid ""
"If *module_relative* is ``False``, then *filename* specifies an OS-specific "
"path.  The path may be absolute or relative; relative paths are resolved "
"with respect to the current working directory."
msgstr ""
"如果 *module_relative* 是 ``False``，那么 *filename* "
"指定了一个操作系统特定的路径。路径可以是绝对的，也可以是相对的；相对路径是相对于当前工作目录而言的。"

#: ../../library/doctest.rst:919
msgid ""
"Optional argument *name* gives the name of the test; by default, or if "
"``None``, ``os.path.basename(filename)`` is used."
msgstr ""
"可选参数 *name* 给出了测试的名称；默认情况下，或者如果是 ``None``，那么使用 "
"``os.path.basename(filename)``。"

#: ../../library/doctest.rst:922
msgid ""
"Optional argument *package* is a Python package or the name of a Python "
"package whose directory should be used as the base directory for a module-"
"relative filename.  If no package is specified, then the calling module's "
"directory is used as the base directory for module-relative filenames.  It "
"is an error to specify *package* if *module_relative* is ``False``."
msgstr ""
"可选参数 *package* 是一个 Python 包或一个 Python 包的名字，其目录应被用作模块相关文件名的基础目录。 "
"如果没有指定包，那么调用模块的目录将作为模块相关文件名的基础目录。如果 *module_relative* 是 ``False``，那么指定 "
"*package* 是错误的。"

#: ../../library/doctest.rst:928
msgid ""
"Optional argument *globs* gives a dict to be used as the globals when "
"executing examples.  A new shallow copy of this dict is created for the "
"doctest, so its examples start with a clean slate. By default, or if "
"``None``, a new empty dict is used."
msgstr ""
"可选参数 *globs* 给出了一个在执行示例时用作全局变量的dict。 "
"这个dict的一个新的浅层副本将为doctest创建，因此它的用例将从一个干净的地方开始。默认情况下，或者如果为 "
"``None``，使用一个新的空dict。"

#: ../../library/doctest.rst:933
msgid ""
"Optional argument *extraglobs* gives a dict merged into the globals used to "
"execute examples.  This works like :meth:`dict.update`:  if *globs* and "
"*extraglobs* have a common key, the associated value in *extraglobs* appears"
" in the combined dict.  By default, or if ``None``, no extra globals are "
"used.  This is an advanced feature that allows parameterization of doctests."
"  For example, a doctest can be written for a base class, using a generic "
"name for the class, then reused to test any number of subclasses by passing "
"an *extraglobs* dict mapping the generic name to the subclass to be tested."
msgstr ""
"可选参数 *extraglobs* 给出了一个合并到用于执行用例全局变量中的dict。 这就像 :meth:`dict.update` 一样：如果 "
"*globs* 和 *extraglobs* 有一个共同的键，那么 *extraglobs* 中的相关值会出现在合并的dict中。 默认情况下，或者为 "
"``None`` ，则不使用额外的全局变量。这是一个高级功能，允许对 doctest "
"进行参数化。例如，可以为一个基类写一个测试，使用该类的通用名称，然后通过传递一个 *extraglobs* "
"dict，将通用名称映射到要测试的子类，从而重复用于测试任何数量的子类。"

#: ../../library/doctest.rst:942
msgid ""
"Optional argument *verbose* prints lots of stuff if true, and prints only "
"failures if false; by default, or if ``None``, it's true if and only if "
"``'-v'`` is in :data:`sys.argv`."
msgstr ""
"可选参数 *verbose* 如果为真值则会打印很多内容，如果为假值则只打印失败信息；在默认情况下，或者在为 ``None`` 时，则当且仅当 "
"``'-v'`` 在 :data:`sys.argv` 中时才会为真值。"

#: ../../library/doctest.rst:946
msgid ""
"Optional argument *report* prints a summary at the end when true, else "
"prints nothing at the end.  In verbose mode, the summary is detailed, else "
"the summary is very brief (in fact, empty if all tests passed)."
msgstr ""
"可选参数 *report* 为True时，在结尾处打印一个总结，否则在结尾处什么都不打印。 "
"在verbose模式下，总结是详细的，否则总结是非常简短的（事实上，如果所有的测试都通过了，总结就是空的）。"

#: ../../library/doctest.rst:950
msgid ""
"Optional argument *optionflags* (default value ``0``) takes the "
":ref:`bitwise OR <bitwise>` of option flags. See section :ref:`doctest-"
"options`."
msgstr ""
"可选参数 *optionflags* (默认值为 ``0``) 接受选项旗标 :ref:`按位或 <bitwise>` 的结果。 参见 "
":ref:`doctest-options` 一节。"

#: ../../library/doctest.rst:954
msgid ""
"Optional argument *raise_on_error* defaults to false.  If true, an exception"
" is raised upon the first failure or unexpected exception in an example.  "
"This allows failures to be post-mortem debugged. Default behavior is to "
"continue running examples."
msgstr ""
"可选参数 *raise_on_error* 默认为False。 "
"如果是True，在一个用例中第一次出现失败或意外的异常时，会触发一个异常。这允许对失败进行事后调试。默认行为是继续运行例子。"

#: ../../library/doctest.rst:959 ../../library/doctest.rst:1102
msgid ""
"Optional argument *parser* specifies a :class:`DocTestParser` (or subclass) "
"that should be used to extract tests from the files.  It defaults to a "
"normal parser (i.e., ``DocTestParser()``)."
msgstr ""
"可选参数 *parser* 指定一个 :class:`DocTestParser` "
"（或子类），它应该被用来从文件中提取测试。它默认为一个普通的解析器（即 ``DocTestParser()``）。"

#: ../../library/doctest.rst:963 ../../library/doctest.rst:1106
msgid ""
"Optional argument *encoding* specifies an encoding that should be used to "
"convert the file to unicode."
msgstr "可选参数 *encoding* 指定了一个编码，应该用来将文件转换为unicode。"

#: ../../library/doctest.rst:969
msgid ""
"All arguments are optional, and all except for *m* should be specified in "
"keyword form."
msgstr "所有的参数都是可选的，除了 *m* 之外，都应该以关键字的形式指定。"

#: ../../library/doctest.rst:972
msgid ""
"Test examples in docstrings in functions and classes reachable from module "
"*m* (or module :mod:`__main__` if *m* is not supplied or is ``None``), "
"starting with ``m.__doc__``."
msgstr ""
"测试从模块 *m* （或模块 :mod:`__main__` ，如果 *m* 没有被提供或为 ``None`` ）可达到的函数和类的文档串中的用例，从 "
"``m.__doc__`` 开始。"

#: ../../library/doctest.rst:976
msgid ""
"Also test examples reachable from dict ``m.__test__``, if it exists. "
"``m.__test__`` maps names (strings) to functions, classes and strings; "
"function and class docstrings are searched for examples; strings are "
"searched directly, as if they were docstrings."
msgstr ""
"还会测试从 dict ``m.__test__`` 可达到的用例，如果存在的话。 ``m.__test__`` "
"将名称（字符串）映射到函数、类和字符串；将在函数和类的文档字符串中搜索用例；字符串将被直接搜索，就像它们是文档字符串一样。"

#: ../../library/doctest.rst:981
msgid ""
"Only docstrings attached to objects belonging to module *m* are searched."
msgstr "只搜索附属于模块 *m* 中的对象的文档串。"

#: ../../library/doctest.rst:983
msgid "Return ``(failure_count, test_count)``."
msgstr "返回 ``(failure_count, test_count)`` 。"

#: ../../library/doctest.rst:985
msgid ""
"Optional argument *name* gives the name of the module; by default, or if "
"``None``, ``m.__name__`` is used."
msgstr "可选参数 *name* 给出了模块的名称；默认情况下，或者如果为 ``None`` ，则为 ``m.__name__`` 。"

#: ../../library/doctest.rst:988
msgid ""
"Optional argument *exclude_empty* defaults to false.  If true, objects for "
"which no doctests are found are excluded from consideration. The default is "
"a backward compatibility hack, so that code still using "
":meth:`doctest.master.summarize <DocTestRunner.summarize>` in conjunction "
"with :func:`testmod` continues to get output for objects with no tests. The "
"*exclude_empty* argument to the newer :class:`DocTestFinder` constructor "
"defaults to true."
msgstr ""
"可选参数 *exclude_empty* 默认为假值。 如果为真值，则未找到任何 doctests 的对象将被排除在考虑范围之外。 "
"默认情况下将做向下兼容处理，因而仍然使用 :meth:`doctest.master.summarize "
"<DocTestRunner.summarize>` 来配合 :func:`testmod` 的代码会继续得到没有测试的对象的输出。 转给较新的 "
":class:`DocTestFinder` 构造器的 *exclude_empty* 参数默认为真值。"

#: ../../library/doctest.rst:996
msgid ""
"Optional arguments *extraglobs*, *verbose*, *report*, *optionflags*, "
"*raise_on_error*, and *globs* are the same as for function :func:`testfile` "
"above, except that *globs* defaults to ``m.__dict__``."
msgstr ""
"可选参数 *extraglobs* 、 *verbose* 、 *report* 、 *optionflags* 、 *raise_on_error* "
"和 *globs* 与上述函数 :func:`testfile` 的参数相同，只是 *globs* 默认为 ``m.__dict__`` 。"

#: ../../library/doctest.rst:1003
msgid ""
"Test examples associated with object *f*; for example, *f* may be a string, "
"a module, a function, or a class object."
msgstr "与对象 *f* 相关的测试用例；例如， *f* 可以是一个字符串、一个模块、一个函数或一个类对象。"

#: ../../library/doctest.rst:1006
msgid ""
"A shallow copy of dictionary argument *globs* is used for the execution "
"context."
msgstr "dict 参数 *globs* 的浅层拷贝被用于执行环境。"

#: ../../library/doctest.rst:1008
msgid ""
"Optional argument *name* is used in failure messages, and defaults to "
"``\"NoName\"``."
msgstr "可选参数 *name* 在失败信息中使用，默认为 ``\"NoName\"`` 。"

#: ../../library/doctest.rst:1011
msgid ""
"If optional argument *verbose* is true, output is generated even if there "
"are no failures.  By default, output is generated only in case of an example"
" failure."
msgstr "如果可选参数 *verbose* 为真，即使没有失败也会产生输出。 默认情况下，只有在用例失败的情况下才会产生输出。"

#: ../../library/doctest.rst:1014
msgid ""
"Optional argument *compileflags* gives the set of flags that should be used "
"by the Python compiler when running the examples.  By default, or if "
"``None``, flags are deduced corresponding to the set of future features "
"found in *globs*."
msgstr ""
"可选参数 *compileflags* 给出了Python编译器在运行例子时应该使用的标志集。默认情况下，或者如果为 ``None`` ，标志是根据 "
"*globs* 中发现的未来特征集推导出来的。"

#: ../../library/doctest.rst:1018
msgid ""
"Optional argument *optionflags* works as for function :func:`testfile` "
"above."
msgstr "可选参数 *optionflags* 的作用与上述 :func:`testfile` 函数中的相同。"

#: ../../library/doctest.rst:1024
msgid "Unittest API"
msgstr "Unittest API"

#: ../../library/doctest.rst:1026
msgid ""
"As your collection of doctest'ed modules grows, you'll want a way to run all"
" their doctests systematically.  :mod:`doctest` provides two functions that "
"can be used to create :mod:`unittest` test suites from modules and text "
"files containing doctests.  To integrate with :mod:`unittest` test "
"discovery, include a :ref:`load_tests <load_tests-protocol>` function in "
"your test module::"
msgstr ""
"随着你带有文档测试的模块不断增加，你会希望以系统性地方式运行所有的文档测试。 :mod:`doctest` "
"提供了两个函数可用来根据模块和包含文档测试的文本文件创建 :mod:`unittest` 测试套件。 要与 :mod:`unittest` "
"测试发现功能实现集成，请在你的测试模块中包括一个 :ref:`load_tests <load_tests-protocol>` 函数::"

#: ../../library/doctest.rst:1032
msgid ""
"import unittest\n"
"import doctest\n"
"import my_module_with_doctests\n"
"\n"
"def load_tests(loader, tests, ignore):\n"
"    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))\n"
"    return tests"
msgstr ""
"import unittest\n"
"import doctest\n"
"import my_module_with_doctests\n"
"\n"
"def load_tests(loader, tests, ignore):\n"
"    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))\n"
"    return tests"

#: ../../library/doctest.rst:1040
msgid ""
"There are two main functions for creating :class:`unittest.TestSuite` "
"instances from text files and modules with doctests:"
msgstr "有两个主要函数用于从文本文件和带doctest的模块中创建 :class:`unittest.TestSuite` 实例。"

#: ../../library/doctest.rst:1046
msgid ""
"Convert doctest tests from one or more text files to a "
":class:`unittest.TestSuite`."
msgstr "将一个或多个文本文件中的doctest测试转换为一个 :class:`unittest.TestSuite` 。"

#: ../../library/doctest.rst:1049
msgid ""
"The returned :class:`unittest.TestSuite` is to be run by the unittest "
"framework and runs the interactive examples in each file.  If an example in "
"any file fails, then the synthesized unit test fails, and a "
":exc:`~unittest.TestCase.failureException` exception is raised showing the "
"name of the file containing the test and a (sometimes approximate) line "
"number.  If all the examples in a file are skipped, then the synthesized "
"unit test is also marked as skipped."
msgstr ""
"返回的 :class:`unittest.TestSuite` 将由 unittest 框架运行并会运行每个文件中的交互式示例。 "
"如果在任何文件中有示例运行失败，那么合成的单元测试就将失败，并引发一个 "
":exc:`~unittest.TestCase.failureException` 异常来显示包含该测试的文件名以及（有时为近似的）行号。 "
"如果某个文件中的所有示例都被跳过，则合成的单元测试也会被标记为跳过。"

#: ../../library/doctest.rst:1056
msgid "Pass one or more paths (as strings) to text files to be examined."
msgstr "传递一个或多个要检查的文本文件的路径（作为字符串）。"

#: ../../library/doctest.rst:1058
msgid "Options may be provided as keyword arguments:"
msgstr "选项可以作为关键字参数提供："

#: ../../library/doctest.rst:1060
msgid ""
"Optional argument *module_relative* specifies how the filenames in *paths* "
"should be interpreted:"
msgstr "可选参数 *module_relative* 指定了 *paths* 中的文件名应该如何解释。"

#: ../../library/doctest.rst:1063
msgid ""
"If *module_relative* is ``True`` (the default), then each filename in "
"*paths* specifies an OS-independent module-relative path.  By default, this "
"path is relative to the calling module's directory; but if the *package* "
"argument is specified, then it is relative to that package.  To ensure OS-"
"independence, each filename should use ``/`` characters to separate path "
"segments, and may not be an absolute path (i.e., it may not begin with "
"``/``)."
msgstr ""
"如果 *module_relative* 是 ``True`` （默认值），那么 *paths* "
"中的每个文件名都指定了一个独立于操作系统的模块相对路径。 默认情况下，这个路径是相对于调用模块的目录的；但是如果指定了 *package* "
"参数，那么它就是相对于该包的。 为了保证操作系统的独立性，每个文件名都应该使用字符来分隔路径段，并且不能是绝对路径（即不能以 ``/`` 开始）。"

#: ../../library/doctest.rst:1071
msgid ""
"If *module_relative* is ``False``, then each filename in *paths* specifies "
"an OS-specific path.  The path may be absolute or relative; relative paths "
"are resolved with respect to the current working directory."
msgstr ""
"如果 *module_relative* 是 ``False`` ，那么 *paths* 中的每个文件名都指定了一个操作系统特定的路径。 "
"路径可以是绝对的，也可以是相对的；相对路径是关于当前工作目录的解析。"

#: ../../library/doctest.rst:1075
msgid ""
"Optional argument *package* is a Python package or the name of a Python "
"package whose directory should be used as the base directory for module-"
"relative filenames in *paths*.  If no package is specified, then the calling"
" module's directory is used as the base directory for module-relative "
"filenames.  It is an error to specify *package* if *module_relative* is "
"``False``."
msgstr ""
"可选参数 *package* 是一个Python包或一个Python包的名字，其目录应该被用作 *paths* 中模块相关文件名的基本目录。 "
"如果没有指定包，那么调用模块的目录将作为模块相关文件名的基础目录。 如果 *module_relative* 是 ``False`` ，那么指定 "
"*package* 是错误的。"

#: ../../library/doctest.rst:1082
msgid ""
"Optional argument *setUp* specifies a set-up function for the test suite. "
"This is called before running the tests in each file.  The *setUp* function "
"will be passed a :class:`DocTest` object.  The *setUp* function can access "
"the test globals as the :attr:`~DocTest.globs` attribute of the test passed."
msgstr ""
"可选参数 *setUp* 为测试套件指定一个设置函数。 此函数会在运行每个文件中的测试之前被调用。 *setUp* 函数将被传入一个 "
":class:`DocTest` 对象。 *setUp* 函数可以通过所传入测试的 :attr:`~DocTest.globs` "
"属性来访问测试的全局变量。"

#: ../../library/doctest.rst:1087
msgid ""
"Optional argument *tearDown* specifies a tear-down function for the test "
"suite.  This is called after running the tests in each file.  The *tearDown*"
" function will be passed a :class:`DocTest` object.  The *tearDown* function"
" can access the test globals as the :attr:`~DocTest.globs` attribute of the "
"test passed."
msgstr ""
"可选参数 *tearDown* 为测试套件指定一个拆卸函数。 此函数会在运行每个文件中的测试之后被调用。 *tearDown* 函数将被传入一个 "
":class:`DocTest` 对象。 *tearDown* 函数可以通过所传入测试的 :attr:`~DocTest.globs` "
"属性来访问测试的全局变量。"

#: ../../library/doctest.rst:1093
msgid ""
"Optional argument *globs* is a dictionary containing the initial global "
"variables for the tests.  A new copy of this dictionary is created for each "
"test.  By default, *globs* is a new empty dictionary."
msgstr ""
"可选参数 *globs* 是一个包含测试的初始全局变量的字典。 这个字典的一个新副本为每个测试创建。 默认情况下， *globs* 是一个新的空字典。"

#: ../../library/doctest.rst:1097
msgid ""
"Optional argument *optionflags* specifies the default doctest options for "
"the tests, created by or-ing together individual option flags.  See section "
":ref:`doctest-options`. See function :func:`set_unittest_reportflags` below "
"for a better way to set reporting options."
msgstr ""
"可选参数 *optionflags* 为测试指定默认的doctest选项，通过将各个选项的标志连接在一起创建。 参见章节 :ref:`doctest-"
"options` 。参见下面的函数 :func:`set_unittest_reportflags` ，以了解设置报告选项的更好方法。"

#: ../../library/doctest.rst:1109
msgid ""
"The global ``__file__`` is added to the globals provided to doctests loaded "
"from a text file using :func:`DocFileSuite`."
msgstr "该全局 ``__file__`` 被添加到提供给用 :func:`DocFileSuite` 从文本文件加载的doctest的全局变量中。"

#: ../../library/doctest.rst:1115
msgid "Convert doctest tests for a module to a :class:`unittest.TestSuite`."
msgstr "将一个模块的doctest测试转换为 :class:`unittest.TestSuite` 。"

#: ../../library/doctest.rst:1117
msgid ""
"The returned :class:`unittest.TestSuite` is to be run by the unittest "
"framework and runs each doctest in the module. Each docstring is run as a "
"separate unit test. If any of the doctests fail, then the synthesized unit "
"test fails, and a :exc:`unittest.TestCase.failureException` exception is "
"raised showing the name of the file containing the test and a (sometimes "
"approximate) line number.  If all the examples in a docstring are skipped, "
"then the"
msgstr ""
"返回的 :class:`unittest.TestSuite` 将由 unittest 框架运行并运行模块中的每个文档测试。 "
"每个文档字符串都将作为单独的单元测试运行。 如果有任何文档测试运行失败，则合成的单元测试就将失败，并引发一个 "
":exc:`unittest.TestCase.failureException` 异常来显示包含该测试的文件名以及（有时为近似的）行号。 "
"如果文档字符串中的所有示例都被跳过，那么"

#: ../../library/doctest.rst:1125
msgid ""
"Optional argument *module* provides the module to be tested.  It can be a "
"module object or a (possibly dotted) module name.  If not specified, the "
"module calling this function is used."
msgstr ""
"可选参数 *module* 提供了要测试的模块。 它可以是一个模块对象或一个（可能是带点的）模块名称。 如果没有指定，则使用调用此函数的模块。"

#: ../../library/doctest.rst:1129
msgid ""
"Optional argument *globs* is a dictionary containing the initial global "
"variables for the tests.  A new copy of this dictionary is created for each "
"test.  By default, *globs* is the module's :attr:`~module.__dict__`."
msgstr ""
"可选参数 *globs* 是一个包含用于测试的初始全局变量的字典。 针对每个测试都将创建一个该字典的新副本。 在默认情况下，*globs* 就是模块的 "
":attr:`~module.__dict__`。"

#: ../../library/doctest.rst:1133
msgid ""
"Optional argument *extraglobs* specifies an extra set of global variables, "
"which is merged into *globs*.  By default, no extra globals are used."
msgstr "可选参数 *extraglobs* 指定了一组额外的全局变量，这些变量被合并到 *globs* 中。 默认情况下，不使用额外的全局变量。"

#: ../../library/doctest.rst:1136
msgid ""
"Optional argument *test_finder* is the :class:`DocTestFinder` object (or a "
"drop-in replacement) that is used to extract doctests from the module."
msgstr "可选参数 *test_finder* 是 :class:`DocTestFinder` 对象（或一个可替换的对象），用于从模块中提取测试。"

#: ../../library/doctest.rst:1139
msgid ""
"Optional arguments *setUp*, *tearDown*, and *optionflags* are the same as "
"for function :func:`DocFileSuite` above, but they are called for each "
"docstring."
msgstr ""
"可选参数 *setUp*, *tearDown* 和 *optionflags* 与上述函数 :func:`DocFileSuite` "
"的相同，但它们会针对每个文档字符串来调用。"

#: ../../library/doctest.rst:1142
msgid "This function uses the same search technique as :func:`testmod`."
msgstr "这个函数使用与 :func:`testmod` 相同的搜索技术。"

#: ../../library/doctest.rst:1144
msgid ""
":func:`DocTestSuite` returns an empty :class:`unittest.TestSuite` if "
"*module* contains no docstrings instead of raising :exc:`ValueError`."
msgstr ""
"如果 *module* 不包含任何文件串，则 :func:`DocTestSuite` 返回一个空的 "
":class:`unittest.TestSuite`，而不是触发 :exc:`ValueError`。"

#: ../../library/doctest.rst:1148
msgid ""
"Under the covers, :func:`DocTestSuite` creates a :class:`unittest.TestSuite`"
" out of :class:`!doctest.DocTestCase` instances, and :class:`!DocTestCase` "
"is a subclass of :class:`unittest.TestCase`. :class:`!DocTestCase` isn't "
"documented here (it's an internal detail), but studying its code can answer "
"questions about the exact details of :mod:`unittest` integration."
msgstr ""
"在内部，:func:`DocTestSuite` 将根据 :class:`!doctest.DocTestCase` 实例创建 "
":class:`unittest.TestSuite`，而 :class:`!DocTestCase` 是 "
":class:`unittest.TestCase` 的子类。 :class:`!DocTestCase` "
"没有记入本文档（它属于内部细节），但研究其代码可以回答有关 :mod:`unittest` 集成的准确细节的问题。"

#: ../../library/doctest.rst:1154
msgid ""
"Similarly, :func:`DocFileSuite` creates a :class:`unittest.TestSuite` out of"
" :class:`!doctest.DocFileCase` instances, and :class:`!DocFileCase` is a "
"subclass of :class:`!DocTestCase`."
msgstr ""
"类似地，:func:`DocFileSuite` 将根据 :class:`!doctest.DocFileCase` 实例创建 "
":class:`unittest.TestSuite`，而 :class:`!DocFileCase` 是 :class:`!DocTestCase` "
"的子类。"

#: ../../library/doctest.rst:1158
msgid ""
"So both ways of creating a :class:`unittest.TestSuite` run instances of "
":class:`!DocTestCase`.  This is important for a subtle reason: when you run "
":mod:`doctest` functions yourself, you can control the :mod:`!doctest` "
"options in use directly, by passing option flags to :mod:`!doctest` "
"functions.  However, if you're writing a :mod:`unittest` framework, "
":mod:`!unittest` ultimately controls when and how tests get run.  The "
"framework author typically wants to control :mod:`!doctest` reporting "
"options (perhaps, e.g., specified by command line options), but there's no "
"way to pass options through :mod:`!unittest` to :mod:`!doctest` test "
"runners."
msgstr ""
"因此这两种创建 :class:`unittest.TestSuite` 的方式都会运行 :class:`!DocTestCase` 的实例。 "
"出于一个微妙的理由这是很重要的：当你自己运行 :mod:`doctest` 的函数时，你可以直接控制使用中的 :mod:`!doctest` "
"选项，具体是通过传递选项旗标给 :mod:`!doctest` 的函数。 然而，如果你在编写一个 :mod:`unittest` 框架，则最终要由 "
":mod:`!unittest` 来控制测试的运行时间和方式。 框架作者通常希望控制 :mod:`!doctest` "
"的报告选项（例如，可能由命令行选项指定），但没有办法通过 :mod:`!unittest` 向 :mod:`!doctest` 测试的运行方传递选项。"

#: ../../library/doctest.rst:1168
msgid ""
"For this reason, :mod:`doctest` also supports a notion of :mod:`!doctest` "
"reporting flags specific to :mod:`unittest` support, via this function:"
msgstr ""
"出于这个原因，:mod:`doctest` 也支持also supports a notion of :mod:`!doctest` 报告专属于 "
":mod:`unittest` 支持的旗标的概念，具体是通过这个函数："

#: ../../library/doctest.rst:1174
msgid "Set the :mod:`doctest` reporting flags to use."
msgstr "设置要使用的 :mod:`doctest` 报告标志。"

#: ../../library/doctest.rst:1176
msgid ""
"Argument *flags* takes the :ref:`bitwise OR <bitwise>` of option flags.  See"
" section :ref:`doctest-options`.  Only \"reporting flags\" can be used."
msgstr ""
"参数 *flags* 是选项标志的 :ref:`bitwise OR <bitwise>` 。 参见章节 :ref:`doctest-options` "
"。 只有 \"报告标志\" 可以被使用。"

#: ../../library/doctest.rst:1179
msgid ""
"This is a module-global setting, and affects all future doctests run by "
"module :mod:`unittest`:  the :meth:`!runTest` method of "
":class:`!DocTestCase` looks at the option flags specified for the test case "
"when the :class:`!DocTestCase` instance was constructed.  If no reporting "
"flags were specified (which is the typical and expected case), "
":mod:`!doctest`'s :mod:`!unittest` reporting flags are :ref:`bitwise ORed "
"<bitwise>` into the option flags, and the option flags so augmented are "
"passed to the :class:`DocTestRunner` instance created to run the doctest.  "
"If any reporting flags were specified when the :class:`!DocTestCase` "
"instance was constructed, :mod:`!doctest`'s :mod:`!unittest` reporting flags"
" are ignored."
msgstr ""
"这是模块全局的设置，并会影响 :mod:`unittest` 模块未来运行的所有文档测试: :class:`!DocTestCase` 的 "
":meth:`!runTest` 方法会查看 :class:`!DocTestCase` 实例构建时为测试用例指定的选项旗标。 "
"如果没有指定报告旗标（这是典型且符合预期的情况），则 :mod:`!doctest` 的 :mod:`!unittest` 报告旗标将与选项旗标进行 "
":ref:`按位或运算 <bitwise>`，经过增强的选项旗标将被传递给为运行文档测试而创建的 :class:`DocTestRunner` 实例。 "
"如果在构造 :class:`!DocTestCase` 实例时指定了任何报告旗标，则 :mod:`!doctest` 的 "
":mod:`!unittest` 报告旗标将被忽略。"

#: ../../library/doctest.rst:1190
msgid ""
"The value of the :mod:`unittest` reporting flags in effect before the "
"function was called is returned by the function."
msgstr ":mod:`unittest` 报告标志的值在调用该函数之前是有效的，由该函数返回。"

#: ../../library/doctest.rst:1197
msgid "Advanced API"
msgstr "高级 API"

#: ../../library/doctest.rst:1199
msgid ""
"The basic API is a simple wrapper that's intended to make doctest easy to "
"use. It is fairly flexible, and should meet most users' needs; however, if "
"you require more fine-grained control over testing, or wish to extend "
"doctest's capabilities, then you should use the advanced API."
msgstr ""
"基本 API 是一个简单的封装，旨在使 doctest "
"易于使用。它相当灵活，应该能满足大多数用户的需求；但是，如果你需要对测试进行更精细的控制，或者希望扩展 doctest 的功能，那么你应该使用高级 "
"API 。"

#: ../../library/doctest.rst:1204
msgid ""
"The advanced API revolves around two container classes, which are used to "
"store the interactive examples extracted from doctest cases:"
msgstr "高级API围绕着两个容器类，用于存储从 doctest 案例中提取的交互式用例:"

#: ../../library/doctest.rst:1207
msgid ""
":class:`Example`: A single Python :term:`statement`, paired with its "
"expected output."
msgstr ":class:`Example`: 一个单一的 Python :term:`statement` ，与它的预期输出配对。"

#: ../../library/doctest.rst:1210
msgid ""
":class:`DocTest`: A collection of :class:`Example`\\ s, typically extracted "
"from a single docstring or text file."
msgstr ":class:`DocTest`: 一组 :class:`Example`\\ s 的集合，通常从一个文档字符串或文本文件中提取。"

#: ../../library/doctest.rst:1213
msgid ""
"Additional processing classes are defined to find, parse, and run, and check"
" doctest examples:"
msgstr "定义了额外的处理类来寻找、解析和运行，并检查 doctest 的用例。"

#: ../../library/doctest.rst:1216
msgid ""
":class:`DocTestFinder`: Finds all docstrings in a given module, and uses a "
":class:`DocTestParser` to create a :class:`DocTest` from every docstring "
"that contains interactive examples."
msgstr ""
":class:`DocTestFinder` : 查找给定模块中的所有文档串，并使用 :class:`DocTestParser` "
"从每个包含交互式用例的文档串中创建一个 :class:`DocTest` 。"

#: ../../library/doctest.rst:1220
msgid ""
":class:`DocTestParser`: Creates a :class:`DocTest` object from a string "
"(such as an object's docstring)."
msgstr ":class:`DocTestParser` : 从一个字符串（如一个对象的文档串）创建一个 :class:`DocTest` 对象。"

#: ../../library/doctest.rst:1223
msgid ""
":class:`DocTestRunner`: Executes the examples in a :class:`DocTest`, and "
"uses an :class:`OutputChecker` to verify their output."
msgstr ""
":class:`DocTestRunner` : 执行 :class:`DocTest` 中的用例，并使用 :class:`OutputChecker`"
" 来验证其输出。"

#: ../../library/doctest.rst:1226
msgid ""
":class:`OutputChecker`: Compares the actual output from a doctest example "
"with the expected output, and decides whether they match."
msgstr ":class:`OutputChecker` : 将一个测试用例的实际输出与预期输出进行比较，并决定它们是否匹配。"

#: ../../library/doctest.rst:1229
msgid ""
"The relationships among these processing classes are summarized in the "
"following diagram::"
msgstr "这些处理类之间的关系总结在下图中::"

#: ../../library/doctest.rst:1232
msgid ""
"                            list of:\n"
"+------+                   +---------+\n"
"|module| --DocTestFinder-> | DocTest | --DocTestRunner-> results\n"
"+------+    |        ^     +---------+     |       ^    (printed)\n"
"            |        |     | Example |     |       |\n"
"            v        |     |   ...   |     v       |\n"
"           DocTestParser   | Example |   OutputChecker\n"
"                           +---------+"
msgstr ""
"                            list of:\n"
"+------+                   +---------+\n"
"|module| --DocTestFinder-> | DocTest | --DocTestRunner-> results\n"
"+------+    |        ^     +---------+     |       ^    (printed)\n"
"            |        |     | Example |     |       |\n"
"            v        |     |   ...   |     v       |\n"
"           DocTestParser   | Example |   OutputChecker\n"
"                           +---------+"

#: ../../library/doctest.rst:1245
msgid "DocTest Objects"
msgstr "DocTest 对象"

#: ../../library/doctest.rst:1250
msgid ""
"A collection of doctest examples that should be run in a single namespace.  "
"The constructor arguments are used to initialize the attributes of the same "
"names."
msgstr "应该在单一命名空间中运行的doctest用例的集合。构造函数参数被用来初始化相同名称的属性。"

#: ../../library/doctest.rst:1254
msgid ""
":class:`DocTest` defines the following attributes.  They are initialized by "
"the constructor, and should not be modified directly."
msgstr ":class:`DocTest` 定义了以下属性。 它们由构造函数初始化，不应该被直接修改。"

#: ../../library/doctest.rst:1260
msgid ""
"A list of :class:`Example` objects encoding the individual interactive "
"Python examples that should be run by this test."
msgstr "一个 :class:`Example` 对象的列表，它编码了应该由该测试运行的单个交互式 Python 用例。"

#: ../../library/doctest.rst:1266
msgid ""
"The namespace (aka globals) that the examples should be run in. This is a "
"dictionary mapping names to values.  Any changes to the namespace made by "
"the examples (such as binding new variables) will be reflected in "
":attr:`globs` after the test is run."
msgstr ""
"例子应该运行的命名空间（又称 globals ）。这是一个将名字映射到数值的字典。例子对名字空间的任何改变（比如绑定新的变量）将在测试运行后反映在 "
":attr:`globs` 中。"

#: ../../library/doctest.rst:1274
msgid ""
"A string name identifying the :class:`DocTest`.  Typically, this is the name"
" of the object or file that the test was extracted from."
msgstr "识别 :class:`DocTest` 的字符串名称。 通常情况下，这是从测试中提取的对象或文件的名称。"

#: ../../library/doctest.rst:1280
msgid ""
"The name of the file that this :class:`DocTest` was extracted from; or "
"``None`` if the filename is unknown, or if the :class:`!DocTest` was not "
"extracted from a file."
msgstr ""
"该 :class:`DocTest` 所属文件的名称；或者如果文件名未知、或 :class:`!DocTest` 不是从文件中提取的则为 "
"``None``。"

#: ../../library/doctest.rst:1287
msgid ""
"The line number within :attr:`filename` where this :class:`DocTest` begins, "
"or ``None`` if the line number is unavailable.  This line number is zero-"
"based with respect to the beginning of the file."
msgstr ""
":attr:`filename` 中的行号，这个 :class:`DocTest` 开始的地方，或者行号不可用时为 ``None``。 "
"这个行号相对于文件的开头来说是零的。"

#: ../../library/doctest.rst:1294
msgid ""
"The string that the test was extracted from, or ``None`` if the string is "
"unavailable, or if the test was not extracted from a string."
msgstr "从测试中提取的字符串，或者如果字符串不可用，或者为 ``None`` ，如果测试没有从字符串中提取。"

#: ../../library/doctest.rst:1301
msgid "Example Objects"
msgstr "Example 对象"

#: ../../library/doctest.rst:1306
msgid ""
"A single interactive example, consisting of a Python statement and its "
"expected output.  The constructor arguments are used to initialize the "
"attributes of the same names."
msgstr "单个交互式用例，由一个 Python 语句及其预期输出组成。 构造函数参数被用来初始化相同名称的属性。"

#: ../../library/doctest.rst:1311
msgid ""
":class:`Example` defines the following attributes.  They are initialized by "
"the constructor, and should not be modified directly."
msgstr ":class:`Example` 定义了以下属性。 它们由构造函数初始化，不应该被直接修改。"

#: ../../library/doctest.rst:1317
msgid ""
"A string containing the example's source code.  This source code consists of"
" a single Python statement, and always ends with a newline; the constructor "
"adds a newline when necessary."
msgstr "一个包含该用例源码的字符串。 源码由一个 Python 语句组成，并且总是以换行结束；构造函数在必要时添加一个换行。"

#: ../../library/doctest.rst:1324
msgid ""
"The expected output from running the example's source code (either from "
"stdout, or a traceback in case of exception).  :attr:`want` ends with a "
"newline unless no output is expected, in which case it's an empty string.  "
"The constructor adds a newline when necessary."
msgstr ""
"运行这个用例的源码的预期输出（可以是 stdout ，也可以是异常情况下的回溯）。 :attr:`want` "
"以一个换行符结束，除非没有预期的输出，在这种情况下它是一个空字符串。 构造函数在必要时添加一个换行。"

#: ../../library/doctest.rst:1332
msgid ""
"The exception message generated by the example, if the example is expected "
"to generate an exception; or ``None`` if it is not expected to generate an "
"exception.  This exception message is compared against the return value of "
":func:`traceback.format_exception_only`.  :attr:`exc_msg` ends with a "
"newline unless it's ``None``.  The constructor adds a newline if needed."
msgstr ""
"用例产生的异常信息，如果这个例子被期望产生一个异常；或者为 ``None`` ，如果它不被期望产生一个异常。 这个异常信息与 "
":func:`traceback.format_exception_only` 的返回值进行比较。 :attr:`exc_msg` 以换行结束，除非是 "
"``None`` 。"

#: ../../library/doctest.rst:1341
msgid ""
"The line number within the string containing this example where the example "
"begins.  This line number is zero-based with respect to the beginning of the"
" containing string."
msgstr "包含本例的字符串中的行号，即本例的开始。 这个行号相对于包含字符串的开头来说是以零开始的。"

#: ../../library/doctest.rst:1348
msgid ""
"The example's indentation in the containing string, i.e., the number of "
"space characters that precede the example's first prompt."
msgstr "用例在包含字符串中的缩进，即在用例的第一个提示前有多少个空格字符。"

#: ../../library/doctest.rst:1354
msgid ""
"A dictionary mapping from option flags to ``True`` or ``False``, which is "
"used to override default options for this example.  Any option flags not "
"contained in this dictionary are left at their default value (as specified "
"by the :class:`DocTestRunner`'s :ref:`optionflags <doctest-options>`). By "
"default, no options are set."
msgstr ""
"一个将选项旗标映射到 ``True`` 或 ``False`` 的字典，用于覆盖这个例子的默认选项。 "
"任何不包含在这个字典中的选项旗标都将保持其默认值（由 :class:`DocTestRunner` 的 :ref:`optionflags "
"<doctest-options>` 指定）。 默认情况下，将不设置任何选项。"

#: ../../library/doctest.rst:1364
msgid "DocTestFinder objects"
msgstr "DocTestFinder 对象"

#: ../../library/doctest.rst:1369
msgid ""
"A processing class used to extract the :class:`DocTest`\\ s that are "
"relevant to a given object, from its docstring and the docstrings of its "
"contained objects. :class:`DocTest`\\ s can be extracted from modules, "
"classes, functions, methods, staticmethods, classmethods, and properties."
msgstr ""
"一个处理类，用于从一个给定的对象的 docstring 和其包含的对象的 docstring 中提取与之相关的 :class:`DocTest` 。 "
":class:`DocTest` 可以从模块、类、函数、方法、静态方法、类方法和属性中提取。"

#: ../../library/doctest.rst:1374
msgid ""
"The optional argument *verbose* can be used to display the objects searched "
"by the finder.  It defaults to ``False`` (no output)."
msgstr "可选的参数 *verbose* 可以用来显示查找器搜索到的对象。 它的默认值是 ``False`` （无输出）。"

#: ../../library/doctest.rst:1377
msgid ""
"The optional argument *parser* specifies the :class:`DocTestParser` object "
"(or a drop-in replacement) that is used to extract doctests from docstrings."
msgstr ""
"可选的参数 *parser* 指定了 :class:`DocTestParser` 对象（或一个可替换的对象），用于从文档串中提取 doctest 。"

#: ../../library/doctest.rst:1380
msgid ""
"If the optional argument *recurse* is false, then :meth:`DocTestFinder.find`"
" will only examine the given object, and not any contained objects."
msgstr ""
"如果可选的参数 *recurse* 是 False ，那么 :meth:`DocTestFinder.find` "
"将只检查给定的对象，而不是任何包含的对象。"

#: ../../library/doctest.rst:1383
msgid ""
"If the optional argument *exclude_empty* is false, then "
":meth:`DocTestFinder.find` will include tests for objects with empty "
"docstrings."
msgstr ""
"如果可选参数 *exclude_empty* 为 False ，那么 :meth:`DocTestFinder.find` "
"将包括对文档字符串为空的对象的测试。"

#: ../../library/doctest.rst:1387
msgid ":class:`DocTestFinder` defines the following method:"
msgstr ":class:`DocTestFinder` 定义了以下方法："

#: ../../library/doctest.rst:1392
msgid ""
"Return a list of the :class:`DocTest`\\ s that are defined by *obj*'s "
"docstring, or by any of its contained objects' docstrings."
msgstr "返回 :class:`DocTest` 的列表，该列表由 *obj* 的文档串或其包含的任何对象的文档串定义。"

#: ../../library/doctest.rst:1395
msgid ""
"The optional argument *name* specifies the object's name; this name will be "
"used to construct names for the returned :class:`DocTest`\\ s.  If *name* is"
" not specified, then ``obj.__name__`` is used."
msgstr ""
"可选参数 *name* 指定了对象的名称；这个名称将被用来为返回的 :class:`DocTest` 构建名称。 如果没有指定 *name* ，则使用 "
"``obj.__name__`` 。"

#: ../../library/doctest.rst:1399
msgid ""
"The optional parameter *module* is the module that contains the given "
"object. If the module is not specified or is ``None``, then the test finder "
"will attempt to automatically determine the correct module.  The object's "
"module is used:"
msgstr ""
"可选参数 *module* 是包含给定对象的模块。如果没有指定模块或者是 ``None`` ，那么测试查找器将试图自动确定正确的模块。 "
"该对象被使用的模块："

#: ../../library/doctest.rst:1403
msgid "As a default namespace, if *globs* is not specified."
msgstr "作为一个默认的命名空间，如果没有指定 *globs* 。"

#: ../../library/doctest.rst:1405
msgid ""
"To prevent the DocTestFinder from extracting DocTests from objects that are "
"imported from other modules.  (Contained objects with modules other than "
"*module* are ignored.)"
msgstr ""
"为了防止 DocTestFinder 从其他模块导入的对象中提取 DocTest 。 (包含有除 *module* 以外的模块的对象会被忽略)。"

#: ../../library/doctest.rst:1409
msgid "To find the name of the file containing the object."
msgstr "找到包含该对象的文件名。"

#: ../../library/doctest.rst:1411
msgid "To help find the line number of the object within its file."
msgstr "找到该对象在其文件中的行号。"

#: ../../library/doctest.rst:1413
msgid ""
"If *module* is ``False``, no attempt to find the module will be made.  This "
"is obscure, of use mostly in testing doctest itself: if *module* is "
"``False``, or is ``None`` but cannot be found automatically, then all "
"objects are considered to belong to the (non-existent) module, so all "
"contained objects will (recursively) be searched for doctests."
msgstr ""
"如果 *module* 是 ``False`` ，将不会试图找到这个模块。 这是不明确的，主要用于测试 doctest 本身：如果 *module* 是"
" ``False`` ，或者是 ``None`` 但不能自动找到，那么所有对象都被认为属于（不存在的）模块，所以所有包含的对象将（递归地）被搜索到 "
"doctest 。"

#: ../../library/doctest.rst:1419
msgid ""
"The globals for each :class:`DocTest` is formed by combining *globs* and "
"*extraglobs* (bindings in *extraglobs* override bindings in *globs*).  A new"
" shallow copy of the globals dictionary is created for each "
":class:`!DocTest`. If *globs* is not specified, then it defaults to the "
"module's :attr:`~module.__dict__`, if specified, or ``{}`` otherwise. If "
"*extraglobs* is not specified, then it defaults to ``{}``."
msgstr ""
"每个 :class:`DocTest` 的全局变量是由 *globs* 和 *extraglobs* 合并组成的（在 *extraglobs* "
"中的绑定会覆盖 *globs* 中的绑定）。 针对每个).  A new shallow copy of the globals dictionary "
"is created for each :class:`!DocTest` 将会新建一个全局字典的浅拷贝。 如果未指定 *globs*，则它默认为模块的"
" :attr:`~module.__dict__`，如果指定了该属性，未指定该属性则为 ``{}``。 如果未指定 *extraglobs*，则它默认为"
" ``{}``。"

#: ../../library/doctest.rst:1430
msgid "DocTestParser objects"
msgstr "DocTestParser 对象"

#: ../../library/doctest.rst:1435
msgid ""
"A processing class used to extract interactive examples from a string, and "
"use them to create a :class:`DocTest` object."
msgstr "一个处理类，用于从一个字符串中提取交互式的用例，并使用它们来创建一个 :class:`DocTest` 对象。"

#: ../../library/doctest.rst:1439
msgid ":class:`DocTestParser` defines the following methods:"
msgstr ":class:`DocTestParser` 定义了以下方法："

#: ../../library/doctest.rst:1444
msgid ""
"Extract all doctest examples from the given string, and collect them into a "
":class:`DocTest` object."
msgstr "从给定的字符串中提取所有的测试用例，并将它们收集到一个 :class:`DocTest` 对象中。"

#: ../../library/doctest.rst:1447
msgid ""
"*globs*, *name*, *filename*, and *lineno* are attributes for the new "
":class:`!DocTest` object.  See the documentation for :class:`DocTest` for "
"more information."
msgstr ""
"*globs*, *name*, *filename* 和 *lineno* 是新的 :class:`!DocTest` 对象的属性。 请参阅 "
":class:`DocTest` 的文档了解详情。"

#: ../../library/doctest.rst:1454
msgid ""
"Extract all doctest examples from the given string, and return them as a "
"list of :class:`Example` objects.  Line numbers are 0-based.  The optional "
"argument *name* is a name identifying this string, and is only used for "
"error messages."
msgstr ""
"从给定的字符串中提取所有的测试用例，并以 :class:`Example` 对象列表的形式返回。 行数以 0 为基数。 可选参数 *name* "
"用于识别这个字符串的名称，只用于错误信息。"

#: ../../library/doctest.rst:1461
msgid ""
"Divide the given string into examples and intervening text, and return them "
"as a list of alternating :class:`Example`\\ s and strings. Line numbers for "
"the :class:`!Example`\\ s are 0-based.  The optional argument *name* is a "
"name identifying this string, and is only used for error messages."
msgstr ""
"将给定的字符串划分为样例和中间文本，并以 :class:`Example` 和字符串交替的列表形式返回。 :class:`!Example` 的行号是从"
" 0 开始的。 可选参数 *name* 是标识该字符串的名称，它仅用于错误消息。"

#: ../../library/doctest.rst:1468
msgid "TestResults objects"
msgstr "TestResults 对象"

#: ../../library/doctest.rst:1475
msgid "Number of failed tests."
msgstr "失败的测试数量。"

#: ../../library/doctest.rst:1479
msgid "Number of attempted tests."
msgstr "执行的测试数量。"

#: ../../library/doctest.rst:1483
msgid "Number of skipped tests."
msgstr "跳过的测试数量。"

#: ../../library/doctest.rst:1491
msgid "DocTestRunner objects"
msgstr "DocTestRunner 对象"

#: ../../library/doctest.rst:1496
msgid ""
"A processing class used to execute and verify the interactive examples in a "
":class:`DocTest`."
msgstr "一个处理类，用于执行和验证 :class:`DocTest` 中的交互式用例。"

#: ../../library/doctest.rst:1499
msgid ""
"The comparison between expected outputs and actual outputs is done by an "
":class:`OutputChecker`.  This comparison may be customized with a number of "
"option flags; see section :ref:`doctest-options` for more information.  If "
"the option flags are insufficient, then the comparison may also be "
"customized by passing a subclass of :class:`!OutputChecker` to the "
"constructor."
msgstr ""
"预期的输出和实际的输出之间的比较是由 :class:`OutputChecker` 来完成的。 这种比较可以通过一些选项旗标来自定义；请参阅 "
":ref:`doctest-options` 小节了解详情。 如果这些选项旗标不够用，那么也可以通过向构造器传入一个 "
":class:`!OutputChecker` 的子类来自定义比较操作。"

#: ../../library/doctest.rst:1505
msgid ""
"The test runner's display output can be controlled in two ways. First, an "
"output function can be passed to :meth:`run`; this function will be called "
"with strings that should be displayed.  It defaults to ``sys.stdout.write``."
"  If capturing the output is not sufficient, then the display output can be "
"also customized by subclassing DocTestRunner, and overriding the methods "
":meth:`report_start`, :meth:`report_success`, "
":meth:`report_unexpected_exception`, and :meth:`report_failure`."
msgstr ""
"测试运行器的显示输出可以通过两种方式来控制。 首先，一个输出函数可以被传递给 :meth:`run`；这个函数将被调用并传入要显示的字符串。 默认使用 "
"``sys.stdout.write``。 如果捕获输出是不够的，那么也可以通过子类化 DocTestRunner，并重写 "
":meth:`report_start`, :meth:`report_success`, "
":meth:`report_unexpected_exception` 和 :meth:`report_failure` 等方法来定制显示输出。"

#: ../../library/doctest.rst:1513
msgid ""
"The optional keyword argument *checker* specifies the :class:`OutputChecker`"
" object (or drop-in replacement) that should be used to compare the expected"
" outputs to the actual outputs of doctest examples."
msgstr ""
"可选的关键字参数 *checker* 指定了 :class:`OutputChecker` 对象（或其相似替换），它应该被用来比较预期输出和 "
"doctest 用例的实际输出。"

#: ../../library/doctest.rst:1517
msgid ""
"The optional keyword argument *verbose* controls the "
":class:`DocTestRunner`'s verbosity.  If *verbose* is ``True``, then "
"information is printed about each example, as it is run.  If *verbose* is "
"``False``, then only failures are printed.  If *verbose* is unspecified, or "
"``None``, then verbose output is used iff the command-line switch ``-v`` is "
"used."
msgstr ""
"可选的关键字参数 *verbose* 控制 :class:`DocTestRunner` 的详细程度。 如果 *verbose* 是 ``True`` "
"，那么每个用例的信息都会被打印出来，当它正在运行时。 如果 *verbose* 是 ``False`` ，则只打印失败的信息。 当 *verbose* "
"没有指定，或者为 ``None`` ，如果使用了命令行开关 ``-v`` ，则使用verbose输出。"

#: ../../library/doctest.rst:1523
msgid ""
"The optional keyword argument *optionflags* can be used to control how the "
"test runner compares expected output to actual output, and how it displays "
"failures. For more information, see section :ref:`doctest-options`."
msgstr ""
"可选的关键字参数 *optionflags* 可以用来控制测试运行器如何比较预期输出和实际输出，以及如何显示失败。更多信息，请参见章节 "
":ref:`doctest-options` 。"

#: ../../library/doctest.rst:1527
msgid ""
"The test runner accumulates statistics. The aggregated number of attempted, "
"failed and skipped examples is also available via the :attr:`tries`, "
":attr:`failures` and :attr:`skips` attributes. The :meth:`run` and "
":meth:`summarize` methods return a :class:`TestResults` instance."
msgstr ""
"测试运行将累积统计数据。 已尝试、已失败和已跳过的示例的聚合计数也可通过 :attr:`tries`, :attr:`failures` 和 "
":attr:`skips` 属性来获取。 :meth:`run` 和 :meth:`summarize` 方法将返回一个 "
":class:`TestResults` 实例。"

#: ../../library/doctest.rst:1532
msgid ":class:`DocTestRunner` defines the following methods:"
msgstr ":class:`DocTestRunner` 定义了以下方法："

#: ../../library/doctest.rst:1537
msgid ""
"Report that the test runner is about to process the given example. This "
"method is provided to allow subclasses of :class:`DocTestRunner` to "
"customize their output; it should not be called directly."
msgstr ""
"报告测试运行器即将处理给定的用例。提供这个方法是为了让 :class:`DocTestRunner` 的子类能够定制他们的输出；它不应该被直接调用。"

#: ../../library/doctest.rst:1541
msgid ""
"*example* is the example about to be processed.  *test* is the test "
"containing *example*.  *out* is the output function that was passed to "
":meth:`DocTestRunner.run`."
msgstr ""
"*example* 是即将被处理的例子。 *test* 是包含 *example* 的测试。 *out* 是传给 "
":meth:`DocTestRunner.run` 的输出函数。"

#: ../../library/doctest.rst:1548
msgid ""
"Report that the given example ran successfully.  This method is provided to "
"allow subclasses of :class:`DocTestRunner` to customize their output; it "
"should not be called directly."
msgstr ""
"报告给定的用例运行成功。 提供这个方法是为了让 :class:`DocTestRunner` 的子类能够定制他们的输出；它不应该被直接调用。"

#: ../../library/doctest.rst:1552 ../../library/doctest.rst:1563
msgid ""
"*example* is the example about to be processed.  *got* is the actual output "
"from the example.  *test* is the test containing *example*.  *out* is the "
"output function that was passed to :meth:`DocTestRunner.run`."
msgstr ""
"*example* 是即将被处理的用例。 *got* 是这个例子的实际输出。 *test* 是包含 *example* 的测试。 *out* 是传递给 "
":meth:`DocTestRunner.run` 的输出函数。"

#: ../../library/doctest.rst:1559
msgid ""
"Report that the given example failed.  This method is provided to allow "
"subclasses of :class:`DocTestRunner` to customize their output; it should "
"not be called directly."
msgstr ""
"报告给定的用例运行失败。 提供这个方法是为了让 :class:`DocTestRunner` 的子类能够定制他们的输出；它不应该被直接调用。"

#: ../../library/doctest.rst:1570
msgid ""
"Report that the given example raised an unexpected exception. This method is"
" provided to allow subclasses of :class:`DocTestRunner` to customize their "
"output; it should not be called directly."
msgstr ""
"报告给定的用例触发了一个异常。 提供这个方法是为了让 :class:`DocTestRunner` 的子类能够定制他们的输出；它不应该被直接调用。"

#: ../../library/doctest.rst:1574
msgid ""
"*example* is the example about to be processed. *exc_info* is a tuple "
"containing information about the unexpected exception (as returned by "
":func:`sys.exc_info`). *test* is the test containing *example*.  *out* is "
"the output function that was passed to :meth:`DocTestRunner.run`."
msgstr ""
"*example* 是将要被处理的用例。 *exc_info* 是一个元组，包含关于异常的信息（如由 :func:`sys.exc_info` 返回）。"
" *test* 是包含 *example* 的测试。 *out* 是传递给 :meth:`DocTestRunner.run` 的输出函数。"

#: ../../library/doctest.rst:1582
msgid ""
"Run the examples in *test* (a :class:`DocTest` object), and display the "
"results using the writer function *out*. Return a :class:`TestResults` "
"instance."
msgstr ""
"运行 *test* (一个 :class:`DocTest` 对象) 中的示例，并使用写入函数 *out* 显示结果。 返回一个 "
":class:`TestResults` 实例。"

#: ../../library/doctest.rst:1586
msgid ""
"The examples are run in the namespace ``test.globs``.  If *clear_globs* is "
"true (the default), then this namespace will be cleared after the test runs,"
" to help with garbage collection. If you would like to examine the namespace"
" after the test completes, then use *clear_globs=False*."
msgstr ""
"这些用例都是在命名空间 ``test.globs`` 中运行的。 如果 *clear_globs* 为 True "
"（默认），那么这个命名空间将在测试运行后被清除，以帮助进行垃圾回收。如果你想在测试完成后检查命名空间，那么使用 *clear_globs=False* "
"。"

#: ../../library/doctest.rst:1591
msgid ""
"*compileflags* gives the set of flags that should be used by the Python "
"compiler when running the examples.  If not specified, then it will default "
"to the set of future-import flags that apply to *globs*."
msgstr ""
"*compileflags* 给出了 Python 编译器在运行例子时应该使用的标志集。如果没有指定，那么它将默认为适用于 *globs* 的 "
"future-import 标志集。"

#: ../../library/doctest.rst:1595
msgid ""
"The output of each example is checked using the :class:`DocTestRunner`'s "
"output checker, and the results are formatted by the "
":meth:`!DocTestRunner.report_\\*` methods."
msgstr ""
"每个例子的输出都使用The output of each example is checked using the "
":class:`DocTestRunner` 的输出检查器进行检查，并且结果将由 :meth:`!DocTestRunner.report_\\*` "
"方法来格式化。"

#: ../../library/doctest.rst:1602
msgid ""
"Print a summary of all the test cases that have been run by this "
"DocTestRunner, and return a :class:`TestResults` instance."
msgstr "打印这个 DocTestRunner 运行过的所有测试用例的概要，并返回一个 :class:`TestResults` 实例。"

#: ../../library/doctest.rst:1605
msgid ""
"The optional *verbose* argument controls how detailed the summary is.  If "
"the verbosity is not specified, then the :class:`DocTestRunner`'s verbosity "
"is used."
msgstr ""
"可选的 *verbose* 参数控制摘要的详细程度。 如果没有指定 verbose ，那么将使用 :class:`DocTestRunner` 的 "
"verbose 。"

#: ../../library/doctest.rst:1609
msgid ":class:`DocTestParser` has the following attributes:"
msgstr ":class:`DocTestParser` 具有下列属性："

#: ../../library/doctest.rst:1613
msgid "Number of attempted examples."
msgstr "尝试的示例数量。"

#: ../../library/doctest.rst:1617
msgid "Number of failed examples."
msgstr "失败的示例数量。"

#: ../../library/doctest.rst:1621
msgid "Number of skipped examples."
msgstr "跳过的示例数量。"

#: ../../library/doctest.rst:1629
msgid "OutputChecker objects"
msgstr "OutputChecker 对象"

#: ../../library/doctest.rst:1634
msgid ""
"A class used to check the whether the actual output from a doctest example "
"matches the expected output.  :class:`OutputChecker` defines two methods: "
":meth:`check_output`, which compares a given pair of outputs, and returns "
"``True`` if they match; and :meth:`output_difference`, which returns a "
"string describing the differences between two outputs."
msgstr ""
"一个用于检查测试用例的实际输出是否与预期输出相匹配的类。 :class:`OutputChecker` 定义了两个方法： "
":meth:`check_output` ，比较给定的一对输出，如果它们匹配则返回 ``True`` ； "
":meth:`output_difference` ，返回一个描述两个输出之间差异的字符串。"

#: ../../library/doctest.rst:1641
msgid ":class:`OutputChecker` defines the following methods:"
msgstr ":class:`OutputChecker` 定义了以下方法："

#: ../../library/doctest.rst:1645
msgid ""
"Return ``True`` iff the actual output from an example (*got*) matches the "
"expected output (*want*).  These strings are always considered to match if "
"they are identical; but depending on what option flags the test runner is "
"using, several non-exact match types are also possible.  See section "
":ref:`doctest-options` for more information about option flags."
msgstr ""
"如果一个用例的实际输出（ *got* ）与预期输出（ *want* ）匹配，则返回 ``True`` 。 "
"如果这些字符串是相同的，总是被认为是匹配的；但是根据测试运行器使用的选项标志，也可能有几种非精确的匹配类型。 参见章节 :ref:`doctest-"
"options` 了解更多关于选项标志的信息。"

#: ../../library/doctest.rst:1654
msgid ""
"Return a string describing the differences between the expected output for a"
" given example (*example*) and the actual output (*got*).  *optionflags* is "
"the set of option flags used to compare *want* and *got*."
msgstr ""
"返回一个字符串，描述给定用例（ *example* ）的预期输出和实际输出（ *got* ）之间的差异。  *optionflags* 是用于比较 "
"*want* 和 *got* 的选项标志集。"

#: ../../library/doctest.rst:1662
msgid "Debugging"
msgstr "调试"

#: ../../library/doctest.rst:1664
msgid "Doctest provides several mechanisms for debugging doctest examples:"
msgstr "Doctest 提供了几种调试 doctest 用例的机制："

#: ../../library/doctest.rst:1666
msgid ""
"Several functions convert doctests to executable Python programs, which can "
"be run under the Python debugger, :mod:`pdb`."
msgstr "有几个函数将测试转换为可执行的 Python 程序，这些程序可以在 Python 调试器， :mod:`pdb` 下运行。"

#: ../../library/doctest.rst:1669
msgid ""
"The :class:`DebugRunner` class is a subclass of :class:`DocTestRunner` that "
"raises an exception for the first failing example, containing information "
"about that example. This information can be used to perform post-mortem "
"debugging on the example."
msgstr ""
":class:`DebugRunner` 类是 :class:`DocTestRunner` "
"的一个子类，它为第一个失败的用例触发一个异常，包含关于这个用例的信息。这些信息可以用来对这个用例进行事后调试。"

#: ../../library/doctest.rst:1674
msgid ""
"The :mod:`unittest` cases generated by :func:`DocTestSuite` support the "
":meth:`debug` method defined by :class:`unittest.TestCase`."
msgstr ""
"由 :func:`DocTestSuite` 生成的 :mod:`unittest` 用例支持由 :class:`unittest.TestCase` "
"定义的 :meth:`debug` 方法，。"

#: ../../library/doctest.rst:1677
msgid ""
"You can add a call to :func:`pdb.set_trace` in a doctest example, and you'll"
" drop into the Python debugger when that line is executed.  Then you can "
"inspect current values of variables, and so on.  For example, suppose "
":file:`a.py` contains just this module docstring::"
msgstr ""
"你可以在 doctest 的用例中加入对 :func:`pdb.set_trace` 的调用，当这一行被执行时，你会进入 Python 调试器。 "
"然后你可以检查变量的当前值，等等。 例如，假设 :file:`a.py` 只包含这个模块 docstring ::"

#: ../../library/doctest.rst:1682
msgid ""
"\"\"\"\n"
">>> def f(x):\n"
"...     g(x*2)\n"
">>> def g(x):\n"
"...     print(x+3)\n"
"...     import pdb; pdb.set_trace()\n"
">>> f(3)\n"
"9\n"
"\"\"\""
msgstr ""
"\"\"\"\n"
">>> def f(x):\n"
"...     g(x*2)\n"
">>> def g(x):\n"
"...     print(x+3)\n"
"...     import pdb; pdb.set_trace()\n"
">>> f(3)\n"
"9\n"
"\"\"\""

#: ../../library/doctest.rst:1692
msgid "Then an interactive Python session may look like this::"
msgstr "那么一个交互式Python会话可能是这样的::"

#: ../../library/doctest.rst:1694
msgid ""
">>> import a, doctest\n"
">>> doctest.testmod(a)\n"
"--Return--\n"
"> <doctest a[1]>(3)g()->None\n"
"-> import pdb; pdb.set_trace()\n"
"(Pdb) list\n"
"  1     def g(x):\n"
"  2         print(x+3)\n"
"  3  ->     import pdb; pdb.set_trace()\n"
"[EOF]\n"
"(Pdb) p x\n"
"6\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[0]>(2)f()->None\n"
"-> g(x*2)\n"
"(Pdb) list\n"
"  1     def f(x):\n"
"  2  ->     g(x*2)\n"
"[EOF]\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[2]>(1)?()->None\n"
"-> f(3)\n"
"(Pdb) cont\n"
"(0, 3)\n"
">>>"
msgstr ""
">>> import a, doctest\n"
">>> doctest.testmod(a)\n"
"--Return--\n"
"> <doctest a[1]>(3)g()->None\n"
"-> import pdb; pdb.set_trace()\n"
"(Pdb) list\n"
"  1     def g(x):\n"
"  2         print(x+3)\n"
"  3  ->     import pdb; pdb.set_trace()\n"
"[EOF]\n"
"(Pdb) p x\n"
"6\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[0]>(2)f()->None\n"
"-> g(x*2)\n"
"(Pdb) list\n"
"  1     def f(x):\n"
"  2  ->     g(x*2)\n"
"[EOF]\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[2]>(1)?()->None\n"
"-> f(3)\n"
"(Pdb) cont\n"
"(0, 3)\n"
">>>"

#: ../../library/doctest.rst:1725
msgid ""
"Functions that convert doctests to Python code, and possibly run the "
"synthesized code under the debugger:"
msgstr "将测试转换为 Python 代码的函数，并可能在调试器下运行合成的代码:"

#: ../../library/doctest.rst:1731
msgid "Convert text with examples to a script."
msgstr "将带有用例的文本转换为脚本。"

#: ../../library/doctest.rst:1733
msgid ""
"Argument *s* is a string containing doctest examples.  The string is "
"converted to a Python script, where doctest examples in *s* are converted to"
" regular code, and everything else is converted to Python comments.  The "
"generated script is returned as a string. For example, ::"
msgstr ""
"参数 *s* 是一个包含测试用例的字符串。 该字符串被转换为 Python 脚本，其中 *s* 中的 doctest "
"用例被转换为常规代码，其他的都被转换为 Python 注释。 生成的脚本将以字符串的形式返回。例如， ::"

#: ../../library/doctest.rst:1738
msgid ""
"import doctest\n"
"print(doctest.script_from_examples(r\"\"\"\n"
"    Set x and y to 1 and 2.\n"
"    >>> x, y = 1, 2\n"
"\n"
"    Print their sum:\n"
"    >>> print(x+y)\n"
"    3\n"
"\"\"\"))"
msgstr ""
"import doctest\n"
"print(doctest.script_from_examples(r\"\"\"\n"
"    Set x and y to 1 and 2.\n"
"    >>> x, y = 1, 2\n"
"\n"
"    Print their sum:\n"
"    >>> print(x+y)\n"
"    3\n"
"\"\"\"))"

#: ../../library/doctest.rst:1748
msgid "displays::"
msgstr "显示::"

#: ../../library/doctest.rst:1750
msgid ""
"# Set x and y to 1 and 2.\n"
"x, y = 1, 2\n"
"#\n"
"# Print their sum:\n"
"print(x+y)\n"
"# Expected:\n"
"## 3"
msgstr ""
"# 将 x 和 y 设为 1 和 2。\n"
"x, y = 1, 2\n"
"#\n"
"# 打印两者之和：\n"
"print(x+y)\n"
"# 预期：\n"
"## 3"

#: ../../library/doctest.rst:1758
msgid ""
"This function is used internally by other functions (see below), but can "
"also be useful when you want to transform an interactive Python session into"
" a Python script."
msgstr "这个函数在内部被其他函数使用（见下文），但当你想把一个交互式 Python 会话转化为 Python 脚本时，也会很有用。"

#: ../../library/doctest.rst:1765
msgid "Convert the doctest for an object to a script."
msgstr "将一个对象的 doctest 转换为一个脚本。"

#: ../../library/doctest.rst:1767
msgid ""
"Argument *module* is a module object, or dotted name of a module, containing"
" the object whose doctests are of interest.  Argument *name* is the name "
"(within the module) of the object with the doctests of interest.  The result"
" is a string, containing the object's docstring converted to a Python "
"script, as described for :func:`script_from_examples` above.  For example, "
"if module :file:`a.py` contains a top-level function :func:`!f`, then ::"
msgstr ""
"参数 *module* 是一个模块对象，或是一个带点号的模块名称，其中包含文档测试需要的对象。 参数 *name* "
"是文档测试需要的对象（在模块中）的名称。 结果是一个字符串，包含该对象的文档字符串转换成的 Python 脚本，如上面 "
":func:`script_from_examples` 所描述的。 举例来说，如果模块 :file:`a.py` 包含一个最高层级的函数 "
":func:`!f`，那么 ::"

#: ../../library/doctest.rst:1774
msgid ""
"import a, doctest\n"
"print(doctest.testsource(a, \"a.f\"))"
msgstr ""
"import a, doctest\n"
"print(doctest.testsource(a, \"a.f\"))"

#: ../../library/doctest.rst:1777
msgid ""
"prints a script version of function :func:`!f`'s docstring, with doctests "
"converted to code, and the rest placed in comments."
msgstr "打印函数 :func:`!f` 的文档字符串的脚本版本，将文档测试转换为代码，而将其余内容放在注释中。"

#: ../../library/doctest.rst:1783
msgid "Debug the doctests for an object."
msgstr "对一个对象的 doctest 进行调试。"

#: ../../library/doctest.rst:1785
msgid ""
"The *module* and *name* arguments are the same as for function "
":func:`testsource` above.  The synthesized Python script for the named "
"object's docstring is written to a temporary file, and then that file is run"
" under the control of the Python debugger, :mod:`pdb`."
msgstr ""
"*module* 和 *name* 参数与上面函数 :func:`testsource` 的参数相同。 被命名对象的文本串的合成 Python "
"脚本被写入一个临时文件，然后该文件在 Python 调试器 :mod:`pdb` 的控制下运行。"

#: ../../library/doctest.rst:1790
msgid ""
"A shallow copy of ``module.__dict__`` is used for both local and global "
"execution context."
msgstr "``module.__dict__`` 的一个浅层拷贝被用于本地和全局的执行环境。"

#: ../../library/doctest.rst:1793
msgid ""
"Optional argument *pm* controls whether post-mortem debugging is used.  If "
"*pm* has a true value, the script file is run directly, and the debugger "
"gets involved only if the script terminates via raising an unhandled "
"exception.  If it does, then post-mortem debugging is invoked, via "
":func:`pdb.post_mortem`, passing the traceback object from the unhandled "
"exception.  If *pm* is not specified, or is false, the script is run under "
"the debugger from the start, via passing an appropriate :func:`exec` call to"
" :func:`pdb.run`."
msgstr ""
"可选参数 *pm* 控制是否使用事后调试。 如果 *pm* 为 True "
"，则直接运行脚本文件，只有当脚本通过引发一个未处理的异常而终止时，调试器才会介入。如果是这样，就会通过 :func:`pdb.post_mortem` "
"调用事后调试，并传递未处理异常的跟踪对象。如果没有指定 *pm* ，或者是 False ，脚本将从一开始就在调试器下运行，通过传递一个适当的 "
":func:`exec` 调用给 :func:`pdb.run` 。"

#: ../../library/doctest.rst:1804
msgid "Debug the doctests in a string."
msgstr "在一个字符串中调试 doctest 。"

#: ../../library/doctest.rst:1806
msgid ""
"This is like function :func:`debug` above, except that a string containing "
"doctest examples is specified directly, via the *src* argument."
msgstr "这就像上面的函数 :func:`debug` ，只是通过 *src* 参数，直接指定一个包含测试用例的字符串。"

#: ../../library/doctest.rst:1809
msgid ""
"Optional argument *pm* has the same meaning as in function :func:`debug` "
"above."
msgstr "可选参数 *pm* 的含义与上述函数 :func:`debug` 的含义相同。"

#: ../../library/doctest.rst:1811
msgid ""
"Optional argument *globs* gives a dictionary to use as both local and global"
" execution context.  If not specified, or ``None``, an empty dictionary is "
"used. If specified, a shallow copy of the dictionary is used."
msgstr ""
"可选的参数 *globs* 给出了一个字典，作为本地和全局的执行环境。 如果没有指定，或者为 ``None`` "
"，则使用一个空的字典。如果指定，则使用字典的浅层拷贝。"

#: ../../library/doctest.rst:1816
msgid ""
"The :class:`DebugRunner` class, and the special exceptions it may raise, are"
" of most interest to testing framework authors, and will only be sketched "
"here.  See the source code, and especially :class:`DebugRunner`'s docstring "
"(which is a doctest!) for more details:"
msgstr ""
":class:`DebugRunner` 类，以及它可能触发的特殊异常，是测试框架作者最感兴趣的，在此仅作简要介绍。请看源代码，特别是 "
":class:`DebugRunner` 的文档串（这是一个测试！）以了解更多细节。"

#: ../../library/doctest.rst:1824
msgid ""
"A subclass of :class:`DocTestRunner` that raises an exception as soon as a "
"failure is encountered.  If an unexpected exception occurs, an "
":exc:`UnexpectedException` exception is raised, containing the test, the "
"example, and the original exception.  If the output doesn't match, then a "
":exc:`DocTestFailure` exception is raised, containing the test, the example,"
" and the actual output."
msgstr ""
":class:`DocTestRunner` 的一个子类，一旦遇到失败，就会触发一个异常。 如果一个意外的异常发生，就会引发一个 "
":exc:`UnexpectedException` 异常，包含测试、用例和原始异常。 如果输出不匹配，那么就会引发一个 "
":exc:`DocTestFailure` 异常，包含测试、用例和实际输出。"

#: ../../library/doctest.rst:1831
msgid ""
"For information about the constructor parameters and methods, see the "
"documentation for :class:`DocTestRunner` in section :ref:`doctest-advanced-"
"api`."
msgstr ""
"关于构造函数参数和方法的信息，请参见 :class:`DocTestRunner` 部分的文档 :ref:`doctest-advanced-api` "
"。"

#: ../../library/doctest.rst:1834
msgid ""
"There are two exceptions that may be raised by :class:`DebugRunner` "
"instances:"
msgstr ":class:`DebugRunner` 实例可能会触发两种异常。"

#: ../../library/doctest.rst:1839
msgid ""
"An exception raised by :class:`DocTestRunner` to signal that a doctest "
"example's actual output did not match its expected output. The constructor "
"arguments are used to initialize the attributes of the same names."
msgstr ""
":class:`DocTestRunner` 触发的异常，表示一个 doctest "
"用例的实际输出与预期输出不一致。构造函数参数被用来初始化相同名称的属性。"

#: ../../library/doctest.rst:1843
msgid ":exc:`DocTestFailure` defines the following attributes:"
msgstr ":exc:`DocTestFailure` 定义了以下属性:"

#: ../../library/doctest.rst:1848 ../../library/doctest.rst:1872
msgid ""
"The :class:`DocTest` object that was being run when the example failed."
msgstr "当该用例失败时正在运行的 :class:`DocTest` 对象。"

#: ../../library/doctest.rst:1853 ../../library/doctest.rst:1877
msgid "The :class:`Example` that failed."
msgstr "失败的 :class:`Example` 。"

#: ../../library/doctest.rst:1858
msgid "The example's actual output."
msgstr "用例的实际输出。"

#: ../../library/doctest.rst:1863
msgid ""
"An exception raised by :class:`DocTestRunner` to signal that a doctest "
"example raised an unexpected exception.  The constructor arguments are used "
"to initialize the attributes of the same names."
msgstr ""
"一个由 :class:`DocTestRunner` 触发的异常，以提示一个 doctest 用例引发了一个意外的异常。 "
"构造函数参数被用来初始化相同名称的属性。"

#: ../../library/doctest.rst:1867
msgid ":exc:`UnexpectedException` defines the following attributes:"
msgstr ":exc:`UnexpectedException` 定义了以下属性:"

#: ../../library/doctest.rst:1882
msgid ""
"A tuple containing information about the unexpected exception, as returned "
"by :func:`sys.exc_info`."
msgstr "一个包含意外异常信息的元组，由 :func:`sys.ex_info` 返回。"

#: ../../library/doctest.rst:1889
msgid "Soapbox"
msgstr "肥皂盒"

#: ../../library/doctest.rst:1891
msgid ""
"As mentioned in the introduction, :mod:`doctest` has grown to have three "
"primary uses:"
msgstr "正如介绍中提到的， :mod:`doctest` 已经发展到有三个主要用途:"

#: ../../library/doctest.rst:1894
msgid "Checking examples in docstrings."
msgstr "检查 docstring 中的用例。"

#: ../../library/doctest.rst:1896
msgid "Regression testing."
msgstr "回归测试。"

#: ../../library/doctest.rst:1898
msgid "Executable documentation / literate testing."
msgstr "可执行的文档/文字测试。"

#: ../../library/doctest.rst:1900
msgid ""
"These uses have different requirements, and it is important to distinguish "
"them. In particular, filling your docstrings with obscure test cases makes "
"for bad documentation."
msgstr "这些用途有不同的要求，区分它们是很重要的。特别是，用晦涩难懂的测试用例来填充你的文档字符串会使文档变得很糟糕。"

#: ../../library/doctest.rst:1904
msgid ""
"When writing a docstring, choose docstring examples with care. There's an "
"art to this that needs to be learned---it may not be natural at first.  "
"Examples should add genuine value to the documentation.  A good example can "
"often be worth many words. If done with care, the examples will be "
"invaluable for your users, and will pay back the time it takes to collect "
"them many times over as the years go by and things change.  I'm still amazed"
" at how often one of my :mod:`doctest` examples stops working after a "
"\"harmless\" change."
msgstr ""
"在编写文档串时，要谨慎地选择文档串的用例。这是一门需要学习的艺术——一开始可能并不自然。用例应该为文档增加真正的价值。 "
"一个好的用例往往可以抵得上许多文字。如果用心去做，这些用例对你的用户来说是非常有价值的，而且随着时间的推移和事情的变化，收集这些用例所花费的时间也会得到很多倍的回报。"
" 我仍然惊讶于我的 :mod:`doctest` 用例在一个“无害”的变化后停止工作。"

#: ../../library/doctest.rst:1912
msgid ""
"Doctest also makes an excellent tool for regression testing, especially if "
"you don't skimp on explanatory text.  By interleaving prose and examples, it"
" becomes much easier to keep track of what's actually being tested, and why."
"  When a test fails, good prose can make it much easier to figure out what "
"the problem is, and how it should be fixed.  It's true that you could write "
"extensive comments in code-based testing, but few programmers do. Many have "
"found that using doctest approaches instead leads to much clearer tests.  "
"Perhaps this is simply because doctest makes writing prose a little easier "
"than writing code, while writing comments in code is a little harder.  I "
"think it goes deeper than just that: the natural attitude when writing a "
"doctest-based test is that you want to explain the fine points of your "
"software, and illustrate them with examples. This in turn naturally leads to"
" test files that start with the simplest features, and logically progress to"
" complications and edge cases.  A coherent narrative is the result, instead "
"of a collection of isolated functions that test isolated bits of "
"functionality seemingly at random.  It's a different attitude, and produces "
"different results, blurring the distinction between testing and explaining."
msgstr ""
"Doctest 也是回归测试的一个很好的工具，特别是如果你不吝啬解释的文字。 "
"通过交错的文本和用例，可以更容易地跟踪真正的测试，以及为什么。当测试失败时，好的文本可以使你更容易弄清问题所在，以及如何解决。 "
"的确，你可以在基于代码的测试中写大量的注释，但很少有程序员这样做。许多人发现，使用 doctest 方法反而能使测试更加清晰。 也许这只是因为 "
"doctest 使写散文比写代码容易一些，而在代码中写注释则有点困难。 我认为它比这更深入：当写一个基于 doctest "
"的测试时，自然的态度是你想解释你的软件的细微之处，并用例子来说明它们。这反过来又自然地导致了测试文件从最简单的功能开始，然后逻辑地发展到复杂和边缘案例。"
" 一个连贯的叙述是结果，而不是一个孤立的函数集合，似乎是随机的测试孤立的功能位。 这是一种不同的态度，产生不同的结果，模糊了测试和解释之间的区别。"

#: ../../library/doctest.rst:1930
msgid ""
"Regression testing is best confined to dedicated objects or files.  There "
"are several options for organizing tests:"
msgstr "回归测试最好限制在专用对象或文件中。 有几种组织测试的选择："

#: ../../library/doctest.rst:1933
msgid ""
"Write text files containing test cases as interactive examples, and test the"
" files using :func:`testfile` or :func:`DocFileSuite`.  This is recommended,"
" although is easiest to do for new projects, designed from the start to use "
"doctest."
msgstr ""
"编写包含测试案例的文本文件作为交互式例子，并使用 :func:`testfile` 或 :func:`DocFileSuite` 来测试这些文件。 "
"建议这样做，尽管对于新的项目来说是最容易做到的，从一开始就设计成使用 doctest 。"

#: ../../library/doctest.rst:1938
msgid ""
"Define functions named ``_regrtest_topic`` that consist of single "
"docstrings, containing test cases for the named topics.  These functions can"
" be included in the same file as the module, or separated out into a "
"separate test file."
msgstr ""
"定义命名为 ``_regrtest_topic`` 的函数，由单个文档串组成，包含命名主题的测试用例。 "
"这些函数可以包含在与模块相同的文件中，或分离出来成为一个单独的测试文件。"

#: ../../library/doctest.rst:1942
msgid ""
"Define a :attr:`~module.__test__` dictionary mapping from regression test "
"topics to docstrings containing test cases."
msgstr "定义一个将回归测试主题映射到包含测试用例的文档字符串的 :attr:`~module.__test__` 字典。"

#: ../../library/doctest.rst:1945
msgid ""
"When you have placed your tests in a module, the module can itself be the "
"test runner.  When a test fails, you can arrange for your test runner to re-"
"run only the failing doctest while you debug the problem.  Here is a minimal"
" example of such a test runner::"
msgstr ""
"当你把你的测试放在一个模块中时，这个模块本身就可以成为测试运行器。 当一个测试失败时，你可以安排你的测试运行器只重新运行失败的测试，同时调试问题。 "
"下面是这样一个测试运行器的最小例子::"

#: ../../library/doctest.rst:1950
msgid ""
"if __name__ == '__main__':\n"
"    import doctest\n"
"    flags = doctest.REPORT_NDIFF|doctest.FAIL_FAST\n"
"    if len(sys.argv) > 1:\n"
"        name = sys.argv[1]\n"
"        if name in globals():\n"
"            obj = globals()[name]\n"
"        else:\n"
"            obj = __test__[name]\n"
"        doctest.run_docstring_examples(obj, globals(), name=name,\n"
"                                       optionflags=flags)\n"
"    else:\n"
"        fail, total = doctest.testmod(optionflags=flags)\n"
"        print(f\"{fail} failures out of {total} tests\")"
msgstr ""
"if __name__ == '__main__':\n"
"    import doctest\n"
"    flags = doctest.REPORT_NDIFF|doctest.FAIL_FAST\n"
"    if len(sys.argv) > 1:\n"
"        name = sys.argv[1]\n"
"        if name in globals():\n"
"            obj = globals()[name]\n"
"        else:\n"
"            obj = __test__[name]\n"
"        doctest.run_docstring_examples(obj, globals(), name=name,\n"
"                                       optionflags=flags)\n"
"    else:\n"
"        fail, total = doctest.testmod(optionflags=flags)\n"
"        print(f\"{fail} failures out of {total} tests\")"

#: ../../library/doctest.rst:1967
msgid "Footnotes"
msgstr "备注"

#: ../../library/doctest.rst:1968
msgid ""
"Examples containing both expected output and an exception are not supported."
" Trying to guess where one ends and the other begins is too error-prone, and"
" that also makes for a confusing test."
msgstr "不支持同时包含预期输出和异常的用例。试图猜测一个在哪里结束，另一个在哪里开始，太容易出错了，而且这也会使测试变得混乱。"

#: ../../library/doctest.rst:376
msgid ">>>"
msgstr ">>>"

#: ../../library/doctest.rst:376
msgid "interpreter prompt"
msgstr "解释器提示符"

#: ../../library/doctest.rst:376 ../../library/doctest.rst:611
msgid "..."
msgstr "..."

#: ../../library/doctest.rst:542
msgid "^ (caret)"
msgstr "^ (脱字号)"

#: ../../library/doctest.rst:542
msgid "marker"
msgstr "标记"

#: ../../library/doctest.rst:591
msgid "<BLANKLINE>"
msgstr "<BLANKLINE>"

#: ../../library/doctest.rst:611 ../../library/doctest.rst:736
msgid "in doctests"
msgstr "在 doctests 中"

#: ../../library/doctest.rst:736
msgid "# (hash)"
msgstr "# (hash)"

#: ../../library/doctest.rst:736
msgid "+ (plus)"
msgstr "+ (加号)"

#: ../../library/doctest.rst:736
msgid "- (minus)"
msgstr "- (减号)"
