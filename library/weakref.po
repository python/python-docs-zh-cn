# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/weakref.rst:4
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- 弱引用"

#: ../../library/weakref.rst:14
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**源代码：** :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:18
msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ":mod:`weakref` 模块允许 Python 程序员创建对象的 :dfn:`弱引用` 。"

#: ../../library/weakref.rst:24
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr "在下文中，术语 :dfn:`所指对象` 表示弱引用所指向的对象。"

#: ../../library/weakref.rst:27
msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, "
":term:`garbage collection` is free to destroy the referent and reuse its "
"memory for something else.  However, until the object is actually destroyed "
"the weak reference may return the object even if there are no strong "
"references to it."
msgstr ""
"对象的弱引用不能保证对象存活：当所指对像的引用只剩弱引用时， :term:`垃圾回收 <garbage collection>` "
"可以销毁所指对象，并将其内存重新用于其它用途。但是，在实际销毁对象之前，即使没有强引用，弱引用也能返回该对象。"

#: ../../library/weakref.rst:33
msgid ""
"A primary use for weak references is to implement caches or mappings holding"
" large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr "弱引用的一个主要用途是实现一个存储大型对象的缓存或映射，但又不希望该大型对象仅因为它只出现在这个缓存或映射中而保持存活。"

#: ../../library/weakref.rst:37
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The "
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied"
" by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a "
":class:`WeakValueDictionary`, then when the last remaining references to "
"that image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"例如，如果你有许多大型二进制图像对象，你可能希望为每个对象关联一个名称。如果你使用 Python "
"字典来将名称映射到图像，或将图像映射到名称，那么图像对象将因为它们在字典中作为值或键而保持存活。 :mod:`weakref` 模块提供的 "
":class:`WeakKeyDictionary` 和 :class:`WeakValueDictionary` 类可以替代 Python "
"字典，它们使用弱引用来构造映射，这种映射不会仅因为对象出现在映射中而使对象保持存活。例如，如果一个图像对象是 "
":class:`WeakValueDictionary` "
"中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收器将回收该对象，并删除弱映射对象中相应的条目。"

#: ../../library/weakref.rst:50
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the "
":class:`set` interface, but keeps weak references to its elements, just like"
" a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` 和 :class:`WeakValueDictionary` "
"在它们的实现中使用了弱引用，并在弱引用上设置当键或值被垃圾回收器回收时通知弱字典的回调函数。 :class:`WeakSet` 实现了 "
":class:`set` 接口，但像 :class:`WeakKeyDictionary` 一样，只持有其元素的弱引用。"

#: ../../library/weakref.rst:57
msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` "
"提供了一种直接的方法来注册当对象被垃圾收集时要调用的清理函数。这比在普通的弱引用上设置回调函数的方式更简单，因为模块会自动确保对象被回收前终结器一直保持存活。"

#: ../../library/weakref.rst:63
msgid ""
"Most programs should find that using one of these weak container types or "
":class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"这些弱容器类型之一或者 :class:`finalize` 就是大多数程序所需要的——通常不需要直接创建自己的弱引用。:mod:`weakref` "
"模块暴露了底层机制，以便用于高级用途。"

#: ../../library/weakref.rst:68
msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not in "
"C), instance methods, sets, frozensets, some :term:`file objects <file "
"object>`, :term:`generators <generator>`, type objects, sockets, arrays, "
"deques, regular expression pattern objects, and code objects."
msgstr ""
"并非所有对象都可以被弱引用。支持弱引用的对象包括类实例、用 Python（而非用 C）编写的函数、实例方法、集合、冻结集合、某些 :term:`文件对象"
" <file object>`、:term:`生成器 <generator>`、类型对象、套接字、数组、双端队列、正则表达式模式对象以及代码对象。"

#: ../../library/weakref.rst:74
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "添加了对 thread.lock，threading.Lock 和代码对象的支持。"

#: ../../library/weakref.rst:77
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr "一些内置类型，如 :class:`list` 和 :class:`dict`，不直接支持弱引用，但可以通过子类化添加支持::"

#: ../../library/weakref.rst:80
msgid ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable"
msgstr ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # 此对象是可弱引用的"

#: ../../library/weakref.rst:87
msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed."
msgstr "其他内置类型，如 :class:`tuple` 和 :class:`int`，不支持弱引用，即使通过子类化也不支持。"

#: ../../library/weakref.rst:90
msgid ""
"Extension types can easily be made to support weak references; see "
":ref:`weakref-support`."
msgstr "可以轻松地使扩展类型支持弱引用；参见 :ref:`weakref-support`。"

#: ../../library/weakref.rst:93
msgid ""
"When ``__slots__`` are defined for a given type, weak reference support is "
"disabled unless a ``'__weakref__'`` string is also present in the sequence "
"of strings in the ``__slots__`` declaration. See :ref:`__slots__ "
"documentation <slots>` for details."
msgstr ""
"当为某个给定类型定义了 ``__slots__`` 时，弱引用支持会被禁用，除非将 ``'__weakref__'`` 字符串也加入到 "
"``__slots__`` 声明的字符串序列中。 请参阅 :ref:`__slots__ 文档 <slots>` 了解详情。"

#: ../../library/weakref.rst:100
msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause "
":const:`None` to be returned.  If *callback* is provided and not "
":const:`None`, and the returned weakref object is still alive, the callback "
"will be called when the object is about to be finalized; the weak reference "
"object will be passed as the only parameter to the callback; the referent "
"will no longer be available."
msgstr ""
"返回 *object* 的弱引用。如果所指对象存活，则可以通过调用引用对象来获取原始对象；如果所指对象不存在，则调用引用对象将得到 "
":const:`None` 。如果提供了值不是 :const:`None` 的 "
"*callback*，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调函数；弱引用对象将作为回调函数的唯一参数传递；然后所指对象将不再可用。"

#: ../../library/weakref.rst:108
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the"
" most recently registered callback to the oldest registered callback."
msgstr "允许为同一个对象的构造多个弱引用。每个弱引用注册的回调函数将按从最近注册的回调函数，到最早注册的回调函数的顺序调用。"

#: ../../library/weakref.rst:112
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`~object.__del__` method."
msgstr ""
"由回调函数引发的异常将记录于标准错误输入，但无法传播该异常；这些异常的处理方式与对象 :meth:`~object.__del__` "
"方法引发异常的处理方式相同。"

#: ../../library/weakref.rst:116
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will"
" maintain their hash value even after the *object* was deleted.  If "
":func:`hash` is called the first time only after the *object* was deleted, "
"the call will raise :exc:`TypeError`."
msgstr ""
"如果 *object* 可哈希，则弱引用也 :term:`可哈希 <hashable>`。即使在 *object* "
"被删除之后，弱引用仍将保持其哈希值。如果在 *object* 被删除之后才首次调用 :func:`hash`，则该调用将引发 "
":exc:`TypeError`。"

#: ../../library/weakref.rst:121
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"弱引用支持相等性测试，但不支持排序。如果所指对象仍然存活，两个引用具有与它们的所指对象具有一致的相等关系（无论 *callback* "
"是否相同）。如果删除了任一所指对象，则仅在两个引用指向同一对象时，二者才相等。"

#: ../../library/weakref.rst:126
msgid "This is a subclassable type rather than a factory function."
msgstr "这是一个可子类化的类型，而非一个工厂函数。"

#: ../../library/weakref.rst:130
msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr "这个只读属性会返回当前关联到弱引用的回调函数。 如果回调函数不存在，或弱引用的所指对象已不存在，则此属性的值为 ``None``。"

#: ../../library/weakref.rst:134
msgid "Added the :attr:`__callback__` attribute."
msgstr "添加了 :attr:`__callback__` 属性。"

#: ../../library/weakref.rst:140
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevents their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the "
":func:`ref` function."
msgstr ""
"返回一个使用弱引用的 *object* 代理。此函数支持在大多数上下文中使用代理，而不要求显式地解引用弱引用对象。返回的对象类型将为 "
"``ProxyType`` 或 ``CallableProxyType``，具体取决于 *object* "
"是否为可调用对象。无论所指对象是否可哈希，代理对象都不属于 :term:`可哈希 <hashable>` "
"对象；这避免了与它们的基本可变性质相关的许多问题，且防止代理被用作字典的键。*callback* 形参含义与 :func:`ref` "
"函数的同名形参含义相同。"

#: ../../library/weakref.rst:149
msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr "在所指对象被作为垃圾回收后访问代理对象的属性将引发 :exc:`ReferenceError`。"

#: ../../library/weakref.rst:152
msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr "扩展代理对象所支持的运算符，包括矩阵乘法运算符 ``@`` 和 ``@=``。"

#: ../../library/weakref.rst:159
msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr "返回指向 *object* 的弱引用和代理的数量。"

#: ../../library/weakref.rst:164
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr "返回由指向 *object* 的所有弱引用和代理构成的列表。"

#: ../../library/weakref.rst:169
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts"
" of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"弱引用键的映射类。当不再存在对键的强引用时，字典中的相关条目将被丢弃。这可用于将额外数据与应用程序中其它部分拥有的对象相关联，而无需向这些对象添加属性。这对于重写了属性访问的对象来说特别有用。"

#: ../../library/weakref.rst:175
msgid ""
"Note that when a key with equal value to an existing key (but not equal "
"identity) is inserted into the dictionary, it replaces the value but does "
"not replace the existing key. Due to this, when the reference to the "
"original key is deleted, it also deletes the entry in the dictionary::"
msgstr ""
"请注意，当把一个与现有键具有相同值（但是标识号不相等）的键插入字典时，它会替换该值，但不会替换现有的键。由于这一点，当删除对原来的键的引用时，也将同时删除字典中的对应条目::"

#: ../../library/weakref.rst:180
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"

#: ../../library/weakref.rst:188
msgid "A workaround would be to remove the key prior to reassignment::"
msgstr "一种变通做法是在重新赋值之前先移除键::"

#: ../../library/weakref.rst:190
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"

#: ../../library/weakref.rst:199 ../../library/weakref.rst:220
msgid ""
"Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr "增加了对 ``|`` 和 ``|=`` 运算符的支持，相关说明见 :pep:`584`。"

#: ../../library/weakref.rst:202
msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""
":class:`WeakKeyDictionary` "
"对象具有一个额外方法，可以直接公开内部引用。这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 "
"此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。"

#: ../../library/weakref.rst:212
msgid "Return an iterable of the weak references to the keys."
msgstr "返回包含对键的弱引用的可迭代对象。"

#: ../../library/weakref.rst:217
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will"
" be discarded when no strong reference to the value exists any more."
msgstr "弱引用值的映射类。当不再存在对该值的强引用时，字典中的条目将被丢弃。"

#: ../../library/weakref.rst:223
msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`WeakKeyDictionary.keyrefs` method."
msgstr ""
":class:`WeakValueDictionary` 对象具有一个额外方法，此方法存在与 "
":meth:`WeakKeyDictionary.keyrefs` 方法相同的问题。"

#: ../../library/weakref.rst:229
msgid "Return an iterable of the weak references to the values."
msgstr "返回包含对值的弱引用的可迭代对象。"

#: ../../library/weakref.rst:234
msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr "保持对其元素弱引用的集合类。当某个元素没有强引用时，该元素将被丢弃。"

#: ../../library/weakref.rst:240
msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 :class:`ref` 子类。 "
"由于绑定方法是临时性的，标准弱引用无法保持它。 :class:`WeakMethod` 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁::"

#: ../../library/weakref.rst:246
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"

#: ../../library/weakref.rst:264
msgid ""
"*callback* is the same as the parameter of the same name to the :func:`ref` "
"function."
msgstr "*callback* 与 :func:`ref` 函数的同名形参含义相同。"

#: ../../library/weakref.rst:270
msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"返回一个可调用的终结器对象，该对象将在 *obj* "
"作为垃圾回收时被调用。与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生命周期管理。"

#: ../../library/weakref.rst:275
msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas"
" calling a dead finalizer returns :const:`None`."
msgstr ""
"终结器总是被视为 *存活* 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 *死亡*。 调用存活的终结器将返回 ``func(*arg, "
"**kwargs)`` 的求值结果，而调用死亡的终结器将返回 :const:`None`。"

#: ../../library/weakref.rst:280
msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's "
":meth:`~object.__del__` method or a weak reference's callback."
msgstr ""
"在垃圾收集期间由终结器回调所引发的异常将显示在标准错误输出中，但无法被传播。 它们会按与对象的 :meth:`~object.__del__` "
"方法或或弱引用的回调所引发的异常相同的方式被处理。"

#: ../../library/weakref.rst:286
msgid ""
"When the program exits, each remaining live finalizer is called unless its "
":attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr "当程序退出时，剩余的存活终结器会被调用，除非它们的 :attr:`atexit` 属性已被设为假值。 它们会按与创建时相反的顺序被调用。"

#: ../../library/weakref.rst:290
msgid ""
"A finalizer will never invoke its callback during the later part of the "
":term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""
"终结器在 :term:`interpreter shutdown` 的后期绝不会唤起其回调函数，此时模块全局变量很可能已被替换为 "
":const:`None`。"

#: ../../library/weakref.rst:296
msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 为存活状态则将其标记为已死亡，并返回调用 ``func(*args, **kwargs)`` 的结果。 如果 *self* "
"已死亡则返回 :const:`None`。"

#: ../../library/weakref.rst:302
msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 为存活状态则将其标记为已死亡，并返回元组 ``(obj, func, args, kwargs)``。 如果 *self* "
"已死亡则返 :const:`None`。"

#: ../../library/weakref.rst:308
msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 为存活状态则返回元组 ``(obj, func, args, kwargs)``。 如果 *self* 已死亡则返回 "
":const:`None`。"

#: ../../library/weakref.rst:313
msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr "如果终结器为存活状态则该特征属性为真值，否则为假值。"

#: ../../library/weakref.rst:317
msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""
"一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 :attr:`.atexit` 为真值的剩余存活终结器。 "
"它们会按与创建时相反的顺序被调用。"

#: ../../library/weakref.rst:324
msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""
"很重要的一点是确保 *func*, *args* 和 *kwargs* 不拥有任何对 *obj* 的引用，无论是直接的或是间接的，否则的话 *obj* "
"将永远不会被作为垃圾回收。 特别地，*func* 不应当是 *obj* 的一个绑定方法。"

#: ../../library/weakref.rst:334
msgid "The type object for weak references objects."
msgstr "弱引用对象的类型对象。"

#: ../../library/weakref.rst:339
msgid "The type object for proxies of objects which are not callable."
msgstr "不可调用对象的代理的类型对象。"

#: ../../library/weakref.rst:344
msgid "The type object for proxies of callable objects."
msgstr "可调用对象的代理的类型对象。"

#: ../../library/weakref.rst:349
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr "包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。"

#: ../../library/weakref.rst:356
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱引用"

#: ../../library/weakref.rst:357
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr "此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。"

#: ../../library/weakref.rst:364
msgid "Weak Reference Objects"
msgstr "弱引用对象"

#: ../../library/weakref.rst:366
msgid ""
"Weak reference objects have no methods and no attributes besides "
":attr:`ref.__callback__`. A weak reference object allows the referent to be "
"obtained, if it still exists, by calling it:"
msgstr "弱引用对象没有 :attr:`ref.__callback__` 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:"

#: ../../library/weakref.rst:380
msgid ""
"If the referent no longer exists, calling the reference object returns "
":const:`None`:"
msgstr "如果引用已不存在，则调用引用对象将返回 :const:`None`:"

#: ../../library/weakref.rst:387
msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"检测一个弱引用对象是否仍然存在应该使用表达式 ``ref() is not None``。 通常，需要使用引用对象的应用代码应当遵循这样的模式::"

#: ../../library/weakref.rst:391
msgid ""
"# r is a weak reference object\n"
"o = r()\n"
"if o is None:\n"
"    # referent has been garbage collected\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"
msgstr ""
"# r 是一个弱引用对象\n"
"o = r()\n"
"if o is None:\n"
"    # 引用已被作为垃圾回收\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"

#: ../../library/weakref.rst:400
msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。"

#: ../../library/weakref.rst:405
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the "
":class:`WeakValueDictionary` to reduce the memory overhead for each entry in"
" the mapping.  This may be most useful to associate additional information "
"with a reference, but could also be used to insert additional processing on "
"calls to retrieve the referent."
msgstr ""
"特别版本的 :class:`ref` 对象可以通过子类化来创建。 在 :class:`WeakValueDictionary` "
"的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。"

#: ../../library/weakref.rst:411
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr "这个例子演示了如何将 :class:`ref` 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值::"

#: ../../library/weakref.rst:415
msgid ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"
msgstr ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"返回一个包含引用和该引用被调用次数的\n"
"        二元组。\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"

#: ../../library/weakref.rst:438
msgid "Example"
msgstr "示例"

#: ../../library/weakref.rst:440
msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in"
" other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID "
"可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。"

#: ../../library/weakref.rst:449
msgid ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"
msgstr ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"

#: ../../library/weakref.rst:465
msgid "Finalizer Objects"
msgstr "终结器对象"

#: ../../library/weakref.rst:467
msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr "使用 :class:`finalize` 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如"

#: ../../library/weakref.rst:481
msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr "终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。"

#: ../../library/weakref.rst:497
msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor"
" when it was created."
msgstr "你可以使用 :meth:`~finalize.detach` 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。"

#: ../../library/weakref.rst:511
msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""
"除非你将 :attr:`~finalize.atexit` 属性设为 :const:`False`，否则终结器在程序退出时如果仍然存活就将被调用。 例如"

#: ../../library/weakref.rst:515
msgid ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"
msgstr ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"

#: ../../library/weakref.rst:526
msgid "Comparing finalizers with :meth:`~object.__del__` methods"
msgstr "比较终结器与 :meth:`~object.__del__` 方法"

#: ../../library/weakref.rst:528
msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the"
" first of the following events occurs:"
msgstr "假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除："

#: ../../library/weakref.rst:532
msgid "the object is garbage collected,"
msgstr "对象被作为垃圾回收，"

#: ../../library/weakref.rst:533
msgid "the object's :meth:`!remove` method is called, or"
msgstr "对象的 :meth:`!remove` 方法被调用，或"

#: ../../library/weakref.rst:534
msgid "the program exits."
msgstr "程序退出。"

#: ../../library/weakref.rst:536
msgid ""
"We might try to implement the class using a :meth:`~object.__del__` method "
"as follows::"
msgstr "我们可以像下面这样尝试使用 :meth:`~object.__del__` 方法来实现这个类::"

#: ../../library/weakref.rst:539
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"

#: ../../library/weakref.rst:555
msgid ""
"Starting with Python 3.4, :meth:`~object.__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""
"从 Python 3.4 开始，:meth:`~object.__del__` 方法会不再阻止循环引用被作为垃圾回收，并且模块全局变量在 "
":term:`interpreter shutdown` 期间不会再被强制设为 :const:`None`。 因此这段代码在 CPython "
"上应该会正常运行而不会出现任何问题。"

#: ../../library/weakref.rst:560
msgid ""
"However, handling of :meth:`~object.__del__` methods is notoriously "
"implementation specific, since it depends on internal details of the "
"interpreter's garbage collector implementation."
msgstr "然而，:meth:`~object.__del__` 方法的处理严重受影响于具体实现，因为它依赖于解释器的垃圾回收实现方式的内部细节。"

#: ../../library/weakref.rst:564
msgid ""
"A more robust alternative can be to define a finalizer which only references"
" the specific functions and objects that it needs, rather than having access"
" to the full state of the object::"
msgstr "更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权::"

#: ../../library/weakref.rst:568
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"

#: ../../library/weakref.rst:580
msgid ""
"Defined like this, our finalizer only receives a reference to the details it"
" needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr "像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。"

#: ../../library/weakref.rst:584
msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr "基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码::"

#: ../../library/weakref.rst:588
msgid ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit reference to the module globals from the function body\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"
msgstr ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # 从函数体隐式地引用模块的 globals\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"

#: ../../library/weakref.rst:596
msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs "
"either."
msgstr ""
"如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 "
":func:`atexit.register`, ``try: ... finally: ...`` 和 ``with: ...`` "
"同样不能保证执行清理。"
