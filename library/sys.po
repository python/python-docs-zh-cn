# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-23 15:08+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sys.rst:2
msgid ":mod:`!sys` --- System-specific parameters and functions"
msgstr ":mod:`!sys` --- 系统相关的形参和函数"

#: ../../library/sys.rst:9
msgid ""
"This module provides access to some variables used or maintained by the "
"interpreter and to functions that interact strongly with the interpreter. It"
" is always available. Unless explicitly noted otherwise, all variables are "
"read-only."
msgstr "该模块提供了一些由解释器使用或维护的变量以及与解释器高强度交互的函数。 它将始终可用。 除非显式地说明例外情况，所有变量都是只读的。"

#: ../../library/sys.rst:16
msgid ""
"On POSIX systems where Python was built with the standard ``configure`` "
"script, this contains the ABI flags as specified by :pep:`3149`."
msgstr ""
"在POSIX系统上，以标准的 ``configure`` 脚本构建的 Python 中，这个变量会包含 :pep:`3149` 中定义的ABI标签。"

#: ../../library/sys.rst:21
msgid ""
"Default flags became an empty string (``m`` flag for pymalloc has been "
"removed)."
msgstr "默认的 flags 变为了空字符串（用于 pymalloc 的 ``m`` 旗标已经移除）"

#: ../../library/sys.rst:25 ../../library/sys.rst:299
#: ../../library/sys.rst:369 ../../library/sys.rst:760
#: ../../library/sys.rst:778 ../../library/sys.rst:1022
#: ../../library/sys.rst:1524 ../../library/sys.rst:1765
#: ../../library/sys.rst:1780 ../../library/sys.rst:1788
#: ../../library/sys.rst:1804 ../../library/sys.rst:2048
msgid "Availability"
msgstr "Availability"

#: ../../library/sys.rst:30
msgid ""
"Append the callable *hook* to the list of active auditing hooks for the "
"current (sub)interpreter."
msgstr "将可调用的对象 *hook* 附加到当前（子）解释器的活动的审计钩子列表中。"

#: ../../library/sys.rst:33
msgid ""
"When an auditing event is raised through the :func:`sys.audit` function, "
"each hook will be called in the order it was added with the event name and "
"the tuple of arguments. Native hooks added by :c:func:`PySys_AddAuditHook` "
"are called first, followed by hooks added in the current (sub)interpreter.  "
"Hooks can then log the event, raise an exception to abort the operation, or "
"terminate the process entirely."
msgstr ""
"当通过 :func:`sys.audit` 函数引发审计事件时，每个钩子将按照其被加入的先后顺序被调用，调用时会传入事件名称和参数元组。 由 "
":c:func:`PySys_AddAuditHook` 添加的原生钩子会先被调用，然后是当前（子）解释器中添加的钩子。 "
"接下来这些钩子会记录事件，引发异常来中止操作，或是完全终止进程。"

#: ../../library/sys.rst:40
msgid ""
"Note that audit hooks are primarily for collecting information about "
"internal or otherwise unobservable actions, whether by Python or libraries "
"written in Python. They are not suitable for implementing a \"sandbox\". In "
"particular, malicious code can trivially disable or bypass hooks added using"
" this function. At a minimum, any security-sensitive hooks must be added "
"using the C API :c:func:`PySys_AddAuditHook` before initialising the "
"runtime, and any modules allowing arbitrary memory modification (such as "
":mod:`ctypes`) should be completely removed or closely monitored."
msgstr ""
"请注意审计钩子主要是用于收集有关内部或在其他情况下不可观察操作的信息，可能是通过 Python 或者用 Python 编写的库。 "
"它们不适合用于实现“沙盒”。 特别重要的一点是，恶意代码可以轻易地禁用或绕过使用此函数添加的钩子。 至少，在初始化运行时之前必须使用 C API "
":c:func:`PySys_AddAuditHook` 来添加任何安全敏感的钩子，并且应当完全删除或密切监视任何允许任意修改内存的模块 (如 "
":mod:`ctypes`)。"

#: ../../library/sys.rst:49 ../../library/sys.rst:51
msgid ""
"Calling :func:`sys.addaudithook` will itself raise an auditing event named "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`RuntimeError`, the new hook will not be added"
" and the exception suppressed. As a result, callers cannot assume that their"
" hook has been added unless they control all existing hooks."
msgstr ""
"调用 :func:`sys.addaudithook` 时它自身将引发一个名为 ``sys.addaudithook`` 的审计事件且不附带参数。 "
"如果任何现有的钩子引发了派生自 :class:`RuntimeError` 的异常，则新的钩子不会被添加并且该异常会被抑制。 "
"其结果就是，调用者无法确保他们的钩子已经被添加，除非他们控制了全部现有的钩子。"

#: ../../library/sys.rst:58
msgid ""
"See the :ref:`audit events table <audit-events>` for all events raised by "
"CPython, and :pep:`578` for the original design discussion."
msgstr ""
"请参阅 :ref:`审计事件表 <audit-events>` 以获取由 CPython 引发的所有事件，并参阅 :pep:`578` "
"了解最初的设计讨论。"

#: ../../library/sys.rst:65
msgid ""
"Exceptions derived from :class:`Exception` but not :class:`RuntimeError` are"
" no longer suppressed."
msgstr "派生自 :class:`Exception` （而非 :class:`RuntimeError` ）的异常不会被抑制。"

#: ../../library/sys.rst:70
msgid ""
"When tracing is enabled (see :func:`settrace`), Python hooks are only traced"
" if the callable has a ``__cantrace__`` member that is set to a true value. "
"Otherwise, trace functions will skip the hook."
msgstr ""
"启用跟踪时（参阅 :func:`settrace` ），仅当可调用对象（钩子）的 ``__cantrace__`` 成员设置为 true "
"时，才会跟踪该钩子。否则，跟踪功能将跳过该钩子。"

#: ../../library/sys.rst:77
msgid ""
"The list of command line arguments passed to a Python script. ``argv[0]`` is"
" the script name (it is operating system dependent whether this is a full "
"pathname or not).  If the command was executed using the :option:`-c` "
"command line option to the interpreter, ``argv[0]`` is set to the string "
"``'-c'``.  If no script name was passed to the Python interpreter, "
"``argv[0]`` is the empty string."
msgstr ""
"一个列表，其中包含了被传递给 Python 脚本的命令行参数。 ``argv[0]`` 为脚本的名称（是否是完整的路径名取决于操作系统）。如果是通过 "
"Python 解释器的命令行参数 :option:`-c` 来执行的， ``argv[0]`` 会被设置成字符串 ``'-c'`` "
"。如果没有脚本名被传递给 Python 解释器， ``argv[0]`` 为空字符串。"

#: ../../library/sys.rst:83
msgid ""
"To loop over the standard input, or the list of files given on the command "
"line, see the :mod:`fileinput` module."
msgstr "为了遍历标准输入，或者通过命令行传递的文件列表，参照 :mod:`fileinput` 模块"

#: ../../library/sys.rst:86
msgid "See also :data:`sys.orig_argv`."
msgstr "另请参阅 :data:`sys.orig_argv`。"

#: ../../library/sys.rst:89
msgid ""
"On Unix, command line arguments are passed by bytes from OS.  Python decodes"
" them with filesystem encoding and \"surrogateescape\" error handler. When "
"you need original bytes, you can get it by ``[os.fsencode(arg) for arg in "
"sys.argv]``."
msgstr ""
"在 Unix 上，系统传递的命令行参数是字节类型的。Python 使用文件系统编码和 \"surrogateescape\" "
"错误处理方案对它们进行解码。当需要原始字节时，可以通过 ``[os.fsencode(arg) for arg in sys.argv]`` 来获取。"

#: ../../library/sys.rst:101
msgid ""
"Raise an auditing event and trigger any active auditing hooks. *event* is a "
"string identifying the event, and *args* may contain optional arguments with"
" more information about the event.  The number and types of arguments for a "
"given event are considered a public and stable API and should not be "
"modified between releases."
msgstr ""
"引发一个审计事件并触发任何激活的审计钩子。 *event* 是一个用于标识事件的字符串，*args* 会包含有关事件的更多信息的可选参数。 "
"特定事件的参数的数量和类型会被视为是公有的稳定 API 且不应当在版本之间进行修改。"

#: ../../library/sys.rst:107
msgid ""
"For example, one auditing event is named ``os.chdir``. This event has one "
"argument called *path* that will contain the requested new working "
"directory."
msgstr "例如，有一个审计事件的名称为 ``os.chdir``。 此事件具有一个名为 *path* 的参数，该参数将包含所请求的新工作目录。"

#: ../../library/sys.rst:111
msgid ""
":func:`sys.audit` will call the existing auditing hooks, passing the event "
"name and arguments, and will re-raise the first exception from any hook. In "
"general, if an exception is raised, it should not be handled and the process"
" should be terminated as quickly as possible. This allows hook "
"implementations to decide how to respond to particular events: they can "
"merely log the event or abort the operation by raising an exception."
msgstr ""
":func:`sys.audit` 将调用现有的审计钩子，传入事件名称和参数，并将重新引发来自任何钩子的第一个异常。 "
"通常来说，如果有一个异常被引发，则它不应当被处理且其进程应当被尽可能快地终止。 "
"这将允许钩子实现来决定对特定事件要如何反应：它们可以只是将事件写入日志或是通过引发异常来中止操作。"

#: ../../library/sys.rst:119
msgid ""
"Hooks are added using the :func:`sys.addaudithook` or "
":c:func:`PySys_AddAuditHook` functions."
msgstr "钩子程序由 :func:`sys.addaudithook` 或 :c:func:`PySys_AddAuditHook` 函数添加。"

#: ../../library/sys.rst:122
msgid ""
"The native equivalent of this function is :c:func:`PySys_Audit`. Using the "
"native function is preferred when possible."
msgstr "与本函数相等效的原生函数是 :c:func:`PySys_Audit`，应尽量使用原生函数。"

#: ../../library/sys.rst:125
msgid ""
"See the :ref:`audit events table <audit-events>` for all events raised by "
"CPython."
msgstr "参阅 :ref:`审计事件表 <audit-events>` 以获取 CPython 定义的所有审计事件。"

#: ../../library/sys.rst:133
msgid ""
"Set during Python startup, before ``site.py`` is run, to the same value as "
":data:`exec_prefix`. If not running in a :ref:`virtual environment <venv-"
"def>`, the values will stay the same; if ``site.py`` finds that a virtual "
"environment is in use, the values of :data:`prefix` and :data:`exec_prefix` "
"will be changed to point to the virtual environment, whereas "
":data:`base_prefix` and :data:`base_exec_prefix` will remain pointing to the"
" base Python installation (the one which the virtual environment was created"
" from)."
msgstr ""
"在 ``site.py`` 运行之前， Python 启动的时候被设置为跟 :data:`exec_prefix` 同样的值。如果不是运行在 "
":ref:`虚拟环境 <venv-def>` 中，两个值会保持相同；如果 ``site.py`` 发现处于一个虚拟环境中， :data:`prefix`"
" 和 :data:`exec_prefix` 将会指向虚拟环境。然而 :data:`base_prefix` 和 "
":data:`base_exec_prefix` 将仍然会指向基础的 Python 环境（用来创建虚拟环境的 Python 环境）"

#: ../../library/sys.rst:147
msgid ""
"Set during Python startup, before ``site.py`` is run, to the same value as "
":data:`prefix`. If not running in a :ref:`virtual environment <venv-def>`, "
"the values will stay the same; if ``site.py`` finds that a virtual "
"environment is in use, the values of :data:`prefix` and :data:`exec_prefix` "
"will be changed to point to the virtual environment, whereas "
":data:`base_prefix` and :data:`base_exec_prefix` will remain pointing to the"
" base Python installation (the one which the virtual environment was created"
" from)."
msgstr ""
"在 ``site.py`` 运行之前， Python 启动的时候被设置为跟 :data:`prefix` 同样的值。如果不是运行在 :ref:`虚拟环境"
" <venv-def>` 中, 两个值会保持相同；如果 ``site.py`` 发现处于一个虚拟环境中， :data:`prefix` 和 "
":data:`exec_prefix` 将会指向虚拟环境。然而 :data:`base_prefix` 和 "
":data:`base_exec_prefix` 将仍然会指向基础的 Python 环境（用来创建虚拟环境的 Python 环境）"

#: ../../library/sys.rst:160
msgid ""
"An indicator of the native byte order.  This will have the value ``'big'`` "
"on big-endian (most-significant byte first) platforms, and ``'little'`` on "
"little-endian (least-significant byte first) platforms."
msgstr ""
"本地字节顺序的指示符。在大端序（最高有效位优先）操作系统上值为 ``'big'`` ，在小端序（最低有效位优先）操作系统上为 ``'little'`` "
"。"

#: ../../library/sys.rst:167
msgid ""
"A tuple of strings containing the names of all modules that are compiled "
"into this Python interpreter.  (This information is not available in any "
"other way --- ``modules.keys()`` only lists the imported modules.)"
msgstr ""
"一个包含所有被编译进 Python 解释器的模块的名称的字符串元组。 （此信息无法通过任何其他办法获取 --- ``modules.keys()`` "
"仅会列出导入的模块。）"

#: ../../library/sys.rst:171
msgid "See also the :data:`sys.stdlib_module_names` list."
msgstr "另请参阅 :data:`sys.stdlib_module_names` 列表。"

#: ../../library/sys.rst:176
msgid ""
"Call ``func(*args)``, while tracing is enabled.  The tracing state is saved,"
" and restored afterwards.  This is intended to be called from a debugger "
"from a checkpoint, to recursively debug or profile some other code."
msgstr ""
"当启用跟踪时，调用 ``func(*args)``。 跟踪状态将被保存，并在以后恢复。 "
"这被设计为由调试器从某个检查点执行调用，以便递归地调试或分析某些其他代码。"

#: ../../library/sys.rst:180
msgid ""
"Tracing is suspended while calling a tracing function set by "
":func:`settrace` or :func:`setprofile` to avoid infinite recursion. "
":func:`!call_tracing` enables explicit recursion of the tracing function."
msgstr ""
"在调用由 :func:`settrace` 或 :func:`setprofile` 设置的跟踪函数时跟踪将暂停以避免无限递归。 "
":func:`!call_tracing` 会启用跟踪函数的显式递归。"

#: ../../library/sys.rst:187
msgid ""
"A string containing the copyright pertaining to the Python interpreter."
msgstr "一个字符串，包含了 Python 解释器有关的版权信息"

#: ../../library/sys.rst:192
msgid ""
"Clear the internal type cache. The type cache is used to speed up attribute "
"and method lookups. Use the function *only* to drop unnecessary references "
"during reference leak debugging."
msgstr "清除内部的类型缓存。类型缓存是为了加速查找方法和属性的。在调试引用泄漏的时候调用这个函数 *只会* 清除不必要的引用。"

#: ../../library/sys.rst:196 ../../library/sys.rst:223
#: ../../library/sys.rst:236
msgid ""
"This function should be used for internal and specialized purposes only."
msgstr "这个函数应该只在内部为了一些特定的目的使用。"

#: ../../library/sys.rst:198
msgid "Use the more general :func:`_clear_internal_caches` function instead."
msgstr "改用更一般化的 :func:`_clear_internal_caches` 函数。"

#: ../../library/sys.rst:204
msgid ""
"Clear all internal performance-related caches. Use this function *only* to "
"release unnecessary references and memory blocks when hunting for leaks."
msgstr "清空所有内部性能相关的缓存。 此函数的使用 *仅限于* 释放不再需要的引用和寻找泄漏的内存块时。"

#: ../../library/sys.rst:212
msgid ""
"Return a dictionary mapping each thread's identifier to the topmost stack "
"frame currently active in that thread at the time the function is called. "
"Note that functions in the :mod:`traceback` module can build the call stack "
"given such a frame."
msgstr ""
"返回一个字典，存放着每个线程的标识符与（调用本函数时）该线程栈顶的帧（当前活动的帧）之间的映射。注意 :mod:`traceback` "
"模块中的函数可以在给定某一帧的情况下构建调用堆栈。"

#: ../../library/sys.rst:217
msgid ""
"This is most useful for debugging deadlock:  this function does not require "
"the deadlocked threads' cooperation, and such threads' call stacks are "
"frozen for as long as they remain deadlocked.  The frame returned for a non-"
"deadlocked thread may bear no relationship to that thread's current activity"
" by the time calling code examines the frame."
msgstr ""
"这对于调试死锁最有用：本函数不需要死锁线程的配合，并且只要这些线程的调用栈保持死锁，它们就是冻结的。在调用本代码来检查栈顶的帧的那一刻，非死锁线程返回的帧可能与该线程当前活动的帧没有任何关系。"

#: ../../library/sys.rst:225
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._current_frames`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys._current_frames``。"

#: ../../library/sys.rst:229
msgid ""
"Return a dictionary mapping each thread's identifier to the topmost "
"exception currently active in that thread at the time the function is "
"called. If a thread is not currently handling an exception, it is not "
"included in the result dictionary."
msgstr ""
"返回一个字典，存放着每个线程的标识与调用此函数时该线程当前活动帧的栈顶异常之间的映射。 如果某个线程当前未在处理异常，它将不被包括在结果字典中。"

#: ../../library/sys.rst:234
msgid "This is most useful for statistical profiling."
msgstr "这对于静态性能分析来说最为有用。"

#: ../../library/sys.rst:238
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._current_exceptions`` with "
"no arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys._current_exceptions``。"

#: ../../library/sys.rst:240
msgid ""
"Each value in the dictionary is now a single exception instance, rather than"
" a 3-tuple as returned from ``sys.exc_info()``."
msgstr "现在字典中的每个值都是单独的异常实例，而不是如 ``sys.exc_info()`` 所返回的 3 元组。"

#: ../../library/sys.rst:246
msgid ""
"This hook function is called by built-in :func:`breakpoint`.  By default, it"
" drops you into the :mod:`pdb` debugger, but it can be set to any other "
"function so that you can choose which debugger gets used."
msgstr ""
"本钩子函数由内建函数 :func:`breakpoint` 调用。默认情况下，它将进入 :mod:`pdb` "
"调试器，但可以将其改为任何其他函数，以选择使用哪个调试器。"

#: ../../library/sys.rst:250
msgid ""
"The signature of this function is dependent on what it calls.  For example, "
"the default binding (e.g. ``pdb.set_trace()``) expects no arguments, but you"
" might bind it to a function that expects additional arguments (positional "
"and/or keyword).  The built-in ``breakpoint()`` function passes its "
"``*args`` and ``**kws`` straight through.  Whatever ``breakpointhooks()`` "
"returns is returned from ``breakpoint()``."
msgstr ""
"该函数的特征取决于其调用的函数。例如，默认绑定（即 ``pdb.set_trace()`` "
"）不要求提供参数，但可以将绑定换成要求提供附加参数（位置参数/关键字参数）的函数。内建函数 ``breakpoint()`` 直接将其 "
"``*args`` 和 ``**kws`` 传入。``breakpointhooks()`` 返回的所有内容都会从 ``breakpoint()`` "
"返回。"

#: ../../library/sys.rst:257
msgid ""
"The default implementation first consults the environment variable "
":envvar:`PYTHONBREAKPOINT`.  If that is set to ``\"0\"`` then this function "
"returns immediately; i.e. it is a no-op.  If the environment variable is not"
" set, or is set to the empty string, ``pdb.set_trace()`` is called. "
"Otherwise this variable should name a function to run, using Python's "
"dotted-import nomenclature, e.g. ``package.subpackage.module.function``. In "
"this case, ``package.subpackage.module`` would be imported and the resulting"
" module must have a callable named ``function()``.  This is run, passing in "
"``*args`` and ``**kws``, and whatever ``function()`` returns, "
"``sys.breakpointhook()`` returns to the built-in :func:`breakpoint` "
"function."
msgstr ""
"默认的实现首先会查询环境变量 :envvar:`PYTHONBREAKPOINT`。如果将该变量设置为 "
"``\"0\"``，则本函数立即返回，表示在断点处无操作。如果未设置该环境变量或将其设置为空字符串，则调用 "
"``pdb.set_trace()``。否则，此变量应指定要运行的函数，指定函数时应使用 Python 的点导入命名法，如 "
"``package.subpackage.module.function``。这种情况下将导入 "
"``package.subpackage.module``，且导入的模块必须有一个名为 ``function()`` "
"的可调用对象。该可调用对象会运行，``*args`` 和 ``**kws`` 会传入，且无论 ``function()`` "
"返回什么，``sys.breakpointhook()`` 都将返回到內建函数 :func:`breakpoint`。"

#: ../../library/sys.rst:269
msgid ""
"Note that if anything goes wrong while importing the callable named by "
":envvar:`PYTHONBREAKPOINT`, a :exc:`RuntimeWarning` is reported and the "
"breakpoint is ignored."
msgstr ""
"请注意，如果在导入 :envvar:`PYTHONBREAKPOINT` 指定的可调用对象时出错，则将报告一个 "
":exc:`RuntimeWarning` 并忽略断点。"

#: ../../library/sys.rst:273
msgid ""
"Also note that if ``sys.breakpointhook()`` is overridden programmatically, "
":envvar:`PYTHONBREAKPOINT` is *not* consulted."
msgstr ""
"另请注意，如果以编程方式覆盖 ``sys.breakpointhook()``，则 *不会* 查询 "
":envvar:`PYTHONBREAKPOINT`。"

#: ../../library/sys.rst:280
msgid ""
"Print low-level information to stderr about the state of CPython's memory "
"allocator."
msgstr "将有关 CPython 内存分配器状态的底层的信息打印至 stderr。"

#: ../../library/sys.rst:283
msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (:option:`configure "
"--with-pydebug option <--with-pydebug>`), it also performs some expensive "
"internal consistency checks."
msgstr ""
"如果 Python 是 :ref:`以调试模式编译的 <debug-build>` (:option:`使用 --with-pydebug 配置选项 "
"<--with-pydebug>`)，它还会执行某些高开销的内部一致性检查。"

#: ../../library/sys.rst:291
msgid ""
"This function is specific to CPython.  The exact output format is not "
"defined here, and may change."
msgstr "本函数仅限 CPython。此处没有定义确切的输出格式，且可能会更改。"

#: ../../library/sys.rst:297
msgid "Integer specifying the handle of the Python DLL."
msgstr "指向 Python DLL 句柄的整数。"

#: ../../library/sys.rst:304
msgid ""
"If *value* is not ``None``, this function prints ``repr(value)`` to "
"``sys.stdout``, and saves *value* in ``builtins._``. If ``repr(value)`` is "
"not encodable to ``sys.stdout.encoding`` with ``sys.stdout.errors`` error "
"handler (which is probably ``'strict'``), encode it to "
"``sys.stdout.encoding`` with ``'backslashreplace'`` error handler."
msgstr ""
"如果 *value* 不是 ``None``，则本函数会将 ``repr(value)`` 打印至 ``sys.stdout``，并将 *value* "
"保存在 ``builtins._`` 中。如果 ``repr(value)`` 无法用 ``sys.stdout.errors`` 错误处理方案（可能为"
" ``'strict'`` ）编码为 ``sys.stdout.encoding``，则用 ``'backslashreplace'`` "
"错误处理方案将其编码为 ``sys.stdout.encoding``。"

#: ../../library/sys.rst:310
msgid ""
"``sys.displayhook`` is called on the result of evaluating an "
":term:`expression` entered in an interactive Python session.  The display of"
" these values can be customized by assigning another one-argument function "
"to ``sys.displayhook``."
msgstr ""
"在交互式 Python 会话中运行 :term:`expression` 产生结果后，将在结果上调用 "
"``sys.displayhook``。若要自定义这些 value 的显示，可以将 ``sys.displayhook`` 指定为另一个单参数函数。"

#: ../../library/sys.rst:314
msgid "Pseudo-code::"
msgstr "伪代码::"

#: ../../library/sys.rst:316
msgid ""
"def displayhook(value):\n"
"    if value is None:\n"
"        return\n"
"    # Set '_' to None to avoid recursion\n"
"    builtins._ = None\n"
"    text = repr(value)\n"
"    try:\n"
"        sys.stdout.write(text)\n"
"    except UnicodeEncodeError:\n"
"        bytes = text.encode(sys.stdout.encoding, 'backslashreplace')\n"
"        if hasattr(sys.stdout, 'buffer'):\n"
"            sys.stdout.buffer.write(bytes)\n"
"        else:\n"
"            text = bytes.decode(sys.stdout.encoding, 'strict')\n"
"            sys.stdout.write(text)\n"
"    sys.stdout.write(\"\\n\")\n"
"    builtins._ = value"
msgstr ""
"def displayhook(value):\n"
"    if value is None:\n"
"        return\n"
"    # 将 '_' 设为 None 以避免继续递归\n"
"    builtins._ = None\n"
"    text = repr(value)\n"
"    try:\n"
"        sys.stdout.write(text)\n"
"    except UnicodeEncodeError:\n"
"        bytes = text.encode(sys.stdout.encoding, 'backslashreplace')\n"
"        if hasattr(sys.stdout, 'buffer'):\n"
"            sys.stdout.buffer.write(bytes)\n"
"        else:\n"
"            text = bytes.decode(sys.stdout.encoding, 'strict')\n"
"            sys.stdout.write(text)\n"
"    sys.stdout.write(\"\\n\")\n"
"    builtins._ = value"

#: ../../library/sys.rst:334
msgid "Use ``'backslashreplace'`` error handler on :exc:`UnicodeEncodeError`."
msgstr "在发生 :exc:`UnicodeEncodeError` 时使用 ``'backslashreplace'`` 错误处理方案。"

#: ../../library/sys.rst:340
msgid ""
"If this is true, Python won't try to write ``.pyc`` files on the import of "
"source modules.  This value is initially set to ``True`` or ``False`` "
"depending on the :option:`-B` command line option and the "
":envvar:`PYTHONDONTWRITEBYTECODE` environment variable, but you can set it "
"yourself to control bytecode file generation."
msgstr ""
"如果该值为 true，则 Python 在导入源码模块时将不会尝试写入 ``.pyc`` 文件。该值会被初始化为 ``True`` 或 "
"``False``，依据是 :option:`-B` 命令行选项和 :envvar:`PYTHONDONTWRITEBYTECODE` "
"环境变量，可以自行设置该值，来控制是否生成字节码文件。"

#: ../../library/sys.rst:349
msgid ""
"A :term:`named tuple` holding information about the environment on the "
"*wasm32-emscripten* platform. The named tuple is provisional and may change "
"in the future."
msgstr ""
"这个 :term:`named tuple` 保存了 *wasm32-emscripten* 平台中环境的相关信息。 "
"该命名元组处于暂定状态并可能在将来被更改。"

#: ../../library/sys.rst:355
msgid ""
"Emscripten version as tuple of ints (major, minor, micro), e.g. ``(3, 1, "
"8)``."
msgstr "以整数元组 (major, minor, micro) 表示的 Emscripten 版本，例如 ``(3, 1, 8)``。"

#: ../../library/sys.rst:359
msgid ""
"Runtime string, e.g. browser user agent, ``'Node.js v14.18.2'``, or "
"``'UNKNOWN'``."
msgstr "运行时字符串，例如 browser user agent, ``'Node.js v14.18.2'`` 或 ``'UNKNOWN'``。"

#: ../../library/sys.rst:363
msgid "``True`` if Python is compiled with Emscripten pthreads support."
msgstr "如果 Python 编译附带了 Emscripten pthreads 支持则为 ``True``。"

#: ../../library/sys.rst:367
msgid "``True`` if Python is compiled with shared memory support."
msgstr "如果 Python 编译附带了共享内存支持则为 ``True``。"

#: ../../library/sys.rst:376
msgid ""
"If this is set (not ``None``), Python will write bytecode-cache ``.pyc`` "
"files to (and read them from) a parallel directory tree rooted at this "
"directory, rather than from ``__pycache__`` directories in the source code "
"tree. Any ``__pycache__`` directories in the source code tree will be "
"ignored and new ``.pyc`` files written within the pycache prefix. Thus if "
"you use :mod:`compileall` as a pre-build step, you must ensure you run it "
"with the same pycache prefix (if any) that you will use at runtime."
msgstr ""
"如果设置了该值 (不能为 ``None``)，Python 会将字节码缓存文件 ``.pyc`` "
"写入到以该值指定的目录为根的并行目录树中（并从中读取），而不是在源代码树的 ``__pycache__`` 目录下读写。 源代码树中所有的 "
"``__pycache__`` 目录都将被忽略并且新的 ``.pyc`` 文件将被写入到 pycache 前缀指定的位置。 因此如果你使用 "
":mod:`compileall` 作为预编译步骤，你必须确保使用与在运行时相同的 pycache 前缀（如果有的话）来运行它。"

#: ../../library/sys.rst:384
msgid ""
"A relative path is interpreted relative to the current working directory."
msgstr "相对路径将解释为相对于当前工作目录。"

#: ../../library/sys.rst:386
msgid ""
"This value is initially set based on the value of the :option:`-X` "
"``pycache_prefix=PATH`` command-line option or the "
":envvar:`PYTHONPYCACHEPREFIX` environment variable (command-line takes "
"precedence). If neither are set, it is ``None``."
msgstr ""
"该值的初值设置，依据 :option:`-X` ``pycache_prefix=PATH`` 命令行选项或 "
":envvar:`PYTHONPYCACHEPREFIX` 环境变量的值（命令行优先）。如果两者均未设置，则为 ``None``。"

#: ../../library/sys.rst:396
msgid ""
"This function prints out a given traceback and exception to ``sys.stderr``."
msgstr "本函数会将所给的回溯和异常输出到 ``sys.stderr`` 中。"

#: ../../library/sys.rst:398
msgid ""
"When an exception other than :exc:`SystemExit` is raised and uncaught, the "
"interpreter calls ``sys.excepthook`` with three arguments, the exception "
"class, exception instance, and a traceback object.  In an interactive "
"session this happens just before control is returned to the prompt; in a "
"Python program this happens just before the program exits.  The handling of "
"such top-level exceptions can be customized by assigning another three-"
"argument function to ``sys.excepthook``."
msgstr ""
"当有 :exc:`SystemExit` 以外的异常被引发且未被捕获时，解释器会调用 ``sys.excepthook`` "
"并附带三个参数：异常类、异常实例和回溯对象。 在交互会话中这将发生在控制返回提示符之前；在 Python 程序中这将发生在程序退出之前。 "
"这种最高层级异常的处理可以通过为 ``sys.excepthook`` 指定另一个三参数函数来实现自定义。"

#: ../../library/sys.rst:405 ../../library/sys.rst:407
msgid ""
"Raise an auditing event ``sys.excepthook`` with arguments ``hook``, "
"``type``, ``value``, ``traceback`` when an uncaught exception occurs. If no "
"hook has been set, ``hook`` may be ``None``. If any hook raises an exception"
" derived from :class:`RuntimeError` the call to the hook will be suppressed."
" Otherwise, the audit hook exception will be reported as unraisable and "
"``sys.excepthook`` will be called."
msgstr ""
"当发生未捕获的异常时，引发一个审计事件 ``sys.excepthook``，附带参数 ``hook``, ``type``, ``value``, "
"``traceback``。如果没有设置钩子，``hook`` 可能为 ``None``。如果某个钩子抛出了派生自 "
":class:`RuntimeError` 的异常，则将禁止对该钩子的调用。否则，审计钩子的异常将被报告为无法抛出，并将调用 "
"``sys.excepthook``。"

#: ../../library/sys.rst:416
msgid ""
"The :func:`sys.unraisablehook` function handles unraisable exceptions and "
"the :func:`threading.excepthook` function handles exception raised by "
":func:`threading.Thread.run`."
msgstr ""
":func:`sys.unraisablehook` 函数处理无法抛出的异常，:func:`threading.excepthook` 函数处理 "
":func:`threading.Thread.run` 抛出的异常。"

#: ../../library/sys.rst:426
msgid ""
"These objects contain the original values of ``breakpointhook``, "
"``displayhook``, ``excepthook``, and ``unraisablehook`` at the start of the "
"program.  They are saved so that ``breakpointhook``, ``displayhook`` and "
"``excepthook``, ``unraisablehook`` can be restored in case they happen to "
"get replaced with broken or alternative objects."
msgstr ""
"程序开始时，这些对象存有 ``breakpointhook``、``displayhook``、``excepthook`` 和 "
"``unraisablehook`` 的初始值。保存它们是为了可以在 ``breakpointhook``、``displayhook`` 和 "
"``excepthook``、``unraisablehook`` 被破坏或被替换时恢复它们。"

#: ../../library/sys.rst:432
msgid "__breakpointhook__"
msgstr "__breakpointhook__"

#: ../../library/sys.rst:435
msgid "__unraisablehook__"
msgstr "__unraisablehook__"

#: ../../library/sys.rst:441
msgid ""
"This function, when called while an exception handler is executing (such as "
"an ``except`` or ``except*`` clause), returns the exception instance that "
"was caught by this handler. When exception handlers are nested within one "
"another, only the exception handled by the innermost handler is accessible."
msgstr ""
"当此函数在某个异常处理器执行过程中（如 ``except`` 或 ``except*`` 子句）被调用时，将返回被该处理器所捕获的异常实例。 "
"当有多个异常处理器彼此嵌套时，只有最内层处理器所处理的异常可以被访问到。"

#: ../../library/sys.rst:446
msgid "If no exception handler is executing, this function returns ``None``."
msgstr "如果没有任何异常处理器在执行，此函数将返回 ``None``。"

#: ../../library/sys.rst:453
msgid ""
"This function returns the old-style representation of the handled exception."
" If an exception ``e`` is currently handled (so :func:`exception` would "
"return ``e``), :func:`exc_info` returns the tuple ``(type(e), e, "
"e.__traceback__)``. That is, a tuple containing the type of the exception (a"
" subclass of :exc:`BaseException`), the exception itself, and a "
":ref:`traceback object <traceback-objects>` which typically encapsulates the"
" call stack at the point where the exception last occurred."
msgstr ""
"此函数返回被处理异常的旧式表示形式。 如果异常 ``e`` 当前已被处理 (因此 :func:`exception` 将会返回 ``e``)，则 "
":func:`exc_info` 将返回元组 ``(type(e), e, e.__traceback__)``。 也就是说，一个包含了该异常类型 "
"(:exc:`BaseException` 的子类) ，异常本身，以及通常封装了异常最后发生位置上调用栈的 :ref:`回溯对象 <traceback-"
"objects>` 的元组。"

#: ../../library/sys.rst:464
msgid ""
"If no exception is being handled anywhere on the stack, this function return"
" a tuple containing three ``None`` values."
msgstr "如果堆栈上的任何地方都没有处理异常，则此函数将返回一个包含三个 ``None`` 的元组。"

#: ../../library/sys.rst:467
msgid ""
"The ``type`` and ``traceback`` fields are now derived from the ``value`` "
"(the exception instance), so when an exception is modified while it is being"
" handled, the changes are reflected in the results of subsequent calls to "
":func:`exc_info`."
msgstr ""
"``type`` 和 ``traceback`` 字段现在是派生自 ``value`` (异常实例)，因此当一个异常在处理期间被修改时，其变化会在后续对"
" :func:`exc_info` 的调用结果中反映出来。"

#: ../../library/sys.rst:475
msgid ""
"A string giving the site-specific directory prefix where the platform-"
"dependent Python files are installed; by default, this is also "
"``'/usr/local'``.  This can be set at build time with the ``--exec-prefix`` "
"argument to the :program:`configure` script.  Specifically, all "
"configuration files (e.g. the :file:`pyconfig.h` header file) are installed "
"in the directory :file:`{exec_prefix}/lib/python{X.Y}/config`, and shared "
"library modules are installed in :file:`{exec_prefix}/lib/python{X.Y}/lib-"
"dynload`, where *X.Y* is the version number of Python, for example ``3.2``."
msgstr ""
"一个字符串，提供特定域的目录前缀，该目录中安装了与平台相关的 Python 文件，默认也是 ``'/usr/local'``。该目录前缀可以在构建时使用"
" :program:`configure` 脚本的 ``--exec-prefix`` 参数进行设置。具体而言，所有配置文件（如 "
":file:`pyconfig.h` 头文件）都安装在目录 :file:`{exec_prefix}/lib/python{X.Y}/config` "
"中，共享库模块安装在 :file:`{exec_prefix}/lib/python{X.Y}/lib-dynload` 中，其中 *X.Y* 是 "
"Python 的版本号，如 ``3.2``。"

#: ../../library/sys.rst:486
msgid ""
"If a :ref:`virtual environment <venv-def>` is in effect, this value will be "
"changed in ``site.py`` to point to the virtual environment. The value for "
"the Python installation will still be available, via "
":data:`base_exec_prefix`."
msgstr ""
"如果在一个 :ref:`虚拟环境 <venv-def>` 中，那么该值将在 ``site.py`` 中被修改，指向虚拟环境。Python "
"安装位置仍然可以用 :data:`base_exec_prefix` 来获取。"

#: ../../library/sys.rst:494
msgid ""
"A string giving the absolute path of the executable binary for the Python "
"interpreter, on systems where this makes sense. If Python is unable to "
"retrieve the real path to its executable, :data:`sys.executable` will be an "
"empty string or ``None``."
msgstr ""
"一个字符串，提供 Python 解释器的可执行二进制文件的绝对路径，仅在部分系统中此值有意义。如果 Python 无法获取其可执行文件的真实路径，则 "
":data:`sys.executable` 将为空字符串或 ``None``。"

#: ../../library/sys.rst:502
msgid ""
"Raise a :exc:`SystemExit` exception, signaling an intention to exit the "
"interpreter."
msgstr "引发一个 :exc:`SystemExit` 异常，表示打算退出解释器。"

#: ../../library/sys.rst:504
msgid ""
"The optional argument *arg* can be an integer giving the exit status "
"(defaulting to zero), or another type of object.  If it is an integer, zero "
"is considered \"successful termination\" and any nonzero value is considered"
" \"abnormal termination\" by shells and the like.  Most systems require it "
"to be in the range 0--127, and produce undefined results otherwise.  Some "
"systems have a convention for assigning specific meanings to specific exit "
"codes, but these are generally underdeveloped; Unix programs generally use 2"
" for command line syntax errors and 1 for all other kind of errors.  If "
"another type of object is passed, ``None`` is equivalent to passing zero, "
"and any other object is printed to :data:`stderr` and results in an exit "
"code of 1.  In particular, ``sys.exit(\"some error message\")`` is a quick "
"way to exit a program when an error occurs."
msgstr ""
"可选参数 *arg* 可以是表示退出状态的整数（默认为 0），也可以是其他类型的对象。如果它是整数，则 shell 等将 0 "
"视为“成功终止”，非零值视为“异常终止”。大多数系统要求该值的范围是 0--"
"127，否则会产生不确定的结果。某些系统为退出代码约定了特定的含义，但通常尚不完善；Unix 程序通常用 2 表示命令行语法错误，用 1 "
"表示所有其他类型的错误。传入其他类型的对象，如果传入 ``None`` 等同于传入 0，如果传入其他对象则将其打印至 "
":data:`stderr`，且退出代码为 1。特别地，``sys.exit(\"some error message\")`` "
"可以在发生错误时快速退出程序。"

#: ../../library/sys.rst:517
msgid ""
"Since :func:`exit` ultimately \"only\" raises an exception, it will only "
"exit the process when called from the main thread, and the exception is not "
"intercepted. Cleanup actions specified by finally clauses of :keyword:`try` "
"statements are honored, and it is possible to intercept the exit attempt at "
"an outer level."
msgstr ""
"由于 :func:`exit` 最终 \"只\" 引发了一个异常，它只在从主线程调用时退出进程，而异常不会被拦截。 :keyword:`try` 语句的"
" finally 子句所指定的清理动作会被遵守，并且有可能在外层拦截退出的尝试。"

#: ../../library/sys.rst:522
msgid ""
"If an error occurs in the cleanup after the Python interpreter has caught "
":exc:`SystemExit` (such as an error flushing buffered data in the standard "
"streams), the exit status is changed to 120."
msgstr ""
"在 Python 解释器捕获 :exc:`SystemExit` 后，如果在清理中发生错误（如清除标准流中的缓冲数据时出错），则退出状态码将变为 "
"120。"

#: ../../library/sys.rst:530
msgid ""
"The :term:`named tuple` *flags* exposes the status of command line flags. "
"The attributes are read only."
msgstr ":term:`具名元组 <named tuple>` *flags* 含有命令行标志的状态。这些属性是只读的。"

#: ../../library/sys.rst:536
msgid ":option:`-d`"
msgstr ":option:`-d`"

#: ../../library/sys.rst:539 ../../library/sys.rst:542
msgid ":option:`-i`"
msgstr ":option:`-i`"

#: ../../library/sys.rst:545
msgid ":option:`-I`"
msgstr ":option:`-I`"

#: ../../library/sys.rst:548
msgid ":option:`-O` or :option:`-OO`"
msgstr ":option:`-O` 或 :option:`-OO`"

#: ../../library/sys.rst:551
msgid ":option:`-B`"
msgstr ":option:`-B`"

#: ../../library/sys.rst:554
msgid ":option:`-s`"
msgstr ":option:`-s`"

#: ../../library/sys.rst:557
msgid ":option:`-S`"
msgstr ":option:`-S`"

#: ../../library/sys.rst:560
msgid ":option:`-E`"
msgstr ":option:`-E`"

#: ../../library/sys.rst:563
msgid ":option:`-v`"
msgstr ":option:`-v`"

#: ../../library/sys.rst:566
msgid ":option:`-b`"
msgstr ":option:`-b`"

#: ../../library/sys.rst:569
msgid ":option:`-q`"
msgstr ":option:`-q`"

#: ../../library/sys.rst:572
msgid ":option:`-R`"
msgstr ":option:`-R`"

#: ../../library/sys.rst:575
msgid ":option:`-X dev <-X>` (:ref:`Python Development Mode <devmode>`)"
msgstr ":option:`-X dev <-X>` (:ref:`Python 开发模式 <devmode>`)"

#: ../../library/sys.rst:578
msgid ":option:`-X utf8 <-X>`"
msgstr ":option:`-X utf8 <-X>`"

#: ../../library/sys.rst:581
msgid ":option:`-P`"
msgstr ":option:`-P`"

#: ../../library/sys.rst:584
msgid ""
":option:`-X int_max_str_digits <-X>` (:ref:`integer string conversion length"
" limitation <int_max_str_digits>`)"
msgstr ""
":option:`-X int_max_str_digits <-X>` (:ref:`integer string conversion length"
" limitation <int_max_str_digits>`)"

#: ../../library/sys.rst:588
msgid ":option:`-X warn_default_encoding <-X>`"
msgstr ":option:`-X warn_default_encoding <-X>`"

#: ../../library/sys.rst:590
msgid "Added ``quiet`` attribute for the new :option:`-q` flag."
msgstr "为新的 :option:`-q` 标志添加了 ``quiet`` 属性"

#: ../../library/sys.rst:593
msgid "The ``hash_randomization`` attribute."
msgstr "``hash_randomization`` 属性"

#: ../../library/sys.rst:596
msgid "Removed obsolete ``division_warning`` attribute."
msgstr "删除了过时的 ``division_warning`` 属性"

#: ../../library/sys.rst:599
msgid "Added ``isolated`` attribute for :option:`-I` ``isolated`` flag."
msgstr "为 :option:`-I` ``isolated`` 标志添加了 ``isolated`` 属性。"

#: ../../library/sys.rst:602
msgid ""
"Added the ``dev_mode`` attribute for the new :ref:`Python Development Mode "
"<devmode>` and the ``utf8_mode`` attribute for the new  :option:`-X` "
"``utf8`` flag."
msgstr ""
"为新的 :ref:`Python 开发模式 <devmode>` 添加了 ``dev_mode`` 属性，为新的 :option:`-X` "
"``utf8`` 标志添加了 ``utf8_mode`` 属性。"

#: ../../library/sys.rst:607
msgid ""
"Added ``warn_default_encoding`` attribute for :option:`-X` "
"``warn_default_encoding`` flag."
msgstr ""
"为 :option:`-X` ``warn_default_encoding`` 旗标添加了 ``warn_default_encoding`` 属性。"

#: ../../library/sys.rst:610
msgid "Added the ``safe_path`` attribute for :option:`-P` option."
msgstr "添加了用于 :option:`-P` 选项的 ``safe_path`` 属性。"

#: ../../library/sys.rst:613
msgid "Added the ``int_max_str_digits`` attribute."
msgstr "增加了 ``int_max_str_digits`` 属性。"

#: ../../library/sys.rst:619
msgid ""
"A :term:`named tuple` holding information about the float type. It contains "
"low level information about the precision and internal representation.  The "
"values correspond to the various floating-point constants defined in the "
"standard header file :file:`float.h` for the 'C' programming language; see "
"section 5.2.4.2.2 of the 1999 ISO/IEC C standard [C99]_, 'Characteristics of"
" floating types', for details."
msgstr ""
"一个 :term:`具名元组 <named tuple>`，存有浮点型的相关信息。它包含的是关于精度和内部表示的底层信息。这些值与标准头文件 "
":file:`float.h` 中为 C 语言定义的各种浮点常量对应，详情请参阅 1999 ISO/IEC C 标准 [C99]_ 的 "
"5.2.4.2.2 节，'Characteristics of floating types（浮点型的特性）'。"

#: ../../library/sys.rst:626
msgid "Attributes of the :data:`!float_info` :term:`named tuple`"
msgstr ":data:`!float_info` :term:`named tuple` 的属性"

#: ../../library/sys.rst:629
msgid "attribute"
msgstr "attribute -- 属性"

#: ../../library/sys.rst:630
msgid "float.h macro"
msgstr "float.h 宏"

#: ../../library/sys.rst:631
msgid "explanation"
msgstr "说明"

#: ../../library/sys.rst:634
msgid ":c:macro:`!DBL_EPSILON`"
msgstr ":c:macro:`!DBL_EPSILON`"

#: ../../library/sys.rst:635
msgid ""
"difference between 1.0 and the least value greater than 1.0 that is "
"representable as a float."
msgstr "1.0 与可表示为浮点数的大于 1.0 的最小值之间的差。"

#: ../../library/sys.rst:638
msgid "See also :func:`math.ulp`."
msgstr "另请参阅 :func:`math.ulp`。"

#: ../../library/sys.rst:641
msgid ":c:macro:`!DBL_DIG`"
msgstr ":c:macro:`!DBL_DIG`"

#: ../../library/sys.rst:642
msgid ""
"The maximum number of decimal digits that can be faithfully represented in a"
" float; see below."
msgstr "浮点数可以真实表示的十进制数的最大位数；见下文。"

#: ../../library/sys.rst:646
msgid ":c:macro:`!DBL_MANT_DIG`"
msgstr ":c:macro:`!DBL_MANT_DIG`"

#: ../../library/sys.rst:647
msgid ""
"Float precision: the number of base-``radix`` digits in the significand of a"
" float."
msgstr "浮点数精度：以 ``radix`` 为基数浮点数的有效位数。"

#: ../../library/sys.rst:651
msgid ":c:macro:`!DBL_MAX`"
msgstr ":c:macro:`!DBL_MAX`"

#: ../../library/sys.rst:652
msgid "The maximum representable positive finite float."
msgstr "可表示的最大正有限浮点数。"

#: ../../library/sys.rst:655
msgid ":c:macro:`!DBL_MAX_EXP`"
msgstr ":c:macro:`!DBL_MAX_EXP`"

#: ../../library/sys.rst:656
msgid ""
"The maximum integer *e* such that ``radix**(e-1)`` is a representable finite"
" float."
msgstr "使得 ``radix**(e-1)`` 是可表示的有限浮点数的最大整数 *e*。"

#: ../../library/sys.rst:660
msgid ":c:macro:`!DBL_MAX_10_EXP`"
msgstr ":c:macro:`!DBL_MAX_10_EXP`"

#: ../../library/sys.rst:661
msgid ""
"The maximum integer *e* such that ``10**e`` is in the range of representable"
" finite floats."
msgstr "使得 ``10**e`` 在可表示的有限浮点数范围内的最大整数 *e*。"

#: ../../library/sys.rst:665
msgid ":c:macro:`!DBL_MIN`"
msgstr ":c:macro:`!DBL_MIN`"

#: ../../library/sys.rst:666
msgid "The minimum representable positive *normalized* float."
msgstr "可表示的最小正 *规范化* 浮点数。"

#: ../../library/sys.rst:668
msgid ""
"Use :func:`math.ulp(0.0) <math.ulp>` to get the smallest positive "
"*denormalized* representable float."
msgstr "使用 :func:`math.ulp(0.0) <math.ulp>` 获取可表示的最小正 *非规格化* 浮点数"

#: ../../library/sys.rst:672
msgid ":c:macro:`!DBL_MIN_EXP`"
msgstr ":c:macro:`!DBL_MIN_EXP`"

#: ../../library/sys.rst:673
msgid ""
"The minimum integer *e* such that ``radix**(e-1)`` is a normalized float."
msgstr "使得 ``radix**(e-1)`` 是规范化浮点数的最小整数 *e*。"

#: ../../library/sys.rst:677
msgid ":c:macro:`!DBL_MIN_10_EXP`"
msgstr ":c:macro:`!DBL_MIN_10_EXP`"

#: ../../library/sys.rst:678
msgid "The minimum integer *e* such that ``10**e`` is a normalized float."
msgstr "使得 ``10**e`` 是归范化浮点数的最小整数 *e*。"

#: ../../library/sys.rst:681
msgid ":c:macro:`!FLT_RADIX`"
msgstr ":c:macro:`!FLT_RADIX`"

#: ../../library/sys.rst:682
msgid "The radix of exponent representation."
msgstr "指数表示法中采用的基数。"

#: ../../library/sys.rst:685
msgid ":c:macro:`!FLT_ROUNDS`"
msgstr ":c:macro:`!FLT_ROUNDS`"

#: ../../library/sys.rst:686
msgid ""
"An integer representing the rounding mode for floating-point arithmetic. "
"This reflects the value of the system :c:macro:`!FLT_ROUNDS` macro at "
"interpreter startup time:"
msgstr "一个代表浮点运算舍入模式的整数。 它反映了解释器启动时系统 :c:macro:`!FLT_ROUNDS` 宏的值："

#: ../../library/sys.rst:690
msgid "``-1``: indeterminable"
msgstr "``-1``: 不确定"

#: ../../library/sys.rst:691
msgid "``0``: toward zero"
msgstr "``0``: 向零值"

#: ../../library/sys.rst:692
msgid "``1``: to nearest"
msgstr "``1``: 向最近值"

#: ../../library/sys.rst:693
msgid "``2``: toward positive infinity"
msgstr "``2``: 向正无穷"

#: ../../library/sys.rst:694
msgid "``3``: toward negative infinity"
msgstr "``3``: 向负无穷"

#: ../../library/sys.rst:696
msgid ""
"All other values for :c:macro:`!FLT_ROUNDS` characterize implementation-"
"defined rounding behavior."
msgstr ":c:macro:`!FLT_ROUNDS` 的所有其他值被用于代表具体实现所定义的舍入行为。"

#: ../../library/sys.rst:699
msgid ""
"The attribute :attr:`sys.float_info.dig` needs further explanation.  If "
"``s`` is any string representing a decimal number with at most "
":attr:`!sys.float_info.dig` significant digits, then converting ``s`` to a "
"float and back again will recover a string representing the same decimal "
"value::"
msgstr ""
"属性 :attr:`sys.float_info.dig` 需要进一步的解释。 如果 ``s`` 是表示十进制数的字符串，且最多有 "
":attr:`!sys.float_info.dig` 位有效数字，那么将 ``s`` 转换为浮点数再转换回来将恢复为一个表示相同十进制值的字符串::"

#: ../../library/sys.rst:705
msgid ""
">>> import sys\n"
">>> sys.float_info.dig\n"
"15\n"
">>> s = '3.14159265358979'    # decimal string with 15 significant digits\n"
">>> format(float(s), '.15g')  # convert to float and back -> same value\n"
"'3.14159265358979'"
msgstr ""
">>> import sys\n"
">>> sys.float_info.dig\n"
"15\n"
">>> s = '3.14159265358979'    # 有 15 个有效位的十进制小数字节串\n"
">>> format(float(s), '.15g')  # 转换为浮点数再转换回来 -> 相同的值\n"
"'3.14159265358979'"

#: ../../library/sys.rst:712
msgid ""
"But for strings with more than :attr:`sys.float_info.dig` significant "
"digits, this isn't always true::"
msgstr "但是对于超过 :attr:`sys.float_info.dig` 位有效数字的字符串，转换前后并非总是相同::"

#: ../../library/sys.rst:715
msgid ""
">>> s = '9876543211234567'    # 16 significant digits is too many!\n"
">>> format(float(s), '.16g')  # conversion changes value\n"
"'9876543211234568'"
msgstr ""
">>> s = '9876543211234567'    # 16 个有效位就太多了！\n"
">>> format(float(s), '.16g')  # 转换将改变原值\n"
"'9876543211234568'"

#: ../../library/sys.rst:721
msgid ""
"A string indicating how the :func:`repr` function behaves for floats.  If "
"the string has value ``'short'`` then for a finite float ``x``, ``repr(x)`` "
"aims to produce a short string with the property that ``float(repr(x)) == "
"x``.  This is the usual behaviour in Python 3.1 and later.  Otherwise, "
"``float_repr_style`` has value ``'legacy'`` and ``repr(x)`` behaves in the "
"same way as it did in versions of Python prior to 3.1."
msgstr ""
"一个字符串，反映 :func:`repr` 函数在浮点数上的行为。如果该字符串是 ``'short'``，那么对于（非无穷的）浮点数 "
"``x``，``repr(x)`` 将会生成一个短字符串，满足 ``float(repr(x)) == x`` 的特性。这是 Python 3.1 "
"及更高版本中的常见行为。否则 ``float_repr_style`` 的值将是 ``'legacy'``，此时 ``repr(x)`` 的行为方式将与"
" Python 3.1 之前的版本相同。"

#: ../../library/sys.rst:734
msgid ""
"Return the number of memory blocks currently allocated by the interpreter, "
"regardless of their size.  This function is mainly useful for tracking and "
"debugging memory leaks.  Because of the interpreter's internal caches, the "
"result can vary from call to call; you may have to call "
":func:`_clear_internal_caches` and :func:`gc.collect` to get more "
"predictable results."
msgstr ""
"返回解释器当前已分配的内存块数，无论它们的大小如何。 此函数主要用于跟踪和调试内存泄漏。 "
"因为解释器有内部缓存，所以不同调用的结果会有变化；你可能需要调用 :func:`_clear_internal_caches` 和 "
":func:`gc.collect` 来获得更可预测的结果。"

#: ../../library/sys.rst:741
msgid ""
"If a Python build or implementation cannot reasonably compute this "
"information, :func:`getallocatedblocks` is allowed to return 0 instead."
msgstr "如果一个 Python 构建或实现无法合理地计算此信息，则允许 :func:`getallocatedblocks` 返回 0。"

#: ../../library/sys.rst:749
msgid "Return the number of unicode objects that have been interned."
msgstr "返回已被处置的 unicode 对象数量。"

#: ../../library/sys.rst:756
msgid ""
"Return the build-time API level of Android as an integer. This represents "
"the minimum version of Android this build of Python can run on. For runtime "
"version information, see :func:`platform.android_ver`."
msgstr ""
"以一个整数的形式返回 Android 的构建时级别。 这代表此 Python 构建版可运行的最小 Android 版本。 对于运行时版本信息，请查看 "
":func:`platform.android_ver`。"

#: ../../library/sys.rst:767
msgid ""
"Return ``'utf-8'``. This is the name of the default string encoding, used in"
" methods like :meth:`str.encode`."
msgstr "返回 ``'utf-8'``。 这是默认字符编码格式的名称，被用于 :meth:`str.encode` 等方法。"

#: ../../library/sys.rst:773
msgid ""
"Return the current value of the flags that are used for :c:func:`dlopen` "
"calls.  Symbolic names for the flag values can be found in the :mod:`os` "
"module (:samp:`RTLD_{xxx}` constants, e.g. :const:`os.RTLD_LAZY`)."
msgstr ""
"返回用于 :c:func:`dlopen` 调用的旗标的当前值。 旗标值的符号名称可在 :mod:`os` 模块中找到 "
"(:samp:`RTLD_{xxx}` 常量，例如 :const:`os.RTLD_LAZY`)。"

#: ../../library/sys.rst:783
msgid ""
"Get the :term:`filesystem encoding <filesystem encoding and error handler>`:"
" the encoding used with the :term:`filesystem error handler <filesystem "
"encoding and error handler>` to convert between Unicode filenames and bytes "
"filenames. The filesystem error handler is returned from "
":func:`getfilesystemencodeerrors`."
msgstr ""
"获取 :term:`文件系统编码格式 <filesystem encoding and error handler>`: 该编码格式与 "
":term:`文件系统错误处理器 <filesystem encoding and error handler>` 一起使用以便在 Unicode "
"文件名和字节文件名之间进行转换。 文件系统错误处理器是从 :func:`getfilesystemencodeerrors` 返回的。"

#: ../../library/sys.rst:789
msgid ""
"For best compatibility, str should be used for filenames in all cases, "
"although representing filenames as bytes is also supported. Functions "
"accepting or returning filenames should support either str or bytes and "
"internally convert to the system's preferred representation."
msgstr ""
"为获得最佳兼容性，在任何时候都应使用 str 来表示文件名，尽管使用 bytes 来表示文件名也是受支持的。 接受还返回文件名的函数应当支持 str 或"
" bytes 并在内部将其转换为系统首选的表示形式。"

#: ../../library/sys.rst:794 ../../library/sys.rst:822
msgid ""
":func:`os.fsencode` and :func:`os.fsdecode` should be used to ensure that "
"the correct encoding and errors mode are used."
msgstr "应使用 :func:`os.fsencode` 和 :func:`os.fsdecode` 来保证所采用的编码和错误处理方案都是正确的。"

#: ../../library/sys.rst:797 ../../library/sys.rst:825
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` 是在 Python 启动时通过 "
":c:func:`PyConfig_Read` 函数来配置的：请参阅 :c:type:`PyConfig` 的 "
":c:member:`~PyConfig.filesystem_encoding` 和 "
":c:member:`~PyConfig.filesystem_errors` 等成员。"

#: ../../library/sys.rst:802
msgid ":func:`getfilesystemencoding` result cannot be ``None`` anymore."
msgstr ":func:`getfilesystemencoding` 的结果将不再有可能是 ``None``。"

#: ../../library/sys.rst:805
msgid ""
"Windows is no longer guaranteed to return ``'mbcs'``. See :pep:`529` and "
":func:`_enablelegacywindowsfsencoding` for more information."
msgstr ""
"Windows 不再保证会返回 ``'mbcs'``。详情请参阅 :pep:`529` 和 "
":func:`_enablelegacywindowsfsencoding`。"

#: ../../library/sys.rst:809
msgid ""
"Return ``'utf-8'`` if the :ref:`Python UTF-8 Mode <utf8-mode>` is enabled."
msgstr "返回 ``'utf-8'``，如果启用了 :ref:`Python UTF-8 模式 <utf8-mode>` 的话。"

#: ../../library/sys.rst:816
msgid ""
"Get the :term:`filesystem error handler <filesystem encoding and error "
"handler>`: the error handler used with the :term:`filesystem encoding "
"<filesystem encoding and error handler>` to convert between Unicode "
"filenames and bytes filenames. The filesystem encoding is returned from "
":func:`getfilesystemencoding`."
msgstr ""
"获取 :term:`文件系统错误处理器 <filesystem encoding and error handler>`: 该错误处理器与 "
":term:`文件系统编码格式 <filesystem encoding and error handler>` 一起使用以便在 Unicode "
"文件名和字节文件名之间进程转换。 文件系统编码格式是由 :func:`getfilesystemencoding` 来返回的。"

#: ../../library/sys.rst:834
msgid ""
"Returns the current value for the :ref:`integer string conversion length "
"limitation <int_max_str_digits>`. See also :func:`set_int_max_str_digits`."
msgstr ""
"返回 :ref:`整数字符串转换长度限制 <int_max_str_digits>` 的当前值。 另请参阅 "
":func:`set_int_max_str_digits`。"

#: ../../library/sys.rst:841
msgid ""
"Return the reference count of the *object*.  The count returned is generally"
" one higher than you might expect, because it includes the (temporary) "
"reference as an argument to :func:`getrefcount`."
msgstr ""
"返回 *object* 的引用计数。返回的计数通常比预期的多一，因为它包括了作为 :func:`getrefcount` 参数的这一次（临时）引用。"

#: ../../library/sys.rst:845
msgid ""
"Note that the returned value may not actually reflect how many references to"
" the object are actually held.  For example, some objects are "
":term:`immortal` and have a very high refcount that does not reflect the "
"actual number of references.  Consequently, do not rely on the returned "
"value to be accurate, other than a value of 0 or 1."
msgstr ""
"请注意返回的值可能并不真正反映实际持有的对象引用数。 例如，有些对象属于 :term:`immortal` 对象并具有并不反映实际引用数的非常高的 "
"refcount 值。 因此，除了 0 或 1 这两个值，不要依赖返回值的准确性。"

#: ../../library/sys.rst:851
msgid ""
"Immortal objects have very large refcounts that do not match the actual "
"number of references to the object."
msgstr "永生对象具有与对象的实际引用次数不相符的非常大的引用计数。"

#: ../../library/sys.rst:857
msgid ""
"Return the current value of the recursion limit, the maximum depth of the "
"Python interpreter stack.  This limit prevents infinite recursion from "
"causing an overflow of the C stack and crashing Python.  It can be set by "
":func:`setrecursionlimit`."
msgstr ""
"返回当前的递归限制值，即 Python 解释器堆栈的最大深度。此限制可防止无限递归导致的 C 堆栈溢出和 Python 崩溃。该值可以通过 "
":func:`setrecursionlimit` 设置。"

#: ../../library/sys.rst:865
msgid ""
"Return the size of an object in bytes. The object can be any type of object."
" All built-in objects will return correct results, but this does not have to"
" hold true for third-party extensions as it is implementation specific."
msgstr "返回对象的大小（以字节为单位）。该对象可以是任何类型。所有内建对象返回的结果都是正确的，但对于第三方扩展不一定正确，因为这与具体实现有关。"

#: ../../library/sys.rst:870
msgid ""
"Only the memory consumption directly attributed to the object is accounted "
"for, not the memory consumption of objects it refers to."
msgstr "只计算直接分配给对象的内存消耗，不计算它所引用的对象的内存消耗。"

#: ../../library/sys.rst:873
msgid ""
"If given, *default* will be returned if the object does not provide means to"
" retrieve the size.  Otherwise a :exc:`TypeError` will be raised."
msgstr "对象不提供计算大小的方法时，如果传入过 *default* 则返回它，否则抛出 :exc:`TypeError` 异常。"

#: ../../library/sys.rst:876
msgid ""
":func:`getsizeof` calls the object's ``__sizeof__`` method and adds an "
"additional garbage collector overhead if the object is managed by the "
"garbage collector."
msgstr ""
"如果对象由垃圾回收器管理，则 :func:`getsizeof` 将调用对象的 ``__sizeof__`` 方法，并在上层添加额外的垃圾回收器。"

#: ../../library/sys.rst:880
msgid ""
"See `recursive sizeof recipe "
"<https://code.activestate.com/recipes/577504-compute-memory-footprint-of-an-"
"object-and-its-cont/>`_ for an example of using :func:`getsizeof` "
"recursively to find the size of containers and all their contents."
msgstr ""
"请参阅 `recursive sizeof recipe "
"<https://code.activestate.com/recipes/577504-compute-memory-footprint-of-an-"
"object-and-its-cont/>`_ 获取一个递归地使用 :func:`getsizeof` 来找出各个容器及其全部内容大小的示例。"

#: ../../library/sys.rst:886
msgid ""
"Return the interpreter's \"thread switch interval\" in seconds; see "
":func:`setswitchinterval`."
msgstr "返回解释器的以秒为单位的“线程切换间隔时间”；参见 :func:`setswitchinterval`。"

#: ../../library/sys.rst:894
msgid ""
"Return a frame object from the call stack.  If optional integer *depth* is "
"given, return the frame object that many calls below the top of the stack.  "
"If that is deeper than the call stack, :exc:`ValueError` is raised.  The "
"default for *depth* is zero, returning the frame at the top of the call "
"stack."
msgstr ""
"返回来自调用栈的一个帧对象。如果传入可选整数 *depth*，则返回从栈顶往下相应调用层数的帧对象。如果该数比调用栈更深，则抛出 "
":exc:`ValueError`。*depth* 的默认值是 0，返回调用栈顶部的帧。"

#: ../../library/sys.rst:899
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._getframe`` with argument "
"``frame``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``sys._getframe`` 并附带参数 ``frame``。"

#: ../../library/sys.rst:903 ../../library/sys.rst:919
msgid ""
"This function should be used for internal and specialized purposes only. It "
"is not guaranteed to exist in all implementations of Python."
msgstr "这个函数应该只在内部为了一些特定的目的使用。不保证它在所有 Python 实现中都存在。"

#: ../../library/sys.rst:909
msgid ""
"Return the name of a module from the call stack.  If optional integer "
"*depth* is given, return the module that many calls below the top of the "
"stack.  If that is deeper than the call stack, or if the module is "
"unidentifiable, ``None`` is returned.  The default for *depth* is zero, "
"returning the module at the top of the call stack."
msgstr ""
"从调用栈返回一个模块的名称。 如果给出了可选的整数 *depth*，则返回从栈顶往下相应调用层数的模块。 "
"如果该数值比调用栈更深，或者如果该模块不可被标识，则返回 ``None``。 *depth* 的默认值为零，即返回位于调用栈顶端的模块。"

#: ../../library/sys.rst:915
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._getframemodulename`` with "
"argument ``depth``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sys._getframemodulename`` 并附带参数 ``depth``。"

#: ../../library/sys.rst:927
msgid ""
"This function only exists if CPython was built using the specialized "
"configure option :option:`--with-trace-refs`. It is intended only for "
"debugging garbage-collection issues."
msgstr ""
"此函数仅当 CPython 使用专门的配置选项 :option:`--with-trace-refs` 构建时才存在。 它仅针对调试垃圾回收问题而设计。"

#: ../../library/sys.rst:931
msgid ""
"Return a list of up to *limit* dynamically allocated Python objects. If "
"*type* is given, only objects of that exact type (not subtypes) are "
"included."
msgstr ""
"返回由至多 *limit* 个动态分配的 Python 对象组成的列表。 如果给定了 *type*，则仅会包括该特定类型（不包括子类型）的对象。"

#: ../../library/sys.rst:935
msgid ""
"Objects from the list are not safe to use. Specifically, the result will "
"include objects from all interpreters that share their object allocator "
"state (that is, ones created with "
":c:member:`PyInterpreterConfig.use_main_obmalloc` set to 1 or using "
":c:func:`Py_NewInterpreter`, and the :ref:`main interpreter <sub-"
"interpreter-support>`). Mixing objects from different interpreters may lead "
"to crashes or other unexpected behavior."
msgstr ""
"使用来自该列表的对象并不保证安全。 具体来说，该结果将包括来自共享对象分配状态的所有解释器的对象 (即创建时是将 "
":c:member:`PyInterpreterConfig.use_main_obmalloc` 设为 1 或是使用 "
":c:func:`Py_NewInterpreter`，以及 :ref:`主解释器 <sub-interpreter-support>`)。 "
"混合来自不同解释器的对象可能导致程序崩溃或其他非预期的行为。"

#: ../../library/sys.rst:946
msgid ""
"This function should be used for specialized purposes only. It is not "
"guaranteed to exist in all implementations of Python."
msgstr "此函数应当仅用于一些特定的目的。 并不保证它在所有 Python 实现中都存在。"

#: ../../library/sys.rst:951
msgid "The result may include objects from other interpreters."
msgstr "结果可能包括来自其他解释器的对象。"

#: ../../library/sys.rst:960
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "返回由 :func:`setprofile` 设置的性能分析函数。"

#: ../../library/sys.rst:969
msgid "Get the trace function as set by :func:`settrace`."
msgstr "返回由 :func:`settrace` 设置的跟踪函数。"

#: ../../library/sys.rst:973
msgid ""
"The :func:`gettrace` function is intended only for implementing debuggers, "
"profilers, coverage tools and the like.  Its behavior is part of the "
"implementation platform, rather than part of the language definition, and "
"thus may not be available in all Python implementations."
msgstr ""
":func:`gettrace` 函数仅用于实现调试器，性能分析器，打包工具等。它的行为是实现平台的一部分，而不是语言定义的一部分，因此并非在所有 "
"Python 实现中都可用。"

#: ../../library/sys.rst:981
msgid ""
"Return a named tuple describing the Windows version currently running.  The "
"named elements are *major*, *minor*, *build*, *platform*, *service_pack*, "
"*service_pack_minor*, *service_pack_major*, *suite_mask*, *product_type* and"
" *platform_version*. *service_pack* contains a string, *platform_version* a "
"3-tuple and all other values are integers. The components can also be "
"accessed by name, so ``sys.getwindowsversion()[0]`` is equivalent to "
"``sys.getwindowsversion().major``. For compatibility with prior versions, "
"only the first 5 elements are retrievable by indexing."
msgstr ""
"返回一个具名元组，描述当前正在运行的 Windows 版本。元素名称包括 *major*, *minor*, *build*, *platform*, "
"*service_pack*, *service_pack_minor*, *service_pack_major*, *suite_mask*, "
"*product_type* 和 *platform_version*。*service_pack* "
"包含一个字符串，*platform_version* 包含一个三元组，其他所有值都是整数。元素也可以通过名称来访问，所以 "
"``sys.getwindowsversion()[0]`` 与 ``sys.getwindowsversion().major`` "
"是等效的。为保持与旧版本的兼容性，只有前 5 个元素可以用索引检索。"

#: ../../library/sys.rst:992
msgid "*platform* will be ``2`` (VER_PLATFORM_WIN32_NT)."
msgstr "*platform* 将为 ``2`` (VER_PLATFORM_WIN32_NT)。"

#: ../../library/sys.rst:994
msgid "*product_type* may be one of the following values:"
msgstr "*product_type* 可能是以下值之一："

#: ../../library/sys.rst:997
msgid "Constant"
msgstr "常量"

#: ../../library/sys.rst:997
msgid "Meaning"
msgstr "含意"

#: ../../library/sys.rst:999
msgid "``1`` (VER_NT_WORKSTATION)"
msgstr "``1`` (VER_NT_WORKSTATION)"

#: ../../library/sys.rst:999
msgid "The system is a workstation."
msgstr "系统是工作站。"

#: ../../library/sys.rst:1001
msgid "``2`` (VER_NT_DOMAIN_CONTROLLER)"
msgstr "``2`` (VER_NT_DOMAIN_CONTROLLER)"

#: ../../library/sys.rst:1001
msgid "The system is a domain controller."
msgstr "系统是域控制器。"

#: ../../library/sys.rst:1004
msgid "``3`` (VER_NT_SERVER)"
msgstr "``3`` (VER_NT_SERVER)"

#: ../../library/sys.rst:1004
msgid "The system is a server, but not a domain controller."
msgstr "系统是服务器，但不是域控制器。"

#: ../../library/sys.rst:1008
msgid ""
"This function wraps the Win32 :c:func:`!GetVersionEx` function; see the "
"Microsoft documentation on :c:func:`!OSVERSIONINFOEX` for more information "
"about these fields."
msgstr ""
"该函数包装了 Win32 :c:func:`!GetVersionEx` 函数；有关这些字段的更多信息请参阅 "
":c:func:`!OSVERSIONINFOEX` 的 Microsoft 文档。"

#: ../../library/sys.rst:1012
msgid ""
"*platform_version* returns the major version, minor version and build number"
" of the current operating system, rather than the version that is being "
"emulated for the process. It is intended for use in logging rather than for "
"feature detection."
msgstr ""
"*platform_version* 返回当前操作系统的主要版本、次要版本和编译版本号，而不是为该进程所模拟的版本。 它旨在用于日志记录而非特性检测。"

#: ../../library/sys.rst:1018
msgid ""
"*platform_version* derives the version from kernel32.dll which can be of a "
"different version than the OS version. Please use :mod:`platform` module for"
" achieving accurate OS version."
msgstr ""
"*platform_version* 会从 kernel32.dll 获取版本号，这个版本可能与 OS 版本不同。 请使用 "
":mod:`platform` 模块来获取准确的 OS 版本号。"

#: ../../library/sys.rst:1024
msgid ""
"Changed to a named tuple and added *service_pack_minor*, "
"*service_pack_major*, *suite_mask*, and *product_type*."
msgstr ""
"更改为具名元组，添加 *service_pack_minor*, *service_pack_major*, *suite_mask* 和 "
"*product_type*。"

#: ../../library/sys.rst:1028
msgid "Added *platform_version*"
msgstr "添加了 *platform_version*"

#: ../../library/sys.rst:1034
msgid ""
"Returns an *asyncgen_hooks* object, which is similar to a "
":class:`~collections.namedtuple` of the form ``(firstiter, finalizer)``, "
"where *firstiter* and *finalizer* are expected to be either ``None`` or "
"functions which take an :term:`asynchronous generator iterator` as an "
"argument, and are used to schedule finalization of an asynchronous generator"
" by an event loop."
msgstr ""
"返回一个 *asyncgen_hooks* 对象，该对象类似于 ``(firstiter, finalizer)`` 形式的 "
":class:`~collections.namedtuple`，其中 *firstiter* 和 *finalizer* 应为 ``None`` "
"或是一个接受 :term:`asynchronous generator iterator` "
"作为参数的函数，并被用来在事件循环中调度异步生成器的最终化。"

#: ../../library/sys.rst:1041
msgid "See :pep:`525` for more details."
msgstr "详情请参阅 :pep:`525`。"

#: ../../library/sys.rst:1045 ../../library/sys.rst:1736
msgid ""
"This function has been added on a provisional basis (see :pep:`411` for "
"details.)"
msgstr "本函数已添加至暂定软件包（详情请参阅 :pep:`411` ）。"

#: ../../library/sys.rst:1051
msgid ""
"Get the current coroutine origin tracking depth, as set by "
":func:`set_coroutine_origin_tracking_depth`."
msgstr "获取由 :func:`set_coroutine_origin_tracking_depth` 设置的协程来源的追踪深度。"

#: ../../library/sys.rst:1057 ../../library/sys.rst:1757
msgid ""
"This function has been added on a provisional basis (see :pep:`411` for "
"details.)  Use it only for debugging purposes."
msgstr "本函数已添加至暂定软件包（详情请参阅 :pep:`411` ）。仅将其用于调试目的。"

#: ../../library/sys.rst:1063
msgid ""
"A :term:`named tuple` giving parameters of the numeric hash implementation."
"  For more details about hashing of numeric types, see :ref:`numeric-hash`."
msgstr ""
"一个 :term:`具名元组 <named tuple>`，给出数字类型的哈希的实现参数。关于数字类型的哈希的详情请参阅 :ref:`numeric-"
"hash`。"

#: ../../library/sys.rst:1069
msgid "The width in bits used for hash values"
msgstr "用于哈希值的位宽度"

#: ../../library/sys.rst:1073
msgid "The prime modulus P used for numeric hash scheme"
msgstr "用于数字哈案方案的质数模数 P"

#: ../../library/sys.rst:1077
msgid "The hash value returned for a positive infinity"
msgstr "为正无穷大返回的哈希值"

#: ../../library/sys.rst:1081
msgid "(This attribute is no longer used)"
msgstr "（该属性已不再被使用）"

#: ../../library/sys.rst:1085
msgid "The multiplier used for the imaginary part of a complex number"
msgstr "用于复数虚部的乘数"

#: ../../library/sys.rst:1089
msgid "The name of the algorithm for hashing of str, bytes, and memoryview"
msgstr "对字符串、字节串和内存视图进行哈希的算法名称"

#: ../../library/sys.rst:1093
msgid "The internal output size of the hash algorithm"
msgstr "哈希算法的内部输出大小"

#: ../../library/sys.rst:1097
msgid "The size of the seed key of the hash algorithm"
msgstr "哈希算法种子密钥的大小"

#: ../../library/sys.rst:1101
msgid "Added *algorithm*, *hash_bits* and *seed_bits*"
msgstr "添加了 *algorithm*, *hash_bits* 和 *seed_bits*"

#: ../../library/sys.rst:1107
msgid ""
"The version number encoded as a single integer.  This is guaranteed to "
"increase with each version, including proper support for non-production "
"releases.  For example, to test that the Python interpreter is at least "
"version 1.5.2, use::"
msgstr ""
"编码为单个整数的版本号。该整数会确保每个版本都自增，其中适当包括了未发布版本。举例来说，要测试 Python 解释器的版本不低于 1.5.2，请使用::"

#: ../../library/sys.rst:1111
msgid ""
"if sys.hexversion >= 0x010502F0:\n"
"    # use some advanced feature\n"
"    ...\n"
"else:\n"
"    # use an alternative implementation or warn the user\n"
"    ..."
msgstr ""
"if sys.hexversion >= 0x010502F0:\n"
"    # 使用某些高级特性\n"
"    ...\n"
"else:\n"
"    # 使用替代实现或警告用户\n"
"    ..."

#: ../../library/sys.rst:1118
msgid ""
"This is called ``hexversion`` since it only really looks meaningful when "
"viewed as the result of passing it to the built-in :func:`hex` function.  "
"The :term:`named tuple`  :data:`sys.version_info` may be used for a more "
"human-friendly encoding of the same information."
msgstr ""
"之所以称它为 ``hexversion``，是因为只有将它传入内置函数 :func:`hex` 后，其结果才看起来有意义。也可以使用 "
":term:`具名元组 <named tuple>` :data:`sys.version_info`，它对相同信息有着更人性化的编码。"

#: ../../library/sys.rst:1123
msgid "More details of ``hexversion`` can be found at :ref:`apiabiversion`."
msgstr "关于 ``hexversion`` 的更多信息可以在 :ref:`apiabiversion` 中找到。"

#: ../../library/sys.rst:1128
msgid ""
"An object containing information about the implementation of the currently "
"running Python interpreter.  The following attributes are required to exist "
"in all Python implementations."
msgstr "一个对象，该对象包含当前运行的 Python 解释器的实现信息。所有 Python 实现中都必须存在下列属性。"

#: ../../library/sys.rst:1132
msgid ""
"*name* is the implementation's identifier, e.g. ``'cpython'``.  The actual "
"string is defined by the Python implementation, but it is guaranteed to be "
"lower case."
msgstr "*name* 是当前实现的标识符，如 ``'cpython'``。实际的字符串由 Python 实现定义，但保证是小写字母。"

#: ../../library/sys.rst:1136
msgid ""
"*version* is a named tuple, in the same format as :data:`sys.version_info`."
"  It represents the version of the Python *implementation*.  This has a "
"distinct meaning from the specific version of the Python *language* to which"
" the currently running interpreter conforms, which ``sys.version_info`` "
"represents.  For example, for PyPy 1.8 ``sys.implementation.version`` might "
"be ``sys.version_info(1, 8, 0, 'final', 0)``, whereas ``sys.version_info`` "
"would be ``sys.version_info(2, 7, 2, 'final', 0)``.  For CPython they are "
"the same value, since it is the reference implementation."
msgstr ""
"*version* 是一个具名元组，格式与 :data:`sys.version_info` 相同。它表示 Python *实现* 的版本。 另一个（由"
" ``sys.version_info`` 表示）是当前解释器遵循的相应 Python *语言* 的版本，两者具有不同的含义。 例如，对于 PyPy "
"1.8，``sys.implementation.version`` 可能是 ``sys.version_info(1, 8, 0, 'final', "
"0)``，而 ``sys.version_info`` 则是 ``sys.version_info(2, 7, 2, 'final', 0)``。对于 "
"CPython 而言两个值是相同的，因为它是参考实现。"

#: ../../library/sys.rst:1146
msgid ""
"*hexversion* is the implementation version in hexadecimal format, like "
":data:`sys.hexversion`."
msgstr "*hexversion* 是十六进制的实现版本，类似于 :data:`sys.hexversion`。"

#: ../../library/sys.rst:1149
msgid ""
"*cache_tag* is the tag used by the import machinery in the filenames of "
"cached modules.  By convention, it would be a composite of the "
"implementation's name and version, like ``'cpython-33'``.  However, a Python"
" implementation may use some other value if appropriate.  If ``cache_tag`` "
"is set to ``None``, it indicates that module caching should be disabled."
msgstr ""
"*cache_tag* 是导入机制使用的标记，用于已缓存模块的文件名。按照惯例，它将由实现的名称和版本组成，如 "
"``'cpython-33'``。但如果合适，Python 实现可以使用其他值。如果 ``cache_tag`` 被置为 "
"``None``，表示模块缓存已禁用。"

#: ../../library/sys.rst:1156
msgid ""
":data:`sys.implementation` may contain additional attributes specific to the"
" Python implementation.  These non-standard attributes must start with an "
"underscore, and are not described here.  Regardless of its contents, "
":data:`sys.implementation` will not change during a run of the interpreter, "
"nor between implementation versions.  (It may change between Python language"
" versions, however.)  See :pep:`421` for more information."
msgstr ""
":data:`sys.implementation` 可能包含相应 Python "
"实现的其他属性。这些非标准属性必须以下划线开头，此处不详细阐述。无论其内容如何，:data:`sys.implementation` "
"在解释器运行期间或不同实现版本之间都不会更改。（但是不同 Python 语言版本间可能会不同。）详情请参阅 :pep:`421`。"

#: ../../library/sys.rst:1167
msgid ""
"The addition of new required attributes must go through the normal PEP "
"process. See :pep:`421` for more information."
msgstr "新的必要属性的添加必须经过常规的 PEP 过程。详情请参阅 :pep:`421`。"

#: ../../library/sys.rst:1172
msgid ""
"A :term:`named tuple` that holds information about Python's internal "
"representation of integers.  The attributes are read only."
msgstr "一个 :term:`具名元组 <named tuple>`，包含 Python 内部整数表示形式的信息。这些属性是只读的。"

#: ../../library/sys.rst:1177
msgid ""
"The number of bits held in each digit. Python integers are stored internally"
" in base ``2**int_info.bits_per_digit``."
msgstr "每个数位占用的比特位数。 Python 整数在内部以 ``2**int_info.bits_per_digit`` 为基数存储。"

#: ../../library/sys.rst:1182
msgid "The size in bytes of the C type used to represent a digit."
msgstr "用于表示一个数位的 C 类型的以字节为单位的大小。"

#: ../../library/sys.rst:1186
msgid ""
"The default value for :func:`sys.get_int_max_str_digits` when it is not "
"otherwise explicitly configured."
msgstr ":func:`sys.get_int_max_str_digits` 在未被显式配置时所使用的默认值。"

#: ../../library/sys.rst:1191
msgid ""
"The minimum non-zero value for :func:`sys.set_int_max_str_digits`, "
":envvar:`PYTHONINTMAXSTRDIGITS`, or :option:`-X int_max_str_digits <-X>`."
msgstr ""
":func:`sys.set_int_max_str_digits`, :envvar:`PYTHONINTMAXSTRDIGITS` 或 "
":option:`-X int_max_str_digits <-X>` 的最小非零值。"

#: ../../library/sys.rst:1198
msgid ""
"Added :attr:`~int_info.default_max_str_digits` and "
":attr:`~int_info.str_digits_check_threshold`."
msgstr ""
"添加了 :attr:`~int_info.default_max_str_digits` 和 "
":attr:`~int_info.str_digits_check_threshold`。"

#: ../../library/sys.rst:1204
msgid ""
"When this attribute exists, its value is automatically called (with no "
"arguments) when the interpreter is launched in :ref:`interactive mode <tut-"
"interactive>`.  This is done after the :envvar:`PYTHONSTARTUP` file is read,"
" so that you can set this hook there.  The :mod:`site` module :ref:`sets "
"this <rlcompleter-config>`."
msgstr ""
"当本属性存在，则以 :ref:`交互模式 <tut-interactive>` 启动解释器时，将自动（不带参数地）调用本属性的值。该过程是在读取 "
":envvar:`PYTHONSTARTUP` 文件之后完成的，所以可以在该文件中设置这一钩子。:mod:`site` 模块 :ref:`设置了这一属性"
" <rlcompleter-config>`。"

#: ../../library/sys.rst:1210 ../../library/sys.rst:1212
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_interactivehook`` "
"with the hook object as the argument when the hook is called on startup."
msgstr ""
"如果在启动时调用了钩子，则引发一个 :ref:`审计事件 <auditing>` "
"``cpython.run_interactivehook``，附带参数为 hook 对象。"

#: ../../library/sys.rst:1221
msgid ""
"Enter *string* in the table of \"interned\" strings and return the interned "
"string -- which is *string* itself or a copy. Interning strings is useful to"
" gain a little performance on dictionary lookup -- if the keys in a "
"dictionary are interned, and the lookup key is interned, the key comparisons"
" (after hashing) can be done by a pointer compare instead of a string "
"compare.  Normally, the names used in Python programs are automatically "
"interned, and the dictionaries used to hold module, class or instance "
"attributes have interned keys."
msgstr ""
"将 *string* 插入 \"interned\" （驻留）字符串表，返回被插入的字符串 -- 它是 *string* "
"本身或副本。驻留字符串对提高字典查找的性能很有用 -- "
"如果字典中的键已驻留，且所查找的键也已驻留，则键（取散列后）的比较可以用指针代替字符串来比较。通常，Python "
"程序使用到的名称会被自动驻留，且用于保存模块、类或实例属性的字典的键也已驻留。"

#: ../../library/sys.rst:1229
msgid ""
"Interned strings are not :term:`immortal`; you must keep a reference to the "
"return value of :func:`intern` around to benefit from it."
msgstr "驻留字符串不属于 :term:`immortal` 对象；你必须保留一个对 :func:`intern` 返回值的引用才能发挥其优势。"

#: ../../library/sys.rst:1235
msgid ""
"Return :const:`True` if the :term:`GIL` is enabled and :const:`False` if it "
"is disabled."
msgstr "如果 :term:`GIL` 已启用则返回 :const:`True` 而如果已禁用则返回 :const:`False`。"

#: ../../library/sys.rst:1242 ../../library/sys.rst:1274
msgid "It is not guaranteed to exist in all implementations of Python."
msgstr "不保证存在于所有的 Python 实现。"

#: ../../library/sys.rst:1246
msgid ""
"Return :const:`True` if the main Python interpreter is :term:`shutting down "
"<interpreter shutdown>`. Return :const:`False` otherwise."
msgstr ""
"如果主 Python 解释器 :term:`正在关闭 <interpreter shutdown>` 则返回 :const:`True`。 "
"在其他情况下返回 :const:`False`。"

#: ../../library/sys.rst:1249
msgid "See also the :exc:`PythonFinalizationError` exception."
msgstr "另请参阅 :exc:`PythonFinalizationError` 异常。"

#: ../../library/sys.rst:1255
msgid ""
"This variable is not always defined; it is set to the exception instance "
"when an exception is not handled and the interpreter prints an error message"
" and a stack traceback.  Its intended use is to allow an interactive user to"
" import a debugger module and engage in post-mortem debugging without having"
" to re-execute the command that caused the error.  (Typical use is ``import "
"pdb; pdb.pm()`` to enter the post-mortem debugger; see :mod:`pdb` module for"
" more information.)"
msgstr ""
"该变量并非总是会被定义；当有未处理的异常时它将被设为相应的异常实例并且解释器将打印异常消息和栈回溯。它的预期用途是允许交互用户导入调试器模块并进行事后调试而不必重新运行导致了错误的命令。"
" （典型用法是执行 ``import pdb; pdb.pm()`` 来进入事后调试器；请参阅 :mod:`pdb` 了解详情。）"

#: ../../library/sys.rst:1267
msgid ""
"Return :const:`True` if the given string is \"interned\", :const:`False` "
"otherwise."
msgstr "如果给定的字符串为“驻留字符串”则返回 :const:`True`，在其他情况下返回 :const:`False`。"

#: ../../library/sys.rst:1281
msgid ""
"These three variables are deprecated; use :data:`sys.last_exc` instead. They"
" hold the legacy representation of ``sys.last_exc``, as returned from "
":func:`exc_info` above."
msgstr ""
"这三个变量已被弃用；请改用 :data:`sys.last_exc`。 它们将保存 ``sys.last_exc`` 的旧表示形式，如上面 "
":func:`exc_info` 所返回的。"

#: ../../library/sys.rst:1287
msgid ""
"An integer giving the maximum value a variable of type :c:type:`Py_ssize_t` "
"can take.  It's usually ``2**31 - 1`` on a 32-bit platform and ``2**63 - 1``"
" on a 64-bit platform."
msgstr ""
"一个整数，表示 :c:type:`Py_ssize_t` 类型的变量可以取到的最大值。在 32 位平台上通常为 ``2**31 - 1``，在 64 "
"位平台上通常为 ``2**63 - 1``。"

#: ../../library/sys.rst:1294
msgid ""
"An integer giving the value of the largest Unicode code point, i.e. "
"``1114111`` (``0x10FFFF`` in hexadecimal)."
msgstr "一个整数，表示最大的 Unicode 码点值，如 ``1114111`` （十六进制为 ``0x10FFFF`` ）。"

#: ../../library/sys.rst:1297
msgid ""
"Before :pep:`393`, ``sys.maxunicode`` used to be either ``0xFFFF`` or "
"``0x10FFFF``, depending on the configuration option that specified whether "
"Unicode characters were stored as UCS-2 or UCS-4."
msgstr ""
"在 :pep:`393` 之前，``sys.maxunicode`` 曾是 ``0xFFFF`` 或 "
"``0x10FFFF``，具体取决于配置选项，该选项指定将 Unicode 字符存储为 UCS-2 还是 UCS-4。"

#: ../../library/sys.rst:1305
msgid ""
"A list of :term:`meta path finder` objects that have their "
":meth:`~importlib.abc.MetaPathFinder.find_spec` methods called to see if one"
" of the objects can find the module to be imported. By default, it holds "
"entries that implement Python's default import semantics. The "
":meth:`~importlib.abc.MetaPathFinder.find_spec` method is called with at "
"least the absolute name of the module being imported. If the module to be "
"imported is contained in a package, then the parent package's "
":attr:`~module.__path__` attribute is passed in as a second argument. The "
"method returns a :term:`module spec`, or ``None`` if the module cannot be "
"found."
msgstr ""
"一个由 :term:`meta path finder` 对象组成的列表，这些对象的 "
":meth:`~importlib.abc.MetaPathFinder.find_spec` 方法将会被调用以确定其中的某个对象能否找到要导入的模块。"
" 在默认情况下，它将存放实现了 Python 默认导入语法的条目。 调用 "
":meth:`~importlib.abc.MetaPathFinder.find_spec` 方法至少要附带待导入模块的绝对名称。 "
"如果待导入模块包含在一个包中，则父包的 :attr:`~module.__path__` 属性将作为第二个参数被传入。 此方法将返回一个 "
":term:`module spec`，或者如果找不到模块则返回 ``None``。"

#: ../../library/sys.rst:1318
msgid ":class:`importlib.abc.MetaPathFinder`"
msgstr ":class:`importlib.abc.MetaPathFinder`"

#: ../../library/sys.rst:1319
msgid ""
"The abstract base class defining the interface of finder objects on "
":data:`meta_path`."
msgstr "抽象基类，定义了 :data:`meta_path` 内的查找器对象的接口。"

#: ../../library/sys.rst:1321
msgid ":class:`importlib.machinery.ModuleSpec`"
msgstr ":class:`importlib.machinery.ModuleSpec`"

#: ../../library/sys.rst:1322
msgid ""
"The concrete class which :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"should return instances of."
msgstr ":meth:`~importlib.abc.MetaPathFinder.find_spec` 返回的实例所对应的具体类。"

#: ../../library/sys.rst:1328
msgid ""
":term:`Module specs <module spec>` were introduced in Python 3.4, by "
":pep:`451`."
msgstr ":term:`模块规格说明 <module spec>` 是在 Python 3.4 中根据 :pep:`451` 引入的。"

#: ../../library/sys.rst:1333
msgid ""
"Removed the fallback that looked for a :meth:`!find_module` method if a "
":data:`meta_path` entry didn't have a "
":meth:`~importlib.abc.MetaPathFinder.find_spec` method."
msgstr ""
"移除了当 :data:`meta_path` 条目没有 :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"方法时查找 :meth:`!find_module` 方法的回调。"

#: ../../library/sys.rst:1339
msgid ""
"This is a dictionary that maps module names to modules which have already "
"been loaded.  This can be manipulated to force reloading of modules and "
"other tricks. However, replacing the dictionary will not necessarily work as"
" expected and deleting essential items from the dictionary may cause Python "
"to fail.  If you want to iterate over this global dictionary always use "
"``sys.modules.copy()`` or ``tuple(sys.modules)`` to avoid exceptions as its "
"size may change during iteration as a side effect of code or activity in "
"other threads."
msgstr ""
"这是一个字典，它将模块名称映射到已经被加载的模块。 "
"这可以被操纵来强制重新加载模块和其他技巧。然而，替换这个字典不一定会像预期的那样工作，从字典中删除重要的项目可能会导致 Python 出错。 "
"如果你想对这个全局字典进行迭代，一定要使用 ``sys.modules.copy()`` 或 ``tuple(sys.modules)`` "
"来避免异常，因为它的大小在迭代过程中可能会因为其他线程中的代码或活动的副作用而改变。"

#: ../../library/sys.rst:1351
msgid ""
"The list of the original command line arguments passed to the Python "
"executable."
msgstr "传给 Python 可执行文件的原始命令行参数列表。"

#: ../../library/sys.rst:1354
msgid ""
"The elements of :data:`sys.orig_argv` are the arguments to the Python "
"interpreter, while the elements of :data:`sys.argv` are the arguments to the"
" user's program. Arguments consumed by the interpreter itself will be "
"present in :data:`sys.orig_argv` and missing from :data:`sys.argv`."
msgstr ""
":data:`sys.orig_argv` 中的元素是传给 Python 解释器的参数，而 :data:`sys.argv` "
"中的元素则是传给用户程序的参数。 解释器本身所使用的参数将出现在 :data:`sys.orig_argv` 中而不会出现在 "
":data:`sys.argv` 中。"

#: ../../library/sys.rst:1366
msgid ""
"A list of strings that specifies the search path for modules. Initialized "
"from the environment variable :envvar:`PYTHONPATH`, plus an installation-"
"dependent default."
msgstr ""
"一个由字符串组成的列表，用于指定模块的搜索路径。初始化自环境变量 :envvar:`PYTHONPATH`，再加上一条与安装有关的默认路径。"

#: ../../library/sys.rst:1370
msgid ""
"By default, as initialized upon program startup, a potentially unsafe path "
"is prepended to :data:`sys.path` (*before* the entries inserted as a result "
"of :envvar:`PYTHONPATH`):"
msgstr ""
"在默认情况下，如在程序启动时被初始化的时候，会有潜在的不安全路径被添加到 :data:`sys.path` 的开头 (在作为的 "
":envvar:`PYTHONPATH` 结果被插入的条目 *之前* 位置):"

#: ../../library/sys.rst:1374
msgid ""
"``python -m module`` command line: prepend the current working directory."
msgstr "``python -m module`` 命令行：添加当前工作目录。"

#: ../../library/sys.rst:1376
msgid ""
"``python script.py`` command line: prepend the script's directory. If it's a"
" symbolic link, resolve symbolic links."
msgstr "``python script.py`` 命令行：添加脚本的目录。 如果是一个符号链接，则会解析符号链接。"

#: ../../library/sys.rst:1378
msgid ""
"``python -c code`` and ``python`` (REPL) command lines: prepend an empty "
"string, which means the current working directory."
msgstr "``python -c code`` 和 ``python`` (REPL) 命令行：添加一个空字符串，这表示当前工作目录。"

#: ../../library/sys.rst:1381
msgid ""
"To not prepend this potentially unsafe path, use the :option:`-P` command "
"line option or the :envvar:`PYTHONSAFEPATH` environment variable."
msgstr ""
"如果不想添加这个具有潜在不安全性的路径，请使用 :option:`-P` 命令行选项或 :envvar:`PYTHONSAFEPATH` 环境变量。"

#: ../../library/sys.rst:1384
msgid ""
"A program is free to modify this list for its own purposes.  Only strings "
"should be added to :data:`sys.path`; all other data types are ignored during"
" import."
msgstr "程序可以出于自己的目的随意修改此列表。 应当只将字符串添加到 :data:`sys.path` 中；所有其他数据类型都将在导入期间被忽略。"

#: ../../library/sys.rst:1390
msgid ""
"Module :mod:`site` This describes how to use .pth files to extend "
":data:`sys.path`."
msgstr ":mod:`site` 模块，该模块描述了如何使用 .pth 文件来扩展 :data:`sys.path`。"

#: ../../library/sys.rst:1395
msgid ""
"A list of callables that take a path argument to try to create a "
":term:`finder` for the path. If a finder can be created, it is to be "
"returned by the callable, else raise :exc:`ImportError`."
msgstr ""
"一个由可调用对象组成的列表，这些对象接受一个路径作为参数，并尝试为该路径创建一个 :term:`查找器 "
"<finder>`。如果成功创建查找器，则可调用对象将返回它，否则将引发 :exc:`ImportError` 异常。"

#: ../../library/sys.rst:1399 ../../library/sys.rst:1410
msgid "Originally specified in :pep:`302`."
msgstr "本特性最早在 :pep:`302` 中被提及。"

#: ../../library/sys.rst:1404
msgid ""
"A dictionary acting as a cache for :term:`finder` objects. The keys are "
"paths that have been passed to :data:`sys.path_hooks` and the values are the"
" finders that are found. If a path is a valid file system path but no finder"
" is found on :data:`sys.path_hooks` then ``None`` is stored."
msgstr ""
"一个字典，作为 :term:`查找器 <finder>` 对象的缓存。key 是传入 :data:`sys.path_hooks` 的路径，value "
"是相应已找到的查找器。如果路径是有效的文件系统路径，但在 :data:`sys.path_hooks` 中未找到查找器，则存入 ``None``。"

#: ../../library/sys.rst:1415
msgid "A string containing a platform identifier. Known values are:"
msgstr "一个包含平台标识的字符串。 已知的值有："

#: ../../library/sys.rst:1418
msgid "System"
msgstr "系统"

#: ../../library/sys.rst:1418
msgid "``platform`` value"
msgstr "``平台`` 值"

#: ../../library/sys.rst:1420
msgid "AIX"
msgstr "AIX"

#: ../../library/sys.rst:1420
msgid "``'aix'``"
msgstr "``'aix'``"

#: ../../library/sys.rst:1421
msgid "Android"
msgstr "Android"

#: ../../library/sys.rst:1421
msgid "``'android'``"
msgstr "``'android'``"

#: ../../library/sys.rst:1422
msgid "Emscripten"
msgstr "Emscripten"

#: ../../library/sys.rst:1422
msgid "``'emscripten'``"
msgstr "``'emscripten'``"

#: ../../library/sys.rst:1423
msgid "iOS"
msgstr "iOS"

#: ../../library/sys.rst:1423
msgid "``'ios'``"
msgstr "``'ios'``"

#: ../../library/sys.rst:1424
msgid "Linux"
msgstr "Linux"

#: ../../library/sys.rst:1424
msgid "``'linux'``"
msgstr "``'linux'``"

#: ../../library/sys.rst:1425
msgid "macOS"
msgstr "macOS"

#: ../../library/sys.rst:1425
msgid "``'darwin'``"
msgstr "``'darwin'``"

#: ../../library/sys.rst:1426
msgid "Windows"
msgstr "Windows"

#: ../../library/sys.rst:1426
msgid "``'win32'``"
msgstr "``'win32'``"

#: ../../library/sys.rst:1427
msgid "Windows/Cygwin"
msgstr "Windows/Cygwin"

#: ../../library/sys.rst:1427
msgid "``'cygwin'``"
msgstr "``'cygwin'``"

#: ../../library/sys.rst:1428
msgid "WASI"
msgstr "WASI"

#: ../../library/sys.rst:1428
msgid "``'wasi'``"
msgstr "``'wasi'``"

#: ../../library/sys.rst:1431
msgid ""
"On Unix systems not listed in the table, the value is the lowercased OS name"
" as returned by ``uname -s``, with the first part of the version as returned"
" by ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, *at the time"
" when Python was built*.  Unless you want to test for a specific system "
"version, it is therefore recommended to use the following idiom::"
msgstr ""
"对于未在表中列出的 Unix 系统，该值是 ``uname -s`` 所返回的小写形式 OS 名称，并附加 ``uname -r`` "
"所返回的版本号的第一部分，例如 ``'sunos5'`` 或 ``'freebsd8'``，*对应 Python 被构建的时间*。 "
"除非你想要检测特定的系统版本，否则建议使用以下惯例::"

#: ../../library/sys.rst:1437
msgid ""
"if sys.platform.startswith('freebsd'):\n"
"    # FreeBSD-specific code here..."
msgstr ""
"if sys.platform.startswith('freebsd'):\n"
"    # 在此添加 FreeBSD 专属的代码..."

#: ../../library/sys.rst:1440
msgid ""
"On Linux, :data:`sys.platform` doesn't contain the major version anymore. It"
" is always ``'linux'``, instead of ``'linux2'`` or ``'linux3'``."
msgstr ""
"在 Linux 上，:data:`sys.platform` 将不再包含主版本号。 它将始终为 ``'linux'``，而不是 ``'linux2'``"
" 或 ``'linux3'``。"

#: ../../library/sys.rst:1444
msgid ""
"On AIX, :data:`sys.platform` doesn't contain the major version anymore. It "
"is always ``'aix'``, instead of ``'aix5'`` or ``'aix7'``."
msgstr ""
"在 AIX 上，:data:`sys.platform` 将不再包含主版本号。 它将始终为 ``'aix'``，而不是 ``'aix5'`` 或 "
"``'aix7'``。"

#: ../../library/sys.rst:1448
msgid ""
"On Android, :data:`sys.platform` now returns ``'android'`` rather than "
"``'linux'``."
msgstr "在 Android 上，:data:`sys.platform` 现在将返回 ``'android'`` 而不是 ``'linux'``。"

#: ../../library/sys.rst:1454
msgid ""
":data:`os.name` has a coarser granularity.  :func:`os.uname` gives system-"
"dependent version information."
msgstr ":data:`os.name` 具有更粗的粒度。 :func:`os.uname` 将给出依赖于具体系统的版本信息。"

#: ../../library/sys.rst:1457
msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ":mod:`platform` 模块对系统的标识有更详细的检查。"

#: ../../library/sys.rst:1463
msgid ""
"Name of the platform-specific library directory. It is used to build the "
"path of standard library and the paths of installed extension modules."
msgstr "平台专用库目录。用于构建标准库的路径和已安装扩展模块的路径。"

#: ../../library/sys.rst:1466
msgid ""
"It is equal to ``\"lib\"`` on most platforms. On Fedora and SuSE, it is "
"equal to ``\"lib64\"`` on 64-bit platforms which gives the following "
"``sys.path`` paths (where ``X.Y`` is the Python ``major.minor`` version):"
msgstr ""
"在大多数平台上，它等同于 ``\"lib\"`` 。在 Fedora 和 SuSE 上，它等同于给出了以下 ``sys.path`` 路径的 64 "
"位平台上的 ``\"lib64\"`` （其中 ``X.Y`` 是 Python 的 ``major.minor`` 版本）。"

#: ../../library/sys.rst:1470
msgid ""
"``/usr/lib64/pythonX.Y/``: Standard library (like ``os.py`` of the :mod:`os`"
" module)"
msgstr "``/usr/lib64/pythonX.Y/``：标准库（如 :mod:`os` 模块的 ``os.py`` ）"

#: ../../library/sys.rst:1472
msgid ""
"``/usr/lib64/pythonX.Y/lib-dynload/``: C extension modules of the standard "
"library (like the :mod:`errno` module, the exact filename is platform "
"specific)"
msgstr ""
"``/usr/lib64/pythonX.Y/lib-dynload/``：标准库的 C 扩展模块（如 :mod:`errno` "
"模块，确切的文件名取决于平台）"

#: ../../library/sys.rst:1475
msgid ""
"``/usr/lib/pythonX.Y/site-packages/`` (always use ``lib``, not "
":data:`sys.platlibdir`): Third-party modules"
msgstr ""
"``/usr/lib/pythonX.Y/site-packages/`` (请使用 ``lib``, 而非 "
":data:`sys.platlibdir`): 第三方模块"

#: ../../library/sys.rst:1477
msgid ""
"``/usr/lib64/pythonX.Y/site-packages/``: C extension modules of third-party "
"packages"
msgstr "``/usr/lib64/pythonX.Y/site-packages/``: 第三方包的 C 扩展模块"

#: ../../library/sys.rst:1485
msgid ""
"A string giving the site-specific directory prefix where the platform "
"independent Python files are installed; on Unix, the default is "
":file:`/usr/local`. This can be set at build time with the "
":option:`--prefix` argument to the :program:`configure` script.  See "
":ref:`installation_paths` for derived paths."
msgstr ""
"一个指定用于安装与平台无关的 Python 文件的站点专属目录前缀的字符串；在 Unix 上，默认为 :file:`/usr/local`。 "
"这可以在构建时通过将 :option:`--prefix` 参数传入 :program:`configure` 脚本来设置。 请参阅 "
":ref:`installation_paths` 了解衍生的路径。"

#: ../../library/sys.rst:1491
msgid ""
"If a :ref:`virtual environment <venv-def>` is in effect, this value will be "
"changed in ``site.py`` to point to the virtual environment. The value for "
"the Python installation will still be available, via :data:`base_prefix`."
msgstr ""
"如果在一个 :ref:`虚拟环境 <venv-def>` 中，那么该值将在 ``site.py`` 中被修改，指向虚拟环境。Python "
"安装位置仍然可以用 :data:`base_prefix` 来获取。"

#: ../../library/sys.rst:1506
msgid ""
"Strings specifying the primary and secondary prompt of the interpreter.  "
"These are only defined if the interpreter is in interactive mode.  Their "
"initial values in this case are ``'>>> '`` and ``'... '``.  If a non-string "
"object is assigned to either variable, its :func:`str` is re-evaluated each "
"time the interpreter prepares to read a new interactive command; this can be"
" used to implement a dynamic prompt."
msgstr ""
"字符串，指定解释器的首要和次要提示符。仅当解释器处于交互模式时，它们才有定义。这种情况下，它们的初值为 ``'>>> '`` 和 ``'... "
"'``。如果赋给其中某个变量的是非字符串对象，则每次解释器准备读取新的交互式命令时，都会重新运行该对象的 "
":func:`str`，这可以用来实现动态的提示符。"

#: ../../library/sys.rst:1516
msgid ""
"Set the flags used by the interpreter for :c:func:`dlopen` calls, such as "
"when the interpreter loads extension modules.  Among other things, this will"
" enable a lazy resolving of symbols when importing a module, if called as "
"``sys.setdlopenflags(0)``.  To share symbols across extension modules, call "
"as ``sys.setdlopenflags(os.RTLD_GLOBAL)``.  Symbolic names for the flag "
"values can be found in the :mod:`os` module (:samp:`RTLD_{xxx}` constants, "
"e.g. :const:`os.RTLD_LAZY`)."
msgstr ""
"设置解释器在调用 :c:func:`dlopen` 时使用的旗标，例如当解释器加载扩展模块的时候。 首先，如果以 "
"``sys.setdlopenflags(0)`` 的形式调用的话这将在导入模块时启用符号的惰性求值。 要在扩展模块之间共享符号，请以 "
"``sys.setdlopenflags(os.RTLD_GLOBAL)`` 的形式调用。 旗标志值的符号名称可以在 :mod:`os` 模块中找到 "
"(:samp:`RTLD_{xxx}` 常量，例如 :const:`os.RTLD_LAZY`)。"

#: ../../library/sys.rst:1528
msgid ""
"Set the :ref:`integer string conversion length limitation "
"<int_max_str_digits>` used by this interpreter. See also "
":func:`get_int_max_str_digits`."
msgstr ""
"设置解释器所使用的 :ref:`整数字符串转换长度限制 <int_max_str_digits>`。 另请参阅 "
":func:`get_int_max_str_digits`。"

#: ../../library/sys.rst:1540
msgid ""
"Set the system's profile function, which allows you to implement a Python "
"source code profiler in Python.  See chapter :ref:`profile` for more "
"information on the Python profiler.  The system's profile function is called"
" similarly to the system's trace function (see :func:`settrace`), but it is "
"called with different events, for example it isn't called for each executed "
"line of code (only on call and return, but the return event is reported even"
" when an exception has been set). The function is thread-specific, but there"
" is no way for the profiler to know about context switches between threads, "
"so it does not make sense to use this in the presence of multiple threads. "
"Also, its return value is not used, so it can simply return ``None``.  Error"
" in the profile function will cause itself unset."
msgstr ""
"设置系统的性能分析函数，该函数使得在 Py​​thon 中能够实现一个 Python 源代码性能分析器。关于 Python Profiler "
"的更多信息请参阅 :ref:`profile` 章节。性能分析函数的调用方式类似于系统的跟踪函数（参阅 :func:`settrace` "
"），但它是通过不同的事件调用的，例如，不是每执行一行代码就调用它一次（仅在调用某函数和从某函数返回时才会调用性能分析函数，但即使某函数发生异常也会算作返回事件）。该函数是特定于单个线程的，但是性能分析器无法得知线程之间的上下文切换，因此在存在多个线程的情况下使用它是没有意义的。另外，因为它的返回值不会被用到，所以可以简单地返回"
" ``None``。性能分析函数中的错误将导致其自身被解除设置。"

#: ../../library/sys.rst:1552
msgid ""
"The same tracing mechanism is used for :func:`!setprofile` as "
":func:`settrace`. To trace calls with :func:`!setprofile` inside a tracing "
"function (e.g. in a debugger breakpoint), see :func:`call_tracing`."
msgstr ""
":func:`!setprofile` 使用与 :func:`settrace` 相同的跟踪机制。 要在跟踪函数内部使用 "
":func:`!setprofile` 来跟踪调用（例如在调试器断点内），请参阅 :func:`call_tracing`。"

#: ../../library/sys.rst:1556
msgid ""
"Profile functions should have three arguments: *frame*, *event*, and *arg*. "
"*frame* is the current stack frame.  *event* is a string: ``'call'``, "
"``'return'``, ``'c_call'``, ``'c_return'``, or ``'c_exception'``. *arg* "
"depends on the event type."
msgstr ""
"性能分析函数应接收三个参数：*frame*、*event* 和 *arg*。*frame* 是当前的堆栈帧。*event* "
"是一个字符串：``'call'``、``'return'``、``'c_call'``、``'c_return'`` 或 "
"``'c_exception'``。*arg* 取决于事件类型。"

#: ../../library/sys.rst:1561 ../../library/sys.rst:1648
msgid "The events have the following meaning:"
msgstr "这些事件具有以下含义："

#: ../../library/sys.rst:1563 ../../library/sys.rst:1650
msgid "``'call'``"
msgstr "``'call'``"

#: ../../library/sys.rst:1564
msgid ""
"A function is called (or some other code block entered).  The profile "
"function is called; *arg* is ``None``."
msgstr "表示调用了某个函数（或进入了其他的代码块）。性能分析函数将被调用，*arg* 为 ``None``。"

#: ../../library/sys.rst:1567 ../../library/sys.rst:1665
msgid "``'return'``"
msgstr "``'return'``"

#: ../../library/sys.rst:1568
msgid ""
"A function (or other code block) is about to return.  The profile function "
"is called; *arg* is the value that will be returned, or ``None`` if the "
"event is caused by an exception being raised."
msgstr ""
"表示某个函数（或别的代码块）即将返回。性能分析函数将被调用，*arg* 是即将返回的值，如果此次返回事件是由于抛出异常，*arg* 为 "
"``None``。"

#: ../../library/sys.rst:1572
msgid "``'c_call'``"
msgstr "``'c_call'``"

#: ../../library/sys.rst:1573
msgid ""
"A C function is about to be called.  This may be an extension function or a "
"built-in.  *arg* is the C function object."
msgstr "表示即将调用某个 C 函数。它可能是扩展函数或是内建函数。*arg* 是 C 函数对象。"

#: ../../library/sys.rst:1576
msgid "``'c_return'``"
msgstr "``'c_return'``"

#: ../../library/sys.rst:1577
msgid "A C function has returned. *arg* is the C function object."
msgstr "表示返回了某个 C 函数。*arg* 是 C 函数对象。"

#: ../../library/sys.rst:1579
msgid "``'c_exception'``"
msgstr "``'c_exception'``"

#: ../../library/sys.rst:1580
msgid "A C function has raised an exception.  *arg* is the C function object."
msgstr "表示某个 C 函数抛出了异常。*arg* 是 C 函数对象。"

#: ../../library/sys.rst:1582
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.setprofile`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys.setprofile``。"

#: ../../library/sys.rst:1587
msgid ""
"Set the maximum depth of the Python interpreter stack to *limit*.  This "
"limit prevents infinite recursion from causing an overflow of the C stack "
"and crashing Python."
msgstr "将 Python 解释器堆栈的最大深度设置为 *limit*。此限制可防止无限递归导致的 C 堆栈溢出和 Python 崩溃。"

#: ../../library/sys.rst:1591
msgid ""
"The highest possible limit is platform-dependent.  A user may need to set "
"the limit higher when they have a program that requires deep recursion and a"
" platform that supports a higher limit.  This should be done with care, "
"because a too-high limit can lead to a crash."
msgstr ""
"不同平台所允许的最高限值不同。当用户有需要深度递归的程序且平台支持更高的限值，可能就需要调高限值。进行该操作需要谨慎，因为过高的限值可能会导致崩溃。"

#: ../../library/sys.rst:1596
msgid ""
"If the new limit is too low at the current recursion depth, a "
":exc:`RecursionError` exception is raised."
msgstr "如果新的限值低于当前的递归深度，将抛出 :exc:`RecursionError` 异常。"

#: ../../library/sys.rst:1599
msgid ""
"A :exc:`RecursionError` exception is now raised if the new limit is too low "
"at the current recursion depth."
msgstr "如果新的限值低于当前的递归深度，现在将抛出 :exc:`RecursionError` 异常。"

#: ../../library/sys.rst:1606
msgid ""
"Set the interpreter's thread switch interval (in seconds).  This floating-"
"point value determines the ideal duration of the \"timeslices\" allocated to"
" concurrently running Python threads.  Please note that the actual value can"
" be higher, especially if long-running internal functions or methods are "
"used.  Also, which thread becomes scheduled at the end of the interval is "
"the operating system's decision.  The interpreter doesn't have its own "
"scheduler."
msgstr ""
"设置解释器的线程切换间隔时间（单位为秒）。该浮点数决定了“时间片”的理想持续时间，时间片将分配给同时运行的 Python "
"线程。请注意，实际值可能更高，尤其是使用了运行时间长的内部函数或方法时。同时，在时间间隔末尾调度哪个线程是操作系统的决定。解释器没有自己的调度程序。"

#: ../../library/sys.rst:1623
msgid ""
"Set the system's trace function, which allows you to implement a Python "
"source code debugger in Python.  The function is thread-specific; for a "
"debugger to support multiple threads, it must register a trace function "
"using :func:`settrace` for each thread being debugged or use "
":func:`threading.settrace`."
msgstr ""
"设置系统的跟踪函数，使得用户在 Python 中就可以实现 Python "
"源代码调试器。该函数是特定于单个线程的，所以要让调试器支持多线程，必须为正在调试的每个线程都用 :func:`settrace` "
"注册一个跟踪函数，或使用 :func:`threading.settrace`。"

#: ../../library/sys.rst:1628
msgid ""
"Trace functions should have three arguments: *frame*, *event*, and *arg*. "
"*frame* is the :ref:`current stack frame <frame-objects>`. *event* is a "
"string: ``'call'``, ``'line'``, ``'return'``, ``'exception'`` or "
"``'opcode'``.  *arg* depends on the event type."
msgstr ""

#: ../../library/sys.rst:1633
msgid ""
"The trace function is invoked (with *event* set to ``'call'``) whenever a "
"new local scope is entered; it should return a reference to a local trace "
"function to be used for the new scope, or ``None`` if the scope shouldn't be"
" traced."
msgstr ""
"每次进入 trace 函数的新的局部作用范围，都会调用 trace 函数（ *event* 会被设置为 ``'call'`` "
"），它应该返回一个引用，指向即将用在新作用范围上的局部跟踪函数；如果不需要跟踪当前的作用范围，则返回 ``None``。"

#: ../../library/sys.rst:1638
msgid ""
"The local trace function should return a reference to itself, or to another "
"function which would then be used as the local trace function for the scope."
msgstr "本地跟踪函数应返回对自身的引用，或对另一个函数的引用然后将其用作本作用域的局部跟踪函数。"

#: ../../library/sys.rst:1641
msgid ""
"If there is any error occurred in the trace function, it will be unset, just"
" like ``settrace(None)`` is called."
msgstr "如果跟踪函数出错，则该跟踪函数将被取消设置，类似于调用 ``settrace(None)``。"

#: ../../library/sys.rst:1645
msgid ""
"Tracing is disabled while calling the trace function (e.g. a function set by"
" :func:`!settrace`). For recursive tracing see :func:`call_tracing`."
msgstr ""
"在调用跟踪函数（例如由 :func:`!settrace` 设置的函数）时将禁用跟踪。 有关递归跟踪请参阅 :func:`call_tracing`。"

#: ../../library/sys.rst:1651
msgid ""
"A function is called (or some other code block entered).  The global trace "
"function is called; *arg* is ``None``; the return value specifies the local "
"trace function."
msgstr "表示调用了某个函数（或进入了其他的代码块）。全局跟踪函数将被调用，*arg* 为 ``None``。返回值将指定局部跟踪函数。"

#: ../../library/sys.rst:1655
msgid "``'line'``"
msgstr "``'line'``"

#: ../../library/sys.rst:1656
msgid ""
"The interpreter is about to execute a new line of code or re-execute the "
"condition of a loop.  The local trace function is called; *arg* is ``None``;"
" the return value specifies the new local trace function.  See "
":file:`Objects/lnotab_notes.txt` for a detailed explanation of how this "
"works. Per-line events may be disabled for a frame by setting "
":attr:`~frame.f_trace_lines` to :const:`False` on that :ref:`frame <frame-"
"objects>`."
msgstr ""
"解释器即将执行一个新的代码行或重新执行一个循环的条件。 局部跟踪函数将被调用；*arg* 为 ``None``；其返回值将指定新的局部跟踪函数。 请参阅"
" :file:`Objects/lnotab_notes.txt` 查看有关其工作原理的详细说明。 可以通过在某个 :ref:`帧 <frame-"
"objects>` 上把 :attr:`~frame.f_trace_lines` 设为 :const:`False` 来禁用相应帧的每行触发事件。"

#: ../../library/sys.rst:1666
msgid ""
"A function (or other code block) is about to return.  The local trace "
"function is called; *arg* is the value that will be returned, or ``None`` if"
" the event is caused by an exception being raised.  The trace function's "
"return value is ignored."
msgstr ""
"表示某个函数（或别的代码块）即将返回。局部跟踪函数将被调用，*arg* 是即将返回的值，如果此次返回事件是由于抛出异常，*arg* 为 "
"``None``。跟踪函数的返回值将被忽略。"

#: ../../library/sys.rst:1671
msgid "``'exception'``"
msgstr "``'exception'``"

#: ../../library/sys.rst:1672
msgid ""
"An exception has occurred.  The local trace function is called; *arg* is a "
"tuple ``(exception, value, traceback)``; the return value specifies the new "
"local trace function."
msgstr ""
"表示发生了某个异常。局部跟踪函数将被调用，*arg* 是一个 ``(exception, value, traceback)`` "
"元组，返回值将指定新的局部跟踪函数。"

#: ../../library/sys.rst:1676
msgid "``'opcode'``"
msgstr "``'opcode'``"

#: ../../library/sys.rst:1677
msgid ""
"The interpreter is about to execute a new opcode (see :mod:`dis` for opcode "
"details).  The local trace function is called; *arg* is ``None``; the return"
" value specifies the new local trace function. Per-opcode events are not "
"emitted by default: they must be explicitly requested by setting "
":attr:`~frame.f_trace_opcodes` to :const:`True` on the :ref:`frame <frame-"
"objects>`."
msgstr ""
"解释器即将执行一个新的操作码（请参阅 :mod:`dis` 了解有关操作码的详情）。 局部跟踪函数将被调用；*arg* 为 "
"``None``；共返回值将指定新的局部跟踪函数。 在默认情况下不会发出每个操作码触发事件：必须通过在某个 :ref:`帧 <frame-"
"objects>` 上把 :attr:`~frame.f_trace_opcodes` 设为 :const:`True` 来显式地发出请求。"

#: ../../library/sys.rst:1684
msgid ""
"Note that as an exception is propagated down the chain of callers, an "
"``'exception'`` event is generated at each level."
msgstr "注意，由于异常是在链式调用中传播的，所以每一级都会产生一个 ``'exception'`` 事件。"

#: ../../library/sys.rst:1687
msgid ""
"For more fine-grained usage, it's possible to set a trace function by "
"assigning ``frame.f_trace = tracefunc`` explicitly, rather than relying on "
"it being set indirectly via the return value from an already installed trace"
" function. This is also required for activating the trace function on the "
"current frame, which :func:`settrace` doesn't do. Note that in order for "
"this to work, a global tracing function must have been installed with "
":func:`settrace` in order to enable the runtime tracing machinery, but it "
"doesn't need to be the same tracing function (e.g. it could be a low "
"overhead tracing function that simply returns ``None`` to disable itself "
"immediately on each frame)."
msgstr ""
"更细微的用法是，可以显式地通过赋值 ``frame.f_trace = tracefunc`` "
"来设置跟踪函数，而不是用现有跟踪函数的返回值去间接设置它。当前帧上的跟踪函数必须激活，而 :func:`settrace` "
"还没有做这件事。注意，为了使上述设置起效，必须使用 :func:`settrace` "
"来安装全局跟踪函数才能启用运行时跟踪机制，但是它不必与上述是同一个跟踪函数（它可以是一个开销很低的跟踪函数，只返回 "
"``None``，即在各个帧上立即将其自身禁用）。"

#: ../../library/sys.rst:1698
msgid "For more information on code and frame objects, refer to :ref:`types`."
msgstr "关于代码对象和帧对象的更多信息请参考 :ref:`types`。"

#: ../../library/sys.rst:1700
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.settrace`` with no "
"arguments."
msgstr "引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys.settrace``。"

#: ../../library/sys.rst:1704
msgid ""
"The :func:`settrace` function is intended only for implementing debuggers, "
"profilers, coverage tools and the like.  Its behavior is part of the "
"implementation platform, rather than part of the language definition, and "
"thus may not be available in all Python implementations."
msgstr ""
":func:`settrace` 函数仅用于实现调试器，性能分析器，打包工具等。它的行为是实现平台的一部分，而不是语言定义的一部分，因此并非在所有 "
"Python 实现中都可用。"

#: ../../library/sys.rst:1711
msgid ""
"``'opcode'`` event type added; :attr:`~frame.f_trace_lines` and "
":attr:`~frame.f_trace_opcodes` attributes added to frames"
msgstr ""
"添加了 ``'opcode'`` 事件类型；为帧添加了 :attr:`~frame.f_trace_lines` 和 "
":attr:`~frame.f_trace_opcodes` 属性"

#: ../../library/sys.rst:1716
msgid ""
"Accepts two optional keyword arguments which are callables that accept an "
":term:`asynchronous generator iterator` as an argument. The *firstiter* "
"callable will be called when an asynchronous generator is iterated for the "
"first time. The *finalizer* will be called when an asynchronous generator is"
" about to be garbage collected."
msgstr ""
"接受两个可选的关键字参数，要求它们是可调用对象，且接受一个 :term:`异步生成器迭代器 <asynchronous generator "
"iterator>` 作为参数。*firstiter* 对象将在异步生成器第一次迭代时调用。*finalizer* 将在异步生成器即将被销毁时调用。"

#: ../../library/sys.rst:1722
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sys.set_asyncgen_hooks_firstiter`` with no arguments."
msgstr ""
"引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys.set_asyncgen_hooks_firstiter``。"

#: ../../library/sys.rst:1724
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sys.set_asyncgen_hooks_finalizer`` with no arguments."
msgstr ""
"引发一个不带参数的 :ref:`审计事件 <auditing>` ``sys.set_asyncgen_hooks_finalizer``。"

#: ../../library/sys.rst:1726
msgid ""
"Two auditing events are raised because the underlying API consists of two "
"calls, each of which must raise its own event."
msgstr "之所以会引发两个审计事件，是因为底层的 API 由两个调用组成，每个调用都须要引发自己的事件。"

#: ../../library/sys.rst:1729
msgid ""
"See :pep:`525` for more details, and for a reference example of a "
"*finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/asyncio/base_events.py`"
msgstr ""
"更多详情请参阅 :pep:`525`，*finalizer* 方法的参考示例可参阅 "
":source:`Lib/asyncio/base_events.py` 中 ``asyncio.Loop.shutdown_asyncgens`` "
"的实现。"

#: ../../library/sys.rst:1741
msgid ""
"Allows enabling or disabling coroutine origin tracking. When enabled, the "
"``cr_origin`` attribute on coroutine objects will contain a tuple of "
"(filename, line number, function name) tuples describing the traceback where"
" the coroutine object was created, with the most recent call first. When "
"disabled, ``cr_origin`` will be ``None``."
msgstr ""
"允许启用或禁用协程溯源。 当启用时，协程对象上的 ``cr_origin`` 属性将包含一个由 (文件名, 行号, 函数名) "
"元组组成的元组，它描述了协程对象自创建以来的回溯信息，最近的调用在最上面。 当禁用时，``cr_origin`` 将为 ``None``。"

#: ../../library/sys.rst:1748
msgid ""
"To enable, pass a *depth* value greater than zero; this sets the number of "
"frames whose information will be captured. To disable, pass set *depth* to "
"zero."
msgstr "要启用，请向 *depth* 传递一个大于零的值，它指定了有多少帧将被捕获信息。要禁用，请将 *depth* 置为零。"

#: ../../library/sys.rst:1752
msgid "This setting is thread-specific."
msgstr "该设置是特定于单个线程的。"

#: ../../library/sys.rst:1762
msgid ""
"Activate the stack profiler trampoline *backend*. The only supported backend"
" is ``\"perf\"``."
msgstr "激活栈性能分析器 trampoline *backend*。 唯一受支持的后端是 ``\"perf\"``。"

#: ../../library/sys.rst:1771
msgid ":ref:`perf_profiling`"
msgstr ":ref:`perf_profiling`"

#: ../../library/sys.rst:1772
msgid "https://perf.wiki.kernel.org"
msgstr "https://perf.wiki.kernel.org"

#: ../../library/sys.rst:1776
msgid "Deactivate the current stack profiler trampoline backend."
msgstr "取消激活当前的栈性能分析器 trampoline 后端。"

#: ../../library/sys.rst:1778
msgid "If no stack profiler is activated, this function has no effect."
msgstr "如果没有激活的栈性能分析器，此函数将没有任何效果。"

#: ../../library/sys.rst:1786
msgid "Return ``True`` if a stack profiler trampoline is active."
msgstr "如果激活了栈性能分析器 trampoline 则返回 ``True``。"

#: ../../library/sys.rst:1794
msgid ""
"Changes the :term:`filesystem encoding and error handler` to 'mbcs' and "
"'replace' respectively, for consistency with versions of Python prior to "
"3.6."
msgstr ""
"将 :term:`filesystem encoding and error handler` 分别修改为 'mbcs' 和 'replace'，以便与"
" 3.6 之前版本的 Python 保持一致。"

#: ../../library/sys.rst:1798
msgid ""
"This is equivalent to defining the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` "
"environment variable before launching Python."
msgstr "这等同于在启动 Python 前先定义好 :envvar:`PYTHONLEGACYWINDOWSFSENCODING` 环境变量。"

#: ../../library/sys.rst:1801
msgid ""
"See also :func:`sys.getfilesystemencoding` and "
":func:`sys.getfilesystemencodeerrors`."
msgstr ""
"另请参阅 :func:`sys.getfilesystemencoding` 和 "
":func:`sys.getfilesystemencodeerrors`。"

#: ../../library/sys.rst:1807
msgid ""
"Changing the filesystem encoding after Python startup is risky because the "
"old fsencoding or paths encoded by the old fsencoding may be cached "
"somewhere. Use :envvar:`PYTHONLEGACYWINDOWSFSENCODING` instead."
msgstr ""
"在 Python 启动后改变文件系统编码格式是有风险的因为旧的文件系统编码格式或由旧的文件系统编码格式所编码的路径可能已被缓存。 请改用 "
":envvar:`PYTHONLEGACYWINDOWSFSENCODING`。"

#: ../../library/sys.rst:1811
msgid "See :pep:`529` for more details."
msgstr "更多详情请参阅 :pep:`529`。"

#: ../../library/sys.rst:1814
msgid "Use :envvar:`PYTHONLEGACYWINDOWSFSENCODING` instead."
msgstr "应改用 :envvar:`PYTHONLEGACYWINDOWSFSENCODING`。"

#: ../../library/sys.rst:1821
msgid ""
":term:`File objects <file object>` used by the interpreter for standard "
"input, output and errors:"
msgstr "解释器用于标准输入、标准输出和标准错误的 :term:`文件对象 <file object>`："

#: ../../library/sys.rst:1824
msgid ""
"``stdin`` is used for all interactive input (including calls to "
":func:`input`);"
msgstr "``stdin`` 用于所有交互式输入（包括对 :func:`input` 的调用）；"

#: ../../library/sys.rst:1826
msgid ""
"``stdout`` is used for the output of :func:`print` and :term:`expression` "
"statements and for the prompts of :func:`input`;"
msgstr ""
"``stdout`` 用于 :func:`print` 和 :term:`expression` 语句的输出，以及用于 :func:`input` "
"的提示符；"

#: ../../library/sys.rst:1828
msgid "The interpreter's own prompts and its error messages go to ``stderr``."
msgstr "解释器自身的提示符和它的错误消息都发往 ``stderr``。"

#: ../../library/sys.rst:1830
msgid ""
"These streams are regular :term:`text files <text file>` like those returned"
" by the :func:`open` function.  Their parameters are chosen as follows:"
msgstr "这些流都是常规 :term:`文本文件 <text file>`，与 :func:`open` 函数返回的对象一致。它们的参数选择如下："

#: ../../library/sys.rst:1834
msgid ""
"The encoding and error handling are is initialized from "
":c:member:`PyConfig.stdio_encoding` and :c:member:`PyConfig.stdio_errors`."
msgstr ""
"编码格式和错误处理器是由 :c:member:`PyConfig.stdio_encoding` 和 "
":c:member:`PyConfig.stdio_errors` 来初始化的。"

#: ../../library/sys.rst:1837
msgid ""
"On Windows, UTF-8 is used for the console device.  Non-character devices "
"such as disk files and pipes use the system locale encoding (i.e. the ANSI "
"codepage).  Non-console character devices such as NUL (i.e. where "
"``isatty()`` returns ``True``) use the value of the console input and output"
" codepages at startup, respectively for stdin and stdout/stderr. This "
"defaults to the system :term:`locale encoding` if the process is not "
"initially attached to a console."
msgstr ""
"在 Windows 上，控制台设备使用 UTF-8。 非字符设备如磁盘文件和管道使用系统语言区域编码格式（例如 ANSI 代码页）。 非控制台字符设备如"
" NUL（例如当 ``isatty()`` 返回 ``True`` 时）会在启动时分别让 stdin 和 stdout/stderr "
"使用控制台输入和输出代码页。 如果进程初始化时没有被附加到控制台则会使用默认的系统 :term:`locale encoding`。"

#: ../../library/sys.rst:1846
msgid ""
"The special behaviour of the console can be overridden by setting the "
"environment variable PYTHONLEGACYWINDOWSSTDIO before starting Python. In "
"that case, the console codepages are used as for any other character device."
msgstr ""
"要重写控制台的特殊行为，可以在启动 Python 前设置 PYTHONLEGACYWINDOWSSTDIO "
"环境变量。此时，控制台代码页将用于其他字符设备。"

#: ../../library/sys.rst:1851
msgid ""
"Under all platforms, you can override the character encoding by setting the "
":envvar:`PYTHONIOENCODING` environment variable before starting Python or by"
" using the new :option:`-X` ``utf8`` command line option and "
":envvar:`PYTHONUTF8` environment variable.  However, for the Windows "
"console, this only applies when :envvar:`PYTHONLEGACYWINDOWSSTDIO` is also "
"set."
msgstr ""
"在所有平台上，都可以通过在 Python 启动前设置 :envvar:`PYTHONIOENCODING` 环境变量来重写字符编码，或通过新的 "
":option:`-X` ``utf8`` 命令行选项和 :envvar:`PYTHONUTF8` 环境变量来设置。但是，对 Windows "
"控制台来说，上述方法仅在设置了 :envvar:`PYTHONLEGACYWINDOWSSTDIO` 后才起效。"

#: ../../library/sys.rst:1858
msgid ""
"When interactive, the ``stdout`` stream is line-buffered. Otherwise, it is "
"block-buffered like regular text files.  The ``stderr`` stream is line-"
"buffered in both cases.  You can make both streams unbuffered by passing the"
" :option:`-u` command-line option or setting the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
"交互模式下，``stdout`` 流是行缓冲的。其他情况下，它像常规文本文件一样是块缓冲的。两种情况下的 ``stderr`` "
"流都是行缓冲的。要使得两个流都变成无缓冲，可以传入 :option:`-u` 命令行选项或设置 :envvar:`PYTHONUNBUFFERED` "
"环境变量。"

#: ../../library/sys.rst:1864
msgid ""
"Non-interactive ``stderr`` is now line-buffered instead of fully buffered."
msgstr "非交互模式下，``stderr`` 现在是行缓冲的，而不是全缓冲的。"

#: ../../library/sys.rst:1870
msgid ""
"To write or read binary data from/to the standard streams, use the "
"underlying binary :data:`~io.TextIOBase.buffer` object.  For example, to "
"write bytes to :data:`stdout`, use ``sys.stdout.buffer.write(b'abc')``."
msgstr ""
"要从标准流写入或读取二进制数据，请使用底层二进制 :data:`~io.TextIOBase.buffer` 对象。例如，要将字节写入 "
":data:`stdout`，请使用 ``sys.stdout.buffer.write(b'abc')``。"

#: ../../library/sys.rst:1874
msgid ""
"However, if you are writing a library (and do not control in which context "
"its code will be executed), be aware that the standard streams may be "
"replaced with file-like objects like :class:`io.StringIO` which do not "
"support the :attr:`!buffer` attribute."
msgstr ""
"但是，如果你正在编写一个库（并且不能控制其代码执行所在的上下文），请注意标准流可能会被不支持 :attr:`!buffer` 属性的文件型对象如 "
":class:`io.StringIO` 所取代。"

#: ../../library/sys.rst:1884
msgid ""
"These objects contain the original values of ``stdin``, ``stderr`` and "
"``stdout`` at the start of the program.  They are used during finalization, "
"and could be useful to print to the actual standard stream no matter if the "
"``sys.std*`` object has been redirected."
msgstr ""
"程序开始时，这些对象存有 ``stdin``、``stderr`` 和 ``stdout`` "
"的初始值。它们在程序结束前都可以使用，且在需要向实际的标准流打印内容时很有用，无论 ``sys.std*`` 对象是否已重定向。"

#: ../../library/sys.rst:1889
msgid ""
"It can also be used to restore the actual files to known working file "
"objects in case they have been overwritten with a broken object.  However, "
"the preferred way to do this is to explicitly save the previous stream "
"before replacing it, and restore the saved object."
msgstr ""
"如果实际文件已经被覆盖成一个损坏的对象了，那它也可用于将实际文件还原成能正常工作的文件对象。但是，本过程的最佳方法应该是，在原来的流被替换之前就显式地保存它，并使用这一保存的对象来还原。"

#: ../../library/sys.rst:1895
msgid ""
"Under some conditions ``stdin``, ``stdout`` and ``stderr`` as well as the "
"original values ``__stdin__``, ``__stdout__`` and ``__stderr__`` can be "
"``None``. It is usually the case for Windows GUI apps that aren't connected "
"to a console and Python apps started with :program:`pythonw`."
msgstr ""
"某些情况下的 ``stdin``、``stdout`` 和 ``stderr`` 以及初始值 ``__stdin__``、``__stdout__`` "
"和 ``__stderr__`` 可以是 ``None``。通常发生在未连接到控制台的 Windows GUI app 中，以及在用 "
":program:`pythonw` 启动的 Python app 中。"

#: ../../library/sys.rst:1903
msgid ""
"A frozenset of strings containing the names of standard library modules."
msgstr "一个包含标准库模组名称字符串的冻结集合。"

#: ../../library/sys.rst:1905
msgid ""
"It is the same on all platforms. Modules which are not available on some "
"platforms and modules disabled at Python build are also listed. All module "
"kinds are listed: pure Python, built-in, frozen and extension modules. Test "
"modules are excluded."
msgstr ""
"它在所有平台上都保持一致。 在某些平台上不可用的模块和在 Python 编译时被禁用的模块也会被列出。 所有种类的模块都会被列出：纯 Python "
"模块、内置模块、冻结模块和扩展模块等。  测试模块则会被排除掉。"

#: ../../library/sys.rst:1910
msgid ""
"For packages, only the main package is listed: sub-packages and sub-modules "
"are not listed. For example, the ``email`` package is listed, but the "
"``email.mime`` sub-package and the ``email.message`` sub-module are not "
"listed."
msgstr ""
"对于包来说，仅会列出主包：子包和子模块不会被列出。 例如，``email`` 包会被列出，但 ``email.mime`` 子包和 "
"``email.message`` 子模块不会被列出。"

#: ../../library/sys.rst:1915
msgid "See also the :data:`sys.builtin_module_names` list."
msgstr "另请参阅 :data:`sys.builtin_module_names` 列表。"

#: ../../library/sys.rst:1922
msgid ""
"A :term:`named tuple` holding information about the thread implementation."
msgstr "一个 :term:`具名元组 <named tuple>`，包含线程实现的信息。"

#: ../../library/sys.rst:1927
msgid "The name of the thread implementation:"
msgstr "线程实现的名称："

#: ../../library/sys.rst:1929
msgid "``\"nt\"``: Windows threads"
msgstr "``\"nt\"``: Windows 线程"

#: ../../library/sys.rst:1930
msgid "``\"pthread\"``: POSIX threads"
msgstr "``\"pthread\"``: POSIX 线程"

#: ../../library/sys.rst:1931
msgid ""
"``\"pthread-stubs\"``: stub POSIX threads (on WebAssembly platforms without "
"threading support)"
msgstr "``\"pthread-stubs\"``: 转存 POSIX 线程（在不支持线程的 WebAssembly 平台上）"

#: ../../library/sys.rst:1933
msgid "``\"solaris\"``: Solaris threads"
msgstr "``\"solaris\"``: Solaris 线程"

#: ../../library/sys.rst:1937
msgid "The name of the lock implementation:"
msgstr "锁实现的名称："

#: ../../library/sys.rst:1939
msgid "``\"semaphore\"``: a lock uses a semaphore"
msgstr "``\"semaphore\"``: 锁使用一个寄存器"

#: ../../library/sys.rst:1940
msgid "``\"mutex+cond\"``: a lock uses a mutex and a condition variable"
msgstr "``\"mutex+cond\"``: 锁使用互斥和条件变量"

#: ../../library/sys.rst:1941
msgid "``None`` if this information is unknown"
msgstr "``None`` 如果此信息未知"

#: ../../library/sys.rst:1945
msgid ""
"The name and version of the thread library. It is a string, or ``None`` if "
"this information is unknown."
msgstr "线程库的名称和版本。 它是一个字符串，如果此信息未知则为 ``None``。"

#: ../../library/sys.rst:1953
msgid ""
"When this variable is set to an integer value, it determines the maximum "
"number of levels of traceback information printed when an unhandled "
"exception occurs. The default is ``1000``.  When set to ``0`` or less, all "
"traceback information is suppressed and only the exception type and value "
"are printed."
msgstr ""
"当该变量值设置为整数，在发生未处理的异常时，它将决定打印的回溯信息的最大层级数。默认为 ``1000``。当将其设置为 ``0`` 或小于 "
"0，将关闭所有回溯信息，并且只打印异常类型和异常值。"

#: ../../library/sys.rst:1961
msgid "Handle an unraisable exception."
msgstr "处理一个无法抛出的异常。"

#: ../../library/sys.rst:1963
msgid ""
"Called when an exception has occurred but there is no way for Python to "
"handle it. For example, when a destructor raises an exception or during "
"garbage collection (:func:`gc.collect`)."
msgstr ""
"它会在发生了一个异常但 Python 没有办法处理时被调用。例如，当一个析构器引发了异常，或在垃圾回收 (:func:`gc.collect`) "
"期间引发了异常。"

#: ../../library/sys.rst:1967
msgid "The *unraisable* argument has the following attributes:"
msgstr "*unraisable* 参数具有以下属性:"

#: ../../library/sys.rst:1969
msgid ":attr:`!exc_type`: Exception type."
msgstr ":attr:`!exc_type`: 异常类型。"

#: ../../library/sys.rst:1970
msgid ":attr:`!exc_value`: Exception value, can be ``None``."
msgstr ":attr:`!exc_value`: 异常值，可以为 ``None``。"

#: ../../library/sys.rst:1971
msgid ":attr:`!exc_traceback`: Exception traceback, can be ``None``."
msgstr ":attr:`!exc_traceback`: 异常回溯，可以为 ``None``。"

#: ../../library/sys.rst:1972
msgid ":attr:`!err_msg`: Error message, can be ``None``."
msgstr ":attr:`!err_msg`: 错误消息，可以为 ``None``。"

#: ../../library/sys.rst:1973
msgid ":attr:`!object`: Object causing the exception, can be ``None``."
msgstr ":attr:`!object`: 导致异常的对象，可以为 ``None``。"

#: ../../library/sys.rst:1975
msgid ""
"The default hook formats :attr:`!err_msg` and :attr:`!object` as: "
"``f'{err_msg}: {object!r}'``; use \"Exception ignored in\" error message if "
":attr:`!err_msg` is ``None``."
msgstr ""
"默认的钩子会将 :attr:`!err_msg` 和 :attr:`!object` 格式化为: ``f'{err_msg}: "
"{object!r}'``；如果 :attr:`!err_msg` 为 ``None`` 则会使用 \"Exception ignored in\" "
"错误消息。"

#: ../../library/sys.rst:1979
msgid ""
":func:`sys.unraisablehook` can be overridden to control how unraisable "
"exceptions are handled."
msgstr "要改变无法抛出的异常的处理过程，可以重写 :func:`sys.unraisablehook`。"

#: ../../library/sys.rst:1984
msgid ":func:`excepthook` which handles uncaught exceptions."
msgstr ":func:`excepthook` 处理未捕获的异常。"

#: ../../library/sys.rst:1988
msgid ""
"Storing :attr:`!exc_value` using a custom hook can create a reference cycle."
" It should be cleared explicitly to break the reference cycle when the "
"exception is no longer needed."
msgstr "使用自定义钩子存储 :attr:`!exc_value` 可能会创建引用循环。 当该异常不再需要时应当显式地清空以打破引用循环。"

#: ../../library/sys.rst:1992
msgid ""
"Storing :attr:`!object` using a custom hook can resurrect it if it is set to"
" an object which is being finalized. Avoid storing :attr:`!object` after the"
" custom hook completes to avoid resurrecting objects."
msgstr ""
"使用自定义钩子存储 :attr:`!object` 可能会在它被设为正在终结的对象时将其复活。 为避免对象复活应当避免在自定义钩子完成后存储 "
":attr:`!object`。"

#: ../../library/sys.rst:1996 ../../library/sys.rst:1998
msgid ""
"Raise an auditing event ``sys.unraisablehook`` with arguments *hook*, "
"*unraisable* when an exception that cannot be handled occurs. The "
"*unraisable* object is the same as what will be passed to the hook. If no "
"hook has been set, *hook* may be ``None``."
msgstr ""
"当发生无法处理的异常时将引发一个审计事件 ``sys.unraisablehook``，附带参数 *hook*、*unraisable*。 其中 "
"*unraisable* 对象与传递给钩子的对象相同。 如果没有设置钩子，那么 *hook* 可以为 ``None``。"

#: ../../library/sys.rst:2007
msgid ""
"A string containing the version number of the Python interpreter plus "
"additional information on the build number and compiler used.  This string "
"is displayed when the interactive interpreter is started.  Do not extract "
"version information out of it, rather, use :data:`version_info` and the "
"functions provided by the :mod:`platform` module."
msgstr ""
"一个包含 Python 解释器版本号加编译版本号以及所用编译器等额外信息的字符串。 此字符串会在交互式解释器启动时显示。 "
"请不要从中提取版本信息，而应当使用 :data:`version_info` 以及 :mod:`platform` 模块所提供的函数。"

#: ../../library/sys.rst:2016
msgid ""
"The C API version for this interpreter.  Programmers may find this useful "
"when debugging version conflicts between Python and extension modules."
msgstr "这个解释器的 C API 版本。当你在调试 Python及期扩展模板的版本冲突这个功能非常有用。"

#: ../../library/sys.rst:2022
msgid ""
"A tuple containing the five components of the version number: *major*, "
"*minor*, *micro*, *releaselevel*, and *serial*.  All values except "
"*releaselevel* are integers; the release level is ``'alpha'``, ``'beta'``, "
"``'candidate'``, or ``'final'``.  The ``version_info`` value corresponding "
"to the Python version 2.0 is ``(2, 0, 0, 'final', 0)``.  The components can "
"also be accessed by name, so ``sys.version_info[0]`` is equivalent to "
"``sys.version_info.major`` and so on."
msgstr ""
"一个包含版本号五部分的元组: *major*, *minor*, *micro*, *releaselevel* 和 *serial*。 除 "
"*releaselevel* 外的所有值均为整数；发布级别值则为 ``'alpha'``, ``'beta'``, ``'candidate'`` 或 "
"``'final'``。 对应于 Python 版本 2.0 的 ``version_info`` 值为 ``(2, 0, 0, 'final', "
"0)``。 这些部分也可按名称访问，因此 ``sys.version_info[0]`` 就等价于 "
"``sys.version_info.major``，依此类推。"

#: ../../library/sys.rst:2030
msgid "Added named component attributes."
msgstr "增加了以名称表示的各部分属性。"

#: ../../library/sys.rst:2035
msgid ""
"This is an implementation detail of the warnings framework; do not modify "
"this value.  Refer to the :mod:`warnings` module for more information on the"
" warnings framework."
msgstr "这是警告框架的一个实现细节；请不要修改此值。 有关警告框架的更多信息请参阅 :mod:`warnings` 模块。"

#: ../../library/sys.rst:2042
msgid ""
"The version number used to form registry keys on Windows platforms. This is "
"stored as string resource 1000 in the Python DLL.  The value is normally the"
" major and minor versions of the running Python interpreter.  It is provided"
" in the :mod:`sys` module for informational purposes; modifying this value "
"has no effect on the registry keys used by Python."
msgstr ""
"用于在 Windows 平台上作为注册表键的版本号。这在 Python DLL 中被存储为 1000 号字符串资源。 其值通常是正在运行的 Python"
" 解释器的主要和次要版本号。 它在 :mod:`sys` 模块中提供是为了信息展示目的；修改此值不会影响 Python 所使用的注册表键。"

#: ../../library/sys.rst:2054
msgid ""
"Namespace containing functions and constants for register callbacks and "
"controlling monitoring events. See  :mod:`sys.monitoring` for details."
msgstr "包含用于注册回调和控制监控事件的函数和常量的命名空间。 详情参见 :mod:`sys.monitoring`。"

#: ../../library/sys.rst:2060
msgid ""
"A dictionary of the various implementation-specific flags passed through the"
" :option:`-X` command-line option.  Option names are either mapped to their "
"values, if given explicitly, or to :const:`True`.  Example:"
msgstr ""
"一个字典，包含通过 :option:`-X` 命令行选项传递的旗标，这些旗标专属于各种具体实现。选项名称将会映射到对应的值（如果显式指定）或者 "
":const:`True`。例如:"

#: ../../library/sys.rst:2064
msgid ""
"$ ./python -Xa=b -Xc\n"
"Python 3.2a3+ (py3k, Oct 16 2010, 20:14:50)\n"
"[GCC 4.4.3] on linux2\n"
"Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n"
">>> import sys\n"
">>> sys._xoptions\n"
"{'a': 'b', 'c': True}"
msgstr ""
"$ ./python -Xa=b -Xc\n"
"Python 3.2a3+ (py3k, Oct 16 2010, 20:14:50)\n"
"[GCC 4.4.3] on linux2\n"
"Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n"
">>> import sys\n"
">>> sys._xoptions\n"
"{'a': 'b', 'c': True}"

#: ../../library/sys.rst:2076
msgid ""
"This is a CPython-specific way of accessing options passed through "
":option:`-X`.  Other implementations may export them through other means, or"
" not at all."
msgstr "这是 CPython 专属的访问通过 :option:`-X` 传递的选项的方式。 其他实现可能会通过其他方式导出它们，或者完全不导出。"

#: ../../library/sys.rst:2084
msgid "Citations"
msgstr "引用"

#: ../../library/sys.rst:2085
msgid ""
"ISO/IEC 9899:1999.  \"Programming languages -- C.\"  A public draft of this "
"standard is available at https://www.open-"
"std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\\ ."
msgstr ""
"ISO/IEC 9899:1999.  \"Programming languages -- C.\"  该标准的公开草案可从 "
"https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf 获得。"

#: ../../library/sys.rst:99
msgid "auditing"
msgstr "审计"

#: ../../library/sys.rst:462
msgid "object"
msgstr "object -- 对象"

#: ../../library/sys.rst:462
msgid "traceback"
msgstr "traceback -- 回溯"

#: ../../library/sys.rst:956 ../../library/sys.rst:1536
msgid "profile function"
msgstr "性能分析函数"

#: ../../library/sys.rst:956 ../../library/sys.rst:1536
msgid "profiler"
msgstr "性能分析器"

#: ../../library/sys.rst:965 ../../library/sys.rst:1619
msgid "trace function"
msgstr "追踪函数"

#: ../../library/sys.rst:965 ../../library/sys.rst:1619
msgid "debugger"
msgstr "调试器"

#: ../../library/sys.rst:1364
msgid "module"
msgstr "module"

#: ../../library/sys.rst:1364
msgid "search"
msgstr "搜索"

#: ../../library/sys.rst:1364
msgid "path"
msgstr "path"

#: ../../library/sys.rst:1500
msgid "interpreter prompts"
msgstr "解释器提示符"

#: ../../library/sys.rst:1500
msgid "prompts, interpreter"
msgstr "提示符，解释器"

#: ../../library/sys.rst:1500
msgid ">>>"
msgstr ">>>"

#: ../../library/sys.rst:1500
msgid "interpreter prompt"
msgstr "解释器提示符"

#: ../../library/sys.rst:1500
msgid "..."
msgstr "..."
