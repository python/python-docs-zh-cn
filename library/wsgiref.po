# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/wsgiref.rst:2
msgid ":mod:`!wsgiref` --- WSGI Utilities and Reference Implementation"
msgstr ":mod:`!wsgiref` --- WSGI 工具和参考实现"

#: ../../library/wsgiref.rst:10
msgid "**Source code:** :source:`Lib/wsgiref`"
msgstr "**源代码:** :source:`Lib/wsgiref`"

#: ../../library/wsgiref.rst:14
msgid ""
"The Web Server Gateway Interface (WSGI) is a standard interface between web "
"server software and web applications written in Python. Having a standard "
"interface makes it easy to use an application that supports WSGI with a "
"number of different web servers."
msgstr ""
"Web 服务器网关接口（WSGI）是 Web 服务器软件和用 Python 编写的 Web 应用程序之间的标准接口。 具有标准接口能够让支持 WSGI "
"的应用程序与多种不同的 Web 服务器配合使用。"

#: ../../library/wsgiref.rst:19
msgid ""
"Only authors of web servers and programming frameworks need to know every "
"detail and corner case of the WSGI design.  You don't need to understand "
"every detail of WSGI just to install a WSGI application or to write a web "
"application using an existing framework."
msgstr ""
"只有 Web 服务器和编程框架的开发者才需要了解 WSGI 设计的每个细节和边界情况。 你不需要了解 WSGI 的每个细节而只需要安装一个 WSGI "
"应用程序或编写使用现有框架的 Web 应用程序。"

#: ../../library/wsgiref.rst:24
msgid ""
":mod:`wsgiref` is a reference implementation of the WSGI specification that "
"can be used to add WSGI support to a web server or framework.  It provides "
"utilities for manipulating WSGI environment variables and response headers, "
"base classes for implementing WSGI servers, a demo HTTP server that serves "
"WSGI applications, types for static type checking, and a validation tool "
"that checks WSGI servers and applications for conformance to the WSGI "
"specification (:pep:`3333`)."
msgstr ""
":mod:`wsgiref` 是 WSGI 规范的一个参考实现，可被用于将 WSGI 支持添加到 Web 服务器或框架中。 它提供了操作 WSGI "
"环境变量和响应标头的工具，实现 WSGI 服务器的基类，可部署 WSGI 应用程序的演示性 HTTP 服务器，用于静态类型检查的类型，以及一个用于检查 "
"WSGI 服务器和应用程序是否符合 WSGI 规范的验证工具 (:pep:`3333`)。"

#: ../../library/wsgiref.rst:32
msgid ""
"See `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ for more "
"information about WSGI, and links to tutorials and other resources."
msgstr ""
"参看 `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ 获取有关 WSGI "
"的更多信息，以及教程和其他资源的链接。"

#: ../../library/wsgiref.rst:39
msgid ":mod:`wsgiref.util` -- WSGI environment utilities"
msgstr ":mod:`wsgiref.util` -- WSGI 环境工具"

#: ../../library/wsgiref.rst:45
msgid ""
"This module provides a variety of utility functions for working with WSGI "
"environments.  A WSGI environment is a dictionary containing HTTP request "
"variables as described in :pep:`3333`.  All of the functions taking an "
"*environ* parameter expect a WSGI-compliant dictionary to be supplied; "
"please see :pep:`3333` for a detailed specification and "
":data:`~wsgiref.types.WSGIEnvironment` for a type alias that can be used in "
"type annotations."
msgstr ""
"本模块提供了多种工具函数配合 WSGI 环境使用。 WSGI 环境就是一个包含 :pep:`3333` 所描述的 HTTP 请求变量的字典。 所有接受 "
"*environ* 形参的函数都会预期得到一个符合 WSGI 规范的字典；请参阅 :pep:`3333` 来了解相关规范的细节并请参阅 "
":data:`~wsgiref.types.WSGIEnvironment` 来了解可被用于类型标注的类型别名。"

#: ../../library/wsgiref.rst:56
msgid ""
"Return a guess for whether ``wsgi.url_scheme`` should be \"http\" or "
"\"https\", by checking for a ``HTTPS`` environment variable in the *environ*"
" dictionary.  The return value is a string."
msgstr ""
"返回对于 ``wsgi.url_scheme`` 应为 \"http\" 还是 \"https\" 的猜测，具体方式是在 *environ* 中检查 "
"``HTTPS`` 环境变量。 返回值是一个字符串。"

#: ../../library/wsgiref.rst:60
msgid ""
"This function is useful when creating a gateway that wraps CGI or a CGI-like"
" protocol such as FastCGI.  Typically, servers providing such protocols will"
" include a ``HTTPS`` variable with a value of \"1\", \"yes\", or \"on\" when"
" a request is received via SSL.  So, this function returns \"https\" if such"
" a value is found, and \"http\" otherwise."
msgstr ""
"此函数适用于创建一个包装了 CGI 或 CGI 类协议例如 FastCGI 的网关。 通常，提供这种协议的服务器将包括一个 ``HTTPS`` "
"变量并会在通过 SSL 接收请求时将其值设为 \"1\", \"yes\" 或 \"on\"。 这样，此函数会在找到上述值时返回 "
"\"https\"，否则返回 \"http\"。"

#: ../../library/wsgiref.rst:69
msgid ""
"Return the full request URI, optionally including the query string, using "
"the algorithm found in the \"URL Reconstruction\" section of :pep:`3333`.  "
"If *include_query* is false, the query string is not included in the "
"resulting URI."
msgstr ""
"使用 :pep:`3333` 的 \"URL Reconstruction\" 一节中的算法返回完整的请求 URL，可能包括查询字符串。 如果 "
"*include_query* 为假值，则结果 URI 中将不包括查询字符串。"

#: ../../library/wsgiref.rst:76
msgid ""
"Similar to :func:`request_uri`, except that the ``PATH_INFO`` and "
"``QUERY_STRING`` variables are ignored.  The result is the base URI of the "
"application object addressed by the request."
msgstr ""
"类似于 :func:`request_uri`，区别在于 ``PATH_INFO`` 和 ``QUERY_STRING`` 变量会被忽略。 "
"结果为请求所指定的应用程序对象的基准 URI。"

#: ../../library/wsgiref.rst:83
msgid ""
"Shift a single name from ``PATH_INFO`` to ``SCRIPT_NAME`` and return the "
"name. The *environ* dictionary is *modified* in-place; use a copy if you "
"need to keep the original ``PATH_INFO`` or ``SCRIPT_NAME`` intact."
msgstr ""
"将单个名称从 ``PATH_INFO`` 变换为 ``SCRIPT_NAME`` 并返回该名称。 *environ* 目录将被原地 "
"*修改*；如果你需要保留原始 ``PATH_INFO`` 或 ``SCRIPT_NAME`` 不变请使用一个副本。"

#: ../../library/wsgiref.rst:87
msgid ""
"If there are no remaining path segments in ``PATH_INFO``, ``None`` is "
"returned."
msgstr "如果 ``PATH_INFO`` 中没有剩余的路径节，则返回 ``None``。"

#: ../../library/wsgiref.rst:89
msgid ""
"Typically, this routine is used to process each portion of a request URI "
"path, for example to treat the path as a series of dictionary keys. This "
"routine modifies the passed-in environment to make it suitable for invoking "
"another WSGI application that is located at the target URI. For example, if "
"there is a WSGI application at ``/foo``, and the request URI path is "
"``/foo/bar/baz``, and the WSGI application at ``/foo`` calls "
":func:`shift_path_info`, it will receive the string \"bar\", and the "
"environment will be updated to be suitable for passing to a WSGI application"
" at ``/foo/bar``.  That is, ``SCRIPT_NAME`` will change from ``/foo`` to "
"``/foo/bar``, and ``PATH_INFO`` will change from ``/bar/baz`` to ``/baz``."
msgstr ""
"通常，此例程被用来处理请求 URI 路径的每个部分，比如说将路径当作是一系列字典键。 此例程会修改传入的环境以使其适合唤起位于目标 URI 上的其他 "
"WSGI 应用程序，如果有一个 WSGI 应用程序位于 ``/foo``，而请求 URI 路径为 ``/foo/bar/baz``，且位于 "
"``/foo`` 的 WSGI 应用程序调用了 :func:`shift_path_info`，它将获得字符串 "
"\"bar\"，而环境将被更新以适合传递给位于 ``/foo/bar`` 的 WSGI 应用程序。 也就是说，``SCRIPT_NAME`` 将由 "
"``/foo`` 变为 ``/foo/bar``，而 ``PATH_INFO`` 将由 ``/bar/baz`` 变为 ``/baz``。"

#: ../../library/wsgiref.rst:100
msgid ""
"When ``PATH_INFO`` is just a \"/\", this routine returns an empty string and"
" appends a trailing slash to ``SCRIPT_NAME``, even though empty path "
"segments are normally ignored, and ``SCRIPT_NAME`` doesn't normally end in a"
" slash.  This is intentional behavior, to ensure that an application can "
"tell the difference between URIs ending in ``/x`` from ones ending in "
"``/x/`` when using this routine to do object traversal."
msgstr ""
"当 ``PATH_INFO`` 只是 \"/\" 时，此例程会返回一个空字符串并在 ``SCRIPT_NAME`` "
"末尾添加一个斜杠，虽然空的路径节通常会被忽略，并且 ``SCRIPT_NAME`` 通常也不以斜杠作为结束。 "
"此行为是有意为之的，用来确保应用程序在使用此例程执行对象遍历时能区分以 ``/x`` 结束的和以 ``/x/`` 结束的 URI。"

#: ../../library/wsgiref.rst:110
msgid "Update *environ* with trivial defaults for testing purposes."
msgstr "以简短的默认值更新 *environ* 用于测试目的。"

#: ../../library/wsgiref.rst:112
msgid ""
"This routine adds various parameters required for WSGI, including "
"``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, ``REQUEST_METHOD``, "
"``SCRIPT_NAME``, ``PATH_INFO``, and all of the :pep:`3333`\\ -defined "
"``wsgi.*`` variables.  It only supplies default values, and does not replace"
" any existing settings for these variables."
msgstr ""
"此例程会添加 WSGI 所需要的各种参数，包括 ``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, "
"``REQUEST_METHOD``, ``SCRIPT_NAME``, ``PATH_INFO`` 以及 :pep:`3333` 中定义的所有 "
"``wsgi.*`` 变量。 它只提供默认值，而不会替换这些变量的现有设置。"

#: ../../library/wsgiref.rst:118
msgid ""
"This routine is intended to make it easier for unit tests of WSGI servers "
"and applications to set up dummy environments.  It should NOT be used by "
"actual WSGI servers or applications, since the data is fake!"
msgstr ""
"此例程的目的是让 WSGI 服务器的单元测试以及应用程序设置测试环境更为容易。 它不应该被实际的 WSGI 服务器或应用程序所使用，因为它用的是假数据！"

#: ../../library/wsgiref.rst:122
msgid ""
"Example usage (see also :func:`~wsgiref.simple_server.demo_app` for another "
"example)::"
msgstr "用法示例 (另请参阅 :func:`~wsgiref.simple_server.demo_app` 中的其他示例)::"

#: ../../library/wsgiref.rst:125
msgid ""
"from wsgiref.util import setup_testing_defaults\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# A relatively simple WSGI application. It's going to print out the\n"
"# environment dictionary after being updated by setup_testing_defaults\n"
"def simple_app(environ, start_response):\n"
"    setup_testing_defaults(environ)\n"
"\n"
"    status = '200 OK'\n"
"    headers = [('Content-type', 'text/plain; charset=utf-8')]\n"
"\n"
"    start_response(status, headers)\n"
"\n"
"    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n"
"           for key, value in environ.items()]\n"
"    return ret\n"
"\n"
"with make_server('', 8000, simple_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"    httpd.serve_forever()"
msgstr ""
"from wsgiref.util import setup_testing_defaults\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# 一个相对简单的 WSGI 应用程序。 它将打印出\n"
"# 由 setup_testing_defaults 更新之后的环境字典\n"
"def simple_app(environ, start_response):\n"
"    setup_testing_defaults(environ)\n"
"\n"
"    status = '200 OK'\n"
"    headers = [('Content-type', 'text/plain; charset=utf-8')]\n"
"\n"
"    start_response(status, headers)\n"
"\n"
"    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n"
"           for key, value in environ.items()]\n"
"    return ret\n"
"\n"
"with make_server('', 8000, simple_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:147
msgid ""
"In addition to the environment functions above, the :mod:`wsgiref.util` "
"module also provides these miscellaneous utilities:"
msgstr "除了上述的环境函数，:mod:`wsgiref.util` 模块还提供了以下辅助工具:"

#: ../../library/wsgiref.rst:153
msgid ""
"Return ``True`` if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header, as "
"defined by :rfc:`2616`."
msgstr ""
"如果 'header_name' 是 :rfc:`2616` 所定义的 HTTP/1.1 \"Hop-by-Hop\" 标头则返回 ``True``。"

#: ../../library/wsgiref.rst:159
msgid ""
"A concrete implementation of the :class:`wsgiref.types.FileWrapper` protocol"
" used to convert a file-like object to an :term:`iterator`. The resulting "
"objects are :term:`iterable`\\ s. As the object is iterated over, the "
"optional *blksize* parameter will be repeatedly passed to the *filelike* "
"object's :meth:`read` method to obtain bytestrings to yield.  When "
":meth:`read` returns an empty bytestring, iteration is ended and is not "
"resumable."
msgstr ""
"一个 :class:`wsgiref.types.FileWrapper` 协议的具体实现被用来将文件型对象转换为 :term:`iterator`。 "
"结果对象将为 :term:`iterable`。 当对象被迭代时，可选的 *blksize* 形参将被反复地传给 *filelike* 对象的 "
":meth:`read` 方法以获取字节器并产生输出。 当 :meth:`read` 返回空字节串时，迭代将结束并且不可再恢复。"

#: ../../library/wsgiref.rst:167
msgid ""
"If *filelike* has a :meth:`close` method, the returned object will also have"
" a :meth:`close` method, and it will invoke the *filelike* object's "
":meth:`close` method when called."
msgstr ""
"如果 *filelike* 具有 :meth:`close` 方法，返回的对象也将具有 :meth:`close` 方法，并且它将在被调用时唤起 "
"*filelike* 对象的 :meth:`close` 方法。"

#: ../../library/wsgiref.rst:171 ../../library/wsgiref.rst:294
#: ../../library/wsgiref.rst:429
msgid "Example usage::"
msgstr "用法示例::"

#: ../../library/wsgiref.rst:173
msgid ""
"from io import StringIO\n"
"from wsgiref.util import FileWrapper\n"
"\n"
"# We're using a StringIO-buffer for as the file-like object\n"
"filelike = StringIO(\"This is an example file-like object\"*10)\n"
"wrapper = FileWrapper(filelike, blksize=5)\n"
"\n"
"for chunk in wrapper:\n"
"    print(chunk)"
msgstr ""
"from io import StringIO\n"
"from wsgiref.util import FileWrapper\n"
"\n"
"# 我们使用一个 StringIO 缓冲区作为文件型对象\n"
"filelike = StringIO(\"This is an example file-like object\"*10)\n"
"wrapper = FileWrapper(filelike, blksize=5)\n"
"\n"
"for chunk in wrapper:\n"
"    print(chunk)"

#: ../../library/wsgiref.rst:183
msgid "Support for :meth:`~object.__getitem__` method has been removed."
msgstr "对 :meth:`~object.__getitem__` 方法的支持已被移除。"

#: ../../library/wsgiref.rst:188
msgid ":mod:`wsgiref.headers` -- WSGI response header tools"
msgstr ":mod:`wsgiref.headers` -- WSGI 响应标头工具"

#: ../../library/wsgiref.rst:194
msgid ""
"This module provides a single class, :class:`Headers`, for convenient "
"manipulation of WSGI response headers using a mapping-like interface."
msgstr "此模块提供了一个单独的类 :class:`Headers`，可以方便地使用一个映射类接口操作 WSGI 响应标头。"

#: ../../library/wsgiref.rst:200
msgid ""
"Create a mapping-like object wrapping *headers*, which must be a list of "
"header name/value tuples as described in :pep:`3333`. The default value of "
"*headers* is an empty list."
msgstr ""
"创建一个包装了 *headers* 的映射类对象，它必须为如 :pep:`3333` 所描述的由标头名称/值元组构成的列表。 *headers* "
"的默认值为一个空列表。"

#: ../../library/wsgiref.rst:204
msgid ""
":class:`Headers` objects support typical mapping operations including "
":meth:`~object.__getitem__`, :meth:`~dict.get`, :meth:`~object.__setitem__`,"
" :meth:`~dict.setdefault`, :meth:`~object.__delitem__` and "
":meth:`~object.__contains__`.  For each of these methods, the key is the "
"header name (treated case-insensitively), and the value is the first value "
"associated with that header name.  Setting a header deletes any existing "
"values for that header, then adds a new value at the end of the wrapped "
"header list.  Headers' existing order is generally maintained, with new "
"headers added to the end of the wrapped list."
msgstr ""
":class:`Headers` 对象支持典型的映射操作包括 :meth:`~object.__getitem__`, "
":meth:`~dict.get`, :meth:`~object.__setitem__`, :meth:`~dict.setdefault`, "
":meth:`~object.__delitem__` 和 :meth:`~object.__contains__`。 "
"对于以上各个方法，映射的键都是标头名称（大小写不敏感），而值则是关联到该标头名称的第一个值。 "
"设置一个标头会移除该标头的任何现有值，再将一个新值添加到所包装的标头列表末尾。 标头的现有顺序通常会保持不变，新的标头会被添加到所包装的列表末尾。"

#: ../../library/wsgiref.rst:214
msgid ""
"Unlike a dictionary, :class:`Headers` objects do not raise an error when you"
" try to get or delete a key that isn't in the wrapped header list. Getting a"
" nonexistent header just returns ``None``, and deleting a nonexistent header"
" does nothing."
msgstr ""
"与字典不同，当你试图获取或删除所包装的标头列表中不存在的键时 :class:`Headers` 对象不会引发错误。 获取一个不存在的标头只是返回 "
"``None``，而删除一个不存在的标头则没有任何影响。"

#: ../../library/wsgiref.rst:219
msgid ""
":class:`Headers` objects also support :meth:`keys`, :meth:`values`, and "
":meth:`items` methods.  The lists returned by :meth:`keys` and :meth:`items`"
" can include the same key more than once if there is a multi-valued header."
"  The ``len()`` of a :class:`Headers` object is the same as the length of "
"its :meth:`items`, which is the same as the length of the wrapped header "
"list.  In fact, the :meth:`items` method just returns a copy of the wrapped "
"header list."
msgstr ""
":class:`Headers` 对象还支持 :meth:`keys`, :meth:`values` 以及 :meth:`items` 方法。 "
"如果存在具有多个值的键则 :meth:`keys` 和 :meth:`items` 所返回的列表可能包括多个相同的键。 对 "
":class:`Headers` 对象执行 ``len()`` 的结果与 :meth:`items` 的长度相同，也与所包装的标头列表的长度相同。 "
"实际上，:meth:`items` 方法只是返回所包装的标头列表的一个副本。"

#: ../../library/wsgiref.rst:226
msgid ""
"Calling ``bytes()`` on a :class:`Headers` object returns a formatted "
"bytestring suitable for transmission as HTTP response headers.  Each header "
"is placed on a line with its value, separated by a colon and a space. Each "
"line is terminated by a carriage return and line feed, and the bytestring is"
" terminated with a blank line."
msgstr ""
"在 :class:`Headers` 对象上调用 ``bytes()`` 将返回适用于作为 HTTP 响应标头来传输的已格式化字节串。 "
"每个标头附带以逗号加空格分隔的值放置在一行中。 每一行都以回车符加换行符结束，且该字节串会以一个空行作为结束。"

#: ../../library/wsgiref.rst:232
msgid ""
"In addition to their mapping interface and formatting features, "
":class:`Headers` objects also have the following methods for querying and "
"adding multi-valued headers, and for adding headers with MIME parameters:"
msgstr "除了映射接口和格式化特性，:class:`Headers` 对象还具有下列方法用来查询和添加多值标头，以及添加具有 MIME 参数的标头:"

#: ../../library/wsgiref.rst:239
msgid "Return a list of all the values for the named header."
msgstr "返回包含指定标头的所有值的列表。"

#: ../../library/wsgiref.rst:241
msgid ""
"The returned list will be sorted in the order they appeared in the original "
"header list or were added to this instance, and may contain duplicates.  Any"
" fields deleted and re-inserted are always appended to the header list.  If "
"no fields exist with the given name, returns an empty list."
msgstr ""
"返回的列表项将按它们在原始标头列表中的出现或被添加到实例中的顺序排序，并可能包含重复项。 任何被删除并重新插入的字段总是会被添加到标头列表末尾。 "
"如果给定名称的字段不存在，则返回一个空列表。"

#: ../../library/wsgiref.rst:249
msgid ""
"Add a (possibly multi-valued) header, with optional MIME parameters "
"specified via keyword arguments."
msgstr "添加一个（可能有多个值）标头，带有通过关键字参数指明的可选的 MIME 参数。"

#: ../../library/wsgiref.rst:252
msgid ""
"*name* is the header field to add.  Keyword arguments can be used to set "
"MIME parameters for the header field.  Each parameter must be a string or "
"``None``. Underscores in parameter names are converted to dashes, since "
"dashes are illegal in Python identifiers, but many MIME parameter names "
"include dashes.  If the parameter value is a string, it is added to the "
"header value parameters in the form ``name=\"value\"``. If it is ``None``, "
"only the parameter name is added. (This is used for MIME parameters without "
"a value.)  Example usage::"
msgstr ""
"*name* 是要添加的标头字段。 可以使用关键字参数来为标头字段设置 MIME 参数。 每个参数必须为字符串或 ``None``。 "
"参数名中的下划线会被转换为连字符，因为连字符不可在 Python 标识符中出现，但许多 MIME 参数名都包括连字符。 如果参数值为字符串，它会以 "
"``name=\"value\"`` 的形式被添加到标头值参数中。 如果为 ``None``，则只会添加参数名。 （这适用于没有值的 MIME 参数。）"
" 示例用法::"

#: ../../library/wsgiref.rst:260
msgid "h.add_header('content-disposition', 'attachment', filename='bud.gif')"
msgstr "h.add_header('content-disposition', 'attachment', filename='bud.gif')"

#: ../../library/wsgiref.rst:262
msgid "The above will add a header that looks like this::"
msgstr "以上代码将添加一个这样的标头::"

#: ../../library/wsgiref.rst:264
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/wsgiref.rst:267
msgid "*headers* parameter is optional."
msgstr "*headers* 形参是可选的。"

#: ../../library/wsgiref.rst:272
msgid ":mod:`wsgiref.simple_server` -- a simple WSGI HTTP server"
msgstr ":mod:`wsgiref.simple_server` -- 一个简单的 WSGI HTTP 服务器"

#: ../../library/wsgiref.rst:278
msgid ""
"This module implements a simple HTTP server (based on :mod:`http.server`) "
"that serves WSGI applications.  Each server instance serves a single WSGI "
"application on a given host and port.  If you want to serve multiple "
"applications on a single host and port, you should create a WSGI application"
" that parses ``PATH_INFO`` to select which application to invoke for each "
"request.  (E.g., using the :func:`shift_path_info` function from "
":mod:`wsgiref.util`.)"
msgstr ""
"此模块实现了一个简单的 HTTP 服务器 (基于 :mod:`http.server`) 来发布 WSGI 应用程序。 "
"每个服务器实例会在给定的主机名和端口号上发布一个 WSGI 应用程序。 如果你想在一个主机名和端口号上发布多个应用程序，你应当创建一个通过解析 "
"``PATH_INFO`` 来选择每个请求要唤起哪个应用程序的 WSGI 应用程序。 (例如，使用 :mod:`wsgiref.util` 中的  "
":func:`shift_path_info` 函数。)"

#: ../../library/wsgiref.rst:289
msgid ""
"Create a new WSGI server listening on *host* and *port*, accepting "
"connections for *app*.  The return value is an instance of the supplied "
"*server_class*, and will process requests using the specified "
"*handler_class*.  *app* must be a WSGI application object, as defined by "
":pep:`3333`."
msgstr ""
"创建一个新的 WSGI 服务器并在 *host* 和 *port* 上进行监听，接受对 *app* 的连接。 返回值是所提供的 "
"*server_class* 的实例，并将使用指定的 *handler_class* 来处理请求。 *app* 必须是一个如 :pep:`3333` "
"所定义的 WSGI 应用程序对象。"

#: ../../library/wsgiref.rst:296
msgid ""
"from wsgiref.simple_server import make_server, demo_app\n"
"\n"
"with make_server('', 8000, demo_app) as httpd:\n"
"    print(\"Serving HTTP on port 8000...\")\n"
"\n"
"    # Respond to requests until process is killed\n"
"    httpd.serve_forever()\n"
"\n"
"    # Alternative: serve one request, then exit\n"
"    httpd.handle_request()"
msgstr ""
"from wsgiref.simple_server import make_server, demo_app\n"
"\n"
"with make_server('', 8000, demo_app) as httpd:\n"
"    print(\"Serving HTTP on port 8000...\")\n"
"\n"
"    # 响应请求直到进程被杀死\n"
"    httpd.serve_forever()\n"
"\n"
"    # 或者：服务一次请求，然后退出\n"
"    httpd.handle_request()"

#: ../../library/wsgiref.rst:310
msgid ""
"This function is a small but complete WSGI application that returns a text "
"page containing the message \"Hello world!\" and a list of the key/value "
"pairs provided in the *environ* parameter.  It's useful for verifying that a"
" WSGI server (such as :mod:`wsgiref.simple_server`) is able to run a simple "
"WSGI application correctly."
msgstr ""
"此函数是一个小巧但完整的 WSGI 应用程序，它返回一个包含消息 \"Hello world!\" 以及 *environ* "
"形参中提供的键/值对的文本页面。 它适用于验证 WSGI 服务器 (例如 :mod:`wsgiref.simple_server`) "
"是否能够正确地运行一个简单的 WSGI 应用程序。"

#: ../../library/wsgiref.rst:316
msgid ""
"The *start_response* callable should follow the :class:`.StartResponse` "
"protocol."
msgstr "*start_response* 可调用对象必须遵循 :class:`.StartResponse` 协议。"

#: ../../library/wsgiref.rst:321
msgid ""
"Create a :class:`WSGIServer` instance.  *server_address* should be a "
"``(host,port)`` tuple, and *RequestHandlerClass* should be the subclass of "
":class:`http.server.BaseHTTPRequestHandler` that will be used to process "
"requests."
msgstr ""
"创建一个 :class:`WSGIServer` 实例。 *server_address* 应当是一个 ``(host,port)`` 元组，而 "
"*RequestHandlerClass* 应当是 :class:`http.server.BaseHTTPRequestHandler` "
"的子类，它将被用来处理请求。"

#: ../../library/wsgiref.rst:326
msgid ""
"You do not normally need to call this constructor, as the "
":func:`make_server` function can handle all the details for you."
msgstr "你通常不需要调用此构造器，因为 :func:`make_server` 函数能为你处理所有的细节。"

#: ../../library/wsgiref.rst:329
msgid ""
":class:`WSGIServer` is a subclass of :class:`http.server.HTTPServer`, so all"
" of its methods (such as :meth:`serve_forever` and :meth:`handle_request`) "
"are available. :class:`WSGIServer` also provides these WSGI-specific "
"methods:"
msgstr ""
":class:`WSGIServer` 是 :class:`http.server.HTTPServer` 的子类，因此它所有的方法 (例如 "
":meth:`serve_forever` 和 :meth:`handle_request`) 都是可用的。 :class:`WSGIServer` "
"还提供了以下 WSGI 专属的方法:"

#: ../../library/wsgiref.rst:336
msgid ""
"Sets the callable *application* as the WSGI application that will receive "
"requests."
msgstr "将可调用对象 *application* 设为将要接受请求的 WSGI 应用程序。"

#: ../../library/wsgiref.rst:342
msgid "Returns the currently set application callable."
msgstr "返回当前设置的应用程序可调用对象。"

#: ../../library/wsgiref.rst:344
msgid ""
"Normally, however, you do not need to use these additional methods, as "
":meth:`set_app` is normally called by :func:`make_server`, and the "
":meth:`get_app` exists mainly for the benefit of request handler instances."
msgstr ""
"但是，你通常不需要使用这些附加的方法，因为 :meth:`set_app` 通常会由 :func:`make_server` 来调用，而 "
":meth:`get_app` 主要是针对请求处理器实例的。"

#: ../../library/wsgiref.rst:351
msgid ""
"Create an HTTP handler for the given *request* (i.e. a socket), "
"*client_address* (a ``(host,port)`` tuple), and *server* "
"(:class:`WSGIServer` instance)."
msgstr ""
"为给定的 *request* 创建一个 HTTP 处理器 (例如套接字)，*client_address* (一个 ``(host,port)`` "
"元组)，以及 *server* (:class:`WSGIServer` 实例)。"

#: ../../library/wsgiref.rst:354
msgid ""
"You do not need to create instances of this class directly; they are "
"automatically created as needed by :class:`WSGIServer` objects.  You can, "
"however, subclass this class and supply it as a *handler_class* to the "
":func:`make_server` function.  Some possibly relevant methods for overriding"
" in subclasses:"
msgstr ""
"你不需要直接创建该类的实例；它们会根据 :class:`WSGIServer` 对象的需要自动创建。 但是，你可以子类化该类并将其作为 "
"*handler_class* 提供给 :func:`make_server` 函数。 一些可能在子类中重载的相关方法:"

#: ../../library/wsgiref.rst:363
msgid ""
"Return a :data:`~wsgiref.types.WSGIEnvironment` dictionary for a request.  "
"The default implementation copies the contents of the :class:`WSGIServer` "
"object's :attr:`base_environ` dictionary attribute and then adds various "
"headers derived from the HTTP request.  Each call to this method should "
"return a new dictionary containing all of the relevant CGI environment "
"variables as specified in :pep:`3333`."
msgstr ""
"返回对应于一个请求的 :data:`~wsgiref.types.WSGIEnvironment` 字典。 默认实现会拷贝 "
":class:`WSGIServer` 对象的 :attr:`base_environ` 字典属性的内容然后添加从 HTTP 请求获取的各种标头。 "
"对此方法的每次调用都应当返回一个新的包含 :pep:`3333` 所规定的所有相关 CGI 环境变量的字典。"

#: ../../library/wsgiref.rst:374
msgid ""
"Return the object that should be used as the ``wsgi.errors`` stream. The "
"default implementation just returns ``sys.stderr``."
msgstr "返回应被用作 ``wsgi.errors`` 流的对象。 默认实现将只返回 ``sys.stderr``。"

#: ../../library/wsgiref.rst:380
msgid ""
"Process the HTTP request.  The default implementation creates a handler "
"instance using a :mod:`wsgiref.handlers` class to implement the actual WSGI "
"application interface."
msgstr ""
"处理 HTTP 请求。 默认的实现会使用 :mod:`wsgiref.handlers` 类创建一个处理器实例来实现实际的 WSGI 应用程序接口。"

#: ../../library/wsgiref.rst:386
msgid ":mod:`wsgiref.validate` --- WSGI conformance checker"
msgstr ":mod:`wsgiref.validate` --- WSGI 一致性检查器"

#: ../../library/wsgiref.rst:392
msgid ""
"When creating new WSGI application objects, frameworks, servers, or "
"middleware, it can be useful to validate the new code's conformance using "
":mod:`wsgiref.validate`.  This module provides a function that creates WSGI "
"application objects that validate communications between a WSGI server or "
"gateway and a WSGI application object, to check both sides for protocol "
"conformance."
msgstr ""
"当创建新的 WSGI 应用程序对象、框架、服务器或中间件时，使用 :mod:`wsgiref.validate` 来验证新代码的一致性是很有用的。 "
"此模块提供了一个创建 WSGI 应用程序对象的函数来验证 WSGI 服务器或网关与 WSGI 应用程序对象之间的通信，以便检查双方的协议一致性。"

#: ../../library/wsgiref.rst:399
msgid ""
"Note that this utility does not guarantee complete :pep:`3333` compliance; "
"an absence of errors from this module does not necessarily mean that errors "
"do not exist.  However, if this module does produce an error, then it is "
"virtually certain that either the server or application is not 100% "
"compliant."
msgstr ""
"请注意这个工具并不保证完全符合 :pep:`3333`；此模块没有报告错误并不一定表示不存在错误。 "
"但是，如果此模块确实报告了错误，那么几乎可以肯定服务器或应用程序不是 100% 符合要求的。"

#: ../../library/wsgiref.rst:404
msgid ""
"This module is based on the :mod:`paste.lint` module from Ian Bicking's "
"\"Python Paste\" library."
msgstr "此模块是基于 Ian Bicking 的 \"Python Paste\" 库的 :mod:`paste.lint` 模块。"

#: ../../library/wsgiref.rst:410
msgid ""
"Wrap *application* and return a new WSGI application object.  The returned "
"application will forward all requests to the original *application*, and "
"will check that both the *application* and the server invoking it are "
"conforming to the WSGI specification and to :rfc:`2616`."
msgstr ""
"包装 *application* 并返回一个新的 WSGI 应用程序对象。  返回的应用程序将转发所有请求到原始的 *application*，并将检查"
" *application* 和唤起它的服务器是否都符合 WSGI 规范和 :rfc:`2616`。"

#: ../../library/wsgiref.rst:415
msgid ""
"Any detected nonconformance results in an :exc:`AssertionError` being "
"raised; note, however, that how these errors are handled is server-"
"dependent.  For example, :mod:`wsgiref.simple_server` and other servers "
"based on :mod:`wsgiref.handlers` (that don't override the error handling "
"methods to do something else) will simply output a message that an error has"
" occurred, and dump the traceback to ``sys.stderr`` or some other error "
"stream."
msgstr ""
"任何被检测到的不一致性都会导致引发 :exc:`AssertionError`；但是请注意，如何对待这些错误取决于具体服务器。 "
"例如，:mod:`wsgiref.simple_server` 和其他基于 :mod:`wsgiref.handlers` "
"的服务器（它们没有重载错误处理方法来做其他操作）将简单地输出一条消息报告发生了错误，并将回溯转给 ``sys.stderr`` 或者其他错误数据流。"

#: ../../library/wsgiref.rst:422
msgid ""
"This wrapper may also generate output using the :mod:`warnings` module to "
"indicate behaviors that are questionable but which may not actually be "
"prohibited by :pep:`3333`.  Unless they are suppressed using Python command-"
"line options or the :mod:`warnings` API, any such warnings will be written "
"to ``sys.stderr`` (*not* ``wsgi.errors``, unless they happen to be the same "
"object)."
msgstr ""
"这个包装器也可能会使用 :mod:`warnings` 模块生成输出来指明存在问题但实际上未被 :pep:`3333` 所禁止的行为。 除非它们被 "
"Python 命令行选项或 :mod:`warnings` API 所屏蔽，否则任何此类警告都将被写入到 ``sys.stderr`` (*不是* "
"``wsgi.errors``，除非它们恰好是同一个对象)。"

#: ../../library/wsgiref.rst:431
msgid ""
"from wsgiref.validate import validator\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# Our callable object which is intentionally not compliant to the\n"
"# standard, so the validator is going to break\n"
"def simple_app(environ, start_response):\n"
"    status = '200 OK'  # HTTP Status\n"
"    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # This is going to break because we need to return a list, and\n"
"    # the validator is going to inform us\n"
"    return b\"Hello World\"\n"
"\n"
"# This is the application wrapped in a validator\n"
"validator_app = validator(simple_app)\n"
"\n"
"with make_server('', 8000, validator_app) as httpd:\n"
"    print(\"Listening on port 8000....\")\n"
"    httpd.serve_forever()"
msgstr ""
"from wsgiref.validate import validator\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# 我们的可调用对象与标准是故意不兼容的，\n"
"# 因此验证器将会出错\n"
"def simple_app(environ, start_response):\n"
"    status = '200 OK'  # HTTP 状态\n"
"    headers = [('Content-type', 'text/plain')]  # HTTP 标头\n"
"    start_response(status, headers)\n"
"\n"
"    # 这将会出错因为我们需要返回一个列表，\n"
"    # 验证器将会提醒我们\n"
"    return b\"Hello World\"\n"
"\n"
"# 这是包装在验证器中国应用程序\n"
"validator_app = validator(simple_app)\n"
"\n"
"with make_server('', 8000, validator_app) as httpd:\n"
"    print(\"Listening on port 8000....\")\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:454
msgid ":mod:`wsgiref.handlers` -- server/gateway base classes"
msgstr ":mod:`wsgiref.handlers` -- 服务器/网关基类"

#: ../../library/wsgiref.rst:460
msgid ""
"This module provides base handler classes for implementing WSGI servers and "
"gateways.  These base classes handle most of the work of communicating with "
"a WSGI application, as long as they are given a CGI-like environment, along "
"with input, output, and error streams."
msgstr ""
"此模块提供了用于实现 WSGI 服务器和网关的处理器基类。 这些基类可处理大部分与 WSGI "
"应用程序通信的工作，只要给予它们一个带有输入、输出和错误流的 CGI 类环境。"

#: ../../library/wsgiref.rst:468
msgid ""
"CGI-based invocation via ``sys.stdin``, ``sys.stdout``, ``sys.stderr`` and "
"``os.environ``.  This is useful when you have a WSGI application and want to"
" run it as a CGI script.  Simply invoke ``CGIHandler().run(app)``, where "
"``app`` is the WSGI application object you wish to invoke."
msgstr ""
"通过 ``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 和 ``os.environ`` 发起基于 CGI "
"的调用。 这在当你有一个 WSGI 应用程序并想将其作为 CGI 脚本运行时很有用处。 只需唤起 "
"``CGIHandler().run(app)``，其中 ``app`` 是你想要唤起的 WSGI 应用程序。"

#: ../../library/wsgiref.rst:473
msgid ""
"This class is a subclass of :class:`BaseCGIHandler` that sets "
"``wsgi.run_once`` to true, ``wsgi.multithread`` to false, and "
"``wsgi.multiprocess`` to true, and always uses :mod:`sys` and :mod:`os` to "
"obtain the necessary CGI streams and environment."
msgstr ""
"该类是 :class:`BaseCGIHandler` 的子类，它将设置 ``wsgi.run_once`` "
"为真值，``wsgi.multithread`` 为假值，``wsgi.multiprocess`` 为真值，并总是使用 :mod:`sys` 和 "
":mod:`os` 来获取所需的 CGI 流和环境。"

#: ../../library/wsgiref.rst:481
msgid ""
"A specialized alternative to :class:`CGIHandler`, for use when deploying on "
"Microsoft's IIS web server, without having set the config allowPathInfo "
"option (IIS>=7) or metabase allowPathInfoForScriptMappings (IIS<7)."
msgstr ""
":class:`CGIHandler` 的一个专门化替代，用于在 Microsoft 的 IIS Web 服务器上部署，无需设置 config "
"allowPathInfo 选项 (IIS>=7) 或 metabase allowPathInfoForScriptMappings (IIS<7)。"

#: ../../library/wsgiref.rst:485
msgid ""
"By default, IIS gives a ``PATH_INFO`` that duplicates the ``SCRIPT_NAME`` at"
" the front, causing problems for WSGI applications that wish to implement "
"routing. This handler strips any such duplicated path."
msgstr ""
"默认情况下，IIS 给出的 ``PATH_INFO`` 会与前面的 ``SCRIPT_NAME`` 重复，导致想要实现路由的 WSGI "
"应用程序出现问题。 这个处理器会去除任何这样的重复路径。"

#: ../../library/wsgiref.rst:489
msgid ""
"IIS can be configured to pass the correct ``PATH_INFO``, but this causes "
"another bug where ``PATH_TRANSLATED`` is wrong. Luckily this variable is "
"rarely used and is not guaranteed by WSGI. On IIS<7, though, the setting can"
" only be made on a vhost level, affecting all other script mappings, many of"
" which break when exposed to the ``PATH_TRANSLATED`` bug. For this reason "
"IIS<7 is almost never deployed with the fix (Even IIS7 rarely uses it "
"because there is still no UI for it.)."
msgstr ""
"IIS 可被配置为传递正确的 ``PATH_INFO``，但这会导致另一个 ``PATH_TRANSLATED`` 出错的问题。 "
"幸运的是这个变量很少被使用并且不被 WSGI 所保证。 但是在 IIS<7 上，这个设置只能在 vhost "
"层级上进行，影响到所有其他脚本映射，其中许多在受 ``PATH_TRANSLATED`` 问题影响时都会中断运行。 因此 IIS<7 "
"的部署几乎从不附带这样的修正（即使 IIS7 也很少使用它，因为它仍然不带 UI）。"

#: ../../library/wsgiref.rst:497
msgid ""
"There is no way for CGI code to tell whether the option was set, so a "
"separate handler class is provided.  It is used in the same way as "
":class:`CGIHandler`, i.e., by calling ``IISCGIHandler().run(app)``, where "
"``app`` is the WSGI application object you wish to invoke."
msgstr ""
"CGI 代码没有办法确定该选项是否已设置，因此提供了一个单独的处理器类。 它的用法与 :class:`CGIHandler` 相同，即通过调用 "
"``IISCGIHandler().run(app)``，其中 ``app`` 是你想要唤起的 WSGI 应用程序。"

#: ../../library/wsgiref.rst:507
msgid ""
"Similar to :class:`CGIHandler`, but instead of using the :mod:`sys` and "
":mod:`os` modules, the CGI environment and I/O streams are specified "
"explicitly. The *multithread* and *multiprocess* values are used to set the "
"``wsgi.multithread`` and ``wsgi.multiprocess`` flags for any applications "
"run by the handler instance."
msgstr ""
"类似于 :class:`CGIHandler`，但是改用 :mod:`sys` 和 :mod:`os` 模块，CGI 环境和 I/O 流会被显式地指定。"
" *multithread* 和 *multiprocess* 值被用来为处理器实例所运行的任何应用程序设置 ``wsgi.multithread`` "
"和 ``wsgi.multiprocess`` 旗标。"

#: ../../library/wsgiref.rst:513
msgid ""
"This class is a subclass of :class:`SimpleHandler` intended for use with "
"software other than HTTP \"origin servers\".  If you are writing a gateway "
"protocol implementation (such as CGI, FastCGI, SCGI, etc.) that uses a "
"``Status:`` header to send an HTTP status, you probably want to subclass "
"this instead of :class:`SimpleHandler`."
msgstr ""
"该类是 :class:`SimpleHandler` 的子类，旨在用于 HTTP \"原始服务器\" 以外的软件。 如果你在编写一个网关协议实现（例如 "
"CGI, FastCGI, SCGI 等等），它使用 ``Status:`` 标头来发布 HTTP 状态，你可能会想要子类化该类而不是 "
":class:`SimpleHandler`。"

#: ../../library/wsgiref.rst:522
msgid ""
"Similar to :class:`BaseCGIHandler`, but designed for use with HTTP origin "
"servers.  If you are writing an HTTP server implementation, you will "
"probably want to subclass this instead of :class:`BaseCGIHandler`."
msgstr ""
"类似于 :class:`BaseCGIHandler`，但被设计用于 HTTP 原始服务器。 如果你在编写一个 HTTP "
"服务器实现，你可能会想要子类化该类而不是 :class:`BaseCGIHandler`。"

#: ../../library/wsgiref.rst:526
msgid ""
"This class is a subclass of :class:`BaseHandler`.  It overrides the "
":meth:`!__init__`, :meth:`~BaseHandler.get_stdin`, "
":meth:`~BaseHandler.get_stderr`, :meth:`~BaseHandler.add_cgi_vars`, "
":meth:`~BaseHandler._write`, and :meth:`~BaseHandler._flush` methods to "
"support explicitly setting the environment and streams via the constructor."
"  The supplied environment and streams are stored in the :attr:`stdin`, "
":attr:`stdout`, :attr:`stderr`, and :attr:`environ` attributes."
msgstr ""
"该类是 :class:`BaseHandler` 的子类。 它重载了 :meth:`!__init__`, "
":meth:`~BaseHandler.get_stdin`, :meth:`~BaseHandler.get_stderr`, "
":meth:`~BaseHandler.add_cgi_vars`, :meth:`~BaseHandler._write` 和 "
":meth:`~BaseHandler._flush` 方法以支持通过构造器显式地设置环境和流。 所提供的环境和流存储在 :attr:`stdin`, "
":attr:`stdout`, :attr:`stderr` 和 :attr:`environ` 属性中。"

#: ../../library/wsgiref.rst:535
msgid ""
"The :meth:`~io.BufferedIOBase.write` method of *stdout* should write each "
"chunk in full, like :class:`io.BufferedIOBase`."
msgstr ""
"*stdout* 的 :meth:`~io.BufferedIOBase.write` 方法应该完整写入每个数据块，与 "
":class:`io.BufferedIOBase` 一样。"

#: ../../library/wsgiref.rst:541
msgid ""
"This is an abstract base class for running WSGI applications.  Each instance"
" will handle a single HTTP request, although in principle you could create a"
" subclass that was reusable for multiple requests."
msgstr ""
"这是适用于运行 WSGI 应用程序的抽象基类。 每个实例将处理一个单独的 HTTP 请求，不过在原则上你也可以创建一个可针对多个请求重用的子类。"

#: ../../library/wsgiref.rst:545
msgid ""
":class:`BaseHandler` instances have only one method intended for external "
"use:"
msgstr ":class:`BaseHandler` 实例只有一个方法提供给外部使用:"

#: ../../library/wsgiref.rst:550
msgid "Run the specified WSGI application, *app*."
msgstr "运行指定的 WSGI 应用程序 *app*。"

#: ../../library/wsgiref.rst:552
msgid ""
"All of the other :class:`BaseHandler` methods are invoked by this method in "
"the process of running the application, and thus exist primarily to allow "
"customizing the process."
msgstr "所有的 :class:`BaseHandler` 其他方法都是在运行应用程序过程中由该方法唤起的，因此主要是为了允许定制运行过程。"

#: ../../library/wsgiref.rst:556
msgid "The following methods MUST be overridden in a subclass:"
msgstr "以下方法必须在子类中被重载:"

#: ../../library/wsgiref.rst:561
msgid ""
"Buffer the bytes *data* for transmission to the client.  It's okay if this "
"method actually transmits the data; :class:`BaseHandler` just separates "
"write and flush operations for greater efficiency when the underlying system"
" actually has such a distinction."
msgstr ""
"缓冲字节数据 *data* 以便传输给客户端。 如果此方法真的传输了数据也是可以的；:class:`BaseHandler` "
"只有在底层系统真有这样的区分时才会区分写入和刷新操作以提高效率。"

#: ../../library/wsgiref.rst:569
msgid ""
"Force buffered data to be transmitted to the client.  It's okay if this "
"method is a no-op (i.e., if :meth:`_write` actually sends the data)."
msgstr "强制将缓冲的数据传输给客户端。 如果此方法无任何操作也是可以的（例如，:meth:`_write` 实际上已发送了数据）。"

#: ../../library/wsgiref.rst:575
msgid ""
"Return an object compatible with :class:`~wsgiref.types.InputStream` "
"suitable for use as the ``wsgi.input`` of the request currently being "
"processed."
msgstr ""
"返回一个兼容 :class:`~wsgiref.types.InputStream` 的适合用作当前所处理请求的 ``wsgi.input`` 的对象。"

#: ../../library/wsgiref.rst:582
msgid ""
"Return an object compatible with :class:`~wsgiref.types.ErrorStream` "
"suitable for use as the ``wsgi.errors`` of the request currently being "
"processed."
msgstr ""
"返回一个兼容 :class:`~wsgiref.types.ErrorStream` 的适合用作当前所处理请求的 ``wsgi.errors`` "
"的对象。"

#: ../../library/wsgiref.rst:589
msgid ""
"Insert CGI variables for the current request into the :attr:`environ` "
"attribute."
msgstr "将当前请求的 CGI 变量插入到 :attr:`environ` 属性。"

#: ../../library/wsgiref.rst:591
msgid ""
"Here are some other methods and attributes you may wish to override. This "
"list is only a summary, however, and does not include every method that can "
"be overridden.  You should consult the docstrings and source code for "
"additional information before attempting to create a customized "
":class:`BaseHandler` subclass."
msgstr ""
"以下是一些你可能会想要重载的其他方法。 但这只是个简略的列表，它不包括每个可被重载的方法。 你应当在在尝试创建自定义的 "
":class:`BaseHandler` 子类之前参阅文档字符串和源代码来了解更多信息。"

#: ../../library/wsgiref.rst:597
msgid "Attributes and methods for customizing the WSGI environment:"
msgstr "用于自定义 WSGI 环境的属性和方法:"

#: ../../library/wsgiref.rst:602
msgid ""
"The value to be used for the ``wsgi.multithread`` environment variable.  It "
"defaults to true in :class:`BaseHandler`, but may have a different default "
"(or be set by the constructor) in the other subclasses."
msgstr ""
"用于 ``wsgi.multithread`` 环境变量的值。 它在 :class:`BaseHandler` "
"中默认为真值，但在其他子类中可能有不同的默认值（或是由构造器来设置）。"

#: ../../library/wsgiref.rst:609
msgid ""
"The value to be used for the ``wsgi.multiprocess`` environment variable.  It"
" defaults to true in :class:`BaseHandler`, but may have a different default "
"(or be set by the constructor) in the other subclasses."
msgstr ""
"用于 ``wsgi.multiprocess`` 环境变量的值。 它在 :class:`BaseHandler` "
"中默认为真值，但在其他子类中可能有不同的默认值（或是由构造器来设置）。"

#: ../../library/wsgiref.rst:616
msgid ""
"The value to be used for the ``wsgi.run_once`` environment variable.  It "
"defaults to false in :class:`BaseHandler`, but :class:`CGIHandler` sets it "
"to true by default."
msgstr ""
"用于 ``wsgi.run_once`` 环境变量的值。 它在 :class:`BaseHandler` 中默认为假值，但在 "
":class:`CGIHandler` 中默认为真值。"

#: ../../library/wsgiref.rst:623
msgid ""
"The default environment variables to be included in every request's WSGI "
"environment.  By default, this is a copy of ``os.environ`` at the time that "
":mod:`wsgiref.handlers` was imported, but subclasses can either create their"
" own at the class or instance level.  Note that the dictionary should be "
"considered read-only, since the default value is shared between multiple "
"classes and instances."
msgstr ""
"要包括在每个请求的 WSGI 环境中的默认环境变量。 在默认情况下，这是当 :mod:`wsgiref.handlers` 被导入时的 "
"``os.environ`` 的一个副本，但也可以在类或实例层级上创建它们自己的子类。 "
"请注意该字典应当被当作是只读的，因为默认值会在多个类和实际之间共享。"

#: ../../library/wsgiref.rst:633
msgid ""
"If the :attr:`origin_server` attribute is set, this attribute's value is "
"used to set the default ``SERVER_SOFTWARE`` WSGI environment variable, and "
"also to set a default ``Server:`` header in HTTP responses.  It is ignored "
"for handlers (such as :class:`BaseCGIHandler` and :class:`CGIHandler`) that "
"are not HTTP origin servers."
msgstr ""
"如果设置了 :attr:`origin_server` 属性，该属性的值会被用来设置默认的 ``SERVER_SOFTWARE`` WSGI "
"环境变量，并且还会被用来设置 HTTP 响应中默认的 ``Server:`` 标头。 它会被不是 HTTP 原始服务器的处理器所忽略 (例如 "
":class:`BaseCGIHandler` 和 :class:`CGIHandler`)。"

#: ../../library/wsgiref.rst:639
msgid ""
"The term \"Python\" is replaced with implementation specific term like "
"\"CPython\", \"Jython\" etc."
msgstr "名称 \"Python\" 会被替换为实现专属的名称如 \"CPython\", \"Jython\" 等等。"

#: ../../library/wsgiref.rst:645
msgid ""
"Return the URL scheme being used for the current request.  The default "
"implementation uses the :func:`guess_scheme` function from "
":mod:`wsgiref.util` to guess whether the scheme should be \"http\" or "
"\"https\", based on the current request's :attr:`environ` variables."
msgstr ""
"返回当前请求所使用的 URL 方案。 默认的实现会使用来自 :mod:`wsgiref.util` 的 :func:`guess_scheme` "
"函数根据当前请求的 :attr:`environ` 变量来猜测方案应该是 \"http\" 还是 \"https\"。"

#: ../../library/wsgiref.rst:653
msgid ""
"Set the :attr:`environ` attribute to a fully populated WSGI environment.  "
"The default implementation uses all of the above methods and attributes, "
"plus the :meth:`get_stdin`, :meth:`get_stderr`, and :meth:`add_cgi_vars` "
"methods and the :attr:`wsgi_file_wrapper` attribute.  It also inserts a "
"``SERVER_SOFTWARE`` key if not present, as long as the :attr:`origin_server`"
" attribute is a true value and the :attr:`server_software` attribute is set."
msgstr ""
"将 :attr:`environ` 属性设为填充了完整内容的 WSGI 环境。 默认的实现会使用上述的所有方法和属性，加上 "
":meth:`get_stdin`, :meth:`get_stderr` 和 :meth:`add_cgi_vars` 方法以及 "
":attr:`wsgi_file_wrapper` 属性。 它还会在 ``SERVER_SOFTWARE`` 不存在时插入该键，只要 "
":attr:`origin_server` 属性为真值并且设置了 :attr:`server_software` 属性。"

#: ../../library/wsgiref.rst:660
msgid "Methods and attributes for customizing exception handling:"
msgstr "用于自定义异常处理的方法和属性:"

#: ../../library/wsgiref.rst:665
msgid ""
"Log the *exc_info* tuple in the server log.  *exc_info* is a ``(type, value,"
" traceback)`` tuple.  The default implementation simply writes the traceback"
" to the request's ``wsgi.errors`` stream and flushes it.  Subclasses can "
"override this method to change the format or retarget the output, mail the "
"traceback to an administrator, or whatever other action may be deemed "
"suitable."
msgstr ""
"将 *exc_info* 元素记录到服务器日志。 *exc_info* 是一个 ``(type, value, traceback)`` 元组。 "
"默认的实现会简单地将回溯信息写入请求的 ``wsgi.errors`` 流并刷新它。 "
"子类可以重写此方法来修改格式或重设输出目标，通过邮件将回溯信息发给管理员，或执行任何其他符合要求的动作。"

#: ../../library/wsgiref.rst:674
msgid ""
"The maximum number of frames to include in tracebacks output by the default "
":meth:`log_exception` method.  If ``None``, all frames are included."
msgstr "要包括在默认 :meth:`log_exception` 方法的回溯信息输出中的最大帧数。 如果为 ``None``，则会包括所有的帧。"

#: ../../library/wsgiref.rst:680
msgid ""
"This method is a WSGI application to generate an error page for the user.  "
"It is only invoked if an error occurs before headers are sent to the client."
msgstr "此方法是一个为用户生成错误页面的 WSGI 应用程序。 它仅当将标头发送给客户端之前发生错误时会被唤起。"

#: ../../library/wsgiref.rst:683
msgid ""
"This method can access the current error using ``sys.exception()``, and "
"should pass that information to *start_response* when calling it (as "
"described in the \"Error Handling\" section of :pep:`3333`). In particular, "
"the *start_response* callable should follow the :class:`.StartResponse` "
"protocol."
msgstr ""
"此方法可以使用 ``sys.exception()`` 来访问当前错误信息，并应当在调用它时将该信息传给 *start_response* (如 "
":pep:`3333` 的 \"Error Handling\" 一节所描述的)。 具体而言，*start_response* 可调用对象应当遵循 "
":class:`.StartResponse` 协议"

#: ../../library/wsgiref.rst:689
msgid ""
"The default implementation just uses the :attr:`error_status`, "
":attr:`error_headers`, and :attr:`error_body` attributes to generate an "
"output page.  Subclasses can override this to produce more dynamic error "
"output."
msgstr ""
"默认的实现只是使用 :attr:`error_status`, :attr:`error_headers`, 和 :attr:`error_body` "
"属性来生成一个输出页面。 子类可以重写此方法来产生更动态化的错误输出。"

#: ../../library/wsgiref.rst:693
msgid ""
"Note, however, that it's not recommended from a security perspective to spit"
" out diagnostics to any old user; ideally, you should have to do something "
"special to enable diagnostic output, which is why the default implementation"
" doesn't include any."
msgstr ""
"但是请注意，从安全角度看来是不建议将诊断信息暴露给任何用户的；理想的做法是你应当通过特别处理来启用诊断输出，因此默认的实现并不包括这样的内容。"

#: ../../library/wsgiref.rst:701
msgid ""
"The HTTP status used for error responses.  This should be a status string as"
" defined in :pep:`3333`; it defaults to a 500 code and message."
msgstr "用于错误响应的 HTTP 状态。 这应当是一个在 :pep:`3333` 中定义的字符串；它默认为代码 500 以相应的消息。"

#: ../../library/wsgiref.rst:707
msgid ""
"The HTTP headers used for error responses.  This should be a list of WSGI "
"response headers (``(name, value)`` tuples), as described in :pep:`3333`.  "
"The default list just sets the content type to ``text/plain``."
msgstr ""
"用于错误响应的 HTTP 标头。 这应当是由 WSGI 响应标头 (``(name, value)`` 元组) 构成的列表，如 :pep:`3333` "
"所定义的。 默认的列表只是将内容类型设为 ``text/plain``。"

#: ../../library/wsgiref.rst:714
msgid ""
"The error response body.  This should be an HTTP response body bytestring. "
"It defaults to the plain text, \"A server error occurred.  Please contact "
"the administrator.\""
msgstr ""
"错误响应体。  这应当是一个 HTTP 响应体字节串。 它默认为纯文本 \"A server error occurred.  Please "
"contact the administrator.\""

#: ../../library/wsgiref.rst:718
msgid ""
"Methods and attributes for :pep:`3333`'s \"Optional Platform-Specific File "
"Handling\" feature:"
msgstr "用于 :pep:`3333` 的 \"可选的平台专属文件处理\" 特性的方法和属性:"

#: ../../library/wsgiref.rst:724
msgid ""
"A ``wsgi.file_wrapper`` factory, compatible with "
":class:`wsgiref.types.FileWrapper`, or ``None``.  The default value of this "
"attribute is the :class:`wsgiref.util.FileWrapper` class."
msgstr ""
"一个 ``wsgi.file_wrapper`` 工厂对象，兼容 :class:`wsgiref.types.FileWrapper`，或者为 "
"``None``。 该属性的默认值是 :class:`wsgiref.util.FileWrapper` 类。"

#: ../../library/wsgiref.rst:731
msgid ""
"Override to implement platform-specific file transmission.  This method is "
"called only if the application's return value is an instance of the class "
"specified by the :attr:`wsgi_file_wrapper` attribute.  It should return a "
"true value if it was able to successfully transmit the file, so that the "
"default transmission code will not be executed. The default implementation "
"of this method just returns a false value."
msgstr ""
"重载以实现平台专属的文件传输。 此方法仅在应用程序的返回值是由 :attr:`wsgi_file_wrapper` 属性指定的类的实例时会被调用。 "
"如果它能够成功地传输文件则应当返回真值，以使得默认的传输代码将不会被执行。 此方法的默认实现只会返回假值。"

#: ../../library/wsgiref.rst:738
msgid "Miscellaneous methods and attributes:"
msgstr "杂项方法和属性:"

#: ../../library/wsgiref.rst:743
msgid ""
"This attribute should be set to a true value if the handler's :meth:`_write`"
" and :meth:`_flush` are being used to communicate directly to the client, "
"rather than via a CGI-like gateway protocol that wants the HTTP status in a "
"special ``Status:`` header."
msgstr ""
"该属性在处理器的 :meth:`_write` 和 :meth:`_flush` 被用于同客户端直接通信而不是通过需要 HTTP 状态为某种特殊 "
"``Status:`` 标头的 CGI 类网关协议时应当被设为真值"

#: ../../library/wsgiref.rst:748
msgid ""
"This attribute's default value is true in :class:`BaseHandler`, but false in"
" :class:`BaseCGIHandler` and :class:`CGIHandler`."
msgstr ""
"该属性在 :class:`BaseHandler` 中默认为真值，但在 :class:`BaseCGIHandler` 和 "
":class:`CGIHandler` 中则为假值。"

#: ../../library/wsgiref.rst:754
msgid ""
"If :attr:`origin_server` is true, this string attribute is used to set the "
"HTTP version of the response set to the client.  It defaults to ``\"1.0\"``."
msgstr ""
"如果 :attr:`origin_server` 为真值，则该字符串属性会被用来设置给客户端的响应的 HTTP 版本。 它的默认值为 "
"``\"1.0\"``。"

#: ../../library/wsgiref.rst:760
msgid ""
"Transcode CGI variables from ``os.environ`` to :pep:`3333` \"bytes in "
"unicode\" strings, returning a new dictionary.  This function is used by "
":class:`CGIHandler` and :class:`IISCGIHandler` in place of directly using "
"``os.environ``, which is not necessarily WSGI-compliant on all platforms and"
" web servers using Python 3 -- specifically, ones where the OS's actual "
"environment is Unicode (i.e. Windows), or ones where the environment is "
"bytes, but the system encoding used by Python to decode it is anything other"
" than ISO-8859-1 (e.g. Unix systems using UTF-8)."
msgstr ""
"将来自 ``os.environ`` 的 CGI 变量转码为 :pep:`3333` \"bytes in unicode\" "
"字符串，返回一个新的字典。 此函数被 :class:`CGIHandler` 和 :class:`IISCGIHandler` 用来替代直接使用 "
"``os.environ``，后者不一定在所有使用 Python 3 的平台和 Web 服务器上都符合 WSGI 标准 -- 特别是当 OS "
"的实际环境为 Unicode 时 (例如 Windows)，或者当环境为字节数据，但被 Python 用来解码它的系统编码格式不是 ISO-8859-1"
" 时 (例如使用 UTF-8 的 Unix 系统)。"

#: ../../library/wsgiref.rst:769
msgid ""
"If you are implementing a CGI-based handler of your own, you probably want "
"to use this routine instead of just copying values out of ``os.environ`` "
"directly."
msgstr "如果你要实现自己的基于 CGI 的处理器，你可能会想要使用此例程而不是简单地从 ``os.environ`` 直接拷贝值。"

#: ../../library/wsgiref.rst:777
msgid ":mod:`wsgiref.types` -- WSGI types for static type checking"
msgstr ":mod:`wsgiref.types` -- 用于静态类型检查的 WSGI 类型"

#: ../../library/wsgiref.rst:783
msgid ""
"This module provides various types for static type checking as described in "
":pep:`3333`."
msgstr "本模块提供了多种类型用于在 :pep:`3333` 中所描述的静态类型检查。"

#: ../../library/wsgiref.rst:791
msgid ""
"A :class:`typing.Protocol` describing :pep:`start_response() <3333#the-"
"start-response-callable>` callables (:pep:`3333`)."
msgstr ""
"一个描述 :pep:`start_response() <3333#the-start-response-callable>` 可迭代对象的 "
":class:`typing.Protocol`。 (:pep:`3333`)"

#: ../../library/wsgiref.rst:797
msgid "A type alias describing a WSGI environment dictionary."
msgstr "一个描述 WSGI 环境字典的类型别名。"

#: ../../library/wsgiref.rst:801
msgid "A type alias describing a WSGI application callable."
msgstr "一个描述 WSGI 应用程序可迭代对象的类型别名。"

#: ../../library/wsgiref.rst:805
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Input Stream <3333#input-"
"and-error-streams>`."
msgstr ""
"一个描述 :pep:`WSGI 输入流 <3333#input-and-error-streams>` 的 "
":class:`typing.Protocol`。"

#: ../../library/wsgiref.rst:810
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Error Stream <3333#input-"
"and-error-streams>`."
msgstr ""
"一个描述 :pep:`WSGI 错误流 <3333#input-and-error-streams>` 的 "
":class:`typing.Protocol`。"

#: ../../library/wsgiref.rst:815
msgid ""
"A :class:`typing.Protocol` describing a :pep:`file wrapper <3333#optional-"
"platform-specific-file-handling>`. See :class:`wsgiref.util.FileWrapper` for"
" a concrete implementation of this protocol."
msgstr ""
"一个描述 :pep:`文件包装器 <3333#optional-platform-specific-file-handling>` 的 "
":class:`typing.Protocol`。 请参阅 :class:`wsgiref.util.FileWrapper` "
"查看此协议的一个具体实现。"

#: ../../library/wsgiref.rst:822
msgid "Examples"
msgstr "例子"

#: ../../library/wsgiref.rst:824
msgid ""
"This is a working \"Hello World\" WSGI application, where the "
"*start_response* callable should follow the :class:`.StartResponse` "
"protocol::"
msgstr ""
"下面是一个可运行的 \"Hello World\" WSGI 应用程序，其中 *start_response* 可调用对象应当遵循 "
":class:`.StartResponse` 协议::"

#: ../../library/wsgiref.rst:827
msgid ""
"\"\"\"\n"
"Every WSGI application must have an application object - a callable\n"
"object that accepts two arguments. For that purpose, we're going to\n"
"use a function (note that you're not limited to a function, you can\n"
"use a class for example). The first argument passed to the function\n"
"is a dictionary containing CGI-style environment variables and the\n"
"second variable is the callable object.\n"
"\"\"\"\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"\n"
"def hello_world_app(environ, start_response):\n"
"    status = \"200 OK\"  # HTTP Status\n"
"    headers = [(\"Content-type\", \"text/plain; charset=utf-8\")]  # HTTP Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # The returned object is going to be printed\n"
"    return [b\"Hello World\"]\n"
"\n"
"with make_server(\"\", 8000, hello_world_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"\n"
"    # Serve until process is killed\n"
"    httpd.serve_forever()"
msgstr ""
"\"\"\"\n"
"每个 WSGI 应用程序必须有一个应用程序对象 —— 即一个将接受\n"
"两个参数的可调用对象。 为达成此目的，我们准备使用一个函数\n"
"（请注意并非仅限使用函数，例如你也可以使用一个类）。\n"
"传给该函数的第一个参数是一个包含 CGI 风格的环境变量的字典\n"
"而第二个变量就是上述的可调用对象。\n"
"\"\"\"\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"\n"
"def hello_world_app(environ, start_response):\n"
"    status = \"200 OK\"  # HTTP Status\n"
"    headers = [(\"Content-type\", \"text/plain; charset=utf-8\")]  # HTTP 标头\n"
"    start_response(status, headers)\n"
"\n"
"    # 返回的对象将被打印出来\n"
"    return [b\"Hello World\"]\n"
"\n"
"with make_server(\"\", 8000, hello_world_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"\n"
"    # 运行服务直到进程被杀掉\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:854
msgid ""
"Example of a WSGI application serving the current directory, accept optional"
" directory and port number (default: 8000) on the command line::"
msgstr "一个发布当前目录的 WSGI 应用程序示例，接受通过命令行指定可选的目录和端口号 (默认值: 8000)::"

#: ../../library/wsgiref.rst:857
msgid ""
"\"\"\"\n"
"Small wsgiref based web server. Takes a path to serve from and an\n"
"optional port number (defaults to 8000), then tries to serve files.\n"
"MIME types are guessed from the file names, 404 errors are raised\n"
"if the file is not found.\n"
"\"\"\"\n"
"import mimetypes\n"
"import os\n"
"import sys\n"
"from wsgiref import simple_server, util\n"
"\n"
"\n"
"def app(environ, respond):\n"
"    # Get the file name and MIME type\n"
"    fn = os.path.join(path, environ[\"PATH_INFO\"][1:])\n"
"    if \".\" not in fn.split(os.path.sep)[-1]:\n"
"        fn = os.path.join(fn, \"index.html\")\n"
"    mime_type = mimetypes.guess_file_type(fn)[0]\n"
"\n"
"    # Return 200 OK if file exists, otherwise 404 Not Found\n"
"    if os.path.exists(fn):\n"
"        respond(\"200 OK\", [(\"Content-Type\", mime_type)])\n"
"        return util.FileWrapper(open(fn, \"rb\"))\n"
"    else:\n"
"        respond(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n"
"        return [b\"not found\"]\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Get the path and port from command-line arguments\n"
"    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()\n"
"    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000\n"
"\n"
"    # Make and start the server until control-c\n"
"    httpd = simple_server.make_server(\"\", port, app)\n"
"    print(f\"Serving {path} on port {port}, control-C to stop\")\n"
"    try:\n"
"        httpd.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"Shutting down.\")\n"
"        httpd.server_close()"
msgstr ""
"\"\"\"\n"
"基于 wsgiref 的小型 web 服务器。 接受一个服务路径和\n"
"一个可选的端口号 (默认为 8000)，然后尝试发布文件。 \n"
"MIME 类型将根据文件名来猜测，如果文件未找到则会\n"
"引发 404 错误。\n"
"\"\"\"\n"
"import mimetypes\n"
"import os\n"
"import sys\n"
"from wsgiref import simple_server, util\n"
"\n"
"\n"
"def app(environ, respond):\n"
"    # 获取文件名和 MIME 类型\n"
"    fn = os.path.join(path, environ[\"PATH_INFO\"][1:])\n"
"    if \".\" not in fn.split(os.path.sep)[-1]:\n"
"        fn = os.path.join(fn, \"index.html\")\n"
"    mime_type = mimetypes.guess_file_type(fn)[0]\n"
"\n"
"    # 如果文件存在则返回 200 OK，否则返回 404 Not Found\n"
"    if os.path.exists(fn):\n"
"        respond(\"200 OK\", [(\"Content-Type\", mime_type)])\n"
"        return util.FileWrapper(open(fn, \"rb\"))\n"
"    else:\n"
"        respond(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n"
"        return [b\"not found\"]\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # 从命令行参数获取路径和端口\n"
"    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()\n"
"    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000\n"
"\n"
"    # 创建并启动服务直至被 control-c 中断\n"
"    httpd = simple_server.make_server(\"\", port, app)\n"
"    print(f\"Serving {path} on port {port}, control-C to stop\")\n"
"    try:\n"
"        httpd.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"Shutting down.\")\n"
"        httpd.server_close()"
