# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# Fei Yin <icebirds@163.com>, 2018
# ww song <sww4718168@gmail.com>, 2018
# Kade For, 2019
# dogn he <hedogn@163.com>, 2019
# Kelly Hwong <dianhuangkan@gmail.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# Arisaka97 <solitaire2312@gmail.com>, 2020
# WH-2099 <wh2099@outlook.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-07 05:06+0000\n"
"PO-Revision-Date: 2017-02-16 23:27+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- SQLite 数据库 DB-API 2.0 接口模块"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**源代码：** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:13
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../library/sqlite3.rst:20
msgid ""
"The sqlite3 module was written by Gerhard Häring.  It provides a SQL "
"interface compliant with the DB-API 2.0 specification described by "
":pep:`249`."
msgstr ""
"sqlite3 模块由  Gerhard Häring 编写。它提供了符合 DB-API 2.0 规范的接口，这个规范是 :pep:`249`。"

#: ../../library/sqlite3.rst:23
msgid ""
"To use the module, you must first create a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the "
":file:`example.db` file::"
msgstr ""
"要使用这个模块，必须先创建一个  :class:`Connection` 对象，它代表数据库。下面例子中，数据将存储在 "
":file:`example.db` 文件中："

#: ../../library/sqlite3.rst:30
msgid ""
"You can also supply the special name ``:memory:`` to create a database in "
"RAM."
msgstr "你也可以使用 ``:memory:`` 来创建一个内存中的数据库"

#: ../../library/sqlite3.rst:32
msgid ""
"Once you have a :class:`Connection`, you can create a :class:`Cursor`  "
"object and call its :meth:`~Cursor.execute` method to perform SQL commands::"
msgstr ""
"当有了 :class:`Connection` 对象后，你可以创建一个 :class:`Cursor` 游标对象，然后调用它的 "
":meth:`~Cursor.execute` 方法来执行 SQL 语句："

#: ../../library/sqlite3.rst:51
msgid ""
"The data you've saved is persistent and is available in subsequent "
"sessions::"
msgstr "这些数据被持久化保存了，而且可以在之后的会话中使用它们："

#: ../../library/sqlite3.rst:57
msgid ""
"Usually your SQL operations will need to use values from Python variables.  "
"You shouldn't assemble your query using Python's string operations because "
"doing so is insecure; it makes your program vulnerable to an SQL injection "
"attack (see https://xkcd.com/327/ for humorous example of what can go "
"wrong)."
msgstr ""
"通常你的 SQL 操作需要使用一些 Python 变量的值。你不应该使用 Python "
"的字符串操作来创建你的查询语句，因为那样做不安全；它会使你的程序容易受到 SQL 注入攻击（在 https://xkcd.com/327/ "
"上有一个搞笑的例子，看看有什么后果）"

#: ../../library/sqlite3.rst:62
msgid ""
"Instead, use the DB-API's parameter substitution.  Put ``?`` as a "
"placeholder wherever you want to use a value, and then provide a tuple of "
"values as the second argument to the cursor's :meth:`~Cursor.execute` "
"method.  (Other database modules may use a different placeholder, such as "
"``%s`` or ``:1``.) For example::"
msgstr ""
"推荐另外一种方法：使用 DB-API 的参数替换。在你的 SQL 语句中，使用 ``?`` 占位符来代替值，然后把对应的值组成的元组做为 "
":meth:`~Cursor.execute` 方法的第二个参数。（其他数据库可能会使用不同的占位符，比如 ``%s`` 或者 ``:1``）例如："

#: ../../library/sqlite3.rst:84
msgid ""
"To retrieve data after executing a SELECT statement, you can either treat "
"the cursor as an :term:`iterator`, call the cursor's "
":meth:`~Cursor.fetchone` method to retrieve a single matching row, or call "
":meth:`~Cursor.fetchall` to get a list of the matching rows."
msgstr ""
"要在执行 SELECT 语句后获取数据，你可以把游标作为 :term:`iterator`，然后调用它的 "
":meth:`~Cursor.fetchone` 方法来获取一条匹配的行，也可以调用 :meth:`~Cursor.fetchall` "
"来得到包含多个匹配行的列表。"

#: ../../library/sqlite3.rst:89
msgid "This example uses the iterator form::"
msgstr "下面是一个使用迭代器形式的例子："

#: ../../library/sqlite3.rst:104
msgid "https://github.com/ghaering/pysqlite"
msgstr "https://github.com/ghaering/pysqlite"

#: ../../library/sqlite3.rst:103
msgid ""
"The pysqlite web page -- sqlite3 is developed externally under the name "
"\"pysqlite\"."
msgstr "pysqlite的主页 -- sqlite3 在外部使用 “pysqlite” 名字进行开发。"

#: ../../library/sqlite3.rst:108
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:107
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../library/sqlite3.rst:111
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:111
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "学习 SQL 语法的教程、参考和例子。"

#: ../../library/sqlite3.rst:113
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../library/sqlite3.rst:114
msgid "PEP written by Marc-André Lemburg."
msgstr "Marc-André Lemburg 写的 PEP。"

#: ../../library/sqlite3.rst:120
msgid "Module functions and constants"
msgstr "模块函数和常量"

#: ../../library/sqlite3.rst:125
msgid ""
"The version number of this module, as a string. This is not the version of "
"the SQLite library."
msgstr "这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。"

#: ../../library/sqlite3.rst:131
msgid ""
"The version number of this module, as a tuple of integers. This is not the "
"version of the SQLite library."
msgstr "这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。"

#: ../../library/sqlite3.rst:137
msgid "The version number of the run-time SQLite library, as a string."
msgstr "使用中的 SQLite 库的版本号，是一个字符串。"

#: ../../library/sqlite3.rst:142
msgid ""
"The version number of the run-time SQLite library, as a tuple of integers."
msgstr "使用中的 SQLite 库的版本号，是一个整数组成的元组。"

#: ../../library/sqlite3.rst:147 ../../library/sqlite3.rst:160
msgid ""
"This constant is meant to be used with the *detect_types* parameter of the "
":func:`connect` function."
msgstr "这个常量可以作为 :func:`connect` 函数的 *detect_types* 参数。"

#: ../../library/sqlite3.rst:150
msgid ""
"Setting it makes the :mod:`sqlite3` module parse the declared type for each "
"column it returns.  It will parse out the first word of the declared type, "
"i. e.  for \"integer primary key\", it will parse out \"integer\", or for "
"\"number(10)\" it will parse out \"number\". Then for that column, it will "
"look into the converters dictionary and use the converter function "
"registered for that type there."
msgstr ""
"设置这个参数后，:mod:`sqlite3` 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary "
"key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。"

#: ../../library/sqlite3.rst:163
msgid ""
"Setting this makes the SQLite interface parse the column name for each "
"column it returns.  It will look for a string formed [mytype] in there, and "
"then decide that 'mytype' is the type of the column. It will try to find an "
"entry of 'mytype' in the converters dictionary and then use the converter "
"function found there to return the value. The column name found in "
":attr:`Cursor.description` does not include the type, i. e. if you use "
"something like ``'as \"Expiration date [datetime]\"'`` in your SQL, then we "
"will parse out everything until the first ``'['`` for the column name and "
"strip the preceeding space: the column name would simply be \"Expiration "
"date\"."
msgstr ""
"设置此参数可使得 SQLite 接口解析它所返回的每一列的列名。 它将在其中查找形式为 [mytype] 的字符串，然后将 'mytype' "
"确定为列的类型。 它将尝试在转换器字典中查找 'mytype' 条目，然后用找到的转换器函数来返回值。 在 "
":attr:`Cursor.description` 中找到的列名并不包括类型，举例来说，如果你在你的 SQL 中使用了像 ``'as "
"\"Expiration date [datetime]\"'`` 这样的写法，那么我们将解析出在第一个 ``'['`` "
"之前的所有内容并去除前导空格作为列名：即列名将为 \"Expiration date\"。"

#: ../../library/sqlite3.rst:176
msgid ""
"Opens a connection to the SQLite database file *database*. By default "
"returns a :class:`Connection` object, unless a custom *factory* is given."
msgstr ""
"连接 SQLite 数据库 *database*。默认返回 :class:`Connection` 对象，除非使用了自定义的 *factory* 参数。"

#: ../../library/sqlite3.rst:179
msgid ""
"*database* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current  working directory) of the database file to be "
"opened. You can use ``\":memory:\"`` to open a database connection to a "
"database that resides in RAM instead of on disk."
msgstr ""
"*database* 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 :term:`path-like "
"object`。你也可以用 ``\":memory:\"`` 在内存中打开一个数据库。"

#: ../../library/sqlite3.rst:184
msgid ""
"When a database is accessed by multiple connections, and one of the "
"processes modifies the database, the SQLite database is locked until that "
"transaction is committed. The *timeout* parameter specifies how long the "
"connection should wait for the lock to go away until raising an exception. "
"The default for the timeout parameter is 5.0 (five seconds)."
msgstr ""
"当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。*timeout* "
"参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。"

#: ../../library/sqlite3.rst:190
msgid ""
"For the *isolation_level* parameter, please see the "
":attr:`~Connection.isolation_level` property of :class:`Connection` objects."
msgstr ""
"*isolation_level* 参数，请查看 :class:`Connection` 对象的 "
":attr:`~Connection.isolation_level` 属性。"

#: ../../library/sqlite3.rst:193
msgid ""
"SQLite natively supports only the types TEXT, INTEGER, REAL, BLOB and NULL. "
"If you want to use other types you must add support for them yourself. The "
"*detect_types* parameter and the using custom **converters** registered with"
" the module-level :func:`register_converter` function allow you to easily do"
" that."
msgstr ""
"SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 "
"*detect_types* 参数和模块级别的 :func:`register_converter` 函数注册**转换器** 可以简单的实现。"

#: ../../library/sqlite3.rst:198
msgid ""
"*detect_types* defaults to 0 (i. e. off, no type detection), you can set it "
"to any combination of :const:`PARSE_DECLTYPES` and :const:`PARSE_COLNAMES` "
"to turn type detection on. Due to SQLite behaviour, types can't be detected "
"for generated fields (for example ``max(data)``), even when *detect_types* "
"parameter is set. In such case, the returned type is :class:`str`."
msgstr ""
"*detect_types* 默认为 0 (即关闭，不进行类型检测)，你可以将其设为任意的 :const:`PARSE_DECLTYPES` 和 "
":const:`PARSE_COLNAMES` 组合来启用类型检测。 由于 SQLite 的行为，生成的字段类型 (例如 ``max(data)``) "
"不能被检测，即使在设置了 *detect_types* 形参时也是如此。 在此情况下，返回的类型为 :class:`str`。"

#: ../../library/sqlite3.rst:204
msgid ""
"By default, *check_same_thread* is :const:`True` and only the creating "
"thread may use the connection. If set :const:`False`, the returned "
"connection may be shared across multiple threads. When using multiple "
"threads with the same connection writing operations should be serialized by "
"the user to avoid data corruption."
msgstr ""
"默认情况下，*check_same_thread* 为 :const:`True`，只有当前的线程可以使用该连接。 如果设置为 "
":const:`False`，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。"

#: ../../library/sqlite3.rst:209
msgid ""
"By default, the :mod:`sqlite3` module uses its :class:`Connection` class for"
" the connect call.  You can, however, subclass the :class:`Connection` class"
" and make :func:`connect` use your class instead by providing your class for"
" the *factory* parameter."
msgstr ""
"默认情况下，当调用 connect 方法的时候，:mod:`sqlite3` 模块使用了它的 :class:`Connection` "
"类。当然，你也可以创建 :class:`Connection` 类的子类，然后创建提供了 *factory* 参数的 :func:`connect` "
"方法。"

#: ../../library/sqlite3.rst:214
msgid "Consult the section :ref:`sqlite3-types` of this manual for details."
msgstr "详情请查阅当前手册的 :ref:`sqlite3-types` 部分。"

#: ../../library/sqlite3.rst:216
msgid ""
"The :mod:`sqlite3` module internally uses a statement cache to avoid SQL "
"parsing overhead. If you want to explicitly set the number of statements "
"that are cached for the connection, you can set the *cached_statements* "
"parameter. The currently implemented default is to cache 100 statements."
msgstr ""
":mod:`sqlite3` 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 "
"*cached_statements* 参数。 当前实现的默认值是缓存100条语句。"

#: ../../library/sqlite3.rst:221
msgid ""
"If *uri* is true, *database* is interpreted as a URI. This allows you to "
"specify options. For example, to open a database in read-only mode you can "
"use::"
msgstr "如果 *uri* 为真，则 *database* 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库："

#: ../../library/sqlite3.rst:227
msgid ""
"More information about this feature, including a list of recognized options,"
" can be found in the `SQLite URI documentation "
"<https://www.sqlite.org/uri.html>`_."
msgstr ""
"有关此功能的更多信息，包括已知选项的列表，可以在 ` SQLite URI 文档 <https://www.sqlite.org/uri.html>`_"
" 中找到。"

#: ../../library/sqlite3.rst:231
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument"
" ``database``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``sqlite3.connect``，附带参数 ``database``。"

#: ../../library/sqlite3.rst:232
msgid "Added the *uri* parameter."
msgstr "增加了 *uri* 参数。"

#: ../../library/sqlite3.rst:235
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database* 现在可以是一个 :term:`path-like object` 对象了，不仅仅是字符串。"

#: ../../library/sqlite3.rst:241
msgid ""
"Registers a callable to convert a bytestring from the database into a custom"
" Python type. The callable will be invoked for all database values that are "
"of the type *typename*. Confer the parameter *detect_types* of the "
":func:`connect` function for how the type detection works. Note that "
"*typename* and the name of the type in your query are matched in case-"
"insensitive manner."
msgstr ""
"注册一个回调对象 *callable*, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 *typename* "
"的数据库的值在转换时，都会调用这个回调对象。通过指定 :func:`connect` 函数的 *detect-types* "
"参数来设置类型检测的方式。注意，*typename* 与查询语句中的类型名进行匹配时不区分大小写。"

#: ../../library/sqlite3.rst:250
msgid ""
"Registers a callable to convert the custom Python type *type* into one of "
"SQLite's supported types. The callable *callable* accepts as single "
"parameter the Python value, and must return a value of the following types: "
"int, float, str or bytes."
msgstr ""
"注册一个回调对象 *callable*，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 *callable* 仅接受一个"
" Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。"

#: ../../library/sqlite3.rst:258
msgid ""
"Returns :const:`True` if the string *sql* contains one or more complete SQL "
"statements terminated by semicolons. It does not verify that the SQL is "
"syntactically correct, only that there are no unclosed string literals and "
"the statement is terminated by a semicolon."
msgstr ""
"如果字符串 *sql* 包含一个或多个完整的 SQL 语句（以分号结束）则返回 :const:`True`。它不会验证 SQL "
"语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。"

#: ../../library/sqlite3.rst:263
msgid ""
"This can be used to build a shell for SQLite, as in the following example:"
msgstr "它可以用来构建一个 SQLite shell，下面是一个例子："

#: ../../library/sqlite3.rst:271
msgid ""
"By default you will not get any tracebacks in user-defined functions, "
"aggregates, converters, authorizer callbacks etc. If you want to debug them,"
" you can call this function with *flag* set to ``True``. Afterwards, you "
"will get tracebacks from callbacks on ``sys.stderr``. Use :const:`False` to "
"disable the feature again."
msgstr ""
"默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 *flag* 参数为 ``True`` "
"并调用此函数。 之后，回调中的回溯信息将会输出到 ``sys.stderr``。 再次使用 :const:`False` 来禁用该功能。"

#: ../../library/sqlite3.rst:281
msgid "Connection Objects"
msgstr "连接对象（Connection）"

#: ../../library/sqlite3.rst:285
msgid "A SQLite database connection has the following attributes and methods:"
msgstr "SQLite 数据库连接对象有如下的属性和方法："

#: ../../library/sqlite3.rst:289
msgid ""
"Get or set the current default isolation level. :const:`None` for autocommit"
" mode or one of \"DEFERRED\", \"IMMEDIATE\" or \"EXCLUSIVE\". See section "
":ref:`sqlite3-controlling-transactions` for a more detailed explanation."
msgstr ""
"获取或设置当前默认的隔离级别。 表示自动提交模式的 :const:`None` 以及 \"DEFERRED\", \"IMMEDIATE\" 或 "
"\"EXCLUSIVE\" 其中之一。 详细描述请参阅 :ref:`sqlite3-controlling-transactions`。"

#: ../../library/sqlite3.rst:295
msgid ""
":const:`True` if a transaction is active (there are uncommitted changes), "
":const:`False` otherwise.  Read-only attribute."
msgstr "如果是在活动事务中（还没有提交改变），返回 :const:`True`，否则，返回 :const:`False`。它是一个只读属性。"

#: ../../library/sqlite3.rst:302
msgid ""
"The cursor method accepts a single optional parameter *factory*. If "
"supplied, this must be a callable returning an instance of :class:`Cursor` "
"or its subclasses."
msgstr ""
"这个方法接受一个可选参数 *factory*，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 :class:`Cursor` "
"类的一个实例或者子类。"

#: ../../library/sqlite3.rst:308
msgid ""
"This method commits the current transaction. If you don't call this method, "
"anything you did since the last call to ``commit()`` is not visible from "
"other database connections. If you wonder why you don't see the data you've "
"written to the database, please check you didn't forget to call this method."
msgstr ""
"这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 ``commit()`` "
"以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。"

#: ../../library/sqlite3.rst:315
msgid ""
"This method rolls back any changes to the database since the last call to "
":meth:`commit`."
msgstr "这个方法回滚从上一次调用 :meth:`commit` 以来所有数据库的改变。"

#: ../../library/sqlite3.rst:320
msgid ""
"This closes the database connection. Note that this does not automatically "
"call :meth:`commit`. If you just close your database connection without "
"calling :meth:`commit` first, your changes will be lost!"
msgstr ""
"关闭数据库连接。注意，它不会自动调用 :meth:`commit` 方法。如果在关闭数据库连接之前没有调用 "
":meth:`commit`，那么你的修改将会丢失！"

#: ../../library/sqlite3.rst:326
msgid ""
"This is a nonstandard shortcut that creates a cursor object by calling the "
":meth:`~Connection.cursor` method, calls the cursor's "
":meth:`~Cursor.execute` method with the *parameters* given, and returns the "
"cursor."
msgstr ""
"这是一个非标准的快捷方法，它会调用 :meth:`~Connection.cursor` 方法来创建一个游标对象，并使用给定的 *parameters*"
" 参数来调用游标对象的 :meth:`~Cursor.execute` 方法，最后返回这个游标对象。"

#: ../../library/sqlite3.rst:333
msgid ""
"This is a nonstandard shortcut that creates a cursor object by calling the "
":meth:`~Connection.cursor` method, calls the cursor's "
":meth:`~Cursor.executemany` method with the *parameters* given, and returns "
"the cursor."
msgstr ""
"这是一个非标准的快捷方法，它会调用 :meth:`~Connection.cursor` 方法来创建一个游标对象，并使用给定的 *parameters*"
" 参数来调用游标对象的 :meth:`~Cursor.executemany` 方法，最后返回这个游标对象。"

#: ../../library/sqlite3.rst:340
msgid ""
"This is a nonstandard shortcut that creates a cursor object by calling the "
":meth:`~Connection.cursor` method, calls the cursor's "
":meth:`~Cursor.executescript` method with the given *sql_script*, and "
"returns the cursor."
msgstr ""
"这是一个非标准的快捷方法，它会调用 :meth:`~Connection.cursor` 方法来创建一个游标对象，并使用给定的 *sql_script*"
" 参数来调用游标对象的 :meth:`~Cursor.executescript` 方法，最后返回这个游标对象。"

#: ../../library/sqlite3.rst:347
msgid ""
"Creates a user-defined function that you can later use from within SQL "
"statements under the function name *name*. *num_params* is the number of "
"parameters the function accepts (if *num_params* is -1, the function may "
"take any number of arguments), and *func* is a Python callable that is "
"called as the SQL function. If *deterministic* is true, the created function"
" is marked as `deterministic <https://sqlite.org/deterministic.html>`_, "
"which allows SQLite to perform additional optimizations. This flag is "
"supported by SQLite 3.8.3 or higher, :exc:`NotSupportedError` will be raised"
" if used with older versions."
msgstr ""
"创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 *name*。 *num_params* 为该函数所接受的形参个数（如果 "
"*num_params* 为 -1，则该函数可接受任意数量的参数）， *func* 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 "
"如果 *deterministic* 为真值，则所创建的函数将被标记为 `deterministic "
"<https://sqlite.org/deterministic.html>`_，这允许 SQLite 执行额外的优化。 此旗标在 SQLite "
"3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 :exc:`NotSupportedError`。"

#: ../../library/sqlite3.rst:357
msgid ""
"The function can return any of the types supported by SQLite: bytes, str, "
"int, float and ``None``."
msgstr "此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 ``None``。"

#: ../../library/sqlite3.rst:360
msgid "The *deterministic* parameter was added."
msgstr "增加了 *deterministic* 形参。"

#: ../../library/sqlite3.rst:363 ../../library/sqlite3.rst:380
#: ../../library/sqlite3.rst:494 ../../library/sqlite3.rst:651
msgid "Example:"
msgstr "示例:"

#: ../../library/sqlite3.rst:370
msgid "Creates a user-defined aggregate function."
msgstr "创建一个自定义的聚合函数。"

#: ../../library/sqlite3.rst:372
msgid ""
"The aggregate class must implement a ``step`` method, which accepts the "
"number of parameters *num_params* (if *num_params* is -1, the function may "
"take any number of arguments), and a ``finalize`` method which will return "
"the final result of the aggregate."
msgstr ""
"参数中 *aggregate_class* 类必须实现两个方法：``step`` 和 ``finalize``。``step`` 方法接受 "
"*num_params* 个参数（如果 *num_params* 为 -1，那么这个函数可以接受任意数量的参数）；``finalize`` "
"方法返回最终的聚合结果。"

#: ../../library/sqlite3.rst:377
msgid ""
"The ``finalize`` method can return any of the types supported by SQLite: "
"bytes, str, int, float and ``None``."
msgstr "``finalize`` 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 ``None``。"

#: ../../library/sqlite3.rst:387
msgid ""
"Creates a collation with the specified *name* and *callable*. The callable "
"will be passed two string arguments. It should return -1 if the first is "
"ordered lower than the second, 0 if they are ordered equal and 1 if the "
"first is ordered higher than the second.  Note that this controls sorting "
"(ORDER BY in SQL) so your comparisons don't affect other SQL operations."
msgstr ""
"使用 *name* 和 *callable* 创建排序规则。这个 *callable* 接受两个字符串对象，如果第一个小于第二个则返回 -1， "
"如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。"

#: ../../library/sqlite3.rst:393
msgid ""
"Note that the callable will get its parameters as Python bytestrings, which "
"will normally be encoded in UTF-8."
msgstr "注意，这个 *callable* 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。"

#: ../../library/sqlite3.rst:396
msgid ""
"The following example shows a custom collation that sorts \"the wrong way\":"
msgstr "以下示例显示了使用“错误方式”进行排序的自定义排序规则："

#: ../../library/sqlite3.rst:400
msgid ""
"To remove a collation, call ``create_collation`` with ``None`` as callable::"
msgstr "要移除一个排序规则，需要调用 ``create_collation`` 并设置 callable 参数为 ``None``。"

#: ../../library/sqlite3.rst:407
msgid ""
"You can call this method from a different thread to abort any queries that "
"might be executing on the connection. The query will then abort and the "
"caller will get an exception."
msgstr ""
"可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。"

#: ../../library/sqlite3.rst:414
msgid ""
"This routine registers a callback. The callback is invoked for each attempt "
"to access a column of a table in the database. The callback should return "
":const:`SQLITE_OK` if access is allowed, :const:`SQLITE_DENY` if the entire "
"SQL statement should be aborted with an error and :const:`SQLITE_IGNORE` if "
"the column should be treated as a NULL value. These constants are available "
"in the :mod:`sqlite3` module."
msgstr ""
"此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 "
":const:`SQLITE_OK`，如果要终止整个 SQL 语句，则返回 :const:`SQLITE_DENY`，如果这一列需要当做 NULL "
"值处理，则返回 :const:`SQLITE_IGNORE`。这些常量可以在  :mod:`sqlite3` 模块中找到。"

#: ../../library/sqlite3.rst:421
msgid ""
"The first argument to the callback signifies what kind of operation is to be"
" authorized. The second and third argument will be arguments or "
":const:`None` depending on the first argument. The 4th argument is the name "
"of the database (\"main\", \"temp\", etc.) if applicable. The 5th argument "
"is the name of the inner-most trigger or view that is responsible for the "
"access attempt or :const:`None` if this access attempt is directly from "
"input SQL code."
msgstr ""
"回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 :const:`None`，具体取决于第一个参数的值。 第 4 "
"个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 "
"个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 :const:`None`。"

#: ../../library/sqlite3.rst:428
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on"
" the first one. All necessary constants are available in the :mod:`sqlite3` "
"module."
msgstr ""
"请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 所有必需的常量都可以在 "
":mod:`sqlite3` 模块中找到。"

#: ../../library/sqlite3.rst:435
msgid ""
"This routine registers a callback. The callback is invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update"
" a GUI."
msgstr ""
"此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。"

#: ../../library/sqlite3.rst:440
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with :const:`None` for *handler*."
msgstr "如果要清除以前安装的任何进度处理程序，调用该方法时请将 *handler* 参数设置为 :const:`None`。"

#: ../../library/sqlite3.rst:443
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr "从处理函数返回非零值将终止当前正在执行的查询并导致它引发 :exc:`OperationalError` 异常。"

#: ../../library/sqlite3.rst:450
msgid ""
"Registers *trace_callback* to be called for each SQL statement that is "
"actually executed by the SQLite backend."
msgstr "为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 *trace_callback*。"

#: ../../library/sqlite3.rst:453
msgid ""
"The only argument passed to the callback is the statement (as string) that "
"is being executed. The return value of the callback is ignored. Note that "
"the backend does not only run statements passed to the "
":meth:`Cursor.execute` methods.  Other sources include the transaction "
"management of the Python module and the execution of triggers defined in the"
" current database."
msgstr ""
"传递给回调的唯一参数是正在执行的语句（作为字符串）。 回调的返回值将被忽略。 请注意，后端不仅运行传递给 :meth:`Cursor.execute` "
"方法的语句。 其他来源包括 Python 模块的事务管理和当前数据库中定义的触发器的执行。"

#: ../../library/sqlite3.rst:459
msgid ""
"Passing :const:`None` as *trace_callback* will disable the trace callback."
msgstr "将传入的 *trace_callback* 设为 :const:`None` 将禁用跟踪回调。"

#: ../../library/sqlite3.rst:466
msgid ""
"This routine allows/disallows the SQLite engine to load SQLite extensions "
"from shared libraries.  SQLite extensions can define new functions, "
"aggregates or whole new virtual table implementations.  One well-known "
"extension is the fulltext-search extension distributed with SQLite."
msgstr ""
"此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 "
"一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。"

#: ../../library/sqlite3.rst:471 ../../library/sqlite3.rst:483
msgid "Loadable extensions are disabled by default. See [#f1]_."
msgstr "默认情况下禁用可加载扩展。 见 [#f1]_."

#: ../../library/sqlite3.rst:479
msgid ""
"This routine loads a SQLite extension from a shared library.  You have to "
"enable extension loading with :meth:`enable_load_extension` before you can "
"use this routine."
msgstr ""
"此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 :meth:`enable_load_extension` 启用扩展加载。"

#: ../../library/sqlite3.rst:489
msgid ""
"You can change this attribute to a callable that accepts the cursor and the "
"original row as a tuple and will return the real result row.  This way, you "
"can implement more advanced ways of returning results, such  as returning an"
" object that can also access columns by name."
msgstr ""
"您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 "
"这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。"

#: ../../library/sqlite3.rst:498
msgid ""
"If returning a tuple doesn't suffice and you want name-based access to "
"columns, you should consider setting :attr:`row_factory` to the highly-"
"optimized :class:`sqlite3.Row` type. :class:`Row` provides both index-based "
"and case-insensitive name-based access to columns with almost no memory "
"overhead. It will probably be better than your own custom dictionary-based "
"approach or even a db_row based solution."
msgstr ""
"如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 :attr:`row_factory` 设置为高度优化的 "
":class:`sqlite3.Row` 类型。 :class:`Row` 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 "
"它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。"

#: ../../library/sqlite3.rst:510
msgid ""
"Using this attribute you can control what objects are returned for the "
"``TEXT`` data type. By default, this attribute is set to :class:`str` and "
"the :mod:`sqlite3` module will return Unicode objects for ``TEXT``. If you "
"want to return bytestrings instead, you can set it to :class:`bytes`."
msgstr ""
"使用此属性可以控制为 ``TEXT`` 数据类型返回的对象。 默认情况下，此属性设置为 :class:`str` 和 :mod:`sqlite3` "
"模块将返回 ``TEXT`` 的 Unicode 对象。 如果要返回字节串，可以将其设置为 :class:`bytes`。"

#: ../../library/sqlite3.rst:515
msgid ""
"You can also set it to any other callable that accepts a single bytestring "
"parameter and returns the resulting object."
msgstr "您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。"

#: ../../library/sqlite3.rst:518
msgid "See the following example code for illustration:"
msgstr "请参阅以下示例代码以进行说明："

#: ../../library/sqlite3.rst:525
msgid ""
"Returns the total number of database rows that have been modified, inserted,"
" or deleted since the database connection was opened."
msgstr "返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。"

#: ../../library/sqlite3.rst:531
msgid ""
"Returns an iterator to dump the database in an SQL text format.  Useful when"
" saving an in-memory database for later restoration.  This function provides"
" the same capabilities as the :kbd:`.dump` command in the :program:`sqlite3`"
" shell."
msgstr ""
"返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 :program:`sqlite3` shell 中的 "
":kbd:`.dump` 命令相同的功能。"

#: ../../library/sqlite3.rst:536
msgid "Example::"
msgstr "示例::"

#: ../../library/sqlite3.rst:550
msgid ""
"This method makes a backup of a SQLite database even while it's being "
"accessed by other clients, or concurrently by the same connection.  The copy"
" will be written into the mandatory argument *target*, that must be another "
":class:`Connection` instance."
msgstr ""
"即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 "
"*target*，该参数必须是另一个 :class:`Connection` 实例。"

#: ../../library/sqlite3.rst:555
msgid ""
"By default, or when *pages* is either ``0`` or a negative integer, the "
"entire database is copied in a single step; otherwise the method performs a "
"loop copying up to *pages* pages at a time."
msgstr ""
"默认情况下，或者当 *pages* 为 ``0`` 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 *pages* 规定数量的页面。"

#: ../../library/sqlite3.rst:559
msgid ""
"If *progress* is specified, it must either be ``None`` or a callable object "
"that will be executed at each iteration with three integer arguments, "
"respectively the *status* of the last iteration, the *remaining* number of "
"pages still to be copied and the *total* number of pages."
msgstr ""
"如果指定了 *progress*，则它必须为 ``None`` 或一个将在每次迭代时附带三个整数参数执行的可调用对象，这三个参数分别是前一次迭代的状态 "
"*status*，将要拷贝的剩余页数 *remaining* 以及总页数 *total*。"

#: ../../library/sqlite3.rst:564
msgid ""
"The *name* argument specifies the database name that will be copied: it must"
" be a string containing either ``\"main\"``, the default, to indicate the "
"main database, ``\"temp\"`` to indicate the temporary database or the name "
"specified after the ``AS`` keyword in an ``ATTACH DATABASE`` statement for "
"an attached database."
msgstr ""
"*name* 参数指定将被拷贝的数据库名称：它必须是一个字符串，其内容为表示主数据库的默认值 ``\"main\"``，表示临时数据库的 "
"``\"temp\"`` 或是在 ``ATTACH DATABASE`` 语句的 ``AS`` 关键字之后指定表示附加数据库的名称。"

#: ../../library/sqlite3.rst:570
msgid ""
"The *sleep* argument specifies the number of seconds to sleep by between "
"successive attempts to backup remaining pages, can be specified either as an"
" integer or a floating point value."
msgstr "*sleep* 参数指定在备份剩余页的连续尝试之间要休眠的秒数，可以指定为一个整数或一个浮点数值。"

#: ../../library/sqlite3.rst:574
msgid "Example 1, copy an existing database into another::"
msgstr "示例一，将现有数据库复制到另一个数据库中："

#: ../../library/sqlite3.rst:588
msgid "Example 2, copy an existing database into a transient copy::"
msgstr "示例二，将现有数据库复制到临时副本中："

#: ../../library/sqlite3.rst:596
msgid "Availability: SQLite 3.6.11 or higher"
msgstr "可用性：SQLite 3.6.11 或以上版本"

#: ../../library/sqlite3.rst:604
msgid "Cursor Objects"
msgstr "Cursor 对象"

#: ../../library/sqlite3.rst:608
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 游标实例具有以下属性和方法。"

#: ../../library/sqlite3.rst:615
msgid ""
"Executes an SQL statement. The SQL statement may be parameterized (i. e. "
"placeholders instead of SQL literals). The :mod:`sqlite3` module supports "
"two kinds of placeholders: question marks (qmark style) and named "
"placeholders (named style)."
msgstr ""
"执行SQL语句。 可以是参数化 SQL 语句（即，在 SQL 语句中使用占位符）。:mod:`sqlite3` "
"模块支持两种占位符：问号（qmark风格）和命名占位符（命名风格）。"

#: ../../library/sqlite3.rst:620
msgid "Here's an example of both styles:"
msgstr "以下是两种风格的示例："

#: ../../library/sqlite3.rst:624
msgid ""
":meth:`execute` will only execute a single SQL statement. If you try to "
"execute more than one statement with it, it will raise a :exc:`.Warning`. "
"Use :meth:`executescript` if you want to execute multiple SQL statements "
"with one call."
msgstr ""
":meth:`execute` 将只执行一条单独的 SQL 语句。 如果你尝试用它执行超过一条语句，将会引发 :exc:`.Warning`。 "
"如果你想要用一次调用执行多条 SQL 语句请使用 :meth:`executescript`。"

#: ../../library/sqlite3.rst:632
msgid ""
"Executes an SQL command against all parameter sequences or mappings found in"
" the sequence *seq_of_parameters*.  The :mod:`sqlite3` module also allows "
"using an :term:`iterator` yielding parameters instead of a sequence."
msgstr ""
"基于在序列 *seq_of_parameters* 中找到的所有形参序列或映射执行一条 SQL 命令。 :mod:`sqlite3` 模块还允许使用 "
":term:`iterator` 代替序列来产生形参。"

#: ../../library/sqlite3.rst:638
msgid "Here's a shorter example using a :term:`generator`:"
msgstr "这是一个使用生成器 :term:`generator` 的简短示例："

#: ../../library/sqlite3.rst:645
msgid ""
"This is a nonstandard convenience method for executing multiple SQL "
"statements at once. It issues a ``COMMIT`` statement first, then executes "
"the SQL script it gets as a parameter."
msgstr ""
"这是一个非标准的便捷方法，可用于一次执行多条 SQL 语句。 它会首先执行一条 ``COMMIT`` 语句，再执行以形参方式获取的 SQL 脚本。"

#: ../../library/sqlite3.rst:649
msgid "*sql_script* can be an instance of :class:`str`."
msgstr "*sql_script* 可以是一个 :class:`str` 类的实例。"

#: ../../library/sqlite3.rst:658
msgid ""
"Fetches the next row of a query result set, returning a single sequence, or "
":const:`None` when no more data is available."
msgstr "获取一个查询结果集的下一行，返回一个单独序列，或是在没有更多可用数据时返回 :const:`None`。"

#: ../../library/sqlite3.rst:664
msgid ""
"Fetches the next set of rows of a query result, returning a list.  An empty "
"list is returned when no more rows are available."
msgstr "获取下一个多行查询结果集，返回一个列表。 当没有更多可用行时将返回一个空列表。"

#: ../../library/sqlite3.rst:667
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If it is not given, the cursor's arraysize determines the number of rows to "
"be fetched. The method should try to fetch as many rows as indicated by the "
"size parameter. If this is not possible due to the specified number of rows "
"not being available, fewer rows may be returned."
msgstr ""
"每次调用获取的行数由 *size* 形参指定。 如果没有给出该形参，则由 cursor 的 arraysize 决定要获取的行数。 此方法将基于 "
"size 形参值尝试获取指定数量的行。 如果获取不到指定的行数，则可能返回较少的行。"

#: ../../library/sqlite3.rst:673
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain"
" the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"请注意 *size* 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 *size* "
"形参，则最好在从一个 :meth:`fetchmany` 调用到下一个调用之间保持相同的值。"

#: ../../library/sqlite3.rst:680
msgid ""
"Fetches all (remaining) rows of a query result, returning a list.  Note that"
" the cursor's arraysize attribute can affect the performance of this "
"operation. An empty list is returned when no rows are available."
msgstr ""
"获取一个查询结果的所有（剩余）行，返回一个列表。 请注意 cursor 的 arraysize 属性会影响此操作的执行效率。 "
"当没有可用行时将返回一个空列表。"

#: ../../library/sqlite3.rst:686
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "立即关闭 cursor（而不是在当 ``__del__`` 被调用的时候）。"

#: ../../library/sqlite3.rst:688
msgid ""
"The cursor will be unusable from this point forward; a "
":exc:`ProgrammingError` exception will be raised if any operation is "
"attempted with the cursor."
msgstr ""
"从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 :exc:`ProgrammingError` 异常。"

#: ../../library/sqlite3.rst:693
msgid ""
"Although the :class:`Cursor` class of the :mod:`sqlite3` module implements "
"this attribute, the database engine's own support for the determination of "
"\"rows affected\"/\"rows selected\" is quirky."
msgstr ""
"虽然 :mod:`sqlite3` 模块的 :class:`Cursor` 类实现了此属性，但数据库引擎本身对于确定 \"受影响行\"/\"已选择行\""
" 的支持并不完善。"

#: ../../library/sqlite3.rst:697
msgid ""
"For :meth:`executemany` statements, the number of modifications are summed "
"up into :attr:`rowcount`."
msgstr "对于 :meth:`executemany` 语句，修改行数会被汇总至 :attr:`rowcount`。"

#: ../../library/sqlite3.rst:700
msgid ""
"As required by the Python DB API Spec, the :attr:`rowcount` attribute \"is "
"-1 in case no ``executeXX()`` has been performed on the cursor or the "
"rowcount of the last operation is not determinable by the interface\". This "
"includes ``SELECT`` statements because we cannot determine the number of "
"rows a query produced until all rows were fetched."
msgstr ""
"根据 Python DB API 规格描述的要求，:attr:`rowcount` 属性 \"当未在 cursor 上执行 "
"``executeXX()`` 或者上一次操作的 rowcount 不是由接口确定时为 -1\"。 这包括 ``SELECT`` "
"语句，因为我们无法确定一次查询将产生的行计数，而要等获取了所有行时才会知道。"

#: ../../library/sqlite3.rst:706
msgid ""
"With SQLite versions before 3.6.5, :attr:`rowcount` is set to 0 if you make "
"a ``DELETE FROM table`` without any condition."
msgstr ""
"在 SQLite 的 3.6.5 版之前，如果你执行 ``DELETE FROM table`` 时不附带任何条件，则 :attr:`rowcount`"
" 将被设为 0。"

#: ../../library/sqlite3.rst:711
msgid ""
"This read-only attribute provides the rowid of the last modified row. It is "
"only set if you issued an ``INSERT`` or a ``REPLACE`` statement using the "
":meth:`execute` method.  For operations other than ``INSERT`` or ``REPLACE``"
" or when :meth:`executemany` is called, :attr:`lastrowid` is set to "
":const:`None`."
msgstr ""
"这个只读属性会提供最近修改行的 rowid。 它只在你使用 :meth:`execute` 方法执行 ``INSERT`` 或 ``REPLACE`` "
"语句时会被设置。 对于 ``INSERT`` 或 ``REPLACE`` 以外的操作或者当 :meth:`executemany` "
"被调用时，:attr:`lastrowid` 会被设为 :const:`None`。"

#: ../../library/sqlite3.rst:717
msgid ""
"If the ``INSERT`` or ``REPLACE`` statement failed to insert the previous "
"successful rowid is returned."
msgstr "如果 ``INSERT`` 或 ``REPLACE`` 语句操作失败则将返回上一次成功操作的 rowid。"

#: ../../library/sqlite3.rst:720
msgid "Added support for the ``REPLACE`` statement."
msgstr "增加了 ``REPLACE`` 语句的支持。"

#: ../../library/sqlite3.rst:725
msgid ""
"Read/write attribute that controls the number of rows returned by "
":meth:`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr "用于控制 :meth:`fetchmany` 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。"

#: ../../library/sqlite3.rst:730
msgid ""
"This read-only attribute provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are :const:`None`."
msgstr ""
"这个只读属性将提供上一次查询的列名称。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 "
":const:`None`。"

#: ../../library/sqlite3.rst:734
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "对于没有任何匹配行的 ``SELECT`` 语句同样会设置该属性。"

#: ../../library/sqlite3.rst:738
msgid ""
"This read-only attribute provides the SQLite database :class:`Connection` "
"used by the :class:`Cursor` object.  A :class:`Cursor` object created by "
"calling :meth:`con.cursor() <Connection.cursor>` will have a "
":attr:`connection` attribute that refers to *con*::"
msgstr ""
"这个只读属性将提供 :class:`Cursor` 对象所使用的 SQLite 数据库 :class:`Connection`。 通过调用 "
":meth:`con.cursor() <Connection.cursor>` 创建的 :class:`Cursor` 对象所包含的 "
":attr:`connection` 属性将指向 *con*::"

#: ../../library/sqlite3.rst:751
msgid "Row Objects"
msgstr "行对象"

#: ../../library/sqlite3.rst:755
msgid ""
"A :class:`Row` instance serves as a highly optimized "
":attr:`~Connection.row_factory` for :class:`Connection` objects. It tries to"
" mimic a tuple in most of its features."
msgstr ""
"一个 :class:`Row` 实例，该实例将作为用于 :class:`Connection` 对象的高度优化的 "
":attr:`~Connection.row_factory`。 它的大部分行为都会模仿元组的特性。"

#: ../../library/sqlite3.rst:759
msgid ""
"It supports mapping access by column name and index, iteration, "
"representation, equality testing and :func:`len`."
msgstr "它支持使用列名称的映射访问以及索引、迭代、文本表示、相等检测和 :func:`len` 等操作。"

#: ../../library/sqlite3.rst:762
msgid ""
"If two :class:`Row` objects have exactly the same columns and their members "
"are equal, they compare equal."
msgstr "如果两个 :class:`Row` 对象具有完全相同的列并且其成员均相等，则它们的比较结果为相等。"

#: ../../library/sqlite3.rst:767
msgid ""
"This method returns a list of column names. Immediately after a query, it is"
" the first member of each tuple in :attr:`Cursor.description`."
msgstr "此方法会在一次查询之后立即返回一个列名称的列表，它是 :attr:`Cursor.description` 中每个元组的第一个成员。"

#: ../../library/sqlite3.rst:770
msgid "Added support of slicing."
msgstr "添加了对切片操作的支持。"

#: ../../library/sqlite3.rst:773
msgid "Let's assume we initialize a table as in the example given above::"
msgstr "让我们假设我们如上面的例子所示初始化一个表::"

#: ../../library/sqlite3.rst:785
msgid "Now we plug :class:`Row` in::"
msgstr "现在我们将 :class:`Row` 插入::"

#: ../../library/sqlite3.rst:817
msgid "Exceptions"
msgstr "异常"

#: ../../library/sqlite3.rst:821
msgid "A subclass of :exc:`Exception`."
msgstr ":exc:`Exception` 的一个子类。"

#: ../../library/sqlite3.rst:825
msgid ""
"The base class of the other exceptions in this module.  It is a subclass of "
":exc:`Exception`."
msgstr "此模块中其他异常的基类。 它是 :exc:`Exception` 的一个子类。"

#: ../../library/sqlite3.rst:830
msgid "Exception raised for errors that are related to the database."
msgstr "针对数据库相关错误引发的异常。"

#: ../../library/sqlite3.rst:834
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr "当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:839
msgid ""
"Exception raised for programming errors, e.g. table not found or already "
"exists, syntax error in the SQL statement, wrong number of parameters "
"specified, etc.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"编程错误引发的异常，例如表未找到或已存在，SQL 语句存在语法错误，指定的形参数量错误等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:845
msgid ""
"Exception raised for errors that are related to the database's operation and"
" not necessarily under the control of the programmer, e.g. an unexpected "
"disconnect occurs, the data source name is not found, a transaction could "
"not be processed, etc.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"与数据库操作相关而不一定能受程序员掌控的错误引发的异常，例如发生非预期的连接中断，数据源名称未找到，事务无法被执行等。 它是 "
":exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:852
msgid ""
"Exception raised in case a method or database API was used which is not "
"supported by the database, e.g. calling the :meth:`~Connection.rollback` "
"method on a connection that does not support transaction or has transactions"
" turned off.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"在使用了某个数据库不支持的方法或数据库 API 时引发的异常，例如在一个不支持事务或禁用了事务的连接上调用 "
":meth:`~Connection.rollback` 方法等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:861
msgid "SQLite and Python types"
msgstr "SQLite 与 Python 类型"

#: ../../library/sqlite3.rst:865
msgid "Introduction"
msgstr "概述"

#: ../../library/sqlite3.rst:867
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr "SQLite 原生支持如下的类型： ``NULL``，``INTEGER``，``REAL``，``TEXT``，``BLOB``。"

#: ../../library/sqlite3.rst:870
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "因此可以将以下Python类型发送到SQLite而不会出现任何问题："

#: ../../library/sqlite3.rst:873 ../../library/sqlite3.rst:890
msgid "Python type"
msgstr "Python 类型"

#: ../../library/sqlite3.rst:873 ../../library/sqlite3.rst:890
msgid "SQLite type"
msgstr "SQLite 类型"

#: ../../library/sqlite3.rst:875 ../../library/sqlite3.rst:892
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/sqlite3.rst:875 ../../library/sqlite3.rst:892
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:877 ../../library/sqlite3.rst:894
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:877 ../../library/sqlite3.rst:894
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:879 ../../library/sqlite3.rst:896
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:879 ../../library/sqlite3.rst:896
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:881
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:881 ../../library/sqlite3.rst:898
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:883 ../../library/sqlite3.rst:901
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:883 ../../library/sqlite3.rst:901
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:887
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "这是SQLite类型默认转换为Python类型的方式："

#: ../../library/sqlite3.rst:898
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "取决于 :attr:`~Connection.text_factory` , 默认为 :class:`str` "

#: ../../library/sqlite3.rst:904
msgid ""
"The type system of the :mod:`sqlite3` module is extensible in two ways: you "
"can store additional Python types in a SQLite database via object "
"adaptation, and you can let the :mod:`sqlite3` module convert SQLite types "
"to different Python types via converters."
msgstr ""
":mod:`sqlite3` 模块的类型系统可通过两种方式来扩展：你可以通过对象适配将额外的 Python 类型保存在 SQLite "
"数据库中，你也可以让 :mod:`sqlite3` 模块通过转换器将 SQLite 类型转换为不同的 Python 类型。"

#: ../../library/sqlite3.rst:911
msgid "Using adapters to store additional Python types in SQLite databases"
msgstr "使用适配器将额外的 Python 类型保存在 SQLite 数据库中。"

#: ../../library/sqlite3.rst:913
msgid ""
"As described before, SQLite supports only a limited set of types natively. "
"To use other Python types with SQLite, you must **adapt** them to one of the"
" sqlite3 module's supported types for SQLite: one of NoneType, int, float, "
"str, bytes."
msgstr ""
"如上文所述，SQLite 只包含对有限类型集的原生支持。 要让 SQLite 能使用其他 Python 类型，你必须将它们 **适配** 至 "
"sqlite3 模块所支持的 SQLite 类型中的一种：NoneType, int, float, str, bytes。"

#: ../../library/sqlite3.rst:918
msgid ""
"There are two ways to enable the :mod:`sqlite3` module to adapt a custom "
"Python type to one of the supported ones."
msgstr "有两种方式能让 :mod:`sqlite3` 模块将某个定制的 Python 类型适配为受支持的类型。"

#: ../../library/sqlite3.rst:923
msgid "Letting your object adapt itself"
msgstr "让对象自行适配"

#: ../../library/sqlite3.rst:925
msgid ""
"This is a good approach if you write the class yourself. Let's suppose you "
"have a class like this::"
msgstr "如果类是你自己编写的，这将是一个很好的方式。 假设你有这样一个类::"

#: ../../library/sqlite3.rst:932
msgid ""
"Now you want to store the point in a single SQLite column.  First you'll "
"have to choose one of the supported types to be used for representing the "
"point. Let's just use str and separate the coordinates using a semicolon. "
"Then you need to give your class a method ``__conform__(self, protocol)`` "
"which must return the converted value. The parameter *protocol* will be "
":class:`PrepareProtocol`."
msgstr ""
"现在你可将这种点对象保存在一个 SQLite 列中。 首先你必须选择一种受支持的类型用来表示点对象。 让我们就用 str 并使用一个分号来分隔坐标值。 "
"然后你需要给你的类加一个方法 ``__conform__(self, protocol)``，它必须返回转换后的值。 形参 *protocol* 将为 "
":class:`PrepareProtocol`。"

#: ../../library/sqlite3.rst:942
msgid "Registering an adapter callable"
msgstr "注册可调用的适配器"

#: ../../library/sqlite3.rst:944
msgid ""
"The other possibility is to create a function that converts the type to the "
"string representation and register the function with "
":meth:`register_adapter`."
msgstr "另一种可能的做法是创建一个将该类型转换为字符串表示的函数并使用 :meth:`register_adapter` 注册该函数。"

#: ../../library/sqlite3.rst:949
msgid ""
"The :mod:`sqlite3` module has two default adapters for Python's built-in "
":class:`datetime.date` and :class:`datetime.datetime` types.  Now let's "
"suppose we want to store :class:`datetime.datetime` objects not in ISO "
"representation, but as a Unix timestamp."
msgstr ""
":mod:`sqlite3` 模块有两个适配器可用于 Python 的内置 :class:`datetime.date` 和 "
":class:`datetime.datetime` 类型。 现在假设我们想要存储 :class:`datetime.datetime` "
"对象，但不是表示为 ISO 格式，而是表示为 Unix 时间戳。"

#: ../../library/sqlite3.rst:958
msgid "Converting SQLite values to custom Python types"
msgstr "将SQLite 值转换为自定义Python 类型"

#: ../../library/sqlite3.rst:960
msgid ""
"Writing an adapter lets you send custom Python types to SQLite. But to make "
"it really useful we need to make the Python to SQLite to Python roundtrip "
"work."
msgstr ""
"编写适配器让你可以将定制的 Python 类型发送给 SQLite。 但要令它真正有用，我们需要实现从 Python 到 SQLite 再回到 "
"Python 的双向转换。"

#: ../../library/sqlite3.rst:963
msgid "Enter converters."
msgstr "输入转换器。"

#: ../../library/sqlite3.rst:965
msgid ""
"Let's go back to the :class:`Point` class. We stored the x and y coordinates"
" separated via semicolons as strings in SQLite."
msgstr "让我们回到 :class:`Point` 类。 我们以字符串形式在 SQLite 中存储了 x 和 y 坐标值。"

#: ../../library/sqlite3.rst:968
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`Point` object from it."
msgstr "首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 :class:`Point` 对象。"

#: ../../library/sqlite3.rst:973
msgid ""
"Converter functions **always** get called with a :class:`bytes` object, no "
"matter under which data type you sent the value to SQLite."
msgstr "转换器函数在调用时 **总是** 会附带一个 :class:`bytes` 对象，无论你将何种数据类型的值发给 SQLite。"

#: ../../library/sqlite3.rst:982
msgid ""
"Now you need to make the :mod:`sqlite3` module know that what you select "
"from the database is actually a point. There are two ways of doing this:"
msgstr "现在你需要让 :mod:`sqlite3` 模块知道你从数据库中选取的其实是一个点对象。 有两种方式都可以做到这件事："

#: ../../library/sqlite3.rst:985
msgid "Implicitly via the declared type"
msgstr "隐式的声明类型"

#: ../../library/sqlite3.rst:987
msgid "Explicitly via the column name"
msgstr "显式的通过列名"

#: ../../library/sqlite3.rst:989
msgid ""
"Both ways are described in section :ref:`sqlite3-module-contents`, in the "
"entries for the constants :const:`PARSE_DECLTYPES` and "
":const:`PARSE_COLNAMES`."
msgstr ""
"这两种方式会在 :ref:`sqlite3-module-contents` 一节中描述，相应条目为 :const:`PARSE_DECLTYPES` "
"和 :const:`PARSE_COLNAMES` 常量。"

#: ../../library/sqlite3.rst:992
msgid "The following example illustrates both approaches."
msgstr "下面的示例说明了这两种方法。"

#: ../../library/sqlite3.rst:998
msgid "Default adapters and converters"
msgstr "默认适配器和转换器"

#: ../../library/sqlite3.rst:1000
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""
"对于 datetime 模块中的 date 和 datetime 类型已提供了默认的适配器。 它们将会以 ISO 日期/ISO 时间戳的形式发给 "
"SQLite。"

#: ../../library/sqlite3.rst:1003
msgid ""
"The default converters are registered under the name \"date\" for "
":class:`datetime.date` and under the name \"timestamp\" for "
":class:`datetime.datetime`."
msgstr ""
"默认转换器使用的注册名称是针对 :class:`datetime.date` 的 \"date\" 和针对 "
":class:`datetime.datetime` 的 \"timestamp\"。"

#: ../../library/sqlite3.rst:1007
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"通过这种方式，你可以在大多数情况下使用 Python 的 date/timestamp 对象而无须任何额外处理。 适配器的格式还与实验性的 SQLite"
" date/time 函数兼容。"

#: ../../library/sqlite3.rst:1011
msgid "The following example demonstrates this."
msgstr "下面的示例演示了这一点。"

#: ../../library/sqlite3.rst:1015
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers,"
" its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr "如果存储在 SQLite 中的时间戳的小数位多于 6 个数字，则时间戳转换器会将该值截断至微秒精度。"

#: ../../library/sqlite3.rst:1023
msgid "Controlling Transactions"
msgstr "控制事务"

#: ../../library/sqlite3.rst:1025
msgid ""
"The underlying ``sqlite3`` library operates in ``autocommit`` mode by "
"default, but the Python :mod:`sqlite3` module by default does not."
msgstr ""
"底层的 ``sqlite3`` 库默认会以 ``autocommit`` 模式运行，但 Python 的 :mod:`sqlite3` "
"模块默认则不使用此模式。"

#: ../../library/sqlite3.rst:1028
msgid ""
"``autocommit`` mode means that statements that modify the database take "
"effect immediately.  A ``BEGIN`` or ``SAVEPOINT`` statement disables "
"``autocommit`` mode, and a ``COMMIT``, a ``ROLLBACK``, or a ``RELEASE`` that"
" ends the outermost transaction, turns ``autocommit`` mode back on."
msgstr ""
"``autocommit`` 模式意味着修改数据库的操作会立即生效。 ``BEGIN`` 或 ``SAVEPOINT`` 语句会禁用 "
"``autocommit`` 模式，而用于结束外层事务的 ``COMMIT``, ``ROLLBACK`` 或 ``RELEASE`` 则会恢复 "
"``autocommit`` 模式。"

#: ../../library/sqlite3.rst:1033
msgid ""
"The Python :mod:`sqlite3` module by default issues a ``BEGIN`` statement "
"implicitly before a Data Modification Language (DML) statement (i.e. "
"``INSERT``/``UPDATE``/``DELETE``/``REPLACE``)."
msgstr ""
"Python 的 :mod:`sqlite3` 模块默认会在数据修改语言 (DML) 类语句 (即 "
"``INSERT``/``UPDATE``/``DELETE``/``REPLACE``) 之前隐式地执行一条 ``BEGIN`` 语句。"

#: ../../library/sqlite3.rst:1037
msgid ""
"You can control which kind of ``BEGIN`` statements :mod:`sqlite3` implicitly"
" executes via the *isolation_level* parameter to the :func:`connect` call, "
"or via the :attr:`isolation_level` property of connections. If you specify "
"no *isolation_level*, a plain ``BEGIN`` is used, which is equivalent to "
"specifying ``DEFERRED``.  Other possible values are ``IMMEDIATE`` and "
"``EXCLUSIVE``."
msgstr ""
"你可以控制 :mod:`sqlite3` 隐式执行的 ``BEGIN`` 语句的种类，具体做法是通过将 *isolation_level* 形参传给 "
":func:`connect` 调用，或者通过指定连接的 :attr:`isolation_level` 属性。 如果你没有指定 "
"*isolation_level*，将使用基本的 ``BEGIN``，它等价于指定 ``DEFERRED``。 其他可能的值为 "
"``IMMEDIATE`` 和 ``EXCLUSIVE``。"

#: ../../library/sqlite3.rst:1044
msgid ""
"You can disable the :mod:`sqlite3` module's implicit transaction management "
"by setting :attr:`isolation_level` to ``None``.  This will leave the "
"underlying ``sqlite3`` library operating in ``autocommit`` mode.  You can "
"then completely control the transaction state by explicitly issuing "
"``BEGIN``, ``ROLLBACK``, ``SAVEPOINT``, and ``RELEASE`` statements in your "
"code."
msgstr ""
"你可以禁用 :mod:`sqlite3` 模块的隐式事务管理，具体做法是将 :attr:`isolation_level` 设为 ``None``。 "
"这将使得下层的 ``sqlite3`` 库采用 ``autocommit`` 模式。 随后你可以通过在代码中显式地使用 ``BEGIN``, "
"``ROLLBACK``, ``SAVEPOINT`` 和 ``RELEASE`` 语句来完全控制事务状态。"

#: ../../library/sqlite3.rst:1050
msgid ""
":mod:`sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr "以前 :mod:`sqlite3` 会在 DDL 语句之前隐式地提交未完成事务。 现在则不会再这样做。"

#: ../../library/sqlite3.rst:1056
msgid "Using :mod:`sqlite3` efficiently"
msgstr "有效使用 :mod:`sqlite3` "

#: ../../library/sqlite3.rst:1060
msgid "Using shortcut methods"
msgstr "使用快捷方式"

#: ../../library/sqlite3.rst:1062
msgid ""
"Using the nonstandard :meth:`execute`, :meth:`executemany` and "
":meth:`executescript` methods of the :class:`Connection` object, your code "
"can be written more concisely because you don't have to create the (often "
"superfluous) :class:`Cursor` objects explicitly. Instead, the "
":class:`Cursor` objects are created implicitly and these shortcut methods "
"return the cursor objects. This way, you can execute a ``SELECT`` statement "
"and iterate over it directly using only a single call on the "
":class:`Connection` object."
msgstr ""
"使用 :class:`Connection` 对象的非标准 :meth:`execute`, :meth:`executemany` 和 "
":meth:`executescript` 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） :class:`Cursor` 对象。相反， "
":class:`Cursor` 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 :class:`Connection` "
"对象调用一次，就能直接执行 ``SELECT`` 语句并遍历对象。"

#: ../../library/sqlite3.rst:1074
msgid "Accessing columns by name instead of by index"
msgstr "通过名称而不是索引访问索引"

#: ../../library/sqlite3.rst:1076
msgid ""
"One useful feature of the :mod:`sqlite3` module is the built-in "
":class:`sqlite3.Row` class designed to be used as a row factory."
msgstr ":mod:`sqlite3` 模块的一个有用功能是内置的 :class:`sqlite3.Row` 类，该类旨在用作行工厂。"

#: ../../library/sqlite3.rst:1079
msgid ""
"Rows wrapped with this class can be accessed both by index (like tuples) and"
" case-insensitively by name:"
msgstr "该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问："

#: ../../library/sqlite3.rst:1086
msgid "Using the connection as a context manager"
msgstr "使用连接作为上下文管理器"

#: ../../library/sqlite3.rst:1088
msgid ""
"Connection objects can be used as context managers that automatically commit"
" or rollback transactions.  In the event of an exception, the transaction is"
" rolled back; otherwise, the transaction is committed:"
msgstr "连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。"

#: ../../library/sqlite3.rst:1097
msgid "Footnotes"
msgstr "脚注"

#: ../../library/sqlite3.rst:1098
msgid ""
"The sqlite3 module is not built with loadable extension support by default, "
"because some platforms (notably Mac OS X) have SQLite libraries which are "
"compiled without this feature. To get loadable extension support, you must "
"pass --enable-loadable-sqlite-extensions to configure."
msgstr ""
"sqlite3 模块默认没有构建可加载扩展支持，因为有一些平台带有不支持这个特性的 SQLite 库（特别是 Mac OS "
"X）。要获得可加载扩展的支持，那么在编译配置的时候必须指定 --enable-loadable-sqlite-extensions 选项。"
