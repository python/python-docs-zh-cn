# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Arisaka97 <solitaire2312@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# Kade For, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# Freesand Leo <yuqinju@163.com>, 2022
# stone jing <stonejing1817@gmail.com>, 2022
# ppcfish <ppcfish@gmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-04 14:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: ppcfish <ppcfish@gmail.com>, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- SQLite 数据库 DB-API 2.0 接口模块"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**源代码：** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../library/sqlite3.rst:30
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by "
":pep:`249`, and requires SQLite 3.7.15 or newer."
msgstr ""

#: ../../library/sqlite3.rst:34
msgid "This document includes four main sections:"
msgstr ""

#: ../../library/sqlite3.rst:36
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ""

#: ../../library/sqlite3.rst:37
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""

#: ../../library/sqlite3.rst:39
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ""

#: ../../library/sqlite3.rst:40
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "学习 SQL 语法的教程、参考和例子。"

#: ../../library/sqlite3.rst:52
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰写。"

#: ../../library/sqlite3.rst:66
msgid "Tutorial"
msgstr "教程"

#: ../../library/sqlite3.rst:68
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""

#: ../../library/sqlite3.rst:73
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""

#: ../../library/sqlite3.rst:84
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to"
" the on-disk database."
msgstr ""

#: ../../library/sqlite3.rst:87
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() "
"<Connection.cursor>` to create the :class:`Cursor`:"
msgstr ""

#: ../../library/sqlite3.rst:95
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration"
" -- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling "
":meth:`cur.execute(...) <Cursor.execute>`:"
msgstr ""

#: ../../library/sqlite3.rst:111
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) "
"<Cursor.execute>`, assign the result to ``res``, and call "
":meth:`res.fetchone() <Cursor.fetchone>` to fetch the resulting row:"
msgstr ""

#: ../../library/sqlite3.rst:125
msgid ""
"We can see that the table has been created, as the query returns a "
":class:`tuple` containing the table's name. If we query ``sqlite_master`` "
"for a non-existent table ``spam``, :meth:`!res.fetchone()` will return "
"``None``:"
msgstr ""

#: ../../library/sqlite3.rst:136
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) "
"<Cursor.execute>`:"
msgstr ""

#: ../../library/sqlite3.rst:148
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see "
":ref:`sqlite3-controlling-transactions` for details). Call "
":meth:`con.commit() <Connection.commit>` on the connection object to commit "
"the transaction:"
msgstr ""

#: ../../library/sqlite3.rst:158
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT``"
" query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() "
"<Cursor.fetchall>` to return all resulting rows:"
msgstr ""

#: ../../library/sqlite3.rst:170
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""

#: ../../library/sqlite3.rst:173
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) "
"<Cursor.executemany>`:"
msgstr ""

#: ../../library/sqlite3.rst:186
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>`"
" to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""

#: ../../library/sqlite3.rst:192
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""

#: ../../library/sqlite3.rst:206
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""

#: ../../library/sqlite3.rst:209
msgid ""
"Finally, verify that the database has been written to disk by calling "
":meth:`con.close() <Connection.close>` to close the existing connection, "
"opening a new one, creating a new cursor, then querying the database:"
msgstr ""

#: ../../library/sqlite3.rst:224
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""

#: ../../library/sqlite3.rst:236
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ""

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ""

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ""

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ""

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:515
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ""

#: ../../library/sqlite3.rst:243
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""

#: ../../library/sqlite3.rst:248
msgid "Reference"
msgstr "参考"

#: ../../library/sqlite3.rst:256
msgid "Module functions"
msgstr ""

#: ../../library/sqlite3.rst:263
msgid "Open a connection to an SQLite database."
msgstr ""

#: ../../library/sqlite3.rst:0 ../../library/sqlite3.rst:0
#: ../../library/sqlite3.rst:0 ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/sqlite3.rst:265
msgid ""
"The path to the database file to be opened. Pass ``\":memory:\"`` to open a "
"connection to a database that is in RAM instead of on disk."
msgstr ""

#: ../../library/sqlite3.rst:271
msgid ""
"How many seconds the connection should wait before raising an exception, if "
"the database is locked by another connection. If another connection opens a "
"transaction to modify the database, it will be locked until that transaction"
" is committed. Default five seconds."
msgstr ""

#: ../../library/sqlite3.rst:278
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and "
":const:`PARSE_COLNAMES` to enable this. Column names takes precedence over "
"declared types if both flags are set. Types cannot be detected for generated"
" fields (for example ``max(data)``), even when the *detect_types* parameter "
"is set; :class:`str` will be returned instead. By default (``0``), type "
"detection is disabled."
msgstr ""

#: ../../library/sqlite3.rst:292
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions`"
" for more."
msgstr ""

#: ../../library/sqlite3.rst:300
msgid ""
"If ``True`` (default), only the creating thread may use the connection. If "
"``False``, the connection may be shared across multiple threads; if so, "
"write operations should be serialized by the user to avoid data corruption."
msgstr ""

#: ../../library/sqlite3.rst:306
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""

#: ../../library/sqlite3.rst:310
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 100 statements."
msgstr ""

#: ../../library/sqlite3.rst:315
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr ""

#: ../../library/sqlite3.rst:326
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument"
" ``database``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``sqlite3.connect``，附带参数 ``database``。"

#: ../../library/sqlite3.rst:327
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.connect/handle``，附带参数 "
"``connection_handle``。"

#: ../../library/sqlite3.rst:329
msgid "The *uri* parameter."
msgstr ""

#: ../../library/sqlite3.rst:332
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database* 现在可以是一个 :term:`path-like object` 对象了，不仅仅是字符串。"

#: ../../library/sqlite3.rst:335
msgid "The ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:340
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is"
" performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""

#: ../../library/sqlite3.rst:346
msgid "For example:"
msgstr "例如:"

#: ../../library/sqlite3.rst:355
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""

#: ../../library/sqlite3.rst:361
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on ``sys.stderr``. Use ``False`` to disable the feature again."
msgstr ""

#: ../../library/sqlite3.rst:370
msgid ""
"Register an *adapter* callable to adapt the Python type *type* into an "
"SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:378
msgid ""
"Register the *converter* callable to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked"
" for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""

#: ../../library/sqlite3.rst:386
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""

#: ../../library/sqlite3.rst:393
msgid "Module constants"
msgstr ""

#: ../../library/sqlite3.rst:397
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""

#: ../../library/sqlite3.rst:407
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: ../../library/sqlite3.rst:412
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""

#: ../../library/sqlite3.rst:428
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: ../../library/sqlite3.rst:435
msgid ""
"Flags that should be returned by the *authorizer_callback* callable passed "
"to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""

#: ../../library/sqlite3.rst:438
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr ""

#: ../../library/sqlite3.rst:439
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""

#: ../../library/sqlite3.rst:440
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""

#: ../../library/sqlite3.rst:444
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr "指明所支持的 DB-API 级别的字符串常量。 根据 DB-API 的需要设置。 硬编码为 ``\"2.0\"``。"

#: ../../library/sqlite3.rst:449
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""

#: ../../library/sqlite3.rst:455
msgid ""
"The :mod:`!sqlite3` module supports ``qmark``, ``numeric``, and ``named`` "
"DB-API parameter styles, because that is what the underlying SQLite library "
"supports. However, the DB-API does not allow multiple values for the "
"``paramstyle`` attribute."
msgstr ""

#: ../../library/sqlite3.rst:463
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""

#: ../../library/sqlite3.rst:467
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of "
":class:`integers <int>`."
msgstr ""

#: ../../library/sqlite3.rst:472
msgid ""
"Integer constant required by the DB-API, stating the level of thread safety "
"the :mod:`!sqlite3` module supports. Currently hard-coded to ``1``, meaning "
"*\"Threads may share the module, but not connections.\"* However, this may "
"not always be true. You can check the underlying SQLite library's compile-"
"time threaded mode using the following query::"
msgstr ""

#: ../../library/sqlite3.rst:485
msgid ""
"Note that the `SQLITE_THREADSAFE levels "
"<https://sqlite.org/compile.html#threadsafe>`_ do not match the DB-API 2.0 "
"``threadsafety`` levels."
msgstr ""
"注意 `SQLITE_THREADSAFE 级别 <https://sqlite.org/compile.html#threadsafe>`_ 与 "
"DB-API 2.0 ``threadsafety`` 级别不一致。"

#: ../../library/sqlite3.rst:491
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:496
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:503
msgid "Connection objects"
msgstr ""

#: ../../library/sqlite3.rst:507
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating "
":class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""

#: ../../library/sqlite3.rst:514
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ""

#: ../../library/sqlite3.rst:517
msgid ""
"An SQLite database connection has the following attributes and methods:"
msgstr "SQLite 数据库连接对象有如下的属性和方法："

#: ../../library/sqlite3.rst:521
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a callable "
"returning an instance of :class:`Cursor` or its subclasses."
msgstr ""

#: ../../library/sqlite3.rst:528
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:533
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:538
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr ""

#: ../../library/sqlite3.rst:545
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.execute`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:551
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.executemany`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:557
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql_script* 调用 "
":meth:`~Cursor.executescript`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:563
msgid "Create or remove a user-defined SQL function."
msgstr ""

#: ../../library/sqlite3.rst:565
msgid "The name of the SQL function."
msgstr ""

#: ../../library/sqlite3.rst:568
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""

#: ../../library/sqlite3.rst:572
msgid ""
"A callable that is called when the SQL function is invoked. The callable "
"must return :ref:`a type natively supported by SQLite <sqlite3-types>`. Set "
"to ``None`` to remove an existing SQL function."
msgstr ""

#: ../../library/sqlite3.rst:579
msgid ""
"If ``True``, the created SQL function is marked as `deterministic "
"<https://sqlite.org/deterministic.html>`_, which allows SQLite to perform "
"additional optimizations."
msgstr ""

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr ""

#: ../../library/sqlite3.rst:584
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""

#: ../../library/sqlite3.rst:587
msgid "The *deterministic* parameter."
msgstr ""

#: ../../library/sqlite3.rst:590 ../../library/sqlite3.rst:628
#: ../../library/sqlite3.rst:847 ../../library/sqlite3.rst:953
#: ../../library/sqlite3.rst:983 ../../library/sqlite3.rst:1088
#: ../../library/sqlite3.rst:1109 ../../library/sqlite3.rst:1248
msgid "Example:"
msgstr "示例:"

#: ../../library/sqlite3.rst:606
msgid "Create or remove a user-defined SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:608
msgid "The name of the SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:611
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it"
" may take any number of arguments."
msgstr ""

#: ../../library/sqlite3.rst:615
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate as"
"   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:616
msgid "A class must implement the following methods:"
msgstr ""

#: ../../library/sqlite3.rst:618
msgid "``step()``: Add a row to the aggregate."
msgstr ""

#: ../../library/sqlite3.rst:619
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:622
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled"
" by *n_arg*."
msgstr ""

#: ../../library/sqlite3.rst:625
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:660
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"使用排序函数 *callable* 创建一个名为 *name* 的排序规则。 *callable* 被传递给两个 :class:`字符串 <str>` "
"参数，并且它应该返回一个 :class:`整数 <int>`。"

#: ../../library/sqlite3.rst:664
msgid "``1`` if the first is ordered higher than the second"
msgstr "如果前者的排序高于后者则为 ``1``"

#: ../../library/sqlite3.rst:665
msgid "``-1`` if the first is ordered lower than the second"
msgstr "如果前者的排序低于于后者则为 ``-1``"

#: ../../library/sqlite3.rst:666
msgid "``0`` if they are ordered equal"
msgstr "如果它们的顺序相同则为 ``0``"

#: ../../library/sqlite3.rst:668
msgid "The following example shows a reverse sorting collation:"
msgstr "下面的例子显示了一个反向排序的排序方法:"

#: ../../library/sqlite3.rst:696
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""

#: ../../library/sqlite3.rst:701
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an exception."
msgstr ""

#: ../../library/sqlite3.rst:708
msgid ""
"Register callable *authorizer_callback* to be invoked for each attempt to "
"access a column of a table in the database. The callback should return one "
"of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE` to "
"signal how access to the column should be handled by the underlying SQLite "
"library."
msgstr ""

#: ../../library/sqlite3.rst:714
msgid ""
"The first argument to the callback signifies what kind of operation is to be"
" authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""

#: ../../library/sqlite3.rst:721
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on"
" the first one. All necessary constants are available in the :mod:`!sqlite3`"
" module."
msgstr ""

#: ../../library/sqlite3.rst:728
msgid ""
"Register callable *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update"
" a GUI."
msgstr ""

#: ../../library/sqlite3.rst:733
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""

#: ../../library/sqlite3.rst:736
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr "从处理函数返回非零值将终止当前正在执行的查询并导致它引发 :exc:`OperationalError` 异常。"

#: ../../library/sqlite3.rst:743
msgid ""
"Register callable *trace_callback* to be invoked for each SQL statement that"
" is actually executed by the SQLite backend."
msgstr ""

#: ../../library/sqlite3.rst:746
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the "
":meth:`Cursor.execute` methods.  Other sources include the :ref:`transaction"
" management <sqlite3-controlling-transactions>` of the :mod:`!sqlite3` "
"module and the execution of triggers defined in the current database."
msgstr ""

#: ../../library/sqlite3.rst:754
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""

#: ../../library/sqlite3.rst:757
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development"
" and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to "
"enable printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"在跟踪回调中产生的异常不会被传播。作为开发和调试的辅助手段，使用 :meth:`~sqlite3.enable_callback_tracebacks`"
" 来启用打印跟踪回调中产生的异常的回调。"

#: ../../library/sqlite3.rst:767
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""

#: ../../library/sqlite3.rst:776
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to "
":program:`configure`."
msgstr ""

#: ../../library/sqlite3.rst:783
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension``"
" with arguments ``connection``, ``enabled``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.enable_load_extension``，附带参数 "
"``connection``, ``enabled``。"

#: ../../library/sqlite3.rst:787
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "增加了 ``sqlite3.enable_load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:830
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""

#: ../../library/sqlite3.rst:834
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.load_extension``，附带参数 ``connection``, "
"``path``。"

#: ../../library/sqlite3.rst:838
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "增加了 ``sqlite3.load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:843
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the "
"``.dump`` command in the :program:`sqlite3` shell."
msgstr ""

#: ../../library/sqlite3.rst:861
msgid "Create a backup of an SQLite database."
msgstr ""

#: ../../library/sqlite3.rst:863
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""

#: ../../library/sqlite3.rst:866
msgid "The database connection to save the backup to."
msgstr ""

#: ../../library/sqlite3.rst:869
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""

#: ../../library/sqlite3.rst:875
msgid ""
"If set to a callable, it is invoked with three integer arguments for every "
"backup iteration: the *status* of the last iteration, the *remaining* number"
" of pages still to be copied, and the *total* number of pages. Defaults to "
"``None``."
msgstr ""

#: ../../library/sqlite3.rst:884
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a"
" custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:891
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""

#: ../../library/sqlite3.rst:895
msgid "Example 1, copy an existing database into another:"
msgstr ""

#: ../../library/sqlite3.rst:914
msgid "Example 2, copy an existing database into a transient copy:"
msgstr ""

#: ../../library/sqlite3.rst:926
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""

#: ../../library/sqlite3.rst:929
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""

#: ../../library/sqlite3.rst:936
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``,"
" ``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""

#: ../../library/sqlite3.rst:944
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the"
" default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""

#: ../../library/sqlite3.rst:949
msgid ""
"A callable that accepts two arguments, a :class:`Cursor` object and the raw "
"row results as a :class:`tuple`, and returns a custom object representing an"
" SQLite row."
msgstr ""

#: ../../library/sqlite3.rst:966
msgid ""
"If returning a tuple doesn't suffice and you want name-based access to "
"columns, you should consider setting :attr:`row_factory` to the highly "
"optimized :class:`sqlite3.Row` type. :class:`Row` provides both index-based "
"and case-insensitive name-based access to columns with almost no memory "
"overhead. It will probably be better than your own custom dictionary-based "
"approach or even a db_row based solution."
msgstr ""

#: ../../library/sqlite3.rst:977
msgid ""
"A callable that accepts a :class:`bytes` parameter and returns a text "
"representation of it. The callable is invoked for SQLite values with the "
"``TEXT`` data type. By default, this attribute is set to :class:`str`. If "
"you want to return ``bytes`` instead, set *text_factory* to ``bytes``."
msgstr ""

#: ../../library/sqlite3.rst:1017
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""

#: ../../library/sqlite3.rst:1023
msgid "Cursor objects"
msgstr ""

#: ../../library/sqlite3.rst:1025
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute"
" SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the "
":ref:`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""

#: ../../library/sqlite3.rst:1032
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you "
":meth:`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the "
"cursor to fetch the resulting rows:"
msgstr ""

#: ../../library/sqlite3.rst:1057
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 游标实例具有以下属性和方法。"

#: ../../library/sqlite3.rst:1064
msgid ""
"Execute SQL statement *sql*. Bind values to the statement using "
":ref:`placeholders <sqlite3-placeholders>` that map to the :term:`sequence` "
"or :class:`dict` *parameters*."
msgstr ""

#: ../../library/sqlite3.rst:1069
msgid ""
":meth:`execute` will only execute a single SQL statement. If you try to "
"execute more than one statement with it, it will raise a :exc:`Warning`. Use"
" :meth:`executescript` if you want to execute multiple SQL statements with "
"one call."
msgstr ""
":meth:`execute` 将只执行一条单独的 SQL 语句。 如果你尝试用它执行超过一条语句，将会引发 :exc:`Warning`。 "
"如果你想要用一次调用执行多条 SQL 语句请使用 :meth:`executescript`。"

#: ../../library/sqlite3.rst:1074
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""

#: ../../library/sqlite3.rst:1082
msgid ""
"Execute :ref:`parameterized <sqlite3-placeholders>` SQL statement *sql* "
"against all parameter sequences or mappings found in the sequence "
"*parameters*.  It is also possible to use an :term:`iterator` yielding "
"parameters instead of a sequence. Uses the same implicit transaction "
"handling as :meth:`~Cursor.execute`."
msgstr ""

#: ../../library/sqlite3.rst:1101
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""

#: ../../library/sqlite3.rst:1107
msgid "*sql_script* must be a :class:`string <str>`."
msgstr ""

#: ../../library/sqlite3.rst:1125
msgid ""
"If :attr:`~Connection.row_factory` is ``None``, return the next row query "
"result set as a :class:`tuple`. Else, pass it to the row factory and return "
"its result. Return ``None`` if no more data is available."
msgstr ""

#: ../../library/sqlite3.rst:1133
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""

#: ../../library/sqlite3.rst:1136
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""

#: ../../library/sqlite3.rst:1142
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain"
" the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"请注意 *size* 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 *size* "
"形参，则最好在从一个 :meth:`fetchmany` 调用到下一个调用之间保持相同的值。"

#: ../../library/sqlite3.rst:1149
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""

#: ../../library/sqlite3.rst:1156
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "立即关闭 cursor（而不是在当 ``__del__`` 被调用的时候）。"

#: ../../library/sqlite3.rst:1158
msgid ""
"The cursor will be unusable from this point forward; a "
":exc:`ProgrammingError` exception will be raised if any operation is "
"attempted with the cursor."
msgstr ""
"从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 :exc:`ProgrammingError` 异常。"

#: ../../library/sqlite3.rst:1163 ../../library/sqlite3.rst:1167
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr ""

#: ../../library/sqlite3.rst:1171
msgid ""
"Read/write attribute that controls the number of rows returned by "
":meth:`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr "用于控制 :meth:`fetchmany` 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。"

#: ../../library/sqlite3.rst:1176
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling "
":meth:`con.cursor() <Connection.cursor>` will have a :attr:`connection` "
"attribute that refers to *con*:"
msgstr ""

#: ../../library/sqlite3.rst:1190
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""

#: ../../library/sqlite3.rst:1194
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "对于没有任何匹配行的 ``SELECT`` 语句同样会设置该属性。"

#: ../../library/sqlite3.rst:1198
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is"
" only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany`"
" or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""

#: ../../library/sqlite3.rst:1206
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "对 ``WITHOUT ROWID`` 表的插入不被记录。"

#: ../../library/sqlite3.rst:1208
msgid "Added support for the ``REPLACE`` statement."
msgstr "增加了 ``REPLACE`` 语句的支持。"

#: ../../library/sqlite3.rst:1213
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods."
msgstr ""

#: ../../library/sqlite3.rst:1228
msgid "Row objects"
msgstr ""

#: ../../library/sqlite3.rst:1232
msgid ""
"A :class:`!Row` instance serves as a highly optimized "
":attr:`~Connection.row_factory` for :class:`Connection` objects. It supports"
" iteration, equality testing, :func:`len`, and :term:`mapping` access by "
"column name and index."
msgstr ""

#: ../../library/sqlite3.rst:1237
msgid "Two row objects compare equal if have equal columns and equal members."
msgstr ""

#: ../../library/sqlite3.rst:1241
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in "
":attr:`Cursor.description`."
msgstr ""

#: ../../library/sqlite3.rst:1245
msgid "Added support of slicing."
msgstr "添加了对切片操作的支持。"

#: ../../library/sqlite3.rst:1265
msgid "PrepareProtocol objects"
msgstr ""

#: ../../library/sqlite3.rst:1269
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves "
"<sqlite3-conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:1277
msgid "Exceptions"
msgstr "异常"

#: ../../library/sqlite3.rst:1279
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "异常层次是由 DB-API 2.0 (:pep:`249`) 定义的。"

#: ../../library/sqlite3.rst:1283
msgid ""
"This exception is raised by :mod:`!sqlite3` if an SQL query is not a "
":class:`string <str>`, or if multiple statements are passed to "
":meth:`~Cursor.execute` or :meth:`~Cursor.executemany`. ``Warning`` is a "
"subclass of :exc:`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:1290
msgid ""
"The base class of the other exceptions in this module. Use this to catch all"
" errors with one single :keyword:`except` statement. ``Error`` is a subclass"
" of :exc:`Exception`."
msgstr ""
"本模块中其他异常的基类。使用它来捕捉所有的错误，只需一条 :keyword:`except` 语句。 ``Error`` 是 "
":exc:`Exception` 的子类。"

#: ../../library/sqlite3.rst:1296
msgid ""
"This exception is raised by :mod:`!sqlite3` for fetch across rollback, or if"
" :mod:`!sqlite3` is unable to bind parameters. ``InterfaceError`` is a "
"subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1302
msgid ""
"Exception raised for errors that are related to the database. This serves as"
" the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"对与数据库有关的错误引发的异常。它作为几种数据库错误的基础异常。它只通过专门的子类隐式引发。 ``DatabaseError`` 是 "
":exc:`Error` 的一个子类。"

#: ../../library/sqlite3.rst:1309
msgid ""
"Exception raised for errors caused by problems with the processed data, like"
" numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"由于处理的数据有问题而产生的异常，比如数字值超出范围，字符串太长。 ``DataError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1315
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"与数据库操作有关的错误而引发的异常，不一定在程序员的控制之下。例如，数据库路径没有找到，或者一个事务无法被处理。 "
"``OperationalError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1323
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr "当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1328
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"当 SQLite 遇到一个内部错误时引发的异常。如果它被引发，可能表明运行中的 SQLite 库有问题。  ``InternalError`` 是 "
":exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1335
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"trying to operate on a closed :class:`Connection`, or trying to execute non-"
"DML statements with :meth:`~Cursor.executemany`. ``ProgrammingError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1342
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1352
msgid "SQLite and Python types"
msgstr "SQLite 与 Python 类型"

#: ../../library/sqlite3.rst:1354
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr "SQLite 原生支持如下的类型： ``NULL``，``INTEGER``，``REAL``，``TEXT``，``BLOB``。"

#: ../../library/sqlite3.rst:1357
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "因此可以将以下Python类型发送到SQLite而不会出现任何问题："

#: ../../library/sqlite3.rst:1360 ../../library/sqlite3.rst:1377
msgid "Python type"
msgstr "Python 类型"

#: ../../library/sqlite3.rst:1360 ../../library/sqlite3.rst:1377
msgid "SQLite type"
msgstr "SQLite 类型"

#: ../../library/sqlite3.rst:1362 ../../library/sqlite3.rst:1379
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1362 ../../library/sqlite3.rst:1379
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1364 ../../library/sqlite3.rst:1381
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1364 ../../library/sqlite3.rst:1381
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1366 ../../library/sqlite3.rst:1383
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1366 ../../library/sqlite3.rst:1383
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1368
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1368 ../../library/sqlite3.rst:1385
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1370 ../../library/sqlite3.rst:1388
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1370 ../../library/sqlite3.rst:1388
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1374
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "这是SQLite类型默认转换为Python类型的方式："

#: ../../library/sqlite3.rst:1385
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "取决于 :attr:`~Connection.text_factory` , 默认为 :class:`str` "

#: ../../library/sqlite3.rst:1391
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you"
" can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters "
"<sqlite3-converters>`."
msgstr ""

#: ../../library/sqlite3.rst:1401
msgid "Default adapters and converters"
msgstr "默认适配器和转换器"

#: ../../library/sqlite3.rst:1403
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""
"对于 datetime 模块中的 date 和 datetime 类型已提供了默认的适配器。 它们将会以 ISO 日期/ISO 时间戳的形式发给 "
"SQLite。"

#: ../../library/sqlite3.rst:1406
msgid ""
"The default converters are registered under the name \"date\" for "
":class:`datetime.date` and under the name \"timestamp\" for "
":class:`datetime.datetime`."
msgstr ""
"默认转换器使用的注册名称是针对 :class:`datetime.date` 的 \"date\" 和针对 "
":class:`datetime.datetime` 的 \"timestamp\"。"

#: ../../library/sqlite3.rst:1410
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"通过这种方式，你可以在大多数情况下使用 Python 的 date/timestamp 对象而无须任何额外处理。 适配器的格式还与实验性的 SQLite"
" date/time 函数兼容。"

#: ../../library/sqlite3.rst:1414
msgid "The following example demonstrates this."
msgstr "下面的示例演示了这一点。"

#: ../../library/sqlite3.rst:1418
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers,"
" its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr "如果存储在 SQLite 中的时间戳的小数位多于 6 个数字，则时间戳转换器会将该值截断至微秒精度。"

#: ../../library/sqlite3.rst:1424
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"默认的 \"时间戳\" 转换器忽略了数据库中的 UTC 偏移，总是返回一个原生的 :class:`datetime.datetime` "
"对象。要在时间戳中保留 UTC 偏移，可以不使用转换器，或者用 :func:`register_converter` 注册一个偏移感知的转换器。"

#: ../../library/sqlite3.rst:1433
msgid "How-to guides"
msgstr ""

#: ../../library/sqlite3.rst:1438
msgid "How to use placeholders to bind values in SQL queries"
msgstr ""

#: ../../library/sqlite3.rst:1440
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_ (see the `xkcd webcomic "
"<https://xkcd.com/327/>`_ for a humorous example of what can go wrong)::"
msgstr ""

#: ../../library/sqlite3.rst:1449
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the"
" second argument of the cursor's :meth:`~Cursor.execute` method. An SQL "
"statement may use one of two kinds of placeholders: question marks (qmark "
"style) or named placeholders (named style). For the qmark style, "
"``parameters`` must be a :term:`sequence <sequence>`. For the named style, "
"it can be either a :term:`sequence <sequence>` or :class:`dict` instance. "
"The length of the :term:`sequence <sequence>` must match the number of "
"placeholders, or a :exc:`ProgrammingError` is raised. If a :class:`dict` is "
"given, it must contain keys for all named parameters. Any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"为此，应使用 DB-API 的形参替换。 要将一个变量插入到查询字符串中，请在字符串中放一个占位符，并通过提供包含多个值的 :class:`元组` "
"作为游标的 :meth:`~Cursor.execute` 方法的第二个参数来将实际值替换到查询中。 SQL "
"语句可以使用两种类别的占位符之一：问号占位符（问号风格）或名称占位符（名称风格）。 对于问号风格，``parameters`` 必须是一个 "
":term:`序列 <sequence>`。 对于名称风格，它可以是一个 :term:`序列 <sequence>` 或者 :class:`dict` "
"实例。 :term:`序列 <sequence>` 的长度必须匹配占位符的数量，否则会引发 :exc:`ProgrammingError`。 "
"如果给出的是一个 :class:`dict`，则它必须包含与全部名称形参相对应的键。 任何额外的条目都会被忽略。 下面是一个同时包含这两种风格的例子:"

#: ../../library/sqlite3.rst:1491
msgid "How to adapt custom Python types to SQLite values"
msgstr ""

#: ../../library/sqlite3.rst:1493
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:1497
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""

#: ../../library/sqlite3.rst:1509
msgid "How to write adaptable objects"
msgstr ""

#: ../../library/sqlite3.rst:1511
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""

#: ../../library/sqlite3.rst:1542
msgid "How to register adapter callables"
msgstr ""

#: ../../library/sqlite3.rst:1544
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""

#: ../../library/sqlite3.rst:1574
msgid "How to convert SQLite values to custom Python types"
msgstr ""

#: ../../library/sqlite3.rst:1576
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types,"
" we use *converters*."
msgstr ""

#: ../../library/sqlite3.rst:1581
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1584
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""

#: ../../library/sqlite3.rst:1589
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter"
" the underlying SQLite data type."
msgstr ""

#: ../../library/sqlite3.rst:1598
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""

#: ../../library/sqlite3.rst:1602
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""

#: ../../library/sqlite3.rst:1603
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr ""

#: ../../library/sqlite3.rst:1604
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""

#: ../../library/sqlite3.rst:1608
msgid ""
"The following example illustrates the implicit and explicit approaches:"
msgstr ""

#: ../../library/sqlite3.rst:1659
msgid "Adapter and converter recipes"
msgstr ""

#: ../../library/sqlite3.rst:1661
msgid "This section shows recipes for common adapters and converters."
msgstr ""

#: ../../library/sqlite3.rst:1704
msgid "How to use connection shortcut methods"
msgstr ""

#: ../../library/sqlite3.rst:1706
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and "
":meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the"
" (often superfluous) :class:`Cursor` objects explicitly. Instead, the "
":class:`Cursor` objects are created implicitly and these shortcut methods "
"return the cursor objects. This way, you can execute a ``SELECT`` statement "
"and iterate over it directly using only a single call on the "
":class:`Connection` object."
msgstr ""

#: ../../library/sqlite3.rst:1747
msgid "How to use the connection context manager"
msgstr ""

#: ../../library/sqlite3.rst:1749
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""

#: ../../library/sqlite3.rst:1758
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:1763
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection."
msgstr ""

#: ../../library/sqlite3.rst:1796
msgid "How to work with SQLite URIs"
msgstr ""

#: ../../library/sqlite3.rst:1798
msgid "Some useful URI tricks include:"
msgstr ""

#: ../../library/sqlite3.rst:1800
msgid "Open a database in read-only mode:"
msgstr ""

#: ../../library/sqlite3.rst:1809
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""

#: ../../library/sqlite3.rst:1819
msgid "Create a shared named in-memory database:"
msgstr ""

#: ../../library/sqlite3.rst:1833
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""

#: ../../library/sqlite3.rst:1842
msgid "Explanation"
msgstr "说明"

#: ../../library/sqlite3.rst:1847
msgid "Transaction control"
msgstr ""

#: ../../library/sqlite3.rst:1849
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ""

#: ../../library/sqlite3.rst:1852
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before "
":meth:`~Cursor.execute` and :meth:`~Cursor.executemany` executes ``INSERT``,"
" ``UPDATE``, ``DELETE``, or ``REPLACE`` statements; for other statements, no"
" implicit transaction handling is performed. Use the "
":meth:`~Connection.commit` and :meth:`~Connection.rollback` methods to "
"respectively commit and roll back pending transactions. You can choose the "
"underlying `SQLite transaction behaviour`_ — that is, whether and what type "
"of ``BEGIN`` statements :mod:`!sqlite3` implicitly executes – via the "
":attr:`~Connection.isolation_level` attribute."
msgstr ""

#: ../../library/sqlite3.rst:1865
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the "
":attr:`~Connection.in_transaction` attribute."
msgstr ""

#: ../../library/sqlite3.rst:1873
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""

#: ../../library/sqlite3.rst:1877
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
