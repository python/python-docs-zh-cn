# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`!sqlite3` --- SQLite 数据库的 DB-API 2.0 接口"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**源代码：** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../library/sqlite3.rst:32
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by "
":pep:`249`, and requires SQLite 3.7.15 or newer."
msgstr ""

#: ../../library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr "本文档包括了四个主要部分："

#: ../../library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` 将教你如何使用 :mod:`!sqlite3` 模块。"

#: ../../library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ":ref:`sqlite3-reference` 描述了该模块定义的类与函数。"

#: ../../library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` 详细介绍了如何处理一些特定的任务。"

#: ../../library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ":ref:`sqlite3-explanation` 提供了关于事务控制（transaction control）的更深一步的背景。"

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "学习 SQL 语法的教程、参考和例子。"

#: ../../library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰写。"

#: ../../library/sqlite3.rst:68
msgid "Tutorial"
msgstr "教程"

#: ../../library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"在本篇教程中，你将会使用 :mod:`!sqlite3` 模块的基本功能创建一个存储 Monty Python "
"的电影作品信息的数据库。本篇教程假定您在阅读前对于数据库的基本概念有所了解，例如 `cursors`_  与  `transactions`_  。"

#: ../../library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"首先，我们需要创建一个新的数据库并打开一个数据库连接以允许 :mod:`!sqlite3` 通过它来动作。 调用 "
":func:`sqlite3.connect` 来创建与当前工作目录下 :file:`tutorial.db` "
"数据库的连接，如果它不存在则会隐式地创建它:"

#: ../../library/sqlite3.rst:81
msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"

#: ../../library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to"
" the on-disk database."
msgstr ""
"上面的代码中，返回的 :class:`Connection` 对象 ``con`` 代表一个与在磁盘上的数据库（on-disk databse）的连接。"

#: ../../library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() "
"<Connection.cursor>` to create the :class:`Cursor`:"
msgstr ""
"为了执行 SQL 语句并且从 SQL 查询中取得结果，我们需要使用游标 (cursor) 。在下面的代码中，我们调用函数 "
":meth:`con.cursor() <Connection.cursor>` 创建了一个游标 (:class:`Cursor`) ："

#: ../../library/sqlite3.rst:93
msgid "cur = con.cursor()"
msgstr "cur = con.cursor()"

#: ../../library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration"
" -- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling "
":meth:`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"通过上面的操作，我们已经得到了与数据库的连接 (connection) 与游标 (cursor) ，现在我们便可以在数据库中创建一张名为 "
"``movie`` 的表了，它包括电影名 （title，在下方代码中对应“title”）、上映年份（release "
"year，在下方代码中对应“year”）以及电影评分（review "
"score，在下方代码中对应“score”）这三列。在本篇教程中，出于简洁的考虑，我们在创建表的 SQL 语句声明中只列出表头名 (column "
"names) ，而没有像一般的 SQL 语句那样同时声明数据列的对应数据类型 —— 这一点得益于 SQLite 的 `flexible typing`_"
" 特性，它使得我们在使用 SQLite 时，指明数据类型这一项工作时可选的。如下面的代码所示，我们通过调用函数 "
":meth:`cur.excute(...) <Cursor.execute>` 执行创建表格的 ``CREATE TABLE`` 语句："

#: ../../library/sqlite3.rst:106
msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr "cur.execute(\"CREATE TABLE movie(title, year, score)\")"

#: ../../library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) "
"<Cursor.execute>`, assign the result to ``res``, and call "
":meth:`res.fetchone() <Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"我们可以通过查询 SQLite 内置的 ``sqlite_matser`` 表以验证新表是否已经创建，本例中，此时该表应该已经包括了一条 "
"``movie`` 的表定义（更多内容请参考 `The Schema Table`_ ）。下面的代码将通过调用函数 "
":meth:`cur.excute(...) <Cursor.execute>` 执行查询，把结果赋给 ``res`` ，而后调用 "
":meth:`res.fetchone() <Cursor.fetchone>` 获取结果行："

#: ../../library/sqlite3.rst:121
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"

#: ../../library/sqlite3.rst:127
msgid ""
"We can see that the table has been created, as the query returns a "
":class:`tuple` containing the table's name. If we query ``sqlite_master`` "
"for a non-existent table ``spam``, :meth:`!res.fetchone` will return "
"``None``:"
msgstr ""
"我们可以看到表已被创建，因为查询结果返回了一个包含表名的 :class:`tuple`。 如果我们在 ``sqlite_master`` "
"中查询一个不存在的表 ``spam``，则 :meth:`!res.fetchone` 将返回 ``None``:"

#: ../../library/sqlite3.rst:132
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"

#: ../../library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) "
"<Cursor.execute>`:"
msgstr ""
"现在，让我们再次调用 :meth:`cur.execute(...) <Cursor.execute>` 去添加由 SQL 字面量 (literals)"
" 提供的两行数据："

#: ../../library/sqlite3.rst:142
msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"

#: ../../library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see "
":ref:`sqlite3-controlling-transactions` for details). Call "
":meth:`con.commit() <Connection.commit>` on the connection object to commit "
"the transaction:"
msgstr ""
"``INSERT`` 语句将隐式地创建一个事务 (transaction) ，事务需要在将更改保存到数据库前提交（更多细节请参考 "
":ref:`sqlite3-controlling-transactions` ）。我们通过在一个连接对象（本例中为 ``con``）上调用 "
":meth:`con.commit() <Connection.commit>` 提交事务："

#: ../../library/sqlite3.rst:156
msgid "con.commit()"
msgstr "con.commit()"

#: ../../library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT``"
" query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() "
"<Cursor.fetchall>` to return all resulting rows:"
msgstr ""
"我们可以通过执行一个 ``SELECT`` 查询以验证数据是否被正确地插入表中。下面的代码中，我们使用我们已经很熟悉的函数 "
":meth:`cur.execute(...) <Cursor.execute>` 将查询结果赋给 ``res`` ，而后调用 "
":meth:`res.fetchall() <Cursor.fetchall>` 返回所有的结果行："

#: ../../library/sqlite3.rst:166
msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"

#: ../../library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"上面的代码中，结果是一个包含了两个元组 (:class:`!tuple`) 的列表 (:class:`list`) "
"，其中每一个元组代表一个数据行，每个数据行都包括该行的 ``score`` 值。"

#: ../../library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) "
"<Cursor.executemany>`:"
msgstr "现在，让我们调用 :meth:`cur.executemany(...) <Cursor.executemany>` 再插入三行数据："

#: ../../library/sqlite3.rst:178
msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # 记得在执行 INSERT 之后提交事务。"

#: ../../library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>`"
" to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"请注意，占位符 (placeholders) ``?`` 是用来在查询中绑定数据 ``data`` 的。在绑定 Python 的值到 SQL "
"语句中时，请使用占位符取代格式化字符串 (:ref:`string formatting <tut-formatting>` ) 以避免 `SQL "
"注入攻击`_ （更多细节请参见 :ref:`sqlite3-placeholders` ）。"

#: ../../library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr "同样的，我们可以通过执行 ``SELECT`` 查询验证新的数据行是否已经插入表中，这一次我们将迭代查询的结果："

#: ../../library/sqlite3.rst:198
msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"

#: ../../library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"如上可见，每一行都是包括 ``(year,title)`` 这两个元素的元组 (:class:`tuple` ) ，它与我们查询中选中的数据列相匹配。"

#: ../../library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling "
":meth:`con.close() <Connection.close>` to close the existing connection, "
"opening a new one, creating a new cursor, then querying the database:"
msgstr ""
"最后，让我们先通过调用 :meth:`con.close() <Connection.close>` "
"关闭现存的与数据库的连接，而后打开一个新的连接、创建一个新的游标、执行一个新的查询以验证我们是否将数据库写入到了本地磁盘上："

#: ../../library/sqlite3.rst:216
msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in {year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', released in 1975\n"
">>> new_con.close()"
msgstr ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in {year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', released in 1975\n"
">>> new_con.close()"

#: ../../library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr "现在您已经成功地使用模块 :mod:`!sqlite3` 创建了一个 SQLite 数据库，并且学会了以多种方式往其中插入数据与检索值。"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr "阅读 :ref:`sqlite3-howtos` 以获取更多信息："

#: ../../library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:243
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:244 ../../library/sqlite3.rst:612
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:247
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr "参阅 :ref:`sqlite3-explanation` 以获取关于事务控制的更深一步的背景。"

#: ../../library/sqlite3.rst:252
msgid "Reference"
msgstr "参考"

#: ../../library/sqlite3.rst:260
msgid "Module functions"
msgstr "模块函数"

#: ../../library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr "打开一个与 SQLite 数据库的连接。"

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to"
" create an `SQLite database existing only in memory "
"<https://sqlite.org/inmemorydb.html>`_, and open a connection to it."
msgstr ""
"要撕开的数据库文件的路径。 你可以传入 ``\":memory:\"`` 来创建一个 `仅存在于内存中的 SQLite 数据库 "
"<https://sqlite.org/inmemorydb.html>`_，并打开它的一个连接。"

#: ../../library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an "
":exc:`OperationalError` when a table is locked. If another connection opens "
"a transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"当一个表被锁定时连接在最终引发 :exc:`OperationalError` 之前应该等待多少秒。 "
"如果另一个链接开启了一个事务来修改一个表，该表将被锁定直到该事务完成提交。 默认值为五秒。"

#: ../../library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and "
":const:`PARSE_COLNAMES` to enable this. Column names takes precedence over "
"declared types if both flags are set. By default (``0``), type detection is "
"disabled."
msgstr ""
"控制是否以及如何查找要转换为 Python 类型的非 :ref:`SQLite 原生支持的 <sqlite3-types>` 数据类型，将使用通过 "
":func:`register_converter` 注册的转换器。 将它设置为 :const:`PARSE_DECLTYPES` 和 "
":const:`PARSE_COLNAMES` 的任意组合 (使用 ``|``，即按位或) 来启用此选项。 "
"如果这两个旗标都已设置则列名将优先于声明的类型。 当为默认值 (``0``) 时，类型检测将被禁用。"

#: ../../library/sqlite3.rst:295
msgid ""
"Control legacy transaction handling behaviour. See "
":attr:`Connection.isolation_level` and :ref:`sqlite3-transaction-control-"
"isolation-level` for more information. Can be ``\"DEFERRED\"`` (default), "
"``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable opening "
"transactions implicitly. Has no effect unless :attr:`Connection.autocommit` "
"is set to :const:`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""
"控制旧式的事务处理行为。 更多信息请参阅 :attr:`Connection.isolation_level` 和 "
":ref:`sqlite3-transaction-control-isolation-level`。 可以为 ``\"DEFERRED\"`` "
"(默认值)、``\"EXCLUSIVE\"`` 或 ``\"IMMEDIATE\"``；或者为 ``None`` 表示禁止隐式地开启事务。 除非 "
":attr:`Connection.autocommit` 设为 "
":const:`~sqlite3.LEGACY_TRANSACTION_CONTROL` (默认值) 否则没有任何影响。"

#: ../../library/sqlite3.rst:305
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"如果为 ``True`` (默认)，则 :exc:`ProgrammingError` 将在数据库连接被它的创建者以外的线程使用时被引发。 如果为 "
"``False``，则连接可以在多个线程中被访问；写入操作需要由用户者进行序列化以避免数据损坏。 请参阅 :attr:`threadsafety` "
"了解详情。"

#: ../../library/sqlite3.rst:314
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"如果您不想使用默认的 :class:`Connection` 类创建连接，那么您可以通过传入一个自定义的 :class:`Connection` "
"类的子类给该参数以创建连接。"

#: ../../library/sqlite3.rst:318
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"该参数指明 :mod:`!sqlite3` 模块应该为该连接进行内部缓存的语句 (statements) 数量。默认情况下，它的值为128。"

#: ../../library/sqlite3.rst:323
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"如果将该参数的值设置为 ``True``，参数 *database* 将会被解释为一个由文件路径与可选的查询字符串组成的 :abbr:`URI "
"(Uniform Resource Identifier)` 链接。链接的前缀协议部分 (schema part) *必需* 是 "
"``\"file:\"`` ，后面的文件路径可以是相对路径或绝对路径。查询字符串允许向 SQLite 传递参数，以实现不同的 "
":ref:`sqlite3-uri-tricks`。"

#: ../../library/sqlite3.rst:332
msgid ""
"Control :pep:`249` transaction handling behaviour. See "
":attr:`Connection.autocommit` and :ref:`sqlite3-transaction-control-"
"autocommit` for more information. *autocommit* currently defaults to "
":const:`~sqlite3.LEGACY_TRANSACTION_CONTROL`. The default will change to "
"``False`` in a future Python release."
msgstr ""
"控制 :pep:`249` 事务处理行为。 更多信息参见 :attr:`Connection.autocommit` 和 "
":ref:`sqlite3-transaction-control-autocommit`。 *autocommit* 目前默认值为 "
":const:`~sqlite3.LEGACY_TRANSACTION_CONTROL`。 在未来的 Python 版本中默认值将变为 "
"``False``。"

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "返回类型"

#: ../../library/sqlite3.rst:343
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument"
" ``database``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``sqlite3.connect`` 并附带参数 ``database``。"

#: ../../library/sqlite3.rst:344
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.connect/handle`` 并附带参数 "
"``connection_handle``。"

#: ../../library/sqlite3.rst:346
msgid "Added the *uri* parameter."
msgstr "增加了 *uri* 参数。"

#: ../../library/sqlite3.rst:349
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database* 现在可以是一个 :term:`path-like object` 对象了，而不仅仅是字符串。"

#: ../../library/sqlite3.rst:352
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "增加了 ``sqlite3.connect/handle`` 审计事件。"

#: ../../library/sqlite3.rst:355
msgid "Added the *autocommit* parameter."
msgstr "增加了 *autocommit* 形参。"

#: ../../library/sqlite3.rst:360
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is"
" performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"如果传入的字符串语句 (statement) 看起来像是包括一条或多条完整的 SQL 语句，那么该函数将返回 ``True`` "
"。请注意，除了检查未封闭的字符串字面 (unclosed string literals) 以及语句是否以分号结束外，它不会执行任何的语法检查 "
"(syntactic verification) 与语法解析 (synatatic parsing) 。"

#: ../../library/sqlite3.rst:366
msgid "For example:"
msgstr "例如:"

#: ../../library/sqlite3.rst:368
msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"

#: ../../library/sqlite3.rst:375
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"该函数可能在这样的情形下非常有用：在通过命令行 (command-line) 输入数据时，可使用该函数判断输入文本是否可以构成一个完成的 SQL "
"语句，或者判断在调用函数 :meth:`~Cursor.execute` 前是否还需要额外的输入。"

#: ../../library/sqlite3.rst:379
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr "请参阅 :source:`Lib/sqlite3/__main__.py` 中的 :func:`!runsource` 了解实际使用情况。"

#: ../../library/sqlite3.rst:384
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"是否启用回调回溯 (callback tracebacks) 。默认情况下，在 SQLite 中，您不会在用户定义的函数、聚合函数 "
"(aggregates) 、转换函数 (converters) 、验证回调函数 (authorizer callbacks) "
"等中得到任何回溯信息。如果您想调试它们，您可以在将形式参数 *flag* 设置为 ``True`` 的情况下调用该函数。之后您便可以从 "
":data:`sys.stderr` 的回调中得到回溯信息。使用 ``False`` 将再次禁用该功能。"

#: ../../library/sqlite3.rst:393
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""
"用户自定义函数回调中的错误将被记录为不可引发的异常。 请使用 :func:`不可引发的钩子处理器 <sys.unraisablehook>` "
"执行对失败回调的内省。"

#: ../../library/sqlite3.rst:399
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as"
" its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"注册 *adapter* :term:`callable` 以将 Python 类型 *type* 适配为一个 SQLite 类型。 "
"该适配器在调用时会传入一个 *type* 类型的 Python 对象作为其唯一参数，并且必须返回一个 :ref:`SQLite 原生支持的类型 "
"<sqlite3-types>` 的值。"

#: ../../library/sqlite3.rst:407
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked"
" for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"注册 *converter* :term:`callable` 以将 *typename* 类型的 SQLite 对象转换为一个特定类型的 Python"
" 对象。转换器会针对所有类型为 *typename* 的 SQLite 值唤起；它会传递一个 :class:`bytes` 对象并且应该返回一个所需的 "
"Python 类型的对象。 请参阅 :func:`connect` 的 *detect_types* 形参了解有关类型检测工作方式的详情。"

#: ../../library/sqlite3.rst:415
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr "注：*typename* 以及您在查询中使用的类型名是不大小写敏感的。"

#: ../../library/sqlite3.rst:422
msgid "Module constants"
msgstr "模块常量"

#: ../../library/sqlite3.rst:426
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style "
"(pre-Python 3.12) transaction control behaviour. See "
":ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"将 :attr:`~Connection.autocommit` 设为该常量以选择旧式（Python 3.12 之前）事务控制行为。 更多信息请参阅 "
":ref:`sqlite3-transaction-control-isolation-level`。"

#: ../../library/sqlite3.rst:432
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"将这个旗标值传递给 :func:`connect` 的 *detect_types* "
"形参，以使用创建数据库表时为每列声明的类型的查找转换器函数。:mod:`!sqlite3` "
"将使用声明类型的第一个单词作为转换字典键来查找转换函数。例如："

#: ../../library/sqlite3.rst:440
msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! 将查找名为 \"integer\" 的转换器\n"
"   p point,                ! 将查找名为 \"point\" 的转换器\n"
"   n number(10)            ! 将查找名为 \"number\" 的转换器\n"
" )"

#: ../../library/sqlite3.rst:448
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗标可以使用 ``|`` （位或）运算符与 :const:`PARSE_COLNAMES` 组合。"

#: ../../library/sqlite3.rst:453
msgid ""
"Generated fields (for example ``MAX(p)``) are returned as :class:`str`. Use "
":const:`!PARSE_COLNAMES` to enforce types for such queries."
msgstr ""
"生成的字段 (例如 ``MAX(p)``) 将作为 :class:`str` 返回。 使用 :const:`!PARSE_COLNAMES` "
"为这样的查询设置类型。"

#: ../../library/sqlite3.rst:458
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The query column name must be "
"wrapped in double quotes (``\"``) and the type name must be wrapped in "
"square brackets (``[]``)."
msgstr ""
"将这个旗标值传递给 :func:`connect` 的 *detect_types* "
"形参以使用类型名称来查找转换器函数，类型名称解析自查询列名，将作为转换器字典键。 查询列名必须包装在双引号 (``\"``) "
"中而类型名称必须包装在方括号 (``[]``) 中。"

#: ../../library/sqlite3.rst:465
msgid "SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter \"point\""
msgstr "SELECT MAX(p) as \"p [point]\" FROM test;  ! 将查找转换器 \"point\""

#: ../../library/sqlite3.rst:469
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗标可以使用 ``|`` （位或）运算符与 :const:`PARSE_DECLTYPES` 组合。"

#: ../../library/sqlite3.rst:476
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"应当由传给 :meth:`Connection.set_authorizer` 的 *authorizer_callback* "
":term:`callable` 返回的旗标，用于指明是否:"

#: ../../library/sqlite3.rst:479
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "访问被允许（:const:`!SQLITE_OK`）。"

#: ../../library/sqlite3.rst:480
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "SQL语句伴异常的执行失败（:const:`!SQLITE_DENY`）。"

#: ../../library/sqlite3.rst:481
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr "该列应被视为NULL（:const:`!SQLITE_IGNORE`）。"

#: ../../library/sqlite3.rst:485
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr "指明所支持的 DB-API 级别的字符串常量。 根据 DB-API 的需要设置。 硬编码为 ``\"2.0\"``。"

#: ../../library/sqlite3.rst:490
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr "指明 :mod:`!sqlite3` 模块所预期的形参标记格式化类型。 根据 DB-API 的需要设置。 硬编码为 ``\"qmark\"``。"

#: ../../library/sqlite3.rst:496
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "``named`` DB-API 形参风格也受到支持。"

#: ../../library/sqlite3.rst:500
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr "以 :class:`字符串 <str>` 表示的运行时 SQLite 库版本号。"

#: ../../library/sqlite3.rst:504
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of "
":class:`integers <int>`."
msgstr "以 :class:`整数 <int>` :class:`tuple` 表示的运行时. SQLite 库版本号。"

#: ../../library/sqlite3.rst:509
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"DB-API 2.0 所要求的整数常量，指明 :mod:`!sqlite3` 模块支持的线程安全级别。 该属性将基于编译下层 SQLite "
"库所使用的默认 `线程模式 <https://sqlite.org/threadsafe.html>`_ 来设置。 SQLite 的线程模式有:"

#: ../../library/sqlite3.rst:514
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr "**Single-thread**: 在此模式下，所有的互斥都被禁用并且 SQLite 同时在多个线程中使用将是不安全的。"

#: ../../library/sqlite3.rst:516
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Multi-thread**: 在此模式下，只要单个数据库连接没有被同时用于两个或多个线程之中 SQLite 就可以安全地被多个线程所使用。"

#: ../../library/sqlite3.rst:519
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr "**Serialized**: 在序列化模式下，SQLite 可以安全地被多个线程所使用而没有额外的限制。"

#: ../../library/sqlite3.rst:522
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr "从 SQLite 线程模式到 DB-API 2.0 线程安全级别的映射关系如下:"

#: ../../library/sqlite3.rst:526
msgid "SQLite threading mode"
msgstr "SQLite 线程模式"

#: ../../library/sqlite3.rst:526
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ":pep:`threadsafety <0249#threadsafety>`"

#: ../../library/sqlite3.rst:526
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:526
msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 含义"

#: ../../library/sqlite3.rst:529
msgid "single-thread"
msgstr "single-thread"

#: ../../library/sqlite3.rst:529
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:529
msgid "Threads may not share the module"
msgstr "各个线程不能共享模块"

#: ../../library/sqlite3.rst:532
msgid "multi-thread"
msgstr "multi-thread"

#: ../../library/sqlite3.rst:532 ../../library/sqlite3.rst:535
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:532
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:532
msgid "Threads may share the module, but not connections"
msgstr "线程可以共享模块，但不能共享连接"

#: ../../library/sqlite3.rst:535
msgid "serialized"
msgstr "serialized"

#: ../../library/sqlite3.rst:535
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:535
msgid "Threads may share the module, connections and cursors"
msgstr "线程可以共享模块、连接和游标Threads may share the module, connections and cursors"

#: ../../library/sqlite3.rst:541
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr "动态设置 *threadsafety* 而不是将其硬编码为 ``1``。"

#: ../../library/sqlite3.rst:546
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr "此模块 :class:`字符串 <str>` 形式的版本号。 这不是 SQLite 库的版本号。"

#: ../../library/sqlite3.rst:549 ../../library/sqlite3.rst:559
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to "
":mod:`!sqlite3`. Today, it carries no meaning or practical value."
msgstr ""
"这个常量原本是用于反映 ``pysqlite`` 包的版本号，它是一个用于对 :mod:`!sqlite3` 进行上游修改的第三方库。 "
"如今它已不具任何意义或实用价值。"

#: ../../library/sqlite3.rst:556
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""
"此模块 :class:`整数 <int>` :class:`tuple` 形式的版本号。 这不是 SQLite 库的版本号。library."

#: ../../library/sqlite3.rst:583
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and "
":meth:`~Connection.getconfig` methods."
msgstr ""
"这些常量被用于 :meth:`Connection.setconfig` 和 :meth:`~Connection.getconfig` 方法。"

#: ../../library/sqlite3.rst:586
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr "这些常量的可用性会根据 Python 编译时使用的 SQLite 版本而发生变化。"

#: ../../library/sqlite3.rst:593
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"

#: ../../library/sqlite3.rst:594
msgid "SQLite docs: Database Connection Configuration Options"
msgstr "SQLite 文档：数据库连接配置选项"

#: ../../library/sqlite3.rst:600
msgid "Connection objects"
msgstr "连接对象"

#: ../../library/sqlite3.rst:604
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating "
":class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"每个打开的 SQLite 数据库均以 ``Connection`` 对象来表示，这种对象是使用 :func:`sqlite3.connect` 创建的。"
" 它们的主要目的是创建 :class:`Cursor` 对象，以及 :ref:`sqlite3-controlling-transactions`。"

#: ../../library/sqlite3.rst:611
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:614
msgid ""
"An SQLite database connection has the following attributes and methods:"
msgstr "SQLite 数据库连接对象有如下的属性和方法："

#: ../../library/sqlite3.rst:618
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a "
":term:`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"创建并返回 :class:`Cursor` 对象。 cursor 方法接受一个可选参数 *factory*。 如果提供了这个参数，它必须是一个 "
":term:`callable` 并且返回 :class:`Cursor` 或其子类的实例。"

#: ../../library/sqlite3.rst:625
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr "打开一个已有的 :abbr:`BLOB（二进制大型对象）` :class:`Blob` 句柄。"

#: ../../library/sqlite3.rst:628
msgid "The name of the table where the blob is located."
msgstr "二进制大对象 blob 所在表的名称。"

#: ../../library/sqlite3.rst:631
msgid "The name of the column where the blob is located."
msgstr "二进制大对象 blob 所在表的列名。"

#: ../../library/sqlite3.rst:634
msgid "The name of the row where the blob is located."
msgstr "二进制大对象 blob 所在的列名。"

#: ../../library/sqlite3.rst:637
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr "如果 blob 应当不带写入权限打开则设为 ``True``。 默认为 ``False``。"

#: ../../library/sqlite3.rst:642
msgid ""
"The name of the database where the blob is located. Defaults to "
"``\"main\"``."
msgstr "二进制大对象 blob 所在的数据库名。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "引发"

#: ../../library/sqlite3.rst:646
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "当尝试打开 ``WITHOUT ROWID`` 的表中的某个 blob 时。"

#: ../../library/sqlite3.rst:653
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"blob 的大小无法使用 :class:`Blob` 类来修改。 可使用 SQL 函数 ``zeroblob`` 来创建固定大小的 blob。"

#: ../../library/sqlite3.rst:660
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If "
":attr:`!autocommit` is ``False``, a new transaction is implicitly opened if "
"a pending transaction was committed by this method."
msgstr ""
"向数据库提交任何待处理事务。 如果 :attr:`autocommit` 为 ``True``，或者没有已开启的事务，则此方法不会做任何操作。 如果 "
":attr:`!autocommit` 为 ``False``，则如果有一个待处理事务被此方法提交则会隐式地开启一个新事务。"

#: ../../library/sqlite3.rst:668
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If "
":attr:`!autocommit` is ``False``, a new transaction is implicitly opened if "
"a pending transaction was rolled back by this method."
msgstr ""
"回滚到任何待处理事务的起始位置。 如果 :attr:`autocommit` 为 ``True``，或者没有已开启的事务，则此方法不会做任何操作。 "
"如果:attr:`!autocommit` 为 ``False``，则如果此方法回滚了一个待处理事务则会隐式地开启一个新事务。"

#: ../../library/sqlite3.rst:676
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""
"关闭数据库连接。 如果 :attr:`autocommit` 为 ``False``，则任何待处理事务都会被隐式地回滚。 如果 "
":attr:`!autocommit` 为 ``True`` 或 "
":data:`LEGACY_TRANSACTION_CONTROL`，则不会执行隐式的事务控制。 请确保在关闭之前 :meth:`commit` "
"以避免丢失待处理的更改。"

#: ../../library/sqlite3.rst:686
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.execute`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:692
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.executemany`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:698
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql_script* 调用 "
":meth:`~Cursor.executescript`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:704
msgid "Create or remove a user-defined SQL function."
msgstr "创建或移除用户定义的 SQL 函数。"

#: ../../library/sqlite3.rst:706
msgid "The name of the SQL function."
msgstr "SQL 函数的名称。"

#: ../../library/sqlite3.rst:709
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr "SQL 函数可接受的参数数量，如果是 ``-1``，则该函数可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:713
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite "
"<sqlite3-types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
"当该 SQL 函数被唤起时将会调用的 :term:`callable`。 该可调用对象必须返回 :ref:`一个 SQLite 原生支持的类型 "
"<sqlite3-types>`。 设为 ``None`` 将移除现有的 SQL 函数。"

#: ../../library/sqlite3.rst:720
msgid ""
"If ``True``, the created SQL function is marked as `deterministic "
"<https://sqlite.org/deterministic.html>`_, which allows SQLite to perform "
"additional optimizations."
msgstr ""
"如为 ``True``，创建的 SQL 函数将被标记为 `deterministic "
"<https://sqlite.org/deterministic.html>`_，这允许 SQLite 执行额外的优化。"

#: ../../library/sqlite3.rst:725
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""

#: ../../library/sqlite3.rst:728
msgid "Added the *deterministic* parameter."
msgstr "增加了 *deterministic* 形参。"

#: ../../library/sqlite3.rst:731 ../../library/sqlite3.rst:770
#: ../../library/sqlite3.rst:833 ../../library/sqlite3.rst:1093
#: ../../library/sqlite3.rst:1513 ../../library/sqlite3.rst:1556
msgid "Example:"
msgstr "示例:"

#: ../../library/sqlite3.rst:733
msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"

#: ../../library/sqlite3.rst:748
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "创建或移除用户自定义的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:750
msgid "The name of the SQL aggregate function."
msgstr "SQL 聚合函数的名称。"

#: ../../library/sqlite3.rst:753
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it"
" may take any number of arguments."
msgstr "SQL 聚合函数可接受的参数数量。 如为 ``-1``，则可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:757
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate as"
"   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"一个类必须实现下列方法:  * ``step()``: 向聚合添加一行。 * ``finalize()``: 将聚合的最终结果作为 :ref:`一个 "
"SQLite 原生支持的类型 <sqlite3-types>` 返回。 ``step()`` 方法需要接受的参数数量是由 *n_arg* 控制的。 设为"
" ``None`` 将移除现有的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:758
msgid "A class must implement the following methods:"
msgstr "此类必须实现以下方法："

#: ../../library/sqlite3.rst:760
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: 向聚合添加一行。"

#: ../../library/sqlite3.rst:761 ../../library/sqlite3.rst:817
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: 将聚合的最终结果作为 :ref:`一个 SQLite 原生支持的类型 <sqlite3-types>` 返回。"

#: ../../library/sqlite3.rst:764
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled"
" by *n_arg*."
msgstr "``step()`` 方法所必须接受的参数数量是由 *n_arg* 控制的。"

#: ../../library/sqlite3.rst:767
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "设为 ``None`` 以移除现有的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:772
msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"

#: ../../library/sqlite3.rst:802
msgid "Create or remove a user-defined aggregate window function."
msgstr "创建或移除用户定义的聚合窗口函数。"

#: ../../library/sqlite3.rst:804
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "要创建或移除的 SQL 聚合窗口函数的名称。"

#: ../../library/sqlite3.rst:807
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr "SQL 聚合窗口函数可接受的参数数量。 如为 ``-1``，则可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:811
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that"
" the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"一个必须实现下列方法的类:  * ``step()``: 向当前窗口添加一行。 * ``value()``: 返回聚合的当前值。 * "
"``inverse()``: 从当前窗口移除一行。 * ``finalize()``: 将聚合的最终结果作为 :ref:`一个 SQLite "
"原生支持的类型 <sqlite3-types>` 返回。 ``step()`` 和 ``value()`` 方法需要接受的参数数量是由 "
"*num_params* 控制的。 设为 ``None`` 将移除现有的 SQL 聚合窗口函数。"

#: ../../library/sqlite3.rst:812
msgid "A class that must implement the following methods:"
msgstr "此类必须实现以下方法："

#: ../../library/sqlite3.rst:814
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: 向当前窗口添加一行。"

#: ../../library/sqlite3.rst:815
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: 返回聚合的当前值。"

#: ../../library/sqlite3.rst:816
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: 从当前窗口移除一行。Remove a row from the current window."

#: ../../library/sqlite3.rst:820
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr "``step()`` 和 ``value()`` 方法需要接受的参数数量是由 *num_params* 控制的。"

#: ../../library/sqlite3.rst:823
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr "设为 ``None`` 将移除现有的 SQL 聚合窗口函数。"

#: ../../library/sqlite3.rst:825
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr "如果在早于 SQLite 3.25.0，不支持聚合窗口函数的版本上使用。"

#: ../../library/sqlite3.rst:835
msgid ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"# 来自 https://www.sqlite.org/windowfunctions.html#udfwinfunc 的示例\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"添加一行到当前窗口。\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"返回聚合的当前值。\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"从当前窗口移除一行。\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"返回聚合的最终值。\n"
"\n"
"        任何清理动作都应放在此处。\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:889
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"使用排序函数 *callable* 创建一个名为 *name* 的排序规则。 *callable* 被传递给两个 :class:`字符串 <str>` "
"参数，并且它应该返回一个 :class:`整数 <int>`。"

#: ../../library/sqlite3.rst:893
msgid "``1`` if the first is ordered higher than the second"
msgstr "如果前者的排序高于后者则为 ``1``"

#: ../../library/sqlite3.rst:894
msgid "``-1`` if the first is ordered lower than the second"
msgstr "如果前者的排序低于于后者则为 ``-1``"

#: ../../library/sqlite3.rst:895
msgid "``0`` if they are ordered equal"
msgstr "如果它们的顺序相同则为 ``0``"

#: ../../library/sqlite3.rst:897
msgid "The following example shows a reverse sorting collation:"
msgstr "下面的例子显示了一个反向排序的排序方法:"

#: ../../library/sqlite3.rst:899
msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"

#: ../../library/sqlite3.rst:925
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "通过将 *callable* 设为 ``None`` 来移除一个排序规则函数。"

#: ../../library/sqlite3.rst:927
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr "排序规则的名称可以包含任意 Unicode 字符。 在之前，只允许 ASCII 字符。"

#: ../../library/sqlite3.rst:934
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an "
":exc:`OperationalError`."
msgstr "从其他的线程调用此方法以中止可能正在连接上执行的任何查询。 被中止的查询将引发 :exc:`OperationalError`。"

#: ../../library/sqlite3.rst:941
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or "
":const:`SQLITE_IGNORE` to signal how access to the column should be handled "
"by the underlying SQLite library."
msgstr ""
"注册 :term:`callable` *authorizer_callback* 用于在每次尝试访问数据库中表的某一列时被唤起。 该回调应当返回 "
":const:`SQLITE_OK`、:const:`SQLITE_DENY` 或 :const:`SQLITE_IGNORE` 中的一个以提示下层 "
"SQLite 库应当如何处理对该列的访问。"

#: ../../library/sqlite3.rst:948
msgid ""
"The first argument to the callback signifies what kind of operation is to be"
" authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"该回调的第一个参数指明哪种操作将被授权。 第二个和第三个参数根据第一个参数的具体值将为传给操作的参数或为 ``None``。 "
"第四个参数如果适用则为数据库名称（\"main\", \"temp\" 等）。 "
"第五个参数是负责尝试访问的最内层触发器或视图的名称或者如果该尝试访问是直接来自输入的 SQL 代码的话则为 ``None``。"

#: ../../library/sqlite3.rst:955
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on"
" the first one. All necessary constants are available in the :mod:`!sqlite3`"
" module."
msgstr ""
"请参阅 SQLite 文档了解第一个参数可能的值以及依赖于第一个参数的第二个和第三个参数的含义。 所有必需的常量均在 :mod:`!sqlite3` "
"模块中可用。"

#: ../../library/sqlite3.rst:959
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "将 ``None`` 作为 *authorizer_callback* 传入将禁用授权回调。"

#: ../../library/sqlite3.rst:961
msgid "Added support for disabling the authorizer using ``None``."
msgstr "增加对使用 ``None`` 禁用授权回调的支持。"

#: ../../library/sqlite3.rst:967
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update"
" a GUI."
msgstr ""
"注册 :term:`callable` *progress_handler* 以针对 SQLite 虚拟机的每 *n* 条指令被唤起。 "
"如果你想要在长时间运行的操作，例如更新 GUI 期间获得来自 SQLite 的调用这将很有用处。"

#: ../../library/sqlite3.rst:972
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr "如果你想清除任何先前安装的进度处理器，可在调用该方法时传入 ``None`` 作为 *progress_handler*。"

#: ../../library/sqlite3.rst:975
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr "从处理函数返回非零值将终止当前正在执行的查询并导致它引发 :exc:`DatabaseError` 异常。"

#: ../../library/sqlite3.rst:982
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr "注册 :term:`callable` *trace_callback* 以针对 SQLite 后端实际执行的每条 SQL 语句被唤起。"

#: ../../library/sqlite3.rst:985
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the "
":meth:`Cursor.execute` methods.  Other sources include the :ref:`transaction"
" management <sqlite3-controlling-transactions>` of the :mod:`!sqlite3` "
"module and the execution of triggers defined in the current database."
msgstr ""
"传给该回调的唯一参数是被执行的语句 (作为 :class:`str`)。 回调的返回值将被忽略。 请注意后端不仅会运行传给 "
":meth:`Cursor.execute` 方法的语句。 其他来源还包括 :mod:`!sqlite3` 模块的 :ref:`事务管理 "
"<sqlite3-controlling-transactions>` 以及在当前数据库中定义的触发器的执行。"

#: ../../library/sqlite3.rst:993
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr "传入 ``None`` 作为 *trace_callback* 将禁用追踪回调。"

#: ../../library/sqlite3.rst:996
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development"
" and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to "
"enable printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"在跟踪回调中产生的异常不会被传播。作为开发和调试的辅助手段，使用 :meth:`~sqlite3.enable_callback_tracebacks`"
" 来启用打印跟踪回调中产生的异常的回调。"

#: ../../library/sqlite3.rst:1006
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"如果 *enabled* 为 ``True`` 则允许 SQLite 从共享库加载 SQLite 扩展；否则，不允许加载 SQLite 扩展。 "
"SQLite 扩展可以定义新的函数、聚合或全新的虚拟表实现。 一个知名的扩展是与随同 SQLite 一起分发的全文搜索扩展。"

#: ../../library/sqlite3.rst:1015
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to "
":program:`configure`."
msgstr ""
"在默认情况下 :mod:`!sqlite3` 模块的构建没有附带可加载扩展支持，因为某些平台（主要是 macOS）上的 SQLite "
"库在编译时未启用此特性。 要获得可加载扩展支持，你必须将 :option:`--enable-loadable-sqlite-extensions` "
"选项传给 :program:`configure`。"

#: ../../library/sqlite3.rst:1022
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension``"
" with arguments ``connection``, ``enabled``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.enable_load_extension`` 并附带参数 "
"``connection``, ``enabled``。"

#: ../../library/sqlite3.rst:1026
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "增加了 ``sqlite3.enable_load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:1032
msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""
"con.enable_load_extension(True)\n"
"\n"
"# 加载 fts (fulltext search) 扩展\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# 你也可以使用 API 调用来加载该扩展：\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# 禁止扩展再次加载\n"
"con.enable_load_extension(False)\n"
"\n"
"# 来自 SQLite wiki 的示例\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE name MATCH 'pie'\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1058
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr "从共享库加载 SQLite 扩展。 请在调用此方法前通过 :meth:`enable_load_extension` 来启用扩展加载。"

#: ../../library/sqlite3.rst:1062
msgid "The path to the SQLite extension."
msgstr "SQLite 扩展的路径。"

#: ../../library/sqlite3.rst:1066
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for"
" details."
msgstr ""
"入口点名称。 如果为 ``None`` (默认值)，SQLite 将自行生成入口点名称；请参阅 SQLite 文档 `Loading an "
"Extension`_ 了解详情。"

#: ../../library/sqlite3.rst:1075
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.load_extension`` 并附带参数 ``connection``,"
" ``path``。"

#: ../../library/sqlite3.rst:1079
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "增加了 ``sqlite3.load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:1082
msgid "Added the *entrypoint* parameter."
msgstr "增加了 *entrypoint* 形参。"

#: ../../library/sqlite3.rst:1089
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the "
"``.dump`` command in the :program:`sqlite3` shell."
msgstr ""
"返回一个 :term:`iterator` 用来将数据库转储为 SQL 源代码。 在保存内存数据库以便将来恢复时很有用处。 类似于 "
":program:`sqlite3` shell 中的 ``.dump`` 命令。"

#: ../../library/sqlite3.rst:1095
msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""
"# 将文件 example.db 转换为 SQL 转储文件 dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"

#: ../../library/sqlite3.rst:1106 ../../library/sqlite3.rst:1178
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-howto-encoding`"

#: ../../library/sqlite3.rst:1111
msgid "Create a backup of an SQLite database."
msgstr "创建 SQLite 数据库的备份。"

#: ../../library/sqlite3.rst:1113
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr "即使数据库是通过其他客户端访问或通过同一连接并发访问也是有效的。"

#: ../../library/sqlite3.rst:1116
msgid "The database connection to save the backup to."
msgstr "用于保存备份的数据库连接。"

#: ../../library/sqlite3.rst:1119
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr "每次要拷贝的页数。 如果小于等于 ``0``，则一次性拷贝整个数据库。 默认为 ``-1``。"

#: ../../library/sqlite3.rst:1125
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for"
" every backup iteration: the *status* of the last iteration, the *remaining*"
" number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"如果设为一个 :term:`callable`，它将针对每次备份迭代附带三个整数参数被唤起：上次迭代的状态 *status*，待拷贝的剩余页数 "
"*remaining*，以及总页数 *total*。 默认值为 ``None``。"

#: ../../library/sqlite3.rst:1134
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a"
" custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"要备份的数据库名称。 可能为代表主数据库的 ``\"main\"`` (默认值)，代表临时数据库的 ``\"temp\"``，或者使用 ``ATTACH"
" DATABASE`` SQL 语句所附加的自定义数据库名称。"

#: ../../library/sqlite3.rst:1141
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr "连续尝试备份剩余页所要间隔的休眠秒数。"

#: ../../library/sqlite3.rst:1145
msgid "Example 1, copy an existing database into another:"
msgstr "示例 1，将现有数据库拷贝至另一个数据库:"

#: ../../library/sqlite3.rst:1147
msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"def progress(status, remaining, total):\n"
"    print(f'已复制 {total-remaining} 到 {total} 页……')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1164
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "示例 2，将现有数据库拷贝至一个临时副本:"

#: ../../library/sqlite3.rst:1166
msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1182
msgid "Get a connection runtime limit."
msgstr "获取一个连接的运行时限制。"

#: ../../library/sqlite3.rst:1184
msgid "The `SQLite limit category`_ to be queried."
msgstr "要查询的 `SQLite limit category`_。"

#: ../../library/sqlite3.rst:1189 ../../library/sqlite3.rst:1226
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "如果 *category* 不能被下层的 SQLite 库所识别。"

#: ../../library/sqlite3.rst:1192
msgid ""
"Example, query the maximum length of an SQL statement for "
":class:`Connection` ``con`` (the default is 1000000000):"
msgstr "示例，查询 :class:`Connection` ``con`` 上一条 SQL 语句的最大长度（默认值为 1000000000）:"

#: ../../library/sqlite3.rst:1202
msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"

#: ../../library/sqlite3.rst:1212
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr "设置连接运行时限制。 如果试图将限制提高到超出强制上界则会静默地截短到强制上界。 无论限制值是否被修改，都将返回之前的限制值。"

#: ../../library/sqlite3.rst:1217
msgid "The `SQLite limit category`_ to be set."
msgstr "要设置的 `SQLite limit category`_。"

#: ../../library/sqlite3.rst:1220
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr "新的限制值。 如为负值，当前限制将保持不变。"

#: ../../library/sqlite3.rst:1229
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection`"
" ``con`` (the default limit is 10):"
msgstr "示例，将 :class:`Connection` ``con`` 上附加的数据库数量限制为 1（默认限制为 10）:"

#: ../../library/sqlite3.rst:1232
msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"

#: ../../library/sqlite3.rst:1250
msgid "Query a boolean connection configuration option."
msgstr "查询一个布尔类型的连接配置选项。"

#: ../../library/sqlite3.rst:1252 ../../library/sqlite3.rst:1263
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr "一个 :ref:`SQLITE_DBCONFIG 代码 <sqlite3-dbconfig-constants>`。"

#: ../../library/sqlite3.rst:1261
msgid "Set a boolean connection configuration option."
msgstr "设置一个布尔类型的连接配置选项。"

#: ../../library/sqlite3.rst:1266
msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr "如果该配置选项应当启用则为 ``True`` (默认值)；如果应当禁用则为 ``False``。"

#: ../../library/sqlite3.rst:1274
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an "
"in-memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"将一个数据库序列化为 :class:`bytes` 对象。 对于普通的磁盘数据库文件，序列化就是磁盘文件的一个副本。 "
"对于内存数据库或“临时”数据库，序列化就是当数据库备份到磁盘时要写入到磁盘的相同字节序列。"

#: ../../library/sqlite3.rst:1280
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "要序列化的数据库名称。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:1288
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr "此方法仅在下层 SQLite 库具有序列化 API 时可用。"

#: ../../library/sqlite3.rst:1296
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a "
":class:`Connection`. This method causes the database connection to "
"disconnect from database *name*, and reopen *name* as an in-memory database "
"based on the serialization contained in *data*."
msgstr ""
"将一个 :meth:`已序列化的 <serialize>` 数据库反序列化至 :class:`Connection`。 此方法将导致数据库连接从 "
"*name* 数据库断开，并基于包含在 *data* 中的序列化数据将 *name* 作为内存数据库重新打开。"

#: ../../library/sqlite3.rst:1302
msgid "A serialized database."
msgstr "已序列化的数据库。"

#: ../../library/sqlite3.rst:1305
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr "反序列化的目标数据库名称。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:1309
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr "如果当前数据库连接正在执行读取事务或备份操作。"

#: ../../library/sqlite3.rst:1313
msgid "If *data* does not contain a valid SQLite database."
msgstr "如果 *data* 不包含有效的 SQLite 数据库。"

#: ../../library/sqlite3.rst:1316
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "如果 :func:`len(data) <len>` 大于 ``2**63 - 1``。"

#: ../../library/sqlite3.rst:1321
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr "此方法仅在下层的 SQLite 库具有反序列化 API 时可用。"

#: ../../library/sqlite3.rst:1328
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. "
":attr:`!autocommit` has three allowed values:"
msgstr "该属性控制符合 :pep:`249` 的事务行为。 :attr:`!autocommit` 有三个可用的值:"

#: ../../library/sqlite3.rst:1331
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that "
":mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and"
" :meth:`rollback` to close transactions."
msgstr ""
"``False``: 选择符合 :pep:`249` 的事务行为，即 :mod:`!sqlite3` 将保证总是开启一个事务。 使用 "
":meth:`commit` 和 :meth:`rollback` 来关闭事务。"

#: ../../library/sqlite3.rst:1335
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr "这是 :attr:`!autocommit` 推荐的取值。"

#: ../../library/sqlite3.rst:1337
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and "
":meth:`rollback` have no effect in this mode."
msgstr ""
"``True``: 使用 SQLite 的 `autocommit mode`_。 在此模式下 :meth:`commit` 和 "
":meth:`rollback` 将没有任何效果。"

#: ../../library/sqlite3.rst:1340
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 "
"(non-:pep:`249`-compliant) transaction control. See :attr:`isolation_level` "
"for more details."
msgstr ""
":data:`LEGACY_TRANSACTION_CONTROL`: Python 3.12 之前 (不符合 :pep:`249`) 的事务控制。 "
"请参阅 :attr:`isolation_level` 了解详情。"

#: ../../library/sqlite3.rst:1344
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr "这是 :attr:`!autocommit` 当前的默认值。"

#: ../../library/sqlite3.rst:1346
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""
"将 :attr:`!autocommit` 更改为 ``False`` 将开启一个新事务，而将其更改为 ``True`` 将提交任何待处理事务。"

#: ../../library/sqlite3.rst:1349
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr "详情参见 :ref:`sqlite3-transaction-control-autocommit`。"

#: ../../library/sqlite3.rst:1353
msgid ""
"The :attr:`isolation_level` attribute has no effect unless "
":attr:`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""
"除非 :attr:`autocommit` 为 :data:`LEGACY_TRANSACTION_CONTROL` 否则 "
":attr:`isolation_level` 属性将不起作用。"

#: ../../library/sqlite3.rst:1360
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr "这个只读属性对应于低层级的 SQLite `autocommit mode`_。"

#: ../../library/sqlite3.rst:1363
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr "如果一个事务处于活动状态（有未提交的更改）则为 ``True``，否则为 ``False``。"

#: ../../library/sqlite3.rst:1370
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``,"
" ``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""
"控制 :mod:`!sqlite3` 的 :ref:`旧式事务处理模式 <sqlite3-transaction-control-isolation-"
"level>`。 如果设为 ``None``，则绝不会隐式地开启事务。如果设为 ``\"DEFERRED\"``、``\"IMMEDIATE\"`` 或"
" ``\"EXCLUSIVE\"`` 中的一个，对应于下层的 `SQLite transaction behaviour`_，会执行 "
":ref:`隐式事务管理 <sqlite3-transaction-control-isolation-level>`。"

#: ../../library/sqlite3.rst:1378
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the"
" default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"如果未被 :func:`connect` 的 *isolation_level* 形参覆盖，则默认为 ``\"\"``，这是 "
"``\"DEFERRED\"`` 的一个别名。"

#: ../../library/sqlite3.rst:1383
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over"
" using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""
"建议使用 :attr:`autocommit` 来控制事务处理而不是使用 :attr:`!isolation_level`。 除非 "
":attr:`autocommit` 设为 :data:`LEGACY_TRANSACTION_CONTROL` (默认值) 否则 "
":attr:`!isolation_level` 将不起作用。"

#: ../../library/sqlite3.rst:1390
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the "
":attr:`!row_factory` of existing cursors belonging to this connection, only "
"new ones. Is ``None`` by default, meaning each row is returned as a "
":class:`tuple`."
msgstr ""
"针对从该连接创建的 :class:`Cursor` 对象的初始 :attr:`~Cursor.row_factory`。 "
"为该属性赋值不会影响属于该连接的现有游标的 :attr:`!row_factory`，只影响新的游标。 默认为 ``None``，表示将每一行作为 "
":class:`tuple` 返回。"

#: ../../library/sqlite3.rst:1397 ../../library/sqlite3.rst:1683
#: ../../library/sqlite3.rst:1706
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "详情参见 :ref:`sqlite3-howto-row-factory`。"

#: ../../library/sqlite3.rst:1401
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
"一个接受 :class:`bytes` 形参并返回其文本表示形式的 :term:`callable`。 该可调用对象将针对数据类型为 ``TEXT`` "
"的 SQLite 值被唤起。 在默认情况下，该属性将被设为 :class:`str`。"

#: ../../library/sqlite3.rst:1406
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "请参阅 :ref:`sqlite3-howto-encoding` 了解详情。"

#: ../../library/sqlite3.rst:1410
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr "返回自打开数据库连接以来已修改、插入或删除的数据库行的总数。"

#: ../../library/sqlite3.rst:1417
msgid "Cursor objects"
msgstr "游标对象"

#: ../../library/sqlite3.rst:1419
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute"
" SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the "
":ref:`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"一个代表被用于执行 SQL 语句，并管理获取操作的上下文的 `database cursor`_ 的 ``Cursor`` 对象。 游标对象是使用 "
":meth:`Connection.cursor`，或是通过使用任何 :ref:`连接快捷方法 <sqlite3-connection-"
"shortcuts>` 来创建的。"

#: ../../library/sqlite3.rst:1426
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you "
":meth:`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the "
"cursor to fetch the resulting rows:"
msgstr ""
"Cursor 对象属于 :term:`迭代器 <iterator>`，这意味着如果你通过 :meth:`~Cursor.execute` 来执行 "
"``SELECT`` 查询，你可以简单地迭代游标来获取结果行:"

#: ../../library/sqlite3.rst:1437
msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1451
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 游标实例具有以下属性和方法。"

#: ../../library/sqlite3.rst:1458
msgid ""
"Execute a single SQL statement, optionally binding Python values using "
":ref:`placeholders <sqlite3-placeholders>`."
msgstr "执行一条 SQL 语句，可以选择使用 :ref:`占位符 <sqlite3-placeholders>` 来绑定 Python 值。"

#: ../../library/sqlite3.rst:1462
msgid "A single SQL statement."
msgstr "一条 SQL 语句。"

#: ../../library/sqlite3.rst:1465
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used."
" See :ref:`sqlite3-placeholders`."
msgstr ""
"要绑定到 *sql* 中占位符的 Python 值。 如果使用命名占位符则会使用 :class:`!dict`。 如果使用非命名占位符则会使用 "
":term:`!sequence`。 参见 :ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1472
msgid "If *sql* contains more than one SQL statement."
msgstr "如果 *sql* 包含多条 SQL 语句。"

#: ../../library/sqlite3.rst:1475
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, "
":attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``,"
" ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""
"如果 :attr:`~Connection.autocommit` 为 "
":data:`LEGACY_TRANSACTION_CONTROL`，:attr:`~Connection.isolation_level` 不为 "
"``None``，*sql* 为一条 ``INSERT``, ``UPDATE``, ``DELETE`` 或 ``REPLACE`` "
"语句，并且没有开启事务，则会在执行 *sql* 之前隐式地开启事务。"

#: ../../library/sqlite3.rst:1484
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders "
"<sqlite3-placeholders>` are used and *parameters* is a sequence instead of a"
" :class:`dict`. Starting with Python 3.14, :exc:`ProgrammingError` will be "
"raised instead."
msgstr ""
"如果使用了 :ref:`命名占位符 <sqlite3-placeholders>` 并且 *parameters* 是一个序列而非 "
":class:`dict` 则会发出 :exc:`DeprecationWarning`。 从 Python 3.14 起，将改为引发 "
":exc:`ProgrammingError`。"

#: ../../library/sqlite3.rst:1490
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "使用 :meth:`executescript` 来执行多条 SQL 语句。statements."

#: ../../library/sqlite3.rst:1494
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"对于 *parameters* 中的每一项，重复执行 :ref:`参数化的 <sqlite3-placeholders>` :abbr:`DML "
"(Data Manipulation Language)` SQL 语句 *sql*。"

#: ../../library/sqlite3.rst:1498
msgid ""
"Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr "使用与 :meth:`~Cursor.execute` 相同的隐式事务处理。"

#: ../../library/sqlite3.rst:1500
msgid "A single SQL DML statement."
msgstr "一条 SQL DML 语句。"

#: ../../library/sqlite3.rst:1503
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"一个用来绑定到 *sql* 中的占位符的形参的 :term:`!iterable`。 参见 :ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1509
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr "如果 *sql* 包含多条 SQL 语句，或者不属于 DML 语句。"

#: ../../library/sqlite3.rst:1515
msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur 是一个 sqlite3.Cursor 对象\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"

#: ../../library/sqlite3.rst:1530
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr "任何结果行都将被丢弃，包括带有 `RETURNING 子句`_ 的 DML 语句。"

#: ../../library/sqlite3.rst:1537
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders "
"<sqlite3-placeholders>` are used and the items in *parameters* are sequences"
" instead of :class:`dict`\\s. Starting with Python 3.14, "
":exc:`ProgrammingError` will be raised instead."
msgstr ""
"如果使用了 :ref:`命名占位符 <sqlite3-placeholders>` 并且 *parameters* 中的每个条目都是序列而非 "
":class:`dict` 则会发出 :exc:`DeprecationWarning`。 从 Python 3.14 起，将改为引发 "
":exc:`ProgrammingError`。"

#: ../../library/sqlite3.rst:1546
msgid ""
"Execute the SQL statements in *sql_script*. If the "
":attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and "
"there is a pending transaction, an implicit ``COMMIT`` statement is executed"
" first. No other implicit transaction control is performed; any transaction "
"control must be added to *sql_script*."
msgstr ""
"执行 *sql_script* 中的 SQL 语句。 如果 :attr:`~Connection.autocommit` 为 "
":data:`LEGACY_TRANSACTION_CONTROL` 并且存在待处理的事务，则首先隐式执行一条 ``COMMIT`` 语句。 "
"不会执行其他隐式事务控制；任何事务控制都必须添加至 *sql_script*。"

#: ../../library/sqlite3.rst:1554
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* 必须为 :class:`字符串 <str>`。"

#: ../../library/sqlite3.rst:1558
msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""
"# cur 是一个 sqlite3.Cursor 对象\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"

#: ../../library/sqlite3.rst:1571
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result"
" set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"如果 :attr:`~Cursor.row_factory` 为 ``None``，则将下一行查询结果集作为 :class:`tuple` 返回。 "
"否则，将其传给指定的行工厂函数并返回函数结果。 如果没有更多可用数据则返回 ``None``。"

#: ../../library/sqlite3.rst:1579
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr "将下一个多行查询结果集作为 :class:`list` 返回。 如果没有更多可用行时则返回一个空列表。"

#: ../../library/sqlite3.rst:1582
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"每次调用要获取的行数是由 *size* 形参指定的。 如果未指定 *size*，则由 :attr:`arraysize` 确定要获取的行数。 "
"如果可用的行少于 *size*，则返回可用的行数。"

#: ../../library/sqlite3.rst:1588
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain"
" the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"请注意 *size* 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 *size* "
"形参，则最好在从一个 :meth:`fetchmany` 调用到下一个调用之间保持相同的值。"

#: ../../library/sqlite3.rst:1595
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"将全部（剩余的）查询结果行作为 :class:`list` 返回。 如果没有可用的行则返回空列表。 请注意 :attr:`arraysize` "
"属性可能会影响此操作的性能。"

#: ../../library/sqlite3.rst:1602
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "立即关闭 cursor（而不是在当 ``__del__`` 被调用的时候）。"

#: ../../library/sqlite3.rst:1604
msgid ""
"The cursor will be unusable from this point forward; a "
":exc:`ProgrammingError` exception will be raised if any operation is "
"attempted with the cursor."
msgstr ""
"从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 :exc:`ProgrammingError` 异常。"

#: ../../library/sqlite3.rst:1609 ../../library/sqlite3.rst:1613
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "DB-API 要求的方法。 在 :mod:`!sqlite3` 不做任何事情。"

#: ../../library/sqlite3.rst:1617
msgid ""
"Read/write attribute that controls the number of rows returned by "
":meth:`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr "用于控制 :meth:`fetchmany` 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。"

#: ../../library/sqlite3.rst:1622
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling "
":meth:`con.cursor() <Connection.cursor>` will have a :attr:`connection` "
"attribute that refers to *con*:"
msgstr ""
"提供属于该游标的 SQLite :class:`Connection` 的只读属性。 通过调用 :meth:`con.cursor() "
"<Connection.cursor>` 创建的 :class:`Cursor` 对象将具有一个指向 *con* 的 "
":attr:`connection` 属性:"

#: ../../library/sqlite3.rst:1627
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"

#: ../../library/sqlite3.rst:1637
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"提供上一次查询的列名称的只读属性。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 "
"``None``。"

#: ../../library/sqlite3.rst:1641
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "对于没有任何匹配行的 ``SELECT`` 语句同样会设置该属性。"

#: ../../library/sqlite3.rst:1645
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is"
" only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany`"
" or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"提供上一次插入的行的行 ID 的只读属性。 它只会在使用 :meth:`execute` 方法的 ``INSERT`` 或 ``REPLACE`` "
"语句成功后被更新。 对于其他语句，则在 :meth:`executemany` 或 "
":meth:`executescript`，或者如果插入失败，``lastrowid`` 的值将保持不变。 ``lastrowid`` 的初始值为 "
"``None``。"

#: ../../library/sqlite3.rst:1653
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "对 ``WITHOUT ROWID`` 表的插入不被记录。"

#: ../../library/sqlite3.rst:1655
msgid "Added support for the ``REPLACE`` statement."
msgstr "增加了 ``REPLACE`` 语句的支持。"

#: ../../library/sqlite3.rst:1660
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"提供 ``INSERT``, ``UPDATE``, ``DELETE`` 和 ``REPLACE`` 语句所修改行数的只读属性；对于其他语句则为 "
"``-1``，包括 :abbr:`CTE (Common Table Expression)` 查询。 只有 :meth:`execute` 和 "
":meth:`executemany` 方法会在语句运行完成后更新此属性。 这意味着任何结果行都必须按顺序被提取以使 :attr:`!rowcount`"
" 获得更新。"

#: ../../library/sqlite3.rst:1671
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"控制从该 :class:`!Cursor` 获取的行的表示形式。 如为 ``None``，一行将表示为一个 :class:`tuple`。可设置形式包括"
" :class:`sqlite3.Row`；或者接受两个参数的 :term:`callable`，一个 :class:`Cursor` "
"对象和由行内所有值组成的 :class:`!tuple`，以及返回代表一个 SQLite 行的自定义对象。"

#: ../../library/sqlite3.rst:1678
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the "
":class:`!Cursor` was created. Assigning to this attribute does not affect "
":attr:`Connection.row_factory` of the parent connection."
msgstr ""
"默认为当 :class:`!Cursor` 被创建时设置的 :attr:`Connection.row_factory`。 对该属性赋值不会影响父连接的"
" :attr:`Connection.row_factory`。"

#: ../../library/sqlite3.rst:1694
msgid "Row objects"
msgstr "Row 对象"

#: ../../library/sqlite3.rst:1698
msgid ""
"A :class:`!Row` instance serves as a highly optimized "
":attr:`~Connection.row_factory` for :class:`Connection` objects. It supports"
" iteration, equality testing, :func:`len`, and :term:`mapping` access by "
"column name and index."
msgstr ""
"一个被用作 :class:`Connection` 对象的高度优化的 :attr:`~Connection.row_factory` 的 "
":class:`!Row` 实例。 它支持迭代、相等性检测、:func:`len` 以及基于列名称的 :term:`mapping` 访问和数字序列。"

#: ../../library/sqlite3.rst:1703
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr "两个 :class:`!Row` 对象如果具有相同的列名称和值则比较结果相等。"

#: ../../library/sqlite3.rst:1710
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in "
":attr:`Cursor.description`."
msgstr ""
"在一次查询之后，立即将由列名称组成的 :class:`list` 作为 :class:`字符串 <str>` 返回，它是 "
":attr:`Cursor.description` 中每个元组的第一个成员。"

#: ../../library/sqlite3.rst:1714
msgid "Added support of slicing."
msgstr "添加了对切片操作的支持。"

#: ../../library/sqlite3.rst:1721
msgid "Blob objects"
msgstr "Blob 对象"

#: ../../library/sqlite3.rst:1727
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call "
":func:`len(blob) <len>` to get the size (number of bytes) of the blob. Use "
"indices and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
":class:`Blob` 实例是可以读写 SQLite :abbr:`BLOB (Binary Large OBject)` 数据的 "
":term:`file-like object`。 调用 :func:`len(blob) <len>` 可得到 blob 的大小（字节数）。 "
"请使用索引和 :term:`切片 <slice>` 来直接访问 blob 数据。"

#: ../../library/sqlite3.rst:1732
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr "将 :class:`Blob` 作为 :term:`context manager` 使用以确保使用结束后 blob 句柄自动关闭。"

#: ../../library/sqlite3.rst:1735
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# 写入到我们的 blob，使用两次 write 操作：\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # 修改我们的 blob 的开头和末尾字节\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# 读取我们的 blob 的内容\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # 输出 \"b'Hello, world!'\"\n"
"con.close()"

#: ../../library/sqlite3.rst:1763
msgid "Close the blob."
msgstr "关闭 blob。"

#: ../../library/sqlite3.rst:1765
msgid ""
"The blob will be unusable from this point onward.  An "
":class:`~sqlite3.Error` (or subclass) exception will be raised if any "
"further operation is attempted with the blob."
msgstr ""
"从这一时刻起该 blob 将不再可用。 如果再尝试用该 blob 执行任何操作将引发 :class:`~sqlite3.Error` (或其子类) "
"异常。"

#: ../../library/sqlite3.rst:1771
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If"
" the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, "
":meth:`~Blob.read` will read until the end of the blob."
msgstr ""
"从 blob 的当前偏移位置读取 *length* 个字节的数据。 如果到达了 blob 的末尾，则将返回 :abbr:`EOF (End of "
"File)` 之前的数据。 当未指定 *length*，或指定负值时，:meth:`~Blob.read` 将读取至 blob 的末尾。"

#: ../../library/sqlite3.rst:1779
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change"
" the blob length.  Writing beyond the end of the blob will raise "
":exc:`ValueError`."
msgstr ""
"在 blob 的当前偏移位置上写入 *data*。 此函数不能改变 blob 的长度。 写入数据超出 blob 的末尾将引发 "
":exc:`ValueError`。"

#: ../../library/sqlite3.rst:1785
msgid "Return the current access position of the blob."
msgstr "返回 blob 的当前访问位置。"

#: ../../library/sqlite3.rst:1789
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other"
" values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"将 Blob 的当前访问位置设为 *offset*。 *origin* 参数默认为 :const:`os.SEEK_SET` (blob 的绝对位置)。"
" *origin* 的其他值包括 :const:`os.SEEK_CUR` （相对于当前位置寻址) 和 :const:`os.SEEK_END` "
"(相对于 blob 末尾寻址)。"

#: ../../library/sqlite3.rst:1797
msgid "PrepareProtocol objects"
msgstr "PrepareProtocol 对象"

#: ../../library/sqlite3.rst:1801
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves "
"<sqlite3-conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol 类型的唯一目的是作为 :pep:`246` 风格的适配协议让对象能够 :ref:`将自身适配 "
"<sqlite3-conform>` 为 :ref:`原生 SQLite 类型 <sqlite3-types>`。"

#: ../../library/sqlite3.rst:1809
msgid "Exceptions"
msgstr "异常"

#: ../../library/sqlite3.rst:1811
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "异常层次是由 DB-API 2.0 (:pep:`249`) 定义的。"

#: ../../library/sqlite3.rst:1815
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"目前此异常不会被 :mod:`!sqlite3` 模块引发，但可能会被使用 :mod:`!sqlite3` "
"的应用程序引发，例如当一个用户自定义的函数在插入操作中截断了数据时。 ``Warning`` 是 :exc:`Exception` 的一个子类。"

#: ../../library/sqlite3.rst:1822
msgid ""
"The base class of the other exceptions in this module. Use this to catch all"
" errors with one single :keyword:`except` statement. ``Error`` is a subclass"
" of :exc:`Exception`."
msgstr ""
"本模块中其他异常的基类。使用它来捕捉所有的错误，只需一条 :keyword:`except` 语句。 ``Error`` 是 "
":exc:`Exception` 的子类。"

#: ../../library/sqlite3.rst:1826
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr "如果异常是产生于 SQLite 库的内部，则以下两个属性将被添加到该异常:"

#: ../../library/sqlite3.rst:1831
msgid ""
"The numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr "来自 `SQLite API <https://sqlite.org/rescode.html>`_ 的数字错误代码"

#: ../../library/sqlite3.rst:1838
msgid ""
"The symbolic name of the numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr "来自 `SQLite API <https://sqlite.org/rescode.html>`_ 的数字错误代码符号名称"

#: ../../library/sqlite3.rst:1845
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the "
":mod:`!sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"因错误使用低层级 SQLite C API 而引发的异常，换句话说，如果此异常被引发，则可能表明 :mod:`!sqlite3` 模块中存在错误。 "
"``InterfaceError`` 是 :exc:`Error` 的一个子类。"

#: ../../library/sqlite3.rst:1852
msgid ""
"Exception raised for errors that are related to the database. This serves as"
" the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"对与数据库有关的错误引发的异常。它作为几种数据库错误的基础异常。它只通过专门的子类隐式引发。 ``DatabaseError`` 是 "
":exc:`Error` 的一个子类。"

#: ../../library/sqlite3.rst:1859
msgid ""
"Exception raised for errors caused by problems with the processed data, like"
" numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"由于处理的数据有问题而产生的异常，比如数字值超出范围，字符串太长。 ``DataError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1865
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"与数据库操作有关的错误而引发的异常，不一定在程序员的控制之下。例如，数据库路径没有找到，或者一个事务无法被处理。 "
"``OperationalError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1873
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr "当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1878
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"当 SQLite 遇到一个内部错误时引发的异常。如果它被引发，可能表明运行中的 SQLite 库有问题。  ``InternalError`` 是 "
":exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1885
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a"
" closed :class:`Connection`. ``ProgrammingError`` is a subclass of "
":exc:`DatabaseError`."
msgstr ""
"针对 :mod:`!sqlite3` API 编程错误引发的异常，例如向查询提供错误数量的绑定，或试图在已关闭的 :class:`Connection`"
" 上执行操作。 ``ProgrammingError`` 是 :exc:`DatabaseError` 的一个子类。"

#: ../../library/sqlite3.rst:1892
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"在下层的 SQLite 库不支持某个方法或数据库 API 的情况下引发的异常。 例如，在 "
":meth:`~Connection.create_function` 中把 *deterministic* 设为 ``True``，而下层的 "
"SQLite 库不支持确定性函数的时候。 ``NotSupportedError`` 是 :exc:`DatabaseError` 的一个子类。"

#: ../../library/sqlite3.rst:1902
msgid "SQLite and Python types"
msgstr "SQLite 与 Python 类型"

#: ../../library/sqlite3.rst:1904
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr "SQLite 原生支持如下的类型： ``NULL``，``INTEGER``，``REAL``，``TEXT``，``BLOB``。"

#: ../../library/sqlite3.rst:1907
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "因此可以将以下Python类型发送到SQLite而不会出现任何问题："

#: ../../library/sqlite3.rst:1910 ../../library/sqlite3.rst:1927
msgid "Python type"
msgstr "Python 类型"

#: ../../library/sqlite3.rst:1910 ../../library/sqlite3.rst:1927
msgid "SQLite type"
msgstr "SQLite 类型"

#: ../../library/sqlite3.rst:1912 ../../library/sqlite3.rst:1929
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1912 ../../library/sqlite3.rst:1929
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1914 ../../library/sqlite3.rst:1931
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1914 ../../library/sqlite3.rst:1931
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1916 ../../library/sqlite3.rst:1933
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1916 ../../library/sqlite3.rst:1933
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1918
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1918 ../../library/sqlite3.rst:1935
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1920 ../../library/sqlite3.rst:1938
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1920 ../../library/sqlite3.rst:1938
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1924
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "这是SQLite类型默认转换为Python类型的方式："

#: ../../library/sqlite3.rst:1935
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "取决于 :attr:`~Connection.text_factory` , 默认为 :class:`str`"

#: ../../library/sqlite3.rst:1941
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you"
" can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters "
"<sqlite3-converters>`."
msgstr ""
":mod:`!sqlite3` 模块的类型系统可通过两种方式来扩展：你可以通过 :ref:`对象适配器 <sqlite3-adapters>` 将额外的"
" Python 类型保存在 SQLite 数据库中，你也可以让 :mod:`!sqlite3` 模块通过 :ref:`转换器 "
"<sqlite3-converters>` 将 SQLite 类型转换为不同的 Python 类型。types via."

#: ../../library/sqlite3.rst:1951
msgid "Default adapters and converters (deprecated)"
msgstr "默认适配器和转换器（已弃用）"

#: ../../library/sqlite3.rst:1955
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to"
" your needs."
msgstr ""
"自 Python 3.12 起，默认适配器和转换器已被弃用。取而代之的是使用 :ref:`sqlite3-adapter-converter-"
"recipes` ，并根据您的需要定制它们。"

#: ../../library/sqlite3.rst:1959
msgid "The deprecated default adapters and converters consist of:"
msgstr "弃用的默认适配器和转换器包括："

#: ../../library/sqlite3.rst:1961
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""
"将 :class:`datetime.date` 对象转换为 `ISO 8601`_ 格式 :class:`字符串 <str>` 的适配器。"

#: ../../library/sqlite3.rst:1963
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr "将 :class:`datetime.datetime` 对象转换为 ISO 8601 格式字符串的适配器。"

#: ../../library/sqlite3.rst:1965
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to "
":class:`datetime.date` objects."
msgstr ""
"从 :ref:`已声明的 <sqlite3-converters>` \"date\" 类型到 :class:`datetime.date` "
"对象的转换器。"

#: ../../library/sqlite3.rst:1967
msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""
"将已声明的 \"timestamp\" 类型转成 :class:`datetime.datetime` 对象的转换器。 小数部分将截断至 6 "
"位（微秒精度）。"

#: ../../library/sqlite3.rst:1973
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"默认的 \"时间戳\" 转换器忽略了数据库中的 UTC 偏移，总是返回一个原生的 :class:`datetime.datetime` "
"对象。要在时间戳中保留 UTC 偏移，可以不使用转换器，或者用 :func:`register_converter` 注册一个偏移感知的转换器。"

#: ../../library/sqlite3.rst:1986
msgid "Command-line interface"
msgstr "命令行接口"

#: ../../library/sqlite3.rst:1988
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""
":mod:`!sqlite3` 模块可以作为脚本被唤起，使用解释器的 :option:`-m` 开关选项，以提供一个简单的 SQLite shell。 "
"参数签名如下::"

#: ../../library/sqlite3.rst:1993
msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr "python -m sqlite3 [-h] [-v] [filename] [sql]"

#: ../../library/sqlite3.rst:1995
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr "输入 ``.quit`` 或 CTRL-D 退出 shell。"

#: ../../library/sqlite3.rst:2001
msgid "Print CLI help."
msgstr "打印 CLI 帮助。"

#: ../../library/sqlite3.rst:2005
msgid "Print underlying SQLite library version."
msgstr "打印下层 SQLite 库版本。"

#: ../../library/sqlite3.rst:2013
msgid "How-to guides"
msgstr "常用方案指引"

#: ../../library/sqlite3.rst:2018
msgid "How to use placeholders to bind values in SQL queries"
msgstr "如何在 SQL 查询中使用占位符来绑定值"

#: ../../library/sqlite3.rst:2020
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"SQL 操作通常会需要使用来自 Python 变量的值。 不过，请谨慎使用 Python 的字符串操作来拼装查询，因为这样易受 `SQL "
"injection attacks`_。 例如，攻击者可以简单地添加结束单引号并注入 ``OR TRUE`` 来选择所有的行::"

#: ../../library/sqlite3.rst:2025
msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""
">>> # 绝不要这样做 -- 很不安全！\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"

#: ../../library/sqlite3.rst:2033
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the"
" second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"请改用 DB-API 的形参替换。 要将变量插入到查询字符串中，可在字符串中使用占位符，并通过将实际值作为游标的 "
":meth:`~Cursor.execute` 方法的第二个参数以由多个值组成的 :class:`tuple` 形式提供给查询来替换它们。"

#: ../../library/sqlite3.rst:2038
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"SQL 语句可以使用两种占位符之一：问号占位符（问号风格）或命名占位符（命名风格）。 对于问号风格，*parameters* "
"要是一个长度必须与占位符的数量相匹配的 :term:`sequence`，否则将引发 :exc:`ProgrammingError`。 "
"对于命名风格，*parameters* 必须是 :class:`dict` "
"（或其子类）的实例，它必须包含与所有命名参数相对应的键；任何额外的条目都将被忽略。 下面是一个同时使用这两种风格的示例："

#: ../../library/sqlite3.rst:2049
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# 这是用于 executemany() 的名称风格：\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# 这是用于 SELECT 查询的问号风格：\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:2076
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ":pep:`249` 数字占位符已经 *不再* 被支持。 如果使用，它们将被解读为命名占位符。"

#: ../../library/sqlite3.rst:2083
msgid "How to adapt custom Python types to SQLite values"
msgstr "如何将自定义 Python 类型适配到 SQLite 值"

#: ../../library/sqlite3.rst:2085
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite 仅支持一个原生数据类型的有限集。 要在 SQLite 数据库中存储自定义 Python 类型，请将它们 *适配* 到 "
":ref:`SQLite 原生可识别的 Python 类型 <sqlite3-types>` 之一。"

#: ../../library/sqlite3.rst:2089
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"有两种方式可将 Python 对象适配到 SQLite 类型：让你的对象自行适配，或是使用 *适配器可调用对象*。 后者将优先于前者发挥作用。 "
"对于导出自定义类型的库，启用该类型的自行适配可能更为合理。 而作为一名应用程序开发者，通过注册自定义适配器函数进行直接控制可能更为合理。"

#: ../../library/sqlite3.rst:2101
msgid "How to write adaptable objects"
msgstr "如何编写可适配对象"

#: ../../library/sqlite3.rst:2103
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"假设我们有一个代表笛卡尔坐标系中的坐标值对 :class:`!Point`，``x`` 和 ``y`` 的类，该坐标值在数据库中将存储为一个文本字符串。"
" 这可以通过添加一个返回已适配值的 ``__conform__(self, protocol)`` 方法来实现。 传给 *protocol* 的对象将为"
" :class:`PrepareProtocol` 类型。"

#: ../../library/sqlite3.rst:2111
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2135
msgid "How to register adapter callables"
msgstr "如何注册适配器可调用对象"

#: ../../library/sqlite3.rst:2137
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"另一种可能的方式是创建一个将 Python 对象转换为 SQLite 兼容类型的函数。 随后可使用 :func:`register_adapter` "
"来注册该函数。"

#: ../../library/sqlite3.rst:2141
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2168
msgid "How to convert SQLite values to custom Python types"
msgstr "如何将 SQLite 值转换为自定义 Python 类型"

#: ../../library/sqlite3.rst:2170
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types,"
" we use *converters*."
msgstr ""
"编写适配器使你可以将 *from* 自定义 Python 类型转换为 *to* SQLite 值。 为了能将 *from* SQLite 值转换为 "
"*to* 自定义 Python 类型，我们可使用 *converters*。"

#: ../../library/sqlite3.rst:2175
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr "让我们回到 :class:`!Point` 类。 我们以以分号分隔的字符串形式在 SQLite 中存储了 x 和 y 坐标值。"

#: ../../library/sqlite3.rst:2178
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr "首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 :class:`!Point` 对象。"

#: ../../library/sqlite3.rst:2183
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter"
" the underlying SQLite data type."
msgstr "转换器函数 **总是** 接受传入一个 :class:`bytes` 对象，无论下层的 SQLite 数据类型是什么。"

#: ../../library/sqlite3.rst:2186
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"

#: ../../library/sqlite3.rst:2192
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"我们现在需要告诉 :mod:`!sqlite3` 何时应当转换一个给定的 SQLite 值。 这是在连接到一个数据库时完成的，使用 "
":func:`connect` 的 *detect_types* 形参。 有三个选项:"

#: ../../library/sqlite3.rst:2196
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "隐式: 将 *detect_types* 设为 :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:2197
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "显式: 将 *detect_types* 设为 :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:2198
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"同时: 将 *detect_types* 设为 ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``。 列名的优先级高于声明的类型。"

#: ../../library/sqlite3.rst:2202
msgid ""
"The following example illustrates the implicit and explicit approaches:"
msgstr "下面的示例演示了隐式和显式的方法:"

#: ../../library/sqlite3.rst:2204
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# 注册适配器和转换器\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) 使用声明的类型来解析\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) 使用列名称来解析\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"

#: ../../library/sqlite3.rst:2255
msgid "Adapter and converter recipes"
msgstr "适配器和转换器范例程序"

#: ../../library/sqlite3.rst:2257
msgid "This section shows recipes for common adapters and converters."
msgstr "本小节显示了通用适配器和转换器的范例程序。"

#: ../../library/sqlite3.rst:2259
msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"将 datetime.date 适配为 ISO 8601 日期。\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"将 datetime.datetime 适配为不带时区的 ISO 8601 日期。\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"将 datetime.datetime 适配为 Unix 时间戳。\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"将 ISO 8601 日期转换为 datetime.date 对象。\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"将 ISO 8601 日期时间转换为 datetime.datetime 对象。\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"将 Unix 纪元时间戳转换为 datetime.datetime 对象。\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"

#: ../../library/sqlite3.rst:2319
msgid "How to use connection shortcut methods"
msgstr "如何使用连接快捷方法"

#: ../../library/sqlite3.rst:2321
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and "
":meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the"
" (often superfluous) :class:`Cursor` objects explicitly. Instead, the "
":class:`Cursor` objects are created implicitly and these shortcut methods "
"return the cursor objects. This way, you can execute a ``SELECT`` statement "
"and iterate over it directly using only a single call on the "
":class:`Connection` object."
msgstr ""
"通过使用 :class:`Connection` 类的 :meth:`~Connection.execute`, "
":meth:`~Connection.executemany` 与 :meth:`~Connection.executescript` "
"方法，您可以简化您的代码，因为无需再显式创建 （通常是多余的） :class:`Cursor` 对象。此时 :class:`Cursor` "
"对象会被隐式创建并且由这些快捷方法返回。这样一来，您仅需在 :class:`Connection` 对象上调用一次方法就可以执行 ``SELECT`` "
"语句，并对其进行迭代。"

#: ../../library/sqlite3.rst:2330
msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, \"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""
"# 创建并填充表。\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", data)\n"
"\n"
"# 打印表内容\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, \"rows\")\n"
"\n"
"# close() 不是一个快捷方法也不会被自动调用；\n"
"# 连接对象应当被手动关闭\n"
"con.close()"

#: ../../library/sqlite3.rst:2362
msgid "How to use the connection context manager"
msgstr "如何使用连接上下文管理器"

#: ../../library/sqlite3.rst:2364
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit`"
" is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""
":class:`Connection` 对象可被用作上下文管理器以便在离开上下文管理器代码块时自动提交或回滚开启的事务。 如果 "
":keyword:`with` 语句体无异常地结束，事务将被提交。 如果提交失败，或者如果 ``with`` 语句体引发了未捕获的异常，则事务将被回滚。"
" 如果 :attr:`~Connection.autocommit` 为 ``False``，则会在提交或回滚后隐式地开启一个新事务。"

#: ../../library/sqlite3.rst:2375
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""
"如果在离开 ``with`` 语句体时没有开启的事务，或者如果 :attr:`~Connection.autocommit` 为 "
"``True``，则上下文管理器将不做任何操作。"

#: ../../library/sqlite3.rst:2380
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using "
":meth:`contextlib.closing`."
msgstr ""
"上下文管理器既不会隐式开启新事务也不会关闭连接。 如果你需要关闭上下文管理器，请考虑使用 :meth:`contextlib.closing`。"

#: ../../library/sqlite3.rst:2384
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR UNIQUE)\")\n"
"\n"
"# 成功，con.commit() 将在此后被自动调用\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() 会在 with 代码块结束时被自动调用并附带一个异常；\n"
"# 该异常仍会被引发并且必须被捕获\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# 被用作上下文管理器的连接对象只能提交或回滚事务，\n"
"# 因此连接对象必须被手动关闭\n"
"con.close()"

#: ../../library/sqlite3.rst:2414
msgid "How to work with SQLite URIs"
msgstr "如何使用 SQLite URI"

#: ../../library/sqlite3.rst:2416
msgid "Some useful URI tricks include:"
msgstr "一些有用的 URI 技巧包括:"

#: ../../library/sqlite3.rst:2418
msgid "Open a database in read-only mode:"
msgstr "以只读模式打开一个数据库:"

#: ../../library/sqlite3.rst:2420
msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2428
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"如果一个数据库尚不存在则不会隐式地新建数据库；如果无法新建数据库则将引发 :exc:`~sqlite3.OperationalError`:"

#: ../../library/sqlite3.rst:2431
msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"

#: ../../library/sqlite3.rst:2438
msgid "Create a shared named in-memory database:"
msgstr "创建一个名为 shared 的内存数据库:"

#: ../../library/sqlite3.rst:2440
msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"

#: ../../library/sqlite3.rst:2454
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr "关于此特性的更多信息，包括可用的形参列表，可以在 `SQLite URI documentation`_ 中找到。"

#: ../../library/sqlite3.rst:2463
msgid "How to create and use row factories"
msgstr "如何创建并使用行工厂对象"

#: ../../library/sqlite3.rst:2465
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a "
":class:`!tuple` does not suit your needs, you can use the "
":class:`sqlite3.Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"在默认情况下，:mod:`!sqlite3` 会以 :class:`tuple` 来表示每一行。 如果 :class:`!tuple` "
"不适合你的需求，你可以使用 :class:`sqlite3.Row` 类或自定义的 :attr:`~Cursor.row_factory`。"

#: ../../library/sqlite3.rst:2470
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the "
":class:`Cursor` and the :class:`Connection`, it is recommended to set "
":class:`Connection.row_factory`, so all cursors created from the connection "
"will use the same row factory."
msgstr ""
"虽然 :attr:`!row_factory` 同时作为 :class:`Cursor` 和 :class:`Connection` "
"的属性存在，但推荐设置 :class:`Connection.row_factory`，这样在该连接上创建的所有游标都将使用同一个行工厂对象。"

#: ../../library/sqlite3.rst:2475
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns,"
" with minimal memory overhead and performance impact over a :class:`!tuple`."
" To use :class:`!Row` as a row factory, assign it to the "
":attr:`!row_factory` attribute:"
msgstr ""
":class:`!Row` 提供了针对列的序列方式和大小写不敏感的名称方式访问，具有优于 :class:`!tuple` 的最小化内存开销和性能影响。 "
"要使用 :class:`!Row` 作为行工厂对象，请将其赋值给 :attr:`!row_factory` 属性:"

#: ../../library/sqlite3.rst:2480
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"

#: ../../library/sqlite3.rst:2485
msgid "Queries now return :class:`!Row` objects:"
msgstr "现在查询将返回 :class:`!Row` 对象:"

#: ../../library/sqlite3.rst:2487
msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # 通过索引访问。\n"
"'Earth'\n"
">>> row[\"name\"]    # 通过名称访问。\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # 列名不区分大小写。\n"
"6378\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2503
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"``FROM`` 子句可以在 ``SELECT`` 语句中省略，像在上面的示例中那样。 在这种情况下，SQLite "
"将返回单独的行，其中的列由表达式来定义，例如使用字面量并给出相应的别名 ``expr AS alias``。"

#: ../../library/sqlite3.rst:2508
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as"
" a :class:`dict`, with column names mapped to values:"
msgstr ""
"你可以创建自定义 :attr:`~Cursor.row_factory` 用来返回 :class:`dict` 形式的行，将列名映射到相应的值。"

#: ../../library/sqlite3.rst:2511
msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"

#: ../../library/sqlite3.rst:2517
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr "使用它，现在查询将返回 :class:`!dict` 而不是 :class:`!tuple`:"

#: ../../library/sqlite3.rst:2519
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2528
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "以下行工厂函数将返回一个 :term:`named tuple`:"

#: ../../library/sqlite3.rst:2530
msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"

#: ../../library/sqlite3.rst:2539
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` 可以像下面这样使用:"

#: ../../library/sqlite3.rst:2541
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # 索引访问。\n"
"1\n"
">>> row.b   # 属性访问。\n"
"2\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2555
msgid ""
"With some adjustments, the above recipe can be adapted to use a "
":class:`~dataclasses.dataclass`, or any other custom class, instead of a "
":class:`~collections.namedtuple`."
msgstr ""
"经过一些调整，上面的范例程序可以被适配为使用 :class:`~dataclasses.dataclass`，或任何其他自定义类，而不是 "
":class:`~collections.namedtuple`。"

#: ../../library/sqlite3.rst:2563
msgid "How to handle non-UTF-8 text encodings"
msgstr "如何处理非 UTF-8 文本编码格式"

#: ../../library/sqlite3.rst:2565
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might"
" fail for other encodings and invalid UTF-8. You can use a custom "
":attr:`~Connection.text_factory` to handle such cases."
msgstr ""
"在默认情况下，:mod:`!sqlite3` 使用 :class:`str` 来适配 ``TEXT`` 数据类型的 SQLite 值。 这对 UTF-8"
" 编码的文本来说很适用，但对于其他编码格式和无效的 UTF-8 来说则可能出错。 你可以使用自定义的 "
":attr:`~Connection.text_factory` 来处理这种情况。"

#: ../../library/sqlite3.rst:2571
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or"
" even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance "
":py:data:`!con` connected to this database, we can decode the Latin-2 "
"encoded text using this :attr:`~Connection.text_factory`:"
msgstr ""
"由于 SQLite 的 `flexible typing`_，遇到包含非 UTF-8 编码格式的 ``TEXT`` "
"数据类型甚至任意数据的表字段的情况并不少见。 作为演示，让我们假定有一个使用 ISO-8859-2 (Latin-2) "
"编码的文本的数据库，例如一个捷克语-英语字典条目的表。 假定我们现在有一个 :class:`Connection` 实例 :py:data:`!con`"
" 已连接到这个数据库，我们将可以使用这个 :attr:`~Connection.text_factory` 来解码使用 Latin-2 编码的文本："

#: ../../library/sqlite3.rst:2580
msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr "con.text_factory = lambda data: str(data, encoding=\"latin2\")"

#: ../../library/sqlite3.rst:2584
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you"
" can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"对于存储在 ``TEXT`` 表字段中的无效 UTF-8 或任意数据，你可以使用以下技巧，借用自 :ref:`unicode-howto`:"

#: ../../library/sqlite3.rst:2587
msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"

#: ../../library/sqlite3.rst:2593
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ":mod:`!sqlite3` 模块 API 不支持包含替代符的字符串。"

#: ../../library/sqlite3.rst:2598
msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

#: ../../library/sqlite3.rst:2604
msgid "Explanation"
msgstr "说明"

#: ../../library/sqlite3.rst:2610
msgid "Transaction control"
msgstr "事务控制"

#: ../../library/sqlite3.rst:2612
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how"
" database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""
":mod:`!sqlite3` 提供了多个方法来控制在何时以及怎样控制数据库事务的开启和关闭。 推荐使用 "
":ref:`sqlite3-transaction-control-autocommit` ，而 :ref:`sqlite3-transaction-"
"control-isolation-level` 则保留了 Python 3.12 之前的行为。"

#: ../../library/sqlite3.rst:2621
msgid "Transaction control via the ``autocommit`` attribute"
msgstr "通过 ``autocommit`` 属性进行事务控制"

#: ../../library/sqlite3.rst:2623
msgid ""
"The recommended way of controlling transaction behaviour is through the "
":attr:`Connection.autocommit` attribute, which should preferably be set "
"using the *autocommit* parameter of :func:`connect`."
msgstr ""
"控制事务行为的推荐方式是通过 :attr:`Connection.autocommit` 属性，最好是使用 :func:`connect` 的 "
"*autocommit* 形参来设置该属性。"

#: ../../library/sqlite3.rst:2628
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies "
":pep:`249`-compliant transaction control. This means:"
msgstr "建议将 *autocommit* 设为 ``False``，表示使用兼容 :pep:`249` 的事务控制。 这意味着："

#: ../../library/sqlite3.rst:2632
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so "
":func:`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` "
"will implicitly open a new transaction (immediately after closing the "
"pending one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` "
"statements when opening transactions."
msgstr ""
":mod:`!sqlite3` 会确保事务始终处于开启状态，因此 :func:`connect` 、:meth:`Connection.commit` "
"和 :meth:`Connection.rollback` 将隐式地开启一个新事务（对于后两者，在关闭待处理事务后会立即执行）。 开启事务时 "
":mod:`!sqlite3` 会使用 ``BEGIN DEFERRED`` 语句。"

#: ../../library/sqlite3.rst:2637
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr "事务应当显式地使用 :meth:`!commit` 执行提交。"

#: ../../library/sqlite3.rst:2638
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr "事务应当显式地使用 :meth:`!rollback` 执行回滚。"

#: ../../library/sqlite3.rst:2639
msgid ""
"An implicit rollback is performed if the database is "
":meth:`~Connection.close`-ed with pending changes."
msgstr "如果数据库执行 :meth:`~Connection.close` 时有待处理的更改则会隐式地执行回滚。"

#: ../../library/sqlite3.rst:2642
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the "
":pep:`249`-compliant :attr:`Connection.autocommit` attribute; use "
":attr:`Connection.in_transaction` to query the low-level SQLite autocommit "
"mode."
msgstr ""
"将 *autocommit* 设为 ``True`` 以启用 SQLite 的 `autocommit mode`_。 "
"在此模式下，:meth:`Connection.commit` 和 :meth:`Connection.rollback` 将没有任何作用。 请注意 "
"SQLite 的自动提交模式与兼容 :pep:`249` 的 :attr:`Connection.autocommit` 属性不同；请使用 "
":attr:`Connection.in_transaction` 查询底层的 SQLite 自动提交模式。"

#: ../../library/sqlite3.rst:2650
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See "
":ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"将 *autocommit* 设为 :data:`LEGACY_TRANSACTION_CONTROL` 以将事务控制行为保留给 "
":attr:`Connection.isolation_level` 属性。 更多信息参见 :ref:`sqlite3-transaction-"
"control-isolation-level`。"

#: ../../library/sqlite3.rst:2659
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr "通过 ``isolation_level`` 属性进行事务控制"

#: ../../library/sqlite3.rst:2663
msgid ""
"The recommended way of controlling transactions is via the "
":attr:`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-"
"control-autocommit`."
msgstr ""
"推荐的控制事务方式是通过 :attr:`~Connection.autocommit` 属性。 参见 "
":ref:`sqlite3-transaction-control-autocommit`。"

#: ../../library/sqlite3.rst:2667
msgid ""
"If :attr:`Connection.autocommit` is set to "
":data:`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""
"如果 :attr:`Connection.autocommit` 被设为 :data:`LEGACY_TRANSACTION_CONTROL` "
"(默认值)，则事务行为由 :attr:`Connection.isolation_level` 属性控制。 "
"否则，:attr:`!isolation_level` 将没有任何作用。"

#: ../../library/sqlite3.rst:2673
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before "
":meth:`~Cursor.execute` and :meth:`~Cursor.executemany` executes ``INSERT``,"
" ``UPDATE``, ``DELETE``, or ``REPLACE`` statements; for other statements, no"
" implicit transaction handling is performed. Use the "
":meth:`~Connection.commit` and :meth:`~Connection.rollback` methods to "
"respectively commit and roll back pending transactions. You can choose the "
"underlying `SQLite transaction behaviour`_ — that is, whether and what type "
"of ``BEGIN`` statements :mod:`!sqlite3` implicitly executes – via the "
":attr:`~Connection.isolation_level` attribute."
msgstr ""
"如果连接的属性 :attr:`~Connection.isolation_level` 不为 ``None``，新的事务会在 "
":meth:`~Cursor.execute` 和 :meth:`~Cursor.executemany` 执行 ``INSERT``, "
"``UPDATE``, ``DELETE`` 或 ``REPLACE`` 语句之前隐式地开启；对于其他语句，则不会执行隐式的事务处理。 可分别使用 "
":meth:`~Connection.commit` 和 :meth:`~Connection.rollback` 方法提交和回滚未应用的事务。 "
"你可以通过 :attr:`~Connection.isolation_level` 属性来选择下层的 `SQLite transaction "
"behaviour`_ — 也就是说，:mod:`!sqlite3` 是否要隐式地执行以及执行何种类型的 ``BEGIN`` 语句"

#: ../../library/sqlite3.rst:2686
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the "
":attr:`~Connection.in_transaction` attribute."
msgstr ""
"如果 :attr:`~Connection.isolation_level` 被设为 ``None``，则完全不会隐式地开启任何事务。 这将使下层 "
"SQLite 库处于 `自动提交模式`_，但也允许用户使用显式 SQL 语句执行他们自己的事务处理。 下层 SQLite 库的自动提交模式可使用 "
":attr:`~Connection.in_transaction` 属性来查询。"

#: ../../library/sqlite3.rst:2694
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
":meth:`~Cursor.executescript` 方法会在执行给定的 SQL 脚本之前隐式地提交任何挂起的事务，无论 "
":attr:`~Connection.isolation_level` 的值是什么。"

#: ../../library/sqlite3.rst:2698
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr "在以前 :mod:`!sqlite3` 会在 DDL 语句之前隐式地提交已开启的事务。 现存则不会再这样做。"

#: ../../library/sqlite3.rst:2702
msgid ""
"The recommended way of controlling transactions is now via the "
":attr:`~Connection.autocommit` attribute."
msgstr "现在推荐的控制事务方式是通过 :attr:`~Connection.autocommit` 属性。"

#: ../../library/sqlite3.rst:1453
msgid "? (question mark)"
msgstr "? (问号)"

#: ../../library/sqlite3.rst:1453 ../../library/sqlite3.rst:1454
msgid "in SQL statements"
msgstr "在 SQL 语句中"

#: ../../library/sqlite3.rst:1454
msgid ": (colon)"
msgstr ": (冒号)"
