# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-26 16:43+0000\n"
"PO-Revision-Date: 2023-05-24 02:19+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- SQLite 数据库 DB-API 2.0 接口模块"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**源代码：** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can"
" use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as"
" PostgreSQL or Oracle."
msgstr ""
"SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL "
"查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 "
"PostgreSQL 或 Oracle。"

#: ../../library/sqlite3.rst:30
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by "
":pep:`249`, and requires SQLite 3.7.15 or newer."
msgstr ""
":mod:`!sqlite3` 模块由Gerhard Häring编写。它提供了 :pep:`249` 所描述的符合 DB-API 2.0 规范的 "
"SQL 接口，并要求使用 SQLite 3.7.15 或更新的版本。"

#: ../../library/sqlite3.rst:34
msgid "This document includes four main sections:"
msgstr "本文档包括了四个主要部分："

#: ../../library/sqlite3.rst:36
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` 将教你如何使用 :mod:`!sqlite3` 模块。"

#: ../../library/sqlite3.rst:37
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ":ref:`sqlite3-reference` 描述了该模块定义的类与函数。"

#: ../../library/sqlite3.rst:39
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` 详细介绍了如何处理一些特定的任务。"

#: ../../library/sqlite3.rst:40
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ":ref:`sqlite3-explanation` 提供了关于事务控制（transaction control）的更深一步的背景。"

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。"

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "学习 SQL 语法的教程、参考和例子。"

#: ../../library/sqlite3.rst:52
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - DB-API 2.0 规范"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰写。"

#: ../../library/sqlite3.rst:66
msgid "Tutorial"
msgstr "教程"

#: ../../library/sqlite3.rst:68
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"在本篇教程中，你将会使用 :mod:`!sqlite3` 模块的基本功能创建一个存储 Monty Python "
"的电影作品信息的数据库。本篇教程假定您在阅读前对于数据库的基本概念有所了解，例如 `cursors`_  与  `transactions`_  。"

#: ../../library/sqlite3.rst:73
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"首先，我们需要创建一个新的数据库并打开一个数据库连接以允许 :mod:`!sqlite3` 通过它来动作。 调用 "
":func:`sqlite3.connect` 来创建与当前工作目录下 :file:`tutorial.db` "
"数据库的连接，如果它不存在则会隐式地创建它:"

#: ../../library/sqlite3.rst:84
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to"
" the on-disk database."
msgstr ""
"上面的代码中，返回的 :class:`Connection` 对象 ``con`` 代表一个与在磁盘上的数据库（on-disk databse）的连接。"

#: ../../library/sqlite3.rst:87
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() "
"<Connection.cursor>` to create the :class:`Cursor`:"
msgstr ""
"为了执行 SQL 语句并且从 SQL 查询中取得结果，我们需要使用游标 (cursor) 。在下面的代码中，我们调用函数 "
":meth:`con.cursor() <Connection.cursor>` 创建了一个游标 (:class:`Cursor`) ："

#: ../../library/sqlite3.rst:95
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration"
" -- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling "
":meth:`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"通过上面的操作，我们已经得到了与数据库的连接 (connection) 与游标 (cursor) ，现在我们便可以在数据库中创建一张名为 "
"``movie`` 的表了，它包括电影名 （title，在下方代码中对应“title”）、上映年份（release "
"year，在下方代码中对应“year”）以及电影评分（review "
"score，在下方代码中对应“score”）这三列。在本篇教程中，出于简洁的考虑，我们在创建表的 SQL 语句声明中只列出表头名 (column "
"names) ，而没有像一般的 SQL 语句那样同时声明数据列的对应数据类型 —— 这一点得益于 SQLite 的 `flexible typing`_"
" 特性，它使得我们在使用 SQLite 时，指明数据类型这一项工作时可选的。如下面的代码所示，我们通过调用函数 "
":meth:`cur.excute(...) <Cursor.execute>` 执行创建表格的 ``CREATE TABLE`` 语句："

#: ../../library/sqlite3.rst:111
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) "
"<Cursor.execute>`, assign the result to ``res``, and call "
":meth:`res.fetchone() <Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"我们可以通过查询 SQLite 内置的 ``sqlite_matser`` 表以验证新表是否已经创建，本例中，此时该表应该已经包括了一条 "
"``movie`` 的表定义（更多内容请参考 `The Schema Table`_ ）。下面的代码将通过调用函数 "
":meth:`cur.excute(...) <Cursor.execute>` 执行查询，把结果赋给 ``res`` ，而后调用 "
":meth:`res.fetchone() <Cursor.fetchone>` 获取结果行："

#: ../../library/sqlite3.rst:125
msgid ""
"We can see that the table has been created, as the query returns a "
":class:`tuple` containing the table's name. If we query ``sqlite_master`` "
"for a non-existent table ``spam``, :meth:`!res.fetchone()` will return "
"``None``:"
msgstr ""
"在上面的代码中，我们可以看到表格已经被创建，因为查询结果返回了一个包含表格名的元组 (:class:`tuple`) 。倘若我们在 "
"``sqlite_master`` 表中查询一个并不存在的表 ``spam`` ，那么 :meth:`!res.fetchone()` 将会返回 "
"``None`` ："

#: ../../library/sqlite3.rst:136
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) "
"<Cursor.execute>`:"
msgstr ""
"现在，让我们再次调用 :meth:`cur.execute(...) <Cursor.execute>` 去添加由 SQL 字面量 (literals)"
" 提供的两行数据："

#: ../../library/sqlite3.rst:148
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see "
":ref:`sqlite3-controlling-transactions` for details). Call "
":meth:`con.commit() <Connection.commit>` on the connection object to commit "
"the transaction:"
msgstr ""
"``INSERT`` 语句将隐式地创建一个事务 (transaction) ，事务需要在将更改保存到数据库前提交（更多细节请参考 "
":ref:`sqlite3-controlling-transactions` ）。我们通过在一个连接对象（本例中为 ``con``）上调用 "
":meth:`con.commit() <Connection.commit>` 提交事务："

#: ../../library/sqlite3.rst:158
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT``"
" query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() "
"<Cursor.fetchall>` to return all resulting rows:"
msgstr ""
"我们可以通过执行一个 ``SELECT`` 查询以验证数据是否被正确地插入表中。下面的代码中，我们使用我们已经很熟悉的函数 "
":meth:`cur.execute(...) <Cursor.execute>` 将查询结果赋给 ``res`` ，而后调用 "
":meth:`res.fetchall() <Cursor.fetchall>` 返回所有的结果行："

#: ../../library/sqlite3.rst:170
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"上面的代码中，结果是一个包含了两个元组 (:class:`!tuple`) 的列表 (:class:`list`) "
"，其中每一个元组代表一个数据行，每个数据行都包括该行的 ``score`` 值。"

#: ../../library/sqlite3.rst:173
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) "
"<Cursor.executemany>`:"
msgstr "现在，让我们调用 :meth:`cur.executemany(...) <Cursor.executemany>` 再插入三行数据："

#: ../../library/sqlite3.rst:186
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>`"
" to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"请注意，占位符 (placeholders) ``?`` 是用来在查询中绑定数据 ``data`` 的。在绑定 Python 的值到 SQL "
"语句中时，请使用占位符取代格式化字符串 (:ref:`string formatting <tut-formatting>` ) 以避免 `SQL "
"注入攻击`_ （更多细节请参见 :ref:`sqlite3-placeholders` ）。"

#: ../../library/sqlite3.rst:192
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr "同样的，我们可以通过执行 ``SELECT`` 查询验证新的数据行是否已经插入表中，这一次我们将迭代查询的结果："

#: ../../library/sqlite3.rst:206
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"如上可见，每一行都是包括 ``(year,title)`` 这两个元素的元组 (:class:`tuple` ) ，它与我们查询中选中的数据列相匹配。"

#: ../../library/sqlite3.rst:209
msgid ""
"Finally, verify that the database has been written to disk by calling "
":meth:`con.close() <Connection.close>` to close the existing connection, "
"opening a new one, creating a new cursor, then querying the database:"
msgstr ""
"最后，让我们先通过调用 :meth:`con.close() <Connection.close>` "
"关闭现存的与数据库的连接，而后打开一个新的连接、创建一个新的游标、执行一个新的查询以验证我们是否将数据库写入到了本地磁盘上："

#: ../../library/sqlite3.rst:224
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr "现在您已经成功地使用模块 :mod:`!sqlite3` 创建了一个 SQLite 数据库，并且学会了以多种方式往其中插入数据与检索值。"

#: ../../library/sqlite3.rst:236
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr "阅读 :ref:`sqlite3-howtos` 以获取更多信息："

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:558
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:244
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr "参阅 :ref:`sqlite3-explanation` 以获取关于事务控制的更深一步的背景。"

#: ../../library/sqlite3.rst:249
msgid "Reference"
msgstr "参考"

#: ../../library/sqlite3.rst:257
msgid "Module functions"
msgstr "模块函数"

#: ../../library/sqlite3.rst:264
msgid "Open a connection to an SQLite database."
msgstr "打开一个与 SQLite 数据库的连接。"

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/sqlite3.rst:266
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to"
" create an `SQLite database existing only in memory "
"<https://sqlite.org/inmemorydb.html>`_, and open a connection to it."
msgstr ""
"要撕开的数据库文件的路径。 你可以传入 ``\":memory:\"`` 来创建一个 `仅存在于内存中的 SQLite 数据库 "
"<https://sqlite.org/inmemorydb.html>`_，并打开它的一个连接。"

#: ../../library/sqlite3.rst:273
msgid ""
"How many seconds the connection should wait before raising an "
":exc:`OperationalError` when a table is locked. If another connection opens "
"a transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"当一个表被锁定时连接在最终引发 :exc:`OperationalError` 之前应该等待多少秒。 "
"如果另一个链接开启了一个事务来修改一个表，该表将被锁定直到该事务完成提交。 默认值为五秒。"

#: ../../library/sqlite3.rst:280
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and "
":const:`PARSE_COLNAMES` to enable this. Column names takes precedence over "
"declared types if both flags are set. Types cannot be detected for generated"
" fields (for example ``max(data)``), even when the *detect_types* parameter "
"is set; :class:`str` will be returned instead. By default (``0``), type "
"detection is disabled."
msgstr ""
"控制是否以及如何使用由 :func:`register_converter` 注册的转换器将并非由 :ref:`SQLite 原生支持的 "
"<sqlite3-types>` 数据类型转换为 Python 类型。 将它设置为 :const:`PARSE_DECLTYPES` 和 "
":const:`PARSE_COLNAMES` 的任意组合 (使用 ``|``，即按位或) 来启动它。 如果两个旗标都被设置则列名将优先于声明的类型。 "
"即使设置了 *detect_types*，依然无法对生成的字段 (例如 ``max(data)``) 进行类型检测；此时它将改为返回 "
":class:`str`。 当使用默认值 (``0``) 时，类型检测将被禁用。"

#: ../../library/sqlite3.rst:294
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions`"
" for more."
msgstr ""
"该参数代表数据库连接的事务控制级别 (:attr:`~Connection.isolation_level`)，它将控制数据库事务是否以及如何隐式创建 "
"。 它的可取值为 ``\"DEFERRED\"`` (默认值)，``\"EXCLUSIVE\"``，``\"IMMEDIATE\"`` 或 "
"``None`` (取用该值将禁止事务的隐式创建)。 请参阅 :ref:`sqlite3-controlling-transactions` "
"以获取更多信息。"

#: ../../library/sqlite3.rst:302
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"如果为 ``True`` (默认)，则 :exc:`ProgrammingError` 将在数据库连接被它的创建者以外的线程使用时被引发。 如果为 "
"``False``，则连接可以在多个线程中被访问；写入操作需要由用户者进行序列化以避免数据损坏。 请参阅 :attr:`threadsafety` "
"了解详情。"

#: ../../library/sqlite3.rst:311
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"如果您不想使用默认的 :class:`Connection` 类创建连接，那么您可以通过传入一个自定义的 :class:`Connection` "
"类的子类给该参数以创建连接。"

#: ../../library/sqlite3.rst:315
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"该参数指明 :mod:`!sqlite3` 模块应该为该连接进行内部缓存的语句 (statements) 数量。默认情况下，它的值为128。"

#: ../../library/sqlite3.rst:320
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"如果将该参数的值设置为 ``True``，参数 *database* 将会被解释为一个由文件路径与可选的查询字符串组成的 :abbr:`URI "
"(Uniform Resource Identifier)` 链接。链接的前缀协议部分 (schema part) *必需* 是 "
"``\"file:\"`` ，后面的文件路径可以是相对路径或绝对路径。查询字符串允许向 SQLite 传递参数，以实现不同的 "
":ref:`sqlite3-uri-tricks`。"

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "返回类型"

#: ../../library/sqlite3.rst:331
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument"
" ``database``."
msgstr ""
"使用它将引发一个附带参数 ``database`` 的 :ref:`审计事件 (auditing event) <auditing>` "
"``sqlite3.connect`` 。"

#: ../../library/sqlite3.rst:332
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"使用它将引发一个附带参数 ``connection_handle`` 的 :ref:`审计事件 <auditing>` "
"``sqlite3.connect/handle`` 。"

#: ../../library/sqlite3.rst:334
msgid "Added the *uri* parameter."
msgstr ""

#: ../../library/sqlite3.rst:337
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database* 现在可以是一个 :term:`path-like object` 对象了，而不仅仅是字符串。"

#: ../../library/sqlite3.rst:340
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:345
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is"
" performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"如果传入的字符串语句 (statement) 看起来像是包括一条或多条完整的 SQL 语句，那么该函数将返回 ``True`` "
"。请注意，除了检查未封闭的字符串字面 (unclosed string literals) 以及语句是否以分号结束外，它不会执行任何的语法检查 "
"(syntactic verification) 与语法解析 (synatatic parsing) 。"

#: ../../library/sqlite3.rst:351
msgid "For example:"
msgstr "例如:"

#: ../../library/sqlite3.rst:360
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"该函数可能在这样的情形下非常有用：在通过命令行 (command-line) 输入数据时，可使用该函数判断输入文本是否可以构成一个完成的 SQL "
"语句，或者判断在调用函数 :meth:`~Cursor.execute` 前是否还需要额外的输入。"

#: ../../library/sqlite3.rst:366
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"是否启用回调回溯 (callback tracebacks) 。默认情况下，在 SQLite 中，您不会在用户定义的函数、聚合函数 "
"(aggregates) 、转换函数 (converters) 、验证回调函数 (authorizer callbacks) "
"等中得到任何回溯信息。如果您想调试它们，您可以在将形式参数 *flag* 设置为 ``True`` 的情况下调用该函数。之后您便可以从 "
":data:`sys.stderr` 的回调中得到回溯信息。使用 ``False`` 将再次禁用该功能。"

#: ../../library/sqlite3.rst:373
msgid ""
"Register an :func:`unraisable hook handler <sys.unraisablehook>` for an "
"improved debug experience:"
msgstr ""
"同样，您可以注册一个 :func:`unraisable hook handler <sys.unraisablehook>` 以改善您的调试体验："

#: ../../library/sqlite3.rst:398
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as"
" its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"注册 *adapter* :term:`callable` 以将 Python 类型 *type* 适配为一个 SQLite 类型。 "
"该适配器在调用时会传入一个 *type* 类型的 Python 对象作为其唯一参数，并且必须返回一个 :ref:`SQLite 原生支持的类型 "
"<sqlite3-types>` 的值。"

#: ../../library/sqlite3.rst:406
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked"
" for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"注册 *converter* :term:`callable` 以将 *typename* 类型的 SQLite 对象转换为一个特定类型的 Python"
" 对象。转换器会针对所有类型为 *typename* 的 SQLite 值发起调用；它会传递一个 :class:`bytes` "
"对象并且应该返回一个所需的 Python 类型的对象。 请参阅 :func:`connect` 的 *detect_types* "
"形参了解有关类型检测工作方式的详情。"

#: ../../library/sqlite3.rst:414
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr "注：*typename* 以及您在查询中使用的类型名是不大小写敏感的。"

#: ../../library/sqlite3.rst:421
msgid "Module constants"
msgstr "模块常量"

#: ../../library/sqlite3.rst:425
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""
"将这个旗标值传递给 :func:`connect` 的 *detect_types* "
"形参，以使用从查询列名解析的类型名作为转换器字典键来查找转换器函数。类型名称必须用方括号（``[]``）括起来。"

#: ../../library/sqlite3.rst:435
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗标可以使用 ``|`` （位或）运算符与 :const:`PARSE_DECLTYPES` 组合。"

#: ../../library/sqlite3.rst:440
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"将这个旗标值传递给 :func:`connect` 的 *detect_types* "
"形参，以使用创建数据库表时为每列声明的类型的查找转换器函数。:mod:`!sqlite3` "
"将使用声明类型的第一个单词作为转换字典键来查找转换函数。例如："

#: ../../library/sqlite3.rst:456
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗标可以使用 ``|`` （位或）运算符与 :const:`PARSE_COLNAMES` 组合。"

#: ../../library/sqlite3.rst:463
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"应当由传给 :meth:`Connection.set_authorizer` 的 *authorizer_callback* "
":term:`callable` 返回的旗标，用于指明是否:"

#: ../../library/sqlite3.rst:466
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "访问被允许（:const:`!SQLITE_OK`）。"

#: ../../library/sqlite3.rst:467
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "SQL语句伴异常的执行失败（:const:`!SQLITE_DENY`）。"

#: ../../library/sqlite3.rst:468
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr "该列应被视为NULL（:const:`!SQLITE_IGNORE`）。"

#: ../../library/sqlite3.rst:472
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr "指明所支持的 DB-API 级别的字符串常量。 根据 DB-API 的需要设置。 硬编码为 ``\"2.0\"``。"

#: ../../library/sqlite3.rst:477
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr "指明 :mod:`!sqlite3` 模块所预期的形参标记格式化类型。 根据 DB-API 的需要设置。 硬编码为 ``\"qmark\"``。"

#: ../../library/sqlite3.rst:483
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "``named`` DB-API 形参风格也受到支持。"

#: ../../library/sqlite3.rst:487
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr "以 :class:`字符串 <str>` 表示的运行时 SQLite 库版本号。"

#: ../../library/sqlite3.rst:491
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of "
":class:`integers <int>`."
msgstr "以 :class:`整数 <int>` :class:`tuple` 表示的运行时. SQLite 库版本号。"

#: ../../library/sqlite3.rst:496
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"DB-API 2.0 所要求的整数常量，指明 :mod:`!sqlite3` 模块支持的线程安全级别。 该属性将基于编译下层 SQLite "
"库所使用的默认 `线程模式 <https://sqlite.org/threadsafe.html>`_ 来设置。 SQLite 的线程模式有:"

#: ../../library/sqlite3.rst:501
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr "**Single-thread**: 在此模式下，所有的互斥都被禁用并且 SQLite 同时在多个线程中使用将是不安全的。"

#: ../../library/sqlite3.rst:503
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Multi-thread**: 在此模式下，只要单个数据库连接没有被同时用于两个或多个线程之中 SQLite 就可以安全地被多个线程所使用。"

#: ../../library/sqlite3.rst:506
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr "**Serialized**: 在序列化模式下，SQLite 可以安全地被多个线程所使用而没有额外的限制。"

#: ../../library/sqlite3.rst:509
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr "从 SQLite 线程模式到 DB-API 2.0 线程安全级别的映射关系如下:"

#: ../../library/sqlite3.rst:513
msgid "SQLite threading mode"
msgstr "SQLite 线程模式"

#: ../../library/sqlite3.rst:513
msgid "`threadsafety`_"
msgstr "`threadsafety`_"

#: ../../library/sqlite3.rst:513
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:513
msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 含义"

#: ../../library/sqlite3.rst:516
msgid "single-thread"
msgstr "single-thread"

#: ../../library/sqlite3.rst:516
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:516
msgid "Threads may not share the module"
msgstr "各个线程不能共享模块"

#: ../../library/sqlite3.rst:519
msgid "multi-thread"
msgstr "multi-thread"

#: ../../library/sqlite3.rst:519 ../../library/sqlite3.rst:522
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:519
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:519
msgid "Threads may share the module, but not connections"
msgstr "线程可以共享模块，但不能共享连接"

#: ../../library/sqlite3.rst:522
msgid "serialized"
msgstr "serialized"

#: ../../library/sqlite3.rst:522
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:522
msgid "Threads may share the module, connections and cursors"
msgstr "线程可以共享模块、连接和游标Threads may share the module, connections and cursors"

#: ../../library/sqlite3.rst:529
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr "动态设置 *threadsafety* 而不是将其硬编码为 ``1``。"

#: ../../library/sqlite3.rst:534
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr "此模块 :class:`字符串 <str>` 形式的版本号。 这不是 SQLite 库的版本号。"

#: ../../library/sqlite3.rst:539
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""
"此模块 :class:`整数 <int>` :class:`tuple` 形式的版本号。 这不是 SQLite 库的版本号。library."

#: ../../library/sqlite3.rst:546
msgid "Connection objects"
msgstr "连接对象"

#: ../../library/sqlite3.rst:550
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating "
":class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"每个打开的 SQLite 数据库均以 ``Connection`` 对象来表示，这种对象是使用 :func:`sqlite3.connect` 创建的。"
" 它们的主要目的是创建 :class:`Cursor` 对象，以及 :ref:`sqlite3-controlling-transactions`。"

#: ../../library/sqlite3.rst:557
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:560
msgid ""
"An SQLite database connection has the following attributes and methods:"
msgstr "SQLite 数据库连接对象有如下的属性和方法："

#: ../../library/sqlite3.rst:564
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a "
":term:`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"创建并返回 :class:`Cursor` 对象。 cursor 方法接受一个可选参数 *factory*。 如果提供了这个参数，它必须是一个 "
":term:`callable` 并且返回 :class:`Cursor` 或其子类的实例。"

#: ../../library/sqlite3.rst:571
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr "打开一个已有的 :abbr:`BLOB（二进制大型对象）` :class:`Blob` 句柄。"

#: ../../library/sqlite3.rst:574
msgid "The name of the table where the blob is located."
msgstr "二进制大对象 blob 所在表的名称。"

#: ../../library/sqlite3.rst:577
msgid "The name of the column where the blob is located."
msgstr "二进制大对象 blob 所在表的列名。"

#: ../../library/sqlite3.rst:580
msgid "The name of the row where the blob is located."
msgstr "二进制大对象 blob 所在的列名。"

#: ../../library/sqlite3.rst:583
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr "如果 blob 应当不带写入权限打开则设为 ``True``。 默认为 ``False``。"

#: ../../library/sqlite3.rst:588
msgid ""
"The name of the database where the blob is located. Defaults to "
"``\"main\"``."
msgstr "二进制大对象 blob 所在的数据库名。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "引发"

#: ../../library/sqlite3.rst:592
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "当尝试打开 ``WITHOUT ROWID`` 的表中的某个 blob 时。"

#: ../../library/sqlite3.rst:599
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"blob 的大小无法使用 :class:`Blob` 类来修改。 可使用 SQL 函数 ``zeroblob`` 来创建固定大小的 blob。"

#: ../../library/sqlite3.rst:606
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr "向数据库提交任何待处理的事务。 如果没有已开启的事务，则此方法不执行任何操作。"

#: ../../library/sqlite3.rst:611
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:616
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr ""

#: ../../library/sqlite3.rst:623
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.execute`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:629
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql* 和 *parameters* 调用 "
":meth:`~Cursor.executemany`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:635
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"创建一个新的 :class:`Cursor` 对象，并在其上使用给出的 *sql_script* 调用 "
":meth:`~Cursor.executescript`。 返回新的游标对象。"

#: ../../library/sqlite3.rst:641
msgid "Create or remove a user-defined SQL function."
msgstr "创建或移除用户定义的 SQL 函数。"

#: ../../library/sqlite3.rst:643
msgid "The name of the SQL function."
msgstr "SQL 函数的名称。"

#: ../../library/sqlite3.rst:646
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr "SQL 函数可接受的参数数量，如果是 ``-1``，则该函数可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:650
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite "
"<sqlite3-types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
"当该 SQL 函数被发起调用时将会调用的 :term:`callable`。 该可调用对象必须返回 :ref:`一个 SQLite 原生支持的类型 "
"<sqlite3-types>`。 设为 ``None`` 将移除现有的 SQL 函数。"

#: ../../library/sqlite3.rst:657
msgid ""
"If ``True``, the created SQL function is marked as `deterministic "
"<https://sqlite.org/deterministic.html>`_, which allows SQLite to perform "
"additional optimizations."
msgstr ""
"如为 ``True``，创建的 SQL 函数将被标记为 `deterministic "
"<https://sqlite.org/deterministic.html>`_，这允许 SQLite 执行额外的优化。"

#: ../../library/sqlite3.rst:662
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr "如果 *deterministic* 在早于 SQLite 3.8.3 的版本上使用。"

#: ../../library/sqlite3.rst:665
msgid "Added the *deterministic* parameter."
msgstr ""

#: ../../library/sqlite3.rst:668 ../../library/sqlite3.rst:706
#: ../../library/sqlite3.rst:769 ../../library/sqlite3.rst:1021
#: ../../library/sqlite3.rst:1362 ../../library/sqlite3.rst:1390
msgid "Example:"
msgstr "示例:"

#: ../../library/sqlite3.rst:684
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "创建或移除用户自定义的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:686
msgid "The name of the SQL aggregate function."
msgstr "SQL 聚合函数的名称。"

#: ../../library/sqlite3.rst:689
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it"
" may take any number of arguments."
msgstr "SQL 聚合函数可接受的参数数量。 如为 ``-1``，则可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:693
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate as"
"   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"一个类必须实现下列方法:  * ``step()``: 向聚合添加一行。 * ``finalize()``: 将聚合的最终结果作为 :ref:`一个 "
"SQLite 原生支持的类型 <sqlite3-types>` 返回。 ``step()`` 方法需要接受的参数数量是由 *n_arg* 控制的。 设为"
" ``None`` 将移除现有的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:694
msgid "A class must implement the following methods:"
msgstr "此类必须实现以下方法："

#: ../../library/sqlite3.rst:696
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: 向聚合添加一行。"

#: ../../library/sqlite3.rst:697 ../../library/sqlite3.rst:753
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: 将聚合的最终结果作为 :ref:`一个 SQLite 原生支持的类型 <sqlite3-types>` 返回。"

#: ../../library/sqlite3.rst:700
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled"
" by *n_arg*."
msgstr "``step()`` 方法所必须接受的参数数量是由 *n_arg* 控制的。"

#: ../../library/sqlite3.rst:703
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "设为 ``None`` 以移除现有的 SQL 聚合函数。"

#: ../../library/sqlite3.rst:738
msgid "Create or remove a user-defined aggregate window function."
msgstr "创建或移除用户定义的聚合窗口函数。"

#: ../../library/sqlite3.rst:740
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "要创建或移除的 SQL 聚合窗口函数的名称。"

#: ../../library/sqlite3.rst:743
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr "SQL 聚合窗口函数可接受的参数数量。 如为 ``-1``，则可以接受任意数量的参数。"

#: ../../library/sqlite3.rst:747
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that"
" the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"一个必须实现下列方法的类:  * ``step()``: 向当前窗口添加一行。 * ``value()``: 返回聚合的当前值。 * "
"``inverse()``: 从当前窗口移除一行。 * ``finalize()``: 将聚合的最终结果作为 :ref:`一个 SQLite "
"原生支持的类型 <sqlite3-types>` 返回。 ``step()`` 和 ``value()`` 方法需要接受的参数数量是由 "
"*num_params* 控制的。 设为 ``None`` 将移除现有的 SQL 聚合窗口函数。"

#: ../../library/sqlite3.rst:748
msgid "A class that must implement the following methods:"
msgstr "此类必须实现以下方法："

#: ../../library/sqlite3.rst:750
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: 向当前窗口添加一行。"

#: ../../library/sqlite3.rst:751
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: 返回聚合的当前值。"

#: ../../library/sqlite3.rst:752
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: 从当前窗口移除一行。Remove a row from the current window."

#: ../../library/sqlite3.rst:756
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr "``step()`` 和 ``value()`` 方法需要接受的参数数量是由 *num_params* 控制的。"

#: ../../library/sqlite3.rst:759
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr "设为 ``None`` 将移除现有的 SQL 聚合窗口函数。"

#: ../../library/sqlite3.rst:761
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr "如果在早于 SQLite 3.25.0，不支持聚合窗口函数的版本上使用。"

#: ../../library/sqlite3.rst:824
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"使用排序函数 *callable* 创建一个名为 *name* 的排序规则。 *callable* 被传递给两个 :class:`字符串 <str>` "
"参数，并且它应该返回一个 :class:`整数 <int>`。"

#: ../../library/sqlite3.rst:828
msgid "``1`` if the first is ordered higher than the second"
msgstr "如果前者的排序高于后者则为 ``1``"

#: ../../library/sqlite3.rst:829
msgid "``-1`` if the first is ordered lower than the second"
msgstr "如果前者的排序低于于后者则为 ``-1``"

#: ../../library/sqlite3.rst:830
msgid "``0`` if they are ordered equal"
msgstr "如果它们的顺序相同则为 ``0``"

#: ../../library/sqlite3.rst:832
msgid "The following example shows a reverse sorting collation:"
msgstr "下面的例子显示了一个反向排序的排序方法:"

#: ../../library/sqlite3.rst:860
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "通过将 *callable* 设为 ``None`` 来移除一个排序规则函数。"

#: ../../library/sqlite3.rst:862
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr "排序规则的名称可以包含任意 Unicode 字符。 在之前，只允许 ASCII 字符。"

#: ../../library/sqlite3.rst:869
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an "
":exc:`OperationalError`."
msgstr "从其他的线程调用此方法以中止可能正在连接上执行的任何查询。 被中止的查询将引发 :exc:`OperationalError`。"

#: ../../library/sqlite3.rst:876
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or "
":const:`SQLITE_IGNORE` to signal how access to the column should be handled "
"by the underlying SQLite library."
msgstr ""
"注册 :term:`callable` *authorizer_callback* 用于在每次尝试访问数据库中表的某一列时发起调用。 该回调应当返回 "
":const:`SQLITE_OK`、:const:`SQLITE_DENY` 或 :const:`SQLITE_IGNORE` 中的一个以提示下层 "
"SQLite 库应当如何处理对该列的访问。"

#: ../../library/sqlite3.rst:883
msgid ""
"The first argument to the callback signifies what kind of operation is to be"
" authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"该回调的第一个参数指明哪种操作将被授权。 第二个和第三个参数根据第一个参数的具体值将为传给操作的参数或为 ``None``。 "
"第四个参数如果适用则为数据库名称（\"main\", \"temp\" 等）。 "
"第五个参数是负责尝试访问的最内层触发器或视图的名称或者如果该尝试访问是直接来自输入的 SQL 代码的话则为 ``None``。"

#: ../../library/sqlite3.rst:890
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on"
" the first one. All necessary constants are available in the :mod:`!sqlite3`"
" module."
msgstr ""
"请参阅 SQLite 文档了解第一个参数可能的值以及依赖于第一个参数的第二个和第三个参数的含义。 所有必需的常量均在 :mod:`!sqlite3` "
"模块中可用。"

#: ../../library/sqlite3.rst:894
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "将 ``None`` 作为 *authorizer_callback* 传入将禁用授权回调。"

#: ../../library/sqlite3.rst:896
msgid "Added support for disabling the authorizer using ``None``."
msgstr "增加对使用 ``None`` 禁用授权回调的支持。"

#: ../../library/sqlite3.rst:902
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update"
" a GUI."
msgstr ""
"注册 :term:`callable` *progress_handler* 以针对 SQLite 虚拟机的每 *n* 条指令发起调用。 "
"如果你想要在长时间运行的操作，例如更新 GUI 期间获得来自 SQLite 的调用这将很有用处。"

#: ../../library/sqlite3.rst:907
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr "如果你想清除任何先前安装的进度处理句柄，可在调用该方法时传入 ``None`` 作为 *progress_handler*。"

#: ../../library/sqlite3.rst:910
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""

#: ../../library/sqlite3.rst:917
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr "注册 :term:`callable` *trace_callback* 以针对 SQLite 后端实际执行的每条 SQL 语句发起调用。"

#: ../../library/sqlite3.rst:920
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the "
":meth:`Cursor.execute` methods.  Other sources include the :ref:`transaction"
" management <sqlite3-controlling-transactions>` of the :mod:`!sqlite3` "
"module and the execution of triggers defined in the current database."
msgstr ""
"传给该回调的唯一参数是被执行的语句 (作为 :class:`str`)。 回调的返回值将被忽略。 请注意后端不仅会运行传给 "
":meth:`Cursor.execute` 方法的语句。 其他来源还包括 :mod:`!sqlite3` 模块的 :ref:`事务管理 "
"<sqlite3-controlling-transactions>` 以及在当前数据库中定义的触发器的执行。"

#: ../../library/sqlite3.rst:928
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr "传入 ``None`` 作为 *trace_callback* 将禁用追踪回调。"

#: ../../library/sqlite3.rst:931
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development"
" and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to "
"enable printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"在跟踪回调中产生的异常不会被传播。作为开发和调试的辅助手段，使用 :meth:`~sqlite3.enable_callback_tracebacks`"
" 来启用打印跟踪回调中产生的异常的回调。"

#: ../../library/sqlite3.rst:941
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"如果 *enabled* 为 ``True`` 则允许 SQLite 从共享库加载 SQLite 扩展；否则，不允许加载 SQLite 扩展。 "
"SQLite 扩展可以定义新的函数、聚合或全新的虚拟表实现。 一个知名的扩展是与随同 SQLite 一起分发的全文搜索扩展。"

#: ../../library/sqlite3.rst:950
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to "
":program:`configure`."
msgstr ""
"在默认情况下 :mod:`!sqlite3` 模块的构建没有附带可加载扩展支持，因为某些平台（主要是 macOS）上的 SQLite "
"库在编译时未启用此特性。 要获得可加载扩展支持，你必须将 :option:`--enable-loadable-sqlite-extensions` "
"选项传给 :program:`configure`。"

#: ../../library/sqlite3.rst:957
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension``"
" with arguments ``connection``, ``enabled``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.enable_load_extension``，附带参数 "
"``connection``, ``enabled``。"

#: ../../library/sqlite3.rst:961
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "增加了 ``sqlite3.enable_load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:1004
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""

#: ../../library/sqlite3.rst:1008
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``sqlite3.load_extension``，附带参数 ``connection``, "
"``path``。"

#: ../../library/sqlite3.rst:1012
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "增加了 ``sqlite3.load_extension`` 审计事件。"

#: ../../library/sqlite3.rst:1017
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the "
"``.dump`` command in the :program:`sqlite3` shell."
msgstr ""
"返回一个 :term:`iterator` 用来将数据库转储为 SQL 源代码。 在保存内存数据库以便将来恢复时很有用处。 类似于 "
":program:`sqlite3` shell 中的 ``.dump`` 命令。"

#: ../../library/sqlite3.rst:1034 ../../library/sqlite3.rst:1104
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-howto-encoding`"

#: ../../library/sqlite3.rst:1039
msgid "Create a backup of an SQLite database."
msgstr "创建 SQLite 数据库的备份。"

#: ../../library/sqlite3.rst:1041
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr "即使数据库是通过其他客户端访问或通过同一连接并发访问也是有效的。"

#: ../../library/sqlite3.rst:1044
msgid "The database connection to save the backup to."
msgstr "用于保存备份的数据库连接。"

#: ../../library/sqlite3.rst:1047
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr "每次要拷贝的页数。 如果小于等于 ``0``，则一次性拷贝整个数据库。 默认为 ``-1``。"

#: ../../library/sqlite3.rst:1053
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for"
" every backup iteration: the *status* of the last iteration, the *remaining*"
" number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"如果设为一个 :term:`callable`，它将针对每次备份迭代附带三个整数参数被发起调用：上次迭代的状态 *status*，待拷贝的剩余页数 "
"*remaining*，以及总页数 *total*。 默认值为 ``None``。"

#: ../../library/sqlite3.rst:1062
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a"
" custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"要备份的数据库名称。 可能为代表主数据库的 ``\"main\"`` (默认值)，代表临时数据库的 ``\"temp\"``，或者使用 ``ATTACH"
" DATABASE`` SQL 语句所附加的自定义数据库名称。"

#: ../../library/sqlite3.rst:1069
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr "连续尝试备份剩余页所要间隔的休眠秒数。"

#: ../../library/sqlite3.rst:1073
msgid "Example 1, copy an existing database into another:"
msgstr "示例 1，将现有数据库拷贝至另一个数据库:"

#: ../../library/sqlite3.rst:1092
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "示例 2，将现有数据库拷贝至一个临时副本:"

#: ../../library/sqlite3.rst:1108
msgid "Get a connection runtime limit."
msgstr "获取一个连接的运行时限制。"

#: ../../library/sqlite3.rst:1110
msgid "The `SQLite limit category`_ to be queried."
msgstr "要查询的 `SQLite limit category`_。"

#: ../../library/sqlite3.rst:1115 ../../library/sqlite3.rst:1152
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "如果 *category* 不能被下层的 SQLite 库所识别。"

#: ../../library/sqlite3.rst:1118
msgid ""
"Example, query the maximum length of an SQL statement for "
":class:`Connection` ``con`` (the default is 1000000000):"
msgstr "示例，查询 :class:`Connection` ``con`` 上一条 SQL 语句的最大长度（默认值为 1000000000）:"

#: ../../library/sqlite3.rst:1138
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr "设置连接运行时限制。 如果试图将限制提高到超出强制上界则会静默地截短到强制上界。 无论限制值是否被修改，都将返回之前的限制值。"

#: ../../library/sqlite3.rst:1143
msgid "The `SQLite limit category`_ to be set."
msgstr "要设置的 `SQLite limit category`_。"

#: ../../library/sqlite3.rst:1146
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr "新的限制值。 如为负值，当前限制将保持不变。"

#: ../../library/sqlite3.rst:1155
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection`"
" ``con`` (the default limit is 10):"
msgstr "示例，将 :class:`Connection` ``con`` 上附加的数据库数量限制为 1（默认限制为 10）:"

#: ../../library/sqlite3.rst:1172
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an "
"in-memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"将一个数据库序列化为 :class:`bytes` 对象。 对于普通的磁盘数据库文件，序列化就是磁盘文件的一个副本。 "
"对于内存数据库或“临时”数据库，序列化就是当数据库备份到磁盘时要写入到磁盘的相同字节序列。"

#: ../../library/sqlite3.rst:1178
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "要序列化的数据库名称。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:1186
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr "此方法仅在下层 SQLite 库具有序列化 API 时可用。"

#: ../../library/sqlite3.rst:1194
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a "
":class:`Connection`. This method causes the database connection to "
"disconnect from database *name*, and reopen *name* as an in-memory database "
"based on the serialization contained in *data*."
msgstr ""
"将一个 :meth:`已序列化的 <serialize>` 数据库反序列化至 :class:`Connection`。 此方法将导致数据库连接从 "
"*name* 数据库断开，并基于包含在 *data* 中的序列化数据将 *name* 作为内存数据库重新打开。"

#: ../../library/sqlite3.rst:1200
msgid "A serialized database."
msgstr "已序列化的数据库。"

#: ../../library/sqlite3.rst:1203
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr "反序列化的目标数据库名称。 默认为 ``\"main\"``。"

#: ../../library/sqlite3.rst:1207
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr "如果当前数据库连接正在执行读取事务或备份操作。"

#: ../../library/sqlite3.rst:1211
msgid "If *data* does not contain a valid SQLite database."
msgstr "如果 *data* 不包含有效的 SQLite 数据库。"

#: ../../library/sqlite3.rst:1214
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "如果 :func:`len(data) <len>` 大于 ``2**63 - 1``。"

#: ../../library/sqlite3.rst:1219
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr "此方法仅在下层的 SQLite 库具有反序列化 API 时可用。"

#: ../../library/sqlite3.rst:1226
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr "这个只读属性对应于低层级的 SQLite `autocommit mode`_。"

#: ../../library/sqlite3.rst:1229
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr "如果一个事务处于活动状态（有未提交的更改）则为 ``True``，否则为 ``False``。"

#: ../../library/sqlite3.rst:1236
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``,"
" ``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""

#: ../../library/sqlite3.rst:1244
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the"
" default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"如果未被 :func:`connect` 的 *isolation_level* 形参覆盖，则默认为 ``\"\"``，这是 "
"``\"DEFERRED\"`` 的一个别名。"

#: ../../library/sqlite3.rst:1249
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the "
":attr:`!row_factory` of existing cursors belonging to this connection, only "
"new ones. Is ``None`` by default, meaning each row is returned as a "
":class:`tuple`."
msgstr ""
"针对从该连接创建的 :class:`Cursor` 对象的初始 :attr:`~Cursor.row_factory`。 "
"为该属性赋值不会影响属于该连接的现有游标的 :attr:`!row_factory`，只影响新的游标。 默认为 ``None``，表示将每一行作为 "
":class:`tuple` 返回。"

#: ../../library/sqlite3.rst:1256 ../../library/sqlite3.rst:1516
#: ../../library/sqlite3.rst:1539
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "详情参见 :ref:`sqlite3-howto-row-factory`。"

#: ../../library/sqlite3.rst:1260
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
"一个接受 :class:`bytes` 形参并返回其文本表示形式的 :term:`callable`。 该可调用对象将针对数据类型为 ``TEXT`` "
"的 SQLite 值发起调用。 在默认情况下，该属性将被设为 :class:`str`。"

#: ../../library/sqlite3.rst:1265
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "请参阅 :ref:`sqlite3-howto-encoding` 了解详情。"

#: ../../library/sqlite3.rst:1269
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr "返回自打开数据库连接以来已修改、插入或删除的数据库行的总数。"

#: ../../library/sqlite3.rst:1276
msgid "Cursor objects"
msgstr "游标对象"

#: ../../library/sqlite3.rst:1278
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute"
" SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the "
":ref:`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"一个代表被用于执行 SQL 语句，并管理获取操作的上下文的 `database cursor`_ 的 ``Cursor`` 对象。 游标对象是使用 "
":meth:`Connection.cursor`，或是通过使用任何 :ref:`连接快捷方法 <sqlite3-connection-"
"shortcuts>` 来创建的。"

#: ../../library/sqlite3.rst:1285
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you "
":meth:`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the "
"cursor to fetch the resulting rows:"
msgstr ""
"Cursor 对象属于 :term:`迭代器 <iterator>`，这意味着如果你通过 :meth:`~Cursor.execute` 来执行 "
"``SELECT`` 查询，你可以简单地迭代游标来获取结果行:"

#: ../../library/sqlite3.rst:1310
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 游标实例具有以下属性和方法。"

#: ../../library/sqlite3.rst:1317
msgid ""
"Execute a single SQL statement, optionally binding Python values using "
":ref:`placeholders <sqlite3-placeholders>`."
msgstr "执行一条 SQL 语句，可以选择使用 :ref:`占位符 <sqlite3-placeholders>` 来绑定 Python 值。"

#: ../../library/sqlite3.rst:1321
msgid "A single SQL statement."
msgstr "一条 SQL 语句。"

#: ../../library/sqlite3.rst:1324
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used."
" See :ref:`sqlite3-placeholders`."
msgstr ""
"要绑定到 *sql* 中占位符的 Python 值。 如果使用命名占位符则会使用 :class:`!dict`。 如果使用非命名占位符则会使用 "
":term:`!sequence`。 参见 :ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1331
msgid "If *sql* contains more than one SQL statement."
msgstr "如果 *sql* 包含多条 SQL 语句。"

#: ../../library/sqlite3.rst:1334
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""

#: ../../library/sqlite3.rst:1339
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "使用 :meth:`executescript` 来执行多条 SQL 语句。statements."

#: ../../library/sqlite3.rst:1343
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"对于 *parameters* 中的每一项，重复执行 :ref:`参数化的 <sqlite3-placeholders>` :abbr:`DML "
"(Data Manipulation Language)` SQL 语句 *sql*。"

#: ../../library/sqlite3.rst:1347
msgid ""
"Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr "使用与 :meth:`~Cursor.execute` 相同的隐式事务处理。"

#: ../../library/sqlite3.rst:1349
msgid "A single SQL DML statement."
msgstr "一条 SQL DML 语句。"

#: ../../library/sqlite3.rst:1352
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"一个用来绑定到 *sql* 中的占位符的形参的 :term:`!iterable`。 参见 :ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1358
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr "如果 *sql* 包含多条 SQL 语句，或者不属于 DML 语句。"

#: ../../library/sqlite3.rst:1375
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr "任何结果行都将被丢弃，包括带有 `RETURNING 子句`_ 的 DML 语句。"

#: ../../library/sqlite3.rst:1382
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""

#: ../../library/sqlite3.rst:1388
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* 必须为 :class:`字符串 <str>`。"

#: ../../library/sqlite3.rst:1405
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result"
" set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"如果 :attr:`~Cursor.row_factory` 为 ``None``，则将下一行查询结果集作为 :class:`tuple` 返回。 "
"否则，将其传给指定的行工厂函数并返回函数结果。 如果没有更多可用数据则返回 ``None``。"

#: ../../library/sqlite3.rst:1413
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr "将下一个多行查询结果集作为 :class:`list` 返回。 如果没有更多可用行时则返回一个空列表。"

#: ../../library/sqlite3.rst:1416
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"每次调用要获取的行数是由 *size* 形参指定的。 如果未指定 *size*，则由 :attr:`arraysize` 确定要获取的行数。 "
"如果可用的行少于 *size*，则返回可用的行数。"

#: ../../library/sqlite3.rst:1422
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain"
" the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"请注意 *size* 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 *size* "
"形参，则最好在从一个 :meth:`fetchmany` 调用到下一个调用之间保持相同的值。"

#: ../../library/sqlite3.rst:1429
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"将全部（剩余的）查询结果行作为 :class:`list` 返回。 如果没有可用的行则返回空列表。 请注意 :attr:`arraysize` "
"属性可能会影响此操作的性能。"

#: ../../library/sqlite3.rst:1436
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "立即关闭 cursor（而不是在当 ``__del__`` 被调用的时候）。"

#: ../../library/sqlite3.rst:1438
msgid ""
"The cursor will be unusable from this point forward; a "
":exc:`ProgrammingError` exception will be raised if any operation is "
"attempted with the cursor."
msgstr ""
"从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 :exc:`ProgrammingError` 异常。"

#: ../../library/sqlite3.rst:1443 ../../library/sqlite3.rst:1447
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "DB-API 要求的方法。 在 :mod:`!sqlite3` 不做任何事情。"

#: ../../library/sqlite3.rst:1451
msgid ""
"Read/write attribute that controls the number of rows returned by "
":meth:`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr "用于控制 :meth:`fetchmany` 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。"

#: ../../library/sqlite3.rst:1456
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling "
":meth:`con.cursor() <Connection.cursor>` will have a :attr:`connection` "
"attribute that refers to *con*:"
msgstr ""
"提供属于该游标的 SQLite :class:`Connection` 的只读属性。 通过调用 :meth:`con.cursor() "
"<Connection.cursor>` 创建的 :class:`Cursor` 对象将具有一个指向 *con* 的 "
":attr:`connection` 属性:"

#: ../../library/sqlite3.rst:1470
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"提供上一次查询的列名称的只读属性。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 "
"``None``。"

#: ../../library/sqlite3.rst:1474
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "对于没有任何匹配行的 ``SELECT`` 语句同样会设置该属性。"

#: ../../library/sqlite3.rst:1478
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is"
" only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany`"
" or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"提供上一次插入的行的行 ID 的只读属性。 它只会在使用 :meth:`execute` 方法的 ``INSERT`` 或 ``REPLACE`` "
"语句成功后被更新。 对于其他语句，则在 :meth:`executemany` 或 "
":meth:`executescript`，或者如果插入失败，``lastrowid`` 的值将保持不变。 ``lastrowid`` 的初始值为 "
"``None``。"

#: ../../library/sqlite3.rst:1486
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "对 ``WITHOUT ROWID`` 表的插入不被记录。"

#: ../../library/sqlite3.rst:1488
msgid "Added support for the ``REPLACE`` statement."
msgstr "增加了 ``REPLACE`` 语句的支持。"

#: ../../library/sqlite3.rst:1493
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"提供 ``INSERT``, ``UPDATE``, ``DELETE`` 和 ``REPLACE`` 语句所修改行数的只读属性；对于其他语句则为 "
"``-1``，包括 :abbr:`CTE (Common Table Expression)` 查询。 只有 :meth:`execute` 和 "
":meth:`executemany` 方法会在语句运行完成后更新此属性。 这意味着任何结果行都必须按顺序被提取以使 :attr:`!rowcount`"
" 获得更新。"

#: ../../library/sqlite3.rst:1504
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"控制从该 :class:`!Cursor` 获取的行的表示形式。 如为 ``None``，一行将表示为一个 :class:`tuple`。可设置形式包括"
" :class:`sqlite3.Row`；或者接受两个参数的 :term:`callable`，一个 :class:`Cursor` "
"对象和由行内所有值组成的 :class:`!tuple`，以及返回代表一个 SQLite 行的自定义对象。"

#: ../../library/sqlite3.rst:1511
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the "
":class:`!Cursor` was created. Assigning to this attribute does not affect "
":attr:`Connection.row_factory` of the parent connection."
msgstr ""
"默认为当 :class:`!Cursor` 被创建时设置的 :attr:`Connection.row_factory`。 对该属性赋值不会影响父连接的"
" :attr:`Connection.row_factory`。"

#: ../../library/sqlite3.rst:1527
msgid "Row objects"
msgstr "Row 对象"

#: ../../library/sqlite3.rst:1531
msgid ""
"A :class:`!Row` instance serves as a highly optimized "
":attr:`~Connection.row_factory` for :class:`Connection` objects. It supports"
" iteration, equality testing, :func:`len`, and :term:`mapping` access by "
"column name and index."
msgstr ""
"一个被用作 :class:`Connection` 对象的高度优化的 :attr:`~Connection.row_factory` 的 "
":class:`!Row` 实例。 它支持迭代、相等性检测、:func:`len` 以及基于列名称的 :term:`mapping` 访问和数字序列。"

#: ../../library/sqlite3.rst:1536
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr "两个 :class:`!Row` 对象如果具有相同的列名称和值则比较结果相等。"

#: ../../library/sqlite3.rst:1543
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in "
":attr:`Cursor.description`."
msgstr ""
"在一次查询之后，立即将由列名称组成的 :class:`list` 作为 :class:`字符串 <str>` 返回，它是 "
":attr:`Cursor.description` 中每个元组的第一个成员。"

#: ../../library/sqlite3.rst:1547
msgid "Added support of slicing."
msgstr "添加了对切片操作的支持。"

#: ../../library/sqlite3.rst:1554
msgid "Blob objects"
msgstr "Blob 对象"

#: ../../library/sqlite3.rst:1560
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call "
":func:`len(blob) <len>` to get the size (number of bytes) of the blob. Use "
"indices and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
":class:`Blob` 实例是可以读写 SQLite :abbr:`BLOB (Binary Large OBject)` 数据的 "
":term:`file-like object`。 调用 :func:`len(blob) <len>` 可得到 blob 的大小（字节数）。 "
"请使用索引和 :term:`切片 <slice>` 来直接访问 blob 数据。"

#: ../../library/sqlite3.rst:1565
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr "将 :class:`Blob` 作为 :term:`context manager` 使用以确保使用结束后 blob 句柄自动关闭。"

#: ../../library/sqlite3.rst:1595
msgid "Close the blob."
msgstr "关闭 blob。"

#: ../../library/sqlite3.rst:1597
msgid ""
"The blob will be unusable from this point onward.  An "
":class:`~sqlite3.Error` (or subclass) exception will be raised if any "
"further operation is attempted with the blob."
msgstr ""
"从这一时刻起该 blob 将不再可用。 如果再尝试用该 blob 执行任何操作将引发 :class:`~sqlite3.Error` (或其子类) "
"异常。"

#: ../../library/sqlite3.rst:1603
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If"
" the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, "
":meth:`~Blob.read` will read until the end of the blob."
msgstr ""
"从 blob 的当前偏移位置读取 *length* 个字节的数据。 如果到达了 blob 的末尾，则将返回 :abbr:`EOF (End of "
"File)` 之前的数据。 当未指定 *length*，或指定负值时，:meth:`~Blob.read` 将读取至 blob 的末尾。"

#: ../../library/sqlite3.rst:1611
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change"
" the blob length.  Writing beyond the end of the blob will raise "
":exc:`ValueError`."
msgstr ""
"在 blob 的当前偏移位置上写入 *data*。 此函数不能改变 blob 的长度。 写入数据超出 blob 的末尾将引发 "
":exc:`ValueError`。"

#: ../../library/sqlite3.rst:1617
msgid "Return the current access position of the blob."
msgstr "返回 blob 的当前访问位置。"

#: ../../library/sqlite3.rst:1621
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other"
" values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"将 Blob 的当前访问位置设为 *offset*。 *origin* 参数默认为 :const:`os.SEEK_SET` (blob 的绝对位置)。"
" *origin* 的其他值包括 :const:`os.SEEK_CUR` （相对于当前位置寻址) 和 :const:`os.SEEK_END` "
"(相对于 blob 末尾寻址)。"

#: ../../library/sqlite3.rst:1629
msgid "PrepareProtocol objects"
msgstr "PrepareProtocol 对象"

#: ../../library/sqlite3.rst:1633
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves "
"<sqlite3-conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol 类型的唯一目的是作为 :pep:`246` 风格的适配协议让对象能够 :ref:`将自身适配 "
"<sqlite3-conform>` 为 :ref:`原生 SQLite 类型 <sqlite3-types>`。"

#: ../../library/sqlite3.rst:1641
msgid "Exceptions"
msgstr "异常"

#: ../../library/sqlite3.rst:1643
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "异常层次是由 DB-API 2.0 (:pep:`249`) 定义的。"

#: ../../library/sqlite3.rst:1647
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"目前此异常不会被 :mod:`!sqlite3` 模块引发，但可能会被使用 :mod:`!sqlite3` "
"的应用程序引发，例如当一个用户自定义的函数在插入操作中截断了数据时。 ``Warning`` 是 :exc:`Exception` 的一个子类。"

#: ../../library/sqlite3.rst:1654
msgid ""
"The base class of the other exceptions in this module. Use this to catch all"
" errors with one single :keyword:`except` statement. ``Error`` is a subclass"
" of :exc:`Exception`."
msgstr ""
"本模块中其他异常的基类。使用它来捕捉所有的错误，只需一条 :keyword:`except` 语句。 ``Error`` 是 "
":exc:`Exception` 的子类。"

#: ../../library/sqlite3.rst:1658
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr "如果异常是产生于 SQLite 库的内部，则以下两个属性将被添加到该异常:"

#: ../../library/sqlite3.rst:1663
msgid ""
"The numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr "来自 `SQLite API <https://sqlite.org/rescode.html>`_ 的数字错误代码"

#: ../../library/sqlite3.rst:1670
msgid ""
"The symbolic name of the numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr "来自 `SQLite API <https://sqlite.org/rescode.html>`_ 的数字错误代码符号名称"

#: ../../library/sqlite3.rst:1677
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the "
":mod:`!sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"因错误使用低层级 SQLite C API 而引发的异常，换句话说，如果此异常被引发，则可能表明 :mod:`!sqlite3` 模块中存在错误。 "
"``InterfaceError`` 是 :exc:`Error` 的一个子类。"

#: ../../library/sqlite3.rst:1684
msgid ""
"Exception raised for errors that are related to the database. This serves as"
" the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"对与数据库有关的错误引发的异常。它作为几种数据库错误的基础异常。它只通过专门的子类隐式引发。 ``DatabaseError`` 是 "
":exc:`Error` 的一个子类。"

#: ../../library/sqlite3.rst:1691
msgid ""
"Exception raised for errors caused by problems with the processed data, like"
" numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"由于处理的数据有问题而产生的异常，比如数字值超出范围，字符串太长。 ``DataError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1697
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"与数据库操作有关的错误而引发的异常，不一定在程序员的控制之下。例如，数据库路径没有找到，或者一个事务无法被处理。 "
"``OperationalError`` 是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1705
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr "当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 :exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1710
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"当 SQLite 遇到一个内部错误时引发的异常。如果它被引发，可能表明运行中的 SQLite 库有问题。  ``InternalError`` 是 "
":exc:`DatabaseError` 的子类。"

#: ../../library/sqlite3.rst:1717
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a"
" closed :class:`Connection`. ``ProgrammingError`` is a subclass of "
":exc:`DatabaseError`."
msgstr ""
"针对 :mod:`!sqlite3` API 编程错误引发的异常，例如向查询提供错误数量的绑定，或试图在已关闭的 :class:`Connection`"
" 上执行操作。 ``ProgrammingError`` 是 :exc:`DatabaseError` 的一个子类。"

#: ../../library/sqlite3.rst:1724
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"在下层的 SQLite 库不支持某个方法或数据库 API 的情况下引发的异常。 例如，在 "
":meth:`~Connection.create_function` 中把 *deterministic* 设为 ``True``，而下层的 "
"SQLite 库不支持确定性函数的时候。 ``NotSupportedError`` 是 :exc:`DatabaseError` 的一个子类。"

#: ../../library/sqlite3.rst:1734
msgid "SQLite and Python types"
msgstr "SQLite 与 Python 类型"

#: ../../library/sqlite3.rst:1736
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr "SQLite 原生支持如下的类型： ``NULL``，``INTEGER``，``REAL``，``TEXT``，``BLOB``。"

#: ../../library/sqlite3.rst:1739
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "因此可以将以下Python类型发送到SQLite而不会出现任何问题："

#: ../../library/sqlite3.rst:1742 ../../library/sqlite3.rst:1759
msgid "Python type"
msgstr "Python 类型"

#: ../../library/sqlite3.rst:1742 ../../library/sqlite3.rst:1759
msgid "SQLite type"
msgstr "SQLite 类型"

#: ../../library/sqlite3.rst:1744 ../../library/sqlite3.rst:1761
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1744 ../../library/sqlite3.rst:1761
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1746 ../../library/sqlite3.rst:1763
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1746 ../../library/sqlite3.rst:1763
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1748 ../../library/sqlite3.rst:1765
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1748 ../../library/sqlite3.rst:1765
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1750
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1750 ../../library/sqlite3.rst:1767
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1752 ../../library/sqlite3.rst:1770
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1752 ../../library/sqlite3.rst:1770
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1756
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "这是SQLite类型默认转换为Python类型的方式："

#: ../../library/sqlite3.rst:1767
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "取决于 :attr:`~Connection.text_factory` , 默认为 :class:`str`"

#: ../../library/sqlite3.rst:1773
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you"
" can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters "
"<sqlite3-converters>`."
msgstr ""
":mod:`!sqlite3` 模块的类型系统可通过两种方式来扩展：你可以通过 :ref:`对象适配器 <sqlite3-adapters>` 将额外的"
" Python 类型保存在 SQLite 数据库中，你也可以让 :mod:`!sqlite3` 模块通过 :ref:`转换器 "
"<sqlite3-converters>` 将 SQLite 类型转换为不同的 Python 类型。types via."

#: ../../library/sqlite3.rst:1783
msgid "Default adapters and converters"
msgstr ""

#: ../../library/sqlite3.rst:1785
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1788
msgid ""
"The default converters are registered under the name \"date\" for "
":class:`datetime.date` and under the name \"timestamp\" for "
":class:`datetime.datetime`."
msgstr ""

#: ../../library/sqlite3.rst:1792
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""

#: ../../library/sqlite3.rst:1796
msgid "The following example demonstrates this."
msgstr ""

#: ../../library/sqlite3.rst:1800
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers,"
" its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""

#: ../../library/sqlite3.rst:1806
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"默认的 \"时间戳\" 转换器忽略了数据库中的 UTC 偏移，总是返回一个原生的 :class:`datetime.datetime` "
"对象。要在时间戳中保留 UTC 偏移，可以不使用转换器，或者用 :func:`register_converter` 注册一个偏移感知的转换器。"

#: ../../library/sqlite3.rst:1815
msgid "How-to guides"
msgstr "常用方案指引"

#: ../../library/sqlite3.rst:1820
msgid "How to use placeholders to bind values in SQL queries"
msgstr "如何在 SQL 查询中使用占位符来绑定值"

#: ../../library/sqlite3.rst:1822
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"SQL 操作通常会需要使用来自 Python 变量的值。 不过，请谨慎使用 Python 的字符串操作来拼装查询，因为这样易受 `SQL "
"injection attacks`_。 例如，攻击者可以简单地添加结束单引号并注入 ``OR TRUE`` 来选择所有的行::"

#: ../../library/sqlite3.rst:1835
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the"
" second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"请改用 DB-API 的形参替换。 要将变量插入到查询字符串中，可在字符串中使用占位符，并通过将实际值作为游标的 "
":meth:`~Cursor.execute` 方法的第二个参数以由多个值组成的 :class:`tuple` 形式提供给查询来替换它们。"

#: ../../library/sqlite3.rst:1840
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* should be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra items"
" are ignored. Here's an example of both styles:"
msgstr ""

#: ../../library/sqlite3.rst:1877
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ":pep:`249` 数字占位符已经 *不再* 被支持。 如果使用，它们将被解读为命名占位符。"

#: ../../library/sqlite3.rst:1884
msgid "How to adapt custom Python types to SQLite values"
msgstr "如何将自定义 Python 类型适配到 SQLite 值"

#: ../../library/sqlite3.rst:1886
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite 仅支持一个原生数据类型的有限集。 要在 SQLite 数据库中存储自定义 Python 类型，请将它们 *适配* 到 "
":ref:`SQLite 原生可识别的 Python 类型 <sqlite3-types>` 之一。"

#: ../../library/sqlite3.rst:1890
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"有两种方式可将 Python 对象适配到 SQLite 类型：让你的对象自行适配，或是使用 *适配器可调用对象*。 后者将优先于前者发挥作用。 "
"对于导出自定义类型的库，启用该类型的自行适配可能更为合理。 而作为一名应用程序开发者，通过注册自定义适配器函数进行直接控制可能更为合理。"

#: ../../library/sqlite3.rst:1902
msgid "How to write adaptable objects"
msgstr "如何编写可适配对象"

#: ../../library/sqlite3.rst:1904
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"假设我们有一个代表笛卡尔坐标系中的坐标值对 :class:`!Point`，``x`` 和 ``y`` 的类，该坐标值在数据库中将存储为一个文本字符串。"
" 这可以通过添加一个返回已适配值的 ``__conform__(self, protocol)`` 方法来实现。 传给 *protocol* 的对象将为"
" :class:`PrepareProtocol` 类型。"

#: ../../library/sqlite3.rst:1935
msgid "How to register adapter callables"
msgstr "如何注册适配器可调用对象"

#: ../../library/sqlite3.rst:1937
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"另一种可能的方式是创建一个将 Python 对象转换为 SQLite 兼容类型的函数。 随后可使用 :func:`register_adapter` "
"来注册该函数。"

#: ../../library/sqlite3.rst:1967
msgid "How to convert SQLite values to custom Python types"
msgstr "如何将 SQLite 值转换为自定义 Python 类型"

#: ../../library/sqlite3.rst:1969
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types,"
" we use *converters*."
msgstr ""
"编写适配器使你可以将 *from* 自定义 Python 类型转换为 *to* SQLite 值。 为了能将 *from* SQLite 值转换为 "
"*to* 自定义 Python 类型，我们可使用 *converters*。"

#: ../../library/sqlite3.rst:1974
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr "让我们回到 :class:`!Point` 类。 我们以以分号分隔的字符串形式在 SQLite 中存储了 x 和 y 坐标值。"

#: ../../library/sqlite3.rst:1977
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr "首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 :class:`!Point` 对象。"

#: ../../library/sqlite3.rst:1982
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter"
" the underlying SQLite data type."
msgstr "转换器函数 **总是** 接受传入一个 :class:`bytes` 对象，无论下层的 SQLite 数据类型是什么。"

#: ../../library/sqlite3.rst:1991
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"我们现在需要告诉 :mod:`!sqlite3` 何时应当转换一个给定的 SQLite 值。 这是在连接到一个数据库时完成的，使用 "
":func:`connect` 的 *detect_types* 形参。 有三个选项:"

#: ../../library/sqlite3.rst:1995
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "隐式: 将 *detect_types* 设为 :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:1996
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "显式: 将 *detect_types* 设为 :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:1997
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"同时: 将 *detect_types* 设为 ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``。 列名的优先级高于声明的类型。"

#: ../../library/sqlite3.rst:2001
msgid ""
"The following example illustrates the implicit and explicit approaches:"
msgstr "下面的示例演示了隐式和显式的方法:"

#: ../../library/sqlite3.rst:2052
msgid "Adapter and converter recipes"
msgstr "适配器和转换器范例程序"

#: ../../library/sqlite3.rst:2054
msgid "This section shows recipes for common adapters and converters."
msgstr "本小节显示了通用适配器和转换器的范例程序。"

#: ../../library/sqlite3.rst:2116
msgid "How to use connection shortcut methods"
msgstr "如何使用连接快捷方法"

#: ../../library/sqlite3.rst:2118
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and "
":meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the"
" (often superfluous) :class:`Cursor` objects explicitly. Instead, the "
":class:`Cursor` objects are created implicitly and these shortcut methods "
"return the cursor objects. This way, you can execute a ``SELECT`` statement "
"and iterate over it directly using only a single call on the "
":class:`Connection` object."
msgstr ""
"通过使用 :class:`Connection` 类的 :meth:`~Connection.execute`, "
":meth:`~Connection.executemany` 与 :meth:`~Connection.executescript` "
"方法，您可以简化您的代码，因为无需再显式创建 （通常是多余的） :class:`Cursor` 对象。此时 :class:`Cursor` "
"对象会被隐式创建并且由这些快捷方法返回。这样一来，您仅需在 :class:`Connection` 对象上调用一次方法就可以执行 ``SELECT`` "
"语句，并对其进行迭代。"

#: ../../library/sqlite3.rst:2159
msgid "How to use the connection context manager"
msgstr "如何使用连接上下文管理器"

#: ../../library/sqlite3.rst:2161
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""

#: ../../library/sqlite3.rst:2170
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:2174
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using "
":meth:`contextlib.closing`."
msgstr ""
"上下文管理器既不会隐式开启新事务也不会关闭连接。 如果你需要关闭上下文管理器，请考虑使用 :meth:`contextlib.closing`。"

#: ../../library/sqlite3.rst:2208
msgid "How to work with SQLite URIs"
msgstr "如何使用 SQLite URI"

#: ../../library/sqlite3.rst:2210
msgid "Some useful URI tricks include:"
msgstr "一些有用的 URI 技巧包括:"

#: ../../library/sqlite3.rst:2212
msgid "Open a database in read-only mode:"
msgstr "以只读模式打开一个数据库:"

#: ../../library/sqlite3.rst:2221
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"如果一个数据库尚不存在则不会隐式地新建数据库；如果无法新建数据库则将引发 :exc:`~sqlite3.OperationalError`:"

#: ../../library/sqlite3.rst:2231
msgid "Create a shared named in-memory database:"
msgstr "创建一个名为 shared 的内存数据库:"

#: ../../library/sqlite3.rst:2245
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr "关于此特性的更多信息，包括可用的形参列表，可以在 `SQLite URI documentation`_ 中找到。"

#: ../../library/sqlite3.rst:2254
msgid "How to create and use row factories"
msgstr "如何创建并使用行工厂对象"

#: ../../library/sqlite3.rst:2256
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a "
":class:`!tuple` does not suit your needs, you can use the "
":class:`sqlite3.Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"在默认情况下，:mod:`!sqlite3` 会以 :class:`tuple` 来表示每一行。 如果 :class:`!tuple` "
"不适合你的需求，你可以使用 :class:`sqlite3.Row` 类或自定义的 :attr:`~Cursor.row_factory`。"

#: ../../library/sqlite3.rst:2261
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the "
":class:`Cursor` and the :class:`Connection`, it is recommended to set "
":class:`Connection.row_factory`, so all cursors created from the connection "
"will use the same row factory."
msgstr ""
"虽然 :attr:`!row_factory` 同时作为 :class:`Cursor` 和 :class:`Connection` "
"的属性存在，但推荐设置 :class:`Connection.row_factory`，这样在该连接上创建的所有游标都将使用同一个行工厂对象。"

#: ../../library/sqlite3.rst:2266
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns,"
" with minimal memory overhead and performance impact over a :class:`!tuple`."
" To use :class:`!Row` as a row factory, assign it to the "
":attr:`!row_factory` attribute:"
msgstr ""
":class:`!Row` 提供了针对列的序列方式和大小写不敏感的名称方式访问，具有优于 :class:`!tuple` 的最小化内存开销和性能影响。 "
"要使用 :class:`!Row` 作为行工厂对象，请将其赋值给 :attr:`!row_factory` 属性:"

#: ../../library/sqlite3.rst:2276
msgid "Queries now return :class:`!Row` objects:"
msgstr "现在查询将返回 :class:`!Row` 对象:"

#: ../../library/sqlite3.rst:2293
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"``FROM`` 子句可以在 ``SELECT`` 语句中省略，像在上面的示例中那样。 在这种情况下，SQLite "
"将返回单独的行，其中的列由表达式来定义，例如使用字面量并给出相应的别名 ``expr AS alias``。"

#: ../../library/sqlite3.rst:2298
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as"
" a :class:`dict`, with column names mapped to values:"
msgstr ""
"你可以创建自定义 :attr:`~Cursor.row_factory` 用来返回 :class:`dict` 形式的行，将列名映射到相应的值。"

#: ../../library/sqlite3.rst:2307
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr "使用它，现在查询将返回 :class:`!dict` 而不是 :class:`!tuple`:"

#: ../../library/sqlite3.rst:2317
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "以下行工厂函数将返回一个 :term:`named tuple`:"

#: ../../library/sqlite3.rst:2328
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` 可以像下面这样使用:"

#: ../../library/sqlite3.rst:2343
msgid ""
"With some adjustments, the above recipe can be adapted to use a "
":class:`~dataclasses.dataclass`, or any other custom class, instead of a "
":class:`~collections.namedtuple`."
msgstr ""
"经过一些调整，上面的范例程序可以被适配为使用 :class:`~dataclasses.dataclass`，或任何其他自定义类，而不是 "
":class:`~collections.namedtuple`。"

#: ../../library/sqlite3.rst:2351
msgid "How to handle non-UTF-8 text encodings"
msgstr "如何处理非 UTF-8 文本编码格式"

#: ../../library/sqlite3.rst:2353
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might"
" fail for other encodings and invalid UTF-8. You can use a custom "
":attr:`~Connection.text_factory` to handle such cases."
msgstr ""
"在默认情况下，:mod:`!sqlite3` 使用 :class:`str` 来适配 ``TEXT`` 数据类型的 SQLite 值。 这对 UTF-8"
" 编码的文本来说很适用，但对于其他编码格式和无效的 UTF-8 来说则可能出错。 你可以使用自定义的 "
":attr:`~Connection.text_factory` 来处理这种情况。"

#: ../../library/sqlite3.rst:2359
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or"
" even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance "
":py:data:`!con` connected to this database, we can decode the Latin-2 "
"encoded text using this :attr:`~Connection.text_factory`:"
msgstr ""
"由于 SQLite 的 `flexible typing`_，遇到包含非 UTF-8 编码格式的 ``TEXT`` "
"数据类型甚至任意数据的表字段的情况并不少见。 作为演示，让我们假定有一个使用 ISO-8859-2 (Latin-2) "
"编码的文本的数据库，例如一个捷克语-英语字典条目的表。 假定我们现在有一个 :class:`Connection` 实例 :py:data:`!con`"
" 已连接到这个数据库，我们将可以使用这个 :attr:`~Connection.text_factory` 来解码使用 Latin-2 编码的文本："

#: ../../library/sqlite3.rst:2372
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you"
" can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"对于存储在 ``TEXT`` 表字段中的无效 UTF-8 或任意数据，你可以使用以下技巧，借用自 :ref:`unicode-howto`:"

#: ../../library/sqlite3.rst:2381
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ":mod:`!sqlite3` 模块 API 不支持包含替代符的字符串。"

#: ../../library/sqlite3.rst:2386
msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

#: ../../library/sqlite3.rst:2392
msgid "Explanation"
msgstr "说明"

#: ../../library/sqlite3.rst:2397
msgid "Transaction control"
msgstr "事务控制"

#: ../../library/sqlite3.rst:2399
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ""

#: ../../library/sqlite3.rst:2402
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before "
":meth:`~Cursor.execute` and :meth:`~Cursor.executemany` executes ``INSERT``,"
" ``UPDATE``, ``DELETE``, or ``REPLACE`` statements; for other statements, no"
" implicit transaction handling is performed. Use the "
":meth:`~Connection.commit` and :meth:`~Connection.rollback` methods to "
"respectively commit and roll back pending transactions. You can choose the "
"underlying `SQLite transaction behaviour`_ — that is, whether and what type "
"of ``BEGIN`` statements :mod:`!sqlite3` implicitly executes – via the "
":attr:`~Connection.isolation_level` attribute."
msgstr ""
"如果连接的属性 :attr:`~Connection.isolation_level` 不为 ``None``，新的事务会在 "
":meth:`~Cursor.execute` 和 :meth:`~Cursor.executemany` 执行 ``INSERT``, "
"``UPDATE``, ``DELETE`` 或 ``REPLACE`` 语句之前隐式地开启；对于其他语句，则不会执行隐式的事务处理。 可分别使用 "
":meth:`~Connection.commit` 和 :meth:`~Connection.rollback` 方法提交和回滚未应用的事务。 "
"你可以通过 :attr:`~Connection.isolation_level` 属性来选择下层的 `SQLite transaction "
"behaviour`_ — 也就是说，:mod:`!sqlite3` 是否要隐式地执行以及执行何种类型的 ``BEGIN`` 语句"

#: ../../library/sqlite3.rst:2415
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the "
":attr:`~Connection.in_transaction` attribute."
msgstr ""
"如果 :attr:`~Connection.isolation_level` 被设为 ``None``，则完全不会隐式地开启任何事务。 这将使下层 "
"SQLite 库处于 `自动提交模式`_，但也允许用户使用显式 SQL 语句执行他们自己的事务处理。 下层 SQLite 库的自动提交模式可使用 "
":attr:`~Connection.in_transaction` 属性来查询。"

#: ../../library/sqlite3.rst:2423
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
":meth:`~Cursor.executescript` 方法会在执行给定的 SQL 脚本之前隐式地提交任何挂起的事务，无论 "
":attr:`~Connection.isolation_level` 的值是什么。"

#: ../../library/sqlite3.rst:2427
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr "在以前 :mod:`!sqlite3` 会在 DDL 语句之前隐式地提交已开启的事务。 现存则不会再这样做。"

#: ../../library/sqlite3.rst:1312
msgid "? (question mark)"
msgstr "? (问号)"

#: ../../library/sqlite3.rst:1312 ../../library/sqlite3.rst:1313
msgid "in SQL statements"
msgstr "在 SQL 语句中"

#: ../../library/sqlite3.rst:1313
msgid ": (colon)"
msgstr ": (冒号)"
