# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:48+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/concurrent.futures.rst:2
msgid ":mod:`!concurrent.futures` --- Launching parallel tasks"
msgstr ":mod:`!concurrent.futures` --- 启动并行任务"

#: ../../library/concurrent.futures.rst:9
msgid ""
"**Source code:** :source:`Lib/concurrent/futures/thread.py` and "
":source:`Lib/concurrent/futures/process.py`"
msgstr ""
"**源码:** :source:`Lib/concurrent/futures/thread.py` 和 "
":source:`Lib/concurrent/futures/process.py`"

#: ../../library/concurrent.futures.rst:14
msgid ""
"The :mod:`concurrent.futures` module provides a high-level interface for "
"asynchronously executing callables."
msgstr ":mod:`concurrent.futures` 模块提供异步执行可调用对象高层接口。"

#: ../../library/concurrent.futures.rst:17
msgid ""
"The asynchronous execution can be performed with threads, using "
":class:`ThreadPoolExecutor`, or separate processes, using "
":class:`ProcessPoolExecutor`.  Both implement the same interface, which is "
"defined by the abstract :class:`Executor` class."
msgstr ""
"异步执行可以由 :class:`ThreadPoolExecutor` 使用线程或由 :class:`ProcessPoolExecutor` "
"使用单独的进程来实现。 两者都是实现抽象类 :class:`Executor` 定义的接口。"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模块在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不适用或不可用。 请参阅 "
":ref:`wasm-availability` 了解详情。"

#: ../../library/concurrent.futures.rst:25
msgid "Executor Objects"
msgstr "Executor 对象"

#: ../../library/concurrent.futures.rst:29
msgid ""
"An abstract class that provides methods to execute calls asynchronously.  It"
" should not be used directly, but through its concrete subclasses."
msgstr "抽象类提供异步执行调用方法。要通过它的子类调用，而不是直接调用。"

#: ../../library/concurrent.futures.rst:34
msgid ""
"Schedules the callable, *fn*, to be executed as ``fn(*args, **kwargs)`` and "
"returns a :class:`Future` object representing the execution of the callable."
" ::"
msgstr ""
"调度可调用对象 *fn*，以 ``fn(*args, **kwargs)`` 方式执行并返回一个代表该可调用对象的执行的 :class:`Future`"
" 对象。 ::"

#: ../../library/concurrent.futures.rst:38
msgid ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"
msgstr ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"

#: ../../library/concurrent.futures.rst:44
msgid "Similar to :func:`map(fn, *iterables) <map>` except:"
msgstr "类似于 :func:`map(fn, *iterables) <map>` 但有以下差异："

#: ../../library/concurrent.futures.rst:46
msgid "the *iterables* are collected immediately rather than lazily;"
msgstr "*iterables* 是立即执行而不是延迟执行的；"

#: ../../library/concurrent.futures.rst:48
msgid ""
"*fn* is executed asynchronously and several calls to *fn* may be made "
"concurrently."
msgstr "*fn* 是异步执行的并且可以并发对 *fn* 的多个调用。"

#: ../../library/concurrent.futures.rst:51
msgid ""
"The returned iterator raises a :exc:`TimeoutError` if "
":meth:`~iterator.__next__` is called and the result isn't available after "
"*timeout* seconds from the original call to :meth:`Executor.map`. *timeout* "
"can be an int or a float.  If *timeout* is not specified or ``None``, there "
"is no limit to the wait time."
msgstr ""
"如果 :meth:`~iterator.__next__` 被调用且从对 :meth:`Executor.map` 原始调用 *timeout* "
"秒之后其结果还不可用则已返回的迭代器将引发 :exc:`TimeoutError`。 *timeout* 可以是整数或浮点数。 如果 *timeout*"
" 未指定或为 ``None``，则不限制等待时间。"

#: ../../library/concurrent.futures.rst:57
msgid ""
"If a *fn* call raises an exception, then that exception will be raised when "
"its value is retrieved from the iterator."
msgstr "如果 *fn* 调用引发了异常，那么当从迭代器获取其值时该异常将被引发。"

#: ../../library/concurrent.futures.rst:60
msgid ""
"When using :class:`ProcessPoolExecutor`, this method chops *iterables* into "
"a number of chunks which it submits to the pool as separate tasks.  The "
"(approximate) size of these chunks can be specified by setting *chunksize* "
"to a positive integer.  For very long iterables, using a large value for "
"*chunksize* can significantly improve performance compared to the default "
"size of 1.  With :class:`ThreadPoolExecutor`, *chunksize* has no effect."
msgstr ""
"使用 :class:`ProcessPoolExecutor` 时，这个方法会将 *iterables* "
"分割任务块并作为独立的任务并提交到执行池中。这些块的大概数量可以由 *chunksize* 指定正整数设置。 对很长的迭代器来说，使用大的 "
"*chunksize* 值比默认值 1 能显著地提高性能。 *chunksize* 对 :class:`ThreadPoolExecutor` "
"没有效果。"

#: ../../library/concurrent.futures.rst:68
msgid "Added the *chunksize* argument."
msgstr "加入 *chunksize* 参数。"

#: ../../library/concurrent.futures.rst:73
msgid ""
"Signal the executor that it should free any resources that it is using when "
"the currently pending futures are done executing.  Calls to "
":meth:`Executor.submit` and :meth:`Executor.map` made after shutdown will "
"raise :exc:`RuntimeError`."
msgstr ""
"当待执行的 future 对象完成执行后向执行者发送信号，它就会释放正在使用的任何资源。 在关闭后调用 :meth:`Executor.submit` "
"和 :meth:`Executor.map` 将会引发 :exc:`RuntimeError`。"

#: ../../library/concurrent.futures.rst:78
msgid ""
"If *wait* is ``True`` then this method will not return until all the pending"
" futures are done executing and the resources associated with the executor "
"have been freed.  If *wait* is ``False`` then this method will return "
"immediately and the resources associated with the executor will be freed "
"when all pending futures are done executing.  Regardless of the value of "
"*wait*, the entire Python program will not exit until all pending futures "
"are done executing."
msgstr ""
"如果 *wait* 为 ``True`` 则此方法只有在所有待执行的 future 对象完成执行且释放已分配的资源后才会返回。 如果 *wait* 为 "
"``False``，方法立即返回，所有待执行的 future 对象完成执行后会释放已分配的资源。 不管 *wait* 的值是什么，整个 Python "
"程序将等到所有待执行的 future 对象完成执行后才退出。"

#: ../../library/concurrent.futures.rst:86
msgid ""
"If *cancel_futures* is ``True``, this method will cancel all pending futures"
" that the executor has not started running. Any futures that are completed "
"or running won't be cancelled, regardless of the value of *cancel_futures*."
msgstr ""
"如果 *cancel_futures* 为 ``True``，此方法将取消所有执行器还未开始运行的挂起的 Future。无论 "
"*cancel_futures* 的值是什么，任何已完成或正在运行的 Future 都不会被取消。"

#: ../../library/concurrent.futures.rst:91
msgid ""
"If both *cancel_futures* and *wait* are ``True``, all futures that the "
"executor has started running will be completed prior to this method "
"returning. The remaining futures are cancelled."
msgstr ""
"如果 *cancel_futures* 和 *wait* 均为 ``True``，则执行器已开始运行的所有 Future 将在此方法返回之前完成。 "
"其余的 Future 会被取消。"

#: ../../library/concurrent.futures.rst:95
msgid ""
"You can avoid having to call this method explicitly if you use the "
":keyword:`with` statement, which will shutdown the :class:`Executor` "
"(waiting as if :meth:`Executor.shutdown` were called with *wait* set to "
"``True``)::"
msgstr ""
"如果使用 :keyword:`with` 语句，你就可以避免显式调用这个方法，它将会停止 :class:`Executor` (就好像 "
":meth:`Executor.shutdown` 调用时 *wait* 设为 ``True`` 一样等待)::"

#: ../../library/concurrent.futures.rst:100
msgid ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"
msgstr ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"

#: ../../library/concurrent.futures.rst:107
msgid "Added *cancel_futures*."
msgstr "增加了 *cancel_futures*。"

#: ../../library/concurrent.futures.rst:112
msgid "ThreadPoolExecutor"
msgstr "ThreadPoolExecutor"

#: ../../library/concurrent.futures.rst:114
msgid ""
":class:`ThreadPoolExecutor` is an :class:`Executor` subclass that uses a "
"pool of threads to execute calls asynchronously."
msgstr ":class:`ThreadPoolExecutor` 是 :class:`Executor` 的子类，它使用线程池来异步执行调用。"

#: ../../library/concurrent.futures.rst:117
msgid ""
"Deadlocks can occur when the callable associated with a :class:`Future` "
"waits on the results of another :class:`Future`.  For example::"
msgstr ""
"当可调用对象已关联了一个 :class:`Future` 然后在等待另一个 :class:`Future` 的结果时就会导致死锁情况。例如::"

#: ../../library/concurrent.futures.rst:120
msgid ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b will never complete because it is waiting on a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a will never complete because it is waiting on b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"
msgstr ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b 永远不会结束因为它在等待 a。\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a 永远不会结束因为它在等待 b。\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"

#: ../../library/concurrent.futures.rst:136
msgid "And::"
msgstr "与::"

#: ../../library/concurrent.futures.rst:138
msgid ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # This will never complete because there is only one worker thread and\n"
"    # it is executing this function.\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"
msgstr ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # 这将永远不会完成因为只有一个工作线程\n"
"    # 并且它正在执行此函数。\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"

#: ../../library/concurrent.futures.rst:150
msgid ""
"An :class:`Executor` subclass that uses a pool of at most *max_workers* "
"threads to execute calls asynchronously."
msgstr ":class:`Executor` 子类使用最多 *max_workers* 个线程的线程池来异步执行调用。"

#: ../../library/concurrent.futures.rst:153
msgid ""
"All threads enqueued to ``ThreadPoolExecutor`` will be joined before the "
"interpreter can exit. Note that the exit handler which does this is executed"
" *before* any exit handlers added using ``atexit``. This means exceptions in"
" the main thread must be caught and handled in order to signal threads to "
"exit gracefully. For this reason, it is recommended that "
"``ThreadPoolExecutor`` not be used for long-running tasks."
msgstr ""
"所有排入 ``ThreadPoolExecutor`` 的队列的线程将在解释器退出之前被合并。 请注意执行此操作的 exit 处理器会在任何使用 "
"``atexit`` 添加的  exit处理器 *之前* 被执行。 这意味着主线程中的异常必须被捕获和处理以便向线程发出信号使其能够优雅地退出。 "
"由于这个原理，建议不要将 ``ThreadPoolExecutor`` 用于长期运行的任务。"

#: ../../library/concurrent.futures.rst:160
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker thread; *initargs* is a tuple of arguments passed to the initializer."
"  Should *initializer* raise an exception, all currently pending jobs will "
"raise a :exc:`~concurrent.futures.thread.BrokenThreadPool`, as well as any "
"attempt to submit more jobs to the pool."
msgstr ""
"*initializer* 是在每个工作者线程开始处调用的一个可选可调用对象。 *initargs* "
"是传递给初始化器的元组参数。任何向池提交更多工作的尝试， *initializer* 都将引发一个异常，当前所有等待的工作都会引发一个 "
":exc:`~concurrent.futures.thread.BrokenThreadPool`。"

#: ../../library/concurrent.futures.rst:166
msgid ""
"If *max_workers* is ``None`` or not given, it will default to the number of "
"processors on the machine, multiplied by ``5``, assuming that "
":class:`ThreadPoolExecutor` is often used to overlap I/O instead of CPU work"
" and the number of workers should be higher than the number of workers for "
":class:`ProcessPoolExecutor`."
msgstr ""
"如果 *max_workers* 为 ``None`` 或没有指定，将默认为机器处理器的个数，假如 "
":class:`ThreadPoolExecutor` 侧重于I/O操作而不是CPU运算，那么可以乘以 ``5`` ，同时工作线程的数量可以比 "
":class:`ProcessPoolExecutor` 的数量高。"

#: ../../library/concurrent.futures.rst:174
msgid ""
"Added the *thread_name_prefix* parameter to allow users to control the "
":class:`threading.Thread` names for worker threads created by the pool for "
"easier debugging."
msgstr ""
"增加了 *thread_name_prefix* 形参来允许用户控制由线程池创建的 :class:`threading.Thread` "
"工作线程名称以方便调试。"

#: ../../library/concurrent.futures.rst:179
#: ../../library/concurrent.futures.rst:283
msgid "Added the *initializer* and *initargs* arguments."
msgstr "加入 *initializer* 和*initargs* 参数。"

#: ../../library/concurrent.futures.rst:182
msgid ""
"Default value of *max_workers* is changed to ``min(32, os.cpu_count() + "
"4)``. This default value preserves at least 5 workers for I/O bound tasks. "
"It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. "
"And it avoids using very large resources implicitly on many-core machines."
msgstr ""
"*max_workers* 的默认值已改为 ``min(32, os.cpu_count() + 4)``。 这个默认值会保留至少 5 个工作线程用于 "
"I/O 密集型任务。 对于那些释放了 GIL 的 CPU 密集型任务，它最多会使用 32 个 CPU "
"核心。这样能够避免在多核机器上不知不觉地使用大量资源。"

#: ../../library/concurrent.futures.rst:188
msgid ""
"ThreadPoolExecutor now reuses idle worker threads before starting "
"*max_workers* worker threads too."
msgstr "现在 ThreadPoolExecutor 在启动 *max_workers* 个工作线程之前也会重用空闲的工作线程。"

#: ../../library/concurrent.futures.rst:195
msgid "ThreadPoolExecutor Example"
msgstr "ThreadPoolExecutor 例子"

#: ../../library/concurrent.futures.rst:198
msgid ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistant-subdomain.python.org/']\n"
"\n"
"# Retrieve a single page and report the URL and contents\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# We can use a with statement to ensure threads are cleaned up promptly\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Start the load operations and mark each future with its URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"
msgstr ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistant-subdomain.python.org/']\n"
"\n"
"# 获取一个页面并报告其 URL 和内容\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# 我们可以使用一个 with 语句来确保线程被迅速清理\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # 开始加载操作并以每个 Future 对象的 URL 对其进行标记\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"

#: ../../library/concurrent.futures.rst:227
msgid "ProcessPoolExecutor"
msgstr "ProcessPoolExecutor"

#: ../../library/concurrent.futures.rst:229
msgid ""
"The :class:`ProcessPoolExecutor` class is an :class:`Executor` subclass that"
" uses a pool of processes to execute calls asynchronously. "
":class:`ProcessPoolExecutor` uses the :mod:`multiprocessing` module, which "
"allows it to side-step the :term:`Global Interpreter Lock <global "
"interpreter lock>` but also means that only picklable objects can be "
"executed and returned."
msgstr ""
":class:`ProcessPoolExecutor` 类是 :class:`Executor` 的子类，它使用进程池来异步地执行调用。 "
":class:`ProcessPoolExecutor` 会使用 :mod:`multiprocessing` 模块，这允许它绕过 "
":term:`全局解释器锁 <global interpreter lock>` 但也意味着只可以处理和返回可封存的对象。"

#: ../../library/concurrent.futures.rst:236
msgid ""
"The ``__main__`` module must be importable by worker subprocesses. This "
"means that :class:`ProcessPoolExecutor` will not work in the interactive "
"interpreter."
msgstr ""
"``__main__`` 模块必须可以被工作者子进程导入。这意味着 :class:`ProcessPoolExecutor` "
"不可以工作在交互式解释器中。"

#: ../../library/concurrent.futures.rst:239
msgid ""
"Calling :class:`Executor` or :class:`Future` methods from a callable "
"submitted to a :class:`ProcessPoolExecutor` will result in deadlock."
msgstr ""
"从可调用对象中调用 :class:`Executor` 或 :class:`Future` 的方法提交给 "
":class:`ProcessPoolExecutor` 会导致死锁。"

#: ../../library/concurrent.futures.rst:244
msgid ""
"An :class:`Executor` subclass that executes calls asynchronously using a "
"pool of at most *max_workers* processes.  If *max_workers* is ``None`` or "
"not given, it will default to the number of processors on the machine. If "
"*max_workers* is less than or equal to ``0``, then a :exc:`ValueError` will "
"be raised. On Windows, *max_workers* must be less than or equal to ``61``. "
"If it is not then :exc:`ValueError` will be raised. If *max_workers* is "
"``None``, then the default chosen will be at most ``61``, even if more "
"processors are available. *mp_context* can be a :mod:`multiprocessing` "
"context or ``None``. It will be used to launch the workers. If *mp_context* "
"is ``None`` or not given, the default :mod:`multiprocessing` context is "
"used. See :ref:`multiprocessing-start-methods`."
msgstr ""

#: ../../library/concurrent.futures.rst:258
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker process; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending"
" jobs will raise a :exc:`~concurrent.futures.process.BrokenProcessPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* 是一个可选的可调用对象，它会在每个工作进程启动时被调用；*initargs* 是传给 initializer 的参数元组。 "
"如果 *initializer* 引发了异常，则所有当前在等待的任务以及任何向进程池提交更多任务的尝试都将引发 "
":exc:`~concurrent.futures.process.BrokenProcessPool`。"

#: ../../library/concurrent.futures.rst:264
msgid ""
"*max_tasks_per_child* is an optional argument that specifies the maximum "
"number of tasks a single process can execute before it will exit and be "
"replaced with a fresh worker process. By default *max_tasks_per_child* is "
"``None`` which means worker processes will live as long as the pool. When a "
"max is specified, the \"spawn\" multiprocessing start method will be used by"
" default in absence of a *mp_context* parameter. This feature is "
"incompatible with the \"fork\" start method."
msgstr ""
"*max_tasks_per_child* 是指定单个进程在其退出并替换为新工作进程之前可以执行的最大任务数量的可选参数。 在默认情况下 "
"*max_tasks_per_child* 为 ``None`` 表示工作进程将存活与进程池一样长的时间。 当指定了最大数量时，则如果不存在 "
"*mp_context* 形参则将默认使用 \"spawn\" 多进程启动方法。 此特性不能兼容 \"fork\" 启动方法。"

#: ../../library/concurrent.futures.rst:272
msgid ""
"When one of the worker processes terminates abruptly, a "
":exc:`~concurrent.futures.process.BrokenProcessPool` error is now raised. "
"Previously, behaviour was undefined but operations on the executor or its "
"futures would often freeze or deadlock."
msgstr ""
"当某个工作进程突然终止时，现在将引发 :exc:`~concurrent.futures.process.BrokenProcessPool`。 "
"在之前版本中，它的行为是未定义的但在执行器上的操作或它的 future 对象往往会被冻结或死锁。"

#: ../../library/concurrent.futures.rst:279
msgid ""
"The *mp_context* argument was added to allow users to control the "
"start_method for worker processes created by the pool."
msgstr "添加 *mp_context* 参数允许用户控制由进程池创建给工作者进程的开始方法 。"

#: ../../library/concurrent.futures.rst:286
msgid ""
"The default :mod:`multiprocessing` start method (see :ref:`multiprocessing-"
"start-methods`) will change away from *fork* in Python 3.14.  Code that "
"requires *fork* be used for their :class:`ProcessPoolExecutor` should "
"explicitly specify that by passing a "
"``mp_context=multiprocessing.get_context(\"fork\")`` parameter."
msgstr ""
"在 Python 3.14 中默认的 :mod:`multiprocessing` 启动方法 (参见 :ref:`multiprocessing-"
"start-methods`) 将改为不再使用 *fork*。 需要为其 :class:`ProcessPoolExecutor` 使用 *fork* "
"的代码应当通过传入 ``mp_context=multiprocessing.get_context(\"fork\")`` 形参来显式地指明这一点。"

#: ../../library/concurrent.futures.rst:293
msgid ""
"The *max_tasks_per_child* argument was added to allow users to control the "
"lifetime of workers in the pool."
msgstr "增加了 *max_tasks_per_child* 参数以允许用户控制进程池中工作进程的生命期。"

#: ../../library/concurrent.futures.rst:297
msgid ""
"On POSIX systems, if your application has multiple threads and the "
":mod:`multiprocessing` context uses the ``\"fork\"`` start method: The "
":func:`os.fork` function called internally to spawn workers may raise a "
":exc:`DeprecationWarning`. Pass a *mp_context* configured to use a different"
" start method. See the :func:`os.fork` documentation for further "
"explanation."
msgstr ""
"在 POSIX 系统上，如果你的应用程序有多个线程而 :mod:`multiprocessing` 上下文使用了 ``\"fork\"`` "
"启动方法：内部调用的 :func:`os.fork` 函数来生成工作进程可能会引发 :exc:`DeprecationWarning`。 "
"请传递配置为使用不同启动方法的 *mp_context*。 进一步的解释请参阅 :func:`os.fork` 文档。"

#: ../../library/concurrent.futures.rst:308
msgid "ProcessPoolExecutor Example"
msgstr "ProcessPoolExecutor 例子"

#: ../../library/concurrent.futures.rst:311
msgid ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../library/concurrent.futures.rst:346
msgid "Future Objects"
msgstr "Future 对象"

#: ../../library/concurrent.futures.rst:348
msgid ""
"The :class:`Future` class encapsulates the asynchronous execution of a "
"callable. :class:`Future` instances are created by :meth:`Executor.submit`."
msgstr ""
":class:`Future` 类将可调用对象封装为异步执行。:class:`Future` 实例由 :meth:`Executor.submit` "
"创建。"

#: ../../library/concurrent.futures.rst:353
msgid ""
"Encapsulates the asynchronous execution of a callable.  :class:`Future` "
"instances are created by :meth:`Executor.submit` and should not be created "
"directly except for testing."
msgstr ""
"将可调用对象封装为异步执行。:class:`Future` 实例由 :meth:`Executor.submit` 创建，除非测试，不应直接创建。"

#: ../../library/concurrent.futures.rst:359
msgid ""
"Attempt to cancel the call.  If the call is currently being executed or "
"finished running and cannot be cancelled then the method will return "
"``False``, otherwise the call will be cancelled and the method will return "
"``True``."
msgstr ""
"尝试取消调用。 如果调用正在执行或已结束运行不能被取消则该方法将返回 ``False``，否则调用会被取消并且该方法将返回 ``True``。"

#: ../../library/concurrent.futures.rst:366
msgid "Return ``True`` if the call was successfully cancelled."
msgstr "如果调用成功取消返回 ``True``。"

#: ../../library/concurrent.futures.rst:370
msgid ""
"Return ``True`` if the call is currently being executed and cannot be "
"cancelled."
msgstr "如果调用正在执行而且不能被取消那么返回 ``True`` 。"

#: ../../library/concurrent.futures.rst:375
msgid ""
"Return ``True`` if the call was successfully cancelled or finished running."
msgstr "如果调用已被取消或正常结束那么返回 ``True``。"

#: ../../library/concurrent.futures.rst:380
msgid ""
"Return the value returned by the call. If the call hasn't yet completed then"
" this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a :exc:`TimeoutError` will be raised. "
"*timeout* can be an int or float.  If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"返回调用所返回的值。 如果调用尚未完成则此方法将等待至多 *timeout* 秒。 如果调用在 *timeout* 秒内仍未完成，则将引发 "
":exc:`TimeoutError`。 *timeout* 可以为整数或浮点数。 如果 *timeout* 未指定或为 "
"``None``，则不限制等待时间。"

#: ../../library/concurrent.futures.rst:387
#: ../../library/concurrent.futures.rst:401
msgid ""
"If the future is cancelled before completing then :exc:`.CancelledError` "
"will be raised."
msgstr "如果 future 在完成前被取消则 :exc:`.CancelledError` 将被触发。"

#: ../../library/concurrent.futures.rst:390
msgid ""
"If the call raised an exception, this method will raise the same exception."
msgstr "如果调用引发了一个异常，这个方法也会引发同样的异常。"

#: ../../library/concurrent.futures.rst:394
msgid ""
"Return the exception raised by the call.  If the call hasn't yet completed "
"then this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a :exc:`TimeoutError` will be raised.  "
"*timeout* can be an int or float.  If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"返回调用所引发的异常。 如果调用尚未完成则此方法将等待至多 *timeout* 秒。 如果调用在 *timeout* 秒内仍未完成，则将引发 "
":exc:`TimeoutError`。 *timeout* 可以为整数或浮点数。 如果 *timeout* 未指定或为 "
"``None``，则不限制等待时间。"

#: ../../library/concurrent.futures.rst:404
msgid "If the call completed without raising, ``None`` is returned."
msgstr "如果调用正常完成那么返回 ``None``。"

#: ../../library/concurrent.futures.rst:408
msgid ""
"Attaches the callable *fn* to the future.  *fn* will be called, with the "
"future as its only argument, when the future is cancelled or finishes "
"running."
msgstr ""
"附加可调用 *fn* 到 future 对象。当 future 对象被取消或完成运行时，将会调用 *fn*，而这个 future "
"对象将作为它唯一的参数。"

#: ../../library/concurrent.futures.rst:412
msgid ""
"Added callables are called in the order that they were added and are always "
"called in a thread belonging to the process that added them.  If the "
"callable raises an :exc:`Exception` subclass, it will be logged and ignored."
"  If the callable raises a :exc:`BaseException` subclass, the behavior is "
"undefined."
msgstr ""
"加入的可调用对象总被属于添加它们的进程中的线程按加入的顺序调用。如果可调用对象引发一个 :exc:`Exception` "
"子类，它会被记录下来并被忽略掉。如果可调用对象引发一个 :exc:`BaseException` 子类，这个行为没有定义。"

#: ../../library/concurrent.futures.rst:418
msgid ""
"If the future has already completed or been cancelled, *fn* will be called "
"immediately."
msgstr "如果 future 对象已经完成或已取消，*fn* 会被立即调用。"

#: ../../library/concurrent.futures.rst:421
msgid ""
"The following :class:`Future` methods are meant for use in unit tests and "
":class:`Executor` implementations."
msgstr "下面这些 :class:`Future` 方法用于单元测试和 :class:`Executor` 实现。"

#: ../../library/concurrent.futures.rst:426
msgid ""
"This method should only be called by :class:`Executor` implementations "
"before executing the work associated with the :class:`Future` and by unit "
"tests."
msgstr "这个方法只可以在执行关联 :class:`Future`  工作之前由 :class:`Executor` 实现调用或由单测试调用。"

#: ../../library/concurrent.futures.rst:430
msgid ""
"If the method returns ``False`` then the :class:`Future` was cancelled, i.e."
" :meth:`Future.cancel` was called and returned ``True``.  Any threads "
"waiting on the :class:`Future` completing (i.e. through :func:`as_completed`"
" or :func:`wait`) will be woken up."
msgstr ""
"如果此方法返回 ``False`` 则 :class:`Future` 已被取消，即 :meth:`Future.cancel` 已被调用并返回 "
"``True``。 任何等待 :class:`Future` 完成 (即通过 :func:`as_completed` 或 :func:`wait`) "
"的线程将被唤醒。"

#: ../../library/concurrent.futures.rst:435
msgid ""
"If the method returns ``True`` then the :class:`Future` was not cancelled "
"and has been put in the running state, i.e. calls to :meth:`Future.running` "
"will return ``True``."
msgstr ""
"如果此方法返回 ``True`` 则 :class:`Future` 没有被取消并已被置为正在运行的状态，即对 "
":meth:`Future.running` 的调用将返回 ``True``。"

#: ../../library/concurrent.futures.rst:439
msgid ""
"This method can only be called once and cannot be called after "
":meth:`Future.set_result` or :meth:`Future.set_exception` have been called."
msgstr ""
"这个方法只可以被调用一次并且不能在调用 :meth:`Future.set_result` 或 :meth:`Future.set_exception`"
" 之后再调用。"

#: ../../library/concurrent.futures.rst:445
msgid ""
"Sets the result of the work associated with the :class:`Future` to *result*."
msgstr "设置将 :class:`Future` 关联工作的结果给 *result* 。"

#: ../../library/concurrent.futures.rst:448
#: ../../library/concurrent.futures.rst:461
msgid ""
"This method should only be used by :class:`Executor` implementations and "
"unit tests."
msgstr "这个方法只可以由 :class:`Executor` 实现和单元测试使用。"

#: ../../library/concurrent.futures.rst:451
#: ../../library/concurrent.futures.rst:464
msgid ""
"This method raises :exc:`concurrent.futures.InvalidStateError` if the "
":class:`Future` is already done."
msgstr ""
"如果 :class:`Future` 已经完成则此方法会引发 :exc:`concurrent.futures.InvalidStateError`。"

#: ../../library/concurrent.futures.rst:458
msgid ""
"Sets the result of the work associated with the :class:`Future` to the "
":class:`Exception` *exception*."
msgstr "设置 :class:`Future` 关联工作的结果给 :class:`Exception` *exception* 。"

#: ../../library/concurrent.futures.rst:470
msgid "Module Functions"
msgstr "模块函数"

#: ../../library/concurrent.futures.rst:474
msgid ""
"Wait for the :class:`Future` instances (possibly created by different "
":class:`Executor` instances) given by *fs* to complete. Duplicate futures "
"given to *fs* are removed and will be returned only once. Returns a named "
"2-tuple of sets.  The first set, named ``done``, contains the futures that "
"completed (finished or cancelled futures) before the wait completed.  The "
"second set, named ``not_done``, contains the futures that did not complete "
"(pending or running futures)."
msgstr ""
"等待由 *fs* 指定的 :class:`Future` 实例（可能由不同的 :class:`Executor` 实例创建）完成。 重复传给 *fs* "
"的 future 会被移除并将只返回一次。 返回一个由集合组成的具名 2 元组。 第一个集合的名称为 ``done``，包含在等待完成之前已完成的 "
"future（包括正常结束或被取消的 future）。 第二个集合的名称为 ``not_done``，包含未完成的 future（包括挂起的或正在运行的"
" future）。"

#: ../../library/concurrent.futures.rst:482
msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* 可以用来控制返回前最大的等待秒数。 *timeout* 可以为 int 或 float 类型。 如果 *timeout* 未指定或为"
" ``None`` ，则不限制等待时间。"

#: ../../library/concurrent.futures.rst:486
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants:"
msgstr "*return_when* 指定此函数应在何时返回。它必须为以下常数之一:"

#: ../../library/concurrent.futures.rst:492
msgid "Constant"
msgstr "常量"

#: ../../library/concurrent.futures.rst:493
msgid "Description"
msgstr "描述"

#: ../../library/concurrent.futures.rst:496
msgid "The function will return when any future finishes or is cancelled."
msgstr "函数将在任意可等待对象结束或取消时返回。"

#: ../../library/concurrent.futures.rst:499
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""
"该函数将在任何 future 对象通过引发异常而结束时返回。 如果没有任何 future 对象引发引发那么它将等价于 "
":const:`ALL_COMPLETED`。"

#: ../../library/concurrent.futures.rst:504
msgid "The function will return when all futures finish or are cancelled."
msgstr "函数将在所有可等待对象结束或取消时返回。"

#: ../../library/concurrent.futures.rst:508
msgid ""
"Returns an iterator over the :class:`Future` instances (possibly created by "
"different :class:`Executor` instances) given by *fs* that yields futures as "
"they complete (finished or cancelled futures). Any futures given by *fs* "
"that are duplicated will be returned once. Any futures that completed before"
" :func:`as_completed` is called will be yielded first.  The returned "
"iterator raises a :exc:`TimeoutError` if :meth:`~iterator.__next__` is "
"called and the result isn't available after *timeout* seconds from the "
"original call to :func:`as_completed`.  *timeout* can be an int or float. If"
" *timeout* is not specified or ``None``, there is no limit to the wait time."
msgstr ""
"返回一个迭代器，每当 *fs* 所给出的 :class:`Future` 实例（可能由不同的 :class:`Executor` "
"实例创建）完成时这个迭代器会产生新的 future（包括正常结束或被取消的 future 对象）。 任何由 *fs* 给出的重复的 future "
"对象将只被返回一次。 任何在 :func:`as_completed` 被调用之前完成的 future 对象将优先被产生。 如果 "
":meth:`~iterator.__next__` 被调用并且在最初调用 :func:`as_completed` 之后的 *timeout* "
"秒内其结果仍不可用，这个迭代器将引发 :exc:`TimeoutError`。 *timeout* 可以为整数或浮点数。 如果 *timeout* "
"未指定或为 ``None``，则不限制等待时间。"

#: ../../library/concurrent.futures.rst:521
msgid ":pep:`3148` -- futures - execute computations asynchronously"
msgstr ":pep:`3148` -- future 对象 - 异步执行指令。"

#: ../../library/concurrent.futures.rst:522
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "该提案描述了Python标准库中包含的这个特性。"

#: ../../library/concurrent.futures.rst:527
msgid "Exception classes"
msgstr "Exception 类"

#: ../../library/concurrent.futures.rst:533
msgid "Raised when a future is cancelled."
msgstr "future 对象被取消时会触发。"

#: ../../library/concurrent.futures.rst:537
msgid ""
"A deprecated alias of :exc:`TimeoutError`, raised when a future operation "
"exceeds the given timeout."
msgstr ":exc:`TimeoutError` 的一个已被弃用的别名，会在 future 操作超出了给定的时限时被引发。"

#: ../../library/concurrent.futures.rst:542
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "这个类是 :exc:`TimeoutError` 的别名。"

#: ../../library/concurrent.futures.rst:547
msgid ""
"Derived from :exc:`RuntimeError`, this exception class is raised when an "
"executor is broken for some reason, and cannot be used to submit or execute "
"new tasks."
msgstr "当执行器被某些原因中断而且不能用来提交或执行新任务时就会被引发派生于 :exc:`RuntimeError` 的异常类。"

#: ../../library/concurrent.futures.rst:555
msgid ""
"Raised when an operation is performed on a future that is not allowed in the"
" current state."
msgstr "当某个操作在一个当前状态所不允许的 future 上执行时将被引发。"

#: ../../library/concurrent.futures.rst:564
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor`, this exception class"
" is raised when one of the workers of a "
":class:`~concurrent.futures.ThreadPoolExecutor` has failed initializing."
msgstr ""
"派生自 :exc:`~concurrent.futures.BrokenExecutor`，这个异常类会在 "
":class:`~concurrent.futures.ThreadPoolExecutor` 的某个工作线程初始化失败时被引发。"

#: ../../library/concurrent.futures.rst:575
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor` (formerly "
":exc:`RuntimeError`), this exception class is raised when one of the workers"
" of a :class:`~concurrent.futures.ProcessPoolExecutor` has terminated in a "
"non-clean fashion (for example, if it was killed from the outside)."
msgstr ""
"派生自 :exc:`~concurrent.futures.BrokenExecutor` (原为 "
":exc:`RuntimeError`)，这个异常类会在 "
":class:`~concurrent.futures.ProcessPoolExecutor` "
"的某个工作进程以不完整的方式终结（例如，从外部杀掉）时被引发。"
