# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Arisaka97 <solitaire2312@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# 1lin24 <1lin24@sina.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/os.path.rst:2
msgid ":mod:`!os.path` --- Common pathname manipulations"
msgstr ":mod:`!os.path` --- 常用的路径操作"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` "
"(for POSIX) and :source:`Lib/ntpath.py` (for Windows)."
msgstr ""
"**源代码:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` (用于 POSIX)"
" 和 :source:`Lib/ntpath.py` (用于 Windows)。"

#: ../../library/os.path.rst:14
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"此模块实现了一些有用的路径名称相关函数。 要读取或写入文件请参见 :func:`open`，对于访问文件系统请参阅 :mod:`os` 模块。 传给 "
"path 形参的可以是字符串、字节串或者任何实现了 :class:`os.PathLike` 协议的对象。"

#: ../../library/os.path.rst:19
msgid ""
"Unlike a Unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also"
" the :mod:`glob` module.)"
msgstr ""
"与 Unix 不同，Python 不会执行任何 *自动* 路径扩展。 当应用程序需要类似 shell 的路径扩展时，可以显式地唤起 "
":func:`expanduser` 和 :func:`expandvars` 这样的函数。 （另请参阅 :mod:`glob` 模块。）"

#: ../../library/os.path.rst:26
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr ":mod:`pathlib` 模块提供高级路径对象。"

#: ../../library/os.path.rst:31
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr "所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。"

#: ../../library/os.path.rst:37
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The "
":mod:`os.path` module is always the path module suitable for the operating "
"system Python is running on, and therefore usable for local paths.  However,"
" you can also import and use the individual modules if you want to "
"manipulate a path that is *always* in one of the different formats.  They "
"all have the same interface:"
msgstr ""
"由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。:mod:`os.path` 模块始终是适合 Python "
"运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 *总是* "
"以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口："

#: ../../library/os.path.rst:45
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` 用于Unix 样式的路径"

#: ../../library/os.path.rst:46
msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` 用于 Windows 路径"

#: ../../library/os.path.rst:51
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, "
":func:`islink`, and :func:`ismount` now return ``False`` instead of raising "
"an exception for paths that contain characters or bytes unrepresentable at "
"the OS level."
msgstr ""
":func:`exists`、:func:`lexists`、:func:`isdir`、:func:`isfile`、:func:`islink` 和"
" :func:`ismount` 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 ``False``，而不是抛出异常。"

#: ../../library/os.path.rst:59
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"返回路径 *path* 的绝对路径（标准化的）。在大多数平台上，这等同于用 ``normpath(join(os.getcwd(), path))`` "
"的方式调用 :func:`normpath` 函数。"

#: ../../library/os.path.rst:63 ../../library/os.path.rst:76
#: ../../library/os.path.rst:117 ../../library/os.path.rst:126
#: ../../library/os.path.rst:142 ../../library/os.path.rst:152
#: ../../library/os.path.rst:178 ../../library/os.path.rst:198
#: ../../library/os.path.rst:215 ../../library/os.path.rst:227
#: ../../library/os.path.rst:236 ../../library/os.path.rst:246
#: ../../library/os.path.rst:260 ../../library/os.path.rst:270
#: ../../library/os.path.rst:289 ../../library/os.path.rst:308
#: ../../library/os.path.rst:380 ../../library/os.path.rst:400
#: ../../library/os.path.rst:423 ../../library/os.path.rst:443
#: ../../library/os.path.rst:459 ../../library/os.path.rst:470
#: ../../library/os.path.rst:484 ../../library/os.path.rst:500
#: ../../library/os.path.rst:525 ../../library/os.path.rst:589
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../library/os.path.rst:69
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"返回路径 *path* 的基本名称。这是将 *path* 传入函数 :func:`split` "
"之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix :program:`basename` "
"程序不同。:program:`basename` 在 ``'/foo/bar/'`` 上返回 ``'bar'``，而 :func:`basename` "
"函数返回一个空字符串 (``''``)。"

#: ../../library/os.path.rst:82
msgid ""
"Return the longest common sub-path of each pathname in the iterable *paths*."
"  Raise :exc:`ValueError` if *paths* contain both absolute and relative "
"pathnames, if *paths* are on different drives, or if *paths* is empty.  "
"Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"返回可迭代对象 *paths* 中每个路径名称的最长共同子路径。 如果 *paths* 同时包含绝对和相对路径名称，如果 *paths* "
"位于不同驱动器，或者如果 *paths* 为空则会引发 :exc:`ValueError`。 不同于 "
":func:`commonprefix`，此函数将返回一个有效的路径。"

#: ../../library/os.path.rst:90
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr "接受一个 :term:`类路径对象 <path-like object>` 序列。"

#: ../../library/os.path.rst:93
msgid "Any iterable can now be passed, rather than just sequences."
msgstr "现在可以传入任意可迭代对象，而不只是序列。"

#: ../../library/os.path.rst:99
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string"
" (``''``)."
msgstr "接受包含多个路径的 *列表*，返回所有路径的最长公共前缀（逐字符比较）。如果 *列表* 为空，则返回空字符串 (``''``)。"

#: ../../library/os.path.rst:105
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr "此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 :func:`commonpath`。"

#: ../../library/os.path.rst:111
msgid ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib'])\n"
"'/usr/l'\n"
"\n"
">>> os.path.commonpath(['/usr/lib', '/usr/local/lib'])\n"
"'/usr'"
msgstr ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib'])\n"
"'/usr/l'\n"
"\n"
">>> os.path.commonpath(['/usr/lib', '/usr/local/lib'])\n"
"'/usr'"

#: ../../library/os.path.rst:123
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr "返回路径 *path* 的目录名称。这是将 *path* 传入函数 :func:`split` 之后，返回的一对值中的第一个元素。"

#: ../../library/os.path.rst:132
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"如果 *path* 指向一个已存在的路径或已打开的文件描述符，返回 ``True``。对于失效的符号链接，返回 "
"``False``。在某些平台上，如果使用 :func:`os.stat` 查询到目标文件没有执行权限，即使 *path* 确实存在，本函数也可能返回 "
"``False``。"

#: ../../library/os.path.rst:138
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr "*path* 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 ``True``，否则返回 ``False``。"

#: ../../library/os.path.rst:148
msgid ""
"Return ``True`` if *path* refers to an existing path, including broken "
"symbolic links.   Equivalent to :func:`exists` on platforms lacking "
":func:`os.lstat`."
msgstr ""
"如果 *path* 指向一个已存在的路径，包括失效的符号链接则返回 ``True``。 在缺少 :func:`os.lstat` 的平台上就等价于 "
":func:`exists`。"

#: ../../library/os.path.rst:160
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr "在 Unix 和 Windows 上，将参数中开头部分的 ``~`` 或 ``~user`` 替换为当前 *用户* 的家目录并返回。"

#: ../../library/os.path.rst:165
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable "
":envvar:`HOME` if it is set; otherwise the current user's home directory is "
"looked up in the password directory through the built-in module :mod:`pwd`. "
"An initial ``~user`` is looked up directly in the password directory."
msgstr ""
"在 Unix 上，开头的 ``~`` 会被环境变量 :envvar:`HOME` 代替，如果变量未设置，则通过内置模块 :mod:`pwd` 在 "
"password 目录中查找当前用户的主目录。以 ``~user`` 开头则直接在 password 目录中查找。"

#: ../../library/os.path.rst:170
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"在 Windows 上，如果 :envvar:`USERPROFILE` 已设置将会被使用，否则 :envvar:`HOMEPATH` 和 "
":envvar:`HOMEDRIVE` 将被组合起来使用。 初始的 ``~user`` 会通过检查当前用户的家目录中匹配 "
":envvar:`USERNAME` 的最后一部分目录名并执行替换来处理。"

#: ../../library/os.path.rst:175
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr "如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。"

#: ../../library/os.path.rst:181
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Windows 不再使用 :envvar:`HOME`。"

#: ../../library/os.path.rst:190
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"输入带有环境变量的路径作为参数，返回展开变量以后的路径。``$name`` 或 ``${name}`` 形式的子字符串被环境变量 *name* "
"的值替换。格式错误的变量名称和对不存在变量的引用保持不变。"

#: ../../library/os.path.rst:195
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and"
" ``${name}``."
msgstr "在 Windows 上，除了 ``$name`` 和 ``${name}`` 外，还可以展开 ``%name%``。"

#: ../../library/os.path.rst:204
msgid ""
"Return the time of last access of *path*.  The return value is a floating-"
"point number giving the number of seconds since the epoch (see the  "
":mod:`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"返回 *path* 的最后访问时间。返回值是一个浮点数，为纪元秒数（参见 :mod:`time` 模块）。如果该文件不存在或不可访问，则抛出 "
":exc:`OSError` 异常。"

#: ../../library/os.path.rst:211
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating-point number giving the number of seconds since the epoch (see the"
"  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or is"
" inaccessible."
msgstr ""
"返回 *path* 的最后修改时间。返回值是一个浮点数，为纪元秒数（参见 :mod:`time` 模块）。如果该文件不存在或不可访问，则抛出 "
":exc:`OSError` 异常。"

#: ../../library/os.path.rst:221
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"返回 *path* 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 "
"*path* 的创建时间。返回值是一个数，为纪元秒数（参见 :mod:`time` 模块）。如果该文件不存在或不可访问，则抛出 "
":exc:`OSError` 异常。"

#: ../../library/os.path.rst:233
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does"
" not exist or is inaccessible."
msgstr "返回 *path* 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 :exc:`OSError` 异常。"

#: ../../library/os.path.rst:242
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with two (back)slashes, or a "
"drive letter, colon, and (back)slash together."
msgstr ""
"如果 *path* 为绝对路径则返回 ``True``。 在 Unix 上，意味着它是以斜杠打头的，在 Windows "
"上它是以两个（反）斜杠，或是由驱动器号、冒号和（反斜杠）连在一起打头的。"

#: ../../library/os.path.rst:249
msgid ""
"On Windows, returns ``False`` if the given path starts with exactly one "
"(back)slash."
msgstr "在 Windows 上，如果给定的路径是以一个单独（反）斜杠打头则返回 ``False``。"

#: ../../library/os.path.rst:256
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This"
" follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"如果 *path* 是 :func:`现有的 <exists>` 常规文件，则返回 "
"``True``。本方法会跟踪符号链接，因此，对于同一路径，:func:`islink` 和 :func:`isfile` 都可能为 ``True``。"

#: ../../library/os.path.rst:266
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true"
" for the same path."
msgstr ""
"如果 *path* 是 :func:`现有的 <exists>` 目录，则返回 "
"``True``。本方法会跟踪符号链接，因此，对于同一路径，:func:`islink` 和 :func:`isdir` 都可能为 ``True``。"

#: ../../library/os.path.rst:276
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <lexists>` directory "
"entry that is a junction.  Always return ``False`` if junctions are not "
"supported on the current platform."
msgstr ""
"Return ``True`` 如果 *path* 指向的 :func:`现有 <lexists>` 目录条目是一个连接点。 "
"则当连接点在当前平台不受支持时将总是返回 ``False``。"

#: ../../library/os.path.rst:285
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"如果 *path* 指向的 :func:`现有 <exists>` 目录条目是一个符号链接，则返回 ``True``。如果 Python "
"运行时不支持符号链接，则总是返回 ``False``。"

#: ../../library/os.path.rst:295
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem.  On Windows, a drive letter root and a share "
"UNC are always mount points, and for any other path ``GetVolumePathName`` is"
" called to see if it is different from the input path."
msgstr ""
"如果路径 *path* 是 :dfn:`挂载点` （文件系统中挂载其他文件系统的点），则返回 ``True``。在 POSIX 上，该函数检查 "
"*path* 的父目录 :file:`{path}/..` 是否在与 *path* 不同的设备上，或者 :file:`{path}/..` 和 "
"*path* 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX "
"变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC "
"始终是挂载点，对于任何其他路径，将调用 ``GetVolumePathName`` 来查看它是否与输入的路径不同。"

#: ../../library/os.path.rst:305
msgid "Added support for detecting non-root mount points on Windows."
msgstr "增加了在 Windows 上检测非根挂载点的支持。"

#: ../../library/os.path.rst:314
msgid ""
"Return ``True`` if pathname *path* is located on a Windows Dev Drive. A Dev "
"Drive is optimized for developer scenarios, and offers faster performance "
"for reading and writing files. It is recommended for use for source code, "
"temporary build directories, package caches, and other IO-intensive "
"operations."
msgstr ""
"如果路径名 *path* 位于一个 Windows Dev 驱动器则返回 ``True``。 Dev Drive "
"针对开发者场景进行了优化，并为读写文件提供更快的性能。 推荐用于源代码、临时构建目录、包缓存以及其他的 IO 密集型操作。"

#: ../../library/os.path.rst:320
msgid ""
"May raise an error for an invalid path, for example, one without a "
"recognizable drive, but returns ``False`` on platforms that do not support "
"Dev Drives. See `the Windows documentation "
"<https://learn.microsoft.com/windows/dev-drive/>`_ for information on "
"enabling and creating Dev Drives."
msgstr ""
"对于无效的路径可能引发错误，例如，没有可识别的驱动器的路径，但在不支持 Dev 驱动器的平台上将返回 ``False``。 请参阅 `Windows "
"文档 <https://learn.microsoft.com/windows/dev-drive/>`_ 了解有关启用并创建 Dev 驱动器的信息。"

#: ../../library/os.path.rst:327
msgid ""
"The function is now available on all platforms, and will always return "
"``False`` on those that have no support for Dev Drives"
msgstr "现在此函数在所有平台上可用，并且在不支持 Dev 驱动器的平台上将总是返回 ``False``。"

#: ../../library/os.path.rst:333
msgid ""
"Return ``True`` if *path* is a reserved pathname on the current system."
msgstr "如果 *path* 为当前系统的保留路径名则返回 ``True``。"

#: ../../library/os.path.rst:335
msgid ""
"On Windows, reserved filenames include those that end with a space or dot; "
"those that contain colons (i.e. file streams such as \"name:stream\"), "
"wildcard characters (i.e. ``'*?\"<>'``), pipe, or ASCII control characters; "
"as well as DOS device names such as \"NUL\", \"CON\", \"CONIN$\", "
"\"CONOUT$\", \"AUX\", \"PRN\", \"COM1\", and \"LPT1\"."
msgstr ""
"在 Windows 上，保留文件名包括以一个空格或点号结尾的；包含冒号的 (即文件流如 \"name:stream\")，通配符 (即 "
"``'*?\"<>'``)，管道或 ASCII 控制符；以及 DOS 设备名称如 \"NUL\", \"CON\", \"CONIN$\", "
"\"CONOUT$\", \"AUX\", \"PRN\", \"COM1\" 和 \"LPT1\"。"

#: ../../library/os.path.rst:343
msgid ""
"This function approximates rules for reserved paths on most Windows systems."
" These rules change over time in various Windows releases. This function may"
" be updated in future Python releases as changes to the rules become broadly"
" available."
msgstr ""
"此函数在多数 Windows 系统上使用相似的保留路径规则。 这些规则会随着时间的推移在不同的 Windows 发布版中发生改变。 "
"此函数可能会随着规则的更改广泛可用在未来的 Python 发布版中被更新。"

#: ../../library/os.path.rst:348
msgid "Availability"
msgstr "Availability"

#: ../../library/os.path.rst:355
msgid ""
"Join one or more path segments intelligently.  The return value is the "
"concatenation of *path* and all members of *\\*paths*, with exactly one "
"directory separator following each non-empty part, except the last. That is,"
" the result will only end in a separator if the last part is either empty or"
" ends in a separator. If a segment is an absolute path (which on Windows "
"requires both a drive and a root), then all previous segments are ignored "
"and joining continues from the absolute path segment."
msgstr ""
"智能地合并一个或多个路径部分。 返回值将是 *path* 和所有 *\\*paths* "
"成员的拼接，其中每个非空部分后面都紧跟一个目录分隔符，最后一个除外。 也就是说，如果最后一个部分为空或是以一个分隔符结束则结果将仅以一个分隔符结束。 "
"如果某个部分为绝对路径（在 Windows 上需要同时有驱动器号和根路径符号），则之前的所有部分会被忽略并从该绝对路径部分开始拼接。"

#: ../../library/os.path.rst:363
msgid ""
"On Windows, the drive is not reset when a rooted path segment (e.g., "
"``r'\\foo'``) is encountered. If a segment is on a different drive or is an "
"absolute path, all previous segments are ignored and the drive is reset. "
"Note that since there is a current directory for each drive, "
"``os.path.join(\"c:\", \"foo\")`` represents a path relative to the current "
"directory on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"在 Windows，当遇到绝对路径部分 (如 ``r'\\foo'``) 时驱动器号将不会被重置。 "
"如果某个部分位于不同驱动器或为绝对路径，则之前的所有部分会被忽略并且该驱动器号会被重置。 请注意由于每个驱动器都有一个当前目录，因此 "
"``os.path.join(\"c:\", \"foo\")`` 是代表驱动器 :file:`C:` 上当前路径的相对路径 "
"(:file:`c:foo`)，而不是 :file:`c:\\\\foo`。"

#: ../../library/os.path.rst:370
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "接受一个 :term:`类路径对象 <path-like object>` 用于 *path* 和 *paths* 。"

#: ../../library/os.path.rst:376
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the"
" pathname to lowercase, and also convert forward slashes to backward "
"slashes. On other operating systems, return the path unchanged."
msgstr "规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。"

#: ../../library/os.path.rst:386
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 ``A//B``、``A/B/``、``A/./B`` 和 ``A/foo/../B`` "
"都会转换成 ``A/B``。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 "
":func:`normcase`。"

#: ../../library/os.path.rst:393
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution "
"<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_,"
" if a pathname begins with exactly two slashes, the first component "
"following the leading characters may be interpreted in an implementation-"
"defined manner, although more than two leading characters shall be treated "
"as a single character."
msgstr ""
"在 POSIX 系统上，根据 `IEEE Std 1003.1 2013 Edition; 4.13 Pathname Resolution "
"<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_，如果一个路径名称以两个斜杠开始，则开始字符之后的第一个部分将以具体实现所定义的方式来解读，但是超过两个开始字符则将被视为单个字符。"

#: ../../library/os.path.rst:406
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system). On Windows, this function will also resolve MS-DOS (also "
"called 8.3) style names such as ``C:\\\\PROGRA~1`` to ``C:\\\\Program "
"Files``."
msgstr ""
"返回指定文件名的规范路径，去除在路径中出现的任何符号链接（如果操作系统支持的话）。 在 Windows 上，此函数也会将 MS-DOS (或称 8.3)"
" 风格的名称如 ``C:\\\\PROGRA~1`` 解析为 ``C:\\\\Program Files``。"

#: ../../library/os.path.rst:411
msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised. If *strict* is ``False`` these errors "
"are ignored, and so the result might be missing or otherwise inaccessible."
msgstr ""
"如果一个路径不存在或是遇到了符号链接循环，并且 *strict* 为 ``True``，则会引发 :exc:`OSError`。 如果 *strict*"
" 为 ``False`` 则这些错误将被忽略，因此结果可能缺失或无法访问。"

#: ../../library/os.path.rst:416
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr "这个函数会模拟操作系统生成规范路径的过程，Windows 与 UNIX 的这个过程在处理链接和后续路径组成部分的交互方式上有所差异。"

#: ../../library/os.path.rst:420
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr "操作系统 API 会根据需要来规范化路径，因此通常不需要调用此函数。"

#: ../../library/os.path.rst:426
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。"

#: ../../library/os.path.rst:429
msgid "The *strict* parameter was added."
msgstr "增加了 *strict* 形参。"

#: ../../library/os.path.rst:435
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"返回从当前目录或可选的 *start* 目录至 *path* 的相对文件路径。 这只是一个路径计算：不会访问文件系统来确认 *path* 或 "
"*start* 是否存在或其性质。 在 Windows 上，当 *path* 和 *start* 位于不同驱动器时将引发 "
":exc:`ValueError`。"

#: ../../library/os.path.rst:441
msgid "*start* defaults to :data:`os.curdir`."
msgstr "*start* 默认为 :data:`os.curdir`。"

#: ../../library/os.path.rst:449
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"如果两个路径都指向相同的文件或目录，则返回 ``True``。这由设备号和 inode 号确定，在任一路径上调用 :func:`os.stat` "
"失败则抛出异常。"

#: ../../library/os.path.rst:453 ../../library/os.path.rst:467
#: ../../library/os.path.rst:481
msgid "Added Windows support."
msgstr "添加了对 Windows 的支持。"

#: ../../library/os.path.rst:456
msgid "Windows now uses the same implementation as all other platforms."
msgstr "Windows现在使用与其他所有平台相同的实现。"

#: ../../library/os.path.rst:465
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr "如果文件描述符 *fp1* 和 *fp2* 指向相同文件，则返回 ``True``。"

#: ../../library/os.path.rst:476
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, "
":func:`os.lstat`, or :func:`os.stat`.  This function implements the "
"underlying comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"如果 stat 元组 *stat1* 和 *stat2* 指向相同文件，则返回 ``True``。这些 stat 元组可能是由 "
":func:`os.fstat`、:func:`os.lstat` 或 :func:`os.stat` 返回的。本函数实现了 "
":func:`samefile` 和 :func:`sameopenfile` 底层所使用的比较过程。"

#: ../../library/os.path.rst:490
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname`"
" and :func:`basename`."
msgstr ""
"将路径 *path* 拆分为一对，即 ``(head, tail)``，其中，*tail* 是路径的最后一部分，而 *head* "
"里是除最后部分外的所有内容。*tail* 部分不会包含斜杠，如果 *path* 以斜杠结尾，则 *tail* 将为空。如果 *path* "
"中没有斜杠，*head* 将为空。如果 *path* 为空，则 *head* 和 *tail* 均为空。*head* "
"末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，``join(head, tail)`` 指向的位置都与 *path* "
"相同（但字符串可能不同）。另请参见函数 :func:`dirname` 和 :func:`basename`。"

#: ../../library/os.path.rst:506
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive"
" specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"将路径 *path* 拆分为一对，即 ``(drive, tail)``，其中 *drive* "
"是挂载点或空字符串。在没有驱动器概念的系统上，*drive* 将始终为空字符串。在所有情况下，``drive + tail`` 都与 *path* "
"相同。"

#: ../../library/os.path.rst:511
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr "在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。"

#: ../../library/os.path.rst:513
msgid ""
"If the path contains a drive letter, drive will contain everything up to and"
" including the colon::"
msgstr "如果路径 path 包含盘符，则 drive 将包含冒号之前的所有内容包括冒号本身::"

#: ../../library/os.path.rst:516
msgid ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"
msgstr ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"

#: ../../library/os.path.rst:519
msgid ""
"If the path contains a UNC path, drive will contain the host name and "
"share::"
msgstr "如果路径包含 UNC 路径，则 drive 将包含主机名和 share::"

#: ../../library/os.path.rst:522
msgid ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"
msgstr ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"

#: ../../library/os.path.rst:531
msgid ""
"Split the pathname *path* into a 3-item tuple ``(drive, root, tail)`` where "
"*drive* is a device name or mount point, *root* is a string of separators "
"after the drive, and *tail* is everything after the root. Any of these items"
" may be the empty string. In all cases, ``drive + root + tail`` will be the "
"same as *path*."
msgstr ""
"将路径名 *path* 拆分为一个 3 元组 ``(drive, root, tail)`` 其中 *drive* 是设置名或挂载点，*root* "
"是表示 drive 之后的分隔符的字符串，而 *tail* 则为 root 之后的所有内容。 这此条目均可以为空字符串。 在所有情况下，``drive "
"+ root + tail`` 都与 *path* 相同。"

#: ../../library/os.path.rst:537
msgid ""
"On POSIX systems, *drive* is always empty. The *root* may be empty (if "
"*path* is relative), a single forward slash (if *path* is absolute), or two "
"forward slashes (implementation-defined per `IEEE Std 1003.1-2017; 4.13 "
"Pathname Resolution "
"<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_.)"
" For example::"
msgstr ""
"在 POSIX 系统上，*drive* 将总是为空。 *root* 可能为空（如果 *path* 是相对路径）、单个正斜杠（如果 *path* "
"是绝对路径）、或两个正斜杠（由基于 `IEEE Std 1003.1-2017; 4.13 Pathname Resolution "
"<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_"
" 的具体实现来定义。） 例如::"

#: ../../library/os.path.rst:543
msgid ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"
msgstr ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"

#: ../../library/os.path.rst:550
msgid ""
"On Windows, *drive* may be empty, a drive-letter name, a UNC share, or a "
"device name. The *root* may be empty, a forward slash, or a backward slash. "
"For example::"
msgstr ""
"在 Windows 上，*drive* 可能为空、以字母表示的驱动器名称、UNC share 或是设备名称。 *root* "
"可能为空、单个正斜杠，或单个反斜杠。 例如::"

#: ../../library/os.path.rst:554
msgid ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"
msgstr ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"

#: ../../library/os.path.rst:564
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"将路径名称 *path* 拆分为 ``(root, ext)``  对使得 ``root + ext == path``，并且扩展名 *ext* "
"为空或以句点打头并最多只包含一个句点。"

#: ../../library/os.path.rst:568
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "如果路径 path 不包含扩展名，则 *ext* 将为 ``''``::"

#: ../../library/os.path.rst:570
msgid ""
">>> splitext('bar')\n"
"('bar', '')"
msgstr ""
">>> splitext('bar')\n"
"('bar', '')"

#: ../../library/os.path.rst:573
msgid ""
"If the path contains an extension, then *ext* will be set to this extension,"
" including the leading period. Note that previous periods will be ignored::"
msgstr "如果路径 path 包含扩展名，则 *ext* 将被设为该扩展名，包括打头的句点。 请注意在其之前的句点将被忽略::"

#: ../../library/os.path.rst:576
msgid ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"
msgstr ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"

#: ../../library/os.path.rst:581
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr "path 中最后一部分如果以点号开头则会被视为 root 的一部分::"

#: ../../library/os.path.rst:584
msgid ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"
msgstr ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"

#: ../../library/os.path.rst:595
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr "如果（在文件系统限制下）允许将任意 Unicode 字符串用作文件名，则为 ``True``。"

#: ../../library/os.path.rst:10
msgid "path"
msgstr "path"

#: ../../library/os.path.rst:10
msgid "operations"
msgstr "操作"

#: ../../library/os.path.rst:156
msgid "~ (tilde)"
msgstr "~ (波浪号)"

#: ../../library/os.path.rst:156
msgid "home directory expansion"
msgstr "主目录扩展"

#: ../../library/os.path.rst:163
msgid "module"
msgstr "module"

#: ../../library/os.path.rst:163
msgid "pwd"
msgstr "pwd"

#: ../../library/os.path.rst:184
msgid "$ (dollar)"
msgstr "$ (货币符号)"

#: ../../library/os.path.rst:184
msgid "environment variables expansion"
msgstr "环境变量扩展"

#: ../../library/os.path.rst:184
msgid "% (percent)"
msgstr "% (百分号)"

#: ../../library/os.path.rst:184
msgid "environment variables expansion (Windows)"
msgstr "环境变量扩展 (Windows)"
