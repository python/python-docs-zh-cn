# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ProgramRipper, 2023
# Freesand Leo <yuqinju@163.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-02 14:19+0000\n"
"PO-Revision-Date: 2022-11-05 19:48+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-extending.rst:6
msgid "Extending"
msgstr "扩展"

#: ../../library/asyncio-extending.rst:8
msgid ""
"The main direction for :mod:`asyncio` extending is writing custom *event "
"loop* classes. Asyncio has helpers that could be used to simplify this task."
msgstr ":mod:`asyncio` 扩展的主要方向是编写自定义的 *事件循环* 类。 asyncio 具有可以被用来简化此任务的辅助工具。"

#: ../../library/asyncio-extending.rst:13
msgid ""
"Third-parties should reuse existing asyncio code with caution, a new Python "
"version is free to break backward compatibility in *internal* part of API."
msgstr "第三方应当小心谨慎地重用现有的异步代码，新的 Python 版本可以自由地打破 API 的 *内部* 部分的向下兼容性。"

#: ../../library/asyncio-extending.rst:19
msgid "Writing a Custom Event Loop"
msgstr "编写自定义事件循环"

#: ../../library/asyncio-extending.rst:21
msgid ""
":class:`asyncio.AbstractEventLoop` declares very many methods.  Implementing"
" all them from scratch is a tedious job."
msgstr ":class:`asyncio.AbstractEventLoop` 声明了大量的方法。 从头开始全部实现它们将是一件烦琐的工作。"

#: ../../library/asyncio-extending.rst:24
msgid ""
"A loop can get many common methods implementation for free by inheriting "
"from :class:`asyncio.BaseEventLoop`."
msgstr "一个事件循环可以通过从 :class:`asyncio.BaseEventLoop` 继承来自动地获得许多常用方法的实现。"

#: ../../library/asyncio-extending.rst:27
msgid ""
"In turn, the successor should implement a bunch of *private* methods "
"declared but not implemented in :class:`asyncio.BaseEventLoop`."
msgstr "相应地，继承者应当实现多个在 :class:`asyncio.BaseEventLoop` 中已声明但未实现的 *私有* 方法。"

#: ../../library/asyncio-extending.rst:30
msgid ""
"For example, ``loop.create_connection()`` checks arguments, resolves DNS "
"addresses, and calls ``loop._make_socket_transport()`` that should be "
"implemented by inherited class. The ``_make_socket_transport()`` method is "
"not documented and is considered as an *internal* API."
msgstr ""
"例如，``loop.create_connection()`` 会检查参数，解析 DNS 地址，并调用应当由继承方类来实现的 "
"``loop._make_socket_transport()``。 ``_make_socket_transport()`` 方法未被写入文档并被视为"
" *内部* API。"

#: ../../library/asyncio-extending.rst:38
msgid "Future and Task private constructors"
msgstr "Future 和 Task 私有构造器"

#: ../../library/asyncio-extending.rst:40
msgid ""
":class:`asyncio.Future` and :class:`asyncio.Task` should be never created "
"directly, please use corresponding :meth:`loop.create_future` and "
":meth:`loop.create_task`, or :func:`asyncio.create_task` factories instead."
msgstr ""
":class:`asyncio.Future` 和 :class:`asyncio.Task` 不应该被直接实例化，请使用对应的 "
":meth:`loop.create_future`, :meth:`loop.create_task` 或 "
":func:`asyncio.create_task` 工厂函数。"

#: ../../library/asyncio-extending.rst:44
msgid ""
"However, third-party *event loops* may *reuse* built-in future and task "
"implementations for the sake of getting a complex and highly optimized code "
"for free."
msgstr "但是，第三方 *事件循环* 可能会 *重用* 内置的 Future 和 Task 实现以自动获得复杂且高度优化的代码。"

#: ../../library/asyncio-extending.rst:47
msgid "For this purpose the following, *private* constructors are listed:"
msgstr "出于这个目的，下面列出了相应的 *私有* 构造器:"

#: ../../library/asyncio-extending.rst:51
msgid "Create a built-in future instance."
msgstr "创建一个内置的 Future 实例。"

#: ../../library/asyncio-extending.rst:53
msgid "*loop* is an optional event loop instance."
msgstr "*loop* 是一个可选的事件循环实例。"

#: ../../library/asyncio-extending.rst:57
msgid "Create a built-in task instance."
msgstr "创建一个内置的 Task 实例。"

#: ../../library/asyncio-extending.rst:59
msgid ""
"*loop* is an optional event loop instance. The rest of arguments are "
"described in :meth:`loop.create_task` description."
msgstr "*loop* 是一个可选的事件循环实例。 其余参数会在 :meth:`loop.create_task` 说明中加以描述。"

#: ../../library/asyncio-extending.rst:64
msgid "*context* argument is added."
msgstr "添加了 *context* 参数。"

#: ../../library/asyncio-extending.rst:69
msgid "Task lifetime support"
msgstr "Task 生命周期支持"

#: ../../library/asyncio-extending.rst:71
msgid ""
"A third party task implementation should call the following functions to "
"keep a task visible by :func:`asyncio.all_tasks` and "
":func:`asyncio.current_task`:"
msgstr ""
"第三方任务实现应当调用下列函数以使任务对 :func:`asyncio.all_tasks` 和 "
":func:`asyncio.current_task` 可见:"

#: ../../library/asyncio-extending.rst:76
msgid "Register a new *task* as managed by *asyncio*."
msgstr "注册一个新的 *task* 并由 *asyncio* 管理。"

#: ../../library/asyncio-extending.rst:78
msgid "Call the function from a task constructor."
msgstr "调用来自任务构造器的函数。"

#: ../../library/asyncio-extending.rst:82
msgid "Unregister a *task* from *asyncio* internal structures."
msgstr "从 *asyncio* 内置结构体中注销 *task*。"

#: ../../library/asyncio-extending.rst:84
msgid "The function should be called when a task is about to finish."
msgstr "此函数应当在任务将要结束时被调用。"

#: ../../library/asyncio-extending.rst:88
msgid "Switch the current task to the *task* argument."
msgstr "将当前任务切换为 *task* 参数。"

#: ../../library/asyncio-extending.rst:90
msgid ""
"Call the function just before executing a portion of embedded *coroutine* "
"(:meth:`coroutine.send` or :meth:`coroutine.throw`)."
msgstr ""
"在执行嵌入的 *coroutine* (:meth:`coroutine.send` 或 :meth:`coroutine.throw`) "
"的一部分之前调用此函数。"

#: ../../library/asyncio-extending.rst:95
msgid "Switch the current task back from *task* to ``None``."
msgstr "将当前任务从 *task* 切换回 ``None``。"

#: ../../library/asyncio-extending.rst:97
msgid ""
"Call the function just after :meth:`coroutine.send` or "
":meth:`coroutine.throw` execution."
msgstr "在 :meth:`coroutine.send` 或 :meth:`coroutine.throw` 执行之后调用此函数。"
