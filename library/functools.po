# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-27 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/functools.rst:2
msgid ""
":mod:`!functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ":mod:`!functools` —— 高阶函数，以及可调用对象上的操作"

#: ../../library/functools.rst:14
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**源代码:** :source:`Lib/functools.py`"

#: ../../library/functools.rst:23
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ":mod:`functools` 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。"

#: ../../library/functools.rst:27
msgid "The :mod:`functools` module defines the following functions:"
msgstr ":mod:`functools` 模块定义了以下函数:"

#: ../../library/functools.rst:31
msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"简单轻量级未绑定函数缓存。 有时称为 `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_。"

#: ../../library/functools.rst:34
msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:`lru_cache`"
" with a size limit."
msgstr ""
"返回值与 ``lru_cache(maxsize=None)`` 相同，创建一个查找函数参数的字典的简单包装器。 "
"因为它不需要清除旧值，所以比带有大小限制的 :func:`lru_cache` 更小更快。"

#: ../../library/functools.rst:39 ../../library/functools.rst:297
msgid "For example::"
msgstr "例如："

#: ../../library/functools.rst:41
msgid ""
"@cache\n"
"def factorial(n):\n"
"    return n * factorial(n-1) if n else 1\n"
"\n"
">>> factorial(10)      # no previously cached result, makes 11 recursive calls\n"
"3628800\n"
">>> factorial(5)       # just looks up cached value result\n"
"120\n"
">>> factorial(12)      # makes two new recursive calls, the other 10 are cached\n"
"479001600"
msgstr ""
"@cache\n"
"def factorial(n):\n"
"    return n * factorial(n-1) if n else 1\n"
"\n"
">>> factorial(10)      # 不预先缓存结果，执行 11 次递归调用\n"
"3628800\n"
">>> factorial(5)       # 只查找缓存结果值\n"
"120\n"
">>> factorial(12)      # 执行两次新的递归调用，另外 10 次已缓存\n"
"479001600"

#: ../../library/functools.rst:52 ../../library/functools.rst:158
msgid ""
"The cache is threadsafe so that the wrapped function can be used in multiple"
" threads.  This means that the underlying data structure will remain "
"coherent during concurrent updates."
msgstr "该缓存是线程安全的因此被包装的函数可在多线程中使用。 这意味着下层的数据结构将在并发更新期间保持一致性。"

#: ../../library/functools.rst:56 ../../library/functools.rst:162
msgid ""
"It is possible for the wrapped function to be called more than once if "
"another thread makes an additional call before the initial call has been "
"completed and cached."
msgstr "如果另一个线程在初始调用完成并被缓存之前执行了额外的调用则被包装的函数可能会被多次调用。"

#: ../../library/functools.rst:65
msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 :func:`property` "
"但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。"

#: ../../library/functools.rst:70 ../../library/functools.rst:142
#: ../../library/functools.rst:438
msgid "Example::"
msgstr "示例::"

#: ../../library/functools.rst:72
msgid ""
"class DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cached_property\n"
"    def stdev(self):\n"
"        return statistics.stdev(self._data)"
msgstr ""
"class DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cached_property\n"
"    def stdev(self):\n"
"        return statistics.stdev(self._data)"

#: ../../library/functools.rst:81
msgid ""
"The mechanics of :func:`cached_property` are somewhat different from "
":func:`property`.  A regular property blocks attribute writes unless a "
"setter is defined. In contrast, a *cached_property* allows writes."
msgstr ""
":func:`cached_property` 的设定与 :func:`property` 有所不同。 常规的 property "
"会阻止属性写入，除非定义了 setter。 与之相反，*cached_property* 则允许写入。"

#: ../../library/functools.rst:85
msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method"
" and it works like a normal attribute."
msgstr ""
"*cached_property* 装饰器仅在执行查找且不存在同名属性时才会运行。 当运行时，*cached_property* 会写入同名的属性。 "
"后续的属性读取和写入操作会优先于 *cached_property* 方法，其行为就像普通的属性一样。"

#: ../../library/functools.rst:91
msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr "缓存的值可通过删除该属性来清空。 这允许 *cached_property* 方法再次运行。"

#: ../../library/functools.rst:94
msgid ""
"The *cached_property* does not prevent a possible race condition in multi-"
"threaded usage. The getter function could run more than once on the same "
"instance, with the latest run setting the cached value. If the cached "
"property is idempotent or otherwise not harmful to run more than once on an "
"instance, this is fine. If synchronization is needed, implement the "
"necessary locking inside the decorated getter function or around the cached "
"property access."
msgstr ""
"*cached_property* 不能防止在多线程使用中可能出现的竞争条件。 getter 函数可以在同一实例上多次运行，最后一次运行将设置缓存值。 "
"如果缓存的特征属性是幂等的或者对于在同一实例上多次运行是无害的，那就没有问题。 如果需要进行同步，请在被装饰的 getter "
"函数内部或在缓存的特征属性访问外部实现必要的锁定操作。"

#: ../../library/functools.rst:102
msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing"
" dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr "注意，这个装饰器会影响 :pep:`412` 键共享字典的操作。 这意味着相应的字典实例可能占用比通常时更多的空间。"

#: ../../library/functools.rst:106
msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are"
" read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as"
" such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"而且，这个装饰器要求每个实例上的 ``__dict__`` 是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 "
"``__dict__`` 属性是类命名空间的只读代理），以及那些指定了 ``__slots__`` 但未包括 ``__dict__`` "
"作为所定义的空位之一的类（因为这样的类根本没有提供 ``__dict__`` 属性）。"

#: ../../library/functools.rst:113
msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can also be achieved "
"by stacking :func:`property` on top of :func:`lru_cache`. See :ref:`faq-"
"cache-method-calls` for more details on how this differs from "
":func:`cached_property`."
msgstr ""
"如果可变的映射不可用或者如果想要节省空间的键共享，可以通过在 :func:`lru_cache` 上堆叠 :func:`property` 来实现类似 "
":func:`cached_property` 的效果。 请参阅 :ref:`faq-cache-method-calls` 了解这与 "
":func:`cached_property` 之间区别的详情。"

#: ../../library/functools.rst:120
msgid ""
"Prior to Python 3.12, ``cached_property`` included an undocumented lock to "
"ensure that in multi-threaded usage the getter function was guaranteed to "
"run only once per instance. However, the lock was per-property, not per-"
"instance, which could result in unacceptably high lock contention. In Python"
" 3.12+ this locking is removed."
msgstr ""
"在 Python 3.12 之前，``cached_property`` 包括了一个未写入文档的锁用来确保在多线程使用中 getter "
"函数对于每个实例保证只运行一次。 但是，这个锁是针对特征属性的，不是针对实例的，这可能导致不可接受的高强度锁争用。 在 Python 3.12+ "
"中这个锁已被移除。"

#: ../../library/functools.rst:130
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, "
":func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, "
":func:`itertools.groupby`).  This function is primarily used as a transition"
" tool for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"将(旧式的)比较函数转换为新式的 :term:`key function` .  在类似于 :func:`sorted` ， :func:`min` ，"
" :func:`max` ， :func:`heapq.nlargest` ， :func:`heapq.nsmallest` ， "
":func:`itertools.groupby` 等函数的 `key` 参数中使用。此函数主要用作将 Python 2 "
"程序转换至新版的转换工具，以保持对比较函数的兼容。"

#: ../../library/functools.rst:137
msgid ""
"A comparison function is any callable that accepts two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts"
" one argument and returns another value to be used as the sort key."
msgstr ""
"比较函数是任何接受两个参数，比较它们，并在结果为小于时返回负数，等于时返回零，大于时返回正数的可调用对象。键函数是接受一个参数并返回另一值的可调用对象，返回值在排序时被用作键。"

#: ../../library/functools.rst:144
msgid ""
"sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order"
msgstr "sorted(iterable, key=cmp_to_key(locale.strcoll))  # 感知语言区域的排序设置"

#: ../../library/functools.rst:146
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有关排序示例和简要排序教程，请参阅 :ref:`sortinghowto`。"

#: ../../library/functools.rst:154
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"一个为函数提供缓存功能的装饰器，缓存 *maxsize* 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。"

#: ../../library/functools.rst:166
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be :term:`hashable`."
msgstr "由于使用字典来缓存结果，因此传给该函数的位置和关键字参数必须为 :term:`hashable`。"

#: ../../library/functools.rst:169
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, ``f(a=1, b=2)`` and ``f(b=2, a=1)`` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"不同的参数模式可能会被视为具有单独缓存项的不同调用。 例如，``f(a=1, b=2)`` 和 ``f(b=2, a=1)`` "
"因其关键字参数顺序不同而可能会具有两个单独的缓存项。"

#: ../../library/functools.rst:174
msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the"
" *maxsize* at its default value of 128::"
msgstr ""
"如果指定了 *user_function*，它必须是一个可调用对象。 这允许 *lru_cache* 装饰器被直接应用于一个用户自定义函数，让 "
"*maxsize* 保持其默认值 128::"

#: ../../library/functools.rst:178
msgid ""
"@lru_cache\n"
"def count_vowels(sentence):\n"
"    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')"
msgstr ""
"@lru_cache\n"
"def count_vowels(sentence):\n"
"    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')"

#: ../../library/functools.rst:182
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr "如果 *maxsize* 设为 ``None``，LRU 特性将被禁用且缓存可无限增长。"

#: ../../library/functools.rst:185
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is "
"false.)"
msgstr ""
"如果 *typed* 被设置为 true ，不同类型的函数参数将被分别缓存。 如果 *typed* 为 false "
"，实现通常会将它们视为等价的调用，只缓存一个结果。(有些类型，如 *str* 和 *int* ，即使 *typed* 为 false "
"，也可能被分开缓存）。"

#: ../../library/functools.rst:191
msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"注意，类型的特殊性只适用于函数的直接参数而不是它们的内容。 标量参数 ``Decimal(42)`` 和 ``Fraction(42)`` "
"被视为具有不同结果的不同调用。相比之下，元组参数 ``('answer', Decimal(42))`` 和 ``('answer', "
"Fraction(42))`` 被视为等同的。"

#: ../../library/functools.rst:197
msgid ""
"The wrapped function is instrumented with a :func:`!cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"被包装的函数配有一个 :func:`!cache_parameters` 函数，它返回一个新的 :class:`dict` 用来显示 *maxsize*"
" 和 *typed* 的值。 这只是出于显示信息的目的。 改变这些值没有有任何效果。"

#: ../../library/functools.rst:205
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`!cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""
"为了帮助评估缓存的有效性并调整 *maxsize* 参数，被包装的函数会附带一个 :func:`!cache_info` 函数，该函数返回一个 "
":term:`named tuple`，其中包含 *hits*、*misses*、*maxsize* 和 *currsize* 等信息。"

#: ../../library/functools.rst:213
msgid ""
"The decorator also provides a :func:`!cache_clear` function for clearing or "
"invalidating the cache."
msgstr "该装饰器还提供了一个 :func:`!cache_clear` 函数，用于清除缓存或使缓存失效。"

#: ../../library/functools.rst:216
msgid ""
"The original underlying function is accessible through the "
":attr:`__wrapped__` attribute.  This is useful for introspection, for "
"bypassing the cache, or for rewrapping the function with a different cache."
msgstr ""
"原始的未经装饰的函数可以通过 :attr:`__wrapped__` 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。"

#: ../../library/functools.rst:220
msgid ""
"The cache keeps references to the arguments and return values until they age"
" out of the cache or until the cache is cleared."
msgstr "缓存会保持对参数的引用并返回值，直到它们结束生命期退出缓存或者直到缓存被清空。"

#: ../../library/functools.rst:223
msgid ""
"If a method is cached, the ``self`` instance argument is included in the "
"cache.  See :ref:`faq-cache-method-calls`"
msgstr "如果一个方法被缓存，则 ``self`` 实例参数会被包括在缓存中。 请参阅 :ref:`faq-cache-method-calls`"

#: ../../library/functools.rst:226
msgid ""
"An `LRU (least recently used) cache "
"<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_(LRU)>`_"
" works best when the most recent calls are the best predictors of upcoming "
"calls (for example, the most popular articles on a news server tend to "
"change each day).  The cache's size limit assures that the cache does not "
"grow without bound on long-running processes such as web servers."
msgstr ""
"`LRU (least recently used) 缓存 "
"<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_(LRU)>`_"
" 在最近的调用是即将到来的调用的最佳预测值时性能最好 (例如，新闻服务器上的最热门文章倾向于每天发生变化)。 "
"缓存的大小限制可确保缓存不会在长期运行的进程如 web 服务器上无限制地增长。"

#: ../../library/functools.rst:233
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call (such as generators and async functions), or impure "
"functions such as time() or random()."
msgstr ""
"一般来说，LRU 缓存只应在你需要重复使用先前计算的值时使用。 "
"因此，缓存有附带影响的函数、每次调用都需要创建不同的可变对象的函数（如生成器和异步函数）或不纯的函数如 time() 或 random() "
"等是没有意义的。"

#: ../../library/functools.rst:239
msgid "Example of an LRU cache for static web content::"
msgstr "静态 Web 内容的 LRU 缓存示例::"

#: ../../library/functools.rst:241
msgid ""
"@lru_cache(maxsize=32)\n"
"def get_pep(num):\n"
"    'Retrieve text of a Python Enhancement Proposal'\n"
"    resource = f'https://peps.python.org/pep-{num:04d}'\n"
"    try:\n"
"        with urllib.request.urlopen(resource) as s:\n"
"            return s.read()\n"
"    except urllib.error.HTTPError:\n"
"        return 'Not Found'\n"
"\n"
">>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:\n"
"...     pep = get_pep(n)\n"
"...     print(n, len(pep))\n"
"\n"
">>> get_pep.cache_info()\n"
"CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)"
msgstr ""
"@lru_cache(maxsize=32)\n"
"def get_pep(num):\n"
"    'Retrieve text of a Python Enhancement Proposal'\n"
"    resource = f'https://peps.python.org/pep-{num:04d}'\n"
"    try:\n"
"        with urllib.request.urlopen(resource) as s:\n"
"            return s.read()\n"
"    except urllib.error.HTTPError:\n"
"        return 'Not Found'\n"
"\n"
">>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:\n"
"...     pep = get_pep(n)\n"
"...     print(n, len(pep))\n"
"\n"
">>> get_pep.cache_info()\n"
"CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)"

#: ../../library/functools.rst:258
msgid ""
"Example of efficiently computing `Fibonacci numbers "
"<https://en.wikipedia.org/wiki/Fibonacci_number>`_ using a cache to "
"implement a `dynamic programming "
"<https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"以下是使用缓存通过 `动态规划 <https://zh.wikipedia.org/wiki/动态规划>`_  计算 `斐波那契数列 "
"<https://zh.wikipedia.org/wiki/斐波那契数列>`_  的例子。"

#: ../../library/functools.rst:264
msgid ""
"@lru_cache(maxsize=None)\n"
"def fib(n):\n"
"    if n < 2:\n"
"        return n\n"
"    return fib(n-1) + fib(n-2)\n"
"\n"
">>> [fib(n) for n in range(16)]\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n"
"\n"
">>> fib.cache_info()\n"
"CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)"
msgstr ""
"@lru_cache(maxsize=None)\n"
"def fib(n):\n"
"    if n < 2:\n"
"        return n\n"
"    return fib(n-1) + fib(n-2)\n"
"\n"
">>> [fib(n) for n in range(16)]\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n"
"\n"
">>> fib.cache_info()\n"
"CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)"

#: ../../library/functools.rst:278
msgid "Added the *typed* option."
msgstr "添加 *typed* 选项。"

#: ../../library/functools.rst:281
msgid "Added the *user_function* option."
msgstr "添加了 *user_function* 选项。"

#: ../../library/functools.rst:284
msgid "Added the function :func:`!cache_parameters`"
msgstr "增加了 :func:`!cache_parameters` 函数"

#: ../../library/functools.rst:289
msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr "给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。"

#: ../../library/functools.rst:293
msgid ""
"The class must define one of :meth:`~object.__lt__`, :meth:`~object.__le__`,"
" :meth:`~object.__gt__`, or :meth:`~object.__ge__`. In addition, the class "
"should supply an :meth:`~object.__eq__` method."
msgstr ""
"该类必须定义以下比较方法之一: "
":meth:`~object.__lt__`、:meth:`~object.__le__`、:meth:`~object.__gt__` 或 "
":meth:`~object.__ge__`。此外，该类还应提供 :meth:`~object.__eq__` 方法。"

#: ../../library/functools.rst:299
msgid ""
"@total_ordering\n"
"class Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"lastname\") and\n"
"                hasattr(other, \"firstname\"))\n"
"    def __eq__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) ==\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) <\n"
"                (other.lastname.lower(), other.firstname.lower()))"
msgstr ""
"@total_ordering\n"
"class Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"lastname\") and\n"
"                hasattr(other, \"firstname\"))\n"
"    def __eq__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) ==\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) <\n"
"                (other.lastname.lower(), other.firstname.lower()))"

#: ../../library/functools.rst:317
msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack"
" traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six"
" rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 *确实* 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 "
"如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。"

#: ../../library/functools.rst:326
msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"这个装饰器不会尝试重写类 *或其上级类* 中已经被声明的方法。 这意味着如果某个上级类定义了比较运算符，则 *total_ordering* "
"将不会再次实现它，即使原方法是抽象方法。"

#: ../../library/functools.rst:333
msgid ""
"Returning ``NotImplemented`` from the underlying comparison function for "
"unrecognised types is now supported."
msgstr "现在已支持从未识别的类型的下层比较函数返回 ``NotImplemented`` 异常。"

#: ../../library/functools.rst:339
msgid ""
"A singleton object used as a sentinel to reserve a place for positional "
"arguments when calling :func:`partial` and :func:`partialmethod`."
msgstr "一个单例对象，在调用 :func:`partial` 和 :func:`partialmethod` 时被用作给位置参数保留位置的哨兵值。"

#: ../../library/functools.rst:347
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"返回一个新的 :ref:`部分对象<partial-objects>`，当被调用时其行为类似于 *func* 附带位置参数 *args* 和关键字参数 "
"*keywords* 被调用。 如果为调用提供了更多的参数，它们会被附加到 *args*。 如果提供了额外的关键字参数，它们会扩展并重写 "
"*keywords*。 大致等价于::"

#: ../../library/functools.rst:354
msgid ""
"def partial(func, /, *args, **keywords):\n"
"    def newfunc(*more_args, **more_keywords):\n"
"        return func(*args, *more_args, **(keywords | more_keywords))\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.keywords = keywords\n"
"    return newfunc"
msgstr ""
"def partial(func, /, *args, **keywords):\n"
"    def newfunc(*more_args, **more_keywords):\n"
"        return func(*args, *more_args, **(keywords | more_keywords))\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.keywords = keywords\n"
"    return newfunc"

#: ../../library/functools.rst:362
msgid ""
"The :func:`!partial` function is used for partial function application which"
" \"freezes\" some portion of a function's arguments and/or keywords "
"resulting in a new object with a simplified signature.  For example, "
":func:`partial` can be used to create a callable that behaves like the "
":func:`int` function where the *base* argument defaults to ``2``:"
msgstr ""
":func:`!partial` 函数会被用于“冻结了”一部分函数的参数和/或关键字的 partial "
"函数从而得到一个具有简化的签名的新对象的应用程序。 例如，:func:`partial` 可被用来创建一个行为类似于 :func:`int` "
"函数的可调用对象，其中 *base* 参数默认值为 ``2``:"

#: ../../library/functools.rst:368
msgid ""
">>> basetwo = partial(int, base=2)\n"
">>> basetwo.__doc__ = 'Convert base 2 string to an int.'\n"
">>> basetwo('10010')\n"
"18"
msgstr ""
">>> basetwo = partial(int, base=2)\n"
">>> basetwo.__doc__ = 'Convert base 2 string to an int.'\n"
">>> basetwo('10010')\n"
"18"

#: ../../library/functools.rst:375
msgid ""
"If :data:`Placeholder` sentinels are present in *args*, they will be filled "
"first when :func:`!partial` is called. This makes it possible to pre-fill "
"any positional argument with a call to :func:`!partial`; without "
":data:`!Placeholder`, only the chosen number of leading positional arguments"
" can be pre-filled."
msgstr ""
"如果 :data:`Placeholder` 哨兵出现在 *args* 中，它们将在调用 :func:`!partial` 时首先被填充。 "
"这使得通过调用 :func:`!partial` 来预先填充任何位置参数成为可能；如果没有 "
":data:`!Placeholder`，则只能预填充选定数量的前导位置参数。"

#: ../../library/functools.rst:380
msgid ""
"If any :data:`!Placeholder` sentinels are present, all must be filled at "
"call time:"
msgstr "如果有任何 :data:`!Placeholder` 哨兵存在，则必须在调用时填充所有哨兵："

#: ../../library/functools.rst:382
msgid ""
">>> say_to_world = partial(print, Placeholder, Placeholder, \"world!\")\n"
">>> say_to_world('Hello', 'dear')\n"
"Hello dear world!"
msgstr ""
">>> say_to_world = partial(print, Placeholder, Placeholder, \"world!\")\n"
">>> say_to_world('Hello', 'dear')\n"
"Hello dear world!"

#: ../../library/functools.rst:388
msgid ""
"Calling ``say_to_world('Hello')`` raises a :exc:`TypeError`, because only "
"one positional argument is provided, but there are two placeholders that "
"must be filled in."
msgstr ""
"调用 ``say_to_world('Hello')`` 会引发 :exc:`TypeError`，因为只提供了一个位置参数，但有两个必须填充的占位符。"

#: ../../library/functools.rst:392
msgid ""
"If :func:`!partial` is applied to an existing :func:`!partial` object, "
":data:`!Placeholder` sentinels of the input object are filled in with new "
"positional arguments. A placeholder can be retained by inserting a new "
":data:`!Placeholder` sentinel to the place held by a previous "
":data:`!Placeholder`:"
msgstr ""
"如果 :func:`!partial` 应用于现有的 :func:`!partial` 对象，则输入对象的 :data:`!Placeholder` "
"哨兵将使用新的位置参数填充。 通过在前一个 :data:`!Placeholder` 所占的位置插入一个新的 :data:`!Placeholder` "
"哨兵，可以保留占位符："

#: ../../library/functools.rst:398
msgid ""
">>> from functools import partial, Placeholder as _\n"
">>> remove = partial(str.replace, _, _, '')\n"
">>> message = 'Hello, dear dear world!'\n"
">>> remove(message, ' dear')\n"
"'Hello, world!'\n"
">>> remove_dear = partial(remove, _, ' dear')\n"
">>> remove_dear(message)\n"
"'Hello, world!'\n"
">>> remove_first_dear = partial(remove_dear, _, 1)\n"
">>> remove_first_dear(message)\n"
"'Hello, dear world!'"
msgstr ""
">>> from functools import partial, Placeholder as _\n"
">>> remove = partial(str.replace, _, _, '')\n"
">>> message = 'Hello, dear dear world!'\n"
">>> remove(message, ' dear')\n"
"'Hello, world!'\n"
">>> remove_dear = partial(remove, _, ' dear')\n"
">>> remove_dear(message)\n"
"'Hello, world!'\n"
">>> remove_first_dear = partial(remove_dear, _, 1)\n"
">>> remove_first_dear(message)\n"
"'Hello, dear world!'"

#: ../../library/functools.rst:412
msgid ""
":data:`!Placeholder` cannot be passed to :func:`!partial` as a keyword "
"argument."
msgstr ":data:`!Placeholder`不能作为关键字参数传递给:func:`!partial`。"

#: ../../library/functools.rst:414
msgid "Added support for :data:`Placeholder` in positional arguments."
msgstr "增加了对位置参数 :data:`Placeholder` 的支持。"

#: ../../library/functools.rst:419
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like "
":class:`partial` except that it is designed to be used as a method "
"definition rather than being directly callable."
msgstr ""
"返回一个新的 :class:`partialmethod` 描述器，其行为类似 :class:`partial` "
"但它被设计用作方法定义而非直接用作可调用对象。"

#: ../../library/functools.rst:423
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr "*func* 必须是一个 :term:`descriptor` 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。"

#: ../../library/functools.rst:426
msgid ""
"When *func* is a descriptor (such as a normal Python function, "
":func:`classmethod`, :func:`staticmethod`, :func:`~abc.abstractmethod` or "
"another instance of :class:`partialmethod`), calls to ``__get__`` are "
"delegated to the underlying descriptor, and an appropriate :ref:`partial "
"object<partial-objects>` returned as the result."
msgstr ""
"当 *func* 是一个描述符（例如普通的 Python "
"函数：:func:`classmethod`、:func:`staticmethod`、:func:`~abc.abstractmethod` 或 "
":class:`partialmethod` 的其他实例）时，对 ``__get__`` 方法的调用会被委托给底层的描述符，并返回一个适当的 "
":ref:`偏函数对象 <partial-objects>` 作为结果。"

#: ../../library/functools.rst:432
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as"
" a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the "
":class:`partialmethod` constructor."
msgstr ""
"当 *func* 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 *self*"
" 参数作为第一个位置参数，其位置甚至会处于提供给 :class:`partialmethod` 构造器的 *args* 和 *keywords* 之前。"

#: ../../library/functools.rst:440
msgid ""
">>> class Cell:\n"
"...     def __init__(self):\n"
"...         self._alive = False\n"
"...     @property\n"
"...     def alive(self):\n"
"...         return self._alive\n"
"...     def set_state(self, state):\n"
"...         self._alive = bool(state)\n"
"...     set_alive = partialmethod(set_state, True)\n"
"...     set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"False\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"True"
msgstr ""
">>> class Cell:\n"
"...     def __init__(self):\n"
"...         self._alive = False\n"
"...     @property\n"
"...     def alive(self):\n"
"...         return self._alive\n"
"...     def set_state(self, state):\n"
"...         self._alive = bool(state)\n"
"...     set_alive = partialmethod(set_state, True)\n"
"...     set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"False\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"True"

#: ../../library/functools.rst:463
msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initial* is present, it is placed before the items of the iterable"
" in the calculation, and serves as a default when the iterable is empty.  If"
" *initial* is not given and *iterable* contains only one item, the first "
"item is returned."
msgstr ""
"将两个参数的 *function* 从左至右累积地应用到 *iterable* 的条目，以便将该可迭代对象缩减为单个值。 "
"例如，``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` 就是计算 ``((((1+2)+3)+4)+5)``。"
" 左边的参数 *x* 是累积的值而右边的参数 *y* 则是来自 *iterable* 的更新值。 如果存在可选项 "
"*initial*，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果未给出 *initial* 并且 "
"*iterable* 仅包含一个条目，则将返回第一项。"

#: ../../library/functools.rst:472
msgid "Roughly equivalent to::"
msgstr "大致相当于："

#: ../../library/functools.rst:474
msgid ""
"initial_missing = object()\n"
"\n"
"def reduce(function, iterable, /, initial=initial_missing):\n"
"    it = iter(iterable)\n"
"    if initial is initial_missing:\n"
"        value = next(it)\n"
"    else:\n"
"        value = initial\n"
"    for element in it:\n"
"        value = function(value, element)\n"
"    return value"
msgstr ""
"initial_missing = object()\n"
"\n"
"def reduce(function, iterable, /, initial=initial_missing):\n"
"    it = iter(iterable)\n"
"    if initial is initial_missing:\n"
"        value = next(it)\n"
"    else:\n"
"        value = initial\n"
"    for element in it:\n"
"        value = function(value, element)\n"
"    return value"

#: ../../library/functools.rst:486
msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr "请参阅 :func:`itertools.accumulate` 了解有关可产生所有中间值的迭代器。"

#: ../../library/functools.rst:489
msgid "*initial* is now supported as a keyword argument."
msgstr "现在支持 *initial* 作为关键字参数。"

#: ../../library/functools.rst:494
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` "
":term:`generic function`."
msgstr "将一个函数转换为 :term:`单分派 <single dispatch>` :term:`generic function`。"

#: ../../library/functools.rst:497
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the"
" dispatch happens on the type of the first argument::"
msgstr ""
"要定义一个泛型函数，用装饰器 ``@singledispatch`` 来装饰它。当使用 ``@singledispatch`` "
"定义一个函数时，请注意调度发生在第一个参数的类型上::"

#: ../../library/functools.rst:501
msgid ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"
msgstr ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"

#: ../../library/functools.rst:511
msgid ""
"To add overloaded implementations to the function, use the :func:`!register`"
" attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""
"若要为函数添加重载实现，请使用泛型函数的 :func:`!register` "
"属性（该属性可作为装饰器使用）。对于带有类型注解的函数，该装饰器会自动推断第一个参数的类型::"

#: ../../library/functools.rst:516
msgid ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: list, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"
msgstr ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: list, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"

#: ../../library/functools.rst:529
msgid ":class:`typing.Union` can also be used::"
msgstr "还可以使用 :class:`typing.Union`::"

#: ../../library/functools.rst:531
msgid ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> from typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)\n"
"..."
msgstr ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> from typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)\n"
"..."

#: ../../library/functools.rst:546
msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr "对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身::"

#: ../../library/functools.rst:549
msgid ""
">>> @fun.register(complex)\n"
"... def _(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Better than complicated.\", end=\" \")\n"
"...     print(arg.real, arg.imag)\n"
"..."
msgstr ""
">>> @fun.register(complex)\n"
"... def _(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Better than complicated.\", end=\" \")\n"
"...     print(arg.real, arg.imag)\n"
"..."

#: ../../library/functools.rst:556
msgid ""
"For code that dispatches on a collections type (e.g., ``list``), but wants "
"to typehint the items of the collection (e.g., ``list[int]``), the dispatch "
"type should be passed explicitly to the decorator itself with the typehint "
"going into the function definition::"
msgstr ""
"对于在多项集类型 (例如 ``list``) 上分派，但希望对多项集中的项设置类型提示 (例如 ``list[int]``) "
"的代码，分派类型应当被显式地传给装饰器本身并将类型提示放在函数定义中::"

#: ../../library/functools.rst:561
msgid ""
">>> @fun.register(list)\n"
"... def _(arg: list[int], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"
msgstr ""
">>> @fun.register(list)\n"
"... def _(arg: list[int], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"

#: ../../library/functools.rst:570
msgid ""
"At runtime the function will dispatch on an instance of a list regardless of"
" the type contained within the list i.e. ``[1,2,3]`` will be dispatched the "
"same as ``[\"foo\", \"bar\", \"baz\"]``. The annotation provided in this "
"example is for static type checkers only and has no runtime impact."
msgstr ""
"当运行时函数将在一个列表的实例上分派而不管列表中包含的类型是什么，也就是说 ``[1,2,3]`` 将以与 ``[\"foo\", \"bar\", "
"\"baz\"]`` 相同的方式分派。 在本例中提供的标注仅针对静态类型检查器而在运行时没有影响。"

#: ../../library/functools.rst:576
msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`~singledispatch.register` attribute can also be used in a "
"functional form::"
msgstr ""
"为了支持注册 :term:`lambda <lambda>` 和已存在的函数，:func:`~singledispatch.register` "
"属性也可以通过函数形式来使用::"

#: ../../library/functools.rst:579
msgid ""
">>> def nothing(arg, verbose=False):\n"
"...     print(\"Nothing.\")\n"
"...\n"
">>> fun.register(type(None), nothing)"
msgstr ""
">>> def nothing(arg, verbose=False):\n"
"...     print(\"Nothing.\")\n"
"...\n"
">>> fun.register(type(None), nothing)"

#: ../../library/functools.rst:584
msgid ""
"The :func:`~singledispatch.register` attribute returns the undecorated "
"function. This enables decorator stacking, :mod:`pickling<pickle>`, and the "
"creation of unit tests for each variant independently::"
msgstr ""
":func:`~singledispatch.register` 属性会返回未经装饰的原始函数。这使得装饰器可以堆叠使用、支持 "
":mod:`pickling<pickle>`，并且能够为每个变体独立创建单元测试。"

#: ../../library/functools.rst:588
msgid ""
">>> @fun.register(float)\n"
"... @fun.register(Decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Half of your number:\", end=\" \")\n"
"...     print(arg / 2)\n"
"...\n"
">>> fun_num is fun\n"
"False"
msgstr ""
">>> @fun.register(float)\n"
"... @fun.register(Decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Half of your number:\", end=\" \")\n"
"...     print(arg / 2)\n"
"...\n"
">>> fun_num is fun\n"
"False"

#: ../../library/functools.rst:598
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "在调用时，泛型函数会根据第一个参数的类型进行分派::"

#: ../../library/functools.rst:601
msgid ""
">>> fun(\"Hello, world.\")\n"
"Hello, world.\n"
">>> fun(\"test.\", verbose=True)\n"
"Let me just say, test.\n"
">>> fun(42, verbose=True)\n"
"Strength in numbers, eh? 42\n"
">>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n"
"Enumerate this:\n"
"0 spam\n"
"1 spam\n"
"2 eggs\n"
"3 spam\n"
">>> fun(None)\n"
"Nothing.\n"
">>> fun(1.23)\n"
"0.615"
msgstr ""
">>> fun(\"Hello, world.\")\n"
"Hello, world.\n"
">>> fun(\"test.\", verbose=True)\n"
"Let me just say, test.\n"
">>> fun(42, verbose=True)\n"
"Strength in numbers, eh? 42\n"
">>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n"
"Enumerate this:\n"
"0 spam\n"
"1 spam\n"
"2 eggs\n"
"3 spam\n"
">>> fun(None)\n"
"Nothing.\n"
">>> fun(1.23)\n"
"0.615"

#: ../../library/functools.rst:618
msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original"
" function decorated with ``@singledispatch`` is registered for the base "
":class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"在没有针对特定类型的已注册实现的情况下，会使用其方法解析顺序来查找更通用的实现。 使用 ``@singledispatch`` 装饰的原始函数将为基本的"
" :class:`object` 类型进行注册，这意味着它将在找不到更好的实现时被使用。"

#: ../../library/functools.rst:624
msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr "如果一个实现被注册到 :term:`abstract base class`，则基类的虚拟子类将被发送到该实现::"

#: ../../library/functools.rst:628
msgid ""
">>> from collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Keys & Values\")\n"
"...     for key, value in arg.items():\n"
"...         print(key, \"=>\", value)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"
msgstr ""
">>> from collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Keys & Values\")\n"
"...     for key, value in arg.items():\n"
"...         print(key, \"=>\", value)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"

#: ../../library/functools.rst:639
msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr "要检查泛型函数将为给定的类型选择哪个实现，请使用 ``dispatch()`` 属性::"

#: ../../library/functools.rst:642
msgid ""
">>> fun.dispatch(float)\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.dispatch(dict)    # note: default implementation\n"
"<function fun at 0x103fe0000>"
msgstr ""
">>> fun.dispatch(float)\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.dispatch(dict)    # 注：默认实现\n"
"<function fun at 0x103fe0000>"

#: ../../library/functools.rst:647
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr "要访问所有已注册实现，请使用只读的 ``registry`` 属性::"

#: ../../library/functools.rst:650
msgid ""
">>> fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"          <class 'decimal.Decimal'>, <class 'list'>,\n"
"          <class 'float'>])\n"
">>> fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.registry[object]\n"
"<function fun at 0x103fe0000>"
msgstr ""
">>> fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"          <class 'decimal.Decimal'>, <class 'list'>,\n"
"          <class 'float'>])\n"
">>> fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.registry[object]\n"
"<function fun at 0x103fe0000>"

#: ../../library/functools.rst:661
msgid ""
"The :func:`~singledispatch.register` attribute now supports using type "
"annotations."
msgstr ":func:`~singledispatch.register` 属性现在支持使用类型注解。"

#: ../../library/functools.rst:664
msgid ""
"The :func:`~singledispatch.register` attribute now supports "
":class:`typing.Union` as a type annotation."
msgstr ""
"现在 :func:`~singledispatch.register` 属性支持将 :class:`typing.Union` 作为类型标注。"

#: ../../library/functools.rst:671
msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` "
":term:`generic function`."
msgstr "将一个方法转换为 :term:`单分派 <single dispatch>` :term:`generic function`。"

#: ../../library/functools.rst:674
msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""
"要定义一个泛型方法，请用 ``@singledispatchmethod`` 装饰器来装饰它。 当使用 "
"``@singledispatchmethod`` 定义一个函数时，请注意发送操作将针对第一个非 *self* 或非 *cls* 参数的类型上::"

#: ../../library/functools.rst:679
msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        return not arg"
msgstr ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        return not arg"

#: ../../library/functools.rst:692
msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as "
":func:`@classmethod<classmethod>`. Note that to allow for "
"``dispatcher.register``, ``singledispatchmethod`` must be the *outer most* "
"decorator. Here is the ``Negator`` class with the ``neg`` methods bound to "
"the class, rather than an instance of the class::"
msgstr ""
"``@singledispatchmethod`` 支持与其他装饰器如 :func:`@classmethod<classmethod>` 相嵌套。 "
"请注意为了允许 ``dispatcher.register``，``singledispatchmethod`` 必须是 *最外层的* 装饰器。 "
"下面是一个 ``Negator`` 类包含绑定到类的 ``neg`` 方法，而不是一个类实例::"

#: ../../library/functools.rst:698
msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    @classmethod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: bool):\n"
"        return not arg"
msgstr ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    @classmethod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: bool):\n"
"        return not arg"

#: ../../library/functools.rst:714
msgid ""
"The same pattern can be used for other similar decorators: "
":func:`@staticmethod<staticmethod>`, "
":func:`@abstractmethod<abc.abstractmethod>`, and others."
msgstr ""
"同样的模式也可被用于其他类似的装饰器: :func:`@staticmethod<staticmethod>`, "
":func:`@abstractmethod<abc.abstractmethod>` 等等。"

#: ../../library/functools.rst:723
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's :attr:`~function.__module__`, "
":attr:`~function.__name__`, :attr:`~function.__qualname__`, "
":attr:`~function.__annotations__`, :attr:`~function.__type_params__`, and "
":attr:`~function.__doc__`, the documentation string) and ``WRAPPER_UPDATES``"
" (which updates the wrapper function's :attr:`~function.__dict__`, i.e. the "
"instance dictionary)."
msgstr ""
"更新一个 *包装器* 函数以使其与 *被包装的* 函数相似。 "
"可选参数为指明原函数的哪些属性要被直接赋值给包装器函数的相匹配属性的元组以及包装器的哪些属性要使用原函数的相应属性来更新。 这些参数的默认值是模块级常量"
" ``WRAPPER_ASSIGNMENTS`` (它将被赋值给包装器函数的 :attr:`~function.__module__`, "
":attr:`~function.__name__`, :attr:`~function.__qualname__`, "
":attr:`~function.__annotations__`, :attr:`~function.__type_params__` 和 "
":attr:`~function.__doc__`，即文档字符串) 以及 ``WRAPPER_UPDATES`` (它将更新包装器函数的 "
":attr:`~function.__dict__`，即实例字典)。"

#: ../../library/functools.rst:735
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"为了允许出于内省和其他目的访问原始函数（例如绕过 :func:`lru_cache` 之类的缓存装饰器），此函数会自动为 wrapper "
"添加一个指向被包装函数的 ``__wrapped__`` 属性。"

#: ../../library/functools.rst:740
msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"此函数的主要目的是在 :term:`decorator` 函数中用来包装被装饰的函数并返回包装器。 "
"如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。"

#: ../../library/functools.rst:746
msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object"
" being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` 可以与函数之外的可调用对象一同使用。 在 *assigned* 或 *updated* "
"中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 *updated* "
"中命名的任何属性则仍将引发 :exc:`AttributeError`。"

#: ../../library/functools.rst:752
msgid ""
"The ``__wrapped__`` attribute is now automatically added. The "
":attr:`~function.__annotations__` attribute is now copied by default. "
"Missing attributes no longer trigger an :exc:`AttributeError`."
msgstr ""
"现在 ``__wrapped__`` 属性会被自动添加。 现在 :attr:`~function.__annotations__` 属性默认会被拷贝。 "
"缺失的属性不会再触发 :exc:`AttributeError`。"

#: ../../library/functools.rst:757
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see "
":issue:`17482`)"
msgstr ""
"``__wrapped__`` 属性现在总是指向被包装的函数，即使该函数定义了 ``__wrapped__`` 属性。 (参见 "
":issue:`17482`)"

#: ../../library/functools.rst:762
msgid ""
"The :attr:`~function.__type_params__` attribute is now copied by default."
msgstr "现在 :attr:`~function.__type_params__` 属性默认会被拷贝。"

#: ../../library/functools.rst:768
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"这是一个便捷函数，用于在定义包装器函数时唤起 :func:`update_wrapper` 作为函数装饰器。 它等价于 "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``。 例如::"

#: ../../library/functools.rst:773
msgid ""
">>> from functools import wraps\n"
">>> def my_decorator(f):\n"
"...     @wraps(f)\n"
"...     def wrapper(*args, **kwds):\n"
"...         print('Calling decorated function')\n"
"...         return f(*args, **kwds)\n"
"...     return wrapper\n"
"...\n"
">>> @my_decorator\n"
"... def example():\n"
"...     \"\"\"Docstring\"\"\"\n"
"...     print('Called example function')\n"
"...\n"
">>> example()\n"
"Calling decorated function\n"
"Called example function\n"
">>> example.__name__\n"
"'example'\n"
">>> example.__doc__\n"
"'Docstring'"
msgstr ""
">>> from functools import wraps\n"
">>> def my_decorator(f):\n"
"...     @wraps(f)\n"
"...     def wrapper(*args, **kwds):\n"
"...         print('Calling decorated function')\n"
"...         return f(*args, **kwds)\n"
"...     return wrapper\n"
"...\n"
">>> @my_decorator\n"
"... def example():\n"
"...     \"\"\"Docstring\"\"\"\n"
"...     print('Called example function')\n"
"...\n"
">>> example()\n"
"Calling decorated function\n"
"Called example function\n"
">>> example.__name__\n"
"'example'\n"
">>> example.__doc__\n"
"'Docstring'"

#: ../../library/functools.rst:794
msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original "
":func:`!example` would have been lost."
msgstr ""
"如果不使用这个装饰器工厂，示例函数的名称将变为 ``'wrapper'``，并且原始 :func:`!example` 函数的文档字符串也会丢失。"

#: ../../library/functools.rst:802
msgid ":class:`partial` Objects"
msgstr ":class:`partial` 对象"

#: ../../library/functools.rst:804
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ":class:`partial` 对象是由 :func:`partial` 创建的可调用对象。 它们具有三个只读属性："

#: ../../library/functools.rst:810
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be"
" forwarded to :attr:`func` with new arguments and keywords."
msgstr "一个可调用对象或函数。 对 :class:`partial` 对象的调用将被转发给 :attr:`func` 并附带新的参数和关键字。"

#: ../../library/functools.rst:816
msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr "最左边的位置参数将放置在提供给 :class:`partial` 对象调用的位置参数之前。"

#: ../../library/functools.rst:822
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object"
" is called."
msgstr "当调用 :class:`partial` 对象时将要提供的关键字参数。"

#: ../../library/functools.rst:825
msgid ""
":class:`partial` objects are like :ref:`function objects <user-defined-"
"funcs>` in that they are callable, weak referenceable, and can have "
"attributes.  There are some important differences.  For instance, the "
":attr:`~definition.__name__` and :attr:`~definition.__doc__` attributes are "
"not created automatically."
msgstr ""
":class:`partial` 对象与 :ref:`函数对象 <user-defined-funcs>` "
"的类似之处在于它们都是可调用、可弱引用并可具有属性的。 但两者也存在一些重要的区别。 例如，:attr:`~definition.__name__` 和"
" :attr:`~definition.__doc__` 属性不会被自动创建。 "
