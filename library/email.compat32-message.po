# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.compat32-message.rst:4
msgid ""
":mod:`email.message.Message`: Representing an email message using the "
":data:`~email.policy.compat32` API"
msgstr ""
":mod:`email.message.Message`: 使用 :data:`~email.policy.compat32` API "
"来表示电子邮件消息"

#: ../../library/email.compat32-message.rst:13
msgid ""
"The :class:`Message` class is very similar to the "
":class:`~email.message.EmailMessage` class, without the methods added by "
"that class, and with the default behavior of certain other methods being "
"slightly different.  We also document here some methods that, while "
"supported by the :class:`~email.message.EmailMessage` class, are not "
"recommended unless you are dealing with legacy code."
msgstr ""
":class:`Message` 类与 :class:`~email.message.EmailMessage` "
"类非常相似，但没有该类所添加的方法，并且某些方法的默认行为也略有不同。 我们还在这里记录了一些虽然被 "
":class:`~email.message.EmailMessage` 类所支持但并不推荐的方法，除非你是在处理旧有代码。"

#: ../../library/email.compat32-message.rst:20
msgid "The philosophy and structure of the two classes is otherwise the same."
msgstr "在其他情况下这两个类的理念和结构都是相同的。"

#: ../../library/email.compat32-message.rst:22
msgid ""
"This document describes the behavior under the default (for "
":class:`Message`) policy :attr:`~email.policy.Compat32`.  If you are going "
"to use another policy, you should be using the "
":class:`~email.message.EmailMessage` class instead."
msgstr ""
"本文档描述了默认 (对于 :class:`Message`) 策略 :attr:`~email.policy.Compat32` 之下的行为。 "
"如果你要使用其他策略，你应当改用 :class:`~email.message.EmailMessage` 类。"

#: ../../library/email.compat32-message.rst:26
msgid ""
"An email message consists of *headers* and a *payload*.  Headers must be "
":rfc:`5322` style names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or the"
" field value.  The payload may be a simple text message, or a binary object,"
" or a structured sequence of sub-messages each with their own set of headers"
" and their own payload.  The latter type of payload is indicated by the "
"message having a MIME type such as :mimetype:`multipart/\\*` or "
":mimetype:`message/rfc822`."
msgstr ""
"电子邮件消息由多个 *标头* 和一个 *载荷* 组成。 标头必须为 :rfc:`5322` 风格的名称和值，其中字典名和值由冒号分隔。 "
"冒号不是字段名或字段值的组成部分。 载荷可以是简单的文本消息，或是二进制对象，或是多个子消息的结构化序列，每个子消息都有自己的标头集合和自己的载荷。 "
"后一种类型的载荷是由具有 :mimetype:`multipart/\\*` 或 :mimetype:`message/rfc822` 等 MIME "
"类型的消息来指明的。"

#: ../../library/email.compat32-message.rst:35
msgid ""
"The conceptual model provided by a :class:`Message` object is that of an "
"ordered dictionary of headers with additional methods for accessing both "
"specialized information from the headers, for accessing the payload, for "
"generating a serialized version of the message, and for recursively walking "
"over the object tree.  Note that duplicate headers are supported but special"
" methods must be used to access them."
msgstr ""
":class:`Message` "
"对象所提供了概念化模型是由标头组成的有序字典，加上用于访问标头中的特殊信息以及访问载荷的额外方法，以便能生成消息的序列化版本，并递归地遍历对象树。 "
"请注意重复的标头是受支持的，但必须使用特殊的方法来访问它们。"

#: ../../library/email.compat32-message.rst:42
msgid ""
"The :class:`Message` pseudo-dictionary is indexed by the header names, which"
" must be ASCII values.  The values of the dictionary are strings that are "
"supposed to contain only ASCII characters; there is some special handling "
"for non-ASCII input, but it doesn't always produce the correct results.  "
"Headers are stored and returned in case-preserving form, but field names are"
" matched case-insensitively.  There may also be a single envelope header, "
"also known as the *Unix-From* header or the ``From_`` header.  The *payload*"
" is either a string or bytes, in the case of simple message objects, or a "
"list of :class:`Message` objects, for MIME container documents (e.g. "
":mimetype:`multipart/\\*` and :mimetype:`message/rfc822`)."
msgstr ""
":class:`Message` 伪字典以标头名作为索引，标头名必须为 ASCII 值。 字典的值为应当只包含 ASCII 字符的字符串；对于非 "
"ASCII 输入有一些特殊处理，但这并不总能产生正确的结果。 标头以保留原大小写的形式存储和返回，但字段名称匹配对大小写不敏感。 "
"还可能会有一个单独的封包标头，也称 *Unix-From* 标头或 ``From_`` 标头。 *载荷* "
"对于简单消息对象的情况是一个字符串或字节串，对于 MIME 容器文档的情况 (例如 :mimetype:`multipart/\\*` 和 "
":mimetype:`message/rfc822`) 则是一个 :class:`Message` 对象。"

#: ../../library/email.compat32-message.rst:53
msgid "Here are the methods of the :class:`Message` class:"
msgstr "以下是 :class:`Message` 类的方法:"

#: ../../library/email.compat32-message.rst:58
msgid ""
"If *policy* is specified (it must be an instance of a :mod:`~email.policy` "
"class) use the rules it specifies to update and serialize the representation"
" of the message.  If *policy* is not set, use the :class:`compat32 "
"<email.policy.Compat32>` policy, which maintains backward compatibility with"
" the Python 3.2 version of the email package.  For more information see the "
":mod:`~email.policy` documentation."
msgstr ""
"如果指定了 *policy* (它必须为 :mod:`~email.policy` 类的实例) 则使用它所设置的规则来更新和序列化消息的表示形式。 "
"如果未设置 *policy*，则使用 :class:`compat32 <email.policy.Compat32>` 策略，该策略会保持对 "
"Python 3.2 版 email 包的向下兼容性。 更多信息请参阅 :mod:`~email.policy` 文档。"

#: ../../library/email.compat32-message.rst:65
msgid "The *policy* keyword argument was added."
msgstr "增加了 *policy* 关键字参数。"

#: ../../library/email.compat32-message.rst:70
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string. *unixfrom* "
"defaults to ``False``.  For backward compatibility reasons, *maxheaderlen* "
"defaults to ``0``, so if you want a different value you must override it "
"explicitly (the value specified for *max_line_length* in the policy will be "
"ignored by this method).  The *policy* argument may be used to override the "
"default policy obtained from the message instance. This can be used to "
"control some of the formatting produced by the method, since the specified "
"*policy* will be passed to the ``Generator``."
msgstr ""
"以展平的字符串形式返回整个消息对象。 或可选的 *unixfrom* 为真值，返回的字符串会包括封包标头。 *unixfrom* 的默认值是 "
"``False``。 出于保持向下兼容性的原因，*maxheaderlen* 的默认值是 "
"``0``，因此如果你想要不同的值你必须显式地重写它（在策略中为 *max_line_length* 指定的值将被此方法忽略）。 *policy* "
"参数可被用于覆盖从消息实例获取的默认策略。 这可以用来对该方法所输出的格式进行一些控制，因为指定的 *policy* 将被传递给 "
"``Generator``。"

#: ../../library/email.compat32-message.rst:80
#: ../../library/email.compat32-message.rst:122
msgid ""
"Flattening the message may trigger changes to the :class:`Message` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"如果需要填充默认值以完成对字符串的转换则展平消息可能触发对 :class:`Message` 的修改（例如，MIME 边界可能会被生成或被修改）。"

#: ../../library/email.compat32-message.rst:84
msgid ""
"Note that this method is provided as a convenience and may not always format"
" the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox"
" format.  For more flexibility, instantiate a "
":class:`~email.generator.Generator` instance and use its "
":meth:`~email.generator.Generator.flatten` method directly.  For example::"
msgstr ""
"请注意此方法是出于便捷原因提供的，并可能无法总是以你想要的方式来格式化消息。 例如，在默认情况下它不会按 Unix mbox 格式的要求对以 "
"``From`` 打头的行执行调整。 为了获得更高灵活性，请实例化一个 :class:`~email.generator.Generator` "
"实例并直接使用其 :meth:`~email.generator.Generator.flatten` 方法。 例如::"

#: ../../library/email.compat32-message.rst:91
msgid ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:98
msgid ""
"If the message object contains binary data that is not encoded according to "
"RFC standards, the non-compliant data will be replaced by unicode \"unknown "
"character\" code points.  (See also :meth:`.as_bytes` and "
":class:`~email.generator.BytesGenerator`.)"
msgstr ""
"如果消息对象包含未按照 RFC 标准进行编码的二进制数据，则这些不合规数据将被 unicode \"unknown character\" "
"码位值所替代。 （另请参阅 :meth:`.as_bytes` 和 :class:`~email.generator.BytesGenerator`。）"

#: ../../library/email.compat32-message.rst:103
msgid "the *policy* keyword argument was added."
msgstr "增加了 *policy* 关键字参数。"

#: ../../library/email.compat32-message.rst:108
msgid ""
"Equivalent to :meth:`.as_string`.  Allows ``str(msg)`` to produce a string "
"containing the formatted message."
msgstr "等价于 :meth:`.as_string`。 让 ``str(msg)`` 产生一个包含已格式化消息的字符串。"

#: ../../library/email.compat32-message.rst:114
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string."
"  *unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the ``BytesGenerator``."
msgstr ""
"以字节串对象的形式返回整个扁平化后的消息。 当可选的 *unixfrom* 为真值时，返回的字符串会包括封包标头。 *unixfrom* 的默认值为 "
"``False``。 *policy* 参数可被用于覆盖从消息实例获取的默认策略。 这可被用来控制该方法所产生的部分格式化效果，因为指定的 "
"*policy* 将被传递给 ``BytesGenerator``。"

#: ../../library/email.compat32-message.rst:126
msgid ""
"Note that this method is provided as a convenience and may not always format"
" the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox"
" format.  For more flexibility, instantiate a "
":class:`~email.generator.BytesGenerator` instance and use its "
":meth:`~email.generator.BytesGenerator.flatten` method directly. For "
"example::"
msgstr ""
"请注意此方法是出于便捷原因提供的，并可能无法总是以你想要的方式来格式化消息。 例如，在默认情况下它不会按 Unix mbox 格式的要求对以 "
"``From`` 打头的行执行调整。 为了获得更高灵活性，请实例化一个 :class:`~email.generator.BytesGenerator`"
" 实例并直接使用其 :meth:`~email.generator.BytesGenerator.flatten` 方法。 例如::"

#: ../../library/email.compat32-message.rst:134
msgid ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:146
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the formatted message."
msgstr "等价于 :meth:`.as_bytes`。 让 ``bytes(msg)`` 产生一个包含已格式化消息的字节串对象。"

#: ../../library/email.compat32-message.rst:154
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ "
":class:`Message` objects, otherwise return ``False``.  When "
":meth:`is_multipart` returns ``False``, the payload should be a string "
"object (which might be a CTE encoded binary payload).  (Note that "
":meth:`is_multipart` returning ``True`` does not necessarily mean that "
"\"msg.get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:`Message` is "
"of type ``message/rfc822``.)"
msgstr ""
"如果该消息的载荷是一个子 :class:`Message` 对象列表则返回 ``True``，否则返回 ``False``。 当 "
":meth:`is_multipart` 返回 ``False`` 时，载荷应当是一个字符串对象（有可能是一个 CTE 编码的二进制载荷）。 （请注意 "
":meth:`is_multipart` 返回 ``True`` 并不意味着 \"msg.get_content_maintype() == "
"'multipart'\" 将返回 ``True``。 例如，``is_multipart`` 在 :class:`Message` 类型为 "
"``message/rfc822`` 时也将返回 ``True``。）"

#: ../../library/email.compat32-message.rst:166
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string."
msgstr "将消息的封包标头设为 *unixfrom*，这应当是一个字符串。"

#: ../../library/email.compat32-message.rst:171
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr "返回消息的信封头。如果信封头从未被设置过，默认返回 ``None`` 。"

#: ../../library/email.compat32-message.rst:177
msgid ""
"Add the given *payload* to the current payload, which must be ``None`` or a "
"list of :class:`Message` objects before the call. After the call, the "
"payload will always be a list of :class:`Message` objects.  If you want to "
"set the payload to a scalar object (e.g. a string), use :meth:`set_payload` "
"instead."
msgstr ""
"将给定的 *payload* 添加到当前载荷中，当前载荷在该调用之前必须为 ``None`` 或是一个 :class:`Message` 对象列表。 "
"在调用之后，此载荷将总是一个 :class:`Message` 对象列表。 如果你想将此载荷设为一个标量对象（如字符串），请改用 "
":meth:`set_payload`。"

#: ../../library/email.compat32-message.rst:183
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by "
":meth:`~email.message.EmailMessage.set_content` and the related ``make`` and"
" ``add`` methods."
msgstr ""
"这是一个旧式方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被 "
":meth:`~email.message.EmailMessage.set_content` 及相关的 ``make`` 和 ``add`` "
"方法所替代。"

#: ../../library/email.compat32-message.rst:191
msgid ""
"Return the current payload, which will be a list of :class:`Message` objects"
" when :meth:`is_multipart` is ``True``, or a string when "
":meth:`is_multipart` is ``False``.  If the payload is a list and you mutate "
"the list object, you modify the message's payload in place."
msgstr ""
"返回当前的载荷，它在 :meth:`is_multipart` 为 ``True`` 时将是一个 :class:`Message` 对象列表，在 "
":meth:`is_multipart` 为 ``False`` 时则是一个字符串。 "
"如果该载荷是一个列表且你修改了这个列表对象，那么你就是原地修改了消息的载荷。"

#: ../../library/email.compat32-message.rst:196
msgid ""
"With optional argument *i*, :meth:`get_payload` will return the *i*-th "
"element of the payload, counting from zero, if :meth:`is_multipart` is "
"``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or "
"greater than or equal to the number of items in the payload.  If the payload"
" is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is given, a "
":exc:`TypeError` is raised."
msgstr ""
"传入可选参数 *i* 时，如果 :meth:`is_multipart` 为 ``True``，:meth:`get_payload` "
"将返回载荷从零开始计数的第 *i* 个元素。 如果 *i* 小于 0 或大于等于载荷中的条目数则将引发 :exc:`IndexError`。 "
"如果载荷是一个字符串 (即 :meth:`is_multipart` 为 ``False``) 且给出了 *i*，则会引发 "
":exc:`TypeError`。"

#: ../../library/email.compat32-message.rst:203
msgid ""
"Optional *decode* is a flag indicating whether the payload should be decoded"
" or not, according to the :mailheader:`Content-Transfer-Encoding` header. "
"When ``True`` and the message is not a multipart, the payload will be "
"decoded if this header's value is ``quoted-printable`` or ``base64``. If "
"some other encoding is used, or :mailheader:`Content-Transfer-Encoding` "
"header is missing, the payload is returned as-is (undecoded).  In all cases "
"the returned value is binary data.  If the message is a multipart and the "
"*decode* flag is ``True``, then ``None`` is returned.  If the payload is "
"base64 and it was not perfectly formed (missing padding, characters outside "
"the base64 alphabet), then an appropriate defect will be added to the "
"message's defect property (:class:`~email.errors.InvalidBase64PaddingDefect`"
" or :class:`~email.errors.InvalidBase64CharactersDefect`, respectively)."
msgstr ""
"可选的 *decode* 是一个指明载荷是否应根据 :mailheader:`Content-Transfer-Encoding` 标头被解码的旗标。 "
"当其值为 ``True`` 且消息没有多个部分时，如果此标头值为 ``quoted-printable`` 或 ``base64`` 则载荷将被解码。 "
"如果使用了其他编码格式，或者找不到 :mailheader:`Content-Transfer-Encoding` 标头时，载荷将被原样返回（不编码）。"
" 在所有情况下返回值都是二进制数据。 如果消息有多个部分且 *decode* 旗标为 ``True``，则将返回 ``None``。 如果载荷为 "
"base64 但内容不完全正确（如缺少填充符、存在 base64 字母表以外的字符等），则将在消息的缺陷属性中添加适当的缺陷值 (分别为 "
":class:`~email.errors.InvalidBase64PaddingDefect` 或 "
":class:`~email.errors.InvalidBase64CharactersDefect`)。"

#: ../../library/email.compat32-message.rst:217
msgid ""
"When *decode* is ``False`` (the default) the body is returned as a string "
"without decoding the :mailheader:`Content-Transfer-Encoding`.  However, for "
"a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made to "
"decode the original bytes using the ``charset`` specified by the "
":mailheader:`Content-Type` header, using the ``replace`` error handler. If "
"no ``charset`` is specified, or if the ``charset`` given is not recognized "
"by the email package, the body is decoded using the default ASCII charset."
msgstr ""
"当 *decode* 为 ``False`` (默认值) 时消息体会作为字符串返回而不解码 :mailheader:`Content-Transfer-"
"Encoding`。 但是，对于 :mailheader:`Content-Transfer-Encoding` 为 8bit 的情况，会尝试使用 "
":mailheader:`Content-Type` 标头指定的 ``charset`` 来解码原始字节串，并使用 ``replace`` "
"错误处理程序。  如果未指定 ``charset``，或者如果指定的 ``charset`` 未被 email 包所识别，则会使用默认的 ASCII "
"字符集来解码消息体。"

#: ../../library/email.compat32-message.rst:226
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by "
":meth:`~email.message.EmailMessage.get_content` and "
":meth:`~email.message.EmailMessage.iter_parts`."
msgstr ""
"这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被 "
":meth:`~email.message.EmailMessage.get_content` 和 "
":meth:`~email.message.EmailMessage.iter_parts` 所替代。"

#: ../../library/email.compat32-message.rst:234
msgid ""
"Set the entire message object's payload to *payload*.  It is the client's "
"responsibility to ensure the payload invariants.  Optional *charset* sets "
"the message's default character set; see :meth:`set_charset` for details."
msgstr ""
"将整个消息对象的载荷设为 *payload*。 客户端要负责确保载荷的不变性。 可选的 *charset* 用于设置消息的默认字符集；详情请参阅 "
":meth:`set_charset`。"

#: ../../library/email.compat32-message.rst:238
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by "
":meth:`~email.message.EmailMessage.set_content`."
msgstr ""
"这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被 "
":meth:`~email.message.EmailMessage.set_content` 所替代。"

#: ../../library/email.compat32-message.rst:245
msgid ""
"Set the character set of the payload to *charset*, which can either be a "
":class:`~email.charset.Charset` instance (see :mod:`email.charset`), a "
"string naming a character set, or ``None``.  If it is a string, it will be "
"converted to a :class:`~email.charset.Charset` instance.  If *charset* is "
"``None``, the ``charset`` parameter will be removed from the "
":mailheader:`Content-Type` header (the message will not be otherwise "
"modified).  Anything else will generate a :exc:`TypeError`."
msgstr ""
"将载荷的字符集设为 *charset*，它可以是 :class:`~email.charset.Charset` 实例 (参见 "
":mod:`email.charset`)、字符集名称字符串或 ``None``。 如果是字符串，它将被转换为一个 "
":class:`~email.charset.Charset` 实例。 如果 *charset* 是 ``None``，``charset`` 形参将从"
" :mailheader:`Content-Type` 标头中被删除（消息将不会进行其他修改）。 任何其他值都将导致 :exc:`TypeError`。"

#: ../../library/email.compat32-message.rst:253
msgid ""
"If there is no existing :mailheader:`MIME-Version` header one will be added."
"  If there is no existing :mailheader:`Content-Type` header, one will be "
"added with a value of :mimetype:`text/plain`.  Whether the "
":mailheader:`Content-Type` header already exists or not, its ``charset`` "
"parameter will be set to *charset.output_charset*.   If "
"*charset.input_charset* and *charset.output_charset* differ, the payload "
"will be re-encoded to the *output_charset*.  If there is no existing "
":mailheader:`Content-Transfer-Encoding` header, then the payload will be "
"transfer-encoded, if needed, using the specified "
":class:`~email.charset.Charset`, and a header with the appropriate value "
"will be added.  If a :mailheader:`Content-Transfer-Encoding` header already "
"exists, the payload is assumed to already be correctly encoded using that "
":mailheader:`Content-Transfer-Encoding` and is not modified."
msgstr ""
"如果 :mailheader:`MIME-Version` 标头不存在则将被添加。 如果 :mailheader:`Content-Type` "
"标头不存在，则将添加一个值为 :mimetype:`text/plain` 的该标头。 无论 :mailheader:`Content-Type` "
"标头是否已存在，其 ``charset`` 形参都将被设为 *charset.output_charset*。 如果 "
"*charset.input_charset* 和 *charset.output_charset* 不同，则载荷将被重编码为 "
"*output_charset*。 如果 :mailheader:`Content-Transfer-Encoding` "
"标头不存在，则载荷将在必要时使用指定的 :class:`~email.charset.Charset` 来转换编码，并将添加一个具有相应值的标头。 如果"
" :mailheader:`Content-Transfer-Encoding` 标头已存在，则会假定载荷已使用该 "
":mailheader:`Content-Transfer-Encoding` 进行正确编码并不会再被修改。"

#: ../../library/email.compat32-message.rst:267
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the *charset* parameter of the "
":meth:`email.message.EmailMessage.set_content` method."
msgstr ""
"这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被 "
":meth:`email.message.EmailMessage.set_content` 方法的 *charset* 形参所替代。"

#: ../../library/email.compat32-message.rst:275
msgid ""
"Return the :class:`~email.charset.Charset` instance associated with the "
"message's payload."
msgstr "返回与消息的载荷相关联的 :class:`~email.charset.Charset` 实例。"

#: ../../library/email.compat32-message.rst:278
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"it always returns ``None``."
msgstr "这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它将总是返回 ``None``。"

#: ../../library/email.compat32-message.rst:283
msgid ""
"The following methods implement a mapping-like interface for accessing the "
"message's :rfc:`2822` headers.  Note that there are some semantic "
"differences between these methods and a normal mapping (i.e. dictionary) "
"interface.  For example, in a dictionary there are no duplicate keys, but "
"here there may be duplicate message headers.  Also, in dictionaries there is"
" no guaranteed order to the keys returned by :meth:`keys`, but in a "
":class:`Message` object, headers are always returned in the order they "
"appeared in the original message, or were added to the message later.  Any "
"header deleted and then re-added are always appended to the end of the "
"header list."
msgstr ""
"以下方法实现了用于访问消息的 :rfc:`2822` 标头的类映射接口。  请注意这些方法和普通映射（例如字典）接口之间存在一些语义上的不同。 "
"举例来说，在一个字典中不能有重复的键，但消息标头则可能有重复。 并且，在字典中由 :meth:`keys` 返回的键的顺序是没有保证的，但在 "
":class:`Message` 对象中，标头总是会按它们在原始消息中的出现或后继加入顺序返回。 任何已删除再重新加入的标头总是会添加到标头列表的末尾。"

#: ../../library/email.compat32-message.rst:293
msgid ""
"These semantic differences are intentional and are biased toward maximal "
"convenience."
msgstr "这些语义上的差异是有意为之且其目的是为了提供最大的便利性。"

#: ../../library/email.compat32-message.rst:296
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr "请注意在任何情况下，消息当中的任何封包标头都不会包含在映射接口当中。"

#: ../../library/email.compat32-message.rst:299
msgid ""
"In a model generated from bytes, any header values that (in contravention of"
" the RFCs) contain non-ASCII bytes will, when retrieved through this "
"interface, be represented as :class:`~email.header.Header` objects with a "
"charset of ``unknown-8bit``."
msgstr ""
"在由字符串生成的模型中，任何包含非 ASCII 字节数据（违反 RFC）的标头值在通过此接口来获取时，将被表示为使用 ``unknown-8bit`` "
"字符集的 :class:`~email.header.Header` 对象。"

#: ../../library/email.compat32-message.rst:307
msgid "Return the total number of headers, including duplicates."
msgstr "返回标头的总数，包括重复项。"

#: ../../library/email.compat32-message.rst:312
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done case-insensitively and *name* should not include the trailing colon. "
"Used for the ``in`` operator, e.g.::"
msgstr ""
"如果消息对象中有一个名为 *name* 的字段则返回 ``True``。 匹配操作对大小写不敏感并且 *name* 不应包括末尾的冒号。 用于 "
"``in`` 运算符，例如::"

#: ../../library/email.compat32-message.rst:316
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"

#: ../../library/email.compat32-message.rst:322
msgid ""
"Return the value of the named header field.  *name* should not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a "
":exc:`KeyError` is never raised."
msgstr ""
"返回指定名称标头字段的值。 *name* 不应包括作为字段分隔符的冒号。 如果标头未找到，则返回 ``None``；:exc:`KeyError` "
"永远不会被引发。"

#: ../../library/email.compat32-message.rst:326
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined."
"  Use the :meth:`get_all` method to get the values of all the extant named "
"headers."
msgstr ""
"请注意如果指定名称的字段在消息标头中多次出现，具体将返回哪个字段值是未定义的。 请使用 :meth:`get_all` 方法来获取所有指定名称标头的值。"

#: ../../library/email.compat32-message.rst:334
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing fields."
msgstr "将具有字段名 *name* 和值 *val* 的标头添加到消息中。 字段会被添加到消息的现有字段的末尾。"

#: ../../library/email.compat32-message.rst:337
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, "
"e.g.::"
msgstr ""
"请注意，这个方法 *既不会* 覆盖 *也不会* 删除任何字段名重名的已有字段。如果你确实想保证新字段是整个信息头当中唯一拥有 *name* "
"字段名的字段，你需要先把旧字段删除。例如："

#: ../../library/email.compat32-message.rst:341
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"

#: ../../library/email.compat32-message.rst:347
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "删除信息头当中字段名匹配 *name* 的所有字段。如果匹配指定名称的字段没有找到，也不会抛出任何异常。"

#: ../../library/email.compat32-message.rst:354
msgid "Return a list of all the message's header field names."
msgstr "以列表形式返回消息头中所有的字段名。"

#: ../../library/email.compat32-message.rst:359
msgid "Return a list of all the message's field values."
msgstr "以列表形式返回消息头中所有的字段值。"

#: ../../library/email.compat32-message.rst:364
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "以二元元组的列表形式返回消息头中所有的字段名和字段值。"

#: ../../library/email.compat32-message.rst:370
msgid ""
"Return the value of the named header field.  This is identical to "
":meth:`~object.__getitem__` except that optional *failobj* is returned if "
"the named header is missing (defaults to ``None``)."
msgstr ""
"返回对应标头字段名的值。 这个方法与 :meth:`~object.__getitem__` 是一样的，只是如果对应标头不存在则返回可选的 "
"*failobj* (默认为 ``None``)。"

#: ../../library/email.compat32-message.rst:374
msgid "Here are some additional useful methods:"
msgstr "以下是一些有用的附加方法:"

#: ../../library/email.compat32-message.rst:379
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr "返回字段名为 *name* 的所有字段值的列表。如果信息内不存在匹配的字段，返回 *failobj* （其默认值为 ``None`` ）。"

#: ../../library/email.compat32-message.rst:386
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary*"
" value for the header."
msgstr ""
"高级头字段设定。这个方法与 :meth:`__setitem__` 类似，不过你可以使用关键字参数为字段提供附加参数。 *_name* 是字段名， "
"*_value* 是字段 *主* 值。"

#: ../../library/email.compat32-message.rst:391
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken"
" as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added.  If the value contains non-ASCII characters, it can be "
"specified as a three tuple in the format ``(CHARSET, LANGUAGE, VALUE)``, "
"where ``CHARSET`` is a string naming the charset to be used to encode the "
"value, ``LANGUAGE`` can usually be set to ``None`` or the empty string (see "
":rfc:`2231` for other possibilities), and ``VALUE`` is the string value "
"containing non-ASCII code points.  If a three tuple is not passed and the "
"value contains non-ASCII characters, it is automatically encoded in "
":rfc:`2231` format using a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of "
"``None``."
msgstr ""
"对于关键字参数字典 *_params* 中的每一项，其键会被当作形参名，并执行下划线和连字符间的转换（因为连字符不是合法的 Python 标识符）。 "
"通常，形参将以 ``key=\"value\"`` 的形式添加，除非值为 ``None``，在这种情况下将只添加键。 如果值包含非 ASCII "
"字符，可将其指定为格式为 ``(CHARSET, LANGUAGE, VALUE)`` 的三元组，其中 ``CHARSET`` "
"为要用来编码值的字符集名称字符串，``LANGUAGE`` 通常可设为 ``None`` 或空字符串（请参阅 :rfc:`2231` "
"了解其他可能的取值），而 ``VALUE`` 为包含非 ASCII 码位的字符串值。 如果不是传入一个三元组且值包含非 ASCII 字符，则会自动以 "
":rfc:`2231` 格式使用 ``CHARSET`` 为 ``utf-8`` 和 ``LANGUAGE`` 为 ``None`` 对其进行编码。"

#: ../../library/email.compat32-message.rst:405
msgid "Here's an example::"
msgstr "以下是为示例代码::"

#: ../../library/email.compat32-message.rst:407
msgid ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

#: ../../library/email.compat32-message.rst:409
msgid "This will add a header that looks like ::"
msgstr "会添加一个形如下文的头字段："

#: ../../library/email.compat32-message.rst:411
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/email.compat32-message.rst:413
msgid "An example with non-ASCII characters::"
msgstr "使用非 ASCII 字符的示例代码::"

#: ../../library/email.compat32-message.rst:415
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

#: ../../library/email.compat32-message.rst:418
msgid "Which produces ::"
msgstr "它的输出结果为 ::"

#: ../../library/email.compat32-message.rst:420
msgid "Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""
msgstr ""
"Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""

#: ../../library/email.compat32-message.rst:425
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case.  If no matching"
" header was found, a :exc:`KeyError` is raised."
msgstr ""
"替换一个标头。 将替换在匹配 *_name* 的消息中找到的第一个标头，标头顺序和字段名大小写保持不变。 如果未找到匹配的标头，则会引发 "
":exc:`KeyError`。"

#: ../../library/email.compat32-message.rst:432
msgid ""
"Return the message's content type.  The returned string is coerced to lower "
"case of the form :mimetype:`maintype/subtype`.  If there was no "
":mailheader:`Content-Type` header in the message the default type as given "
"by :meth:`get_default_type` will be returned.  Since according to "
":rfc:`2045`, messages always have a default type, :meth:`get_content_type` "
"will always return a value."
msgstr ""
"返回消息的内容类型。 返回的字符串会强制转换为 :mimetype:`maintype/subtype` 的全小写形式。 如果消息中没有 "
":mailheader:`Content-Type` 标头则将返回由 :meth:`get_default_type` 给出的默认类型。 因为根据 "
":rfc:`2045`，消息总是要有一个默认类型，所以 :meth:`get_content_type` 将总是返回一个值。"

#: ../../library/email.compat32-message.rst:439
msgid ""
":rfc:`2045` defines a message's default type to be :mimetype:`text/plain` "
"unless it appears inside a :mimetype:`multipart/digest` container, in which "
"case it would be :mimetype:`message/rfc822`.  If the :mailheader:`Content-"
"Type` header has an invalid type specification, :rfc:`2045` mandates that "
"the default type be :mimetype:`text/plain`."
msgstr ""
":rfc:`2045` 将消息的默认类型定义为 :mimetype:`text/plain`，除非它是出现在 "
":mimetype:`multipart/digest` 容器内，在这种情况下其类型应为 :mimetype:`message/rfc822`。 如果 "
":mailheader:`Content-Type` 标头指定了无效的类型，:rfc:`2045` 规定其默认类型应为 "
":mimetype:`text/plain`。"

#: ../../library/email.compat32-message.rst:448
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"返回信息的主要内容类型。准确来说，此方法返回的是 :meth:`get_content_type` 方法所返回的形如 "
":mimetype:`maintype/subtype` 的字符串当中的 :mimetype:`maintype` 部分。"

#: ../../library/email.compat32-message.rst:454
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part"
" of the string returned by :meth:`get_content_type`."
msgstr ""
"返回信息的子内容类型。准确来说，此方法返回的是 :meth:`get_content_type` 方法所返回的形如 "
":mimetype:`maintype/subtype` 的字符串当中的 :mimetype:`subtype` 部分。"

#: ../../library/email.compat32-message.rst:460
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of "
":mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"返回默认的内容类型。绝大多数的信息，其默认内容类型都是 :mimetype:`text/plain` 。作为 "
":mimetype:`multipart/digest` 容器内子部分的信息除外，它们的默认内容类型是 "
":mimetype:`message/rfc822` 。"

#: ../../library/email.compat32-message.rst:468
msgid ""
"Set the default content type.  *ctype* should either be "
":mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is not "
"enforced.  The default content type is not stored in the "
":mailheader:`Content-Type` header."
msgstr ""
"设置默认的内容类型。 *ctype* 应当为 :mimetype:`text/plain` 或者 "
":mimetype:`message/rfc822`，尽管这并非强制。 默认的内容类型不会存储在 :mailheader:`Content-Type` "
"标头中。"

#: ../../library/email.compat32-message.rst:476
msgid ""
"Return the message's :mailheader:`Content-Type` parameters, as a list. The "
"elements of the returned list are 2-tuples of key/value pairs, as split on "
"the ``'='`` sign.  The left hand side of the ``'='`` is the key, while the "
"right hand side is the value.  If there is no ``'='`` sign in the parameter "
"the value is the empty string, otherwise the value is as described in "
":meth:`get_param` and is unquoted if optional *unquote* is ``True`` (the "
"default)."
msgstr ""
"将消息的 :mailheader:`Content-Type` 形参作为列表返回。 所返回列表的元素为以 ``'='`` 号拆分出的键/值对 2 元组。"
" ``'='`` 左侧的为键，右侧的为值。 如果形参值中没有 ``'='`` 号，否则该将值如 :meth:`get_param` 描述并且在可选 "
"*unquote* 为 ``True`` (默认值) 时会被取消转义。"

#: ../../library/email.compat32-message.rst:484
msgid ""
"Optional *failobj* is the object to return if there is no "
":mailheader:`Content-Type` header.  Optional *header* is the header to "
"search instead of :mailheader:`Content-Type`."
msgstr ""
"可选的 *failobj* 是在没有 :mailheader:`Content-Type` 标头时要返回的对象。 可选的 *header* 是要替代 "
":mailheader:`Content-Type` 被搜索的标头。"

#: ../../library/email.compat32-message.rst:488
#: ../../library/email.compat32-message.rst:526
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the *params* property of the individual "
"header objects returned by the header access methods."
msgstr ""
"这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被标头访问方法所返回的单独标头对象的 "
"*params* 特征属性所替代。"

#: ../../library/email.compat32-message.rst:496
msgid ""
"Return the value of the :mailheader:`Content-Type` header's parameter "
"*param* as a string.  If the message has no :mailheader:`Content-Type` "
"header or if there is no such parameter, then *failobj* is returned "
"(defaults to ``None``)."
msgstr ""
"将 :mailheader:`Content-Type` 标头的形参 *param* 作为字符串返回。 如果消息没有 "
":mailheader:`Content-Type` 标头或者没有这样的形参，则返回 *failobj* (默认为 ``None``)。"

#: ../../library/email.compat32-message.rst:501
msgid ""
"Optional *header* if given, specifies the message header to use instead of "
":mailheader:`Content-Type`."
msgstr "如果给出可选的 *header*，它会指定要替代 :mailheader:`Content-Type` 来使用的消息标头。"

#: ../../library/email.compat32-message.rst:504
msgid ""
"Parameter keys are always compared case insensitively.  The return value can"
" either be a string, or a 3-tuple if the parameter was :rfc:`2231` encoded."
"  When it's a 3-tuple, the elements of the value are of the form ``(CHARSET,"
" LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and ``LANGUAGE`` can be "
"``None``, in which case you should consider ``VALUE`` to be encoded in the "
"``us-ascii`` charset.  You can usually ignore ``LANGUAGE``."
msgstr ""
"形参的键总是以大小写不敏感的方式来比较的。 返回值可以是一个字符串，或者如果形参以 :rfc:`2231` 编码则是一个 3 元组。 当为 3 "
"元组时，值中的元素采用 ``(CHARSET, LANGUAGE, VALUE)`` 的形式。 请注意 ``CHARSET`` 和 "
"``LANGUAGE`` 都可以为 ``None``，在此情况下你应当将 ``VALUE`` 当作以 ``us-ascii`` 字符集来编码。 "
"你可以总是忽略 ``LANGUAGE``。"

#: ../../library/email.compat32-message.rst:512
msgid ""
"If your application doesn't care whether the parameter was encoded as in "
":rfc:`2231`, you can collapse the parameter value by calling "
":func:`email.utils.collapse_rfc2231_value`, passing in the return value from"
" :meth:`get_param`.  This will return a suitably decoded Unicode string when"
" the value is a tuple, or the original string unquoted if it isn't.  For "
"example::"
msgstr ""
"如果你的应用不关心形参是否以 :rfc:`2231` 来编码，你可以通过调用 "
":func:`email.utils.collapse_rfc2231_value` 来展平形参值，传入来自 :meth:`get_param` "
"的返回值。 当值为元组时这将返回一个经适当编码的 Unicode 字符串，否则返回未经转换的原字符串。 例如::"

#: ../../library/email.compat32-message.rst:519
msgid ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"
msgstr ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"

#: ../../library/email.compat32-message.rst:522
msgid ""
"In any case, the parameter value (either the returned string, or the "
"``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set "
"to ``False``."
msgstr ""
"无论在哪种情况下，形参值（或为返回的字符串，或为 3 元组形式的 ``VALUE`` 条目）总是未经转换的，除非 *unquote* 被设为 "
"``False``。"

#: ../../library/email.compat32-message.rst:535
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, its value will be replaced with *value*.  If "
"the :mailheader:`Content-Type` header as not yet been defined for this "
"message, it will be set to :mimetype:`text/plain` and the new parameter "
"value will be appended as per :rfc:`2045`."
msgstr ""
"在 :mailheader:`Content-Type` 标头中设置一个形参。 如果该形参已存在于标头中，它的值将被替换为 *value*。 "
"如果此消息还未定义 :mailheader:`Content-Type` 标头，它将被设为 :mimetype:`text/plain` "
"且新的形参值将按 :rfc:`2045` 的要求添加。"

#: ../../library/email.compat32-message.rst:541
msgid ""
"Optional *header* specifies an alternative header to :mailheader:`Content-"
"Type`, and all parameters will be quoted as necessary unless optional "
"*requote* is ``False`` (the default is ``True``)."
msgstr ""
"可选的 *header* 指定一个 :mailheader:`Content-Type` 的替代标头，并且所有形参将根据需要被转换，除非可选的 "
"*requote* 为 ``False`` (默认为 ``True``)。"

#: ../../library/email.compat32-message.rst:545
msgid ""
"If optional *charset* is specified, the parameter will be encoded according "
"to :rfc:`2231`. Optional *language* specifies the RFC 2231 language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings."
msgstr ""
"如果指定了可选的 *charset*，形参将按照 :rfc:`2231` 来编码。 可选的 *language* 指定了 RFC 2231 "
"的语言，默认为空字符串。 *charset* 和 *language* 都应为字符串。"

#: ../../library/email.compat32-message.rst:550
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"如果 *replace* 为 ``False`` （默认值），该头字段会被移动到所有头字段列表的末尾。如果 *replace* 为 ``True`` "
"，字段会被原地更新。"

#: ../../library/email.compat32-message.rst:554
msgid "``replace`` keyword was added."
msgstr "添加了 ``replace`` 关键字。"

#: ../../library/email.compat32-message.rst:559
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its"
" value.  All values will be quoted as necessary unless *requote* is "
"``False`` (the default is ``True``).  Optional *header* specifies an "
"alternative to :mailheader:`Content-Type`."
msgstr ""
"从 :mailheader:`Content-Type` 标头中完全移除给定的形参。 标头将被原地重写并不带该形参或它的值。  "
"所有的值将根据需要被转换，除非 *requote* 为 ``False`` (默认为 ``True``)。 可选的 *header* 指定 "
":mailheader:`Content-Type` 的一个替代项。"

#: ../../library/email.compat32-message.rst:568
msgid ""
"Set the main type and subtype for the :mailheader:`Content-Type` header. "
"*type* must be a string in the form :mimetype:`maintype/subtype`, otherwise "
"a :exc:`ValueError` is raised."
msgstr ""
"设置 :mailheader:`Content-Type` 标头的主类型和子类型。 *type* 必须为 "
":mimetype:`maintype/subtype` 形式的字符串，否则会引发 :exc:`ValueError`。"

#: ../../library/email.compat32-message.rst:572
msgid ""
"This method replaces the :mailheader:`Content-Type` header, keeping all the "
"parameters in place.  If *requote* is ``False``, this leaves the existing "
"header's quoting as is, otherwise the parameters will be quoted (the "
"default)."
msgstr ""
"此方法可替换 :mailheader:`Content-Type` 标头，并保持所有形参不变。 如果 *requote* 为 "
"``False``，这会保持原有标头引用转换不变，否则形参将被引用转换（默认行为）。"

#: ../../library/email.compat32-message.rst:577
msgid ""
"An alternative header can be specified in the *header* argument. When the "
":mailheader:`Content-Type` header is set a :mailheader:`MIME-Version` header"
" is also added."
msgstr ""
"可以在 *header* 参数中指定一个替代标头。 当 :mailheader:`Content-Type` 标头被设置时也会添加一个 "
":mailheader:`MIME-Version` 标头。"

#: ../../library/email.compat32-message.rst:581
msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the ``make_`` and ``add_`` methods."
msgstr ""
"这是一个遗留方法。 在 :class:`~email.message.EmailMessage` 类上它的功能已被 ``make_`` and "
"``add_`` 方法所替代。"

#: ../../library/email.compat32-message.rst:588
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or"
" the header is missing, then *failobj* is returned. The returned string will"
" always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"返回信息头当中 :mailheader:`Content-Disposition` 字段当中名为 ``filename`` "
"的参数值。如果该字段当中没有此参数，该方法会退而寻找 :mailheader:`Content-Type` 字段当中的 ``name`` "
"参数值。如果这个也没有找到，或者这些个字段压根就不存在，返回 *failobj* 。返回的字符串永远按照 "
":func:`email.utils.unquote` 方法去除引号。"

#: ../../library/email.compat32-message.rst:599
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"返回信息头当中 :mailheader:`Content-Type` 字段当中名为 ``boundary`` "
"的参数值。如果字段当中没有此参数，或者这些个字段压根就不存在，返回 *failobj* 。返回的字符串永远按照 "
":func:`email.utils.unquote` 方法去除引号。"

#: ../../library/email.compat32-message.rst:607
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if necessary."
"  A :exc:`~email.errors.HeaderParseError` is raised if the message object "
"has no :mailheader:`Content-Type` header."
msgstr ""
"将 :mailheader:`Content-Type` 头字段的 ``boundary`` 参数设置为 *boundary* 。 "
":meth:`set_boundary` 方法永远都会在必要的时候为 *boundary* 添加引号。如果信息对象中没有 "
":mailheader:`Content-Type` 头字段，抛出 :exc:`~email.errors.HeaderParseError` 异常。"

#: ../../library/email.compat32-message.rst:612
msgid ""
"Note that using this method is subtly different than deleting the old "
":mailheader:`Content-Type` header and adding a new one with the new boundary"
" via :meth:`add_header`, because :meth:`set_boundary` preserves the order of"
" the :mailheader:`Content-Type` header in the list of headers. However, it "
"does *not* preserve any continuation lines which may have been present in "
"the original :mailheader:`Content-Type` header."
msgstr ""
"请注意使用这个方法与删除旧的 :mailheader:`Content-Type` 标头并通过 :meth:`add_header` "
"添加一个带有新边界的新标头有细微的差异，因为 :meth:`set_boundary` 会保留 :mailheader:`Content-Type` "
"标头在原标头列表中的顺序。 但是，它 *不会* 保留原 :mailheader:`Content-Type` 标头中可能存在的任何连续的行。"

#: ../../library/email.compat32-message.rst:622
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or"
" if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"返回 :mailheader:`Content-Type` 头字段中的 ``charset`` "
"参数，强制小写。如果字段当中没有此参数，或者这个字段压根不存在，返回 *failobj* 。"

#: ../../library/email.compat32-message.rst:626
msgid ""
"Note that this method differs from :meth:`get_charset` which returns the "
":class:`~email.charset.Charset` instance for the default encoding of the "
"message body."
msgstr ""
"请注意此方法不同于 :meth:`get_charset`，后者会返回 :class:`~email.charset.Charset` "
"实例作为消息体的默认编码格式。"

#: ../../library/email.compat32-message.rst:632
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"返回一个包含了信息内所有字符集名字的列表。 如果信息是 :mimetype:`multipart` "
"类型的，那么列表当中的每一项都对应其载荷的子部分的字符集名字。 否则，该列表是一个长度为 1 的列表。"

#: ../../library/email.compat32-message.rst:636
msgid ""
"Each item in the list will be a string which is the value of the ``charset``"
" parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  However, if the subpart has no :mailheader:`Content-Type` header, "
"no ``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"列表中的每一项都是字符串，它们是其所表示的子部分的 :mailheader:`Content-Type` 标头中 ``charset`` 形参的值。 "
"但是，如果该子部分没有 :mailheader:`Content-Type` 标头，或没有 ``charset`` 形参，或者主 MIME 类型不是 "
":mimetype:`text`，则所返回列表中的对应项将为 *failobj*。"

#: ../../library/email.compat32-message.rst:646
msgid ""
"Return the lowercased value (without parameters) of the message's "
":mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"如果信息的 :mailheader:`Content-Disposition` 头字段存在，返回其字段值；否则返回 ``None`` "
"。返回的值均为小写，不包含参数。如果信息遵循 :rfc:`2183` 标准，则此方法的返回值只可能在 *inline* 、 *attachment* 和"
" ``None`` 之间选择。"

#: ../../library/email.compat32-message.rst:655
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 方法是一个多功能生成器。它可以被用来以深度优先顺序遍历信息对象树的所有部分和子部分。一般而言， :meth:`walk` "
"会被用作 ``for`` 循环的迭代器，每一次迭代都返回其下一个子部分。"

#: ../../library/email.compat32-message.rst:660
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "以下例子会打印出一封具有多部分结构之信息的每个部分的 MIME 类型。"

#: ../../library/email.compat32-message.rst:674
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

#: ../../library/email.compat32-message.rst:686
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` 会遍历所有 :meth:`is_multipart` 方法返回 ``True`` 的部分之子部分，哪怕 "
"``msg.get_content_maintype() == 'multipart'`` 返回的是 ``False`` 。使用 "
"``_structure`` 除错帮助函数可以帮助我们在下面这个例子当中看清楚这一点："

#: ../../library/email.compat32-message.rst:692
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

#: ../../library/email.compat32-message.rst:713
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the"
" subparts."
msgstr ""
"在这里， ``message`` 的部分并非 ``multiparts`` ，但是它们真的包含子部分！ ``is_multipart()`` 返回 "
"``True`` ， ``walk`` 也深入进这些子部分中。"

#: ../../library/email.compat32-message.rst:718
msgid ""
":class:`Message` objects can also optionally contain two instance "
"attributes, which can be used when generating the plain text of a MIME "
"message."
msgstr ":class:`Message` 对象也可以包含两个可选的实例属性，它们可被用于生成纯文本的 MIME 消息。"

#: ../../library/email.compat32-message.rst:724
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"MIME 文档格式在标头之后的空白行以及第一个多部分的分界字符串之间允许添加一些文本， 通常，此文本在支持 MIME "
"的邮件阅读器中永远不可见，因为它处在标准 MIME 保护范围之外。 但是，当查看消息的原始文本，或当在不支持 MIME "
"的阅读器中查看消息时，此文本会变得可见。"

#: ../../library/email.compat32-message.rst:731
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after"
" the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the "
":class:`~email.generator.Generator` is writing out the plain text "
"representation of a MIME message, and it finds the message has a *preamble* "
"attribute, it will write this text in the area between the headers and the "
"first boundary.  See :mod:`email.parser` and :mod:`email.generator` for "
"details."
msgstr ""
"*preamble* 属性包含 MIME 文档开头部分的这些处于保护范围之外的文本。 当 :class:`~email.parser.Parser` "
"在标头之后及第一个分界字符串之前发现一些文本时，它会将这些文本赋值给消息的 *preamble* 属性。 当 "
":class:`~email.generator.Generator` 写出 MIME 消息的纯文本表示形式时，如果它发现消息具有 *preamble*"
" 属性，它将在标头及第一个分界之间区域写出这些文本。 请参阅 :mod:`email.parser` 和 :mod:`email.generator` "
"了解更多细节。"

#: ../../library/email.compat32-message.rst:741
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr "请注意如果消息对象没有前导文本，则 *preamble* 属性将为 ``None``。"

#: ../../library/email.compat32-message.rst:747
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message."
msgstr "*epilogue* 属性的作用方式与 *preamble* 属性相同，区别在于它包含出现于最后一个分界与消息结尾之间的文本。"

#: ../../library/email.compat32-message.rst:751
msgid ""
"You do not need to set the epilogue to the empty string in order for the "
":class:`~email.generator.Generator` to print a newline at the end of the "
"file."
msgstr ""
"你不需要将 epilogue 设为空字符串以便让 :class:`~email.generator.Generator` 在文件末尾打印一个换行符。"

#: ../../library/email.compat32-message.rst:758
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of"
" the possible parsing defects."
msgstr ""
"*defects* 属性包含在解析消息时发现的所有问题的列表。 请参阅 :mod:`email.errors` 了解可能的解析缺陷的详细描述。"
