# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:55+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/mmap.rst:2
msgid ":mod:`!mmap` --- Memory-mapped file support"
msgstr ":mod:`!mmap` --- 内存映射文件支持"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/mmap.rst:11
msgid ""
"Memory-mapped file objects behave like both :class:`bytearray` and like "
":term:`file objects <file object>`.  You can use mmap objects in most places"
" where :class:`bytearray` are expected; for example, you can use the "
":mod:`re` module to search through a memory-mapped file.  You can also "
"change a single byte by doing ``obj[index] = 97``, or change a subsequence "
"by assigning to a slice: ``obj[i1:i2] = b'...'``.  You can also read and "
"write data starting at the current file position, and :meth:`seek` through "
"the file to different positions."
msgstr ""
"内存映射文件对象的行为既像 :class:`bytearray` 又像 :term:`文件对象 <file object>`。 你可以在大部分接受 "
":class:`bytearray` 的地方使用 mmap 对象；例如，你可以使用 :mod:`re` 模块来搜索一个内存映射文件。 你也可以通过执行 "
"``obj[index] = 97`` 来修改单个字节，或者通过对切片赋值来修改一个子序列: ``obj[i1:i2] = b'...'``。 "
"你还可以在文件的当前位置开始读取和写入数据，并使用 :meth:`seek` 前往另一个位置。"

#: ../../library/mmap.rst:19
msgid ""
"A memory-mapped file is created by the :class:`~mmap.mmap` constructor, "
"which is different on Unix and on Windows.  In either case you must provide "
"a file descriptor for a file opened for update. If you wish to map an "
"existing Python file object, use its :meth:`~io.IOBase.fileno` method to "
"obtain the correct value for the *fileno* parameter.  Otherwise, you can "
"open the file using the :func:`os.open` function, which returns a file "
"descriptor directly (the file still needs to be closed when done)."
msgstr ""
"内存映射文件是由 :class:`~mmap.mmap` 构造器创建的，它在 Unix 和在 Windows 上会有所不同。 "
"无论在哪种情况下你都必须为一个打开用于更新的文件提供文件描述符。 如果你想要映射一个已有的 Python 文件对象，请使用其 "
":meth:`~io.IOBase.fileno` 方法来为 *fileno* 形参获取正确的值。 否则，你可以使用 :func:`os.open` "
"函数来打开这个文件，它会直接返回一个文件描述符（结束时仍然需要关闭该文件）。"

#: ../../library/mmap.rst:28
msgid ""
"If you want to create a memory-mapping for a writable, buffered file, you "
"should :func:`~io.IOBase.flush` the file first.  This is necessary to ensure"
" that local modifications to the buffers are actually available to the "
"mapping."
msgstr ""
"如果要为可写的缓冲文件创建内存映射，则应当首先 :func:`~io.IOBase.flush` 该文件。 这确保了对缓冲区的本地修改在内存映射中可用。"

#: ../../library/mmap.rst:33
msgid ""
"For both the Unix and Windows versions of the constructor, *access* may be "
"specified as an optional keyword parameter. *access* accepts one of four "
"values: :const:`ACCESS_READ`, :const:`ACCESS_WRITE`, or :const:`ACCESS_COPY`"
" to specify read-only, write-through or copy-on-write memory respectively, "
"or :const:`ACCESS_DEFAULT` to defer to *prot*.  *access* can be used on both"
" Unix and Windows.  If *access* is not specified, Windows mmap returns a "
"write-through mapping.  The initial memory values for all three access types"
" are taken from the specified file.  Assignment to an :const:`ACCESS_READ` "
"memory map raises a :exc:`TypeError` exception.  Assignment to an "
":const:`ACCESS_WRITE` memory map affects both memory and the underlying "
"file. Assignment to an :const:`ACCESS_COPY` memory map affects memory but "
"does not update the underlying file."
msgstr ""
"对于 Unix 和 Windows 版本的构造函数，可以将 *access* 指定为可选的关键字参数。 *access* 接受以下四个值之一： "
":const:`ACCESS_READ` ， :const:`ACCESS_WRITE` 或 :const:`ACCESS_COPY` "
"分别指定只读，直写或写时复制内存，或 :const:`ACCESS_DEFAULT` 推迟到 *prot* 。 *access* 可以在 Unix 和 "
"Windows 上使用。如果未指定 *access* ，则 Windows mmap 返回直写映射。这三种访问类型的初始内存值均取自指定的文件。向 "
":const:`ACCESS_READ` 内存映射赋值会引发 :exc:`TypeError` 异常。 向 :const:`ACCESS_WRITE` "
"内存映射赋值会影响内存和底层的文件。 向 :const:`ACCESS_COPY` 内存映射赋值会影响内存，但不会更新底层的文件。"

#: ../../library/mmap.rst:46
msgid "Added :const:`ACCESS_DEFAULT` constant."
msgstr "添加了 :const:`ACCESS_DEFAULT` 常量。"

#: ../../library/mmap.rst:49
msgid ""
"To map anonymous memory, -1 should be passed as the fileno along with the "
"length."
msgstr "要映射匿名内存，应将 -1 作为 fileno 和 length 一起传递。"

#: ../../library/mmap.rst:53
msgid ""
"**(Windows version)** Maps *length* bytes from the file specified by the "
"file handle *fileno*, and creates a mmap object.  If *length* is larger than"
" the current size of the file, the file is extended to contain *length* "
"bytes.  If *length* is ``0``, the maximum length of the map is the current "
"size of the file, except that if the file is empty Windows raises an "
"exception (you cannot create an empty mapping on Windows)."
msgstr ""
"**（ Windows 版本）** 映射被文件句柄 *fileno* 指定的文件的 *length* 个字节，并创建一个 mmap 对象。如果 "
"*length* 大于当前文件大小，则文件将扩展为包含 *length* 个字节。如果 *length* 为 "
"``0``，则映射的最大长度为当前文件大小。如果文件为空， Windows 会引发异常（你无法在Windows上创建空映射）。"

#: ../../library/mmap.rst:60
msgid ""
"*tagname*, if specified and not ``None``, is a string giving a tag name for "
"the mapping.  Windows allows you to have many different mappings against the"
" same file.  If you specify the name of an existing tag, that tag is opened,"
" otherwise a new tag of this name is created.  If this parameter is omitted "
"or ``None``, the mapping is created without a name.  Avoiding the use of the"
" *tagname* parameter will assist in keeping your code portable between Unix "
"and Windows."
msgstr ""
"如果指定了 *tagname* 并且不为 ``None``，则将是一个为映射提供标签名称的字符串。 Windows 允许对同一文件设置许多不同的映射。 "
"如果指定一个现有标签的名称，则将打开该标签，否则将创建一个具有该名称的新标签。 如果此形参被省略或为 ``None``，则创建的映射将不带名称。 "
"避免使用 *tagname* 形参将有助于使你的代码在 Unix 和 Windows 之间可移植。"

#: ../../library/mmap.rst:68
msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0.  *offset* must be a multiple of the "
":const:`ALLOCATIONGRANULARITY`."
msgstr ""
"*offset* 可以被指定为非负整数偏移量。 mmap 引用将相对于从文件开头的偏移。 *offset* 默认为0。 *offeset* 必须是 "
":const:`ALLOCATIONGRANULARITY` 的倍数。"

#: ../../library/mmap.rst:72 ../../library/mmap.rst:174
msgid ""
"Raises an :ref:`auditing event <auditing>` ``mmap.__new__`` with arguments "
"``fileno``, ``length``, ``access``, ``offset``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``mmap.__new__`` 并附带参数 ``fileno``, ``length``, "
"``access``, ``offset``。"

#: ../../library/mmap.rst:78
msgid ""
"**(Unix version)** Maps *length* bytes from the file specified by the file "
"descriptor *fileno*, and returns a mmap object.  If *length* is ``0``, the "
"maximum length of the map will be the current size of the file when "
":class:`~mmap.mmap` is called."
msgstr ""
"**(Unix 版本)** 映射文件描述符 *fileno* 指定的文件的 *length* 个字节，并返回一个 mmap 对象。如果 *length*"
" 为 ``0`` ，则当调用 :class:`~mmap.mmap` 时，映射的最大长度将为文件的当前大小。"

#: ../../library/mmap.rst:83
msgid ""
"*flags* specifies the nature of the mapping. :const:`MAP_PRIVATE` creates a "
"private copy-on-write mapping, so changes to the contents of the mmap object"
" will be private to this process, and :const:`MAP_SHARED` creates a mapping "
"that's shared with all other processes mapping the same areas of the file.  "
"The default value is :const:`MAP_SHARED`. Some systems have additional "
"possible flags with the full list specified in :ref:`MAP_* constants <map-"
"constants>`."
msgstr ""
"*flags* 指明映射的性质。 :const:`MAP_PRIVATE` 会创建私有的写入时拷贝映射，因此对 mmap "
"对象内容的修改将为该进程所私有。 而 :const:`MAP_SHARED` 会创建与其他映射同一文件区域的进程所共享的映射。 默认值为 "
":const:`MAP_SHARED`。 某些系统还具有额外的可用旗标，完整列表会在 :ref:`MAP_* 常量 <map-constants>` "
"中指明。"

#: ../../library/mmap.rst:91
msgid ""
"*prot*, if specified, gives the desired memory protection; the two most "
"useful values are :const:`PROT_READ` and :const:`PROT_WRITE`, to specify "
"that the pages may be read or written.  *prot* defaults to :const:`PROT_READ"
" \\| PROT_WRITE`."
msgstr ""
"如果指明了 *prot*，它将给出所需的内存保护方式；最有用的两个值是 :const:`PROT_READ` 和 "
":const:`PROT_WRITE`，分别指明页面为可读或可写。 *prot* 默认为 :const:`PROT_READ \\| "
"PROT_WRITE`。"

#: ../../library/mmap.rst:96
msgid ""
"*access* may be specified in lieu of *flags* and *prot* as an optional "
"keyword parameter.  It is an error to specify both *flags*, *prot* and "
"*access*.  See the description of *access* above for information on how to "
"use this parameter."
msgstr ""
"可以指定 *access* 作为替代 *flags* 和 *prot* 的可选关键字形参。 同时指定 *flags*, *prot* 和 "
"*access* 将导致错误。 请参阅上文中 *access* 的描述了解有关如何使用此形参的信息。"

#: ../../library/mmap.rst:101
msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0. *offset* must be a multiple of :const:`ALLOCATIONGRANULARITY`"
" which is equal to :const:`PAGESIZE` on Unix systems."
msgstr ""
"*offset* 可以被指定为非负整数偏移量。 mmap 引用将相对于从文件开头的偏移。 *offset* 默认为 0。 *offset* 必须是 "
":const:`ALLOCATIONGRANULARITY` 的倍数，它在 Unix 系统上等价于 :const:`PAGESIZE`。"

#: ../../library/mmap.rst:106
msgid ""
"If *trackfd* is ``False``, the file descriptor specified by *fileno* will "
"not be duplicated, and the resulting :class:`!mmap` object will not be "
"associated with the map's underlying file. This means that the "
":meth:`~mmap.mmap.size` and :meth:`~mmap.mmap.resize` methods will fail. "
"This mode is useful to limit the number of open file descriptors."
msgstr ""
"如果 *trackfd* 为 ``False``，则由 *fileno* 指定的文件描述符将不会被复制，而结果 :class:`!mmap` "
"对象将不会被关联到映射的下层文件。 这意味着 :meth:`~mmap.mmap.size` 和 :meth:`~mmap.mmap.resize` "
"方法将会失败。 此模式适用于限制打开文件描述符的数量。"

#: ../../library/mmap.rst:113
msgid ""
"To ensure validity of the created memory mapping the file specified by the "
"descriptor *fileno* is internally automatically synchronized with the "
"physical backing store on macOS."
msgstr "为了确保已创建内存映射的有效性，描述符 *fileno* 所指定的文件在 macOS 上会与物理后备存储进行内部自动同步。"

#: ../../library/mmap.rst:117
msgid "The *trackfd* parameter was added."
msgstr "增加了 *trackfd* 形参。"

#: ../../library/mmap.rst:120
msgid "This example shows a simple way of using :class:`~mmap.mmap`::"
msgstr "这个例子演示了使用 :class:`~mmap.mmap` 的简单方式::"

#: ../../library/mmap.rst:122
msgid ""
"import mmap\n"
"\n"
"# write a simple example file\n"
"with open(\"hello.txt\", \"wb\") as f:\n"
"    f.write(b\"Hello Python!\\n\")\n"
"\n"
"with open(\"hello.txt\", \"r+b\") as f:\n"
"    # memory-map the file, size 0 means whole file\n"
"    mm = mmap.mmap(f.fileno(), 0)\n"
"    # read content via standard file methods\n"
"    print(mm.readline())  # prints b\"Hello Python!\\n\"\n"
"    # read content via slice notation\n"
"    print(mm[:5])  # prints b\"Hello\"\n"
"    # update content using slice notation;\n"
"    # note that new content must have same size\n"
"    mm[6:] = b\" world!\\n\"\n"
"    # ... and read again using standard file methods\n"
"    mm.seek(0)\n"
"    print(mm.readline())  # prints b\"Hello  world!\\n\"\n"
"    # close the map\n"
"    mm.close()"
msgstr ""
"import mmap\n"
"\n"
"# 写入一个简单的示例文件\n"
"with open(\"hello.txt\", \"wb\") as f:\n"
"    f.write(b\"Hello Python!\\n\")\n"
"\n"
"with open(\"hello.txt\", \"r+b\") as f:\n"
"    # 对文件进行内存映射，大小为 0 表示整个文件\n"
"    mm = mmap.mmap(f.fileno(), 0)\n"
"    # 通过标准文件方法读取内容\n"
"    print(mm.readline())  # prints b\"Hello Python!\\n\"\n"
"    # 通过切片标记方式读取内容\n"
"    print(mm[:5])  # 打印 b\"Hello\"\n"
"    # 使用切片标记方式更新内容；\n"
"    # 请注意新内容必须为相同的大小\n"
"    mm[6:] = b\" world!\\n\"\n"
"    # ... 并使用标准文件方法再次读取\n"
"    mm.seek(0)\n"
"    print(mm.readline())  # prints b\"Hello  world!\\n\"\n"
"    # 关闭映射\n"
"    mm.close()"

#: ../../library/mmap.rst:145
msgid ""
":class:`~mmap.mmap` can also be used as a context manager in a "
":keyword:`with` statement::"
msgstr ":class:`~mmap.mmap` 也可以在 :keyword:`with` 语句中被用作上下文管理器::"

#: ../../library/mmap.rst:148
msgid ""
"import mmap\n"
"\n"
"with mmap.mmap(-1, 13) as mm:\n"
"    mm.write(b\"Hello world!\")"
msgstr ""
"import mmap\n"
"\n"
"with mmap.mmap(-1, 13) as mm:\n"
"    mm.write(b\"Hello world!\")"

#: ../../library/mmap.rst:153
msgid "Context manager support."
msgstr "上下文管理器支持。"

#: ../../library/mmap.rst:157
msgid ""
"The next example demonstrates how to create an anonymous map and exchange "
"data between the parent and child processes::"
msgstr "下面的例子演示了如何创建一个匿名映射并在父进程和子进程之间交换数据。::"

#: ../../library/mmap.rst:160
msgid ""
"import mmap\n"
"import os\n"
"\n"
"mm = mmap.mmap(-1, 13)\n"
"mm.write(b\"Hello world!\")\n"
"\n"
"pid = os.fork()\n"
"\n"
"if pid == 0:  # In a child process\n"
"    mm.seek(0)\n"
"    print(mm.readline())\n"
"\n"
"    mm.close()"
msgstr ""
"import mmap\n"
"import os\n"
"\n"
"mm = mmap.mmap(-1, 13)\n"
"mm.write(b\"Hello world!\")\n"
"\n"
"pid = os.fork()\n"
"\n"
"if pid == 0:  # In a child process\n"
"    mm.seek(0)\n"
"    print(mm.readline())\n"
"\n"
"    mm.close()"

#: ../../library/mmap.rst:176
msgid "Memory-mapped file objects support the following methods:"
msgstr "映射内存的文件对象支持以下方法:"

#: ../../library/mmap.rst:180
msgid ""
"Closes the mmap. Subsequent calls to other methods of the object will result"
" in a ValueError exception being raised. This will not close the open file."
msgstr "关闭 mmap。 后续调用该对象的其他方法将导致引发 ValueError 异常。 此方法将不会关闭打开的文件。"

#: ../../library/mmap.rst:187
msgid "``True`` if the file is closed."
msgstr "如果文件已关闭则返回 ``True``。"

#: ../../library/mmap.rst:194
msgid ""
"Returns the lowest index in the object where the subsequence *sub* is found,"
" such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"返回子序列 *sub* 在对象内被找到的最小索引号，使得 *sub* 被包含在 [*start*, *end*] 范围中。 可选参数 *start* 和"
" *end* 会被解读为切片表示法。 如果未找到则返回 ``-1``。"

#: ../../library/mmap.rst:199 ../../library/mmap.rst:291
#: ../../library/mmap.rst:331
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "现在接受可写的 :term:`字节类对象 <bytes-like object>`。"

#: ../../library/mmap.rst:205
msgid ""
"Flushes changes made to the in-memory copy of a file back to disk. Without "
"use of this call there is no guarantee that changes are written back before "
"the object is destroyed.  If *offset* and *size* are specified, only changes"
" to the given range of bytes will be flushed to disk; otherwise, the whole "
"extent of the mapping is flushed.  *offset* must be a multiple of the "
":const:`PAGESIZE` or :const:`ALLOCATIONGRANULARITY`."
msgstr ""
"将对文件的内存副本的修改刷新至磁盘。 如果不使用此调用则无法保证在对象被销毁前将修改写回存储。 如果指定了 *offset* 和 "
"*size*，则只将对指定范围内字节的修改刷新至磁盘；在其他情况下，映射的全部范围都会被刷新。 *offset* 必须为 "
":const:`PAGESIZE` 或 :const:`ALLOCATIONGRANULARITY` 的倍数。"

#: ../../library/mmap.rst:212
msgid ""
"``None`` is returned to indicate success.  An exception is raised when the "
"call failed."
msgstr "返回 ``None`` 以表示成功。 当调用失败时将引发异常。"

#: ../../library/mmap.rst:215
msgid ""
"Previously, a nonzero value was returned on success; zero was returned on "
"error under Windows.  A zero value was returned on success; an exception was"
" raised on error under Unix."
msgstr ""
"在之前版本中，成功时将返回非零值；在 Windows 下当发生错误时将返回零。 在 Unix 下 成功时将返回零值；当发生错误时将引发异常。"

#: ../../library/mmap.rst:223
msgid ""
"Send advice *option* to the kernel about the memory region beginning at "
"*start* and extending *length* bytes.  *option* must be one of the "
":ref:`MADV_* constants <madvise-constants>` available on the system.  If "
"*start* and *length* are omitted, the entire mapping is spanned.  On some "
"systems (including Linux), *start* must be a multiple of the "
":const:`PAGESIZE`."
msgstr ""
"将有关内存区域的建议 *option* 发送至内核，从 *start* 开始扩展 *length* 个字节。 *option* 必须为系统中可用的 "
":ref:`MADV_* 常量 <madvise-constants>` 之一。 如果省略 *start* 和 *length*，则会包含整个映射。 "
"在某些系统中（包括 Linux），*start* 必须为 :const:`PAGESIZE` 的倍数。"

#: ../../library/mmap.rst:230
msgid "Availability: Systems with the ``madvise()`` system call."
msgstr "可用性: 具有 ``madvise()`` 系统调用的系统。"

#: ../../library/mmap.rst:237
msgid ""
"Copy the *count* bytes starting at offset *src* to the destination index "
"*dest*.  If the mmap was created with :const:`ACCESS_READ`, then calls to "
"move will raise a :exc:`TypeError` exception."
msgstr ""
"将从偏移量 *src* 开始的 *count* 个字节拷贝到目标索引号 *dest*。 如果 mmap 创建时设置了 "
":const:`ACCESS_READ`，则调用 move 将引发 :exc:`TypeError` 异常。"

#: ../../library/mmap.rst:244
msgid ""
"Return a :class:`bytes` containing up to *n* bytes starting from the current"
" file position. If the argument is omitted, ``None`` or negative, return all"
" bytes from the current file position to the end of the mapping. The file "
"position is updated to point after the bytes that were returned."
msgstr ""
"返回一个 :class:`bytes`，其中包含从当前文件位置开始的至多 *n* 个字节。 如果参数省略，为 ``None`` "
"或负数，则返回从当前文件位置开始直至映射结尾的所有字节。 文件位置会被更新为返回字节数据之后的位置。"

#: ../../library/mmap.rst:250
msgid "Argument can be omitted or ``None``."
msgstr "参数可被省略或为 ``None``。"

#: ../../library/mmap.rst:255
msgid ""
"Returns a byte at the current file position as an integer, and advances the "
"file position by 1."
msgstr "将当前文件位置上的一个字节以整数形式返回，并让文件位置前进 1。"

#: ../../library/mmap.rst:261
msgid ""
"Returns a single line, starting at the current file position and up to the "
"next newline. The file position is updated to point after the bytes that "
"were returned."
msgstr "返回一个单独的行，从当前文件位置开始直到下一个换行符。 文件位置会被更新为返回字节数据之后的位置。"

#: ../../library/mmap.rst:268
msgid "Resizes the map and the underlying file, if any."
msgstr "改变映射和下层文件的大小，如果存在的话。"

#: ../../library/mmap.rst:270
msgid ""
"Resizing a map created with *access* of :const:`ACCESS_READ` or "
":const:`ACCESS_COPY`, will raise a :exc:`TypeError` exception. Resizing a "
"map created with *trackfd* set to ``False``, will raise a :exc:`ValueError` "
"exception."
msgstr ""
"改变具有 :const:`ACCESS_READ` 或 :const:`ACCESS_COPY` *访问权限* 的已创建映射的大小，将引发一个 "
":exc:`TypeError` 异常。 改变 *trackfd* 被设为 ``False`` 的已创建映射的大小，将引发一个 "
":exc:`ValueError` 异常。"

#: ../../library/mmap.rst:275
msgid ""
"**On Windows**: Resizing the map will raise an :exc:`OSError` if there are "
"other maps against the same named file. Resizing an anonymous map (ie "
"against the pagefile) will silently create a new map with the original data "
"copied over up to the length of the new size."
msgstr ""
"**在 Windows 上**: 如果存在其他针对相同名称文件的映射则改变映射大小将引发 :exc:`OSError`。 "
"改变匿名映射（即针对分页文件）的大小将静默地创建一个新映射并将原始数据复制到对应新大小的长度。"

#: ../../library/mmap.rst:280
msgid ""
"Correctly fails if attempting to resize when another map is held Allows "
"resize against an anonymous map on Windows"
msgstr "如果在持有另一个映射允许在 Windows 上针对匿名映射改变大小的情况下尝试改变大小则会正确地报告失败"

#: ../../library/mmap.rst:286
msgid ""
"Returns the highest index in the object where the subsequence *sub* is "
"found, such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"返回子序列 *sub* 在对象内被找到的最大索引号，使得 *sub* 被包含在 [*start*, *end*] 范围中。 可选参数 *start* 和"
" *end* 会被解读为切片表示法。 如果未找到则返回 ``-1``。"

#: ../../library/mmap.rst:297
msgid ""
"Set the file's current position.  *whence* argument is optional and defaults"
" to ``os.SEEK_SET`` or ``0`` (absolute file positioning); other values are "
"``os.SEEK_CUR`` or ``1`` (seek relative to the current position) and "
"``os.SEEK_END`` or ``2`` (seek relative to the file's end)."
msgstr ""
"设置文件的当前位置。 *whence* 参数为可选项并且默认为 ``os.SEEK_SET`` 或 ``0`` (绝对文件定位)；其他值还有 "
"``os.SEEK_CUR`` 或 ``1`` (相对当前位置查找) 和 ``os.SEEK_END`` 或 ``2`` (相对文件末尾查找)。"

#: ../../library/mmap.rst:302
msgid "Return the new absolute position instead of ``None``."
msgstr "返回一个新的绝对位置值而非 ``None``。"

#: ../../library/mmap.rst:307
msgid ""
"Return whether the file supports seeking, and the return value is always "
"``True``."
msgstr "返回文件是否支持定位，返回值将始终为 ``True``。"

#: ../../library/mmap.rst:313
msgid ""
"Return the length of the file, which can be larger than the size of the "
"memory-mapped area."
msgstr "返回文件的长度，该数值可以大于内存映射区域的大小。"

#: ../../library/mmap.rst:319
msgid "Returns the current position of the file pointer."
msgstr "返回文件指针的当前位置。"

#: ../../library/mmap.rst:324
msgid ""
"Write the bytes in *bytes* into memory at the current position of the file "
"pointer and return the number of bytes written (never less than "
"``len(bytes)``, since if the write fails, a :exc:`ValueError` will be "
"raised).  The file position is updated to point after the bytes that were "
"written.  If the mmap was created with :const:`ACCESS_READ`, then writing to"
" it will raise a :exc:`TypeError` exception."
msgstr ""
"将 *bytes* 中的字节数据写入文件指针当前位置的内存并返回写入的字节总数 (一定不小于 ``len(bytes)``，因为如果写入失败，将会引发 "
":exc:`ValueError`)。 在字节数据被写入后文件位置将会更新。 如果 mmap 创建时设置了 "
":const:`ACCESS_READ`，则向其写入将引发 :exc:`TypeError` 异常。"

#: ../../library/mmap.rst:334
msgid "The number of bytes written is now returned."
msgstr "现在会返回写入的字节总数。"

#: ../../library/mmap.rst:340
msgid ""
"Write the integer *byte* into memory at the current position of the file "
"pointer; the file position is advanced by ``1``. If the mmap was created "
"with :const:`ACCESS_READ`, then writing to it will raise a :exc:`TypeError` "
"exception."
msgstr ""
"将整数值 *byte* 写入文件指针当前位置的内存；文件位置前进 ``1``。 如果 mmap 创建时设置了 "
":const:`ACCESS_READ`，则向其写入将引发 :exc:`TypeError` 异常。"

#: ../../library/mmap.rst:348
msgid "MADV_* Constants"
msgstr "MADV_* 常量"

#: ../../library/mmap.rst:375
msgid ""
"These options can be passed to :meth:`mmap.madvise`.  Not every option will "
"be present on every system."
msgstr "这些选项可被传给 :meth:`mmap.madvise`。 不是每个选项都存在于每个系统中。"

#: ../../library/mmap.rst:378
msgid "Availability: Systems with the madvise() system call."
msgstr "可用性: 具有 madvise() 系统调用的系统。"

#: ../../library/mmap.rst:385
msgid "MAP_* Constants"
msgstr "MAP_* 常量"

#: ../../library/mmap.rst:409
msgid ""
"These are the various flags that can be passed to :meth:`mmap.mmap`.  "
":data:`MAP_ALIGNED_SUPER` is only available at FreeBSD and "
":data:`MAP_CONCEAL` is only available at OpenBSD.  Note that some options "
"might not be present on some systems."
msgstr ""
"以下是可被传给 :meth:`mmap.mmap` 的各种旗标。  :data:`MAP_ALIGNED_SUPER` 仅在 FreeBSD 上可用而 "
":data:`MAP_CONCEAL` 仅在 OpenBSD 上可用。 请注意某些选项在某些系统上可能不存在。"

#: ../../library/mmap.rst:413
msgid "Added :data:`MAP_POPULATE` constant."
msgstr "增加了 :data:`MAP_POPULATE` 常量。"

#: ../../library/mmap.rst:416
msgid "Added :data:`MAP_STACK` constant."
msgstr "增加了 :data:`MAP_STACK` 常量。"

#: ../../library/mmap.rst:419
msgid "Added :data:`MAP_ALIGNED_SUPER` and :data:`MAP_CONCEAL` constants."
msgstr "增加了 :data:`MAP_ALIGNED_SUPER` 和 :data:`MAP_CONCEAL` 常量。"

#: ../../library/mmap.rst:422
msgid ""
"Added :data:`MAP_32BIT`, :data:`MAP_HASSEMAPHORE`, :data:`MAP_JIT`, "
":data:`MAP_NOCACHE`, :data:`MAP_NOEXTEND`, :data:`MAP_NORESERVE`, "
":data:`MAP_RESILIENT_CODESIGN`, :data:`MAP_RESILIENT_MEDIA`, "
":data:`MAP_TPRO`, :data:`MAP_TRANSLATED_ALLOW_EXECUTE`, and "
":data:`MAP_UNIX03` constants."
msgstr ""
"增加了 :data:`MAP_32BIT`, :data:`MAP_HASSEMAPHORE`, :data:`MAP_JIT`, "
":data:`MAP_NOCACHE`, :data:`MAP_NOEXTEND`, :data:`MAP_NORESERVE`, "
":data:`MAP_RESILIENT_CODESIGN`, :data:`MAP_RESILIENT_MEDIA`, "
":data:`MAP_TPRO`, :data:`MAP_TRANSLATED_ALLOW_EXECUTE` 和 :data:`MAP_UNIX03` "
"等常量。"
