# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.mock-examples.rst:2
msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`!unittest.mock` --- 新手入门"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "使用 mock"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "模拟方法调用"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr "使用 :class:`Mock` 的常见场景："

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "模拟函数调用"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "记录在对象上的方法调用"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr "你可能需要替换一个对象上的方法，用于确认此方法被系统中的其他部分调用过，并且调用时使用了正确的参数。"

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods"
" and attributes that allow you to make assertions about how it has been "
"used."
msgstr "使用了 mock (本例中的 ``real.method``) 之后，它有方法和属性可以让你针对它是被如何使用的下断言。"

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes"
" a sensible one to use by default."
msgstr ""
"在多数示例中，:class:`Mock` 与 :class:`MagicMock` 两个类可以相互替换，而 ``MagicMock`` "
"是一个更适用的类，通常情况下，使用它就可以了。"

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"如果 mock 被调用，它的 :attr:`~Mock.called` 属性就会变成 ``True``，更重要的是，我们可以使用 "
":meth:`~Mock.assert_called_with` 或者 :meth:`~Mock.assert_called_once_with` "
"方法来确认它在被调用时使用了正确的参数。"

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr "在如下的测试示例中，验证对于 ``ProductionClass().method`` 的调用会导致 ``something`` 的调用。"

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "对象上的方法调用的 mock"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a"
" method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"上一个例子中我们直接在对象上给方法打补丁以检查它是否被正确地调用。 "
"另一个常见的用例是将一个对象传给一个方法（或被测试系统的某个部分）然后检查它是否以正确的方式被使用。"

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"下面这个简单的 ``ProductionClass`` 具有一个 ``closer`` 方法。 如果它附带一个对象被调用那么它就会调用其中的 "
"``close``。"

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check"
" that it was called correctly."
msgstr "所以为了测试它我们需要传入一个带有 ``close`` 方法的对象并检查它是否被正确地调用。"

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but "
":meth:`~Mock.assert_called_with` will raise a failure exception."
msgstr ""
"我们不需要做任何事来在我们的 mock 上提供 'close' 方法。 访问 close 的操作就会创建它。 因此，如果 'close' "
"还未被调用那么在测试时访问它就将创建它，但是 :meth:`~Mock.assert_called_with` 则会引发一个失败的异常。"

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "模拟类"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"一个常见的用例是模拟被测试的代码所实例化的类。 当你给一个类打上补丁，该类就会被替换为一个 mock。 实例是通过 *调用该类* 来创建的。 "
"这意味着你要通过查看被模拟类的返回值来访问“mock 实例”。"

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the"
" mock, so it is configured by modifying the mock :attr:`~Mock.return_value`."
" ::"
msgstr ""
"在下面的例子中我们有一个函数 ``some_function`` 实例化了 ``Foo`` 并调用该实例中的一个方法。 对 :func:`patch` "
"的调用会将类 ``Foo`` 替换为一个 mock。 ``Foo`` 实例是调用该 mock 的结果，所以它是通过修改 "
":attr:`~Mock.return_value` 来配置的。 ::"

#: ../../library/unittest.mock-examples.rst:118
msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "命名你的 mock"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of"
" the mock and can be helpful when the mock appears in test failure messages."
" The name is also propagated to attributes or methods of the mock:"
msgstr ""
"给你的 mock 起个名字可能会很有用。 名字会显示在 mock 的 repr 中并在 mock 出现于测试失败消息中时可以帮助理解。 "
"这个名字也会被传播给 mock 的属性或方法:"

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "追踪所有的调用"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The "
":attr:`~Mock.mock_calls` attribute records all calls to child attributes of "
"the mock - and also to their children."
msgstr ""
"通常你会想要追踪对某个方法的多次调用。 :attr:`~Mock.mock_calls` 属性记录了所有对 mock 的子属性的调用 —— "
"并且还包括对它们的子属性的调用。"

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional "
"calls:"
msgstr ""
"如果你做了一个有关 ``mock_calls`` 的断言并且有任何非预期的方法被调用，则断言将失败。 "
"这很有用处，因为除了断言你所预期的调用已被执行，你还会检查它们是否以正确的顺序被执行并且没有额外的调用:"

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr "你使用 :data:`call` 对象来构造列表以便与 ``mock_calls`` 进行比较:"

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which means"
" it is not possible to track nested calls where the parameters used to "
"create ancestors are important:"
msgstr "然而，返回 mock 的调用的形参不会被记录，这意味着不可能追踪附带了重要形参的创建上级对象的嵌套调用:"

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "设置返回值和属性"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "在 mock 对象上设置返回值是非常容易的:"

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "当然你也可以对 mock 上的方法做同样的操作:"

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "返回值也可以在构造器中设置:"

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "如果你需要在你的 mock 上设置一个属性，只需这样做:"

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"有时你会想要模拟更复杂的情况，例如这个例子 ``mock.connection.cursor().execute(\"SELECT 1\")``。 "
"如果我们希望这个调用返回一个列表，那么我们还必须配置嵌套调用的结果。"

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr "我们可以像这样使用 :data:`call` 在一个“链式调用”中构造调用集合以便随后方便地设置断言:"

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of"
" calls representing the chained calls."
msgstr "对 ``.call_list()`` 的调用会将我们的调用对象转成一个代表链式调用的调用列表。"

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "通过 mock 引发异常"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"一个很有用的属性是 :attr:`~Mock.side_effect`。 如果你将该属性设为一个异常类或者实例那么当 mock "
"被调用时该异常将会被引发。"

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "附带影响函数和可迭代对象"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` 也可以被设为一个函数或可迭代对象。 ``side_effect`` 作为可迭代对象的应用场景适用于你的 mock "
"将要被多次调用，并且你希望每次调用都返回不同的值的情况。 当你将 ``side_effect`` 设为一个可迭代对象时每次对 mock "
"的调用将返回可迭代对象的下一个值。"

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"对于更高级的用例，例如根据 mock 调用时附带的参数动态改变返回值，``side_effect`` 可以指定一个函数。 该函数将附带与 mock "
"相同的参数被调用。 该函数所返回的就是调用所返回的对象:"

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "模拟异步迭代器"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock "
":ref:`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value`"
" attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"从 Python 3.8 起，``AsyncMock`` 和 ``MagicMock`` 支持通过 ``__aiter__`` 来模拟 "
":ref:`async-iterators`。 ``__aiter__`` 的 :attr:`~Mock.return_value` "
"属性可以被用来设置要用于迭代的返回值。"

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "模拟异步上下文管理器"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock "
":ref:`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"从 Python 3.8 起，``AsyncMock`` 和 ``MagicMock`` 支持通过 ``__aenter__`` 和 "
"``__aexit__`` 来模拟 :ref:`async-context-managers`。 在默认情况下，``__aenter__`` 和 "
"``__aexit__`` 将为返回异步函数的 ``AsyncMock`` 实例。"

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "基于现有对象创建模拟对象"

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later"
" you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"使用模拟操作的一个问题是它会将你的测试与你的 mock 实现相关联而不是与你的真实代码相关联。 假设你有一个实现了 ``some_method`` "
"的类。 在对另一个类的测试中，你提供了一个 *同样* 提供了 ``some_method`` 的模拟该对象的 mock 对象。 "
"如果后来你重构了第一个类，使得它不再具有 ``some_method`` —— 那么你的测试将继续保持通过，尽管现在你的代码已经被破坏了！"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately"
" without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` 允许你使用allows you to provide an object as a specification for "
"the mock, using the *spec* 关键字参数来提供一个对象作为 mock 的规格说明。 在 mock "
"上访问不存在于你的规格说明对象中的方法 / 属性将立即引发一个属性错误。 "
"如果你修改你的规格说明的实现，，那么使用了该类的测试将立即开始失败而不需要你在这些测试中实例化该类。"

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr "使用规格说明还可以启用对 mock 的调用的更聪明的匹配操作，无论是否有将某些形参作为位置或关键字参数传入::"

#: ../../library/unittest.mock-examples.rst:348
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"如果你想要让这些更聪明的匹配操作也适用于 mock 上的方法调用，你可以使用 :ref:`auto-speccing <auto-speccing>`。"

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr "如果你想要更强形式的规格说明以防止设置任意属性并获取它们那么你可以使用 *spec_set* 来代替 *spec*。"

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr "使用 side_effect 返回每个文件的内容"

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. "
":attr:`~Mock.side_effect` can be used to return a new Mock object per call. "
"This can be used to return different contents per file stored in a "
"dictionary::"
msgstr ""
":func:`mock_open` 被用来为 :func:`open` 方法打补丁。 :attr:`~Mock.side_effect` "
"可被用来在每次调用中返回一个新的 Mock 对象。 这可被用来返回存储在字典中的每个文件的不同内容::"

#: ../../library/unittest.mock-examples.rst:370
msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "补丁装饰器"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"在查找对象的名称空间中修补对象使用 :func:`patch` 。使用起来很简单，阅读 :ref:`在哪里打补丁 <where-to-patch>` "
"来快速上手。"

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other"
" tests and cause hard to diagnose problems."
msgstr ""
"测试中的一个常见需求是为类属性或模块属性打补丁，例如修补内置对象或修补某个模块中的类来测试其是否被实例化。 "
"模块和类都可算是全局对象，因此对它们打补丁的操作必须在测试完成之后被还原否则补丁将持续影响其他测试并导致难以诊断的问题。"

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, "
":func:`patch.object` and :func:`patch.dict`. ``patch`` takes a single "
"string, of the form ``package.module.Class.attribute`` to specify the "
"attribute you are patching. It also optionally takes a value that you want "
"the attribute (or class or whatever) to be replaced with. 'patch.object' "
"takes an object and the name of the attribute you would like patched, plus "
"optionally the value to patch it with."
msgstr ""
"为此 mock 提供了三个便捷的装饰器: :func:`patch`, :func:`patch.object` 和 "
":func:`patch.dict`。 ``patch`` 接受单个字符串，其形式 ``package.module.Class.attribute``"
" 指明你要修补的属性。 它还可选择接受一个值用来替换指定的属性（或者类对象等等）。 'patch.object' "
"接受一个对象和你想要修补的属性名称，并可选择接受要用作补丁的值。"

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``::"

#: ../../library/unittest.mock-examples.rst:414
msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use "
":func:`patch` instead of :func:`patch.object`:"
msgstr ""
"如果你要给一个模块 (包括 :mod:`builtins`) 打补丁则可使用 :func:`patch` 来代替 "
":func:`patch.object`:"

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr "如有必要模块名可以是“带点号”的，其形式如 ``package.module``::"

#: ../../library/unittest.mock-examples.rst:441
msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "一个良好的模式是实际地装饰测试方法本身:"

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"如果你想要通过 Mock 来打补丁，你可以只附带一个参数使用 :func:`patch` (或附带两个参数使用 "
":func:`patch.object`)。 这将为你创建 mock 并传递给测试函数 / 方法:"

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "你可以使用以下模式来堆叠多个补丁装饰器::"

#: ../../library/unittest.mock-examples.rst:473
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"当你嵌套 patch 装饰器时将以它们被应用的相同顺序（即 *Python* 应用装饰器的正常顺序）将 mock 传入被装饰的函数。 "
"也就是说从下往上，因此在上面的示例中 ``test_module.ClassName2`` 的 mock 会被最先传入。"

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr "还有一个 :func:`patch.dict` 用于在一定范围内设置字典中的值，并在测试结束时将字典恢复为其原始状态："

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr "``patch``, ``patch.object`` 和 ``patch.dict`` 都可被用作上下文管理器。"

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr "在你使用 :func:`patch` 为你创建 mock 时，你可以使用 with 语句的 \"as\" 形式来获得对 mock 的引用:"

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used"
" as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"作为替代 ``patch``, ``patch.object`` 和 ``patch.dict`` 可以被用作类装饰器。 "
"当以此方式使用时其效果与将装饰器单独应用到每个以 \"test\" 打头的方法上相同。"

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "更多示例"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "下面是一些针对更为高级应用场景的补充示例。"

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "模拟链式调用"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"实际上一旦你理解了 :attr:`~Mock.return_value` 属性那么使用 mock 模拟链式调用就会相当直观。 当一个 mock "
"首次被调用，或者当你在它被调用前获取其 ``return_value`` 时，将会创建一个新的 :class:`Mock`。"

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr "这意味着你可以通过检视 ``return_value`` mock 来了解从调用被模拟对象返回的对象是如何被使用的:"

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr "从这里开始只需一个步骤即可配置并创建有关链式调用的断言。 当然还有另一种选择是首先以更易于测试的方式来编写你的代码..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "因此，如果我们有这样一些代码:"

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"假定 ``BackendProvider`` 已经过良好测试，我们要如何测试 ``method()``？ 特别地，我们希望测试代码段 ``# more "
"code`` 是否以正确的方式使用了响应对象。"

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"由于这个链式调用来自一个实例属性我们可以对 ``backend`` 属性在 ``Something`` 实例上进行猴子式修补。 "
"在这个特定情况下我们只对最后调用 ``start_call`` 的返回值感兴趣所以我们不需要进行太多的配置。 "
"让我们假定它返回的是“文件类”对象，因此我们将确保我们的响应对象使用内置的 :func:`open` 作为其 ``spec``。"

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"为了做到这一点我们创建一个 mock 实例作为我们的 mock 后端并为它创建一个 mock 响应对象。 要将该响应对象设为最后的 "
"``start_call`` 的返回值我们可以这样做::"

#: ../../library/unittest.mock-examples.rst:573
msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call.return_value"
" = mock_response"
msgstr ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call.return_value"
" = mock_response"

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the "
":meth:`~Mock.configure_mock` method to directly set the return value for "
"us::"
msgstr "我们可以通过更好一些的方式做到这一点，即使用 :meth:`~Mock.configure_mock` 方法直接为我们设置返回值::"

#: ../../library/unittest.mock-examples.rst:578
msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call.return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call.return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr "有了这些我们就能准备好给“mock 后端”打上猴子补丁并可以执行真正的调用::"

#: ../../library/unittest.mock-examples.rst:587
msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""
">>> something.backend = mock_backend\n"
">>> something.method()"

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"使用 :attr:`~Mock.mock_calls` 我们可以通过一个断言来检查链式调用。 一个链式调用就是在一行代码中连续执行多个调用，所以在 "
"``mock_calls`` 中将会有多个条目。 我们可以使用 :meth:`call.call_list` 来为我们创建这个调用列表::"

#: ../../library/unittest.mock-examples.rst:595
msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs').start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs').start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "部分模拟"

#: ../../library/unittest.mock-examples.rst:603
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static "
":meth:`datetime.date.today` method."
msgstr ""
"在一些测试中，我想把对 :meth:`datetime.date.today` "
"的调用模拟为返回一个已知日期的调用，但又不想阻止测试中的代码创建新的日期对象。 然而 :class:`datetime.date` 是用 C "
"语言编写的，因此我不能简单地给静态的 :meth:`datetime.date.today` 方法打上猴子补丁。"

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr "我找到了实现这一点的简单方式即通过一个 mock 来实际包装日期类，但通过对构造器的调用传递给真实的类（并返回真实的实例）。"

#: ../../library/unittest.mock-examples.rst:612
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and"
" returned by ``side_effect``. ::"
msgstr ""
"这里使用 :func:`patch 装饰器 <patch>` 来模拟被测试模块中的 ``date`` 类。 然后将模拟 date 类的 "
":attr:`~Mock.side_effect` 属性设为一个返回真实日期的 lambda 函数。 当模拟 date 类被调用时，将通过 "
"``side_effect`` 构造并返回一个真实日期。 ::"

#: ../../library/unittest.mock-examples.rst:618
msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"请注意我们没有在全局范围上修补 :class:`datetime.date`，我们只是在 *使用* 它的模块中给 ``date`` 打补丁。 参见 "
":ref:`补丁的位置 <where-to-patch>`。"

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"当 ``date.today()`` 被调用时将返回一个已知的日期，但对 ``date(...)`` 构造器的调用仍会返回普通的日期。 "
"如果不是这样你会发现你必须使用与被测试的代码完全相同的算法来计算出预期的结果，这是测试工作中的一个经典的反模式。"

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"对 date 构造器的调用会被记录在 ``mock_date`` 属性中 (``call_count`` 等)，它们也可能对你的测试有用处。"

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"有关处理模块日期或其他内置类的一种替代方式的讨论请参见 `这篇博客文章 <https://williambert.online/2011/07/how-"
"to-unit-testing-in-django-with-mocking-and-patching/>`_。"

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "模拟生成器方法"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr "Python 生成器是指在被迭代时使用 :keyword:`yield` 语句来返回一系列值的函数或方法 [#]_。"

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a "
":class:`MagicMock`."
msgstr ""
"调用生成器方法 / 函数将返回生成器对象。 生成器对象随后会被迭代。 迭代操作对应的协议方法是 "
":meth:`~container.__iter__`，因此我们可以使用 :class:`MagicMock` 来模拟它。"

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "以下是一个使用 \"iter\" 方法模拟为生成器的示例类:"

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "我们要如何模拟这个类，特别是它的 \"iter\" 方法呢？"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call to"
" :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"为了配置从迭代操作（隐含在对 :class:`list` 的调用中）返回的值，我们需要配置调用 ``foo.iter()`` 所返回的对象。"

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses "
"<http://www.dabeaz.com/coroutines/index.html>`_ of generators, but we aren't"
" concerned about them here. A very good introduction to generators and how "
"powerful they are is: `Generator Tricks for Systems Programmers "
"<http://www.dabeaz.com/generators/>`_."
msgstr ""
"此外还有生成器表达式和更多的生成器 `进阶用法 "
"<http://www.dabeaz.com/coroutines/index.html>`_，但在这里我们不去关心它们。 "
"有关生成器及其强大功能的一个很好的介绍请参阅: `针对系统程序员的生成器妙招 "
"<http://www.dabeaz.com/generators/>`_。"

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "对每个测试方法应用相同的补丁"

#: ../../library/unittest.mock-examples.rst:685
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"如果你想要为多个测试方法准备好多个补丁那么最简单的方式就是将 patch 装饰器应用到每个方法上。 这在感觉上像上不必要的重复。 对此，你可以使用 "
":func:`patch` (包括基各种不同形式) 作为类装饰器。 这将把补丁应用于类上的所有测试方法。 测试方法是通过以 ``test`` "
"打头的名称来标识的::"

#: ../../library/unittest.mock-examples.rst:692
msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"另一种管理补丁的方式是使用 :ref:`start-and-stop`。 它允许你将打补丁操作移至你的 ``setUp`` 和 ``tearDown``"
" 方法中。 ::"

#: ../../library/unittest.mock-examples.rst:713
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by"
" calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. "
":meth:`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你要使用这个技巧则你必须通过调用 ``stop`` 来确保补丁被“恢复”。 这可能要比你想像的更麻烦，因为如果在 setUp 中引发了异常那么 "
"tearDown 将不会被调用。 :meth:`unittest.TestCase.addCleanup` 可以做到更方便::"

#: ../../library/unittest.mock-examples.rst:731
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "模拟未绑定方法"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so"
" it doesn't get self passed in. The workaround is to patch the unbound "
"method with a real function instead. The :func:`patch` decorator makes it so"
" simple to patch out methods with a mock that having to create a real "
"function becomes a nuisance."
msgstr ""
"当前在编写测试时我需要修补一个 *未绑定方法* (在类上而不是在实例上为方法打补丁)。 我需要将 self "
"作为第一个参数传入因为我想对哪些对象在调用这个特定方法进行断言。 问题是这里你不能用 mock 来打补丁，因为如果你用 mock "
"来替换一个未绑定方法那么当从实例中获取时它就不会成为一个已绑定方法，因而它不会获得传入的 self。 "
"绕过此问题的办法是改用一个真正的函数来修补未绑定方法。 :func:`patch` 装饰器让使用 mock "
"来给方法打补丁变得如此简单以至于创建一个真正的函数成为一件麻烦事。"

#: ../../library/unittest.mock-examples.rst:757
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"如果将 ``autospec=True`` 传给 patch 那么它就会用一个 *真正的* 函数对象来打补丁。 "
"这个函数对象具有与它所替换的函数相同的签名，但会在内部将操作委托给一个 mock。 你仍然可以通过与以前完全相同的方式来自动创建你的 mock。 "
"但是这将意味着一件事，就是如果你用它来修补一个类上的非绑定方法那么如果它是从一个实例中获取则被模拟的函数将被转为已绑定方法。 传给它的第一个参数将为 "
"``self``，而这真是我想要的:"

#: ../../library/unittest.mock-examples.rst:778
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"如果我们不使用 ``autospec=True`` 那么这个未绑定方法会改为通过一个 Mock 补丁来修补，而不是附带 ``self`` 来调用。"

#: ../../library/unittest.mock-examples.rst:783
msgid "Checking multiple calls with mock"
msgstr "通过 mock 检查多次调用"

#: ../../library/unittest.mock-examples.rst:785
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr "mock 有一个很好的 API 用于针对你的 mock 对象如何被使用来下断言。"

#: ../../library/unittest.mock-examples.rst:792
msgid ""
"If your mock is only being called once you can use the "
":meth:`~Mock.assert_called_once_with` method that also asserts that the "
":attr:`~Mock.call_count` is one."
msgstr ""
"如果你的 mock 只会被调用一次那么你可以使用 :meth:`~Mock.assert_called_once_with` 方法，该方法也会断言 "
":attr:`~Mock.call_count` 的值为一。"

#: ../../library/unittest.mock-examples.rst:803
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use "
":attr:`~Mock.call_args_list`:"
msgstr ""
"``assert_called_with`` 和 ``assert_called_once_with`` 都是有关 *最近* 调用的断言。 如果你的 "
"mock 将被多次调用，并且你想要针对 *所有* 这些调用下断言你可以使用 :attr:`~Mock.call_args_list`:"

#: ../../library/unittest.mock-examples.rst:815
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"使用 :data:`call` 辅助对象可以方便地针对这些调用下断言。 你可以创建一个预期调用的列表并将其与 ``call_args_list`` "
"比较。 这看起来与 ``call_args_list`` 的 repr 非常相似:"

#: ../../library/unittest.mock-examples.rst:825
msgid "Coping with mutable arguments"
msgstr "处理可变参数"

#: ../../library/unittest.mock-examples.rst:827
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were"
" when the mock was called."
msgstr ""
"另一种很少见，但可能给你带来麻烦的情况会在你的 mock 附带可变参数被调用的时候发生。 ``call_args`` 和 "
"``call_args_list`` 将保存对这些参数的 *引用*。 如果这些参数被受测试的代码所改变那么你将无法再针对当该 mock "
"被调用时附带的参数值下断言。"

#: ../../library/unittest.mock-examples.rst:832
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr "下面是一些演示此问题的示例代码。 设想在 'mymodule' 中定义了下列函数::"

#: ../../library/unittest.mock-examples.rst:835
msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"先执行 frob 然后清空 val\"\n"
"    frob(val)\n"
"    val.clear()"

#: ../../library/unittest.mock-examples.rst:843
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr "当我们想要测试 ``grob`` 调用 ``frob`` 并附带了正确的参数时将可看到发生了什么::"

#: ../../library/unittest.mock-examples.rst:846
msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"

#: ../../library/unittest.mock-examples.rst:858
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr "对于 mock 的一个可能性是复制你传入的参数。 如果你创建依赖于对象标识号相等性的断言那么这可能会在后面导致问题。"

#: ../../library/unittest.mock-examples.rst:862
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"下面是一个使用 :attr:`~Mock.side_effect` 功能的解决方案。 如果你为 mock 提供了 ``side_effect`` "
"函数那么 ``side_effect`` 将附带与该 mock 相同的参数被调用。 这样我们就有机会拷贝这些参数并将其保存起来用于之后执行断言。 "
"在本例中我使用了 *另一个* mock 来保存参数以便可以使用该 mock 的方法来执行断言。 在这里辅助函数再次为我设置好了这一切。 ::"

#: ../../library/unittest.mock-examples.rst:870
msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"

#: ../../library/unittest.mock-examples.rst:891
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a"
" new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"调用 ``copy_call_args`` 时会传入将被调用的 mock。 它将返回一个新的 mock 供我们进行断言。 ``side_effect``"
" 函数会拷贝这些参数并附带该副本来调用我们的 ``new_mock``。"

#: ../../library/unittest.mock-examples.rst:897
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"如果你的 mock 只会被使用一次那么有更容易的方式可以在它们被调用时检查参数。 你可以简单地在 ``side_effect`` 函数中执行检查。"

#: ../../library/unittest.mock-examples.rst:911
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or "
":class:`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. "
"Here's an example implementation:"
msgstr ""
"一个替代方式是创建一个 :class:`Mock` 或 :class:`MagicMock`  的子类来拷贝 (使用 "
":func:`copy.deepcopy`) 参数。 下面是一个示例实现:"

#: ../../library/unittest.mock-examples.rst:935
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"当你子类化 ``Mock`` 或 ``MagicMock`` 时所有动态创建的属性以及 ``return_value`` 都将自动使用你的子类。 "
"这意味着 ``CopyingMock`` 的所有子类也都将为 ``CopyingMock`` 类型。"

#: ../../library/unittest.mock-examples.rst:941
msgid "Nesting Patches"
msgstr "嵌套补丁"

#: ../../library/unittest.mock-examples.rst:943
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you"
" can end up with nested with statements indenting further and further to the"
" right::"
msgstr "使用 patch 作为上下文管理器很不错，但是如果你要执行多个补丁你将不断嵌套 with 语句使得代码越来越深地向右缩进::"

#: ../../library/unittest.mock-examples.rst:947
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:961
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"使用 unittest ``cleanup`` 函数和 :ref:`start-and-stop` 我们可以达成同样的效果而无须嵌套缩进。 "
"一个简单的辅助方法 ``create_patch`` 会为我们执行打补丁操作并返回所创建的 mock::"

#: ../../library/unittest.mock-examples.rst:966
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:989
msgid "Mocking a dictionary with MagicMock"
msgstr "使用 MagicMock 模拟字典"

#: ../../library/unittest.mock-examples.rst:991
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr "你可能会想要模拟一个字典或其他容器对象，记录所有对它的访问并让它的行为仍然像是一个字典。"

#: ../../library/unittest.mock-examples.rst:994
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary,"
" and using :data:`~Mock.side_effect` to delegate dictionary access to a real"
" underlying dictionary that is under our control."
msgstr ""
"要做到这点我们可以用 :class:`MagicMock`，它的行为类似于字典，并会使用 :data:`~Mock.side_effect` "
"将字典访问委托给下层的在我们控制之下的一个真正的字典。"

#: ../../library/unittest.mock-examples.rst:998
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods"
" of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"当我们的 ``MagicMock`` 的 :meth:`~object.__getitem__` 和 "
":meth:`~object.__setitem__` 方法被调用（即正常的字典访问操作）时 ``side_effect`` 将附带相应的键（对于 "
"``__setitem__`` 还将附带值）被调用。 我们还可以控制返回的内容。"

#: ../../library/unittest.mock-examples.rst:1003
msgid ""
"After the ``MagicMock`` has been used we can use attributes like "
":data:`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"在 ``MagicMock`` 被使用之后我们可以使用 :data:`~Mock.call_args_list` "
"等属性来针对该字典是如何被使用的下断言。"

#: ../../library/unittest.mock-examples.rst:1019
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr "``MagicMock`` 的一个可用替代是使用 ``Mock`` 并 *仅仅* 提供你明确需要的魔术方法:"

#: ../../library/unittest.mock-examples.rst:1026
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"*第三个* 选项是使用 ``MagicMock`` 但传入 ``dict`` 作为 *spec* (或 *spec_set*) 参数以使得所创建的 "
"``MagicMock`` 只有字典魔术方法是可用的:"

#: ../../library/unittest.mock-examples.rst:1034
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError`"
" if you try to access a key that doesn't exist."
msgstr ""
"通过提供这些附带影响函数，``mock`` 的行为将类似于普通字典但又会记录所有访问。 如果你尝试访问一个不存在的键它甚至会引发 "
":exc:`KeyError`。"

#: ../../library/unittest.mock-examples.rst:1053
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr "在它被使用之后你可以使用普通的 mock 方法和属性进行有关访问操作的断言:"

#: ../../library/unittest.mock-examples.rst:1065
msgid "Mock subclasses and their attributes"
msgstr "模拟子类及其属性"

#: ../../library/unittest.mock-examples.rst:1067
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr "你可能出于各种原因想要子类化 :class:`Mock`。 其中一个可能的原因是为了添加辅助方法。 下面是一个笨兮兮的示例:"

#: ../../library/unittest.mock-examples.rst:1083
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"The standard behaviour for ``Mock`` 实例的标准行为是属性和返回值 mock 具有与它们所访问的 mock "
"相同的类型。 这将确保 ``Mock`` 的属性均为 ``Mocks`` 而 ``MagicMock`` 的属性均为 ``MagicMocks`` "
"[#]_。 因此如果你通过子类化来添加辅助方法那么它们也将在你的子类的实例的属性和返回值 mock 上可用。"

#: ../../library/unittest.mock-examples.rst:1099
msgid ""
"Sometimes this is inconvenient. For example, `one user "
"<https://code.google.com/archive/p/mock/issues/105>`_ is subclassing mock to"
" created a `Twisted adaptor "
"<https://twisted.org/documents/11.0.0/api/twisted.python.components.html>`_."
" Having this applied to attributes too actually causes errors."
msgstr ""
"有时这很不方便。 例如，`一位用户 <https://code.google.com/archive/p/mock/issues/105>`_ 子类化了"
" mock 来创建一个 `Twisted 适配器 "
"<https://twisted.org/documents/11.0.0/api/twisted.python.components.html>`_。"
" 将它也应用于属性实际上会导致出错。"

#: ../../library/unittest.mock-examples.rst:1105
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent"
" your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (它的所有形式) 使用一个名为 ``_get_child_mock`` 的方法来创建这些用于属性和返回值的“子 mock”。 "
"你可以通过重写此方法来防止你的子类被用于属性。 其签名被设为接受任意关键字参数 (``**kwargs``) 并且它们会被传递给 mock 构造器:"

#: ../../library/unittest.mock-examples.rst:1122
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable"
" methods."
msgstr "此规则的一个例外涉及不可调用 mock。 属性会使用可调用对象版本是因为如非如此则不可调用 mock 将无法拥有可调用的方法。"

#: ../../library/unittest.mock-examples.rst:1128
msgid "Mocking imports with patch.dict"
msgstr "通过 patch.dict 模拟导入"

#: ../../library/unittest.mock-examples.rst:1130
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr "有一种会令模拟变困难的情况是当你在函数内部有局部导入。 这更难模拟的原因是它们不是使用来自我们能打补丁的模拟命名空间中的对象。"

#: ../../library/unittest.mock-examples.rst:1134
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"一般来说局部导入是应当避免的。 局部导入有时是为了防止循环依赖，而这个问题 *通常* 都有更好的解决办法（重构代码）或者通过延迟导入来防止“前期成本”。"
" 这也可以通过比无条件地局部导入更好的方式来解决（将模块保存为一个类或模块属性并且只在首次使用时执行导入）。"

#: ../../library/unittest.mock-examples.rst:1141
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"除此之外还有一个办法可以使用 ``mock`` 来影响导入的结果。 导入操作会从 :data:`sys.modules` 字典提取一个 *对象*。 "
"请注意是提取一个 *对象*，它不是必须为模块。 首次导入一个模块将使一个模块对象被放入 "
"``sys.modules``，因此通常当你执行导入时你将得到一个模块。 但是并非必然如此。"

#: ../../library/unittest.mock-examples.rst:1148
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"这意味着你可以使用 :func:`patch.dict` 来 *临时性地* 将一个 mock 放入 :data:`sys.modules`。 "
"在补丁激活期间的任何导入操作都将得到该 mock。 当补丁完成时（被装饰的函数退出，with 语句代码块结束或者 ``patcher.stop()`` "
"被调用）则之前存在的任何东西都将被安全地恢复。"

#: ../../library/unittest.mock-examples.rst:1154
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "下面是一个模拟 'fooble' 模拟的示例。"

#: ../../library/unittest.mock-examples.rst:1166
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"你可以看到 ``import fooble`` 成功执行，而当退出时 :data:`sys.modules` 中将不再有 'fooble'。"

#: ../../library/unittest.mock-examples.rst:1169
msgid "This also works for the ``from module import name`` form:"
msgstr "这同样适用于 ``from module import name`` 形式:"

#: ../../library/unittest.mock-examples.rst:1179
msgid "With slightly more work you can also mock package imports:"
msgstr "稍微多做一点工作你还可以模拟包的导入:"

#: ../../library/unittest.mock-examples.rst:1192
msgid "Tracking order of calls and less verbose call assertions"
msgstr "追踪调用顺序和不太冗长的调用断言"

#: ../../library/unittest.mock-examples.rst:1194
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects,"
" however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
":class:`Mock` 类允许你通过 :attr:`~Mock.method_calls` 属性来追踪在你的 mock 对象上的方法调用的 "
"*顺序*。 这并不允许你追踪单独 mock 对象之间的调用顺序，但是我们可以使用 :attr:`~Mock.mock_calls` 来达到同样的效果。"

#: ../../library/unittest.mock-examples.rst:1199
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an"
" arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be"
" recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"因为 mock 会追踪 ``mock_calls`` 中对子 mock 的调用，并且访问 mock 的任意属性都会创建一个子 "
"mock，所以我们可以基于父 mock 创建单独的子 mock。 随后对这些子 mock 的调用将按顺序被记录在父 mock 的 "
"``mock_calls`` 中:"

#: ../../library/unittest.mock-examples.rst:1216
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr "我们可以随后通过与管理器 mock 上的 ``mock_calls`` 属性进行比较来进行有关这些调用，包括调用顺序的断言:"

#: ../../library/unittest.mock-examples.rst:1223
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"如果 ``patch`` 创建并准备好了你的 mock 那么你可以使用 :meth:`~Mock.attach_mock` 方法将它们附加到管理器 "
"mock 上。 在附加之后所有调用都将被记录在管理器的 ``mock_calls`` 中。 ::"

#: ../../library/unittest.mock-examples.rst:1227
msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"

#: ../../library/unittest.mock-examples.rst:1242
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the "
":meth:`~Mock.assert_has_calls` method. This takes a list of calls "
"(constructed with the :data:`call` object). If that sequence of calls are in"
" :attr:`~Mock.mock_calls` then the assert succeeds."
msgstr ""
"如果已经进行了许多调用，但是你只对它们的一个特定序列感兴趣则有一种替代方式是使用 :meth:`~Mock.assert_has_calls` 方法。 "
"这需要一个调用的列表（使用 :data:`call` 对象来构建）。 如果该调用序列在 :attr:`~Mock.mock_calls` "
"中则断言将成功。"

#: ../../library/unittest.mock-examples.rst:1256
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls"
" that have been made to the mock, the assert still succeeds."
msgstr "即使链式调用 ``m.one().two().three()`` 不是对 mock 的唯一调用，该断言仍将成功。"

#: ../../library/unittest.mock-examples.rst:1259
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"有时可能会对一个 mock 进行多次调用，而你只对断言其中的 *某些* 调用感兴趣。 你甚至可能对顺序也不关心。 在这种情况下你可以将 "
"``any_order=True`` 传给 ``assert_has_calls``:"

#: ../../library/unittest.mock-examples.rst:1271
msgid "More complex argument matching"
msgstr "更复杂的参数匹配"

#: ../../library/unittest.mock-examples.rst:1273
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr "使用与 :data:`ANY` 一样的基本概念我们可以实现匹配器以便在用作 mock 的参数的对象上执行更复杂的断言。"

#: ../../library/unittest.mock-examples.rst:1276
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need"
" to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these"
" attributes for us."
msgstr ""
"假设我们准备将某个对象传给一个在默认情况下基于对象标识相等（这是 Python 中用户自定义类的默认行为）的 mock。 要使用 "
":meth:`~Mock.assert_called_with` 我们就将必须传入完全相同的对象。 "
"如果我们只对该对象的某些属性感兴趣那么我们可以创建一个能为我们检查这些属性的匹配器。"

#: ../../library/unittest.mock-examples.rst:1283
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr "在这个示例中你可以看到为何执行对 ``assert_called_with`` 的‘标准’调用并不足够:"

#: ../../library/unittest.mock-examples.rst:1298
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr "一个针对我们的 ``Foo`` 类的比较函数看上去会是这样的:"

#: ../../library/unittest.mock-examples.rst:1310
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr "而一个可以使用这样的比较函数进行相等性比较运算的匹配器对象看上去会是这样的:"

#: ../../library/unittest.mock-examples.rst:1321
msgid "Putting all this together:"
msgstr "将所有这些放在一起:"

#: ../../library/unittest.mock-examples.rst:1326
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher``"
" equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is"
" raised:"
msgstr ""
"``Matcher`` 是用我们的比较函数和我们想要比较的 ``Foo`` 对象来实例化的。 在 ``assert_called_with`` "
"中将会调用 ``Matcher`` 的相等性方法，它会将调用 mock 时附带的对象与我们创建我们的匹配器时附带的对象进行比较。 如果它们匹配则 "
"``assert_called_with`` 通过，而如果不匹配则会引发 :exc:`AssertionError`:"

#: ../../library/unittest.mock-examples.rst:1339
msgid ""
"With a bit of tweaking you could have the comparison function raise the "
":exc:`AssertionError` directly and provide a more useful failure message."
msgstr "通过一些调整你可以让比较函数直接引发 :exc:`AssertionError` 并提供更有用的失败消息。"

#: ../../library/unittest.mock-examples.rst:1342
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest "
"<https://pyhamcrest.readthedocs.io/>`_ provides similar functionality, that "
"may be useful here, in the form of its equality matcher "
"(`hamcrest.library.integration.match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)."
msgstr ""
"从 1.5 版开始，Python 测试库 `PyHamcrest <https://pyhamcrest.readthedocs.io/>`_ "
"提供了类似的功能，在这里可能会很有用，它采用的形式是相等性匹配器 "
"(`hamcrest.library.integration.match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)。"
