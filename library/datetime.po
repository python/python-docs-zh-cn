# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/datetime.rst:2
msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`!datetime` --- 基本日期和时间类型"

#: ../../library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**源代码：** :source:`Lib/datetime.py`"

#: ../../library/datetime.rst:17
msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ":mod:`!datetime` 模块提供了用于操作日期和时间的类。"

#: ../../library/datetime.rst:19
msgid ""
"While date and time arithmetic is supported, the focus of the implementation"
" is on efficient attribute extraction for output formatting and "
"manipulation."
msgstr "在支持日期时间数学运算的同时，实现的关注点更着重于如何能够更有效地解析其属性用于格式化输出和数据操作。"

#: ../../library/datetime.rst:24
msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr "跳到 :ref:`格式代码 <format-codes>`。"

#: ../../library/datetime.rst:28
msgid "Module :mod:`calendar`"
msgstr "模块 :mod:`calendar`"

#: ../../library/datetime.rst:29
msgid "General calendar related functions."
msgstr "通用日历相关函数"

#: ../../library/datetime.rst:31
msgid "Module :mod:`time`"
msgstr "模块 :mod:`time`"

#: ../../library/datetime.rst:32
msgid "Time access and conversions."
msgstr "时间的访问和转换"

#: ../../library/datetime.rst:34
msgid "Module :mod:`zoneinfo`"
msgstr ":mod:`zoneinfo` 模块"

#: ../../library/datetime.rst:35
msgid "Concrete time zones representing the IANA time zone database."
msgstr "代表 IANA 时区数据库的具体时区。"

#: ../../library/datetime.rst:37
msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "`dateutil <https://dateutil.readthedocs.io/en/stable/>`_ 包"

#: ../../library/datetime.rst:38
msgid "Third-party library with expanded time zone and parsing support."
msgstr "具有扩展时区和解析支持的第三方库。"

#: ../../library/datetime.rst:40
msgid "Package :pypi:`DateType`"
msgstr "包 :pypi:`DateType`"

#: ../../library/datetime.rst:41
msgid ""
"Third-party library that introduces distinct static types to e.g. allow "
":term:`static type checkers <static type checker>` to differentiate between "
"naive and aware datetimes."
msgstr ""
"引入了几种独特的静态类型的第三方库，例如允许 :term:`静态类型检查器 <static type checker>` 区分简单型和感知型日期时间。"

#: ../../library/datetime.rst:48
msgid "Aware and Naive Objects"
msgstr "感知型对象和简单型对象"

#: ../../library/datetime.rst:50
msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" depending"
" on whether or not they include time zone information."
msgstr "日期和时间对象可以根据它们是否包含时区信息而分为“感知型”和“简单型”两类。"

#: ../../library/datetime.rst:53
msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An aware"
" object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"充分掌握应用性算法和政治性时间调整信息例如时区和夏令时的情况下，一个 **感知型** 对象就能相对于其他感知型对象来精确定位自身时间点。 "
"感知型对象是用来表示一个没有解释空间的固定时间点。 [#]_"

#: ../../library/datetime.rst:59
msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object "
"represents Coordinated Universal Time (UTC), local time, or time in some "
"other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. Naive"
" objects are easy to understand and to work with, at the cost of ignoring "
"some aspects of reality."
msgstr ""
"**简单型** 对象没有包含足够多的信息来无歧义地相对于其他 date/time 对象来定位自身时间点。 "
"不论一个简单型对象所代表的是世界标准时间（UTC）、当地时间还是某个其他时区的时间完全取决于具体程序，就像一个特定数字所代表的是米、英里还是质量完全取决于具体程序一样。"
" 简单型对象更易于理解和使用，代价则是忽略了某些现实性考量。"

#: ../../library/datetime.rst:66
msgid ""
"For applications requiring aware objects, :class:`.datetime` and "
":class:`.time` objects have an optional time zone information attribute, "
":attr:`!tzinfo`, that can be set to an instance of a subclass of the "
"abstract :class:`tzinfo` class. These :class:`tzinfo` objects capture "
"information about the offset from UTC time, the time zone name, and whether "
"daylight saving time is in effect."
msgstr ""
"对于要求感知型对象的应用，:class:`.datetime` 和 :class:`.time` 对象具有一个可选的时区信息属性 "
":attr:`!tzinfo`，它可被设为抽象类 :class:`tzinfo` 的子类的一个实例。 这些 :class:`tzinfo` 对象会捕获与"
" UTC 时间的差值、时区名称以及夏令时是否生效等信息。"

#: ../../library/datetime.rst:72
msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can "
"represent simple time zones with fixed offsets from UTC, such as UTC itself "
"or North American EST and EDT time zones. Supporting time zones at deeper "
"levels of detail is up to the application. The rules for time adjustment "
"across the world are more political than rational, change frequently, and "
"there is no standard suitable for every application aside from UTC."
msgstr ""
":mod:`!datetime` 模块只提供了一个具体的 :class:`tzinfo` 类，即 :class:`timezone` 类。 "
":class:`!timezone` 类可以表示具有相对于 UTC 的固定时差的简单时区，例如 UTC 本身或北美 EST 和 EDT 时区等。 "
"支持时区的详细程度取决于具体的应用。 世界各地的时间调整规则往往是政治性多于合理性，经常会发生变化，除了 UTC 之外并没有一个能适合所有应用的标准。"

#: ../../library/datetime.rst:81
msgid "Constants"
msgstr "常量"

#: ../../library/datetime.rst:83
msgid "The :mod:`!datetime` module exports the following constants:"
msgstr ":mod:`!datetime` 模块导出了以下常量："

#: ../../library/datetime.rst:87
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MINYEAR` is 1."
msgstr ":class:`date` 或 :class:`.datetime` 对象允许的最小年份数值。 :const:`MINYEAR` 为 1。"

#: ../../library/datetime.rst:93
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
":class:`date` 或 :class:`.datetime` 对象允许的最大年份数值。 :const:`MAXYEAR` 为 9999。"

#: ../../library/datetime.rst:98
msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr "UTC 时区单例 :attr:`datetime.timezone.utc` 的别名。"

#: ../../library/datetime.rst:103
msgid "Available Types"
msgstr "有效的类型"

#: ../../library/datetime.rst:108
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was,"
" and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and"
" :attr:`day`."
msgstr ""
"一个理想化的简单型日期，它假设当今的公历在过去和未来永远有效。 属性: :attr:`year`, :attr:`month`, and "
":attr:`day`。"

#: ../../library/datetime.rst:116
msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, "
":attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"一个独立于任何特定日期的理想化时间，它假设每一天都恰好等于 24\\*60\\*60 秒。 （这里没有“闰秒”的概念。） 包含属性: "
":attr:`hour`, :attr:`minute`, :attr:`second`, :attr:`microsecond` 和 "
":attr:`.tzinfo`。"

#: ../../library/datetime.rst:125
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:`month`,"
" :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, "
":attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"日期和时间的结合。属性：:attr:`year`, :attr:`month`, :attr:`day`, :attr:`hour`, "
":attr:`minute`, :attr:`second`, :attr:`microsecond`, and :attr:`.tzinfo`."

#: ../../library/datetime.rst:133
msgid ""
"A duration expressing the difference between two :class:`.datetime` or "
":class:`date` instances to microsecond resolution."
msgstr "将两个 :class:`.datetime` 或 :class:`date` 实例之间的差值表示为微秒级精度的持续时间。"

#: ../../library/datetime.rst:140
msgid ""
"An abstract base class for time zone information objects. These are used by "
"the :class:`.datetime` and :class:`.time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""
"一个描述时区信息对象的抽象基类。 用来给 :class:`.datetime` 和 :class:`.time` "
"类提供自定义的时间调整概念（例如处理时区和/或夏令时）。"

#: ../../library/datetime.rst:148
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a fixed "
"offset from the UTC."
msgstr "一个实现了 :class:`tzinfo` 抽象基类的子类，用于表示相对于 世界标准时间（UTC）的偏移量。"

#: ../../library/datetime.rst:153 ../../library/datetime.rst:171
msgid "Objects of these types are immutable."
msgstr "这些类型的对象都是不可变的。"

#: ../../library/datetime.rst:155
msgid "Subclass relationships::"
msgstr "子类关系 ::"

#: ../../library/datetime.rst:157
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"

#: ../../library/datetime.rst:166
msgid "Common Properties"
msgstr "通用的特征属性"

#: ../../library/datetime.rst:168
msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and :class:`timezone`"
" types share these common features:"
msgstr ""
":class:`date`, :class:`.datetime`, :class:`.time` 和 :class:`timezone` "
"类型共享这些通用特性:"

#: ../../library/datetime.rst:172
msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be used "
"as dictionary keys."
msgstr "这些类型的对象是 :term:`hashable`，意味着它们可以被用作字典的键。"

#: ../../library/datetime.rst:174
msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr "这些类型的对象支持通过 :mod:`pickle` 模块进行高效的封存。"

#: ../../library/datetime.rst:177
msgid "Determining if an Object is Aware or Naive"
msgstr "确定一个对象是感知型还是简单型"

#: ../../library/datetime.rst:179
msgid "Objects of the :class:`date` type are always naive."
msgstr ":class:`date`  类型的对象都是简单型的。"

#: ../../library/datetime.rst:181
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or "
"naive."
msgstr ":class:`.time` 或 :class:`.datetime` 类型的对象可以是感知型或者简单型。"

#: ../../library/datetime.rst:183
msgid ""
"A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr "一个 :class:`.datetime` 对象 ``d`` 在以下条件同时成立时将是感知型的："

#: ../../library/datetime.rst:185
msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo`` 不为 ``None``"

#: ../../library/datetime.rst:186
msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)`` 不返回 ``None``"

#: ../../library/datetime.rst:188
msgid "Otherwise, ``d`` is naive."
msgstr "在其他情况下，``d`` 将是简单型的。"

#: ../../library/datetime.rst:190
msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr "一个 :class:`.time` 对象 ``t`` 在以下条件同时成立时将是感知型的："

#: ../../library/datetime.rst:192
msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo`` 不为 ``None``"

#: ../../library/datetime.rst:193
msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "``t.tzinfo.utcoffset(None)`` 不返回 ``None``。"

#: ../../library/datetime.rst:195
msgid "Otherwise, ``t`` is naive."
msgstr "在其他情况下，``t`` 将是简单型的。"

#: ../../library/datetime.rst:197
msgid ""
"The distinction between aware and naive doesn't apply to :class:`timedelta` "
"objects."
msgstr "感知型和简单型之间的区别不适用于 :class:`timedelta` 对象。"

#: ../../library/datetime.rst:203
msgid ":class:`timedelta` Objects"
msgstr ":class:`timedelta` 类对象"

#: ../../library/datetime.rst:205
msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two :class:`.datetime` or :class:`date` instances."
msgstr ""
":class:`timedelta` 对象表示一段持续的时间，即两个 :class:`.datetime` 或 :class:`date` "
"实例之间的差值。"

#: ../../library/datetime.rst:210
msgid ""
"All arguments are optional and default to 0. Arguments may be integers or "
"floats, and may be positive or negative."
msgstr "所有参数都是可选的并且默认为 0。 这些参数可以是整数或者浮点数，并可以为正值或者负值。"

#: ../../library/datetime.rst:213
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. Arguments "
"are converted to those units:"
msgstr "只有 *days*, *seconds* 和 *microseconds* 会存储在内部。 参数单位的换算规则如下："

#: ../../library/datetime.rst:216
msgid "A millisecond is converted to 1000 microseconds."
msgstr "1毫秒会转换成1000微秒。"

#: ../../library/datetime.rst:217
msgid "A minute is converted to 60 seconds."
msgstr "1分钟会转换成60秒。"

#: ../../library/datetime.rst:218
msgid "An hour is converted to 3600 seconds."
msgstr "1小时会转换成3600秒。"

#: ../../library/datetime.rst:219
msgid "A week is converted to 7 days."
msgstr "1星期会转换成7天。"

#: ../../library/datetime.rst:221
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr "日期、秒、微秒都是标准化的，所以它们的表达方式也是唯一的，例："

#: ../../library/datetime.rst:224
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: ../../library/datetime.rst:225
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= seconds < 3600*24`` (一天的秒数)"

#: ../../library/datetime.rst:226
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: ../../library/datetime.rst:228
msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those three "
"resulting attributes::"
msgstr ""
"下面的例子演示了如何对 *days*, *seconds* 和 *microseconds* "
"以外的任意参数执行“合并”操作并标准化为以上三个结果属性::"

#: ../../library/datetime.rst:232
msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # 只保留日期、秒和微秒\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"

#: ../../library/datetime.rst:246
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"在有任何参数为浮点型并且 microseconds "
"值为小数的情况下，从所有参数中余下的微秒数将被合并，并使用四舍五入偶不入奇的规则将总计值舍入到最接近的整数微秒值。 "
"如果没有任何参数为浮点型的情况下，则转换和标准化过程将是完全精确的（不会丢失信息）。"

#: ../../library/datetime.rst:253
msgid ""
"If the normalized value of days lies outside the indicated range, "
":exc:`OverflowError` is raised."
msgstr "如果标准化后的 days 数值超过了指定范围，将会抛出 :exc:`OverflowError` 异常。"

#: ../../library/datetime.rst:256
msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example::"
msgstr "请注意对负数值进行标准化的结果可能会令人感到惊讶。 例如::"

#: ../../library/datetime.rst:259
msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"

#: ../../library/datetime.rst:264
msgid ""
"Since the string representation of :class:`!timedelta` objects can be "
"confusing, use the following recipe to produce a more readable format:"
msgstr "由于 :class:`!timedelta` 对象的字符串表示形式可能令人困惑，请使用以下写法以产生更具可读性的格式："

#: ../../library/datetime.rst:267
msgid ""
">>> def pretty_timedelta(td):\n"
"...     if td.days >= 0:\n"
"...         return str(td)\n"
"...     return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(hours=-1)\n"
">>> str(d)  # not human-friendly\n"
"'-1 day, 23:00:00'\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"
msgstr ""
">>> def pretty_timedelta(td):\n"
"...     if td.days >= 0:\n"
"...         return str(td)\n"
"...     return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(hours=-1)\n"
">>> str(d)  # 对人类不友好\n"
"'-1 day, 23:00:00'\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"

#: ../../library/datetime.rst:281 ../../library/datetime.rst:582
#: ../../library/datetime.rst:1142 ../../library/datetime.rst:1780
#: ../../library/datetime.rst:2385
msgid "Class attributes:"
msgstr "类属性："

#: ../../library/datetime.rst:285
msgid ""
"The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr " :class:`timedelta` 类对象的最小值为 ``timedelta(-999999999)``。"

#: ../../library/datetime.rst:290
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
" :class:`timedelta` 类对象的最大值为 ``timedelta(days=999999999, hours=23, "
"minutes=59, seconds=59, microseconds=999999)``。"

#: ../../library/datetime.rst:296
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr "两个不相等的 :class:`timedelta` 类对象最小的间隔为 ``timedelta(microseconds=1)``。"

#: ../../library/datetime.rst:299
msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than "
"``-timedelta.min``. ``-timedelta.max`` is not representable as a "
":class:`timedelta` object."
msgstr ""
"请注意，因为标准化的缘故，``timedelta.max`` 大于 ``-timedelta.min``。 ``-timedelta.max`` "
"不可以表示为一个 :class:`timedelta` 对象。"

#: ../../library/datetime.rst:303 ../../library/datetime.rst:600
#: ../../library/datetime.rst:1162 ../../library/datetime.rst:1800
msgid "Instance attributes (read-only):"
msgstr "实例属性（只读）："

#: ../../library/datetime.rst:307
msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "-999,999,999 至 999,999,999 开区间。"

#: ../../library/datetime.rst:312
msgid "Between 0 and 86,399 inclusive."
msgstr "0 至 86,399 开区间。"

#: ../../library/datetime.rst:316
msgid ""
"It is a somewhat common bug for code to unintentionally use this attribute "
"when it is actually intended to get a :meth:`~timedelta.total_seconds` value"
" instead:"
msgstr "一个有点常见的代码错误是当实际是要获取 :meth:`~timedelta.total_seconds` 值时无意中使用了这个属性："

#: ../../library/datetime.rst:320
msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"

#: ../../library/datetime.rst:331
msgid "Between 0 and 999,999 inclusive."
msgstr "0 至 999,999 开区间。"

#: ../../library/datetime.rst:334 ../../library/datetime.rst:617
#: ../../library/datetime.rst:1215
msgid "Supported operations:"
msgstr "支持的运算："

#: ../../library/datetime.rst:339 ../../library/datetime.rst:620
#: ../../library/datetime.rst:1218
msgid "Operation"
msgstr "运算"

#: ../../library/datetime.rst:339 ../../library/datetime.rst:620
#: ../../library/datetime.rst:1218
msgid "Result"
msgstr "结果："

#: ../../library/datetime.rst:341
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: ../../library/datetime.rst:341
msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == t2``"
" are true. (1)"
msgstr ""
"``t2`` 和 ``t3`` 之和。 运算后 ``t1 - t2 == t3`` 且 ``t1 - t3 == t2`` 为真值。 (1)"

#: ../../library/datetime.rst:345
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: ../../library/datetime.rst:345
msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 == "
"t1 + t3`` are true. (1)(6)"
msgstr ""
"``t2`` 和 ``t3`` 之差。 运算后 ``t1 == t2 - t3`` 且 ``t2 == t1 + t3`` 为真值。 (1)(6)"

#: ../../library/datetime.rst:349
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i or t1 = i * t2``"

#: ../../library/datetime.rst:349
msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr "时差乘以一个整数。 运算后如果 ``i != 0`` 则 ``t1 // i == t2`` 为真值。"

#: ../../library/datetime.rst:353
msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "通常情况下，``t1  * i == t1 * (i-1) + t1`` 为真值。 (1)"

#: ../../library/datetime.rst:356
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f or t1 = f * t2``"

#: ../../library/datetime.rst:356
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest multiple "
"of timedelta.resolution using round-half-to-even."
msgstr "乘以一个浮点数，结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。"

#: ../../library/datetime.rst:360
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: ../../library/datetime.rst:360
msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns a "
":class:`float` object."
msgstr "总时长 ``t2`` 除以间隔单位 ``t3`` (3)。 返回一个 :class:`float` 对象。"

#: ../../library/datetime.rst:364
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f or t1 = t2 / i``"

#: ../../library/datetime.rst:364
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr "除以一个浮点数或整数。 结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。"

#: ../../library/datetime.rst:368
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` or ``t1 = t2 // t3``"

#: ../../library/datetime.rst:368
msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr "计算底数，其余部分（如果有）将被丢弃。在第二种情况下，将返回整数。 （3）"

#: ../../library/datetime.rst:372
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: ../../library/datetime.rst:372
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "余数为一个 :class:`timedelta` 对象。(3)"

#: ../../library/datetime.rst:375
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: ../../library/datetime.rst:375
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = t1 %"
" t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"计算商和余数: ``q = t1 // t2`` (3) 和 ``r = t1 % t2``。 ``q`` 是一个整数而 ``r`` 是一个 "
":class:`timedelta` 对象。"

#: ../../library/datetime.rst:380
msgid "``+t1``"
msgstr "``+t1``"

#: ../../library/datetime.rst:380
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "返回一个相同数值的 :class:`timedelta` 对象。"

#: ../../library/datetime.rst:383
msgid "``-t1``"
msgstr "``-t1``"

#: ../../library/datetime.rst:383
msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and to"
" ``t1 * -1``. (1)(4)"
msgstr ""
"等价于 ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``，以及 ``t1 * -1``。 "
"(1)(4)"

#: ../../library/datetime.rst:387
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: ../../library/datetime.rst:387
msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr "当 ``t.days >= 0`` 时等于 ``+t``，而当 ``t.days < 0`` 时等于 ``-t``。 (2)"

#: ../../library/datetime.rst:390
msgid "``str(t)``"
msgstr "``str(t)``"

#: ../../library/datetime.rst:390
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D is"
" negative for negative ``t``. (5)"
msgstr ""
"返回一个形如 ``[D day[s], ][H]H:MM:SS[.UUUUUU]`` 的字符串，当 ``t`` 为负数的时候，  D 也为负数。 (5)"

#: ../../library/datetime.rst:394
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: ../../library/datetime.rst:394
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr "返回一个 :class:`timedelta` 对象的字符串表示形式，作为附带正规属性值的构造器调用。"

#: ../../library/datetime.rst:400 ../../library/datetime.rst:639
#: ../../library/datetime.rst:2616
msgid "Notes:"
msgstr "注释："

#: ../../library/datetime.rst:403
msgid "This is exact but may overflow."
msgstr "结果正确，但可能会溢出。"

#: ../../library/datetime.rst:406
msgid "This is exact and cannot overflow."
msgstr "结果正确，不会溢出。"

#: ../../library/datetime.rst:409
msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "除以零将会引发 :exc:`ZeroDivisionError`。"

#: ../../library/datetime.rst:412
msgid ""
"``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr "``-timedelta.max`` 不可以表示为一个 :class:`timedelta` 对象。"

#: ../../library/datetime.rst:415
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat unusual "
"results for negative timedeltas. For example::"
msgstr ":class:`timedelta` 对象的字符串表示形式类似于其内部表示形式被规范化。对于负时间增量，这会导致一些不寻常的结果。例如::"

#: ../../library/datetime.rst:419
msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"

#: ../../library/datetime.rst:425
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + "
"(-t3)`` except when t3 is equal to ``timedelta.max``; in that case the "
"former will produce a result while the latter will overflow."
msgstr ""
"表达式 ``t2 - t3`` 通常与 ``t2 + (-t3)`` 是等价的，除非 t3 等于 ``timedelta.max``; "
"在这种情况下前者会返回结果，而后者则会溢出。"

#: ../../library/datetime.rst:429
msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and "
":class:`.datetime` objects (see below)."
msgstr ""
"除了上面列举的操作以外，:class:`timedelta` 对象还支持与 :class:`date` 和 :class:`.datetime` "
"对象进行特定的相加和相减运算（见下文）。"

#: ../../library/datetime.rst:433
msgid ""
"Floor division and true division of a :class:`timedelta` object by another "
":class:`timedelta` object are now supported, as are remainder operations and"
" the :func:`divmod` function. True division and multiplication of a "
":class:`timedelta` object by a :class:`float` object are now supported."
msgstr ""
"现在已支持 :class:`timedelta` 对象与另一个 :class:`timedelta` 对象相整除或相除，包括求余运算和 "
":func:`divmod` 函数。 现在也支持 :class:`timedelta` 对象加上或乘以一个 :class:`float` 对象。"

#: ../../library/datetime.rst:439
msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ":class:`timedelta` 对象支持相等性和顺序比较。"

#: ../../library/datetime.rst:441
msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true if"
" and only if it isn't equal to ``timedelta(0)``."
msgstr "在布尔运算中，:class:`timedelta` 对象当且仅当其不等于 ``timedelta(0)`` 时则会被视为真值。"

#: ../../library/datetime.rst:444 ../../library/datetime.rst:681
#: ../../library/datetime.rst:1305 ../../library/datetime.rst:1907
msgid "Instance methods:"
msgstr "实例方法："

#: ../../library/datetime.rst:448
msgid ""
"Return the total number of seconds contained in the duration. Equivalent to "
"``td / timedelta(seconds=1)``. For interval units other than seconds, use "
"the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"返回期间占用了多少秒。等价于 ``td / timedelta(seconds=1)``。对于秒以外的间隔单位，直接使用除法形式 (例如  ``td /"
" timedelta(microseconds=1)``)。"

#: ../../library/datetime.rst:452
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr "需要注意的是，时间间隔较大时，这个方法的结果中的微秒将会失真（大多数平台上大于270年视为一个较大的时间间隔）。"

#: ../../library/datetime.rst:458
msgid "Examples of usage: :class:`timedelta`"
msgstr ":class:`timedelta` 用法示例"

#: ../../library/datetime.rst:460
msgid "An additional example of normalization::"
msgstr "一个标准化的附加示例::"

#: ../../library/datetime.rst:462
msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""
">>> # another_year 的部分增加恰好 365 天\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"

#: ../../library/datetime.rst:472
msgid "Examples of :class:`timedelta` arithmetic::"
msgstr ":class:`timedelta` 算术运算的示例::"

#: ../../library/datetime.rst:474
msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"

#: ../../library/datetime.rst:491
msgid ":class:`date` Objects"
msgstr ":class:`date` 对象"

#: ../../library/datetime.rst:493
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions."
msgstr ":class:`date` 对象代表一个理想化历法中的日期（年、月和日），即当今的格列高利历向前后两个方向无限延伸。"

#: ../../library/datetime.rst:497
msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called "
"day number 2, and so on. [#]_"
msgstr "公元 1 年 1 月 1日是第 1 日，公元 1 年 1 月 2 日是第 2 日，依此类推。 [#]_"

#: ../../library/datetime.rst:502
msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr "所有参数都是必要的。 参数必须是在下面范围内的整数："

#: ../../library/datetime.rst:505
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: ../../library/datetime.rst:506
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: ../../library/datetime.rst:507
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= 日期 <= 给定年月对应的天数``"

#: ../../library/datetime.rst:509 ../../library/datetime.rst:899
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr "如果参数不在这些范围内，则抛出 :exc:`ValueError` 异常。"

#: ../../library/datetime.rst:512 ../../library/datetime.rst:904
msgid "Other constructors, all class methods:"
msgstr "其它构造器，所有的类方法："

#: ../../library/datetime.rst:516
msgid "Return the current local date."
msgstr "返回当前的本地日期。"

#: ../../library/datetime.rst:518
msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "这等价于 ``date.fromtimestamp(time.time())``。"

#: ../../library/datetime.rst:522
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr "返回对应于 POSIX 时间戳的当地时间，例如 :func:`time.time` 返回的就是时间戳。"

#: ../../library/datetime.rst:525
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of"
" values supported by the platform C :c:func:`localtime` function, and "
":exc:`OSError` on :c:func:`localtime` failure. It's common for this to be "
"restricted to years from 1970 through 2038. Note that on non-POSIX systems "
"that include leap seconds in their notion of a timestamp, leap seconds are "
"ignored by :meth:`fromtimestamp`."
msgstr ""
"这可能引发 :exc:`OverflowError`，如果时间戳数值超出所在平台 C :c:func:`localtime` "
"函数的支持范围的话，并且会在 :c:func:`localtime` 出错时引发 :exc:`OSError`。 通常该数值会被限制在 1970 年至 "
"2038 年之间。 请注意在时间戳概念包含闰秒的非 POSIX 系统上，闰秒会被 :meth:`fromtimestamp` 所忽略。"

#: ../../library/datetime.rst:532
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on "
":c:func:`localtime` failure."
msgstr ""
"引发 :exc:`OverflowError` 而不是 :exc:`ValueError`，如果时间戳数值超出所在平台 C "
":c:func:`localtime` 函数的支持范围的话，并会在 :c:func:`localtime` 出错时引发 :exc:`OSError` "
"而不是 :exc:`ValueError`。"

#: ../../library/datetime.rst:541
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr "返回对应于预期格列高利历序号的日期，其中公元 1 年 1 月 1 日的序号为 1。"

#: ../../library/datetime.rst:544
msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= date.max.toordinal()``."
" For any date ``d``, ``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"除非 ``1 <= ordinal <= date.max.toordinal()`` 否则会引发 :exc:`ValueError`。 对于任意的日期"
" ``d``，均有 ``date.fromordinal(d.toordinal()) == d``。"

#: ../../library/datetime.rst:551
msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr "返回一个对应于以任何有效 ISO 8601 格式给出的 *date_string* 的 :class:`date`，下列格式除外："

#: ../../library/datetime.rst:554 ../../library/datetime.rst:1064
msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, ``YYYY``)."
msgstr "目前不支持降低精度的日期 (``YYYY-MM``, ``YYYY``)。"

#: ../../library/datetime.rst:556 ../../library/datetime.rst:1066
msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr "目前不支持扩展日期表示形式 (``±YYYYYY-MM-DD``)。"

#: ../../library/datetime.rst:558 ../../library/datetime.rst:1068
msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr "目前不支持序数日期 (``YYYY-OOO``)。"

#: ../../library/datetime.rst:560 ../../library/datetime.rst:1070
#: ../../library/datetime.rst:1536
msgid "Examples::"
msgstr "示例::"

#: ../../library/datetime.rst:562
msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"

#: ../../library/datetime.rst:571
msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr "在之前版本中，此方法仅支持一种格式 ``YYYY-MM-DD``。"

#: ../../library/datetime.rst:576
msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified by "
"year, week and day. This is the inverse of the function "
":meth:`date.isocalendar`."
msgstr ""
"返回指定 year, week 和 day 所对应 ISO 历法日期的 :class:`date`。 这是函数 "
":meth:`date.isocalendar` 的逆操作。"

#: ../../library/datetime.rst:586
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "最小的日期 ``date(MINYEAR, 1, 1)`` 。"

#: ../../library/datetime.rst:591
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "最大的日期 ，``date(MAXYEAR, 12, 31)``。"

#: ../../library/datetime.rst:596
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr "两个日期对象的最小间隔，``timedelta(days=1)``。"

#: ../../library/datetime.rst:604 ../../library/datetime.rst:1166
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "在 :const:`MINYEAR` 和 :const:`MAXYEAR` 之间，包含边界。"

#: ../../library/datetime.rst:609 ../../library/datetime.rst:1171
msgid "Between 1 and 12 inclusive."
msgstr "1 至 12（含）"

#: ../../library/datetime.rst:614 ../../library/datetime.rst:1176
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "返回1到指定年月的天数间的数字。"

#: ../../library/datetime.rst:622
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: ../../library/datetime.rst:622
msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr "``date2`` 将为 ``date1`` 之后的 ``timedelta.days`` 日。 (1)"

#: ../../library/datetime.rst:625
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: ../../library/datetime.rst:625
msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "计算 ``date2`` 使得 ``date2 + timedelta == date1``。 (2)"

#: ../../library/datetime.rst:628
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: ../../library/datetime.rst:628 ../../library/datetime.rst:1224
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/datetime.rst:0
msgid "``date1 == date2``"
msgstr "``date1 == date2``"

#: ../../library/datetime.rst:0
msgid "``date1 != date2``"
msgstr "``date1 != date2``"

#: ../../library/datetime.rst:630 ../../library/datetime.rst:1226
msgid "Equality comparison. (4)"
msgstr "相等性比较。 (4)"

#: ../../library/datetime.rst:0
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst:0
msgid "``date1 > date2``"
msgstr "``date1 > date2``"

#: ../../library/datetime.rst:0
msgid "``date1 <= date2``"
msgstr "``date1 <= date2``"

#: ../../library/datetime.rst:0
msgid "``date1 >= date2``"
msgstr "``date1 >= date2``"

#: ../../library/datetime.rst:633 ../../library/datetime.rst:1229
msgid "Order comparison. (5)"
msgstr "顺序比较。 (5)"

#: ../../library/datetime.rst:642
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. "
":exc:`OverflowError` is raised if ``date2.year`` would be smaller than "
":const:`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"如果 ``timedelta.days > 0`` 则 *date2* 将在时间线上前进，如果 ``timedelta.days < 0`` 则将后退。"
" 操作完成后 ``date2 - date1 == timedelta.days``。 ``timedelta.seconds`` 和 "
"``timedelta.microseconds`` 会被忽略。 如果 ``date2.year`` 将小于 :const:`MINYEAR` 或大于 "
":const:`MAXYEAR` 则会引发 :exc:`OverflowError`。"

#: ../../library/datetime.rst:649
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds`` 和 ``timedelta.microseconds`` 会被忽略。"

#: ../../library/datetime.rst:652
msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and "
"``timedelta.microseconds`` are 0, and ``date2 + timedelta == date1`` after."
msgstr ""
"该值是精确的，且不会溢出。 运算后 ``timedelta.seconds`` 和 ``timedelta.microseconds`` 均为 0，且 "
"``date2 + timedelta == date1``。"

#: ../../library/datetime.rst:656
msgid ":class:`date` objects are equal if they represent the same date."
msgstr ":class:`date` 对象在表示相同的日期时相等。"

#: ../../library/datetime.rst:658
msgid ""
":class:`!date` objects that are not also :class:`.datetime` instances are "
"never equal to :class:`!datetime` objects, even if they represent the same "
"date."
msgstr ""
"不属于 :class:`.datetime` 实例的 :class:`!date` 对象永远不会与 :class:`!datetime` "
"对象相等，即使它们表示相同的日期。"

#: ../../library/datetime.rst:663
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if ``date1.toordinal() <"
" date2.toordinal()``."
msgstr ""
"当 *date1* 的时间在 *date2* 之前则认为 *date1* 小于 *date2*。 换句话说，当且仅当 "
"``date1.toordinal() < date2.toordinal()`` 时 ``date1 < date2``。"

#: ../../library/datetime.rst:667
msgid ""
"Order comparison between a :class:`!date` object that is not also a "
":class:`.datetime` instance and a :class:`!datetime` object raises "
":exc:`TypeError`."
msgstr ""
"不同时为 :class:`.datetime` 实例的 :class:`!date` 实例和 :class:`!datetime` "
"对象之间的顺序比较将会引发 :exc:`TypeError`。"

#: ../../library/datetime.rst:671 ../../library/datetime.rst:1297
msgid ""
"Comparison between :class:`.datetime` object and an instance of the "
":class:`date` subclass that is not a :class:`!datetime` subclass no longer "
"converts the latter to :class:`!date`, ignoring the time part and the time "
"zone. The default behavior can be changed by overriding the special "
"comparison methods in subclasses."
msgstr ""
"在 :class:`.datetime` 对象和不属于 :class:`!datetime` 子类的 :class:`date` "
"子类的实例之间进行比较时不会再将后者转换为 :class:`!date`，并忽略时间部分和时区信息。 此默认行为可以通过在子类中重写特殊比较方法来更改。"

#: ../../library/datetime.rst:679
msgid ""
"In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr "在布尔运算中，所有 :class:`date` 对象都会被视为真值。"

#: ../../library/datetime.rst:685
msgid ""
"Return a new :class:`date` object with the same values, but with specified "
"parameters updated."
msgstr "返回一个具有同样的值，但更新了指定形参的新的 :class:`date` 对象。"

#: ../../library/datetime.rst:688 ../../library/datetime.rst:1953
msgid "Example::"
msgstr "示例::"

#: ../../library/datetime.rst:690
msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"

#: ../../library/datetime.rst:695
msgid ""
"The generic function :func:`copy.replace` also supports :class:`date` "
"objects."
msgstr "泛型函数 :func:`copy.replace` 也支持 :class:`date` 对象。"

#: ../../library/datetime.rst:701 ../../library/datetime.rst:1421
msgid ""
"Return a :class:`time.struct_time` such as returned by "
":func:`time.localtime`."
msgstr "返回一个 :class:`time.struct_time`，即 :func:`time.localtime` 所返回的类型。"

#: ../../library/datetime.rst:703
msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr "hours, minutes 和 seconds 值均为 0，且 DST 旗标值为 -1。"

#: ../../library/datetime.rst:705 ../../library/datetime.rst:1423
msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()`` 等价于::"

#: ../../library/datetime.rst:707
msgid ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"

#: ../../library/datetime.rst:709
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."
msgstr ""
"其中 ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` "
"是当前年份中的日期序号，起始值 1 表示 1 月 1 日。"

#: ../../library/datetime.rst:715
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1. For any :class:`date` object ``d``, "
"``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"返回日期的预期格列高利历序号，其中公元 1 年 1 月 1 日的序号为 1. 对于任意的 :class:`date` 对象 ``d``，均有 "
"``date.fromordinal(d.toordinal()) == d``。"

#: ../../library/datetime.rst:722
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6."
" For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also "
":meth:`isoweekday`."
msgstr ""
"返回一个整数代表星期几，星期一为0，星期天为6。例如， ``date(2002, 12, 4).weekday() == 2``，表示的是星期三。参阅 "
":meth:`isoweekday`。"

#: ../../library/datetime.rst:729
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7."
" For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also"
" :meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"返回一个整数代表星期几，星期一为1，星期天为7。例如：``date(2002, 12, 4).isoweekday() == 3``,表示星期三。参见 "
":meth:`weekday`, :meth:`isocalendar`。"

#: ../../library/datetime.rst:736
msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr "返回一个由三部分组成的 :term:`named tuple` 对象: ``year``, ``week`` 和 ``weekday``。"

#: ../../library/datetime.rst:739
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr "ISO 历法是一种被广泛使用的格列高利历。 [#]_"

#: ../../library/datetime.rst:741
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday. The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""
"ISO 年由 52 或 53 个完整星期构成，每个星期开始于星期一结束于星期日。 一个 ISO "
"年的第一个星期就是（格列高利）历法的一年中第一个包含星期四的星期。 这被称为 1 号星期，这个星期四所在的 ISO 年与其所在的格列高利年相同。"

#: ../../library/datetime.rst:746
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"例如，2004 年的第一天是星期四，因此 ISO 2004 年的第一个星期开始于 2003 年 12 月 29 日星期一，结束于 2004 年 1 月 "
"4 日星期日::"

#: ../../library/datetime.rst:749
msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"

#: ../../library/datetime.rst:755
msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr "结果由元组改为 :term:`named tuple`。"

#: ../../library/datetime.rst:760
msgid ""
"Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr "返回一个以 ISO 8601 格式 ``YYYY-MM-DD`` 来表示日期的字符串::"

#: ../../library/datetime.rst:762
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"

#: ../../library/datetime.rst:768
msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "对于日期 ``d``，``str(d)`` 等价于 ``d.isoformat()``。"

#: ../../library/datetime.rst:773
msgid "Return a string representing the date::"
msgstr "返回一个表示日期的字符串::"

#: ../../library/datetime.rst:775
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"

#: ../../library/datetime.rst:779 ../../library/datetime.rst:1607
msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()`` 等效于::"

#: ../../library/datetime.rst:781 ../../library/datetime.rst:1609
msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr "time.ctime(time.mktime(d.timetuple()))"

#: ../../library/datetime.rst:783
msgid ""
"on platforms where the native C :c:func:`ctime` function (which "
":func:`time.ctime` invokes, but which :meth:`date.ctime` does not invoke) "
"conforms to the C standard."
msgstr ""
"在原生 C :c:func:`ctime` 函数遵循 C 标准的平台上 (:func:`time.ctime` 会发起对该函数的调用，但 "
":meth:`date.ctime` 并不会) 。"

#: ../../library/datetime.rst:790
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and "
":meth:`date.isoformat`."
msgstr ""
"返回一个由显式格式字符串所控制的，代表日期的字符串。 表示时、分或秒的格式代码值将为 0。 另请参阅 :ref:`strftime-strptime-"
"behavior` 和 :meth:`date.isoformat`。"

#: ../../library/datetime.rst:797
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a format "
"string for a :class:`.date` object in :ref:`formatted string literals "
"<f-strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
"与 :meth:`.date.strftime` 相同。 此方法使得在 :ref:`格式化字符串字面值 <f-strings>` 中以及使用 "
":meth:`str.format` 时为 :class:`.date` 对象指定格式字符串成为可能。 另请参阅 :ref:`strftime-"
"strptime-behavior` 和 :meth:`date.isoformat`。"

#: ../../library/datetime.rst:803
msgid "Examples of Usage: :class:`date`"
msgstr ":class:`date` 用法示例"

#: ../../library/datetime.rst:805
msgid "Example of counting days to an event::"
msgstr "计算距离特定事件天数的例子::"

#: ../../library/datetime.rst:807
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"

#: ../../library/datetime.rst:824
msgid "More examples of working with :class:`date`:"
msgstr "使用 :class:`date` 的更多例子："

#: ../../library/datetime.rst:826
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 1. 1. 0001 之后的第 730920 天\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # 有关格式化字符串输出的方法\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # 用于提取不同历法中的‘部分’的方法\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # 年\n"
"3                   # 月\n"
"11                  # 日\n"
"0\n"
"0\n"
"0\n"
"0                   # 周序号 (0 = 星期一)\n"
"70                  # 当年的第 70 天\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO 年\n"
"11                  # ISO 第几周\n"
"1                   # ISO 周序号 ( 1 = 星期一 )\n"
"\n"
">>> # 日期对象是不可变的；所有操作都将产生一个新对象\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"

#: ../../library/datetime.rst:873
msgid ":class:`.datetime` Objects"
msgstr ":class:`.datetime` 对象"

#: ../../library/datetime.rst:875
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
":class:`.datetime` 对象是包含来自 :class:`date` 对象和 :class:`.time` 对象的所有信息的单一对象。"

#: ../../library/datetime.rst:878
msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in "
"every day."
msgstr ""
"与 :class:`date` 对象一样，:class:`.datetime` 假定当前的格列高利历向前后两个方向无限延伸；与 "
":class:`.time` 对象一样，:class:`.datetime` 假定每一天恰好有 3600\\*24 秒。"

#: ../../library/datetime.rst:882
msgid "Constructor:"
msgstr "构造器 ："

#: ../../library/datetime.rst:886
msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"*year*, *month* 和 *day* 参数是必须的。 *tzinfo* 可以是 ``None`` 或者是一个 :class:`tzinfo` "
"子类的实例。 其余的参数必须是在下面范围内的整数："

#: ../../library/datetime.rst:890
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: ../../library/datetime.rst:891
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: ../../library/datetime.rst:892
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= 指定年月的天数``,"

#: ../../library/datetime.rst:893 ../../library/datetime.rst:1771
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: ../../library/datetime.rst:894 ../../library/datetime.rst:1772
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: ../../library/datetime.rst:895 ../../library/datetime.rst:1773
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: ../../library/datetime.rst:896 ../../library/datetime.rst:1774
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: ../../library/datetime.rst:897 ../../library/datetime.rst:1775
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: ../../library/datetime.rst:901 ../../library/datetime.rst:1342
#: ../../library/datetime.rst:1920
msgid "Added the *fold* parameter."
msgstr "增加了 *fold* 形参。"

#: ../../library/datetime.rst:908
msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr "返回表示当前地方时的 date 和 time，其中 :attr:`.tzinfo` 为 ``None``。"

#: ../../library/datetime.rst:910
msgid "Equivalent to::"
msgstr "等价于::"

#: ../../library/datetime.rst:912
msgid "datetime.fromtimestamp(time.time())"
msgstr "datetime.fromtimestamp(time.time())"

#: ../../library/datetime.rst:914
msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr "另请参阅 :meth:`now`, :meth:`fromtimestamp`。"

#: ../../library/datetime.rst:916
msgid ""
"This method is functionally equivalent to :meth:`now`, but without a ``tz`` "
"parameter."
msgstr "此方法的功能等价于 :meth:`now`，但是不带 ``tz`` 形参。"

#: ../../library/datetime.rst:921
msgid "Return the current local date and time."
msgstr "返回表示当前地方时的 date 和 time 对象。"

#: ../../library/datetime.rst:923
msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like "
":meth:`today`, but, if possible, supplies more precision than can be gotten "
"from going through a :func:`time.time` timestamp (for example, this may be "
"possible on platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"如果可选参数 *tz* 为 ``None`` 或未指定，这就类似于 :meth:`today`，但该方法会在可能的情况下提供比通过 "
":func:`time.time` 时间戳所获时间值更高的精度（例如，在提供了 C :c:func:`gettimeofday` "
"函数的平台上就可以做到这一点）。"

#: ../../library/datetime.rst:929
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time zone."
msgstr ""
"如果 *tz* 不为 ``None``，它必须是 :class:`tzinfo` 子类的一个实例，并且当前日期和时间将被转换到 *tz* 时区。"

#: ../../library/datetime.rst:932
msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr "此函数可以替代 :meth:`today` 和 :meth:`utcnow`。"

#: ../../library/datetime.rst:936
msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr "对 :meth:`!datetime.now` 的后续调用可能由于下层时钟的精度返回相同的时刻。"

#: ../../library/datetime.rst:941
msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr "返回表示当前 UTC 时间的 date 和 time，其中 :attr:`.tzinfo` 为 ``None``。"

#: ../../library/datetime.rst:943
msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"这类似于 :meth:`now`，但返回的是当前 UTC 日期和时间，类型为简单型 :class:`.datetime` 对象。 感知型的当前 UTC "
"日期时间可通过调用 ``datetime.now(timezone.utc)`` 来获得。 另请参阅 :meth:`now`。"

#: ../../library/datetime.rst:949
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in"
" UTC. As such, the recommended way to create an object representing the "
"current time in UTC is by calling ``datetime.now(timezone.utc)``."
msgstr ""
"由于简单型 ``datetime`` 对象会被许多 ``datetime`` 方法当作本地时间来处理，最好是使用感知型日期时间对象来表示 UTC 时间。"
" 因此，创建表示当前 UTC 时间的对象的推荐方式是通过调用 ``datetime.now(timezone.utc)``。"

#: ../../library/datetime.rst:956
msgid "Use :meth:`datetime.now` with :const:`UTC` instead."
msgstr "改用带 :const:`UTC` 的 :meth:`datetime.now`。"

#: ../../library/datetime.rst:961
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as"
" is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`.datetime` object is naive."
msgstr ""
"返回 POSIX 时间戳对应的本地日期和时间，如 :func:`time.time` 返回的。 如果可选参数 *tz* 指定为 ``None`` "
"或未指定，时间戳将转换为平台的本地日期和时间，并且返回的 :class:`.datetime` 对象将为简单型。"

#: ../../library/datetime.rst:966
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"如果 *tz* 不为 ``None``，它必须是 :class:`tzinfo` 子类的一个实例，并且时间戳将被转换到 *tz* 指定的时区。"

#: ../../library/datetime.rst:969
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions, and :exc:`OSError` on :c:func:`localtime` or "
":c:func:`gmtime` failure. It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by "
":meth:`fromtimestamp`, and then it's possible to have two timestamps "
"differing by a second that yield identical :class:`.datetime` objects. This "
"method is preferred over :meth:`utcfromtimestamp`."
msgstr ""
":meth:`fromtimestamp` 可能会引发 :exc:`OverflowError`，如果时间戳数值超出所在平台 C "
":c:func:`localtime` 或 :c:func:`gmtime` 函数的支持范围的话，并会在 :c:func:`localtime` 或 "
":c:func:`gmtime` 报错时引发 :exc:`OSError`。 通常该数值会被限制在 1970 年至 2038 年之间。 "
"请注意在时间戳概念包含闰秒的非 POSIX 系统上，闰秒会被 :meth:`fromtimestamp` "
"所忽略，结果可能导致两个相差一秒的时间戳产生相同的 :class:`.datetime` 对象。 相比 :meth:`utcfromtimestamp`"
" 更推荐使用此方法。"

#: ../../library/datetime.rst:980
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions. Raise :exc:`OSError` instead of "
":exc:`ValueError` on :c:func:`localtime` or :c:func:`gmtime` failure."
msgstr ""
"引发 :exc:`OverflowError` 而不是 :exc:`ValueError`，如果时间戳数值超出所在平台 C "
":c:func:`localtime` 或 :c:func:`gmtime` 函数的支持范围的话。 并会在 :c:func:`localtime` 或 "
":c:func:`gmtime` 出错时引发 :exc:`OSError` 而不是 :exc:`ValueError`。"

#: ../../library/datetime.rst:987
msgid ""
":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ":meth:`fromtimestamp` 可能返回 :attr:`.fold` 值设为 1 的实例。"

#: ../../library/datetime.rst:992
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, with"
" :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
"返回对应于 POSIX 时间戳的 UTC :class:`.datetime`，其中 :attr:`.tzinfo` 值为 ``None``。 "
"（结果为简单型对象。）"

#: ../../library/datetime.rst:995
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of"
" values supported by the platform C :c:func:`gmtime` function, and "
":exc:`OSError` on :c:func:`gmtime` failure. It's common for this to be "
"restricted to years in 1970 through 2038."
msgstr ""
"这可能引发 :exc:`OverflowError`，如果时间戳数值超出所在平台 C :c:func:`gmtime` 函数的支持范围的话，并会在 "
":c:func:`gmtime` 报错时引发 :exc:`OSError`。 通常该数值会被限制在 1970 至 2038 年之间。"

#: ../../library/datetime.rst:1000
msgid ""
"To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr "要得到一个感知型 :class:`.datetime` 对象，应调用 :meth:`fromtimestamp`::"

#: ../../library/datetime.rst:1002
msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr "datetime.fromtimestamp(timestamp, timezone.utc)"

#: ../../library/datetime.rst:1004
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr "在 POSIX 兼容的平台上，它等价于以下表达式::"

#: ../../library/datetime.rst:1007
msgid ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"

#: ../../library/datetime.rst:1009
msgid ""
"except the latter formula always supports the full years range: between "
":const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "不同之处在于后一种形式总是支持完整年份范围：从 :const:`MINYEAR` 到 :const:`MAXYEAR` 的开区间。"

#: ../../library/datetime.rst:1014
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in"
" UTC. As such, the recommended way to create an object representing a "
"specific timestamp in UTC is by calling ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``."
msgstr ""
"由于简单型 ``datetime`` 对象会被许多 ``datetime`` 方法当作本地时间来处理，最好是使用感知型日期时间对象来表示 UTC 时间。"
" 因此，创建表示特定 UTC 时间戳的日期时间对象的推荐方式是通过调用 ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``。"

#: ../../library/datetime.rst:1020
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`gmtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on "
":c:func:`gmtime` failure."
msgstr ""
"引发 :exc:`OverflowError` 而不是 :exc:`ValueError`，如果时间戳数值超出所在平台 C "
":c:func:`gmtime` 函数的支持范围的话。 并会在 :c:func:`gmtime` 出错时引发 :exc:`OSError` 而不是 "
":exc:`ValueError`。"

#: ../../library/datetime.rst:1028
msgid "Use :meth:`datetime.fromtimestamp` with :const:`UTC` instead."
msgstr "改用带 :const:`UTC` 的 :meth:`datetime.fromtimestamp`。"

#: ../../library/datetime.rst:1033
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`.tzinfo` "
"is ``None``."
msgstr ""
"返回对应于预期格列高利历序号的 :class:`.datetime`，其中公元 1 年 1 月 1 日的序号为 1。 除非 ``1 <= ordinal"
" <= datetime.max.toordinal()`` 否则会引发 :exc:`ValueError`。 结果的 hour, minute, "
"second 和 microsecond 值均为 0，并且 :attr:`.tzinfo` 值为 ``None``。"

#: ../../library/datetime.rst:1041
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to "
"the given :class:`date` object's, and whose time components are equal to the"
" given :class:`.time` object's. If the *tzinfo* argument is provided, its "
"value is used to set the :attr:`.tzinfo` attribute of the result, otherwise "
"the :attr:`~.time.tzinfo` attribute of the *time* argument is used.  If the "
"*date* argument is a :class:`.datetime` object, its time components and "
":attr:`.tzinfo` attributes are ignored."
msgstr ""
"返回一个新的 :class:`.datetime` 对象，其日期部分等于给定的 :class:`date` 对象的值，而其时间部分等于给定的 "
":class:`.time` 对象的值。 如果提供了 *tzinfo* 参数，其值会被用来设置结果的 :attr:`.tzinfo` 属性，否则将使用 "
"*time* 参数的 :attr:`~.time.tzinfo` 属性。 如果 *date* 参数是一个 :class:`.datetime` "
"对象，则其时间部分和 :attr:`.tzinfo` 属性将被忽略。"

#: ../../library/datetime.rst:1049
msgid ""
"For any :class:`.datetime` object ``d``, ``d == datetime.combine(d.date(), "
"d.time(), d.tzinfo)``."
msgstr ""
"对于任意 :class:`.datetime` 对象 ``d``，``d == datetime.combine(d.date(), d.time(),"
" d.tzinfo)``。"

#: ../../library/datetime.rst:1052
msgid "Added the *tzinfo* argument."
msgstr "增加了 *tzinfo* 参数。"

#: ../../library/datetime.rst:1058
msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr "返回一个对应于以任何有效的 8601 格式给出的 *date_string* 的 :class:`.datetime`，下列格式除外:"

#: ../../library/datetime.rst:1061 ../../library/datetime.rst:1871
msgid "Time zone offsets may have fractional seconds."
msgstr "时区时差可能会有带小数的秒值。"

#: ../../library/datetime.rst:1062
msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr "``T`` 分隔符可以用任何单个 unicode 字符来替换。"

#: ../../library/datetime.rst:1063 ../../library/datetime.rst:1876
msgid "Fractional hours and minutes are not supported."
msgstr "带小数的时和分是不受支持的。"

#: ../../library/datetime.rst:1072
msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"

#: ../../library/datetime.rst:1094
msgid ""
"Previously, this method only supported formats that could be emitted by "
":meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
"在之前版本中，此方法仅支持可以由 :meth:`date.isoformat` 或 :meth:`datetime.isoformat` 发出的格式。"

#: ../../library/datetime.rst:1101
msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date specified"
" by year, week and day. The non-date components of the datetime are "
"populated with their normal default values. This is the inverse of the "
"function :meth:`datetime.isocalendar`."
msgstr ""
"返回以 year, week 和 day 值指明的 ISO 历法日期所对应的 :class:`.datetime`。 该datetime "
"对象的非日期部分将使用其标准默认值来填充。 这是函数 :meth:`datetime.isocalendar` 的逆操作。"

#: ../../library/datetime.rst:1110
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed according"
" to *format*."
msgstr "返回一个对应于 *date_string*，根据 *format* 进行解析得到的 :class:`.datetime` 对象。"

#: ../../library/datetime.rst:1113
msgid ""
"If *format* does not contain microseconds or time zone information, this is "
"equivalent to::"
msgstr "如果 *format* 不包含微秒或时区信息，这将等价于::"

#: ../../library/datetime.rst:1115 ../../library/datetime.rst:2596
msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "datetime(*(time.strptime(date_string, format)[0:6]))"

#: ../../library/datetime.rst:1117
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed by"
" :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and "
":meth:`datetime.fromisoformat`."
msgstr ""
"如果 date_string 和 format 无法被 :func:`time.strptime` 解析或它返回一个不是时间元组的值则将引发 "
":exc:`ValueError`。 另请参阅 :ref:`strftime-strptime-behavior` 和 "
":meth:`datetime.fromisoformat`。"

#: ../../library/datetime.rst:1124
msgid ""
"If *format* specifies a day of month without a year a "
":exc:`DeprecationWarning` is now emitted.  This is to avoid a quadrennial "
"leap year bug in code seeking to parse only a month and day as the default "
"year used in absence of one in the format is not a leap year. Such *format* "
"values may raise an error as of Python 3.15.  The workaround is to always "
"include a year in your *format*.  If parsing *date_string* values that do "
"not have a year, explicitly add a year that is a leap year before parsing:"
msgstr ""
"现在如果 *format* 指定了月份日期但没有年份则会发出 :exc:`DeprecationWarning`。 "
"这是为了避免在代码中当格式缺少年份仅能解析月份和日期时将使用非闰年的默认年份而导致四年轮回的闰年程序错误。 这样的 *format* 值在 Python"
" 3.15 将可能引发错误。 绕过此问题的办法是始终在你的 *format* 中包括年份。 如果是解析不带年份的 *date_string* "
"值，则在解析之前显式地添加一个属于闰年的年份："

#: ../../library/datetime.rst:1133
msgid ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"

#: ../../library/datetime.rst:1146
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr "最早的可表示 :class:`.datetime`，``datetime(MINYEAR, 1, 1, tzinfo=None)``。"

#: ../../library/datetime.rst:1152
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23,"
" 59, 59, 999999, tzinfo=None)``."
msgstr ""
"最晚的可表示 :class:`.datetime`，``datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, "
"tzinfo=None)``。"

#: ../../library/datetime.rst:1158
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr "两个不相等的 :class:`.datetime` 对象之间可能的最小间隔，``timedelta(microseconds=1)``。"

#: ../../library/datetime.rst:1181 ../../library/datetime.rst:1804
msgid "In ``range(24)``."
msgstr "取值范围是 ``range(24)``。"

#: ../../library/datetime.rst:1186 ../../library/datetime.rst:1191
#: ../../library/datetime.rst:1809 ../../library/datetime.rst:1814
msgid "In ``range(60)``."
msgstr "取值范围是 ``range(60)``。"

#: ../../library/datetime.rst:1196 ../../library/datetime.rst:1819
msgid "In ``range(1000000)``."
msgstr "取值范围是 ``range(1000000)``。"

#: ../../library/datetime.rst:1201
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr "作为 *tzinfo* 参数被传给 :class:`.datetime` 构造器的对象，如果没有传入值则为 ``None``。"

#: ../../library/datetime.rst:1207 ../../library/datetime.rst:1830
msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated interval. "
"(A repeated interval occurs when clocks are rolled back at the end of "
"daylight saving time or when the UTC offset for the current zone is "
"decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall "
"time representation."
msgstr ""
"取值范围是 ``[0, 1]``。 用于在重复的时间段中消除边界时间的歧义。 （当夏令时结束时回拨时钟或由于政治原因导致当前时区的 UTC "
"时差减少就会出现重复时间段。） 取值 0 和 1 分别表示两个相同边界时间表示形式的前一个和后一个时间。"

#: ../../library/datetime.rst:1220
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: ../../library/datetime.rst:1220 ../../library/datetime.rst:2443
#: ../../library/datetime.rst:2448 ../../library/datetime.rst:2460
#: ../../library/datetime.rst:2465 ../../library/datetime.rst:2525
#: ../../library/datetime.rst:2530 ../../library/datetime.rst:2534
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/datetime.rst:1222
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: ../../library/datetime.rst:1222 ../../library/datetime.rst:2476
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/datetime.rst:1224
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 == datetime2``"
msgstr "``datetime1 == datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 != datetime2``"
msgstr "``datetime1 != datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 > datetime2``"
msgstr "``datetime1 > datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 <= datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 >= datetime2``"
msgstr "``datetime1 >= datetime2``"

#: ../../library/datetime.rst:1236
msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. The result has the same :attr:`~.datetime.tzinfo` "
"attribute as the input datetime, and ``datetime2 - datetime1 == timedelta`` "
"after. :exc:`OverflowError` is raised if ``datetime2.year`` would be smaller"
" than :const:`MINYEAR` or larger than :const:`MAXYEAR`. Note that no time "
"zone adjustments are done even if the input is an aware object."
msgstr ""
"``datetime2`` 是 ``datetime1`` 去掉 ``timedelta`` 时间段的结果，如果 ``timedelta.days > "
"0`` 则是在时间线上前进，如果 ``timedelta.days < 0`` 则时在时间线上后退。 该结果具有与输入的 datetime 相同的 "
":attr:`~.datetime.tzinfo` 属性，并且运算后 ``datetime2 - datetime1 == timedelta``。 "
"如果 ``datetime2.year`` 将要小于 :const:`MINYEAR` 或大于 :const:`MAXYEAR` 则会引发 "
":exc:`OverflowError`。 请注意即使输入的是一个感知型对象该方法也不会进行时区调整。"

#: ../../library/datetime.rst:1245
msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == datetime1``."
" As for addition, the result has the same :attr:`~.datetime.tzinfo` "
"attribute as the input datetime, and no time zone adjustments are done even "
"if the input is aware."
msgstr ""
"计算 ``datetime2`` 使得 ``datetime2 + timedelta == datetime1``。 与相加操作一样，结果具有与输入的"
" datetime 相同的 :attr:`~.datetime.tzinfo` 属性，即使输入的是一个感知型对象该方法也不会进行时区调整。"

#: ../../library/datetime.rst:1250
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware and "
"the other is naive, :exc:`TypeError` is raised."
msgstr ""
"从一个 :class:`.datetime` 减去一个 :class:`.datetime` 仅对两个操作数均为简单型或均为感知型时有定义。 "
"如果一个是感知型而另一个是简单型，则会引发 :exc:`TypeError`。"

#: ../../library/datetime.rst:1254
msgid ""
"If both are naive, or both are aware and have the same "
":attr:`~.datetime.tzinfo` attribute, the :attr:`~.datetime.tzinfo` "
"attributes are ignored, and the result is a :class:`timedelta` object ``t`` "
"such that ``datetime2 + t == datetime1``. No time zone adjustments are done "
"in this case."
msgstr ""
"如果两个操作数都是简单型，或都是感知型并且具有相同的 :attr:`~.datetime.tzinfo` 属性，则 "
":attr:`~.datetime.tzinfo` 属性会被忽略，并且结果会是一个使得 ``datetime2 + t == datetime1`` 的"
" :class:`timedelta` 对象 ``t``。 在此情况下不会进行时区调整。"

#: ../../library/datetime.rst:1259
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` attributes, "
"``a-b`` acts as if ``a`` and ``b`` were first converted to naive UTC "
"datetimes. The result is ``(a.replace(tzinfo=None) - a.utcoffset()) - "
"(b.replace(tzinfo=None) - b.utcoffset())`` except that the implementation "
"never overflows."
msgstr ""
"如果两者均为感知型且具有不同的 :attr:`~.datetime.tzinfo` 属性，``a-b`` 的效果就如同 ``a`` 和 ``b`` "
"首先被转换为简单型 UTC 日期时间。 结果将为 ``(a.replace(tzinfo=None) - a.utcoffset()) - "
"(b.replace(tzinfo=None) - b.utcoffset())``，不同之处在于具体实现绝对不会溢出。"

#: ../../library/datetime.rst:1265
msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ":class:`.datetime` 对象如果在考虑时区的情况下表示相同的日期和时间那么就是相等的。"

#: ../../library/datetime.rst:1268
msgid "Naive and aware :class:`!datetime` objects are never equal."
msgstr "简单型和感知型 :class:`!datetime` 对象绝不会相等。"

#: ../../library/datetime.rst:1270
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows. :class:`!datetime` instances in a repeated "
"interval are never equal to :class:`!datetime` instances in other time zone."
msgstr ""
"如果两个操作数均为感知型，且具有相同的 :attr:`!tzinfo` 属性，则 :attr:`!tzinfo` 和 "
":attr:`~.datetime.fold` 属性将被忽略并对基本日期时间值进行比较。 如果两个操作数均为感知型且具有不同的 "
":attr:`~.datetime.tzinfo` 属性，则比较行为将如同两个操作数首先被转换为 UTC，不同之处是具体实现绝对不会溢出。 "
"具有重复间隔的 :class:`!datetime` 实例绝对不会等于属性其他时区的 :class:`!datetime` 实例。"

#: ../../library/datetime.rst:1280
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time, taking into account the time zone."
msgstr ""
"在考虑时区的情况下，当 *datetime1* 的时间在 *datetime2* 之前则认为 *datetime1* 小于 *datetime2*。"

#: ../../library/datetime.rst:1283
msgid ""
"Order comparison between naive and aware :class:`.datetime` objects raises "
":exc:`TypeError`."
msgstr "简单型和感知型 :class:`.datetime` 对象之间的顺序比较将会引发 :exc:`TypeError`。"

#: ../../library/datetime.rst:1286
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows."
msgstr ""
"如果两个操作数均为感知型，且具有相同的 :attr:`!tzinfo` 属性，则 :attr:`!tzinfo` 和 "
":attr:`~.datetime.fold` 属性将被忽略并对基本日期时间值进行比较。 如果两个操作数均为感知型且具有不同的 "
":attr:`~.datetime.tzinfo` 属性，则比较行为将如同两个操作数首先被转换为 UTC 日期时间，不同之处是具体实现绝对不会溢出。"

#: ../../library/datetime.rst:1293
msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances "
"don't raise :exc:`TypeError`."
msgstr "感知型和简单型 :class:`.datetime` 实例之间的相等比较不会引发 :exc:`TypeError`。"

#: ../../library/datetime.rst:1309
msgid "Return :class:`date` object with same year, month and day."
msgstr "返回具有同样 year, month 和 day 值的 :class:`date` 对象。"

#: ../../library/datetime.rst:1314
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond and"
" fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"返回具有同样 hour, minute, second, microsecond 和 fold 值的 :class:`.time` 对象。 "
":attr:`.tzinfo` 值为 ``None``。 另请参见 :meth:`timetz` 方法。"

#: ../../library/datetime.rst:1317 ../../library/datetime.rst:1326
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "fold 值会被复制给返回的 :class:`.time` 对象。"

#: ../../library/datetime.rst:1323
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond, "
"fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"返回具有同样 hour, minute, second, microsecond, fold 和 tzinfo 属性性的 :class:`.time` "
"对象。 另请参见 :meth:`time` 方法。"

#: ../../library/datetime.rst:1334
msgid ""
"Return a new :class:`datetime` object with the same attributes, but with "
"specified parameters updated. Note that ``tzinfo=None`` can be specified to "
"create a naive datetime from an aware datetime with no conversion of date "
"and time data."
msgstr ""
"返回一个具有同样属性的新的 :class:`datetime` 对象，但更新指定的形参。 请注意可以通过指定 ``tzinfo=None`` "
"基于一个感知型 datetime 创建一个简单型 datetime 而不必转换日期和时间数据。"

#: ../../library/datetime.rst:1339
msgid ""
":class:`.datetime` objects are also supported by generic function "
":func:`copy.replace`."
msgstr ":class:`.datetime` 对象也被泛型函数 :func:`copy.replace` 所支持。"

#: ../../library/datetime.rst:1348
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute *tz*, "
"adjusting the date and time data so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""
"返回一个具有新的 :attr:`.tzinfo` 属性 *tz* 的 :class:`.datetime` 对象，并会调整日期和时间数据使得结果对应的 "
"UTC 时间与 *self* 相同，但为 *tz* 时区的本地时间。"

#: ../../library/datetime.rst:1352
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and its"
" :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. If "
"*self* is naive, it is presumed to represent time in the system time zone."
msgstr ""
"如果给出了 *tz*，则它必须是一个 :class:`tzinfo` 子类的实例，并且其 :meth:`utcoffset` 和 :meth:`dst`"
" 方法不可返回 ``None``。 如果 *self* 为简单型，它会被假定为基于系统时区表示的时间。"

#: ../../library/datetime.rst:1356
msgid ""
"If called without arguments (or with ``tz=None``) the system local time zone"
" is assumed for the target time zone. The ``.tzinfo`` attribute of the "
"converted datetime instance will be set to an instance of :class:`timezone` "
"with the zone name and offset obtained from the OS."
msgstr ""
"如果调用时不传入参数 (或传入 ``tz=None``) 则将假定目标时区为系统的本地时区。 转换后 datetime 实例的 ``.tzinfo`` "
"属性将被设为一个 :class:`timezone` 实例，时区名称和时差值将从 OS 获取。"

#: ../../library/datetime.rst:1361
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time data is performed. Else the result is local time "
"in the time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have the same"
" date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"如果 ``self.tzinfo`` 为 *tz*，``self.astimezone(tz)`` 等于 *self*: 不会对日期或时间数据进行调整。"
" 否则结果为 *tz* 时区的本地时间，代表的 UTC 时间与 *self* 相同：在 ``astz = dt.astimezone(tz)`` "
"之后，``astz - astz.utcoffset()`` 将具有与 ``dt - dt.utcoffset()`` 相同的日期和时间数据。"

#: ../../library/datetime.rst:1367
msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a datetime "
"*dt* without adjustment of date and time data, use "
"``dt.replace(tzinfo=tz)``. If you merely want to remove the "
":class:`!timezone` object from an aware datetime *dt* without conversion of "
"date and time data, use ``dt.replace(tzinfo=None)``."
msgstr ""
"如果你只是想要附加一个 :class:`timezone` 对象 *tz* 到一个 datetime 对象 *dt* 而不调整日期和时间数据，请使用 "
"``dt.replace(tzinfo=tz)``。 如果你只是想要从一个感知型 datetime 对象 *dt* 移除 "
":class:`!timezone` 对象，请使用 ``dt.replace(tzinfo=None)``。"

#: ../../library/datetime.rst:1372
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a "
":class:`tzinfo` subclass to affect the result returned by "
":meth:`astimezone`. Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"请注意默认的 :meth:`tzinfo.fromutc` 方法在 :class:`tzinfo` 的子类中可以被重写，从而影响 "
":meth:`astimezone` 的返回结果。 如果忽略出错的情况，:meth:`astimezone` 的行为就类似于::"

#: ../../library/datetime.rst:1376
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # 将 self 转换为 UTC，并附加新的时区对象\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # 从 UTC 转换为 tz 的地方时。\n"
"    return tz.fromutc(utc)"

#: ../../library/datetime.rst:1384
msgid "*tz* now can be omitted."
msgstr "*tz* 现在可以被省略。"

#: ../../library/datetime.rst:1387
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that are "
"presumed to represent system local time."
msgstr ":meth:`astimezone` 方法可以由简单型实例调用，这将假定其表示本地时间。"

#: ../../library/datetime.rst:1394
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(self)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude less "
"than one day."
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.utcoffset(self)``，并且在后者不返回 ``None`` 或者一个幅度小于一天的 "
":class:`timedelta` 对象时将引发异常。"

#: ../../library/datetime.rst:1398 ../../library/datetime.rst:1993
#: ../../library/datetime.rst:2100 ../../library/datetime.rst:2345
#: ../../library/datetime.rst:2357 ../../library/datetime.rst:2669
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "UTC 时差不再限制为一个整数分钟值。"

#: ../../library/datetime.rst:1404
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(self)``, and raises an exception if the latter doesn't "
"return ``None`` or a :class:`timedelta` object with magnitude less than one "
"day."
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.dst(self)``，并且在后者不返回 ``None`` 或者一个幅度小于一天的 :class:`timedelta` "
"对象时将引发异常。"

#: ../../library/datetime.rst:1408 ../../library/datetime.rst:2003
#: ../../library/datetime.rst:2154
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "DST 差值不再限制为一个整数分钟值。"

#: ../../library/datetime.rst:1414
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(self)``, raises an exception if the latter doesn't "
"return ``None`` or a string object,"
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.tzname(self)``，如果后者不返回 ``None`` 或者一个字符串对象则将引发异常。"

#: ../../library/datetime.rst:1425
msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"

#: ../../library/datetime.rst:1429
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st. The "
":attr:`~time.struct_time.tm_isdst` flag of the result is set according to "
"the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or :meth:`dst` returns "
"``None``, :attr:`!tm_isdst` is set to ``-1``; else if :meth:`dst` returns a "
"non-zero value, :attr:`!tm_isdst` is set to 1; else :attr:`!tm_isdst` is set"
" to 0."
msgstr ""
"其中 ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` "
"是日期在当前年份中的序号，起始值 1 表示 1 月 1 日。 结果的 :attr:`~time.struct_time.tm_isdst` 旗标会根据 "
":meth:`dst` 方法来设定：如果 :attr:`.tzinfo` 为 ``None`` 或 :meth:`dst` 返回 ``None``，则 "
":attr:`!tm_isdst` 将设为 ``-1``；否则如果 :meth:`dst` 返回非零值，则 :attr:`!tm_isdst` 将设为 "
"1；在其他情况下 :attr:`!tm_isdst` 将设为 0。"

#: ../../library/datetime.rst:1440
msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as "
"``d.timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is forced "
"to 0 regardless of what ``d.dst()`` returns. DST is never in effect for a "
"UTC time."
msgstr ""
"如果 :class:`.datetime` 实例 ``d`` 为简单型，这将与 ``d.timetuple()`` 相当，区别在于 "
":attr:`~.time.struct_time.tm_isdst` 会被强制设为 0 而无视 ``d.dst()`` 返回值。 DST 对于 UTC"
" 时间必定无效。"

#: ../../library/datetime.rst:1444
msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting "
"``d.utcoffset()``, and a :class:`time.struct_time` for the normalized time "
"is returned. :attr:`!tm_isdst` is forced to 0. Note that an "
":exc:`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or "
"``MAXYEAR`` and UTC adjustment spills over a year boundary."
msgstr ""
"如果 ``d`` 为感知型，则 ``d`` 会通过减去 ``d.utcoffset()`` 来标准化为 UTC 时间，并返回表示该标准化时间的 "
":class:`time.struct_time`。 :attr:`!tm_isdst` 将被强制设为 0。 请注意如果 ``d.year`` 为 "
"``MINYEAR`` 或 ``MAXYEAR`` 且 UTC 调整超出一年的边界则可能引发 :exc:`OverflowError`。"

#: ../../library/datetime.rst:1453
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in"
" UTC; as a result, using :meth:`datetime.utctimetuple` may give misleading "
"results. If you have a naive ``datetime`` representing UTC, use "
"``datetime.replace(tzinfo=timezone.utc)`` to make it aware, at which point "
"you can use :meth:`.datetime.timetuple`."
msgstr ""
"由于简单型 ``datetime`` 对象会被许多 ``datetime`` 方法当作本地时间来处理，最好是使用感知型日期时间来表示 UTC "
"时间；因此，使用 :meth:`datetime.utctimetuple` 可能会给出误导性的结果。 如果你有一个表示 UTC 的简单型 "
"``datetime``，请使用 ``datetime.replace(tzinfo=timezone.utc)`` 将其改为感知型，这样你才能使用 "
":meth:`.datetime.timetuple`。"

#: ../../library/datetime.rst:1462
msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as "
"``self.date().toordinal()``."
msgstr "返回日期的预期格列高利历序号。 与 ``self.date().toordinal()`` 相同。"

#: ../../library/datetime.rst:1467
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. The"
" return value is a :class:`float` similar to that returned by "
":func:`time.time`."
msgstr ""
"返回对应于 :class:`.datetime` 实例的 POSIX 时间戳。 此返回值是与 :func:`time.time` 返回值类似的 "
":class:`float` 对象。"

#: ../../library/datetime.rst:1471
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time and "
"this method relies on the platform C :c:func:`mktime` function to perform "
"the conversion. Since :class:`.datetime` supports wider range of values than"
" :c:func:`mktime` on many platforms, this method may raise "
":exc:`OverflowError` or :exc:`OSError` for times far in the past or far in "
"the future."
msgstr ""
"简单型 :class:`.datetime` 实例会被假定为代表本地时间并且此方法依赖于平台的 C :c:func:`mktime` 函数来执行转换。 "
"由于在许多平台上 :class:`.datetime` 支持的取值范围比 :c:func:`mktime` "
"更广，对于极其遥远的过去或未来此方法可能会引发 :exc:`OverflowError` 或 :exc:`OSError`。"

#: ../../library/datetime.rst:1478
msgid ""
"For aware :class:`.datetime` instances, the return value is computed as::"
msgstr "对于感知型 :class:`.datetime` 实例，返回值的计算方式为::"

#: ../../library/datetime.rst:1481
msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"

#: ../../library/datetime.rst:1485
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ":meth:`timestamp` 方法使用 :attr:`.fold` 属性来消除重复间隔中的时间歧义。"

#: ../../library/datetime.rst:1491
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive "
":class:`.datetime` instance representing UTC time. If your application uses "
"this convention and your system time zone is not set to UTC, you can obtain "
"the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"没有一个方法能直接从表示 UTC 时间的简单型 :class:`.datetime` 实例获取 POSIX 时间戳。 "
"如果你的应用程序使用此惯例并且你的系统时区不是设为 UTC，你可以通过提供 ``tzinfo=timezone.utc`` 来获取 POSIX "
"时间戳::"

#: ../../library/datetime.rst:1497
msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"

#: ../../library/datetime.rst:1499
msgid "or by calculating the timestamp directly::"
msgstr "或者通过直接计算时间戳::"

#: ../../library/datetime.rst:1501
msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"

#: ../../library/datetime.rst:1505
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6."
" The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"返回一个整数代表星期几，星期一为 0，星期天为 6。 相当于 ``self.date().weekday()``。 另请参阅 "
":meth:`isoweekday`。"

#: ../../library/datetime.rst:1511
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7."
" The same as ``self.date().isoweekday()``. See also :meth:`weekday`, "
":meth:`isocalendar`."
msgstr ""
"返回一个整数代表星期几，星期一为 1，星期天为 7。 相当于 ``self.date().isoweekday()``。 另请参阅 "
":meth:`weekday`, :meth:`isocalendar`。"

#: ../../library/datetime.rst:1518
msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` and "
"``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"返回一个由三部分组成的 :term:`named tuple`: ``year``, ``week`` 和 ``weekday``。 等同于 "
"``self.date().isocalendar()``。"

#: ../../library/datetime.rst:1524
msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr "返回一个以 ISO 8601 格式表示的日期和时间字符串："

#: ../../library/datetime.rst:1526
msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``YYYY-MM-DDTHH:MM:SS.ffffff``，如果 :attr:`microsecond` 不为 0"

#: ../../library/datetime.rst:1527
msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS``，如果 :attr:`microsecond` 为 0"

#: ../../library/datetime.rst:1529
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, giving "
"the UTC offset:"
msgstr "如果 :meth:`utcoffset` 返回值不为 ``None``，则添加一个字符串来给出 UTC 时差："

#: ../../library/datetime.rst:1532
msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` "
"is not 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``，如果 :attr:`microsecond` 不为"
" 0"

#: ../../library/datetime.rst:1534
msgid ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``，如果 :attr:`microsecond` 为 0"

#: ../../library/datetime.rst:1538
msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"

#: ../../library/datetime.rst:1544
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result. For example::"
msgstr "可选参数 *sep* (默认为 ``'T'``) 为单个分隔字符，会被放在结果的日期和时间两部分之间。 例如::"

#: ../../library/datetime.rst:1547
msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"

#: ../../library/datetime.rst:1558 ../../library/datetime.rst:1933
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be one"
" of the following:"
msgstr "可选参数 *timespec* 要包含的额外时间组件值 (默认为 ``'auto'``)。它可以是以下值之一："

#: ../../library/datetime.rst:1562 ../../library/datetime.rst:1937
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: 如果 :attr:`microsecond` 为 0 则与 ``'seconds'`` 相同，否则与 "
"``'microseconds'`` 相同。"

#: ../../library/datetime.rst:1564 ../../library/datetime.rst:1939
msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr "``'hours'``: 以两个数码的 ``HH`` 格式 包含 :attr:`hour`。"

#: ../../library/datetime.rst:1565 ../../library/datetime.rst:1940
msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` format."
msgstr "``'minutes'``: 以 ``HH:MM`` 格式包含 :attr:`hour` 和 :attr:`minute`。"

#: ../../library/datetime.rst:1566 ../../library/datetime.rst:1941
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` in "
"``HH:MM:SS`` format."
msgstr ""
"``'seconds'``: 以 ``HH:MM:SS`` 格式包含 :attr:`hour`, :attr:`minute` 和 "
":attr:`second`。"

#: ../../library/datetime.rst:1568 ../../library/datetime.rst:1943
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second part "
"to milliseconds. ``HH:MM:SS.sss`` format."
msgstr "``'milliseconds'``: 包含完整时间，但将秒值的小数部分截断至毫秒。 格式为 ``HH:MM:SS.sss``。"

#: ../../library/datetime.rst:1570 ../../library/datetime.rst:1945
msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr "``'microseconds'``: 以 ``HH:MM:SS.ffffff`` 格式包含完整时间。"

#: ../../library/datetime.rst:1574 ../../library/datetime.rst:1949
msgid "Excluded time components are truncated, not rounded."
msgstr "排除掉的时间部分将被截断，而不是被舍入。"

#: ../../library/datetime.rst:1576
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr "对于无效的 *timespec* 参数将引发 :exc:`ValueError`::"

#: ../../library/datetime.rst:1579
msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"

#: ../../library/datetime.rst:1586 ../../library/datetime.rst:1964
msgid "Added the *timespec* parameter."
msgstr "增加了 *timespec* 形参。"

#: ../../library/datetime.rst:1592
msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to "
"``d.isoformat(' ')``."
msgstr "对于 :class:`.datetime` 实例 ``d``，``str(d)`` 等价于 ``d.isoformat(' ')``。"

#: ../../library/datetime.rst:1598
msgid "Return a string representing the date and time::"
msgstr "返回一个表示日期和时间的字符串::"

#: ../../library/datetime.rst:1600
msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"

#: ../../library/datetime.rst:1604
msgid ""
"The output string will *not* include time zone information, regardless of "
"whether the input is aware or naive."
msgstr "输出字符串将 *并不* 包括时区信息，无论输入的是感知型还是简单型。"

#: ../../library/datetime.rst:1611
msgid ""
"on platforms where the native C :c:func:`ctime` function (which "
":func:`time.ctime` invokes, but which :meth:`datetime.ctime` does not "
"invoke) conforms to the C standard."
msgstr ""
"在原生 C :c:func:`ctime` 函数遵循 C 标准的平台上 (:func:`time.ctime` 会发起对该函数的调用，但 "
":meth:`datetime.ctime` 并不会) 。"

#: ../../library/datetime.rst:1618
msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string. See also :ref:`strftime-strptime-behavior` and "
":meth:`datetime.isoformat`."
msgstr ""
"返回一个由显式格式字符串所控制的，代表日期和时间的字符串。 另请参阅 :ref:`strftime-strptime-behavior` 和 "
":meth:`datetime.isoformat`。"

#: ../../library/datetime.rst:1625
msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also "
":ref:`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
"与 :meth:`.datetime.strftime` 相同。 此方法使得在 :ref:`格式化字符串字面值 <f-strings>` 中以及使用 "
":meth:`str.format` 时为 :class:`.datetime` 对象指定格式字符串成为可能。 另请参阅 :ref:`strftime-"
"strptime-behavior` 和 :meth:`datetime.isoformat`。"

#: ../../library/datetime.rst:1632
msgid "Examples of Usage: :class:`.datetime`"
msgstr "用法示例: :class:`.datetime`"

#: ../../library/datetime.rst:1634
msgid "Examples of working with :class:`.datetime` objects:"
msgstr "使用 :class:`.datetime` 对象的例子："

#: ../../library/datetime.rst:1636
msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone.utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # 使用 datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # 使用 datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone.utc)\n"
"\n"
">>> # 使用 datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # 使用 datetime.timetuple() 来获取由所有属性组成的元组\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # 年\n"
"11      # 月\n"
"21      # 日\n"
"16      # 时\n"
"30      # 分\n"
"0       # 秒\n"
"1       # 周序号 (0 = 星期一)\n"
"325     # 自 1 月 1 日开始的天数\n"
"-1      # dst - 方法 tzinfo.dst() 返回 None\n"
"\n"
">>> # ISO 格式的日期\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO 年\n"
"47      # ISO 第几周\n"
"2       # ISO 周序号\n"
"\n"
">>> # 格式化日期时间对象\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"

#: ../../library/datetime.rst:1687
msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then "
"+4:30 UTC thereafter::"
msgstr ""
"以下示例定义了一个 :class:`tzinfo` 子类，它捕获 Kabul, Afghanistan 时区的信息，该时区使用 +4 UTC 直到 "
"1945 年，之后则使用 +4:30 UTC::"

#: ../../library/datetime.rst:1691
msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, 30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # 喀布尔曾使用 +4 直到 1945 年，后改为 +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, 30):\n"
"            # 带有歧义（“虚幻”）的半小时区间代表\n"
"            # 由于从 +4 改为 +4:30 导致的时间‘折叠’。\n"
"            # 如果 dt 落在此虚幻区间，则使用该折叠\n"
"            # 确定如何计算。 参见 PEP495。\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # 遵循与在 datetime.tzinfo 中相同的效力\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # 需要一个针对 fromutc 的自定义实现\n"
"        # 因为此函数的输入是 utc 日期时间值\n"
"        # 但其 tzinfo 设为 self。\n"
"        # 参见 datetime.astimezone 或 fromtimestamp。\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # 喀布尔不实行夏令时。\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""

#: ../../library/datetime.rst:1734
msgid "Usage of ``KabulTz`` from above::"
msgstr "上述 ``KabulTz`` 的用法::"

#: ../../library/datetime.rst:1736
msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # 修改前的日期时间\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # 修改后的日期时间\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # 将日期时间转换至另一个时区\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"

#: ../../library/datetime.rst:1760
msgid ":class:`.time` Objects"
msgstr ":class:`.time` 对象"

#: ../../library/datetime.rst:1762
msgid ""
"A :class:`.time` object represents a (local) time of day, independent of any"
" particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""
"一个 :class:`.time` 对象代表某日的（本地）时间，它独立于任何特定日期，并可通过 :class:`tzinfo` 对象来调整。"

#: ../../library/datetime.rst:1767
msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a "
":class:`tzinfo` subclass. The remaining arguments must be integers in the "
"following ranges:"
msgstr ""
"所有参数都是可选的。 *tzinfo* 可以是 ``None``，或者是一个 :class:`tzinfo` 子类的实例。 "
"其余的参数必须是在下面范围内的整数："

#: ../../library/datetime.rst:1777
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised. "
"All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"如果给出一个此范围以外的参数，则会引发 :exc:`ValueError`。 所有参数默认值均为 0 但 *tzinfo* 除外，其默认值为 "
"``None``。"

#: ../../library/datetime.rst:1785
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr "早最的可表示 :class:`.time`, ``time(0, 0, 0, 0)``。"

#: ../../library/datetime.rst:1790
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr "最晚的可表示 :class:`.time`, ``time(23, 59, 59, 999999)``。"

#: ../../library/datetime.rst:1795
msgid ""
"The smallest possible difference between non-equal :class:`.time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on "
":class:`.time` objects is not supported."
msgstr ""
"两个不相等的 :class:`.time` 对象之间可能的最小间隔，``timedelta(microseconds=1)``，但是请注意 "
":class:`.time` 对象并不支持算术运算。"

#: ../../library/datetime.rst:1824
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` constructor, "
"or ``None`` if none was passed."
msgstr "作为 tzinfo 参数被传给 :class:`.time` 构造器的对象，如果没有传入值则为 ``None``。"

#: ../../library/datetime.rst:1838
msgid ""
":class:`.time` objects support equality and order comparisons, where ``a`` "
"is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ":class:`.time` 对象支持相等和顺序比较，当 ``a`` 的时间在 ``b`` 之前则认为 ``a`` 小于 ``b``。"

#: ../../library/datetime.rst:1841
msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""
"简单型和感知型 :class:`!time` 对象绝对不会相等。 简单型和感知型 :class:`!time` 对象之间的顺序比较将会引发 "
":exc:`TypeError`。"

#: ../../library/datetime.rst:1845
msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored and "
"the base times are compared. If both comparands are aware and have different"
" :attr:`!tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"如果两个操作数均为感知型，且具有相同的 :attr:`~.time.tzinfo` 属性，则 :attr:`!tzinfo` 和 "
":attr:`!fold` 属性会被忽略并对基本时间值进行比较。 如果两个操作数均为感知型且具有不同的 :attr:`!tzinfo` "
"属性，则两个操作数将首先通过减去它们的 UTC 时差（从 ``self.utcoffset()`` 获取）来进行调整。"

#: ../../library/datetime.rst:1851
msgid ""
"Equality comparisons between aware and naive :class:`.time` instances don't "
"raise :exc:`TypeError`."
msgstr "感知型和简单型 :class:`.time` 实例之间的相等性比较不会引发 :exc:`TypeError`。"

#: ../../library/datetime.rst:1855
msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be "
"true."
msgstr "在布尔运算时，:class:`.time` 对象总是被视为真值。"

#: ../../library/datetime.rst:1857
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if it "
"represented midnight in UTC. This behavior was considered obscure and error-"
"prone and has been removed in Python 3.5. See :issue:`13936` for full "
"details."
msgstr ""
"在 Python 3.5 之前，如果一个 :class:`.time` 对象代表 UTC 午夜零时则会被视为假值。 "
"此行为被认为容易引发困惑和错误，因此从 Python 3.5 起已被去除。 详情参见 :issue:`13936`。"

#: ../../library/datetime.rst:1864
msgid "Other constructor:"
msgstr "其他构造方法："

#: ../../library/datetime.rst:1868
msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO "
"8601 format, with the following exceptions:"
msgstr "返回一个对应于以任何有效的 ISO 8601 格式给出的 *time_string* 的 :class:`.time`，下列格式除外:"

#: ../../library/datetime.rst:1872
msgid ""
"The leading ``T``, normally required in cases where there may be ambiguity "
"between a date and a time, is not required."
msgstr "打头的 ``T``，通常在当日期和时间之间可能存在歧义时才有必要，不是必需的。"

#: ../../library/datetime.rst:1874
msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will be "
"truncated)."
msgstr "带小数的秒值可以有任意多位数码（超过 6 位将被截断）。"

#: ../../library/datetime.rst:1878
msgid "Examples:"
msgstr "示例："

#: ../../library/datetime.rst:1880
msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"

#: ../../library/datetime.rst:1902
msgid ""
"Previously, this method only supported formats that could be emitted by "
":meth:`time.isoformat`."
msgstr "在之前版本中，此方法仅支持可由 :meth:`time.isoformat` 发出的格式。"

#: ../../library/datetime.rst:1912
msgid ""
"Return a new :class:`.time` with the same values, but with specified "
"parameters updated. Note that ``tzinfo=None`` can be specified to create a "
"naive :class:`.time` from an aware :class:`.time`, without conversion of the"
" time data."
msgstr ""
"返回一个具有同样属性的新的 :class:`.time` 对象，但更新指定的形参。 请注意可以通过指定 ``tzinfo=None`` 基于一个感知型 "
":class:`.time` 创建一个简单型 :class:`.time`，而不必转换时间数据。"

#: ../../library/datetime.rst:1917
msgid ""
":class:`.time` objects are also supported by generic function "
":func:`copy.replace`."
msgstr ":class:`.time` 对象也被泛型函数 :func:`copy.replace` 所支持。"

#: ../../library/datetime.rst:1926
msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr "返回表示为下列 ISO 8601 格式之一的时间字符串："

#: ../../library/datetime.rst:1928
msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``，如果 :attr:`microsecond` 不为 0"

#: ../../library/datetime.rst:1929
msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``，如果 :attr:`microsecond` 为 0"

#: ../../library/datetime.rst:1930
msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``，如果 :meth:`utcoffset` 不返回 ``None``"

#: ../../library/datetime.rst:1931
msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and "
":meth:`utcoffset` does not return ``None``"
msgstr ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``，如果 :attr:`microsecond` 为 0 并且 "
":meth:`utcoffset` 不返回 ``None``"

#: ../../library/datetime.rst:1951
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr "对于无效的 *timespec* 参数将引发 :exc:`ValueError`。"

#: ../../library/datetime.rst:1955
msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456).isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456).isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"

#: ../../library/datetime.rst:1970
msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "对于时间对象 ``t``，``str(t)`` 等价于 ``t.isoformat()``。"

#: ../../library/datetime.rst:1975
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and "
":meth:`time.isoformat`."
msgstr ""
"返回一个由显式格式字符串所控制的，代表时间的字符串。 另请参阅 :ref:`strftime-strptime-behavior` 和 "
":meth:`time.isoformat`。"

#: ../../library/datetime.rst:1981
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a format "
"string for a :class:`.time` object in :ref:`formatted string literals "
"<f-strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
"与 :meth:`.time.strftime` 相同。 此方法使得在 :ref:`格式化字符串字面值 <f-strings>` 中以及使用 "
":meth:`str.format` 时为 :class:`.time` 对象指定格式字符串成为可能。 另请参阅 :ref:`strftime-"
"strptime-behavior` 和 :meth:`time.isoformat`。"

#: ../../library/datetime.rst:1989
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(None)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude less "
"than one day."
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.utcoffset(None)``，并且在后者不返回 ``None`` 或一个幅度小于一天的 a "
":class:`timedelta` 对象时将引发异常。"

#: ../../library/datetime.rst:1999
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(None)``, and raises an exception if the latter doesn't "
"return ``None``, or a :class:`timedelta` object with magnitude less than one"
" day."
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.dst(None)``，并且在后者不返回 ``None`` 或者一个幅度小于一天的 :class:`timedelta` "
"对象时将引发异常。"

#: ../../library/datetime.rst:2008
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(None)``, or raises an exception if the latter doesn't "
"return ``None`` or a string object."
msgstr ""
"如果 :attr:`.tzinfo` 为 ``None``，则返回 ``None``，否则返回 "
"``self.tzinfo.tzname(None)``，如果后者不返回 ``None`` 或者一个字符串对象则将引发异常。"

#: ../../library/datetime.rst:2013
msgid "Examples of Usage: :class:`.time`"
msgstr "用法示例: :class:`.time`"

#: ../../library/datetime.rst:2015
msgid "Examples of working with a :class:`.time` object::"
msgstr "使用 :class:`.time` 对象的例子::"

#: ../../library/datetime.rst:2017
msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"

#: ../../library/datetime.rst:2046
msgid ":class:`tzinfo` Objects"
msgstr ":class:`tzinfo` 对象"

#: ../../library/datetime.rst:2050
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr "这是一个抽象基类，也就是说该类不应被直接实例化。 请定义 :class:`tzinfo` 的子类来捕获有关特定时区的信息。"

#: ../../library/datetime.rst:2054
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the"
" constructors for :class:`.datetime` and :class:`.time` objects. The latter "
"objects view their attributes as being in local time, and the "
":class:`tzinfo` object supports methods revealing offset of local time from "
"UTC, the name of the time zone, and DST offset, all relative to a date or "
"time object passed to them."
msgstr ""
":class:`tzinfo` 的（某个实体子类）的实例可以被传给 :class:`.datetime` 和 :class:`.time` "
"对象的构造器。 这些对象会将它们的属性视为对应于本地时间，并且 :class:`tzinfo` 对象支持展示本地时间与 UTC 的差值、时区名称以及 "
"DST 差值的方法，都是与传给它们的日期或时间对象的相对值。"

#: ../../library/datetime.rst:2060
msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the "
":class:`.datetime` methods you use. The :mod:`!datetime` module provides "
":class:`timezone`, a simple concrete subclass of :class:`tzinfo` which can "
"represent time zones with fixed offset from UTC such as UTC itself or North "
"American EST and EDT."
msgstr ""
"你需要派生一个实体子类，并且（至少）提供你使用 :class:`.datetime` 方法所需要的标准 :class:`tzinfo` 方法的实现。 "
":mod:`!datetime` 模块提供了 :class:`timezone`，这是 :class:`tzinfo` 的一个简单实体子类，它能以与 "
"UTC 的固定差值来表示不同的时区，例如 UTC 本身或北美的 EST 和 EDT。"

#: ../../library/datetime.rst:2067
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an "
":meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"对于封存操作的特殊要求：一个 :class:`tzinfo` 子类必须具有可不带参数调用的 :meth:`~object.__init__` "
"方法，否则它虽然可以被封存，但可能无法再次解封。 这是个技术性要求，在未来可能会被取消。"

#: ../../library/datetime.rst:2073
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods. Exactly which methods are needed depends on the uses made of aware "
":mod:`!datetime` objects. If in doubt, simply implement all of them."
msgstr ""
"一个 :class:`tzinfo` 的实体子类可能需要实现以下方法。 具体需要实现的方法取决于感知型 :mod:`!datetime` "
"对象如何使用它。 如果有疑问，可以简单地全部实现它们。objects. If in doubt, simply implement all of "
"them."

#: ../../library/datetime.rst:2080
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that is"
" positive east of UTC. If local time is west of UTC, this should be "
"negative."
msgstr ""
"将本地时间与 UTC 时差返回为一个 :class:`timedelta` 对象，如果本地时区在 UTC 以东则为正值。 如果本地时区在 UTC "
"以西则为负值。"

#: ../../library/datetime.rst:2083
msgid ""
"This represents the *total* offset from UTC; for example, if a "
":class:`tzinfo` object represents both time zone and DST adjustments, "
":meth:`utcoffset` should return their sum. If the UTC offset isn't known, "
"return ``None``. Else the value returned must be a :class:`timedelta` object"
" strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)`` (the "
"magnitude of the offset must be less than one day). Most implementations of "
":meth:`utcoffset` will probably look like one of these two::"
msgstr ""
"这表示与 UTC 的 *总计* 时差；举例来说，如果一个 :class:`tzinfo` 对象同时代表时区和 DST 调整，则 "
":meth:`utcoffset` 应当返回两者的和。 如果 UTC 时差不确定则返回 ``None``。 在其他情况下返回值必须为一个 "
":class:`timedelta` 对象，其取值严格限制于 ``-timedelta(hours=24)`` 和 "
"``timedelta(hours=24)`` 之间（差值的幅度必须小于一天）。 大多数 :meth:`utcoffset` "
"的实现看起来可能像是以下两者之一::"

#: ../../library/datetime.rst:2091
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""
"return CONSTANT                 # 固定偏移类\n"
"return CONSTANT + self.dst(dt)  # 夏令时感知类"

#: ../../library/datetime.rst:2094
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return"
" ``None`` either."
msgstr "如果 :meth:`utcoffset` 返回值不为 ``None``，则 :meth:`dst` 也不应返回 ``None``。"

#: ../../library/datetime.rst:2097
msgid ""
"The default implementation of :meth:`utcoffset` raises "
":exc:`NotImplementedError`."
msgstr "默认的 :meth:`utcoffset` 实现会引发 :exc:`NotImplementedError`。"

#: ../../library/datetime.rst:2106
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta` "
"object or ``None`` if DST information isn't known."
msgstr "将夏令时（DST）调整返回为一个 :class:`timedelta` 对象，如果 DST 信息未知则返回 ``None``。"

#: ../../library/datetime.rst:2110
msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, return"
" the offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to the"
" UTC offset returned by :meth:`utcoffset`, so there's no need to consult "
":meth:`dst` unless you're interested in obtaining DST info separately. For "
"example, :meth:`datetime.timetuple` calls its :attr:`~.datetime.tzinfo` "
"attribute's :meth:`dst` method to determine how the "
":attr:`~time.struct_time.tm_isdst` flag should be set, and "
":meth:`tzinfo.fromutc` calls :meth:`dst` to account for DST changes when "
"crossing time zones."
msgstr ""
"如果 DST 未启用则返回 ``timedelta(0)``。 如果 DST 已启用，则将差值作为一个 :class:`timedelta` "
"对象返回（请参阅 :meth:`utcoffset` 了解详情）。 请注意 DST 差值如果可用，就会直接被加入 :meth:`utcoffset` "
"所返回的 UTC 时差，因此无需额外查询 :meth:`dst`，除非你希望单独获取 DST 信息。 "
"例如，:meth:`datetime.timetuple` 会调用其 :attr:`~.datetime.tzinfo` 属性的 :meth:`dst`"
" 方法来确定应该如何设置 :attr:`~time.struct_time.tm_isdst` 旗标，而 :meth:`tzinfo.fromutc` "
"会调用 :meth:`dst` 来在跨越时区时处理 DST 的改变。"

#: ../../library/datetime.rst:2120
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and"
" daylight times must be consistent in this sense:"
msgstr "一个可以同时处理标准时和夏令时的 :class:`tzinfo` 子类的实例 *tz* 必须在此情形中保持一致："

#: ../../library/datetime.rst:2123
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: ../../library/datetime.rst:2125
msgid ""
"must return the same result for every :class:`.datetime` *dt* with "
"``dt.tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression "
"yields the time zone's \"standard offset\", which should not depend on the "
"date or the time, but only on geographic location. The implementation of "
":meth:`datetime.astimezone` relies on this, but cannot detect violations; "
"it's the programmer's responsibility to ensure it. If a :class:`tzinfo` "
"subclass cannot guarantee this, it may be able to override the default "
"implementation of :meth:`tzinfo.fromutc` to work correctly with "
":meth:`~.datetime.astimezone` regardless."
msgstr ""
"必须为具有 ``dt.tzinfo == tz`` 的每个 :class:`.datetime` *dt* 返回同样的结果。 对于同样的 "
":class:`tzinfo` 子类，此表达式会产生特定时区的“标准时差”，它不应依赖于具体日期或时间，而只依赖于地理位置。 "
":meth:`datetime.astimezone` 的实现依赖于此方法，但无法检测违反规则的情况；确保符合规则是程序员的责任。 如果一个 "
":class:`tzinfo` 子类不能保证这一点，也许可以重写 :meth:`tzinfo.fromutc` 的默认实现以便在任何情况下与 "
":meth:`~.datetime.astimezone` 正确配合。"

#: ../../library/datetime.rst:2134
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr "大多数 :meth:`dst` 的实现可能会如以下两者之一::"

#: ../../library/datetime.rst:2136
msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # 固定偏移类：不考虑夏令时\n"
"    return timedelta(0)"

#: ../../library/datetime.rst:2140
msgid "or::"
msgstr "或者："

#: ../../library/datetime.rst:2142
msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # 此代码根据输入的 dt.year 设置时区的夏令时\n"
"    # 切换的开始和结束时刻 dston 和 dstoff，并以\n"
"    # 标准地方时表示。\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"

#: ../../library/datetime.rst:2152
msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr "默认的 :meth:`dst` 实现会引发 :exc:`NotImplementedError`。"

#: ../../library/datetime.rst:2160
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the "
":mod:`!datetime` module, and there's no requirement that it mean anything in"
" particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` are"
" all valid replies. Return ``None`` if a string name isn't known. Note that "
"this is a method rather than a fixed string primarily because some "
":class:`tzinfo` subclasses will wish to return different names depending on "
"the specific value of *dt* passed, especially if the :class:`tzinfo` class "
"is accounting for daylight time."
msgstr ""
"将对应于 :class:`.datetime` 对象 *dt* 的时区名称作为字符串返回。 :mod:`!datetime` "
"模块未定义任何有关字符串名称的内容，也不要求它具有任何特定含义。 例如``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` "
"都是有效的返回值。 如果字符串名称未知则返回 ``None``。 请注意这是一个方法而不是一个固定的字符串，这主要是因为某些 "
":class:`tzinfo` 子类可能需要根据所传入的特定 *dt* 值返回不同的名称，特别是在 :class:`tzinfo` "
"类要负责处理夏令时的场合中。"

#: ../../library/datetime.rst:2170
msgid ""
"The default implementation of :meth:`tzname` raises "
":exc:`NotImplementedError`."
msgstr "默认的 :meth:`tzname` 实现会引发 :exc:`NotImplementedError`。"

#: ../../library/datetime.rst:2173
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` object, "
"in response to their methods of the same names. A :class:`.datetime` object "
"passes itself as the argument, and a :class:`.time` object passes ``None`` "
"as the argument. A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class "
":class:`.datetime`."
msgstr ""
"这些方法会被 :class:`.datetime` 或 :class:`.time` 对象调用，用来与它们的同名方法相对应。 "
":class:`.datetime` 对象会将自身作为传入参数，而 :class:`.time` 对象会将 ``None`` 作为传入参数。 这样 "
":class:`tzinfo` 子类的方法应当准备好接受 *dt* 参数值为 ``None`` 或是 :class:`.datetime` 类的实例。"

#: ../../library/datetime.rst:2179
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response. For example, returning ``None`` is appropriate if the class wishes"
" to say that time objects don't participate in the :class:`tzinfo` "
"protocols. It may be more useful for ``utcoffset(None)`` to return the "
"standard UTC offset, as there is no other convention for discovering the "
"standard offset."
msgstr ""
"当传入 ``None`` 时，应当由类的设计者来决定最佳回应方式。 例如，返回 ``None`` 适用于希望该类提示时间对象不参与 "
":class:`tzinfo` 协议处理。 让 ``utcoffset(None)`` 返回标准 UTC "
"时差也许会更有用处，因为并没有其他可用于发现标准时差的约定惯例。"

#: ../../library/datetime.rst:2185
msgid ""
"When a :class:`.datetime` object is passed in response to a "
":class:`.datetime` method, ``dt.tzinfo`` is the same object as *self*. "
":class:`tzinfo` methods can rely on this, unless user code calls "
":class:`tzinfo` methods directly. The intent is that the :class:`tzinfo` "
"methods interpret *dt* as being in local time, and not need worry about "
"objects in other time zones."
msgstr ""
"当传入一个 :class:`.datetime` 对象来回应 :class:`.datetime` 方法时，``dt.tzinfo`` 与 *self*"
" 是同一对象。 :class:`tzinfo` 方法可以依赖这一点，除非用户代码直接调用了 :class:`tzinfo` 方法。 此行为的目的是使得 "
":class:`tzinfo` 方法将 *dt* 解读为本地时间，而不需要担心其他时区的相关对象。"

#: ../../library/datetime.rst:2191
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr "还有一个额外的 :class:`tzinfo` 方法，某个子类可能会希望重写它："

#: ../../library/datetime.rst:2196
msgid ""
"This is called from the default :meth:`datetime.astimezone` implementation. "
"When called from that, ``dt.tzinfo`` is *self*, and *dt*'s date and time "
"data are to be viewed as expressing a UTC time. The purpose of "
":meth:`fromutc` is to adjust the date and time data, returning an equivalent"
" datetime in *self*'s local time."
msgstr ""
"此方法会由默认的 :meth:`datetime.astimezone` 实现来调用。 当被其调用时，``dt.tzinfo`` 为 *self*，并且"
" *dt* 的日期和时间数据会被视为表示 UTC 时间。 :meth:`fromutc` 的目标是调整日期和时间数据，返回一个等价的表示 *self* "
"的本地时间的 datetime。"

#: ../../library/datetime.rst:2202
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default "
":meth:`fromutc` implementation without problems. It's strong enough to "
"handle fixed-offset time zones, and time zones accounting for both standard "
"and daylight time, and the latter even if the DST transition times differ in"
" different years. An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of "
":meth:`~.datetime.astimezone` and :meth:`fromutc` may not produce the result"
" you want if the result is one of the hours straddling the moment the "
"standard offset changes."
msgstr ""
"大多数 :class:`tzinfo` 子类应该能够毫无问题地继承默认的 :meth:`fromutc` 实现。 "
"它的健壮性足以处理固定差值的时区以及同时负责标准时和夏令时的时区，对于后者甚至还能处理 DST 转换时间在各个年份有变化的情况。 一个默认 "
":meth:`fromutc` 实现可能无法在所有情况下正确处理的例子是（与 UTC "
"的）标准时差取决于所经过的特定日期和时间，这种情况可能由于政治原因而出现。 默认的 :meth:`~.datetime.astimezone` 和 "
":meth:`fromutc` 实现可能无法生成你希望的结果，如果这个结果恰好是跨越了标准时差发生改变的时刻当中的某个小时值的话。"

#: ../../library/datetime.rst:2213
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr "忽略针对错误情况的代码，默认 :meth:`fromutc` 实现的行为方式如下::"

#: ../../library/datetime.rst:2216
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""
"def fromutc(self, dt):\n"
"    # 如果 dt.tzinfo 不为 self 则引发 ValueError\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # 如果 dtoff 为 None 或 dtdst 为 None 则引发 ValueError\n"
"    delta = dtoff - dtdst  # 这是 self 的标准偏移\n"
"    if delta:\n"
"        dt += delta   # 转换为标准地方时\n"
"        dtdst = dt.dst()\n"
"        # 如果 dtdst 为 None 则引发 ValueError\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"

#: ../../library/datetime.rst:2231
msgid ""
"In the following :download:`tzinfo_examples.py "
"<../includes/tzinfo_examples.py>` file there are some examples of "
":class:`tzinfo` classes:"
msgstr ""
"在以下 :download:`tzinfo_examples.py <../includes/tzinfo_examples.py>` 文件中有一些 "
":class:`tzinfo` 类的例子："

#: ../../library/datetime.rst:2235
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# 一个考虑系统平台地方时处理方式的类。\n"
"# （可能导致在 UTC 时差和/或夏令时规则\n"
"#  曾经发生过变化的时区的某些历史时间\n"
"#  出现错误的值。）\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # 删除时间折叠\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# 针对美国各大时区当前夏令时规则的完整实现。\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US 夏令时规则\n"
"#\n"
"# 这是一个有关美国夏令时起止时间的有所简化的规则集\n"
"# （即在某些情况下可能出错。）要获取最新的完整夏令时\n"
"# 规则和时区定义集，请访问 Olson 数据库 (或尝试 pytz)：\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (更新可能不及时)\n"
"#\n"
"# 在美国，从 2007 年起，夏令时开始于 3 月的第二个星期天\n"
"# 上午 2 时 (标准时)，即从 3 月 8 日起的第一个星期天。\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# 结束于 11 月的第一天星期天上午 2 时 (夏令时)。\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# 从 1987 到 2006 年，夏令时开始于 4 月的第一个星期天\n"
"# 上午 2 时 (标准时)，结束于 10 月的最后一个星期天上午 2 时\n"
"# (夏令时)，即从 10 月 25 日起的第一个星期天。\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# 从 1967 到 1986 年，夏令时开始于 4 月的最后一个星期天\n"
"# 上午 2 时 (标准时)，(即从 4 月 24 日起的第一个星期天)\n"
"# 结束于 10 月的最后一个星期天上午 2 时 (夏令时)，\n"
"# 即从 10 月 25 日起的第一个星期天。\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # 找到美国夏令时的起止时间。 针对 1967 之前的年份，\n"
"    # 将为非夏令时返回 start = end。\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # 对于某种或两种情况，可以考虑在此设置异常。\n"
"            # 具体取决于你想如何处理它们。\n"
"            # 默认的 fromutc() 实现 (由默认的 astimezone() 实现调用)\n"
"            # 将传入一个 dt.tzinfo 为 self 的日期时间。\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # 无法将简单型与感知型对象进行比较，\n"
"        # 因此先从 dt 移除时区。\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # 夏令时已生效。\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # 折叠 (有歧义的小时值)：使用 dt.fold 来消除歧义。\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # 空档 (不存在的小时值)：逆向折叠规则。\n"
"            return HOUR if dt.fold else ZERO\n"
"        # 夏令时已结束。\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # 重复的小时值\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # 标准时\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # 夏令时\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"

#: ../../library/datetime.rst:2237
msgid ""
"Note that there are unavoidable subtleties twice per year in a "
":class:`tzinfo` subclass accounting for both standard and daylight time, at "
"the DST transition points. For concreteness, consider US Eastern (UTC "
"-0500), where EDT begins the minute after 1:59 (EST) on the second Sunday in"
" March, and ends the minute after 1:59 (EDT) on the first Sunday in "
"November::"
msgstr ""
"请注意同时负责标准时和夏令时的 :class:`tzinfo` 子类在每年两次的 DST 转换点上会出现不可避免的微妙问题。具体而言，考虑美国东部时区 "
"(UTC -0500)，它的 EDT 从三月的第二个星期天 1:59 (EST) 之后一分钟开始，并在十一月的第一天星期天 1:59 (EDT) "
"之后一分钟结束::"

#: ../../library/datetime.rst:2243
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"

#: ../../library/datetime.rst:2251
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00. A wall time of the form 2:MM doesn't really make sense on that day,"
" so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the"
" day DST begins. For example, at the Spring forward transition of 2016, we "
"get::"
msgstr ""
"当 DST 开始时（即 \"start\" 行），本地时钟从 1:59 跳到 3:00。 形式为 2:MM 的时间值在那一天是没有意义的，因此在 DST"
" 开始那一天 ``astimezone(Eastern)`` 不会输出包含 ``hour == 2`` 的结果。 例如，在 2016 "
"年春季时钟向前调整时，我们得到::"

#: ../../library/datetime.rst:2256
msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"

#: ../../library/datetime.rst:2270
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time. In Eastern, that's times of the form 5:MM UTC on"
" the day daylight time ends. The local wall clock leaps from 1:59 (daylight "
"time) back to 1:00 (standard time) again. Local times of the form 1:MM are "
"ambiguous. :meth:`~.datetime.astimezone` mimics the local clock's behavior "
"by mapping two adjacent UTC hours into the same local hour then. In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern, but earlier times have the :attr:`~.datetime.fold` "
"attribute set to 0 and the later times have it set to 1. For example, at the"
" Fall back transition of 2016, we get::"
msgstr ""
"当 DST 结束时（见 \"end\" 行），会有更糟糕的潜在问题：本地时间值中有一个小时是不可能没有歧义的：夏令时的最后一小时。 "
"即以北美东部时间表示当天夏令时结束时的形式为 5:MM UTC 的时间。 本地时钟从 1:59（夏令时）再次跳回到 1:00（标准时）。 形式为 "
"1:MM 的本地时间就是有歧义的。 此时 :meth:`~.datetime.astimezone` 是通过将两个相邻的 UTC "
"小时映射到两个相同的本地小时来模仿本地时钟的行为。 在这个北美东部时间的示例中，形式为 5:MM 和 6:MM 的 UTC "
"时间在转换为北美东部时间时都将被映射到 1:MM，但前一个时间会将 :attr:`~.datetime.fold` 属性设为 0 而后一个时间会将其设为"
" 1。 例如，在 2016 年秋季时钟往回调整时，我们得到::"

#: ../../library/datetime.rst:2281
msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"

#: ../../library/datetime.rst:2292
msgid ""
"Note that the :class:`.datetime` instances that differ only by the value of "
"the :attr:`~.datetime.fold` attribute are considered equal in comparisons."
msgstr ""
"请注意不同的 :class:`.datetime` 实例仅通过 :attr:`~.datetime.fold` "
"属性值来加以区分，它们在比较时会被视为相等。"

#: ../../library/datetime.rst:2295
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly check "
"the value of the :attr:`~.datetime.fold` attribute or avoid using hybrid "
":class:`tzinfo` subclasses; there are no ambiguities when using "
":class:`timezone`, or any other fixed-offset :class:`tzinfo` subclass (such "
"as a class representing only EST (fixed offset -5 hours), or only EDT (fixed"
" offset -4 hours))."
msgstr ""
"不允许时间显示存在歧义的应用程序需要显式地检查 :attr:`~.datetime.fold` 属性的值，或者避免使用混合式的 "
":class:`tzinfo` 子类；当使用 :class:`timezone` 或者任何其他固定差值的 :class:`tzinfo` "
"子类（例如仅表示 EST (固定差值 -5 小时)，或仅表示 EDT (固定差值 -4 小时) 的类时是不会有歧义的）。"

#: ../../library/datetime.rst:2303
msgid ":mod:`zoneinfo`"
msgstr ":mod:`zoneinfo`"

#: ../../library/datetime.rst:2304
msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
":mod:`!datetime` 模块有一个基本 :class:`timezone` 类（用来处理任意与 UTC 的固定时差）及其 "
":attr:`timezone.utc` 属性（UTC :class:`!timezone` 实例）。"

#: ../../library/datetime.rst:2308
msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the Olson "
"database) to Python, and its usage is recommended."
msgstr "``zoneinfo`` 为 Python 带来了 *IANA时区数据库* （也被称为 Olson 数据库），推荐使用它。"

#: ../../library/datetime.rst:2311
msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr "`IANA 时区数据库 <https://www.iana.org/time-zones>`_"

#: ../../library/datetime.rst:2312
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains code "
"and data that represent the history of local time for many representative "
"locations around the globe. It is updated periodically to reflect changes "
"made by political bodies to time zone boundaries, UTC offsets, and daylight-"
"saving rules."
msgstr ""
"该时区数据库 (通常称为 tz, tzdata 或 zoneinfo) 包含大量代码和数据用来表示全球许多有代表性的地点的本地时间的历史信息。 "
"它会定期进行更新以反映各政治实体对时区边界、UTC 差值和夏令时规则的更改。"

#: ../../library/datetime.rst:2322
msgid ":class:`timezone` Objects"
msgstr ":class:`timezone` 对象"

#: ../../library/datetime.rst:2324
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each instance "
"of which represents a time zone defined by a fixed offset from UTC."
msgstr ""
":class:`timezone` 类是 :class:`tzinfo` 的子类，它的每个实例都代表一个以与 UTC 的固定时差来定义的时区。"

#: ../../library/datetime.rst:2328
msgid ""
"Objects of this class cannot be used to represent time zone information in "
"the locations where different offsets are used in different days of the year"
" or where historical changes have been made to civil time."
msgstr "此类的对象不可被用于代表某些特殊地点的时区信息，这些地点在一年的不同日期会使用不同的时差，或是在历史上对民用时间进行过调整。"

#: ../../library/datetime.rst:2335
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"*offset* 参数必须指定为一个 :class:`timedelta` 对象，表示本地时间与 UTC 的时差。 它必须严格限制于 "
"``-timedelta(hours=24)`` 和 ``timedelta(hours=24)`` 之间，否则会引发 "
":exc:`ValueError`。"

#: ../../library/datetime.rst:2340
msgid ""
"The *name* argument is optional. If specified it must be a string that will "
"be used as the value returned by the :meth:`datetime.tzname` method."
msgstr "*name* 参数是可选的。 如果指定则必须为一个字符串，它将被用作 :meth:`datetime.tzname` 方法的返回值。"

#: ../../library/datetime.rst:2351 ../../library/datetime.rst:2362
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr "返回当 :class:`timezone` 实例被构造时指定的固定值。"

#: ../../library/datetime.rst:2354
msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr "*dt* 参数会被忽略。 返回值是一个 :class:`timedelta` 实例，其值等于本地时间与 UTC 之间的时差。"

#: ../../library/datetime.rst:2365
msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. If "
"*offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a string "
"in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH and MM "
"are two digits of ``offset.hours`` and ``offset.minutes`` respectively."
msgstr ""
"如果没有在构造器中提供 *name*，则 ``tzname(dt)`` 所返回的名称将根据 ``offset`` 值按以下规则生成。 如果 "
"*offset* 为 ``timedelta(0)``，则名称为“UTC”，否则为字符串 ``UTC±HH:MM``，其中 ± 为 ``offset``"
" 的正负符号，HH 和 MM 分别为表示 ``offset.hours`` 和 ``offset.minutes`` 的两个数码。"

#: ../../library/datetime.rst:2371
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr "由 ``offset=timedelta(0)`` 生成的名称现在是简单的 ``'UTC'``，而不是 ``'UTC+00:00'``。"

#: ../../library/datetime.rst:2378
msgid "Always returns ``None``."
msgstr "总是返回 ``None``。"

#: ../../library/datetime.rst:2382
msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware "
":class:`.datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"返回 ``dt + offset``。 *dt* 参数必须为一个感知型 :class:`.datetime` 实例，其中 ``tzinfo`` 值设为 "
"``self``。"

#: ../../library/datetime.rst:2389
msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "UTC 时区，``timezone(timedelta(0))``。"

#: ../../library/datetime.rst:2398
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr ":meth:`~.datetime.strftime` 和 :meth:`~.datetime.strptime` 的行为"

#: ../../library/datetime.rst:2400
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string."
msgstr ""
":class:`date`, :class:`.datetime` 和 :class:`.time` 对象都支持 "
"``strftime(format)`` 方法，可用来创建由一个显式格式字符串所控制的表示时间的字符串。"

#: ../../library/datetime.rst:2404
msgid ""
"Conversely, the :meth:`datetime.strptime` class method creates a "
":class:`.datetime` object from a string representing a date and time and a "
"corresponding format string."
msgstr ""
"相反地，:meth:`datetime.strptime` 类会根据表示日期和时间的字符串和相应的格式字符串来创建一个 "
":class:`.datetime` 对象。"

#: ../../library/datetime.rst:2408
msgid ""
"The table below provides a high-level comparison of "
":meth:`~.datetime.strftime` versus :meth:`~.datetime.strptime`:"
msgstr ""
"下表提供了 :meth:`~.datetime.strftime` 与 :meth:`~.datetime.strptime` 的高层级比较："

#: ../../library/datetime.rst:2412
msgid "``strftime``"
msgstr "``strftime``"

#: ../../library/datetime.rst:2412
msgid "``strptime``"
msgstr "``strptime``"

#: ../../library/datetime.rst:2414
msgid "Usage"
msgstr "用法"

#: ../../library/datetime.rst:2414
msgid "Convert object to a string according to a given format"
msgstr "根据给定的格式将对象转换为字符串"

#: ../../library/datetime.rst:2414
msgid ""
"Parse a string into a :class:`.datetime` object given a corresponding format"
msgstr "将字符串解析为给定相应格式的 :class:`.datetime` 对象"

#: ../../library/datetime.rst:2416
msgid "Type of method"
msgstr "方法类型"

#: ../../library/datetime.rst:2416
msgid "Instance method"
msgstr "实例方法"

#: ../../library/datetime.rst:2416
msgid "Class method"
msgstr "类方法"

#: ../../library/datetime.rst:2418
msgid "Method of"
msgstr "方法"

#: ../../library/datetime.rst:2418
msgid ":class:`date`; :class:`.datetime`; :class:`.time`"
msgstr ":class:`date`; :class:`.datetime`; :class:`.time`"

#: ../../library/datetime.rst:2418
msgid ":class:`.datetime`"
msgstr ":class:`.datetime`"

#: ../../library/datetime.rst:2420
msgid "Signature"
msgstr "签名"

#: ../../library/datetime.rst:2420
msgid "``strftime(format)``"
msgstr "``strftime(format)``"

#: ../../library/datetime.rst:2420
msgid "``strptime(date_string, format)``"
msgstr "``strptime(date_string, format)``"

#: ../../library/datetime.rst:2427
msgid ""
":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr ":meth:`~.datetime.strftime` 和 :meth:`~.datetime.strptime` 格式码"

#: ../../library/datetime.rst:2429
msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr "这些方法接受可被用于解析和格式化日期的格式代码::"

#: ../../library/datetime.rst:2431
msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"

#: ../../library/datetime.rst:2437
msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C implementation."
msgstr "以下列表显示了 1989 版 C 标准所要求的全部格式代码，它们在带有标准 C 实现的所有平台上均可用。"

#: ../../library/datetime.rst:2441 ../../library/datetime.rst:2544
msgid "Directive"
msgstr "指示符"

#: ../../library/datetime.rst:2441 ../../library/datetime.rst:2544
msgid "Meaning"
msgstr "含意"

#: ../../library/datetime.rst:2441 ../../library/datetime.rst:2544
msgid "Example"
msgstr "示例"

#: ../../library/datetime.rst:2441 ../../library/datetime.rst:2544
msgid "Notes"
msgstr "备注"

#: ../../library/datetime.rst:2443
msgid "``%a``"
msgstr "``%a``"

#: ../../library/datetime.rst:2443
msgid "Weekday as locale's abbreviated name."
msgstr "当地工作日的缩写。"

#: ../../library/datetime.rst:0
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: ../../library/datetime.rst:0
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "So, Mo, ..., Sa (de_DE)"

#: ../../library/datetime.rst:2448
msgid "``%A``"
msgstr "``%A``"

#: ../../library/datetime.rst:2448
msgid "Weekday as locale's full name."
msgstr "本地化的星期中每日的完整名称。"

#: ../../library/datetime.rst:0
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Sunday, Monday, ..., Saturday (en_US);"

#: ../../library/datetime.rst:0
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

#: ../../library/datetime.rst:2453
msgid "``%w``"
msgstr "``%w``"

#: ../../library/datetime.rst:2453
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "以十进制数显示的工作日，其中0表示星期日，6表示星期六。"

#: ../../library/datetime.rst:2453
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: ../../library/datetime.rst:2457
msgid "``%d``"
msgstr "``%d``"

#: ../../library/datetime.rst:2457
msgid "Day of the month as a zero-padded decimal number."
msgstr "补零后，以十进制数显示的月份中的一天。"

#: ../../library/datetime.rst:2457
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: ../../library/datetime.rst:2457 ../../library/datetime.rst:2470
#: ../../library/datetime.rst:2473 ../../library/datetime.rst:2479
#: ../../library/datetime.rst:2482 ../../library/datetime.rst:2488
#: ../../library/datetime.rst:2506
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/datetime.rst:2460
msgid "``%b``"
msgstr "``%b``"

#: ../../library/datetime.rst:2460
msgid "Month as locale's abbreviated name."
msgstr "当地月份的缩写。"

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (en_US);"

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

#: ../../library/datetime.rst:2465
msgid "``%B``"
msgstr "``%B``"

#: ../../library/datetime.rst:2465
msgid "Month as locale's full name."
msgstr "本地化的月份全名。"

#: ../../library/datetime.rst:0
msgid "January, February, ..., December (en_US);"
msgstr "January, February, ..., December (en_US);"

#: ../../library/datetime.rst:0
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "Januar, Februar, ..., Dezember (de_DE)"

#: ../../library/datetime.rst:2470
msgid "``%m``"
msgstr "``%m``"

#: ../../library/datetime.rst:2470
msgid "Month as a zero-padded decimal number."
msgstr "补零后，以十进制数显示的月份。"

#: ../../library/datetime.rst:2470 ../../library/datetime.rst:2482
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: ../../library/datetime.rst:2473
msgid "``%y``"
msgstr "``%y``"

#: ../../library/datetime.rst:2473
msgid "Year without century as a zero-padded decimal number."
msgstr "补零后，以十进制数表示的，不带世纪的年份。"

#: ../../library/datetime.rst:2473
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: ../../library/datetime.rst:2476
msgid "``%Y``"
msgstr "``%Y``"

#: ../../library/datetime.rst:2476
msgid "Year with century as a decimal number."
msgstr "十进制数表示的带世纪的年份。"

#: ../../library/datetime.rst:2476 ../../library/datetime.rst:2546
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: ../../library/datetime.rst:2479
msgid "``%H``"
msgstr "``%H``"

#: ../../library/datetime.rst:2479
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "以补零后的十进制数表示的小时（24 小时制）。"

#: ../../library/datetime.rst:2479
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: ../../library/datetime.rst:2482
msgid "``%I``"
msgstr "``%I``"

#: ../../library/datetime.rst:2482
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "以补零后的十进制数表示的小时（12 小时制）。"

#: ../../library/datetime.rst:2485
msgid "``%p``"
msgstr "``%p``"

#: ../../library/datetime.rst:2485
msgid "Locale's equivalent of either AM or PM."
msgstr "本地化的 AM 或 PM 。"

#: ../../library/datetime.rst:0
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: ../../library/datetime.rst:0
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: ../../library/datetime.rst:2485
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: ../../library/datetime.rst:2488
msgid "``%M``"
msgstr "``%M``"

#: ../../library/datetime.rst:2488
msgid "Minute as a zero-padded decimal number."
msgstr "补零后，以十进制数显示的分钟。"

#: ../../library/datetime.rst:2488 ../../library/datetime.rst:2491
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: ../../library/datetime.rst:2491
msgid "``%S``"
msgstr "``%S``"

#: ../../library/datetime.rst:2491
msgid "Second as a zero-padded decimal number."
msgstr "补零后，以十进制数显示的秒。"

#: ../../library/datetime.rst:2491
msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

#: ../../library/datetime.rst:2494
msgid "``%f``"
msgstr "``%f``"

#: ../../library/datetime.rst:2494
msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr "微秒作为一个十进制数，零填充到 6 位。"

#: ../../library/datetime.rst:2494
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: ../../library/datetime.rst:2494
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/datetime.rst:2498 ../../library/datetime.rst:2657
msgid "``%z``"
msgstr "``%z``"

#: ../../library/datetime.rst:2498
msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object is"
" naive)."
msgstr "UTC 偏移量，格式为 ``±HHMM[SS[.ffffff]]`` （如果是简单型对象则为空字符串）。"

#: ../../library/datetime.rst:2498
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(空), +0000, -0400, +1030, +063415, -030712.345216"

#: ../../library/datetime.rst:2498 ../../library/datetime.rst:2503
#: ../../library/datetime.rst:2560
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/datetime.rst:2503 ../../library/datetime.rst:2683
msgid "``%Z``"
msgstr "``%Z``"

#: ../../library/datetime.rst:2503
msgid "Time zone name (empty string if the object is naive)."
msgstr "时区名称（如果对象为简单型则为空字符串）。"

#: ../../library/datetime.rst:2503
msgid "(empty), UTC, GMT"
msgstr "(空), UTC, GMT"

#: ../../library/datetime.rst:2506
msgid "``%j``"
msgstr "``%j``"

#: ../../library/datetime.rst:2506
msgid "Day of the year as a zero-padded decimal number."
msgstr "以补零后的十进制数表示的一年中的日序号。"

#: ../../library/datetime.rst:2506
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: ../../library/datetime.rst:2509
msgid "``%U``"
msgstr "``%U``"

#: ../../library/datetime.rst:2509
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday are"
" considered to be in week 0."
msgstr "以补零后的十进制数表示的一年中的周序号（星期日作为每周的第一天）。 在新的一年中第一个星期日之前的所有日子都被视为是在第 0 周。"

#: ../../library/datetime.rst:2509 ../../library/datetime.rst:2517
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: ../../library/datetime.rst:2509 ../../library/datetime.rst:2517
msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

#: ../../library/datetime.rst:2517
msgid "``%W``"
msgstr "``%W``"

#: ../../library/datetime.rst:2517
msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday are"
" considered to be in week 0."
msgstr "以补零后的十进制数表示的一年中的周序号（星期一作为每周的第一天）。 在新的一年中第一个星期一之前的所有日子都被视为是在第 0 周。"

#: ../../library/datetime.rst:2525
msgid "``%c``"
msgstr "``%c``"

#: ../../library/datetime.rst:2525
msgid "Locale's appropriate date and time representation."
msgstr "本地化的适当日期和时间表示。"

#: ../../library/datetime.rst:0
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

#: ../../library/datetime.rst:2530
msgid "``%x``"
msgstr "``%x``"

#: ../../library/datetime.rst:2530
msgid "Locale's appropriate date representation."
msgstr "本地化的适当日期表示。"

#: ../../library/datetime.rst:0
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: ../../library/datetime.rst:0
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

#: ../../library/datetime.rst:2534
msgid "``%X``"
msgstr "``%X``"

#: ../../library/datetime.rst:2534
msgid "Locale's appropriate time representation."
msgstr "本地化的适当时间表示。"

#: ../../library/datetime.rst:0
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

#: ../../library/datetime.rst:0
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

#: ../../library/datetime.rst:2537
msgid "``%%``"
msgstr "``%%``"

#: ../../library/datetime.rst:2537
msgid "A literal ``'%'`` character."
msgstr "字面的 ``'%'`` 字符。"

#: ../../library/datetime.rst:2537
msgid "%"
msgstr "%"

#: ../../library/datetime.rst:2540
msgid ""
"Several additional directives not required by the C89 standard are included "
"for convenience. These parameters all correspond to ISO 8601 date values."
msgstr "为了方便起见，还包括了C89标准不需要的其他一些指示符。 这些参数都对应于 ISO 8601 日期值。"

#: ../../library/datetime.rst:2546
msgid "``%G``"
msgstr "``%G``"

#: ../../library/datetime.rst:2546
msgid ""
"ISO 8601 year with century representing the year that contains the greater "
"part of the ISO week (``%V``)."
msgstr "带有世纪的 ISO 8601 年份，表示包含大部分 ISO 星期 (``%V``) 的年份。"

#: ../../library/datetime.rst:2546
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/datetime.rst:2551
msgid "``%u``"
msgstr "``%u``"

#: ../../library/datetime.rst:2551
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "以十进制数显示的 ISO 8601 星期中的日序号，其中 1 表示星期一。"

#: ../../library/datetime.rst:2551
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: ../../library/datetime.rst:2554
msgid "``%V``"
msgstr "``%V``"

#: ../../library/datetime.rst:2554
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the week. "
"Week 01 is the week containing Jan 4."
msgstr "以十进制数显示的 ISO 8601 星期，以星期一作为每周的第一天。 第 01 周为包含 1 月 4 日的星期。"

#: ../../library/datetime.rst:2554
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: ../../library/datetime.rst:2554
msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

#: ../../library/datetime.rst:2560 ../../library/datetime.rst:2679
msgid "``%:z``"
msgstr "``%:z``"

#: ../../library/datetime.rst:2560
msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the object "
"is naive)."
msgstr "``±HH:MM[:SS[.ffffff]]`` 形式的 UTC 偏移量（如果是简单型对象则为空字符串）。"

#: ../../library/datetime.rst:2560
msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(空), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"

#: ../../library/datetime.rst:2566
msgid ""
"These may not be available on all platforms when used with the "
":meth:`~.datetime.strftime` method. The ISO 8601 year and ISO 8601 week "
"directives are not interchangeable with the year and week number directives "
"above. Calling :meth:`~.datetime.strptime` with incomplete or ambiguous ISO "
"8601 directives will raise a :exc:`ValueError`."
msgstr ""
"这些代码可能不是在所有平台上都可与 :meth:`~.datetime.strftime` 方法配合使用。 ISO 8601 年份和 ISO 8601 "
"星期指示符并不能与上面的年份和星期序号指示符相互替代。 调用 :meth:`~.datetime.strptime` 时传入不完整或有歧义的 ISO "
"8601 指示符将引发 :exc:`ValueError`。"

#: ../../library/datetime.rst:2571
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling of "
"unsupported format specifiers."
msgstr ""
"对完整格式代码集的支持在不同平台上有所差异，因为 Python 要调用所在平台的 C 库的 :c:func:`strftime` "
"函数，而不同平台的差异是很常见的。 要查看你所用平台所支持的完整格式代码集，请参阅 :manpage:`strftime(3)` 文档。 "
"不同的平台在处理不支持的格式说明符方面也有差异。"

#: ../../library/datetime.rst:2577
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "增加了 ``%G``,  ``%u``  和 ``%V``。"

#: ../../library/datetime.rst:2580
msgid "``%:z`` was added."
msgstr "增加了 ``%:z``。"

#: ../../library/datetime.rst:2584
msgid "Technical Detail"
msgstr "技术细节"

#: ../../library/datetime.rst:2586
msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a "
":meth:`~date.timetuple` method."
msgstr ""
"总体而言，``d.strftime(fmt)`` 类似于 :mod:`time` 模块的 ``time.strftime(fmt, "
"d.timetuple())`` 但是并非所有对象都支持 :meth:`~date.timetuple` 方法。"

#: ../../library/datetime.rst:2590
msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""
"对于 :meth:`.datetime.strptime` 类方法，默认值为 ``1900-01-01T00:00:00.000``: "
"任何未在格式字符串中指定的部分都将从默认值中获取。 [#]_"

#: ../../library/datetime.rst:2594
msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr "使用 ``datetime.strptime(date_string, format)`` 等价于::"

#: ../../library/datetime.rst:2598
msgid ""
"except when the format includes sub-second components or time zone offset "
"information, which are supported in ``datetime.strptime`` but are discarded "
"by ``time.strptime``."
msgstr ""
"除非格式中包含秒以下的部分或时区差值信息，它们在 ``datetime.strptime`` 中受支持但会被 ``time.strptime`` "
"所丢弃。"

#: ../../library/datetime.rst:2602
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day should"
" not be used, as :class:`!time` objects have no such values. If they're used"
" anyway, 1900 is substituted for the year, and 1 for the month and day."
msgstr ""
"对于 :class:`.time` 对象，年、月、日的格式代码不应被使用，因为 :class:`!time` 对象没有这些值。 "
"如果它们仍被使用，则年份将被替换为 1900 而月和日将被替换为 1。"

#: ../../library/datetime.rst:2606
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and"
" microseconds should not be used, as :class:`date` objects have no such "
"values. If they're used anyway, 0 is substituted for them."
msgstr ""
"对于 :class:`date` 对象，时、分、秒和微秒的格式代码不应被使用，因为 :class:`date` 对象没有这些值。 "
"如果它们仍被使用，则都将被替换为 0。"

#: ../../library/datetime.rst:2610
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved "
"intact in the output, while on others ``strftime`` may raise "
":exc:`UnicodeError` or return an empty string instead."
msgstr ""
"出于相同的原因，对于包含当前区域设置字符集所无法表示的 Unicode 码位的格式字符串的处理方式也取决于具体平台。 "
"在某些平台上这样的码位会不加修改地原样输出，而在其他平台上 ``strftime`` 则可能引发 :exc:`UnicodeError` "
"或只返回一个空字符串。"

#: ../../library/datetime.rst:2619
msgid ""
"Because the format depends on the current locale, care should be taken when "
"making assumptions about the output value. Field orderings will vary (for "
"example, \"month/day/year\" versus \"day/month/year\"), and the output may "
"contain non-ASCII characters."
msgstr ""
"因为该格式依赖于当前语言区域，所以在假定输出值时应当仔细考虑。 字段顺序可能会有变化（例如 \"month/day/year\" 和 "
"\"day/month/year\"），并且输出还可能包含非 ASCII 字符。"

#: ../../library/datetime.rst:2625
msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, 9999]"
" range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
":meth:`~.datetime.strptime` 方法能够解析整个 [1, 9999] 范围内的年份，但 < 1000 的年份必须加零填充为 4 "
"位数字宽度。"

#: ../../library/datetime.rst:2628
msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1900."
msgstr "在之前的版本中，:meth:`~.datetime.strftime` 方法只限用于 >= 1900 的年份。"

#: ../../library/datetime.rst:2632
msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to years "
">= 1000."
msgstr "在 3.2 版中，:meth:`~.datetime.strftime` 方法只限用于 >= 1000 的年份。"

#: ../../library/datetime.rst:2637
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` directive "
"only affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
"当与 :meth:`~.datetime.strptime` 方法一起使用时，如果使用 ``%I`` 指示符来解析时，则 ``%p`` "
"指示符只会影响输出时字段。"

#: ../../library/datetime.rst:2641
msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not support "
"leap seconds."
msgstr "与 :mod:`time` 模块不同的是，:mod:`!datetime` 模块不支持闰秒。"

#: ../../library/datetime.rst:2645
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` directive "
"accepts from one to six digits and zero pads on the right. ``%f`` is an "
"extension to the set of format characters in the C standard (but implemented"
" separately in datetime objects, and therefore always available)."
msgstr ""
"当与 :meth:`~.datetime.strptime` 方法一起使用时，``%f`` 指示符可接受一至六个数码及左边的零填充。 ``%f`` 是对"
" C 标准中格式字符集的扩展（但单独在 datetime 对象中实现，因此它总是可用）。"

#: ../../library/datetime.rst:2652
msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are replaced"
" by empty strings."
msgstr "对于简单型对象，``%z``, ``%:z`` 和 ``%Z`` 格式代码会被替换为空字符串。"

#: ../../library/datetime.rst:2655
msgid "For an aware object:"
msgstr "对于一个感知型对象而言："

#: ../../library/datetime.rst:2658
msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the number "
"of UTC offset hours, ``MM`` is a 2-digit string giving the number of UTC "
"offset minutes, ``SS`` is a 2-digit string giving the number of UTC offset "
"seconds and ``ffffff`` is a 6-digit string giving the number of UTC offset "
"microseconds. The ``ffffff`` part is omitted when the offset is a whole "
"number of seconds and both the ``ffffff`` and the ``SS`` part is omitted "
"when the offset is a whole number of minutes. For example, if "
":meth:`~.datetime.utcoffset` returns ``timedelta(hours=-3, minutes=-30)``, "
"``%z`` is replaced with the string ``'-0330'``."
msgstr ""
":meth:`~.datetime.utcoffset` 会被转换为 ``±HHMM[SS[.ffffff]]`` 形式的字符串，其中 ``HH`` "
"为给出 UTC 时差的小时部分的 2 位数码字符串，``MM`` 为给出 UTC 时差的分钟部分的 2 位数码字符串，``SS`` 为给出 UTC "
"时差的秒部分的 2 位数码字符串，而 ``ffffff`` 则为给出 UTC 时差的微秒部分的 6 位数码字符串。 当时差为整数秒时 "
"``ffffff`` 部分将被省略，而当时差为整数分钟时 ``ffffff`` 和 ``SS`` 部分都将被省略。 举例来说，如果 "
":meth:`~.datetime.utcoffset` 返回 ``timedelta(hours=-3, minutes=-30)``，则 "
"``%z`` 会被替换为字符串 ``'-0330'``。"

#: ../../library/datetime.rst:2672
msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime` "
"method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"当向 :meth:`~.datetime.strptime` 方法提供 ``%z`` 指示符时，UTC 差值可以在时、分和秒之间使用冒号作为分隔符。 "
"例如，``'+01:00:00'`` 将被解读为一小时的差值。 此外，提供 ``'Z'`` 就相当于 ``'+00:00'``。"

#: ../../library/datetime.rst:2680
msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours, "
"minutes and seconds."
msgstr "行为与 ``%z`` 相同，但在时，分和秒之间有冒号分隔符。"

#: ../../library/datetime.rst:2684
msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if "
":meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced by "
"the returned value, which must be a string."
msgstr ""
"在 :meth:`~.datetime.strftime` 中，如果 :meth:`~.datetime.tzname` 返回 ``None`` 则 "
"``%Z`` 会被替换为一个空字符串；在其他情况下 ``%Z`` 会被替换为该返回值，它必须为一个字符串。"

#: ../../library/datetime.rst:2688
msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ":meth:`~.datetime.strptime` 仅接受特定的 ``%Z`` 值："

#: ../../library/datetime.rst:2690
msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "你的机器的区域设置可以是 ``time.tzname`` 中的任何值"

#: ../../library/datetime.rst:2691
msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "硬编码的值 ``UTC`` 和 ``GMT``"

#: ../../library/datetime.rst:2693
msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as valid "
"values, but probably not ``EST``. It will raise ``ValueError`` for invalid "
"values."
msgstr ""
"这样生活在日本的人可用的值为 ``JST``, ``UTC`` 和 ``GMT``，但可能没有 ``EST``。 它将引发 ``ValueError``"
" 表示无效的值。"

#: ../../library/datetime.rst:2697
msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The ``tzinfo`` "
"of the result will be set to a :class:`timezone` instance."
msgstr ""
"当提供 ``%z`` 指示符给 :meth:`~.datetime.strptime` 方法时，将产生一个感知型 :class:`.datetime` "
"对象。 结果的 ``tzinfo`` 将被设为一个 :class:`timezone` 实例。"

#: ../../library/datetime.rst:2703
msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` are"
" only used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
"当与 :meth:`~.datetime.strptime` 方法一起使用时，``%U`` 和 ``%W`` 仅用于指定了星期值和日历年份 "
"(``%Y``) 的计算。"

#: ../../library/datetime.rst:2708
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when the "
"day of the week and the ISO year (``%G``) are specified in a "
":meth:`~.datetime.strptime` format string. Also note that ``%G`` and ``%Y`` "
"are not interchangeable."
msgstr ""
"类似于 ``%U`` 和 ``%W``，``%V`` 仅用于在 :meth:`~.datetime.strptime` 格式字符串中指定了星期值和 "
"ISO 年份 (``%G``) 的计算。 还要注意 ``%G`` 和 ``%Y`` 是不可互换的。"

#: ../../library/datetime.rst:2714
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero is "
"optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
"当与 :meth:`~.datetime.strptime` 方法一起使用时，前导的零在格式 ``%d``, ``%m``, ``%H``, "
"``%I``, ``%M``, ``%S``, ``%j``, ``%U``, ``%W`` 和 ``%V`` 中是可选的。 格式 ``%y`` "
"则要求有前导的零。"

#: ../../library/datetime.rst:2719
msgid ""
"When parsing a month and day using :meth:`~.datetime.strptime`, always "
"include a year in the format.  If the value you need to parse lacks a year, "
"append an explicit dummy leap year.  Otherwise your code will raise an "
"exception when it encounters leap day because the default year used by the "
"parser is not a leap year.  Users run into this bug every four years..."
msgstr ""
"当使用 :meth:`~.datetime.strptime` 解析月份和日期时，始终在格式字符串中包括年份。 "
"如果你需要解析的值缺少年份，则添加一个显式的占位用闰年。 否则当你的代码遇到一个闰日时将引发异常因为解析器所使用的默认年份不是一个闰年。 "
"用户会每隔四年碰到这个程序错误..."

#: ../../library/datetime.rst:2725
msgid ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # No leap year bug.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"
msgstr ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # 没有闰年错误。\n"
"datetime.datetime(1984, 2, 29, 0, 0)"

#: ../../library/datetime.rst:2731
msgid ""
":meth:`~.datetime.strptime` calls using a format string containing a day of "
"month without a year now emit a :exc:`DeprecationWarning`. In 3.15 or later "
"we may change this into an error or change the default year to a leap year. "
"See :gh:`70647`."
msgstr ""
"使用包含不带年份的月份日期的格式字符串的 :meth:`~.datetime.strptime` 调用现在将引发 "
":exc:`DeprecationWarning`。 在 3.15 或更新的版本中我们可能将其修改为引发错误或将默认年从修改为一年闰年。 参见 "
":gh:`70647`。"

#: ../../library/datetime.rst:2738
msgid "Footnotes"
msgstr "备注"

#: ../../library/datetime.rst:2739
msgid "If, that is, we ignore the effects of Relativity"
msgstr "就是说如果我们忽略相对论效应的话。"

#: ../../library/datetime.rst:2741
msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the "
"base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"这与 Dershowitz 和 Reingold 所著 *Calendrical Calculations* "
"中“预期格列高利”历法的定义一致，它是适用于该书中所有运算的基础历法。 请参阅该书了解在预期格利高利历序列与许多其他历法系统之间进行转换的算法。"

#: ../../library/datetime.rst:2747
msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm>`_"
" for a good explanation."
msgstr ""
"请参阅 R. H. van Gent 所著 `ISO 8601 历法的数学指南 "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm>`_"
" 以获取更完整的说明。"

#: ../../library/datetime.rst:2751
msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since 1900 is not"
" a leap year."
msgstr "传入 ``datetime.strptime('Feb 29', '%b %d')`` 将导致错误，因为 1900 不是闰年。"

#: ../../library/datetime.rst:2392
msgid "% (percent)"
msgstr "% (百分号)"

#: ../../library/datetime.rst:2392
msgid "datetime format"
msgstr "日期时间格式"
