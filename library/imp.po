# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 18:10+0000\n"
"PO-Revision-Date: 2025-07-18 20:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/imp.rst:2
msgid ":mod:`imp` --- Access the :ref:`import <importsystem>` internals"
msgstr ":mod:`imp` --- 访问 :ref:`import <importsystem>` 内部对象"

#: ../../library/imp.rst:8
msgid "**Source code:** :source:`Lib/imp.py`"
msgstr "**源代码：** :source:`Lib/imp.py`"

#: ../../library/imp.rst:10
msgid "The :mod:`imp` module is deprecated in favor of :mod:`importlib`."
msgstr ":mod:`imp` 模块已被废弃，请改用 :mod:`importlib`。"

#: ../../library/imp.rst:17
msgid ""
"This module provides an interface to the mechanisms used to implement the "
":keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr "本模块提供了一个接口，用于实现 :keyword:`import` 语句的机制。这里定义了以下常量和函数："

#: ../../library/imp.rst:25
msgid ""
"Return the magic string value used to recognize byte-compiled code files "
"(:file:`.pyc` files).  (This value may be different for each Python "
"version.)"
msgstr "返回用于识别字节编译代码文件 (:file:`.pyc` files) 的魔术字符串值。 （该值对于各个 Python 版本可能不同。）"

#: ../../library/imp.rst:28
msgid "Use :attr:`importlib.util.MAGIC_NUMBER` instead."
msgstr "改用 :attr:`importlib.util.MAGIC_NUMBER`。"

#: ../../library/imp.rst:34
msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is"
" a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function"
" to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary"
" files), and *type* is the file type, which has one of the values "
":const:`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described"
" below."
msgstr ""
"返回一个 3 元素元组的列表，每个元组描述了一个特定的模块类型。 每个三元组的形式为 ``(suffix, mode, type)``，其中 "
"*suffix* 是要附加到模块名称上以组成要搜索的文件名的字符串，*mode* 是要传给内置 :func:`open` 函数以打开该文件的模式字符串 "
"(可以为针对文本文件的 ``'r'`` 或针对二进制文件的 ``'rb'``)，而 *type* 是文件类型，它的值为 "
":const:`PY_SOURCE`, :const:`PY_COMPILED` 之一 :const:`C_EXTENSION`，具体说明如下。"

#: ../../library/imp.rst:43
msgid "Use the constants defined on :mod:`importlib.machinery` instead."
msgstr "改用在 :mod:`importlib.machinery` 上定义的常量。"

#: ../../library/imp.rst:49
msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module "
"(:const:`PY_FROZEN`), and on some systems some other places are looked in as"
" well (on Windows, it looks in the registry which may point to a specific "
"file)."
msgstr ""
"尝试找到模块 *name*。 如果 *path* 被省略或为 ``None``，则会搜索 ``sys.path`` "
"给出的目录名列表，但在此前会先搜索几个特殊位置：该函数将尝试找到具有给定名称的内置模块 (:const:`C_BUILTIN`)，然后是冻结模块 "
"(:const:`PY_FROZEN`)，并且在某些系统上还会查找其他几个位置（在 Windows 上，它将查看注册表，其中可能指向某一特定文件）。"

#: ../../library/imp.rst:56
msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes`"
" above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"在其他情况下，*path* 必须是一个目录名列表；将在每个目录中搜索具有上述 :func:`get_suffixes` 所返回的任何后缀的文件。 "
"列表中的无效名称将被静默地忽略（但是所有列表条目都必须为字符串）。"

#: ../../library/imp.rst:61
msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr "如果搜索成功，返回值将是一个 3 元素元组 ``(file, pathname, description)``:"

#: ../../library/imp.rst:64
msgid ""
"*file* is an open :term:`file object` positioned at the beginning, "
"*pathname* is the pathname of the file found, and *description* is a "
"3-element tuple as contained in the list returned by :func:`get_suffixes` "
"describing the kind of module found."
msgstr ""
"*file* 是一个放在最前面的已打开的 :term:`file object`，*pathname* 是打到的文件的路径名，而 "
"*description* 是一个描述所找到的模块种类的 3 元素元组，如 :func:`get_suffixes` 所返回的列表中包含的内容。"

#: ../../library/imp.rst:69
msgid ""
"If the module is built-in or frozen then *file* and *pathname* are both "
"``None`` and the *description* tuple contains empty strings for its suffix "
"and mode; the module type is indicated as given in parentheses above.  If "
"the search is unsuccessful, :exc:`ImportError` is raised.  Other exceptions "
"indicate problems with the arguments or environment."
msgstr ""
"如果模块为内置或冻结模块则 *file* 和 *pathname* 都将为 ``None`` 并且 *description* "
"元组将包含空字符串来表示其后缀和模式；模块类型按上述圆括号中所给出的内容来指明。 如果搜索未成功，则会引发 :exc:`ImportError`。 "
"其他异常被用于指示参数或环境问题。"

#: ../../library/imp.rst:75
msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"如果模块是一个包，则 *file* 将为 ``None``，*pathname* 将为包路径而 *description* 元组的最后一项将为 "
":const:`PKG_DIRECTORY`。"

#: ../../library/imp.rst:78
msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use "
":func:`find_module` and :func:`load_module` to find and load package *P*, "
"and then use :func:`find_module` with the *path* argument set to "
"``P.__path__``. When *P* itself has a dotted name, apply this recipe "
"recursively."
msgstr ""
"此函数不会处理多层级的模块名称（包含点号的名称）。 为了找到 *P.M*，也就是 *P* 包的的子模块 *M*，请使用 "
":func:`find_module` 和 :func:`load_module` 来找到并载入 *P* 包，然后使用 "
":func:`find_module` 并将 *path* 参数设为 ``P.__path__``。 当 *P* "
"本身也具有带点号的名称时，请递归地应用此步骤。"

#: ../../library/imp.rst:84
msgid ""
"Use :func:`importlib.util.find_spec` instead unless Python 3.3 compatibility"
" is required, in which case use :func:`importlib.find_loader`. For example "
"usage of the former case, see the :ref:`importlib-examples` section of the "
":mod:`importlib` documentation."
msgstr ""
"请改用 :func:`importlib.util.find_spec` 除非需要兼容 Python 3.3，对于后一种情况请使用 "
":func:`importlib.find_loader`。 要查看对于前一种情况的示例用法，请参阅 :mod:`importlib` 文档的 "
":ref:`importlib-examples` 小节。"

#: ../../library/imp.rst:94
msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does"
" more than importing the module: if the module was already imported, it will"
" reload the module!  The *name* argument indicates the full module name "
"(including the package name, if this is a submodule of a package).  The "
"*file* argument is an open file, and *pathname* is the corresponding file "
"name; these can be ``None`` and ``''``, respectively, when the module is a "
"package or not being loaded from a file.  The *description* argument is a "
"tuple, as would be returned by :func:`get_suffixes`, describing what kind of"
" module must be loaded."
msgstr ""
"加载之前由 :func:`find_module` 所找到的模块（或由其他方式执行搜索所产生的兼容的结果）。 "
"此函数所做的不只是导入模块：如果模块已经被导入，它将重新加载此模块！ *name* 参数指明完整的模块名称（包括包名，如果它是一个包的子模块的话）。 "
"*file* 参数是一个打开的文件，而 *pathname* 是相应的文件名；当模块是一个包或者不是从文档加载时，它们可以分别为 ``None`` 和 "
"``''``。 *description* 参数是一个元组，如 :func:`get_suffixes` 将返回的内容一样，描述了必须加载什么样的模块。"

#: ../../library/imp.rst:105
msgid ""
"If the load is successful, the return value is the module object; otherwise,"
" an exception (usually :exc:`ImportError`) is raised."
msgstr "如果加载成功，则返回值为相应的模块对象；否则，将引发一个异常 (通常为 :exc:`ImportError`)。"

#: ../../library/imp.rst:108
msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if"
" it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**重要:** 调用方需负责关闭 *file* 参数，如果它不为 ``None`` 的话，即使是在有异常被引发时。 这最好是使用 "
":keyword:`try` ... :keyword:`finally` 语句来实现。"

#: ../../library/imp.rst:112
msgid ""
"If previously used in conjunction with :func:`imp.find_module` then consider"
" using :func:`importlib.import_module`, otherwise use the loader returned by"
" the replacement you chose for :func:`imp.find_module`. If you called "
":func:`imp.load_module` and related functions directly with file path "
"arguments then use a combination of "
":func:`importlib.util.spec_from_file_location` and "
":func:`importlib.util.module_from_spec`. See the :ref:`importlib-examples` "
"section of the :mod:`importlib` documentation for details of the various "
"approaches."
msgstr ""
"如果之前是与 :func:`imp.find_module` 一起使用则可考虑使用 "
":func:`importlib.import_module`，在其他情况下请使用你选择的 :func:`imp.find_module` "
"替代品所返回的加载器。 如果你直接附带文件路径参数调用 :func:`imp.load_module` 和相关函数则请使用 "
":func:`importlib.util.spec_from_file_location` 和 "
":func:`importlib.util.module_from_spec` 的组合。 参见 :mod:`importlib` 文档的 "
":ref:`importlib-examples` 小节来了解各种方式的细节。"

#: ../../library/imp.rst:126
msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr "返回一个新的名为 *name* 的空模块对象。 此对象 *不会* 被插入到 ``sys.modules`` 中。 "

#: ../../library/imp.rst:129
msgid "Use :func:`importlib.util.module_from_spec` instead."
msgstr "请改用 :func:`importlib.util.module_from_spec`。"

#: ../../library/imp.rst:135
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (the same as the *module* argument)."
msgstr ""
"重新加载之前导入的 *module*。 该参数必须是一个模块对象，因此它之前必须已经被成功导入了。 "
"这在当你已使用外部编辑器编辑过模块源代码文件并想在不退出 Python 解释器的情况下尝试新版本时会很有用处。 返回值为模块对象（与 *module* "
"参数所指向的相同）。"

#: ../../library/imp.rst:141
msgid "When ``reload(module)`` is executed:"
msgstr "当 ``reload(module)`` 被执行时:"

#: ../../library/imp.rst:143
msgid ""
"Python modules' code is recompiled and the module-level code reexecuted, "
"defining a new set of objects which are bound to names in the module's "
"dictionary.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"Python 模块的代码会被重新编译并且模块层级的代码将重新执行，定义一个新的绑定到模块字典中的名称的对象集合。 扩展模块的 ``init`` "
"函数不会被重复调用。"

#: ../../library/imp.rst:148
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr "与Python中的所有的其它对象一样，旧的对象只有在它们的引用计数为0之后才会被回收。"

#: ../../library/imp.rst:151
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr "模块命名空间中的名称重新指向任何新的或更改后的对象。"

#: ../../library/imp.rst:154
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr "其他旧对象的引用（例如那个模块的外部名称）不会被重新绑定到引用的新对象的，并且如果有需要，必须在出现的每个命名空间中进行更新。"

#: ../../library/imp.rst:158
msgid "There are a number of other caveats:"
msgstr "有一些其他注意事项："

#: ../../library/imp.rst:160
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"当一个模块被重新加载的时候，它的字典（包含了那个模块的全区变量）会被保留。名称的重新定义会覆盖旧的定义，所以通常来说这不是问题。如果一个新模块没有定义在旧版本模块中定义的名称，则将保留旧版本中的定义。这一特性可用于作为那个模块的优点，如果它维护一个全局表或者对象的缓存"
" —— 使用 :keyword:`try` 语句，就可以测试表的存在并且跳过它的初始化，如果有需要的话::"

#: ../../library/imp.rst:173
msgid ""
"It is legal though generally not very useful to reload built-in or "
"dynamically loaded modules, except for :mod:`sys`, :mod:`__main__` and "
":mod:`builtins`. In many cases, however, extension modules are not designed "
"to be initialized more than once, and may fail in arbitrary ways when "
"reloaded."
msgstr ""
"重新加载内置或动态加载的模块是合法操作但通常不是很有用处，除非是 :mod:`sys`, :mod:`__main__` 和 "
":mod:`builtins`。 但是在许多情况下，扩展模块并不是被设计为可被多次初始化的，并可能在重新加载时以任意方式失败。"

#: ../../library/imp.rst:178
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import`"
" and qualified names (*module*.*name*) instead."
msgstr ""
"如果一个模块使用 :keyword:`from` ... :keyword:`import` ... 导入来自另一个模块的对象，则为另一个模块调用 "
":func:`reload` 并不会重新定义从其中导入的对象 --- 绕过此问题的一种方式是重新执行 :keyword:`!from` "
"语句，另一种方式是使用 :keyword:`!import` 和限定名称 (*module*.*name*) 来代替。"

#: ../../library/imp.rst:184
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr "如果一个模块创建一个类的实例，重新加载定义那个类的模块不影响那些实例的方法定义———它们继续使用旧类中的定义。对于子类来说同样是正确的。"

#: ../../library/imp.rst:188
msgid ""
"Relies on both ``__name__`` and ``__loader__`` being defined on the module "
"being reloaded instead of just ``__name__``."
msgstr "依赖于 ``__name__`` 和 ``__loader__`` 而不仅是 ``__name__`` 同时定义在被重新加载的模块上。"

#: ../../library/imp.rst:192
msgid "Use :func:`importlib.reload` instead."
msgstr "使用 :func:`importlib.reload` 来代替。"

#: ../../library/imp.rst:196
msgid ""
"The following functions are conveniences for handling :pep:`3147` byte-"
"compiled file paths."
msgstr "下列函数可以方便地处理 :pep:`3147` 字节编译的文件路径。"

#: ../../library/imp.rst:203
msgid ""
"Return the :pep:`3147` path to the byte-compiled file associated with the "
"source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the return "
"value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. "
"The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised). By passing in ``True`` or "
"``False`` for *debug_override* you can override the system's value for "
"``__debug__``, leading to optimized bytecode."
msgstr ""
"返回与源 :pep:`3147` 定义的 *path* 相关联的已编译字节码文件的路径。 举例来说，如果 *path* 为 "
"``/foo/bar/baz.py`` 则 Python 3.2 中的返回值将是 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``。 字符串 ``cpython-32`` 来自于当前的魔术标签 "
"(参见 :func:`get_tag`; 如果 :attr:`sys.implementation.cache_tag` 未定义则将引发 "
":exc:`NotImplementedError`)。 通过为 *debug_override* 传入 ``True`` 或 ``False`` "
"你可以覆盖系统设置的 ``__debug__`` 值，以生成优化的字节码。"

#: ../../library/imp.rst:212
msgid "*path* need not exist."
msgstr "*path* 不必存在。"

#: ../../library/imp.rst:214
msgid ""
"If :attr:`sys.implementation.cache_tag` is ``None``, then "
":exc:`NotImplementedError` is raised."
msgstr ""
"如果 :attr:`sys.implementation.cache_tag` 为 ``None``，则会引发 "
":exc:`NotImplementedError`。"

#: ../../library/imp.rst:218
msgid "Use :func:`importlib.util.cache_from_source` instead."
msgstr "使用 :func:`importlib.util.cache_from_source` 来代替。"

#: ../../library/imp.rst:221
msgid "The *debug_override* parameter no longer creates a ``.pyo`` file."
msgstr "*debug_override* 形参不会再创建 ``.pyo`` 文件。"

#: ../../library/imp.rst:227
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` format, a :exc:`ValueError` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"根据给定的 :pep:`3147` 文件名的 *path*，返回相关联的源代码文件路径。 举例来说，如果 *path* 为 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` 则返回的路径将是 ``/foo/bar/baz.py``。 "
"*path* 不必已存在，但是如果它未遵循 :pep:`3147` 格式，则会引发 :exc:`ValueError`。 如果未定义 "
":attr:`sys.implementation.cache_tag`，则会引发 :exc:`NotImplementedError`。"

#: ../../library/imp.rst:235
msgid ""
"Raise :exc:`NotImplementedError` when :attr:`sys.implementation.cache_tag` "
"is not defined."
msgstr ""
"当未定义 :attr:`sys.implementation.cache_tag` 时将引发 :exc:`NotImplementedError`。"

#: ../../library/imp.rst:239
msgid "Use :func:`importlib.util.source_from_cache` instead."
msgstr "使用 :func:`importlib.util.source_from_cache` 来代替。"

#: ../../library/imp.rst:245
msgid ""
"Return the :pep:`3147` magic tag string matching this version of Python's "
"magic number, as returned by :func:`get_magic`."
msgstr "返回与此 Python 版本魔数相匹配的 :pep:`3147` 魔术标签字符串，如 :func:`get_magic` 所返回的。"

#: ../../library/imp.rst:248
msgid ""
"Use :attr:`sys.implementation.cache_tag` directly starting in Python 3.3."
msgstr "从 Python 3.3 开始直接使用 :attr:`sys.implementation.cache_tag`。"

#: ../../library/imp.rst:253
msgid ""
"The following functions help interact with the import system's internal "
"locking mechanism.  Locking semantics of imports are an implementation "
"detail which may vary from release to release.  However, Python ensures that"
" circular imports work without any deadlocks."
msgstr ""
"以下函数可以帮助与导入系统的内部锁定机制进行交互。 导入的锁定语义是一个可能在不同发布版之间发生改变的实现细节。 但是，Python "
"会确保循环导入操作不会出现任何死锁。"

#: ../../library/imp.rst:261
msgid ""
"Return ``True`` if the global import lock is currently held, else ``False``."
" On platforms without threads, always return ``False``."
msgstr "如果当前持有全局导入锁则返回 ``True``，否则返回 ``False``。 在没有线程的系统平台上，将总是返回 ``False``。"

#: ../../library/imp.rst:264
msgid ""
"On platforms with threads, a thread executing an import first holds a global"
" import lock, then sets up a per-module lock for the rest of the import.  "
"This blocks other threads from importing the same module until the original "
"import completes, preventing other threads from seeing incomplete module "
"objects constructed by the original thread.  An exception is made for "
"circular imports, which by construction have to expose an incomplete module "
"object at some point."
msgstr ""
"在有线程的平台上，执行导入的线程首先会持有一个全局导入锁，然后为导入其余部分设置模块专属锁。 "
"这将阻止其他线程导入相同的模块直到原始导入完成，防止其他线程看到由原始线程构建的不完整的模块对象。 "
"循环导入是个例外情况，它在构造上就必须在某一时刻暴露不完整的模块对象。"

#: ../../library/imp.rst:272 ../../library/imp.rst:292
#: ../../library/imp.rst:305
msgid ""
"The locking scheme has changed to per-module locks for the most part.  A "
"global import lock is kept for some critical tasks, such as initializing the"
" per-module locks."
msgstr "锁定方案在大多数情况下都已改为按模块锁定。 对于某些关键任务会保留一个全局导入锁，比如初始化每个模块的锁。"

#: ../../library/imp.rst:282
msgid ""
"Acquire the interpreter's global import lock for the current thread. This "
"lock should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr "为当前线程获取解释器的全局导入锁。 这个锁应当由导入钩子来使用以确保导入模块时的线程安全。"

#: ../../library/imp.rst:286
msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has"
" acquired it."
msgstr "一旦某个线程获取了导入锁，同一个线程可以再次获取它而不会阻塞；该线程每次获得它都必须再释放它一次。"

#: ../../library/imp.rst:290
msgid "On platforms without threads, this function does nothing."
msgstr "在没有线程的平台上，此函数将不做任何操作。"

#: ../../library/imp.rst:302
msgid ""
"Release the interpreter's global import lock. On platforms without threads, "
"this function does nothing."
msgstr "释放解释器的全局导入锁。 在没有线程的平台上，此函数将不做任何操作。"

#: ../../library/imp.rst:313
msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr "以下是在本模块中定义的具有整数值的常量，用来表示 :func:`find_module` 的搜索结果。"

#: ../../library/imp.rst:319
msgid "The module was found as a source file."
msgstr "模块作为一个源文件被发现。"

#: ../../library/imp.rst:326
msgid "The module was found as a compiled code object file."
msgstr "模块作为一个已编译代码对象文件被发现。"

#: ../../library/imp.rst:333
msgid "The module was found as dynamically loadable shared library."
msgstr "模块作为动态可加载共享库被发现。"

#: ../../library/imp.rst:340
msgid "The module was found as a package directory."
msgstr "模块作为一个包目录被发现。"

#: ../../library/imp.rst:347
msgid "The module was found as a built-in module."
msgstr "模块作为一个内置模块被发现。"

#: ../../library/imp.rst:354
msgid "The module was found as a frozen module."
msgstr "模块作为一个冻结模块被发现。"

#: ../../library/imp.rst:361
msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
":class:`NullImporter` 类型是一个在无法找到任何模块时处理非目录路径字符串 :pep:`302` 导入钩子。 "
"调用此类型时传入一个现有目录或空字符串将引发 :exc:`ImportError`。 在其他情况下，将返回一个 "
":class:`NullImporter` 实例。"

#: ../../library/imp.rst:366
msgid "Instances have only one method:"
msgstr "这些实例只有一个方法:"

#: ../../library/imp.rst:370
msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr "此方法总是返回 ``None``，表示所请求的模块无法找到。"

#: ../../library/imp.rst:373
msgid ""
"``None`` is inserted into ``sys.path_importer_cache`` instead of an instance"
" of :class:`NullImporter`."
msgstr ""
"将把 ``None`` 插入到 ``sys.path_importer_cache`` 而不是 :class:`NullImporter` 的实例。"

#: ../../library/imp.rst:377
msgid "Insert ``None`` into ``sys.path_importer_cache`` instead."
msgstr "改为将 ``None`` 插入到 ``sys.path_importer_cache``。"

#: ../../library/imp.rst:384
msgid "Examples"
msgstr "例子"

#: ../../library/imp.rst:386
msgid ""
"The following function emulates what was the standard import statement up to"
" Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't"
" work in that version, since :func:`find_module` has been extended and "
":func:`load_module` has been added in 1.4.) ::"
msgstr ""
"以下函数模拟了 Python 1.4 及之前版本的标准导入语句（没有多层级的模块名称）。 （这个 *实现* 不可用于那些版本，因为 "
":func:`find_module` 已经被扩展而 :func:`load_module` 在 1.4 中已被添加。） ::"
