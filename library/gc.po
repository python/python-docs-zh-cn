# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-15 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/gc.rst:2
msgid ":mod:`!gc` --- Garbage Collector interface"
msgstr ":mod:`!gc` --- 垃圾回收器接口"

#: ../../library/gc.rst:12
msgid ""
"This module provides an interface to the optional garbage collector.  It "
"provides the ability to disable the collector, tune the collection "
"frequency, and set debugging options.  It also provides access to "
"unreachable objects that the collector found but cannot free.  Since the "
"collector supplements the reference counting already used in Python, you can"
" disable the collector if you are sure your program does not create "
"reference cycles.  Automatic collection can be disabled by calling "
"``gc.disable()``.  To debug a leaking program call "
"``gc.set_debug(gc.DEBUG_LEAK)``. Notice that this includes "
"``gc.DEBUG_SAVEALL``, causing garbage-collected objects to be saved in "
"gc.garbage for inspection."
msgstr ""
"此模块提供可选的垃圾回收器的接口，提供的功能包括：关闭收集器、调整收集频率、设置调试选项。它同时提供对回收器找到但是无法释放的不可达对象的访问。由于 "
"Python 使用了带有引用计数的回收器，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 ``gc.disable()`` "
"关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 ``gc.set_debug(gc.DEBUG_LEAK)`` ；需要注意的是，它包含 "
"``gc.DEBUG_SAVEALL`` ，使得被垃圾回收的对象会被存放在 gc.garbage 中以待检查。"

#: ../../library/gc.rst:23
msgid "The :mod:`gc` module provides the following functions:"
msgstr ":mod:`gc` 模块提供下列函数："

#: ../../library/gc.rst:28
msgid "Enable automatic garbage collection."
msgstr "启用自动垃圾回收"

#: ../../library/gc.rst:33
msgid "Disable automatic garbage collection."
msgstr "停用自动垃圾回收"

#: ../../library/gc.rst:38
msgid "Return ``True`` if automatic collection is enabled."
msgstr "如果启用了自动回收则返回 ``True``。"

#: ../../library/gc.rst:43
msgid ""
"Perform a collection.  The optional argument *generation* may be an integer "
"specifying which generation to collect (from 0 to 2).  A :exc:`ValueError` "
"is raised if the generation number is invalid. The sum of collected objects "
"and uncollectable objects is returned."
msgstr ""
"执行回收。可选参数 *generation* 可以是一个整数，指定收集哪一代（从 0 到 2）。如果 generation 值无效将引发 "
":exc:`ValueError`。 返回已回收对象和不可回收对象的总和。"

#: ../../library/gc.rst:48
msgid ""
"Calling ``gc.collect(0)`` will perform a GC collection on the young "
"generation."
msgstr "调用 ``gc.collect(0)`` 将在青年代上执行 GC 收集。"

#: ../../library/gc.rst:50
msgid ""
"Calling ``gc.collect(1)`` will perform a GC collection on the young "
"generation and an increment of the old generation."
msgstr "调用 ``gc.collect(1)`` 将在青年代上执行 GC 收集并叠加老年代。"

#: ../../library/gc.rst:53
msgid ""
"Calling ``gc.collect(2)`` or ``gc.collect()`` performs a full collection"
msgstr "调用 ``gc.collect(2)`` 或 ``gc.collect()`` 将执行一次完整的回收"

#: ../../library/gc.rst:55
msgid ""
"The free lists maintained for a number of built-in types are cleared "
"whenever a full collection or collection of the highest generation (2) is "
"run.  Not all items in some free lists may be freed due to the particular "
"implementation, in particular :class:`float`."
msgstr ""
"每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 :class:`float` "
"的实现，在某些空闲列表中并非所有项都会被释放。"

#: ../../library/gc.rst:60
msgid ""
"The effect of calling ``gc.collect()`` while the interpreter is already "
"performing a collection is undefined."
msgstr "当解释器已经在执行收集任务时调用 ``gc.collect()`` 的效果是未定义的。"

#: ../../library/gc.rst:63
msgid "``generation=1`` performs an increment of collection."
msgstr "``generation=1`` 执行一次增量回收。"

#: ../../library/gc.rst:69
msgid ""
"Set the garbage collection debugging flags. Debugging information will be "
"written to ``sys.stderr``.  See below for a list of debugging flags which "
"can be combined using bit operations to control debugging."
msgstr ""
"设置垃圾回收器的调试标识位。调试信息会被写入 ``sys.stderr`` "
"。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。"

#: ../../library/gc.rst:76
msgid "Return the debugging flags currently set."
msgstr "返回当前调试标识位。"

#: ../../library/gc.rst:82
msgid ""
"Returns a list of all objects tracked by the collector, excluding the list "
"returned. If *generation* is not ``None``, return only the objects as "
"follows:"
msgstr ""
"返回一个由垃圾回收器所跟踪的所有对象组成的列表，不包括已返回对象的列表。 如果 *generation* 不为 ``None``，则只返回下列对象："

#: ../../library/gc.rst:85
msgid "0: All objects in the young generation"
msgstr "0：在青年代中的所有对象"

#: ../../library/gc.rst:86
msgid "1: No objects, as there is no generation 1 (as of Python 3.14)"
msgstr "1: 无对象，因为（自 Python 3.14 起）已不存在第 1 代。"

#: ../../library/gc.rst:87
msgid "2: All objects in the old generation"
msgstr "2: 在老年代中的所有对象"

#: ../../library/gc.rst:89
msgid "New *generation* parameter."
msgstr "新的 *generation* 形参。"

#: ../../library/gc.rst:92
msgid "Generation 1 is removed"
msgstr "第 1 代已被移除"

#: ../../library/gc.rst:95
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_objects`` with argument "
"``generation``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``gc.get_objects`` 并附带参数 ``generation``。"

#: ../../library/gc.rst:99
msgid ""
"Return a list of three per-generation dictionaries containing collection "
"statistics since interpreter start.  The number of keys may change in the "
"future, but currently each dictionary will contain the following items:"
msgstr ""
"返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容："

#: ../../library/gc.rst:104
msgid "``collections`` is the number of times this generation was collected;"
msgstr "``collections`` 是该代被回收的次数；"

#: ../../library/gc.rst:106
msgid ""
"``collected`` is the total number of objects collected inside this "
"generation;"
msgstr "``collected`` 是该代中被回收的对象总数；"

#: ../../library/gc.rst:109
msgid ""
"``uncollectable`` is the total number of objects which were found to be "
"uncollectable (and were therefore moved to the :data:`garbage` list) inside "
"this generation."
msgstr "``uncollectable`` 是在这一代中被发现无法收集的对象总数 （因此被移动到 :data:`garbage` 列表中）。"

#: ../../library/gc.rst:118
msgid ""
"Set the garbage collection thresholds (the collection frequency). Setting "
"*threshold0* to zero disables collection."
msgstr "设置垃圾回收阈值（收集频率）。 将 *threshold0* 设为零会禁用回收。"

#: ../../library/gc.rst:121
msgid ""
"The GC classifies objects into two generations depending on whether they "
"have survived a collection. New objects are placed in the young generation. "
"If an object survives a collection it is moved into the old generation."
msgstr "GC根据对象是否在回收中幸存下来将其分为两代。新对象被放置在青年代中。如果一个对象在回收中幸存下来，则将其移动到老年代中。"

#: ../../library/gc.rst:125
msgid ""
"In order to decide when to run, the collector keeps track of the number of "
"object allocations and deallocations since the last collection.  When the "
"number of allocations minus the number of deallocations exceeds "
"*threshold0*, collection starts. For each collection, all the objects in the"
" young generation and some fraction of the old generation is collected."
msgstr ""
"为了决定何时运行，回收器会跟踪自上次回收以来对象分配和释放的数量。当分配数减去释放数超过 *threshold0* "
"时，启动回收。每次回收都会回收青年代的所有对象和老年代的一部分对象。"

#: ../../library/gc.rst:131
msgid ""
"In the free-threaded build, the increase in process memory usage is also "
"checked before running the collector.  If the memory usage has not increased"
" by 10% since the last collection and the net number of object allocations "
"has not exceeded 40 times *threshold0*, the collection is not run."
msgstr ""
"在自由线程构建中，在运行回收器之前还会检查进程内存使用量的增加。如果自上次回收以来内存使用量没有增加10%，并且对象分配的净数量没有超过40倍 "
"*threshold0* ，则不会运行回收。"

#: ../../library/gc.rst:136
msgid ""
"The fraction of the old generation that is collected is **inversely** "
"proportional to *threshold1*. The larger *threshold1* is, the slower objects"
" in the old generation are collected. For the default value of 10, 1% of the"
" old generation is scanned during each collection."
msgstr ""
"被回收的老年代数据的比例与 *threshold1* 成 **反比**。*threshold1* "
"越大，老年代对象的收集速度越慢。对于默认值10，在每次回收期间扫描老年代的1%。"

#: ../../library/gc.rst:141
msgid "*threshold2* is ignored."
msgstr "*threshold2* 被忽略。"

#: ../../library/gc.rst:143
msgid ""
"See `Garbage collector design "
"<https://devguide.python.org/garbage_collector>`_ for more information."
msgstr "更多信息，请参阅 `垃圾回收器设计 <https://devguide.python.org/garbage_collector>`_。"

#: ../../library/gc.rst:145
msgid "*threshold2* is ignored"
msgstr "*threshold2* 将被忽略"

#: ../../library/gc.rst:151
msgid ""
"Return the current collection  counts as a tuple of ``(count0, count1, "
"count2)``."
msgstr "将当前回收计数以形为 ``(count0, count1, count2)`` 的元组返回。"

#: ../../library/gc.rst:157
msgid ""
"Return the current collection thresholds as a tuple of ``(threshold0, "
"threshold1, threshold2)``."
msgstr "将当前回收阈值以形为 ``(threshold0, threshold1, threshold2)`` 的元组返回。"

#: ../../library/gc.rst:163
msgid ""
"Return the list of objects that directly refer to any of objs. This function"
" will only locate those containers which support garbage collection; "
"extension types which do refer to other objects but do not support garbage "
"collection will not be found."
msgstr "返回直接引用任意一个 *objs* 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。"

#: ../../library/gc.rst:168
msgid ""
"Note that objects which have already been dereferenced, but which live in "
"cycles and have not yet been collected by the garbage collector can be "
"listed among the resulting referrers.  To get only currently live objects, "
"call :func:`collect` before calling :func:`get_referrers`."
msgstr ""
"需要注意的是，已经解除对 *objs* 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 "
"*objs* 的对象，需要调用 :func:`collect` 然后再调用 :func:`get_referrers` 。"

#: ../../library/gc.rst:174
msgid ""
"Care must be taken when using objects returned by :func:`get_referrers` "
"because some of them could still be under construction and hence in a "
"temporarily invalid state. Avoid using :func:`get_referrers` for any purpose"
" other than debugging."
msgstr ""
"在使用 :func:`get_referrers` 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 "
":func:`get_referrers` 用于调试以外的其它目的。"

#: ../../library/gc.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referrers`` with "
"argument ``objs``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``gc.get_referrers`` 并附带参数 ``objs``。"

#: ../../library/gc.rst:184
msgid ""
"Return a list of objects directly referred to by any of the arguments. The "
"referents returned are those objects visited by the arguments' C-level "
":c:member:`~PyTypeObject.tp_traverse` methods (if any), and may not be all "
"objects actually directly reachable.  :c:member:`~PyTypeObject.tp_traverse` "
"methods are supported only by objects that support garbage collection, and "
"are only required to visit objects that may be involved in a cycle.  So, for"
" example, if an integer is directly reachable from an argument, that integer"
" object may or may not appear in the result list."
msgstr ""
"返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） "
":c:member:`~PyTypeObject.tp_traverse` 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 "
":c:member:`~PyTypeObject.tp_traverse`  "
"方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。"

#: ../../library/gc.rst:192
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referents`` with "
"argument ``objs``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``gc.get_referents`` 并附带参数 ``objs``。"

#: ../../library/gc.rst:196
msgid ""
"Returns ``True`` if the object is currently tracked by the garbage "
"collector, ``False`` otherwise.  As a general rule, instances of atomic "
"types aren't tracked and instances of non-atomic types (containers, user-"
"defined objects...) are.  However, some type-specific optimizations can be "
"present in order to suppress the garbage collector footprint of simple "
"instances (e.g. dicts containing only atomic keys and values)::"
msgstr ""
"当对象正在被垃圾回收器监控时返回 ``True`` ，否则返回 ``False`` "
"。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。"

#: ../../library/gc.rst:203
msgid ""
">>> gc.is_tracked(0)\n"
"False\n"
">>> gc.is_tracked(\"a\")\n"
"False\n"
">>> gc.is_tracked([])\n"
"True\n"
">>> gc.is_tracked({})\n"
"False\n"
">>> gc.is_tracked({\"a\": 1})\n"
"True"
msgstr ""
">>> gc.is_tracked(0)\n"
"False\n"
">>> gc.is_tracked(\"a\")\n"
"False\n"
">>> gc.is_tracked([])\n"
"True\n"
">>> gc.is_tracked({})\n"
"False\n"
">>> gc.is_tracked({\"a\": 1})\n"
"True"

#: ../../library/gc.rst:219
msgid ""
"Returns ``True`` if the given object has been finalized by the garbage "
"collector, ``False`` otherwise. ::"
msgstr "如果给定对象已被垃圾回收器终结则返回 ``True``，否则返回 ``False``。 ::"

#: ../../library/gc.rst:222
msgid ""
">>> x = None\n"
">>> class Lazarus:\n"
"...     def __del__(self):\n"
"...         global x\n"
"...         x = self\n"
"...\n"
">>> lazarus = Lazarus()\n"
">>> gc.is_finalized(lazarus)\n"
"False\n"
">>> del lazarus\n"
">>> gc.is_finalized(x)\n"
"True"
msgstr ""
">>> x = None\n"
">>> class Lazarus:\n"
"...     def __del__(self):\n"
"...         global x\n"
"...         x = self\n"
"...\n"
">>> lazarus = Lazarus()\n"
">>> gc.is_finalized(lazarus)\n"
"False\n"
">>> del lazarus\n"
">>> gc.is_finalized(x)\n"
"True"

#: ../../library/gc.rst:240
msgid ""
"Freeze all the objects tracked by the garbage collector; move them to a "
"permanent generation and ignore them in all the future collections."
msgstr "冻结由垃圾回收器追踪的所有对象；将它们移至永久世代并在所有未来的回收操作中忽略它们。"

#: ../../library/gc.rst:243
msgid ""
"If a process will ``fork()`` without ``exec()``, avoiding unnecessary copy-"
"on-write in child processes will maximize memory sharing and reduce overall "
"memory usage. This requires both avoiding creation of freed \"holes\" in "
"memory pages in the parent process and ensuring that GC collections in child"
" processes won't touch the ``gc_refs`` counter of long-lived objects "
"originating in the parent process. To accomplish both, call ``gc.disable()``"
" early in the parent process, ``gc.freeze()`` right before ``fork()``, and "
"``gc.enable()`` early in child processes."
msgstr ""
"如果一个进程将执行 ``fork()`` 而不执行 ``exec()``，则在子进程中避免不必要的写入时拷贝将最大化内存共享并减少总体内存使用。 "
"这需要同时在父进程的内存页中避免创建已释放的“空洞”并确保在子进程中的 GC 回收不会触及源自父进程的长寿对象的 ``gc_refs`` 计数器。 "
"要同时达成这两个目标，请在父进程中尽早调用 ``gc.disable()``，在 ``fork()`` 之前调用 "
"``gc.freeze()``，并在子进程中尽早调用 ``gc.enable()``。 "

#: ../../library/gc.rst:257
msgid ""
"Unfreeze the objects in the permanent generation, put them back into the "
"oldest generation."
msgstr "解冻永久代中的对象，并将它们放回到年老代中。"

#: ../../library/gc.rst:265
msgid "Return the number of objects in the permanent generation."
msgstr "返回永久代中的对象数量。"

#: ../../library/gc.rst:270
msgid ""
"The following variables are provided for read-only access (you can mutate "
"the values but should not rebind them):"
msgstr "提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）："

#: ../../library/gc.rst:275
msgid ""
"A list of objects which the collector found to be unreachable but could not "
"be freed (uncollectable objects).  Starting with Python 3.4, this list "
"should be empty most of the time, except when using instances of C extension"
" types with a non-``NULL`` ``tp_del`` slot."
msgstr ""
"一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 "
"``NULL`` ``tp_del`` 空位的 C 扩展类型的实例。"

#: ../../library/gc.rst:280
msgid ""
"If :const:`DEBUG_SAVEALL` is set, then all unreachable objects will be added"
" to this list rather than freed."
msgstr "如果设置了 :const:`DEBUG_SAVEALL` ，则所有不可访问对象将被添加至该列表而不会被释放。"

#: ../../library/gc.rst:283
msgid ""
"If this list is non-empty at :term:`interpreter shutdown`, a "
":exc:`ResourceWarning` is emitted, which is silent by default.  If "
":const:`DEBUG_UNCOLLECTABLE` is set, in addition all uncollectable objects "
"are printed."
msgstr ""
"当 :term:`interpreter shutdown` 即解释器关闭时，若此列表非空，会产生 :exc:`ResourceWarning` "
"，即资源警告，在默认情况下此警告不会被提醒。如果设置了 :const:`DEBUG_UNCOLLECTABLE` ，所有无法被回收的对象会被打印。"

#: ../../library/gc.rst:289
msgid ""
"Following :pep:`442`, objects with a :meth:`~object.__del__` method don't "
"end up in :data:`gc.garbage` anymore."
msgstr ""
"根据 :pep:`442`，具有 :meth:`~object.__del__` 方法的对象不会再由 :data:`gc.garbage` 来处理。"

#: ../../library/gc.rst:295
msgid ""
"A list of callbacks that will be invoked by the garbage collector before and"
" after collection.  The callbacks will be called with two arguments, *phase*"
" and *info*."
msgstr "在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： *phase* 和 *info* 。"

#: ../../library/gc.rst:299
msgid "*phase* can be one of two values:"
msgstr "*phase* 可为以下两值之一："

#: ../../library/gc.rst:301
msgid "\"start\": The garbage collection is about to start."
msgstr "\"start\": 垃圾回收即将开始。"

#: ../../library/gc.rst:303
msgid "\"stop\": The garbage collection has finished."
msgstr "\"stop\": 垃圾回收已结束。"

#: ../../library/gc.rst:305
msgid ""
"*info* is a dict providing more information for the callback.  The following"
" keys are currently defined:"
msgstr " *info* 是一个字典，提供了回调函数更多信息。已有定义的键有："

#: ../../library/gc.rst:308
msgid "\"generation\": The oldest generation being collected."
msgstr "\"generation\"（代） ：正在被回收的最久远的一代。"

#: ../../library/gc.rst:310
msgid ""
"\"collected\": When *phase* is \"stop\", the number of objects successfully "
"collected."
msgstr "\"collected\"（已回收的 ）: 当*phase* 为 \"stop\" 时，被成功回收的对象的数目。"

#: ../../library/gc.rst:313
msgid ""
"\"uncollectable\": When *phase* is \"stop\", the number of objects that "
"could not be collected and were put in :data:`garbage`."
msgstr ""
"\"uncollectable\"（不可回收的）: 当 *phase* 为 \"stop\" 时，不能被回收并被放入 :data:`garbage` "
"的对象的数目。"

#: ../../library/gc.rst:316
msgid ""
"Applications can add their own callbacks to this list.  The primary use "
"cases are:"
msgstr "应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有："

#: ../../library/gc.rst:319
msgid ""
"Gathering statistics about garbage collection, such as how often various "
"generations are collected, and how long the collection takes."
msgstr "统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。"

#: ../../library/gc.rst:323
msgid ""
"Allowing applications to identify and clear their own uncollectable types "
"when they appear in :data:`garbage`."
msgstr "使应用程序可以识别和清理他们自己的在 :data:`garbage` 中的不可回收类型的对象。"

#: ../../library/gc.rst:329
msgid "The following constants are provided for use with :func:`set_debug`:"
msgstr "以下常量被用于 :func:`set_debug` ："

#: ../../library/gc.rst:334
msgid ""
"Print statistics during collection.  This information can be useful when "
"tuning the collection frequency."
msgstr "在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。"

#: ../../library/gc.rst:340
msgid "Print information on collectable objects found."
msgstr "当发现可回收对象时打印信息。"

#: ../../library/gc.rst:345
msgid ""
"Print information of uncollectable objects found (objects which are not "
"reachable but cannot be freed by the collector).  These objects will be "
"added to the ``garbage`` list."
msgstr "打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 ``garbage`` 列表中。"

#: ../../library/gc.rst:349
msgid ""
"Also print the contents of the :data:`garbage` list at :term:`interpreter "
"shutdown`, if it isn't empty."
msgstr ""
"当 :term:`interpreter shutdown` 时，即解释器关闭时，若 :data:`garbage` "
"列表中存在对象，这些对象也会被打印输出。"

#: ../../library/gc.rst:355
msgid ""
"When set, all unreachable objects found will be appended to *garbage* rather"
" than being freed.  This can be useful for debugging a leaking program."
msgstr "设置后，所有回收器找到的不可达对象会被添加进 *garbage* 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。"

#: ../../library/gc.rst:361
msgid ""
"The debugging flags necessary for the collector to print information about a"
" leaking program (equal to ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL``)."
msgstr ""
"调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL`` ）。"
