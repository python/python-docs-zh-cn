# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Meng Du <alphanow@gmail.com>, 2020
# walkinrain <walkinrain2008@outlook.com>, 2020
# ppcfish <ppcfish@gmail.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 11:56+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asynchat.rst:2
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ":mod:`asynchat` --- 异步 socket 指令/响应 处理器"

#: ../../library/asynchat.rst:10
msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr "**源代码:** :source:`Lib/asynchat.py`"

#: ../../library/asynchat.rst:12
msgid "Please use :mod:`asyncio` instead."
msgstr "请使用 :mod:`asyncio` 替代。"

#: ../../library/asynchat.rst:19
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr "该模块仅为提供向后兼容。我们推荐在新代码中使用 :mod:`asyncio` 。"

#: ../../library/asynchat.rst:22
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data`"
" and :meth:`found_terminator` methods. It uses the same asynchronous loop as"
" :mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher`"
" and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new "
":class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""
"此模块在 :mod:`asyncore` 框架之上构建，简化了异步客户端和服务器并使得处理元素为以任意字符串结束或者为可变长度的协议更加容易。 "
":mod:`asynchat` 定义了一个可以由你来子类化的抽象类 :class:`async_chat`，提供了 "
":meth:`collect_incoming_data` 和 :meth:`found_terminator` 等方法的实现。 它使用与 "
":mod:`asyncore` 相同的异步循环，并且可以在通道映射中自由地混合 :class:`asyncore.dispatcher` 和 "
":class:`asynchat.async_chat` 这两种类型的通道。 一般来说 :class:`asyncore.dispatcher` "
"服务器通道在接收到传入的连接请求时会生成新的 :class:`asynchat.async_chat` 通道对象。"

#: ../../library/asynchat.rst:37
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""
"这个类是 :class:`asyncore.dispatcher` 的抽象子类。 对于实际使用的代码你必须子类化 "
":class:`async_chat`，提供有意义的 :meth:`collect_incoming_data` 和 "
":meth:`found_terminator` 方法。 :class:`asyncore.dispatcher` "
"的方法也可以被使用，但它们在消息/响应上下文中并不是全都有意义。"

#: ../../library/asynchat.rst:44
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a "
":c:func:`select` call. Once the polling loop has been started the "
":class:`async_chat` object's methods are called by the event-processing "
"framework with no action on the part of the programmer."
msgstr ""
"与 :class:`asyncore.dispatcher` 类似，:class:`async_chat` 也定义了一组通过对 "
":c:func:`select` 调用之后的套接字条件进行分析所生成的事件。 一旦启动轮询循环 :class:`async_chat` "
"对象的方法就会被事件处理框架调用而无须程序员方面做任何操作。"

#: ../../library/asynchat.rst:50
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr "两个可被修改的类属性，用以提升性能，甚至也可能会节省内存。"

#: ../../library/asynchat.rst:56
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr "异步输入缓冲区大小 (默认为 ``4096``)。"

#: ../../library/asynchat.rst:61
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr "异步输出缓冲区大小 (默认为 ``4096``)。"

#: ../../library/asynchat.rst:63
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a :abbr:`FIFO (first-in, first-out)` queue of *producers*. A producer"
" need have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty"
" bytes object. At this point the :class:`async_chat` object removes the "
"producer from the queue and starts using the next producer, if any. When the"
" producer queue is empty the :meth:`handle_write` method does nothing. You "
"use the channel object's :meth:`set_terminator` method to describe how to "
"recognize the end of, or an important breakpoint in, an incoming "
"transmission from the remote endpoint."
msgstr ""
"与 :class:`asyncore.dispatcher` 不同，:class:`async_chat` 允许你定义一个 :abbr:`FIFO "
"(先进先出)` 队列 *producers*。 其中的生产者只需要一个方法 :meth:`more`，该方法应当返回要在通道上传输的数据。 "
"生产者通过让其 :meth:`more` 方法返回空字节串对象来表明其处于耗尽状态 (*意即* 它已不再包含数据)。 此时 "
":class:`async_chat` 对象会将该生产者从队列中移除并开始使用下一个生产者，如果有下一个的话。 当生产者队列为空时 "
":meth:`handle_write` 方法将不执行任何操作。 你要使用通道对象的 :meth:`set_terminator` "
"方法来描述如何识别来自远程端点的入站传输的结束或是重要的中断点。"

#: ../../library/asynchat.rst:76
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods "
":meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""
"要构建一个可用的 :class:`async_chat` 子类，你的输入方法 :meth:`collect_incoming_data` 和 "
":meth:`found_terminator` 必须要处理通道异步接收的数据。 这些参数的描述见下文。"

#: ../../library/asynchat.rst:84
msgid ""
"Pushes a ``None`` on to the producer queue. When this producer is popped off"
" the queue it causes the channel to be closed."
msgstr "将 ``None`` 推入生产者队列。 当此生产者被弹出队列时它将导致通道被关闭。"

#: ../../library/asynchat.rst:90
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a "
":exc:`NotImplementedError` exception."
msgstr ""
"调用时附带 *data*，其中包含任意数量的已接收数据。 必须被重载的默认方法将引发一个 :exc:`NotImplementedError` 异常。"

#: ../../library/asynchat.rst:97
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer queue."
msgstr "在紧急情况下此方法将丢弃输入和/或输出缓冲区以及生产者队列中的任何数据。"

#: ../../library/asynchat.rst:103
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""
"当输入数据流能匹配 :meth:`set_terminator` 所设定的终结条件时会被调用。 必须被重载的默认方法将引发一个 "
":exc:`NotImplementedError` 异常。 被缓冲的输入数据应当可以通过实例属性来获取。"

#: ../../library/asynchat.rst:111
msgid "Returns the current terminator for the channel."
msgstr "返回通道的当前终结器。"

#: ../../library/asynchat.rst:116
msgid ""
"Pushes data on to the channel's queue to ensure its transmission. This is "
"all you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to"
" implement encryption and chunking, for example."
msgstr ""
"将数据推入通道的队列以确保其被传输。 "
"要让通道将数据写到网络中你只需要这样做就足够了，虽然以更复杂的方式使用你自己的生产者也是有可能的，例如为了实现加密和分块。"

#: ../../library/asynchat.rst:124
msgid ""
"Takes a producer object and adds it to the producer queue associated with "
"the channel.  When all currently-pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method"
" and send the data to the remote endpoint."
msgstr ""
"获取一个生产者对象并将其加入到与通道相关联的生产者队列中。 当所有当前已推入的生产者都已被耗尽时通道将通过调用其 :meth:`more` "
"方法来耗用此生产者的数据并将数据发送至远程端点。"

#: ../../library/asynchat.rst:132
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to"
" handle incoming protocol data."
msgstr "设置可在通道上被识别的终结条件。 ``term`` 可以是三种类型值中的任意一种 ，对应于处理入站协议数据的三种不同方式。"

#: ../../library/asynchat.rst:137
msgid "term"
msgstr "term"

#: ../../library/asynchat.rst:137
msgid "Description"
msgstr "描述"

#: ../../library/asynchat.rst:139
msgid "*string*"
msgstr "*string*"

#: ../../library/asynchat.rst:139
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr "当在输入流中发现该字符串时将会调用 :meth:`found_terminator`"

#: ../../library/asynchat.rst:142
msgid "*integer*"
msgstr "*integer*"

#: ../../library/asynchat.rst:142
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr "当接收到指定数量的字符时将会调用 :meth:`found_terminator`"

#: ../../library/asynchat.rst:146
msgid "``None``"
msgstr "``None``"

#: ../../library/asynchat.rst:146
msgid "The channel continues to collect data forever"
msgstr "通道会不断地持续收集数据"

#: ../../library/asynchat.rst:150
msgid ""
"Note that any data following the terminator will be available for reading by"
" the channel after :meth:`found_terminator` is called."
msgstr "请注意终结器之后的任何数据将可在 :meth:`found_terminator` 被调用后由通道来读取。"

#: ../../library/asynchat.rst:157
msgid "asynchat Example"
msgstr "asynchat 示例"

#: ../../library/asynchat.rst:159
msgid ""
"The following partial example shows how HTTP requests can be read with "
":class:`async_chat`.  A web server might create an "
":class:`http_request_handler` object for each incoming client connection. "
"Notice that initially the channel terminator is set to match the blank line "
"at the end of the HTTP headers, and a flag indicates that the headers are "
"being read."
msgstr ""
"下面的例子片段显示了如何通过 :class:`async_chat` 来读取 HTTP 请求。 Web 服务器可以为每个入站的客户端连接创建 "
":class:`http_request_handler` 对象。 请注意在初始时通道终结器会被设置为匹配 HTTP "
"请求头末尾的空行，并且会用一个旗标来指明请求头正在被读取。"

#: ../../library/asynchat.rst:166
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-"
"Length:`` header is used to set a numeric terminator to read the right "
"amount of data from the channel."
msgstr ""
"一旦完成了标头的读取，如果请求类型为 POST (表明输入流中存在更多的数据) 则会使用 ``Content-Length:`` "
"标头来设置一个数值终结器以从通道读取适当数量的数据。"

#: ../../library/asynchat.rst:171
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been"
" marshalled, after setting the channel terminator to ``None`` to ensure that"
" any extraneous data sent by the web client are ignored. ::"
msgstr ""
"一旦完成了对所有相关输入的处理，将会在设置通道终结器为 ``None`` 以确保忽略掉 Web 客户端所发送的任何无关数据之后调用 "
":meth:`handle_request` 方法。 ::"
