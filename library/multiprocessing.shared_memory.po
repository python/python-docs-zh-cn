# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# zeroswan <zeroswan@outlook.com>, 2021
# Chi Xu <jackson1014qq@gmail.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# ppcfish <ppcfish@gmail.com>, 2024
# Kade For, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-27 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.shared_memory.rst:2
msgid ""
":mod:`!multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ":mod:`!multiprocessing.shared_memory` --- 可跨进程直接访问的共享内存"

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**源代码:** :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes,"
" a :class:`~multiprocessing.managers.BaseManager` subclass, "
":class:`~multiprocessing.managers.SharedMemoryManager`, is also provided in "
"the :mod:`multiprocessing.managers` module."
msgstr ""
"该模块提供了一个 :class:`SharedMemory` 类，用于分配和管理多核或对称多处理器（SMP）机器上进程间的共享内存。 "
"为了协助进行不同进程间共享内存的生命周期管理，在 :mod:`multiprocessing.managers` 模块中还提供了一个 "
":class:`~multiprocessing.managers.BaseManager` 的子类 "
":class:`~multiprocessing.managers.SharedMemoryManager`。"

#: ../../library/multiprocessing.shared_memory.rst:26
msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory blocks"
" (though is not necessarily implemented explicitly as such) and does not "
"refer to \"distributed shared memory\".  This style of shared memory permits"
" distinct processes to potentially read and write to a common (or shared) "
"region of volatile memory.  Processes are conventionally limited to only "
"have access to their own process memory space but shared memory permits the "
"sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data"
" via disk or socket or other communications requiring the "
"serialization/deserialization and copying of data."
msgstr ""
"在本模块中，共享内存是指“POSIX 风格”的共享内存块（虽然它并不一定被显式地以这种风格实现）而不是指“分布式共享内存”。 "
"这种风格的共享内存允许不同进程读写一块共同的（或共享的）易失性内存区域。 "
"进程在传统上被限制为只能访问它们自己的进程内存空间而共享内存则允许跨进程共享数据，从而避免通过进程间发送消息的形式传递数据。 "
"相比通过磁盘或套接字或者其他需要序列化/反序列化以及数据拷贝的共享形式，直接通过内存共享数据可提供显著的性能提升。"

#: ../../library/multiprocessing.shared_memory.rst:41
msgid ""
"Create an instance of the :class:`!SharedMemory` class for either creating a"
" new shared memory block or attaching to an existing shared memory block.  "
"Each shared memory block is assigned a unique name. In this way, one process"
" can create a shared memory block with a particular name and a different "
"process can attach to that same shared memory block using that same name."
msgstr ""
"创建一个 :class:`!SharedMemory` 类的实例用来新建一个共享内存块或关联到一个已存在的共享内存块。 "
"每个共享内存块都被赋予一个独有的名称。 通过这种方式，进程可以创建一个具有特定名称的共享内存块然后别的进程可以使用相同的名称关联到相同的共享内存块。"

#: ../../library/multiprocessing.shared_memory.rst:48
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink` method should "
"be called to ensure proper cleanup."
msgstr ""
"作为一种跨进程共享数据的方式，共享内存块的寿命可以超过创建它的原始进程。 当一个进程不再需要访问一个可能仍被其他进程所需要的的共享内存块时，应当调用 "
":meth:`close` 方法。 当一个共享内存块不再被任何进程所需要时，则应当调用 :meth:`unlink` 方法以确保执行适当的清理操作。"

#: ../../library/multiprocessing.shared_memory.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/multiprocessing.shared_memory.rst:55
msgid ""
"The unique name for the requested shared memory, specified as a string. When"
" creating a new shared memory block, if ``None`` (the default) is supplied "
"for the name, a novel name will be generated."
msgstr ""
"被请求的共享内存的独有名称，以字符串形式指定。 当创建新的共享内存块时，如果提供 ``None`` 作为名称（默认值），将随机生成一个新名称。"

#: ../../library/multiprocessing.shared_memory.rst:61
msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr "控制是要创建新的共享内存块 (``True``) 还是关联到已有的共享内存块 (``False``)。"

#: ../../library/multiprocessing.shared_memory.rst:65
msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon that "
"platform's memory page size, the exact size of the shared memory block may "
"be larger or equal to the size requested. When attaching to an existing "
"shared memory block, the *size* parameter is ignored."
msgstr ""
"当创建新的共享内存块时所请求的字节数。 由于某些平台会选择根据平台的内存页大小来分配内存块，因此共享内存块的实际大小可能会大于等于所请求的大小。 "
"当关联到已有的共享内存块时，*size* 形参将被忽略。"

#: ../../library/multiprocessing.shared_memory.rst:73
msgid ""
"When ``True``, register the shared memory block with a resource tracker "
"process on platforms where the OS does not do this automatically. The "
"resource tracker ensures proper cleanup of the shared memory even if all "
"other processes with access to the memory exit without doing so. Python "
"processes created from a common ancestor using :mod:`multiprocessing` "
"facilities share a single resource tracker process, and the lifetime of "
"shared memory segments is handled automatically among these processes. "
"Python processes created in any other way will receive their own resource "
"tracker when accessing shared memory with *track* enabled. This will cause "
"the shared memory to be deleted by the resource tracker of the first process"
" that terminates. To avoid this issue, users of :mod:`subprocess` or "
"standalone Python processes should set *track* to ``False`` when there is "
"already another process in place that does the bookkeeping. *track* is "
"ignored on Windows, which has its own tracking and automatically deletes "
"shared memory when all handles to it have been closed."
msgstr ""
"当为 ``True`` 时，将在 OS 不会自动为共享内存块注册资源跟踪器进程的平台上执行注册操作。 "
"资源跟踪器会确保共享内存的正确清理，即使全部其他具有该内存访问权限的进程均未执行清理即退出。 使用 :mod:`multiprocessing` "
"的工具创建的具有共同上级的 Python 进程将共享一个资源跟踪器进程，并且共享内存段的生命周期将在这些进程中自动进行管理。 以任何其他方式创建的 "
"Python 进程在启用 *track* 的情况下访问共享内存时将获得它们自己的资源跟踪器。 这将导致共享内存会被第一个终结的进程的资源跟踪器删除。 "
"为避免此问题，:mod:`subprocess` 或独立 Python 进程的使用者在已经有另一个进程执行跟踪记录时应当将 *track* 设为 "
"``False``。在 Windows 上 *track* 将被忽略，因为该系统有自己的跟踪机制并会在所有指向特定共享内存的句柄被关闭时自动删除它。"

#: ../../library/multiprocessing.shared_memory.rst:91
msgid "Added the *track* parameter."
msgstr "增加了 *track* 形参。"

#: ../../library/multiprocessing.shared_memory.rst:96
msgid ""
"Close the file descriptor/handle to the shared memory from this instance.  "
":meth:`close` should be called once access to the shared memory block from "
"this instance is no longer needed.  Depending on operating system, the "
"underlying memory may or may not be freed even if all handles to it have "
"been closed.  To ensure proper cleanup, use the :meth:`unlink` method."
msgstr ""
"关闭该实例指向共享内存的文件描述符/句柄。 一旦不再需要从该实例指向共享内存块的访问权限 :meth:`close` 就应当被调用。 "
"根据具体的操作系统，即使所有指向下层内存的句柄都已被关闭，内存都有可能被释放也有可能不被释放。 要确保正确的清理，请使用 :meth:`unlink` "
"方法。"

#: ../../library/multiprocessing.shared_memory.rst:105
msgid ""
"Delete the underlying shared memory block.  This should be called only once "
"per shared memory block regardless of the number of handles to it, even in "
"other processes. :meth:`unlink` and :meth:`close` can be called in any "
"order, but trying to access data inside a shared memory block after "
":meth:`unlink` may result in memory access errors, depending on platform."
msgstr ""
"删除下层的共享内存块。 此方法在每个共享内存块上应当只被调用一次，无论指向它的句柄数量有多少。 :meth:`unlink` 和 "
":meth:`close` 可以按任意顺序调用，但在can be called in any order, but trying to access "
"data inside a shared memory block after :meth:`unlink` "
"之后再试图访问共享内存块中的数据将导致内存访问错误，其种类取决于具体的系统平台。"

#: ../../library/multiprocessing.shared_memory.rst:112
msgid ""
"This method has no effect on Windows, where the only way to delete a shared "
"memory block is to close all handles."
msgstr "此方法在 Windows 上无效，在该系统上删除共享内存块的唯一方式是关闭所有的句柄。"

#: ../../library/multiprocessing.shared_memory.rst:117
msgid "A memoryview of contents of the shared memory block."
msgstr "共享内存块内容的 memoryview 。"

#: ../../library/multiprocessing.shared_memory.rst:121
msgid "Read-only access to the unique name of the shared memory block."
msgstr "共享内存块的唯一标识，只读属性。"

#: ../../library/multiprocessing.shared_memory.rst:125
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "共享内存块的字节大小，只读属性。"

#: ../../library/multiprocessing.shared_memory.rst:128
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr "以下示例展示了 :class:`SharedMemory` 底层的用法::"

#: ../../library/multiprocessing.shared_memory.rst:131
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # Modify multiple at once\n"
">>> buffer[4] = 100                           # Modify single byte at a time\n"
">>> # Attach to an existing shared memory block\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # Copy the data into a new array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # Modify via shm_b using bytes\n"
">>> bytes(shm_a.buf[:5])      # Access via shm_a\n"
"b'howdy'\n"
">>> shm_b.close()   # Close each SharedMemory instance\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # Call unlink only once to release the shared memory"
msgstr ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # 一次修改多个字节\n"
">>> buffer[4] = 100                           # 一次修改单个字节\n"
">>> # 关联到现有的共享内存块\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # 将数据拷贝到一个新的 array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # 通过 shm_b 使用字节串来修改\n"
">>> bytes(shm_a.buf[:5])      # 通过 shm_a 来访问\n"
"b'howdy'\n"
">>> shm_b.close()   # 关闭每个 SharedMemory 实例\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # 仅调用一次 unlink 来释放共享内存"

#: ../../library/multiprocessing.shared_memory.rst:154
msgid ""
"The following example demonstrates a practical use of the "
":class:`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, "
"accessing the same :class:`!numpy.ndarray` from two distinct Python shells:"
msgstr ""
"下面的例子展示了 :class:`SharedMemory` 类配合 `NumPy 数组 <https://numpy.org/>`_ "
"的实际应用，从两个独立的 Python shell 访问相同的 :class:`!numpy.ndarray`:"

#: ../../library/multiprocessing.shared_memory.rst:158
msgid ""
">>> # In the first Python interactive shell\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Start with an existing NumPy array\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # We did not specify a name so one was chosen for us\n"
"'psm_21467_46075'\n"
"\n"
">>> # In either the same shell or a new Python shell on the same machine\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Attach to the existing shared memory block\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Note that a.shape is (6,) and a.dtype is np.int64 in this example\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Back in the first Python interactive shell, b reflects this change\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Clean up from within the second Python shell\n"
">>> del c  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> existing_shm.close()\n"
"\n"
">>> # Clean up from within the first Python shell\n"
">>> del b  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> shm.close()\n"
">>> shm.unlink()  # Free and release the shared memory block at the very end"
msgstr ""
">>> # 在第一个 Python 交互式 shell 中\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # 从一个现有的 NumPy 数组开始\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # 我们没有指定名称因此会自动为我们选择一个\n"
"'psm_21467_46075'\n"
"\n"
">>> # 在同一个 shell 中或同一台机器上新的 Python shell 中\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # 关联到现有的共享内存块\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # 请注意在这个例子中 a.shape 为 (6,) 而 a.dtype 为 np.int64\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # 回到第一个 Python 交互式 shell，b 将反映出此变化\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # 在第二个 Python shell 中执行清理\n"
">>> del c  # 不是必须的；只是强调该数组已不再使用\n"
">>> existing_shm.close()\n"
"\n"
">>> # 在第一个 Python shell 中执行清理\n"
">>> del b  # 不是必须的；只是强制该数组已不再使用\n"
">>> shm.close()\n"
">>> shm.unlink()  # 最后清理并释放共享内存块"

#: ../../library/multiprocessing.shared_memory.rst:208
msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ":class:`multiprocessing.managers.BaseManager` 的子类，可被用于跨进程的共享内存块管理。"

#: ../../library/multiprocessing.shared_memory.rst:211
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a "
":class:`!SharedMemoryManager` instance causes a new process to be started. "
"This new process's sole purpose is to manage the life cycle of all shared "
"memory blocks created through it.  To trigger the release of all shared "
"memory blocks managed by that process, call "
":meth:`~multiprocessing.managers.BaseManager.shutdown` on the instance. This"
" triggers a :meth:`~multiprocessing.shared_memory.SharedMemory.unlink` call "
"on all of the :class:`SharedMemory` objects managed by that process and then"
" stops the process itself.  By creating :class:`!SharedMemory` instances "
"through a :class:`!SharedMemoryManager`, we avoid the need to manually track"
" and trigger the freeing of shared memory resources."
msgstr ""
"在 :class:`!SharedMemoryManager` 实例上调用 "
":meth:`~multiprocessing.managers.BaseManager.start` 方法会导致启动一个新进程。 "
"这个新进程的唯一目的就是管理所有通过它创建的共享内存块的生命周期。 想要释放该进程所管理的全部共享内存块，可以在实例上调用 "
":meth:`~multiprocessing.managers.BaseManager.shutdown`。 这会触发执行该进程所管理的所有 "
":class:`SharedMemory` 对象上的 "
":meth:`~multiprocessing.shared_memory.SharedMemory.unlink` 调用，然后停止该进程本身。 通过 "
":class:`!SharedMemoryManager` 创建 :class:`!SharedMemory` "
"实例，我们可以避免手动跟踪并触发共享内存资源的释放。"

#: ../../library/multiprocessing.shared_memory.rst:223
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory`"
" instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"这个类提供了创建和返回 :class:`SharedMemory` 实例的方法，以及以共享内存为基础创建一个列表类对象 "
"(:class:`ShareableList`) 的方法。"

#: ../../library/multiprocessing.shared_memory.rst:227
msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description of"
" the inherited *address* and *authkey* optional input arguments and how they"
" may be used to connect to an existing :class:`!SharedMemoryManager` service"
" from other processes."
msgstr ""
"请参阅 :class:`~multiprocessing.managers.BaseManager` 查看有关被继承的可选输入参数 *address* "
"和 *authkey* 以及如何使用它们来从其他进程连接已有的optional input arguments and how they may be "
"used to connect to an existing :class:`!SharedMemoryManager` 服务的说明。"

#: ../../library/multiprocessing.shared_memory.rst:234
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr "新建并返回一个具有指定的 *size* 个字节的 :class:`SharedMemory` 对象。"

#: ../../library/multiprocessing.shared_memory.rst:239
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input *sequence*."
msgstr "新建并返回一个 :class:`ShareableList` 对象，使用从 *sequence* 输入的值来初始化。"

#: ../../library/multiprocessing.shared_memory.rst:243
msgid ""
"The following example demonstrates the basic mechanisms of a "
":class:`~multiprocessing.managers.SharedMemoryManager`:"
msgstr ""
"下面的例子展示了 :class:`~multiprocessing.managers.SharedMemoryManager` 的基本机制："

#: ../../library/multiprocessing.shared_memory.rst:246
msgid ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # Start the process that manages the shared memory blocks\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # Calls unlink() on sl, raw_shm, and another_sl"
msgstr ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # 启动管理共享内存块的进程\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # 在 sl, raw_shm 和 another_sl 上调用 unlink()"

#: ../../library/multiprocessing.shared_memory.rst:261
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via the"
" :keyword:`with` statement to ensure that all shared memory blocks are "
"released after they are no longer needed:"
msgstr ""
"下面的例子展示了使用 :class:`~multiprocessing.managers.SharedMemoryManager` "
"对象的一种更方便的方式，通过 :keyword:`with` 语句来确保所有共享内存块在它们不再被需要时得到释放："

#: ../../library/multiprocessing.shared_memory.rst:266
msgid ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # Divide the work among two processes, storing partial results in sl\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # A multiprocessing.Pool might be more efficient\n"
"...     p1.join()\n"
"...     p2.join()   # Wait for all work to complete in both processes\n"
"...     total_result = sum(sl)  # Consolidate the partial results now in sl"
msgstr ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # 将工作分给两个进程，将部分结果存储在 sl 中\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # 用 multiprocessing.Pool 可能会更高效\n"
"...     p1.join()\n"
"...     p2.join()   # 等等两个进程中的所有工作完成\n"
"...     total_result = sum(sl)  # 现在合并 sl 中的部分结果"

#: ../../library/multiprocessing.shared_memory.rst:280
msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a "
":keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block "
"finishes execution."
msgstr ""
"当在 :keyword:`with` 语句中使用 "
":class:`~multiprocessing.managers.SharedMemoryManager` 对象时，使用这个管理器创建的共享内存块会在"
" :keyword:`!with` 语句代码块结束执行时全部被释放。"

#: ../../library/multiprocessing.shared_memory.rst:288
msgid ""
"Provide a mutable list-like object where all values stored within are stored"
" in a shared memory block. This constrains storable values to the following "
"built-in data types:"
msgstr "提供一个可变的列表型对象，其中存储的所有值都是存储在一个共享内存块中。 这会将可存储的值限制为下列内置数据类型："

#: ../../library/multiprocessing.shared_memory.rst:292
msgid ":class:`int` (signed 64-bit)"
msgstr ":class:`int` (有符号 64 位)"

#: ../../library/multiprocessing.shared_memory.rst:293
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/multiprocessing.shared_memory.rst:294
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../library/multiprocessing.shared_memory.rst:295
msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ":class:`str` (当使用 UTF-8 编码时每个小于 10M 字节)"

#: ../../library/multiprocessing.shared_memory.rst:296
msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ":class:`bytes` (每个小于 10M 字节)"

#: ../../library/multiprocessing.shared_memory.rst:297
msgid "``None``"
msgstr "``None``"

#: ../../library/multiprocessing.shared_memory.rst:299
msgid ""
"It also notably differs from the built-in :class:`list` type in that these "
"lists can not change their overall length (i.e. no :meth:`!append`, "
":meth:`!insert`, etc.) and do not support the dynamic creation of new "
":class:`!ShareableList` instances via slicing."
msgstr ""
"它与内置 :class:`list` 类型的显著区别还在于这些列表无法改变其总长度（即没有 :meth:`!append`, "
":meth:`!insert` 等）并且不支持通过切片动态地创建新的 :class:`!ShareableList`。"

#: ../../library/multiprocessing.shared_memory.rst:305
msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing "
":class:`!ShareableList` by its unique shared memory name."
msgstr ""
"*sequence* 会被用来填充已有值的新 :class:`!ShareableList`。 设为 ``None`` "
"则会基于唯一的共享内存名称联系到现有的 :class:`!ShareableList`。"

#: ../../library/multiprocessing.shared_memory.rst:309
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing "
":class:`!ShareableList`, specify its shared memory block's unique name while"
" leaving *sequence* set to ``None``."
msgstr ""
"*name* 是所请求的共享内存的唯一名称，与 :class:`SharedMemory` 的定义中描述的一致。 当关联到现有的 "
":class:`!ShareableList` 时，将指明其共享内存块的唯一名称并将 *sequence* 设为 ``None``。"

#: ../../library/multiprocessing.shared_memory.rst:316
msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they end"
" with ``\\x00`` nul bytes or characters, those may be *silently stripped* "
"when fetching them by index from the :class:`!ShareableList`. This "
"``.rstrip(b'\\x00')`` behavior is considered a bug and may go away in the "
"future. See :gh:`106939`."
msgstr ""
":class:`bytes` 和 :class:`str` 值存在一个已知问题。 如果它们以 ``\\x00`` 空字节或字符结尾，那么当按索引号从 "
":class:`!ShareableList` 提取这些值时它们可能会被 *静默地去除*。 这种 ``.rstrip(b'\\x00')`` "
"行为并认为是一个程序错误并可能在未来被修复。 参见 :gh:`106939`。"

#: ../../library/multiprocessing.shared_memory.rst:322
msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the end"
" of such values when storing and unconditionally removing it when fetching:"
msgstr ""
"对于某些应用来说在右侧截去尾部空值会造成问题，要绕过此问题可以在存储这样的值时总是无条件地在其末尾附加一个额外的非 0 字节并在获取时无条件地移除它:"

#: ../../library/multiprocessing.shared_memory.rst:327
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"
msgstr ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"

#: ../../library/multiprocessing.shared_memory.rst:345
msgid "Return the number of occurrences of *value*."
msgstr "返回 *value* 出现的次数。"

#: ../../library/multiprocessing.shared_memory.rst:349
msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if *value* "
"is not present."
msgstr "返回 *value* 首次出现的索引位置。 如果 *value* 不存在则会引发 :exc:`ValueError`。"

#: ../../library/multiprocessing.shared_memory.rst:354
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr "包含由所有当前存储值所使用的 :mod:`struct` 打包格式的只读属性。"

#: ../../library/multiprocessing.shared_memory.rst:359
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "存储了值的 :class:`SharedMemory` 实例。"

#: ../../library/multiprocessing.shared_memory.rst:362
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr "下面的例子演示了 :class:`ShareableList` 实例的基本用法:"

#: ../../library/multiprocessing.shared_memory.rst:395
msgid ""
"The following example depicts how one, two, or many processes may access the"
" same :class:`ShareableList` by supplying the name of the shared memory "
"block behind it:"
msgstr "下面的例子演示了一个、两个或多个进程如何通过提供下层的共享内存块名称来访问同一个 :class:`ShareableList`:"

#: ../../library/multiprocessing.shared_memory.rst:410
msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if "
"needed. Note, that it will still be the same shared object. This happens, "
"because the deserialized object has the same unique name and is just "
"attached to an existing object with the same name (if the object is still "
"alive):"
msgstr ""
"下面的例子显示 :class:`ShareableList` (以及下层的 :class:`SharedMemory`) 对象可以在必要时被封存和解封。"
" 请注意，它将仍然为同一个共享对象。 出现这种情况是因为被反序列化的对象具有相同的唯一名称并会使用这个相同的名称附加到现有的对象上（如果对象仍然存活）："

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Shared Memory"
msgstr "共享内存"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "POSIX Shared Memory"
msgstr "POSIX 共享内存"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Named Shared Memory"
msgstr "已命名共享内存"
