# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Chi Xu <jackson1014qq@gmail.com>, 2020
# zeroswan <weditor@163.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 12:06+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.shared_memory.rst:2
msgid ""
":mod:`multiprocessing.shared_memory` ---  Provides shared memory for direct "
"access across processes"
msgstr ":mod:`multiprocessing.shared_memory` --- 可从进程直接访问的共享内存"

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**源代码:** :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes,"
" a :class:`~multiprocessing.managers.BaseManager` subclass, "
":class:`SharedMemoryManager`, is also provided in the "
"``multiprocessing.managers`` module."
msgstr ""
"该模块提供了一个 :class:`SharedMemory` "
"类，用于分配和管理多核或对称多处理器（SMP）机器上进程间的共享内存。为了协助管理不同进程间的共享内存生命周期，``multiprocessing.managers``"
" 模块也提供了一个 :class:`~multiprocessing.managers.BaseManager` 的子类： "
":class:`SharedMemoryManager`。"

#: ../../library/multiprocessing.shared_memory.rst:26
msgid ""
"In this module, shared memory refers to \"System V style\" shared memory "
"blocks (though is not necessarily implemented explicitly as such) and does "
"not refer to \"distributed shared memory\".  This style of shared memory "
"permits distinct processes to potentially read and write to a common (or "
"shared) region of volatile memory.  Processes are conventionally limited to "
"only have access to their own process memory space but shared memory permits"
" the sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data"
" via disk or socket or other communications requiring the "
"serialization/deserialization and copying of data."
msgstr ""
"本模块中，共享内存是指 \"System V 类型\" 的共享内存块（虽然可能和它实现方式不完全一致）而不是 "
"“分布式共享内存”。这种类型的的共享内存允许不同进程读写一片公共（或者共享）的易失性存储区域。一般来说，进程被限制只能访问属于自己进程空间的内存，但是共享内存允许跨进程共享数据，从而避免通过进程间发送消息的形式传递数据。相比通过磁盘、套接字或者其他要求序列化、反序列化和复制数据的共享形式，直接通过内存共享数据拥有更出色性能。"

#: ../../library/multiprocessing.shared_memory.rst:41
msgid ""
"Creates a new shared memory block or attaches to an existing shared memory "
"block.  Each shared memory block is assigned a unique name. In this way, one"
" process can create a shared memory block with a particular name and a "
"different process can attach to that same shared memory block using that "
"same name."
msgstr ""
"创建一个新的共享内存块或者连接到一片已经存在的共享内存块。每个共享内存块都被指定了一个全局唯一的名称。通过这种方式，一个进程可以通过提供一个特定的名字创建一个共享内存区块，然后其他进程使用同样的名字连接到这个共享内存块。"

#: ../../library/multiprocessing.shared_memory.rst:47
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close()` method should be called. When a shared memory"
" block is no longer needed by any process, the :meth:`unlink()` method "
"should be called to ensure proper cleanup."
msgstr ""
"作为一种跨进程共享数据的方式，共享内存块的寿命可能超过创建它的原始进程。一个共享内存块可能同时被多个进程使用，当一个进程不再需要访问这个共享内存块的时候，应该调用"
" :meth:`close()` 方法。当一个共享内存块不被任何进程使用的时候，应该调用 :meth:`unlink()` 方法以执行必要的清理。"

#: ../../library/multiprocessing.shared_memory.rst:54
msgid ""
"*name* is the unique name for the requested shared memory, specified as a "
"string.  When creating a new shared memory block, if ``None`` (the default) "
"is supplied for the name, a novel name will be generated."
msgstr ""
"*name* 是共享内存的唯一名称，字符串类型。如果创建一个新共享内存块的时候，名称指定为 ``None``  (默认值)，将会随机产生一个新名称。"

#: ../../library/multiprocessing.shared_memory.rst:58
msgid ""
"*create* controls whether a new shared memory block is created (``True``) or"
" an existing shared memory block is attached (``False``)."
msgstr "*create* 指定创建一个新的共享内存块 (``True``) 还是连接到已存在的共享内存块 (``False``) 。"

#: ../../library/multiprocessing.shared_memory.rst:61
msgid ""
"*size* specifies the requested number of bytes when creating a new shared "
"memory block.  Because some platforms choose to allocate chunks of memory "
"based upon that platform's memory page size, the exact size of the shared "
"memory block may be larger or equal to the size requested.  When attaching "
"to an existing shared memory block, the ``size`` parameter is ignored."
msgstr ""
"如果是新创建共享内存块则 *size* "
"用于指定块的大小为多少字节。由于某些平台是使用特定内存页大小为最小单位来分配的，最终得到的内存块大小可能大于或等于要求的大小。如果是连接到已经存在的共享内存块，"
" ``size`` 参数会被忽略。"

#: ../../library/multiprocessing.shared_memory.rst:69
msgid ""
"Closes access to the shared memory from this instance.  In order to ensure "
"proper cleanup of resources, all instances should call ``close()`` once the "
"instance is no longer needed.  Note that calling ``close()`` does not cause "
"the shared memory block itself to be destroyed."
msgstr ""
"关闭实例对于共享内存的访问连接。所有实例确认自己不再需要使用共享内存的时候都应该调用 ``close()`` ，以保证必要的资源清理。调用 "
"``close()`` 并不会销毁共享内存区域。"

#: ../../library/multiprocessing.shared_memory.rst:77
msgid ""
"Requests that the underlying shared memory block be destroyed.  In order to "
"ensure proper cleanup of resources, ``unlink()`` should be called once (and "
"only once) across all processes which have need for the shared memory block."
"  After requesting its destruction, a shared memory block may or may not be "
"immediately destroyed and this behavior may differ across platforms.  "
"Attempts to access data inside the shared memory block after ``unlink()`` "
"has been called may result in memory access errors.  Note: the last process "
"relinquishing its hold on a shared memory block may call ``unlink()`` and "
":meth:`close()` in either order."
msgstr ""
"请求销毁底层的共享内存块。为了执行必要的资源清理， 在所有使用这个共享内存块的进程中， ``unlink()`` 应该调用一次(且只能调用一次) "
"。发出此销毁请求后，共享内存块可能会、也可能不会立即销毁，且此行为在不同操作系统之间可能不同。调用 ``unlink()`` "
"后再尝试方位其中的数据可能导致内存错误。注意: 最后一个关闭共享内存访问权限的进程可以以任意顺序调用 ``unlink()`` 和 "
":meth:`close()` 。"

#: ../../library/multiprocessing.shared_memory.rst:90
msgid "A memoryview of contents of the shared memory block."
msgstr "共享内存块内容的 memoryview 。"

#: ../../library/multiprocessing.shared_memory.rst:94
msgid "Read-only access to the unique name of the shared memory block."
msgstr "共享内存块的唯一标识，只读属性。"

#: ../../library/multiprocessing.shared_memory.rst:98
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "共享内存块的字节大小，只读属性"

#: ../../library/multiprocessing.shared_memory.rst:101
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr "以下示例展示了 :class:`SharedMemory` 的底层的用法::"

#: ../../library/multiprocessing.shared_memory.rst:127
msgid ""
"The following example demonstrates a practical use of the "
":class:`SharedMemory` class with `NumPy arrays <https://www.numpy.org/>`_, "
"accessing the same ``numpy.ndarray`` from two distinct Python shells:"
msgstr ""
"以下示例展示了一个现实中的例子，使用  :class:`SharedMemory` 类和`NumPy arrays "
"<https://www.numpy.org/>`_ 结合, 从两个 Python shell 中访问同一个 ``numpy.ndarray`` :"

#: ../../library/multiprocessing.shared_memory.rst:181
msgid ""
"A subclass of :class:`~multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ":class:`~multiprocessing.managers.BaseManager` 的子类，可用于管理跨进程的共享内存块。"

#: ../../library/multiprocessing.shared_memory.rst:184
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a "
":class:`SharedMemoryManager` instance causes a new process to be started. "
"This new process's sole purpose is to manage the life cycle of all shared "
"memory blocks created through it.  To trigger the release of all shared "
"memory blocks managed by that process, call "
":meth:`~multiprocessing.managers.BaseManager.shutdown()` on the instance. "
"This triggers a :meth:`SharedMemory.unlink()` call on all of the "
":class:`SharedMemory` objects managed by that process and then stops the "
"process itself.  By creating ``SharedMemory`` instances through a "
"``SharedMemoryManager``, we avoid the need to manually track and trigger the"
" freeing of shared memory resources."
msgstr ""
"调用 :class:`SharedMemoryManager`  实例上的 "
":meth:`~multiprocessing.managers.BaseManager.start`  "
"方法会启动一个新进程。这个新进程的唯一目的就是管理所有由它创建的共享内存块的生命周期。想要释放此进程管理的所有共享内存块，可以调用实例的 "
":meth:`~multiprocessing.managers.BaseManager.shutdown()`  方法。这会触发执行它管理的所有  "
":class:`SharedMemory` 对象的 :meth:`SharedMemory.unlink()` 方法，然后停止这个进程。通过  "
"``SharedMemoryManager`` 创建 ``SharedMemory`` 实例，我们可以避免手动跟踪和释放共享内存资源。"

#: ../../library/multiprocessing.shared_memory.rst:196
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory`"
" instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"这个类提供了创建和返回 :class:`SharedMemory` 实例的方法，以及以共享内存为基础创建一个列表类对象 "
"(:class:`ShareableList`) 的方法。"

#: ../../library/multiprocessing.shared_memory.rst:200
msgid ""
"Refer to :class:`multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing ``SharedMemoryManager`` service from "
"other processes."
msgstr ""
"有关继承的可选输入参数 *address* 和 *authkey*  以及他们如何用于从进程连接已经存在的 "
"``SharedMemoryManager`` 服务，参见 :class:`multiprocessing.managers.BaseManager` "
" "

#: ../../library/multiprocessing.shared_memory.rst:207
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"``size`` in bytes."
msgstr "使用 ``size`` 参数，创建一个新的指定字节大小的 :class:`SharedMemory` 对象并返回。"

#: ../../library/multiprocessing.shared_memory.rst:212
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input ``sequence``."
msgstr "创建并返回一个新的 :class:`ShareableList` 对象，通过输入参数 ``sequence`` 初始化。"

#: ../../library/multiprocessing.shared_memory.rst:216
msgid ""
"The following example demonstrates the basic mechanisms of a "
":class:`SharedMemoryManager`:"
msgstr "下面的案例展示了 :class:`SharedMemoryManager` 的基础机制:"

#: ../../library/multiprocessing.shared_memory.rst:234
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`SharedMemoryManager` objects via the :keyword:`with` statement"
" to ensure that all shared memory blocks are released after they are no "
"longer needed:"
msgstr ""
"以下案例展示了 :class:`SharedMemoryManager` 对象的一种可能更方便的使用方式，通过 :keyword:`with` "
"语句来保证所有共享内存块在使用完后被释放。"

#: ../../library/multiprocessing.shared_memory.rst:253
msgid ""
"When using a :class:`SharedMemoryManager` in a :keyword:`with` statement, "
"the shared memory blocks created using that manager are all released when "
"the :keyword:`with` statement's code block finishes execution."
msgstr ""
"当在 :keyword:`with` 语句中使用 :class:`SharedMemoryManager`  "
"对象的时候，使用这个管理器创建的共享内存块会在  :keyword:`with` 语句代码块结束后被释放。"

#: ../../library/multiprocessing.shared_memory.rst:260
msgid ""
"Provides a mutable list-like object where all values stored within are "
"stored in a shared memory block.  This constrains storable values to only "
"the ``int``, ``float``, ``bool``, ``str`` (less than 10M bytes each), "
"``bytes`` (less than 10M bytes each), and ``None`` built-in data types. It "
"also notably differs from the built-in ``list`` type in that these lists can"
" not change their overall length (i.e. no append, insert, etc.) and do not "
"support the dynamic creation of new :class:`ShareableList` instances via "
"slicing."
msgstr ""
"提供一个可修改的类 list 对象，其中所有值都存放在共享内存块中。这限制了可被存储在其中的值只能是 ``int``, ``float``, "
"``bool``, ``str``  （每条数据小于10M）, ``bytes`` （每条数据小于10M）以及 ``None`` "
"这些内置类型。它另一个显著区别于内置 ``list`` 类型的地方在于它的长度无法修改（比如，没有 append, insert "
"等操作）且不支持通过切片操作动态创建新的 :class:`ShareableList`  实例。"

#: ../../library/multiprocessing.shared_memory.rst:269
msgid ""
"*sequence* is used in populating a new ``ShareableList`` full of values. Set"
" to ``None`` to instead attach to an already existing ``ShareableList`` by "
"its unique shared memory name."
msgstr ""
"*sequence* 会被用来为一个新的 ``ShareableList`` 填充值。 设为 ``None`` 则会基于共享内存名称关联到一个已经存在的"
" ``ShareableList``。"

#: ../../library/multiprocessing.shared_memory.rst:273
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing "
"``ShareableList``, specify its shared memory block's unique name while "
"leaving ``sequence`` set to ``None``."
msgstr ""
"*name* 是所请求的共享内存的唯一名称，与 :class:`SharedMemory` 的定义中所描述的一致。 当关联到现有的 "
"``ShareableList`` 时，则指明其共享内存块的唯一名称并将 ``sequence`` 设为 ``None``。"

#: ../../library/multiprocessing.shared_memory.rst:280
msgid "Returns the number of occurrences of ``value``."
msgstr "返回 ``value`` 出现的次数。"

#: ../../library/multiprocessing.shared_memory.rst:284
msgid ""
"Returns first index position of ``value``.  Raises :exc:`ValueError` if "
"``value`` is not present."
msgstr "返回 ``value`` 首次出现的位置，如果 ``value`` 不存在, 则抛出 :exc:`ValueError` 异常。"

#: ../../library/multiprocessing.shared_memory.rst:289
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr "包含由所有当前存储值所使用的 :mod:`struct` 打包格式的只读属性。"

#: ../../library/multiprocessing.shared_memory.rst:294
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "存储了值的 :class:`SharedMemory` 实例。"

#: ../../library/multiprocessing.shared_memory.rst:297
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr "下面的例子演示了 :class:`ShareableList` 实例的基本用法:"

#: ../../library/multiprocessing.shared_memory.rst:330
msgid ""
"The following example depicts how one, two, or many processes may access the"
" same :class:`ShareableList` by supplying the name of the shared memory "
"block behind it:"
msgstr "下面的例子演示了一个、两个或多个进程如何通过提供下层的共享内存块名称来访问同一个 :class:`ShareableList`:"
