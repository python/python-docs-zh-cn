# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Woko <banbooliu@gmail.com>, 2021
# Jarry Shaw <jarryshaw@icloud.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Nyuan Zhang, 2022
# Alpha Du <alphanow@gmail.com>, 2022
# Dai Xu <daixu61@hotmail.com>, 2022
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/collections.abc.rst:2
msgid ":mod:`!collections.abc` --- Abstract Base Classes for Containers"
msgstr ":mod:`!collections.abc` --- 容器的抽象基类"

#: ../../library/collections.abc.rst:10
msgid "Formerly, this module was part of the :mod:`collections` module."
msgstr "该模块曾是 :mod:`collections` 模块的组成部分。"

#: ../../library/collections.abc.rst:13
msgid "**Source code:** :source:`Lib/_collections_abc.py`"
msgstr "**源代码：** :source:`Lib/_collections_abc.py`"

#: ../../library/collections.abc.rst:23
msgid ""
"This module provides :term:`abstract base classes <abstract base class>` "
"that can be used to test whether a class provides a particular interface; "
"for example, whether it is :term:`hashable` or whether it is a "
":term:`mapping`."
msgstr ""
"本模块提供了一些 :term:`抽象基类 <abstract base class>`，它们可被用于测试一个类是否提供某个特定的接口；例如，它是否为 "
":term:`hashable` 或是否为 :term:`mapping` 等。"

#: ../../library/collections.abc.rst:27
msgid ""
"An :func:`issubclass` or :func:`isinstance` test for an interface works in "
"one of three ways."
msgstr "一个接口的 :func:`issubclass` 或 :func:`isinstance` 测试采用以下三种方式之一。"

#: ../../library/collections.abc.rst:30
msgid ""
"A newly written class can inherit directly from one of the abstract base "
"classes.  The class must supply the required abstract methods.  The "
"remaining mixin methods come from inheritance and can be overridden if "
"desired.  Other methods may be added as needed:"
msgstr ""
"新编写的类可以直接继承自某个抽象基类。 该类必须提供所面的抽象方法。 其他混入方法来自于继承并且可在需要时被重写。 其他方法可以被按需添加："

#: ../../library/collections.abc.rst:35
msgid ""
"class C(Sequence):                      # Direct inheritance\n"
"    def __init__(self): ...             # Extra method not required by the ABC\n"
"    def __getitem__(self, index):  ...  # Required abstract method\n"
"    def __len__(self):  ...             # Required abstract method\n"
"    def count(self, value): ...         # Optionally override a mixin method"
msgstr ""
"class C(Sequence):                      # 直接继承\n"
"    def __init__(self): ...             # ABC 所不需要的额外方法\n"
"    def __getitem__(self, index):  ...  # 需要的抽象方法\n"
"    def __len__(self):  ...             # 需要的抽象方法\n"
"    def count(self, value): ...         # 可选覆盖一个混入方法"

#: ../../library/collections.abc.rst:43
msgid ""
">>> issubclass(C, Sequence)\n"
"True\n"
">>> isinstance(C(), Sequence)\n"
"True"
msgstr ""
">>> issubclass(C, Sequence)\n"
"True\n"
">>> isinstance(C(), Sequence)\n"
"True"

#: ../../library/collections.abc.rst:50
msgid ""
"Existing classes and built-in classes can be registered as \"virtual "
"subclasses\" of the ABCs.  Those classes should define the full API "
"including all of the abstract methods and all of the mixin methods. This "
"lets users rely on :func:`issubclass` or :func:`isinstance` tests to "
"determine whether the full interface is supported.  The exception to this "
"rule is for methods that are automatically inferred from the rest of the "
"API:"
msgstr ""
"已有的类和内置类可被注册为 ABC 的“虚拟子类”。 这些类应当定义完整的 API 包括所有抽象方法和所有混合方法。 这使得用户能依靠 "
":func:`issubclass` 或 :func:`isinstance` 测试来确定完整接口是否受到支持。 此规则的例外情况是那些从 API "
"的其他部分自动推断出来的方法："

#: ../../library/collections.abc.rst:58
msgid ""
"class D:                                 # No inheritance\n"
"    def __init__(self): ...              # Extra method not required by the ABC\n"
"    def __getitem__(self, index):  ...   # Abstract method\n"
"    def __len__(self):  ...              # Abstract method\n"
"    def count(self, value): ...          # Mixin method\n"
"    def index(self, value): ...          # Mixin method\n"
"\n"
"Sequence.register(D)                     # Register instead of inherit"
msgstr ""
"class D:                                 # 无继承\n"
"    def __init__(self): ...              # ABC 所不需要的额外方法\n"
"    def __getitem__(self, index):  ...   # 抽象方法\n"
"    def __len__(self):  ...              # 抽象方法\n"
"    def count(self, value): ...          # 混入方法\n"
"    def index(self, value): ...          # 混入方法\n"
"\n"
"Sequence.register(D)                     # 注册而非继承"

#: ../../library/collections.abc.rst:69
msgid ""
">>> issubclass(D, Sequence)\n"
"True\n"
">>> isinstance(D(), Sequence)\n"
"True"
msgstr ""
">>> issubclass(D, Sequence)\n"
"True\n"
">>> isinstance(D(), Sequence)\n"
"True"

#: ../../library/collections.abc.rst:76
msgid ""
"In this example, class :class:`!D` does not need to define ``__contains__``,"
" ``__iter__``, and ``__reversed__`` because the :ref:`in-operator "
"<comparisons>`, the :term:`iteration <iterable>` logic, and the "
":func:`reversed` function automatically fall back to using ``__getitem__`` "
"and ``__len__``."
msgstr ""
"在这个例子中，:class:`!D` 类不需要定义 ``__contains__``, ``__iter__`` 和 "
"``__reversed__``，因为 :ref:`in 运算符 <comparisons>`, :term:`迭代 <iterable>` 逻辑和 "
":func:`reversed` 函数会自动回退为使用 ``__getitem__`` 和 ``__len__``。"

#: ../../library/collections.abc.rst:82
msgid ""
"Some simple interfaces are directly recognizable by the presence of the "
"required methods (unless those methods have been set to :const:`None`):"
msgstr "某些简单接口可以根据所需方法是否存在来直接识别 (除非这些方法已被设置为 :const:`None`):"

#: ../../library/collections.abc.rst:85
msgid ""
"class E:\n"
"    def __iter__(self): ...\n"
"    def __next__(self): ..."
msgstr ""
"class E:\n"
"    def __iter__(self): ...\n"
"    def __next__(self): ..."

#: ../../library/collections.abc.rst:91
msgid ""
">>> issubclass(E, Iterable)\n"
"True\n"
">>> isinstance(E(), Iterable)\n"
"True"
msgstr ""
">>> issubclass(E, Iterable)\n"
"True\n"
">>> isinstance(E(), Iterable)\n"
"True"

#: ../../library/collections.abc.rst:98
msgid ""
"Complex interfaces do not support this last technique because an interface "
"is more than just the presence of method names.  Interfaces specify "
"semantics and relationships between methods that cannot be inferred solely "
"from the presence of specific method names.  For example, knowing that a "
"class supplies ``__getitem__``, ``__len__``, and ``__iter__`` is "
"insufficient for distinguishing a :class:`Sequence` from a :class:`Mapping`."
msgstr ""
"复杂的接口不支持最后这种技术手段因为接口并不只是作为方法名称存在。 接口指明了方法之间的语义和关系，这些是无法根据特定方法名称的存在推断出来的。 "
"例如，知道一个类提供了 ``__getitem__``, ``__len__`` 和 ``__iter__`` 并不足以区分 "
":class:`Sequence` 和 :class:`Mapping`。"

#: ../../library/collections.abc.rst:106
msgid ""
"These abstract classes now support ``[]``. See :ref:`types-genericalias` and"
" :pep:`585`."
msgstr "这些抽象类现在都支持 ``[]``。 参见 :ref:`types-genericalias` 和 :pep:`585`。"

#: ../../library/collections.abc.rst:113
msgid "Collections Abstract Base Classes"
msgstr "容器抽象基类"

#: ../../library/collections.abc.rst:115
msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr "这个容器模块提供了以下 :term:`ABCs <abstract base class>`:"

#: ../../library/collections.abc.rst:120
msgid "ABC"
msgstr "抽象基类"

#: ../../library/collections.abc.rst:120
msgid "Inherits from"
msgstr "继承自"

#: ../../library/collections.abc.rst:120
msgid "Abstract Methods"
msgstr "抽象方法"

#: ../../library/collections.abc.rst:120
msgid "Mixin Methods"
msgstr "Mixin 方法"

#: ../../library/collections.abc.rst:122
msgid ":class:`Container` [1]_"
msgstr ":class:`Container` [1]_"

#: ../../library/collections.abc.rst:122
msgid "``__contains__``"
msgstr "``__contains__``"

#: ../../library/collections.abc.rst:123
msgid ":class:`Hashable` [1]_"
msgstr ":class:`Hashable` [1]_"

#: ../../library/collections.abc.rst:123
msgid "``__hash__``"
msgstr "``__hash__``"

#: ../../library/collections.abc.rst:124
msgid ":class:`Iterable` [1]_ [2]_"
msgstr ":class:`Iterable` [1]_ [2]_"

#: ../../library/collections.abc.rst:124 ../../library/collections.abc.rst:125
msgid "``__iter__``"
msgstr "``__iter__``"

#: ../../library/collections.abc.rst:125
msgid ":class:`Iterator` [1]_"
msgstr ":class:`Iterator` [1]_"

#: ../../library/collections.abc.rst:125 ../../library/collections.abc.rst:126
msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

#: ../../library/collections.abc.rst:125
msgid "``__next__``"
msgstr "``__next__``"

#: ../../library/collections.abc.rst:126
msgid ":class:`Reversible` [1]_"
msgstr ":class:`Reversible` [1]_"

#: ../../library/collections.abc.rst:126
msgid "``__reversed__``"
msgstr "``__reversed__``"

#: ../../library/collections.abc.rst:127
msgid ":class:`Generator`  [1]_"
msgstr ":class:`Generator`  [1]_"

#: ../../library/collections.abc.rst:127
msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

#: ../../library/collections.abc.rst:127 ../../library/collections.abc.rst:176
msgid "``send``, ``throw``"
msgstr "``send``, ``throw``"

#: ../../library/collections.abc.rst:127
msgid "``close``, ``__iter__``, ``__next__``"
msgstr "``close``, ``__iter__``, ``__next__``"

#: ../../library/collections.abc.rst:128
msgid ":class:`Sized`  [1]_"
msgstr ":class:`Sized`  [1]_"

#: ../../library/collections.abc.rst:128
msgid "``__len__``"
msgstr "``__len__``"

#: ../../library/collections.abc.rst:129
msgid ":class:`Callable`  [1]_"
msgstr ":class:`Callable`  [1]_"

#: ../../library/collections.abc.rst:129
msgid "``__call__``"
msgstr "``__call__``"

#: ../../library/collections.abc.rst:130
msgid ":class:`Collection`  [1]_"
msgstr ":class:`Collection`  [1]_"

#: ../../library/collections.abc.rst:130
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

#: ../../library/collections.abc.rst:130 ../../library/collections.abc.rst:146
msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__contains__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:134 ../../library/collections.abc.rst:137
#: ../../library/collections.abc.rst:143
msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

#: ../../library/collections.abc.rst:134
msgid ":class:`Reversible`, :class:`Collection`"
msgstr ":class:`Reversible`, :class:`Collection`"

#: ../../library/collections.abc.rst:134 ../../library/collections.abc.rst:143
msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

#: ../../library/collections.abc.rst:134
msgid ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"

#: ../../library/collections.abc.rst:137
msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

#: ../../library/collections.abc.rst:137
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

#: ../../library/collections.abc.rst:137
msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``clear``, ``reverse``, "
"``extend``, ``pop``, ``remove``, and ``__iadd__``"
msgstr ""
"继承了 :class:`Sequence` 的方法以及 ``append``, ``clear``, ``reverse``, ``extend``, "
"``pop``, ``remove`` 和 ``__iadd__``"

#: ../../library/collections.abc.rst:143
msgid ":class:`ByteString`"
msgstr ":class:`ByteString`"

#: ../../library/collections.abc.rst:143
msgid "Inherited :class:`Sequence` methods"
msgstr "继承自 :class:`Sequence` 的方法"

#: ../../library/collections.abc.rst:146 ../../library/collections.abc.rst:151
msgid ":class:`Set`"
msgstr ":class:`Set`"

#: ../../library/collections.abc.rst:146 ../../library/collections.abc.rst:157
msgid ":class:`Collection`"
msgstr ":class:`Collection`"

#: ../../library/collections.abc.rst:146
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__rsub__``, ``__xor__``, "
"``__rxor__`` and ``isdisjoint``"
msgstr ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__rsub__``, ``__xor__``, "
"``__rxor__`` 和 ``isdisjoint``"

#: ../../library/collections.abc.rst:151
msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

#: ../../library/collections.abc.rst:151
msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

#: ../../library/collections.abc.rst:151
msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""
"继承自 :class:`Set` 的方法以及 ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__``，和  ``__isub__``"

#: ../../library/collections.abc.rst:157 ../../library/collections.abc.rst:161
msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

#: ../../library/collections.abc.rst:157
msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:157
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"

#: ../../library/collections.abc.rst:161
msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

#: ../../library/collections.abc.rst:161
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:161
msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ""
"继承自 :class:`Mapping` 的方法以及 ``pop``, ``popitem``, ``clear``, ``update``，和 "
"``setdefault``"

#: ../../library/collections.abc.rst:168
msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

#: ../../library/collections.abc.rst:168
msgid ":class:`Sized`"
msgstr ":class:`Sized`"

#: ../../library/collections.abc.rst:168
msgid "``__init__``, ``__len__`` and ``__repr__``"
msgstr "``__init__``, ``__len__`` 和 ``__repr__``"

#: ../../library/collections.abc.rst:169
msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
#: ../../library/collections.abc.rst:173
msgid "``__contains__``, ``__iter__``"
msgstr "``__contains__``, ``__iter__``"

#: ../../library/collections.abc.rst:171
msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`MappingView`, :class:`Collection`"
msgstr ":class:`MappingView`, :class:`Collection`"

#: ../../library/collections.abc.rst:175
msgid ":class:`Awaitable` [1]_"
msgstr ":class:`Awaitable` [1]_"

#: ../../library/collections.abc.rst:175
msgid "``__await__``"
msgstr "``__await__``"

#: ../../library/collections.abc.rst:176
msgid ":class:`Coroutine` [1]_"
msgstr ":class:`Coroutine` [1]_"

#: ../../library/collections.abc.rst:176
msgid ":class:`Awaitable`"
msgstr ":class:`Awaitable`"

#: ../../library/collections.abc.rst:176
msgid "``close``"
msgstr "``close``"

#: ../../library/collections.abc.rst:177
msgid ":class:`AsyncIterable` [1]_"
msgstr ":class:`AsyncIterable` [1]_"

#: ../../library/collections.abc.rst:177 ../../library/collections.abc.rst:178
msgid "``__aiter__``"
msgstr "``__aiter__``"

#: ../../library/collections.abc.rst:178
msgid ":class:`AsyncIterator` [1]_"
msgstr ":class:`AsyncIterator` [1]_"

#: ../../library/collections.abc.rst:178
msgid ":class:`AsyncIterable`"
msgstr ":class:`AsyncIterable`"

#: ../../library/collections.abc.rst:178
msgid "``__anext__``"
msgstr "``__anext__``"

#: ../../library/collections.abc.rst:179
msgid ":class:`AsyncGenerator` [1]_"
msgstr ":class:`AsyncGenerator` [1]_"

#: ../../library/collections.abc.rst:179
msgid ":class:`AsyncIterator`"
msgstr ":class:`AsyncIterator`"

#: ../../library/collections.abc.rst:179
msgid "``asend``, ``athrow``"
msgstr "``asend``, ``athrow``"

#: ../../library/collections.abc.rst:179
msgid "``aclose``, ``__aiter__``, ``__anext__``"
msgstr "``aclose``, ``__aiter__``, ``__anext__``"

#: ../../library/collections.abc.rst:180
msgid ":class:`Buffer` [1]_"
msgstr ":class:`Buffer` [1]_"

#: ../../library/collections.abc.rst:180
msgid "``__buffer__``"
msgstr "``__buffer__``"

#: ../../library/collections.abc.rst:185
msgid "Footnotes"
msgstr "附注"

#: ../../library/collections.abc.rst:186
msgid ""
"These ABCs override :meth:`~abc.ABCMeta.__subclasshook__` to support testing"
" an interface by verifying the required methods are present and have not "
"been set to :const:`None`.  This only works for simple interfaces.  More "
"complex interfaces require registration or direct subclassing."
msgstr ""
"这些 ABC 重写了 :meth:`~abc.ABCMeta.__subclasshook__` 以便支持通过验证所需的方法是否存在并且没有被设为 "
":const:`None` 来测试一个接口。 这只适用于简单的接口。 更复杂的接口需要注册或者直接子类化。"

#: ../../library/collections.abc.rst:192
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are registered "
"as :class:`Iterable` or that have an :meth:`~container.__iter__` method, but"
" it does not detect classes that iterate with the "
":meth:`~object.__getitem__` method.  The only reliable way to determine "
"whether an object is :term:`iterable` is to call ``iter(obj)``."
msgstr ""
"检查 ``isinstance(obj, Iterable)`` 是否侦测到被注册为 :class:`Iterable` 或者具有 "
":meth:`~container.__iter__` 方法的类，但它不能侦测到使用 :meth:`~object.__getitem__` "
"方法进行迭代的类。 确定一个对象是否为 :term:`iterable` 的唯一可靠方式是调用 ``iter(obj)``。"

#: ../../library/collections.abc.rst:200
msgid "Collections Abstract Base Classes -- Detailed Descriptions"
msgstr "多项集抽象基类 -- 详细描述"

#: ../../library/collections.abc.rst:205
msgid "ABC for classes that provide the :meth:`~object.__contains__` method."
msgstr "提供了 :meth:`~object.__contains__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:209
msgid "ABC for classes that provide the :meth:`~object.__hash__` method."
msgstr "提供了 :meth:`~object.__hash__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:213
msgid "ABC for classes that provide the :meth:`~object.__len__` method."
msgstr "用于提供 :meth:`~object.__len__` 方法的类的 ABC"

#: ../../library/collections.abc.rst:217
msgid "ABC for classes that provide the :meth:`~object.__call__` method."
msgstr "用于提供 :meth:`~object.__call__` 方法的类的 ABC"

#: ../../library/collections.abc.rst:219
msgid ""
"See :ref:`annotating-callables` for details on how to use :class:`!Callable`"
" in type annotations."
msgstr "有关如何在类型标注中使用 :class:`!Callable` 的详细信息请参阅 :ref:`annotating-callables`。"

#: ../../library/collections.abc.rst:224
msgid "ABC for classes that provide the :meth:`~container.__iter__` method."
msgstr "用于提供 :meth:`~container.__iter__` 方法的类的 ABC"

#: ../../library/collections.abc.rst:226
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are registered "
"as :class:`Iterable` or that have an :meth:`~container.__iter__` method, but"
" it does not detect classes that iterate with the "
":meth:`~object.__getitem__` method. The only reliable way to determine "
"whether an object is :term:`iterable` is to call ``iter(obj)``."
msgstr ""
"检查 ``isinstance(obj, Iterable)`` 是否侦测到被注册为 :class:`Iterable` 或者具有 "
":meth:`~container.__iter__` 方法的类，但它不能侦测到使用 :meth:`~object.__getitem__` "
"方法进行迭代的类。 确定一个对象是否为 :term:`iterable` 的唯一可靠方式是调用 ``iter(obj)``。"

#: ../../library/collections.abc.rst:235
msgid "ABC for sized iterable container classes."
msgstr "集合了 Sized 和 Iterable 类的抽象基类。"

#: ../../library/collections.abc.rst:241
msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and "
":meth:`~iterator.__next__` methods.  See also the definition of "
":term:`iterator`."
msgstr ""
"提供了 :meth:`~iterator.__iter__` 和 :meth:`~iterator.__next__` 方法的抽象基类。参见 "
":term:`iterator` 的定义。"

#: ../../library/collections.abc.rst:247
msgid ""
"ABC for iterable classes that also provide the :meth:`~object.__reversed__` "
"method."
msgstr "用于同时提供了 :meth:`~object.__reversed__` 方法的可迭代类的 ABC"

#: ../../library/collections.abc.rst:254
msgid ""
"ABC for :term:`generator` classes that implement the protocol defined in "
":pep:`342` that extends :term:`iterators <iterator>` with the "
":meth:`~generator.send`, :meth:`~generator.throw` and "
":meth:`~generator.close` methods."
msgstr ""
"用于实现了 :pep:`342` 中定义的协议的 :term:`generator` 类的 ABC，它通过 "
":meth:`~generator.send`, :meth:`~generator.throw` 和 :meth:`~generator.close`"
" 方法对 :term:`迭代器 <iterator>` 进行了扩展。"

#: ../../library/collections.abc.rst:259
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!Generator` in type annotations."
msgstr ""
"有关在类型标注中使用 :class:`!Generator` 的详细信息请参阅 :ref:`annotating-generators-and-"
"coroutines`。"

#: ../../library/collections.abc.rst:268
msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "只读的与可变的 :term:`序列 <sequence>` 的抽象基类。"

#: ../../library/collections.abc.rst:270
msgid ""
"Implementation note: Some of the mixin methods, such as "
":meth:`~container.__iter__`, :meth:`~object.__reversed__` and :meth:`index`,"
" make repeated calls to the underlying :meth:`~object.__getitem__` method. "
"Consequently, if :meth:`~object.__getitem__` is implemented with constant "
"access speed, the mixin methods will have linear performance; however, if "
"the underlying method is linear (as it would be with a linked list), the "
"mixins will have quadratic performance and will likely need to be "
"overridden."
msgstr ""
"实现注意事项：某些混入方法，如 :meth:`~container.__iter__`, :meth:`~object.__reversed__` 和 "
":meth:`index`，会重复调用下层的 :meth:`~object.__getitem__` 方法。 因此，如果 "
":meth:`~object.__getitem__` "
"被实现为常数级访问速度，则混入方法的性能将为线性级；但是，如果下层的方法是线性的（例如链表就是如此），则混入方法的性能将为平方级并可能需要被重写。"

#: ../../library/collections.abc.rst:279
msgid "The index() method added support for *stop* and *start* arguments."
msgstr "index() 方法支持 *stop* 和 *start* 参数。"

#: ../../library/collections.abc.rst:283
msgid ""
"The :class:`ByteString` ABC has been deprecated. For use in typing, prefer a"
" union, like ``bytes | bytearray``, or :class:`collections.abc.Buffer`. For "
"use as an ABC, prefer :class:`Sequence` or :class:`collections.abc.Buffer`."
msgstr ""
":class:`ByteString` ABC 已被弃用。 当用于类型标注时，建议改为并集形式，如 ``bytes | bytearray``，或 "
":class:`collections.abc.Buffer`。 当用作 ABC 时，建议改为 :class:`Sequence` 或 "
":class:`collections.abc.Buffer`。"

#: ../../library/collections.abc.rst:292
msgid "ABCs for read-only and mutable :ref:`sets <types-set>`."
msgstr "用于只读和可变 :ref:`集合 <types-set>` 的 ABC。"

#: ../../library/collections.abc.rst:297
msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr "只读的与可变的 :term:`映射 <mapping>` 的抽象基类。"

#: ../../library/collections.abc.rst:304
msgid ""
"ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr "映射及其键和值的 :term:`视图 <dictionary view>` 的抽象基类。"

#: ../../library/collections.abc.rst:308
msgid ""
"ABC for :term:`awaitable` objects, which can be used in :keyword:`await` "
"expressions.  Custom implementations must provide the "
":meth:`~object.__await__` method."
msgstr ""
"针对 :term:`awaitable` 对象的 ABC，它可被用于 :keyword:`await` 表达式。 根据惯例所有实现都必须提供 "
":meth:`~object.__await__` 方法。"

#: ../../library/collections.abc.rst:312
msgid ""
":term:`Coroutine <coroutine>` objects and instances of the "
":class:`~collections.abc.Coroutine` ABC are all instances of this ABC."
msgstr ""
":term:`协程 <coroutine>` 对象和 :class:`~collections.abc.Coroutine` ABC 的实例都是这个 "
"ABC 的实例。"

#: ../../library/collections.abc.rst:316
msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are *awaitables*,"
" even though they do not have an :meth:`~object.__await__` method. Using "
"``isinstance(gencoro, Awaitable)`` for them will return ``False``. Use "
":func:`inspect.isawaitable` to detect them."
msgstr ""
"在 CPython 中，基于生成器的协程 (使用 :func:`@types.coroutine <types.coroutine>` 装饰的 "
":term:`生成器 <generator>`) 都是 *可等待对象*，即使它们没有 :meth:`~object.__await__` 方法。 "
"对它们使用 ``isinstance(gencoro, Awaitable)`` 将返回 ``False``。 请使用 "
":func:`inspect.isawaitable` 来检测它们。"

#: ../../library/collections.abc.rst:326
msgid ""
"ABC for :term:`coroutine` compatible classes.  These implement the following"
" methods, defined in :ref:`coroutine-objects`: :meth:`~coroutine.send`, "
":meth:`~coroutine.throw`, and :meth:`~coroutine.close`.  Custom "
"implementations must also implement :meth:`~object.__await__`.  All "
":class:`Coroutine` instances are also instances of :class:`Awaitable`."
msgstr ""
"用于 :term:`coroutine` 兼容类的 ABC。 实现了如下定义在 :ref:`coroutine-objects` 里的方法: "
":meth:`~coroutine.send`, :meth:`~coroutine.throw` 和 "
":meth:`~coroutine.close`。 根据惯例所有实现都还需要实现 :meth:`~object.__await__`。 所有的 "
":class:`Coroutine` 实例同时也是 :class:`Awaitable` 的实例。"

#: ../../library/collections.abc.rst:334
msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are *awaitables*,"
" even though they do not have an :meth:`~object.__await__` method. Using "
"``isinstance(gencoro, Coroutine)`` for them will return ``False``. Use "
":func:`inspect.isawaitable` to detect them."
msgstr ""
"在 CPython 中，基于生成器的协程 (使用 :func:`@types.coroutine <types.coroutine>` 装饰的 "
":term:`生成器 <generator>`) 都是 *可等待对象*，即使它们没有 :meth:`~object.__await__` 方法。 "
"对它们使用 ``isinstance(gencoro, Coroutine)`` 将返回 ``False``。 请使用 "
":func:`inspect.isawaitable` 来检测它们。"

#: ../../library/collections.abc.rst:340
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!Coroutine` in type annotations. The variance and order of type "
"parameters correspond to those of :class:`Generator`."
msgstr ""
"有关在类型标注中使用 :class:`!Coroutine` 的详细信息请参阅 :ref:`annotating-generators-and-"
"coroutines`。 类型形参的变化和顺序与 :class:`Generator` 的相对应。"

#: ../../library/collections.abc.rst:349
msgid ""
"ABC for classes that provide an ``__aiter__`` method.  See also the "
"definition of :term:`asynchronous iterable`."
msgstr ""
"针对提供了 ``__aiter__`` 方法的类的 ABC。 另请参阅 :term:`asynchronous iterable` 的定义。"

#: ../../library/collections.abc.rst:356
msgid ""
"ABC for classes that provide ``__aiter__`` and ``__anext__`` methods.  See "
"also the definition of :term:`asynchronous iterator`."
msgstr ""
"提供了 ``__aiter__`` 和 ``__anext__`` 方法的抽象基类。参见 :term:`asynchronous iterator` "
"的定义。"

#: ../../library/collections.abc.rst:363
msgid ""
"ABC for :term:`asynchronous generator` classes that implement the protocol "
"defined in :pep:`525` and :pep:`492`."
msgstr ""
"针对实现了在 :pep:`525` 和 :pep:`492` 中定义的协议的 :term:`asynchronous generator` 类的 "
"ABC。"

#: ../../library/collections.abc.rst:366
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!AsyncGenerator` in type annotations."
msgstr ""
"有关在类型标注中使用 :class:`!AsyncGenerator` 的详细信息请参阅 :ref:`annotating-generators-"
"and-coroutines`。"

#: ../../library/collections.abc.rst:373
msgid ""
"ABC for classes that provide the :meth:`~object.__buffer__` method, "
"implementing the :ref:`buffer protocol <bufferobjects>`. See :pep:`688`."
msgstr ""
"针对提供 :meth:`~object.__buffer__` 方法的类的 ABC，实现了 :ref:`缓冲区协议 <bufferobjects>`。 "
"参见 :pep:`688`。"

#: ../../library/collections.abc.rst:379
msgid "Examples and Recipes"
msgstr "例子和配方"

#: ../../library/collections.abc.rst:381
msgid ""
"ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr "ABC 允许我们询问类或实例是否提供特定的功能，例如::"

#: ../../library/collections.abc.rst:384
msgid ""
"size = None\n"
"if isinstance(myvar, collections.abc.Sized):\n"
"    size = len(myvar)"
msgstr ""
"size = None\n"
"if isinstance(myvar, collections.abc.Sized):\n"
"    size = len(myvar)"

#: ../../library/collections.abc.rst:388
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop"
" classes supporting container APIs.  For example, to write a class "
"supporting the full :class:`Set` API, it is only necessary to supply the "
"three underlying abstract methods: :meth:`~object.__contains__`, "
":meth:`~container.__iter__`, and :meth:`~object.__len__`. The ABC supplies "
"the remaining methods such as :meth:`!__and__` and "
":meth:`~frozenset.isdisjoint`::"
msgstr ""
"有些 ABC 还适用于作为混入类，这可以更容易地开发支持容器 API 的类。 例如，要写一个支持完整 :class:`Set` API "
"的类，只需要提供三个下层抽象方法: :meth:`~object.__contains__`, :meth:`~container.__iter__` "
"和 :meth:`~object.__len__`。 ABC 会提供其余的方法如 :meth:`!__and__` 和 "
":meth:`~frozenset.isdisjoint`::"

#: ../../library/collections.abc.rst:395
msgid ""
"class ListBasedSet(collections.abc.Set):\n"
"    ''' Alternate set implementation favoring space over speed\n"
"        and not requiring the set elements to be hashable. '''\n"
"    def __init__(self, iterable):\n"
"        self.elements = lst = []\n"
"        for value in iterable:\n"
"            if value not in lst:\n"
"                lst.append(value)\n"
"\n"
"    def __iter__(self):\n"
"        return iter(self.elements)\n"
"\n"
"    def __contains__(self, value):\n"
"        return value in self.elements\n"
"\n"
"    def __len__(self):\n"
"        return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # The __and__() method is supported automatically"
msgstr ""
"class ListBasedSet(collections.abc.Set):\n"
"    ''' 空间重于速度并且不要求集合元素可哈希的\n"
"        替代性集合实现。 '''\n"
"    def __init__(self, iterable):\n"
"        self.elements = lst = []\n"
"        for value in iterable:\n"
"            if value not in lst:\n"
"                lst.append(value)\n"
"\n"
"    def __iter__(self):\n"
"        return iter(self.elements)\n"
"\n"
"    def __contains__(self, value):\n"
"        return value in self.elements\n"
"\n"
"    def __len__(self):\n"
"        return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # 自动支持 __and__() 方法"

#: ../../library/collections.abc.rst:417
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr "当把 :class:`Set` 和 :class:`MutableSet` 用作混入类时需注意："

#: ../../library/collections.abc.rst:420
msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an :term:`iterable`. The class constructor "
"is assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal :class:`classmethod` called "
":meth:`!_from_iterable` which calls ``cls(iterable)`` to produce a new set. "
"If the :class:`Set` mixin is being used in a class with a different "
"constructor signature, you will need to override :meth:`!_from_iterable` "
"with a classmethod or regular method that can construct new instances from "
"an iterable argument."
msgstr ""
"由于某些集合操作会创建新的集合，默认的混入方法需要一种根据 :term:`iterable` 创建新实例的方式。 类构造器应当具有 "
"``ClassName(iterable)`` 形式的签名。 这样它将被重构为一个执行 :meth:`!_from_iterable` 的内部 "
":class:`classmethod`，该方法会调用 ``cls(iterable)`` 来产生一个新的集合。 如果 :class:`Set` "
"混入类在具有不同构造器签名的类中被使用，你将需要通过一个能根据可迭代对象参数构造新实例的类方法或常规方法来重写 "
":meth:`!_from_iterable`。"

#: ../../library/collections.abc.rst:431
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`~object.__le__` and :meth:`~object.__ge__`, then the"
" other operations will automatically follow suit."
msgstr ""
"要重写比较运算（应该是为了提高速度，因为其语义是固定的），请重新定义 :meth:`~object.__le__` 和 "
":meth:`~object.__ge__`，然后其他运算将自动跟进。"

#: ../../library/collections.abc.rst:437
msgid ""
"The :class:`Set` mixin provides a :meth:`!_hash` method to compute a hash "
"value for the set; however, :meth:`~object.__hash__` is not defined because "
"not all sets are :term:`hashable` or immutable.  To add set hashability "
"using mixins, inherit from both :meth:`Set` and :meth:`Hashable`, then "
"define ``__hash__ = Set._hash``."
msgstr ""
":class:`Set` 混入类提供了一个 :meth:`!_hash` 方法为集合计算哈希值；但是，:meth:`~object.__hash__` "
"没有被定义因为并非所有集合都是 :term:`hashable` 或不可变对象。 要使用混入类为集合添加可哈希性，请同时继承 :meth:`Set` 和"
" :meth:`Hashable`，然后定义 ``__hash__ = Set._hash``。"

#: ../../library/collections.abc.rst:445
msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for an "
"example built on :class:`MutableSet`."
msgstr ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ 是基于 "
":class:`MutableSet` 构建的一个示例。"

#: ../../library/collections.abc.rst:448
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr "对于抽象基类，参见 :mod:`abc` 模块和 :pep:`3119`。"
