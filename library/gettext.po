# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/gettext.rst:2
msgid ":mod:`gettext` --- Multilingual internationalization services"
msgstr ":mod:`gettext` --- 多语种国际化服务"

#: ../../library/gettext.rst:10
msgid "**Source code:** :source:`Lib/gettext.py`"
msgstr "**源代码：** :source:`Lib/gettext.py`"

#: ../../library/gettext.rst:14
msgid ""
"The :mod:`gettext` module provides internationalization (I18N) and "
"localization (L10N) services for your Python modules and applications. It "
"supports both the GNU :program:`gettext` message catalog API and a higher "
"level, class-based API that may be more appropriate for Python files.  The "
"interface described below allows you to write your module and application "
"messages in one natural language, and provide a catalog of translated "
"messages for running under different natural languages."
msgstr ""
":mod:`gettext` 模块为 Python 模块和应用程序提供国际化 (Internationalization, I18N) 和本地化 "
"(Localization, L10N) 服务。它同时支持 GNU :program:`gettext` 消息编目 API 和更高级的、基于类的 "
"API，后者可能更适合于 Python "
"文件。下方描述的接口允许用户使用一种自然语言编写模块和应用程序消息，并提供翻译后的消息编目，以便在不同的自然语言下运行。"

#: ../../library/gettext.rst:22
msgid ""
"Some hints on localizing your Python modules and applications are also "
"given."
msgstr "同时还给出一些本地化 Python 模块及应用程序的小技巧。"

#: ../../library/gettext.rst:26
msgid "GNU :program:`gettext` API"
msgstr "GNU :program:`gettext` API"

#: ../../library/gettext.rst:28
msgid ""
"The :mod:`gettext` module defines the following API, which is very similar "
"to the GNU :program:`gettext` API.  If you use this API you will affect the "
"translation of your entire application globally.  Often this is what you "
"want if your application is monolingual, with the choice of language "
"dependent on the locale of your user.  If you are localizing a Python "
"module, or if your application needs to switch languages on the fly, you "
"probably want to use the class-based API instead."
msgstr ""
"模块 :mod:`gettext` 定义了下列  API，这与 :program:`gettext` API 类似。如果你使用该 "
"API，将会对整个应用程序产生全局的影响。如果你的应用程序支持多语种，而语言选择取决于用户的语言环境设置，这通常正是你所想要的。而如果你正在本地化某个 "
"Python 模块，或者你的应用程序需要在运行时切换语言，相反你或许想用基于类的API。"

#: ../../library/gettext.rst:39
msgid ""
"Bind the *domain* to the locale directory *localedir*.  More concretely, "
":mod:`gettext` will look for binary :file:`.mo` files for the given domain "
"using the path (on Unix): "
":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`, where *language* is "
"searched for in the environment variables :envvar:`LANGUAGE`, "
":envvar:`LC_ALL`, :envvar:`LC_MESSAGES`, and :envvar:`LANG` respectively."
msgstr ""
"将 *domain* 绑定到本地目录 *localedir*。 更具体地来说，模块 :mod:`gettext` 将使用路径 (在 Unix 系统中):"
"  :file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo` 查找二进制 :file:`.mo` "
"文件，此处对应地查找 *language* 的位置是环境变量 :envvar:`LANGUAGE`, :envvar:`LC_ALL`, "
":envvar:`LC_MESSAGES` 和 :envvar:`LANG` 中。"

#: ../../library/gettext.rst:45
msgid ""
"If *localedir* is omitted or ``None``, then the current binding for *domain*"
" is returned. [#]_"
msgstr "如果遗漏了 *localedir* 或者设置为 ``None``，那么将返回当前 *domain* 所绑定的值 [#]_"

#: ../../library/gettext.rst:51
msgid ""
"Change or query the current global domain.  If *domain* is ``None``, then "
"the current global domain is returned, otherwise the global domain is set to"
" *domain*, which is returned."
msgstr ""
"修改或查询当前的全局域。如果 *domain* 为 ``None``，则返回当前的全局域，不为 ``None`` 则将全局域设置为 "
"*domain*，并返回它。"

#: ../../library/gettext.rst:59
msgid ""
"Return the localized translation of *message*, based on the current global "
"domain, language, and locale directory.  This function is usually aliased as"
" :func:`!_` in the local namespace (see examples below)."
msgstr ""
"返回 *message* 的本地化翻译，依据当前的全局域、语言和语言区域目录。 本函数在局部命名空间中通常包含别名 :func:`!_` "
"(参见下面的示例)。"

#: ../../library/gettext.rst:66
msgid ""
"Like :func:`.gettext`, but look the message up in the specified *domain*."
msgstr "与 :func:`.gettext` 类似，但在指定的 *domain* 中查找 message。"

#: ../../library/gettext.rst:71
msgid ""
"Like :func:`.gettext`, but consider plural forms. If a translation is found,"
" apply the plural formula to *n*, and return the resulting message (some "
"languages have more than two plural forms). If no translation is found, "
"return *singular* if *n* is 1; return *plural* otherwise."
msgstr ""
"与 :func:`.gettext` 类似，但考虑了复数形式。如果找到了翻译，则将 *n* "
"代入复数公式，然后返回得出的消息（某些语言具有两种以上的复数形式）。如果未找到翻译，则 *n* 为 1 时返回 *singular*，为其他数时返回 "
"*plural*。"

#: ../../library/gettext.rst:76
msgid ""
"The Plural formula is taken from the catalog header. It is a C or Python "
"expression that has a free variable *n*; the expression evaluates to the "
"index of the plural in the catalog. See `the GNU gettext documentation "
"<https://www.gnu.org/software/gettext/manual/gettext.html>`__ for the "
"precise syntax to be used in :file:`.po` files and the formulas for a "
"variety of languages."
msgstr ""
"复数公式取自编目头文件。它是 C 或 Python 表达式，有一个自变量 *n*，该表达式计算的是所需复数形式在编目中的索引号。关于在 "
":file:`.po` 文件中使用的确切语法和各种语言的公式，请参阅 `GNU gettext 文档 "
"<https://www.gnu.org/software/gettext/manual/gettext.html>`__ 。"

#: ../../library/gettext.rst:86
msgid ""
"Like :func:`ngettext`, but look the message up in the specified *domain*."
msgstr "与 :func:`ngettext` 类似，但在指定的 *domain* 中查找 message。"

#: ../../library/gettext.rst:94
msgid ""
"Similar to the corresponding functions without the ``p`` in the prefix (that"
" is, :func:`gettext`, :func:`dgettext`, :func:`ngettext`, "
":func:`dngettext`), but the translation is restricted to the given message "
"*context*."
msgstr ""
"与前缀中没有 ``p`` 的相应函数类似（即 :func:`gettext`, :func:`dgettext`, :func:`ngettext`, "
":func:`dngettext` ），但是仅翻译给定的 message *context*。"

#: ../../library/gettext.rst:101
msgid ""
"Note that GNU :program:`gettext` also defines a :func:`!dcgettext` method, "
"but this was deemed not useful and so it is currently unimplemented."
msgstr ""
"请注意 GNU :program:`gettext` 还定义了一个 :func:`!dcgettext` 方法，但它被认为并不实用因此目前尚未实现它。"

#: ../../library/gettext.rst:104
msgid "Here's an example of typical usage for this API::"
msgstr "这是该 API 的典型用法示例::"

#: ../../library/gettext.rst:115
msgid "Class-based API"
msgstr "基于类的 API"

#: ../../library/gettext.rst:117
msgid ""
"The class-based API of the :mod:`gettext` module gives you more flexibility "
"and greater convenience than the GNU :program:`gettext` API.  It is the "
"recommended way of localizing your Python applications and modules.  "
":mod:`!gettext` defines a :class:`GNUTranslations` class which implements "
"the parsing of GNU :file:`.mo` format files, and has methods for returning "
"strings. Instances of this class can also install themselves in the built-in"
" namespace as the function :func:`!_`."
msgstr ""
"与 GNU :program:`gettext` API 相比，:mod:`gettext` 模块的基于类的API 提供了更多的灵活性和便利性。 "
"这是本地化 Python 应用程序和模块的推荐方式。 :mod:`!gettext` 定义了一个 :class:`GNUTranslations` "
"类，它实现了对 GNU :file:`.mo` 格式文件的解析，并且具有用于返回字符串的方法。 本类的实例也可以将自身作为函数 :func:`!_` "
"安装到内置命名空间中。"

#: ../../library/gettext.rst:127
msgid ""
"This function implements the standard :file:`.mo` file search algorithm.  It"
" takes a *domain*, identical to what :func:`textdomain` takes.  Optional "
"*localedir* is as in :func:`bindtextdomain`. Optional *languages* is a list "
"of strings, where each string is a language code."
msgstr ""
"本函数实现了标准的 :file:`.mo` 文件搜索算法。它接受一个 *domain*，它与 :func:`textdomain` "
"接受的域相同。可选参数 *localedir* 与 :func:`bindtextdomain` 中的相同。可选参数 *languages* "
"是多条字符串的列表，其中每条字符串都是一种语言代码。"

#: ../../library/gettext.rst:132
msgid ""
"If *localedir* is not given, then the default system locale directory is "
"used. [#]_  If *languages* is not given, then the following environment "
"variables are searched: :envvar:`LANGUAGE`, :envvar:`LC_ALL`, "
":envvar:`LC_MESSAGES`, and :envvar:`LANG`.  The first one returning a non-"
"empty value is used for the *languages* variable. The environment variables "
"should contain a colon separated list of languages, which will be split on "
"the colon to produce the expected list of language code strings."
msgstr ""
"如果没有传入 *localedir*，则使用默认的系统语言环境目录。 [#]_ 如果没有传入 "
"*languages*，则搜索以下环境变量：:envvar:`LANGUAGE`、:envvar:`LC_ALL`、:envvar:`LC_MESSAGES`"
" 和 :envvar:`LANG`。从这些变量返回的第一个非空值将用作 *languages* "
"变量。环境变量应包含一个语言列表，由冒号分隔，该列表会被按冒号拆分，以产生所需的语言代码字符串列表。"

#: ../../library/gettext.rst:140
msgid ""
":func:`find` then expands and normalizes the languages, and then iterates "
"through them, searching for an existing file built of these components:"
msgstr ":func:`find` 将扩展并规范化 language，然后遍历它们，搜索由这些组件构建的现有文件:"

#: ../../library/gettext.rst:143
msgid ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"
msgstr ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"

#: ../../library/gettext.rst:145
msgid ""
"The first such file name that exists is returned by :func:`find`. If no such"
" file is found, then ``None`` is returned. If *all* is given, it returns a "
"list of all file names, in the order in which they appear in the languages "
"list or the environment variables."
msgstr ""
":func:`find` 返回找到类似的第一个文件名。如果找不到这样的文件，则返回 ``None``。如果传入了 "
"*all*，它将返回一个列表，包含所有文件名，并按它们在语言列表或环境变量中出现的顺序排列。"

#: ../../library/gettext.rst:153
msgid ""
"Return a ``*Translations`` instance based on the *domain*, *localedir*, and "
"*languages*, which are first passed to :func:`find` to get a list of the "
"associated :file:`.mo` file paths.  Instances with identical :file:`.mo` "
"file names are cached.  The actual class instantiated is *class_* if "
"provided, otherwise :class:`GNUTranslations`.  The class's constructor must "
"take a single :term:`file object` argument."
msgstr ""
"根据 *domain*, *localedir* 和 *languages* 返回一个 ``*Translations`` 实例，它们将首先被传给 "
":func:`find` 以获取由所关联的 :file:`.mo` 文件路径组成的列表。 具有相同 :file:`.mo` 文件名的实例会被缓存。 "
"如果提供了 *class_* 则它将是被实例化的类，否则将是 :class:`GNUTranslations`。 该类的构造器必须接受一个 "
":term:`file object` 参数。"

#: ../../library/gettext.rst:160
msgid ""
"If multiple files are found, later files are used as fallbacks for earlier "
"ones. To allow setting the fallback, :func:`copy.copy` is used to clone each"
" translation object from the cache; the actual instance data is still shared"
" with the cache."
msgstr ""
"如果找到多个文件，后找到的文件将用作先前文件的替补。为了设置替补，将使用 :func:`copy.copy` 从缓存中克隆每个 translation "
"对象。实际的实例数据仍在缓存中共享。"

#: ../../library/gettext.rst:165
msgid ""
"If no :file:`.mo` file is found, this function raises :exc:`OSError` if "
"*fallback* is false (which is the default), and returns a "
":class:`NullTranslations` instance if *fallback* is true."
msgstr ""
"如果 :file:`.mo` 文件未找到，且 *fallback* 为 false（默认值），则本函数引发 :exc:`OSError` 异常，如果 "
"*fallback* 为 true，则返回一个 :class:`NullTranslations` 实例。"

#: ../../library/gettext.rst:169
msgid ""
":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr "过去触发的 :exc:`IOError`，现在是 :exc:`OSError` 的别名。"

#: ../../library/gettext.rst:172
msgid "*codeset* parameter is removed."
msgstr "*codeset* 形参已被移除。"

#: ../../library/gettext.rst:177
msgid ""
"This installs the function :func:`!_` in Python's builtins namespace, based "
"on *domain* and *localedir* which are passed to the function "
":func:`translation`."
msgstr ""
"这将在 Python 的内置命名空间中安装 :func:`!_` 函数，基于传给 :func:`translation` 函数的 *domain* 和 "
"*localedir*。"

#: ../../library/gettext.rst:180
msgid ""
"For the *names* parameter, please see the description of the translation "
"object's :meth:`~NullTranslations.install` method."
msgstr ""
"*names* 参数的信息请参阅 translation 对象的 :meth:`~NullTranslations.install` 方法的描述。"

#: ../../library/gettext.rst:183
msgid ""
"As seen below, you usually mark the strings in your application that are "
"candidates for translation, by wrapping them in a call to the :func:`!_` "
"function, like this::"
msgstr "如下所示，通常是将字符串包裹在对 :func:`!_` 函数的调用中，以标记应用程序中待翻译的字符串，就像这样::"

#: ../../library/gettext.rst:189
msgid ""
"For convenience, you want the :func:`!_` function to be installed in "
"Python's builtins namespace, so it is easily accessible in all modules of "
"your application."
msgstr "为了方便，可将 :func:`!_` 函数安装在 Python 的内置命名空间中，这样就可以在应用程序的所有模块中轻松地访问它。"

#: ../../library/gettext.rst:193
msgid "*names* is now a keyword-only parameter."
msgstr "*names* 现在是仅限关键字形参。"

#: ../../library/gettext.rst:197
msgid "The :class:`NullTranslations` class"
msgstr ":class:`NullTranslations` 类"

#: ../../library/gettext.rst:199
msgid ""
"Translation classes are what actually implement the translation of original "
"source file message strings to translated message strings. The base class "
"used by all translation classes is :class:`NullTranslations`; this provides "
"the basic interface you can use to write your own specialized translation "
"classes.  Here are the methods of :class:`!NullTranslations`:"
msgstr ""
"translation 类实际实现的是，将原始源文件消息字符串转换为已翻译的消息字符串。所有 translation 类使用的基类为 "
":class:`NullTranslations`，它提供了基本的接口，可用于编写自己定制的 translation 类。以下是 "
":class:`!NullTranslations` 的方法："

#: ../../library/gettext.rst:208
msgid ""
"Takes an optional :term:`file object` *fp*, which is ignored by the base "
"class. Initializes \"protected\" instance variables *_info* and *_charset* "
"which are set by derived classes, as well as *_fallback*, which is set "
"through :meth:`add_fallback`.  It then calls ``self._parse(fp)`` if *fp* is "
"not ``None``."
msgstr ""
"接受一个可选参数 :term:`文件对象 <file object>` *fp*，该参数会被基类忽略。初始化由派生类设置的 \"protected\" "
"（受保护的）实例变量 *_info* 和 *_charset*，与 *_fallback* 类似，但它是通过 :meth:`add_fallback` "
"来设置的。如果 *fp* 不为 ``None``，就会调用 ``self._parse(fp)``。"

#: ../../library/gettext.rst:216
msgid ""
"No-op in the base class, this method takes file object *fp*, and reads the "
"data from the file, initializing its message catalog.  If you have an "
"unsupported message catalog file format, you should override this method to "
"parse your format."
msgstr ""
"在基类中没有操作，本方法接受文件对象 "
"*fp*，从该文件读取数据，用来初始化消息编目。如果你手头的消息编目文件的格式不受支持，则应重写本方法来解析你的格式。"

#: ../../library/gettext.rst:224
msgid ""
"Add *fallback* as the fallback object for the current translation object. A "
"translation object should consult the fallback if it cannot provide a "
"translation for a given message."
msgstr ""
"添加 *fallback* 为当前 translation 对象的替补对象。如果 translation 对象无法为指定消息提供翻译，则应向替补查询。"

#: ../../library/gettext.rst:231
msgid ""
"If a fallback has been set, forward :meth:`!gettext` to the fallback. "
"Otherwise, return *message*.  Overridden in derived classes."
msgstr "如果设置了替补，则转发 :meth:`!gettext` 给替补。否则返回 *message*。在派生类中被重写。"

#: ../../library/gettext.rst:237
msgid ""
"If a fallback has been set, forward :meth:`!ngettext` to the fallback. "
"Otherwise, return *singular* if *n* is 1; return *plural* otherwise. "
"Overridden in derived classes."
msgstr ""
"如果设置了替补，则转发 :meth:`!ngettext` 给替补。否则，*n* 为 1 时返回 *singular*，为其他时返回 "
"*plural*。在派生类中被重写。"

#: ../../library/gettext.rst:244
msgid ""
"If a fallback has been set, forward :meth:`pgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr "如果设置了替补，则转发 :meth:`pgettext` 给替补。否则返回已翻译的消息。在派生类中被重写。"

#: ../../library/gettext.rst:252
msgid ""
"If a fallback has been set, forward :meth:`npgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr "如果设置了替补，则转发 :meth:`npgettext` 给替补。否则返回已翻译的消息。在派生类中被重写。"

#: ../../library/gettext.rst:260
msgid ""
"Return a dictionary containing the metadata found in the message catalog "
"file."
msgstr "返回一个包含在消息编目文件中找到的元数据的字典。"

#: ../../library/gettext.rst:266
msgid "Return the encoding of the message catalog file."
msgstr "返回消息编目文件的编码。"

#: ../../library/gettext.rst:271
msgid ""
"This method installs :meth:`.gettext` into the built-in namespace, binding "
"it to ``_``."
msgstr "本方法将 :meth:`.gettext` 安装至内建命名空间，并绑定为 ``_``。"

#: ../../library/gettext.rst:274
msgid ""
"If the *names* parameter is given, it must be a sequence containing the "
"names of functions you want to install in the builtins namespace in addition"
" to :func:`!_`.  Supported names are ``'gettext'``, ``'ngettext'``, "
"``'pgettext'``, and ``'npgettext'``."
msgstr ""
"如果给出了 *names* 形参，则它必须是一个包含除 :func:`!_` 外需要在内置命名空间中安装的函数的名称的序列。 受支持的名称有 "
"``'gettext'``, ``'ngettext'``, ``'pgettext'`` 和 ``'npgettext'``。"

#: ../../library/gettext.rst:279
msgid ""
"Note that this is only one way, albeit the most convenient way, to make the "
":func:`!_` function available to your application.  Because it affects the "
"entire application globally, and specifically the built-in namespace, "
"localized modules should never install :func:`!_`. Instead, they should use "
"this code to make :func:`!_` available to their module::"
msgstr ""
"请注意这只是将 :func:`!_` 函数提供给应用程序的一种方式，尽管也是最方便的方式。 "
"由于它会全局性地影响整个应用程序，特别是内置命名空间，因此本地化的模块绝不应安装 :func:`!_`。 作为替代，它们应使用以下代码使 "
":func:`!_` 可用于它们的模块::"

#: ../../library/gettext.rst:289
msgid ""
"This puts :func:`!_` only in the module's global namespace and so only "
"affects calls within this module."
msgstr "这样只把 :func:`!_` 放在模块的全局命名空间中所以只会影响该模块内的调用。"

#: ../../library/gettext.rst:292
msgid "Added ``'pgettext'`` and ``'npgettext'``."
msgstr "添加了 ``'pgettext'`` 和 ``'npgettext'``。"

#: ../../library/gettext.rst:297
msgid "The :class:`GNUTranslations` class"
msgstr ":class:`GNUTranslations` 类"

#: ../../library/gettext.rst:299
msgid ""
"The :mod:`!gettext` module provides one additional class derived from "
":class:`NullTranslations`: :class:`GNUTranslations`.  This class overrides "
":meth:`!_parse` to enable reading GNU :program:`gettext` format :file:`.mo` "
"files in both big-endian and little-endian format."
msgstr ""
":mod:`!gettext` 模块提供了一个派生自 :class:`NullTranslations` 的附加类: "
":class:`GNUTranslations`。 该类重写了 :meth:`!_parse` 以同时支持以大端序和小端序格式读取 GNU "
":program:`gettext` 格式的 :file:`.mo` 文件。"

#: ../../library/gettext.rst:304
msgid ""
":class:`GNUTranslations` parses optional metadata out of the translation "
"catalog. It is convention with GNU :program:`gettext` to include metadata as"
" the translation for the empty string. This metadata is in :rfc:`822`\\ "
"-style ``key: value`` pairs, and should contain the ``Project-Id-Version`` "
"key.  If the key ``Content-Type`` is found, then the ``charset`` property is"
" used to initialize the \"protected\" :attr:`!_charset` instance variable, "
"defaulting to ``None`` if not found.  If the charset encoding is specified, "
"then all message ids and message strings read from the catalog are converted"
" to Unicode using this encoding, else ASCII is assumed."
msgstr ""
":class:`GNUTranslations` 会从翻译编目中解析可选的元数据。 根据惯例 GNU :program:`gettext` "
"会以空字符串翻译的形式包括元数据。 该元数据使用 :rfc:`822` 风格的 ``key: value`` 对，并且应当包含 ``Project-"
"Id-Version`` 键。 如果找到了 ``Content-Type`` 键，则将使用 ``charset`` 属性来初始化 "
"\"protected\" :attr:`!_charset` 实例变量，如未找到则默认为 ``None``。 如果指定了 charset "
"编码格式，则从编目中读取的所有消息 ID 和消息字符串都将使用该编码格式转换为 Unicode，否则会设定使用 ASCII。"

#: ../../library/gettext.rst:314
msgid ""
"Since message ids are read as Unicode strings too, all ``*gettext()`` "
"methods will assume message ids as Unicode strings, not byte strings."
msgstr ""
"由于消息 ID 也是以 Unicode 字符串的形式读取的，因此所有 ``*gettext()`` 方法都会假定消息 ID 为 "
"Unicode字符串，而不是字节串。"

#: ../../library/gettext.rst:317
msgid ""
"The entire set of key/value pairs are placed into a dictionary and set as "
"the \"protected\" :attr:`!_info` instance variable."
msgstr "整个键/值对集合将被放入一个字典并设置为 \"protected\" :attr:`!_info` 实例变量。"

#: ../../library/gettext.rst:320
msgid ""
"If the :file:`.mo` file's magic number is invalid, the major version number "
"is unexpected, or if other problems occur while reading the file, "
"instantiating a :class:`GNUTranslations` class can raise :exc:`OSError`."
msgstr ""
"如果 :file:`.mo` 文件的魔法值 (magic number) 无效，或遇到意外的主版本号，或在读取文件时发生其他问题，则实例化 "
":class:`GNUTranslations` 类会引发 :exc:`OSError`。"

#: ../../library/gettext.rst:326
msgid ""
"The following methods are overridden from the base class implementation:"
msgstr "下列方法是根据基类实现重写的："

#: ../../library/gettext.rst:330
msgid ""
"Look up the *message* id in the catalog and return the corresponding message"
" string, as a Unicode string.  If there is no entry in the catalog for the "
"*message* id, and a fallback has been set, the look up is forwarded to the "
"fallback's :meth:`~NullTranslations.gettext` method.  Otherwise, the "
"*message* id is returned."
msgstr ""
"在编目中查找 *message* ID，并以 Unicode 字符串形式返回相应的消息字符串。如果在编目中没有 *message* ID "
"条目，且配置了替补，则查找请求将被转发到替补的 :meth:`~NullTranslations.gettext` 方法。否则，返回 *message*"
" ID。"

#: ../../library/gettext.rst:339
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the message"
" id for purposes of lookup in the catalog, while *n* is used to determine "
"which plural form to use.  The returned message string is a Unicode string."
msgstr ""
"查找消息 ID 的复数形式。*singular* 用作消息 ID，用于在编目中查找，同时 *n* 用于确定使用哪种复数形式。返回的消息字符串是 "
"Unicode 字符串。"

#: ../../library/gettext.rst:343
msgid ""
"If the message id is not found in the catalog, and a fallback is specified, "
"the request is forwarded to the fallback's "
":meth:`~NullTranslations.ngettext` method.  Otherwise, when *n* is 1 "
"*singular* is returned, and *plural* is returned in all other cases."
msgstr ""
"如果在编目中没有找到消息 ID，且配置了替补，则查找请求将被转发到替补的 :meth:`~NullTranslations.ngettext` "
"方法。否则，当 *n* 为 1 时返回 *singular*，其他情况返回 *plural*。"

#: ../../library/gettext.rst:348
msgid "Here is an example::"
msgstr "例如："

#: ../../library/gettext.rst:360
msgid ""
"Look up the *context* and *message* id in the catalog and return the "
"corresponding message string, as a Unicode string.  If there is no entry in "
"the catalog for the *message* id and *context*, and a fallback has been set,"
" the look up is forwarded to the fallback's :meth:`pgettext` method.  "
"Otherwise, the *message* id is returned."
msgstr ""
"在编目中查找 *context* 和 *message* ID，并以 Unicode 字符串形式返回相应的消息字符串。如果在编目中没有 "
"*message* ID 和 *context* 条目，且配置了替补，则查找请求将被转发到替补的 :meth:`pgettext` 方法。否则，返回 "
"*message* ID。"

#: ../../library/gettext.rst:371
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the message"
" id for purposes of lookup in the catalog, while *n* is used to determine "
"which plural form to use."
msgstr "查找消息 ID 的复数形式。*singular* 用作消息 ID，用于在编目中查找，同时 *n* 用于确定使用哪种复数形式。"

#: ../../library/gettext.rst:375
msgid ""
"If the message id for *context* is not found in the catalog, and a fallback "
"is specified, the request is forwarded to the fallback's :meth:`npgettext` "
"method.  Otherwise, when *n* is 1 *singular* is returned, and *plural* is "
"returned in all other cases."
msgstr ""
"如果在编目中没有找到 *context* 对应的消息 ID，且配置了替补，则查找请求将被转发到替补的 :meth:`npgettext` 方法。否则，当"
" *n* 为 1 时返回 *singular*，其他情况返回 *plural*。"

#: ../../library/gettext.rst:384
msgid "Solaris message catalog support"
msgstr "Solaris 消息编目支持"

#: ../../library/gettext.rst:386
msgid ""
"The Solaris operating system defines its own binary :file:`.mo` file format,"
" but since no documentation can be found on this format, it is not supported"
" at this time."
msgstr "Solaris 操作系统定义了自己的二进制 :file:`.mo` 文件格式，但由于找不到该格式的文档，因此目前不支持该格式。"

#: ../../library/gettext.rst:392
msgid "The Catalog constructor"
msgstr "编目构造器"

#: ../../library/gettext.rst:396
msgid ""
"GNOME uses a version of the :mod:`gettext` module by James Henstridge, but "
"this version has a slightly different API.  Its documented usage was::"
msgstr ""
"GNOME 用的 :mod:`gettext` 模块是 James Henstridge 写的版本，但该版本的 API 略有不同。它文档中的用法是::"

#: ../../library/gettext.rst:404
msgid ""
"For compatibility with this older module, the function :func:`!Catalog` is "
"an alias for the :func:`translation` function described above."
msgstr "为了与此模块的旧版本兼容，函数 :func:`!Catalog` 是上述 :func:`translation` 函数的别名。"

#: ../../library/gettext.rst:407
msgid ""
"One difference between this module and Henstridge's: his catalog objects "
"supported access through a mapping API, but this appears to be unused and so"
" is not currently supported."
msgstr ""
"本模块与 Henstridge 的模块有一个区别：他的编目对象支持通过映射 API 进行访问，但是该特性似乎从未使用过，因此目前不支持该特性。"

#: ../../library/gettext.rst:414
msgid "Internationalizing your programs and modules"
msgstr "国际化 (I18N) 你的程序和模块"

#: ../../library/gettext.rst:416
msgid ""
"Internationalization (I18N) refers to the operation by which a program is "
"made aware of multiple languages.  Localization (L10N) refers to the "
"adaptation of your program, once internationalized, to the local language "
"and cultural habits. In order to provide multilingual messages for your "
"Python programs, you need to take the following steps:"
msgstr ""
"国际化 (I18N) 是指使程序可切换多种语言的操作。本地化 (L10N) 是指程序的适配能力，一旦程序被国际化，就能适配当地的语言和文化习惯。为了向 "
"Python 程序提供不同语言的消息，需要执行以下步骤："

#: ../../library/gettext.rst:422
msgid ""
"prepare your program or module by specially marking translatable strings"
msgstr "准备程序或模块，将可翻译的字符串特别标记起来"

#: ../../library/gettext.rst:424
msgid ""
"run a suite of tools over your marked files to generate raw messages "
"catalogs"
msgstr "在已标记的文件上运行一套工具，用来生成原始消息编目"

#: ../../library/gettext.rst:426
msgid "create language-specific translations of the message catalogs"
msgstr "创建消息编目的不同语言的翻译"

#: ../../library/gettext.rst:428
msgid ""
"use the :mod:`gettext` module so that message strings are properly "
"translated"
msgstr "使用 :mod:`gettext` 模块，以便正确翻译消息字符串"

#: ../../library/gettext.rst:430
msgid ""
"In order to prepare your code for I18N, you need to look at all the strings "
"in your files.  Any string that needs to be translated should be marked by "
"wrapping it in ``_('...')`` --- that is, a call to the function :func:`_ "
"<gettext>`.  For example::"
msgstr ""
"为了准备代码以实现 I18N，你需要查看文件中的所有字符串。 任何需要翻译的字符串都应在 ``_('...')`` 中包含它来进行标记 --- "
"即调用函数  :func:`_ <gettext>`。 例如::"

#: ../../library/gettext.rst:439
msgid ""
"In this example, the string ``'writing a log message'`` is marked as a "
"candidate for translation, while the strings ``'mylog.txt'`` and ``'w'`` are"
" not."
msgstr ""
"在这个例子中，字符串 ``'writing a log message'`` 被标记为待翻译，而字符串 ``'mylog.txt'`` 和 "
"``'w'`` 没有被标记。"

#: ../../library/gettext.rst:442
msgid ""
"There are a few tools to extract the strings meant for translation. The "
"original GNU :program:`gettext` only supported C or C++ source code but its "
"extended version :program:`xgettext` scans code written in a number of "
"languages, including Python, to find strings marked as translatable.  `Babel"
" <https://babel.pocoo.org/>`__ is a Python internationalization library that"
" includes a :file:`pybabel` script to extract and compile message catalogs."
"  François Pinard's program called :program:`xpot` does a similar job and is"
" available as part of his `po-utils package <https://github.com/pinard/po-"
"utils>`__."
msgstr ""
"有一些工具可以将待翻译的字符串提取出来。 原版的 GNU :program:`gettext` 仅支持 C 或 C++ 源代码，但其扩展版 "
":program:`xgettext` 可以扫描多种语言的代码，包括 Python 在内，来找出标记为可翻译的字符串。 `Babel "
"<https://babel.pocoo.org/>`__ 是一个包括了可用于提取并编译消息编目的 :file:`pybabel` 脚本的 Python"
" 国际化库。 François Pinard 的 :program:`xpot` 程序也能完成类似的工作并可在他的 `po-utils 包 "
"<https://github.com/pinard/po-utils>`__ 中获取。"

#: ../../library/gettext.rst:452
msgid ""
"(Python also includes pure-Python versions of these programs, called "
":program:`pygettext.py` and :program:`msgfmt.py`; some Python distributions "
"will install them for you.  :program:`pygettext.py` is similar to "
":program:`xgettext`, but only understands Python source code and cannot "
"handle other programming languages such as C or C++. :program:`pygettext.py`"
" supports a command-line interface similar to :program:`xgettext`; for "
"details on its use, run ``pygettext.py --help``.  :program:`msgfmt.py` is "
"binary compatible with GNU :program:`msgfmt`.  With these two programs, you "
"may not need the GNU :program:`gettext` package to internationalize your "
"Python applications.)"
msgstr ""
"（Python 还包括了这些程序的纯 Python 版本，称为 :program:`pygettext.py` 和 "
":program:`msgfmt.py`，某些 Python 发行版已经安装了它们。:program:`pygettext.py` 类似于 "
":program:`xgettext`，但只能理解 Python 源代码，无法处理诸如 C 或 C++ "
"的其他编程语言。:program:`pygettext.py` 支持的命令行界面类似于 :program:`xgettext`，查看其详细用法请运行 "
"``pygettext.py --help``。:program:`msgfmt.py` 与 GNU :program:`msgfmt` "
"是二进制兼容的。有了这两个程序，可以不需要 GNU :program:`gettext` 包来国际化 Python 应用程序。）"

#: ../../library/gettext.rst:464
msgid ""
":program:`xgettext`, :program:`pygettext`, and similar tools generate "
":file:`.po` files that are message catalogs.  They are structured human-"
"readable files that contain every marked string in the source code, along "
"with a placeholder for the translated versions of these strings."
msgstr ""
":program:`xgettext`、:program:`pygettext` 或类似工具生成的 :file:`.po` "
"文件就是消息编目。它们是结构化的人类可读文件，包含源代码中所有被标记的字符串，以及这些字符串的翻译的占位符。"

#: ../../library/gettext.rst:470
msgid ""
"Copies of these :file:`.po` files are then handed over to the individual "
"human translators who write translations for every supported natural "
"language.  They send back the completed language-specific versions as a "
":file:`<language-name>.po` file that's compiled into a machine-readable "
":file:`.mo` binary catalog file using the :program:`msgfmt` program.  The "
":file:`.mo` files are used by the :mod:`gettext` module for the actual "
"translation processing at run-time."
msgstr ""
"然后把这些 :file:`.po` 文件的副本交给各个人工译者，他们为所支持的每种自然语言编写翻译。译者以 :file:`<语言名称>.po` "
"文件的形式发送回翻译完的某个语言的版本，将该文件用 :program:`msgfmt` 程序编译为机器可读的 :file:`.mo` "
"二进制编目文件。:mod:`gettext` 模块使用 :file:`.mo` 文件在运行时进行实际的翻译处理。"

#: ../../library/gettext.rst:479
msgid ""
"How you use the :mod:`gettext` module in your code depends on whether you "
"are internationalizing a single module or your entire application. The next "
"two sections will discuss each case."
msgstr "如何在代码中使用 :mod:`gettext` 模块取决于国际化单个模块还是整个应用程序。接下来的两节将讨论每种情况。"

#: ../../library/gettext.rst:485
msgid "Localizing your module"
msgstr "本地化你的模块"

#: ../../library/gettext.rst:487
msgid ""
"If you are localizing your module, you must take care not to make global "
"changes, e.g. to the built-in namespace. You should not use the GNU "
":program:`gettext` API but instead the class-based API."
msgstr ""
"如果要本地化模块，则切忌进行全局性的更改，如更改内建命名空间。不应使用 GNU :program:`gettext` API，而应使用基于类的 API。"

#: ../../library/gettext.rst:491
msgid ""
"Let's say your module is called \"spam\" and the module's various natural "
"language translation :file:`.mo` files reside in :file:`/usr/share/locale` "
"in GNU :program:`gettext` format.  Here's what you would put at the top of "
"your module::"
msgstr ""
"假设你的模块叫做 \"spam\"，并且该模块的各种自然语言翻译 :file:`.mo` 文件存放于 "
":file:`/usr/share/locale`，为 GNU :program:`gettext` 格式。以下内容应放在模块顶部::"

#: ../../library/gettext.rst:502
msgid "Localizing your application"
msgstr "本地化你的应用程序"

#: ../../library/gettext.rst:504
msgid ""
"If you are localizing your application, you can install the :func:`!_` "
"function globally into the built-in namespace, usually in the main driver "
"file of your application.  This will let all your application-specific files"
" just use ``_('...')`` without having to explicitly install it in each file."
msgstr ""
"如果你正在本地化你的应用程序，你可以将 :func:`!_` 函数全局安装到内置命名空间中，通常位于应用程序的主驱动文件内。 "
"这样将让你的应用程序专属的所有文件都可以使用 ``_('...')`` 而无需在每个文件中显示安装它。"

#: ../../library/gettext.rst:509
msgid ""
"In the simple case then, you need only add the following bit of code to the "
"main driver file of your application::"
msgstr "最简单的情况，就只需将以下代码添加到应用程序的主程序文件中::"

#: ../../library/gettext.rst:515
msgid ""
"If you need to set the locale directory, you can pass it into the "
":func:`install` function::"
msgstr "如果需要设置语言环境目录，可以将其传递给 :func:`install` 函数::"

#: ../../library/gettext.rst:523
msgid "Changing languages on the fly"
msgstr "即时更改语言"

#: ../../library/gettext.rst:525
msgid ""
"If your program needs to support many languages at the same time, you may "
"want to create multiple translation instances and then switch between them "
"explicitly, like so::"
msgstr "如果程序需要同时支持多种语言，则可能需要创建多个翻译实例，然后在它们之间进行显式切换，如下所示::"

#: ../../library/gettext.rst:546
msgid "Deferred translations"
msgstr "延迟翻译"

#: ../../library/gettext.rst:548
msgid ""
"In most coding situations, strings are translated where they are coded. "
"Occasionally however, you need to mark strings for translation, but defer "
"actual translation until later.  A classic example is::"
msgstr "在大多数代码中，字符串会在编写位置进行翻译。但偶尔需要将字符串标记为待翻译，实际翻译却推迟到后面。一个典型的例子是::"

#: ../../library/gettext.rst:561
msgid ""
"Here, you want to mark the strings in the ``animals`` list as being "
"translatable, but you don't actually want to translate them until they are "
"printed."
msgstr "此处希望将 ``animals`` 列表中的字符串标记为可翻译，但不希望在打印之前对它们进行翻译。"

#: ../../library/gettext.rst:565
msgid "Here is one way you can handle this situation::"
msgstr "这是处理该情况的一种方式::"

#: ../../library/gettext.rst:581
msgid ""
"This works because the dummy definition of :func:`!_` simply returns the "
"string unchanged.  And this dummy definition will temporarily override any "
"definition of :func:`!_` in the built-in namespace (until the :keyword:`del`"
" command). Take care, though if you have a previous definition of :func:`!_`"
" in the local namespace."
msgstr ""
"这样做是因为 :func:`!_` 的虚定义只是简单地原样返回字符串。 并且这个虚定义将临时覆盖内置命名空间中任何的 :func:`!_` 定义（直到 "
":keyword:`del` 命令）。 但是如果之前你在局部命名空间中已有 :func:`!_` 的定义，则需要特别注意。"

#: ../../library/gettext.rst:587
msgid ""
"Note that the second use of :func:`!_` will not identify \"a\" as being "
"translatable to the :program:`gettext` program, because the parameter is not"
" a string literal."
msgstr ""
"请注意在第二次使用 :func:`!_` 时将不会认为“a”可以由 :program:`gettext` 程序去翻译，因为该形参不是字符串字面值。"

#: ../../library/gettext.rst:591
msgid "Another way to handle this is with the following example::"
msgstr "解决该问题的另一种方法是下面这个例子::"

#: ../../library/gettext.rst:605
msgid ""
"In this case, you are marking translatable strings with the function "
":func:`!N_`, which won't conflict with any definition of :func:`!_`. "
"However, you will need to teach your message extraction program to look for "
"translatable strings marked with :func:`!N_`. :program:`xgettext`, "
":program:`pygettext`, ``pybabel extract``, and :program:`xpot` all support "
"this through the use of the :option:`!-k` command-line switch. The choice of"
" :func:`!N_` here is totally arbitrary; it could have just as easily been "
":func:`!MarkThisStringForTranslation`."
msgstr ""
"在这种情况下，你用函数  :func:`!N_` 来标记可翻译的字符串，它与 :func:`!_` 的任何定义都不会冲突。 "
"不过，你需要让你的消息提取程序寻找用 :func:`!N_` 标记的可翻译字符串。 :program:`xgettext`, "
":program:`pygettext`, ``pybabel extract`` 和 :program:`xpot` 都通过使用 "
":option:`!-k` 命令行开关来支持此功能。 这里选择用 :func:`!N_` 完全是任意的；它也可以简单地改为 "
":func:`!MarkThisStringForTranslation`。"

#: ../../library/gettext.rst:616
msgid "Acknowledgements"
msgstr "致谢"

#: ../../library/gettext.rst:618
msgid ""
"The following people contributed code, feedback, design suggestions, "
"previous implementations, and valuable experience to the creation of this "
"module:"
msgstr "以下人员为创建此模块贡献了代码、反馈、设计建议、早期实现和宝贵的经验："

#: ../../library/gettext.rst:621
msgid "Peter Funk"
msgstr "Peter Funk"

#: ../../library/gettext.rst:623
msgid "James Henstridge"
msgstr "James Henstridge"

#: ../../library/gettext.rst:625
msgid "Juan David Ibáñez Palomar"
msgstr "Juan David Ibáñez Palomar"

#: ../../library/gettext.rst:627
msgid "Marc-André Lemburg"
msgstr "Marc-André Lemburg"

#: ../../library/gettext.rst:629
msgid "Martin von Löwis"
msgstr "Martin von Löwis"

#: ../../library/gettext.rst:631
msgid "François Pinard"
msgstr "François Pinard"

#: ../../library/gettext.rst:633
msgid "Barry Warsaw"
msgstr "Barry Warsaw"

#: ../../library/gettext.rst:635
msgid "Gustavo Niemeyer"
msgstr "Gustavo Niemeyer"

#: ../../library/gettext.rst:638
msgid "Footnotes"
msgstr "备注"

#: ../../library/gettext.rst:639
msgid ""
"The default locale directory is system dependent; for example, on Red Hat "
"Linux it is :file:`/usr/share/locale`, but on Solaris it is "
":file:`/usr/lib/locale`. The :mod:`!gettext` module does not try to support "
"these system dependent defaults; instead its default is "
":file:`{sys.base_prefix}/share/locale` (see :data:`sys.base_prefix`). For "
"this reason, it is always best to call :func:`bindtextdomain` with an "
"explicit absolute path at the start of your application."
msgstr ""
"默认的语言区域目录取决于具体系统；例如，在 Red Hat Linux 上为 :file:`/usr/share/locale`，但在 Solaris "
"上则为 :file:`/usr/lib/locale`。 :mod:`!gettext` 模块没有试图支持这些依赖于系统的默认值；而是默认设为 "
":file:`{sys.base_prefix}/share/locale` (参见 :data:`sys.base_prefix`)。 "
"基于上述原因，最好每次都在程序启动时调用 :func:`bindtextdomain` 并附带一个显式的绝对路径。"

#: ../../library/gettext.rst:647
msgid "See the footnote for :func:`bindtextdomain` above."
msgstr "参阅上方 :func:`bindtextdomain` 的脚注。"

#: ../../library/gettext.rst:56
msgid "_ (underscore)"
msgstr "_ (下划线)"

#: ../../library/gettext.rst:56
msgid "gettext"
msgstr "gettext"

#: ../../library/gettext.rst:394
msgid "GNOME"
msgstr "GNOME"
