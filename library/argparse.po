# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 14:57+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/argparse.rst:2
msgid ""
":mod:`!argparse` --- Parser for command-line options, arguments and "
"subcommands"
msgstr ":mod:`!argparse` --- 用于命令行选项、参数和子命令的解析器"

#: ../../library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**源代码：** :source:`Lib/argparse.py`"

#: ../../library/argparse.rst:16
msgid ""
"While :mod:`argparse` is the default recommended standard library module for"
" implementing basic command line applications, authors with more exacting "
"requirements for exactly how their command line applications behave may find"
" it doesn't provide the necessary level of control. Refer to :ref:`choosing-"
"an-argument-parser` for alternatives to consider when ``argparse`` doesn't "
"support behaviors that the application requires (such as entirely disabling "
"support for interspersed options and positional arguments, or accepting "
"option parameter values that start with ``-`` even when they correspond to "
"another defined option)."
msgstr ""
"虽然 :mod:`argparse` "
"是推荐的用于实现基本命令行应用程序的标准库模块，但对于命令行应用程序的行为有更明确的要求的开发者可能会发现它并未提供所需层次的控制能力。 请参阅 "
":ref:`choosing-an-argument-parser` 了解当 ``argparse`` "
"不支持特定应用程序需要的行为（例如完全禁用散开选项和位置参数，或接受以 ``-`` 开头的选项形参值即使它们对应了其它已定义的选项）时可以考虑的替代。"

#: ../../library/argparse.rst-1
msgid "Tutorial"
msgstr "教程"

#: ../../library/argparse.rst:30
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the "
":ref:`argparse tutorial <argparse-tutorial>`."
msgstr ""
"此页面包含该 API 的参考信息。有关 Python 命令行解析更细致的介绍，请参阅 :ref:`argparse 教程 <argparse-"
"tutorial>`。"

#: ../../library/argparse.rst:34
msgid ""
"The :mod:`!argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and "
":mod:`!argparse` will figure out how to parse those out of :data:`sys.argv`."
"  The :mod:`!argparse` module also automatically generates help and usage "
"messages.  The module will also issue errors when users give the program "
"invalid arguments."
msgstr ""
":mod:`!argparse` 模块让编写用户友好的命令行接口变得容易。 程序定义它需要哪些参数，:mod:`!argparse` 将会知道如何从 "
":data:`sys.argv` 解析它们。 :mod:`!argparse` 模块还能自动生成帮助和用法消息文本。 "
"该模块还会在用户向程序传入无效参数时发出错误提示。"

#: ../../library/argparse.rst:40
msgid ""
"The :mod:`!argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply to the parser as "
"whole::"
msgstr ""
":mod:`!argparse` 模块对命令行界面的支持是围绕 :class:`argparse.ArgumentParser` 实例建立的。 "
"它是一个用于参数规格说明的容器并包含应用于解析器的一组选项::"

#: ../../library/argparse.rst:44
msgid ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"
msgstr ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"

#: ../../library/argparse.rst:49
msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""
":meth:`ArgumentParser.add_argument` 方法将单个参数规格说明关联到解析器。 "
"它支持位置参数，接受各种值的选项，以及各种启用/禁用旗标::"

#: ../../library/argparse.rst:53
msgid ""
"parser.add_argument('filename')           # positional argument\n"
"parser.add_argument('-c', '--count')      # option that takes a value\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # on/off flag"
msgstr ""
"parser.add_argument('filename')           # 位置参数\n"
"parser.add_argument('-c', '--count')      # 接受一个值的选项\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # 启用/禁用旗标"

#: ../../library/argparse.rst:58
msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""
":meth:`ArgumentParser.parse_args` 方法运行解析器并将提取的数据放入 "
":class:`argparse.Namespace` 对象::"

#: ../../library/argparse.rst:61
msgid ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"
msgstr ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"

#: ../../library/argparse.rst:65
msgid ""
"If you're looking for a guide about how to upgrade :mod:`optparse` code to "
":mod:`!argparse`, see :ref:`Upgrading Optparse Code <upgrading-optparse-"
"code>`."
msgstr ""
"如果您正在寻找如何将 :mod:`optparse` 代码升级到 :mod:`!argparse` 的指南，请参阅 :ref:`Upgrading "
"Optparse Code <upgrading-optparse-code>`。"

#: ../../library/argparse.rst:69
msgid "ArgumentParser objects"
msgstr "ArgumentParser 对象"

#: ../../library/argparse.rst:78
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed"
" as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"创建一个新的 :class:`ArgumentParser` "
"对象。所有的参数都应当作为关键字参数传入。每个参数在下面都有它更详细的描述，但简而言之，它们是："

#: ../../library/argparse.rst:82
msgid ""
"prog_ - The name of the program (default: ``os.path.basename(sys.argv[0])``)"
msgstr "prog_ - 程序的名称 (默认值: ``os.path.basename(sys.argv[0])``)"

#: ../../library/argparse.rst:85
msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr "usage_ - 描述程序用途的字符串（默认值：从添加到解析器的参数生成）"

#: ../../library/argparse.rst:88
msgid ""
"description_ - Text to display before the argument help (by default, no "
"text)"
msgstr "description_ - 要在参数帮助信息之前显示的文本（默认：无文本）"

#: ../../library/argparse.rst:91
msgid ""
"epilog_ - Text to display after the argument help (by default, no text)"
msgstr "epilog_ - 要在参数帮助信息之后显示的文本（默认：无文本）"

#: ../../library/argparse.rst:93
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr "parents_ - 一个 :class:`ArgumentParser` 对象的列表，它们的参数也应包含在内"

#: ../../library/argparse.rst:96
msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - 用于自定义帮助文档输出格式的类"

#: ../../library/argparse.rst:98
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr "prefix_chars_ - 可选参数的前缀字符集合（默认值： '-'）"

#: ../../library/argparse.rst:101
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr "fromfile_prefix_chars_ - 当需要从文件中读取其他参数时，用于标识文件名的前缀字符集合（默认值： ``None``）"

#: ../../library/argparse.rst:104
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr "argument_default_ - 参数的全局默认值（默认值： ``None``）"

#: ../../library/argparse.rst:107
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr "conflict_handler_ - 解决冲突选项的策略（通常是不必要的）"

#: ../../library/argparse.rst:110
msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr "add_help_ - 为解析器添加一个 ``-h/--help`` 选项（默认值： ``True``）"

#: ../../library/argparse.rst:112
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is"
" unambiguous. (default: ``True``)"
msgstr "allow_abbrev_ - 如果缩写是无歧义的，则允许缩写长选项 （默认值：``True``）"

#: ../../library/argparse.rst:115
msgid ""
"exit_on_error_ - Determines whether or not :class:`!ArgumentParser` exits "
"with error info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ - 确定当出现错误时，:class:`!ArgumentParser` "
"是否退出并显示错误信息。（默认值:``True``）"

#: ../../library/argparse.rst:118
msgid "*allow_abbrev* parameter was added."
msgstr "增加了 *allow_abbrev* 参数。"

#: ../../library/argparse.rst:121
msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr "在之前的版本中，*allow_abbrev* 还会禁用短旗标分组，例如 ``-vv`` 表示为 ``-v -v``。"

#: ../../library/argparse.rst:125
msgid "*exit_on_error* parameter was added."
msgstr "添加了 *exit_on_error* 形参。"

#: ../../library/argparse.rst:128 ../../library/argparse.rst:610
msgid "The following sections describe how each of these are used."
msgstr "以下部分描述这些参数如何使用。"

#: ../../library/argparse.rst:134
msgid "prog"
msgstr "prog"

#: ../../library/argparse.rst:137
msgid ""
"By default, :class:`ArgumentParser` calculates the name of the program to "
"display in help messages depending on the way the Python interpreter was "
"run:"
msgstr "默认情况下 ，:class:`ArgumentParser` 根据Python 解释器 的运行方式，计算出要在帮助信息中显示的程序名称："

#: ../../library/argparse.rst:140
msgid ""
"The :func:`base name <os.path.basename>` of ``sys.argv[0]`` if a file was "
"passed as argument."
msgstr ""
"如果作为参数传递的是文件，则是``sys.argv[0]`` 的 :func:`base name <os.path.basename>` 。"

#: ../../library/argparse.rst:142
msgid ""
"The Python interpreter name followed by ``sys.argv[0]`` if a directory or a "
"zipfile was passed as argument."
msgstr "如果作为参数传递的是目录或 ZIP 文件，则是Python 解释器名称，后接 ``sys.argv[0]``。"

#: ../../library/argparse.rst:144
msgid ""
"The Python interpreter name followed by ``-m`` followed by the module or "
"package name if the :option:`-m` option was used."
msgstr "如果使用 :option:`-m` 选项则是在 Python 解释器名称后接 ``-m`` 再加模块或包的名称。"

#: ../../library/argparse.rst:147
msgid ""
"This default is almost always desirable because it will make the help "
"messages match the string that was used to invoke the program on the command"
" line. However, to change this default behavior, another value can be "
"supplied using the ``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"默认行为几乎总是符合需求因为它将使帮助消息与在命令行上唤起程序所用的字符串相匹配。 不过，要更改此默认行为，可以将 ``prog=`` 参数传入 "
":class:`ArgumentParser` 以提供另外的值::"

#: ../../library/argparse.rst:152
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"

#: ../../library/argparse.rst:159
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or from "
"the ``prog=`` argument, is available to help messages using the ``%(prog)s``"
" format specifier."
msgstr ""
"需要注意的是，无论是从 ``sys.argv[0]`` 或是从 ``prog=`` 参数确定的程序名称，都可以在帮助消息里通过 ``%(prog)s``"
" 格式说明符来引用。"

#: ../../library/argparse.rst:165
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"

#: ../../library/argparse.rst:176
msgid "usage"
msgstr "usage（用法）"

#: ../../library/argparse.rst:178
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains. The default message can be overridden with the "
"``usage=`` keyword argument::"
msgstr ""
"默认情况下，:class:`ArgumentParser` 会从它所包含的参数中计算出用法消息。 默认消息可以通过 ``usage=`` "
"关键字参数进行覆盖。"

#: ../../library/argparse.rst:182
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"

#: ../../library/argparse.rst:195
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr "在用法消息中可以使用 ``%(prog)s`` 格式说明符来填入程序名称。"

#: ../../library/argparse.rst:202
msgid "description"
msgstr "description（描述）"

#: ../../library/argparse.rst:204
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments."
msgstr ""
"大多数对 :class:`ArgumentParser` 构造器的调用都会使用 ``description=`` 关键字参数。 "
"这个参数简要描述这个程序做什么以及怎么做。 在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间。"

#: ../../library/argparse.rst:210
msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr "在默认情况下，description 将被换行以便适应给定的空间。如果想改变这种行为，见 formatter_class_ 参数。"

#: ../../library/argparse.rst:215
msgid "epilog"
msgstr "epilog"

#: ../../library/argparse.rst:217
msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"一些程序喜欢在 description 参数后显示额外的对程序的描述。这种文字能够通过给 :class:`ArgumentParser`:: 提供 "
"``epilog=`` 参数而被指定。"

#: ../../library/argparse.rst:221
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"

#: ../../library/argparse.rst:234
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"和 description_ 参数一样，``epilog=`` text 在默认情况下会换行，但是这种行为能够被调整通过提供 "
"formatter_class_ 参数给 :class:`ArgumentParse`."

#: ../../library/argparse.rst:240
msgid "parents"
msgstr "parents"

#: ../../library/argparse.rst:242
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to "
":class:`ArgumentParser` can be used.  The ``parents=`` argument takes a list"
" of :class:`ArgumentParser` objects, collects all the positional and "
"optional actions from them, and adds these actions to the "
":class:`ArgumentParser` object being constructed::"
msgstr ""
"有些时候，少数解析器会使用同一系列参数。 单个解析器能够通过提供 ``parents=`` 参数给 :class:`ArgumentParser` "
"而使用相同的参数而不是重复这些参数的定义。``parents=`` 参数使用 :class:`ArgumentParser` "
"对象的列表，从它们那里收集所有的位置和可选的行为，然后将这写行为加到正在构建的 :class:`ArgumentParser` 对象。"

#: ../../library/argparse.rst:249
msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"

#: ../../library/argparse.rst:262
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"请注意大多数父解析器会指定 ``add_help=False`` . 否则， :class:`ArgumentParse` 将会看到两个 "
"``-h/--help`` 选项（一个在父参数中一个在子参数中）并且产生一个错误。"

#: ../../library/argparse.rst:267
msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr "你在通过 ``parents=`` 传递解析器之前必须完全初始化它们。 如果你在子解析器之后改变父解析器，这些改变将不会反映在子解析器上。"

#: ../../library/argparse.rst:275
msgid "formatter_class"
msgstr "formatter_class"

#: ../../library/argparse.rst:277
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such"
" classes:"
msgstr ":class:`ArgumentParser` 对象允许通过指定备用格式化类来自定义帮助格式。目前，有四种这样的类。"

#: ../../library/argparse.rst:286
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, "
":class:`ArgumentParser` objects line-wrap the description_ and epilog_ texts"
" in command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` 和 :class:`RawTextHelpFormatter` "
"在正文的描述和展示上给与了更多的控制。:class:`ArgumentParser` 对象会将 description_ 和 epilog_ "
"的文字在命令行中自动换行。"

#: ../../library/argparse.rst:291
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose words\n"
"will be wrapped across a couple lines"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose words\n"
"will be wrapped across a couple lines"

#: ../../library/argparse.rst:311
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"传 :class:`RawDescriptionHelpFormatter` 给 ``formatter_class=`` 表示 "
"description_ 和 epilog_ 已经被正确的格式化了，不能在命令行中被自动换行::"

#: ../../library/argparse.rst:315
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"

#: ../../library/argparse.rst:337
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple newlines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` 保留各种帮助文本的空白符，包括参数描述。 但是，多个换行符会被替换为一个。 "
"如果你希望保留多个空行，请在换行符之间添加空格。"

#: ../../library/argparse.rst:342
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ":class:`ArgumentDefaultsHelpFormatter` 自动添加默认的值的信息到每一个帮助信息的参数中::"

#: ../../library/argparse.rst:345
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"

#: ../../library/argparse.rst:360
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` 为它的值在每一个参数中使用 type_ 的参数名当作它的显示名（而不是使用通常的格式"
" dest_ )::"

#: ../../library/argparse.rst:364
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"

#: ../../library/argparse.rst:381
msgid "prefix_chars"
msgstr "prefix_chars"

#: ../../library/argparse.rst:383
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g."
" for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the :class:`ArgumentParser` constructor::"
msgstr ""
"大多数命令行选项会使用 ``-`` 作为前缀，例如 ``-f/--foo``。 如果解析器需要支持不同的或者额外的前缀字符，例如像 ``+f`` 或 "
"``/foo`` 之类的选项，可以在 :class:`ArgumentParser` 构造器中使用 ``prefix_chars=`` "
"参数来指定它们::"

#: ../../library/argparse.rst:389
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"

#: ../../library/argparse.rst:395
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be"
" disallowed."
msgstr ""
"``prefix_chars=`` 参数默认使用 ``'-'``。 提供一组不包括 ``-`` 的字符将导致 ``-f/--foo`` 选项不被允许。"

#: ../../library/argparse.rst:401
msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

#: ../../library/argparse.rst:403
msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""
"在某些时候，如在处理一个特别长的参数列表时，把参数列表保存在一个文件中而不是在命令行中打印出来会更有意义。 如果提供 "
"``fromfile_prefix_chars=`` 参数给 :class:`ArgumentParser` "
"构造器，则任何以指定字符打头的参数都将被当作文件来处理，并将被它们包含的参数所替代。 举例来说::"

#: ../../library/argparse.rst:410
msgid ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"

#: ../../library/argparse.rst:418
msgid ""
"Arguments read from a file must by default be one per line (but see also "
":meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they"
" were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', "
"'-f', 'bar']``."
msgstr ""
"从文件读取的参数在默认情况下必须一个一行（但是可参见  "
":meth:`~ArgumentParser.convert_arg_line_to_args`）并且它们被视为与命令行上的原始文件引用参数位于同一位置。所以在以上例子中，``['-f',"
" 'foo', '@args.txt']`` 的表示和 ``['-f', 'foo', '-f', 'bar']`` 的表示相同。"

#: ../../library/argparse.rst:424
msgid ""
":class:`ArgumentParser` uses :term:`filesystem encoding and error handler` "
"to read the file containing arguments."
msgstr ""
":class:`ArgumentParser` 使用 :term:`filesystem encoding and error handler` "
"来读取包含参数的文件。"

#: ../../library/argparse.rst:427
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr "``fromfile_prefix_chars=`` 参数默认为 ``None``，意味着参数不会被当作文件对待。"

#: ../../library/argparse.rst:430
msgid ""
":class:`ArgumentParser` changed encoding and errors to read arguments files "
"from default (e.g. :func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>` and ``\"strict\"``) to the :term:`filesystem "
"encoding and error handler`. Arguments file should be encoded in UTF-8 "
"instead of ANSI Codepage on Windows."
msgstr ""
":class:`ArgumentParser` 将读取参数的编码格式和错误处理方式从默认值 (即 "
":func:`locale.getpreferredencoding(False) <locale.getpreferredencoding>` 和 "
"``\"strict\"``) 改为 :term:`filesystem encoding and error handler`。 在 Windows "
"上参数文件应当以 UTF-8 而不是 ANSI 代码页来编码。"

#: ../../library/argparse.rst:438
msgid "argument_default"
msgstr "argument_default"

#: ../../library/argparse.rst:440
msgid ""
"Generally, argument defaults are specified either by passing a default to "
":meth:`~ArgumentParser.add_argument` or by calling the "
":meth:`~ArgumentParser.set_defaults` methods with a specific set of name-"
"value pairs.  Sometimes however, it may be useful to specify a single "
"parser-wide default for arguments.  This can be accomplished by passing the "
"``argument_default=`` keyword argument to :class:`ArgumentParser`.  For "
"example, to globally suppress attribute creation on "
":meth:`~ArgumentParser.parse_args` calls, we supply "
"``argument_default=SUPPRESS``::"
msgstr ""
"一般情况下，参数默认会通过设置一个默认到 :meth:`~ArgumentParser.add_argument` 或者调用带一组指定键值对的 "
":meth:`ArgumentParser.set_defaults` 方法。但是有些时候，为参数指定一个普遍适用的解析器会更有用。这能够通过传输 "
"``argument_default=`` 关键词参数给 :class:`ArgumentParser` 来完成。举个栗子，要全局禁止在 "
":meth:`~ArgumentParser.parse_args` 中创建属性，我们提供 "
"``argument_default=SUPPRESS``::"

#: ../../library/argparse.rst:449
msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"

#: ../../library/argparse.rst:460
msgid "allow_abbrev"
msgstr "allow_abbrev"

#: ../../library/argparse.rst:462
msgid ""
"Normally, when you pass an argument list to the "
":meth:`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it "
":ref:`recognizes abbreviations <prefix-matching>` of long options."
msgstr ""
"正常情况下，当你向 :class:`ArgumentParser` 的 :meth:`~ArgumentParser.parse_args` "
"方法传入一个参数列表时，它会 :ref:`recognizes abbreviations  <prefix-matching>`。"

#: ../../library/argparse.rst:466
msgid ""
"This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr "这个特性可以设置 ``allow_abbrev`` 为 ``False`` 来关闭::"

#: ../../library/argparse.rst:468
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"

#: ../../library/argparse.rst:479
msgid "conflict_handler"
msgstr "conflict_handler"

#: ../../library/argparse.rst:481
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
":class:`ArgumentParser` 对象不允许在相同选项字符串下有两种行为。默认情况下， :class:`ArgumentParser` "
"对象会产生一个异常如果去创建一个正在使用的选项字符串参数。"

#: ../../library/argparse.rst:486
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"

#: ../../library/argparse.rst:493
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any"
" older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument of"
" :class:`ArgumentParser`::"
msgstr ""
"有些时候（例如：使用 parents_），重写旧的有相同选项字符串的参数会更有用。为了产生这种行为， ``'resolve'`` 值可以提供给 "
":class:`ArgumentParser` 的 ``conflict_handler=`` 参数::"

#: ../../library/argparse.rst:498
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"

#: ../../library/argparse.rst:509
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old "
"``-f/--foo`` action is retained as the ``-f`` action, because only the "
"``--foo`` option string was overridden."
msgstr ""
"注意 :class:`ArgumentParser` 对象只能移除一个行为如果它所有的选项字符串都被重写。所以，在上面的例子中，旧的 "
"``-f/--foo`` 行为 回合 ``-f`` 行为保持一样, 因为只有 ``--foo`` 选项字符串被重写。"

#: ../../library/argparse.rst:516
msgid "add_help"
msgstr "add_help"

#: ../../library/argparse.rst:518
msgid ""
"By default, :class:`ArgumentParser` objects add an option which simply "
"displays the parser's help message. If ``-h`` or ``--help`` is supplied at "
"the command line, the :class:`!ArgumentParser` help will be printed."
msgstr ""
"在默认情况下，:class:`ArgumentParser` 对象会添加一个简单地显示解析器的帮助消息的选项。 如果在命令行中提供了 ``-h`` 或 "
"``--help``，则会打印 :class:`!ArgumentParser` 帮助消息。"

#: ../../library/argparse.rst:522
msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to "
":class:`ArgumentParser`::"
msgstr ""
"有时候可能会需要关闭额外的帮助信息。这可以通过在 :class:`ArgumentParser` 中设置 ``add_help=`` 参数为 "
"``False`` 来实现。"

#: ../../library/argparse.rst:526
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"

#: ../../library/argparse.rst:534
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case "
"``-h`` and ``--help`` are not valid options.  In this case, the first "
"character in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"帮助选项一般为 ``-h/--help``。如果 ``prefix_chars=`` 被指定并且没有包含 ``-`` 字符，在这种情况下， ``-h``"
" ``--help`` 不是有效的选项。此时， ``prefix_chars`` 的第一个字符将用作帮助选项的前缀。"

#: ../../library/argparse.rst:540
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"

#: ../../library/argparse.rst:549
msgid "exit_on_error"
msgstr "exit_on_error"

#: ../../library/argparse.rst:551
msgid ""
"Normally, when you pass an invalid argument list to the "
":meth:`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it "
"will print a *message* to :data:`sys.stderr` and exit with a status code of "
"2."
msgstr ""
"通常，当你向 :class:`ArgumentParser`  :meth:`~ArgumentParser.parse_args` "
"方法传入一个无效的参数列表时，它会将 *message* 打印到 :data:`sys.stderr` 并附带状态码 2 退出程序。"

#: ../../library/argparse.rst:555
msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr "如果用户想要手动捕获错误，可通过将 ``exit_on_error`` 设为 ``False`` 来启用该特性::"

#: ../../library/argparse.rst:558
msgid ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"
msgstr ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"

#: ../../library/argparse.rst:572
msgid "The add_argument() method"
msgstr "add_argument() 方法"

#: ../../library/argparse.rst:578
msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr "定义单个的命令行参数应当如何解析。每个形参都在下面有它自己更多的描述，长话短说有："

#: ../../library/argparse.rst:581
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``'foo'``"
" or ``'-f', '--foo'``."
msgstr ""
"`name or flags`_ - 一个名称或是由选项字符串组成的列表，例如 ``'foo'`` 或 ``'-f', '--foo'``。"

#: ../../library/argparse.rst:584
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr "action_ - 当参数在命令行中出现时使用的动作基本类型。"

#: ../../library/argparse.rst:587
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr "nargs_ - 命令行参数应当消耗的数目。"

#: ../../library/argparse.rst:589
msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr "const_ - 被一些 action_ 和 nargs_ 选择所需求的常数。"

#: ../../library/argparse.rst:591
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr "default_ - 当参数未在命令行中出现并且也不存在于命名空间对象时所产生的值。"

#: ../../library/argparse.rst:594
msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr "type_ - 命令行参数应当被转换成的类型。"

#: ../../library/argparse.rst:596
msgid "choices_ - A sequence of the allowable values for the argument."
msgstr "choices_ - 由允许作为参数的值组成的序列。"

#: ../../library/argparse.rst:598
msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals"
" only)."
msgstr "required_ - 此命令行选项是否可省略 （仅选项可用）。"

#: ../../library/argparse.rst:601
msgid "help_ - A brief description of what the argument does."
msgstr "help_ - 一个此选项作用的简单描述。"

#: ../../library/argparse.rst:603
msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ - 在使用方法消息中使用的参数值示例。"

#: ../../library/argparse.rst:605
msgid ""
"dest_ - The name of the attribute to be added to the object returned by "
":meth:`parse_args`."
msgstr "dest_ - 被添加到 :meth:`parse_args` 所返回对象上的属性名。"

#: ../../library/argparse.rst:608
msgid "deprecated_ - Whether or not use of the argument is deprecated."
msgstr "deprecated_ - 参数的使用是否已被弃用。"

#: ../../library/argparse.rst:616
msgid "name or flags"
msgstr "name or flags"

#: ../../library/argparse.rst:618
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to "
":meth:`~ArgumentParser.add_argument` must therefore be either a series of "
"flags, or a simple argument name."
msgstr ""
":meth:`~ArgumentParser.add_argument` 方法必须知道是要接收一个可选参数，如 ``-f`` 或 "
"``--foo``，还是一个位置参数，如由文件名组成的列表。 因此首先传递给 :meth:`~ArgumentParser.add_argument` "
"的参数必须是一组旗标，或一个简单的参数名称。"

#: ../../library/argparse.rst:624
msgid "For example, an optional argument could be created like::"
msgstr "例如，可以这样创建可选参数::"

#: ../../library/argparse.rst:626
msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ">>> parser.add_argument('-f', '--foo')"

#: ../../library/argparse.rst:628
msgid "while a positional argument could be created like::"
msgstr "而位置参数可以这么创建::"

#: ../../library/argparse.rst:630
msgid ">>> parser.add_argument('bar')"
msgstr ">>> parser.add_argument('bar')"

#: ../../library/argparse.rst:632
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"当 :meth:`~ArgumentParser.parse_args` 被调用，选项会以 ``-`` 前缀识别，剩下的参数则会被假定为位置参数::"

#: ../../library/argparse.rst:636
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"

#: ../../library/argparse.rst:651
msgid "action"
msgstr "action"

#: ../../library/argparse.rst:653
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
":class:`ArgumentParser` 对象将命令行参数与动作相关联。这些动作可以做与它们相关联的命令行参数的任何事，尽管大多数动作只是简单的向"
" :meth:`~ArgumentParser.parse_args` 返回的对象上添加属性。``action`` "
"命名参数指定了这个命令行参数应当如何处理。供应的动作有："

#: ../../library/argparse.rst:659
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action."
msgstr "``'store'`` - 这用于存储参数的值。 这是默认的动作。"

#: ../../library/argparse.rst:662
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` - 存储由 const_ 关键字参数指定的值；请注意 const_ 关键字参数默认为 ``None``。 "
"``'store_const'`` 动作最常被用于指定某类旗标的可选参数。 例如::"

#: ../../library/argparse.rst:667
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:672
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively::"
msgstr ""
"``'store_true'`` 和 ``'store_false'`` - 这些是 ``'store_const'`` 的特例，分别用于存储 "
"``True`` 和 ``False`` 值。 此外，它们还会分别创建默认的 ``False`` 和 ``True`` 值::"

#: ../../library/argparse.rst:677
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"

#: ../../library/argparse.rst:684
msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list. It is useful to allow an option to be specified multiple times. If the"
" default value is non-empty, the default elements will be present in the "
"parsed value for the option, with any values from the command line appended "
"after those default values. Example usage::"
msgstr ""
"``'append'`` - 存储一个列表，并将每个参数值添加到该列表。 它适用于允许可多次指定的选项。 "
"如果默认值非空，则默认的元素将出现在该选项的已解析值中，并将所有来自命令行的值添加在默认值之后。 示例用法::"

#: ../../library/argparse.rst:690
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"

#: ../../library/argparse.rst:695
msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list; note that the const_ keyword "
"argument defaults to ``None``. The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For"
" example::"
msgstr ""
"``'append_const'`` - 存储一个列表，并将由 const_ 关键字参数指定的值添加到列表中；请注意 const_ 关键字参数默认为 "
"``None``。 ``'append_const'`` 动作通常适用于多个参数需要将常量存储到同一列表的场合。 例如::"

#: ../../library/argparse.rst:701
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"

#: ../../library/argparse.rst:707
msgid ""
"``'extend'`` - This stores a list and appends each item from the multi-value"
" argument list to it. The ``'extend'`` action is typically used with the "
"nargs_ keyword argument value ``'+'`` or ``'*'``. Note that when nargs_ is "
"``None`` (the default) or ``'?'``, each character of the argument string "
"will be appended to the list. Example usage::"
msgstr ""
"``'extend'`` - 这将存储一个列表并添加来自于多值参数列表的每个条目。 ``'extend'`` 动作通常配合 nargs_ 关键字参数值 "
"``'+'`` 或 ``'*'`` 使用。 请注意当 nargs_ 为 ``None`` (默认值) 或 ``'?'`` "
"时，将把参数字符串中的每个字符添加到列表。 示例用法::"

#: ../../library/argparse.rst:715
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", \"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", \"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"

#: ../../library/argparse.rst:722
msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For"
" example, this is useful for increasing verbosity levels::"
msgstr "``'count'`` - 计算一个关键字参数出现的数目或次数。例如，对于一个增长的详情等级来说有用::"

#: ../../library/argparse.rst:725
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"

#: ../../library/argparse.rst:730
msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr "请注意，*default* 将为 ``None``，除非显式地设为 *0*。"

#: ../../library/argparse.rst:732
msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - 打印所有当前解析器中的选项和参数的完整帮助信息，然后退出。默认情况下，一个 help "
"动作会被自动加入解析器。关于输出是如何创建的，参与 :class:`ArgumentParser`。"

#: ../../library/argparse.rst:737
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the "
":meth:`~ArgumentParser.add_argument` call, and prints version information "
"and exits when invoked::"
msgstr ""
"``'version'`` - 期望有一个 ``version=`` 命名参数在 "
":meth:`~ArgumentParser.add_argument` 调用中，并打印版本信息并在调用后退出::"

#: ../../library/argparse.rst:741
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"

#: ../../library/argparse.rst:747
msgid ""
"Only actions that consume command-line arguments (e.g. ``'store'``, "
"``'append'`` or ``'extend'``) can be used with positional arguments."
msgstr ""
"只有消耗命令行参数的动作 (例如 ``'store'``, ``'append'`` 或 ``'extend'``) 可以配合位置参数使用。"

#: ../../library/argparse.rst:752
msgid ""
"You may also specify an arbitrary action by passing an :class:`Action` "
"subclass or other object that implements the same interface. The "
":class:`!BooleanOptionalAction` is available in :mod:`!argparse` and adds "
"support for boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"你还可以通过传递一个 :class:`Action` 子类或实现了相同接口的其他对象来指定任意动作。 "
":class:`!BooleanOptionalAction` 在 :mod:`!argparse` 中可用并会添加对布尔类型动作如 ``--foo``"
" 和 ``--no-foo`` 的支持::"

#: ../../library/argparse.rst:757
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"

#: ../../library/argparse.rst:765
msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the :meth:`!__call__` method and optionally the :meth:`!__init__`"
" and :meth:`!format_usage` methods. You can also register custom actions "
"using the :meth:`~ArgumentParser.register` method and reference them by "
"their registered name."
msgstr ""
"创建自定义动作的推荐方式是扩展 :class:`Action`，重写 :meth:`!__call__` 方法以及可选的 "
":meth:`!__init__` 和 :meth:`!format_usage` 方法。 你还可以使用 "
":meth:`~ArgumentParser.register` 方法注册自定义动作并通过其注册名称来引用它们。"

#: ../../library/argparse.rst:770
msgid "An example of a custom action::"
msgstr "一个自定义动作的例子::"

#: ../../library/argparse.rst:772
msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"

#: ../../library/argparse.rst:790
msgid "For more details, see :class:`Action`."
msgstr "更多描述，见 :class:`Action`。"

#: ../../library/argparse.rst:796
msgid "nargs"
msgstr "nargs"

#: ../../library/argparse.rst:798
msgid ""
":class:`ArgumentParser` objects usually associate a single command-line "
"argument with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action. See also :ref:`specifying-ambiguous-arguments`. The supported values"
" are:"
msgstr ""
":class:`ArgumentParser` 对象通常会将一个单独的命令行参数关联到一个单独的要执行的动作。 ``nargs`` "
"关键字参数会将不同数量的命令行参数关联到一个单独的动作。 另请参阅 :ref:`specifying-ambiguous-arguments`。 "
"受支持的值有："

#: ../../library/argparse.rst:803
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr "``N`` （一个整数）。命令行中的 ``N`` 个参数会被聚集到一个列表中。 例如::"

#: ../../library/argparse.rst:806
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"

#: ../../library/argparse.rst:812
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr "注意 ``nargs=1`` 会产生一个单元素列表。这和默认的元素本身是不同的。"

#: ../../library/argparse.rst:817
msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``。 如果可能的话，会从命令行中消耗一个参数，并产生一个单独项。 如果当前没有命令行参数，将会产生 default_ 值。 "
"注意对于可选参数来说，还有一个额外情况 —— 出现了选项字符串但没有跟随命令行参数，在此情况下将会产生 const_ 值。 "
"一些说明这种情况的例子如下::"

#: ../../library/argparse.rst:824
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"

#: ../../library/argparse.rst:834
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr "``nargs='?'`` 的一个更普遍用法是允许可选的输入或输出文件::"

#: ../../library/argparse.rst:837
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),\n"
"...                     default=sys.stdin)\n"
">>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),\n"
"...                     default=sys.stdout)\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),\n"
"...                     default=sys.stdin)\n"
">>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),\n"
"...                     default=sys.stdout)\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)"

#: ../../library/argparse.rst:851
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note"
" that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``。所有当前命令行参数被聚集到一个列表中。注意通过 ``nargs='*'`` "
"来实现多个位置参数通常没有意义，但是多个选项是可能的。例如::"

#: ../../library/argparse.rst:856
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"

#: ../../library/argparse.rst:865
msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered into "
"a list.  Additionally, an error message will be generated if there wasn't at"
" least one command-line argument present.  For example::"
msgstr ""
"``'+'``。和 ``'*'`` 类似，所有当前命令行参数被聚集到一个列表中。另外，当前没有至少一个命令行参数时会产生一个错误信息。例如::"

#: ../../library/argparse.rst:869
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"

#: ../../library/argparse.rst:877
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced. Actions that do not consume command-line arguments (e.g. "
"``'store_const'``) set ``nargs=0``."
msgstr ""
"如果未提供 ``nargs`` 关键字参数，则消耗参数的数量将由 action_ 来确定。 通常这意味着消耗一个命令行参数并产生一个条目（而非列表）。 "
"不消耗命令行参数的动作 (例如 ``'store_const'``) 则要设置 ``nargs=0``。"

#: ../../library/argparse.rst:887
msgid "const"
msgstr "const"

#: ../../library/argparse.rst:889
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
":meth:`~ArgumentParser.add_argument`  的 ``const`` 参数用于保存不从命令行中读取但被各种 "
":class:`ArgumentParser` 动作需求的常数值。最常用的两例为："

#: ../../library/argparse.rst:893
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by "
":meth:`~ArgumentParser.parse_args`. See the action_ description for "
"examples. If ``const`` is not provided to "
":meth:`~ArgumentParser.add_argument`, it will receive a default value of "
"``None``."
msgstr ""
"当 :meth:`~ArgumentParser.add_argument` 附带 ``action='store_const'`` 或 "
"``action='append_const'`` 被调用时。 这些动作会把 ``const`` 值添加到 "
":meth:`~ArgumentParser.parse_args` 所返回的对象的属性中。 请查看 action_ 的示例描述。 如果未将 "
"``const`` 提供给 :meth:`~ArgumentParser.add_argument`，它将接收一个 ``None`` 的默认值。"

#: ../../library/argparse.rst:901
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"to be ``None`` instead.  See the nargs_ description for examples."
msgstr ""
"当 :meth:`~ArgumentParser.add_argument` 附带选项字符串 (如 ``-f`` 或 ``--foo``) 和 "
"``nargs='?'`` 被调用的时候。 这会创建一个可以跟随零到一个命令行参数的选项参数。 "
"当解析该命令行时，如果选项字符串没有跟随任何命令行参数，``const`` 的值将被假定为以 ``None`` 代替。 请参阅 nargs_ "
"描述中的示例。"

#: ../../library/argparse.rst:908
msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""
"在默认情况下 ``const=None``，包括 ``action='append_const'`` 或 "
"``action='store_const'`` 的时候。"

#: ../../library/argparse.rst:915
msgid "default"
msgstr "默认值"

#: ../../library/argparse.rst:917
msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of "
":meth:`~ArgumentParser.add_argument`, whose value defaults to ``None``, "
"specifies what value should be used if the command-line argument is not "
"present. For optional arguments, the ``default`` value is used when the "
"option string was not present at the command line::"
msgstr ""
"所有选项和一些位置参数可能在命令行中被忽略。:meth:`~ArgumentParser.add_argument` 的命名参数 "
"``default``，默认值为 ``None``，指定了在命令行参数未出现时应当使用的值。对于选项， ``default`` "
"值在选项未在命令行中出现时使用::"

#: ../../library/argparse.rst:924
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:931
msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not overwrite it::"
msgstr "如果目标命名空间已经有一个属性集，则 *default* 动作不会覆盖它::"

#: ../../library/argparse.rst:934
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"

#: ../../library/argparse.rst:939
msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the "
":class:`Namespace` return value.  Otherwise, the parser uses the value as "
"is::"
msgstr ""
"如果 ``default`` 值是一个字符串，解析器解析此值就像一个命令行参数。特别是，在将属性设置在 :class:`Namespace` "
"的返回值之前，解析器应用任何提供的 type_ 转换参数。否则解析器使用原值::"

#: ../../library/argparse.rst:944
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"

#: ../../library/argparse.rst:950
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr "对于 nargs_ 等于 ``?`` 或 ``*`` 的位置参数， ``default`` 值在没有命令行参数出现时使用。"

#: ../../library/argparse.rst:953
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:960
msgid ""
"For required_ arguments, the ``default`` value is ignored. For example, this"
" applies to positional arguments with nargs_ values other than ``?`` or "
"``*``, or optional arguments marked as ``required=True``."
msgstr ""
"对于 required_ 参数， ``default`` 值将被忽略。 例如，这将适用于带有 ``?`` 和 ``*`` 以外的 nargs_ "
"值的位置参数，或者被标记为 ``required=True`` 的可选参数。"

#: ../../library/argparse.rst:964
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr "提供 ``default=argparse.SUPPRESS`` 导致命令行参数未出现时没有属性被添加::"

#: ../../library/argparse.rst:967
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"

#: ../../library/argparse.rst:978
msgid "type"
msgstr "type -- 类型"

#: ../../library/argparse.rst:980
msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"默认情况下，解析器会将命令行参数当作简单字符串读入。 然而，命令行字符串经常应当被解读为其他类型，例如 :class:`float` 或 "
":class:`int`。 :meth:`~ArgumentParser.add_argument` 的 ``type`` "
"关键字允许执行任何必要的类型检查和类型转换。"

#: ../../library/argparse.rst:986
msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr "如果 type_ 关键字使用了 default_ 关键字，则类型转换器仅会在默认值为字符串时被应用。"

#: ../../library/argparse.rst:989
msgid ""
"The argument to ``type`` can be a callable that accepts a single string or "
"the name of a registered type (see :meth:`~ArgumentParser.register`) If the "
"function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or "
":exc:`ValueError`, the exception is caught and a nicely formatted error "
"message is displayed. Other exception types are not handled."
msgstr ""
"传给 ``type`` 的参数可以是接受一个字符串或一个已注册类型名称 (参见 :meth:`~ArgumentParser.register`) "
"的可调用对象。 如果该函数引发了 :exc:`ArgumentTypeError`, :exc:`TypeError` 或 "
":exc:`ValueError`，异常将被捕获并显示经良好格式化的错误消息。 其他异常类型则不会被处理。"

#: ../../library/argparse.rst:995
msgid "Common built-in types and functions can be used as type converters:"
msgstr "普通内置类型和函数可被用作类型转换器:"

#: ../../library/argparse.rst:997
msgid ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('dest_file', type=argparse.FileType('w', encoding='latin-1'))\n"
"parser.add_argument('datapath', type=pathlib.Path)"
msgstr ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('dest_file', type=argparse.FileType('w', encoding='latin-1'))\n"
"parser.add_argument('datapath', type=pathlib.Path)"

#: ../../library/argparse.rst:1010
msgid "User defined functions can be used as well:"
msgstr "用户自定义的函数也可以被使用:"

#: ../../library/argparse.rst:1012
msgid ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"
msgstr ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"

#: ../../library/argparse.rst:1022
msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"不建议将 :func:`bool` 函数用作类型转换器。 它所做的只是将空字符串转为 ``False`` 而将非空字符串转为 ``True``。 "
"这通常不是用户所想要的。"

#: ../../library/argparse.rst:1026
msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"通常，``type`` 关键字是仅应被用于只会引发上述三种被支持的异常的简单转换的便捷选项。 "
"任何具有更复杂错误处理或资源管理的转换都应当在参数被解析后由下游代码来完成。"

#: ../../library/argparse.rst:1031
msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A "
":exc:`~json.JSONDecodeError` would not be well formatted and a "
":exc:`FileNotFoundError` exception would not be handled at all."
msgstr ""
"例如，JSON 或 YAML 转换具有复杂的错误情况，需要能给出比 ``type`` 关键字所能给出的更好的报告。 "
":exc:`~json.JSONDecodeError` 将不会被良好地格式化而 :exc:`FileNotFoundError` "
"异常则完全不会被处理。"

#: ../../library/argparse.rst:1036
msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses :class:`~argparse.FileType` and then"
" a subsequent argument fails, an error is reported but the file is not "
"automatically closed.  In this case, it would be better to wait until after "
"the parser has run and then use the :keyword:`with`-statement to manage the "
"files."
msgstr ""
"甚至 :class:`~argparse.FileType` 在用于 ``type`` 关键字时也是有限制的。 如果一个参数使用了 "
":class:`~argparse.FileType` 并且有一个后续参数出错，则将报告错误但文件并不会被自动关闭。 "
"在此情况下，更好的做法是等待直到解析器运行完毕再使用 :keyword:`with` 语句来管理文件。"

#: ../../library/argparse.rst:1043
msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr "对于简单地检查一组固定值的类型检查器，请考虑改用 choices_ 关键字。"

#: ../../library/argparse.rst:1050
msgid "choices"
msgstr "choices"

#: ../../library/argparse.rst:1052
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a sequence object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"某些命令行参数应当从一组受限的值中选择。 这可以通过将一个序列对象作为 *choices* 关键字参数传给 "
":meth:`~ArgumentParser.add_argument` 来处理。 "
"当执行命令行解析时，参数值将被检查，如果参数不是可接受的值之一就将显示错误消息::"

#: ../../library/argparse.rst:1058
msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"

#: ../../library/argparse.rst:1067
msgid ""
"Note that inclusion in the *choices* sequence is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices*"
" sequence should match the type_ specified."
msgstr ""
"注意包括在 *choices* 序列中的内容会在执行任意 type_ 转换之后被检查，因此 *choices* 序列中对象的类型应当与指定的 type_"
" 相匹配。"

#: ../../library/argparse.rst:1071
msgid ""
"Any sequence can be passed as the *choices* value, so :class:`list` objects,"
" :class:`tuple` objects, and custom sequences are all supported."
msgstr ""
"任何序列都可作为 *choices* 值传入，因此 :class:`list` 对象、:class:`tuple` 对象以及自定义序列都是受支持的。"

#: ../../library/argparse.rst:1074
msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr "不建议使用 :class:`enum.Enum`，因为要控制其在用法、帮助和错误消息中的外观是很困难的。"

#: ../../library/argparse.rst:1077
msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""
"已格式化的选项会覆盖默认的 *metavar*，该值一般是派生自 *dest*。 这通常就是你所需要的，因为用户永远不会看到 *dest* 形参。 "
"如果不想要这样的显示（或许因为有很多选择），只需指定一个显式的 metavar_。"

#: ../../library/argparse.rst:1086
msgid "required"
msgstr "required"

#: ../../library/argparse.rst:1088
msgid ""
"In general, the :mod:`!argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"通常，:mod:`!argparse` 模块会假定像 ``-f`` 和 ``--bar`` 这样的旗标是表示 *可选* "
"参数，它们总是可以在命令行中被省略。 要让一个选项成为 *必需*，则可以将 ``True`` 作为 ``required=`` 关键字参数传给 "
":meth:`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1093
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"

#: ../../library/argparse.rst:1101
msgid ""
"As the example shows, if an option is marked as ``required``, "
":meth:`~ArgumentParser.parse_args` will report an error if that option is "
"not present at the command line."
msgstr ""
"如这个例子所示，如果一个选项被标记为 "
"``required``，则当该选项未在命令行中出现时，:meth:`~ArgumentParser.parse_args` 将会报告一个错误。"

#: ../../library/argparse.rst:1107
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr "必需的选项通常被认为是不适宜的，因为用户会预期 *options* 都是 *可选的*，因此在可能的情况下应当避免使用它们。"

#: ../../library/argparse.rst:1114
msgid "help"
msgstr "help"

#: ../../library/argparse.rst:1116
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument."
msgstr ""
"``help`` 值是一个包含参数的简短描述的字符串。 当用户请求帮助时（一般是通过在命令行中使用 ``-h`` 或 ``--help`` "
"的方式），这些 ``help`` 描述信息将随每个参数一同显示。"

#: ../../library/argparse.rst:1121
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword"
" arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"``help`` 字符串可包括各种格式描述符以避免重复使用程序名称或参数 default_ 等文本。 有效的描述符包括程序名称 ``%(prog)s``"
" 和传给 :meth:`~ArgumentParser.add_argument` 的大部分关键字参数，例如 ``%(default)s``, "
"``%(type)s`` 等等::"

#: ../../library/argparse.rst:1126
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"

#: ../../library/argparse.rst:1138
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr "由于帮助字符串支持 %-formatting，如果你希望在帮助字符串中显示 ``%`` 字面值，你必须将其转义为 ``%%``。"

#: ../../library/argparse.rst:1141
msgid ""
":mod:`!argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`!argparse` 支持静默特定选面的帮助条目，具体方式是将 ``help`` 值设为 ``argparse.SUPPRESS``::"

#: ../../library/argparse.rst:1144
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"

#: ../../library/argparse.rst:1156
msgid "metavar"
msgstr "metavar"

#: ../../library/argparse.rst:1158
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, :class:`!ArgumentParser` "
"objects use the dest_ value as the \"name\" of each object.  By default, for"
" positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A "
"single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""
"当 :class:`ArgumentParser` 生成帮助消息时，它需要用某种方式来引用每个预期的参数。 "
"默认情况下，:class:`!ArgumentParser` 对象使用 dest_ 值作为每个对象的“名字”。 默认情况下，对于位置参数动作，dest_"
" 值将被直接使用，而对于可选参数动作，dest_ 值将被转为大写形式。 因此，对于 ``dest='bar'`` 位置参数的引用形式将为 "
"``bar``。 带有单个命令行参数的可选参数 ``--foo`` 的引用形式将为 ``FOO``。 一个样例::"

#: ../../library/argparse.rst:1167
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"

#: ../../library/argparse.rst:1182
msgid "An alternative name can be specified with ``metavar``::"
msgstr "可以使用 ``metavar`` 来指定一个替代名称::"

#: ../../library/argparse.rst:1184
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"

#: ../../library/argparse.rst:1199
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"请注意 ``metavar`` 仅改变 *显示的* 名称 -  :meth:`~ArgumentParser.parse_args` "
"对象的属性名称仍然会由 dest_ 值确定。"

#: ../../library/argparse.rst:1203
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"不同的 ``nargs`` 值可能导致 metavar 被多次使用。 提供一个元组给 ``metavar`` 即为每个参数指定不同的显示信息::"

#: ../../library/argparse.rst:1207
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"

#: ../../library/argparse.rst:1222
msgid "dest"
msgstr "dest"

#: ../../library/argparse.rst:1224
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of "
":meth:`~ArgumentParser.add_argument`.  For positional argument actions, "
"``dest`` is normally supplied as the first argument to "
":meth:`~ArgumentParser.add_argument`::"
msgstr ""
"大多数 :class:`ArgumentParser` 动作会添加一些值作为 :meth:`~ArgumentParser.parse_args` "
"所返回对象的一个属性。 该属性的名称由 :meth:`~ArgumentParser.add_argument` 的 ``dest`` 关键字参数确定。"
" 对于位置参数动作，``dest`` 通常会作为 :meth:`~ArgumentParser.add_argument` 的第一个参数提供::"

#: ../../library/argparse.rst:1231
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1236
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"对于可选参数动作，``dest`` 的值通常取自选项字符串。 :class:`ArgumentParser` 会通过接受第一个长选项字符串并去掉开头的 "
"``--`` 字符串来生成 ``dest`` 的值。 如果没有提供长选项字符串，则 ``dest`` 将通过接受第一个短选项字符串并去掉开头的 "
"``-`` 字符来获得。 任何内部的 ``-`` 字符都将被转换为 ``_`` 字符以确保字符串是有效的属性名称。 下面的例子显示了这种行为::"

#: ../../library/argparse.rst:1245
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"

#: ../../library/argparse.rst:1253
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` 允许提供自定义属性名称::"

#: ../../library/argparse.rst:1255
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1264
msgid "deprecated"
msgstr "deprecated"

#: ../../library/argparse.rst:1266
msgid ""
"During a project's lifetime, some arguments may need to be removed from the "
"command line. Before removing them, you should inform your users that the "
"arguments are deprecated and will be removed. The ``deprecated`` keyword "
"argument of :meth:`~ArgumentParser.add_argument`, which defaults to "
"``False``, specifies if the argument is deprecated and will be removed in "
"the future. For arguments, if ``deprecated`` is ``True``, then a warning "
"will be printed to :data:`sys.stderr` when the argument is used::"
msgstr ""
"在一个项目的生命期内，某些命令行参数可能需要被移除。 在移除它们之前，你应当通知你的用户这些参数已被弃用并将被移除。 "
":meth:`~ArgumentParser.add_argument` 的 ``deprecated`` "
"关键字参数指明参数已被弃用并将在未来被移除，其默认值为 ``False``。 对于每个参数，如果 ``deprecated`` 为 "
"``True``，那么当该参数被使用时会打印一条警告到 :data:`sys.stderr`::"

#: ../../library/argparse.rst:1276
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='snake.py')\n"
">>> parser.add_argument('--legs', default=0, type=int, deprecated=True)\n"
">>> parser.parse_args([])\n"
"Namespace(legs=0)\n"
">>> parser.parse_args(['--legs', '4'])\n"
"snake.py: warning: option '--legs' is deprecated\n"
"Namespace(legs=4)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='snake.py')\n"
">>> parser.add_argument('--legs', default=0, type=int, deprecated=True)\n"
">>> parser.parse_args([])\n"
"Namespace(legs=0)\n"
">>> parser.parse_args(['--legs', '4'])\n"
"snake.py: warning: option '--legs' is deprecated\n"
"Namespace(legs=4)"

#: ../../library/argparse.rst:1289
msgid "Action classes"
msgstr "Action 类"

#: ../../library/argparse.rst:1291
msgid ""
":class:`!Action` classes implement the Action API, a callable which returns "
"a callable which processes arguments from the command-line. Any object which"
" follows this API may be passed as the ``action`` parameter to "
":meth:`~ArgumentParser.add_argument`."
msgstr ""
":class:`!Action` 类实现了 Action API，是一个返回可调用对象的可调用对象，它返回的可调用对象将处理来自命令行的参数。 "
"任何遵循此 API 的对象均可作为 ``action`` 形参传给 :meth:`~ArgumentParser.add_argument`。"

#: ../../library/argparse.rst:1300
msgid ""
":class:`!Action` objects are used by an :class:`ArgumentParser` to represent"
" the information needed to parse a single argument from one or more strings "
"from the command line. The :class:`!Action` class must accept the two "
"positional arguments plus any keyword arguments passed to "
":meth:`ArgumentParser.add_argument` except for the ``action`` itself."
msgstr ""
":class:`!Action` 对象会被 :class:`ArgumentParser` "
"用来代表从命令行中的一个或多个字符串中解析出单个参数所必须的信息。 :class:`!Action` 类必须接受两个位置参数加上传给 "
":meth:`ArgumentParser.add_argument` 的除了 ``action`` 本身的任何关键字参数。"

#: ../../library/argparse.rst:1306
msgid ""
"Instances of :class:`!Action` (or return value of any callable to the "
"``action`` parameter) should have attributes :attr:`!dest`, "
":attr:`!option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`,"
" :attr:`!help`, etc. defined. The easiest way to ensure these attributes are"
" defined is to call :meth:`!Action.__init__`."
msgstr ""
":class:`!Action` 的实例（或作为 ``action`` 形参的任何可调用对象的返回值）应当定义 :attr:`!dest`, "
":attr:`!option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`,"
" :attr:`!help` 等属性。 确定这些属性的最容易的方式是调用 :meth:`!Action.__init__`。"

#: ../../library/argparse.rst:1314
msgid ""
":class:`!Action` instances should be callable, so subclasses must override "
"the :meth:`!__call__` method, which should accept four parameters:"
msgstr ""
":class:`!Action` 的实例应当为可调用对象，因此所有子类都必须重写 :meth:`!__call__` 方法，它应当接受四个形参："

#: ../../library/argparse.rst:1317
msgid ""
"*parser* - The :class:`ArgumentParser` object which contains this action."
msgstr "*parser* - 包含此动作的 :class:`ArgumentParser` 对象。"

#: ../../library/argparse.rst:1319
msgid ""
"*namespace* - The :class:`Namespace` object that will be returned by "
":meth:`~ArgumentParser.parse_args`.  Most actions add an attribute to this "
"object using :func:`setattr`."
msgstr ""
"*namespace* - 将由 :meth:`~ArgumentParser.parse_args` 返回的 :class:`Namespace` "
"对象。 大多数动作会使用 :func:`setattr` 为此对象添加一个属性。"

#: ../../library/argparse.rst:1323
msgid ""
"*values* - The associated command-line arguments, with any type conversions "
"applied.  Type conversions are specified with the type_ keyword argument to "
":meth:`~ArgumentParser.add_argument`."
msgstr ""
"*values* - 关联的命令行参数，并提供要应用的类型转换。 类型转换是由传给 "
":meth:`~ArgumentParser.add_argument` 的 type_ 关键字参数指定的。"

#: ../../library/argparse.rst:1327
msgid ""
"*option_string* - The option string that was used to invoke this action. The"
" ``option_string`` argument is optional, and will be absent if the action is"
" associated with a positional argument."
msgstr ""
"*option_string* - 被用于唤起此动作的选项字符串。 ``option_string`` "
"参数是可选的，并且在动作被关联到位置参数时将被略去。"

#: ../../library/argparse.rst:1331
msgid ""
"The :meth:`!__call__` method may perform arbitrary actions, but will "
"typically set attributes on the ``namespace`` based on ``dest`` and "
"``values``."
msgstr ""
":meth:`!__call__` 方法可以执行任意动作，但通常将基于 ``dest`` 和 ``values`` 来设置 ``namespace`` "
"的属性。"

#: ../../library/argparse.rst:1336
msgid ""
":class:`!Action` subclasses can define a :meth:`!format_usage` method that "
"takes no argument and return a string which will be used when printing the "
"usage of the program. If such method is not provided, a sensible default "
"will be used."
msgstr ""
":class:`!Action` 子类可以定义 :meth:`!format_usage` "
"方法，该方法不接受任何参数并返回一个将被用于打印程序的用法说明的字符串。 如果未提供此方法，则将使用适当的默认值。"

#: ../../library/argparse.rst:1342
msgid "The parse_args() method"
msgstr "parse_args() 方法"

#: ../../library/argparse.rst:1346
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr "将参数字符串转换为对象并将其设为命名空间的属性。 返回带有成员的命名空间。"

#: ../../library/argparse.rst:1349
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for "
":meth:`!add_argument` for details."
msgstr ""
"之前对 :meth:`add_argument` 的调用决定了哪些对象会被创建以及它们如何被赋值。 请参阅 :meth:`!add_argument` "
"的文档了解详情。"

#: ../../library/argparse.rst:1353
msgid ""
"args_ - List of strings to parse.  The default is taken from "
":data:`sys.argv`."
msgstr "args_ - 要解析的字符串列表。 默认值是从 :data:`sys.argv` 获取。"

#: ../../library/argparse.rst:1356
msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty "
":class:`Namespace` object."
msgstr "namespace_ - 用于获取属性的对象。 默认值是一个新的空 :class:`Namespace` 对象。"

#: ../../library/argparse.rst:1361
msgid "Option value syntax"
msgstr "选项值语法"

#: ../../library/argparse.rst:1363
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 方法支持多种指定选项值的方式（如果它接受选项的话）。 "
"在最简单的情况下，选项和它的值是作为两个单独参数传入的::"

#: ../../library/argparse.rst:1367
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1375
msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using"
" ``=`` to separate them::"
msgstr "对于长选项（名称长度超过一个字符的选项），选项和值也可以作为单个命令行参数传入，使用 ``=`` 分隔它们即可::"

#: ../../library/argparse.rst:1379
msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1382
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr "对于短选项（长度只有一个字符的选项），选项和它的值可以拼接在一起::"

#: ../../library/argparse.rst:1385
msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"

#: ../../library/argparse.rst:1388
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr "有些短选项可以使用单个 ``-`` 前缀来进行合并，如果仅有最后一个选项（或没有任何选项）需要值的话::"

#: ../../library/argparse.rst:1391
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"

#: ../../library/argparse.rst:1400
msgid "Invalid arguments"
msgstr "无效的参数"

#: ../../library/argparse.rst:1402
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid"
" options, wrong number of positional arguments, etc.  When it encounters "
"such an error, it exits and prints the error along with a usage message::"
msgstr ""
"在解析命令行时，:meth:`~ArgumentParser.parse_args` "
"会检测多种错误，包括有歧义的选项、无效的类型、无效的选项、错误的位置参数个数等等。 当遇到这种错误时，它将退出并打印出错误文本同时附带用法消息::"

#: ../../library/argparse.rst:1407
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"

#: ../../library/argparse.rst:1428
msgid "Arguments containing ``-``"
msgstr "包含 ``-`` 的参数"

#: ../../library/argparse.rst:1430
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 方法会在用户明显出错时尝试给出错误信息，但某些情况本身就存在歧义。 "
"例如，命令行参数 ``-1`` 可能是尝试指定一个选项也可能是尝试提供一个位置参数。 "
":meth:`~ArgumentParser.parse_args` "
"方法在此会谨慎行事：位置参数只有在它们看起来像负数并且解析器中没有任何选项看起来像负数时才能以 ``-`` 打头。::"

#: ../../library/argparse.rst:1438
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # 没有负数选项，因此 -1 是位置参数\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # 没有负数选项，因此 -1 和 -5 是位置参数\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # 有负数选项，因此 -1 是选项\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # 有负数选项，因此 -2 是选项\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # 有负数选项，因此两个 -1 都是选项\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"

#: ../../library/argparse.rst:1468
msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"如果你有必须以 ``-`` 打头的位置参数并且看起来不像负数，你可以插入伪参数 ``'--'`` 以告诉 "
":meth:`~ArgumentParser.parse_args` 在那之后的内容是一个位置参数::"

#: ../../library/argparse.rst:1473
msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"

#: ../../library/argparse.rst:1476
msgid ""
"See also :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` for more details."
msgstr ""
"另请参阅 :ref:`针对有歧义参数的 argparse 指引 <specifying-ambiguous-arguments>` 来了解更多细节。"

#: ../../library/argparse.rst:1482
msgid "Argument abbreviations (prefix matching)"
msgstr "参数缩写（前缀匹配）"

#: ../../library/argparse.rst:1484
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 方法 :ref:`在默认情况下 <allow_abbrev>` "
"允许将长选项缩写为前缀，如果缩写无歧义（即前缀与一个特定选项相匹配）的话::"

#: ../../library/argparse.rst:1488
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"

#: ../../library/argparse.rst:1499
msgid ""
"An error is produced for arguments that could produce more than one options."
" This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr "可产生一个以上选项的参数会引发错误。 此特定可通过将 :ref:`allow_abbrev` 设为 ``False`` 来禁用。"

#: ../../library/argparse.rst:1505
msgid "Beyond ``sys.argv``"
msgstr "在 ``sys.argv`` 以外"

#: ../../library/argparse.rst:1507
msgid ""
"Sometimes it may be useful to have an :class:`ArgumentParser` parse "
"arguments other than those of :data:`sys.argv`.  This can be accomplished by"
" passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is "
"useful for testing at the interactive prompt::"
msgstr ""
"有时在 :data:`sys.argv` 以外增加 :class:`ArgumentParser` 解析参数也很有用处。 这可以通过将一个字符串列表传给"
" :meth:`~ArgumentParser.parse_args` 来实现。 它适用于在交互提示符下进行测试::"

#: ../../library/argparse.rst:1512
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"

#: ../../library/argparse.rst:1527
msgid "The Namespace object"
msgstr "命名空间对象"

#: ../../library/argparse.rst:1531
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create"
" an object holding attributes and return it."
msgstr "由 :meth:`~ArgumentParser.parse_args` 默认使用的简单类，可创建一个存放属性的对象并将其返回。"

#: ../../library/argparse.rst:1534
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"这个类被有意做得很简单，只是一个具有可读字符串表示形式的 :class:`object`。 如果你更喜欢类似字典的属性视图，你可以使用标准 Python"
" 中惯常的 :func:`vars`::"

#: ../../library/argparse.rst:1538
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"

#: ../../library/argparse.rst:1544
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object."
"  This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"另一个用处是让 :class:`ArgumentParser` 为一个已存在对象而不是为一个新的 :class:`Namespace` 对象的属性赋值。"
" 这可以通过指定 ``namespace=`` 关键字参数来实现::"

#: ../../library/argparse.rst:1548
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"

#: ../../library/argparse.rst:1560
msgid "Other utilities"
msgstr "其它实用工具"

#: ../../library/argparse.rst:1563
msgid "Sub-commands"
msgstr "子命令"

#: ../../library/argparse.rst:1570
msgid ""
"Many programs split up their functionality into a number of subcommands, for"
" example, the ``svn`` program can invoke subcommands like ``svn checkout``, "
"``svn update``, and ``svn commit``.  Splitting up functionality this way can"
" be a particularly good idea when a program performs several different "
"functions which require different kinds of command-line arguments. "
":class:`ArgumentParser` supports the creation of such subcommands with the "
":meth:`!add_subparsers` method.  The :meth:`!add_subparsers` method is "
"normally called with no arguments and returns a special action object.  This"
" object has a single method, :meth:`~_SubParsersAction.add_parser`, which "
"takes a command name and any :class:`!ArgumentParser` constructor arguments,"
" and returns an :class:`!ArgumentParser` object that can be modified as "
"usual."
msgstr ""
"许多程序都将其功能拆分为一系列子命令，例如，``svn`` 程序可唤起像 ``svn checkout``, ``svn update`` 和 "
"``svn commit`` 等子命令。 当一个程序执行需要多组不同各类命令行参数时这种拆分功能的方式是一个非常好的主意。 "
":class:`ArgumentParser` 通过 :meth:`!add_subparsers` 方法支持创建这样的子命令。 "
":meth:`!add_subparsers` 方法通常不带参数地调用并返回一个特殊的动作对象。 该对象只有一个方法 "
":meth:`~_SubParsersAction.add_parser`，它接受一个命令名称和任意多个 "
":class:`!ArgumentParser` 构造器参数，并返回一个可以通常方式进行修改的 :class:`!ArgumentParser` 对象。"

#: ../../library/argparse.rst:1582
msgid "Description of parameters:"
msgstr "形参的描述"

#: ../../library/argparse.rst:1584
msgid ""
"*title* - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr "*title* - 帮助输出中子解析器分组的标题；如果提供了描述则默认为 \"subcommands\"，否则使用位置参数的标题"

#: ../../library/argparse.rst:1588
msgid ""
"*description* - description for the sub-parser group in help output, by "
"default ``None``"
msgstr "*description* - 帮助输出中对子解析器组的描述，默认为 ``None``"

#: ../../library/argparse.rst:1591
msgid ""
"*prog* - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr "*prog* - 将与子命令帮助一同显示的用法信息，默认为程序名称和子解析器参数之前的任何位置参数"

#: ../../library/argparse.rst:1595
msgid ""
"*parser_class* - class which will be used to create sub-parser instances, by"
" default the class of the current parser (e.g. :class:`ArgumentParser`)"
msgstr ""
"*parser_class* - 将被用于创建子解析器实例的类，默认为当前解析器类 (例如 :class:`ArgumentParser`)"

#: ../../library/argparse.rst:1598
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr "action_ - 当此参数在命令行中出现时要执行动作的基本类型"

#: ../../library/argparse.rst:1601
msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr "dest_ - 将被用于保存子命令名称的属性名；默认为 ``None`` 即不保存任何值"

#: ../../library/argparse.rst:1604
msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr "required_ - 是否必须要提供子命令，默认为 ``False`` (在 3.7 中新增)"

#: ../../library/argparse.rst:1607
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr "help_ - 在输出帮助中的子解析器分组帮助信息，默认为 ``None``"

#: ../../library/argparse.rst:1609
msgid ""
"metavar_ - string presenting available subcommands in help; by default it is"
" ``None`` and presents subcommands in form {cmd1, cmd2, ..}"
msgstr "metavar_ - 帮助信息中表示可用子命令的字符串；默认为 ``None`` 并以 {cmd1, cmd2, ..} 的形式表示子命令"

#: ../../library/argparse.rst:1612
msgid "Some example usage::"
msgstr "一些使用示例::"

#: ../../library/argparse.rst:1614
msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='subcommand help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""
">>> # 创建一个最高层级解析器\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='subcommand help')\n"
">>>\n"
">>> # 创建一个针对 \"a\" 命令的解析器\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # 创建一个针对 \"b\" 命令的解析器\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz help')\n"
">>>\n"
">>> # 解析一些参数列表\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"

#: ../../library/argparse.rst:1633
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"请注意 :meth:`parse_args` 返回的对象将只包含主解析器和由命令行所选择的子解析器的属性（而没有任何其他子解析器）。 "
"因此在上面的例子中，当指定了 ``a`` 命令时，将只存在 ``foo`` 和 ``bar`` 属性，而当指定了 ``b`` 命令时，则只存在 "
"``foo`` 和 ``baz`` 属性。"

#: ../../library/argparse.rst:1640
msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument"
" to :meth:`~_SubParsersAction.add_parser` as above.)"
msgstr ""
"类似地，当一个子解析器请求帮助消息时，只有该特定解析器的帮助消息会被打印出来。 帮助消息将不包括父解析器或同级解析器的消息。 "
"（每个子解析器命令一条帮助消息，但是，也可以像上面那样通过将 ``help=`` 参数传入 "
":meth:`~_SubParsersAction.add_parser` 来给出。）"

#: ../../library/argparse.rst:1648
msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"

#: ../../library/argparse.rst:1676
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
":meth:`add_subparsers` 方法也支持 ``title`` 和 ``description`` 关键字参数。 "
"当两者都存在时，子解析器的命令将出现在输出帮助消息中它们自己的分组内。 例如::"

#: ../../library/argparse.rst:1680
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"

#: ../../library/argparse.rst:1697
msgid ""
"Furthermore, :meth:`~_SubParsersAction.add_parser` supports an additional "
"*aliases* argument, which allows multiple strings to refer to the same "
"subparser. This example, like ``svn``, aliases ``co`` as a shorthand for "
"``checkout``::"
msgstr ""
"此外，:meth:`~_SubParsersAction.add_parser` 还支持附加的 *aliases* "
"参数，它允许多个字符串指向同一个子解析器。 下面的例子，类似于 ``svn``，将别名 ``co`` 设为 ``checkout`` 的缩写形式::"

#: ../../library/argparse.rst:1702
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"

#: ../../library/argparse.rst:1709
msgid ""
":meth:`~_SubParsersAction.add_parser` supports also an additional "
"*deprecated* argument, which allows to deprecate the subparser."
msgstr ""
":meth:`~_SubParsersAction.add_parser` 也支持附加的 *deprecated* 参数，它允许弃用子解析器。"

#: ../../library/argparse.rst:1723
msgid ""
"One particularly effective way of handling subcommands is to combine the use"
" of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` so "
"that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"一个特别有效的处理子命令的方式是将 :meth:`add_subparsers` 方法与对 :meth:`set_defaults` "
"的调用结合起来使用以便每个子解析器能知道应当执行哪个 Python 函数。 例如::"

#: ../../library/argparse.rst:1728
msgid ""
">>> # subcommand functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""
">>> # 子命令函数\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # 创建最高层级解析器\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # 创建针对 \"foo\" 命令的解析器\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # 创建针对 \"bar\" 命令的解析器\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # 解析参数并调用被选定的任何函数\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # 解析参数并调用被选定的任何函数\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"

#: ../../library/argparse.rst:1760
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"通过这种方式，你可以在参数解析结束后让 :meth:`parse_args` 执行调用适当函数的任务。 "
"像这样将函数关联到动作通常是你处理每个子解析器的不同动作的最简便方式。 但是，如果有必要检查被唤起的子解析器的名称，则 "
":meth:`add_subparsers` 调用的 ``dest`` 关键字参数将可实现::"

#: ../../library/argparse.rst:1767
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"

#: ../../library/argparse.rst:1776
msgid "New *required* keyword-only parameter."
msgstr "新增 *required* 仅限关键字形参。"

#: ../../library/argparse.rst:1781
msgid "FileType objects"
msgstr "FileType 对象"

#: ../../library/argparse.rst:1785
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type"
" argument of :meth:`ArgumentParser.add_argument`.  Arguments that have "
":class:`FileType` objects as their type will open command-line arguments as "
"files with the requested modes, buffer sizes, encodings and error handling "
"(see the :func:`open` function for more details)::"
msgstr ""
":class:`FileType` 工厂类用于创建可作为 :meth:`ArgumentParser.add_argument` 的 type "
"参数传入的对象。 以 :class:`FileType` "
"对象作为其类型的参数将使用命令行参数以所请求模式、缓冲区大小、编码格式和错误处理方式打开文件（请参阅 :func:`open` 函数了解详情）::"

#: ../../library/argparse.rst:1791
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)"

#: ../../library/argparse.rst:1797
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""
"FileType 对象能理解伪参数 ``'-'`` 并会自动将其转换为 :data:`sys.stdin` 用于可读的 "
":class:`FileType` 对象以及 :data:`sys.stdout` 用于可写的 :class:`FileType` 对象::"

#: ../../library/argparse.rst:1801
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"

#: ../../library/argparse.rst:1806
msgid "Added the *encodings* and *errors* parameters."
msgstr "增加了 *encodings* 和 *errors* 形参。"

#: ../../library/argparse.rst:1811
msgid "Argument groups"
msgstr "参数组"

#: ../../library/argparse.rst:1816
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"options\" when displaying help messages. When"
" there is a better conceptual grouping of arguments than this default one, "
"appropriate groups can be created using the :meth:`!add_argument_group` "
"method::"
msgstr ""
"在默认情况下，:class:`ArgumentParser` 会在显示帮助消息时将命令行参数分为“位置参数”和“选项”两组。 "
"当存在比默认更好的分组概念时，可以使用 :meth:`!add_argument_group` 方法来创建适当的分组::"

#: ../../library/argparse.rst:1822
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"

#: ../../library/argparse.rst:1833
msgid ""
"The :meth:`add_argument_group` method returns an argument group object which"
" has an :meth:`~ArgumentParser.add_argument` method just like a regular "
":class:`ArgumentParser`.  When an argument is added to the group, the parser"
" treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`!add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
":meth:`add_argument_group` 方法返回一个具有 :meth:`~ArgumentParser.add_argument` "
"方法的参数分组对象，这与常规的 :class:`ArgumentParser` 一样。 "
"当一个参数被加入分组时，解析器儒将地它视为一个正常的参数，但是会在单独的帮助消息分组中显示该参数。 "
":meth:`!add_argument_group` 方法接受 *title* 和 *description* 参数以使用它们来定制显示内容::"

#: ../../library/argparse.rst:1841
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"

#: ../../library/argparse.rst:1859
msgid ""
"The optional, keyword-only parameters argument_default_ and "
"conflict_handler_ allow for finer-grained control of the behavior of the "
"argument group. These parameters have the same meaning as in the "
":class:`ArgumentParser` constructor, but apply specifically to the argument "
"group rather than the entire parser."
msgstr ""
"可选的仅限关键字形参 argument_default_ 和 conflict_handler_ 允许对参数分组行为进行更细粒度的控制。 这些形参具有与"
" :class:`ArgumentParser` 构造器中相同的含义，但是专门应用于参数分组而不是整个解析器。"

#: ../../library/argparse.rst:1864
msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr "请注意任意不在你的自定义分组中的参数最终都将回到通常的“位置参数”和“可选参数”分组中。"

#: ../../library/argparse.rst:1867
msgid ""
"Calling :meth:`add_argument_group` on an argument group is deprecated. This "
"feature was never supported and does not always work correctly. The function"
" exists on the API by accident through inheritance and will be removed in "
"the future."
msgstr ""
"在参数分组上调用 :meth:`add_argument_group` 已被弃用。 此特性从未受到支持并且不保证总能正确工作。此函数出现在 API "
"中是继承导致的意外并将在未来被移除。"

#: ../../library/argparse.rst:1875
msgid "Mutual exclusion"
msgstr "互斥"

#: ../../library/argparse.rst:1879
msgid ""
"Create a mutually exclusive group. :mod:`!argparse` will make sure that only"
" one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr "创建一个互斥分组。 :mod:`!argparse` 将会确保互斥分组中只有一个参数在命令行中可用::"

#: ../../library/argparse.rst:1883
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"

#: ../../library/argparse.rst:1895
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
":meth:`add_mutually_exclusive_group` 方法也接受一个 *required* "
"参数，表示在互斥组中至少有一个参数是需要的::"

#: ../../library/argparse.rst:1899
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"

#: ../../library/argparse.rst:1907
msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of "
":meth:`~ArgumentParser.add_argument_group`. However, a mutually exclusive "
"group can be added to an argument group that has a title and description. "
"For example::"
msgstr ""
"请注意当前互斥的参数组不支持 :meth:`~ArgumentParser.add_argument_group` 的 *title* 和 "
"*description* 参数。 但是，互斥的参数数可以被添加到具有 title 和 description 的参数组中。 例如::"

#: ../../library/argparse.rst:1913
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"

#: ../../library/argparse.rst:1930
msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group is deprecated. These features were never "
"supported and do not always work correctly. The functions exist on the API "
"by accident through inheritance and will be removed in the future."
msgstr ""
"在互斥的分组上调用 :meth:`add_argument_group` 或 :meth:`add_mutually_exclusive_group` "
"已被弃用。 这些特性从未受到支持并且不保证总能正确工作。 这些函数出现在 API 中是继承导致的意外并将在未来被移除。"

#: ../../library/argparse.rst:1938
msgid "Parser defaults"
msgstr "解析器默认值"

#: ../../library/argparse.rst:1942
msgid ""
"Most of the time, the attributes of the object returned by "
":meth:`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"在大多数时候，:meth:`parse_args` 所返回对象的属性将完全通过检查命令行参数和参数动作来确定。 :meth:`set_defaults`"
" 则允许加入一些无须任何命令行检查的额外属性::"

#: ../../library/argparse.rst:1948
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"

#: ../../library/argparse.rst:1954
msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr "请注意解析器层级的默认值总是会覆盖参数层级的默认值::"

#: ../../library/argparse.rst:1956
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"

#: ../../library/argparse.rst:1962
msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"解析器层级默认值在需要多解析器时会特别有用。 请参阅 :meth:`~ArgumentParser.add_subparsers` "
"方法了解此类型的一个示例。"

#: ../../library/argparse.rst:1968
msgid ""
"Get the default value for a namespace attribute, as set by either "
":meth:`~ArgumentParser.add_argument` or by "
":meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"获取一个命名空间属性的默认值，该值是由 :meth:`~ArgumentParser.add_argument` 或 "
":meth:`~ArgumentParser.set_defaults` 设置的::"

#: ../../library/argparse.rst:1972
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"

#: ../../library/argparse.rst:1979
msgid "Printing help"
msgstr "打印帮助"

#: ../../library/argparse.rst:1981
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"在大多数典型应用中，:meth:`~ArgumentParser.parse_args` 将负责任何用法和错误消息的格式化和打印。 "
"但是，也可使用某些其他格式化方法:"

#: ../../library/argparse.rst:1987
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"打印一段简短描述，说明应当如何在命令行中唤起 :class:`ArgumentParser`。 如果 *file* 为 ``None``，则默认使用 "
":data:`sys.stdout`。"

#: ../../library/argparse.rst:1993
msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"打印一条帮助消息，包括程序用法和通过 :class:`ArgumentParser` 注册的相关参数信息。 如果 *file* 为 "
"``None``，则默认使用 :data:`sys.stdout`。"

#: ../../library/argparse.rst:1997
msgid ""
"There are also variants of these methods that simply return a string instead"
" of printing it:"
msgstr "还存在这些方法的几个变化形式，它们只返回字符串而不打印消息:"

#: ../../library/argparse.rst:2002
msgid ""
"Return a string containing a brief description of how the "
":class:`ArgumentParser` should be invoked on the command line."
msgstr "返回一个包含简短描述的字符串，说明应当如何在命令行中唤起 :class:`ArgumentParser`。"

#: ../../library/argparse.rst:2007
msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr "反回一个包含帮助消息的字符串，包括程序用法和通过 :class:`ArgumentParser` 注册的相关参数信息。"

#: ../../library/argparse.rst:2012
msgid "Partial parsing"
msgstr "部分解析"

#: ../../library/argparse.rst:2016
msgid ""
"Sometimes a script only needs to handle a specific set of command-line "
"arguments, leaving any unrecognized arguments for another script or program."
" In these cases, the :meth:`~ArgumentParser.parse_known_args` method can be "
"useful."
msgstr ""
"有时一个脚本只需要处理特定的命令行参数集合，把不能识别的参数留给其他脚本或程序。 "
"在这种情况下，:meth:`~ArgumentParser.parse_known_args` 方法就会很有用处。"

#: ../../library/argparse.rst:2021
msgid ""
"This method works similarly to :meth:`~ArgumentParser.parse_args`, but it "
"does not raise an error for extra, unrecognized arguments. Instead, it "
"parses the known arguments and returns a two item tuple that contains the "
"populated namespace and the list of any unrecognized arguments."
msgstr ""
"此方法的运作方式与 :meth:`~ArgumentParser.parse_args` 类似，但它不会针对额外的不能识别的参数引发错误。 "
"它会解析已知参数并返回一个包含已填充命名空间和不能识别的参数列表的二元组。"

#: ../../library/argparse.rst:2028
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"

#: ../../library/argparse.rst:2035
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to "
":meth:`~ArgumentParser.parse_known_args`. The parser may consume an option "
"even if it's just a prefix of one of its known options, instead of leaving "
"it in the remaining arguments list."
msgstr ""
":ref:`前缀匹配 <prefix-matching>` 规则应用于 "
":meth:`~ArgumentParser.parse_known_args`。 "
"一个解析器即使在某个选项只是已知选项的前缀时也能读取该选项，而不是将其放入剩余参数列表。"

#: ../../library/argparse.rst:2042
msgid "Customizing file parsing"
msgstr "自定义文件解析"

#: ../../library/argparse.rst:2046
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword"
" argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"从文件读取的参数（见 :class:`ArgumentParser` 的 *fromfile_prefix_chars* "
"关键字参数）将是一行读取一个参数。 :meth:`convert_arg_line_to_args` 可被重写以使用更复杂的读取方式。"

#: ../../library/argparse.rst:2051
msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"此方法接受从参数文件读取的字符串形式的单个参数 *arg_line*。 它返回从该字符串解析出的参数列表。 "
"此方法将在每次按顺序从参数文件读取一行时被调用一次。"

#: ../../library/argparse.rst:2055
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr "此方法的一个有用的重写是将每个以空格分隔的单词视为一个参数。 下面的例子演示了如何实现这一点::"

#: ../../library/argparse.rst:2058
msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"

#: ../../library/argparse.rst:2064
msgid "Exiting methods"
msgstr "退出方法"

#: ../../library/argparse.rst:2068
msgid ""
"This method terminates the program, exiting with the specified *status* and,"
" if given, it prints a *message* to :data:`sys.stderr` before that. The user"
" can override this method to handle these steps differently::"
msgstr ""
"此方法将终结程序，退出时附带指定的 *status*，并且如果给出了 *message* 则会在退出前将其打印到 :data:`sys.stderr`。"
" 用户可重写此方法以不同方式来处理这些步骤::"

#: ../../library/argparse.rst:2072
msgid ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"
msgstr ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"

#: ../../library/argparse.rst:2080
msgid ""
"This method prints a usage message, including the *message*, to "
":data:`sys.stderr` and terminates the program with a status code of 2."
msgstr "此方法将把用法消息包括 *message* 打印到 :data:`sys.stderr` 并附带状态码 2 终结程序。"

#: ../../library/argparse.rst:2085
msgid "Intermixed parsing"
msgstr "混合解析"

#: ../../library/argparse.rst:2090
msgid ""
"A number of Unix commands allow the user to intermix optional arguments with"
" positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this"
" parsing style."
msgstr ""
"许多 Unix 命令允许用户混用可选参数与位置参数。 :meth:`~ArgumentParser.parse_intermixed_args` 和 "
":meth:`~ArgumentParser.parse_known_intermixed_args` 方法均支持这种解析风格。"

#: ../../library/argparse.rst:2095
msgid ""
"These parsers do not support all the :mod:`!argparse` features, and will "
"raise exceptions if unsupported features are used.  In particular, "
"subparsers, and mutually exclusive groups that include both optionals and "
"positionals are not supported."
msgstr ""
"这些解析器并不支持所有的 :mod:`!argparse` 特性，并且当不受支持的特性被使用时将会引发异常。 "
"具体来说，子解析器以及同时包括可选参数和位置参数的互斥分组是不受支持的。"

#: ../../library/argparse.rst:2100
msgid ""
"The following example shows the difference between "
":meth:`~ArgumentParser.parse_known_args` and "
":meth:`~ArgumentParser.parse_intermixed_args`: the former returns ``['2', "
"'3']`` as unparsed arguments, while the latter collects all the positionals "
"into ``rest``.  ::"
msgstr ""
"下面的例子显示了 :meth:`~ArgumentParser.parse_known_args` 与 "
":meth:`~ArgumentParser.parse_intermixed_args` 之间的差异：前者会将 ``['2', '3']`` "
"返回为未解析的参数，而后者会将所有位置参数收集至 ``rest`` 中。 ::"

#: ../../library/argparse.rst:2106
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"

#: ../../library/argparse.rst:2115
msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple"
" containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` "
"返回由两个条目组成的元组，其中包含带成员的命名空间以及剩余参数字符串列表。 当存在任何剩余的未解析参数字符串时 "
":meth:`~ArgumentParser.parse_intermixed_args` 将引发一个错误。"

#: ../../library/argparse.rst:2124
msgid "Registering custom types or actions"
msgstr "注册自定义的类型或动作"

#: ../../library/argparse.rst:2128
msgid ""
"Sometimes it's desirable to use a custom string in error messages to provide"
" more user-friendly output. In these cases, :meth:`!register` can be used to"
" register custom actions or types with a parser and allow you to reference "
"the type by their registered name instead of their callable name."
msgstr ""
"在某些时候有必要在错误消息中使用自定义的字符串以提供对用户更友好的输出。 在这种情况下，可以使用 :meth:`!register` "
"来注册带有解析器的自定义动作或类型并允许你按其注册名称而非其可调用对象名称来引用该类型。"

#: ../../library/argparse.rst:2133
msgid ""
"The :meth:`!register` method accepts three arguments - a *registry_name*, "
"specifying the internal registry where the object will be stored (e.g., "
"``action``, ``type``), *value*, which is the key under which the object will"
" be registered, and object, the callable to be registered."
msgstr ""
":meth:`!register` 方法接受三个参数 —— *registry_name*，指定将要存储对象的内部注册表 (例如 ``action``,"
" ``type``)，*value*，将要注册对象对应的键，以及 object，将要注册的可调用对象。"

#: ../../library/argparse.rst:2138
msgid ""
"The following example shows how to register a custom type with a parser::"
msgstr "下面的例子演示了如何注册一个带解析器的自定义类型::"

#: ../../library/argparse.rst:2140
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type='hexadecimal integer', choices=None, required=False, help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type='hexadecimal integer', choices=None, required=False, help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"

#: ../../library/argparse.rst:2152
msgid "Exceptions"
msgstr "异常"

#: ../../library/argparse.rst:2156
msgid "An error from creating or using an argument (optional or positional)."
msgstr "来自创建或使用某个参数的消息（可选或位置参数）。"

#: ../../library/argparse.rst:2158
msgid ""
"The string value of this exception is the message, augmented with "
"information about the argument that caused it."
msgstr "此异常的字符串值即异常消息，并附带有导致该异常的参数的相关信息。"

#: ../../library/argparse.rst:2163
msgid ""
"Raised when something goes wrong converting a command line string to a type."
msgstr "当从一个命令行字符串到特定类型的转换出现问题时引发。"

#: ../../library/argparse.rst:2167
msgid "Guides and Tutorials"
msgstr "指南与教程"

#: ../../library/argparse.rst:815
msgid "? (question mark)"
msgstr "? (问号)"

#: ../../library/argparse.rst:815 ../../library/argparse.rst:849
#: ../../library/argparse.rst:863
msgid "in argparse module"
msgstr "在 argparse 模块中"

#: ../../library/argparse.rst:849
msgid "* (asterisk)"
msgstr "* (星号)"

#: ../../library/argparse.rst:863
msgid "+ (plus)"
msgstr "+ (加号)"
