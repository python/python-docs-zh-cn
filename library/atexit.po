# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/atexit.rst:2
msgid ":mod:`!atexit` --- Exit handlers"
msgstr ":mod:`!atexit` --- 退出处理器"

#: ../../library/atexit.rst:12
msgid ""
"The :mod:`atexit` module defines functions to register and unregister "
"cleanup functions.  Functions thus registered are automatically executed "
"upon normal interpreter termination.  :mod:`atexit` runs these functions in "
"the *reverse* order in which they were registered; if you register ``A``, "
"``B``, and ``C``, at interpreter termination time they will be run in the "
"order ``C``, ``B``, ``A``."
msgstr ""
":mod:`atexit` 模块定义了清理函数的注册和反注册函数. 被注册的函数会在解释器正常终止时执行. :mod:`atexit` "
"会按照注册顺序的*逆序*执行; 如果你注册了 ``A``, ``B`` 和 ``C``, 那么在解释器终止时会依序执行 ``C``, ``B``, "
"``A``."

#: ../../library/atexit.rst:19
msgid ""
"**Note:** The functions registered via this module are not called when the "
"program is killed by a signal not handled by Python, when a Python fatal "
"internal error is detected, or when :func:`os._exit` is called."
msgstr ""
"**注意:** 通过该模块注册的函数, 在程序被未被 Python 捕获的信号杀死时并不会执行, 在检测到 Python 内部致命错误以及调用了 "
":func:`os._exit` 时也不会执行."

#: ../../library/atexit.rst:23
msgid ""
"**Note:** The effect of registering or unregistering functions from within a"
" cleanup function is undefined."
msgstr "**注意:** 在清理函数内部注册或注销函数可能产生的影响是未定义的。"

#: ../../library/atexit.rst:26
msgid ""
"When used with C-API subinterpreters, registered functions are local to the "
"interpreter they were registered in."
msgstr "当配合 C-API 子解释器使用时，已注册函数是它们所注册解释器中的局部对象。"

#: ../../library/atexit.rst:32
msgid ""
"Register *func* as a function to be executed at termination.  Any optional "
"arguments that are to be passed to *func* must be passed as arguments to "
":func:`register`.  It is possible to register the same function and "
"arguments more than once."
msgstr ""
"将 *func* 注册为终止时执行的函数.  任何传给 *func* 的可选的参数都应当作为参数传给 :func:`register`.  "
"可以多次注册同样的函数及参数."

#: ../../library/atexit.rst:37
msgid ""
"At normal program termination (for instance, if :func:`sys.exit` is called "
"or the main module's execution completes), all functions registered are "
"called in last in, first out order.  The assumption is that lower level "
"modules will normally be imported before higher level modules and thus must "
"be cleaned up later."
msgstr ""
"在正常的程序终止时 (举例来说, 当调用了 :func:`sys.exit` 或是主模块的执行完成时), 所有注册过的函数都会以后进先出的顺序执行. "
"这样做是假定更底层的模块通常会比高层模块更早引入, 因此需要更晚清理."

#: ../../library/atexit.rst:43
msgid ""
"If an exception is raised during execution of the exit handlers, a traceback"
" is printed (unless :exc:`SystemExit` is raised) and the exception "
"information is saved.  After all exit handlers have had a chance to run, the"
" last exception to be raised is re-raised."
msgstr ""
"如果在 exit 处理器执行期间引发了异常，将会打印回溯信息 (除非引发的是 :exc:`SystemExit`) 并且异常信息会被保存。 在所有 "
"exit 处理器都获得运行机会之后，所引发的最后一个异常会被重新引发。"

#: ../../library/atexit.rst:48
msgid ""
"This function returns *func*, which makes it possible to use it as a "
"decorator."
msgstr "这个函数返回 *func* 对象，可以把它当作装饰器使用。"

#: ../../library/atexit.rst:52
msgid ""
"Starting new threads or calling :func:`os.fork` from a registered function "
"can lead to race condition between the main Python runtime thread freeing "
"thread states while internal :mod:`threading` routines or the new process "
"try to use that state. This can lead to crashes rather than clean shutdown."
msgstr ""
"启动新线程或从已注册的函数调用 :func:`os.fork` 可能导致主 Python 运行时线程释放线程状态而内部 :mod:`threading`"
" 例程或新进程试图使用该状态之间的竞争条件。 这会造成程序崩溃而不是正常关闭。"

#: ../../library/atexit.rst:58
msgid ""
"Attempts to start a new thread or :func:`os.fork` a new process in a "
"registered function now leads to :exc:`RuntimeError`."
msgstr "现在尝试启动新线程或在已注册的函数中 :func:`os.fork` 新进程会导致 :exc:`RuntimeError`。"

#: ../../library/atexit.rst:64
msgid ""
"Remove *func* from the list of functions to be run at interpreter shutdown. "
":func:`unregister` silently does nothing if *func* was not previously "
"registered.  If *func* has been registered more than once, every occurrence "
"of that function in the :mod:`atexit` call stack will be removed.  Equality "
"comparisons (``==``) are used internally during unregistration, so function "
"references do not need to have matching identities."
msgstr ""
"将 *func* 移出当解释器关闭时要运行的函数列表。 如果 *func* 之前未被注册则 :func:`unregister` 将静默地不做任何事。 "
"如果 *func* 已被注册一次以上，则该函数每次在 :mod:`atexit` 调用栈中的出现都将被移除。 当取消注册时会在内部使用相等性比较 "
"(``==``)，因而函数引用不需要具有匹配的标识号。"

#: ../../library/atexit.rst:74
msgid "Module :mod:`readline`"
msgstr "模块 :mod:`readline`"

#: ../../library/atexit.rst:75
msgid ""
"Useful example of :mod:`atexit` to read and write :mod:`readline` history "
"files."
msgstr "使用 :mod:`atexit` 读写 :mod:`readline` 历史文件的有用的例子。"

#: ../../library/atexit.rst:82
msgid ":mod:`atexit` Example"
msgstr ":mod:`atexit` 示例"

#: ../../library/atexit.rst:84
msgid ""
"The following simple example demonstrates how a module can initialize a "
"counter from a file when it is imported and save the counter's updated value"
" automatically when the program terminates without relying on the "
"application making an explicit call into this module at termination. ::"
msgstr ""
"以下简单例子演示了一个模块在被导入时如何从文件初始化一个计数器，并在程序终结时自动保存计数器的更新值，此操作不依赖于应用在终结时对此模块进行显式调用。::"

#: ../../library/atexit.rst:89
msgid ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"
msgstr ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"

#: ../../library/atexit.rst:107
msgid ""
"Positional and keyword arguments may also be passed to :func:`register` to "
"be passed along to the registered function when it is called::"
msgstr "位置和关键字参数也可传入 :func:`register` 以便传递给被调用的已注册函数::"

#: ../../library/atexit.rst:110
msgid ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# or:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"
msgstr ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# 或者：\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"

#: ../../library/atexit.rst:119
msgid "Usage as a :term:`decorator`::"
msgstr "作为 :term:`decorator`: 使用:"

#: ../../library/atexit.rst:121
msgid ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"
msgstr ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"

#: ../../library/atexit.rst:127
msgid "This only works with functions that can be called without arguments."
msgstr "只有在函数不需要任何参数调用时才能工作."
