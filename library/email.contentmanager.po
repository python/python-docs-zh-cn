# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.contentmanager.rst:2
msgid ":mod:`!email.contentmanager`: Managing MIME Content"
msgstr ":mod:`!email.contentmanager`: 管理 MIME 内容"

#: ../../library/email.contentmanager.rst:10
msgid "**Source code:** :source:`Lib/email/contentmanager.py`"
msgstr "**源代码:** :source:`Lib/email/contentmanager.py`"

#: ../../library/email.contentmanager.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.contentmanager.rst:19
msgid ""
"Base class for content managers.  Provides the standard registry mechanisms "
"to register converters between MIME content and other representations, as "
"well as the ``get_content`` and ``set_content`` dispatch methods."
msgstr ""
"内容管理器的基类。 提供注册 MIME 内容和其他表示形式间转换器的标准注册机制，以及 ``get_content`` 和 "
"``set_content`` 发送方法。"

#: ../../library/email.contentmanager.rst:26
msgid ""
"Look up a handler function based on the ``mimetype`` of *msg* (see next "
"paragraph), call it, passing through all arguments, and return the result of"
" the call.  The expectation is that the handler will extract the payload "
"from *msg* and return an object that encodes information about the extracted"
" data."
msgstr ""
"基于 *msg* 的 ``mimetype`` 查找处理函数（参见下一段），调用该函数，传递所有参数，并返回调用的结果。 预期的效果是处理程序将从 "
"*msg* 中提取有效载荷并返回编码了有关被提取数据信息的对象。"

#: ../../library/email.contentmanager.rst:32
msgid ""
"To find the handler, look for the following keys in the registry, stopping "
"with the first one found:"
msgstr "要找到处理程序，将在注册表中查找以下键，找到第一个键即停止:"

#: ../../library/email.contentmanager.rst:35
msgid "the string representing the full MIME type (``maintype/subtype``)"
msgstr "表示完整 MIME 类型的字符串 (``maintype/subtype``)"

#: ../../library/email.contentmanager.rst:36
msgid "the string representing the ``maintype``"
msgstr "表示 ``maintype`` 的字符串"

#: ../../library/email.contentmanager.rst:37
msgid "the empty string"
msgstr "空字符串"

#: ../../library/email.contentmanager.rst:39
msgid ""
"If none of these keys produce a handler, raise a :exc:`KeyError` for the "
"full MIME type."
msgstr "如果这些键都没有产生处理程序，则为完整 MIME 类型引发一个 :exc:`KeyError`。"

#: ../../library/email.contentmanager.rst:45
msgid ""
"If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise "
"look up a handler function based on the type of *obj* (see next paragraph), "
"call :meth:`~email.message.EmailMessage.clear_content` on the *msg*, and "
"call the handler function, passing through all arguments.  The expectation "
"is that the handler will transform and store *obj* into *msg*, possibly "
"making other changes to *msg* as well, such as adding various MIME headers "
"to encode information needed to interpret the stored data."
msgstr ""
"如果 ``maintype`` 为 ``multipart``，则引发 :exc:`TypeError`；否则基于 *obj* "
"的类型（参见下一段）查找处理函数，在 *msg* 上调用 "
":meth:`~email.message.EmailMessage.clear_content`，并调用处理函数，传递所有参数。 "
"预期的效果是处理程序将转换 *obj* 并存入 *msg*，并可能对 *msg* 进行其他更改，例如添加各种 MIME "
"标头来编码需要用来解释所存储数据的信息。"

#: ../../library/email.contentmanager.rst:54
msgid ""
"To find the handler, obtain the type of *obj* (``typ = type(obj)``), and "
"look for the following keys in the registry, stopping with the first one "
"found:"
msgstr "要找到处理程序，将获取 *obj* 的类型 (``typ = type(obj)``)，并在注册表中查找以下键，找到第一个键即停止:"

#: ../../library/email.contentmanager.rst:58
msgid "the type itself (``typ``)"
msgstr "类型本身 (``typ``)"

#: ../../library/email.contentmanager.rst:59
msgid ""
"the type's fully qualified name (``typ.__module__ + '.' + "
"typ.__qualname__``)."
msgstr "类型的完整限定名称 (``typ.__module__ + '.' + typ.__qualname__``)。"

#: ../../library/email.contentmanager.rst:61
msgid "the type's :attr:`qualname <type.__qualname__>` (``typ.__qualname__``)"
msgstr "类型的 :attr:`qualname <type.__qualname__>` (``typ.__qualname__``)"

#: ../../library/email.contentmanager.rst:62
msgid "the type's :attr:`name <type.__name__>` (``typ.__name__``)."
msgstr "类型的 :attr:`name <type.__name__>` (``typ.__name__``)。"

#: ../../library/email.contentmanager.rst:64
msgid ""
"If none of the above match, repeat all of the checks above for each of the "
"types in the :term:`MRO` (:attr:`typ.__mro__ <type.__mro__>`). Finally, if "
"no other key yields a handler, check for a handler for the key ``None``.  If"
" there is no handler for ``None``, raise a :exc:`KeyError` for the fully "
"qualified name of the type."
msgstr ""
"如果未匹配到上述任何一项，则为 :term:`MRO` (:attr:`typ.__mro__ <type.__mro__>`) "
"中的每个类型重复上述所有检测。 最后，如果没有其他键产生处理器，则为 ``None`` 键检测处理器。 如果没有 ``None`` "
"的处理器，则为该类型的完整限定名称引发 :exc:`KeyError`。"

#: ../../library/email.contentmanager.rst:71
msgid ""
"Also add a :mailheader:`MIME-Version` header if one is not present (see also"
" :class:`.MIMEPart`)."
msgstr ""
"并会添加一个 :mailheader:`MIME-Version` 标头，如果没有的话 (另请参见 :class:`.MIMEPart`)。"

#: ../../library/email.contentmanager.rst:77
msgid ""
"Record the function *handler* as the handler for *key*.  For the possible "
"values of *key*, see :meth:`get_content`."
msgstr "将 *handler* 函数记录为 *key* 的处理程序。 对于可能的 *key* 键，请参阅 :meth:`get_content`。"

#: ../../library/email.contentmanager.rst:83
msgid ""
"Record *handler* as the function to call when an object of a type matching "
"*typekey* is passed to :meth:`set_content`.  For the possible values of "
"*typekey*, see :meth:`set_content`."
msgstr ""
"将 *handler* 记录为当一个匹配 *typekey* 的类型对象被传递给 :meth:`set_content` 时所要调用的函数。 对于可能的"
" *typekey* 值，请参阅 :meth:`set_content`。"

#: ../../library/email.contentmanager.rst:89
msgid "Content Manager Instances"
msgstr "内容管理器实例"

#: ../../library/email.contentmanager.rst:91
msgid ""
"Currently the email package provides only one concrete content manager, "
":data:`raw_data_manager`, although more may be added in the future. "
":data:`raw_data_manager` is the "
":attr:`~email.policy.EmailPolicy.content_manager` provided by "
":attr:`~email.policy.EmailPolicy` and its derivatives."
msgstr ""
"目前 email 包只提供了一个实体内容管理器 :data:`raw_data_manager`，不过在未来可能会添加更多。 "
":data:`raw_data_manager` 是由 :attr:`~email.policy.EmailPolicy` 及其衍生工具所提供的 "
":attr:`~email.policy.EmailPolicy.content_manager`。"

#: ../../library/email.contentmanager.rst:100
msgid ""
"This content manager provides only a minimum interface beyond that provided "
"by :class:`~email.message.Message` itself:  it deals only with text, raw "
"byte strings, and :class:`~email.message.Message` objects.  Nevertheless, it"
" provides significant advantages compared to the base API: ``get_content`` "
"on a text part will return a unicode string without the application needing "
"to manually decode it, ``set_content`` provides a rich set of options for "
"controlling the headers added to a part and controlling the content transfer"
" encoding, and it enables the use of the various ``add_`` methods, thereby "
"simplifying the creation of multipart messages."
msgstr ""
"这个内容管理器仅提供了超出 :class:`~email.message.Message` 本身提供内容的最小接口：它只处理文本、原始字节串和 "
":class:`~email.message.Message` 对象。 不过相比基础 API，它具有显著的优势：在文本部分上执行 "
"``get_content`` 将返回一个 unicode 字符串而无需由应用程序来手动解码，``set_content`` "
"为控制添加到一个部分的标头和控制内容传输编码格式提供了丰富的选项集合，并且它还启用了多种 ``add_`` 方法，从而简化了多部分消息的创建过程。"

#: ../../library/email.contentmanager.rst:112
msgid ""
"Return the payload of the part as either a string (for ``text`` parts), an "
":class:`~email.message.EmailMessage` object (for ``message/rfc822`` parts), "
"or a ``bytes`` object (for all other non-multipart types).  Raise a "
":exc:`KeyError` if called on a ``multipart``.  If the part is a ``text`` "
"part and *errors* is specified, use it as the error handler when decoding "
"the payload to unicode.  The default error handler is ``replace``."
msgstr ""
"将指定部分的有效载荷作为字符串（对于 ``text`` 部分）, :class:`~email.message.EmailMessage` 对象（对于 "
"``message/rfc822`` 部分）或 ``bytes`` 对象（对于所有其他非多部分类型）返回。 如果是在 ``multipart`` "
"上调用则会引发 :exc:`KeyError`。 如果指定部分是一个 ``text`` 部分并且指明了 *errors*，则会在将载荷解码为 "
"unicode 时将其用作错误处理程序。 默认的错误处理程序是 ``replace``。"

#: ../../library/email.contentmanager.rst:131
msgid "Add headers and payload to *msg*:"
msgstr "向 *msg* 添加标头和有效载荷:"

#: ../../library/email.contentmanager.rst:133
msgid ""
"Add a :mailheader:`Content-Type` header with a ``maintype/subtype`` value."
msgstr "添加一个带有 ``maintype/subtype`` 值的 :mailheader:`Content-Type` 标头。"

#: ../../library/email.contentmanager.rst:136
msgid ""
"For ``str``, set the MIME ``maintype`` to ``text``, and set the subtype to "
"*subtype* if it is specified, or ``plain`` if it is not."
msgstr ""
"对于 ``str``，将 MIME ``maintype`` 设为 ``text``，如果指定了子类型 *subtype* 则设为指定值，否则设为 "
"``plain``。"

#: ../../library/email.contentmanager.rst:138
msgid ""
"For ``bytes``, use the specified *maintype* and *subtype*, or raise a "
":exc:`TypeError` if they are not specified."
msgstr ""
"对于 ``bytes``，将使用指定的 *maintype* 和 *subtype*，如果未指定则会引发 :exc:`TypeError`。"

#: ../../library/email.contentmanager.rst:140
msgid ""
"For :class:`~email.message.EmailMessage` objects, set the maintype to "
"``message``, and set the subtype to *subtype* if it is specified or "
"``rfc822`` if it is not.  If *subtype* is ``partial``, raise an error "
"(``bytes`` objects must be used to construct ``message/partial`` parts)."
msgstr ""
"对于 :class:`~email.message.EmailMessage` 对象，将 maintype 设为 ``message``，并将指定的 "
"subtype 设为 *subtype*，如果未指定则设为 ``rfc822``。 如果 *subtype* 为 "
"``partial``，则引发一个错误（必须使用 ``bytes`` 对象来构造 ``message/partial`` 部分）。"

#: ../../library/email.contentmanager.rst:146
msgid ""
"If *charset* is provided (which is valid only for ``str``), encode the "
"string to bytes using the specified character set.  The default is "
"``utf-8``.  If the specified *charset* is a known alias for a standard MIME "
"charset name, use the standard charset instead."
msgstr ""
"如果提供了 *charset* (这只对 ``str`` 适用)，则使用指定的字符集将字符串编码为字节串。 默认值为 ``utf-8``。 如果指定的 "
"*charset* 是某个标准 MIME 字符集名称的已知别名，则会改用该标准字符集。"

#: ../../library/email.contentmanager.rst:151
msgid ""
"If *cte* is set, encode the payload using the specified content transfer "
"encoding, and set the :mailheader:`Content-Transfer-Encoding` header to that"
" value.  Possible values for *cte* are ``quoted-printable``, ``base64``, "
"``7bit``, ``8bit``, and ``binary``.  If the input cannot be encoded in the "
"specified encoding (for example, specifying a *cte* of ``7bit`` for an input"
" that contains non-ASCII values), raise a :exc:`ValueError`."
msgstr ""
"如果设置了 *cte*，则使用指定的内容传输编码格式对有效载荷进行编码，并将 :mailheader:`Content-Transfer-"
"Encoding` 标头设为该值。 可能的 *cte* 值有 ``quoted-printable``, ``base64``, ``7bit``, "
"``8bit`` 和 ``binary``。 如果输入无法以指定的编码格式被编码 (例如，对于包含非 ASCII 值的输入指定 *cte* 值为 "
"``7bit``)，则会引发 :exc:`ValueError`。"

#: ../../library/email.contentmanager.rst:159
msgid ""
"For ``str`` objects, if *cte* is not set use heuristics to determine the "
"most compact encoding.  Prior to encoding, :meth:`str.splitlines` is used to"
" normalize all line boundaries, ensuring that each line of the payload is "
"terminated by the current policy's :data:`~email.policy.Policy.linesep` "
"property (even if the original string did not end with one)."
msgstr ""
"对于 ``str`` 对象，如果未设置 *cte* 则使用启发式求解来确定最紧凑的编码格式。 在编码之前，将使用 "
":meth:`str.splitlines` 来正规化所有行边界，确保载荷的每一行是以当前策略的 "
":data:`~email.policy.Policy.linesep` 特性属性来结束的（即使原始字符串不是以它结束）。"

#: ../../library/email.contentmanager.rst:165
msgid ""
"For ``bytes`` objects, *cte* is taken to be base64 if not set, and the "
"aforementioned newline translation is not performed."
msgstr "对于 ``bytes`` 对象，如果未设置 *cte* 则使用 base64，并且不会执行之前提及的换行符转写。"

#: ../../library/email.contentmanager.rst:167
msgid ""
"For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise an error if"
" a *cte* of ``quoted-printable`` or ``base64`` is requested for *subtype* "
"``rfc822``, and for any *cte* other than ``7bit`` for *subtype* ``external-"
"body``.  For ``message/rfc822``, use ``8bit`` if *cte* is not specified.  "
"For all other values of *subtype*, use ``7bit``."
msgstr ""
"对于 :class:`~email.message.EmailMessage`，按照 :rfc:`2046`，如果为 *subtype* "
"``rfc822`` 请求的 *cte* 为 ``quoted-printable`` 或 ``base64`` ，而为 ``7bit`` 以外的任何 "
"*cte* 为 *subtype* ``external-body`` 则会引发一个错误。 对于 ``message/rfc822``，如果 *cte*"
" 未指定则会使用 ``8bit``。 对于所有其他 *subtype* 值，都会使用 ``7bit``。"

#: ../../library/email.contentmanager.rst:174
msgid ""
"A *cte* of ``binary`` does not actually work correctly yet. The "
"``EmailMessage`` object as modified by ``set_content`` is correct, but "
":class:`~email.generator.BytesGenerator` does not serialize it correctly."
msgstr ""
"*cte* 值为 ``binary`` 实际上还不能正确工作。 由 ``set_content`` 所修改的 ``EmailMessage`` "
"对象是正确的，但 :class:`~email.generator.BytesGenerator` 不会正确地将其序列化。"

#: ../../library/email.contentmanager.rst:179
msgid ""
"If *disposition* is set, use it as the value of the :mailheader:`Content-"
"Disposition` header.  If not specified, and *filename* is specified, add the"
" header with the value ``attachment``. If *disposition* is not specified and"
" *filename* is also not specified, do not add the header.  The only valid "
"values for *disposition* are ``attachment`` and ``inline``."
msgstr ""
"如果设置了 *disposition*，它会被用作 :mailheader:`Content-Disposition` 标头的值。 "
"如果未设置，并且指定了 *filename*，则添加值为 ``attachment`` 的标头。 如果未设置 *disposition* 并且也未指定 "
"*filename*，则不添加标头。 *disposition* 的有效值仅有 ``attachment`` 和 ``inline``。"

#: ../../library/email.contentmanager.rst:186
msgid ""
"If *filename* is specified, use it as the value of the ``filename`` "
"parameter of the :mailheader:`Content-Disposition` header."
msgstr ""
"如果设置了 *filename*，则将其用作 :mailheader:`Content-Disposition` 标头的 ``filename`` "
"参数的值。"

#: ../../library/email.contentmanager.rst:189
msgid ""
"If *cid* is specified, add a :mailheader:`Content-ID` header with *cid* as "
"its value."
msgstr "如果设置了 *cid*，则添加一个 :mailheader:`Content-ID` 标头并将其值设为 *cid*。"

#: ../../library/email.contentmanager.rst:192
msgid ""
"If *params* is specified, iterate its ``items`` method and use the resulting"
" ``(key, value)`` pairs to set additional parameters on the "
":mailheader:`Content-Type` header."
msgstr ""
"如果设置了 *params*，则迭代其 ``items`` 方法并使用输出的 ``(key, value)`` 结果对在 "
":mailheader:`Content-Type` 标头上设置附加参数。"

#: ../../library/email.contentmanager.rst:196
msgid ""
"If *headers* is specified and is a list of strings of the form ``headername:"
" headervalue`` or a list of ``header`` objects (distinguished from strings "
"by having a ``name`` attribute), add the headers to *msg*."
msgstr ""
"如果设置了 *headers* 并且为 ``headername: headervalue`` 形式的字符串的列表或为 ``header`` "
"对象的列表（通过一个 ``name`` 属性与字符串相区分），则将标头添加到 *msg*。"

#: ../../library/email.contentmanager.rst:203
msgid "Footnotes"
msgstr "备注"

#: ../../library/email.contentmanager.rst:204
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`"
msgstr "最初在 3.4 中作为 :term:`暂定模块 <provisional package>` 添加"
