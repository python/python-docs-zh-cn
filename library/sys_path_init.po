# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sys_path_init.rst:4
msgid "The initialization of the :data:`sys.path` module search path"
msgstr ":data:`sys.path` 模块搜索路径的初始化"

#: ../../library/sys_path_init.rst:6
msgid ""
"A module search path is initialized when Python starts. This module search "
"path may be accessed at :data:`sys.path`."
msgstr "模块搜索路径是在 Python 启动时被初始化的。 这个模块搜索路径可通过 :data:`sys.path` 来访问。"

#: ../../library/sys_path_init.rst:9
msgid ""
"The first entry in the module search path is the directory that contains the"
" input script, if there is one. Otherwise, the first entry is the current "
"directory, which is the case when executing the interactive shell, a "
":option:`-c` command, or :option:`-m` module."
msgstr ""
"模块搜索路径的第一个条目是包含输入脚本的目录，如果存在输入脚本的话。 否则，第一个条目将是当前目录，当执行交互式 shell, :option:`-c`"
" 命令, 或 :option:`-m` 模块时都属于这种情况。"

#: ../../library/sys_path_init.rst:14
msgid ""
"The :envvar:`PYTHONPATH` environment variable is often used to add "
"directories to the search path. If this environment variable is found then "
"the contents are added to the module search path."
msgstr ":envvar:`PYTHONPATH` 环境变量经常被用于将目录添加到搜索路径。 如果发现了该环境变量则其内容将被添加到模块搜索路径中。"

#: ../../library/sys_path_init.rst:20
msgid ""
":envvar:`PYTHONPATH` will affect all installed Python versions/environments."
" Be wary of setting this in your shell profile or global environment "
"variables. The :mod:`site` module offers more nuanced techniques as "
"mentioned below."
msgstr ""
":envvar:`PYTHONPATH` 将影响所有已安装的 Python 版本/环境。 在你的 shell "
"用户配置或全局环境变量中设置它时需要小心谨慎。 :mod:`site` 模块提供了下文所述的更细微的技巧。"

#: ../../library/sys_path_init.rst:24
msgid ""
"The next items added are the directories containing standard Python modules "
"as well as any :term:`extension module`\\s that these modules depend on. "
"Extension modules are ``.pyd`` files on Windows and ``.so`` files on other "
"platforms. The directory with the platform-independent Python modules is "
"called ``prefix``. The directory with the extension modules is called "
"``exec_prefix``."
msgstr ""
"随后加入的条目是包含标准 Python 模块以及这些模块所依赖的任何 :term:`extension module` 的目录。 扩展模块在 "
"Windows 上为 ``.pyd`` 文件而在其他平台上则为 ``.so`` 文件。 独立于平台的 Python 模块的目录称为 "
"``prefix``。 扩展模块的目录称为 ``exec_prefix``。"

#: ../../library/sys_path_init.rst:30
msgid ""
"The :envvar:`PYTHONHOME` environment variable may be used to set the "
"``prefix`` and ``exec_prefix`` locations. Otherwise these directories are "
"found by using the Python executable as a starting point and then looking "
"for various 'landmark' files and directories. Note that any symbolic links "
"are followed so the real Python executable location is used as the search "
"starting point. The Python executable location is called ``home``."
msgstr ""
":envvar:`PYTHONHOME` 环境变量可以被用于设置 ``prefix`` 和 ``exec_prefix`` 的位置。 "
"在其他情况下这些目录将使用 Python 可执行文件作为起始点来确定然后再查找几处 '地标' 文件和目录。 请注意任何符号链接也会被引入以便使用实际的 "
"Python 可执行文件位置作为搜索起始点。 这个 Python 可执行文件位置被称为 ``home``。"

#: ../../library/sys_path_init.rst:37
msgid ""
"Once ``home`` is determined, the ``prefix`` directory is found by first "
"looking for :file:`python{majorversion}{minorversion}.zip` "
"(``python311.zip``). On Windows the zip archive is searched for in ``home`` "
"and on Unix the archive is expected to be in :file:`lib`. Note that the "
"expected zip archive location is added to the module search path even if the"
" archive does not exist. If no archive was found, Python on Windows will "
"continue the search for ``prefix`` by looking for :file:`Lib\\\\os.py`. "
"Python on Unix will look for "
":file:`lib/python{majorversion}.{minorversion}/os.py` "
"(``lib/python3.11/os.py``). On Windows ``prefix`` and ``exec_prefix`` are "
"the same, however on other platforms "
":file:`lib/python{majorversion}.{minorversion}/lib-dynload` "
"(``lib/python3.11/lib-dynload``) is searched for and used as an anchor for "
"``exec_prefix``. On some platforms :file:`lib` may be :file:`lib64` or "
"another value, see :data:`sys.platlibdir` and :envvar:`PYTHONPLATLIBDIR`."
msgstr ""
"一旦确定了 ``home``，则 ``prefix`` 目录将通过首先查找 "
":file:`python{majorversion}{minorversion}.zip` (``python311.zip``) 来找到。 在 "
"Windows 上将会到 ``home`` 中搜索 zip 归档而在 Unix 上则会到 :file:`lib` 中搜索它。 请注意预期的 zip "
"归档位置即使在此归档不存在时仍然会被添加到模块搜索路径。 如果未找到归档，在 Windows 上 Python 将继续通过查找 "
":file:`Lib\\\\os.py` 来搜索 ``prefix``。 在 Unix 上 Python 将查找 "
":file:`lib/python{majorversion}.{minorversion}/os.py` "
"(``lib/python3.11/os.py``)。 在 Windows 上 ``prefix`` 和 ``exec_prefix`` "
"是相同的，但是在其他平台上则会搜索 :file:`lib/python{majorversion}.{minorversion}/lib-"
"dynload` (``lib/python3.11/lib-dynload``) 并将其用作 ``exec_prefix`` 的锚点。 在某些平台上 "
":file:`lib` 可能为 :file:`lib64` 或其他值，请参阅 :data:`sys.platlibdir` 和 "
":envvar:`PYTHONPLATLIBDIR`。"

#: ../../library/sys_path_init.rst:50
msgid ""
"Once found, ``prefix`` and ``exec_prefix`` are available at "
":data:`sys.base_prefix` and :data:`sys.base_exec_prefix` respectively."
msgstr ""
"一旦找到，``prefix`` 和 ``exec_prefix`` 将分别在 :data:`sys.base_prefix` 和 "
":data:`sys.base_exec_prefix` 上可用。"

#: ../../library/sys_path_init.rst:53
msgid ""
"If :envvar:`PYTHONHOME` is not set, and a ``pyvenv.cfg`` file is found "
"alongside the main executable, or in its parent directory, "
":data:`sys.prefix` and :data:`sys.exec_prefix` get set to the directory "
"containing ``pyvenv.cfg``, otherwise they are set to the same value as "
":data:`sys.base_prefix` and :data:`sys.base_exec_prefix`, respectively. This"
" is used by :ref:`sys-path-init-virtual-environments`."
msgstr ""
"如果未设置 :envvar:`PYTHONHOME`，而在主可执行文件所在位置或其父目录中找到了 ``pyvenv.cfg`` 文件，则会将 "
":data:`sys.prefix` 和 :data:`sys.exec_prefix` 设为包含 ``pyvenv.cfg`` "
"的目录，在其他情况下它们会被分别设为与 :data:`sys.base_prefix` 和 :data:`sys.base_exec_prefix` "
"相同的值。 该值将被 :ref:`sys-path-init-virtual-environments` 使用。"

#: ../../library/sys_path_init.rst:60
msgid ""
"Finally, the :mod:`site` module is processed and :file:`site-packages` "
"directories are added to the module search path. A common way to customize "
"the search path is to create :mod:`sitecustomize` or :mod:`usercustomize` "
"modules as described in the :mod:`site` module documentation."
msgstr ""
"最后，将会处理 :mod:`site` 模块并将 :file:`site-packages` 目录添加到模块搜索路径。 "
"自定义搜索路径的一个常用方式是创建 :mod:`sitecustomize` 或 :mod:`usercustomize` 模块，如 "
":mod:`site` 模块文档所描述的那样。"

#: ../../library/sys_path_init.rst:67
msgid ""
"Certain command line options may further affect path calculations. See "
":option:`-E`, :option:`-I`, :option:`-s` and :option:`-S` for further "
"details."
msgstr ""
"特定的命令行选项可能对路径计算造成额外的影响。 请参阅 :option:`-E`, :option:`-I`, :option:`-s` 和 "
":option:`-S` 了解更多细节。"

#: ../../library/sys_path_init.rst:72
msgid ""
":data:`sys.prefix` and :data:`sys.exec_prefix` are now set to the "
"``pyvenv.cfg`` directory during the path initialization. This was previously"
" done by :mod:`site`, therefore affected by :option:`-S`."
msgstr ""
"在路径初始化期间 :data:`sys.prefix` 和 :data:`sys.exec_prefix` 现在会被设为 ``pyvenv.cfg`` "
"目录。 在之前版本中这是由 :mod:`site` 完成的，因而会受 :option:`-S` 影响。"

#: ../../library/sys_path_init.rst:79
msgid "Virtual Environments"
msgstr "虚拟环境"

#: ../../library/sys_path_init.rst:81
msgid ""
"Virtual environments place a ``pyvenv.cfg`` file in their prefix, which "
"causes :data:`sys.prefix` and :data:`sys.exec_prefix` to point to them, "
"instead of the base installation."
msgstr ""
"各虚拟环境会在其前缀中放置一个 ``pyvenv.cfg`` 文件，这将使得 :data:`sys.prefix` 和 "
":data:`sys.exec_prefix` 指向它们，而非指向基本安装位置。"

#: ../../library/sys_path_init.rst:85
msgid ""
"The ``prefix`` and ``exec_prefix`` values of the base installation are "
"available at :data:`sys.base_prefix` and :data:`sys.base_exec_prefix`."
msgstr ""
"基本安装版的 ``prefix`` 和 ``exec_prefix`` 值可从 :data:`sys.base_prefix` 和 "
":data:`sys.base_exec_prefix` 获取。"

#: ../../library/sys_path_init.rst:88
msgid ""
"As well as being used as a marker to identify virtual environments, "
"``pyvenv.cfg`` may also be used to configure the :mod:`site` initialization."
" Please refer to :mod:`site`'s :ref:`virtual environments documentation "
"<site-virtual-environments-configuration>`."
msgstr ""
"除了用作标识虚拟环境的标记，``pyvenv.cfg`` 还可被用来配置 :mod:`site` 的初始化。 请参阅 :mod:`site` 的 "
":ref:`虚拟环境文档 <site-virtual-environments-configuration>`。"

#: ../../library/sys_path_init.rst:95
msgid ":envvar:`PYTHONHOME` overrides the ``pyvenv.cfg`` detection."
msgstr ":envvar:`PYTHONHOME` 将覆盖 ``pyvenv.cfg`` 检测。"

#: ../../library/sys_path_init.rst:99
msgid ""
"There are other ways how \"virtual environments\" could be implemented, this"
" documentation refers implementations based on the ``pyvenv.cfg`` mechanism,"
" such as :mod:`venv`. Most virtual environment implementations follow the "
"model set by :mod:`venv`, but there may be exotic implementations that "
"diverge from it."
msgstr ""
"还有其他一些方式可以实现“虚拟环境”，本文档介绍了基于 ``pyvenv.cfg`` 机制的实现，如 :mod:`venv`。 "
"大多数虚拟环境实现都遵循由 :mod:`venv` 所设定的模型，但也可能存在与其不同的新奇实现。"

#: ../../library/sys_path_init.rst:106
msgid "_pth files"
msgstr "_pth 文件"

#: ../../library/sys_path_init.rst:108
msgid ""
"To completely override :data:`sys.path` create a ``._pth`` file with the "
"same name as the shared library or executable (``python._pth`` or "
"``python311._pth``). The shared library path is always known on Windows, "
"however it may not be available on other platforms. In the ``._pth`` file "
"specify one line for each path to add to :data:`sys.path`. The file based on"
" the shared library name overrides the one based on the executable, which "
"allows paths to be restricted for any program loading the runtime if "
"desired."
msgstr ""
"若要完全覆盖 :data:`sys.path` 则请创建一个与共享库或可执行文件 (``python._pth`` 或 "
"``python311._pth``) 同名的 ``._pth`` 文件。 共享库路径在 Windows 是始终是已知的，但这在其他平台上也许会不可用。"
" 请在 ``._pth`` 文件中为添加到 :data:`sys.path` 的每个路径指定对应的一行。 "
"基于共享库名称的文件会覆盖基于可执行文件的对应文件，这允许在必要时为任何加载运行时的程序限制路径。"

#: ../../library/sys_path_init.rst:116
msgid ""
"When the file exists, all registry and environment variables are ignored, "
"isolated mode is enabled, and :mod:`site` is not imported unless one line in"
" the file specifies ``import site``. Blank paths and lines starting with "
"``#`` are ignored. Each path may be absolute or relative to the location of "
"the file. Import statements other than to ``site`` are not permitted, and "
"arbitrary code cannot be specified."
msgstr ""
"当文件存在时，将忽略所有注册表和环境变量，启用隔离模式，并且：除非文件中的一行指定 ``import site`` ，否则不会导入 "
":mod:`site` 。以 ``＃`` 开头的空白路径和行将被忽略。每个路径可以是绝对的或相对于文件的位置。不允许使用除 ``site`` "
"以外的导入语句，并且不能指定任意代码。"

#: ../../library/sys_path_init.rst:123
msgid ""
"Note that ``.pth`` files (without leading underscore) will be processed "
"normally by the :mod:`site` module when ``import site`` has been specified."
msgstr "请注意，当指定 ``import site`` 时， ``.pth`` 文件（没有前导下划线）将由 :mod:`site` 模块正常处理。"

#: ../../library/sys_path_init.rst:127
msgid "Embedded Python"
msgstr "嵌入式 Python"

#: ../../library/sys_path_init.rst:129
msgid ""
"If Python is embedded within another application "
":c:func:`Py_InitializeFromConfig` and the :c:type:`PyConfig` structure can "
"be used to initialize Python. The path specific details are described at "
":ref:`init-path-config`."
msgstr ""
"如果 Python 被嵌入其他应用程序中则 :c:func:`Py_InitializeFromConfig` 和 :c:type:`PyConfig`"
" 结构体可被用来初始化 Python。 路径专属的细节描述见 :ref:`init-path-config`。"

#: ../../library/sys_path_init.rst:135
msgid ":ref:`windows_finding_modules` for detailed Windows notes."
msgstr ":ref:`windows_finding_modules` 了解更多有关 Windows 的细节说明。"

#: ../../library/sys_path_init.rst:136
msgid ":ref:`using-on-unix` for Unix details."
msgstr ":ref:`using-on-unix` 了解 Unix 的相关细节。"
