# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2022
# Wulian233 <xiguawulian@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 00:57+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`!configparser` --- Configuration file parser"
msgstr ":mod:`!configparser` --- 配置文件解析器"

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**源代码:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"此模块提供了它实现一种基本配置语言 :class:`ConfigParser` 类，这种语言所提供的结构与 Microsoft Windows INI "
"文件的类似。 你可以使用这种语言来编写能够由最终用户来自定义的 Python 程序。"

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr "这个库 *并不* 能够解析或写入在 Windows Registry 扩展版本 INI 语法中所使用的值-类型前缀。"

#: ../../library/configparser.rst:36
msgid "Module :mod:`tomllib`"
msgstr "模块 :mod:`tomllib`"

#: ../../library/configparser.rst:37
msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr "TOML 是一种具有良好规范的针对应用程序配置文件的格式。 它被专门设计作为 INI 改进版本。"

#: ../../library/configparser.rst:40
msgid "Module :mod:`shlex`"
msgstr "模块 :mod:`shlex`"

#: ../../library/configparser.rst:41
msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr "支持创建类似 Unix shell 的同样可被用于应用程序配置文件的迷你语言。"

#: ../../library/configparser.rst:44
msgid "Module :mod:`json`"
msgstr "模块 :mod:`json`"

#: ../../library/configparser.rst:45
msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr "``json`` 模块实现了 JavaScript 语法的一个子集，它有时被用于配置，但是不支持注释。"

#: ../../library/configparser.rst:61
msgid "Quick Start"
msgstr "快速起步"

#: ../../library/configparser.rst:63
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "让我们准备一个非常基本的配置文件，它看起来是这样的:"

#: ../../library/configparser.rst:65
msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Compression = yes\n"
"CompressionLevel = 9\n"
"ForwardX11 = yes\n"
"\n"
"[forge.example]\n"
"User = hg\n"
"\n"
"[topsecret.server.example]\n"
"Port = 50022\n"
"ForwardX11 = no"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Compression = yes\n"
"CompressionLevel = 9\n"
"ForwardX11 = yes\n"
"\n"
"[forge.example]\n"
"User = hg\n"
"\n"
"[topsecret.server.example]\n"
"Port = 50022\n"
"ForwardX11 = no"

#: ../../library/configparser.rst:80
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"INI 文件的结构描述见 `以下章节 <#supported-ini-file-structure>`_。 "
"总的来说，这种文件由多个节组成，每个节包含多个带有值的键。 :mod:`configparser` 类可以读取和写入这种文件。 "
"让我们先通过程序方式来创建上述的配置文件。"

#: ../../library/configparser.rst:86
msgid ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Compression': 'yes',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {}\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022'     # mutates the parser\n"
">>> topsecret['ForwardX11'] = 'no'  # same here\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> with open('example.ini', 'w') as configfile:\n"
"...   config.write(configfile)\n"
"..."
msgstr ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Compression': 'yes',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {}\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022'     # 更改解析器\n"
">>> topsecret['ForwardX11'] = 'no'  # same here\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> with open('example.ini', 'w') as configfile:\n"
"...   config.write(configfile)\n"
"..."

#: ../../library/configparser.rst:104
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"如你所见，我们可以把配置解析器当作一个字典来处理。 两者确实存在差异，`将在后文说明 <#mapping-protocol-"
"access>`_，但是其行为非常接近于字典所具有一般行为。"

#: ../../library/configparser.rst:108
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr "现在我们已经创建并保存了一个配置文件，让我们再将它读取出来并探究其中包含的数据。"

#: ../../library/configparser.rst:111
msgid ""
">>> config = configparser.ConfigParser()\n"
">>> config.sections()\n"
"[]\n"
">>> config.read('example.ini')\n"
"['example.ini']\n"
">>> config.sections()\n"
"['forge.example', 'topsecret.server.example']\n"
">>> 'forge.example' in config\n"
"True\n"
">>> 'python.org' in config\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Compression']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'no'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"...     print(key)\n"
"user\n"
"compressionlevel\n"
"serveraliveinterval\n"
"compression\n"
"forwardx11\n"
">>> config['forge.example']['ForwardX11']\n"
"'yes'"
msgstr ""
">>> config = configparser.ConfigParser()\n"
">>> config.sections()\n"
"[]\n"
">>> config.read('example.ini')\n"
"['example.ini']\n"
">>> config.sections()\n"
"['forge.example', 'topsecret.server.example']\n"
">>> 'forge.example' in config\n"
"True\n"
">>> 'python.org' in config\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Compression']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'no'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"...     print(key)\n"
"user\n"
"compressionlevel\n"
"serveraliveinterval\n"
"compression\n"
"forwardx11\n"
">>> config['forge.example']['ForwardX11']\n"
"'yes'"

#: ../../library/configparser.rst:143
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all"
" other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"正如我们在上面所看到的，相关的 API 相当直观。 唯一有些神奇的地方是 ``DEFAULT`` 小节，它为所有其他小节提供了默认值 [1]_。 "
"还要注意小节中的键大小写不敏感并且会存储为小写形式 [1]_。"

#: ../../library/configparser.rst:148 ../../library/configparser.rst:1003
msgid ""
"It is possible to read several configurations into a single "
":class:`ConfigParser`, where the most recently added configuration has the "
"highest priority. Any conflicting keys are taken from the more recent "
"configuration while the previously existing keys are retained. The example "
"below reads in an ``override.ini`` file, which will override any conflicting"
" keys from the ``example.ini`` file."
msgstr ""
"将多个配置读入单个 :class:`ConfigParser` 是可能的，其中最近添加的配置具有最高优先级。 "
"任何冲突的键都会从更近的配置获取并且先前存在的键会被保留。 下面的例子读入一个 ``override.ini`` 文件，它将覆盖任何来自 "
"``example.ini`` 文件的冲突的键。"

#: ../../library/configparser.rst:155 ../../library/configparser.rst:1010
msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"

#: ../../library/configparser.rst:160 ../../library/configparser.rst:1015
msgid ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> with open('override.ini', 'w') as configfile:\n"
"...     config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini']\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"
msgstr ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> with open('override.ini', 'w') as configfile:\n"
"...     config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini']\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"

#: ../../library/configparser.rst:174
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr "此行为等价于一次 :meth:`ConfigParser.read` 调用并向 *filenames* 形参传入多个文件。"

#: ../../library/configparser.rst:179
msgid "Supported Datatypes"
msgstr "支持的数据类型"

#: ../../library/configparser.rst:181
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr "配置解析器并不会猜测配置文件中值的类型，而总是将它们在内部存储为字符串。 这意味着如果你需要其他数据类型，你应当自己来转换:"

#: ../../library/configparser.rst:185
msgid ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"
msgstr ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"

#: ../../library/configparser.rst:192
msgid ""
"Since this task is so common, config parsers provide a range of handy getter"
" methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"由于这种任务十分常用，配置解析器提供了一系列便捷的获取方法来处理整数、浮点数和布尔值。 最后一个类型的处理最为有趣，因为简单地将值传给 "
"``bool()`` 是没有用的，``bool('False')`` 仍然会是 ``True``。 为解决这个问题配置解析器还提供了 "
":meth:`~ConfigParser.getboolean`。 这个方法对大小写不敏感并可识别 ``'yes'``/``'no'``, "
"``'on'``/``'off'``, ``'true'``/``'false'`` 和 ``'1'``/``'0'`` [1]_ 等布尔值。 例如:"

#: ../../library/configparser.rst:200
msgid ""
">>> topsecret.getboolean('ForwardX11')\n"
"False\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"
msgstr ""
">>> topsecret.getboolean('ForwardX11')\n"
"False\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"

#: ../../library/configparser.rst:209
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"除了 :meth:`~ConfigParser.getboolean`，配置解析器还提供了同类的 "
":meth:`~ConfigParser.getint` 和 :meth:`~ConfigParser.getfloat` 方法。 "
"你可以注册你自己的转换器并或是定制已提供的转换器。 [1]_"

#: ../../library/configparser.rst:215
msgid "Fallback Values"
msgstr "回退值"

#: ../../library/configparser.rst:217
msgid ""
"As with a dictionary, you can use a section's :meth:`~ConfigParser.get` "
"method to provide fallback values:"
msgstr "与字典类似，你可以使用某一节的 :meth:`~ConfigParser.get` 方法来提供回退值："

#: ../../library/configparser.rst:220
msgid ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('CompressionLevel')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"
msgstr ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('CompressionLevel')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"

#: ../../library/configparser.rst:230
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"请注意默认值会优先于回退值。 例如，在我们的示例中 ``'CompressionLevel'`` 键仅在 ``'DEFAULT'`` 小节中被指定。 "
"如果我们尝试从 ``'topsecret.server.example'`` 小节获取它，我们将总是会得到默认值，即使我们指定了一个回退值:"

#: ../../library/configparser.rst:236
msgid ""
">>> topsecret.get('CompressionLevel', '3')\n"
"'9'"
msgstr ""
">>> topsecret.get('CompressionLevel', '3')\n"
"'9'"

#: ../../library/configparser.rst:241
msgid ""
"One more thing to be aware of is that the parser-level "
":meth:`~ConfigParser.get` method provides a custom, more complex interface, "
"maintained for backwards compatibility.  When using this method, a fallback "
"value can be provided via the ``fallback`` keyword-only argument:"
msgstr ""
"还需要注意的一点是解析器层级的 :meth:`~ConfigParser.get` 方法提供了自定义的更复杂接口，它被继续维护用于向下兼容。 "
"当使用此方法时，可以通过 ``fallback`` 仅限关键字参数提供一个回退值："

#: ../../library/configparser.rst:246
msgid ""
">>> config.get('forge.example', 'monster',\n"
"...            fallback='No such things as monsters')\n"
"'No such things as monsters'"
msgstr ""
">>> config.get('forge.example', 'monster',\n"
"...            fallback='No such things as monsters')\n"
"'No such things as monsters'"

#: ../../library/configparser.rst:252
msgid ""
"The same ``fallback`` argument can be used with the "
":meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` and "
":meth:`~ConfigParser.getboolean` methods, for example:"
msgstr ""
"同样的 ``fallback`` 参数也可在 :meth:`~ConfigParser.getint`, "
":meth:`~ConfigParser.getfloat` 和 :meth:`~ConfigParser.getboolean` 方法中使用，例如:"

#: ../../library/configparser.rst:256
msgid ""
">>> 'BatchMode' in topsecret\n"
"False\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"True\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"
msgstr ""
">>> 'BatchMode' in topsecret\n"
"False\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"True\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"

#: ../../library/configparser.rst:268
msgid "Supported INI File Structure"
msgstr "受支持的 INI 文件结构"

#: ../../library/configparser.rst:270
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but"
" keys are not [1]_.  Leading and trailing whitespace is removed from keys "
"and values. Values can be omitted if the parser is configured to allow it "
"[1]_, in which case the key/value delimiter may also be left out.  Values "
"can also span multiple lines, as long as they are indented deeper than the "
"first line of the value.  Depending on the parser's mode, blank lines may be"
" treated as parts of multiline values or ignored."
msgstr ""
"配置文件是由小节组成的，每个小节都有一个 ``[section]`` 标头，加上多个由特定字符串 (默认为 ``=`` 或 ``:`` [1]_) "
"分隔的键/值条目。 在默认情况下，小节名对大小写敏感而键对大小写不敏感 [1]_。 键和值开头和末尾的空格会被移除。 在解释器配置允许时值可以被省略 "
"[1]_，在此情况下键/值分隔符也可以被省略。 值还可以跨越多行，只要值的其他行带有比第一行更深的缩进。 "
"依据解析器的具体模式，空白行可能会被视为多行值的组成部分或是被忽略。"

#: ../../library/configparser.rst:280
msgid ""
"By default, a valid section name can be any string that does not contain "
"'\\\\n'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"在默认情况下，有效的节名称可以是不包含 '\\\\n' 的任意字符串。 要改变此设定，请参阅 :attr:`ConfigParser.SECTCRE`。"

#: ../../library/configparser.rst:283
msgid ""
"The first section name may be omitted if the parser is configured to allow "
"an unnamed top level section with ``allow_unnamed_section=True``. In this "
"case, the keys/values may be retrieved by :const:`UNNAMED_SECTION` as in "
"``config[UNNAMED_SECTION]``."
msgstr ""
"如果解析器通过 ``allow_unnamed_section=True`` 被配置为允许未命名的最高层级小节则第一个小节的名称可以省略。 "
"在这种情况下，键/值可以通过 :const:`UNNAMED_SECTION` 来获取例如 ``config[UNNAMED_SECTION]``。"

#: ../../library/configparser.rst:288
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"配置文件可以包含注释，要带有指定字符前缀 (默认为 ``#`` 和 ``;`` [1]_)。 注释可以单独出现于原本的空白行，并可使用缩进。 [1]_"

#: ../../library/configparser.rst:292 ../../library/configparser.rst:376
msgid "For example:"
msgstr "例如:"

#: ../../library/configparser.rst:294
msgid ""
"[Simple Values]\n"
"key=value\n"
"spaces in keys=allowed\n"
"spaces in values=allowed as well\n"
"spaces around the delimiter = obviously\n"
"you can also use : to delimit keys from values\n"
"\n"
"[All Values Are Strings]\n"
"values like this: 1000000\n"
"or this: 3.14159265359\n"
"are they treated as numbers? : no\n"
"integers, floats and booleans are held as: strings\n"
"can use the API to get converted values directly: true\n"
"\n"
"[Multiline Values]\n"
"chorus: I'm a lumberjack, and I'm okay\n"
"    I sleep all night and I work all day\n"
"\n"
"[No Values]\n"
"key_without_value\n"
"empty string value here =\n"
"\n"
"[You can use comments]\n"
"# like this\n"
"; or this\n"
"\n"
"# By default only in an empty line.\n"
"# Inline comments can be harmful because they prevent users\n"
"# from using the delimiting characters as parts of values.\n"
"# That being said, this can be customized.\n"
"\n"
"    [Sections Can Be Indented]\n"
"        can_values_be_as_well = True\n"
"        does_that_mean_anything_special = False\n"
"        purpose = formatting for readability\n"
"        multiline_values = are\n"
"            handled just fine as\n"
"            long as they are indented\n"
"            deeper than the first line\n"
"            of a value\n"
"        # Did I mention we can indent comments, too?"
msgstr ""
"[Simple Values]\n"
"key=value\n"
"spaces in keys=allowed\n"
"spaces in values=allowed as well\n"
"spaces around the delimiter = obviously\n"
"you can also use : to delimit keys from values\n"
"\n"
"[All Values Are Strings]\n"
"values like this: 1000000\n"
"or this: 3.14159265359\n"
"are they treated as numbers? : no\n"
"integers, floats and booleans are held as: strings\n"
"can use the API to get converted values directly: true\n"
"\n"
"[Multiline Values]\n"
"chorus: I'm a lumberjack, and I'm okay\n"
"    I sleep all night and I work all day\n"
"\n"
"[No Values]\n"
"key_without_value\n"
"empty string value here =\n"
"\n"
"[You can use comments]\n"
"# like this\n"
"; or this\n"
"\n"
"# By default only in an empty line.\n"
"# Inline comments can be harmful because they prevent users\n"
"# from using the delimiting characters as parts of values.\n"
"# That being said, this can be customized.\n"
"\n"
"    [Sections Can Be Indented]\n"
"        can_values_be_as_well = True\n"
"        does_that_mean_anything_special = False\n"
"        purpose = formatting for readability\n"
"        multiline_values = are\n"
"            handled just fine as\n"
"            long as they are indented\n"
"            deeper than the first line\n"
"            of a value\n"
"        # Did I mention we can indent comments, too?"

#: ../../library/configparser.rst:342
msgid "Unnamed Sections"
msgstr "未命名小节"

#: ../../library/configparser.rst:344
msgid ""
"The name of the first section (or unique) may be omitted and values "
"retrieved by the :const:`UNNAMED_SECTION` attribute."
msgstr "第一（或唯一）小节的名称可以省略并且其值可通过 :const:`UNNAMED_SECTION` 属性来获取。"

#: ../../library/configparser.rst:347
msgid ""
">>> config = \"\"\"\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> unnamed = configparser.ConfigParser(allow_unnamed_section=True)\n"
">>> unnamed.read_string(config)\n"
">>> unnamed.get(configparser.UNNAMED_SECTION, 'option')\n"
"'value'"
msgstr ""
">>> config = \"\"\"\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> unnamed = configparser.ConfigParser(allow_unnamed_section=True)\n"
">>> unnamed.read_string(config)\n"
">>> unnamed.get(configparser.UNNAMED_SECTION, 'option')\n"
"'value'"

#: ../../library/configparser.rst:361
msgid "Interpolation of values"
msgstr "值的插值"

#: ../../library/configparser.rst:363
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr "在核心功能之上，:class:`ConfigParser` 还支持插值。 这意味着值可以在被 ``get()`` 调用返回之前进行预处理。"

#: ../../library/configparser.rst:371
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values"
" to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"默认实现由 :class:`ConfigParser` 来使用。 它允许值包含引用了相同小节中其他值或者特殊的默认小节中的值的格式字符串 [1]_。 "
"额外的默认值可以在初始化时提供。"

#: ../../library/configparser.rst:378
msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Pictures\n"
"\n"
"[Escape]\n"
"# use a %% to escape the % sign (% is the only character that needs to be escaped):\n"
"gain: 80%%"
msgstr ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Pictures\n"
"\n"
"[Escape]\n"
"# use a %% to escape the % sign (% is the only character that needs to be escaped):\n"
"gain: 80%%"

#: ../../library/configparser.rst:389
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"在上面的例子里，:class:`ConfigParser` 的 *interpolation* 设为 "
"``BasicInterpolation()``，这会将 ``%(home_dir)s`` 求解为 ``home_dir`` 的值 (在这里是 "
"``/Users``)。 ``%(my_dir)s`` 的将被实际求解为 ``/Users/lumberjack``。 "
"所有插值都是按需进行的，这样引用链中使用的键不必以任何特定顺序在配置文件中指明。"

#: ../../library/configparser.rst:396
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and "
"``%(home_dir)s/lumberjack`` as the value of ``my_dir``."
msgstr ""
"当 ``interpolation`` 设为 ``None`` 时，解析器会简单地返回 ``%(my_dir)s/Pictures`` 作为 "
"``my_pictures`` 的值，并返回 ``%(home_dir)s/lumberjack`` 作为 ``my_dir`` 的值。"

#: ../../library/configparser.rst:404
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the "
"``section:`` part is omitted, interpolation defaults to the current section "
"(and possibly the default values from the special section)."
msgstr ""
"一个用于插值的替代处理程序实现了更高级的语法，它被用于 ``zc.buildout`` 中的实例。 扩展插值使用 "
"``${section:option}`` 来表示来自外部小节的值。 插值可以跨越多个层级。 为了方便使用，``section:`` "
"部分可被省略，插值会默认作用于当前小节（可能会从特殊小节获取默认值）。"

#: ../../library/configparser.rst:411
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr "例如，上面使用基本插值描述的配置，使用扩展插值将是这个样子:"

#: ../../library/configparser.rst:414
msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: ${home_dir}/lumberjack\n"
"my_pictures: ${my_dir}/Pictures\n"
"\n"
"[Escape]\n"
"# use a $$ to escape the $ sign ($ is the only character that needs to be escaped):\n"
"cost: $$80"
msgstr ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: ${home_dir}/lumberjack\n"
"my_pictures: ${my_dir}/Pictures\n"
"\n"
"[Escape]\n"
"# use a $$ to escape the $ sign ($ is the only character that needs to be escaped):\n"
"cost: $$80"

#: ../../library/configparser.rst:425
msgid "Values from other sections can be fetched as well:"
msgstr "来自其他小节的值也可以被获取:"

#: ../../library/configparser.rst:427
msgid ""
"[Common]\n"
"home_dir: /Users\n"
"library_dir: /Library\n"
"system_dir: /System\n"
"macports_dir: /opt/local\n"
"\n"
"[Frameworks]\n"
"Python: 3.2\n"
"path: ${Common:system_dir}/Library/Frameworks/\n"
"\n"
"[Arthur]\n"
"nickname: Two Sheds\n"
"last_name: Jackson\n"
"my_dir: ${Common:home_dir}/twosheds\n"
"my_pictures: ${my_dir}/Pictures\n"
"python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}"
msgstr ""
"[Common]\n"
"home_dir: /Users\n"
"library_dir: /Library\n"
"system_dir: /System\n"
"macports_dir: /opt/local\n"
"\n"
"[Frameworks]\n"
"Python: 3.2\n"
"path: ${Common:system_dir}/Library/Frameworks/\n"
"\n"
"[Arthur]\n"
"nickname: Two Sheds\n"
"last_name: Jackson\n"
"my_dir: ${Common:home_dir}/twosheds\n"
"my_pictures: ${my_dir}/Pictures\n"
"python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}"

#: ../../library/configparser.rst:447
msgid "Mapping Protocol Access"
msgstr "映射协议访问"

#: ../../library/configparser.rst:451
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of "
":mod:`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"映射协议访问这个通用名称是指允许以字典的方式来使用自定义对象的功能。 在 :mod:`configparser` 中，映射接口的实现使用了 "
"``parser['section']['option']`` 标记法。"

#: ../../library/configparser.rst:456
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken"
" from the original parser on demand.  What's even more important is that "
"when values are changed on a section proxy, they are actually mutated in the"
" original parser."
msgstr ""
"``parser['section']`` 专门为解析器中的小节数据返回一个代理。 这意味着其中的值不会被拷贝，而是在需要时从原始解析器中获取。 "
"更为重要的是，当值在小节代理上被修改时，它们其实是在原始解析器中发生了改变。"

#: ../../library/configparser.rst:462
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the "
":class:`~collections.abc.MutableMapping` ABC. However, there are a few "
"differences that should be taken into account:"
msgstr ""
":mod:`configparser` 对象的行为会尽可能地接近真正的字典。 映射接口是完整而且遵循 "
":class:`~collections.abc.MutableMapping` ABC 规范的。 但是，还是有一些差异应当被纳入考虑:"

#: ../../library/configparser.rst:467
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner"
" [1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by default."
"  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"默认情况下，小节中的所有键是以大小写不敏感的方式来访问的 [1]_。 例如 ``for option in parser[\"section\"]`` "
"只会产生 ``optionxform`` 形式的选项键名称。 也就是说默认使用小写字母键名。 与此同时，对于一个包含键 ``'a'`` "
"的小节，以下两个表达式均将返回 ``True``::"

#: ../../library/configparser.rst:472
msgid ""
"\"a\" in parser[\"section\"]\n"
"\"A\" in parser[\"section\"]"
msgstr ""
"\"a\" in parser[\"section\"]\n"
"\"A\" in parser[\"section\"]"

#: ../../library/configparser.rst:475
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that "
"``.clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"所有小节也包括 ``DEFAULTSECT``，这意味着对一个小节执行 ``.clear()`` 可能无法使得该小节显示为空。 "
"这是因为默认值是无法从小节中被删除的（因为从技术上说它们并不在那里）。 如果它们在小节中被覆盖，删除将导致默认值重新变为可见。 尝试删除默认值将会引发 "
":exc:`KeyError`。"

#: ../../library/configparser.rst:482
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` 无法从解析器中被移除:"

#: ../../library/configparser.rst:484
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "尝试删除将引发 :exc:`ValueError`，"

#: ../../library/configparser.rst:486
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` 会保留其原状，"

#: ../../library/configparser.rst:488
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` 绝不会将其返回。"

#: ../../library/configparser.rst:490
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a"
" fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - 第二个参数 **并非** 回退值。 但是请注意小节层级的 "
"``get()`` 方法可同时兼容映射协议和经典配置解析器 API。"

#: ../../library/configparser.rst:494
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: "
"``parser.items(section, raw, vars)``.  The latter call returns a list of "
"*option*, *value* pairs for a specified ``section``, with all interpolations"
" expanded (unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` 兼容映射协议（返回 *section_name*, *section_proxy* 对的列表，包括 "
"DEFAULTSECT）。 但是，此方法也可以附带参数被唤起: ``parser.items(section, raw, vars)``。 "
"这种调用形式返回指定 ``section`` 的 *option*, *value* 对的列表，将展开所有插值（除非提供了 ``raw=True`` "
"选项）。"

#: ../../library/configparser.rst:501
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings"
" working as expected."
msgstr "映射协议是在现有的传统 API 之上实现的，以便重写原始接口的子类仍然具有符合预期的有效映射。"

#: ../../library/configparser.rst:507
msgid "Customizing Parser Behaviour"
msgstr "定制解析器行为"

#: ../../library/configparser.rst:509
msgid ""
"There are nearly as many INI format variants as there are applications using"
" it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to"
" customize some of the features."
msgstr ""
"INI 格式的变种数量几乎和使用此格式的应用一样多。 :mod:`configparser` 花费了很大力气来为尽量大范围的可用 INI 样式提供支持。"
" 默认的可用功能主要由历史状况来确定，你很可能会想要定制某些特性。"

#: ../../library/configparser.rst:515
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`!__init__` options:"
msgstr "改变特定配置解析器行为的最常见方式是使用 :meth:`!__init__` 选项："

#: ../../library/configparser.rst:518
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*，默认值: ``None``"

#: ../../library/configparser.rst:520
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"此选项接受一个键值对的字典，它将被首先放入 ``DEFAULT`` 小节。 "
"这实现了一种优雅的方式来支持简洁的配置文件，它不必指定与已记录的默认值相同的值。"

#: ../../library/configparser.rst:525
msgid ""
"Hint: if you want to specify default values for a specific section, use "
":meth:`~ConfigParser.read_dict` before you read the actual file."
msgstr "提示：如果你想要为特定的节指定默认值，请在读取实际文件之前 使用 :meth:`~ConfigParser.read_dict`。"

#: ../../library/configparser.rst:528
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*，默认值: :class:`dict`"

#: ../../library/configparser.rst:530
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr "此选项主要影响映射协议的行为和写入配置文件的外观。 使用标准字典时，每个小节是按照它们被加入解析器的顺序保存的。 在小节内的选项也是如此。"

#: ../../library/configparser.rst:535
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr "还有其他替换的字典类型可以使用，例如在写回数据时对小节和选项进行排序。"

#: ../../library/configparser.rst:538
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order"
" of the keys will be ordered.  For example:"
msgstr "请注意：存在其他方式只用一次操作来添加键值对的集合。 当你在这些操作中使用一个常规字典时，键将按顺序进行排列。 例如:"

#: ../../library/configparser.rst:542
msgid ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [option for option in parser['section3']]\n"
"['foo', 'bar', 'baz']"
msgstr ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [option for option in parser['section3']]\n"
"['foo', 'bar', 'baz']"

#: ../../library/configparser.rst:560
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*，默认值: ``False``"

#: ../../library/configparser.rst:562
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The"
" *allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"已知某些配置文件会包括不带值的设置，但其在其他方面均符合 :mod:`configparser` 所支持的语法。 构造器的 "
"*allow_no_value* 形参可用于指明应当接受这样的值:"

#: ../../library/configparser.rst:567
msgid ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # we don't need ACID today\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # Settings with values are treated as before:\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # Settings without values provide None:\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # Settings which aren't specified still raise an error:\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"
msgstr ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # we don't need ACID today\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # 有值的设置像之前一样处理：\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # 没有值的设置将为 None：\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # 未指定的设置仍将引发错误：\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"

#: ../../library/configparser.rst:597
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*，默认值: ``('=', ':')``"

#: ../../library/configparser.rst:599
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr "分隔符是用于在小节内分隔键和值的子字符串。 在一行中首次出现的分隔子字符串会被视为一个分隔符。 这意味着值可以包含分隔符（但键不可以）。"

#: ../../library/configparser.rst:603
msgid ""
"See also the *space_around_delimiters* argument to "
":meth:`ConfigParser.write`."
msgstr "另请参见 :meth:`ConfigParser.write` 的 *space_around_delimiters* 参数。"

#: ../../library/configparser.rst:606
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*，默认值: ``('#', ';')``"

#: ../../library/configparser.rst:608
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*，默认值: ``None``"

#: ../../library/configparser.rst:610
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"注释前缀是配置文件中用于标示一条有效注释的开头的字符串。 *comment_prefixes* 仅用在被视为空白的行（可以缩进）之前而 "
"*inline_comment_prefixes* 可用在每个有效值之后（例如小节名称、选项以及空白的行）。 默认情况下禁用行内注释，并且 "
"``'#'`` 和 ``';'`` 都被用作完整行注释的前缀。"

#: ../../library/configparser.rst:617
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"在之前的 :mod:`configparser` 版本中行为匹配 ``comment_prefixes=('#',';')`` 和 "
"``inline_comment_prefixes=(';',)``。"

#: ../../library/configparser.rst:621
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"请注意配置解析器不支持对注释前缀的转义，因此使用 *inline_comment_prefixes* 可能妨碍用户将被用作注释前缀的字符指定为可选值。 "
"当有疑问时，请避免设置 *inline_comment_prefixes*。 "
"在许多情况下，在多行值的一行开头存储注释前缀字符的唯一方式是进行前缀插值，例如::"

#: ../../library/configparser.rst:628
msgid ""
">>> from configparser import ConfigParser, ExtendedInterpolation\n"
">>> parser = ConfigParser(interpolation=ExtendedInterpolation())\n"
">>> # the default BasicInterpolation could be used as well\n"
">>> parser.read_string(\"\"\"\n"
"... [DEFAULT]\n"
"... hash = #\n"
"...\n"
"... [hashes]\n"
"... shebang =\n"
"...   ${hash}!/usr/bin/env python\n"
"...   ${hash} -*- coding: utf-8 -*-\n"
"...\n"
"... extensions =\n"
"...   enabled_extension\n"
"...   another_extension\n"
"...   #disabled_by_comment\n"
"...   yet_another_extension\n"
"...\n"
"... interpolation not necessary = if # is not at line start\n"
"... even in multiline values = line #1\n"
"...   line #2\n"
"...   line #3\n"
"... \"\"\")\n"
">>> print(parser['hashes']['shebang'])\n"
"\n"
"#!/usr/bin/env python\n"
"# -*- coding: utf-8 -*-\n"
">>> print(parser['hashes']['extensions'])\n"
"\n"
"enabled_extension\n"
"another_extension\n"
"yet_another_extension\n"
">>> print(parser['hashes']['interpolation not necessary'])\n"
"if # is not at line start\n"
">>> print(parser['hashes']['even in multiline values'])\n"
"line #1\n"
"line #2\n"
"line #3"
msgstr ""
">>> from configparser import ConfigParser, ExtendedInterpolation\n"
">>> parser = ConfigParser(interpolation=ExtendedInterpolation())\n"
">>> # 默认的 BasicInterpolation 也同样可用\n"
">>> parser.read_string(\"\"\"\n"
"... [DEFAULT]\n"
"... hash = #\n"
"...\n"
"... [hashes]\n"
"... shebang =\n"
"...   ${hash}!/usr/bin/env python\n"
"...   ${hash} -*- coding: utf-8 -*-\n"
"...\n"
"... extensions =\n"
"...   enabled_extension\n"
"...   another_extension\n"
"...   #disabled_by_comment\n"
"...   yet_another_extension\n"
"...\n"
"... interpolation not necessary = if # is not at line start\n"
"... even in multiline values = line #1\n"
"...   line #2\n"
"...   line #3\n"
"... \"\"\")\n"
">>> print(parser['hashes']['shebang'])\n"
"\n"
"#!/usr/bin/env python\n"
"# -*- coding: utf-8 -*-\n"
">>> print(parser['hashes']['extensions'])\n"
"\n"
"enabled_extension\n"
"another_extension\n"
"yet_another_extension\n"
">>> print(parser['hashes']['interpolation not necessary'])\n"
"if # is not at line start\n"
">>> print(parser['hashes']['even in multiline values'])\n"
"line #1\n"
"line #2\n"
"line #3"

#: ../../library/configparser.rst:667
msgid "*strict*, default value: ``True``"
msgstr "*strict*，默认值: ``True``"

#: ../../library/configparser.rst:669
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using "
":meth:`~ConfigParser.read_file`, :meth:`~ConfigParser.read_string` or "
":meth:`~ConfigParser.read_dict`).  It is recommended to use strict parsers "
"in new applications."
msgstr ""
"当设为 ``True`` 时，解析器在从单一源读取 (使用 :meth:`~ConfigParser.read_file`, "
":meth:`~ConfigParser.read_string` 或 :meth:`~ConfigParser.read_dict`) "
"期间将不允许任何节或选项出现重复。 推荐在新的应用中使用严格解析器。"

#: ../../library/configparser.rst:674
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr "在之前的 :mod:`configparser` 版本中行为匹配 ``strict=False``。"

#: ../../library/configparser.rst:678
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*，默认值: ``True``"

#: ../../library/configparser.rst:680
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"在配置解析器中，值可以包含多行，只要它们的缩进级别低于它们所对应的键。 默认情况下解析器还会将空行视为值的一部分。 "
"于此同时，键本身也可以任意缩进以提升可读性。 因此，当配置文件变得非常庞大而复杂时，用户很容易失去对文件结构的掌控。 例如:"

#: ../../library/configparser.rst:687
msgid ""
"[Section]\n"
"key = multiline\n"
"  value with a gotcha\n"
"\n"
" this = is still a part of the multiline value of 'key'"
msgstr ""
"[Section]\n"
"key = multiline\n"
"  value with a gotcha\n"
"\n"
" this = is still a part of the multiline value of 'key'"

#: ../../library/configparser.rst:695
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"在用户查看时这可能会特别有问题，如果她是使用比例字体来编辑文件的话。 这就是为什么当你的应用不需要带有空行的值时，你应该考虑禁用它们。 "
"这将使得空行每次都会作为键之间的分隔。 在上面的示例中，空行产生了两个键，``key`` 和 ``this``。"

#: ../../library/configparser.rst:701
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr "*default_section*，默认值: ``configparser.DEFAULTSECT`` (即: ``\"DEFAULT\"``)"

#: ../../library/configparser.rst:704
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the "
"``parser_instance.default_section`` attribute and may be modified at runtime"
" (i.e. to convert files from one format to another)."
msgstr ""
"允许设置一个保存默认值的特殊节在其他节或插值等目的中使用的惯例是这个库所拥有的一个强大概念，使得用户能够创建复杂的声明性配置。 这种特殊节通常称为 "
"``\"DEFAULT\"`` 但也可以被定制为指向任何其他有效的节名称。 一些典型的值包括: ``\"general\"`` 或 "
"``\"common\"``。 所提供的名称在从任意节读取的时候被用于识别默认的节，而且也会在将配置写回文件时被使用。 它的当前值可以使用 "
"``parser_instance.default_section`` 属性来获取，并且可以在运行时被修改（即将文件从一种格式转换为另一种格式）。"

#: ../../library/configparser.rst:715
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*interpolation*，默认值: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:717
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. "
":class:`RawConfigParser` has a default value of ``None``."
msgstr ""
"插值行为可以用通过提供 *interpolation* 参数提供自定义处理程序的方式来定制。 ``None`` "
"可用来完全禁用插值，``ExtendedInterpolation()`` 提供了一种更高级的变体形式，它的设计受到了 ``zc.buildout`` "
"的启发。 有关该主题的更多信息请参见 `专门的文档章节 <#interpolation-of-values>`_。 "
":class:`RawConfigParser` 具有默认的值 ``None``。"

#: ../../library/configparser.rst:724
msgid "*converters*, default value: not set"
msgstr "*converters*，默认值: 不设置"

#: ../../library/configparser.rst:726
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, and"
" :meth:`~ConfigParser.getboolean` are implemented.  Should other getters be "
"desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': "
"decimal.Decimal}`` would add :meth:`!getdecimal` on both the parser object "
"and all section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"配置解析器提供了可选的值获取方法用来执行类型转换。 默认情况下实现了 :meth:`~ConfigParser.getint`, "
":meth:`~ConfigParser.getfloat` 和 :meth:`~ConfigParser.getboolean`。 "
"如果还需要其他获取方法，用户可以在子类中定义它们，或者传入一个字典，其中每个键都是一个转换器的名称而每个值都是一个实现了特定转换的可调用对象。 "
"例如，传入 ``{'decimal': decimal.Decimal}`` 将对解释器对象和所有节代理添加 :meth:`!getdecimal`。 "
"换句话说，可以同时编写 ``parser_instance.getdecimal('section', 'key', fallback=0)`` 和 "
"``parser_instance['section'].getdecimal('key', 0)``。"

#: ../../library/configparser.rst:737
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"如果转换器需要访问解析器的状态，可以在配置解析器子类上作为一个方法来实现。 如果该方法的名称是以 ``get`` "
"打头的，它将在所有节代理上以兼容字典的形式提供（参见上面的 ``getdecimal()`` 示例）。"

#: ../../library/configparser.rst:742
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr "更多高级定制选项可通过重写这些解析器属性的默认值来达成。 默认值是在类中定义的，因此它们可以通过子类或属性赋值来重写。"

#: ../../library/configparser.rst:748
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``,"
" ``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"默认情况下当使用 :meth:`~ConfigParser.getboolean` 时，配置解析器会将下列值视为 ``True``: ``'1'``, "
"``'yes'``, ``'true'``, ``'on'`` 而将下列值视为 ``False``: ``'0'``, ``'no'``, "
"``'false'``, ``'off'``。 你可以通过指定一个自定义的字符串键及其对应的布尔值字典来覆盖此行为。 例如:"

#: ../../library/configparser.rst:754
msgid ""
">>> custom = configparser.ConfigParser()\n"
">>> custom['section1'] = {'funky': 'nope'}\n"
">>> custom['section1'].getboolean('funky')\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Not a boolean: nope\n"
">>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}\n"
">>> custom['section1'].getboolean('funky')\n"
"False"
msgstr ""
">>> custom = configparser.ConfigParser()\n"
">>> custom['section1'] = {'funky': 'nope'}\n"
">>> custom['section1'].getboolean('funky')\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Not a boolean: nope\n"
">>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}\n"
">>> custom['section1'].getboolean('funky')\n"
"False"

#: ../../library/configparser.rst:766
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or "
"``enabled``/``disabled``."
msgstr "其他典型的布尔值对包括 ``accept``/``reject`` 或 ``enabled``/``disabled``。"

#: ../../library/configparser.rst:772
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"这个方法会转换每次 read, get, 或 set 操作的选项名称。 默认会将名称转换为小写形式。 "
"这也意味着当一个配置文件被写入时，所有键都将为小写形式。 如果此行为不合适则要重写此方法。 例如:"

#: ../../library/configparser.rst:778
msgid ""
">>> config = \"\"\"\n"
"... [Section1]\n"
"... Key = Value\n"
"...\n"
"... [Section2]\n"
"... AnotherKey = Value\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> custom = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"
msgstr ""
">>> config = \"\"\"\n"
"... [Section1]\n"
"... Key = Value\n"
"...\n"
"... [Section2]\n"
"... AnotherKey = Value\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> custom = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"

#: ../../library/configparser.rst:802
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr "optionxform 函数会将选项名称转换为规范形式。 这应该是一个幂等函数：如果名称已经为规范形式，则应不加修改地将其返回。"

#: ../../library/configparser.rst:809
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered"
" part of the section name, thus ``[  larch  ]`` will be read as a section of"
" name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For"
" example:"
msgstr ""
"一个已编译正则表达式会被用来解析节标头。 默认将 ``[section]`` 匹配到名称 ``\"section\"``。 "
"空格会被视为节名称的一部分，因此 ``[  larch  ]`` 将被读取为一个名称为 ``\"  larch  \"`` 的节。 "
"如果此行为不合适则要覆盖此属性。 例如:"

#: ../../library/configparser.rst:815
msgid ""
">>> import re\n"
">>> config = \"\"\"\n"
"... [Section 1]\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> typical.sections()\n"
"['Section 1', '  Section 2  ']\n"
">>> custom = configparser.ConfigParser()\n"
">>> custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
">>> custom.read_string(config)\n"
">>> custom.sections()\n"
"['Section 1', 'Section 2']"
msgstr ""
">>> import re\n"
">>> config = \"\"\"\n"
"... [Section 1]\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> typical.sections()\n"
"['Section 1', '  Section 2  ']\n"
">>> custom = configparser.ConfigParser()\n"
">>> custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
">>> custom.read_string(config)\n"
">>> custom.sections()\n"
"['Section 1', 'Section 2']"

#: ../../library/configparser.rst:837
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"虽然 ConfigParser 对象也使用 ``OPTCRE`` 属性来识别选项行，但并不推荐重写它，因为这会与构造器选项 "
"*allow_no_value* 和 *delimiters* 产生冲突。"

#: ../../library/configparser.rst:843
msgid "Legacy API Examples"
msgstr "旧式 API 示例"

#: ../../library/configparser.rst:845
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"主要出于向下兼容性的考虑，:mod:`configparser` 还提供了一种采用显式 ``get``/``set`` 方法的旧式 API。 "
"虽然以下介绍的方法存在有效的用例，但对于新项目仍建议采用映射协议访问。 旧式 API 在多数时候都更复杂、更底层并且完全违反直觉。"

#: ../../library/configparser.rst:851
msgid "An example of writing to a configuration file::"
msgstr "一个写入配置文件的示例::"

#: ../../library/configparser.rst:853
msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"\n"
"# Please note that using RawConfigParser's set functions, you can assign\n"
"# non-string values to keys internally, but will receive an error when\n"
"# attempting to write to a file or when you get it in non-raw mode. Setting\n"
"# values using the mapping protocol or ConfigParser's set() does not allow\n"
"# such assignments to take place.\n"
"config.add_section('Section1')\n"
"config.set('Section1', 'an_int', '15')\n"
"config.set('Section1', 'a_bool', 'true')\n"
"config.set('Section1', 'a_float', '3.1415')\n"
"config.set('Section1', 'baz', 'fun')\n"
"config.set('Section1', 'bar', 'Python')\n"
"config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n"
"\n"
"# Writing our configuration file to 'example.cfg'\n"
"with open('example.cfg', 'w') as configfile:\n"
"    config.write(configfile)"
msgstr ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"\n"
"# 请注意在使用 RawConfigParser 的 set 函数时，\n"
"# 你可以在内部为键赋非字符串值，但当你试图\n"
"# 写入文件或在非原始模式下获取它时将会报错。 \n"
"# 使用映射协议或 ConfigParser 的 set() 设置值时\n"
"# 不允许执行这样的赋值。\n"
"config.add_section('Section1')\n"
"config.set('Section1', 'an_int', '15')\n"
"config.set('Section1', 'a_bool', 'true')\n"
"config.set('Section1', 'a_float', '3.1415')\n"
"config.set('Section1', 'baz', 'fun')\n"
"config.set('Section1', 'bar', 'Python')\n"
"config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n"
"\n"
"# 将我们的配置文件写入 'example.cfg'\n"
"with open('example.cfg', 'w') as configfile:\n"
"    config.write(configfile)"

#: ../../library/configparser.rst:874
msgid "An example of reading the configuration file again::"
msgstr "一个再次读取配置文件的示例::"

#: ../../library/configparser.rst:876
msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() raises an exception if the value is not a float\n"
"# getint() and getboolean() also do this for their respective types\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.\n"
"# This is because we are using a RawConfigParser().\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"
msgstr ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() 在值不为浮点数时将引发异常\n"
"# getint() 和 getboolean() 对其相应类型也是如此\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# 请注意下面的输出不会执行 '%(bar)s' 或 '%(baz)s' 插值。\n"
"# 这是因为我们是使用 RawConfigParser()。\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"

#: ../../library/configparser.rst:892
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "要获取插值，请使用 :class:`ConfigParser`::"

#: ../../library/configparser.rst:894
msgid ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# Set the optional *raw* argument of get() to True if you wish to disable\n"
"# interpolation in a single get operation.\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# The optional *vars* argument is a dict with members that will take\n"
"# precedence in interpolation.\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# The optional *fallback* argument can be used to provide a fallback value\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError\n"
"# but we can also use:\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"
msgstr ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# 如果你想要在一个单独的 get 操作中禁用插值\n"
"# 可将 get() 的可选参数 *raw* 设为 True。\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# 可选参数 *vars* 是一个字典，其中的元素将在\n"
"# 插值中优先使用。\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# 可选参数 *fallback* 可被用来提供一个回退值\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# 直接使用 print(cfg.get('Section1', 'monster')) 将会引发 NoOptionError\n"
"# 但我们还可以使用：\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"

#: ../../library/configparser.rst:925
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr "默认值在两种类型的 ConfigParser 中均可用。 它们将在当某个选项未在别处定义时被用于插值。 ::"

#: ../../library/configparser.rst:928
msgid ""
"import configparser\n"
"\n"
"# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""
msgstr ""
"import configparser\n"
"\n"
"# 'bar' 和 'baz' 分别默认为 'Life' 和 'hard' 的新实例\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""

#: ../../library/configparser.rst:943
msgid "ConfigParser Objects"
msgstr "ConfigParser 对象"

#: ../../library/configparser.rst:953
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"主配置解析器。 当给定 *defaults* 时，它会被初始化为包含固有默认值的字典。 当给定 *dict_type* "
"时，它将被用来创建包含节、节中的选项以及默认值的字典。"

#: ../../library/configparser.rst:958
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"当给定 *delimiters* 时，它会被用作分隔键与值的子字符串的集合。 当给定 *comment_prefixes* "
"时，它将被用作在否则为空行的注释的前缀子字符串的集合。 注释可以被缩进。 当给定 *inline_comment_prefixes* "
"时，它将被用作非空行的注释的前缀子字符串的集合。"

#: ../../library/configparser.rst:964
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or "
":exc:`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` "
"(default: ``True``), each empty line marks the end of an option.  Otherwise,"
" internal empty lines of a multiline option are kept as part of the value. "
"When *allow_no_value* is ``True`` (default: ``False``), options without "
"values are accepted; the value held for these is ``None`` and they are "
"serialized without the trailing delimiter."
msgstr ""
"当 *strict* 为 ``True`` (默认值) 时，解析器在从单个源（文件、字符串或字典）读取时将不允许任何节或选项出现重复，否则会引发 "
":exc:`DuplicateSectionError` 或 :exc:`DuplicateOptionError`。 当 "
"*empty_lines_in_values* 为 ``False`` (默认值: ``True``) 时，每个空行均表示一个选项的结束。 "
"在其他情况下，一个多行选项内部的空行会被保留为值的一部分。 当 *allow_no_value* 为 ``True`` (默认值: ``False``)"
" 时，将接受没有值的选项；此种选项的值将为 ``None`` 并且它们会以不带末尾分隔符的形式被序列化。"

#: ../../library/configparser.rst:974
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes"
" (normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"at runtime using the ``default_section`` instance attribute. This won't re-"
"evaluate an already parsed config file, but will be used when writing parsed"
" settings to a new config file."
msgstr ""
"当给出 *default_section* 时，它指定了为其他部分和插值目的而保存默认值的特殊部分的名称 (通常命名为 "
"``\"DEFAULT\"``)。 该值可通过使用 ``default_section`` 实例属性在运行时被读取或修改值。 "
"这不会对已解析的配置文件进行重新求值，但会在将解析的设置写入新的配置文件时使用。"

#: ../../library/configparser.rst:981
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"插值行为可通过给出 *interpolation* 参数提供自定义处理程序的方式来定制。 ``None`` "
"可用来完全禁用插值，``ExtendedInterpolation()`` 提供了一种更高级的变体形式，它的设计受到了 ``zc.buildout`` "
"的启发。 有关该主题的更多信息请参见 `专门的文档章节 <#interpolation-of-values>`_。"

#: ../../library/configparser.rst:987
msgid ""
"All option names used in interpolation will be passed through the "
":meth:`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"插值中使用的所有选项名称将像任何其他选项名称引用一样通过 :meth:`optionxform` 方法来传递。 例如，使用 "
":meth:`optionxform` 的默认实现（它会将选项名称转换为小写形式）时，值 ``foo %(bar)s`` 和 ``foo "
"%(BAR)s`` 是等价的。"

#: ../../library/configparser.rst:993
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`!get*` method on the parser "
"object and section proxies."
msgstr ""
"当给出 *converters* 时，它应当是一个字典，其中每个键代表一个类型转换器的名称而每个值则为实现从字符串到目标数据类型的转换的可调用对象。 "
"每个转换器会获得其在解析器对象和节代理上对应的 :meth:`!get*` 方法。"

#: ../../library/configparser.rst:999
msgid ""
"When *allow_unnamed_section* is ``True`` (default: ``False``), the first "
"section name can be omitted. See the `\"Unnamed Sections\" section "
"<#unnamed-sections>`_."
msgstr ""
"当 *allow_unnamed_section* 为 ``True`` 为 (默认值: ``False``)，第一个节名称可被省略。 参见 "
"`\"未命名节\" 一节 <#unnamed-sections>`_。"

#: ../../library/configparser.rst:1028
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "默认的 *dict_type* 为 :class:`collections.OrderedDict`。"

#: ../../library/configparser.rst:1031 ../../library/configparser.rst:1324
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"添加了 *allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* 以及 *interpolation*。"

#: ../../library/configparser.rst:1036 ../../library/configparser.rst:1329
msgid "The *converters* argument was added."
msgstr "添加了 *converters* 参数。"

#: ../../library/configparser.rst:1039
msgid ""
"The *defaults* argument is read with :meth:`read_dict`, providing consistent"
" behavior across the parser: non-string keys and values are implicitly "
"converted to strings."
msgstr ""
"*defaults* 参数将在 :meth:`read_dict` 时被读取，提供全解析器范围内一致的行为：非字符串类型的键和值会被隐式地转换为字符串。"

#: ../../library/configparser.rst:1044 ../../library/configparser.rst:1332
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr "默认的 *dict_type* 为 :class:`dict`，因为它现在会保留插入顺序。"

#: ../../library/configparser.rst:1048
msgid ""
"Raise a :exc:`MultilineContinuationError` when *allow_no_value* is ``True``,"
" and a key without a value is continued with an indented line."
msgstr ""
"当 *allow_no_value* 为 ``True`` 且没有值的键带有一个缩进的行时将会引发 "
":exc:`MultilineContinuationError`。"

#: ../../library/configparser.rst:1052 ../../library/configparser.rst:1336
msgid "The *allow_unnamed_section* argument was added."
msgstr "增加了 *allow_unnamed_section* 参数。"

#: ../../library/configparser.rst:1057
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "返回包含实例范围内默认值的字典。"

#: ../../library/configparser.rst:1062
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr "返回可用节的列表；*default section* 不包括在该列表中。"

#: ../../library/configparser.rst:1068
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"向实例添加一个名为 *section* 的节。 如果给定名称的节已存在，将会引发 :exc:`DuplicateSectionError`。 如果传入了"
" *default section* 名称，则会引发 :exc:`ValueError`。 节名称必须为字符串；如果不是则会引发 "
":exc:`TypeError`。"

#: ../../library/configparser.rst:1073
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "非字符串的节名称将引发 :exc:`TypeError`。"

#: ../../library/configparser.rst:1079
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr "指明相应名称的 *section* 是否存在于配置中。 *default section* 不包含在内。"

#: ../../library/configparser.rst:1085
msgid "Return a list of options available in the specified *section*."
msgstr "返回指定 *section* 中可用选项的列表。"

#: ../../library/configparser.rst:1090
msgid ""
"If the given *section* exists, and contains the given *option*, return "
":const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"如果给定的 *section* 存在并且包含给定的 *option* 则返回 :const:`True`；否则返回 :const:`False`。 "
"如果指定的 *section* 为 :const:`None` 或空字符串，则会使用 DEFAULT。"

#: ../../library/configparser.rst:1097
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr "尝试读取并解析一个包含文件名的可迭代对象，返回一个被成功解析的文件名列表。"

#: ../../library/configparser.rst:1100
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames*"
" cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"如果 *filenames* 为字符串、:class:`bytes` 对象或 :term:`path-like "
"object`，它会被当作单个文件来处理。 如果 *filenames* 中名称对应的某个文件无法被打开，该文件将被忽略。 "
"这样的设计使得你可以指定包含多个潜在配置文件位置的可迭代对象（例如当前目录、用户家目录以及某个系统级目录），存在于该可迭代对象中的所有配置文件都将被读取。"

#: ../../library/configparser.rst:1109
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using "
":meth:`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"如果名称对应的文件全都不存在，则 :class:`ConfigParser` 实例将包含一个空数据集。 一个要求从文件加载初始值的应用应当在调用 "
":meth:`read` 来获取任何可选文件之前使用 :meth:`read_file` 来加载所要求的一个或多个文件::"

#: ../../library/configparser.rst:1115
msgid ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"
msgstr ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"

#: ../../library/configparser.rst:1122
msgid ""
"Added the *encoding* parameter. Previously, all files were read using the "
"default encoding for :func:`open`."
msgstr "增加了 *encoding* 形参。 在之前版本中，所有文件都将使用 :func:`open` 的默认编码格式来读取。"

#: ../../library/configparser.rst:1126
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "*filenames* 形参接受一个 :term:`path-like object`。"

#: ../../library/configparser.rst:1129
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "*filenames* 形参接受一个 :class:`bytes` 对象。"

#: ../../library/configparser.rst:1135
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr "从 *f* 读取并解析配置数据，它必须是一个产生 Unicode 字符串的可迭代对象（例如以文本模式打开的文件）。"

#: ../../library/configparser.rst:1138
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`!name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"可选参数 *source* 指定要读取的文件名称。 如果未给出并且 *f* 具有 :attr:`!name` 属性，则该属性会被用作 "
"*source*；默认值为 ``'<???>'``。"

#: ../../library/configparser.rst:1142
msgid "Replaces :meth:`!readfp`."
msgstr "替代 :meth:`!readfp`。"

#: ../../library/configparser.rst:1147
msgid "Parse configuration data from a string."
msgstr "从字符串中解析配置数据。"

#: ../../library/configparser.rst:1149
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"可选参数 *source* 指定一个所传入字符串的上下文专属名称。 如果未给出，则会使用 ``'<string>'``。 这通常应为一个文件系统路径或 "
"URL。"

#: ../../library/configparser.rst:1158
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"从任意一个提供了类似于字典的 ``items()`` 方法的对象加载配置。 键为节名称，值为包含节中所出现的键和值的字典。 "
"如果所用的字典类型会保留顺序，则节和其中的键将按顺序加入。 值会被自动转换为字符串。"

#: ../../library/configparser.rst:1164
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr "可选参数 *source* 指定一个所传入字典的上下文专属名称。 如果未给出，则会使用 ``<dict>``。"

#: ../../library/configparser.rst:1167
msgid "This method can be used to copy state between parsers."
msgstr "此方法可被用于在解析器之间拷贝状态。"

#: ../../library/configparser.rst:1174
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"获取指定名称的 *section* 的一个 *option* 的值。 如果提供了 *vars*，则它必须为一个字典。 *option* 的查找顺序为 "
"*vars*（如果有提供）、*section* 以及 *DEFAULTSECT*。 如果未找到该键并且提供了 *fallback*，则它会被用作回退值。"
" 可以提供 ``None`` 作为 *fallback* 值。"

#: ../../library/configparser.rst:1180
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the"
" *raw* argument is true.  Values for interpolation keys are looked up in the"
" same manner as the option."
msgstr "所有 ``'%'`` 插值会在返回值中被展开，除非 *raw* 参数为真值。 插值键所使用的值会按与选项相同的方式来查找。"

#: ../../library/configparser.rst:1184
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially"
" when using the mapping protocol)."
msgstr ""
"*raw*, *vars* 和 *fallback* 都是仅限关键字参数，以防止用户试图使用第三个参数作业为 *fallback* "
"回退值（特别是在使用映射 协议的时候）。"

#: ../../library/configparser.rst:1192
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"将在指定 *section* 中的 *option* 强制转换为整数的便捷方法。 参见 :meth:`get` 获取对于 *raw*, *vars* 和"
" *fallback* 的解释。"

#: ../../library/configparser.rst:1199
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating-point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"将在指定 *section* 中的 *option* 强制转换为浮点数的便捷方法。 参见 :meth:`get` 获取对于 *raw*, *vars* "
"和 *fallback* 的解释。"

#: ../../library/configparser.rst:1206
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise "
":exc:`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"将在指定 *section* 中的 *option* 强制转换为布尔值的便捷方法。 请注意选项所接受的值为 ``'1'``, ``'yes'``, "
"``'true'`` 和 ``'on'``，它们会使得此方法返回 ``True``，以及 ``'0'``, ``'no'``, ``'false'`` "
"和 ``'off'``，它们会使得此方法返回 ``False``。 这些字符串值会以对大小写不敏感的方式被检测。 任何其他值都将导致引发 "
":exc:`ValueError`。 参见 :meth:`get` 获取对于 *raw*, *vars* 和 *fallback* 的解释。"

#: ../../library/configparser.rst:1219
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"当未给出 *section* 时，将返回由 *section_name*, *section_proxy* 对组成的列表，包括 DEFAULTSECT。"

#: ../../library/configparser.rst:1222
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the "
":meth:`get` method."
msgstr ""
"在其他情况下，将返回给定的 *section* 中的 option 的 *name*, *value* 对组成的列表。 可选参数具有与 "
":meth:`get` 方法的参数相同的含义。"

#: ../../library/configparser.rst:1226
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr "*vars* 中的条目将不在结果中出现。 之前的行为混淆了实际的解析器选项和为插值提供的变量。"

#: ../../library/configparser.rst:1234
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"如果给定的节存在，则将所给出的选项设为指定的值；在其他情况下将引发 :exc:`NoSectionError`。 *option* 和 *value* "
"必须为字符串；如果不是则将引发 :exc:`TypeError`。"

#: ../../library/configparser.rst:1241
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"将配置的表示形式写入指定的 :term:`file object`，该对象必须以文本模式打开（接受字符串）。 此表示形式可由将来的 "
":meth:`read` 调用进行解析。 如果 *space_around_delimiters* 为真值，键和值之前的分隔符两边将加上空格。"

#: ../../library/configparser.rst:1247
msgid ""
"Raises InvalidWriteError if this would write a representation which cannot "
"be accurately parsed by a future :meth:`read` call from this parser."
msgstr "如果这会写入一个无法被该解析器后续的 :meth:`read` 调用精确解析的表示形式则会引发 InvalidWriteError。"

#: ../../library/configparser.rst:1253
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"原始配置文件中的注释在写回配置时不会被保留。 具体哪些会被当作注释，取决于为 *comment_prefix* 和 "
"*inline_comment_prefix* 所指定的值。"

#: ../../library/configparser.rst:1261
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"将指定的 *option* 从指定的 *section* 中移除。 如果指定的节不存在则会引发 :exc:`NoSectionError`。 "
"如果要移除的选项存在则返回 :const:`True`；在其他情况下将返回 :const:`False`。"

#: ../../library/configparser.rst:1269
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr "从配置中移除指定的 *section*。 如果指定的节确实存在则返回 ``True``。 在其他情况下将返回 ``False``。"

#: ../../library/configparser.rst:1275
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"将选项名 *option* 转换为输入文件中的形式或客户端代码所传入的应当在内部结构中使用的形式。 默认实现将返回 *option* "
"的小写形式版本；子类可以重写此行为，或者客户端代码也可以在实例上设置一个具有此名称的属性来影响此行为。"

#: ../../library/configparser.rst:1281
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"你不需要子类化解析器来使用此方法，你也可以在一个实例上设置它，或使用一个接受字符串参数并返回字符串的函数。 例如将它设为 ``str`` "
"将使得选项名称变得大小写敏感::"

#: ../../library/configparser.rst:1286
msgid ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"
msgstr ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"

#: ../../library/configparser.rst:1289
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr "请注意当读取配置文件时，选项名称两边的空格将在调用 :meth:`optionxform` 之前被去除。"

#: ../../library/configparser.rst:1295
msgid ""
"A special object representing a section name used to reference the unnamed "
"section (see :ref:`unnamed-sections`)."
msgstr "一个代表用于引用未命名小节的小节名称的特殊对象 (参见 :ref:`unnamed-sections`)。"

#: ../../library/configparser.rst:1300
msgid ""
"The maximum depth for recursive interpolation for "
":meth:`~configparser.ConfigParser.get` when the *raw* parameter is false.  "
"This is relevant only when the default *interpolation* is used."
msgstr ""
"当 *raw* 形参为假值时 :meth:`~configparser.ConfigParser.get` 所采用的递归插值的最大深度。 "
"这只在使用默认的 *interpolation* 时会起作用。"

#: ../../library/configparser.rst:1308
msgid "RawConfigParser Objects"
msgstr "RawConfigParser 对象"

#: ../../library/configparser.rst:1319
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values"
" via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"旧式 :class:`ConfigParser`。 它默认禁用插值并且允许通过不安全的 ``add_section`` 和 ``set`` 方法以及旧式"
" ``defaults=`` 关键字参数处理来设置非字符串的节名、选项名和值。"

#: ../../library/configparser.rst:1340
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"考虑改用 :class:`ConfigParser`，它会检查内部保存的值的类型。 如果你不想要插值，你可以使用 "
"``ConfigParser(interpolation=None)``。"

#: ../../library/configparser.rst:1347
msgid ""
"Add a section named *section* or :const:`UNNAMED_SECTION` to the instance."
msgstr "为实例添加一个名为 *section* 或 :const:`UNNAMED_SECTION` 的小节。"

#: ../../library/configparser.rst:1349
msgid ""
"If the given section already exists, :exc:`DuplicateSectionError` is raised."
" If the *default section* name is passed, :exc:`ValueError` is raised. If "
":const:`UNNAMED_SECTION` is passed and support is disabled, "
":exc:`UnnamedSectionDisabledError` is raised."
msgstr ""
"如果给定名称的节已存在，会引发 :exc:`DuplicateSectionError`。 如果传入了 *default section* "
"名称，则会引发 :exc:`ValueError`。 如果传入了 :const:`UNNAMED_SECTION` 且其支持被禁用，则会引发 "
":exc:`UnnamedSectionDisabledError`。"

#: ../../library/configparser.rst:1354
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr "不检查 *section* 以允许用户创建以非字符串命名的节。 此行为已不受支持并可能导致内部错误。"

#: ../../library/configparser.rst:1357
msgid "Added support for :const:`UNNAMED_SECTION`."
msgstr "添加了对 :const:`UNNAMED_SECTION` 的支持。"

#: ../../library/configparser.rst:1363
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use "
":class:`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set"
" to true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"如果给定的节存在，则将给定的选项设为指定的值；在其他情况下将引发 :exc:`NoSectionError`。 虽然可能使用 "
":class:`RawConfigParser` (或使用 :class:`ConfigParser` 并将 *raw* 形参设为真值) "
"以便实现非字符串值的 *internal* 存储，但是完整功能（包括插值和输出到文件）只能使用字符串值来实现。"

#: ../../library/configparser.rst:1370
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a"
" file or get it in non-raw mode.  **Use the mapping protocol API** which "
"does not allow such assignments to take place."
msgstr ""
"此方法允许用户在内部将非字符串值赋给键。 此行为已不受支持并会在尝试写入到文件或在非原始模式下获取数据时导致错误。 **请使用映射协议 "
"API**，它不允许出现这样的赋值。"

#: ../../library/configparser.rst:1377
msgid "Exceptions"
msgstr "异常"

#: ../../library/configparser.rst:1381
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "所有其他 :mod:`configparser` 异常的基类。"

#: ../../library/configparser.rst:1386
msgid "Exception raised when a specified section is not found."
msgstr "当找不到指定节时引发的异常。"

#: ../../library/configparser.rst:1391
msgid ""
"Exception raised if :meth:`~ConfigParser.add_section` is called with the "
"name of a section that is already present or in strict parsers when a "
"section if found more than once in a single input file, string or "
"dictionary."
msgstr ""
"当调用 :meth:`~ConfigParser.add_section` "
"时传入已存在的节名称，或者在严格解析器中当单个输入文件、字符串或字典内出现重复的节时引发的异常。"

#: ../../library/configparser.rst:1395
msgid ""
"Added the optional *source* and *lineno* attributes and parameters to "
":meth:`!__init__`."
msgstr "向 :meth:`!__init__` 添加了可选的 *source* 和 *lineno* 属性和形参。"

#: ../../library/configparser.rst:1402
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"当单个选项在从单个文件、字符串或字典读取时出现两次时引发的异常。 "
"这会捕获拼写错误和大小写敏感相关的错误，例如一个字典可能包含两个键分别代表同一个大小写不敏感的配置键。"

#: ../../library/configparser.rst:1410
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr "当指定的选项未在指定的节中被找到时引发的异常。"

#: ../../library/configparser.rst:1416
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr "当执行字符串插值发生问题时所引发的异常的基类。"

#: ../../library/configparser.rst:1422
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of "
":exc:`InterpolationError`."
msgstr ""
"当字符串插值由于迭代次数超出 :const:`MAX_INTERPOLATION_DEPTH` 而无法完成所引发的异常。 为 "
":exc:`InterpolationError` 的子类。"

#: ../../library/configparser.rst:1429
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr "当从某个值引用的选项并不存在时引发的异常。 为 :exc:`InterpolationError` 的子类。"

#: ../../library/configparser.rst:1435
msgid ""
"Exception raised when the source text into which substitutions are made does"
" not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr "当将要执行替换的源文本不符合要求的语法时引发的异常。 为 :exc:`InterpolationError` 的子类。"

#: ../../library/configparser.rst:1441
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr "当尝试解析一个不带节标头的文件时引发的异常。"

#: ../../library/configparser.rst:1446
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "当尝试解析一个文件而发生错误时引发的异常。"

#: ../../library/configparser.rst:1448
msgid ""
"The ``filename`` attribute and :meth:`!__init__` constructor argument were "
"removed.  They have been available using the name ``source`` since 3.2."
msgstr ""
"``filename`` 属性和 :meth:`!__init__` 构造器参数已被移除。 它们自 3.2 起可以使用名称 ``source`` "
"来访问。"

#: ../../library/configparser.rst:1454
msgid ""
"Exception raised when a key without a corresponding value is continued with "
"an indented line."
msgstr "当没有对应值的键带有一个缩进的行时将引发的异常。"

#: ../../library/configparser.rst:1461
msgid ""
"Exception raised when attempting to use the :const:`UNNAMED_SECTION` without"
" enabling it."
msgstr "在未启用 :const:`UNNAMED_SECTION` 的情况下尝试使用它时引发异常。"

#: ../../library/configparser.rst:1468
msgid ""
"Exception raised when an attempted :meth:`ConfigParser.write` would not be "
"parsed accurately with a future :meth:`ConfigParser.read` call."
msgstr ""
"当尝试的 :meth:`ConfigParser.write` 可能在将来的 :meth:`ConfigParser.read` "
"调用无法被准确解析时，引发异常。"

#: ../../library/configparser.rst:1471
msgid ""
"Ex: Writing a key beginning with the :attr:`ConfigParser.SECTCRE` pattern "
"would parse as a section header when read. Attempting to write this will "
"raise this exception."
msgstr ""
"例如：写一个以 :attr:`ConfigParser.SECTCRE` 模式开头的键，它在读取时将被解析为节头。 尝试写入此内容将引发此异常。"

#: ../../library/configparser.rst:1478
msgid "Footnotes"
msgstr "备注"

#: ../../library/configparser.rst:1479
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"配置解析器允许重度定制。 如果你有兴趣改变脚注说明中所介绍的行为，请参阅 `Customizing Parser Behaviour`_ 一节。"

#: ../../library/configparser.rst:16
msgid ".ini"
msgstr ".ini"

#: ../../library/configparser.rst:16
msgid "file"
msgstr "文件"

#: ../../library/configparser.rst:16
msgid "configuration"
msgstr "配置"

#: ../../library/configparser.rst:16
msgid "ini file"
msgstr "ini 文件"

#: ../../library/configparser.rst:16
msgid "Windows ini file"
msgstr "Windows ini 文件"

#: ../../library/configparser.rst:367
msgid "% (percent)"
msgstr "% (百分号)"

#: ../../library/configparser.rst:367 ../../library/configparser.rst:400
msgid "interpolation in configuration files"
msgstr "在配置文件中的插值"

#: ../../library/configparser.rst:400
msgid "$ (dollar)"
msgstr "$ (货币符号)"
