# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-13 15:01+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`!dataclasses` --- 数据类"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**源码：** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as "
":meth:`~object.__init__` and :meth:`~object.__repr__` to user-defined "
"classes.  It was originally described in :pep:`557`."
msgstr ""
"这个模块提供了一个装饰器和一些函数，用于自动为用户自定义的类添加生成的 :term:`特殊方法 <special method>` 例如 "
":meth:`~object.__init__` 和 :meth:`~object.__repr__`。 它的初始描述见 :pep:`557`。"

#: ../../library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using "
":pep:`526` type annotations.  For example, this code::"
msgstr "在这些生成的方法中使用的成员变量是使用 :pep:`526` 类型标注来定义的。例如以下代码："

#: ../../library/dataclasses.rst:22
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"

#: ../../library/dataclasses.rst:34
msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr "将添加多项内容，包括如下所示的 :meth:`!__init__`::"

#: ../../library/dataclasses.rst:36
msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = 0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = 0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"

#: ../../library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr "请注意此方法会自动添加到类中：它不是在如上所示的 :class:`!InventoryItem` 定义中直接指定的。"

#: ../../library/dataclasses.rst:47
msgid "Module contents"
msgstr "模块内容"

#: ../../library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated "
":term:`special methods <special method>` to classes, as described below."
msgstr ""
"此函数是一个 :term:`decorator`，它被用于将生成的 :term:`特殊方法 <special method>` 添加到类中，如下所述。"

#: ../../library/dataclasses.rst:54
msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
"``@dataclass`` examines the type specified in the variable annotation."
msgstr ""
"``@dataclass`` 装饰器会检查类以找到其中的 ``field``。 ``field`` 被定义为具有 :term:`类型标注 "
"<variable annotation>` 的类变量。 除了下面所述的两个例外，在 ``@dataclass`` "
"中没有任何东西会去检查变量标注中指定的类型。"

#: ../../library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr "这些字段在所有生成的方法中的顺序，都是它们在类定义中出现的顺序。"

#: ../../library/dataclasses.rst:63
msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"``@dataclass`` 装饰器将把各种“双下线”方法添加到类，具体如下所述。 "
"如果所添加的任何方法在类中已存在，其行为将取决于形参的值，具体如下所述。 该装饰器将返回执行其调用的类而不会创建新类。"

#: ../../library/dataclasses.rst:69
msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, it "
"acts as if it has the default values documented in this signature.  That is,"
" these three uses of ``@dataclass`` are equivalent::"
msgstr ""
"如果 ``@dataclass`` 仅被用作不带形参的简单装饰器，其行为相当于使用在此签名中记录的默认值。 也就是说，这三种 "
"``@dataclass`` 的用法是等价的::"

#: ../../library/dataclasses.rst:74
msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."

#: ../../library/dataclasses.rst:87
msgid "The parameters to ``@dataclass`` are:"
msgstr "``@dataclass`` 的形参有："

#: ../../library/dataclasses.rst:89
msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr "*init*: 如为真值（默认），将生成 :meth:`~object.__init__` 方法。"

#: ../../library/dataclasses.rst:92
msgid ""
"If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr "如果类已经定义了 :meth:`!__init__`，此形参将被忽略。"

#: ../../library/dataclasses.rst:95
msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr*: 如为真值（默认），将生成 :meth:`~object.__repr__` 方法。 生成的 repr 字符串将带有类名及每个字符的名称和"
" repr，并按它们在类中定义的顺序排列。 不包括被标记为从 repr 排除的字段。 例如: "
"``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``。"

#: ../../library/dataclasses.rst:102
msgid ""
"If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr "如果类已经定义了 :meth:`!__repr__`，此形参将被忽略。"

#: ../../library/dataclasses.rst:105
msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical"
" type."
msgstr ""
"*eq*: 如为真值（默认），将生成 :meth:`~object.__eq__` 方法。 此方法将把类当作由其字段组成的元组那样按顺序进行比较。 "
"要比较的两个实例必须是相同的类型。"

#: ../../library/dataclasses.rst:110
msgid ""
"If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr "如果类已经定义了 :meth:`!__eq__`，此形参将被忽略。"

#: ../../library/dataclasses.rst:113
msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, "
":meth:`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` "
"methods will be generated.  These compare the class as if it were a tuple of"
" its fields, in order.  Both instances in the comparison must be of the "
"identical type.  If *order* is true and *eq* is false, a :exc:`ValueError` "
"is raised."
msgstr ""
"*order*: 如为真值 (默认为 ``False``)，将生成 :meth:`~object.__lt__`, "
":meth:`~object.__le__`, :meth:`~object.__gt__` 和 :meth:`~object.__ge__` 方法。 "
"这些方法将把类当作由其字段组成的元组那样按顺序进行比较。 要比较的两个实例必须是相同的类型。 如果 *order* 为真值且 *eq* 为假值，则会引发"
" :exc:`ValueError`。"

#: ../../library/dataclasses.rst:120
msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, "
":meth:`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"如果类已经定义了 :meth:`!__lt__`, :meth:`!__le__`, :meth:`!__gt__` 或者 "
":meth:`!__ge__` 中的任意一个，将引发 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:124
msgid ""
"*unsafe_hash*: If true, force ``dataclasses`` to create a "
":meth:`~object.__hash__` method, even though it may not be safe to do so. "
"Otherwise, generate a :meth:`~object.__hash__` method according to how *eq* "
"and *frozen* are set. The default value is ``False``."
msgstr ""
"*unsafe_hash*: 如为真值，则强制 ``dataclasses`` 创建 :meth:`~object.__hash__` "
"方法，即使这样做可能是不安全的。 在其他情况下，将根据 *eq* 和 *frozen* 的设置方式来生成 "
":meth:`~object.__hash__` 方法。 默认值为 ``False``。"

#: ../../library/dataclasses.rst:130
msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a "
":meth:`!__hash__` implies that instances of the class are immutable. "
"Mutability is a complicated property that depends on the programmer's "
"intent, the existence and behavior of :meth:`!__eq__`, and the values of the"
" *eq* and *frozen* flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`!__hash__` 会在对象被添加到哈希多项集如字典和集合时由内置的 :meth:`hash` 使用。 具有 "
":meth:`!__hash__` 就意味着类的实例是不可变的。 可变性是一个依赖于程序员的实际意图、:meth:`!__eq__` "
"是否存在及其具体行为，以及 ``@dataclass`` 装饰器中 *eq* 和 *frozen* 旗标的值的复杂特征属性。"

#: ../../library/dataclasses.rst:137
msgid ""
"By default, ``@dataclass`` will not implicitly add a "
":meth:`~object.__hash__` method unless it is safe to do so.  Neither will it"
" add or change an existing explicitly defined :meth:`!__hash__` method.  "
"Setting the class attribute ``__hash__ = None`` has a specific meaning to "
"Python, as described in the :meth:`!__hash__` documentation."
msgstr ""
"在默认情况下，``@dataclass`` 不会隐式地添加 :meth:`~object.__hash__` 方法，除非这样做是安全的。 "
"它也没会添加或更改现有的显式定义的 :meth:`!__hash__` 方法。 设置类属性 ``__hash__ = None`` 对 Python "
"具有特定含义，如 :meth:`!__hash__` 文档中所述。"

#: ../../library/dataclasses.rst:143
msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``,"
" then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method. "
"Although not recommended, you can force ``@dataclass`` to create a "
":meth:`!__hash__` method with ``unsafe_hash=True``. This might be the case "
"if your class is logically immutable but can still be mutated. This is a "
"specialized use case and should be considered carefully."
msgstr ""
"如果 :meth:`!__hash__` 没有被显式定义，或者它被设为 ``None``，则 ``@dataclass`` *可能* 会添加一个隐式 "
":meth:`!__hash__` 方法。 虽然并不推荐，但你可以用 ``unsafe_hash=True`` 来强制让 ``@dataclass`` "
"创建一个 :meth:`!__hash__` 方法。 如果你的类在逻辑上不可变但却仍然可被修改那么可能就是这种情况一。 "
"这是一个特殊用例并且应当被小心地处理。"

#: ../../library/dataclasses.rst:150
msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` method"
" in your dataclass and set ``unsafe_hash=True``; this will result in a "
":exc:`TypeError`."
msgstr ""
"以下是针对隐式创建 :meth:`!__hash__` 方法的规则。 请注意你的数据类中不能既有显式的 :meth:`!__hash__` 方法又设置 "
"``unsafe_hash=True``；这将导致 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:155
msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will generate "
"a :meth:`!__hash__` method for you.  If *eq* is true and *frozen* is false, "
":meth:`!__hash__` will be set to ``None``, marking it unhashable (which it "
"is, since it is mutable).  If *eq* is false, :meth:`!__hash__` will be left "
"untouched meaning the :meth:`!__hash__` method of the superclass will be "
"used (if the superclass is :class:`object`, this means it will fall back to "
"id-based hashing)."
msgstr ""
"如果 *eq* 和 *frozen* 均为真值，则默认 ``@dataclass`` 将为你生成 :meth:`!__hash__` 方法。 如果 "
"*eq* 为真值而 *frozen* 为假值，则:meth:`!__hash__` 将被设为 "
"``None``，即将其标记为不可哈希（因为它属于可变对象）。 如果 *eq* 为假值，则 :meth:`!__hash__` "
"将保持不变，这意味着将使用超类的 :meth:`!__hash__` 方法（如果超类是 :class:`object`，这意味着它将回退为基于 id "
"的哈希）。"

#: ../../library/dataclasses.rst:163
msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If "
":meth:`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the"
" class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"*frozen*: 如为真值 (默认为 ``False``)，则对字段赋值将引发异常。 这模拟了只读的冻结实例。 如果在类中定义了 "
":meth:`~object.__setattr__` 或 :meth:`~object.__delattr__`，则将引发 "
":exc:`TypeError`。 参见下文的讨论。"

#: ../../library/dataclasses.rst:168
msgid ""
"*match_args*: If true (the default is ``True``), the "
":attr:`~object.__match_args__` tuple will be created from the list of non "
"keyword-only parameters to the generated :meth:`~object.__init__` method "
"(even if :meth:`!__init__` is not generated, see above).  If false, or if "
":attr:`!__match_args__` is already defined in the class, then "
":attr:`!__match_args__` will not be generated."
msgstr ""
"*match_args*: 如为真值 (默认为 ``True``)，则将根据传给生成的 :meth:`~object.__init__` "
"方法的非关键字形参列表来创建 the :attr:`~object.__match_args__` 元组（即使没有生成 "
":meth:`!__init__`，见上文）。 如为假值，或者如果 :attr:`!__match_args__` 已在类中定义，则不会生成 "
":attr:`!__match_args__`。"

#: ../../library/dataclasses.rst:177
msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will be"
" marked as keyword-only.  If a field is marked as keyword-only, then the "
"only effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`!__init__` "
"is called. See the :term:`parameter` glossary entry for details.  Also see "
"the :const:`KW_ONLY` section."
msgstr ""
"*kw_only*: 如为真值 (默认值为 ``False``)，则所有字段都将被标记为仅限关键字的。 "
"如果一个字段被标记为仅限关键字的，则唯一的影响是由仅限关键字的字段生成的 :meth:`~object.__init__` 形参在 "
":meth:`!__init__` 被调用时必须以关键字形式来指定。 详情参见 :term:`parameter` 术语表条目。 另请参阅 "
":const:`KW_ONLY` 一节。"

#: ../../library/dataclasses.rst:185
msgid "Keyword-only fields are not included in :attr:`!__match_args__`."
msgstr "仅限关键字字段不会被包括在 :attr:`!__match_args__` 中。"

#: ../../library/dataclasses.rst:189
msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`!__slots__` is already defined in the class, then "
":exc:`TypeError` is raised."
msgstr ""
"*slots*: 如为真值 (默认为 ``False``)，则将生成 :attr:`~object.__slots__` "
"属性并返回一个新类而非原本的类。 如果 :attr:`!__slots__` 已在类中定义，则会引发 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:195
msgid ""
"Calling no-arg :func:`super` in dataclasses using ``slots=True`` will result"
" in the following exception being raised: ``TypeError: super(type, obj): obj"
" must be an instance or subtype of type``. The two-arg :func:`super` is a "
"valid workaround. See :gh:`90562` for full details."
msgstr ""
"在使用 ``slots=True`` 的数据类中调用无参数的 :func:`super` 将导致引发以下异常: ``TypeError: "
"super(type, obj): obj must be an instance or subtype of type``。 "
"可用的绕过方式是调用带两个参数的 :func:`super`。 请参阅 :gh:`90562` 了解完整细节。"

#: ../../library/dataclasses.rst:202
msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when "
"using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""
"在使用 ``slots=True`` 时向基类 :meth:`~object.__init_subclass__` 传入形参将导致 "
":exc:`TypeError`。 应使用不带参数的 ``__init_subclass__`` 或使用默认值的绕过方式。 请参阅 "
":gh:`91126` 了解完整细节。"

#: ../../library/dataclasses.rst:210
msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not use"
" :attr:`!__slots__` to retrieve the field names of a dataclass. Use "
":func:`fields` instead. To be able to determine inherited slots, base class "
":attr:`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""
"如果某个字段名称已经包括在基类的 :attr:`!__slots__` 中，它将不会被包括在生成的 :attr:`!__slots__` 中以防止 "
":ref:`重写它们 <datamodel-note-slots>`。 因此，请不要使用 :attr:`!__slots__` 来获取数据类的字段名称。"
" 而应改用 :func:`fields`。 为了能够确定所继承的槽位，基类 :attr:`!__slots__` 可以是任意可迭代对象，但是 *不可以*"
" 是迭代器。an iterator."

#: ../../library/dataclasses.rst:220
msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-able "
"<weakref.ref>`. It is an error to specify ``weakref_slot=True`` without also"
" specifying ``slots=True``."
msgstr ""
"*weakref_slot*: 如为真值 (默认为 ``False``)，则添加一个名为 \"__weakref__\" 的槽位，这是使得一个实例 "
":func:`可以弱引用 <weakref.ref>` 所必需的。 指定 ``weakref_slot=True`` 而不同时指定 "
"``slots=True`` 将会导致错误。"

#: ../../library/dataclasses.rst:228
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr "可以用普通的 Python 语法为各个 ``field`` 指定默认值："

#: ../../library/dataclasses.rst:231
msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' 没有默认值\n"
"    b: int = 0   # 为 'b' 赋默认值"

#: ../../library/dataclasses.rst:236
msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr ""
"在这个例子中，:attr:`!a` 和 :attr:`!b` 都将被包括在所添加的 :meth:`~object.__init__` "
"方法中，该方法将被定义为::"

#: ../../library/dataclasses.rst:239
msgid "def __init__(self, a: int, b: int = 0):"
msgstr "def __init__(self, a: int, b: int = 0):"

#: ../../library/dataclasses.rst:241
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a"
" field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
"如果在具有默认值的字段之后存在没有默认值的字段，将会引发 :exc:`TypeError`。无论此情况是发生在单个类中还是作为类继承的结果，都是如此。"

#: ../../library/dataclasses.rst:247
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`!field` "
"function.  For example::"
msgstr ""
"对于常见和简单的用例，不需要其他的功能。 但是，有些数据类的特性需要额外的每字段信息。 为了满足这种对额外信息的需求，你可以通过调用所提供的 "
":func:`!field` 函数来替换默认的字段值。 例如::"

#: ../../library/dataclasses.rst:253
msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"

#: ../../library/dataclasses.rst:260
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"如上所示，:const:`MISSING` 值是一个哨兵对象，用于检测一些形参是否由用户提供。使用它是因为 ``None`` "
"对于一些形参来说是有效的用户值。任何代码都不应该直接使用 :const:`MISSING` 值。"

#: ../../library/dataclasses.rst:265
msgid "The parameters to :func:`!field` are:"
msgstr "传给 :func:`!field` 的形参有："

#: ../../library/dataclasses.rst:267
msgid ""
"*default*: If provided, this will be the default value for this field.  This"
" is needed because the :func:`!field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default*: 如果提供，这将为该字段的默认值。 设置此形参是因为 :func:`!field` 调用本身会替换通常的默认值所在位置。"

#: ../../library/dataclasses.rst:271
msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as"
" discussed below.  It is an error to specify both *default* and "
"*default_factory*."
msgstr ""
"*default_factory*: 如果提供，它必须是一个零参数的可调用对象，它将在该字段需要一个默认值时被调用。 "
"在其他目的以外，它还可被用于指定具有可变默认值的字段，如下所述。 同时指定 *default* 和 *default_factory* 将会导致错误。"

#: ../../library/dataclasses.rst:277
msgid ""
"*init*: If true (the default), this field is included as a parameter to the "
"generated :meth:`~object.__init__` method."
msgstr "*init*: 如为真值（默认），则该字段将作为一个形参被包括在生成的 :meth:`~object.__init__` 方法中。"

#: ../../library/dataclasses.rst:280
msgid ""
"*repr*: If true (the default), this field is included in the string returned"
" by the generated :meth:`~object.__repr__` method."
msgstr "*repr*: 如为真值（默认值），则该字段将被包括在生成的 :meth:`~object.__repr__` 方法所返回的字符串中。"

#: ../../library/dataclasses.rst:283
msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included in "
"the generated :meth:`~object.__hash__` method.  If false, this field is "
"excluded from the generated :meth:`~object.__hash__`. If ``None`` (the "
"default), use the value of *compare*: this would normally be the expected "
"behavior, since a field should be included in the hash if it's used for "
"comparisons.  Setting this value to anything other than ``None`` is "
"discouraged."
msgstr ""
"*hash*: 这可以是一个布尔值或 ``None``。 如为真值，则此字段将被包括在所生成的 :meth:`~object.__hash__` "
"方法中。 如为假值，则此字段将被排除在所生成的 :meth:`~object.__hash__` 之外。 如为 ``None`` (默认值)，则使用 "
"*compare* 的值：这通常是预期的行为，因为一个字段如果被用于比较那么就应当被包括在哈希运算中。 不建议将该值设为 ``None`` "
"以外的任何值。"

#: ../../library/dataclasses.rst:291
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a"
" field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"设置 ``hash=False`` 但 ``compare=True`` "
"的一个合理情况是，一个计算哈希值的代价很高的字段是检验等价性需要的，且还有其他字段可以用于计算类型的哈希值。可以从哈希值中排除该字段，但仍令它用于比较。"

#: ../../library/dataclasses.rst:297
msgid ""
"*compare*: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, "
":meth:`~object.__gt__`, et al.)."
msgstr ""
"*compare*: 如为真值（默认），则该字段将被包括在生成的相等和比较方法中 (:meth:`~object.__eq__`, "
":meth:`~object.__gt__` 等等)。"

#: ../../library/dataclasses.rst:301
msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not used "
"at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as a "
"namespace in the metadata."
msgstr ""
"*metadata*: 这可以是一个映射或为 ``None``。 ``None`` 将被当作空字典来处理。 这个值将被包装在 "
":func:`~types.MappingProxyType` 以便其为只读，并暴露在 :class:`Field` 对象上。 "
"它完全不被数据类所使用，并且是作为第三方扩展机制提供的。 多个第三方可以各自拥有其本身的键，以用作元数据的命名空间。"

#: ../../library/dataclasses.rst:309
msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is used "
"when the generated :meth:`~object.__init__` method's parameters are "
"computed."
msgstr ""
"*kw_only*: 如为真值，则该字段将被标记为仅限关键字的。 这将在计算所生成的 :meth:`~object.__init__` "
"方法的形参时被使用。"

#: ../../library/dataclasses.rst:313
msgid "Keyword-only fields are also not included in :attr:`!__match_args__`."
msgstr "仅限关键字字段也不会被包括在 :attr:`!__match_args__` 中。"

#: ../../library/dataclasses.rst:317
msgid ""
"If the default value of a field is specified by a call to :func:`!field`, "
"then the class attribute for this field will be replaced by the specified "
"*default* value.  If *default* is not provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`@dataclass "
"<dataclass>` decorator runs, the class attributes will all contain the "
"default values for the fields, just as if the default value itself were "
"specified.  For example, after::"
msgstr ""
"如果通过对 :func:`!field` 的调用来指定字段的默认值，那么该字段对应的类属性将被替换为指定的 *default* 值。 如果没有提供 "
"*default*，那么该类属性将被删除。 其意图是在 :func:`@dataclass <dataclass>` "
"装饰器运行之后，该类属性将包含所有字段的默认值，就像直接指定了默认值本身一样。 例如，在执行以下代码之后::"

#: ../../library/dataclasses.rst:326
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"

#: ../../library/dataclasses.rst:333
msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute "
":attr:`!C.t` will be ``20``, and the class attributes :attr:`!C.x` and "
":attr:`!C.y` will not be set."
msgstr ""
"类属性 :attr:`!C.z` 将为 ``10``，类属性 :attr:`!C.t` 将为 ``20``，类属性 :attr:`!C.x` 和 "
":attr:`!C.y` 将不被设置。"

#: ../../library/dataclasses.rst:339
msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` object"
" directly.  Its documented attributes are:"
msgstr ""
":class:`!Field` 对象描述每个已定义的字段。 这些对象是在内部创建的，并会由 :func:`fields` 模块块方法返回（见下文）。 "
"用户绝不应直接实例化 :class:`!Field` 对象。 已写入文档的属性如下："

#: ../../library/dataclasses.rst:344
msgid ":attr:`!name`: The name of the field."
msgstr ":attr:`!name`: 字段的名称。"

#: ../../library/dataclasses.rst:345
msgid ":attr:`!type`: The type of the field."
msgstr ":attr:`!type`: 字段的类型。"

#: ../../library/dataclasses.rst:346
msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, "
":attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` "
"have the identical meaning and values as they do in the :func:`field` "
"function."
msgstr ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, "
":attr:`!hash`, :attr:`!compare`, :attr:`!metadata` 和 :attr:`!kw_only` 具有与 "
":func:`field` 函数中对应参数相同的含义和值。"

#: ../../library/dataclasses.rst:350
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr "可能存在其他属性，但它们是私有的。用户不应检查或依赖于这些属性。"

#: ../../library/dataclasses.rst:355
msgid ""
"``InitVar[T]`` type annotations describe variables that are :ref:`init-only "
"<dataclasses-init-only-variables>`. Fields annotated with :class:`!InitVar` "
"are considered pseudo-fields, and thus are neither returned by the "
":func:`fields` function nor used in any way except adding them as parameters"
" to :meth:`~object.__init__` and an optional :meth:`__post_init__`."
msgstr ""
"``InitVar[T]`` 类型标注用于描述 :ref:`仅限初始化 <dataclasses-init-only-variables>` 变量。 "
"使用 :class:`!InitVar` 标注的字段将被视作伪字段，因此既不会被 :func:`fields` 函数返回也不会在除了作为传给 "
":meth:`~object.__init__` 的和可选的 :meth:`__post_init__` 的形参添加之外以任何方式被使用。"

#: ../../library/dataclasses.rst:364
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"返回一个能描述此数据类所包含的字段的元组，元组的每一项都是 :class:`Field` "
"对象。接受数据类或数据类的实例。如果没有传递一个数据类或实例将引发 :exc:`TypeError`。不返回 ``ClassVar`` 或 "
"``InitVar`` 等伪字段。"

#: ../../library/dataclasses.rst:371
msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"将数据类 *obj* 转换为一个字典 (使用工厂函数 *dict_factory*)。 每个数据类会被转换为以 ``name: value`` "
"键值对来存储其字段的字典。 数据类、字典、列表和元组会被递归地处理。 其他对象会通过 :func:`copy.deepcopy` 来拷贝。"

#: ../../library/dataclasses.rst:377
msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr "在嵌套的数据类上使用 :func:`!asdict` 的例子::"

#: ../../library/dataclasses.rst:379
msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"

#: ../../library/dataclasses.rst:394 ../../library/dataclasses.rst:414
msgid "To create a shallow copy, the following workaround may be used::"
msgstr "要创建一个浅拷贝，可以使用以下的变通方法："

#: ../../library/dataclasses.rst:396
msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr "{field.name: getattr(obj, field.name) for field in fields(obj)}"

#: ../../library/dataclasses.rst:398
msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr "如果 *obj* 不是一个数据类实例则 :func:`!asdict` 将引发 :exc:`TypeError` 。"

#: ../../library/dataclasses.rst:403
msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"将数据类 *obj* 转换为元组 (使用工厂函数 *tuple_factory*)。 每个数据类将被转换为由其字段值组成的元组。 "
"数据类、字典、列表和元组会被递归地处理。 其他对象会通过 :func:`copy.deepcopy` 来拷贝。"

#: ../../library/dataclasses.rst:409
msgid "Continuing from the previous example::"
msgstr "继续前一个例子："

#: ../../library/dataclasses.rst:411
msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"

#: ../../library/dataclasses.rst:416
msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"

#: ../../library/dataclasses.rst:418
msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr "如果 *obj* 不是一个数据类实例则 :func:`!astuple` 将引发 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:423
msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in *fields*,"
" base classes as given in *bases*, and initialized with a namespace as given"
" in *namespace*.  *fields* is an iterable whose elements are each either "
"``name``, ``(name, type)``, or ``(name, type, Field)``.  If just ``name`` is"
" supplied, :data:`typing.Any` is used for ``type``.  The values of *init*, "
"*repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, *kw_only*, "
"*slots*, and *weakref_slot* have the same meaning as they do in "
":func:`@dataclass <dataclass>`."
msgstr ""
"新建一个名为 *cls_name* 的数据类，其字段在 *fields* 中定义，其基类在 *bases* 中给出，并使用在 *namespace* "
"中给定的命名空间来初始化。 *fields* 是一个可迭代对象，其中每个元素均为 ``name``, ``(name, type)`` 或 "
"``(name, type, Field)`` 的形式。 如果只提供了 ``name``，则使用 :data:`typing.Any` 作为 "
"``type``。 *init*, *repr*, *eq*, *order*, *unsafe_hash*, *frozen*, "
"*match_args*, *kw_only*, *slots* 和 *weakref_slot* 值的含义与 :func:`@dataclass "
"<dataclass>` 中的同名参数一致。"

#: ../../library/dataclasses.rst:433
msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the dataclass "
"is set to that value. By default, it is set to the module name of the "
"caller."
msgstr ""
"如果定义了 *module*，则该数据类的 :attr:`!__module__` 属性将被设为该值。 在默认情况下，它将被设为调用方的模块名。"

#: ../../library/dataclasses.rst:437
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the "
":func:`@dataclass <dataclass>` function to convert that class to a "
"dataclass.  This function is provided as a convenience.  For example::"
msgstr ""
"此函数不是必需的，因为任何用于创建带有 :attr:`!__annotations__` 的新类的 Python 机制都可以进一步用 "
":func:`@dataclass <dataclass>` 函数将创建的类转换为数据类。 提供此函数是为了方便。 例如::"

#: ../../library/dataclasses.rst:443
msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"

#: ../../library/dataclasses.rst:449
msgid "Is equivalent to::"
msgstr "等价于："

#: ../../library/dataclasses.rst:451
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"

#: ../../library/dataclasses.rst:462
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values"
" from *changes*.  If *obj* is not a Data Class, raises :exc:`TypeError`.  If"
" keys in *changes* are not field names of the given dataclass, raises "
":exc:`TypeError`."
msgstr ""
"创建一个与 *obj* 类型相同的新对象，将字段替换为 *changes* 的值。 如果 *obj* 不是数据类，则会引发 "
":exc:`TypeError`。 如果 *changes* 中的键不是给定数据类的字段名，则会引发 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:467
msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__`"
" method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"新返回的对象是通过调用数据类的 :meth:`~object.__init__` 方法来创建的。 这确保了如果存在 "
":meth:`__post_init__`，则它也会被调用。"

#: ../../library/dataclasses.rst:471
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`!replace` so that they can be passed to "
":meth:`!__init__` and :meth:`__post_init__`."
msgstr ""
"如果存在任何没有默认值的仅初始化变量，那么必须在调用 :func:`!replace` 时指定它们的值，以便它们可以被传递给 "
":meth:`!__init__` 和 :meth:`__post_init__`。"

#: ../../library/dataclasses.rst:475
msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"如果 *changes* 包含被任何定义为 defined as having ``init=False`` 的字段都会导致错误。 在此情况下将引发 "
":exc:`ValueError`。"

#: ../../library/dataclasses.rst:479
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to "
":func:`!replace`.  They are not copied from the source object, but rather "
"are initialized in :meth:`__post_init__`, if they're initialized at all.  It"
" is expected that ``init=False`` fields will be rarely and judiciously used."
"  If they are used, it might be wise to have alternate class constructors, "
"or perhaps a custom :func:`!replace` (or similarly named) method which "
"handles instance copying."
msgstr ""
"需要预先注意 ``init=False`` 字段在对 :func:`!replace` 的调用期间的行为。 "
"如果它们会被初始化，它们就不会从源对象拷贝，而是在 :meth:`__post_init__` 中初始化。 通常预期 ``init=False`` "
"字段将很少能被正确地使用。 如果要使用它们，那么更明智的做法是使用另外的类构造器，或者自定义的 :func:`!replace` (或类似名称) "
"方法来处理实例的拷贝。"

#: ../../library/dataclasses.rst:488
msgid ""
"Dataclass instances are also supported by generic function "
":func:`copy.replace`."
msgstr "数据类支持也被泛型函数 :func:`copy.replace` 所支持。"

#: ../../library/dataclasses.rst:492
msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of a "
"dataclass) or an instance of one, otherwise return ``False``."
msgstr "如果其形参是一个 dataclass（包括 dataclass 的子类）或其实例则返回 ``True``，否则返回 ``False``。"

#: ../../library/dataclasses.rst:495
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"如果你需要知道一个类是否是一个数据类的实例（而不是一个数据类本身），那么再添加一个 ``not isinstance(obj, type)`` 检查："

#: ../../library/dataclasses.rst:499
msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"

#: ../../library/dataclasses.rst:504
msgid "A sentinel value signifying a missing default or default_factory."
msgstr "一个指明“没有提供 default 或 default_factory”的监视值。"

#: ../../library/dataclasses.rst:508
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field"
" with the type of :const:`!KW_ONLY` are marked as keyword-only fields.  Note"
" that a pseudo-field of type :const:`!KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`!KW_ONLY` field.  Keyword-only fields signify "
":meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"一个用途类型标的监视值。 任何在伪字段之后的类型为 :const:`!KW_ONLY` 的字段会被标记为仅限关键字的字段。 请注意在其他情况下 "
":const:`!KW_ONLY` 类型的伪字段会被完全忽略。 这包括此类字段的名称。 根据惯例，名称 ``_`` 会被用作 "
":const:`!KW_ONLY` 字段。 仅限关键字字段指明当类被实例化时 :meth:`~object.__init__` "
"形参必须以关键字形式来指定。"

#: ../../library/dataclasses.rst:517
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr "在这个例子中，字段 ``y`` 和 ``z`` 将被标记为仅限关键字字段::"

#: ../../library/dataclasses.rst:519
msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"

#: ../../library/dataclasses.rst:528
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`!KW_ONLY`."
msgstr "在单个数据类中，指定一个以上 :const:`!KW_ONLY` 类型的字段将导致错误。"

#: ../../library/dataclasses.rst:535
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or "
":meth:`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"在定义时设置了 ``frozen=True`` 的类上调用隐式定义的 :meth:`~object.__setattr__` 或 "
":meth:`~object.__delattr__` 时引发。 这是 :exc:`AttributeError` 的一个子类。"

#: ../../library/dataclasses.rst:542
msgid "Post-init processing"
msgstr "初始化后处理"

#: ../../library/dataclasses.rst:546
msgid ""
"When defined on the class, it will be called by the generated "
":meth:`~object.__init__`, normally as :meth:`!self.__post_init__`. However, "
"if any ``InitVar`` fields are defined, they will also be passed to "
":meth:`!__post_init__` in the order they were defined in the class.  If no "
":meth:`!__init__` method is generated, then :meth:`!__post_init__` will not "
"automatically be called."
msgstr ""
"当在类上定义时，它将被所生成的 :meth:`~object.__init__` 调用，通常是以 :meth:`!self.__post_init__`"
" 的形式。 但是，如果定义了任何 ``InitVar`` 字段，它们也将按照它们在类中定义的顺序被传递给 :meth:`!__post_init__`。"
" 如果没有生成 :meth:`!__init__` 方法，那么 :meth:`!__post_init__` 将不会被自动调用。"

#: ../../library/dataclasses.rst:553
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr "在其他用途中，这允许初始化依赖于一个或多个其他字段的字段值。例如::"

#: ../../library/dataclasses.rst:556
msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"

#: ../../library/dataclasses.rst:565
msgid ""
"The :meth:`~object.__init__` method generated by :func:`@dataclass "
"<dataclass>` does not call base class :meth:`!__init__` methods. If the base"
" class has an :meth:`!__init__` method that has to be called, it is common "
"to call this method in a :meth:`__post_init__` method::"
msgstr ""
"由 :func:`@dataclass <dataclass>` 生成的 :meth:`~object.__init__` 方法不会调用基类的 "
":meth:`!__init__` 方法。 如果基类有必须被调用的 :meth:`!__init__` 方法，通常是在 "
":meth:`__post_init__` 方法中调用此方法::"

#: ../../library/dataclasses.rst:570
msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"

#: ../../library/dataclasses.rst:582
msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"但是，请注意一般来说数据类生成的 :meth:`!__init__` 方法不需要被调用，因为派生的数据类将负责初始化任何本身为数据类的基类的所有字段。"

#: ../../library/dataclasses.rst:586
msgid ""
"See the section below on init-only variables for ways to pass parameters to "
":meth:`!__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"请参阅下面有关仅初始化变量的小节来了解如何将形参传递给 :meth:`!__post_init__`。 另请参阅关于 :func:`replace` "
"如何处理 ``init=False`` 字段的警告。"

#: ../../library/dataclasses.rst:593
msgid "Class variables"
msgstr "类变量"

#: ../../library/dataclasses.rst:595
msgid ""
"One of the few places where :func:`@dataclass <dataclass>` actually inspects"
" the type of a field is to determine if a field is a class variable as "
"defined in :pep:`526`.  It does this by checking if the type of the field is"
" :data:`typing.ClassVar`.  If a field is a ``ClassVar``, it is excluded from"
" consideration as a field and is ignored by the dataclass mechanisms.  Such "
"``ClassVar`` pseudo-fields are not returned by the module-level "
":func:`fields` function."
msgstr ""
"少数几个 :func:`@dataclass <dataclass>` 会实际检查字段类型的地方之一是确定字段是否为如 :pep:`526` "
"所定义的类变量。 它通过检查字段的类型是否为 :data:`typing.ClassVar` 来实现这一点。 如果一个字段是 "
"``ClassVar``，它将被排除在考虑范围之外并被数据类机制所忽略。 这样的 ``ClassVar`` 伪字段将不会被模块层级的 "
":func:`fields` 函数返回。"

#: ../../library/dataclasses.rst:606
msgid "Init-only variables"
msgstr "仅初始化变量"

#: ../../library/dataclasses.rst:608
msgid ""
"Another place where :func:`@dataclass <dataclass>` inspects a type "
"annotation is to determine if a field is an init-only variable.  It does "
"this by seeing if the type of a field is of type :class:`InitVar`.  If a "
"field is an :class:`InitVar`, it is considered a pseudo-field called an "
"init-only field.  As it is not a true field, it is not returned by the "
"module-level :func:`fields` function.  Init-only fields are added as "
"parameters to the generated :meth:`~object.__init__` method, and are passed "
"to the optional :meth:`__post_init__` method.  They are not otherwise used "
"by dataclasses."
msgstr ""
"另一个 :func:`@dataclass <dataclass>` 会检查类型标注的地方是为了确定一个字段是否为仅限初始化的变量。 "
"它通过检查字段的类型是否为 :class:`InitVar` 类型来做到这一点。 如果一个字段是 "
":class:`InitVar`，它会被当作是一个名为仅限初始化字段的伪字段。 因为它不是一个真正的字段，所以它不会被模块层级的 "
":func:`fields` 函数返回。 仅限初始化字段会作为形参被添加到所生成的 :meth:`~object.__init__` "
"方法中，并会被传递给可选的 :meth:`__post_init__` 方法。 在其他情况下它们将不会被类所使用。"

#: ../../library/dataclasses.rst:618
msgid ""
"For example, suppose a field will be initialized from a database, if a value"
" is not provided when creating the class::"
msgstr "例如，假设在创建类时没有为某个字段提供值，初始化时将从数据库中取值::"

#: ../../library/dataclasses.rst:621
msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"

#: ../../library/dataclasses.rst:633
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for "
":attr:`!i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"在这种情况下，:func:`fields` 将返回 :class:`Field` 作为 :attr:`!i` 和 :attr:`!j`，但不包括 "
":attr:`!database`。"

#: ../../library/dataclasses.rst:639
msgid "Frozen instances"
msgstr "冻结的实例"

#: ../../library/dataclasses.rst:641
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator you "
"can emulate immutability.  In that case, dataclasses will add "
":meth:`~object.__setattr__` and :meth:`~object.__delattr__` methods to the "
"class.  These methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"创建真正不可变的 Python 对象是不可能的。 但是，你可以通过将 ``frozen=True`` 传递给 :func:`@dataclass "
"<dataclass>` 装饰器来模拟出不可变性。 在这种情况下，数据类将向类添加 :meth:`~object.__setattr__` 和 "
":meth:`~object.__delattr__` 方法。 当被唤起时这些方法将会引发 :exc:`FrozenInstanceError`。"

#: ../../library/dataclasses.rst:647
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: "
":meth:`~object.__init__` cannot use simple assignment to initialize fields, "
"and must use :meth:`!object.__setattr__`."
msgstr ""
"在使用 ``frozen=True`` 时会有微小的性能损失: :meth:`~object.__init__` "
"不能使用简单赋值来初始化字段，而必须使用 :meth:`!object.__setattr__`。"

#: ../../library/dataclasses.rst:656
msgid "Inheritance"
msgstr "继承"

#: ../../library/dataclasses.rst:658
msgid ""
"When the dataclass is being created by the :func:`@dataclass <dataclass>` "
"decorator, it looks through all of the class's base classes in reverse MRO "
"(that is, starting at :class:`object`) and, for each dataclass that it "
"finds, adds the fields from that base class to an ordered mapping of fields."
" After all of the base class fields are added, it adds its own fields to the"
" ordered mapping.  All of the generated methods will use this combined, "
"calculated ordered mapping of fields.  Because the fields are in insertion "
"order, derived classes override base classes.  An example::"
msgstr ""
"当数据类由 :func:`@dataclass <dataclass>` 装饰器创建时，它会按反向 MRO 顺序（也就是说，从 "
":class:`object` 开始）查看它的所有基类，并将找到的每个数据类的字段添加到一个有序映射中。 所有生成的方法都将使用这个有序映射。 "
"字段会遵守它们被插入的顺序，因此派生类会重写基类。 一个例子::"

#: ../../library/dataclasses.rst:668
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"

#: ../../library/dataclasses.rst:678
msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  "
"The final type of :attr:`!x` is :class:`int`, as specified in class "
":class:`!C`."
msgstr ""
"最终的字段列表依次是 :attr:`!x`, :attr:`!y`, :attr:`!z`。 最终的 :attr:`!x` 类型是 "
":class:`int`，正如类 :class:`!C` 中所指定的。"

#: ../../library/dataclasses.rst:681
msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr "为 :class:`!C` 生成的 :meth:`~object.__init__` 方法看起来像是这样::"

#: ../../library/dataclasses.rst:683
msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"

#: ../../library/dataclasses.rst:686
msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ":meth:`!__init__` 中仅限关键字形参的重新排序"

#: ../../library/dataclasses.rst:688
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"在计算出 :meth:`~object.__init__` 所需要的形参之后，任何仅限关键字形参会被移至所有常规（非仅限关键字）形参的后面。 这是 "
"Python 中实现仅限关键字形参所要求的：它们必须位于非仅限关键字形参之后。"

#: ../../library/dataclasses.rst:694
msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""
"在这个例子中，:attr:`!Base.y`, :attr:`!Base.w` 和 :attr:`!D.t` 是仅限关键字字段，而 "
":attr:`!Base.x` 和 :attr:`!D.z` 是常规字段::"

#: ../../library/dataclasses.rst:697
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"

#: ../../library/dataclasses.rst:709
msgid ""
"The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr "为 :class:`!D` 生成的 :meth:`!__init__` 方法看起来像是这样::"

#: ../../library/dataclasses.rst:711
msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t:"
" int = 0):"
msgstr ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t:"
" int = 0):"

#: ../../library/dataclasses.rst:713
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr "请注意形参原来在字段列表中出现的位置已被重新排序：前面是来自常规字段的形参而后面是来自仅限关键字字段的形参。"

#: ../../library/dataclasses.rst:717
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr "仅限关键字形参的相对顺序会在重新排序的 :meth:`!__init__` 列表中保持不变。"

#: ../../library/dataclasses.rst:722
msgid "Default factory functions"
msgstr "默认工厂函数"

#: ../../library/dataclasses.rst:724
msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"如果一个 :func:`field` 指定了 *default_factory*，它将在该字段需要默认值时不带参数地被调用。 "
"例如，要创建一个列表的新实例，则使用::"

#: ../../library/dataclasses.rst:728
msgid "mylist: list = field(default_factory=list)"
msgstr "mylist: list = field(default_factory=list)"

#: ../../library/dataclasses.rst:730
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies *default_factory*, then the default factory "
"function will always be called from the generated :meth:`!__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"如果一个字段被排除在 :meth:`~object.__init__` 之外 (使用 ``init=False``) 并且该字段还指定了 "
"*default_factory*，则默认的工厂函数将总是会从生成的 :meth:`!__init__` 函数中被调用。 "
"发生这种情况是因为没有其他方式能为字段提供初始值。"

#: ../../library/dataclasses.rst:737
msgid "Mutable default values"
msgstr "可变的默认值"

#: ../../library/dataclasses.rst:739
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr "Python 在类属性中存储默认成员变量值。思考这个例子，不使用数据类::"

#: ../../library/dataclasses.rst:742
msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"

#: ../../library/dataclasses.rst:754
msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr "请注意类 :class:`!C` 的两个实例将共享同一个类变量 :attr:`!x`，正如预期的那样。"

#: ../../library/dataclasses.rst:757
msgid "Using dataclasses, *if* this code was valid::"
msgstr "使用数据类，*如果* 此代码有效："

#: ../../library/dataclasses.rst:759
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # 此代码将引发 ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"

#: ../../library/dataclasses.rst:765
msgid "it would generate code similar to::"
msgstr "它生成的代码类似于::"

#: ../../library/dataclasses.rst:767
msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"

#: ../../library/dataclasses.rst:776
msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value for "
":attr:`!x` when creating a class instance will share the same copy of "
":attr:`!x`.  Because dataclasses just use normal Python class creation they "
"also share this behavior.  There is no general way for Data Classes to "
"detect this condition.  Instead, the :func:`@dataclass <dataclass>` "
"decorator will raise a :exc:`ValueError` if it detects an unhashable default"
" parameter.  The assumption is that if a value is unhashable, it is mutable."
"  This is a partial solution, but it does protect against many common "
"errors."
msgstr ""
"这具有与使用 :class:`!C` 类的原始示例相同的问题。 也就是说，当创建类实例时如果 :class:`!D` 类的两个实例没有为 "
":attr:`!x` 指定值则将共享同一个 :attr:`!x` 的副本。 因为数据类只是使用普通的 Python 类创建方式所以它们也会共享此行为。 "
"数据类没有任何通用方式来检测这种情况。 相反地，:func:`@dataclass <dataclass>` 装饰器在检测到不可哈希的默认形参时将会引发"
" :exc:`ValueError`。 这一行为假定如果一个值是不可哈希的，则它就是可变对象。 这是一个部分解决方案，但它确实能防止许多常见错误。"

#: ../../library/dataclasses.rst:787
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr "使用默认工厂函数是一种创建可变类型新实例的方法，并将其作为字段的默认值::"

#: ../../library/dataclasses.rst:790
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"

#: ../../library/dataclasses.rst:796
msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, "
":class:`dict`, or :class:`set`, unhashable objects are now not allowed as "
"default values.  Unhashability is used to approximate mutability."
msgstr ""
"现在不再是寻找并阻止使用类型为 :class:`list`, :class:`dict` 或 :class:`set` "
"的对象，而是不允许将不可哈希的对象用作默认值。 就是不可哈希性被作为不可变性的近似物了。"

#: ../../library/dataclasses.rst:803
msgid "Descriptor-typed fields"
msgstr "描述器类型的字段"

#: ../../library/dataclasses.rst:805
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr "当字段被 :ref:`描述器对象 <descriptors>` 赋值为默认值时会遵循以下行为:"

#: ../../library/dataclasses.rst:808
msgid ""
"The value for the field passed to the dataclass's :meth:`~object.__init__` "
"method is passed to the descriptor's :meth:`~object.__set__` method rather "
"than overwriting the descriptor object."
msgstr ""
"传递给数据类的 :meth:`~object.__init__` 方法的字段值会被传递给描述器的 :meth:`~object.__set__` "
"方法而不会覆盖描述器对象。"

#: ../../library/dataclasses.rst:812
msgid ""
"Similarly, when getting or setting the field, the descriptor's "
":meth:`~object.__get__` or :meth:`!__set__` method is called rather than "
"returning or overwriting the descriptor object."
msgstr ""
"类似地，当获取或设置字段值时，将调用描述器的 :meth:`~object.__get__` 或 :meth:`!__set__` "
"方法而不是返回或重写描述器对象。"

#: ../../library/dataclasses.rst:816
msgid ""
"To determine whether a field contains a default value, :func:`@dataclass "
"<dataclass>` will call the descriptor's :meth:`!__get__` method using its "
"class access form: ``descriptor.__get__(obj=None, type=cls)``.  If the "
"descriptor returns a value in this case, it will be used as the field's "
"default. On the other hand, if the descriptor raises :exc:`AttributeError` "
"in this situation, no default value will be provided for the field."
msgstr ""
"为了确定一个字段是否包含默认值，:func:`@dataclass <dataclass>` 会使用类访问形式调用描述器的 "
":meth:`!__get__` 方法: ``descriptor.__get__(obj=None, type=cls)``。 "
"如果在此情况下描述器返回了一个值，它将被用作字段的默认值。 另一方面，如果在此情况下描述器引发了 "
":exc:`AttributeError`，则不会为字段提供默认值。"

#: ../../library/dataclasses.rst:826
msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # 调用 __set__ 并传入 2.5\n"
"print(i.quantity_on_hand)   # 2"

#: ../../library/dataclasses.rst:851
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a"
" normal field."
msgstr "若一个字段的类型是描述器，但其默认值并不是描述器对象，那么该字段只会像普通的字段一样工作。"
