# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# emrich <emrich3@163.com>, 2017
# cdarlint <cdarling@126.com>, 2018
# ww song <sww4718168@gmail.com>, 2018
# Shengjing Zhu <zsj950618@gmail.com>, 2018
# isaced <isaced@163.com>, 2018
# eric R <trencyclopedia@gmail.com>, 2018
# CommonZ <zyyzcode@outlook.com>, 2018
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2019
# Meng Du <alphanow@gmail.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-08 11:02+0900\n"
"PO-Revision-Date: 2017-02-16 23:27+0000\n"
"Last-Translator: Meng Du <alphanow@gmail.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "内置类型"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "以下部分描述了解释器中内置的标准类型。"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "主要内置类型有数字、序列、映射、类、实例和异常。"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 ``None``。"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""
"有些操作受多种对象类型的支持；特别地，实际上所有对象都可以被比较、检测逻辑值，以及转换为字符串（使用 :func:`repr` 函数或略有差异的 "
":func:`str` 函数）。 后一个函数是在对象由 :func:`print` 函数输出时被隐式地调用的。"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "逻辑值检测"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"任何对象都可以进行逻辑值的检测，以便在 :keyword:`if` 或 :keyword:`while` "
"作为条件或是作为下文所述布尔运算的操作数来使用。"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a "
":meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 :meth:`__bool__` 方法且返回 ``False`` 或是定义了 "
":meth:`__len__` 方法且返回零。 [1]_  下面基本完整地列出了会被视为假值的内置对象:"

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "被定义为假值的常量: ``None`` 和 ``False``。"

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr "任何数值类型的零: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr "空的序列和多项集: ``''``, ``()``, ``[]``, ``{}``, ``set()``, ``range(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"产生布尔值结果的运算和内置函数总是返回 ``0`` 或 ``False`` 作为假值，``1`` 或 ``True`` 作为真值，除非另行说明。 "
"（重要例外：布尔运算 ``or`` 和 ``and`` 总是返回其中一个操作数。）"

#: ../../library/stdtypes.rst:78
msgid ""
"Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "布尔运算 --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "这些属于布尔运算，按优先级升序排列:"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:275 ../../library/stdtypes.rst:364
#: ../../library/stdtypes.rst:414 ../../library/stdtypes.rst:856
#: ../../library/stdtypes.rst:1051
msgid "Operation"
msgstr "运算"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:364 ../../library/stdtypes.rst:414
#: ../../library/stdtypes.rst:856 ../../library/stdtypes.rst:1051
msgid "Result"
msgstr "结果"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:414 ../../library/stdtypes.rst:856
#: ../../library/stdtypes.rst:1051 ../../library/stdtypes.rst:2199
#: ../../library/stdtypes.rst:3331
msgid "Notes"
msgstr "注释"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "if *x* is false, then *y*, else *x*"

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:285
#: ../../library/stdtypes.rst:858 ../../library/stdtypes.rst:861
#: ../../library/stdtypes.rst:1062 ../../library/stdtypes.rst:2205
#: ../../library/stdtypes.rst:3337
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "if *x* is false, then *x*, else *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:288
#: ../../library/stdtypes.rst:308 ../../library/stdtypes.rst:1090
#: ../../library/stdtypes.rst:2209 ../../library/stdtypes.rst:2211
#: ../../library/stdtypes.rst:3341 ../../library/stdtypes.rst:3343
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "if *x* is false, then ``True``, else ``False``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:870
#: ../../library/stdtypes.rst:1093 ../../library/stdtypes.rst:2213
#: ../../library/stdtypes.rst:2215 ../../library/stdtypes.rst:2217
#: ../../library/stdtypes.rst:2219 ../../library/stdtypes.rst:3345
#: ../../library/stdtypes.rst:3347 ../../library/stdtypes.rst:3349
#: ../../library/stdtypes.rst:3351
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:319
#: ../../library/stdtypes.rst:432 ../../library/stdtypes.rst:897
#: ../../library/stdtypes.rst:1101 ../../library/stdtypes.rst:2245
#: ../../library/stdtypes.rst:3381
msgid "Notes:"
msgstr "注释:"

#: ../../library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr "这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。"

#: ../../library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr "这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。"

#: ../../library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` 的优先级比非布尔运算符低，因此 ``not a == b`` 会被解读为 ``not (a == b)`` 而 ``a == not "
"b`` 会引发语法错误。"

#: ../../library/stdtypes.rst:120
msgid "Comparisons"
msgstr "比较"

#: ../../library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons"
" can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to "
"``x < y and y <= z``, except that *y* is evaluated only once (but in both "
"cases *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，``x < y <= z`` 等价于 "
"``x < y and y <= z``，前者的不同之处在于 *y* 只被求值一次（但在两种情况下当 ``x < y`` 结果为假值时 *z* "
"都不会被求值）。"

#: ../../library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "此表格汇总了比较运算:"

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2176
#: ../../library/stdtypes.rst:2199 ../../library/stdtypes.rst:3308
#: ../../library/stdtypes.rst:3331
msgid "Meaning"
msgstr "含义"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
msgid "strictly less than"
msgstr "严格小于"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
msgid "less than or equal"
msgstr "小于或等于"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "严格大于"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "大于或等于"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
msgid "equal"
msgstr "等于"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
msgid "not equal"
msgstr "不等于"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:157
msgid "object identity"
msgstr "对象标识"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:159
msgid "negated object identity"
msgstr "否定的对象标识"

#: ../../library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. Furthermore, some types (for example, function objects) support only "
"a degenerate notion of comparison where any two objects of that type are "
"unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a "
":exc:`TypeError` exception when comparing a complex number with another "
"built-in numeric type, when the objects are of different types that cannot "
"be compared, or in other cases where there is no defined ordering."
msgstr ""
"除了不同数字类型以外，不同类型的对象比较时绝对不会相等。 而且，某些类型（例如函数对象）仅支持简化比较形式，即任何两个该种类型的对象必定不相等。 "
"``<``, ``<=``, ``>`` 和 ``>=`` 运算符在以下情况中将引发 :exc:`TypeError` "
"异常：当比较复数与另一个内置数字类型时，当两个对象具有无法被比较的不同类型时，或在未定义次序的其他情况时。"

#: ../../library/stdtypes.rst:182
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr "具有不同标识的类的实例比较结果通常为不相等，除非类定义了 :meth:`__eq__` 方法。"

#: ../../library/stdtypes.rst:185
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of"
" the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and "
":meth:`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are "
"sufficient, if you want the conventional meanings of the comparison "
"operators)."
msgstr ""
"一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，包括 :meth:`__lt__`, "
":meth:`__le__`, :meth:`__gt__` 以及 :meth:`__ge__` (而如果你想实现常规意义上的比较操作，通常只要有 "
":meth:`__lt__` 和 :meth:`__eq__` 就可以了)。"

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ":keyword:`is` 和 :keyword:`is not` 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。"

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and "
":keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"还有两种具有相同语法优先级的运算 :keyword:`in` 和 :keyword:`not in`，它们被 :term:`iterable` 或实现了"
" :meth:`__contains__` 方法的类型所支持。"

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "数字类型 --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in "
":data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, and"
" :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr ""
"存在三种不同的数字类型: :dfn:`整数`, :dfn:`浮点数` 和 :dfn:`复数`。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 "
"浮点数通常使用 C 中的 :c:type:`double` 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 "
":data:`sys.float_info` 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z* 中提取这两个部分，可使用 "
"``z.real`` 和 ``z.imag``。 （标准库包含附加的数字类型，如表示有理数的 :mod:`fractions` "
"以及以用户定制精度表示浮点数的 :mod:`decimal`。）"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number"
" with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 "
"包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 ``'j'`` 或 ``'J'`` "
"会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。"

#: ../../library/stdtypes.rst:263
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers"
" of mixed type use the same rule. [2]_ The constructors :func:`int`, "
":func:`float`, and :func:`complex` can be used to produce numbers of a "
"specific type."
msgstr ""
"Python 完全支持混合算术：当一个二元运算符用于不同数字类型的操作数时，具有“较窄” "
"类型的操作数会被扩展为另操作数的类型，整数比浮点数更窄，浮点数又比复数更窄。 混合类型数字之间的比较也使用相同的规则。 [2]_ 构造器 "
":func:`int`, :func:`float` 和 :func:`complex` 可被用于生成特定类型的数字。"

#: ../../library/stdtypes.rst:270
msgid ""
"All numeric types (except complex) support the following operations, sorted "
"by ascending priority (all numeric operations have a higher priority than "
"comparison operations):"
msgstr "所有数字类型（复数除外）都支持下列运算，按优先级升序排序（所有数字运算的优先级都高于比较运算）:"

#: ../../library/stdtypes.rst:275
msgid "Full documentation"
msgstr "完整文档"

#: ../../library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "*x* 和 *y* 的合计"

#: ../../library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "*x* 和 *y* 的差异"

#: ../../library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "*x* 和 *y* 的乘积"

#: ../../library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "*x* 和 *y* 的商"

#: ../../library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "*x* 和 *y* 的商数"

#: ../../library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr " ``x / y`` 的余数"

#: ../../library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* 取反"

#: ../../library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* 不变"

#: ../../library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "*x* 的绝对值或大小"

#: ../../library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "将 *x* 转换为整数"

#: ../../library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "将 *x* 转换为浮点数"

#: ../../library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "一个带有实部 *re* 和虚部 *im* 的复数。*im* 默认为0。"

#: ../../library/stdtypes.rst:301 ../../library/stdtypes.rst:1083
#: ../../library/stdtypes.rst:2207 ../../library/stdtypes.rst:3368
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "复数 *c* 的共轭"

#: ../../library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)``"

#: ../../library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* 的 *y* 次幂"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
#: ../../library/stdtypes.rst:1072 ../../library/stdtypes.rst:1075
#: ../../library/stdtypes.rst:2232 ../../library/stdtypes.rst:2235
#: ../../library/stdtypes.rst:2238 ../../library/stdtypes.rst:3364
#: ../../library/stdtypes.rst:3371
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: ``1//2`` 为 ``0``, "
"``(-1)//2`` 为 ``-1``, ``1//(-2)`` 为 ``-1`` 而 ``(-1)//(-2)`` 为 ``0``。"

#: ../../library/stdtypes.rst:328
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "不可用于复数。 而应在适当条件下使用 :func:`abs` 转换为浮点数。"

#: ../../library/stdtypes.rst:340
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see"
" functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断；请参阅 :func:`math.floor` 和 :func:`math.ceil` "
"函数查看转换的完整定义。"

#: ../../library/stdtypes.rst:345
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr "float 也接受字符串 \"nan\" 和附带可选前缀 \"+\" 或 \"-\" 的 \"inf\" 分别表示非数字 (NaN) 以及正或负无穷。"

#: ../../library/stdtypes.rst:349
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr "Python 将 ``pow(0, 0)`` 和 ``0 ** 0`` 定义为 ``1``，这是编程语言的普遍做法。"

#: ../../library/stdtypes.rst:353
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr "接受的数字字面值包括数码 ``0`` 到 ``9`` 或任何等效的 Unicode 字符（具有 ``Nd`` 特征属性的代码点）。"

#: ../../library/stdtypes.rst:356
msgid ""
"See "
"http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt "
"for a complete list of code points with the ``Nd`` property."
msgstr ""
"请参阅 "
"http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt "
"查看具有 ``Nd`` 特征属性的代码点的完整列表。"

#: ../../library/stdtypes.rst:360
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr "所有 :class:`numbers.Real` 类型 (:class:`int` 和 :class:`float`) 还包括下列运算:"

#: ../../library/stdtypes.rst:366
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:366
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* 截断为 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:369
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:369
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* 舍入到 *n* 位小数，半数值会舍入到偶数。 如果省略 *n*，则默认为 0。"

#: ../../library/stdtypes.rst:373
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:373
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "<= *x* 的最大 :class:`~numbers.Integral` "

#: ../../library/stdtypes.rst:376
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:376
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr ">= *x* 的最小 :class:`~numbers.Integral` "

#: ../../library/stdtypes.rst:380
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "有关更多的数字运算请参阅 :mod:`math` 和 :mod:`cmath` 模块。"

#: ../../library/stdtypes.rst:389
msgid "Bitwise Operations on Integer Types"
msgstr "整数类型的按位运算"

#: ../../library/stdtypes.rst:403
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr "按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。"

#: ../../library/stdtypes.rst:407
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and"
" ``-``)."
msgstr ""
"二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 ``~`` 具有与其他一元算术运算 (``+`` and ``-``) "
"相同的优先级。"

#: ../../library/stdtypes.rst:411
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "此表格是以优先级升序排序的按位运算列表:"

#: ../../library/stdtypes.rst:416
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:416
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`或`"

#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:419
#: ../../library/stdtypes.rst:422 ../../library/stdtypes.rst:1096
#: ../../library/stdtypes.rst:2221 ../../library/stdtypes.rst:2225
#: ../../library/stdtypes.rst:3353 ../../library/stdtypes.rst:3357
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:419
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:419
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`异或`"

#: ../../library/stdtypes.rst:422
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:422
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`与`"

#: ../../library/stdtypes.rst:425
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:425
msgid "*x* shifted left by *n* bits"
msgstr "*x* 左移 *n* 位"

#: ../../library/stdtypes.rst:425
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:427
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:427
msgid "*x* shifted right by *n* bits"
msgstr "*x* 右移 *n* 位"

#: ../../library/stdtypes.rst:427
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:429
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:429
msgid "the bits of *x* inverted"
msgstr "*x* 逐位取反"

#: ../../library/stdtypes.rst:435
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr "负的移位数是非法的，会导致引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:438
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr "左移 *n* 位等价于不带溢出检测地乘以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:442
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without"
" overflow check."
msgstr "右移 *n* 位等价于不带溢出检测地除以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:446
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + "
"max(x.bit_length(), y.bit_length())`` or more) is sufficient to get the same"
" result as if there were an infinite number of sign bits."
msgstr ""
"使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 ``1 + max(x.bit_length(), "
"y.bit_length())`` 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。"

#: ../../library/stdtypes.rst:453
msgid "Additional Methods on Integer Types"
msgstr "整数类型的附加方法"

#: ../../library/stdtypes.rst:455
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"int 类型实现了 :class:`numbers.Integral` :term:`abstract base class`。 "
"此外，它还提供了其他几个方法:"

#: ../../library/stdtypes.rst:460
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零::"

#: ../../library/stdtypes.rst:469
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr ""
"更准确地说，如果``x`` 非零，则 ``x.bit_length()`` 是使得 ``2**(k-1) <= abs(x) < 2**k`` "
"的唯一正整数 ``k``。 同样地，当 ``abs(x)`` 小到足以具有正确的舍入对数时，则 ``k = 1 + int(log(abs(x), "
"2))``。 如果 ``x`` 为零，则 ``x.bit_length()`` 返回 ``0``。"

#: ../../library/stdtypes.rst:475
msgid "Equivalent to::"
msgstr "等价于::"

#: ../../library/stdtypes.rst:486
msgid "Return an array of bytes representing an integer."
msgstr "返回表示一个整数的字节数组。"

#: ../../library/stdtypes.rst:498
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is"
" raised if the integer is not representable with the given number of bytes."
msgstr "整数会使用 *length* 个字节来表示。 如果整数不能用给定的字节数来表示则会引发 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:502 ../../library/stdtypes.rst:534
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the"
" beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"*byteorder* 参数确定用于表示整数的字节顺序。 如果 *byteorder* 为 ``\"big\"``，则最高位字节放在字节数组的开头。 "
"如果 *byteorder* 为 ``\"little\"``，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 "
":data:`sys.byteorder` 作为字节顺序值。"

#: ../../library/stdtypes.rst:509
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* 参数确定是否使用二的补码来表示整数。 如果 *signed* 为 ``False`` 并且给出的是负整数，则会引发 "
":exc:`OverflowError`。 *signed* 的默认值为 ``False``。"

#: ../../library/stdtypes.rst:518
msgid "Return the integer represented by the given array of bytes."
msgstr "返回由给定字节数组所表示的整数。"

#: ../../library/stdtypes.rst:531
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr "*bytes* 参数必须为一个 :term:`bytes-like object` 或是生成字节的可迭代对象。"

#: ../../library/stdtypes.rst:541
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 参数指明是否使用二的补码来表示整数。"

#: ../../library/stdtypes.rst:548
msgid "Additional Methods on Float"
msgstr "浮点类型的附加方法"

#: ../../library/stdtypes.rst:550
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"float 类型实现了 :class:`numbers.Real` :term:`abstract base class`。 float "
"还具有以下附加方法。"

#: ../../library/stdtypes.rst:555
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float"
" and with a positive denominator.  Raises :exc:`OverflowError` on infinities"
" and a :exc:`ValueError` on NaNs."
msgstr ""
"返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 :exc:`OverflowError` 而 NaN 则会引发 "
":exc:`ValueError`。"

#: ../../library/stdtypes.rst:562
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "如果 float 实例可用有限位整数表示则返回 ``True``，否则返回 ``False``::"

#: ../../library/stdtypes.rst:570
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 *十进制数* "
"字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。"

#: ../../library/stdtypes.rst:581
msgid ""
"Return a representation of a floating-point number as a hexadecimal string."
"  For finite floating-point numbers, this representation will always include"
" a leading ``0x`` and a trailing ``p`` and exponent."
msgstr "以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 ``0x`` 和尾随的 ``p`` 加指数。"

#: ../../library/stdtypes.rst:589
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr "返回以十六进制字符串 *s* 表示的浮点数的类方法。 字符串 *s* 可以带有前导和尾随的空格。"

#: ../../library/stdtypes.rst:594
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr "请注意 :meth:`float.hex` 是实例方法，而 :meth:`float.fromhex` 是类方法。"

#: ../../library/stdtypes.rst:597
msgid "A hexadecimal string takes the form::"
msgstr "十六进制字符串采用的形式为::"

#: ../../library/stdtypes.rst:601
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and"
" there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2"
" of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted"
" by :meth:`float.fromhex`."
msgstr ""
"可选的 ``sign`` 可以是 ``+`` 或 ``-``，``integer`` 和 ``fraction`` "
"是十六进制数码组成的字符串，``exponent`` 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction "
"中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 "
"特别地，:meth:`float.hex` 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 ``%a`` 格式字符或 "
"Java 的 ``Double.toHexString`` 所生成的十六进制数字符串由为 :meth:`float.fromhex` 所接受。"

#: ../../library/stdtypes.rst:614
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 ``0x3.a7p10`` 表示浮点数 "
"``(3 + 10./16 + 7./16**2) * 2.0**10`` 即 ``3740.0``::"

#: ../../library/stdtypes.rst:624
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr "对 ``3740.0`` 应用反向转换会得到另一个代表相同数值的十六进制数字符串::"

#: ../../library/stdtypes.rst:634
msgid "Hashing of numeric types"
msgstr "数字类型的哈希运算"

#: ../../library/stdtypes.rst:636
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement"
" that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, "
":class:`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) "
"Python's hash for numeric types is based on a single mathematical function "
"that's defined for any rational number, and hence applies to all instances "
"of :class:`int` and :class:`fractions.Fraction`, and all finite instances of"
" :class:`float` and :class:`decimal.Decimal`.  Essentially, this function is"
" given by reduction modulo ``P`` for a fixed prime ``P``.  The value of "
"``P`` is made available to Python as the :attr:`modulus` attribute of "
":data:`sys.hash_info`."
msgstr ""
"对于可能为不同类型的数字 ``x`` 和 ``y``，要求 ``x == y`` 时必定 ``hash(x) == hash(y)`` (详情参见 "
":meth:`__hash__` 方法的文档)。 为了便于在各种数字类型 (包括 :class:`int`, :class:`float`, "
":class:`decimal.Decimal` 和 :class:`fractions.Fraction`) 上实现并保证效率，Python "
"对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 :class:`int` 和 "
":class:`fractions.Fraction` 的全部实例，以及 :class:`float` 和 "
":class:`decimal.Decimal` 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 ``P`` 进行 ``P`` "
"降模给出的。 ``P`` 的值在 Python 中可以 :data:`sys.hash_info` 的 :attr:`modulus` "
"属性的形式被访问。"

#: ../../library/stdtypes.rst:651
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"目前所用的质数设定，在 C long 为 32 位的机器上 ``P = 2**31 - 1`` 而在 C long 为 64 位的机器上 ``P = "
"2**61 - 1``。"

#: ../../library/stdtypes.rst:654
msgid "Here are the rules in detail:"
msgstr "详细规则如下所述:"

#: ../../library/stdtypes.rst:656
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible"
" by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n,"
" P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"如果 ``x = m / n`` 是一个非负的有理数且 ``n`` 不可被 ``P`` 整除，则定义 ``hash(x)`` 为 ``m * "
"invmod(n, P) % P``，其中 ``invmod(n, P)`` 是对 ``n`` 模 ``P`` 取反。"

#: ../../library/stdtypes.rst:660
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule"
" above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"如果 ``x = m / n`` 是一个非负的有理数且 ``n`` 可被 ``P`` 整除（但 ``m`` 不能）则 ``n`` 不能对 ``P`` "
"降模，以上规则不适用；在此情况下则定义 ``hash(x)`` 为常数值 ``sys.hash_info.inf``。"

#: ../../library/stdtypes.rst:665
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as "
"``-hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"如果 ``x = m / n`` 是一个负的有理数则定义 ``hash(x)`` 为 ``-hash(-x)``。 如果结果哈希值为 ``-1`` "
"则将其替换为 ``-2``。"

#: ../../library/stdtypes.rst:669
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same"
" hash value.)"
msgstr ""

#: ../../library/stdtypes.rst:674
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, reduced modulo "
"``2**sys.hash_info.width`` so that it lies in "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))``.  "
"Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""

#: ../../library/stdtypes.rst:682
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, "
":class:`float`, or :class:`complex`::"
msgstr ""

#: ../../library/stdtypes.rst:737
msgid "Iterator Types"
msgstr ""

#: ../../library/stdtypes.rst:745
msgid ""
"Python supports a concept of iteration over containers.  This is implemented"
" using two distinct methods; these are used to allow user-defined classes to"
" support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""

#: ../../library/stdtypes.rst:750
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""

#: ../../library/stdtypes.rst:757
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:766
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""

#: ../../library/stdtypes.rst:772
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements. This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:780
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:785
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized forms."
"  The specific types are not important beyond their implementation of the "
"iterator protocol."
msgstr ""

#: ../../library/stdtypes.rst:790
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises "
":exc:`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""

#: ../../library/stdtypes.rst:798
msgid "Generator Types"
msgstr ""

#: ../../library/stdtypes.rst:800
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and "
":meth:`~generator.__next__` methods. More information about generators can "
"be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../library/stdtypes.rst:812
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr ""

#: ../../library/stdtypes.rst:814
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""

#: ../../library/stdtypes.rst:823
msgid "Common Sequence Operations"
msgstr ""

#: ../../library/stdtypes.rst:827
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom"
" sequence types."
msgstr ""

#: ../../library/stdtypes.rst:832
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k*"
" are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""

#: ../../library/stdtypes.rst:837
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""

#: ../../library/stdtypes.rst:858
msgid "``x in s``"
msgstr ""

#: ../../library/stdtypes.rst:858
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""

#: ../../library/stdtypes.rst:861
msgid "``x not in s``"
msgstr ""

#: ../../library/stdtypes.rst:861
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""

#: ../../library/stdtypes.rst:864
msgid "``s + t``"
msgstr ""

#: ../../library/stdtypes.rst:864
msgid "the concatenation of *s* and *t*"
msgstr ""

#: ../../library/stdtypes.rst:864
msgid "(6)(7)"
msgstr ""

#: ../../library/stdtypes.rst:867
msgid "``s * n`` or ``n * s``"
msgstr ""

#: ../../library/stdtypes.rst:867
msgid "equivalent to adding *s* to itself *n* times"
msgstr ""

#: ../../library/stdtypes.rst:867
msgid "(2)(7)"
msgstr ""

#: ../../library/stdtypes.rst:870
msgid "``s[i]``"
msgstr ""

#: ../../library/stdtypes.rst:870
msgid "*i*\\ th item of *s*, origin 0"
msgstr ""

#: ../../library/stdtypes.rst:872
msgid "``s[i:j]``"
msgstr ""

#: ../../library/stdtypes.rst:872
msgid "slice of *s* from *i* to *j*"
msgstr ""

#: ../../library/stdtypes.rst:872
msgid "(3)(4)"
msgstr ""

#: ../../library/stdtypes.rst:874
msgid "``s[i:j:k]``"
msgstr ""

#: ../../library/stdtypes.rst:874
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""

#: ../../library/stdtypes.rst:874
msgid "(3)(5)"
msgstr ""

#: ../../library/stdtypes.rst:877
msgid "``len(s)``"
msgstr ""

#: ../../library/stdtypes.rst:877
msgid "length of *s*"
msgstr ""

#: ../../library/stdtypes.rst:879
msgid "``min(s)``"
msgstr ""

#: ../../library/stdtypes.rst:879
msgid "smallest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:881
msgid "``max(s)``"
msgstr ""

#: ../../library/stdtypes.rst:881
msgid "largest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:883
msgid "``s.index(x[, i[, j]])``"
msgstr ""

#: ../../library/stdtypes.rst:883
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""

#: ../../library/stdtypes.rst:883 ../../library/stdtypes.rst:3339
msgid "\\(8)"
msgstr ""

#: ../../library/stdtypes.rst:887
msgid "``s.count(x)``"
msgstr ""

#: ../../library/stdtypes.rst:887
msgid "total number of occurrences of *x* in *s*"
msgstr ""

#: ../../library/stdtypes.rst:891
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal"
" and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../library/stdtypes.rst:900
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such as"
" :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""

#: ../../library/stdtypes.rst:921
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty"
" list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single"
" list. You can create a list of different lists this way::"
msgstr ""

#: ../../library/stdtypes.rst:933
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr ""

#: ../../library/stdtypes.rst:937
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*:"
" ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""

#: ../../library/stdtypes.rst:942
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal"
" to *j*, the slice is empty."
msgstr ""

#: ../../library/stdtypes.rst:949
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of"
" items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other"
" words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is"
" ``None``, it is treated like ``1``."
msgstr ""

#: ../../library/stdtypes.rst:960
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""

#: ../../library/stdtypes.rst:965
msgid ""
"if concatenating :class:`str` objects, you can build a list and use "
":meth:`str.join` at the end or else write to an :class:`io.StringIO` "
"instance and retrieve its value when complete"
msgstr ""

#: ../../library/stdtypes.rst:969
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use "
":meth:`bytes.join` or :class:`io.BytesIO`, or you can do in-place "
"concatenation with a :class:`bytearray` object.  :class:`bytearray` objects "
"are mutable and have an efficient overallocation mechanism"
msgstr ""

#: ../../library/stdtypes.rst:974
msgid ""
"if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""

#: ../../library/stdtypes.rst:976
msgid "for other types, investigate the relevant class documentation"
msgstr ""

#: ../../library/stdtypes.rst:980
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""

#: ../../library/stdtypes.rst:985
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only"
" without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""

#: ../../library/stdtypes.rst:996
msgid "Immutable Sequence Types"
msgstr ""

#: ../../library/stdtypes.rst:1003
msgid ""
"The only operation that immutable sequence types generally implement that is"
" not also implemented by mutable sequence types is support for the "
":func:`hash` built-in."
msgstr ""

#: ../../library/stdtypes.rst:1007
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and "
":class:`frozenset` instances."
msgstr ""

#: ../../library/stdtypes.rst:1011
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""

#: ../../library/stdtypes.rst:1018
msgid "Mutable Sequence Types"
msgstr ""

#: ../../library/stdtypes.rst:1025
msgid ""
"The operations in the following table are defined on mutable sequence types."
" The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""

#: ../../library/stdtypes.rst:1029
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value"
" restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""

#: ../../library/stdtypes.rst:1053
msgid "``s[i] = x``"
msgstr ""

#: ../../library/stdtypes.rst:1053
msgid "item *i* of *s* is replaced by *x*"
msgstr ""

#: ../../library/stdtypes.rst:1056
msgid "``s[i:j] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1056
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""

#: ../../library/stdtypes.rst:1060
msgid "``del s[i:j]``"
msgstr ""

#: ../../library/stdtypes.rst:1060
msgid "same as ``s[i:j] = []``"
msgstr ""

#: ../../library/stdtypes.rst:1062
msgid "``s[i:j:k] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1062
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""

#: ../../library/stdtypes.rst:1065
msgid "``del s[i:j:k]``"
msgstr ""

#: ../../library/stdtypes.rst:1065
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr ""

#: ../../library/stdtypes.rst:1068
msgid "``s.append(x)``"
msgstr ""

#: ../../library/stdtypes.rst:1068
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""

#: ../../library/stdtypes.rst:1072
msgid "``s.clear()``"
msgstr ""

#: ../../library/stdtypes.rst:1072
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr ""

#: ../../library/stdtypes.rst:1075
msgid "``s.copy()``"
msgstr ""

#: ../../library/stdtypes.rst:1075
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr ""

#: ../../library/stdtypes.rst:1078
msgid "``s.extend(t)`` or ``s += t``"
msgstr ""

#: ../../library/stdtypes.rst:1078
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""

#: ../../library/stdtypes.rst:1083
msgid "``s *= n``"
msgstr ""

#: ../../library/stdtypes.rst:1083
msgid "updates *s* with its contents repeated *n* times"
msgstr ""

#: ../../library/stdtypes.rst:1086
msgid "``s.insert(i, x)``"
msgstr ""

#: ../../library/stdtypes.rst:1086
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""

#: ../../library/stdtypes.rst:1090
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../../library/stdtypes.rst:1090
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr ""

#: ../../library/stdtypes.rst:1093
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1093
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "删除 *s* 中第一个 ``s[i]`` 等于 *x* 的项目。"

#: ../../library/stdtypes.rst:1096
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1096
msgid "reverses the items of *s* in place"
msgstr "就地将列表中的元素逆序。"

#: ../../library/stdtypes.rst:1104
msgid "*t* must have the same length as the slice it is replacing."
msgstr ""

#: ../../library/stdtypes.rst:1107
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""

#: ../../library/stdtypes.rst:1111
msgid "``remove`` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""

#: ../../library/stdtypes.rst:1114
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""

#: ../../library/stdtypes.rst:1119
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such"
" as :class:`dict` and :class:`set`)"
msgstr ""

#: ../../library/stdtypes.rst:1123
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` 和 :meth:`!copy` 方法。"

#: ../../library/stdtypes.rst:1127
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""

#: ../../library/stdtypes.rst:1136
msgid "Lists"
msgstr "列表"

#: ../../library/stdtypes.rst:1140
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr "列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。"

#: ../../library/stdtypes.rst:1146
msgid "Lists may be constructed in several ways:"
msgstr ""

#: ../../library/stdtypes.rst:1148
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""

#: ../../library/stdtypes.rst:1149
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""

#: ../../library/stdtypes.rst:1150
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr ""

#: ../../library/stdtypes.rst:1151
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""

#: ../../library/stdtypes.rst:1153
msgid ""
"The constructor builds a list whose items are the same and in the same order"
" as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:1162
msgid ""
"Many other operations also produce lists, including the :func:`sorted` "
"built-in."
msgstr ""

#: ../../library/stdtypes.rst:1165
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable"
" <typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""

#: ../../library/stdtypes.rst:1171
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""

#: ../../library/stdtypes.rst:1176
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref"
":`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""

#: ../../library/stdtypes.rst:1179
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""

#: ../../library/stdtypes.rst:1186
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style"
" *cmp* function to a *key* function."
msgstr ""

#: ../../library/stdtypes.rst:1189
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* 为一个布尔值。 如果设为 ``True``，则每个列表元素将按反向顺序比较进行排序。"

#: ../../library/stdtypes.rst:1192
msgid ""
"This method modifies the sequence in place for economy of space when sorting"
" a large sequence.  To remind users that it operates by side effect, it does"
" not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""

#: ../../library/stdtypes.rst:1197
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""

#: ../../library/stdtypes.rst:1204
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""

#: ../../library/stdtypes.rst:1213
msgid "Tuples"
msgstr "元组"

#: ../../library/stdtypes.rst:1217
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or "
":class:`dict` instance)."
msgstr ""

#: ../../library/stdtypes.rst:1225
msgid "Tuples may be constructed in a number of ways:"
msgstr ""

#: ../../library/stdtypes.rst:1227
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""

#: ../../library/stdtypes.rst:1228
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""

#: ../../library/stdtypes.rst:1229
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr ""

#: ../../library/stdtypes.rst:1230
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""

#: ../../library/stdtypes.rst:1232
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""

#: ../../library/stdtypes.rst:1240
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses."
" The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""

#: ../../library/stdtypes.rst:1246
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""

#: ../../library/stdtypes.rst:1249
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""

#: ../../library/stdtypes.rst:1257
msgid "Ranges"
msgstr ""

#: ../../library/stdtypes.rst:1261
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` "
"loops."
msgstr ""

#: ../../library/stdtypes.rst:1268
msgid ""
"The arguments to the range constructor must be integers (either built-in "
":class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, "
":exc:`ValueError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:1274
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""

#: ../../library/stdtypes.rst:1278
msgid ""
"For a negative *step*, the contents of the range are still determined by the"
" formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""

#: ../../library/stdtypes.rst:1282
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint."
" Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""

#: ../../library/stdtypes.rst:1287
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise "
":exc:`OverflowError`."
msgstr ""

#: ../../library/stdtypes.rst:1291
msgid "Range examples::"
msgstr ""

#: ../../library/stdtypes.rst:1308
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""

#: ../../library/stdtypes.rst:1315
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""

#: ../../library/stdtypes.rst:1320
msgid "The value of the *stop* parameter"
msgstr ""

#: ../../library/stdtypes.rst:1324
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""

#: ../../library/stdtypes.rst:1327
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or "
":class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""

#: ../../library/stdtypes.rst:1333
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""

#: ../../library/stdtypes.rst:1353
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop`"
" and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""

#: ../../library/stdtypes.rst:1360
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test "
":class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""

#: ../../library/stdtypes.rst:1366
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""

#: ../../library/stdtypes.rst:1371
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""

#: ../../library/stdtypes.rst:1377
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""

#: ../../library/stdtypes.rst:1389
msgid "Text Sequence Type --- :class:`str`"
msgstr ""

#: ../../library/stdtypes.rst:1391
msgid ""
"Textual data in Python is handled with :class:`str` objects, or "
":dfn:`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode"
" code points.  String literals are written in a variety of ways:"
msgstr ""

#: ../../library/stdtypes.rst:1396
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr ""

#: ../../library/stdtypes.rst:1397
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr ""

#: ../../library/stdtypes.rst:1398
msgid "Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes\"\"\"``"
msgstr ""

#: ../../library/stdtypes.rst:1400
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""

#: ../../library/stdtypes.rst:1403
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""

#: ../../library/stdtypes.rst:1407
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""

#: ../../library/stdtypes.rst:1411
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""

#: ../../library/stdtypes.rst:1414
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == "
"s[0:1]``."
msgstr ""

#: ../../library/stdtypes.rst:1420
msgid ""
"There is also no mutable string type, but :meth:`str.join` or "
":class:`io.StringIO` can be used to efficiently construct strings from "
"multiple fragments."
msgstr ""

#: ../../library/stdtypes.rst:1424
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""

#: ../../library/stdtypes.rst:1436
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""

#: ../../library/stdtypes.rst:1440
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns "
":meth:`object.__str__() <object.__str__>`, which is the \"informal\" or "
"nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a "
":meth:`~object.__str__` method, then :func:`str` falls back to returning "
":meth:`repr(object) <repr>`."
msgstr ""

#: ../../library/stdtypes.rst:1451
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a "
":term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to "
":meth:`bytes.decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes"
" object underlying the buffer object is obtained before calling "
":meth:`bytes.decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for "
"information on buffer objects."
msgstr ""

#: ../../library/stdtypes.rst:1460
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""

#: ../../library/stdtypes.rst:1468
msgid ""
"For more information on the ``str`` class and its methods, see "
":ref:`textseq` and the :ref:`string-methods` section below.  To output "
"formatted strings, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections.  In addition, see the :ref:`stringservices` section."
msgstr ""

#: ../../library/stdtypes.rst:1480
msgid "String Methods"
msgstr ""

#: ../../library/stdtypes.rst:1485
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""

#: ../../library/stdtypes.rst:1488
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, "
":ref:`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""

#: ../../library/stdtypes.rst:1495
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular"
" expression support in the :mod:`re` module)."
msgstr ""

#: ../../library/stdtypes.rst:1501
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""

#: ../../library/stdtypes.rst:1507
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""

#: ../../library/stdtypes.rst:1510
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; "
":meth:`casefold` converts it to ``\"ss\"``."
msgstr ""

#: ../../library/stdtypes.rst:1516
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1524
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1532
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../library/stdtypes.rst:1539
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other"
" name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""

#: ../../library/stdtypes.rst:1548
msgid "Support for keyword arguments added."
msgstr ""

#: ../../library/stdtypes.rst:1554
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:1562
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current"
" column is set to zero and the string is examined character by character.  "
"If the character is a tab (``\\t``), one or more space characters are "
"inserted in the result until the current column is equal to the next tab "
"position. (The tab character itself is not copied.)  If the character is a "
"newline (``\\n``) or return (``\\r``), it is copied and the current column "
"is reset to zero.  Any other character is copied unchanged and the current "
"column is incremented by one regardless of how the character is represented "
"when printed."
msgstr ""

#: ../../library/stdtypes.rst:1583
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:1589
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""

#: ../../library/stdtypes.rst:1599
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of"
" the corresponding argument."
msgstr ""

#: ../../library/stdtypes.rst:1609
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options"
" that can be specified in format strings."
msgstr ""

#: ../../library/stdtypes.rst:1613
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, "
":class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: "
"``'{:n}'.format(1234)``), the function temporarily sets the ``LC_CTYPE`` "
"locale to the ``LC_NUMERIC`` locale to decode ``decimal_point`` and "
"``thousands_sep`` fields of :c:func:`localeconv` if they are non-ASCII or "
"longer than 1 byte, and the ``LC_NUMERIC`` locale is different than the "
"``LC_CTYPE`` locale.  This temporary change affects other threads."
msgstr ""

#: ../../library/stdtypes.rst:1622
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""

#: ../../library/stdtypes.rst:1630
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""

#: ../../library/stdtypes.rst:1646
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""

#: ../../library/stdtypes.rst:1652
msgid ""
"Return true if all characters in the string are alphanumeric and there is at"
" least one character, false otherwise.  A character ``c`` is alphanumeric if"
" one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""

#: ../../library/stdtypes.rst:1660
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., "
"those with general category property being one of \"Lm\", \"Lt\", \"Lu\", "
"\"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""

#: ../../library/stdtypes.rst:1669
msgid ""
"Return true if the string is empty or all characters in the string are "
"ASCII, false otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""

#: ../../library/stdtypes.rst:1678
msgid ""
"Return true if all characters in the string are decimal characters and there"
" is at least one character, false otherwise. Decimal characters are those "
"that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT"
" ZERO.  Formally a decimal character is a character in the Unicode General "
"Category \"Nd\"."
msgstr ""

#: ../../library/stdtypes.rst:1688
msgid ""
"Return true if all characters in the string are digits and there is at least"
" one character, false otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""

#: ../../library/stdtypes.rst:1698
msgid ""
"Return true if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr ""

#: ../../library/stdtypes.rst:1701
msgid ""
"Use :func:`keyword.iskeyword` to test for reserved identifiers such as "
":keyword:`def` and :keyword:`class`."
msgstr ""

#: ../../library/stdtypes.rst:1706
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1712
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters include"
" digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""

#: ../../library/stdtypes.rst:1722
msgid ""
"Return true if all characters in the string are printable or the string is "
"empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling"
" of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""

#: ../../library/stdtypes.rst:1733
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise.  Whitespace characters  are "
"those characters defined in the Unicode character database as \"Other\" or "
"\"Separator\" and those with bidirectional property being one of \"WS\", "
"\"B\", or \"S\"."
msgstr ""

#: ../../library/stdtypes.rst:1740
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false "
"otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1747
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1753
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A "
":exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""

#: ../../library/stdtypes.rst:1761
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1768
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""

#: ../../library/stdtypes.rst:1771
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1777
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values"
" are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:1790
msgid ""
"This static method returns a translation table usable for "
":meth:`str.translate`."
msgstr ""

#: ../../library/stdtypes.rst:1792
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals,"
" strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""

#: ../../library/stdtypes.rst:1797
msgid ""
"If there are two arguments, they must be strings of equal length, and in the"
" resulting dictionary, each character in x will be mapped to the character "
"at the same position in y.  If there is a third argument, it must be a "
"string, whose characters will be mapped to ``None`` in the result."
msgstr ""

#: ../../library/stdtypes.rst:1805
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""

#: ../../library/stdtypes.rst:1813
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced"
" by *new*.  If the optional argument *count* is given, only the first "
"*count* occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:1820
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start*"
" and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""

#: ../../library/stdtypes.rst:1827
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""

#: ../../library/stdtypes.rst:1833
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1840
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""

#: ../../library/stdtypes.rst:1848
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""

#: ../../library/stdtypes.rst:1857
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values"
" are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:1870
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""

#: ../../library/stdtypes.rst:1876
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""

#: ../../library/stdtypes.rst:1882 ../../library/stdtypes.rst:1898
#: ../../library/stdtypes.rst:1950 ../../library/stdtypes.rst:2018
#: ../../library/stdtypes.rst:2082 ../../library/stdtypes.rst:2843
#: ../../library/stdtypes.rst:2859 ../../library/stdtypes.rst:2950
#: ../../library/stdtypes.rst:2966 ../../library/stdtypes.rst:2991
#: ../../library/stdtypes.rst:3005 ../../library/stdtypes.rst:3033
#: ../../library/stdtypes.rst:3047 ../../library/stdtypes.rst:3065
#: ../../library/stdtypes.rst:3092 ../../library/stdtypes.rst:3115
#: ../../library/stdtypes.rst:3142 ../../library/stdtypes.rst:3184
#: ../../library/stdtypes.rst:3208
msgid "For example::"
msgstr "例如::"

#: ../../library/stdtypes.rst:1891
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive whitespace are regarded as a single separator,"
" and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty"
" string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:1913
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line"
" breaks are not included in the resulting list unless *keepends* is given "
"and true."
msgstr ""

#: ../../library/stdtypes.rst:1917
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""

#: ../../library/stdtypes.rst:1921
msgid "Representation"
msgstr ""

#: ../../library/stdtypes.rst:1921
msgid "Description"
msgstr "描述"

#: ../../library/stdtypes.rst:1923
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1923
msgid "Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:1925
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1925
msgid "Carriage Return"
msgstr ""

#: ../../library/stdtypes.rst:1927
msgid "``\\r\\n``"
msgstr ""

#: ../../library/stdtypes.rst:1927
msgid "Carriage Return + Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:1929
msgid "``\\v`` or ``\\x0b``"
msgstr ""

#: ../../library/stdtypes.rst:1929
msgid "Line Tabulation"
msgstr ""

#: ../../library/stdtypes.rst:1931
msgid "``\\f`` or ``\\x0c``"
msgstr ""

#: ../../library/stdtypes.rst:1931
msgid "Form Feed"
msgstr ""

#: ../../library/stdtypes.rst:1933
msgid "``\\x1c``"
msgstr ""

#: ../../library/stdtypes.rst:1933
msgid "File Separator"
msgstr ""

#: ../../library/stdtypes.rst:1935
msgid "``\\x1d``"
msgstr ""

#: ../../library/stdtypes.rst:1935
msgid "Group Separator"
msgstr ""

#: ../../library/stdtypes.rst:1937
msgid "``\\x1e``"
msgstr ""

#: ../../library/stdtypes.rst:1937
msgid "Record Separator"
msgstr ""

#: ../../library/stdtypes.rst:1939
msgid "``\\x85``"
msgstr ""

#: ../../library/stdtypes.rst:1939
msgid "Next Line (C1 Control Code)"
msgstr ""

#: ../../library/stdtypes.rst:1941
msgid "``\\u2028``"
msgstr ""

#: ../../library/stdtypes.rst:1941
msgid "Line Separator"
msgstr ""

#: ../../library/stdtypes.rst:1943
msgid "``\\u2029``"
msgstr ""

#: ../../library/stdtypes.rst:1943
msgid "Paragraph Separator"
msgstr ""

#: ../../library/stdtypes.rst:1948
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr ""

#: ../../library/stdtypes.rst:1957
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""

#: ../../library/stdtypes.rst:1966
msgid "For comparison, ``split('\\n')`` gives::"
msgstr ""

#: ../../library/stdtypes.rst:1976
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""

#: ../../library/stdtypes.rst:1984
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather,"
" all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:1995
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from"
" the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""

#: ../../library/stdtypes.rst:2008
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase"
" and vice versa. Note that it is not necessarily true that "
"``s.swapcase().swapcase() == s``."
msgstr ""

#: ../../library/stdtypes.rst:2015
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""

#: ../../library/stdtypes.rst:2023 ../../library/stdtypes.rst:3152
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it"
" means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr ""

#: ../../library/stdtypes.rst:2031 ../../library/stdtypes.rst:3160
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""

#: ../../library/stdtypes.rst:2046
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or "
":term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table"
" object can do any of the following: return a Unicode ordinal or a string, "
"to map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""

#: ../../library/stdtypes.rst:2055
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from "
"character-to-character mappings in different formats."
msgstr ""

#: ../../library/stdtypes.rst:2058
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""

#: ../../library/stdtypes.rst:2064
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:2070
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:2076
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled"
" by inserting the padding *after* the sign character rather than before. The"
" original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2094
msgid "``printf``-style String Formatting"
msgstr ""

#: ../../library/stdtypes.rst:2107
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals "
"<f-strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives"
" provides their own trade-offs and benefits of simplicity, flexibility, "
"and/or extensibility."
msgstr ""

#: ../../library/stdtypes.rst:2115
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""

#: ../../library/stdtypes.rst:2121
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: ../../library/stdtypes.rst:2131 ../../library/stdtypes.rst:3263
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr ""

#: ../../library/stdtypes.rst:2134 ../../library/stdtypes.rst:3266
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../library/stdtypes.rst:2136 ../../library/stdtypes.rst:3268
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters"
" (for example, ``(somename)``)."
msgstr ""

#: ../../library/stdtypes.rst:2139 ../../library/stdtypes.rst:3271
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: ../../library/stdtypes.rst:2142 ../../library/stdtypes.rst:3274
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the"
" object to convert comes after the minimum field width and optional "
"precision."
msgstr ""

#: ../../library/stdtypes.rst:2146 ../../library/stdtypes.rst:3278
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the"
" next element of the tuple in *values*, and the value to convert comes after"
" the precision."
msgstr ""

#: ../../library/stdtypes.rst:2151 ../../library/stdtypes.rst:3283
msgid "Length modifier (optional)."
msgstr ""

#: ../../library/stdtypes.rst:2153 ../../library/stdtypes.rst:3285
msgid "Conversion type."
msgstr ""

#: ../../library/stdtypes.rst:2155
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key"
" selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../library/stdtypes.rst:2164 ../../library/stdtypes.rst:3296
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a"
" sequential parameter list)."
msgstr ""

#: ../../library/stdtypes.rst:2167 ../../library/stdtypes.rst:3299
msgid "The conversion flag characters are:"
msgstr ""

#: ../../library/stdtypes.rst:2176 ../../library/stdtypes.rst:3308
msgid "Flag"
msgstr "标志"

#: ../../library/stdtypes.rst:2178 ../../library/stdtypes.rst:3310
msgid "``'#'``"
msgstr ""

#: ../../library/stdtypes.rst:2178 ../../library/stdtypes.rst:3310
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: ../../library/stdtypes.rst:2181 ../../library/stdtypes.rst:3313
msgid "``'0'``"
msgstr ""

#: ../../library/stdtypes.rst:2181 ../../library/stdtypes.rst:3313
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../library/stdtypes.rst:2183 ../../library/stdtypes.rst:3315
msgid "``'-'``"
msgstr ""

#: ../../library/stdtypes.rst:2183 ../../library/stdtypes.rst:3315
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""

#: ../../library/stdtypes.rst:2186 ../../library/stdtypes.rst:3318
msgid "``' '``"
msgstr ""

#: ../../library/stdtypes.rst:2186 ../../library/stdtypes.rst:3318
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#: ../../library/stdtypes.rst:2189 ../../library/stdtypes.rst:3321
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2189 ../../library/stdtypes.rst:3321
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides"
" a \"space\" flag)."
msgstr ""

#: ../../library/stdtypes.rst:2193 ../../library/stdtypes.rst:3325
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as"
" it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: ../../library/stdtypes.rst:2196 ../../library/stdtypes.rst:3328
msgid "The conversion types are:"
msgstr ""

#: ../../library/stdtypes.rst:2199 ../../library/stdtypes.rst:3331
msgid "Conversion"
msgstr ""

#: ../../library/stdtypes.rst:2201 ../../library/stdtypes.rst:3333
msgid "``'d'``"
msgstr ""

#: ../../library/stdtypes.rst:2201 ../../library/stdtypes.rst:2203
#: ../../library/stdtypes.rst:3333 ../../library/stdtypes.rst:3335
msgid "Signed integer decimal."
msgstr ""

#: ../../library/stdtypes.rst:2203 ../../library/stdtypes.rst:3335
msgid "``'i'``"
msgstr ""

#: ../../library/stdtypes.rst:2205 ../../library/stdtypes.rst:3337
msgid "``'o'``"
msgstr ""

#: ../../library/stdtypes.rst:2205 ../../library/stdtypes.rst:3337
msgid "Signed octal value."
msgstr ""

#: ../../library/stdtypes.rst:2207 ../../library/stdtypes.rst:3339
msgid "``'u'``"
msgstr ""

#: ../../library/stdtypes.rst:2207 ../../library/stdtypes.rst:3339
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: ../../library/stdtypes.rst:2209 ../../library/stdtypes.rst:3341
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2209 ../../library/stdtypes.rst:3341
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:2211 ../../library/stdtypes.rst:3343
msgid "``'X'``"
msgstr ""

#: ../../library/stdtypes.rst:2211 ../../library/stdtypes.rst:3343
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3345
msgid "``'e'``"
msgstr ""

#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3345
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:2215 ../../library/stdtypes.rst:3347
msgid "``'E'``"
msgstr ""

#: ../../library/stdtypes.rst:2215 ../../library/stdtypes.rst:3347
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:2217 ../../library/stdtypes.rst:3349
msgid "``'f'``"
msgstr ""

#: ../../library/stdtypes.rst:2217 ../../library/stdtypes.rst:2219
#: ../../library/stdtypes.rst:3349 ../../library/stdtypes.rst:3351
msgid "Floating point decimal format."
msgstr ""

#: ../../library/stdtypes.rst:2219 ../../library/stdtypes.rst:3351
msgid "``'F'``"
msgstr ""

#: ../../library/stdtypes.rst:2221 ../../library/stdtypes.rst:3353
msgid "``'g'``"
msgstr ""

#: ../../library/stdtypes.rst:2221 ../../library/stdtypes.rst:3353
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2225 ../../library/stdtypes.rst:3357
msgid "``'G'``"
msgstr ""

#: ../../library/stdtypes.rst:2225 ../../library/stdtypes.rst:3357
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2229 ../../library/stdtypes.rst:3361
msgid "``'c'``"
msgstr ""

#: ../../library/stdtypes.rst:2229
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: ../../library/stdtypes.rst:2232 ../../library/stdtypes.rst:3374
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2232
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""

#: ../../library/stdtypes.rst:2235 ../../library/stdtypes.rst:3368
msgid "``'s'``"
msgstr ""

#: ../../library/stdtypes.rst:2235
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: ../../library/stdtypes.rst:2238 ../../library/stdtypes.rst:3371
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2238
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""

#: ../../library/stdtypes.rst:2241 ../../library/stdtypes.rst:3377
msgid "``'%'``"
msgstr ""

#: ../../library/stdtypes.rst:2241 ../../library/stdtypes.rst:3377
msgid ""
"No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: ../../library/stdtypes.rst:2248 ../../library/stdtypes.rst:3384
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""

#: ../../library/stdtypes.rst:2252 ../../library/stdtypes.rst:3388
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""

#: ../../library/stdtypes.rst:2256 ../../library/stdtypes.rst:3392
msgid ""
"The alternate form causes the result to always contain a decimal point, even"
" if no digits follow it."
msgstr ""

#: ../../library/stdtypes.rst:2259 ../../library/stdtypes.rst:3395
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:2263 ../../library/stdtypes.rst:3399
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: ../../library/stdtypes.rst:2266 ../../library/stdtypes.rst:3402
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:2270 ../../library/stdtypes.rst:3406
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr ""

#: ../../library/stdtypes.rst:2273 ../../library/stdtypes.rst:3415
msgid "See :pep:`237`."
msgstr ""

#: ../../library/stdtypes.rst:2275
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""

#: ../../library/stdtypes.rst:2280
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""

#: ../../library/stdtypes.rst:2291
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, "
":class:`memoryview`"
msgstr ""

#: ../../library/stdtypes.rst:2299
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and "
":class:`bytearray`. They are supported by :class:`memoryview` which uses the"
" :ref:`buffer protocol <bufferobjects>` to access the memory of other binary"
" objects without needing to make a copy."
msgstr ""

#: ../../library/stdtypes.rst:2304
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""

#: ../../library/stdtypes.rst:2310
msgid "Bytes Objects"
msgstr ""

#: ../../library/stdtypes.rst:2314
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""

#: ../../library/stdtypes.rst:2321
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""

#: ../../library/stdtypes.rst:2324
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""

#: ../../library/stdtypes.rst:2325
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr ""

#: ../../library/stdtypes.rst:2326
msgid "Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""

#: ../../library/stdtypes.rst:2328
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""

#: ../../library/stdtypes.rst:2332
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""

#: ../../library/stdtypes.rst:2336
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based"
" elements and can be usefully manipulated with some text-oriented "
"algorithms, this is not generally the case for arbitrary binary data "
"(blindly applying text processing algorithms to binary data formats that are"
" not ASCII compatible will usually lead to data corruption)."
msgstr ""

#: ../../library/stdtypes.rst:2346
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""

#: ../../library/stdtypes.rst:2349
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""

#: ../../library/stdtypes.rst:2350
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr ""

#: ../../library/stdtypes.rst:2351
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""

#: ../../library/stdtypes.rst:2353
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ""

#: ../../library/stdtypes.rst:2355
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""

#: ../../library/stdtypes.rst:2361
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""

#: ../../library/stdtypes.rst:2368
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just"
" spaces."
msgstr ""

#: ../../library/stdtypes.rst:2372
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""

#: ../../library/stdtypes.rst:2377 ../../library/stdtypes.rst:2453
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""

#: ../../library/stdtypes.rst:2385
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes"
" object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""

#: ../../library/stdtypes.rst:2390
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""

#: ../../library/stdtypes.rst:2395
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition."
" In Python 3.x, those implicit conversions are gone - conversions between "
"8-bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""

#: ../../library/stdtypes.rst:2408
msgid "Bytearray Objects"
msgstr ""

#: ../../library/stdtypes.rst:2412
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""

#: ../../library/stdtypes.rst:2417
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are"
" always created by calling the constructor:"
msgstr ""

#: ../../library/stdtypes.rst:2420
msgid "Creating an empty instance: ``bytearray()``"
msgstr ""

#: ../../library/stdtypes.rst:2421
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""

#: ../../library/stdtypes.rst:2422
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr ""

#: ../../library/stdtypes.rst:2423
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""

#: ../../library/stdtypes.rst:2425
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""

#: ../../library/stdtypes.rst:2429
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""

#: ../../library/stdtypes.rst:2431
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""

#: ../../library/stdtypes.rst:2437
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""

#: ../../library/stdtypes.rst:2444
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""

#: ../../library/stdtypes.rst:2448
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""

#: ../../library/stdtypes.rst:2461
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""

#: ../../library/stdtypes.rst:2466
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into"
" a list of integers using ``list(b)``."
msgstr ""

#: ../../library/stdtypes.rst:2475
msgid "Bytes and Bytearray Operations"
msgstr ""

#: ../../library/stdtypes.rst:2480
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>`"
" sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""

#: ../../library/stdtypes.rst:2488
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""

#: ../../library/stdtypes.rst:2495
msgid "and::"
msgstr ""

#: ../../library/stdtypes.rst:2500
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""

#: ../../library/stdtypes.rst:2505
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""

#: ../../library/stdtypes.rst:2508
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""

#: ../../library/stdtypes.rst:2514
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the"
" range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../library/stdtypes.rst:2518 ../../library/stdtypes.rst:2565
#: ../../library/stdtypes.rst:2587 ../../library/stdtypes.rst:2653
#: ../../library/stdtypes.rst:2666
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""

#: ../../library/stdtypes.rst:2521 ../../library/stdtypes.rst:2577
#: ../../library/stdtypes.rst:2590 ../../library/stdtypes.rst:2656
#: ../../library/stdtypes.rst:2669
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""

#: ../../library/stdtypes.rst:2528
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling scheme."
"  The default for *errors* is ``'strict'``, meaning that encoding errors "
"raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`error-handlers`. For a list"
" of possible encodings, see section :ref:`standard-encodings`."
msgstr ""

#: ../../library/stdtypes.rst:2538
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term"
":`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""

#: ../../library/stdtypes.rst:2542
msgid "Added support for keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:2549
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:2554
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2560
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:2570
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""

#: ../../library/stdtypes.rst:2584
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""

#: ../../library/stdtypes.rst:2597
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""

#: ../../library/stdtypes.rst:2608
msgid ""
"This static method returns a translation table usable for "
":meth:`bytes.translate` that will map each character in *from* into the "
"character at the same position in *to*; *from* and *to* must both be :term"
":`bytes-like objects <bytes-like object>` and have the same length."
msgstr ""

#: ../../library/stdtypes.rst:2619
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed"
" by two empty bytes or bytearray objects."
msgstr ""

#: ../../library/stdtypes.rst:2626 ../../library/stdtypes.rst:2683
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2632
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:2636
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""

#: ../../library/stdtypes.rst:2641 ../../library/stdtypes.rst:2734
#: ../../library/stdtypes.rst:2748 ../../library/stdtypes.rst:2772
#: ../../library/stdtypes.rst:2786 ../../library/stdtypes.rst:2821
#: ../../library/stdtypes.rst:2891 ../../library/stdtypes.rst:2909
#: ../../library/stdtypes.rst:2937 ../../library/stdtypes.rst:3076
#: ../../library/stdtypes.rst:3131 ../../library/stdtypes.rst:3174
#: ../../library/stdtypes.rst:3195 ../../library/stdtypes.rst:3217
#: ../../library/stdtypes.rst:3419
msgid ""
"The bytearray version of this method does *not* operate in place - it always"
" produces a new object, even if no changes were made."
msgstr ""

#: ../../library/stdtypes.rst:2648
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""

#: ../../library/stdtypes.rst:2663
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:2676
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed"
" by two empty bytes or bytearray objects."
msgstr ""

#: ../../library/stdtypes.rst:2689
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:2694
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2700
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""

#: ../../library/stdtypes.rst:2705
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation "
"table."
msgstr ""

#: ../../library/stdtypes.rst:2708
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""

#: ../../library/stdtypes.rst:2714
msgid "*delete* is now supported as a keyword argument."
msgstr ""

#: ../../library/stdtypes.rst:2718
msgid ""
"The following methods on bytes and bytearray objects have default behaviours"
" that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""

#: ../../library/stdtypes.rst:2727
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2741
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2755
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:2767 ../../library/stdtypes.rst:2816
#: ../../library/stdtypes.rst:2886
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""

#: ../../library/stdtypes.rst:2779
msgid ""
"Return a copy of the object right justified in a sequence of length *width*."
" Padding is done using the specified *fillbyte* (default is an ASCII space)."
" For :class:`bytes` objects, the original sequence is returned if *width* is"
" less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2793
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are"
" done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for"
" splitting from the right, :meth:`rsplit` behaves like :meth:`split` which "
"is described in detail below."
msgstr ""

#: ../../library/stdtypes.rst:2804
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:2828
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""

#: ../../library/stdtypes.rst:2834
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of"
" object being split.  The *sep* argument may be any :term:`bytes-like "
"object`."
msgstr ""

#: ../../library/stdtypes.rst:2852
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting"
" an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:2873
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:2895
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII"
" compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""

#: ../../library/stdtypes.rst:2903
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII"
" byte values are passed through unchanged."
msgstr ""

#: ../../library/stdtypes.rst:2916
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by"
" one or more ASCII spaces, depending on the current column and the given tab"
" size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If"
" the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""

#: ../../library/stdtypes.rst:2944
msgid ""
"Return true if all bytes in the sequence are alphabetical ASCII characters "
"or ASCII decimal digits and the sequence is not empty, false otherwise. "
"Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""

#: ../../library/stdtypes.rst:2961
msgid ""
"Return true if all bytes in the sequence are alphabetic ASCII characters and"
" the sequence is not empty, false otherwise.  Alphabetic ASCII characters "
"are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: ../../library/stdtypes.rst:2977
msgid ""
"Return true if the sequence is empty or all bytes in the sequence are ASCII,"
" false otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""

#: ../../library/stdtypes.rst:2987
msgid ""
"Return true if all bytes in the sequence are ASCII decimal digits and the "
"sequence is not empty, false otherwise. ASCII decimal digits are those byte "
"values in the sequence ``b'0123456789'``."
msgstr ""

#: ../../library/stdtypes.rst:3002
msgid ""
"Return true if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:3012 ../../library/stdtypes.rst:3054
#: ../../library/stdtypes.rst:3070 ../../library/stdtypes.rst:3120
#: ../../library/stdtypes.rst:3189
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: ../../library/stdtypes.rst:3020
msgid ""
"Return true if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, false otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""

#: ../../library/stdtypes.rst:3029
msgid ""
"Return true if the sequence is ASCII titlecase and the sequence is not "
"empty, false otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""

#: ../../library/stdtypes.rst:3044
msgid ""
"Return true if there is at least one uppercase alphabetic ASCII character in"
" the sequence and no lowercase ASCII characters, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:3062
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""

#: ../../library/stdtypes.rst:3087
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""

#: ../../library/stdtypes.rst:3099
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""

#: ../../library/stdtypes.rst:3112
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""

#: ../../library/stdtypes.rst:3124
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that "
"``bin.swapcase().swapcase() == bin`` for the binary versions. Case "
"conversions are symmetrical in ASCII, even though that is not generally true"
" for arbitrary Unicode code points."
msgstr ""

#: ../../library/stdtypes.rst:3138
msgid ""
"Return a titlecased version of the binary sequence where words start with an"
" uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""

#: ../../library/stdtypes.rst:3147
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""

#: ../../library/stdtypes.rst:3181
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""

#: ../../library/stdtypes.rst:3202
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make"
" a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is"
" handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""

#: ../../library/stdtypes.rst:3224
msgid "``printf``-style Bytes Formatting"
msgstr ""

#: ../../library/stdtypes.rst:3241
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""

#: ../../library/stdtypes.rst:3246
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or"
" *interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with"
" zero or more elements of *values*. The effect is similar to using the "
":c:func:`sprintf` in the C language."
msgstr ""

#: ../../library/stdtypes.rst:3253
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format bytes object, or a single mapping object (for"
" example, a dictionary)."
msgstr ""

#: ../../library/stdtypes.rst:3287
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For "
"example:"
msgstr ""

#: ../../library/stdtypes.rst:3361
msgid "Single byte (accepts integer or single byte objects)."
msgstr ""

#: ../../library/stdtypes.rst:3364
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3364
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or"
" has :meth:`__bytes__`)."
msgstr ""

#: ../../library/stdtypes.rst:3368
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: ../../library/stdtypes.rst:3371
msgid ""
"Bytes (converts any Python object using "
"``repr(obj).encode('ascii','backslashreplace)``)."
msgstr ""

#: ../../library/stdtypes.rst:3374
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: ../../library/stdtypes.rst:3374
msgid "\\(7)"
msgstr ""

#: ../../library/stdtypes.rst:3409
msgid ""
"``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: ../../library/stdtypes.rst:3412
msgid ""
"``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: ../../library/stdtypes.rst:3424
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ""

#: ../../library/stdtypes.rst:3431
msgid "Memory Views"
msgstr ""

#: ../../library/stdtypes.rst:3433
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of"
" an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""

#: ../../library/stdtypes.rst:3439
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include "
":class:`bytes` and :class:`bytearray`."
msgstr ""

#: ../../library/stdtypes.rst:3443
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""

#: ../../library/stdtypes.rst:3449
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view."
" The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:3456
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""

#: ../../library/stdtypes.rst:3469
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is"
" also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""

#: ../../library/stdtypes.rst:3478
msgid "Here is an example with a non-byte format::"
msgstr ""

#: ../../library/stdtypes.rst:3490
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""

#: ../../library/stdtypes.rst:3511
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == "
"hash(m.tobytes())``::"
msgstr ""

#: ../../library/stdtypes.rst:3523
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""

#: ../../library/stdtypes.rst:3527
msgid ""
"memoryview is now registered automatically with "
":class:`collections.abc.Sequence`"
msgstr ""

#: ../../library/stdtypes.rst:3531
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""

#: ../../library/stdtypes.rst:3534
msgid ":class:`memoryview` has several methods:"
msgstr ""

#: ../../library/stdtypes.rst:3538
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""

#: ../../library/stdtypes.rst:3542
msgid ""
"For the subset of :mod:`struct` format strings currently supported by "
":meth:`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""

#: ../../library/stdtypes.rst:3561
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""

#: ../../library/stdtypes.rst:3577
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""

#: ../../library/stdtypes.rst:3580
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""

#: ../../library/stdtypes.rst:3586
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""

#: ../../library/stdtypes.rst:3595
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""

#: ../../library/stdtypes.rst:3602
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""

#: ../../library/stdtypes.rst:3613
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""

#: ../../library/stdtypes.rst:3623
msgid ""
":meth:`tolist` now supports all single character native formats in "
":mod:`struct` module syntax as well as multi-dimensional representations."
msgstr ""

#: ../../library/stdtypes.rst:3630
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a "
":class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""

#: ../../library/stdtypes.rst:3636
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""

#: ../../library/stdtypes.rst:3647
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""

#: ../../library/stdtypes.rst:3663
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself"
" is not copied. Supported casts are 1D -> C-:term:`contiguous` and "
"C-contiguous -> 1D."
msgstr ""

#: ../../library/stdtypes.rst:3669
msgid ""
"The destination format is restricted to a single element native format in "
":mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""

#: ../../library/stdtypes.rst:3674
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr ""

#: ../../library/stdtypes.rst:3697
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr ""

#: ../../library/stdtypes.rst:3710
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr ""

#: ../../library/stdtypes.rst:3736
msgid "Cast 1D/unsigned char to 2D/unsigned long::"
msgstr ""

#: ../../library/stdtypes.rst:3750
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""

#: ../../library/stdtypes.rst:3753
msgid "There are also several readonly attributes available:"
msgstr ""

#: ../../library/stdtypes.rst:3757
msgid "The underlying object of the memoryview::"
msgstr ""

#: ../../library/stdtypes.rst:3768
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""

#: ../../library/stdtypes.rst:3787
msgid "Multi-dimensional arrays::"
msgstr ""

#: ../../library/stdtypes.rst:3804
msgid "A bool indicating whether the memory is read only."
msgstr ""

#: ../../library/stdtypes.rst:3808
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""

#: ../../library/stdtypes.rst:3813
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""

#: ../../library/stdtypes.rst:3819
msgid "The size in bytes of each element of the memoryview::"
msgstr ""

#: ../../library/stdtypes.rst:3832
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""

#: ../../library/stdtypes.rst:3837
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""

#: ../../library/stdtypes.rst:3840 ../../library/stdtypes.rst:3848
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr ""

#: ../../library/stdtypes.rst:3845
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""

#: ../../library/stdtypes.rst:3853
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""

#: ../../library/stdtypes.rst:3857
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:3863
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:3869
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:3877
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr ""

#: ../../library/stdtypes.rst:3881
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union,"
" difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:3888
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""

#: ../../library/stdtypes.rst:3893
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can be"
" changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since"
" it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type"
" is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element"
" of another set."
msgstr ""

#: ../../library/stdtypes.rst:3901
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""

#: ../../library/stdtypes.rst:3905
msgid "The constructors for both classes work the same:"
msgstr ""

#: ../../library/stdtypes.rst:3910
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""

#: ../../library/stdtypes.rst:3916
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""

#: ../../library/stdtypes.rst:3921
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""

#: ../../library/stdtypes.rst:3925
msgid "Test *x* for membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:3929
msgid "Test *x* for non-membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:3933
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are"
" disjoint if and only if their intersection is the empty set."
msgstr ""

#: ../../library/stdtypes.rst:3939
msgid "Test whether every element in the set is in *other*."
msgstr ""

#: ../../library/stdtypes.rst:3943
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:3949
msgid "Test whether every element in *other* is in the set."
msgstr ""

#: ../../library/stdtypes.rst:3953
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:3959
msgid "Return a new set with elements from the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:3964
msgid "Return a new set with elements common to the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:3969
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""

#: ../../library/stdtypes.rst:3974
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""

#: ../../library/stdtypes.rst:3978
msgid "Return a shallow copy of the set."
msgstr ""

#: ../../library/stdtypes.rst:3981
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and "
":meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/stdtypes.rst:3988
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two"
" sets are equal if and only if every element of each set is contained in the"
" other (each is a subset of the other). A set is less than another set if "
"and only if the first set is a proper subset of the second set (is a subset,"
" but is not equal). A set is greater than another set if and only if the "
"first set is a proper superset of the second set (is a superset, but is not "
"equal)."
msgstr ""

#: ../../library/stdtypes.rst:3995
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""

#: ../../library/stdtypes.rst:3999
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are"
" not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""

#: ../../library/stdtypes.rst:4004
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../library/stdtypes.rst:4007
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""

#: ../../library/stdtypes.rst:4009
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""

#: ../../library/stdtypes.rst:4013
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""

#: ../../library/stdtypes.rst:4019
msgid "Update the set, adding elements from all others."
msgstr ""

#: ../../library/stdtypes.rst:4024
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""

#: ../../library/stdtypes.rst:4029
msgid "Update the set, removing elements found in others."
msgstr ""

#: ../../library/stdtypes.rst:4034
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""

#: ../../library/stdtypes.rst:4038
msgid "Add element *elem* to the set."
msgstr ""

#: ../../library/stdtypes.rst:4042
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not"
" contained in the set."
msgstr ""

#: ../../library/stdtypes.rst:4047
msgid "Remove element *elem* from the set if it is present."
msgstr ""

#: ../../library/stdtypes.rst:4051
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError`"
" if the set is empty."
msgstr ""

#: ../../library/stdtypes.rst:4056
msgid "Remove all elements from the set."
msgstr ""

#: ../../library/stdtypes.rst:4059
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""

#: ../../library/stdtypes.rst:4064
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and "
":meth:`discard` methods may be a set.  To support searching for an "
"equivalent frozenset, a temporary one is created from *elem*."
msgstr ""

#: ../../library/stdtypes.rst:4072
msgid "Mapping Types --- :class:`dict`"
msgstr ""

#: ../../library/stdtypes.rst:4082
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in "
":class:`list`, :class:`set`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:4088
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""

#: ../../library/stdtypes.rst:4097
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}``"
" or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""

#: ../../library/stdtypes.rst:4105
msgid ""
"Return a new dictionary initialized from an optional positional argument and"
" a possibly empty set of keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:4108
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the"
" positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4118
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces"
" the value from the positional argument."
msgstr ""

#: ../../library/stdtypes.rst:4123
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""

#: ../../library/stdtypes.rst:4134
msgid ""
"Providing keyword arguments as in the first example only works for keys that"
" are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""

#: ../../library/stdtypes.rst:4138
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""

#: ../../library/stdtypes.rst:4143
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: ../../library/stdtypes.rst:4147
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is"
" not in the map."
msgstr ""

#: ../../library/stdtypes.rst:4152
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, "
":exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot "
"be an instance variable::"
msgstr ""

#: ../../library/stdtypes.rst:4170
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used by"
" :class:`collections.defaultdict`."
msgstr ""

#: ../../library/stdtypes.rst:4176
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: ../../library/stdtypes.rst:4180
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the"
" map."
msgstr ""

#: ../../library/stdtypes.rst:4185
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: ../../library/stdtypes.rst:4189
msgid "Equivalent to ``not key in d``."
msgstr ""

#: ../../library/stdtypes.rst:4193
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""

#: ../../library/stdtypes.rst:4198
msgid "Remove all items from the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4202
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4206
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""

#: ../../library/stdtypes.rst:4208
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4213
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If"
" *default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:4219
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4224
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4229
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a "
":exc:`KeyError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:4235
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""

#: ../../library/stdtypes.rst:4238
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":meth:`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:4242
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""

#: ../../library/stdtypes.rst:4248
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"如果字典存在键 *key* ，返回它的值。如果不存在，插入值为 *default* 的键 *key* ，并返回 *default* 。 "
"*default* 默认为 ``None``。"

#: ../../library/stdtypes.rst:4254
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4257
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value"
" pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../library/stdtypes.rst:4264
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4267
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs. Order comparisons ('<', '<=', '>=', '>') raise "
":exc:`TypeError`."
msgstr ""

#: ../../library/stdtypes.rst:4271
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""

#: ../../library/stdtypes.rst:4289
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""

#: ../../library/stdtypes.rst:4294
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a "
":class:`dict`."
msgstr ""

#: ../../library/stdtypes.rst:4301
msgid "Dictionary view objects"
msgstr ""

#: ../../library/stdtypes.rst:4303
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and "
":meth:`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view"
" reflects these changes."
msgstr ""

#: ../../library/stdtypes.rst:4308
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""

#: ../../library/stdtypes.rst:4313
msgid "Return the number of entries in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4317
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4320
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  Another way to create the same list is ``pairs"
" = [(v, k) for (k, v) in d.items()]``."
msgstr ""

#: ../../library/stdtypes.rst:4325
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise"
" a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:4328
msgid "Dictionary order is guaranteed to be insertion order."
msgstr ""

#: ../../library/stdtypes.rst:4333
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""

#: ../../library/stdtypes.rst:4337
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all"
" values are hashable, so that ``(key, value)`` pairs are unique and "
"hashable, then the items view is also set-like.  (Values views are not "
"treated as set-like since the entries are generally not unique.)  For set-"
"like views, all of the operations defined for the abstract base class "
":class:`collections.abc.Set` are available (for example, ``==``, ``<``, or "
"``^``)."
msgstr ""

#: ../../library/stdtypes.rst:4344
msgid "An example of dictionary view usage::"
msgstr ""

#: ../../library/stdtypes.rst:4379
msgid "Context Manager Types"
msgstr ""

#: ../../library/stdtypes.rst:4386
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context"
" defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""

#: ../../library/stdtypes.rst:4394
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements"
" using this context manager."
msgstr ""

#: ../../library/stdtypes.rst:4399
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow "
":func:`open` to be used as the context expression in a :keyword:`with` "
"statement."
msgstr ""

#: ../../library/stdtypes.rst:4403
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside the"
" :keyword:`!with` statement."
msgstr ""

#: ../../library/stdtypes.rst:4413
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while"
" executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4418
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""

#: ../../library/stdtypes.rst:4425
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows"
" context management code to easily detect whether or not an :meth:`__exit__`"
" method has actually failed."
msgstr ""

#: ../../library/stdtypes.rst:4431
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""

#: ../../library/stdtypes.rst:4437
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary "
":meth:`__enter__` and :meth:`__exit__` methods, rather than the iterator "
"produced by an undecorated generator function."
msgstr ""

#: ../../library/stdtypes.rst:4444
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to"
" define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr ""

#: ../../library/stdtypes.rst:4454
msgid "Other Built-in Types"
msgstr ""

#: ../../library/stdtypes.rst:4456
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""

#: ../../library/stdtypes.rst:4463
msgid "Modules"
msgstr "模块"

#: ../../library/stdtypes.rst:4465
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named *foo* "
"to exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""

#: ../../library/stdtypes.rst:4472
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the"
" dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to the"
" :attr:`~object.__dict__` attribute is not possible (you can write "
"``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't "
"write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is "
"not recommended."
msgstr ""

#: ../../library/stdtypes.rst:4480
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""

#: ../../library/stdtypes.rst:4488
msgid "Classes and Class Instances"
msgstr ""

#: ../../library/stdtypes.rst:4490
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""

#: ../../library/stdtypes.rst:4496
msgid "Functions"
msgstr ""

#: ../../library/stdtypes.rst:4498
msgid ""
"Function objects are created by function definitions.  The only operation on"
" a function object is to call it: ``func(argument-list)``."
msgstr ""

#: ../../library/stdtypes.rst:4501
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""

#: ../../library/stdtypes.rst:4505
msgid "See :ref:`function` for more information."
msgstr ""

#: ../../library/stdtypes.rst:4511
msgid "Methods"
msgstr ""

#: ../../library/stdtypes.rst:4515
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""

#: ../../library/stdtypes.rst:4520
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called "
":dfn:`instance method`) object. When called, it will add the ``self`` "
"argument to the argument list.  Bound methods have two special read-only "
"attributes: ``m.__self__`` is the object on which the method operates, and "
"``m.__func__`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling "
"``m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."
msgstr ""

#: ../../library/stdtypes.rst:4529
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on"
" bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""

#: ../../library/stdtypes.rst:4549 ../../library/stdtypes.rst:4577
msgid "See :ref:`types` for more information."
msgstr ""

#: ../../library/stdtypes.rst:4557
msgid "Code Objects"
msgstr "代码对象"

#: ../../library/stdtypes.rst:4563
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\""
" executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their "
":attr:`__code__` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../library/stdtypes.rst:4574
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""

#: ../../library/stdtypes.rst:4583
msgid "Type Objects"
msgstr ""

#: ../../library/stdtypes.rst:4589
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all"
" standard built-in types."
msgstr ""

#: ../../library/stdtypes.rst:4594
msgid "Types are written like this: ``<class 'int'>``."
msgstr ""

#: ../../library/stdtypes.rst:4600
msgid "The Null Object"
msgstr ""

#: ../../library/stdtypes.rst:4602
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""

#: ../../library/stdtypes.rst:4606
msgid "It is written as ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4613
msgid "The Ellipsis Object"
msgstr ""

#: ../../library/stdtypes.rst:4615
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named "
":const:`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the "
":const:`Ellipsis` singleton."
msgstr ""

#: ../../library/stdtypes.rst:4620
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr ""

#: ../../library/stdtypes.rst:4626
msgid "The NotImplemented Object"
msgstr ""

#: ../../library/stdtypes.rst:4628
msgid ""
"This object is returned from comparisons and binary operations when they are"
" asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""

#: ../../library/stdtypes.rst:4633
msgid "It is written as ``NotImplemented``."
msgstr ""

#: ../../library/stdtypes.rst:4639
msgid "Boolean Values"
msgstr ""

#: ../../library/stdtypes.rst:4641
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and"
" 1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""

#: ../../library/stdtypes.rst:4654
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../library/stdtypes.rst:4660
msgid "Internal Objects"
msgstr ""

#: ../../library/stdtypes.rst:4662
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""

#: ../../library/stdtypes.rst:4669
msgid "Special Attributes"
msgstr ""

#: ../../library/stdtypes.rst:4671
msgid ""
"The implementation adds a few special read-only attributes to several object"
" types, where they are relevant.  Some of these are not reported by the "
":func:`dir` built-in function."
msgstr ""

#: ../../library/stdtypes.rst:4678
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""

#: ../../library/stdtypes.rst:4684
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../library/stdtypes.rst:4689
msgid "The tuple of base classes of a class object."
msgstr ""

#: ../../library/stdtypes.rst:4694
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""

#: ../../library/stdtypes.rst:4700
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""

#: ../../library/stdtypes.rst:4708
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""

#: ../../library/stdtypes.rst:4714
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""

#: ../../library/stdtypes.rst:4721
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""

#: ../../library/stdtypes.rst:4730
msgid "Footnotes"
msgstr "脚注"

#: ../../library/stdtypes.rst:4731
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""

#: ../../library/stdtypes.rst:4734
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``,"
" and similarly for tuples."
msgstr ""

#: ../../library/stdtypes.rst:4737
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""

#: ../../library/stdtypes.rst:4739
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:4742
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
