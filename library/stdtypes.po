# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "内置类型"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "以下部分描述了解释器中内置的标准类型。"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "主要内置类型有数字、序列、映射、类、实例和异常。"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 ``None``。"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly"
" used when an object is written by the :func:`print` function."
msgstr ""
"有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 :func:`repr` 函数或略有差异的 "
":func:`str` 函数）。 后一个函数是在对象由 :func:`print` 函数输出时被隐式地调用的。"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "逻辑值检测"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"任何对象都可以进行逻辑值的检测，以便在 :keyword:`if` 或 :keyword:`while` "
"作为条件或是作为下文所述布尔运算的操作数来使用。"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a "
":meth:`~object.__bool__` method that returns ``False`` or a "
":meth:`~object.__len__` method that returns zero, when called with the "
"object. [1]_  Here are most of the built-in objects considered false:"
msgstr ""
"在默认情况下，一个对象会被视为具有真值，除非其所属的类定义了在对象上调用时返回 ``False`` 的 :meth:`~object.__bool__`"
" 方法或者返回零的 :meth:`~object.__len__` 方法。 [1]_  以下基本完整地列出了具有假值的内置对象："

#: ../../library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "被定义为假值的常量: ``None`` 和 ``False``"

#: ../../library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr "任何数值类型的零: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr "空的序列和多项集: ``''``, ``()``, ``[]``, ``{}``, ``set()``, ``range(0)``"

#: ../../library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"产生布尔值结果的运算和内置函数总是返回 ``0`` 或 ``False`` 作为假值，``1`` 或 ``True`` 作为真值，除非另行说明。 "
"（重要例外：布尔运算 ``or`` 和 ``and`` 总是返回其中一个操作数。）"

#: ../../library/stdtypes.rst:79
msgid ""
"Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "布尔运算 --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "这些属于布尔运算，按优先级升序排列:"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:144
#: ../../library/stdtypes.rst:276 ../../library/stdtypes.rst:366
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:965
#: ../../library/stdtypes.rst:1170
msgid "Operation"
msgstr "运算"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:366 ../../library/stdtypes.rst:416
#: ../../library/stdtypes.rst:965 ../../library/stdtypes.rst:1170
msgid "Result"
msgstr "结果："

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:965
#: ../../library/stdtypes.rst:1170 ../../library/stdtypes.rst:2590
#: ../../library/stdtypes.rst:3809
msgid "Notes"
msgstr "备注"

#: ../../library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "如果 *x* 为真值，则 *x*，否则 *y*"

#: ../../library/stdtypes.rst:88 ../../library/stdtypes.rst:967
#: ../../library/stdtypes.rst:970 ../../library/stdtypes.rst:1181
#: ../../library/stdtypes.rst:2596 ../../library/stdtypes.rst:3815
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "if *x* is false, then *x*, else *y*"

#: ../../library/stdtypes.rst:91 ../../library/stdtypes.rst:289
#: ../../library/stdtypes.rst:309 ../../library/stdtypes.rst:1209
#: ../../library/stdtypes.rst:2600 ../../library/stdtypes.rst:2602
#: ../../library/stdtypes.rst:3819 ../../library/stdtypes.rst:3821
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:94
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "if *x* is false, then ``True``, else ``False``"

#: ../../library/stdtypes.rst:94 ../../library/stdtypes.rst:979
#: ../../library/stdtypes.rst:1212 ../../library/stdtypes.rst:2604
#: ../../library/stdtypes.rst:2606 ../../library/stdtypes.rst:2608
#: ../../library/stdtypes.rst:2610 ../../library/stdtypes.rst:3823
#: ../../library/stdtypes.rst:3825 ../../library/stdtypes.rst:3827
#: ../../library/stdtypes.rst:3829
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:320
#: ../../library/stdtypes.rst:434 ../../library/stdtypes.rst:1016
#: ../../library/stdtypes.rst:1221 ../../library/stdtypes.rst:2636
#: ../../library/stdtypes.rst:3859
msgid "Notes:"
msgstr "注释："

#: ../../library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr "这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。"

#: ../../library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr "这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。"

#: ../../library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` 的优先级比非布尔运算符低，因此 ``not a == b`` 会被解读为 ``not (a == b)`` 而 ``a == not "
"b`` 会引发语法错误。"

#: ../../library/stdtypes.rst:121
msgid "Comparisons"
msgstr "比较运算"

#: ../../library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons"
" can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to "
"``x < y and y <= z``, except that *y* is evaluated only once (but in both "
"cases *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，``x < y <= z`` 等价于 "
"``x < y and y <= z``，前者的不同之处在于 *y* 只被求值一次（但在两种情况下当 ``x < y`` 结果为假值时 *z* "
"都不会被求值）。"

#: ../../library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "此表格汇总了比较运算:"

#: ../../library/stdtypes.rst:144 ../../library/stdtypes.rst:2422
#: ../../library/stdtypes.rst:2567 ../../library/stdtypes.rst:2590
#: ../../library/stdtypes.rst:3786 ../../library/stdtypes.rst:3809
msgid "Meaning"
msgstr "含意"

#: ../../library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:146
msgid "strictly less than"
msgstr "严格小于"

#: ../../library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:148
msgid "less than or equal"
msgstr "小于或等于"

#: ../../library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "严格大于"

#: ../../library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "大于或等于"

#: ../../library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:154
msgid "equal"
msgstr "等于"

#: ../../library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:156
msgid "not equal"
msgstr "不等于"

#: ../../library/stdtypes.rst:158
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:158
msgid "object identity"
msgstr "对象标识"

#: ../../library/stdtypes.rst:160
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:160
msgid "negated object identity"
msgstr "否定的对象标识"

#: ../../library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"除不同的数字类型外，不同类型的对象不能进行相等比较。``==`` 运算符总有定义，但对于某些对象类型（例如，类对象），它等于 :keyword:`is`"
" 。其他 ``<``、``<=``、``>`` 和 ``>=`` 运算符仅在有意义的地方定义。例如，当参与比较的参数之一为复数时，它们会抛出 "
":exc:`TypeError` 异常。"

#: ../../library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr "具有不同标识的类的实例比较结果通常为不相等，除非类定义了 :meth:`~object.__eq__` 方法。"

#: ../../library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of"
" the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, "
":meth:`~object.__gt__`, and :meth:`~object.__ge__` (in general, "
":meth:`~object.__lt__` and :meth:`~object.__eq__` are sufficient, if you "
"want the conventional meanings of the comparison operators)."
msgstr ""
"一个类的实例不能与相同类的其他实例或其他类型的对象进行排序，除非定义该类定义了足够多的方法，包括 :meth:`~object.__lt__`, "
":meth:`~object.__le__`, :meth:`~object.__gt__` 以及 :meth:`~object.__ge__` "
"(而如果你想实现常规意义上的比较操作，通常只要有 :meth:`~object.__lt__` 和 :meth:`~object.__eq__` "
"就可以了)。"

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ":keyword:`is` 和 :keyword:`is not` 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。"

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and "
":keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"还有两种具有相同语法优先级的运算 :keyword:`in` 和 :keyword:`not in`，它们被 :term:`iterable` 或实现了"
" :meth:`~object.__contains__` 方法的类型所支持。"

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "数字类型 --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating-"
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating-point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating-point numbers "
"for the machine on which your program is running is available in "
":data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating-point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes the additional numeric types :mod:`fractions.Fraction`, for "
"rationals, and :mod:`decimal.Decimal`, for floating-point numbers with user-"
"definable precision.)"
msgstr ""
"存在三种不同的数字类型: :dfn:`整数`, :dfn:`浮点数` 和 :dfn:`复数`。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 "
"浮点数通常使用 C 中的 :c:expr:`double` 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 "
":data:`sys.float_info` 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z* 中提取这两个部分，可使用 "
"``z.real`` 和 ``z.imag``。 （标准库包含附加的数字类型，如表示有理数的 :mod:`fractions.Fraction` "
"以及以用户定制精度表示浮点数的 :mod:`decimal.Decimal`。）"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating-point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number"
" with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 "
"包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 ``'j'`` 或 ``'J'`` "
"会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。"

#: ../../library/stdtypes.rst:263
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers"
" of different types behaves as though the exact values of those numbers were"
" being compared. [2]_"
msgstr ""
"Python "
"完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，\"较窄\"类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。[2]_"

#: ../../library/stdtypes.rst:269
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used"
" to produce numbers of a specific type."
msgstr "构造函数 :func:`int`、 :func:`float` 和 :func:`complex` 可以用来构造特定类型的数字。"

#: ../../library/stdtypes.rst:272
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr "所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：:ref:`operator-summary`）:"

#: ../../library/stdtypes.rst:276
msgid "Full documentation"
msgstr "完整文档"

#: ../../library/stdtypes.rst:278
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:278
msgid "sum of *x* and *y*"
msgstr "*x* 和 *y* 的和"

#: ../../library/stdtypes.rst:280
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:280
msgid "difference of *x* and *y*"
msgstr "*x* 和 *y* 的差"

#: ../../library/stdtypes.rst:282
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:282
msgid "product of *x* and *y*"
msgstr "*x* 和 *y* 的乘积"

#: ../../library/stdtypes.rst:284
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:284
msgid "quotient of *x* and *y*"
msgstr "*x* 和 *y* 的商"

#: ../../library/stdtypes.rst:286
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:286
msgid "floored quotient of *x* and *y*"
msgstr "*x* 和 *y* 的商数"

#: ../../library/stdtypes.rst:286
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: ../../library/stdtypes.rst:289
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:289
msgid "remainder of ``x / y``"
msgstr "``x / y`` 的余数"

#: ../../library/stdtypes.rst:291
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:291
msgid "*x* negated"
msgstr "*x* 取反"

#: ../../library/stdtypes.rst:293
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:293
msgid "*x* unchanged"
msgstr "*x* 不变"

#: ../../library/stdtypes.rst:295
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:295
msgid "absolute value or magnitude of *x*"
msgstr "*x* 的绝对值或大小"

#: ../../library/stdtypes.rst:295
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:298
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:298
msgid "*x* converted to integer"
msgstr "将 *x* 转换为整数"

#: ../../library/stdtypes.rst:298
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:298
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:300
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:300
msgid "*x* converted to floating point"
msgstr "将 *x* 转换为浮点数"

#: ../../library/stdtypes.rst:300
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:300
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:302
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:302
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "一个带有实部 *re* 和虚部 *im* 的复数。*im* 默认为0。"

#: ../../library/stdtypes.rst:302 ../../library/stdtypes.rst:1202
#: ../../library/stdtypes.rst:2598 ../../library/stdtypes.rst:3846
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:302
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:306
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:306
msgid "conjugate of the complex number *c*"
msgstr "复数 *c* 的共轭"

#: ../../library/stdtypes.rst:309
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:309
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)``"

#: ../../library/stdtypes.rst:309
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:311
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
msgid "*x* to the power *y*"
msgstr "*x* 的 *y* 次幂"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
#: ../../library/stdtypes.rst:1191 ../../library/stdtypes.rst:1194
#: ../../library/stdtypes.rst:2623 ../../library/stdtypes.rst:2626
#: ../../library/stdtypes.rst:2629 ../../library/stdtypes.rst:3842
#: ../../library/stdtypes.rst:3849
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:311
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:313
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:323
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"也称为整数除法。 对于 :class:`int` 类型的操作数，结果的类型为 :class:`int`。 对于 :class:`float` "
"类型的操作数，结果的类型为 :class:`float`。 总的说来，结果是一个整数，但结果的类型不一定为 :class:`int`。 "
"结果总是向负无穷的方向舍入: ``1//2`` 为``0``，``(-1)//2`` 为 ``-1``，``1//(-2)`` 为 "
"``-1``，``(-1)//(-2)`` 为 ``0``。"

#: ../../library/stdtypes.rst:331
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "不可用于复数。 而应在适当条件下使用 :func:`abs` 转换为浮点数。"

#: ../../library/stdtypes.rst:342
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"从 :class:`float` 转换为 :class:`int` 将会执行截断，丢弃掉小数部分。 请参阅 :func:`math.floor` 和 "
":func:`math.ceil` 函数了解替代的转换方式。"

#: ../../library/stdtypes.rst:347
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr "float 也接受字符串 \"nan\" 和附带可选前缀 \"+\" 或 \"-\" 的 \"inf\" 分别表示非数字 (NaN) 以及正或负无穷。"

#: ../../library/stdtypes.rst:351
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr "Python 将 ``pow(0, 0)`` 和 ``0 ** 0`` 定义为 ``1``，这是编程语言的普遍做法。"

#: ../../library/stdtypes.rst:355
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr "接受的数字字面值包括数码 ``0`` 到 ``9`` 或任何等效的 Unicode 字符（具有 ``Nd`` 特征属性的代码点）。"

#: ../../library/stdtypes.rst:358
msgid ""
"See `the Unicode Standard "
"<https://unicode.org/Public/UNIDATA/extracted/DerivedNumericType.txt>`_ for "
"a complete list of code points with the ``Nd`` property."
msgstr ""
"请参阅 `Unicode 标准 "
"<https://unicode.org/Public/UNIDATA/extracted/DerivedNumericType.txt>`_ 了解具有"
" ``Nd`` 特征属性的码位完整列表。"

#: ../../library/stdtypes.rst:362
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr "所有 :class:`numbers.Real` 类型 (:class:`int` 和 :class:`float`) 还包括下列运算:"

#: ../../library/stdtypes.rst:368
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:368
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* 截断为 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:371
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:371
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* 舍入到 *n* 位小数，半数值会舍入到偶数。 如果省略 *n*，则默认为 0。"

#: ../../library/stdtypes.rst:375
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:375
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "<= *x* 的最大 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:378
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:378
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr ">= *x* 的最小 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:382
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "有关更多的数字运算请参阅 :mod:`math` 和 :mod:`cmath` 模块。"

#: ../../library/stdtypes.rst:391
msgid "Bitwise Operations on Integer Types"
msgstr "整数类型的按位运算"

#: ../../library/stdtypes.rst:405
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr "按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。"

#: ../../library/stdtypes.rst:409
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and"
" ``-``)."
msgstr ""
"二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 ``~`` 具有与其他一元算术运算 (``+`` and ``-``) "
"相同的优先级。"

#: ../../library/stdtypes.rst:413
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "此表格是以优先级升序排序的按位运算列表:"

#: ../../library/stdtypes.rst:418
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:418
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`或`"

#: ../../library/stdtypes.rst:418 ../../library/stdtypes.rst:421
#: ../../library/stdtypes.rst:424 ../../library/stdtypes.rst:1216
#: ../../library/stdtypes.rst:2612 ../../library/stdtypes.rst:2616
#: ../../library/stdtypes.rst:3831 ../../library/stdtypes.rst:3835
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:421
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:421
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`异或`"

#: ../../library/stdtypes.rst:424
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:424
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* 和 *y* 按位 :dfn:`与`"

#: ../../library/stdtypes.rst:427
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:427
msgid "*x* shifted left by *n* bits"
msgstr "*x* 左移 *n* 位"

#: ../../library/stdtypes.rst:427
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:429
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:429
msgid "*x* shifted right by *n* bits"
msgstr "*x* 右移 *n* 位"

#: ../../library/stdtypes.rst:429
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:431
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:431
msgid "the bits of *x* inverted"
msgstr "*x* 逐位取反"

#: ../../library/stdtypes.rst:437
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr "负的移位数是非法的，会导致引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:440
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "左移 *n* 位等价于乘以 ``pow(2, n)`` 。"

#: ../../library/stdtypes.rst:443
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr "右移 *n* 位等价于除以 ``pow(2, n)`` ，作向下取整除法。"

#: ../../library/stdtypes.rst:446
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + "
"max(x.bit_length(), y.bit_length())`` or more) is sufficient to get the same"
" result as if there were an infinite number of sign bits."
msgstr ""
"使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 ``1 + max(x.bit_length(), "
"y.bit_length())`` 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。"

#: ../../library/stdtypes.rst:453
msgid "Additional Methods on Integer Types"
msgstr "整数类型的附加方法"

#: ../../library/stdtypes.rst:455
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"int 类型实现了 :class:`numbers.Integral` :term:`abstract base class`。 "
"此外，它还提供了其他几个方法:"

#: ../../library/stdtypes.rst:460
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零::"

#: ../../library/stdtypes.rst:463
msgid ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"
msgstr ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"

#: ../../library/stdtypes.rst:469
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr ""
"更准确地说，如果 ``x`` 非零，则 ``x.bit_length()`` 是使得 ``2**(k-1) <= abs(x) < 2**k`` "
"的唯一正整数 ``k``。 同样地，当 ``abs(x)`` 小到足以具有正确的舍入对数时，则 ``k = 1 + int(log(abs(x), "
"2))``。 如果 ``x`` 为零，则 ``x.bit_length()`` 返回 ``0``。"

#: ../../library/stdtypes.rst:475 ../../library/stdtypes.rst:498
#: ../../library/stdtypes.rst:543 ../../library/stdtypes.rst:587
msgid "Equivalent to::"
msgstr "等价于::"

#: ../../library/stdtypes.rst:477
msgid ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"
msgstr ""
"def bit_length(self):\n"
"    s = bin(self)       # 二进制表示形式:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # 移除开头的零和负号\n"
"    return len(s)       # len('100101') --> 6"

#: ../../library/stdtypes.rst:486
msgid ""
"Return the number of ones in the binary representation of the absolute value"
" of the integer. This is also known as the population count. Example::"
msgstr "返回整数的绝对值的二进制表示中 1 的个数。也被称为 population count。示例::"

#: ../../library/stdtypes.rst:490
msgid ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"
msgstr ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"

#: ../../library/stdtypes.rst:500
msgid ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"
msgstr ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"

#: ../../library/stdtypes.rst:507
msgid "Return an array of bytes representing an integer."
msgstr "返回表示一个整数的字节数组。"

#: ../../library/stdtypes.rst:519
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An "
":exc:`OverflowError` is raised if the integer is not representable with the "
"given number of bytes."
msgstr ""
"整数会使用 *length* 个字节来表示，默认为 1。 如果整数不能用给定的字节数来表示则会引发 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:523
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder*"
" is ``\"little\"``, the most significant byte is at the end of the byte "
"array."
msgstr ""
"*byteorder* 参数确定用于表示整数的字节顺序，默认为 ``\"big\"``。 如果 *byteorder* 为 "
"``\"big\"``，则最高位字节放在字节数组的开头。 如果 *byteorder* 为 "
"``\"little\"``，则最高位字节放在字节数组的末尾。"

#: ../../library/stdtypes.rst:529
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* 参数确定是否使用二的补码来表示整数。 如果 *signed* 为 ``False`` 并且给出的是负整数，则会引发 "
":exc:`OverflowError`。 *signed* 的默认值为 ``False``。"

#: ../../library/stdtypes.rst:534
msgid ""
"The default values can be used to conveniently turn an integer into a single"
" byte object::"
msgstr "默认值可用于方便地将整数转为一个单字节对象::"

#: ../../library/stdtypes.rst:537
msgid ""
">>> (65).to_bytes()\n"
"b'A'"
msgstr ""
">>> (65).to_bytes()\n"
"b'A'"

#: ../../library/stdtypes.rst:540
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr "但是，当使用默认参数时，请不要试图转换大于 255 的值否则会引发 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:545
msgid ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"
msgstr ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"

#: ../../library/stdtypes.rst:556
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr "添加了 ``length`` 和 ``byteorder`` 的默认参数值。"

#: ../../library/stdtypes.rst:561
msgid "Return the integer represented by the given array of bytes."
msgstr "返回由给定字节数组所表示的整数。"

#: ../../library/stdtypes.rst:574
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr "*bytes* 参数必须为一个 :term:`bytes-like object` 或是生成字节的可迭代对象。"

#: ../../library/stdtypes.rst:577
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder*"
" is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use "
":data:`sys.byteorder` as the byte order value."
msgstr ""
"*byteorder* 参数确定用于表示整数的字节顺序，默认为 ``\"big\"``。 如果 *byteorder* 为 "
"``\"big\"``，则最高位字节放在字节数组的开头。 如果 *byteorder* 为 "
"``\"little\"``，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 :data:`sys.byteorder` "
"作为字节顺序值。"

#: ../../library/stdtypes.rst:584
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 参数指明是否使用二的补码来表示整数。"

#: ../../library/stdtypes.rst:589
msgid ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"
msgstr ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"

#: ../../library/stdtypes.rst:604
msgid "Added default argument value for ``byteorder``."
msgstr "添加了 ``byteorder`` 的默认参数值。"

#: ../../library/stdtypes.rst:609
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr "返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为分子并以 ``1`` 作为分母。"

#: ../../library/stdtypes.rst:618
msgid ""
"Returns ``True``. Exists for duck type compatibility with "
":meth:`float.is_integer`."
msgstr "返回 ``True``。 存在于兼容 :meth:`float.is_integer` 的鸭子类型。"

#: ../../library/stdtypes.rst:623
msgid "Additional Methods on Float"
msgstr "浮点类型的附加方法"

#: ../../library/stdtypes.rst:625
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"float 类型实现了 :class:`numbers.Real` :term:`abstract base class`。 float "
"还具有以下附加方法。"

#: ../../library/stdtypes.rst:630
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises "
":exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"返回一对整数，其比率正好等于原浮点数。 该比率为最简形式且分母为正值。 无穷大会引发 :exc:`OverflowError` 而 NaN 则会引发 "
":exc:`ValueError`。"

#: ../../library/stdtypes.rst:637
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "如果 float 实例可用有限位整数表示则返回 ``True``，否则返回 ``False``::"

#: ../../library/stdtypes.rst:640
msgid ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"
msgstr ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"

#: ../../library/stdtypes.rst:645
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 *十进制数* "
"字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。"

#: ../../library/stdtypes.rst:656
msgid ""
"Return a representation of a floating-point number as a hexadecimal string."
"  For finite floating-point numbers, this representation will always include"
" a leading ``0x`` and a trailing ``p`` and exponent."
msgstr "以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 ``0x`` 和尾随的 ``p`` 加指数。"

#: ../../library/stdtypes.rst:664
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr "返回以十六进制字符串 *s* 表示的浮点数的类方法。 字符串 *s* 可以带有前导和尾随的空格。"

#: ../../library/stdtypes.rst:669
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr "请注意 :meth:`float.hex` 是实例方法，而 :meth:`float.fromhex` 是类方法。"

#: ../../library/stdtypes.rst:672
msgid "A hexadecimal string takes the form::"
msgstr "十六进制字符串采用的形式为::"

#: ../../library/stdtypes.rst:674
msgid "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"
msgstr "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"

#: ../../library/stdtypes.rst:676
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and"
" there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2"
" of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted"
" by :meth:`float.fromhex`."
msgstr ""
"可选的 ``sign`` 可以是 ``+`` 或 ``-``，``integer`` 和 ``fraction`` "
"是十六进制数码组成的字符串，``exponent`` 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction "
"中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 "
"特别地，:meth:`float.hex` 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 ``%a`` 格式字符或 "
"Java 的 ``Double.toHexString`` 所生成的十六进制数字符串由为 :meth:`float.fromhex` 所接受。"

#: ../../library/stdtypes.rst:689
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 ``0x3.a7p10`` 表示浮点数 "
"``(3 + 10./16 + 7./16**2) * 2.0**10`` 即 ``3740.0``::"

#: ../../library/stdtypes.rst:695
msgid ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"
msgstr ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"

#: ../../library/stdtypes.rst:699
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr "对 ``3740.0`` 应用反向转换会得到另一个代表相同数值的十六进制数字符串::"

#: ../../library/stdtypes.rst:702
msgid ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"
msgstr ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"

#: ../../library/stdtypes.rst:709
msgid "Hashing of numeric types"
msgstr "数字类型的哈希运算"

#: ../../library/stdtypes.rst:711
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement"
" that ``hash(x) == hash(y)`` whenever ``x == y`` (see the "
":meth:`~object.__hash__` method documentation for more details).  For ease "
"of implementation and efficiency across a variety of numeric types "
"(including :class:`int`, :class:`float`, :class:`decimal.Decimal` and "
":class:`fractions.Fraction`) Python's hash for numeric types is based on a "
"single mathematical function that's defined for any rational number, and "
"hence applies to all instances of :class:`int` and "
":class:`fractions.Fraction`, and all finite instances of :class:`float` and "
":class:`decimal.Decimal`.  Essentially, this function is given by reduction "
"modulo ``P`` for a fixed prime ``P``.  The value of ``P`` is made available "
"to Python as the :attr:`~sys.hash_info.modulus` attribute of "
":data:`sys.hash_info`."
msgstr ""
"对于可能为不同类型的数字 ``x`` 和 ``y``，要求当 ``x == y`` 时必定有 ``hash(x) == hash(y)`` (详情参见 "
":meth:`~object.__hash__` 方法的文档)。 为了便于在各种数字类型 (包括 :class:`int`, "
":class:`float`, :class:`decimal.Decimal` 和 :class:`fractions.Fraction`) "
"上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 :class:`int` 和 "
":class:`fractions.Fraction` 的全部实例，以及 :class:`float` 和 "
":class:`decimal.Decimal` 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 ``P`` 进行 ``P`` "
"降模给出的。 ``P`` 的值在 Python 中可以 :data:`sys.hash_info` 的 "
":attr:`~sys.hash_info.modulus` 属性的形式被访问。"

#: ../../library/stdtypes.rst:726
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"目前所用的质数设定，在 C long 为 32 位的机器上 ``P = 2**31 - 1`` 而在 C long 为 64 位的机器上 ``P = "
"2**61 - 1``。"

#: ../../library/stdtypes.rst:729
msgid "Here are the rules in detail:"
msgstr "详细规则如下所述:"

#: ../../library/stdtypes.rst:731
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible"
" by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n,"
" P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"如果 ``x = m / n`` 是一个非负的有理数且 ``n`` 不可被 ``P`` 整除，则定义 ``hash(x)`` 为 ``m * "
"invmod(n, P) % P``，其中 ``invmod(n, P)`` 是对 ``n`` 模 ``P`` 取反。"

#: ../../library/stdtypes.rst:735
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule"
" above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"如果 ``x = m / n`` 是一个非负的有理数且 ``n`` 可被 ``P`` 整除（但 ``m`` 不能）则 ``n`` 不能对 ``P`` "
"降模，以上规则不适用；在此情况下则定义 ``hash(x)`` 为常数值 ``sys.hash_info.inf``。"

#: ../../library/stdtypes.rst:740
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as "
"``-hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"如果 ``x = m / n`` 是一个负的有理数则定义 ``hash(x)`` 为 ``-hash(-x)``。 如果结果哈希值为 ``-1`` "
"则将其替换为 ``-2``。"

#: ../../library/stdtypes.rst:744
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr "特殊值 ``sys.hash_info.inf`` 和 ``-sys.hash_info.inf`` 分别用于正无穷或负无穷的哈希值。"

#: ../../library/stdtypes.rst:748
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, reduced modulo "
"``2**sys.hash_info.width`` so that it lies in "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))``.  "
"Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"对于一个 :class:`complex` 值 ``z``，会通过计算 ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)`` 将实部和虚部的哈希值结合起来，并进行降模 ``2**sys.hash_info.width`` 以使其处于 "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))`` 范围之内。"
" 同样地，如果结果为 ``-1`` 则将其替换为 ``-2``。"

#: ../../library/stdtypes.rst:756
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, "
":class:`float`, or :class:`complex`::"
msgstr ""
"为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、:class:`float` 或 "
":class:`complex` 的哈希值::"

#: ../../library/stdtypes.rst:761
msgid ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"
msgstr ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # 移除 P 的公因数。 （如果 m 和 n 互质则不需要。）\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # 费马小定理: pow(n, P-1, P) 等于 1，\n"
"        # 则 pow(n, P-2, P) 等于 n 除以 P 的余数的倒数。\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n"
"    # 带正负号的约减求余运算 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"

#: ../../library/stdtypes.rst:812
msgid "Boolean Type - :class:`bool`"
msgstr "布尔类型 - :class:`bool`"

#: ../../library/stdtypes.rst:814
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr "代表真值的布尔对象。 :class:`bool` 类型只有两个常量实例: ``True`` 和 ``False``。"

#: ../../library/stdtypes.rst:822
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr "内置函数 :func:`bool` 可将任意值转换为布尔值，如果该值可以被解读为逻辑值的话（参见上面的 :ref:`truth` 小节）。"

#: ../../library/stdtypes.rst:825
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and"
" ``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"对于逻辑运算，请使用 :ref:`布尔运算符 <boolean>` ``and``, ``or`` 和 ``not``。 当于两个布尔值应用按位运算符 "
"``&``, ``|``, ``^`` 时，它们将返回一个等价于逻辑运算 \"与\", \"或\", \"异或\" 的布尔值。 "
"但是，更推荐使用逻辑运算符 ``and``, ``or`` 和 ``!=`` 而不是 ``&``, ``|`` 和 ``^``。"

#: ../../library/stdtypes.rst:834
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise"
" an error in Python 3.16."
msgstr "使用按位取反运算符 ``~`` 已被弃用并将在 Python 3.16 中引发错误。"

#: ../../library/stdtypes.rst:837
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and"
" 1, respectively. However, relying on this is discouraged; explicitly "
"convert using :func:`int` instead."
msgstr ""
":class:`bool` 是 :class:`int` 的子类 (参见 :ref:`typesnumeric`)。 "
"在许多数字场景下，``False`` 和 ``True`` 的行为分别与整数 0 和 1 类似。 但是，不建议这样使用；请使用 :func:`int` "
"显式地执行转换。"

#: ../../library/stdtypes.rst:845
msgid "Iterator Types"
msgstr "迭代器类型"

#: ../../library/stdtypes.rst:853
msgid ""
"Python supports a concept of iteration over containers.  This is implemented"
" using two distinct methods; these are used to allow user-defined classes to"
" support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 "
"将在下文中详细描述的序列总是支持迭代方法。"

#: ../../library/stdtypes.rst:858
msgid ""
"One method needs to be defined for container objects to provide "
":term:`iterable` support:"
msgstr "容器对象要提供 :term:`iterable` 支持，必须定义一个方法:"

#: ../../library/stdtypes.rst:865
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"返回一个 :term:`iterator` 对象。 该对象需要支持下文所述的迭代器协议。 "
"如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 "
"（支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结果。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 "
":c:member:`~PyTypeObject.tp_iter` 槽位。"

#: ../../library/stdtypes.rst:874
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr "迭代器对象自身需要支持以下两个方法，它们共同组成了 :dfn:`迭代器协议`:"

#: ../../library/stdtypes.rst:880
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements.  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"返回 :term:`iterator` 对象本身。 这是同时允许容器和迭代器配合 :keyword:`for` 和 :keyword:`in` "
"语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 "
":c:member:`~PyTypeObject.tp_iter` 槽位。"

#: ../../library/stdtypes.rst:889
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to"
" the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
":term:`iterator` 中返回下一项。 如果已经没有可返回的项，则会引发 :exc:`StopIteration` 异常。 此方法对应于 "
"Python/C API 中 Python 对象类型结构体的 :c:member:`~PyTypeObject.tp_iternext` 槽位。"

#: ../../library/stdtypes.rst:894
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized forms."
"  The specific types are not important beyond their implementation of the "
"iterator protocol."
msgstr ""
"Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 "
"除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。"

#: ../../library/stdtypes.rst:899
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises "
":exc:`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"一旦迭代器的 :meth:`~iterator.__next__` 方法引发了 "
":exc:`StopIteration`，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。"

#: ../../library/stdtypes.rst:907
msgid "Generator Types"
msgstr "生成器类型"

#: ../../library/stdtypes.rst:909
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~object.__iter__` method "
"is implemented as a generator, it will automatically return an iterator "
"object (technically, a generator object) supplying the "
":meth:`~iterator.__iter__` and :meth:`~generator.__next__` methods. More "
"information about generators can be found in :ref:`the documentation for the"
" yield expression <yieldexpr>`."
msgstr ""
"Python 的 :term:`generator` 提供了一种实现迭代器协议的便捷方式。 如果一个容器对象的 "
":meth:`~object.__iter__` 方法以生成器的形式实现，它将自动返回一个提供 :meth:`~iterator.__iter__` 和"
" :meth:`~generator.__next__` 方法的迭代器对象（从技术上说，是一个生成器对象）。 有关生成器的更多信息可参阅 "
":ref:`yield 表达式的文档 <yieldexpr>`。"

#: ../../library/stdtypes.rst:921
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "序列类型 --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:923
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"有三种基本序列类型：list, tuple 和 range 对象。 为处理 :ref:`二进制数据 <binaryseq>` 和 :ref:`文本字符串"
" <textseq>` 而特别定制的附加序列类型会在专门的小节中描述。"

#: ../../library/stdtypes.rst:932
msgid "Common Sequence Operations"
msgstr "通用序列操作"

#: ../../library/stdtypes.rst:936
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom"
" sequence types."
msgstr ""
"大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 :class:`collections.abc.Sequence` ABC "
"被提供用来更容易地在自定义序列类型上正确地实现这些操作。"

#: ../../library/stdtypes.rst:941
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k*"
" are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"此表按优先级升序列出了序列操作。 在表格中，*s* 和 *t* 是具有相同类型的序列，*n*, *i*, *j* 和 *k* 是整数而 *x* "
"是任何满足 *s* 所规定的类型和值限制的任意对象。"

#: ../../library/stdtypes.rst:946
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"``in`` 和 ``not in`` 操作具有与比较操作相同的优先级。 ``+`` (拼接) 和 ``*`` (重复) "
"操作具有与对应数值运算相同的优先级。 [3]_"

#: ../../library/stdtypes.rst:967
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:967
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "如果 *s* 中的某项等于 *x* 则结果为 ``True``，否则为 ``False``"

#: ../../library/stdtypes.rst:970
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:970
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "如果 *s* 中的某项等于 *x* 则结果为 ``False``，否则为 ``True``"

#: ../../library/stdtypes.rst:973
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:973
msgid "the concatenation of *s* and *t*"
msgstr "*s* 与 *t* 相拼接"

#: ../../library/stdtypes.rst:973
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:976
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` 或 ``n * s``"

#: ../../library/stdtypes.rst:976
msgid "equivalent to adding *s* to itself *n* times"
msgstr "相当于 *s* 与自身进行 *n* 次拼接"

#: ../../library/stdtypes.rst:976
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:979
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:979
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* 的第 *i* 项，起始为 0"

#: ../../library/stdtypes.rst:981
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j*"
msgstr "*s* 从 *i* 到 *j* 的切片"

#: ../../library/stdtypes.rst:981
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:983
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:983
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* 从 *i* 到 *j* 步长为 *k* 的切片"

#: ../../library/stdtypes.rst:983
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:986
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:986
msgid "length of *s*"
msgstr "*s* 的长度"

#: ../../library/stdtypes.rst:988
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:988
msgid "smallest item of *s*"
msgstr "*s* 的最小项"

#: ../../library/stdtypes.rst:990
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:990
msgid "largest item of *s*"
msgstr "*s* 的最大项"

#: ../../library/stdtypes.rst:992
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:992
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr "*x* 在 *s* 中首次出现项的索引号（索引号在 *i* 或其后且在 *j* 之前）"

#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:3817
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:996
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:996
msgid "total number of occurrences of *x* in *s*"
msgstr "*x* 在 *s* 中出现的总次数"

#: ../../library/stdtypes.rst:1000
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal"
" and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 "
"这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 （完整细节请参阅语言参考的 :ref:`comparisons` "
"部分。）"

#: ../../library/stdtypes.rst:1010
msgid ""
"Forward and reversed iterators over mutable sequences access values using an"
" index.  That index will continue to march forward (or backward) even if the"
" underlying sequence is mutated.  The iterator terminates only when an "
":exc:`IndexError` or a :exc:`StopIteration` is encountered (or when the "
"index drops below zero)."
msgstr ""
"可变序列的正向和逆向迭代器使用一个索引来访问值。 即使底层序列被改变该索引也将持续向前（或向后）步进。 迭代器只有在遇到 "
":exc:`IndexError` 或 a :exc:`StopIteration` 时才会终结（或是当索引降至零以下）。"

#: ../../library/stdtypes.rst:1019
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such as"
" :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"虽然 ``in`` 和 ``not in`` 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 :class:`str`, "
":class:`bytes` 和 :class:`bytearray`) 也使用它们进行子序列检测::"

#: ../../library/stdtypes.rst:1024
msgid ""
">>> \"gg\" in \"eggs\"\n"
"True"
msgstr ""
">>> \"gg\" in \"eggs\"\n"
"True"

#: ../../library/stdtypes.rst:1028
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"小于 ``0`` 的 *n* 值会被当作 ``0`` 来处理 (生成一个与 *s* 同类型的空序列)。 请注意序列 *s* "
"中的项并不会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如::"

#: ../../library/stdtypes.rst:1033
msgid ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"
msgstr ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"

#: ../../library/stdtypes.rst:1040
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty"
" list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single"
" list. You can create a list of different lists this way::"
msgstr ""
"具体的原因在于 ``[[]]`` 是一个包含了一个空列表的单元素列表，所以 ``[[]] * 3`` 结果中的三个元素都是对这一个空列表的引用。 修改 "
"``lists`` 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表::"

#: ../../library/stdtypes.rst:1045
msgid ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"
msgstr ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"

#: ../../library/stdtypes.rst:1052
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr "进一步的解释可以在 FAQ 条目 :ref:`faq-multidimensional-list` 中查看。"

#: ../../library/stdtypes.rst:1056
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*:"
" ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"如果 *i* 或 *j* 为负值，则索引顺序是相对于序列 *s* 的末尾: 索引号会被替换为 ``len(s) + i`` 或 ``len(s) + "
"j``。 但要注意 ``-0`` 仍然为 ``0``。"

#: ../../library/stdtypes.rst:1061
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal"
" to *j*, the slice is empty."
msgstr ""
"*s* 从 *i* 到 *j* 的切片被定义为所有满足 ``i <= k < j`` 的索引号 *k* 的项组成的序列。 如果 *i* 或 *j* 大于"
" ``len(s)``，则使用 ``len(s)``。 如果 *i* 被省略或为 ``None``，则使用 ``0``。 如果 *j* 被省略或为 "
"``None``，则使用 ``len(s)``。 如果 *i* 大于等于 *j*，则切片为空。"

#: ../../library/stdtypes.rst:1068
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of"
" items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other"
" words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is"
" ``None``, it is treated like ``1``."
msgstr ""
"*s* 从 *i* 到 *j* 步长为 *k* 的切片被定义为所有满足 ``0 <= n < (j-i)/k`` 的索引号  ``x = i + "
"n*k`` 的项组成的序列。 换句话说，索引号为 ``i``, ``i+k``, ``i+2*k``, ``i+3*k``，以此类推，当达到 *j* "
"时停止 (但一定不包括 *j*)。 当 *k* 为正值时，*i* 和 *j* 会被减至不大于 ``len(s)``。 当 *k* 为负值时，*i* 和 "
"*j* 会被减至不大于 ``len(s) - 1``。 如果 *i* 或 *j* 被省略或为 ``None``，它们会成为“终止”值 "
"(是哪一端的终止值则取决于 *k* 的符号)。 请注意，*k* 不可为零。 如果 *k* 为 ``None``，则当作 ``1`` 处理。"

#: ../../library/stdtypes.rst:1079
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 "
"想要获得线性的运行时开销，你必须改用下列替代方案之一："

#: ../../library/stdtypes.rst:1084
msgid ""
"if concatenating :class:`str` objects, you can build a list and use "
":meth:`str.join` at the end or else write to an :class:`io.StringIO` "
"instance and retrieve its value when complete"
msgstr ""
"如果拼接 :class:`str` 对象，你可以构建一个列表并在最后使用 :meth:`str.join` 或是写入一个 "
":class:`io.StringIO` 实例并在结束时获取它的值"

#: ../../library/stdtypes.rst:1088
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use "
":meth:`bytes.join` or :class:`io.BytesIO`, or you can do in-place "
"concatenation with a :class:`bytearray` object.  :class:`bytearray` objects "
"are mutable and have an efficient overallocation mechanism"
msgstr ""
"如果拼接 :class:`bytes` 对象，你可以类似地使用 :meth:`bytes.join` 或 "
":class:`io.BytesIO`，或者你也可以使用 :class:`bytearray` 对象进行原地拼接。 :class:`bytearray`"
" 对象是可变的，并且具有高效的重分配机制"

#: ../../library/stdtypes.rst:1093
msgid ""
"if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr "如果拼接 :class:`tuple` 对象，请改为扩展 :class:`list` 类"

#: ../../library/stdtypes.rst:1095
msgid "for other types, investigate the relevant class documentation"
msgstr "对于其它类型，请查看相应的文档"

#: ../../library/stdtypes.rst:1099
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr "某些序列类型 (例如 :class:`range`) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。"

#: ../../library/stdtypes.rst:1104
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only"
" without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"当 *x* 在 *s* 中找不到时 ``index`` 会引发 :exc:`ValueError`。 不是所有实现都支持传入额外参数 *i* 和 "
"*j*。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 "
"``s[i:j].index(x)``，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。"

#: ../../library/stdtypes.rst:1115
msgid "Immutable Sequence Types"
msgstr "不可变序列类型"

#: ../../library/stdtypes.rst:1122
msgid ""
"The only operation that immutable sequence types generally implement that is"
" not also implemented by mutable sequence types is support for the "
":func:`hash` built-in."
msgstr "不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 :func:`hash` 内置函数的支持。"

#: ../../library/stdtypes.rst:1126
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and "
":class:`frozenset` instances."
msgstr ""
"这种支持允许不可变类型，例如 :class:`tuple` 实例被用作 :class:`dict` 键，以及存储在 :class:`set` 和 "
":class:`frozenset` 实例中。"

#: ../../library/stdtypes.rst:1130
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr "尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 :exc:`TypeError`。"

#: ../../library/stdtypes.rst:1137
msgid "Mutable Sequence Types"
msgstr "可变序列类型"

#: ../../library/stdtypes.rst:1144
msgid ""
"The operations in the following table are defined on mutable sequence types."
" The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"以下表格中的操作是在可变序列类型上定义的。 :class:`collections.abc.MutableSequence` ABC "
"被提供用来更容易地在自定义序列类型上正确实现这些操作。"

#: ../../library/stdtypes.rst:1148
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value"
" restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"表格中的 *s* 是可变序列类型的实例，*t* 是任意可迭代对象，而 *x* 是符合对 *s* 所规定类型与值限制的任何对象 "
"(例如，:class:`bytearray` 仅接受满足 ``0 <= x <= 255`` 值限制的整数)。"

#: ../../library/stdtypes.rst:1172
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1172
msgid "item *i* of *s* is replaced by *x*"
msgstr "将 *s* 的第 *i* 项替换为 *x*"

#: ../../library/stdtypes.rst:1175
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1175
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "将 *s* 从 *i* 到 *j* 的切片替换为可迭代对象 *t* 的内容"

#: ../../library/stdtypes.rst:1179
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1179
msgid "same as ``s[i:j] = []``"
msgstr "等同于 ``s[i:j] = []``"

#: ../../library/stdtypes.rst:1181
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1181
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "将 ``s[i:j:k]`` 的元素替换为 *t* 的元素"

#: ../../library/stdtypes.rst:1184
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1184
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "从列表中移除 ``s[i:j:k]`` 的元素"

#: ../../library/stdtypes.rst:1187
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1187
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "将 *x* 添加到序列的末尾 (等同于 ``s[len(s):len(s)] = [x]``)"

#: ../../library/stdtypes.rst:1191
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1191
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "从 *s* 中移除所有项 (等同于 ``del s[:]``)"

#: ../../library/stdtypes.rst:1194
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1194
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "创建 *s* 的浅拷贝 (等同于 ``s[:]``)"

#: ../../library/stdtypes.rst:1197
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` 或 ``s += t``"

#: ../../library/stdtypes.rst:1197
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "用 *t* 的内容扩展 *s* (基本上等同于 ``s[len(s):len(s)] = t``)"

#: ../../library/stdtypes.rst:1202
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1202
msgid "updates *s* with its contents repeated *n* times"
msgstr "使用 *s* 的内容重复 *n* 次来对其进行更新"

#: ../../library/stdtypes.rst:1205
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1205
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "在由 *i* 给出的索引位置将 *x* 插入 *s* (等同于 ``s[i:i] = [x]``)"

#: ../../library/stdtypes.rst:1209
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` 或 ``s.pop(i)``"

#: ../../library/stdtypes.rst:1209
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "提取在 *i* 位置上的项，并将其从 *s* 中移除"

#: ../../library/stdtypes.rst:1212
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1212
msgid "removes the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "从 *s* 中移除第一个 ``s[i]`` 等于 *x* 的条目"

#: ../../library/stdtypes.rst:1216
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1216
msgid "reverses the items of *s* in place"
msgstr "就地将列表中的元素逆序。"

#: ../../library/stdtypes.rst:1224
msgid ""
"If *k* is not equal to ``1``, *t* must have the same length as the slice it "
"is replacing."
msgstr "如果 *k* 不等于 ``1``，则 *t* 必须与它所替换的切片具有相同的长度。"

#: ../../library/stdtypes.rst:1227
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr "可选参数 *i* 默认为 ``-1``，因此在默认情况下会移除并返回最后一项。"

#: ../../library/stdtypes.rst:1231
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr "当在 *s* 中找不到 *x* 时 :meth:`remove` 操作会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1234
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"当反转大尺寸序列时 :meth:`reverse` 方法会原地修改该序列以保证空间经济性。 "
"为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。"

#: ../../library/stdtypes.rst:1239
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such"
" as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the "
":class:`collections.abc.MutableSequence` ABC, but most concrete mutable "
"sequence classes provide it."
msgstr ""
"包括 :meth:`clear` 和 :meth:`!copy` 是为了与不支持切片操作的可变容器 (例如 :class:`dict` 和 "
":class:`set`) 的接口保持一致。 :meth:`!copy` 不是 "
":class:`collections.abc.MutableSequence` ABC 的一部分，但大多数具体的可变序列类都提供了它。"

#: ../../library/stdtypes.rst:1245
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` 和 :meth:`!copy` 方法。"

#: ../../library/stdtypes.rst:1249
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"*n* 值为一个整数，或是一个实现了 :meth:`~object.__index__` 的对象。 *n* 值为零或负数将清空序列。 "
"序列中的项不会被拷贝；它们会被多次引用，正如 :ref:`typesseq-common` 中有关 ``s * n`` 的说明。"

#: ../../library/stdtypes.rst:1258
msgid "Lists"
msgstr "列表"

#: ../../library/stdtypes.rst:1262
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr "列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。"

#: ../../library/stdtypes.rst:1268
msgid "Lists may be constructed in several ways:"
msgstr "可以用多种方式构建列表："

#: ../../library/stdtypes.rst:1270
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "使用一对方括号来表示空列表: ``[]``"

#: ../../library/stdtypes.rst:1271
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr "使用方括号，其中的项以逗号分隔: ``[a]``, ``[a, b, c]``"

#: ../../library/stdtypes.rst:1272
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "使用列表推导式: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1273
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "使用类型的构造器: ``list()`` 或 ``list(iterable)``"

#: ../../library/stdtypes.rst:1275
msgid ""
"The constructor builds a list whose items are the same and in the same order"
" as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"构造器将构造一个列表，其中的项与 *iterable* 中的项具有相同的的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其它可迭代对象。"
" 如果 *iterable* 已经是一个列表，将创建并返回其副本，类似于 ``iterable[:]``。 例如，``list('abc')`` 返回 "
"``['a', 'b', 'c']`` 而 ``list( (1, 2, 3) )`` 返回 ``[1, 2, 3]``。 "
"如果没有给出参数，构造器将创建一个空列表 ``[]``。"

#: ../../library/stdtypes.rst:1284
msgid ""
"Many other operations also produce lists, including the :func:`sorted` "
"built-in."
msgstr "其它许多操作也会产生列表，包括 :func:`sorted` 内置函数。"

#: ../../library/stdtypes.rst:1287
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable"
" <typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"列表实现了所有 :ref:`一般 <typesseq-common>` 和 :ref:`可变 <typesseq-mutable>` 序列的操作。 "
"列表还额外提供了以下方法："

#: ../../library/stdtypes.rst:1293
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"此方法会对列表进行原地排序，只使用 ``<`` 来进行各项间比较。 异常不会被屏蔽 —— "
"如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。"

#: ../../library/stdtypes.rst:1298
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword "
"(:ref:`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` 接受两个仅限以关键字形式传入的参数 (:ref:`仅限关键字参数 <keyword-only_parameter>`):"

#: ../../library/stdtypes.rst:1301
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 ``key=str.lower``)。 "
"对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 ``None`` 表示直接对列表项排序而不计算一个单独的键值。"

#: ../../library/stdtypes.rst:1308
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style"
" *cmp* function to a *key* function."
msgstr "可以使用 :func:`functools.cmp_to_key` 将 2.x 风格的 *cmp* 函数转换为 *key* 函数。"

#: ../../library/stdtypes.rst:1311
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* 为一个布尔值。 如果设为 ``True``，则每个列表元素将按反向顺序比较进行排序。"

#: ../../library/stdtypes.rst:1314
msgid ""
"This method modifies the sequence in place for economy of space when sorting"
" a large sequence.  To remind users that it operates by side effect, it does"
" not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 "
":func:`sorted` 显示地请求一个新的已排序列表实例）。"

#: ../../library/stdtypes.rst:1319
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
":meth:`sort` 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- "
"这有利于进行多重排序（例如先按部门、再接薪级排序）。"

#: ../../library/stdtypes.rst:1324
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有关排序示例和简要排序教程，请参阅 :ref:`sortinghowto` 。"

#: ../../library/stdtypes.rst:1328
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C "
"实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1337
msgid "Tuples"
msgstr "元组"

#: ../../library/stdtypes.rst:1341
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or "
":class:`dict` instance)."
msgstr ""
"元组是不可变序列，通常用于储存异构数据的多项集（例如由 :func:`enumerate` 内置函数所产生的二元组）。 "
"元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 :class:`set` 或 :class:`dict` 的实例）。"

#: ../../library/stdtypes.rst:1349
msgid "Tuples may be constructed in a number of ways:"
msgstr "可以用多种方式构建元组："

#: ../../library/stdtypes.rst:1351
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "使用一对圆括号来表示空元组: ``()``"

#: ../../library/stdtypes.rst:1352
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "使用一个后缀的逗号来表示单元组: ``a,`` 或 ``(a,)``"

#: ../../library/stdtypes.rst:1353
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "使用以逗号分隔的多个项: ``a, b, c`` or ``(a, b, c)``"

#: ../../library/stdtypes.rst:1354
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "使用内置的 :func:`tuple`: ``tuple()`` 或 ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1356
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"构造器将构造一个元组，其中的项与 *iterable* 中的项具有相同的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其他可迭代对象。 "
"如果 *iterable* 已经是一个元组，会不加改变地将其返回。 例如，``tuple('abc')`` 返回 ``('a', 'b', 'c')``"
" 而 ``tuple( [1, 2, 3] )`` 返回 ``(1, 2, 3)``。 如果没有给出参数，构造器将创建一个空元组 ``()``。"

#: ../../library/stdtypes.rst:1364
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses."
" The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，``f(a, b, c)`` "
"是在调用函数时附带三个参数，而 ``f((a, b, c))`` 则是在调用函数时附带一个三元组。"

#: ../../library/stdtypes.rst:1370
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr "元组实现了所有 :ref:`一般 <typesseq-common>` 序列的操作。"

#: ../../library/stdtypes.rst:1373
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"对于通过名称访问相比通过索引访问更清晰的异构数据多项集，:func:`collections.namedtuple` "
"可能是比简单元组对象更为合适的选择。"

#: ../../library/stdtypes.rst:1381
msgid "Ranges"
msgstr "range 对象"

#: ../../library/stdtypes.rst:1385
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` "
"loops."
msgstr ":class:`range` 类型表示不可变的数字序列，通常用于在 :keyword:`for` 循环中循环指定的次数。"

#: ../../library/stdtypes.rst:1392
msgid ""
"The arguments to the range constructor must be integers (either built-in "
":class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is zero,"
" :exc:`ValueError` is raised."
msgstr ""
"range 构造器的参数必须为整数（可以是内置的 :class:`int` 或任何实现了 :meth:`~object.__index__` "
"特殊方法的对象）。 如果省略 *step* 参数，则默认为 ``1``。 如果省略 *start* 参数，则默认为 ``0``。 如果 *step* "
"为零，则会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1398
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"如果 *step* 为正值，确定 range ``r`` 内容的公式为 ``r[i] = start + step*i`` 其中 ``i >= 0`` "
"且 ``r[i] < stop``。"

#: ../../library/stdtypes.rst:1402
msgid ""
"For a negative *step*, the contents of the range are still determined by the"
" formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"如果 *step* 为负值，确定 range 内容的公式仍然为 ``r[i] = start + step*i``，但限制条件改为 ``i >= 0``"
" 且 ``r[i] > stop``."

#: ../../library/stdtypes.rst:1406
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint."
" Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"如果 ``r[0]`` 不符合值的限制条件，则该 range 对象为空。 range "
"对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。"

#: ../../library/stdtypes.rst:1411
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise "
":exc:`OverflowError`."
msgstr ""
"元素绝对值大于 :data:`sys.maxsize` 的 range 对象是被允许的，但某些特性 (例如 :func:`len`) 可能引发 "
":exc:`OverflowError`。"

#: ../../library/stdtypes.rst:1415
msgid "Range examples::"
msgstr "一些 range 对象的例子::"

#: ../../library/stdtypes.rst:1417
msgid ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"
msgstr ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"

#: ../../library/stdtypes.rst:1432
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"range 对象实现了 :ref:`一般 <typesseq-common>` 序列的所有操作，但拼接和重复除外（这是由于 range "
"对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。"

#: ../../library/stdtypes.rst:1439
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "*start* 形参的值 (如果该形参未提供则为 ``0``)"

#: ../../library/stdtypes.rst:1444
msgid "The value of the *stop* parameter"
msgstr "*stop* 形参的值"

#: ../../library/stdtypes.rst:1448
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "*step* 形参的值 (如果该形参未提供则为 ``1``)"

#: ../../library/stdtypes.rst:1451
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or "
":class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
":class:`range` 类型相比常规 :class:`list` 或 :class:`tuple` 的优势在于一个 :class:`range` "
"对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 ``start``, ``stop`` 和 ``step`` "
"值，并会根据需要计算具体单项或子范围的值）。"

#: ../../library/stdtypes.rst:1457
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"range 对象实现了 :class:`collections.abc.Sequence` "
"ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 (参见 :ref:`typesseq`):"

#: ../../library/stdtypes.rst:1477
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop`"
" and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"使用 ``==`` 和 ``!=`` 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range "
"对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 :attr:`~range.start`, "
":attr:`~range.stop` 和 :attr:`~range.step` 属性，例如 ``range(0) == range(2, 1, "
"3)`` 而 ``range(0, 3, 2) == range(0, 4, 2)``。）"

#: ../../library/stdtypes.rst:1484
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test "
":class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"实现 Sequence ABC。 支持切片和负数索引。 使用 :class:`int` 对象在固定时间内进行成员检测，而不是逐一迭代所有项。"

#: ../../library/stdtypes.rst:1490
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr "定义 '==' 和 '!=' 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。"

#: ../../library/stdtypes.rst:1495
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"增加了 :attr:`~range.start`, :attr:`~range.stop` 和 :attr:`~range.step` 属性。"

#: ../../library/stdtypes.rst:1500
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating-point applications."
msgstr ""
"`linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ 演示了如何实现一个惰性求值版本的适合浮点数应用的 range 对象。"

#: ../../library/stdtypes.rst:1512
msgid "Text Sequence Type --- :class:`str`"
msgstr "文本序列类型 --- :class:`str`"

#: ../../library/stdtypes.rst:1514
msgid ""
"Textual data in Python is handled with :class:`str` objects, or "
":dfn:`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode"
" code points.  String literals are written in a variety of ways:"
msgstr ""
"在 Python 中处理文本数据是使用 :class:`str` 对象，也称为 :dfn:`字符串`。 字符串是由 Unicode 码位构成的不可变 "
":ref:`序列 <typesseq>`。 字符串字面值有多种不同的写法："

#: ../../library/stdtypes.rst:1519
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "单引号: ``'允许包含有 \"双\" 引号'``"

#: ../../library/stdtypes.rst:1520
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "双引号: ``\"允许嵌入 '单' 引号\"``"

#: ../../library/stdtypes.rst:1521
msgid "Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes\"\"\"``"
msgstr "三重引号: ``'''三重单引号'''``, ``\"\"\"三重双引号\"\"\"``"

#: ../../library/stdtypes.rst:1523
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr "使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。"

#: ../../library/stdtypes.rst:1526
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，``(\"spam \" \"eggs\") "
"== \"spam eggs\"``。"

#: ../../library/stdtypes.rst:1530
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""
"请参阅 :ref:`strings` 了解有关各种字符串字面值形式的更多信息，包括所支持的 :ref:`转义序列 <escape-"
"sequences>`，以及禁用大多数转义序列处理的 ``r`` (\"raw\") 前缀。"

#: ../../library/stdtypes.rst:1534
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr "字符串也可以通过使用 :class:`str` 构造器从其他对象创建。"

#: ../../library/stdtypes.rst:1537
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == "
"s[0:1]``."
msgstr ""
"由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 *s*, ``s[0] == "
"s[0:1]``。"

#: ../../library/stdtypes.rst:1543
msgid ""
"There is also no mutable string type, but :meth:`str.join` or "
":class:`io.StringIO` can be used to efficiently construct strings from "
"multiple fragments."
msgstr ""
"不存在可变的字符串类型，但是 :meth:`str.join` 或 :class:`io.StringIO` "
"可以被被用来根据多个片段高效率地构建字符串。"

#: ../../library/stdtypes.rst:1547
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 ``u`` 前缀。 它对字符串字面值的含义没有影响，并且不能与 ``r`` "
"前缀同时出现。"

#: ../../library/stdtypes.rst:1559
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"返回 *object* 的 :ref:`字符串 <textseq>` 版本。 如果未提供 *object* 则返回空字符串。 在其他情况下 "
"``str()`` 的行为取决于 *encoding* 或 *errors* 是否有给出，具体见下。"

#: ../../library/stdtypes.rst:1563
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns "
":meth:`type(object).__str__(object) <object.__str__>`, which is the "
"\"informal\" or nicely printable string representation of *object*.  For "
"string objects, this is the string itself.  If *object* does not have a "
":meth:`~object.__str__` method, then :func:`str` falls back to returning "
":func:`repr(object) <repr>`."
msgstr ""
"如果 *encoding* 或 *errors* 均未给出，则 ``str(object)`` 将返回 "
":meth:`type(object).__str__(object) <object.__str__>`，这是 *object* "
"的“非正式”而适合显示的字符串表示形式。 对于字符串对象，这就是该字符串本身。 如果 *object* 没有 "
":meth:`~object.__str__` 方法，则 :func:`str` 将回退为返回 :func:`repr(object) <repr>`。"

#: ../../library/stdtypes.rst:1575
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a "
":term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to "
":meth:`bytes.decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes"
" object underlying the buffer object is obtained before calling "
":meth:`bytes.decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for "
"information on buffer objects."
msgstr ""
"如果 *encoding* 或 *errors* 至少给出其中之一，则 *object* 应该是一个 :term:`bytes-like object`"
" (例如 :class:`bytes` 或 :class:`bytearray`)。 在此情况下，如果 *object* 是一个 "
":class:`bytes` (或 :class:`bytearray`) 对象，则 ``str(bytes, encoding, errors)`` "
"等价于 :meth:`bytes.decode(encoding, errors) <bytes.decode>`。 否则的话，会在调用 "
":meth:`bytes.decode` 之前获取缓冲区对象下层的 bytes 对象。 请参阅 :ref:`binaryseq` 与 "
":ref:`bufferobjects` 了解有关缓冲区对象的信息。"

#: ../../library/stdtypes.rst:1584
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"将一个 :class:`bytes` 对象传入 :func:`str` 而不给出 *encoding* 或 *errors* 参数的操作属于第一种情况，"
" 将返回非正式的字符串表示（另请参阅 Python 的 :option:`-b` 命令行选项）。 例如::"

#: ../../library/stdtypes.rst:1589
msgid ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""
msgstr ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""

#: ../../library/stdtypes.rst:1592
msgid ""
"For more information on the ``str`` class and its methods, see "
":ref:`textseq` and the :ref:`string-methods` section below.  To output "
"formatted strings, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections.  In addition, see the :ref:`stringservices` section."
msgstr ""
"有关 ``str`` 类及其方法的更多信息，请参阅下面的 :ref:`textseq` 和 :ref:`string-methods` 小节。 "
"要输出格式化字符串，请参阅 :ref:`f-strings` 和 :ref:`formatstrings` 小节。 此外还可以参阅 "
":ref:`stringservices` 小节。"

#: ../../library/stdtypes.rst:1604
msgid "String Methods"
msgstr "字符串的方法"

#: ../../library/stdtypes.rst:1609
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr "字符串实现了所有 :ref:`一般 <typesseq-common>` 序列的操作，还额外提供了以下列出的一些附加方法。"

#: ../../library/stdtypes.rst:1612
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, "
":ref:`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 :meth:`str.format`, "
":ref:`formatstrings` 和 :ref:`string-formatting`) 而另一种是基于 C ``printf`` "
"样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 (:ref:`old-string-"
"formatting`)。"

#: ../../library/stdtypes.rst:1619
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular"
" expression support in the :mod:`re` module)."
msgstr ""
"标准库的 :ref:`textservices` 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 :mod:`re` "
"模块中的正则表达式支持）。"

#: ../../library/stdtypes.rst:1625
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "返回原字符串的副本，其首个字符大写，其余为小写。"

#: ../../library/stdtypes.rst:1628
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。"

#: ../../library/stdtypes.rst:1635
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr "返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。"

#: ../../library/stdtypes.rst:1638
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; "
":meth:`casefold` converts it to ``\"ss\"``."
msgstr ""
"消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 ``'ß'`` 相当于 "
"``\"ss\"``。 由于它已经是小写了，:meth:`lower` 不会对 ``'ß'`` 做任何改变；而 :meth:`casefold` "
"则会将其转换为 ``\"ss\"``。"

#: ../../library/stdtypes.rst:1644
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__."
msgstr ""
"大小写折叠算法在 ` Unicode 标准第 3.13 节 'Default Case Folding' 中描述 "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__。"

#: ../../library/stdtypes.rst:1653
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"返回长度为 *width* 的字符串，原字符串在其正中。 使用指定的 *fillchar* 填充两边的空位（默认使用 ASCII 空格符）。 如果 "
"*width* 小于等于 ``len(s)`` 则返回原字符串的副本。"

#: ../../library/stdtypes.rst:1661
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"返回子字符串 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* "
"会被解读为切片表示法。"

#: ../../library/stdtypes.rst:1665
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr "如果 *sub* 为空，则返回字符之间的空字符串数，即字符串的长度加一。"

#: ../../library/stdtypes.rst:1671
msgid "Return the string encoded to :class:`bytes`."
msgstr "返回编码为 :class:`bytes` 的字符串。"

#: ../../library/stdtypes.rst:1673 ../../library/stdtypes.rst:2982
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr "*encoding* 默认为 ``'utf-8'`` ；请参阅 :ref:`standard-encodings` 了解其他可能的值。"

#: ../../library/stdtypes.rst:1676
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via "
":func:`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* 控制如何处理编码错误。 如为 ``'strict'`` (默认值)，则会引发 :exc:`UnicodeError`。 其他可能的值有"
" ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` 以及通过 :func:`codecs.register_error` 注册的任何其他名称。 请参阅 "
":ref:`error-handlers` 了解详情。"

#: ../../library/stdtypes.rst:1683
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a "
":ref:`debug build <debug-build>` is used."
msgstr ""
"出于性能原因，除非真正发生了编码错误，启用了 :ref:`devmode` 或使用了 :ref:`调试编译版 <debug-build>` 否则不会检查"
" *errors* 值的有效性。"

#: ../../library/stdtypes.rst:1688 ../../library/stdtypes.rst:3001
msgid "Added support for keyword arguments."
msgstr "加入了对关键字参数的支持。"

#: ../../library/stdtypes.rst:1691 ../../library/stdtypes.rst:3004
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in "
":ref:`debug mode <debug-build>`."
msgstr "现在会在 :ref:`devmode` 和 :ref:`调试模式 <debug-build>` 下检查 *errors* 参数的值。"

#: ../../library/stdtypes.rst:1698
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"如果字符串以指定的 *suffix* 结束返回 ``True``，否则返回 ``False``。 *suffix* "
"也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。"

#: ../../library/stdtypes.rst:1706
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current"
" column is set to zero and the string is examined character by character.  "
"If the character is a tab (``\\t``), one or more space characters are "
"inserted in the result until the current column is equal to the next tab "
"position. (The tab character itself is not copied.)  If the character is a "
"newline (``\\n``) or return (``\\r``), it is copied and the current column "
"is reset to zero.  Any other character is copied unchanged and the current "
"column is incremented by one regardless of how the character is represented "
"when printed."
msgstr ""
"返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* 个字符设为一个制表位（默认值"
" 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 "
"(``\\t``)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (``\\n``) "
"或回车符 (``\\r``)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。"

#: ../../library/stdtypes.rst:1727
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"返回子字符串 *sub* 在 ``s[start:end]`` 切片内被找到的最小索引。 可选参数 *start* 与 *end* "
"会被解读为切片表示法。 如果 *sub* 未被找到则返回 ``-1``。"

#: ../../library/stdtypes.rst:1733
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~str.find` 方法应该只在你需要知道 *sub* 所在位置时使用。 要检查 *sub* 是否为子字符串，请使用 "
":keyword:`in` 操作符::"

#: ../../library/stdtypes.rst:1737
msgid ""
">>> 'Py' in 'Python'\n"
"True"
msgstr ""
">>> 'Py' in 'Python'\n"
"True"

#: ../../library/stdtypes.rst:1743
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of"
" the corresponding argument."
msgstr ""
"执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 ``{}`` 括起来的替换域。 "
"每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。"

#: ../../library/stdtypes.rst:1753
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options"
" that can be specified in format strings."
msgstr "请参阅 :ref:`formatstrings` 了解有关可以在格式字符串中指定的各种格式选项的说明。"

#: ../../library/stdtypes.rst:1757
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, "
":class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: "
"``'{:n}'.format(1234)``), the function temporarily sets the ``LC_CTYPE`` "
"locale to the ``LC_NUMERIC`` locale to decode ``decimal_point`` and "
"``thousands_sep`` fields of :c:func:`localeconv` if they are non-ASCII or "
"longer than 1 byte, and the ``LC_NUMERIC`` locale is different than the "
"``LC_CTYPE`` locale.  This temporary change affects other threads."
msgstr ""
"当使用 ``n`` 类型 (例如: ``'{:n}'.format(1234)``) 来格式化数字 (:class:`int`, "
":class:`float`, :class:`complex`, :class:`decimal.Decimal` 及其子类) "
"的时候，该函数会临时性地将 ``LC_CTYPE`` 区域设置为 ``LC_NUMERIC`` 区域以解码  :c:func:`localeconv` "
"的 ``decimal_point`` 和 ``thousands_sep`` 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 "
"``LC_NUMERIC`` 区域会与 ``LC_CTYPE`` 区域不一致。 这个临时更改会影响其他线程。"

#: ../../library/stdtypes.rst:1766
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"当使用 ``n`` 类型格式化数字时，该函数在某些情况下会临时性地将 ``LC_CTYPE`` 区域设置为 ``LC_NUMERIC`` 区域。"

#: ../../library/stdtypes.rst:1774
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"类似于 ``str.format(**mapping)``，不同之处在于 ``mapping`` 会被直接使用而不是复制到一个 "
":class:`dict`。 适宜使用此方法的一个例子是当 ``mapping`` 为 dict 的子类的情况："

#: ../../library/stdtypes.rst:1790
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr "类似于 :meth:`~str.find`，但在找不到子字符串时会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1796
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, "
"``c.isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 ``True`` ， 否则返回 ``False`` 。 如果 "
"``c.isalpha()`` ， ``c.isdecimal()`` ， ``c.isdigit()`` ，或 ``c.isnumeric()`` "
"之中有一个返回 ``True`` ，则字符 ``c`` 是字母或数字。"

#: ../../library/stdtypes.rst:1804
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", "
"i.e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic"
" property defined in the section 4.10 'Letters, Alphabetic, and Ideographic'"
" of the Unicode Standard "
"<https://www.unicode.org/versions/Unicode15.1.0/ch04.pdf>`_."
msgstr ""
"如果字符串中的所有字符都为字母类并且至少有一个字符则返回 ``True``，否则返回 ``False``。 字母类字符是指在 Unicode "
"字符数据库中被定义为 \"Letter\" 的字符，即通用类别属性为 \"Lm\", \"Lt\", \"Lu\", \"Ll\" 或 \"Lo\" "
"之一的字符。 请注意这不同于 `在 Unicode 标准 4.10 节 'Letters, Alphabetic, and Ideographic' "
"中定义的 Alphabetic 属性  "
"<https://www.unicode.org/versions/Unicode15.1.0/ch04.pdf>`_。"

#: ../../library/stdtypes.rst:1815
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"如果字符串为空或字符串中的所有字符都是 ASCII ，返回 ``True`` ，否则返回 ``False`` 。ASCII 字符的码点范围是 "
"U+0000-U+007F 。"

#: ../../library/stdtypes.rst:1824
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are"
" those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-"
"INDIC DIGIT ZERO.  Formally a decimal character is a character in the "
"Unicode General Category \"Nd\"."
msgstr ""
"如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 ``True`` ， 否则返回 ``False`` "
"。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 "
"\"Nd\" 中的一个字符。"

#: ../../library/stdtypes.rst:1834
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters"
" and digits that need special handling, such as the compatibility "
"superscript digits. This covers digits which cannot be used to form numbers "
"in base 10, like the Kharosthi numbers.  Formally, a digit is a character "
"that has the property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"如果字符串中的所有字符都是数字，并且至少有一个字符，返回 ``True`` ，否则返回 ``False`` 。 "
"数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 "
"严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。"

#: ../../library/stdtypes.rst:1844
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr "如果字符串是有效的标识符，返回 ``True`` ，依据语言定义， :ref:`identifiers` 节。"

#: ../../library/stdtypes.rst:1847
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
":func:`keyword.iskeyword` 可被用来测试字符串 ``s`` 是否为保留的标识符，如 :keyword:`def` 和 "
":keyword:`class`。"

#: ../../library/stdtypes.rst:1850
msgid "Example: ::"
msgstr "示例： ::"

#: ../../library/stdtypes.rst:1853
msgid ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"
msgstr ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"

#: ../../library/stdtypes.rst:1863
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and"
" there is at least one cased character, ``False`` otherwise."
msgstr "如果字符串中至少有一个区分大小写的字符 [4]_ 且此类字符均为小写则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/stdtypes.rst:1869
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"如果字符串中至少有一个字符且所有字符均为数值字符则返回 ``True`` ，否则返回 ``False`` 。 数值字符包括数字字符，以及所有在 "
"Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 "
"正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 "
"Numeric_Type=Numeric 的字符。"

#: ../../library/stdtypes.rst:1879
msgid ""
"Return ``True`` if all characters in the string are printable, ``False`` if "
"it contains at least one non-printable character."
msgstr "如果字符串中的所有字符均为可打印字符则返回 ``True``，如果包含至少一个不可打印字符则返回 ``False``。"

#: ../../library/stdtypes.rst:1882
msgid ""
"Here \"printable\" means the character is suitable for :func:`repr` to use "
"in its output; \"non-printable\" means that :func:`repr` on built-in types "
"will hex-escape the character.  It has no bearing on the handling of strings"
" written to :data:`sys.stdout` or :data:`sys.stderr`."
msgstr ""
"这里的“可打印”是指字符适用于在其输出中 :func:`repr` 中；“不可打印”则意味着内置类型的 :func:`repr` "
"将以十六进制转义代码表示该字符。 它不会影响对写入到 :data:`sys.stdout` 或 :data:`sys.stderr` 的字符串的处理。"

#: ../../library/stdtypes.rst:1887
msgid ""
"The printable characters are those which in the Unicode character database "
"(see :mod:`unicodedata`) have a general category in group Letter, Mark, "
"Number, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space "
"0x20. Nonprintable characters are those in group Separator or Other (Z or "
"C), except the ASCII space."
msgstr ""
"可打印字符就是在 Unicode 字符数据库 (参见 :mod:`unicodedata`) 中分组为主类别 Letter, Mark, Number,"
" Punctuation 或 Symbol (L, M, N, P 或 S) 的字符；加上 ASCII 空格符 0x20。 不可打印字符就是分组为 "
"Separator 或 Other (Z 或 C) 的字符，ASCII 空格符除外。"

#: ../../library/stdtypes.rst:1896
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr "如果字符串中只有空白字符且至少有一个字符则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/stdtypes.rst:1899
msgid ""
"A character is *whitespace* if in the Unicode character database (see "
":mod:`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"*空白* 字符是指在 Unicode 字符数据库 (参见 :mod:`unicodedata`) 中主要类别为 ``Zs`` (\"Separator,"
" space\") 或所属双向类为 ``WS``, ``B`` 或 ``S`` 的字符。"

#: ../../library/stdtypes.rst:1907
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"如果字符串中至少有一个字符且为标题字符串则返回 ``True`` ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 "
"``False`` 。"

#: ../../library/stdtypes.rst:1914
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and"
" there is at least one cased character, ``False`` otherwise."
msgstr "如果字符串中至少有一个区分大小写的字符 [4]_ 且此类字符均为大写则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/stdtypes.rst:1932
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A "
":exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"返回一个由 *iterable* 中的字符串拼接而成的字符串。 如果 *iterable* 中存在任何非字符串值包括 :class:`bytes` "
"对象则会引发 :exc:`TypeError`。 调用该方法的字符串将作为元素之间的分隔。"

#: ../../library/stdtypes.rst:1940
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"返回长度为 *width* 的字符串，原字符串在其中靠左对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 "
"*width* 小于等于 ``len(s)`` 则返回原字符串的副本。"

#: ../../library/stdtypes.rst:1947
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr "返回原字符串的副本，其所有区分大小写的字符 [4]_ 均转换为小写。"

#: ../../library/stdtypes.rst:1950
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__."
msgstr ""
"所使用的小写算法 `在 Unicode 标准 3.13 节 'Default Case Folding' 中描述 "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__。"

#: ../../library/stdtypes.rst:1957
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values"
" are stripped::"
msgstr ""
"返回原字符串的副本，移除其中的前导字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 ``None``，则 *chars* "
"参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:1962
msgid ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"
msgstr ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"

#: ../../library/stdtypes.rst:1967
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr "参见 :meth:`str.removeprefix` ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:"

#: ../../library/stdtypes.rst:1970
msgid ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"
msgstr ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"

#: ../../library/stdtypes.rst:1978
msgid ""
"This static method returns a translation table usable for "
":meth:`str.translate`."
msgstr "此静态方法返回一个可供 :meth:`str.translate` 使用的转换对照表。"

#: ../../library/stdtypes.rst:1980
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals,"
" strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode "
"码位序号、（任意长度的）字符串或 ``None`` 的字典。 字符键将会被转换为码位序号。"

#: ../../library/stdtypes.rst:1985
msgid ""
"If there are two arguments, they must be strings of equal length, and in the"
" resulting dictionary, each character in x will be mapped to the character "
"at the same position in y.  If there is a third argument, it must be a "
"string, whose characters will be mapped to ``None`` in the result."
msgstr ""
"如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 "
"如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 ``None``。"

#: ../../library/stdtypes.rst:1993
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"在 *sep* 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 "
"3 元组中包含字符本身以及两个空字符串。"

#: ../../library/stdtypes.rst:2001
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr "如果字符串以 *prefix* 字符串开头，返回 ``string[len(prefix):]``。 否则，返回原始字符串的副本："

#: ../../library/stdtypes.rst:2005
msgid ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"
msgstr ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"

#: ../../library/stdtypes.rst:2015
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"如果字符串以 *suffix* 字符串结尾，并且 *suffix* 非空，返回 ``string[:-len(suffix)]``。 "
"否则，返回原始字符串的副本::"

#: ../../library/stdtypes.rst:2019
msgid ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"
msgstr ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"

#: ../../library/stdtypes.rst:2029
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced"
" by *new*.  If *count* is given, only the first *count* occurrences are "
"replaced. If *count* is not specified or ``-1``, then all occurrences are "
"replaced."
msgstr ""
"返回字符串的副本，其中出现的所有子字符串 *old* 都将被替换为 *new*。 如果给出了 *count*，则只替换前 *count* 次出现。 如果"
" *count* 未指定或为 ``-1``，则全部替换。"

#: ../../library/stdtypes.rst:2033
msgid "*count* is now supported as a keyword argument."
msgstr "现在可支持 *count* 关键字参数。"

#: ../../library/stdtypes.rst:2039
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start*"
" and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"返回子字符串 *sub* 在字符串内被找到的最大（最右）索引，这样 *sub* 将包含在 ``s[start:end]`` 当中。 可选参数 "
"*start* 与 *end* 会被解读为切片表示法。 如果未找到则返回 ``-1``。"

#: ../../library/stdtypes.rst:2046
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr "类似于 :meth:`rfind`，但在子字符串 *sub* 未找到时会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:2052
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"返回长度为 *width* 的字符串，原字符串在其中靠右对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 "
"*width* 小于等于 ``len(s)`` 则返回原字符串的副本。"

#: ../../library/stdtypes.rst:2059
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"在 *sep* 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 "
"如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。"

#: ../../library/stdtypes.rst:2067
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 "
"*最右边* 开始。 如果 *sep* 未指定或为 ``None``，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，:meth:`rsplit` "
"的其他行为都类似于下文所述的 :meth:`split`。"

#: ../../library/stdtypes.rst:2076
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values"
" are stripped::"
msgstr ""
"返回原字符串的副本，移除其中的末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 ``None``，则 *chars* "
"参数默认移除空白符。 实际上 *chars* 参数并非指定单个后缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:2081
msgid ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"
msgstr ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"

#: ../../library/stdtypes.rst:2086
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr "要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 :meth:`str.removesuffix` 方法。 例如:"

#: ../../library/stdtypes.rst:2089
msgid ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"
msgstr ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"

#: ../../library/stdtypes.rst:2096
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* "
"次拆分（因此，列表最多会有 ``maxsplit+1`` 个元素）。 如果 *maxsplit* 未指定或为 "
"``-1``，则不限制拆分次数（进行所有可能的拆分）。"

#: ../../library/stdtypes.rst:2102
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"as a single delimiter (to split with multiple delimiters, use "
":func:`re.split`). Splitting an empty string with a specified separator "
"returns ``['']``."
msgstr ""
"如果给出了 *sep*，则连续的分隔符不会被组合在一起而是会被视为分隔空字符串 (例如 ``'1,,2'.split(',')`` 将返回 "
"``['1', '', '2']``)。 *sep* 参数可能是由多个字符组成的单个分隔符 (要使用多个分隔符进行拆分，请使用 "
":func:`re.split`)。 使用指定的分隔符拆分一个空字符串将返回 ``['']``。"

#: ../../library/stdtypes.rst:2109 ../../library/stdtypes.rst:2127
#: ../../library/stdtypes.rst:2139 ../../library/stdtypes.rst:2191
#: ../../library/stdtypes.rst:2259 ../../library/stdtypes.rst:2327
#: ../../library/stdtypes.rst:3319 ../../library/stdtypes.rst:3337
#: ../../library/stdtypes.rst:3428 ../../library/stdtypes.rst:3444
#: ../../library/stdtypes.rst:3469 ../../library/stdtypes.rst:3483
#: ../../library/stdtypes.rst:3511 ../../library/stdtypes.rst:3525
#: ../../library/stdtypes.rst:3543 ../../library/stdtypes.rst:3570
#: ../../library/stdtypes.rst:3593 ../../library/stdtypes.rst:3620
#: ../../library/stdtypes.rst:3662 ../../library/stdtypes.rst:3686
msgid "For example::"
msgstr "例如："

#: ../../library/stdtypes.rst:2111
msgid ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"
msgstr ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"

#: ../../library/stdtypes.rst:2120
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive whitespace are regarded as a single separator,"
" and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty"
" string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"如果 *sep* 未指定或为 "
"``None``，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 "
"因此，使用 ``None`` 拆分空字符串或仅包含空格的字符串将返回 ``[]``。"

#: ../../library/stdtypes.rst:2129
msgid ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"
msgstr ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"

#: ../../library/stdtypes.rst:2136
msgid ""
"If *sep* is not specified or is ``None`` and  *maxsplit* is ``0``, only "
"leading runs of consecutive whitespace are considered."
msgstr "如果 *sep* 未指定或为 ``None`` 且  *maxsplit* 为 ``0``，则只有开头的连连续空格会被纳入考虑。"

#: ../../library/stdtypes.rst:2141
msgid ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \"   \".split(None, 0)\n"
"[]\n"
">>> \"   foo   \".split(maxsplit=0)\n"
"['foo   ']"
msgstr ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \"   \".split(None, 0)\n"
"[]\n"
">>> \"   foo   \".split(maxsplit=0)\n"
"['foo   ']"

#: ../../library/stdtypes.rst:2154
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line"
" breaks are not included in the resulting list unless *keepends* is given "
"and true."
msgstr "返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 *keepends* 且为真值。"

#: ../../library/stdtypes.rst:2158
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr "此方法会以下列行边界进行拆分。 特别地，行边界是 :term:`universal newlines` 的一个超集。"

#: ../../library/stdtypes.rst:2162
msgid "Representation"
msgstr "表示符"

#: ../../library/stdtypes.rst:2162
msgid "Description"
msgstr "描述"

#: ../../library/stdtypes.rst:2164
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2164
msgid "Line Feed"
msgstr "换行"

#: ../../library/stdtypes.rst:2166
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2166
msgid "Carriage Return"
msgstr "回车"

#: ../../library/stdtypes.rst:2168
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2168
msgid "Carriage Return + Line Feed"
msgstr "回车 + 换行"

#: ../../library/stdtypes.rst:2170
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` 或 ``\\x0b``"

#: ../../library/stdtypes.rst:2170
msgid "Line Tabulation"
msgstr "行制表符"

#: ../../library/stdtypes.rst:2172
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` 或 ``\\x0c``"

#: ../../library/stdtypes.rst:2172
msgid "Form Feed"
msgstr "换表单"

#: ../../library/stdtypes.rst:2174
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2174
msgid "File Separator"
msgstr "文件分隔符"

#: ../../library/stdtypes.rst:2176
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2176
msgid "Group Separator"
msgstr "组分隔符"

#: ../../library/stdtypes.rst:2178
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2178
msgid "Record Separator"
msgstr "记录分隔符"

#: ../../library/stdtypes.rst:2180
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2180
msgid "Next Line (C1 Control Code)"
msgstr "下一行 (C1 控制码)"

#: ../../library/stdtypes.rst:2182
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2182
msgid "Line Separator"
msgstr "行分隔符"

#: ../../library/stdtypes.rst:2184
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2184
msgid "Paragraph Separator"
msgstr "段分隔符"

#: ../../library/stdtypes.rst:2189
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` 和 ``\\f`` 被添加到行边界列表"

#: ../../library/stdtypes.rst:2193
msgid ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"
msgstr ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"

#: ../../library/stdtypes.rst:2198
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""
"不同于 :meth:`~str.split`，当给出了分隔字符串 *sep* "
"时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行::"

#: ../../library/stdtypes.rst:2202
msgid ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"
msgstr ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"

#: ../../library/stdtypes.rst:2207
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "作为比较，``split('\\n')`` 的结果为::"

#: ../../library/stdtypes.rst:2209
msgid ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"
msgstr ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"

#: ../../library/stdtypes.rst:2217
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"如果字符串以指定的 *prefix* 开始则返回 ``True``，否则返回 ``False``。 *prefix* "
"也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。"

#: ../../library/stdtypes.rst:2225
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather,"
" all combinations of its values are stripped::"
msgstr ""
"返回原字符串的副本，移除其中的前导和末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 ``None``，则 *chars* "
"参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:2231
msgid ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"
msgstr ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"

#: ../../library/stdtypes.rst:2236
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from"
" the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"最外侧的前导和末尾 *chars* 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 *chars* 所指定字符集的字符时停止。 "
"类似的操作也将在结尾端发生。 例如::"

#: ../../library/stdtypes.rst:2242
msgid ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"
msgstr ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"

#: ../../library/stdtypes.rst:2249
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase"
" and vice versa. Note that it is not necessarily true that "
"``s.swapcase().swapcase() == s``."
msgstr ""
"返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 ``s.swapcase().swapcase() == s`` 并不一定为真值。"

#: ../../library/stdtypes.rst:2256
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr "返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。"

#: ../../library/stdtypes.rst:2261
msgid ""
">>> 'Hello world'.title()\n"
"'Hello World'"
msgstr ""
">>> 'Hello world'.title()\n"
"'Hello World'"

#: ../../library/stdtypes.rst:2264 ../../library/stdtypes.rst:3630
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it"
" means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr ""
"该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 "
"该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果::"

#: ../../library/stdtypes.rst:2269
msgid ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""

#: ../../library/stdtypes.rst:2272
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ":func:`string.capwords` 函数没有此问题，因为它只用空格来拆分单词。"

#: ../../library/stdtypes.rst:2275
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular"
" expressions::"
msgstr "作为替代，可以使用正则表达式来构造针对撇号的变通处理::"

#: ../../library/stdtypes.rst:2278
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""

#: ../../library/stdtypes.rst:2290
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or "
":term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table"
" object can do any of the following: return a Unicode ordinal or a string, "
"to map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个通过 :meth:`~object.__getitem__` "
"来实现索引操作的对象，通常为 :term:`mapping` 或 :term:`sequence`。 当以 Unicode "
"码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 码位序号或字符串，将字符映射为一个或多个其他字符；返回 "
"``None``，将字符从返回的字符串中删除；或引发 :exc:`LookupError` 异常，将字符映射为其自身。"

#: ../../library/stdtypes.rst:2299
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from "
"character-to-character mappings in different formats."
msgstr "你可以使用 :meth:`str.maketrans` 基于不同格式的字符到字符映射来创建一个转换映射表。"

#: ../../library/stdtypes.rst:2302
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr "另请参阅 :mod:`codecs` 模块以了解定制字符映射的更灵活方式。"

#: ../../library/stdtypes.rst:2308
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"返回原字符串的副本，其中所有区分大小写的字符 [4]_ 均转换为大写。 请注意如果 ``s`` 包含不区分大小写的字符或者如果结果字符的 Unicode"
" 类别不是 \"Lu\" (Letter, uppercase) 而是 \"Lt\" (Letter, titlecase) 则 "
"``s.upper().isupper()`` 有可能为 ``False``。"

#: ../../library/stdtypes.rst:2314
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__."
msgstr ""
"所使用的大写转换算法 `在 Unicode 标准的第 3.13 节 'Default Case Folding' 中描述 "
"<https://www.unicode.org/versions/Unicode15.1.0/ch03.pdf>`__。"

#: ../../library/stdtypes.rst:2321
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled"
" by inserting the padding *after* the sign character rather than before. The"
" original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"返回原字符串的副本，在左边填充 ASCII ``'0'`` 数码使其长度变为 *width*。 正负值前缀 (``'+'``/``'-'``) "
"的处理方式是在正负符号 *之后* 填充而非在之前。 如果 *width* 小于等于 ``len(s)`` 则返回原字符串的副本。"

#: ../../library/stdtypes.rst:2329
msgid ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"
msgstr ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"

#: ../../library/stdtypes.rst:2350
msgid "Formatted String Literals (f-strings)"
msgstr "格式化字符串字面值（f-字符串）"

#: ../../library/stdtypes.rst:2353
msgid ""
"The :keyword:`await` and :keyword:`async for` can be used in expressions "
"within f-strings."
msgstr ":keyword:`await` 和 :keyword:`async for` 可在 f-字符串内部的表达式中使用。"

#: ../../library/stdtypes.rst:2356
msgid "Added the debugging operator (``=``)"
msgstr "增加了调试运算符 (``=``)"

#: ../../library/stdtypes.rst:2358
msgid ""
"Many restrictions on expressions within f-strings have been removed. "
"Notably, nested strings, comments, and backslashes are now permitted."
msgstr "许多针对 f-字符串内部的表达式的限制已被移除。 例如，嵌套字符串、注释和反斜杠现在都是允许的。"

#: ../../library/stdtypes.rst:2362
msgid ""
"An :dfn:`f-string` (formally a :dfn:`formatted string literal`) is a string "
"literal that is prefixed with ``f`` or ``F``. This type of string literal "
"allows embedding arbitrary Python expressions within *replacement fields*, "
"which are delimited by curly brackets (``{}``). These expressions are "
"evaluated at runtime, similarly to :meth:`str.format`, and are converted "
"into regular :class:`str` objects. For example:"
msgstr ""
":dfn:`f-字符串` (正式名称为 :dfn:`格式化字符串字面值`) 是带有 ``f`` 或 ``F`` 前缀的字符串字面值。 "
"这种类型的字符串字面值允许将任意 Python 表达式嵌入到由花括号 (``{}``) 标记的 *替换字段* 内部。 这些表达式将在运行时被求值，这与 "
":meth:`str.format` 类似，并被转换为常规的 :class:`str` 对象。 例如："

#: ../../library/stdtypes.rst:2370
msgid ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"
msgstr ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"

#: ../../library/stdtypes.rst:2377
msgid "It is also possible to use a multi line f-string:"
msgstr "也可以使用包含多行的 f-字符串："

#: ../../library/stdtypes.rst:2379
msgid ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"
msgstr ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"

#: ../../library/stdtypes.rst:2385
msgid ""
"A single opening curly bracket, ``'{'``, marks a *replacement field* that "
"can contain any Python expression:"
msgstr "一个单独的左花括号，``'{'``，标记一个可包含任意 Python 表达式的 *替换字段*："

#: ../../library/stdtypes.rst:2388
msgid ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"
msgstr ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"

#: ../../library/stdtypes.rst:2394
msgid "To include a literal ``{`` or ``}``, use a double bracket:"
msgstr "要包括 ``{`` 或 ``}`` 字面值，请使用双花括号："

#: ../../library/stdtypes.rst:2396
msgid ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"
msgstr ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"

#: ../../library/stdtypes.rst:2402
msgid ""
"Functions can also be used, and :ref:`format specifiers <formatstrings>`:"
msgstr "还可以使用函数，以及 :ref:`格式说明符 <formatstrings>`:"

#: ../../library/stdtypes.rst:2404
msgid ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"
msgstr ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"

#: ../../library/stdtypes.rst:2410
msgid "Any non-string expression is converted using :func:`str`, by default:"
msgstr "在默认情况下，任何非字符串表达式都将使用 :func:`str` 来转换："

#: ../../library/stdtypes.rst:2412
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"

#: ../../library/stdtypes.rst:2418
msgid ""
"To use an explicit conversion, use the ``!`` (exclamation mark) operator, "
"followed by any of the valid formats, which are:"
msgstr "要使用显式转换，请使用 ``!`` (叹号) 运算符，后面跟任意的有效格式说明符，包括："

#: ../../library/stdtypes.rst:2422 ../../library/stdtypes.rst:2590
#: ../../library/stdtypes.rst:3809
msgid "Conversion"
msgstr "转换符"

#: ../../library/stdtypes.rst:2424
msgid "``!a``"
msgstr "``!a``"

#: ../../library/stdtypes.rst:2424
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/stdtypes.rst:2425
msgid "``!r``"
msgstr "``!r``"

#: ../../library/stdtypes.rst:2425
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/stdtypes.rst:2426
msgid "``!s``"
msgstr "``!s``"

#: ../../library/stdtypes.rst:2426
msgid ":func:`str`"
msgstr ":func:`str`"

#: ../../library/stdtypes.rst:2429
msgid "For example:"
msgstr "例如:"

#: ../../library/stdtypes.rst:2431
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"

#: ../../library/stdtypes.rst:2442
msgid ""
"While debugging it may be helpful to see both the expression and its value, "
"by using the equals sign (``=``) after the expression. This preserves spaces"
" within the brackets, and can be used with a converter. By default, the "
"debugging operator uses the :func:`repr` (``!r``) conversion. For example:"
msgstr ""
"在调试期间同时看到表达式和值会很有帮助，具体是在表达式后使用等号 (``=``)。 这将保留花括号内部的空格，并可以使用转换器。 "
"在默认情况下，调试运算符使用 :func:`repr` (``!r``) 转换器。 例如："

#: ../../library/stdtypes.rst:2448
msgid ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"

#: ../../library/stdtypes.rst:2459
msgid ""
"Once the output has been evaluated, it can be formatted using a :ref:`format"
" specifier <formatstrings>` following a colon (``':'``). After the "
"expression has been evaluated, and possibly converted to a string, the "
":meth:`!__format__` method of the result is called with the format "
"specifier, or the empty string if no format specifier is given. The "
"formatted result is then used as the final value for the replacement field. "
"For example:"
msgstr ""
"输出一旦已被求值，就可以用 :ref:`格式说明符 <formatstrings>` 后面跟一个冒号 (``':'``) 来格式化它。 "
"在表达式已被求值，并可能被转换为字符串之后，就会调用结果的 :meth:`!__format__` "
"方法并附带该格式说明符，或者如果未给出格式说明符则附带空字符串。 随后将使用已格式化的结果作为替换字段最终的值。 例如："

#: ../../library/stdtypes.rst:2467
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"

#: ../../library/stdtypes.rst:2479
msgid "``printf``-style String Formatting"
msgstr "``printf`` 风格的字符串格式化"

#: ../../library/stdtypes.rst:2492
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals "
"<f-strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives"
" provides their own trade-offs and benefits of simplicity, flexibility, "
"and/or extensibility."
msgstr ""
"此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 :ref:`格式化字符串字面值 "
"<f-strings>`，:meth:`str.format` 接口或 :ref:`模板字符串 <template-strings>` "
"有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。"

#: ../../library/stdtypes.rst:2500
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"function in the C language. For example:"
msgstr ""
"字符串具有一种特殊的内置操作即 ``%`` (求模) 运算符。 这也被称为字符串的 *格式化* 或 *插值* 运算符。 对于给定的 ``format %"
" values`` (其中 *format* 是一个字符串)，在 *format* 中的 ``%`` 转换标记符将被替换为零个或多个 *values* "
"中的元素。 其效果类似于在 C 语言中使用 :c:func:`sprintf` 函数。 例如："

#: ../../library/stdtypes.rst:2507
msgid ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."
msgstr ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."

#: ../../library/stdtypes.rst:2512
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"如果 *format* 要求一个单独参数，则 *values* 可以为一个非元组对象。 [5]_  否则的话，*values* "
"必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。"

#: ../../library/stdtypes.rst:2522 ../../library/stdtypes.rst:3741
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr "转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序："

#: ../../library/stdtypes.rst:2525 ../../library/stdtypes.rst:3744
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "``'%'`` 字符，用于标记转换符的起始。"

#: ../../library/stdtypes.rst:2527 ../../library/stdtypes.rst:3746
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters"
" (for example, ``(somename)``)."
msgstr "映射键（可选），由加圆括号的字符序列组成 (例如 ``(somename)``)。"

#: ../../library/stdtypes.rst:2530 ../../library/stdtypes.rst:3749
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "转换旗标（可选），用于影响某些转换类型的结果。"

#: ../../library/stdtypes.rst:2533 ../../library/stdtypes.rst:3752
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the"
" object to convert comes after the minimum field width and optional "
"precision."
msgstr ""
"最小字段宽度（可选）。 如果指定为 ``'*'`` (星号)，则实际宽度会从 *values* "
"元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。"

#: ../../library/stdtypes.rst:2537 ../../library/stdtypes.rst:3756
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the"
" next element of the tuple in *values*, and the value to convert comes after"
" the precision."
msgstr ""
"精度（可选），以在 ``'.'`` (点号) 之后加精度值的形式给出。 如果指定为 ``'*'`` (星号)，则实际精度会从 *values* "
"元组的下一元素中读取，要转换的对象则为精度之后的元素。"

#: ../../library/stdtypes.rst:2542 ../../library/stdtypes.rst:3761
msgid "Length modifier (optional)."
msgstr "长度修饰符（可选）。"

#: ../../library/stdtypes.rst:2544 ../../library/stdtypes.rst:3763
msgid "Conversion type."
msgstr "转换类型。"

#: ../../library/stdtypes.rst:2546
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key"
" selects the value to be formatted from the mapping.  For example:"
msgstr ""
"当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 *必须* 包含加圆括号的映射键，对应 ``'%'`` 字符之后字典中的每一项。 "
"映射键将从映射中选取要格式化的值。 例如："

#: ../../library/stdtypes.rst:2555 ../../library/stdtypes.rst:3774
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a"
" sequential parameter list)."
msgstr "在此情况下格式中不能出现 ``*`` 标记符（因其需要一个序列类的参数列表）。"

#: ../../library/stdtypes.rst:2558 ../../library/stdtypes.rst:3777
msgid "The conversion flag characters are:"
msgstr "转换旗标为："

#: ../../library/stdtypes.rst:2567 ../../library/stdtypes.rst:3786
msgid "Flag"
msgstr "旗标"

#: ../../library/stdtypes.rst:2569 ../../library/stdtypes.rst:3788
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2569 ../../library/stdtypes.rst:3788
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "值的转换将使用“替代形式”（具体定义见下文）。"

#: ../../library/stdtypes.rst:2572 ../../library/stdtypes.rst:3791
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2572 ../../library/stdtypes.rst:3791
msgid "The conversion will be zero padded for numeric values."
msgstr "转换将为数字值填充零字符。"

#: ../../library/stdtypes.rst:2574 ../../library/stdtypes.rst:3793
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2574 ../../library/stdtypes.rst:3793
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr "转换值将靠左对齐（如果同时给出 ``'0'`` 转换，则会覆盖后者）。"

#: ../../library/stdtypes.rst:2577 ../../library/stdtypes.rst:3796
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2577 ../../library/stdtypes.rst:3796
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr "(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。"

#: ../../library/stdtypes.rst:2580 ../../library/stdtypes.rst:3799
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2580 ../../library/stdtypes.rst:3799
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides"
" a \"space\" flag)."
msgstr "符号字符 (``'+'`` 或 ``'-'``) 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。"

#: ../../library/stdtypes.rst:2584 ../../library/stdtypes.rst:3803
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as"
" it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"可以给出长度修饰符 (``h``, ``l`` 或 ``L``)，但会被忽略，因为对 Python 来说没有必要 -- 所以 ``%ld`` 等价于 "
"``%d``。"

#: ../../library/stdtypes.rst:2587 ../../library/stdtypes.rst:3806
msgid "The conversion types are:"
msgstr "转换类型为："

#: ../../library/stdtypes.rst:2592 ../../library/stdtypes.rst:3811
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2592 ../../library/stdtypes.rst:2594
#: ../../library/stdtypes.rst:3811 ../../library/stdtypes.rst:3813
msgid "Signed integer decimal."
msgstr "有符号十进制整数。"

#: ../../library/stdtypes.rst:2594 ../../library/stdtypes.rst:3813
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2596 ../../library/stdtypes.rst:3815
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2596 ../../library/stdtypes.rst:3815
msgid "Signed octal value."
msgstr "有符号八进制数。"

#: ../../library/stdtypes.rst:2598 ../../library/stdtypes.rst:3817
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2598 ../../library/stdtypes.rst:3817
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "过时类型 -- 等价于 ``'d'``。"

#: ../../library/stdtypes.rst:2600 ../../library/stdtypes.rst:3819
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2600 ../../library/stdtypes.rst:3819
msgid "Signed hexadecimal (lowercase)."
msgstr "有符号十六进制数（小写）。"

#: ../../library/stdtypes.rst:2602 ../../library/stdtypes.rst:3821
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2602 ../../library/stdtypes.rst:3821
msgid "Signed hexadecimal (uppercase)."
msgstr "有符号十六进制数（大写）。"

#: ../../library/stdtypes.rst:2604 ../../library/stdtypes.rst:3823
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2604 ../../library/stdtypes.rst:3823
msgid "Floating-point exponential format (lowercase)."
msgstr "浮点指数格式（小写）。"

#: ../../library/stdtypes.rst:2606 ../../library/stdtypes.rst:3825
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2606 ../../library/stdtypes.rst:3825
msgid "Floating-point exponential format (uppercase)."
msgstr "浮点指数格式（大写）。"

#: ../../library/stdtypes.rst:2608 ../../library/stdtypes.rst:3827
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2608 ../../library/stdtypes.rst:2610
#: ../../library/stdtypes.rst:3827 ../../library/stdtypes.rst:3829
msgid "Floating-point decimal format."
msgstr "浮点十进制格式。"

#: ../../library/stdtypes.rst:2610 ../../library/stdtypes.rst:3829
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2612 ../../library/stdtypes.rst:3831
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2612 ../../library/stdtypes.rst:3831
msgid ""
"Floating-point format. Uses lowercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。"

#: ../../library/stdtypes.rst:2616 ../../library/stdtypes.rst:3835
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2616 ../../library/stdtypes.rst:3835
msgid ""
"Floating-point format. Uses uppercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。"

#: ../../library/stdtypes.rst:2620 ../../library/stdtypes.rst:3839
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2620
msgid "Single character (accepts integer or single character string)."
msgstr "单个字符（接受整数或单个字符的字符串）。"

#: ../../library/stdtypes.rst:2623 ../../library/stdtypes.rst:3852
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2623
msgid "String (converts any Python object using :func:`repr`)."
msgstr "字符串（使用 :func:`repr` 转换任何 Python 对象）。"

#: ../../library/stdtypes.rst:2626 ../../library/stdtypes.rst:3846
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2626
msgid "String (converts any Python object using :func:`str`)."
msgstr "字符串（使用 :func:`str` 转换任何 Python 对象）。"

#: ../../library/stdtypes.rst:2629 ../../library/stdtypes.rst:3849
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2629
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "字符串（使用 :func:`ascii` 转换任何 Python 对象）。"

#: ../../library/stdtypes.rst:2632 ../../library/stdtypes.rst:3855
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2632 ../../library/stdtypes.rst:3855
msgid ""
"No argument is converted, results in a ``'%'`` character in the result."
msgstr "不转换参数，在结果中输出一个 ``'%'`` 字符。"

#: ../../library/stdtypes.rst:2639 ../../library/stdtypes.rst:3862
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr "此替代形式会在第一个数码之前插入标示八进制数的前缀 (``'0o'``)。"

#: ../../library/stdtypes.rst:2643 ../../library/stdtypes.rst:3866
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"此替代形式会在第一个数码之前插入 ``'0x'`` 或 ``'0X'`` 前缀（取决于是使用 ``'x'`` 还是 ``'X'`` 格式）。"

#: ../../library/stdtypes.rst:2647 ../../library/stdtypes.rst:3870
msgid ""
"The alternate form causes the result to always contain a decimal point, even"
" if no digits follow it."
msgstr "此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。"

#: ../../library/stdtypes.rst:2650 ../../library/stdtypes.rst:3873
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "小数点后的数码位数由精度决定，默认为 6。"

#: ../../library/stdtypes.rst:2654 ../../library/stdtypes.rst:3877
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr "此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。"

#: ../../library/stdtypes.rst:2657 ../../library/stdtypes.rst:3880
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "小数点前后的有效数码位数由精度决定，默认为 6。"

#: ../../library/stdtypes.rst:2661 ../../library/stdtypes.rst:3884
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "如果精度为 ``N``，输出将截短为 ``N`` 个字符。"

#: ../../library/stdtypes.rst:2664 ../../library/stdtypes.rst:3893
msgid "See :pep:`237`."
msgstr "参见 :pep:`237`。"

#: ../../library/stdtypes.rst:2666
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr "由于 Python 字符串显式指明长度，``%s`` 转换不会将 ``'\\0'`` 视为字符串的结束。"

#: ../../library/stdtypes.rst:2671
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr "绝对值超过 1e50 的 ``%f`` 转换不会再被替换为 ``%g`` 转换。"

#: ../../library/stdtypes.rst:2682
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, "
":class:`memoryview`"
msgstr "二进制序列类型 --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"

#: ../../library/stdtypes.rst:2690
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and "
":class:`bytearray`. They are supported by :class:`memoryview` which uses the"
" :ref:`buffer protocol <bufferobjects>` to access the memory of other binary"
" objects without needing to make a copy."
msgstr ""
"操作二进制数据的核心内置类型是 :class:`bytes` 和 :class:`bytearray`。 它们由 :class:`memoryview`"
" 提供支持，该对象使用 :ref:`缓冲区协议 <bufferobjects>` 来访问其他二进制对象所在内存，不需要创建对象的副本。"

#: ../../library/stdtypes.rst:2695
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ":mod:`array` 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。"

#: ../../library/stdtypes.rst:2701
msgid "Bytes Objects"
msgstr "bytes 对象"

#: ../../library/stdtypes.rst:2705
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII"
" 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。"

#: ../../library/stdtypes.rst:2712
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr "首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 ``b`` 前缀："

#: ../../library/stdtypes.rst:2715
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "单引号: ``b'同样允许嵌入 \"双\" 引号'``。"

#: ../../library/stdtypes.rst:2716
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "双引号: ``b\"仍然允许嵌入 '单' 引号\"``"

#: ../../library/stdtypes.rst:2717
msgid "Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr "三重引号: ``b'''三重单引号'''``, ``b\"\"\"三重双引号\"\"\"``"

#: ../../library/stdtypes.rst:2719
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码格式为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes "
"字面值。"

#: ../../library/stdtypes.rst:2723
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"像字符串字面值一样，bytes 字面值也可以使用 ``r`` 前缀来禁用转义序列处理。 请参阅 :ref:`strings` 了解有关各种 bytes "
"字面值形式的详情，包括所支持的转义序列。"

#: ../../library/stdtypes.rst:2727
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based"
" elements and can be usefully manipulated with some text-oriented "
"algorithms, this is not generally the case for arbitrary binary data "
"(blindly applying text processing algorithms to binary data formats that are"
" not ASCII compatible will usually lead to data corruption)."
msgstr ""
"虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 ``0"
" <= x < 256`` (如果违反此限制将引发 :exc:`ValueError`)。 "
"这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII "
"的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII "
"的二进制数据格式往往将导致数据损坏）。"

#: ../../library/stdtypes.rst:2737
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr "除了字面值形式，bytes 对象还可以通过其他几种方式来创建："

#: ../../library/stdtypes.rst:2740
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "指定长度的以零值填充的 bytes 对象: ``bytes(10)``"

#: ../../library/stdtypes.rst:2741
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "通过由整数组成的可迭代对象: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2742
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr "通过缓冲区协议复制现有的二进制数据:  ``bytes(obj)``"

#: ../../library/stdtypes.rst:2744
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "另请参阅 :ref:`bytes <func-bytes>` 内置类型。"

#: ../../library/stdtypes.rst:2746
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法："

#: ../../library/stdtypes.rst:2752
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"此 :class:`bytes` 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII"
" 空白符会被忽略。"

#: ../../library/stdtypes.rst:2759
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just"
" spaces."
msgstr ":meth:`bytes.fromhex` 现在会忽略所有 ASCII 空白符而不只是空格符。"

#: ../../library/stdtypes.rst:2763
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr "存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。"

#: ../../library/stdtypes.rst:2768 ../../library/stdtypes.rst:2853
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr "返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。"

#: ../../library/stdtypes.rst:2774
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 *sep* 形参包含于输出中。 默认情况下，该分隔符会放在每个字节之间。 第二个可选的"
" *bytes_per_sep* 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。"

#: ../../library/stdtypes.rst:2791
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters"
" to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` 现在支持可选的 *sep* 和 *bytes_per_sep* 形参以在十六进制输出的字节之间插入分隔符。"

#: ../../library/stdtypes.rst:2795
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes"
" object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 *b*，``b[0]`` 将为一个整数，而 ``b[0:1]``"
" 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。"

#: ../../library/stdtypes.rst:2800
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"bytes 对象的表示使用字面值格式 (``b'...'``)，因为它通常都要比像 ``bytes([46, 46, 46])`` 这样的格式更好用。 "
"你总是可以使用 ``list(b)`` 将 bytes 对象转换为一个由整数构成的列表。"

#: ../../library/stdtypes.rst:2808
msgid "Bytearray Objects"
msgstr "bytearray 对象"

#: ../../library/stdtypes.rst:2812
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ":class:`bytearray` 对象是 :class:`bytes` 对象的可变对应物。"

#: ../../library/stdtypes.rst:2817
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are"
" always created by calling the constructor:"
msgstr "bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建："

#: ../../library/stdtypes.rst:2820
msgid "Creating an empty instance: ``bytearray()``"
msgstr "创建一个空实例: ``bytearray()``"

#: ../../library/stdtypes.rst:2821
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "创建一个指定长度的以零值填充的实例: ``bytearray(10)``"

#: ../../library/stdtypes.rst:2822
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "通过由整数组成的可迭代对象: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:2823
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr "通过缓冲区协议复制现有的二进制数据:  ``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:2825
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"由于 bytearray 对象是可变的，该对象除了 :ref:`bytes-methods` 中所描述的 bytes 和 bytearray "
"共有操作之外，还支持 :ref:`可变 <typesseq-mutable>` 序列操作。"

#: ../../library/stdtypes.rst:2829
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "另请参见 :ref:`bytearray <func-bytearray>` 内置类型。"

#: ../../library/stdtypes.rst:2831
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法："

#: ../../library/stdtypes.rst:2837
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
":class:`bytearray` 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的"
" ASCII 空白符会被忽略。"

#: ../../library/stdtypes.rst:2844
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ":meth:`bytearray.fromhex` 现在会忽略所有 ASCII 空白符而不只是空格符。"

#: ../../library/stdtypes.rst:2848
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr "存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。"

#: ../../library/stdtypes.rst:2861
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"与 :meth:`bytes.hex` 相似， :meth:`bytearray.hex` 现在支持可选的 *sep* 和 "
"*bytes_per_sep* 参数以在十六进制输出的字节之间插入分隔符。"

#: ../../library/stdtypes.rst:2866
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 *b*，``b[0]`` 将为一个整数，而 "
"``b[0:1]`` 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。"

#: ../../library/stdtypes.rst:2871
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into"
" a list of integers using ``list(b)``."
msgstr ""
"bytearray 对象的表示使用 bytes 对象字面值格式 (``bytearray(b'...')``)，因为它通常都要比 "
"``bytearray([46, 46, 46])`` 这样的格式更好用。 你总是可以使用 ``list(b)`` 将 bytearray "
"对象转换为一个由整数构成的列表。"

#: ../../library/stdtypes.rst:2880
msgid "Bytes and Bytearray Operations"
msgstr "bytes 和 bytearray 操作"

#: ../../library/stdtypes.rst:2885
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>`"
" sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"bytes 和 bytearray 对象都支持 :ref:`通用 <typesseq-common>` 序列操作。 "
"它们不仅能与相同类型的操作数，也能与任何 :term:`bytes-like object` 进行互操作。 "
"由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。"

#: ../../library/stdtypes.rst:2893
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 "
"例如，你必须使用以下写法::"

#: ../../library/stdtypes.rst:2897
msgid ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"
msgstr ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"

#: ../../library/stdtypes.rst:2900
msgid "and::"
msgstr "和::"

#: ../../library/stdtypes.rst:2902
msgid ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"
msgstr ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"

#: ../../library/stdtypes.rst:2905
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。"

#: ../../library/stdtypes.rst:2910
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr "使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。"

#: ../../library/stdtypes.rst:2913
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr "bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。"

#: ../../library/stdtypes.rst:2919
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the"
" range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"返回子序列 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* 会被解读为切片表示法。"

#: ../../library/stdtypes.rst:2923 ../../library/stdtypes.rst:3028
#: ../../library/stdtypes.rst:3050 ../../library/stdtypes.rst:3116
#: ../../library/stdtypes.rst:3129
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr "要搜索的子序列可以是任意 :term:`bytes-like object` 或是 0 至 255 范围内的整数。"

#: ../../library/stdtypes.rst:2926
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr "如果 *sub* 为空，则返回字符之间的空切片的数量即字节串对象的长度加一。"

#: ../../library/stdtypes.rst:2929 ../../library/stdtypes.rst:3040
#: ../../library/stdtypes.rst:3053 ../../library/stdtypes.rst:3119
#: ../../library/stdtypes.rst:3132
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "也接受 0 至 255 范围内的整数作为子序列。"

#: ../../library/stdtypes.rst:2936
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr "如果二进制数据以 *prefix* 字符串开头，返回 ``bytes[len(prefix):]``。 否则，返回原始二进制数据的副本："

#: ../../library/stdtypes.rst:2940
msgid ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"
msgstr ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"

#: ../../library/stdtypes.rst:2945
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*prefix* 可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2949 ../../library/stdtypes.rst:2971
#: ../../library/stdtypes.rst:3104 ../../library/stdtypes.rst:3197
#: ../../library/stdtypes.rst:3211 ../../library/stdtypes.rst:3242
#: ../../library/stdtypes.rst:3256 ../../library/stdtypes.rst:3298
#: ../../library/stdtypes.rst:3369 ../../library/stdtypes.rst:3387
#: ../../library/stdtypes.rst:3415 ../../library/stdtypes.rst:3554
#: ../../library/stdtypes.rst:3609 ../../library/stdtypes.rst:3652
#: ../../library/stdtypes.rst:3673 ../../library/stdtypes.rst:3695
#: ../../library/stdtypes.rst:3897
msgid ""
"The bytearray version of this method does *not* operate in place - it always"
" produces a new object, even if no changes were made."
msgstr "此方法的 bytearray 版本 *并非* 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。"

#: ../../library/stdtypes.rst:2958
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"如果二进制数据以 *suffix* 字符串结尾，并且 *suffix* 非空，返回 ``bytes[:-len(suffix)]``。 "
"否则，返回原始二进制数据的副本::"

#: ../../library/stdtypes.rst:2962
msgid ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"
msgstr ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"

#: ../../library/stdtypes.rst:2967
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*suffix* 可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2980
msgid "Return the bytes decoded to a :class:`str`."
msgstr "返回解码为 :class:`str` 的字节串。"

#: ../../library/stdtypes.rst:2985
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via "
":func:`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* 控制如何处理编码错误。 如为 ``'strict'`` (默认值)，则会引发 :exc:`UnicodeError`。 其他可能的值有"
" ``'ignore'``, ``'replace'`` 以及通过 :func:`codecs.register_error` 注册的任何其他名称。 "
"请参阅 :ref:`error-handlers` 了解详情。"

#: ../../library/stdtypes.rst:2991
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a "
":ref:`debug build <debug-build>` is used."
msgstr ""
"出于性能原因，除非真正发生了编码错误，启用了 :ref:`devmode` 或使用了 :ref:`调试编译版 <debug-build>` 否则不会检查"
" *errors* 值的有效性。"

#: ../../library/stdtypes.rst:2997
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any "
":term:`bytes-like object` directly, without needing to make a temporary "
":class:`!bytes` or :class:`!bytearray` object."
msgstr ""
"将 *encoding* 参数传给 :class:`str` 允许直接解码任何 :term:`bytes-like object`，无须创建临时的 "
":class:`!bytes` 或 :class:`!bytearray` 对象。"

#: ../../library/stdtypes.rst:3012
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"如果二进制数据以指定的 *suffix* 结束则返回 ``True``，否则返回 ``False``。 *suffix* "
"也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。"

#: ../../library/stdtypes.rst:3017
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "要搜索的后缀可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3023
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"返回子序列 *sub* 在数据中被找到的最小索引，*sub* 包含于切片 ``s[start:end]`` 之内。 可选参数 *start* 与 "
"*end* 会被解读为切片表示法。 如果 *sub* 未被找到则返回 ``-1``。"

#: ../../library/stdtypes.rst:3033
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~bytes.find` 方法应该只在你需要知道 *sub* 所在位置时使用。 要检查 *sub* 是否为子串，请使用 "
":keyword:`in` 操作符::"

#: ../../library/stdtypes.rst:3037
msgid ""
">>> b'Py' in b'Python'\n"
"True"
msgstr ""
">>> b'Py' in b'Python'\n"
"True"

#: ../../library/stdtypes.rst:3047
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr "类似于 :meth:`~bytes.find`，但在找不到子序列时会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:3060
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"返回一个由 *iterable* 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 *iterable* 中存在任何非 "
":term:`字节类对象 <bytes-like object>` 包括存在 :class:`str` 对象值则会引发 "
":exc:`TypeError`。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。"

#: ../../library/stdtypes.rst:3071
msgid ""
"This static method returns a translation table usable for "
":meth:`bytes.translate` that will map each character in *from* into the "
"character at the same position in *to*; *from* and *to* must both be "
":term:`bytes-like objects <bytes-like object>` and have the same length."
msgstr ""
"此静态方法返回一个可用于 :meth:`bytes.translate` 的转换对照表，它将把 *from* 中的每个字符映射为 *to* "
"中相同位置上的字符；*from* 与 *to* 必须都是 :term:`字节类对象 <bytes-like object>` 并且具有相同的长度。"

#: ../../library/stdtypes.rst:3082
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed"
" by two empty bytes or bytearray objects."
msgstr ""
"在 *sep* 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 "
"如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。"

#: ../../library/stdtypes.rst:3089 ../../library/stdtypes.rst:3146
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "要搜索的分隔符可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3095
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"返回序列的副本，其中出现的所有子序列 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。"

#: ../../library/stdtypes.rst:3099
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr "要搜索的子序列及其替换序列可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3111
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"返回子序列 *sub* 在序列内被找到的最大（最右）索引，这样 *sub* 将包含在 ``s[start:end]`` 当中。 可选参数 *start*"
" 与 *end* 会被解读为切片表示法。 如果未找到则返回 ``-1``。"

#: ../../library/stdtypes.rst:3126
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr "类似于 :meth:`~bytes.rfind`，但在子序列 *sub* 未找到时会引发 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:3139
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"在 *sep* 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray "
"副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。"

#: ../../library/stdtypes.rst:3152
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"如果二进制数据以指定的 *prefix* 开头则返回 ``True``，否则返回 ``False``。 *prefix* "
"也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。"

#: ../../library/stdtypes.rst:3157
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "要搜索的前缀可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3163
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 *delete* 中出现的 bytes，其余 bytes "
"将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。"

#: ../../library/stdtypes.rst:3168
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation "
"table."
msgstr "你可以使用 :func:`bytes.maketrans` 方法来创建转换表。"

#: ../../library/stdtypes.rst:3171
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr "对于仅需移除字符的转换，请将 *table* 参数设为 ``None``::"

#: ../../library/stdtypes.rst:3174
msgid ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"
msgstr ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"

#: ../../library/stdtypes.rst:3177
msgid "*delete* is now supported as a keyword argument."
msgstr "现在支持将 *delete* 作为关键字参数。"

#: ../../library/stdtypes.rst:3181
msgid ""
"The following methods on bytes and bytearray objects have default behaviours"
" that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适当的参数仍然可用于任意二进制数据。 "
"请注意本小节中所有的 bytearray 方法都 *不是* 原地执行操作，而是会产生新的对象。"

#: ../../library/stdtypes.rst:3190
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"返回原对象的副本，在长度为 *width* 的序列内居中，使用指定的 *fillbyte* 填充两边的空位（默认使用 ASCII 空格符）。 对于 "
":class:`bytes` 对象，如果 *width* 小于等于 ``len(s)`` 则返回原序列的副本。"

#: ../../library/stdtypes.rst:3204
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"返回原对象的副本，在长度为 *width* 的序列中靠左对齐。 使用指定的 *fillbyte* 填充空位（默认使用 ASCII 空格符）。 对于 "
":class:`bytes` 对象，如果 *width* 小于等于 ``len(s)`` 则返回原序列的副本。"

#: ../../library/stdtypes.rst:3218
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"返回原序列的副本，移除指定的前导字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 "
"如果省略或为 ``None``，则 *chars* 参数默认移除 ASCII 空白符。 *chars* "
"参数并非指定单个前缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:3225
msgid ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"
msgstr ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"

#: ../../library/stdtypes.rst:3230
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"要移除的二进制序列可以是任意 :term:`bytes-like object` 。 要删除单个前缀字符串，而不是全部给定集合中的字符，请参见 "
":meth:`str.removeprefix` 方法。 例如:"

#: ../../library/stdtypes.rst:3235
msgid ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"
msgstr ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"

#: ../../library/stdtypes.rst:3249
msgid ""
"Return a copy of the object right justified in a sequence of length *width*."
" Padding is done using the specified *fillbyte* (default is an ASCII space)."
" For :class:`bytes` objects, the original sequence is returned if *width* is"
" less than or equal to ``len(s)``."
msgstr ""
"返回原对象的副本，在长度为 *width* 的序列中靠右对齐。 使用指定的 *fillbyte* 填充空位（默认使用 ASCII 空格符）。 对于 "
":class:`bytes` 对象，如果 *width* 小于等于 ``len(s)`` 则返回原序列的副本。"

#: ../../library/stdtypes.rst:3263
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are"
" done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for"
" splitting from the right, :meth:`rsplit` behaves like :meth:`split` which "
"is described in detail below."
msgstr ""
"将二进制序列拆分为相同类型的子序列，使用 *sep* 作为分隔符。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 "
"*最右边* 开始。 如果 *sep* 未指定或为 ``None``，任何只包含 ASCII 空白符的子序列都会被作为分隔符。 "
"除了从右边开始拆分，:meth:`rsplit` 的其他行为都类似于下文所述的 :meth:`split`。"

#: ../../library/stdtypes.rst:3274
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"返回原序列的副本，移除指定的末尾字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 "
"如果省略或为 ``None``，则 *chars* 参数默认移除 ASCII 空白符。 *chars* "
"参数并非指定单个后缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:3281
msgid ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"
msgstr ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"

#: ../../library/stdtypes.rst:3286
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"要移除的二进制序列可以是任意 :term:`bytes-like object` 。 要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 "
":meth:`str.removesuffix` 方法。 例如:"

#: ../../library/stdtypes.rst:3291
msgid ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"
msgstr ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"

#: ../../library/stdtypes.rst:3305
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"将二进制序列拆分为相同类型的子序列，使用 *sep* 作为分隔符。 如果给出了 *maxsplit* 且非负值，则最多进行 *maxsplit* "
"次拆分（因此，列表最多会有 ``maxsplit+1`` 个元素）。 如果 *maxsplit* 未指定或为 "
"``-1``，则不限制拆分次数（进行所有可能的拆分）。"

#: ../../library/stdtypes.rst:3311
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence as a single delimiter. Splitting an empty sequence with a"
" specified separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on "
"the type of object being split.  The *sep* argument may be any :term:`bytes-"
"like object`."
msgstr ""
"如果给出了 *sep*，则连续的分隔符不会被组合在一起而是会被视为分隔空子序列 (例如 ``b'1,,2'.split(b',')`` 将将返回 "
"``[b'1', b'', b'2']``)。 *sep* 参数可能是由多个序列组成的单个分隔符。 使用指定的分隔符拆分一个空序列将返回 "
"``[b'']`` 或 ``[bytearray(b'')]``，具体取决于被拆分对象的类型。 *sep* 参数可以是任何 :term:`bytes-"
"like object`。"

#: ../../library/stdtypes.rst:3321
msgid ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"
msgstr ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"

#: ../../library/stdtypes.rst:3330
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting"
" an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"如果 *sep* 未指定或为 ``None``，则会应用另一种拆分算法：连续的 ASCII "
"空白符会被视为单个分隔符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅包含 ASCII 空白符的序列进行拆分将返回 "
"``[]``。"

#: ../../library/stdtypes.rst:3340
msgid ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"
msgstr ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"

#: ../../library/stdtypes.rst:3351
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"返回原序列的副本，移除指定的开头和末尾字节。 *chars* 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII "
"字符。 如果省略或为 ``None``，则 *chars* 参数默认移除 ASCII 空白符。 *chars* "
"参数并非指定单个前缀或后缀；而是会移除参数值的所有组合::"

#: ../../library/stdtypes.rst:3359
msgid ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"
msgstr ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"

#: ../../library/stdtypes.rst:3364
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr "要移除的字节值二进制序列可以是任意 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3373
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII"
" compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进制数据。 请注意本小节中所有的 "
"bytearray 方法都 *不是* 原地执行操作，而是会产生新的对象。"

#: ../../library/stdtypes.rst:3381
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII"
" byte values are passed through unchanged."
msgstr ""
"返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大写而其余的小写。 非 ASCII 字节值将保持原样不变。"

#: ../../library/stdtypes.rst:3394
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by"
" one or more ASCII spaces, depending on the current column and the given tab"
" size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If"
" the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* "
"个字节设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。 "
"如果字节为 ASCII 制表符 (``b'\\t'``)，则并在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） "
"如果当前字节为 ASCII 换行符 (``b'\\n'``) 或回车符 (``b'\\r'``)，它会被复制并将当前列重设为零。 "
"任何其他字节会被不加修改地复制并将当前列加一，不论该字节值在被打印时会如何显示::"

#: ../../library/stdtypes.rst:3408
msgid ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"
msgstr ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"

#: ../../library/stdtypes.rst:3422
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence"
" ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 ``True`` ，否则返回 ``False`` 。 字母类"
" ASCII 字符就是字节值包含在序列 "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 中的字符。 ASCII "
"十进制数码就是字节值包含在序列 ``b'0123456789'`` 中的字符。"

#: ../../library/stdtypes.rst:3430
msgid ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"
msgstr ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"

#: ../../library/stdtypes.rst:3439
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters"
" and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 ``True`` ，否则返回 ``False`` 。 字母类 ASCII "
"字符就是字节值包含在序列 ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` "
"中的字符。"

#: ../../library/stdtypes.rst:3446
msgid ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"
msgstr ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"

#: ../../library/stdtypes.rst:3455
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"如果序列为空或序列中所有字节都是 ASCII 字节则返回 ``True`` ，否则返回 ``False`` 。 ASCII 字节的取值范围是 "
"0-0x7F。"

#: ../../library/stdtypes.rst:3465
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 ``True`` ，否则返回 ``False`` 。 ASCII "
"十进制数码就是字节值包含在序列 ``b'0123456789'`` 中的字符。"

#: ../../library/stdtypes.rst:3471
msgid ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"
msgstr ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"

#: ../../library/stdtypes.rst:3480
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr "如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/stdtypes.rst:3485
msgid ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"
msgstr ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"

#: ../../library/stdtypes.rst:3490 ../../library/stdtypes.rst:3532
#: ../../library/stdtypes.rst:3548 ../../library/stdtypes.rst:3598
#: ../../library/stdtypes.rst:3667
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"小写 ASCII 字符就是字节值包含在序列 ``b'abcdefghijklmnopqrstuvwxyz'`` 中的字符。 大写 ASCII "
"字符就是字节值包含在序列 ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 中的字符。"

#: ../../library/stdtypes.rst:3498
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are"
" those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 ``True`` ，否则返回 ``False`` 。 ASCII "
"空白符就是字节值包含在序列 ``b' \\t\\n\\r\\x0b\\f'`` (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。"

#: ../../library/stdtypes.rst:3507
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"如果序列为 ASCII 标题大小写形式并且序列非空则返回 ``True`` ，否则返回 ``False`` 。 请参阅 "
":meth:`bytes.title` 了解有关“标题大小写”的详细定义。"

#: ../../library/stdtypes.rst:3513
msgid ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"
msgstr ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"

#: ../../library/stdtypes.rst:3522
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr "如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/stdtypes.rst:3527
msgid ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"
msgstr ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"

#: ../../library/stdtypes.rst:3540
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr "返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。"

#: ../../library/stdtypes.rst:3545
msgid ""
">>> b'Hello World'.lower()\n"
"b'hello world'"
msgstr ""
">>> b'Hello World'.lower()\n"
"b'hello world'"

#: ../../library/stdtypes.rst:3565
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 :term:`universal newlines` 方式来分行。"
" 结果列表中不包含换行符，除非给出了 *keepends* 且为真值。"

#: ../../library/stdtypes.rst:3572
msgid ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"
msgstr ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"

#: ../../library/stdtypes.rst:3577
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""
"不同于 :meth:`~bytes.split`，当给出了分隔符 *sep* "
"时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行::"

#: ../../library/stdtypes.rst:3581
msgid ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"
msgstr ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"

#: ../../library/stdtypes.rst:3590
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr "返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。"

#: ../../library/stdtypes.rst:3595
msgid ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"
msgstr ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"

#: ../../library/stdtypes.rst:3602
msgid ""
"Unlike :func:`str.swapcase`, it is always the case that "
"``bin.swapcase().swapcase() == bin`` for the binary versions. Case "
"conversions are symmetrical in ASCII, even though that is not generally true"
" for arbitrary Unicode code points."
msgstr ""
"不同于 :func:`str.swapcase`，在二进制版本下 ``bin.swapcase().swapcase() == bin`` 始终成立。 "
"大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。"

#: ../../library/stdtypes.rst:3616
msgid ""
"Return a titlecased version of the binary sequence where words start with an"
" uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr "返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小写。 不区别大小写的字节值将保持原样不变。"

#: ../../library/stdtypes.rst:3622
msgid ""
">>> b'Hello world'.title()\n"
"b'Hello World'"
msgstr ""
">>> b'Hello world'.title()\n"
"b'Hello World'"

#: ../../library/stdtypes.rst:3625
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"小写 ASCII 字符就是字节值包含在序列 ``b'abcdefghijklmnopqrstuvwxyz'`` 中的字符。 大写 ASCII "
"字符就是字节值包含在序列 ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 中的字符。 所有其他字节值都不区分大小写。"

#: ../../library/stdtypes.rst:3635
msgid ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""

#: ../../library/stdtypes.rst:3638
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "可以使用正则表达式来构建针对撇号的特别处理::"

#: ../../library/stdtypes.rst:3640
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""

#: ../../library/stdtypes.rst:3659
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr "返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。"

#: ../../library/stdtypes.rst:3664
msgid ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"
msgstr ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"

#: ../../library/stdtypes.rst:3680
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make"
" a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is"
" handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"返回原序列的副本，在左边填充 ``b'0'`` 数码使序列长度为 *width*。 正负值前缀 (``b'+'``/ ``b'-'``) "
"的处理方式是在正负符号 *之后* 填充而非在之前。 对于 :class:`bytes` 对象，如果 *width* 小于等于 ``len(seq)`` "
"则返回原序列。"

#: ../../library/stdtypes.rst:3688
msgid ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"
msgstr ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"

#: ../../library/stdtypes.rst:3702
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` 风格的字节串格式化"

#: ../../library/stdtypes.rst:3719
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。"

#: ../../library/stdtypes.rst:3724
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or"
" *interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with"
" zero or more elements of *values*. The effect is similar to using the "
":c:func:`sprintf` in the C language."
msgstr ""
"字节串对象 (``bytes``/``bytearray``) 具有一种特殊的内置操作：使用 ``%`` (取模) 运算符。 这也被称为字节串的 "
"*格式化* 或 *插值* 运算符。 对于 ``format % values`` (其中 *format* 为一个字节串对象)，在 *format* "
"中的 ``%`` 转换标记符将被替换为零个或多个 *values* 条目。 其效果类似于在 C 语言中使用 :c:func:`sprintf`。"

#: ../../library/stdtypes.rst:3731
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format bytes object, or a single mapping object (for"
" example, a dictionary)."
msgstr ""
"如果 *format* 要求一个单独参数，则 *values* 可以为一个非元组对象。 [5]_  否则的话，*values* "
"必须或是是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象（例如元组）。"

#: ../../library/stdtypes.rst:3765
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For "
"example:"
msgstr ""
"当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 *必须* 包含加圆括号的映射键，对应 ``'%'`` 字符之后字典中的每一项。 "
"映射键将从映射中选取要格式化的值。 例如："

#: ../../library/stdtypes.rst:3839
msgid "Single byte (accepts integer or single byte objects)."
msgstr "单个字节（接受整数或单个字节对象）。"

#: ../../library/stdtypes.rst:3842
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3842
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or"
" has :meth:`~object.__bytes__`)."
msgstr ""
"字节串（任何遵循 :ref:`缓冲区协议 <bufferobjects>` 或是具有 :meth:`~object.__bytes__` 的对象）。"

#: ../../library/stdtypes.rst:3846
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'s'`` 是 ``'b'`` 的一个别名，只应当在基于 Python2/3 的代码中使用。"

#: ../../library/stdtypes.rst:3849
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"字节串（使用 ``repr(obj).encode('ascii', 'backslashreplace')`` 来转换任意 Python 对象）。"

#: ../../library/stdtypes.rst:3852
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'r'`` 是 ``'a'`` 的一个别名，只应当在基于 Python2/3 的代码中使用。"

#: ../../library/stdtypes.rst:3852
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3887
msgid ""
"``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` 已弃用，但在 3.x 系列中将不会被移除。"

#: ../../library/stdtypes.rst:3890
msgid ""
"``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` 已弃用，但在 3.x 系列中将不会被移除。"

#: ../../library/stdtypes.rst:3902
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - 为 bytes 和 bytearray 添加 % 格式化"

#: ../../library/stdtypes.rst:3909
msgid "Memory Views"
msgstr "内存视图"

#: ../../library/stdtypes.rst:3911
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of"
" an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview` 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 :ref:`缓冲区协议 "
"<bufferobjects>` 而无需进行拷贝。"

#: ../../library/stdtypes.rst:3917
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"创建一个引用 *object* 的 :class:`memoryview` 。 *object* 必须支持缓冲区协议。支持缓冲区协议的内置对象有 "
":class:`bytes` 和 :class:`bytearray` 。"

#: ../../library/stdtypes.rst:3921
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such"
" as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` 有 **元素** 的概念， **元素** 指由原始 *object* 处理的原子内存单元。对于许多简单的类型，如"
" :class:`bytes` 和 :class:`bytearray` ，一个元素是一个字节，但其他类型，如 :class:`array.array`"
" 可能有更大的元素。"

#: ../../library/stdtypes.rst:3926
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is"
" equal to the number of elements in the view."
msgstr ""
"``len(view)`` 等于 :class:`~memoryview.tolist` 的长度，即视图的嵌套列表表示形式。 如果 "
"``view.ndim = 1``，它将等于视图中元素的数量。"

#: ../../library/stdtypes.rst:3930
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr "如果 ``view.ndim == 0``，现在 ``len(view)`` 将引发 :exc:`TypeError` 而不是返回 1."

#: ../../library/stdtypes.rst:3933
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ":class:`~memoryview.itemsize` 属性将给出单个元素的字节数。"

#: ../../library/stdtypes.rst:3936
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ":class:`memoryview` 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图::"

#: ../../library/stdtypes.rst:3939
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"

#: ../../library/stdtypes.rst:3949
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is"
" also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"如果 :class:`~memoryview.format` 是一个来自于 :mod:`struct` "
"模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 *元素*。 "
"一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 *ndim* 个整数构成的元素进行索引，*ndim* "
"即其维度。 零维内存视图可以使用空元组进行索引。"

#: ../../library/stdtypes.rst:3958
msgid "Here is an example with a non-byte format::"
msgstr "这里是一个使用非字节格式的例子::"

#: ../../library/stdtypes.rst:3960
msgid ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"
msgstr ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"

#: ../../library/stdtypes.rst:3970
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr "如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许::"

#: ../../library/stdtypes.rst:3973
msgid ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"
msgstr ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"

#: ../../library/stdtypes.rst:3991
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"格式符为 'B', 'b' 或 'c' 的 :term:`hashable` (只读) 类型的一维内存视图也是可哈希对象。 哈希被定义为 "
"``hash(m) == hash(m.tobytes())``::"

#: ../../library/stdtypes.rst:3995
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"

#: ../../library/stdtypes.rst:4003
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr "一维内存视图现在可以被切片。 格式符为 'B', 'b' 或 'c' 的一维内存视图现在是 :term:`hashable`。"

#: ../../library/stdtypes.rst:4007
msgid ""
"memoryview is now registered automatically with "
":class:`collections.abc.Sequence`"
msgstr "内存视图现在会自动注册为 :class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:4011
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "内存视图现在可使用整数元组进行索引。"

#: ../../library/stdtypes.rst:4014
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` 具有以下一些方法："

#: ../../library/stdtypes.rst:4018
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"memoryview 与 :pep:`3118` 中的导出器这两者如果形状相同，并且如果当使用 :mod:`struct` "
"语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。"

#: ../../library/stdtypes.rst:4022
msgid ""
"For the subset of :mod:`struct` format strings currently supported by "
":meth:`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"对于 :meth:`tolist` 当前所支持的 :mod:`struct` 格式字符串子集，如果 ``v.tolist() == "
"w.tolist()`` 则 ``v`` 和 ``w`` 相等::"

#: ../../library/stdtypes.rst:4025
msgid ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"
msgstr ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"

#: ../../library/stdtypes.rst:4041
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr "如果两边的格式字符串都不被 :mod:`struct` 模块所支持，则两对象比较结果总是不相等（即使格式字符串和缓冲区内容相同）::"

#: ../../library/stdtypes.rst:4045
msgid ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"
msgstr ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"

#: ../../library/stdtypes.rst:4057
msgid ""
"Note that, as with floating-point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr "请注意，与浮点数的情况一样，对于内存视图对象来说，``v is w`` 也 *并不* 意味着 ``v == w``。"

#: ../../library/stdtypes.rst:4060
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr "之前的版本比较原始内存时会忽略条目的格式与逻辑数组结构。"

#: ../../library/stdtypes.rst:4066
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr "将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 :class:`bytes` 构造器。 ::"

#: ../../library/stdtypes.rst:4069
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"
msgstr ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"

#: ../../library/stdtypes.rst:4075
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。 :meth:`tobytes` 支持所有格式字符串，不符合 "
":mod:`struct` 模块语法的那些也包括在内。"

#: ../../library/stdtypes.rst:4080
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the"
" original array is converted to C or Fortran order. For contiguous views, "
"'A' returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* 可以为 {'C', 'F', 'A'}。 当 *order* 为 'C' 或 'F' 时，原始数组的数据会被转换至 C 或 "
"Fortran 顺序。 对于连续视图，'A' 会返回物理内存的精确副本。 特别地，内存中的 Fortran "
"顺序会被保留。对于非连续视图，数据会先被转换为 C 形式。 *order=None* 与 *order='C'* 是相同的。"

#: ../../library/stdtypes.rst:4089
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr "返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。 ::"

#: ../../library/stdtypes.rst:4092
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"
msgstr ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"

#: ../../library/stdtypes.rst:4098
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"与 :meth:`bytes.hex` 相似， :meth:`memoryview.hex` 现在支持可选的 *sep* 和 "
"*bytes_per_sep* 参数以在十六进制输出的字节之间插入分隔符。"

#: ../../library/stdtypes.rst:4105
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "将缓冲区内的数据以一个元素列表的形式返回。 ::"

#: ../../library/stdtypes.rst:4107
msgid ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"

#: ../../library/stdtypes.rst:4115
msgid ""
":meth:`tolist` now supports all single character native formats in "
":mod:`struct` module syntax as well as multi-dimensional representations."
msgstr ":meth:`tolist` 现在支持 :mod:`struct` 模块语法中的所有单字符原生格式以及多维表示形式。"

#: ../../library/stdtypes.rst:4122
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview"
" object is unchanged. ::"
msgstr "返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。 ::"

#: ../../library/stdtypes.rst:4125
msgid ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"
msgstr ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"

#: ../../library/stdtypes.rst:4141
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a "
":class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动作（例如，:class:`bytearray` "
"将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽早去除这些限制（并释放任何多余的资源）。"

#: ../../library/stdtypes.rst:4147
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release` itself which can be called "
"multiple times)::"
msgstr ""
"在此方法被调用后，任何对该视图的进一步操作都将引发 :class:`ValueError` (除了可被多次调用的 :meth:`release` "
"本身)::"

#: ../../library/stdtypes.rst:4151
msgid ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"

#: ../../library/stdtypes.rst:4158
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr "使用 ``with`` 语句，可以通过上下文管理协议达到类似的效果::"

#: ../../library/stdtypes.rst:4161
msgid ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"

#: ../../library/stdtypes.rst:4174
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself"
" is not copied. Supported casts are 1D -> C-:term:`contiguous` and "
"C-contiguous -> 1D."
msgstr ""
"将内存视图转化为新的格式或形状。 *shape* 默认为 ``[byte_length//new_itemsize]``，这意味着结果视图将是一维的。 "
"返回值是一个新的内存视图，但缓冲区本身不会被复制。 支持的转化有 1D -> C-:term:`contiguous` 和 C-contiguous "
"-> 1D。"

#: ../../library/stdtypes.rst:4180
msgid ""
"The destination format is restricted to a single element native format in "
":mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
" Note that all byte lengths may depend on the operating system."
msgstr ""
"目标格式被限制为 :mod:`struct` 语法中的单一元素的原生格式。 这些格式中的一种必须为字节格式 ('B', 'b' 或 'c')。 "
"结果的字节长度必须与原始长度相同。 请注意全部字节长度可能取决于具体操作系统。"

#: ../../library/stdtypes.rst:4186
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "将 1D/long 转换为 1D/unsigned bytes::"

#: ../../library/stdtypes.rst:4188
msgid ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"
msgstr ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"

#: ../../library/stdtypes.rst:4209
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "将 1D/unsigned bytes 转换为 1D/char::"

#: ../../library/stdtypes.rst:4211
msgid ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"
msgstr ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"

#: ../../library/stdtypes.rst:4222
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char::"

#: ../../library/stdtypes.rst:4224
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"

#: ../../library/stdtypes.rst:4248
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "将 1D/unsigned long 转换为 2D/unsigned long::"

#: ../../library/stdtypes.rst:4250
msgid ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"
msgstr ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"

#: ../../library/stdtypes.rst:4262
msgid "The source format is no longer restricted when casting to a byte view."
msgstr "当转换为字节视图时，源格式将不再受限。"

#: ../../library/stdtypes.rst:4265
msgid "There are also several readonly attributes available:"
msgstr "还存在一些可用的只读属性："

#: ../../library/stdtypes.rst:4269
msgid "The underlying object of the memoryview::"
msgstr "内存视图的下层对象::"

#: ../../library/stdtypes.rst:4271
msgid ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"
msgstr ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"

#: ../../library/stdtypes.rst:4280
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``。 "
"这是数组在连续表示时将会占用的空间总字节数。 它不一定等于 ``len(m)``::"

#: ../../library/stdtypes.rst:4284
msgid ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"
msgstr ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"

#: ../../library/stdtypes.rst:4299
msgid "Multi-dimensional arrays::"
msgstr "多维数组::"

#: ../../library/stdtypes.rst:4301
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"

#: ../../library/stdtypes.rst:4316
msgid "A bool indicating whether the memory is read only."
msgstr "一个表明内存是否只读的布尔值。"

#: ../../library/stdtypes.rst:4320
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"一个字符串，包含视图中每个元素的格式（表示为 :mod:`struct` 模块样式）。 内存视图可以从具有任意格式字符串的导出器创建，但某些方法 (例如"
" :meth:`tolist`) 仅限于原生的单元素格式。"

#: ../../library/stdtypes.rst:4325
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"格式 ``'B'`` 现在会按照 struct 模块语法来处理。 这意味着 ``memoryview(b'abc')[0] == b'abc'[0] "
"== 97``。"

#: ../../library/stdtypes.rst:4331
msgid "The size in bytes of each element of the memoryview::"
msgstr "memoryview 中每个元素以字节表示的大小::"

#: ../../library/stdtypes.rst:4333
msgid ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"
msgstr ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"

#: ../../library/stdtypes.rst:4344
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "一个整数，表示内存所代表的多维数组具有多少个维度。"

#: ../../library/stdtypes.rst:4349
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr "一个整数元组，通过 :attr:`ndim` 的长度值给出内存所代表的 N 维数组的形状。"

#: ../../library/stdtypes.rst:4352 ../../library/stdtypes.rst:4360
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "当 ndim = 0 时值为空元组而不再为 ``None``。"

#: ../../library/stdtypes.rst:4357
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr "一个整数元组，通过 :attr:`ndim` 的长度给出以字节表示的大小，以便访问数组中每个维度上的每个元素。"

#: ../../library/stdtypes.rst:4365
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "供 PIL 风格的数组内部使用。 该值仅作为参考信息。"

#: ../../library/stdtypes.rst:4369
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "一个表明内存是否为 C-:term:`contiguous` 的布尔值。"

#: ../../library/stdtypes.rst:4375
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "一个表明内存是否为 Fortran :term:`contiguous` 的布尔值。"

#: ../../library/stdtypes.rst:4381
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "一个表明内存是否为 :term:`contiguous` 的布尔值。"

#: ../../library/stdtypes.rst:4389
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "集合类型 --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4393
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union,"
" difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""
":dfn:`set` 对象是由具有唯一性的 :term:`hashable` 对象所组成的无序多项集。 "
"常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器对象请参看 "
":class:`dict`, :class:`list` 与 :class:`tuple` 等内置类，以及 :mod:`collections` "
"模块。）"

#: ../../library/stdtypes.rst:4400
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"与其他多项集一样，集合也支持 ``x in set``, ``len(set)`` 和 ``for x in set``。 "
"作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。"

#: ../../library/stdtypes.rst:4405
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can be"
" changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since"
" it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type"
" is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element"
" of another set."
msgstr ""
"目前有两种内置集合类型，:class:`set` 和 :class:`frozenset`。 :class:`set` 类型是可变的 --- "
"其内容可以使用 :meth:`~set.add` 和 :meth:`~set.remove` 这样的方法来改变。 "
"由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 :class:`frozenset` 类型是不可变并且为 "
":term:`hashable` --- 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。"

#: ../../library/stdtypes.rst:4413
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"除了可以使用 :class:`set` 构造器，非空的 set (不是 frozenset) "
"还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: ``{'jack', 'sjoerd'}``。"

#: ../../library/stdtypes.rst:4417
msgid "The constructors for both classes work the same:"
msgstr "两个类的构造器具有相同的作用方式："

#: ../../library/stdtypes.rst:4422
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"返回一个新的 set 或 frozenset 对象，其元素来自于 *iterable*。 集合的元素必须为 :term:`hashable`。 "
"要表示由集合对象构成的集合，所有的内层集合必须为 :class:`frozenset` 对象。 如果未指定 "
"*iterable*，则将返回一个新的空集合。"

#: ../../library/stdtypes.rst:4428
msgid "Sets can be created by several means:"
msgstr "集合可用多种方式来创建:"

#: ../../library/stdtypes.rst:4430
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr "使用花括号内以逗号分隔元素的方式: ``{'jack', 'sjoerd'}``"

#: ../../library/stdtypes.rst:4431
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr "使用集合推导式: ``{c for c in 'abracadabra' if c not in 'abc'}``"

#: ../../library/stdtypes.rst:4432
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr "使用类型构造器: ``set()``, ``set('foobar')``, ``set(['a', 'b', 'foo'])``"

#: ../../library/stdtypes.rst:4434
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set` 和 :class:`frozenset` 的实例提供以下操作："

#: ../../library/stdtypes.rst:4439
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "返回集合 *s* 中的元素数量（即 *s* 的基数）。"

#: ../../library/stdtypes.rst:4443
msgid "Test *x* for membership in *s*."
msgstr "检测 *x* 是否为 *s* 中的成员。"

#: ../../library/stdtypes.rst:4447
msgid "Test *x* for non-membership in *s*."
msgstr "检测 *x* 是否非 *s* 中的成员。"

#: ../../library/stdtypes.rst:4451
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are"
" disjoint if and only if their intersection is the empty set."
msgstr "如果集合中没有与 *other* 共有的元素则返回 ``True``。 当且仅当两个集合的交集为空集合时，两者为不相交集合。"

#: ../../library/stdtypes.rst:4457
msgid "Test whether every element in the set is in *other*."
msgstr "检测是否集合中的每个元素都在 *other* 之中。"

#: ../../library/stdtypes.rst:4461
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr "检测集合是否为 *other* 的真子集，即 ``set <= other and set != other``。"

#: ../../library/stdtypes.rst:4467
msgid "Test whether every element in *other* is in the set."
msgstr "检测是否 *other* 中的每个元素都在集合之中。"

#: ../../library/stdtypes.rst:4471
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr "检测集合是否为 *other* 的真超集，即 ``set >= other and set != other``。"

#: ../../library/stdtypes.rst:4477
msgid "Return a new set with elements from the set and all others."
msgstr "返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。"

#: ../../library/stdtypes.rst:4482
msgid "Return a new set with elements common to the set and all others."
msgstr "返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。"

#: ../../library/stdtypes.rst:4487
msgid "Return a new set with elements in the set that are not in the others."
msgstr "返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。"

#: ../../library/stdtypes.rst:4492
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr "返回一个新集合，其中的元素或属于原集合或属于 *other* 指定的其他集合，但不能同时属于两者。"

#: ../../library/stdtypes.rst:4496
msgid "Return a shallow copy of the set."
msgstr "返回原集合的浅拷贝。"

#: ../../library/stdtypes.rst:4499
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and "
":meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"注意， :meth:`union` 、 :meth:`intersection` 、 :meth:`difference` 、 "
":meth:`symmetric_difference` 、 :meth:`issubset`  和 :meth:`issuperset` "
"方法的非运算符版本可以接受任何可迭代对象作为一个参数。相比之下，基于运算符的对应方法则要求参数为集合对象。这就避开了像 ``set('abc') & "
"'cbs'`` 这样容易出错的结构，而换成了可读性更好的 ``set('abc').intersection('cbs')``。"

#: ../../library/stdtypes.rst:4506
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two"
" sets are equal if and only if every element of each set is contained in the"
" other (each is a subset of the other). A set is less than another set if "
"and only if the first set is a proper subset of the second set (is a subset,"
" but is not equal). A set is greater than another set if and only if the "
"first set is a proper superset of the second set (is a superset, but is not "
"equal)."
msgstr ""
":class:`set` 和 :class:`frozenset` 均支持集合与集合的比较。 "
"两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 "
"一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 "
"一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。"

#: ../../library/stdtypes.rst:4513
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` 的实例与 :class:`frozenset` 的实例之间基于它们的成员进行比较。 例如 ``set('abc') == "
"frozenset('abc')`` 返回 ``True``，``set('abc') in set([frozenset('abc')])`` "
"也一样。"

#: ../../library/stdtypes.rst:4517
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are"
" not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 *所有* 比较均返回 ``False``:"
" ``a<b``, ``a==b``, or ``a>b``。"

#: ../../library/stdtypes.rst:4522
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 :meth:`list.sort` 方法的输出并无定义。"

#: ../../library/stdtypes.rst:4525
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "集合的元素，与字典的键类似，必须为 :term:`hashable`。"

#: ../../library/stdtypes.rst:4527
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"混合了 :class:`set` 实例与 :class:`frozenset` 的二进制位运算将返回与第一个操作数相同的类型。例如: "
"``frozenset('ab') | set('bc')`` 将返回 :class:`frozenset` 的实例。"

#: ../../library/stdtypes.rst:4531
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr "下表列出了可用于 :class:`set` 而不能用于不可变的 :class:`frozenset` 实例的操作："

#: ../../library/stdtypes.rst:4537
msgid "Update the set, adding elements from all others."
msgstr "更新集合，添加来自 others 中的所有元素。"

#: ../../library/stdtypes.rst:4542
msgid "Update the set, keeping only elements found in it and all others."
msgstr "更新集合，只保留其中在所有 others 中也存在的元素。"

#: ../../library/stdtypes.rst:4547
msgid "Update the set, removing elements found in others."
msgstr "更新集合，移除其中也存在于 others 中的元素。"

#: ../../library/stdtypes.rst:4552
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "更新集合，只保留存在于集合的一方而非共同存在的元素。"

#: ../../library/stdtypes.rst:4556
msgid "Add element *elem* to the set."
msgstr "将元素 *elem* 添加到集合中。"

#: ../../library/stdtypes.rst:4560
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not"
" contained in the set."
msgstr "从集合中移除元素 *elem*。 如果 *elem* 不存在于集合中则会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4565
msgid "Remove element *elem* from the set if it is present."
msgstr "如果元素 *elem* 存在于集合中则将其移除。"

#: ../../library/stdtypes.rst:4569
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError`"
" if the set is empty."
msgstr "从集合中移除并返回任意一个元素。 如果集合为空则会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4574
msgid "Remove all elements from the set."
msgstr "从集合中移除所有元素。"

#: ../../library/stdtypes.rst:4577
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"请注意，非运算符版本的 :meth:`update`, :meth:`intersection_update`, "
":meth:`difference_update` 和 :meth:`symmetric_difference_update` "
"方法将接受任意可迭代对象作为参数。"

#: ../../library/stdtypes.rst:4582
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, "
":meth:`remove`, and :meth:`discard` methods may be a set.  To support "
"searching for an equivalent frozenset, a temporary one is created from "
"*elem*."
msgstr ""
"请注意，:meth:`~object.__contains__`, :meth:`remove` 和 :meth:`discard` 方法的 "
"*elem* 参数可以是一个集合。 为支持搜索等价的冻结集合，将根据 *elem* 临时创建一个相应的对象。"

#: ../../library/stdtypes.rst:4591
msgid "Mapping Types --- :class:`dict`"
msgstr "映射类型 --- :class:`dict`"

#: ../../library/stdtypes.rst:4601
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in "
":class:`list`, :class:`set`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""
":term:`mapping` 对象会将 :term:`hashable` 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 "
":dfn:`字典`。 （关于其他容器对象请参看 :class:`list`, :class:`set` 与 :class:`tuple` 等内置类，以及"
" :mod:`collections` 模块。）"

#: ../../library/stdtypes.rst:4607
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary "
"entry."
msgstr ""
"字典的键 *几乎* 可以为任何值。 不是 :term:`hashable` "
"的值，即包含列表、字典或其他可变类型（按值比较而非按对象标识比较）的值不可被用作键。 比较结果相等的值（如 ``1``, ``1.0`` 和 "
"``True`` 等）可被互换使用以索引同一个字典条目。"

#: ../../library/stdtypes.rst:4618
msgid ""
"Return a new dictionary initialized from an optional positional argument and"
" a possibly empty set of keyword arguments."
msgstr "返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。"

#: ../../library/stdtypes.rst:4621
msgid "Dictionaries can be created by several means:"
msgstr "字典可用多种方式来创建:"

#: ../../library/stdtypes.rst:4623
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack':"
" 4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"使用花括号内以逗号分隔 ``键: 值`` 对的方式: ``{'jack': 4098, 'sjoerd': 4127}`` or ``{4098: "
"'jack', 4127: 'sjoerd'}``"

#: ../../library/stdtypes.rst:4625
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr "使用字典推导式: ``{}``, ``{x: x ** 2 for x in range(10)}``"

#: ../../library/stdtypes.rst:4626
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"使用类型构造器: ``dict()``, ``dict([('foo', 100), ('bar', 200)])``, ``dict(foo=100,"
" bar=200)``"

#: ../../library/stdtypes.rst:4629
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it defines a ``keys()`` method, a "
"dictionary is created by calling :meth:`~object.__getitem__` on the argument"
" with each returned key from the method.  Otherwise, the positional argument"
" must be an :term:`iterable` object.  Each item in the iterable must itself "
"be an iterable with exactly two elements.  The first element of each item "
"becomes a key in the new dictionary, and the second element the "
"corresponding value.  If a key occurs more than once, the last value for "
"that key becomes the corresponding value in the new dictionary."
msgstr ""
"如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其定义了 ``keys()`` 方法，则通过在该参数上调用 "
":meth:`~object.__getitem__` 创建一个字典并包含从该方法返回的每个键。 在其他情况下，位置参数必须是一个 "
":term:`iterable` 对象。 该可迭代对象中的每一项本身必须是一个恰好包含两个元素的可迭代对象。 "
"每一项中的第一个元素将成为新字典的一个键，第二个元素将成为其对应的值。 如果一个键出现多次，该键的最后一个值将成为其在新字典中的对应值。"

#: ../../library/stdtypes.rst:4639
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces"
" the value from the positional argument."
msgstr ""
"如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。"

#: ../../library/stdtypes.rst:4644 ../../library/stdtypes.rst:4662
msgid ""
"Providing keyword arguments as in the first example only works for keys that"
" are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr "像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。"

#: ../../library/stdtypes.rst:4647
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=',"
" '>') raise :exc:`TypeError`.  To illustrate dictionary creation and "
"equality, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"字典比较的结果当且仅当它们具有相同的 ``(key, value)`` 对时（不考虑顺序）才会相等。 顺序比较 ('<', '<=', '>=', "
"'>') 会引发 :exc:`TypeError`。 为了说明字典创建和相等性规则，下面的示例都返回一个等于 ``{\"one\": 1, "
"\"two\": 2, \"three\": 3}`` 的字典::"

#: ../../library/stdtypes.rst:4653
msgid ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"
msgstr ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"

#: ../../library/stdtypes.rst:4665
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr "字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。 ::"

#: ../../library/stdtypes.rst:4668
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"

#: ../../library/stdtypes.rst:4683
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr "字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。"

#: ../../library/stdtypes.rst:4687
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr "这些是字典所支持的操作（因而自定义的映射类型也应当支持）："

#: ../../library/stdtypes.rst:4692
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "返回字典 *d* 中使用的所有键的列表。"

#: ../../library/stdtypes.rst:4696
msgid "Return the number of items in the dictionary *d*."
msgstr "返回字典 *d* 中的项数。"

#: ../../library/stdtypes.rst:4700
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is"
" not in the map."
msgstr "返回 *d* 中以 *key* 为键的项。 如果映射中不存在 *key* 则会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4705
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, "
":exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot "
"be an instance variable::"
msgstr ""
"如果字典的子类定义了方法 :meth:`__missing__` 并且 *key* 不存在，则 ``d[key]`` 操作将调用该方法并附带键 "
"*key* 作为参数。 ``d[key]`` 随后将返回或引发 ``__missing__(key)`` 调用所返回或引发的任何对象或异常。 "
"没有其他操作或方法会唤起 :meth:`__missing__`。 如果未定义 :meth:`__missing__`，则会引发 "
":exc:`KeyError`。 :meth:`__missing__` 必须是一个方法；它不能是一个实例变量::"

#: ../../library/stdtypes.rst:4713
msgid ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"
msgstr ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"

#: ../../library/stdtypes.rst:4724
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used by"
" :class:`collections.defaultdict`."
msgstr ""
"上面的例子显示了 :class:`collections.Counter` 实现的部分代码。 还有另一个不同的 ``__missing__`` 方法是由"
" :class:`collections.defaultdict` 所使用的。"

#: ../../library/stdtypes.rst:4730
msgid "Set ``d[key]`` to *value*."
msgstr "将 ``d[key]`` 设为 *value*。"

#: ../../library/stdtypes.rst:4734
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the"
" map."
msgstr "将 ``d[key]`` 从 *d* 中移除。 如果映射中不存在 *key* 则会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4739
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "如果 *d* 中存在键 *key* 则返回 ``True``，否则返回 ``False``。"

#: ../../library/stdtypes.rst:4743
msgid "Equivalent to ``not key in d``."
msgstr "等价于 ``not key in d``。"

#: ../../library/stdtypes.rst:4747
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr "返回以字典的键为元素的迭代器。 这是 ``iter(d.keys())`` 的快捷方式。"

#: ../../library/stdtypes.rst:4752
msgid "Remove all items from the dictionary."
msgstr "移除字典中的所有元素。"

#: ../../library/stdtypes.rst:4756
msgid "Return a shallow copy of the dictionary."
msgstr "返回原字典的浅拷贝。"

#: ../../library/stdtypes.rst:4760
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr "使用来自 *iterable* 的键创建一个新字典，并将键值设为 *value*。"

#: ../../library/stdtypes.rst:4762
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so"
" it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` 是一个返回新字典的类方法。 *value* 默认为 ``None``。 所有值都只引用一个单独的实例，因此让 "
"*value* 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 :ref:`字典推导式 <dict>`。"

#: ../../library/stdtypes.rst:4770
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If"
" *default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"如果 *key* 存在于字典中则返回 *key* 的值，否则返回 *default*。 如果 *default* 未给出则默认为 "
"``None``，因而此方法绝不会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4776
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr "返回由字典项 (``(键, 值)`` 对) 组成的一个新视图。 参见 :ref:`视图对象文档 <dict-views>`。"

#: ../../library/stdtypes.rst:4781
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr "返回由字典键组成的一个新视图。 参见 :ref:`视图对象文档 <dict-views>`。"

#: ../../library/stdtypes.rst:4786
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a "
":exc:`KeyError` is raised."
msgstr ""
"如果 *key* 存在于字典中则将其移除并返回其值，否则返回 *default*。 如果 *default* 未给出且 *key* "
"不存在于字典中，则会引发 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4792
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr "从字典中移除并返回一个 ``(键, 值)`` 对。 键值对会按 :abbr:`LIFO (后进先出)` 的顺序被返回。"

#: ../../library/stdtypes.rst:4795
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":meth:`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 :meth:`popitem` 将引发 "
":exc:`KeyError`。"

#: ../../library/stdtypes.rst:4799
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr "现在会确保采用 LIFO 顺序。 在之前的版本中，:meth:`popitem` 会返回一个任意的键/值对。"

#: ../../library/stdtypes.rst:4805
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr "返回一个逆序获取字典键的迭代器。 这是 ``reversed(d.keys())`` 的快捷方式。"

#: ../../library/stdtypes.rst:4812
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"如果字典存在键 *key* ，返回它的值。如果不存在，插入值为 *default* 的键 *key* ，并返回 *default* 。 "
"*default* 默认为 ``None``。"

#: ../../library/stdtypes.rst:4818
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr "使用来自 *other* 的键/值对更新字典，覆盖原有的键。 返回 ``None``。"

#: ../../library/stdtypes.rst:4821
msgid ""
":meth:`update` accepts either another object with a ``keys()`` method (in "
"which case :meth:`~object.__getitem__` is called with every key returned "
"from the method) or an iterable of key/value pairs (as tuples or other "
"iterables of length two). If keyword arguments are specified, the dictionary"
" is then updated with those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` 接受另一个具有 ``keys()`` 方法的对象（在此情况下 :meth:`~object.__getitem__` "
"将被调用并附带从该方法返回的键）或一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 "
"如果指定了关键字参数，则会以其所对应的键/值对更新字典: ``d.update(red=1, blue=2)``。"

#: ../../library/stdtypes.rst:4829
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr "返回由字典值组成的一个新视图。 参见 :ref:`视图对象文档 <dict-views>`。"

#: ../../library/stdtypes.rst:4832
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"两个 ``dict.values()`` 视图之间的相等性比较将总是返回 ``False``。 这在 ``dict.values()`` "
"与其自身比较时也同样适用::"

#: ../../library/stdtypes.rst:4836
msgid ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"
msgstr ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"

#: ../../library/stdtypes.rst:4842
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"合并 *d* 和 *other* 中的键和值来创建一个新的字典，两者必须都是字典。当 *d* 和 *other* 有相同键时， *other* "
"的值优先。"

#: ../../library/stdtypes.rst:4850
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"用 *other* 的键和值更新字典 *d* ，*other* 可以是 :term:`mapping` 或 :term:`iterable` "
"的键值对。当 *d* 和 *other* 有相同键时， *other* 的值优先。"

#: ../../library/stdtypes.rst:4856
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "字典和字典视图都是可逆的。 ::"

#: ../../library/stdtypes.rst:4858
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"

#: ../../library/stdtypes.rst:4868
msgid "Dictionaries are now reversible."
msgstr "字典现在是可逆的。"

#: ../../library/stdtypes.rst:4873
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a "
":class:`dict`."
msgstr ":class:`types.MappingProxyType` 可被用来创建一个 :class:`dict` 的只读视图。"

#: ../../library/stdtypes.rst:4880
msgid "Dictionary view objects"
msgstr "字典视图对象"

#: ../../library/stdtypes.rst:4882
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and "
":meth:`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view"
" reflects these changes."
msgstr ""
"由 :meth:`dict.keys`, :meth:`dict.values` 和 :meth:`dict.items` 所返回的对象是 "
"*视图对象*。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。"

#: ../../library/stdtypes.rst:4887
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr "字典视图可以被迭代以产生与其对应的数据，并支持成员检测："

#: ../../library/stdtypes.rst:4892
msgid "Return the number of entries in the dictionary."
msgstr "返回字典中的条目数。"

#: ../../library/stdtypes.rst:4896
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr "返回字典中的键、值或项（以 ``(键, 值)`` 为元素的元组表示）的迭代器。"

#: ../../library/stdtypes.rst:4899
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  Another way to create the same list is ``pairs"
" = [(v, k) for (k, v) in d.items()]``."
msgstr ""
"键和值是按插入时的顺序进行迭代的。 这样就允许使用 :func:`zip` 来创建 ``(值, 键)`` 对: ``pairs = "
"zip(d.values(), d.keys())``。 另一个创建相同列表的方式是 ``pairs = [(v, k) for (k, v) in "
"d.items()]``."

#: ../../library/stdtypes.rst:4904
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise"
" a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr "在添加或删除字典中的条目期间对视图进行迭代可能引发 :exc:`RuntimeError` 或者无法完全迭代所有条目。"

#: ../../library/stdtypes.rst:4907
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "字典顺序会确保为插入顺序。"

#: ../../library/stdtypes.rst:4912
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr "如果 *x* 是对应字典中存在的键、值或项（在最后一种情况下 *x* 应为一个 ``(键, 值)`` 元组） 则返回 ``True``。"

#: ../../library/stdtypes.rst:4917
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr "返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。"

#: ../../library/stdtypes.rst:4920
msgid "Dictionary views are now reversible."
msgstr "字典视图现在是可逆的。"

#: ../../library/stdtypes.rst:4925
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr "返回 :class:`types.MappingProxyType` 对象，封装了字典视图指向的原始字典。"

#: ../../library/stdtypes.rst:4930
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`."
" Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example,"
" ``==``, ``<``, or ``^``).  While using set operators, set-like views accept"
" any iterable as the other operand, unlike sets which only accept sets as "
"the input."
msgstr ""
"键视图与集合类似因为其条目是唯一的并且为 :term:`hashable`。 条视图也有类似集合的操作因为 (键, 值) 对是唯一的并且键是可哈希的。 "
"如果条目视图中的所有值也都是可哈希的，那么条目视图就可以与其他集合执行互操作。 （值视图不会被认为与集合类似因为条目通常不是唯一的）。 "
"对于与集合类似的视图，可以使用为抽象基类 :class:`collections.abc.Set` 定义的所有操作（例如，``==``, ``<`` 或"
" ``^`` 等）。 虽然使用了集合运算符，但与集合类似的视图接受任何可迭代对象作为其操作数，而不像集合那样只接受集合作为输入。"

#: ../../library/stdtypes.rst:4942
msgid "An example of dictionary view usage::"
msgstr "一个使用字典视图的示例::"

#: ../../library/stdtypes.rst:4944
msgid ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order (insertion order)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # get back a read-only proxy for the original dictionary\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"
msgstr ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # 迭代\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # 键和值将以相同顺序（插入顺序）被迭代\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # 视图对象是动态的并会反映字典的改变\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # 集合运算\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # 获取原始字典的只读代理\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"

#: ../../library/stdtypes.rst:4986
msgid "Context Manager Types"
msgstr "上下文管理器类型"

#: ../../library/stdtypes.rst:4993
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context"
" defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python 的 :keyword:`with` 语句支持通过上下文管理器所定义的运行时上下文这一概念。 "
"此对象的实现使用了一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语句执行完毕时退出该上下文："

#: ../../library/stdtypes.rst:5001
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements"
" using this context manager."
msgstr ""
"进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 :keyword:`with` 语句的 "
":keyword:`!as` 子句中的标识符。"

#: ../../library/stdtypes.rst:5006
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow "
":func:`open` to be used as the context expression in a :keyword:`with` "
"statement."
msgstr ""
"一个返回其自身的上下文管理器的例子是 :term:`file object`。 文件对象会从 __enter__() 返回其自身，以允许 "
":func:`open` 被用作 :keyword:`with` 语句中的上下文表达式。"

#: ../../library/stdtypes.rst:5010
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside the"
" :keyword:`!with` statement."
msgstr ""
"一个返回关联对象的上下文管理器的例子是 :func:`decimal.localcontext` 所返回的对象。 此种管理器会将活动的 decimal "
"上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 :keyword:`with` 语句的语句体中的当前 decimal "
"上下文进行更改，而不会影响 :keyword:`!with` 语句以外的代码。"

#: ../../library/stdtypes.rst:5020
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while"
" executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 :keyword:`with` "
"语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 ``None``。"

#: ../../library/stdtypes.rst:5025
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"自此方法返回一个真值将导致 :keyword:`with` 语句屏蔽异常并继续执行紧随在 :keyword:`!with` 语句之后的语句。 "
"否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 :keyword:`!with` 语句的语句体中发生的任何异常。"

#: ../../library/stdtypes.rst:5032
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows"
" context management code to easily detect whether or not an "
":meth:`~object.__exit__` method has actually failed."
msgstr ""
"传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 "
"这允许上下文管理代码方便地检测 :meth:`~object.__exit__` 方法是否确实已失败。"

#: ../../library/stdtypes.rst:5038
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文。 "
"除了实现上下文管理协议以外，不同类型不会被特殊处理。 请参阅 :mod:`contextlib` 模块查看相关的示例。"

#: ../../library/stdtypes.rst:5044
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary "
":meth:`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` "
"methods, rather than the iterator produced by an undecorated generator "
"function."
msgstr ""
"Python 的 :term:`generator` 和 :class:`contextlib.contextmanager` "
"装饰器提供了实现这些协议的便捷方式。 如果使用 :class:`contextlib.contextmanager` "
"装饰器来装饰一个生成器函数，它将返回一个实现了必要的 :meth:`~contextmanager.__enter__` 和 "
":meth:`~contextmanager.__exit__` 方法的上下文管理器，而不再是由未经装饰的生成器所产生的迭代器。"

#: ../../library/stdtypes.rst:5051
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to"
" define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr ""
"请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这些方法的扩展类型必须将它们作为普通的 "
"Python 可访问方法来提供。 与设置运行时上下文的开销相比，单个类字典查找的开销可以忽略不计。"

#: ../../library/stdtypes.rst:5059
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, "
":ref:`Union <types-union>`"
msgstr ""
"类型注解的类型 --- :ref:`Generic Alias <types-genericalias>` 、 :ref:`Union <types-"
"union>`"

#: ../../library/stdtypes.rst:5064
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are "
":ref:`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
":term:`type annotations <annotation>` 的内置类型为 :ref:`Generic Alias<types-"
"genericalias>` 和 :ref:`Union<types-union>`。"

#: ../../library/stdtypes.rst:5071
msgid "Generic Alias Type"
msgstr "GenericAlias 类型"

#: ../../library/stdtypes.rst:5077
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"``GenericAlias`` 对象通常是通过 :ref:`抽取 <subscriptions>` 一个类来创建的。 它们最常被用于 "
":ref:`容器类 <sequence-types>`，如 :class:`list` 或 :class:`dict`。 "
"举例来说，``list[int]`` 这个 ``GenericAlias`` 对象是通过附带 :class:`int` 参数抽取 ``list`` "
"类来创建的。 ``GenericAlias`` 对象的主要目的是用于 :term:`类型标注 <annotation>`。"

#: ../../library/stdtypes.rst:5087
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr "通常一个类只有在实现了特殊方法 :meth:`~object.__class_getitem__` 时才支持抽取操作。"

#: ../../library/stdtypes.rst:5090
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr "``GenericAlias`` 对象可作为 :term:`generic type` 的代理，实现了 *形参化泛型*。"

#: ../../library/stdtypes.rst:5093
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations"
" to signify a :class:`set` in which all the elements are of type "
":class:`bytes`."
msgstr ""
"对于一个容器类，提供给类的 :ref:`抽取 <subscriptions>` 操作的参数可以指明对象所包含的元素类型。 "
"例如，``set[bytes]`` 可在类型标注中用来表示一个 :class:`set` 中的所有元素均为 :class:`bytes` 类型。"

#: ../../library/stdtypes.rst:5099
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both the"
" :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"对于一个定义了 :meth:`~object.__class_getitem__` "
"但不属于容器的类，提供给类的抽取操作的参数往往会指明在对象上定义的一个或多个方法的返回值类型。 例如，:mod:`正则表达式 <re>` 可以被用在 "
":class:`str` 数据类型和 :class:`bytes` 数据类型上:"

#: ../../library/stdtypes.rst:5105
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will"
" both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"如果 ``x = re.search('foo', 'foo')``，则 ``x`` 将为一个 :ref:`re.Match <match-"
"objects>` 对象而 ``x.group(0)`` 和 ``x[0]`` 的返回值将均为 :class:`str` 类型。 "
"我们可以在类型标注中使用 ``GenericAlias`` ``re.Match[str]`` 来代表这种对象。"

#: ../../library/stdtypes.rst:5111
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of "
"``y.group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"如果 ``y = re.search(b'bar', b'bar')``，(注意 ``b`` 表示 :class:`bytes`)，则 ``y`` "
"也将为一个 ``re.Match`` 的实例，但 ``y.group(0)`` 和 ``y[0]`` 的返回值将均为 :class:`bytes` "
"类型。 在类型标注中，我们将使用 ``re.Match[bytes]`` 来代表这种形式的 :ref:`re.Match <match-"
"objects>` 对象。"

#: ../../library/stdtypes.rst:5117
msgid ""
"``GenericAlias`` objects are instances of the class "
":class:`types.GenericAlias`, which can also be used to create "
"``GenericAlias`` objects directly."
msgstr ""
"``GenericAlias`` 对象是 :class:`types.GenericAlias` 类的实例，该类也可被用来直接创建 "
"``GenericAlias`` 对象。"

#: ../../library/stdtypes.rst:5123
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"创建一个代表由类型 *X*, *Y* 来参数化的类型 ``T`` 的 ``GenericAlias``，此类型会更依赖于所使用的 ``T``。 "
"例如，一个接受包含 :class:`float` 元素的 :class:`list` 的函数::"

#: ../../library/stdtypes.rst:5128
msgid ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"
msgstr ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"

#: ../../library/stdtypes.rst:5131
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is"
" a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"另一个例子是关于 :term:`mapping` 对象的，用到了 "
":class:`dict`，泛型的两个类型参数分别代表了键类型和值类型。本例中的函数需要一个 ``dict``，其键的类型为 "
":class:`str`，值的类型为 :class:`int`:。"

#: ../../library/stdtypes.rst:5136
msgid ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."
msgstr ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."

#: ../../library/stdtypes.rst:5139
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"内置函数 :func:`isinstance` 和 :func:`issubclass` 不接受第二个参数为 ``GenericAlias`` 类型："

#: ../../library/stdtypes.rst:5142
msgid ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"

#: ../../library/stdtypes.rst:5147
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python 运行时不会强制执行 :term:`类型标注 <annotation>`。 这种行为扩展到了泛型及其类型形参。 当由 "
"``GenericAlias`` 创建容器对象时，并不会检查容器中为元素指定的类型。 例如，以下代码虽然不被鼓励，但运行时并不会报错::"

#: ../../library/stdtypes.rst:5153
msgid ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"
msgstr ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"

#: ../../library/stdtypes.rst:5157
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr "不仅如此，在创建对象的过程中，应用了参数后的泛型还会抹除类型参数："

#: ../../library/stdtypes.rst:5160
msgid ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"
msgstr ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"

#: ../../library/stdtypes.rst:5168
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr "在泛型上调用 :func:`repr` 或 :func:`str` 会显示应用参数之后的类型："

#: ../../library/stdtypes.rst:5170
msgid ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"
msgstr ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"

#: ../../library/stdtypes.rst:5176
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"调用泛型容器的 :meth:`~object.__getitem__` 方法将引发异常以防出现 ``dict[str][str]`` 之类的错误::"

#: ../../library/stdtypes.rst:5179
msgid ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"
msgstr ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"

#: ../../library/stdtypes.rst:5184
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"不过，当使用了 :ref:`类型变量 <generics>` 时这种表达式是无效的。 索引必须有与 ``GenericAlias`` 对象的 "
":attr:`~genericalias.__args__` 中的类型变量条目数量相当的元素。 ::"

#: ../../library/stdtypes.rst:5188
msgid ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"
msgstr ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"

#: ../../library/stdtypes.rst:5195
msgid "Standard Generic Classes"
msgstr "标准泛型类"

#: ../../library/stdtypes.rst:5197
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr "下列标准库类支持形参化的泛型。 此列表并不是详尽无遗的。"

#: ../../library/stdtypes.rst:5200
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:5201
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:5202
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:5203
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:5204
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:5205
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:5206
msgid ":class:`asyncio.Future`"
msgstr ":class:`asyncio.Future`"

#: ../../library/stdtypes.rst:5207
msgid ":class:`asyncio.Task`"
msgstr ":class:`asyncio.Task`"

#: ../../library/stdtypes.rst:5208
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:5209
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:5210
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:5211
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:5212
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:5213
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:5214
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:5215
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:5216
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:5217
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:5218
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:5219
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:5220
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:5221
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:5222
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:5223
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:5224
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:5225
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:5226
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:5227
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:5228
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:5229
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:5230
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:5231
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:5232
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:5233
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:5234
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:5235
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:5236
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5237
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5238
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:5239
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:5240
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5241
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:5242
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5243
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:5244
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5245
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5246
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../../library/stdtypes.rst:5247
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5248
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:5249
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5250
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../../library/stdtypes.rst:5251
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5252
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5253
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5254
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5255
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5260
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "``GenericAlias`` 对象的特殊属性"

#: ../../library/stdtypes.rst:5262
msgid "All parameterized generics implement special read-only attributes."
msgstr "应用参数后的泛型都实现了一些特殊的只读属性："

#: ../../library/stdtypes.rst:5266
msgid "This attribute points at the non-parameterized generic class::"
msgstr "本属性指向未应用参数之前的泛型类："

#: ../../library/stdtypes.rst:5268
msgid ""
">>> list[int].__origin__\n"
"<class 'list'>"
msgstr ""
">>> list[int].__origin__\n"
"<class 'list'>"

#: ../../library/stdtypes.rst:5274
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"该属性是传给泛型类的原始 :meth:`~object.__class_getitem__` 的泛型所组成的 :class:`tuple` (长度可能为"
" 1)::"

#: ../../library/stdtypes.rst:5278
msgid ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"
msgstr ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"

#: ../../library/stdtypes.rst:5284
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr "该属性是延迟计算出来的一个元组（可能为空），包含了  ``__args__`` 中的类型变量。"

#: ../../library/stdtypes.rst:5287
msgid ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"
msgstr ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"

#: ../../library/stdtypes.rst:5295
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because "
":class:`typing.ParamSpec` is intended primarily for static type checking."
msgstr ""
"带有参数 :class:`typing.ParamSpec`  的 ``GenericAlias`` 对象，在类型替换后其 "
"``__parameters__`` 可能会不准确，因为 :class:`typing.ParamSpec` 主要用于静态类型检查。"

#: ../../library/stdtypes.rst:5302
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr "一个布尔值，如果别名已使用 ``*`` 运算符进行解包则为真值 (参见 :data:`~typing.TypeVarTuple`)。"

#: ../../library/stdtypes.rst:5310
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` —— 类型注解"

#: ../../library/stdtypes.rst:5311
msgid "Introducing Python's framework for type annotations."
msgstr "介绍 Python 中用于类型标注的框架。"

#: ../../library/stdtypes.rst:5313
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - 标准多项集中的类型提示泛型"

#: ../../library/stdtypes.rst:5314
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method "
":meth:`~object.__class_getitem__`."
msgstr "介绍了对标准库类进行原生形参化的能力，只要它们实现了特殊的类方法 :meth:`~object.__class_getitem__`。"

#: ../../library/stdtypes.rst:5318
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and "
":class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`用户自定义泛型 <user-defined-generics>` 和 "
":class:`typing.Generic`"

#: ../../library/stdtypes.rst:5319
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr "有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。"

#: ../../library/stdtypes.rst:5328
msgid "Union Type"
msgstr "union 类型"

#: ../../library/stdtypes.rst:5334
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended"
" primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to "
":data:`typing.Union`."
msgstr ""
"联合对象包含了在多个 :ref:`类型对象 <bltin-type-objects>` 上执行 ``|`` (按位或) 运算后的值。 这些类型主要用于 "
":term:`类型标注 <annotation>`。与 :data:`typing.Union` 相比，联合类型表达式可以实现更简洁的类型提示语法。"

#: ../../library/stdtypes.rst:5341
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or "
":class:`float`::"
msgstr ""
"定义包含了 *X*、*Y* 等类型的 union 对象。 ``X | Y`` 表示 X 或 Y。相当于 ``typing.Union[X, Y]`` "
"。比如以下函数的参数应为类型  :class:`int` 或 :class:`float` ："

#: ../../library/stdtypes.rst:5346
msgid ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"
msgstr ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"

#: ../../library/stdtypes.rst:5351
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime."
" For unions which include forward references, present the whole expression "
"as a string, e.g. ``\"int | Foo\"``."
msgstr ""
"不可在运行时使用 ``|`` 操作数来定义有一个或多个成员为前向引用的并集。 例如，``int | \"Foo\"``，其中 ``\"Foo\"`` "
"是指向某个尚未定义的类的引用，在运行时将会失败。 对于包括前向引用的并集，请将整个表达式用字符串来表示，例如 ``\"int | Foo\"``。"

#: ../../library/stdtypes.rst:5359
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr "union 对象可与其他 union 对象进行比较。详细结果如下："

#: ../../library/stdtypes.rst:5361
msgid "Unions of unions are flattened::"
msgstr "多次组合的结果会平推："

#: ../../library/stdtypes.rst:5363
msgid "(int | str) | float == int | str | float"
msgstr "(int | str) | float == int | str | float"

#: ../../library/stdtypes.rst:5365
msgid "Redundant types are removed::"
msgstr "冗余的类型会被删除："

#: ../../library/stdtypes.rst:5367
msgid "int | str | int == int | str"
msgstr "int | str | int == int | str"

#: ../../library/stdtypes.rst:5369
msgid "When comparing unions, the order is ignored::"
msgstr "在相互比较时，会忽略顺序："

#: ../../library/stdtypes.rst:5371
msgid "int | str == str | int"
msgstr "int | str == str | int"

#: ../../library/stdtypes.rst:5373
msgid "It is compatible with :data:`typing.Union`::"
msgstr "与 :data:`typing.union` 兼容："

#: ../../library/stdtypes.rst:5375
msgid "int | str == typing.Union[int, str]"
msgstr "int | str == typing.Union[int, str]"

#: ../../library/stdtypes.rst:5377
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Optional 类型可表示为与 ``None`` 的组合。"

#: ../../library/stdtypes.rst:5379
msgid "str | None == typing.Optional[str]"
msgstr "str | None == typing.Optional[str]"

#: ../../library/stdtypes.rst:5384
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a"
" union object::"
msgstr ":func:`isinstance` 和 :func:`issubclass` 也支持 union 对象："

#: ../../library/stdtypes.rst:5387
msgid ""
">>> isinstance(\"\", int | str)\n"
"True"
msgstr ""
">>> isinstance(\"\", int | str)\n"
"True"

#: ../../library/stdtypes.rst:5390
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects"
" cannot be checked::"
msgstr "但是联合对象中的 :ref:`参数化泛型 <types-genericalias>` 将无法被检测::"

#: ../../library/stdtypes.rst:5393
msgid ""
">>> isinstance(1, int | list[int])  # short-circuit evaluation\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance(1, int | list[int])  # 短路求值\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"

#: ../../library/stdtypes.rst:5400
msgid ""
"The user-exposed type for the union object can be accessed from "
":data:`types.UnionType` and used for :func:`isinstance` checks.  An object "
"cannot be instantiated from the type::"
msgstr ""
"union 对象构成的用户类型可以经由 :data:`types.UnionType` 访问，并可用于 :func:`isinstance` 检查。 "
"而不能由类型直接实例化为对象："

#: ../../library/stdtypes.rst:5404
msgid ""
">>> import types\n"
">>> isinstance(int | str, types.UnionType)\n"
"True\n"
">>> types.UnionType()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'types.UnionType' instances"
msgstr ""
">>> import types\n"
">>> isinstance(int | str, types.UnionType)\n"
"True\n"
">>> types.UnionType()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'types.UnionType' instances"

#: ../../library/stdtypes.rst:5413
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"为了支持 ``X | Y`` 语法，类型对象加入了 :meth:`!__or__` 方法。 如果一个元类实现了 "
":meth:`!__or__`，Union 可以重载它："

#: ../../library/stdtypes.rst:5417
msgid ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"
msgstr ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"

#: ../../library/stdtypes.rst:5433
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` —— 提出了 ``X | Y`` 语法和 union 类型。"

#: ../../library/stdtypes.rst:5441
msgid "Other Built-in Types"
msgstr "其他内置类型"

#: ../../library/stdtypes.rst:5443
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr "解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。"

#: ../../library/stdtypes.rst:5450
msgid "Modules"
msgstr "模块"

#: ../../library/stdtypes.rst:5452
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named *foo* "
"to exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"模块唯一的特殊操作是属性访问: ``m.name``，这里 *m* 为一个模块而 *name* 访问定义在 *m* 的符号表中的一个名称。 "
"模块属性可以被赋值。 （请注意 :keyword:`import` 语句严格来说也是对模块对象的一种操作；``import foo`` "
"不要求存在一个名为 *foo* 的模块对象，而是要求存在一个对于名为 *foo* 的模块的 (永久性) *定义*。）"

#: ../../library/stdtypes.rst:5459
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the"
" dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to the"
" :attr:`~object.__dict__` attribute is not possible (you can write "
"``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't "
"write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is "
"not recommended."
msgstr ""
"每个模块都有一个特殊属性 :attr:`~object.__dict__`。 这是包含模块的符号表的字典。 "
"修改此字典将实际改变模块的符号表，但是无法直接对 :attr:`~object.__dict__` 赋值 (你可以写 ``m.__dict__['a']"
" = 1``，这会将 ``m.a`` 定义为 ``1``，但是你不能写 ``m.__dict__ = {}``)。 不建议直接修改 "
":attr:`~object.__dict__`。"

#: ../../library/stdtypes.rst:5467
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"内置于解释器中的模块会写成这样: ``<module 'sys' (built-in)>``。 如果是从一个文件加载，则会写成 ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``。"

#: ../../library/stdtypes.rst:5475
msgid "Classes and Class Instances"
msgstr "类与类实例"

#: ../../library/stdtypes.rst:5477
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "关于这些类型请参阅 :ref:`objects` 和 :ref:`class`。"

#: ../../library/stdtypes.rst:5483
msgid "Functions"
msgstr "函数"

#: ../../library/stdtypes.rst:5485
msgid ""
"Function objects are created by function definitions.  The only operation on"
" a function object is to call it: ``func(argument-list)``."
msgstr "函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: ``func(argument-list)``。"

#: ../../library/stdtypes.rst:5488
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr "实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函数），但实现方式不同，因此对象类型也不同。"

#: ../../library/stdtypes.rst:5492
msgid "See :ref:`function` for more information."
msgstr "更多信息请参阅 :ref:`function`。"

#: ../../library/stdtypes.rst:5498
msgid "Methods"
msgstr "方法"

#: ../../library/stdtypes.rst:5502
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as "
":meth:`append` on lists) and :ref:`class instance method <instance-"
"methods>`. Built-in methods are described with the types that support them."
msgstr ""
"方法是使用属性表示法来调用的函数。 存在两种形式: :ref:`内置方法 <builtin-methods>` (如列表的 "
":meth:`append`) 和 :ref:`类实例方法 <instance-methods>`。 内置方法由支持它们的类型来描述。"

#: ../../library/stdtypes.rst:5507
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called "
":ref:`instance method <instance-methods>`) object. When called, it will add "
"the ``self`` argument to the argument list.  Bound methods have two special "
"read-only attributes: :attr:`m.__self__ <method.__self__>` is the object on "
"which the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, arg-2, "
"..., arg-n)``."
msgstr ""
"如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: :dfn:`绑定方法` (或称 :ref:`实例方法 "
"<instance-methods>`) 对象。 当被调用时，它会将 ``self`` 参数添加到参数列表。 绑定方法具有两个特殊的只读属性: "
":attr:`m.__self__ <method.__self__>` 操作该方法的对象，而 :attr:`m.__func__ "
"<method.__func__>` 是实现该方法的函数。 调用 ``m(arg-1, arg-2, ..., arg-n)`` 完全等价于调用 "
"``m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)``。"

#: ../../library/stdtypes.rst:5518
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`),"
" setting method attributes on bound methods is disallowed.  Attempting to "
"set an attribute on a method results in an :exc:`AttributeError` being "
"raised.  In order to set a method attribute, you need to explicitly set it "
"on the underlying function object:"
msgstr ""
"与 :ref:`函数对象 <user-defined-funcs>` 类似，绑定方法对象也支持获取任意属性。 "
"但是，由于方法属性实际上保存于下层的函数对象中 (:attr:`method.__func__`)，因此不允许设置绑定方法的方法属性。 "
"尝试设置方法的属性将会导致引发 :exc:`AttributeError`。 想要设置方法属性，你必须在下层的函数对象中显式地设置它。"

#: ../../library/stdtypes.rst:5526
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"

#: ../../library/stdtypes.rst:5541
msgid "See :ref:`instance-methods` for more information."
msgstr "请参阅 :ref:`instance-methods` 了解更多信息。"

#: ../../library/stdtypes.rst:5549
msgid "Code Objects"
msgstr "代码对象"

#: ../../library/stdtypes.rst:5555
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\""
" executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their "
":attr:`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""
"代码对象被具体实现用来表示“伪编译”的可执行 Python 代码例如一个函数体。 它们不同于函数对象，因为它们不包含对其全局执行环境的引用。 "
"代码对象由内置的 :func:`compile` 函数返回，并可通过函数对象的 :attr:`~function.__code__` 属性来提取。 "
"另请参阅 :mod:`code` 模块。"

#: ../../library/stdtypes.rst:5562
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"访问 :attr:`~function.__code__` 会引发一个 :ref:`审计事件 <auditing>` "
"``object.__getattr__``，并附带参数 ``obj`` 和 ``\"__code__\"``。"

#: ../../library/stdtypes.rst:5569
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr "可以通过将代码对象（而非源码字符串）传给 :func:`exec` 或 :func:`eval` 内置函数来执行或求值。"

#: ../../library/stdtypes.rst:5572
msgid "See :ref:`types` for more information."
msgstr "更多信息请参阅 :ref:`types`。"

#: ../../library/stdtypes.rst:5578
msgid "Type Objects"
msgstr "类型对象"

#: ../../library/stdtypes.rst:5584
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all"
" standard built-in types."
msgstr ""
"类型对象表示各种对象类型。 对象的类型可通过内置函数 :func:`type` 来获取。 类型没有特殊的操作。 标准库模块 :mod:`types` "
"定义了所有标准内置类型的名称。"

#: ../../library/stdtypes.rst:5589
msgid "Types are written like this: ``<class 'int'>``."
msgstr "类型以这样的写法来表示: ``<class 'int'>``。"

#: ../../library/stdtypes.rst:5595
msgid "The Null Object"
msgstr "空对象"

#: ../../library/stdtypes.rst:5597
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 ``None`` (这是个内置名称)。 "
"``type(None)()`` 会生成同一个单例。"

#: ../../library/stdtypes.rst:5601
msgid "It is written as ``None``."
msgstr "该对象的写法为 ``None``。"

#: ../../library/stdtypes.rst:5608
msgid "The Ellipsis Object"
msgstr "省略符对象"

#: ../../library/stdtypes.rst:5610
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named "
":const:`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the "
":const:`Ellipsis` singleton."
msgstr ""
"此对象常被用于切片 (参见 :ref:`slicings`)。 它不支持任何特殊的操作。 省略符对象只有一种值 :const:`Ellipsis` "
"(这是个内置名称)。 ``type(Ellipsis)()`` 会生成 :const:`Ellipsis` 单例。"

#: ../../library/stdtypes.rst:5615
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "该对象的写法为 ``Ellipsis`` 或 ``...``。"

#: ../../library/stdtypes.rst:5621
msgid "The NotImplemented Object"
msgstr "未实现对象"

#: ../../library/stdtypes.rst:5623
msgid ""
"This object is returned from comparisons and binary operations when they are"
" asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. "
":code:`type(NotImplemented)()` produces the singleton instance."
msgstr ""
"此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。 请参阅 :ref:`comparisons` 了解更多信息。 未实现对象只有一种值 "
":data:`NotImplemented`。 :code:`type(NotImplemented)()` 会生成这个单例。"

#: ../../library/stdtypes.rst:5628
msgid "It is written as :code:`NotImplemented`."
msgstr "其写法为 :code:`NotImplemented`。"

#: ../../library/stdtypes.rst:5634
msgid "Internal Objects"
msgstr "内部对象"

#: ../../library/stdtypes.rst:5636
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""
"相关信息请参阅 :ref:`types`。 其中描述了 :ref:`栈帧对象 <frame-objects>`, :ref:`回溯对象 "
"<traceback-objects>` 以及切片对象等。"

#: ../../library/stdtypes.rst:5644
msgid "Special Attributes"
msgstr "特殊属性"

#: ../../library/stdtypes.rst:5646
msgid ""
"The implementation adds a few special read-only attributes to several object"
" types, where they are relevant.  Some of these are not reported by the "
":func:`dir` built-in function."
msgstr "语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被 :func:`dir` 内置函数所列出。"

#: ../../library/stdtypes.rst:5653
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "类、函数、方法、描述器或生成器实例的名称。"

#: ../../library/stdtypes.rst:5659
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr "类、函数、方法、描述器或生成器实例的 :term:`qualified name`。"

#: ../../library/stdtypes.rst:5667
msgid "The name of the module in which a class or function was defined."
msgstr "类或函数定义所在的模块的名称。"

#: ../../library/stdtypes.rst:5672
msgid ""
"The documentation string of a class or function, or ``None`` if undefined."
msgstr "类或函数的文档字符串，如果未定义则为 ``None``。"

#: ../../library/stdtypes.rst:5677
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and "
":ref:`type aliases <type-aliases>`. For classes and functions that are not "
"generic, this will be an empty tuple."
msgstr ""
"泛型类、函数和 :ref:`类型别名 <type-aliases>` 的 :ref:`类型形参 <type-params>`。 "
"对于非泛型类和函数，这将为空元组。"

#: ../../library/stdtypes.rst:5687
msgid "Integer string conversion length limitation"
msgstr "整数字符串转换长度限制"

#: ../../library/stdtypes.rst:5689
msgid ""
"CPython has a global limit for converting between :class:`int` and "
":class:`str` to mitigate denial of service attacks. This limit *only* "
"applies to decimal or other non-power-of-two number bases. Hexadecimal, "
"octal, and binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython 对于 :class:`int` 和 :class:`str` 之间的转换有一个全局限制以缓解拒绝服务攻击。 此限制 *仅会* "
"作用于十进制或其他以非二的乘方为基数的数字。 十六进制、八进制和二进制转换不受限制。 该限制可以被配置。"

#: ../../library/stdtypes.rst:5694
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that"
" can convert a string to a binary integer or a binary integer to a string in"
" linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
":class:`int` 类型在 CPython 中是存储为二进制形式的任意长度的数字（通常称为“大数字”）。 "
"不存在可在线性时间内将一个字符串转换为二进制整数或将一个二进制整数转换为字符串的算法，*除非* 基数为 2 的乘方。 对于基数为 10 "
"来说已知最好的算法也有亚二次方复杂度。 转换一个大数值如 ``int('1' * 500_000)`` 在快速的 CPU 上也会花费一秒以上的时间。"

#: ../../library/stdtypes.rst:5701
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr "限制转换大小是一项避免 :cve:`2020-10735` 的务实解决方式。"

#: ../../library/stdtypes.rst:5703
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr "此限制会在可能涉及非线性转换算法时作用于输入或输出字符串中的数字型字符数量。 下划线和正负号不计入限制数量。"

#: ../../library/stdtypes.rst:5707
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr "当一个操作会超出限制时，将引发 :exc:`ValueError`:"

#: ../../library/stdtypes.rst:5709
msgid ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited."
msgstr ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # 含义如名称所示，这是默认值。\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # 十六进制数没有限制。"

#: ../../library/stdtypes.rst:5729
msgid ""
"The default limit is 4300 digits as provided in "
":data:`sys.int_info.default_max_str_digits <sys.int_info>`. The lowest limit"
" that can be configured is 640 digits as provided in "
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>`."
msgstr ""
"默认限制为 4300 位即 :data:`sys.int_info.default_max_str_digits <sys.int_info>` 的值。"
" 最低限制可被配置为 640 位即 :data:`sys.int_info.str_digits_check_threshold "
"<sys.int_info>`。"

#: ../../library/stdtypes.rst:5734
msgid "Verification:"
msgstr "验证:"

#: ../../library/stdtypes.rst:5736
msgid ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."
msgstr ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."

#: ../../library/stdtypes.rst:5749
msgid "Affected APIs"
msgstr "受影响的 API"

#: ../../library/stdtypes.rst:5751
msgid ""
"The limitation only applies to potentially slow conversions between "
":class:`int` and :class:`str` or :class:`bytes`:"
msgstr "此限制仅会作用于 :class:`int` 和 :class:`str` 和 :class:`bytes` 之间存在速度变慢可能的转换:"

#: ../../library/stdtypes.rst:5754
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` 默认以 10 为基数。"

#: ../../library/stdtypes.rst:5755
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` 用于所有不为 2 的乘方的基数。"

#: ../../library/stdtypes.rst:5756
msgid "``str(integer)``."
msgstr "``str(integer)``。"

#: ../../library/stdtypes.rst:5757
msgid "``repr(integer)``."
msgstr "``repr(integer)``。"

#: ../../library/stdtypes.rst:5758
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"任何其他目标是以 10 为基数的字符串转换，例如 ``f\"{integer}\"``, ``\"{}\".format(integer)`` 或 "
"``b\"%d\" % integer``。"

#: ../../library/stdtypes.rst:5761
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "此限制不会作用于使用线性算法的函数:"

#: ../../library/stdtypes.rst:5763
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` 中 base 可以为 2, 4, 8, 16 或 32。"

#: ../../library/stdtypes.rst:5764
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` 和 :func:`int.to_bytes`。"

#: ../../library/stdtypes.rst:5765
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`。"

#: ../../library/stdtypes.rst:5766
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` 用于十六进制、八进制和二进制数。"

#: ../../library/stdtypes.rst:5767
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` 至 :class:`float`。"

#: ../../library/stdtypes.rst:5768
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` 至 :class:`decimal.Decimal`。"

#: ../../library/stdtypes.rst:5771
msgid "Configuring the limit"
msgstr "配置限制值"

#: ../../library/stdtypes.rst:5773
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr "在 Python 启动之前你可以使用环境变量或解释器命令行旗标来配置限制值:"

#: ../../library/stdtypes.rst:5776
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`，例如 ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"是将限制设为 640 而 ``PYTHONINTMAXSTRDIGITS=0 python3`` 是禁用此限制。"

#: ../../library/stdtypes.rst:5779
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`，例如 ``python3 -X "
"int_max_str_digits=640``"

#: ../../library/stdtypes.rst:5781
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of "
":envvar:`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If "
"both the env var and the ``-X`` option are set, the ``-X`` option takes "
"precedence. A value of *-1* indicates that both were unset, thus a value of "
":data:`sys.int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` 包含 :envvar:`PYTHONINTMAXSTRDIGITS` 或 "
":option:`-X int_max_str_digits <-X>` 的值。 如果环境变量和 ``-X`` 选项均有设置，则 ``-X`` "
"选项优先。 值为 *-1* 表示两者均未设置，因此会在初始化时使用 "
":data:`sys.int_info.default_max_str_digits` 的值。"

#: ../../library/stdtypes.rst:5787
msgid ""
"From code, you can inspect the current limit and set a new one using these "
":mod:`sys` APIs:"
msgstr "从代码中，你可以检查当前的限制并使用这些 :mod:`sys` API 来设置新值:"

#: ../../library/stdtypes.rst:5790
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have"
" their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` 和 :func:`sys.set_int_max_str_digits` "
"是解释器级限制的读取器和设置器。 子解释器具有它们自己的限制。"

#: ../../library/stdtypes.rst:5794
msgid ""
"Information about the default and minimum can be found in "
":data:`sys.int_info`:"
msgstr "有关默认值和最小值的信息可在 :data:`sys.int_info` 中找到:"

#: ../../library/stdtypes.rst:5796
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ":data:`sys.int_info.default_max_str_digits <sys.int_info>` 是已编译的默认限制。"

#: ../../library/stdtypes.rst:5798
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest"
" accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` "
"是该限制可接受的最低值（禁用该限制的 0 除外）。"

#: ../../library/stdtypes.rst:5805
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or"
" even at installation time - anytime an up to date ``.pyc`` does not already"
" exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"设置较低的限制值 *可能* 导致问题。 虽然不常见，但还是会有在其源代码中包含超出最小阈值的十进制整数常量的代码存在。 "
"设置此限制的一个后果将是包含比此限制长的十进制整数字面值的 Python 源代码将在解析期间遇到错误，通常是在启动时或导入时甚至是在安装时 —— "
"只要对于某个代码还不存在已更新的 ``.pyc`` 就会发生。 一种在包含此类大数值常量的源代码中绕过该问题的办法是将它们转换为不受限制的 ``0x``"
" 十六进制形式。"

#: ../../library/stdtypes.rst:5814
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"如果你使用了较低的限制则请要彻底地测试你的应用程序。 确保你的测试通过环境变量或旗标尽早设置该限制来运行以便在启动期间甚至是在可能唤起 Python "
"来将 ``.py`` 源文件预编译为 ``.pyc`` 文件的任何安装步骤其间应用该限制。"

#: ../../library/stdtypes.rst:5820
msgid "Recommended configuration"
msgstr "推荐配置"

#: ../../library/stdtypes.rst:5822
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"默认的 :data:`sys.int_info.default_max_str_digits` 被预期对于大多数应用程序来说都是合理的。 "
"如果你的应用程序需要不同的限制值，请使用不预设 Python 版本的代码从你的主入口点进行设置，因为这些 API 是在 3.12 "
"之前的版本所发布的安全补丁中添加的。"

#: ../../library/stdtypes.rst:5827
msgid "Example::"
msgstr "示例："

#: ../../library/stdtypes.rst:5829
msgid ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"
msgstr ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"

#: ../../library/stdtypes.rst:5839
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "如果你需要完全禁用它，请将其设为 ``0``。"

#: ../../library/stdtypes.rst:5843
msgid "Footnotes"
msgstr "备注"

#: ../../library/stdtypes.rst:5844
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr "有关这些特殊方法的额外信息可参看 Python 参考指南 (:ref:`customization`)。"

#: ../../library/stdtypes.rst:5847
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``,"
" and similarly for tuples."
msgstr "作为结果，列表 ``[1, 2]`` 与 ``[1.0, 2.0]`` 是相等的，元组的情况也类似。"

#: ../../library/stdtypes.rst:5850
msgid "They must have since the parser can't tell the type of the operands."
msgstr "必须如此，因为解析器无法判断操作数的类型。"

#: ../../library/stdtypes.rst:5852
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"区分大小写的字符是指所属一般类别属性为 \"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase) 或"
" \"Lt\" (Letter, titlecase) 之一的字符。"

#: ../../library/stdtypes.rst:5855
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr "若只是要格式化一个元组，则应提供一个单例元组，其中只包含一个元素，就是需要格式化的那个元组。"

#: ../../library/stdtypes.rst:13
msgid "built-in"
msgstr "内置"

#: ../../library/stdtypes.rst:13 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:393 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:1139
#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4593
#: ../../library/stdtypes.rst:5580
msgid "types"
msgstr "types"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:4593
msgid "statement"
msgstr "statement -- 语句"

#: ../../library/stdtypes.rst:34
msgid "if"
msgstr "if"

#: ../../library/stdtypes.rst:34
msgid "while"
msgstr "while"

#: ../../library/stdtypes.rst:34
msgid "truth"
msgstr "真值"

#: ../../library/stdtypes.rst:34
msgid "value"
msgstr "value"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:817
msgid "Boolean"
msgstr "布尔值"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:393
msgid "operations"
msgstr "操作"

#: ../../library/stdtypes.rst:34
msgid "false"
msgstr "false"

#: ../../library/stdtypes.rst:44
msgid "true"
msgstr "true"

#: ../../library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "None (内置对象)"

#: ../../library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False (内置对象)"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
#: ../../library/stdtypes.rst:123 ../../library/stdtypes.rst:195
#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950
msgid "operator"
msgstr "operator"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "or"
msgstr "or"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "and"
msgstr "and"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "False"
msgstr "False"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "True"
msgstr "True"

#: ../../library/stdtypes.rst:98
msgid "not"
msgstr "not"

#: ../../library/stdtypes.rst:123
msgid "chaining"
msgstr "chaining"

#: ../../library/stdtypes.rst:123
msgid "comparisons"
msgstr "比较"

#: ../../library/stdtypes.rst:123
msgid "comparison"
msgstr "比较"

#: ../../library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: ../../library/stdtypes.rst:123
msgid "< (less)"
msgstr "< (小与)"

#: ../../library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: ../../library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> (大与)"

#: ../../library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: ../../library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: ../../library/stdtypes.rst:123
msgid "is"
msgstr "is"

#: ../../library/stdtypes.rst:123
msgid "is not"
msgstr "is not"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:934 ../../library/stdtypes.rst:1117
#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1260
#: ../../library/stdtypes.rst:1339 ../../library/stdtypes.rst:1383
#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1540
#: ../../library/stdtypes.rst:2684 ../../library/stdtypes.rst:2703
#: ../../library/stdtypes.rst:2810 ../../library/stdtypes.rst:4391
#: ../../library/stdtypes.rst:4593 ../../library/stdtypes.rst:5073
#: ../../library/stdtypes.rst:5330 ../../library/stdtypes.rst:5500
#: ../../library/stdtypes.rst:5544
msgid "object"
msgstr "object -- 对象"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:229 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:335
msgid "numeric"
msgstr "数字"

#: ../../library/stdtypes.rst:163
msgid "objects"
msgstr "objects"

#: ../../library/stdtypes.rst:163
msgid "comparing"
msgstr "比较"

#: ../../library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__() (实例方法)"

#: ../../library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__() (实例方法)"

#: ../../library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__() (实例方法)"

#: ../../library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__() (实例方法)"

#: ../../library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__() (实例方法)"

#: ../../library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__() (实例方法)"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "in"
msgstr "in"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "not in"
msgstr "not in"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
#: ../../library/stdtypes.rst:393
msgid "integer"
msgstr "integer"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "floating-point"
msgstr "浮点数"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "complex number"
msgstr "complex number -- 复数"

#: ../../library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: ../../library/stdtypes.rst:208
msgid "language"
msgstr "语言"

#: ../../library/stdtypes.rst:229
msgid "literals"
msgstr "字面值"

#: ../../library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "十六进制"

#: ../../library/stdtypes.rst:229
msgid "octal"
msgstr "八进制"

#: ../../library/stdtypes.rst:229
msgid "binary"
msgstr "二进制"

#: ../../library/stdtypes.rst:246
msgid "arithmetic"
msgstr "arithmetic"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:4593
#: ../../library/stdtypes.rst:5551 ../../library/stdtypes.rst:5565
#: ../../library/stdtypes.rst:5580
msgid "built-in function"
msgstr "内置函数"

#: ../../library/stdtypes.rst:246
msgid "int"
msgstr "int"

#: ../../library/stdtypes.rst:246
msgid "float"
msgstr "float"

#: ../../library/stdtypes.rst:246
msgid "complex"
msgstr "复数"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2560
#: ../../library/stdtypes.rst:3779
msgid "+ (plus)"
msgstr "+ (加号)"

#: ../../library/stdtypes.rst:246
msgid "unary operator"
msgstr "单目运算符"

#: ../../library/stdtypes.rst:246
msgid "binary operator"
msgstr "双目运算符"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2560
#: ../../library/stdtypes.rst:3779
msgid "- (minus)"
msgstr "- (减号)"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2517
#: ../../library/stdtypes.rst:3736
msgid "* (asterisk)"
msgstr "* (星号)"

#: ../../library/stdtypes.rst:246
msgid "/ (slash)"
msgstr "/ (斜杠)"

#: ../../library/stdtypes.rst:246
msgid "//"
msgstr "//"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2481
#: ../../library/stdtypes.rst:3704
msgid "% (percent)"
msgstr "% (百分号)"

#: ../../library/stdtypes.rst:246
msgid "**"
msgstr "**"

#: ../../library/stdtypes.rst:316 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:4593
msgid "operations on"
msgstr "运算目标"

#: ../../library/stdtypes.rst:316
msgid "conjugate() (complex number method)"
msgstr "conjugate() (复数方法)"

#: ../../library/stdtypes.rst:335 ../../library/stdtypes.rst:1606
#: ../../library/stdtypes.rst:2684 ../../library/stdtypes.rst:5580
msgid "module"
msgstr "module"

#: ../../library/stdtypes.rst:335
msgid "math"
msgstr "math"

#: ../../library/stdtypes.rst:335
msgid "floor() (in module math)"
msgstr "floor() (在 math 模块中)"

#: ../../library/stdtypes.rst:335
msgid "ceil() (in module math)"
msgstr "ceil() (在 math 模块中)"

#: ../../library/stdtypes.rst:335
msgid "trunc() (in module math)"
msgstr "trunc() (在 math 模块中)"

#: ../../library/stdtypes.rst:335
msgid "conversions"
msgstr "转换"

#: ../../library/stdtypes.rst:393
msgid "bitwise"
msgstr "bitwise"

#: ../../library/stdtypes.rst:393
msgid "shifting"
msgstr "移位"

#: ../../library/stdtypes.rst:393
msgid "masking"
msgstr "掩码"

#: ../../library/stdtypes.rst:393
msgid "| (vertical bar)"
msgstr "| (竖线)"

#: ../../library/stdtypes.rst:393
msgid "^ (caret)"
msgstr "^ (脱字号)"

#: ../../library/stdtypes.rst:393
msgid "& (ampersand)"
msgstr "& (和号)"

#: ../../library/stdtypes.rst:393
msgid "<<"
msgstr "<<"

#: ../../library/stdtypes.rst:393
msgid ">>"
msgstr ">>"

#: ../../library/stdtypes.rst:393
msgid "~ (tilde)"
msgstr "~ (波浪号)"

#: ../../library/stdtypes.rst:817
msgid "values"
msgstr "values"

#: ../../library/stdtypes.rst:847
msgid "iterator protocol"
msgstr "迭代器协议"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:4988
msgid "protocol"
msgstr "协议"

#: ../../library/stdtypes.rst:847
msgid "iterator"
msgstr "iterator -- 迭代器"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:934
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1117
#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1154
msgid "sequence"
msgstr "sequence"

#: ../../library/stdtypes.rst:847
msgid "iteration"
msgstr "迭代"

#: ../../library/stdtypes.rst:847
msgid "container"
msgstr "容器"

#: ../../library/stdtypes.rst:847
msgid "iteration over"
msgstr "迭代目标"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:4593
msgid "len"
msgstr "len"

#: ../../library/stdtypes.rst:950
msgid "min"
msgstr "min"

#: ../../library/stdtypes.rst:950
msgid "max"
msgstr "max"

#: ../../library/stdtypes.rst:950
msgid "concatenation"
msgstr "拼接"

#: ../../library/stdtypes.rst:950
msgid "operation"
msgstr "operation"

#: ../../library/stdtypes.rst:950
msgid "repetition"
msgstr "重复"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
msgid "subscript"
msgstr "下标"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
msgid "slice"
msgstr "slice -- 切片"

#: ../../library/stdtypes.rst:950
msgid "count() (sequence method)"
msgstr "count() (序列方法)"

#: ../../library/stdtypes.rst:950
msgid "index() (sequence method)"
msgstr "index() (序列方法)"

#: ../../library/stdtypes.rst:1006
msgid "loop"
msgstr "循环"

#: ../../library/stdtypes.rst:1006
msgid "over mutable sequence"
msgstr "针对可变序列"

#: ../../library/stdtypes.rst:1006
msgid "mutable sequence"
msgstr "可变序列"

#: ../../library/stdtypes.rst:1006
msgid "loop over"
msgstr "循环"

#: ../../library/stdtypes.rst:1117
msgid "immutable"
msgstr "immutable -- 不可变对象"

#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:1339
msgid "tuple"
msgstr "元组"

#: ../../library/stdtypes.rst:1117
msgid "hash"
msgstr "hash"

#: ../../library/stdtypes.rst:1139
msgid "mutable"
msgstr "mutable -- 可变对象"

#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:1260
msgid "list"
msgstr "list"

#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:2684
#: ../../library/stdtypes.rst:2810 ../../library/stdtypes.rst:2882
#: ../../library/stdtypes.rst:3704
msgid "bytearray"
msgstr "bytearray"

#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4593
#: ../../library/stdtypes.rst:5330 ../../library/stdtypes.rst:5580
msgid "type"
msgstr "type"

#: ../../library/stdtypes.rst:1154
msgid "assignment"
msgstr "赋值"

#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4593
msgid "del"
msgstr "del"

#: ../../library/stdtypes.rst:1154
msgid "append() (sequence method)"
msgstr "append() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "clear() (sequence method)"
msgstr "clear() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "copy() (sequence method)"
msgstr "copy() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "extend() (sequence method)"
msgstr "extend() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "insert() (sequence method)"
msgstr "insert() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "pop() (sequence method)"
msgstr "pop() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "remove() (sequence method)"
msgstr "remove() (序列方法)"

#: ../../library/stdtypes.rst:1154
msgid "reverse() (sequence method)"
msgstr "reverse() (序列方法)"

#: ../../library/stdtypes.rst:1383
msgid "range"
msgstr "range"

#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1553
#: ../../library/stdtypes.rst:1598 ../../library/stdtypes.rst:2335
#: ../../library/stdtypes.rst:2481
msgid "string"
msgstr "string"

#: ../../library/stdtypes.rst:1504
msgid "text sequence type"
msgstr "文本序列类型"

#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1553
#: ../../library/stdtypes.rst:1571
msgid "str (built-in class)"
msgstr "str (内置类)"

#: ../../library/stdtypes.rst:1504
msgid "(see also string)"
msgstr "(另请参阅字符串)"

#: ../../library/stdtypes.rst:1540
msgid "io.StringIO"
msgstr "io.StringIO"

#: ../../library/stdtypes.rst:1571 ../../library/stdtypes.rst:2676
msgid "buffer protocol"
msgstr "缓冲协议"

#: ../../library/stdtypes.rst:1571 ../../library/stdtypes.rst:2684
#: ../../library/stdtypes.rst:2703 ../../library/stdtypes.rst:2882
#: ../../library/stdtypes.rst:3704
msgid "bytes"
msgstr "字节串"

#: ../../library/stdtypes.rst:1598 ../../library/stdtypes.rst:2882
msgid "methods"
msgstr "方法"

#: ../../library/stdtypes.rst:1606
msgid "re"
msgstr "re"

#: ../../library/stdtypes.rst:2149 ../../library/stdtypes.rst:3558
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/stdtypes.rst:2149
msgid "str.splitlines method"
msgstr "str.splitlines 方法"

#: ../../library/stdtypes.rst:2335
msgid "! formatted string literal"
msgstr "! 格式化字符串字面值"

#: ../../library/stdtypes.rst:2335
msgid "formatted string literals"
msgstr "格式化字符串字面值"

#: ../../library/stdtypes.rst:2335
msgid "! f-string"
msgstr "! f-字符串"

#: ../../library/stdtypes.rst:2335
msgid "f-strings"
msgstr "f 字符串"

#: ../../library/stdtypes.rst:2335
msgid "fstring"
msgstr "fstring"

#: ../../library/stdtypes.rst:2335
msgid "interpolated string literal"
msgstr "插值字符串字面值"

#: ../../library/stdtypes.rst:2335
msgid "formatted literal"
msgstr "格式化字面值"

#: ../../library/stdtypes.rst:2335
msgid "interpolated literal"
msgstr "插值字面值"

#: ../../library/stdtypes.rst:2335
msgid "{} (curly brackets)"
msgstr "{} (花括号)"

#: ../../library/stdtypes.rst:2335
msgid "in formatted string literal"
msgstr "格式字符串字面值形式"

#: ../../library/stdtypes.rst:2335
msgid "! (exclamation mark)"
msgstr "! (叹号)"

#: ../../library/stdtypes.rst:2335
msgid ": (colon)"
msgstr ": (冒号)"

#: ../../library/stdtypes.rst:2335
msgid "= (equals)"
msgstr "= (等于号)"

#: ../../library/stdtypes.rst:2335
msgid "for help in debugging using string literals"
msgstr "用于帮助使用字符串字面值进行调试"

#: ../../library/stdtypes.rst:2481
msgid "formatting, string (%)"
msgstr "格式化, 字符串 (%)"

#: ../../library/stdtypes.rst:2481
msgid "interpolation, string (%)"
msgstr "插值, 字符串 (%)"

#: ../../library/stdtypes.rst:2481
msgid "formatting, printf"
msgstr "格式化, printf"

#: ../../library/stdtypes.rst:2481
msgid "interpolation, printf"
msgstr "插值, printf"

#: ../../library/stdtypes.rst:2481 ../../library/stdtypes.rst:3704
msgid "printf-style formatting"
msgstr "printf 风格的格式化"

#: ../../library/stdtypes.rst:2481 ../../library/stdtypes.rst:3704
msgid "sprintf-style formatting"
msgstr "sprintf 风格的格式化"

#: ../../library/stdtypes.rst:2517 ../../library/stdtypes.rst:3736
msgid "() (parentheses)"
msgstr "() (圆括号)"

#: ../../library/stdtypes.rst:2517 ../../library/stdtypes.rst:2560
#: ../../library/stdtypes.rst:3736 ../../library/stdtypes.rst:3779
msgid "in printf-style formatting"
msgstr "使用 printf 风格的格式化"

#: ../../library/stdtypes.rst:2517 ../../library/stdtypes.rst:3736
msgid ". (dot)"
msgstr ". (点号)"

#: ../../library/stdtypes.rst:2560 ../../library/stdtypes.rst:3779
msgid "# (hash)"
msgstr "# (hash)"

#: ../../library/stdtypes.rst:2560 ../../library/stdtypes.rst:3779
msgid "space"
msgstr "space"

#: ../../library/stdtypes.rst:2676
msgid "binary sequence types"
msgstr "二进制序列类型"

#: ../../library/stdtypes.rst:2684
msgid "memoryview"
msgstr "memoryview"

#: ../../library/stdtypes.rst:2684
msgid "array"
msgstr "array"

#: ../../library/stdtypes.rst:3558
msgid "bytes.splitlines method"
msgstr "bytes.splitlines 方法"

#: ../../library/stdtypes.rst:3558
msgid "bytearray.splitlines method"
msgstr "bytearray.splitlines 方法"

#: ../../library/stdtypes.rst:3704
msgid "formatting"
msgstr "格式化"

#: ../../library/stdtypes.rst:3704
msgid "bytes (%)"
msgstr "bytes (%)"

#: ../../library/stdtypes.rst:3704
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: ../../library/stdtypes.rst:3704
msgid "interpolation"
msgstr "插值"

#: ../../library/stdtypes.rst:4391
msgid "set"
msgstr "set"

#: ../../library/stdtypes.rst:4593
msgid "mapping"
msgstr "mapping -- 映射"

#: ../../library/stdtypes.rst:4593
msgid "dictionary"
msgstr "dictionary -- 字典"

#: ../../library/stdtypes.rst:4703
msgid "__missing__()"
msgstr "__missing__()"

#: ../../library/stdtypes.rst:4988
msgid "context manager"
msgstr "context manager -- 上下文管理器"

#: ../../library/stdtypes.rst:4988
msgid "context management protocol"
msgstr "上下文管理协议"

#: ../../library/stdtypes.rst:4988
msgid "context management"
msgstr "上下文管理"

#: ../../library/stdtypes.rst:5061
msgid "annotation"
msgstr "annotation -- 标注"

#: ../../library/stdtypes.rst:5061
msgid "type annotation; type hint"
msgstr "类型标注; 类型提示type hint"

#: ../../library/stdtypes.rst:5073
msgid "GenericAlias"
msgstr "GenericAlias"

#: ../../library/stdtypes.rst:5073
msgid "Generic"
msgstr "Generic"

#: ../../library/stdtypes.rst:5073
msgid "Alias"
msgstr "Alias"

#: ../../library/stdtypes.rst:5330
msgid "Union"
msgstr "Union"

#: ../../library/stdtypes.rst:5330
msgid "union"
msgstr "union"

#: ../../library/stdtypes.rst:5500
msgid "method"
msgstr "method -- 方法"

#: ../../library/stdtypes.rst:5544
msgid "code"
msgstr "code -- 代码"

#: ../../library/stdtypes.rst:5544
msgid "code object"
msgstr "代码对象"

#: ../../library/stdtypes.rst:5551
msgid "compile"
msgstr "编译"

#: ../../library/stdtypes.rst:5551
msgid "__code__ (function object attribute)"
msgstr "__code__ (函数对象属性)"

#: ../../library/stdtypes.rst:5565
msgid "exec"
msgstr "exec"

#: ../../library/stdtypes.rst:5565
msgid "eval"
msgstr "eval"

#: ../../library/stdtypes.rst:5604
msgid "..."
msgstr "..."

#: ../../library/stdtypes.rst:5604
msgid "ellipsis literal"
msgstr "省略符字面值"
