# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-12 19:15+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/bdb.rst:2
msgid ":mod:`bdb` --- Debugger framework"
msgstr ":mod:`bdb` --- 调试器框架"

#: ../../library/bdb.rst:7
msgid "**Source code:** :source:`Lib/bdb.py`"
msgstr "**源代码:** :source:`Lib/bdb.py`"

#: ../../library/bdb.rst:11
msgid ""
"The :mod:`bdb` module handles basic debugger functions, like setting "
"breakpoints or managing execution via the debugger."
msgstr ":mod:`bdb` 模块处理基本的调试器函数，例如设置中断点或通过调试器来管理执行。"

#: ../../library/bdb.rst:14
msgid "The following exception is defined:"
msgstr "定义了以下异常："

#: ../../library/bdb.rst:18
msgid "Exception raised by the :class:`Bdb` class for quitting the debugger."
msgstr "由 :class:`Bdb` 类引发用于退出调试器的异常。"

#: ../../library/bdb.rst:21
msgid "The :mod:`bdb` module also defines two classes:"
msgstr ":mod:`bdb` 模块还定义了两个类:"

#: ../../library/bdb.rst:25
msgid ""
"This class implements temporary breakpoints, ignore counts, disabling and "
"(re-)enabling, and conditionals."
msgstr "这个类实现了临时性中断点、忽略计数、禁用与（重新）启用，以及条件设置等。"

#: ../../library/bdb.rst:28
msgid ""
"Breakpoints are indexed by number through a list called :attr:`bpbynumber` "
"and by ``(file, line)`` pairs through :attr:`bplist`.  The former points to "
"a single instance of class :class:`Breakpoint`.  The latter points to a list"
" of such instances since there may be more than one breakpoint per line."
msgstr ""
"中断点通过一个名为 :attr:`bpbynumber` 的列表基于数字并通过 :attr:`bplist` 基于 ``(file, line)`` "
"对进行索引。 前者指向一个 :class:`Breakpoint` 类的单独实例。 后者指向一个由这种实例组成的列表，因为在每一行中可能存在多个中断点。"

#: ../../library/bdb.rst:33
msgid ""
"When creating a breakpoint, its associated :attr:`file name <file>` should "
"be in canonical form.  If a :attr:`funcname` is defined, a breakpoint "
":attr:`hit <hits>` will be counted when the first line of that function is "
"executed.  A :attr:`conditional <cond>` breakpoint always counts a "
":attr:`hit <hits>`."
msgstr ""
"当创建一个中断点时，它所关联的 :attr:`文件名 <file>` 应当为规范形式。 如果定义了 "
":attr:`funcname`，则当该函数的第一行被执行时将增加一次中断点 :attr:`命中 <hits>` 次数。 :attr:`有条件的 "
"<cond>` 中断点将总是会计入 :attr:`命中 <hits>` 次数。"

#: ../../library/bdb.rst:39
msgid ":class:`Breakpoint` instances have the following methods:"
msgstr ":class:`Breakpoint` 的实例具有下列方法:"

#: ../../library/bdb.rst:43
msgid ""
"Delete the breakpoint from the list associated to a file/line.  If it is the"
" last breakpoint in that position, it also deletes the entry for the "
"file/line."
msgstr "从关联到文件/行的列表中删除此中断点。 如果它是该位置上的最后一个中断点，还将删除相应的文件/行条目。"

#: ../../library/bdb.rst:50
msgid "Mark the breakpoint as enabled."
msgstr "将此中断点标记为启用。"

#: ../../library/bdb.rst:55
msgid "Mark the breakpoint as disabled."
msgstr "将此中断点标记为禁用。"

#: ../../library/bdb.rst:60
msgid ""
"Return a string with all the information about the breakpoint, nicely "
"formatted:"
msgstr "返回一个带有关于此中断点的所有信息的，格式良好的字符串:"

#: ../../library/bdb.rst:63
msgid "Breakpoint number."
msgstr "中断点编号 。"

#: ../../library/bdb.rst:64
msgid "Temporary status (del or keep)."
msgstr "临时状态（删除或保留）。"

#: ../../library/bdb.rst:65
msgid "File/line position."
msgstr "文件/行位置。"

#: ../../library/bdb.rst:66
msgid "Break condition."
msgstr "中断条件"

#: ../../library/bdb.rst:67
msgid "Number of times to ignore."
msgstr "要忽略的次数。"

#: ../../library/bdb.rst:68
msgid "Number of times hit."
msgstr "命中的次数。"

#: ../../library/bdb.rst:74
msgid ""
"Print the output of :meth:`bpformat` to the file *out*, or if it is "
"``None``, to standard output."
msgstr ""
"将 :meth:`bpformat` 的输出打印到文件 *out*，或者如果为 ``None`` 则打印到标准输出。, to standard "
"output."

#: ../../library/bdb.rst:77
msgid ":class:`Breakpoint` instances have the following attributes:"
msgstr ":class:`Breakpoint` 实例具有以下属性:"

#: ../../library/bdb.rst:81
msgid "File name of the :class:`Breakpoint`."
msgstr ":class:`Breakpoint` 的文件名。"

#: ../../library/bdb.rst:85
msgid "Line number of the :class:`Breakpoint` within :attr:`file`."
msgstr ":class:`Breakpoint` 在 :attr:`file` 中的行号。"

#: ../../library/bdb.rst:89
msgid "True if a :class:`Breakpoint` at (file, line) is temporary."
msgstr "如果 (file, line) 上的 :class:`Breakpoint` 是临时性的则返回 True。"

#: ../../library/bdb.rst:93
msgid "Condition for evaluating a :class:`Breakpoint` at (file, line)."
msgstr "在 (file, line) 上对 :class:`Breakpoint` 求值的条件。"

#: ../../library/bdb.rst:97
msgid ""
"Function name that defines whether a :class:`Breakpoint` is hit upon "
"entering the function."
msgstr "用于定义在进入函数时一个 :class:`Breakpoint` 是否命中的函数的名称。"

#: ../../library/bdb.rst:102
msgid "True if :class:`Breakpoint` is enabled."
msgstr "如果 :class:`Breakpoint` 被启用则为 True。"

#: ../../library/bdb.rst:106
msgid "Numeric index for a single instance of a :class:`Breakpoint`."
msgstr "一个 :class:`Breakpoint` 单独实例的数字索引。"

#: ../../library/bdb.rst:110
msgid ""
"Dictionary of :class:`Breakpoint` instances indexed by (:attr:`file`, "
":attr:`line`) tuples."
msgstr "以 (:attr:`file`, :attr:`line`) 元组作为索引的 :class:`Breakpoint` 实例的字典。"

#: ../../library/bdb.rst:115
msgid "Number of times to ignore a :class:`Breakpoint`."
msgstr "忽略一个 :class:`Breakpoint` 的次数。"

#: ../../library/bdb.rst:119
msgid "Count of the number of times a :class:`Breakpoint` has been hit."
msgstr "命中一个 :class:`Breakpoint` 的次数统计。"

#: ../../library/bdb.rst:123
msgid "The :class:`Bdb` class acts as a generic Python debugger base class."
msgstr ":class:`Bdb` 类是作为通用的 Python 调试器基类。"

#: ../../library/bdb.rst:125
msgid ""
"This class takes care of the details of the trace facility; a derived class "
"should implement user interaction.  The standard debugger class "
"(:class:`pdb.Pdb`) is an example."
msgstr "这个类负责追踪工具的细节；所派生的类应当实现用户交互。 标准调试器类 (:class:`pdb.Pdb`) 就是一个例子。"

#: ../../library/bdb.rst:129
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name"
" patterns.  The debugger will not step into frames that originate in a "
"module that matches one of these patterns. Whether a frame is considered to "
"originate in a certain module is determined by the ``__name__`` in the frame"
" globals."
msgstr ""
"如果给出了 *skip* 参数，它必须是一个包含 glob 风格的模块名称模式的可迭代对象。 调试器将不会步进到来自与这些模式相匹配的模块的帧。 "
"一个帧是否会被视为来自特定的模块是由帧的 ``__name__`` 全局变量来确定的。"

#: ../../library/bdb.rst:135
msgid "The *skip* argument."
msgstr "*skip* 参数。"

#: ../../library/bdb.rst:138
msgid ""
"The following methods of :class:`Bdb` normally don't need to be overridden."
msgstr ":class:`Bdb` 的以下方法通常不需要被重写。"

#: ../../library/bdb.rst:142
msgid "Return canonical form of *filename*."
msgstr "返回 *filename* 的规范形式。"

#: ../../library/bdb.rst:144
msgid ""
"For real file names, the canonical form is an operating-system-dependent, "
":func:`case-normalized <os.path.normcase>` :func:`absolute path "
"<os.path.abspath>`. A *filename* with angle brackets, such as "
"``\"<stdin>\"`` generated in interactive mode, is returned unchanged."
msgstr ""
"对于真实的文件名称，此规范形式是一个依赖于具体操作系统的，:func:`大小写规范的 <os.path.normcase>` :func:`绝对路径 "
"<os.path.abspath>`。 在交互模式下生成的带有尖括号的 *filename*，如 ``\"<stdin>\"``，会被不加修改地返回。"

#: ../../library/bdb.rst:151
msgid ""
"Set the :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` and "
":attr:`quitting` attributes with values ready to start debugging."
msgstr ""
"将 :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` 和 "
":attr:`quitting` 属性设置为准备开始调试的值。"

#: ../../library/bdb.rst:156
msgid ""
"This function is installed as the trace function of debugged frames.  Its "
"return value is the new trace function (in most cases, that is, itself)."
msgstr "此函数被安装为被调试帧的追踪函数。 它的返回值是新的追踪函数（在大多数情况下就是它自身）。"

#: ../../library/bdb.rst:159
msgid ""
"The default implementation decides how to dispatch a frame, depending on the"
" type of event (passed as a string) that is about to be executed. *event* "
"can be one of the following:"
msgstr "默认实现会决定如何分派帧，这取决于即将被执行的事件的类型（作为字符串传入）。 *event* 可以是下列值之一:"

#: ../../library/bdb.rst:163
msgid "``\"line\"``: A new line of code is going to be executed."
msgstr "``\"line\"``: 一个新的代码行即将被执行。"

#: ../../library/bdb.rst:164
msgid ""
"``\"call\"``: A function is about to be called, or another code block "
"entered."
msgstr "``\"call\"``: 一个函数即将被调用，或者进入了另一个代码块。"

#: ../../library/bdb.rst:166
msgid "``\"return\"``: A function or other code block is about to return."
msgstr "``\"return\"``: 一个函数或其他代码块即将返回。"

#: ../../library/bdb.rst:167
msgid "``\"exception\"``: An exception has occurred."
msgstr "``\"exception\"``: 一个异常已发生。"

#: ../../library/bdb.rst:168
msgid "``\"c_call\"``: A C function is about to be called."
msgstr "``\"c_call\"``: 一个 C 函数即将被调用。"

#: ../../library/bdb.rst:169
msgid "``\"c_return\"``: A C function has returned."
msgstr "``\"c_return\"``: 一个 C 函数已返回。"

#: ../../library/bdb.rst:170
msgid "``\"c_exception\"``: A C function has raised an exception."
msgstr "``\"c_exception\"``: 一个 C 函数引发了异常。"

#: ../../library/bdb.rst:172
msgid ""
"For the Python events, specialized functions (see below) are called.  For "
"the C events, no action is taken."
msgstr "对于 Python 事件，调用了专门的函数（见下文）。 对于 C 事件，不执行任何操作。"

#: ../../library/bdb.rst:175
msgid "The *arg* parameter depends on the previous event."
msgstr "*arg* 形参取决于之前的事件。"

#: ../../library/bdb.rst:177
msgid ""
"See the documentation for :func:`sys.settrace` for more information on the "
"trace function.  For more information on code and frame objects, refer to "
":ref:`types`."
msgstr ""
"请参阅 :func:`sys.settrace` 的文档了解追踪函数的更多信息。 对于代码和帧对象的详情，请参考 :ref:`types`。"

#: ../../library/bdb.rst:183
msgid ""
"If the debugger should stop on the current line, invoke the "
":meth:`user_line` method (which should be overridden in subclasses). Raise a"
" :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can"
" be set from :meth:`user_line`).  Return a reference to the "
":meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"如果调试器应当在当前行上停止，则发起调用 :meth:`user_line` 方法（该方法应当在子类中被重写）。 如果设置了 "
":attr:`Bdb.quitting` 旗标（可以通过 :meth:`user_line` 设置）则将引发 :exc:`BdbQuit` 异常。 "
"返回一个对 :meth:`trace_dispatch` 方法的引用以便在该作用域内进一步地追踪。"

#: ../../library/bdb.rst:191
msgid ""
"If the debugger should stop on this function call, invoke the "
":meth:`user_call` method (which should be overridden in subclasses). Raise a"
" :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can"
" be set from :meth:`user_call`).  Return a reference to the "
":meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"如果调试器应当在此函数调用上停止，则发起调用 :meth:`user_call` 方法（该方法应当在子类中被重写）。 如果设置了 "
":attr:`Bdb.quitting` 旗标（可以通过 :meth:`user_call` 设置）则将引发 :exc:`BdbQuit` 异常。 "
"返回一个对 :meth:`trace_dispatch` 方法的引用以便在该作用域内进一步地追踪。"

#: ../../library/bdb.rst:199
msgid ""
"If the debugger should stop on this function return, invoke the "
":meth:`user_return` method (which should be overridden in subclasses). Raise"
" a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which "
"can be set from :meth:`user_return`).  Return a reference to the "
":meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"如果调试器应当在此函数返回时停止，则发起调用 :meth:`user_return` 方法（该方法应当在子类中被重写）。 如果设置了 "
":attr:`Bdb.quitting` 旗标（可以通过 :meth:`user_return` 设置）则将引发 :exc:`BdbQuit` 异常。 "
"返回一个对 :meth:`trace_dispatch` 方法的引用以便在该作用域内进一步地追踪。"

#: ../../library/bdb.rst:207
msgid ""
"If the debugger should stop at this exception, invokes the "
":meth:`user_exception` method (which should be overridden in subclasses). "
"Raise a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set "
"(which can be set from :meth:`user_exception`).  Return a reference to the "
":meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"如果调试器应当在此异常上停止，则发起调用 :meth:`user_exception` 方法（该方法应当在子类中被重写）。 如果设置了 "
":attr:`Bdb.quitting` 旗标（可以通过 :meth:`user_exception` 设置）则将引发 :exc:`BdbQuit` "
"异常。 返回一个对 :meth:`trace_dispatch` 方法的引用以便在该作用域内进一步地追踪。"

#: ../../library/bdb.rst:213
msgid ""
"Normally derived classes don't override the following methods, but they may "
"if they want to redefine the definition of stopping and breakpoints."
msgstr "通常情况下派生的类不会重写下列方法，但是如果想要重新定义停止和中断点的定义则可能会重写它们。"

#: ../../library/bdb.rst:218
msgid "Return True if *module_name* matches any skip pattern."
msgstr "如果 *module_name* 匹配到任何跳过模式则返回 True。"

#: ../../library/bdb.rst:222
msgid "Return True if *frame* is below the starting frame in the stack."
msgstr "如果 *frame* 在栈的起始帧之下则返回 True。"

#: ../../library/bdb.rst:226
msgid "Return True if there is an effective breakpoint for this line."
msgstr "如果该行有生效的中断点则返回 True。"

#: ../../library/bdb.rst:228
msgid ""
"Check whether a line or function breakpoint exists and is in effect.  Delete"
" temporary breakpoints based on information from :func:`effective`."
msgstr "检测某行或某函数是否存在中断点且处于生效状态。 基于来自 :func:`effective` 的信息删除临时中断点。"

#: ../../library/bdb.rst:233
msgid "Return True if any breakpoint exists for *frame*'s filename."
msgstr "如果存在任何针对 *frame* 的文件名的中断点则返回 True。"

#: ../../library/bdb.rst:235
msgid ""
"Derived classes should override these methods to gain control over debugger "
"operation."
msgstr "派生的类应当重写这些方法以获取调试器操作的控制权。"

#: ../../library/bdb.rst:240
msgid ""
"Called from :meth:`dispatch_call` if a break might stop inside the called "
"function."
msgstr "如果中断可能在被调用的函数内停止则会从 :meth:`dispatch_call` 来调用。"

#: ../../library/bdb.rst:245
msgid ""
"Called from :meth:`dispatch_line` when either :meth:`stop_here` or "
":meth:`break_here` returns ``True``."
msgstr ""
"当 :meth:`stop_here` 或 :meth:`break_here` 返回 ``True`` 时则会从 "
":meth:`dispatch_line` 来调用。"

#: ../../library/bdb.rst:250
msgid ""
"Called from :meth:`dispatch_return` when :meth:`stop_here` returns ``True``."
msgstr "当 :meth:`stop_here` 返回 ``True`` 时则会从 :meth:`dispatch_return` 来调用。"

#: ../../library/bdb.rst:254
msgid ""
"Called from :meth:`dispatch_exception` when :meth:`stop_here` returns "
"``True``."
msgstr "当 :meth:`stop_here` 返回 ``True`` 时则会从 :meth:`dispatch_exception` 来调用。"

#: ../../library/bdb.rst:259
msgid "Handle how a breakpoint must be removed when it is a temporary one."
msgstr "处理当一个中断点属于临时性中断点时是否必须要移除它。"

#: ../../library/bdb.rst:261
msgid "This method must be implemented by derived classes."
msgstr "此方法必须由派生类来实现。"

#: ../../library/bdb.rst:264
msgid ""
"Derived classes and clients can call the following methods to affect the "
"stepping state."
msgstr "派生类与客户端可以调用以下方法来影响步进状态。"

#: ../../library/bdb.rst:269
msgid "Stop after one line of code."
msgstr "在一行代码之后停止。"

#: ../../library/bdb.rst:273
msgid "Stop on the next line in or below the given frame."
msgstr "在给定的帧以内或以下的下一行停止。"

#: ../../library/bdb.rst:277
msgid "Stop when returning from the given frame."
msgstr "当从给定的帧返回时停止。"

#: ../../library/bdb.rst:281
msgid ""
"Stop when the line with the *lineno* greater than the current one is reached"
" or when returning from current frame."
msgstr "在 *lineno* 行大于当前所到达的行或者在从当前帧返回时停止。"

#: ../../library/bdb.rst:286
msgid ""
"Start debugging from *frame*.  If *frame* is not specified, debugging starts"
" from caller's frame."
msgstr "从 *frame* 开始调试。 如果未指定 *frame*，则从调用者的帧开始调试。"

#: ../../library/bdb.rst:291
msgid ""
"Stop only at breakpoints or when finished.  If there are no breakpoints, set"
" the system trace function to ``None``."
msgstr "仅在中断点上或是当结束时停止。 如果不存在中断点，则将系统追踪函数设为 ``None``。"

#: ../../library/bdb.rst:296
msgid ""
"Set the :attr:`quitting` attribute to ``True``.  This raises :exc:`BdbQuit` "
"in the next call to one of the :meth:`dispatch_\\*` methods."
msgstr ""
"将 :attr:`quitting` 属性设为 ``True``。 这将在对某个 :meth:`dispatch_\\*` 方法的下一次调用中引发 "
":exc:`BdbQuit`。"

#: ../../library/bdb.rst:300
msgid ""
"Derived classes and clients can call the following methods to manipulate "
"breakpoints.  These methods return a string containing an error message if "
"something went wrong, or ``None`` if all is well."
msgstr ""
"派生的类和客户端可以调用下列方法来操纵中断点。 如果出现错误则这些方法将返回一个包含错误消息的字符串，或者如果一切正常则返回 ``None``。"

#: ../../library/bdb.rst:306
msgid ""
"Set a new breakpoint.  If the *lineno* line doesn't exist for the *filename*"
" passed as argument, return an error message.  The *filename* should be in "
"canonical form, as described in the :meth:`canonic` method."
msgstr ""
"设置一个新的中断点。 如果对于作为参数传入的 *filename* 不存在 *lineno*，则返回一条错误消息。 *filename* "
"应为规范的形式，如在 :meth:`canonic` 方法中描述的。"

#: ../../library/bdb.rst:312
msgid ""
"Delete the breakpoints in *filename* and *lineno*.  If none were set, return"
" an error message."
msgstr "删除位于 *filename* 和 *lineno* 的中断点。 如果未设置过中断点，则返回一条错误消息。"

#: ../../library/bdb.rst:317
msgid ""
"Delete the breakpoint which has the index *arg* in the "
":attr:`Breakpoint.bpbynumber`.  If *arg* is not numeric or out of range, "
"return an error message."
msgstr ""
"删除 :attr:`Breakpoint.bpbynumber` 中索引号为 *arg* 的中断点。 如果 *arg* "
"不是数字或超出范围，则返回一条错误消息。"

#: ../../library/bdb.rst:323
msgid ""
"Delete all breakpoints in *filename*.  If none were set, return an error "
"message."
msgstr "删除位于 *filename* 的所有中断点。 如果未设置过中断点，则返回一条错误消息。"

#: ../../library/bdb.rst:328
msgid ""
"Delete all existing breakpoints.  If none were set, return an error message."
msgstr "删除所有现存的中断点。 如果未设置过中断点，则返回一条错误消息。"

#: ../../library/bdb.rst:333
msgid ""
"Return a breakpoint specified by the given number.  If *arg* is a string, it"
" will be converted to a number.  If *arg* is a non-numeric string, if the "
"given breakpoint never existed or has been deleted, a :exc:`ValueError` is "
"raised."
msgstr ""
"返回由指定数字所指明的中断点。 如果 *arg* 是一个字符串，它将被转换为一个数字。 如果 *arg* "
"不是一个表示数字的字符串，如果给定的中断点不存在或者已被删除，则会引发 :exc:`ValueError`。"

#: ../../library/bdb.rst:342
msgid "Return True if there is a breakpoint for *lineno* in *filename*."
msgstr "如果 *filename* 中的 *lineno* 上有中断点则返回 True。"

#: ../../library/bdb.rst:346
msgid ""
"Return all breakpoints for *lineno* in *filename*, or an empty list if none "
"are set."
msgstr "返回 *filename* 中在 *lineno* 上的所有中断点，或者如果未设置任何中断点则返回一个空列表。"

#: ../../library/bdb.rst:351
msgid ""
"Return all breakpoints in *filename*, or an empty list if none are set."
msgstr "返回 *filename* 中的所有中断点，或者如果未设置任何中断点则返回一个空列表。"

#: ../../library/bdb.rst:355
msgid "Return all breakpoints that are set."
msgstr "返回已设置的所有中断点。"

#: ../../library/bdb.rst:358
msgid ""
"Derived classes and clients can call the following methods to get a data "
"structure representing a stack trace."
msgstr "派生类与客户端可以调用以下方法来获取一个代表栈回溯信息的数组结构。"

#: ../../library/bdb.rst:363
msgid "Return a list of (frame, lineno) tuples in a stack trace, and a size."
msgstr "返回一个栈回溯中 (frame, lineno) 元组的列表，及一个大小值。"

#: ../../library/bdb.rst:365
msgid ""
"The most recently called frame is last in the list. The size is the number "
"of frames below the frame where the debugger was invoked."
msgstr "最近调用的帧将排在列表的末尾。 大小值即调试器被发起调用所在帧之下的帧数量。"

#: ../../library/bdb.rst:370
msgid ""
"Return a string with information about a stack entry, which is a ``(frame, "
"lineno)`` tuple.  The return string contains:"
msgstr "返回一个字符串，其内容为有关以 ``(frame, lineno)`` 元组表示的特定栈条目的信息。 返回的字符串包含:"

#: ../../library/bdb.rst:373
msgid "The canonical filename which contains the frame."
msgstr "包含该帧的规范文件名。"

#: ../../library/bdb.rst:374
msgid "The function name or ``\"<lambda>\"``."
msgstr "函数名称或 ``\"<lambda>\"``。"

#: ../../library/bdb.rst:375
msgid "The input arguments."
msgstr "输入参数。"

#: ../../library/bdb.rst:376
msgid "The return value."
msgstr "返回值。"

#: ../../library/bdb.rst:377
msgid "The line of code (if it exists)."
msgstr "代码的行（如果存在）。"

#: ../../library/bdb.rst:380
msgid ""
"The following two methods can be called by clients to use a debugger to "
"debug a :term:`statement`, given as a string."
msgstr "以下两个方法可由客户端调用以使用一个调试器来调试一条以字符串形式给出的 :term:`statement`。"

#: ../../library/bdb.rst:385
msgid ""
"Debug a statement executed via the :func:`exec` function.  *globals* "
"defaults to :attr:`__main__.__dict__`, *locals* defaults to *globals*."
msgstr ""
"调试一条通过 :func:`exec` 函数执行的语句。 *globals* 默认为 "
":attr:`__main__.__dict__`，*locals* 默认为 *globals*。"

#: ../../library/bdb.rst:390
msgid ""
"Debug an expression executed via the :func:`eval` function.  *globals* and "
"*locals* have the same meaning as in :meth:`run`."
msgstr ""
"调试一条通过 :func:`eval` 函数执行的表达式。 *globals* 和 *locals* 的含义与在 :meth:`run` 中的相同。"

#: ../../library/bdb.rst:395
msgid "For backwards compatibility.  Calls the :meth:`run` method."
msgstr "为了保证向下兼容性。 调用 :meth:`run` 方法。"

#: ../../library/bdb.rst:399
msgid "Debug a single function call, and return its result."
msgstr "调试一个单独的函数调用，并返回其结果。"

#: ../../library/bdb.rst:402
msgid "Finally, the module defines the following functions:"
msgstr "最后，这个模块定义了以下函数:"

#: ../../library/bdb.rst:406
msgid ""
"Return True if we should break here, depending on the way the "
":class:`Breakpoint` *b* was set."
msgstr "如果要在此中断则返回 True，具体取决于 :class:`Breakpoint` *b* 的设置方式。"

#: ../../library/bdb.rst:409
msgid ""
"If it was set via line number, it checks if :attr:`b.line "
"<bdb.Breakpoint.line>` is the same as the one in *frame*. If the breakpoint "
"was set via :attr:`function name <bdb.Breakpoint.funcname>`, we have to "
"check we are in the right *frame* (the right function) and if we are on its "
"first executable line."
msgstr ""
"如果是通过行号设置的，它将检查 :attr:`b.line <bdb.Breakpoint.line>` 是否与 *frame* 中的行一致。 "
"如果中断点是通过 :attr:`函数名称 <bdb.Breakpoint.funcname>` 设置的，则必须检查是否位于正确的 *帧* (正确的函数)"
" 以及是否位于其中第一个可执行的行。"

#: ../../library/bdb.rst:418
msgid ""
"Return ``(active breakpoint, delete temporary flag)`` or ``(None, None)`` as"
" the breakpoint to act upon."
msgstr ""
"返回 ``(active breakpoint, delete temporary flag)`` 或 ``(None, None)`` "
"作为目标中断点。"

#: ../../library/bdb.rst:421
msgid ""
"The *active breakpoint* is the first entry in :attr:`bplist "
"<bdb.Breakpoint.bplist>` for the (:attr:`file <bdb.Breakpoint.file>`, "
":attr:`line <bdb.Breakpoint.line>`) (which must exist) that is "
":attr:`enabled <bdb.Breakpoint.enabled>`, for which :func:`checkfuncname` is"
" True, and that has neither a False :attr:`condition <bdb.Breakpoint.cond>` "
"nor positive :attr:`ignore <bdb.Breakpoint.ignore>` count.  The *flag*, "
"meaning that a temporary breakpoint should be deleted, is False only when "
"the :attr:`cond <bdb.Breakpoint.cond>` cannot be evaluated (in which case, "
":attr:`ignore <bdb.Breakpoint.ignore>` count is ignored)."
msgstr ""
"*激活的中断点* 是 :attr:`bplist <bdb.Breakpoint.bplist>` 中对应 (:attr:`file "
"<bdb.Breakpoint.file>`, :attr:`line <bdb.Breakpoint.line>`) 的第一个 :attr:`已启用的"
" <bdb.Breakpoint.enabled>` 条目 (它必须存在)，对应的 :func:`checkfuncname` 为 True，并且没有 "
"False :attr:`cond <bdb.Breakpoint.cond>` 或为正值的 :attr:`ignore "
"<bdb.Breakpoint.ignore>` 计数。 *flag* 表示临时中断点应当被删除，它仅在 :attr:`cond "
"<bdb.Breakpoint.cond>` 无法被求值时 (在此情况下，:attr:`ignore <bdb.Breakpoint.ignore>` "
"计数会被忽略) 才会为 False。"

#: ../../library/bdb.rst:432
msgid "If no such entry exists, then (None, None) is returned."
msgstr "如果不存在这样的条目，则返回 (None, None)。"

#: ../../library/bdb.rst:437
msgid "Start debugging with a :class:`Bdb` instance from caller's frame."
msgstr "使用一个来自调用方的帧的 :class:`Bdb` 实例开始调试。"
