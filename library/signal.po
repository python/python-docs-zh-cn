# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# cdarlint <cdarling@126.com>, 2021
# Menghua Xiao <arieshout@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/signal.rst:2
msgid ":mod:`signal` --- Set handlers for asynchronous events"
msgstr ":mod:`signal` --- 设置异步事件处理程序"

#: ../../library/signal.rst:9
msgid "This module provides mechanisms to use signal handlers in Python."
msgstr "该模块提供了在 Python 中使用信号处理程序的机制。"

#: ../../library/signal.rst:13
msgid "General rules"
msgstr "一般规则"

#: ../../library/signal.rst:15
msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets"
" can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""
":func:`signal.signal` 函数允许定义在接收到信号时执行的自定义处理程序。少量的默认处理程序已经设置： "
":const:`SIGPIPE` 被忽略（因此管道和套接字上的写入错误可以报告为普通的 Python 异常）以及如果父进程没有更改 "
":const:`SIGINT` ，则其会被翻译成 :exc:`KeyboardInterrupt` 异常。"

#: ../../library/signal.rst:22
msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for "
":const:`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"一旦设置，特定信号的处理程序将保持安装，直到它被显式重置（ Python 模拟 BSD 样式接口而不管底层实现），但 :const:`SIGCHLD` "
"的处理程序除外，它遵循底层实现。"

#: ../../library/signal.rst:29
msgid "Execution of Python signal handlers"
msgstr "执行 Python 信号处理程序"

#: ../../library/signal.rst:31
msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal"
" handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"Python 信号处理程序不会在低级（ C ）信号处理程序中执行。相反，低级信号处理程序设置一个标志，告诉 :term:`virtual "
"machine` 稍后执行相应的 Python 信号处理程序（例如在下一个 :term:`bytecode` 指令）。这会导致："

#: ../../library/signal.rst:37
msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or "
":const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous"
" errors."
msgstr ""
"捕获同步错误是没有意义的，例如 :const:`SIGFPE` 或 :const:`SIGSEGV` ，它们是由 C "
"代码中的无效操作引起的。Python 将从信号处理程序返回到 C 代码，这可能会再次引发相同的信号，导致 Python 显然的挂起。 从Python "
"3.3开始，你可以使用 :mod:`faulthandler` 模块来报告同步错误。"

#: ../../library/signal.rst:44
msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"纯 C 中实现的长时间运行的计算（例如在大量文本上的正则表达式匹配）可以在任意时间内不间断地运行，而不管接收到任何信号。计算完成后将调用 Python "
"信号处理程序。"

#: ../../library/signal.rst:49
msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in"
" the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""

#: ../../library/signal.rst:57
msgid "Signals and threads"
msgstr "信号与线程"

#: ../../library/signal.rst:59
msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Python 信号处理程序总是会在主 Python 主解释器的主线程中执行，即使信号是在另一个线程中接收的。 这意味着信号不能被用作线程间通信的手段。 "
"你可以改用 :mod:`threading` 模块中的同步原语。"

#: ../../library/signal.rst:64
msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr "此外，只有主解释器的主线程才被允许设置新的信号处理程序。"

#: ../../library/signal.rst:68
msgid "Module contents"
msgstr "模块内容"

#: ../../library/signal.rst:70
msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask "
"(:const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>`. "
":func:`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and "
":func:`sigwait` functions return human-readable :class:`enums "
"<enum.IntEnum>`."
msgstr ""
"信号（ SIG* ），处理程序（ :const:`SIG_DFL` ， :const:`SIG_IGN`）和 sigmask（ "
":const:`SIG_BLOCK` ， :const:`SIG_UNBLOCK` ， :const:`SIG_SETMASK` "
"）下面列出的相关常量变成了 :class:`enums <enum.IntEnum>` 。 :func:`getsignal` ， "
":func:`pthread_sigmask` ， :func:`sigpending` 和 :func:`sigwait` 函数返回人类可读的 "
":class:`enums <enum.IntEnum>` 。"

#: ../../library/signal.rst:80
msgid "The variables defined in the :mod:`signal` module are:"
msgstr "在 :mod:`signal` 模块中定义的变量是："

#: ../../library/signal.rst:85
msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"这是两种标准信号处理选项之一；它只会执行信号的默认函数。 例如，在大多数系统上，对于 :const:`SIGQUIT` "
"的默认操作是转储核心并退出，而对于 :const:`SIGCHLD` 的默认操作是简单地忽略它。"

#: ../../library/signal.rst:93
msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr "这是另一个标准信号处理程序，它将简单地忽略给定的信号。"

#: ../../library/signal.rst:99
msgid "Abort signal from :manpage:`abort(3)`."
msgstr "来自 :manpage:`abort(3)` 的中止信号。"

#: ../../library/signal.rst:103
msgid "Timer signal from :manpage:`alarm(2)`."
msgstr "来自 :manpage:`alarm(2)` 的计时器信号。"

#: ../../library/signal.rst:105 ../../library/signal.rst:117
#: ../../library/signal.rst:123 ../../library/signal.rst:133
#: ../../library/signal.rst:147 ../../library/signal.rst:165
#: ../../library/signal.rst:173 ../../library/signal.rst:187
#: ../../library/signal.rst:193 ../../library/signal.rst:199
#: ../../library/signal.rst:450 ../../library/signal.rst:457
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`可用性 <availability>`: Unix。"

#: ../../library/signal.rst:109
msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr "来自键盘的中断 (CTRL + BREAK)。"

#: ../../library/signal.rst:111 ../../library/signal.rst:218
#: ../../library/signal.rst:228
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`可用性 <availability>`: Windows。"

#: ../../library/signal.rst:115
msgid "Bus error (bad memory access)."
msgstr "总线错误 (非法的内存访问)。"

#: ../../library/signal.rst:121
msgid "Child process stopped or terminated."
msgstr "子进程被停止或终结。"

#: ../../library/signal.rst:127
msgid "Alias to :data:`SIGCHLD`."
msgstr ":data:`SIGCHLD` 的别名。"

#: ../../library/signal.rst:131
msgid "Continue the process if it is currently stopped"
msgstr "如果进程当前已停止则继续执行它"

#: ../../library/signal.rst:137
msgid "Floating-point exception. For example, division by zero."
msgstr "浮点异常。 例如除以零。"

#: ../../library/signal.rst:140
msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or"
" modulo operation is zero."
msgstr "当除法或求余运算的第二个参数为零时会引发 :exc:`ZeroDivisionError` 。"

#: ../../library/signal.rst:145
msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr "在控制终端上检测到挂起或控制进程的终止。"

#: ../../library/signal.rst:151
msgid "Illegal instruction."
msgstr "非法指令。"

#: ../../library/signal.rst:155
msgid "Interrupt from keyboard (CTRL + C)."
msgstr "来自键盘的中断 (CTRL + C)。"

#: ../../library/signal.rst:157
msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr "默认的动作是引发 :exc:`KeyboardInterrupt`。"

#: ../../library/signal.rst:161
msgid "Kill signal."
msgstr "终止信号。"

#: ../../library/signal.rst:163
msgid "It cannot be caught, blocked, or ignored."
msgstr "它不能被捕获、阻塞或忽略。"

#: ../../library/signal.rst:169
msgid "Broken pipe: write to pipe with no readers."
msgstr "损坏的管道：写入到没有读取器的管道。"

#: ../../library/signal.rst:171
msgid "Default action is to ignore the signal."
msgstr "默认的动作是忽略此信号。"

#: ../../library/signal.rst:177
msgid "Segmentation fault: invalid memory reference."
msgstr "段错误：无效的内存引用。"

#: ../../library/signal.rst:181
msgid "Termination signal."
msgstr "终结信号。"

#: ../../library/signal.rst:185
msgid "User-defined signal 1."
msgstr "用户自定义信号 1。"

#: ../../library/signal.rst:191
msgid "User-defined signal 2."
msgstr "用户自定义信号 2。"

#: ../../library/signal.rst:197
msgid "Window resize signal."
msgstr "窗口调整大小信号。"

#: ../../library/signal.rst:203
msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in "
":manpage:`signal(7)`). Note that not all systems define the same set of "
"signal names; only those names defined by the system are defined by this "
"module."
msgstr ""
"所有信号编号都是符号化定义的。 例如，挂起信号被定义为 :const:`signal.SIGHUP`；变量的名称与 C 程序中使用的名称相同，具体见 "
"``<signal.h>``。 ':c:func:`signal`' 的 Unix 手册页面列出了现有的信号 (在某些系统上这是 "
":manpage:`signal(2)`，在其他系统中此列表则是在 :manpage:`signal(7)` 中)。 "
"请注意并非所有系统都会定义相同的信号名称集；只有系统所定义的名称才会由此模块来定义。"

#: ../../library/signal.rst:214
msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr "对应于 :kbd:`Ctrl+C` 击键事件的信号。此信号只能用于 :func:`os.kill` 。"

#: ../../library/signal.rst:224
msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr "对应于 :kbd:`Ctrl+Break` 击键事件的信号。此信号只能用于 :func:`os.kill` 。"

#: ../../library/signal.rst:234
msgid "One more than the number of the highest signal number."
msgstr "比最高信号数多一。"

#: ../../library/signal.rst:239
msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr "实时递减间隔计时器，并在到期时发送 :const:`SIGALRM` 。"

#: ../../library/signal.rst:245
msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr "仅在进程执行时递减间隔计时器，并在到期时发送 SIGVTALRM 。"

#: ../../library/signal.rst:251
msgid ""
"Decrements interval timer both when the process executes and when the system"
" is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"当进程执行时以及当系统替进程执行时都会减小间隔计时器。 这个计时器与 ITIMER_VIRTUAL "
"相配结，通常被用于分析应用程序在用户和内核空间中花费的时间。 SIGPROF 会在超期时被发送。"

#: ../../library/signal.rst:259
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ":func:`pthread_sigmask` 的 *how* 形参的一个可能的值，表明信号将会被阻塞。"

#: ../../library/signal.rst:266
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ":func:`pthread_sigmask` 的 *how* 形参的是个可能的值，表明信号将被解除阻塞。"

#: ../../library/signal.rst:273
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ":func:`pthread_sigmask` 的 *how* 形参的一个可能的值，表明信号掩码将要被替换。"

#: ../../library/signal.rst:279
msgid "The :mod:`signal` module defines one exception:"
msgstr ":mod:`signal` 模块定义了一个异常:"

#: ../../library/signal.rst:283
msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or "
":func:`getitimer` implementation. Expect this error if an invalid interval "
"timer or a negative time is passed to :func:`setitimer`. This error is a "
"subtype of :exc:`OSError`."
msgstr ""
"作为来自下层 :func:`setitimer` 或 :func:`getitimer` 实现错误的信号被引发。 如果将无效的定时器或负的时间值传给 "
":func:`setitimer` 就导致这个错误。 此错误是 :exc:`OSError` 的子类型。"

#: ../../library/signal.rst:288
msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of "
":exc:`OSError`."
msgstr "此错误是 :exc:`IOError` 的子类型，现在则是 :exc:`OSError` 的别名。"

#: ../../library/signal.rst:293
msgid "The :mod:`signal` module defines the following functions:"
msgstr ":mod:`signal` 模块定义了以下函数:"

#: ../../library/signal.rst:298
msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal"
" be sent to the process in *time* seconds. Any previously scheduled alarm is"
" canceled (only one alarm can be scheduled at any time).  The returned value"
" is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"如果 *time* 值非零，则此函数将要求将一个 :const:`SIGALRM` 信号在 *time* 秒内发往进程。 "
"任何在之前排入计划的警报都会被取消（在任何时刻都只能有一个警报被排入计划）。 后续的返回值将是任何之前设置的警报被传入之前的秒数。 如果 *time* "
"值为零，则不会将任何警报排入计划，并且任何已排入计划的警报都会被取消。 如果返回值为零，则目前没有任何警报被排入计划。"

#: ../../library/signal.rst:306
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`alarm(2)` for further information."
msgstr ":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`alarm(2)`。"

#: ../../library/signal.rst:311
msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values "
":const:`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, "
":const:`signal.SIG_IGN` means that the signal was previously ignored, "
":const:`signal.SIG_DFL` means that the default way of handling the signal "
"was previously in use, and ``None`` means that the previous signal handler "
"was not installed from Python."
msgstr ""
"返回当前用于信号 *signalnum* 的信号处理程序。 返回值可以是一个 Python 可调用对象，或是特殊值 "
":const:`signal.SIG_IGN`, :const:`signal.SIG_DFL` 或 :const:`None` 之一。 "
"在这里，:const:`signal.SIG_IGN` 表示信号在之前被忽略，:const:`signal.SIG_DFL` "
"表示之前在使用默认的信号处理方式，而 ``None`` 表示之前的信号处理程序未由 Python 安装。"

#: ../../library/signal.rst:322
msgid ""
"Return the system description of the signal *signalnum*, such as "
"\"Interrupt\", \"Segmentation fault\", etc. Returns :const:`None` if the "
"signal is not recognized."
msgstr ""
"返回信号 *signalnum* 的系统描述，例如 \"Interrupt\", \"Segmentation fault\" 等等。 "
"如果信号无法被识别则返回 :const:`None`。"

#: ../../library/signal.rst:331
msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr "返回本平台上的有效信号编号集。 这可能会少于 ``range(1, NSIG)``，如果某些信号被系统保留作为内部使用的话。"

#: ../../library/signal.rst:340
msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr "使进程休眠直至接收到一个信号；然后将会调用适当的处理程序。 返回空值。"

#: ../../library/signal.rst:345
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`signal(2)` for further information."
msgstr ":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`signal(2)`。"

#: ../../library/signal.rst:346
msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and "
":func:`sigpending`."
msgstr ""
"另请参阅 :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` 和 "
":func:`sigpending`。"

#: ../../library/signal.rst:352
msgid "Sends a signal to the calling process. Returns nothing."
msgstr "向调用方进程发送一个信号。 返回空值。"

#: ../../library/signal.rst:359
msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""
"发送信号 *sig* 到文件描述符 *pidfd* 所指向的进程。 Python 目前不支持 *siginfo* 形参；它必须为 ``None``。 "
"提供 *flags* 参数是为了将来扩展；当前未定义旗标值。"

#: ../../library/signal.rst:364
msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr "更多信息请参阅 :manpage:`pidfd_send_signal(2)` 手册页面。"

#: ../../library/signal.rst:366
msgid ":ref:`Availability <availability>`: Linux 5.1+"
msgstr ":ref:`可用性 <availability>`: Linux 5.1+"

#: ../../library/signal.rst:372
msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the"
" same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""
"将信号 *signalnum* 发送至与调用者在同一进程中另一线程 *thread_id*。 目标线程可被用于执行任何代码（Python或其它）。 "
"但是，如果目标线程是在执行 Python 解释器，则 Python 信号处理程序将 :ref:`由主解释器的主线程来执行 <signals-and-"
"threads>`。 因此，将信号发送给特定 Python 线程的唯一作用在于强制让一个正在运行的系统调用失败并抛出 "
":exc:`InterruptedError`。"

#: ../../library/signal.rst:380
msgid ""
"Use :func:`threading.get_ident()` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""
"使用 :func:`threading.get_ident()` 或 :class:`threading.Thread` 对象的 "
":attr:`~threading.Thread.ident` 属性为 *thread_id* 获取合适的值。"

#: ../../library/signal.rst:384
msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr "如果 *signalnum* 为 0，则不会发送信号，但仍然会执行错误检测；这可被用来检测目标线程是否仍在运行。"

#: ../../library/signal.rst:387
msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``signal.pthread_kill``，附带参数 ``thread_id``, "
"``signalnum``。"

#: ../../library/signal.rst:391
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`pthread_kill(3)` for further information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`pthread_kill(3)`。"

#: ../../library/signal.rst:392
msgid "See also :func:`os.kill`."
msgstr "另请参阅 :func:`os.kill`。"

#: ../../library/signal.rst:399
msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr "获取和/或修改调用方线程的信号掩码。 信号掩码是一组传送过程目前为调用者而阻塞的信号集。 返回旧的信号掩码作为一组信号。"

#: ../../library/signal.rst:403
msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "该调用的行为取决于 *how* 的值，具体见下。"

#: ../../library/signal.rst:405
msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ":data:`SIG_BLOCK`: 被阻塞信号集是当前集与 *mask* 参数的并集。"

#: ../../library/signal.rst:407
msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ":data:`SIG_UNBLOCK`: *mask* 中的信号会从当前已阻塞信号集中被移除。 允许尝试取消对一个非阻塞信号的阻塞。"

#: ../../library/signal.rst:410
msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ":data:`SIG_SETMASK`: 已阻塞信号集会被设为 *mask* 参数的值。"

#: ../../library/signal.rst:413
msgid ""
"*mask* is a set of signal numbers (e.g. {:const:`signal.SIGINT`, "
":const:`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask"
" including all signals."
msgstr ""
"*mask* 是一个信号编号集合 (例如 {:const:`signal.SIGINT`, :const:`signal.SIGTERM`})。 请使用"
" :func:`~signal.valid_signals` 表示包含所有信号的完全掩码。"

#: ../../library/signal.rst:417
msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr "例如，``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` 会读取调用方线程的信号掩码。"

#: ../../library/signal.rst:420
msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ":data:`SIGKILL` 和 :data:`SIGSTOP` 不能被阻塞。"

#: ../../library/signal.rst:424
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` for further "
"information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`sigprocmask(2)` 和 "
":manpage:`pthread_sigmask(3)`。"

#: ../../library/signal.rst:425
msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr "另请参阅 :func:`pause`, :func:`sigpending` 和 :func:`sigwait`。"

#: ../../library/signal.rst:432
msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, "
":const:`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by "
"*which* to fire after *seconds* (float is accepted, different from "
":func:`alarm`) and after that every *interval* seconds (if *interval* is "
"non-zero). The interval timer specified by *which* can be cleared by setting"
" *seconds* to zero."
msgstr ""
"设置由 *which* 指明的给定间隔计时器 (:const:`signal.ITIMER_REAL`, "
":const:`signal.ITIMER_VIRTUAL` 或 :const:`signal.ITIMER_PROF` 之一) 在 *seconds*"
" 秒 (接受浮点数值，为与 :func:`alarm` 之差) 之后开始并在每 *interval* 秒间隔时 (如果 *interval* 不为零) "
"启动。 由 *which* 指明的间隔计时器可通过将 *seconds* 设为零来清空。"

#: ../../library/signal.rst:439
msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends "
":const:`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver "
":const:`SIGPROF`."
msgstr ""
"当一个间隔计时器启动时，会有信号发送至进程。 所发送的具体信号取决于所使用的计时器；:const:`signal.ITIMER_REAL` 将发送 "
":const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` 将发送 :const:`SIGVTALRM`, 而 "
":const:`signal.ITIMER_PROF` 将发送 :const:`SIGPROF`."

#: ../../library/signal.rst:445
msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "原有的值会以元组: (delay, interval) 的形式被返回。"

#: ../../library/signal.rst:447
msgid ""
"Attempting to pass an invalid interval timer will cause an "
":exc:`ItimerError`."
msgstr "尝试传入无效的计时器将导致 :exc:`ItimerError`。"

#: ../../library/signal.rst:455
msgid "Returns current value of a given interval timer specified by *which*."
msgstr "返回由 *which* 指明的给定间隔计时器当前的值。"

#: ../../library/signal.rst:462
msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal is received, the "
"signal number is written as a single byte into the fd.  This can be used by "
"a library to wakeup a poll or select call, allowing the signal to be fully "
"processed."
msgstr ""
"将唤醒文件描述符设为 *fd*。 当接收到信号时，会将信号编号以单个字节的形式写入 fd。 这可被其它库用来唤醒一次 poll 或 select "
"调用，以允许该信号被完全地处理。"

#: ../../library/signal.rst:467
msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from"
" *fd* before calling poll or select again."
msgstr ""
"原有的唤醒 fd 会被返回（或者如果未启用文件描述符唤醒则返回 -1）。 如果 *fd* 为 -1，文件描述符唤醒会被禁用。 如果不为 -1，则 "
"*fd* 必须为非阻塞型。 需要由库来负责在重新调用 poll 或 select 之前从 *fd* 移除任何字节数据。"

#: ../../library/signal.rst:472 ../../library/signal.rst:526
msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"当启用线程用时，此函数只能从 :ref:`主解释器的主线程 <signals-and-threads>` 被调用；尝试从另一线程调用它将导致 "
":exc:`ValueError` 异常被引发。"

#: ../../library/signal.rst:477
msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""
"使用此函数有两种通常的方式。 在两种方式下，当有信号到达时你都是用 fd 来唤醒，但之后它们在确定达到的一个或多个信号 *which* 时存在差异。"

#: ../../library/signal.rst:482
msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte"
" values give you the signal numbers. This is simple, but in rare cases it "
"can run into a problem: generally the fd will have a limited amount of "
"buffer space, and if too many signals arrive too quickly, then the buffer "
"may become full, and some signals may be lost. If you use this approach, "
"then you should set ``warn_on_full_buffer=True``, which will at least cause "
"a warning to be printed to stderr when signals are lost."
msgstr ""
"在第一种方式下，我们从 fd 的缓冲区读取数据，这些字节值会给你信号编号。 这种方式很简单，但在少数情况下会发生问题：通常 fd "
"将有缓冲区空间大小限制，如果信号到达得太多且太快，缓冲区可能会爆满，有些信号可能丢失。 如果你使用此方式，则你应当设置 "
"``warn_on_full_buffer=True``，当信号丢失时这至少能将警告消息打印到 stderr。"

#: ../../library/signal.rst:491
msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""
"在第二种方式下，我们 *只会* 将唤醒 fd 用于唤醒，而忽略实际的字节值。 在此情况下，我们所关心的只有 fd "
"的缓冲区为空还是不为空；爆满的缓冲区完全不会导致问题。 如果你使用此方式，则你应当设置 "
"``warn_on_full_buffer=False``，这样你的用户就不会被虚假的警告消息所迷惑。"

#: ../../library/signal.rst:498
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，此函数现在也支持套接字处理。"

#: ../../library/signal.rst:501
msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "添加了 ``warn_on_full_buffer`` 形参。"

#: ../../library/signal.rst:506
msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"更改系统调用重启行为：如果 *flag* 为 :const:`False`，系统调用将在被信号 *signalnum* "
"中断时重启，否则系统调用将被中断。 返回空值。"

#: ../../library/signal.rst:512
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`siginterrupt(3)` for further information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`siginterrupt(3)`。"

#: ../../library/signal.rst:513
msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling "
":c:func:`siginterrupt` with a true *flag* value for the given signal."
msgstr ""
"请注意用 :func:`signal` 安装信号处理程序将重启行为重置为可通过显式调用 :c:func:`siginterrupt` 并为给定信号的 "
"*flag* 设置真值来实现中断。"

#: ../../library/signal.rst:520
msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler*"
" can be a callable Python object taking two arguments (see below), or one of"
" the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The"
" previous signal handler will be returned (see the description of "
":func:`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for "
"further information.)"
msgstr ""
"将信号 *signalnum* 的处理程序设为函数 *handler*。 *handler* 可以为接受两个参数（见下）的 Python "
"可调用对象，或者为特殊值 :const:`signal.SIG_IGN` 或 :const:`signal.SIG_DFL` 之一。 "
"之前的信号处理程序将被返回（参见上文 :func:`getsignal` 的描述）。 （更多信息请参阅 Unix 手册页面 "
":manpage:`signal(2)`。）"

#: ../../library/signal.rst:531
msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or"
" see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*handler* 将附带两个参数调用：信号编号和当前堆栈帧 (``None`` 或一个帧对象；有关帧对象的描述请参阅 :ref:`类型层级结构描述 "
"<frame-objects>` 或者参阅 :mod:`inspect` 模块中的属性描述)。"

#: ../../library/signal.rst:536
msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, "
":const:`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, "
":const:`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised "
"in any other case. Note that not all systems define the same set of signal "
"names; an :exc:`AttributeError` will be raised if a signal name is not "
"defined as ``SIG*`` module level constant."
msgstr ""
"在 Windows 上，:func:`signal` 调用只能附带 :const:`SIGABRT`, :const:`SIGFPE`, "
":const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:`SIGTERM` 或 "
":const:`SIGBREAK`。 任何其他值都将引发 :exc:`ValueError`。 "
"请注意不是所有系统都定义了同样的信号名称集合；如果一个信号名称未被定义为 ``SIG*`` 模块层级常量则将引发 "
":exc:`AttributeError`。"

#: ../../library/signal.rst:547
msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the"
" set of the pending signals."
msgstr "检查正在等待传送给调用方线程的信号集合（即在阻塞期间被引发的信号）。 返回正在等待的信号集合。"

#: ../../library/signal.rst:553
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`sigpending(2)` for further information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`sigpending(2)`。"

#: ../../library/signal.rst:554
msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr "另请参阅 :func:`pause`, :func:`pthread_sigmask` 和 :func:`sigwait`。"

#: ../../library/signal.rst:561
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal"
" number."
msgstr ""
"挂起调用方线程的执行直到信号集合 *sigset* 中指定的信号之一被传送。 此函数会接受该信号（将其从等待信号列表中移除），并返回信号编号。"

#: ../../library/signal.rst:567
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`sigwait(3)` for further information."
msgstr ":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`sigwait(3)`。"

#: ../../library/signal.rst:568
msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, "
":func:`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
"另请参阅 :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, "
":func:`sigwaitinfo` 和 :func:`sigtimedwait`。"

#: ../../library/signal.rst:576
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an "
":exc:`InterruptedError` if it is interrupted by a signal that is not in "
"*sigset*."
msgstr ""
"挂起调用方线程的执行直到信号集合 *sigset* 中指定的信号之一被传送。 此函数会接受该信号并将其从等待信号列表中移除。 如果 *sigset* "
"中的信号之一已经在等待调用方线程，此函数将立即返回并附带有关该信号的信息。 被传送信号的信号处理程序不会被调用。 如果该函数被某个不在 *sigset*"
" 中的信号中断则会引发 :exc:`InterruptedError`。"

#: ../../library/signal.rst:585
msgid ""
"The return value is an object representing the data contained in the "
":c:type:`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, "
":attr:`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, "
":attr:`si_band`."
msgstr ""
"返回值是一个代表 :c:type:`siginfo_t` 结构体所包含数据的对象，具体为: :attr:`si_signo`, "
":attr:`si_code`, :attr:`si_errno`, :attr:`si_pid`, :attr:`si_uid`, "
":attr:`si_status`, :attr:`si_band`。"

#: ../../library/signal.rst:592
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`sigwaitinfo(2)` for further information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`sigwaitinfo(2)`。"

#: ../../library/signal.rst:593
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr "另请参阅 :func:`pause`, :func:`sigwait` 和 :func:`sigtimedwait`。"

#: ../../library/signal.rst:597
msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr "当被某个 不在 *sigset* 中的信号中断时本函数将进行重试并且信号处理程序不会引发异常（请参阅 :pep:`475` 了解其理由）。"

#: ../../library/signal.rst:605
msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as :const:`0`, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""
"类似于 :func:`sigwaitinfo`，但会接受一个额外的 *timeout* 参数来指定超时限制。 如果将 *timeout* 指定为 "
":const:`0`，则会执行轮询。 如果发生超时则返回 :const:`None`。"

#: ../../library/signal.rst:611
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page "
":manpage:`sigtimedwait(2)` for further information."
msgstr ""
":ref:`可用性 <availability>`: Unix。 更多信息请参见手册页面 :manpage:`sigtimedwait(2)`。"

#: ../../library/signal.rst:612
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr "另请参阅 :func:`pause`, :func:`sigwait` 和 :func:`sigwaitinfo`。"

#: ../../library/signal.rst:616
msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""
"现在当此函数被某个不在 *sigset* 中的信号中断时将以计算出的 *timeout* 进行重试并且信号处理程序不会引发异常（请参阅 "
":pep:`475` 了解其理由）。"

#: ../../library/signal.rst:625
msgid "Example"
msgstr "示例"

#: ../../library/signal.rst:627
msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second"
" alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"这是一个最小示例程序。 它使用 :func:`alarm` "
"函数来限制等待打开一个文件所花费的时间；这在文件为无法开启的串行设备时会很有用处，此情况通常会导致 :func:`os.open` 无限期地挂起。  "
"解决办法是在打开文件之前设置 5 秒钟的 alarm；如果操作耗时过长，将会发送 alarm 信号，并且处理程序会引发一个异常。 ::"

#: ../../library/signal.rst:650
msgid "Note on SIGPIPE"
msgstr "对于 SIGPIPE 的说明"

#: ../../library/signal.rst:652
msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a "
":const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like "
":code:`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap "
"your entry point to catch this exception as follows::"
msgstr ""
"将你的程序用管道输出到工具例如 :manpage:`head(1)` 将会导致 :const:`SIGPIPE` "
"信号在其标准输出的接收方提前关闭时被发送到你的进程。 这将引发一个异常例如 :code:`BrokenPipeError: [Errno 32] "
"Broken pipe`。 要处理这种情况，请对你的入口点进行包装以捕获此异常，如下所示::"

#: ../../library/signal.rst:679
msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""

#: ../../library/signal.rst:688
msgid "Note on Signal Handlers and Exceptions"
msgstr ""

#: ../../library/signal.rst:690
msgid ""
"If a signal handler raises an exception, the exception will be propagated to"
" the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""

#: ../../library/signal.rst:697
msgid "To illustrate this issue, consider the following code::"
msgstr ""

#: ../../library/signal.rst:714
msgid ""
"For many programs, especially those that merely want to exit on "
":exc:`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as"
" a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
