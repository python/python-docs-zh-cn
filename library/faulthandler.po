# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Menghua Xiao <arieshout@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:05+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/faulthandler.rst:2
msgid ":mod:`!faulthandler` --- Dump the Python traceback"
msgstr ":mod:`!faulthandler` --- 转储 Python 回溯信息"

#: ../../library/faulthandler.rst:11
msgid ""
"This module contains functions to dump Python tracebacks explicitly, on a "
"fault, after a timeout, or on a user signal. Call "
":func:`faulthandler.enable` to install fault handlers for the "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`,"
" :const:`~signal.SIGBUS`, and :const:`~signal.SIGILL` signals. You can also "
"enable them at startup by setting the :envvar:`PYTHONFAULTHANDLER` "
"environment variable or by using the :option:`-X` ``faulthandler`` command "
"line option."
msgstr ""
"本模块包含当发生故障、超时或收到用户信号时可转储 Python 回溯信息的函数。 调用 :func:`faulthandler.enable` "
"可安装针对 :const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` 和 :const:`~signal.SIGILL` "
"信号的故障处理器。 你还可以在启动时通过设置 :envvar:`PYTHONFAULTHANDLER` 环境变量或使用 :option:`-X` "
"``faulthandler`` 命令行选项来启用它们。"

#: ../../library/faulthandler.rst:19
msgid ""
"The fault handler is compatible with system fault handlers like Apport or "
"the Windows fault handler. The module uses an alternative stack for signal "
"handlers if the :c:func:`!sigaltstack` function is available. This allows it"
" to dump the traceback even on a stack overflow."
msgstr ""
"故障处理器可兼容系统故障处理器如 Apport 或 Windows 故障处理器。 本模块会在 :c:func:`!sigaltstack` "
"函数可用时为信号处理器使用备用栈。 这允许它即使在栈溢出的情况下也能转储回溯信息。"

#: ../../library/faulthandler.rst:24
msgid ""
"The fault handler is called on catastrophic cases and therefore can only use"
" signal-safe functions (e.g. it cannot allocate memory on the heap). Because"
" of this limitation traceback dumping is minimal compared to normal Python "
"tracebacks:"
msgstr ""
"故障处理程序将在灾难性场合调用，因此只能使用信号安全的函数（比如不能在堆上分配内存）。由于这一限制，与正常的 Python 跟踪相比，转储量是最小的。"

#: ../../library/faulthandler.rst:29
msgid ""
"Only ASCII is supported. The ``backslashreplace`` error handler is used on "
"encoding."
msgstr "只支持 ASCII 码。编码时会用到  ``backslashreplace`` 错误处理程序。"

#: ../../library/faulthandler.rst:31
msgid "Each string is limited to 500 characters."
msgstr "每个字符串限制在 500 个字符以内。"

#: ../../library/faulthandler.rst:32
msgid ""
"Only the filename, the function name and the line number are displayed. (no "
"source code)"
msgstr "只会显式文件名、函数名和行号。（不显示源代码）"

#: ../../library/faulthandler.rst:34
msgid "It is limited to 100 frames and 100 threads."
msgstr "上限是 100 页内存帧和 100 个线程。"

#: ../../library/faulthandler.rst:35
msgid "The order is reversed: the most recent call is shown first."
msgstr "反序排列：最近的调用最先显示。"

#: ../../library/faulthandler.rst:37
msgid ""
"By default, the Python traceback is written to :data:`sys.stderr`. To see "
"tracebacks, applications must be run in the terminal. A log file can "
"alternatively be passed to :func:`faulthandler.enable`."
msgstr ""
"默认情况下，Python 的跟踪信息会写入 :data:`sys.stderr`。为了能看到跟踪信息，应用程序必须运行于终端中。日志文件也可以传给 "
":func:`faulthandler.enable`。"

#: ../../library/faulthandler.rst:41
msgid ""
"The module is implemented in C, so tracebacks can be dumped on a crash or "
"when Python is deadlocked."
msgstr "本模块是用 C 语言实现的，所以才能在崩溃或 Python 死锁时转储跟踪信息。"

#: ../../library/faulthandler.rst:44
msgid ""
"The :ref:`Python Development Mode <devmode>` calls "
":func:`faulthandler.enable` at Python startup."
msgstr ""
"在 Python 启动时， :ref:`Python 开发模式 <devmode>` 会调用 :func:`faulthandler.enable`。"

#: ../../library/faulthandler.rst:49
msgid "Module :mod:`pdb`"
msgstr "模块 :mod:`pdb`"

#: ../../library/faulthandler.rst:50
msgid "Interactive source code debugger for Python programs."
msgstr "用于 Python 程序的交互式源代码调试器。"

#: ../../library/faulthandler.rst:52
msgid "Module :mod:`traceback`"
msgstr "模块 :mod:`traceback`"

#: ../../library/faulthandler.rst:53
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr "提取、格式化和打印 Python 程序的栈回溯信息的标准接口。"

#: ../../library/faulthandler.rst:56
msgid "Dumping the traceback"
msgstr "转储跟踪信息"

#: ../../library/faulthandler.rst:60
msgid ""
"Dump the tracebacks of all threads into *file*. If *all_threads* is "
"``False``, dump only the current thread."
msgstr "将所有线程的跟踪数据转储到 *file* 中。如果 *all_threads* 为 ``False``，则只转储当前线程。"

#: ../../library/faulthandler.rst:63
msgid ""
":func:`traceback.print_tb`, which can be used to print a traceback object."
msgstr ":func:`traceback.print_tb`，可被用于打印回溯对象。"

#: ../../library/faulthandler.rst:65 ../../library/faulthandler.rst:119
#: ../../library/faulthandler.rst:165 ../../library/faulthandler.rst:190
msgid "Added support for passing file descriptor to this function."
msgstr "增加了向本函数传入文件描述符的支持。"

#: ../../library/faulthandler.rst:70
msgid "Dumping the C stack"
msgstr ""

#: ../../library/faulthandler.rst:76
msgid "Dump the C stack trace of the current thread into *file*."
msgstr ""

#: ../../library/faulthandler.rst:78
msgid ""
"If the Python build does not support it or the operating system does not "
"provide a stack trace, then this prints an error in place of a dumped C "
"stack."
msgstr ""

#: ../../library/faulthandler.rst:85
msgid "C Stack Compatibility"
msgstr ""

#: ../../library/faulthandler.rst:87
msgid ""
"If the system does not support the C-level :manpage:`backtrace(3)` or "
":manpage:`dladdr1(3)`, then C stack dumps will not work. An error will be "
"printed instead of the stack."
msgstr ""

#: ../../library/faulthandler.rst:91
msgid ""
"Additionally, some compilers do not support :term:`CPython's <CPython>` "
"implementation of C stack dumps. As a result, a different error may be "
"printed instead of the stack, even if the the operating system supports "
"dumping stacks."
msgstr ""

#: ../../library/faulthandler.rst:97
msgid ""
"Dumping C stacks can be arbitrarily slow, depending on the DWARF level of "
"the binaries in the call stack."
msgstr ""

#: ../../library/faulthandler.rst:101
msgid "Fault handler state"
msgstr "故障处理程序的状态"

#: ../../library/faulthandler.rst:105
msgid ""
"Enable the fault handler: install handlers for the :const:`~signal.SIGSEGV`,"
" :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` "
"and :const:`~signal.SIGILL` signals to dump the Python traceback. If "
"*all_threads* is ``True``, produce tracebacks for every running thread. "
"Otherwise, dump only the current thread."
msgstr ""
"启用默认的处理器：为 :const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` 和 :const:`~signal.SIGILL` "
"信号安装处理器来转储 Python 回溯信息。 如果 *all_threads* 为 ``True``，则会为每个运行中的线程产生回溯信息。 "
"在其他情况下，将只转储当前线程。"

#: ../../library/faulthandler.rst:112
msgid ""
"The *file* must be kept open until the fault handler is disabled: see "
":ref:`issue with file descriptors <faulthandler-fd>`."
msgstr "*file* 必须保持打开状态，直至停用故障处理程序为止：参见 :ref:`文件描述符相关话题 <faulthandler-fd>`。"

#: ../../library/faulthandler.rst:115
msgid ""
"If *c_stack* is ``True``, then the C stack trace is printed after the Python"
" traceback, unless the system does not support it. See :func:`dump_c_stack` "
"for more information on compatibility."
msgstr ""

#: ../../library/faulthandler.rst:122
msgid "On Windows, a handler for Windows exception is also installed."
msgstr "在 Windows 系统中，同时会安装一个 Windows 异常处理程序。"

#: ../../library/faulthandler.rst:125
msgid ""
"The dump now mentions if a garbage collector collection is running if "
"*all_threads* is true."
msgstr "现在如果 *all_threads* 为 True，则转储信息会包含垃圾收集器是否正在运行。"

#: ../../library/faulthandler.rst:129
msgid ""
"Only the current thread is dumped if the :term:`GIL` is disabled to prevent "
"the risk of data races."
msgstr ""

#: ../../library/faulthandler.rst:133
msgid "The dump now displays the C stack trace if *c_stack* is true."
msgstr ""

#: ../../library/faulthandler.rst:138
msgid ""
"Disable the fault handler: uninstall the signal handlers installed by "
":func:`enable`."
msgstr "停用故障处理程序：卸载由 :func:`enable` 安装的信号处理程序。"

#: ../../library/faulthandler.rst:143
msgid "Check if the fault handler is enabled."
msgstr "检查故障处理程序是否被启用。"

#: ../../library/faulthandler.rst:147
msgid "Dumping the tracebacks after a timeout"
msgstr "一定时间后转储跟踪数据。"

#: ../../library/faulthandler.rst:151
msgid ""
"Dump the tracebacks of all threads, after a timeout of *timeout* seconds, or"
" every *timeout* seconds if *repeat* is ``True``.  If *exit* is ``True``, "
"call :c:func:`!_exit` with status=1 after dumping the tracebacks.  (Note "
":c:func:`!_exit` exits the process immediately, which means it doesn't do "
"any cleanup like flushing file buffers.) If the function is called twice, "
"the new call replaces previous parameters and resets the timeout. The timer "
"has a sub-second resolution."
msgstr ""
"在 *timeout* 秒超时后，转储所有线程的回溯信息，或者如果 *repeat* 为 ``True`` 则每隔 *timeout* 秒执行一次转储。"
" 如果 *exit* 为 ``True``，则在转储回溯信息后调用 :c:func:`!_exit` 并设置 status=1。 （请注意 "
":c:func:`!_exit` 会立即关闭进程，这意味着不会做任何清理工作，如刷新文件缓冲区等。） "
"如果函数被调用两次，则新的调用将替代之前的形参并重置超时。 计时器的精度为亚秒级。"

#: ../../library/faulthandler.rst:159
msgid ""
"The *file* must be kept open until the traceback is dumped or "
":func:`cancel_dump_traceback_later` is called: see :ref:`issue with file "
"descriptors <faulthandler-fd>`."
msgstr ""
"*file* 必须保持打开状态，直至跟踪信息转储完毕，或调用了 :func:`cancel_dump_traceback_later`  ：参见 "
":ref:`文件描述符相关话题 <faulthandler-fd>`。"

#: ../../library/faulthandler.rst:163
msgid "This function is implemented using a watchdog thread."
msgstr "本函数用一个看门狗线程实现。"

#: ../../library/faulthandler.rst:168
msgid "This function is now always available."
msgstr "该函数现在总是可用。"

#: ../../library/faulthandler.rst:173
msgid "Cancel the last call to :func:`dump_traceback_later`."
msgstr "取消 :func:`dump_traceback_later` 的最后一次调用。"

#: ../../library/faulthandler.rst:177
msgid "Dumping the traceback on a user signal"
msgstr "转储用户信号的跟踪信息。"

#: ../../library/faulthandler.rst:181
msgid ""
"Register a user signal: install a handler for the *signum* signal to dump "
"the traceback of all threads, or of the current thread if *all_threads* is "
"``False``, into *file*. Call the previous handler if chain is ``True``."
msgstr ""
"注册一个用户信号：为 *signum* 信号安装一个处理程序，将所有线程或当前线程（*all_threads* 为 ``False`` "
"时）的跟踪信息转储到 *file* 中。如果 chain 为 ``True``，则调用上一层处理程序。"

#: ../../library/faulthandler.rst:185
msgid ""
"The *file* must be kept open until the signal is unregistered by "
":func:`unregister`: see :ref:`issue with file descriptors <faulthandler-"
"fd>`."
msgstr ""
"*file* 必须保持打开状态，直至该信号被 :func:`unregister` 注销：参见 :ref:`文件描述符相关话题 "
"<faulthandler-fd>`。"

#: ../../library/faulthandler.rst:188 ../../library/faulthandler.rst:199
msgid "Not available on Windows."
msgstr "Windows 中不可用。"

#: ../../library/faulthandler.rst:195
msgid ""
"Unregister a user signal: uninstall the handler of the *signum* signal "
"installed by :func:`register`. Return ``True`` if the signal was registered,"
" ``False`` otherwise."
msgstr ""
"注销一个用户信号：卸载由 :func:`register` 安装的 *signum* 信号处理程序。如果信号已注册，返回 ``True``，否则返回 "
"``False``。"

#: ../../library/faulthandler.rst:205
msgid "Issue with file descriptors"
msgstr "文件描述符相关话题"

#: ../../library/faulthandler.rst:207
msgid ""
":func:`enable`, :func:`dump_traceback_later` and :func:`register` keep the "
"file descriptor of their *file* argument. If the file is closed and its file"
" descriptor is reused by a new file, or if :func:`os.dup2` is used to "
"replace the file descriptor, the traceback will be written into a different "
"file. Call these functions again each time that the file is replaced."
msgstr ""
":func:`enable` 、 :func:`dump_traceback_later` 和 :func:`register` 保留其 *file* "
"参数给出的文件描述符。 如果文件关闭，文件描述符将被一个新文件重新使用；或者用 :func:`os.dup2` "
"替换了文件描述符，则跟踪信息将被写入另一个文件。 每次文件被替换时，都会再次调用这些函数。"

#: ../../library/faulthandler.rst:215
msgid "Example"
msgstr "示例"

#: ../../library/faulthandler.rst:217
msgid ""
"Example of a segmentation fault on Linux with and without enabling the fault"
" handler:"
msgstr "在 Linux 中启用和停用内存段故障的默认处理程序："

#: ../../library/faulthandler.rst:220
msgid ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"
msgstr ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"
