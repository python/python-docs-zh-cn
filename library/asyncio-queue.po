# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-queue.rst:7
msgid "Queues"
msgstr "队列集"

#: ../../library/asyncio-queue.rst:9
msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr "**源代码:** :source:`Lib/asyncio/queues.py`"

#: ../../library/asyncio-queue.rst:13
msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""
"asyncio 队列被设计成与 :mod:`queue` 模块类似。尽管 asyncio队列不是线程安全的，但是他们是被设计专用于 "
"async/await 代码。"

#: ../../library/asyncio-queue.rst:17
msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use "
":func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""
"注意asyncio 的队列没有 *timeout* 形参；请使用 :func:`asyncio.wait_for` 函数为队列添加超时操作。"

#: ../../library/asyncio-queue.rst:21
msgid "See also the `Examples`_ section below."
msgstr "参见下面的 `Examples`_ 部分。"

#: ../../library/asyncio-queue.rst:24
msgid "Queue"
msgstr "Queue"

#: ../../library/asyncio-queue.rst:28
msgid "A first in, first out (FIFO) queue."
msgstr "先进，先出（FIFO）队列"

#: ../../library/asyncio-queue.rst:30
msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""
"如果 *maxsize* 小于等于零，则队列尺寸是无限的。如果是大于 ``0`` 的整数，则当队列达到 *maxsize* 时， ``await "
"put()`` 将阻塞至某个元素被 :meth:`get` 取出。"

#: ../../library/asyncio-queue.rst:35
msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is"
" always known and can be returned by calling the :meth:`qsize` method."
msgstr "不像标准库中的并发型 :mod:`queue` ，队列的尺寸一直是已知的，可以通过调用 :meth:`qsize` 方法返回。"

#: ../../library/asyncio-queue.rst:39
msgid "Removed the *loop* parameter."
msgstr "移除了 *loop* 形参。"

#: ../../library/asyncio-queue.rst:43
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "这个类不是线程安全的（:ref:`not thread safe <asyncio-multithreading>`）。"

#: ../../library/asyncio-queue.rst:47
msgid "Number of items allowed in the queue."
msgstr "队列中可存放的元素数量。"

#: ../../library/asyncio-queue.rst:51
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "如果队列为空返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/asyncio-queue.rst:55
msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr "如果有 :attr:`maxsize` 个条目在队列中，则返回 ``True`` 。"

#: ../../library/asyncio-queue.rst:57
msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then "
":meth:`full` never returns ``True``."
msgstr "如果队列用 ``maxsize=0`` (默认值) 初始化，则 :meth:`full` 永远不会返回 ``True``。"

#: ../../library/asyncio-queue.rst:63
msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr "从队列中删除并返回一个元素。如果队列为空，则等待，直到队列中有元素。"

#: ../../library/asyncio-queue.rst:68
msgid ""
"Return an item if one is immediately available, else raise "
":exc:`QueueEmpty`."
msgstr "立即返回一个队列中的元素，如果队列内有值，否则引发异常  :exc:`QueueEmpty` 。"

#: ../../library/asyncio-queue.rst:74
msgid "Block until all items in the queue have been received and processed."
msgstr "阻塞至队列中所有的元素都被接收和处理完毕。"

#: ../../library/asyncio-queue.rst:76
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls "
":meth:`task_done` to indicate that the item was retrieved and all work on it"
" is complete.  When the count of unfinished tasks drops to zero, "
":meth:`join` unblocks."
msgstr ""
"当条目添加到队列的时候，未完成任务的计数就会增加。每当消费协程调用 :meth:`task_done` "
"表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， :meth:`join` 阻塞被解除。"

#: ../../library/asyncio-queue.rst:85
msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr "添加一个元素进队列。如果队列满了，在添加元素之前，会一直等待空闲插槽可用。"

#: ../../library/asyncio-queue.rst:90
msgid "Put an item into the queue without blocking."
msgstr "不阻塞的放一个元素入队列。"

#: ../../library/asyncio-queue.rst:92
msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr "如果没有立即可用的空闲槽，引发 :exc:`QueueFull` 异常。"

#: ../../library/asyncio-queue.rst:96
msgid "Return the number of items in the queue."
msgstr "返回队列用的元素数量。"

#: ../../library/asyncio-queue.rst:100
msgid "Indicate that a formerly enqueued work item is complete."
msgstr "表明之前加入队列的工作条目已经完成。"

#: ../../library/asyncio-queue.rst:102
msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a work "
"item, a subsequent call to :meth:`task_done` tells the queue that the "
"processing on the work item is complete."
msgstr ""
"由队列的消费者使用。 对于每个被用于获取工作条目的 :meth:`~Queue.get`，将有一个对 :meth:`task_done` "
"的后续调用来告诉队列工作条目的操作已完成。"

#: ../../library/asyncio-queue.rst:106
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every"
" item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"如果 :meth:`join` 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 :meth:`~Queue.put` 进队列的条目的 "
":meth:`task_done` 都被收到)。"

#: ../../library/asyncio-queue.rst:111
msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr "如果被调用的次数多于放入队列中的项目数量，将引发 :exc:`ValueError` 。"

#: ../../library/asyncio-queue.rst:116
msgid "Priority Queue"
msgstr "优先级队列"

#: ../../library/asyncio-queue.rst:120
msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ":class:`Queue` 的变体；按优先级顺序取出条目 (最小的先取出)。"

#: ../../library/asyncio-queue.rst:123
msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr "条目通常是 ``(priority_number, data)`` 形式的元组。"

#: ../../library/asyncio-queue.rst:128
msgid "LIFO Queue"
msgstr "后进先出队列"

#: ../../library/asyncio-queue.rst:132
msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first"
" (last in, first out)."
msgstr ":class:`Queue` 的变体，先取出最近添加的条目（后进，先出）。"

#: ../../library/asyncio-queue.rst:137
msgid "Exceptions"
msgstr "异常"

#: ../../library/asyncio-queue.rst:141
msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called"
" on an empty queue."
msgstr "当队列为空的时候，调用 :meth:`~Queue.get_nowait` 方法而引发这个异常。"

#: ../../library/asyncio-queue.rst:147
msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr "当队列中条目数量已经达到它的 *maxsize* 的时候，调用 :meth:`~Queue.put_nowait` 方法而引发的异常。"

#: ../../library/asyncio-queue.rst:152
msgid "Examples"
msgstr "例子"

#: ../../library/asyncio-queue.rst:156
msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr "队列能被用于多个的并发任务的工作量分配："

#: ../../library/asyncio-queue.rst:159
msgid ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # 从队列获取一个“工作项”。\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # 休眠 \"sleep_for\" 秒。\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # 通知队列“工作项”已被处理。\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # 创建一个用于存储我们的“工作项”的队列。\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # 生成随机时段并将它们放入队列。\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # 创建三个工作任务来并发地处理队列。\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # 等待直到队列处理完毕。\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # 取消我们的工作任务。\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # 等待直到所有工作任务都被取消。\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
