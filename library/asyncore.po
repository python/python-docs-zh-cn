# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# Stan Ulbrych, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-05 17:03+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Stan Ulbrych, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncore.rst:2
msgid ":mod:`asyncore` --- Asynchronous socket handler"
msgstr ":mod:`asyncore` --- 异步套接字处理器"

#: ../../library/asyncore.rst:14
msgid "**Source code:** :source:`Lib/asyncore.py`"
msgstr "**源码：** :source:`Lib/asyncore.py`"

#: ../../library/asyncore.rst:20
msgid ""
"The :mod:`asyncore` module is deprecated (see :pep:`PEP 594 <594#asyncore>` "
"for details). Please use :mod:`asyncio` instead."
msgstr ""
":mod:`asyncore` 模块已被弃用（请参阅 :pep:`PEP 594 <594#asyncore>` 了解详情）。 请改用 "
":mod:`asyncio`。"

#: ../../library/asyncore.rst:25
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr "该模块仅为提供向后兼容。我们推荐在新代码中使用 :mod:`asyncio` 。"

#: ../../library/asyncore.rst:28
msgid ""
"This module provides the basic infrastructure for writing asynchronous  "
"socket service clients and servers."
msgstr "该模块提供用于编写异步套接字服务客户端与服务端的基础构件。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`可用性 <availability>`: 非 Emscripten，非 WASI。"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模块在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不适用或不可用。 请参阅 "
":ref:`wasm-availability` 了解详情。"

#: ../../library/asyncore.rst:33
msgid ""
"There are only two ways to have a program on a single processor do  \"more "
"than one thing at a time.\" Multi-threaded programming is the  simplest and "
"most popular way to do it, but there is another very different technique, "
"that lets you have nearly all the advantages of  multi-threading, without "
"actually using multiple threads.  It's really  only practical if your "
"program is largely I/O bound.  If your program is processor bound, then pre-"
"emptive scheduled threads are probably what you really need.  Network "
"servers are rarely processor bound, however."
msgstr ""
"只有两种方法让单个处理器上的程序“同一时间完成不止一件事”。 "
"多线程编程是最简单和最流行的方法，但是还有另一种非常不同的技术，它可以让你拥有多线程的几乎所有优点，而无需实际使用多线程。 它仅仅在你的程序主要受 "
"I/O 限制时有用，那么。 如果你的程序受处理器限制，那么先发制人的预定线程可能就是你真正需要的。 但是，网络服务器很少受处理器限制。"

#: ../../library/asyncore.rst:42
msgid ""
"If your operating system supports the :c:func:`select` system call in its "
"I/O library (and nearly all do), then you can use it to juggle multiple "
"communication channels at once; doing other work while your I/O is taking "
"place in the \"background.\"  Although this strategy can seem strange and "
"complex, especially at first, it is in many ways easier to understand and "
"control than multi-threaded programming.  The :mod:`asyncore` module solves "
"many of the difficult problems for you, making the task of building "
"sophisticated high-performance network servers and clients a snap.  For "
"\"conversational\" applications and protocols the companion :mod:`asynchat` "
"module is invaluable."
msgstr ""
"如果你的操作系统在其 I/O 库中支持 :c:func:`select` 系统调用（几乎所有操作系统），那么你可以使用它来同时处理多个通信通道；在 "
"I/O 正在“后台”时进行其他工作。 虽然这种策略看起来很奇怪和复杂，特别是起初，它在很多方面比多线程编程更容易理解和控制。 "
":mod:`asyncore` 模块为您解决了许多难题，使得构建复杂的高性能网络服务器和客户端的任务变得轻而易举。 对于“会话”应用程序和协议，伴侣 "
":mod:`asynchat` 模块是非常宝贵的。"

#: ../../library/asyncore.rst:53
msgid ""
"The basic idea behind both modules is to create one or more network "
"*channels*, instances of class :class:`asyncore.dispatcher` and "
":class:`asynchat.async_chat`.  Creating the channels adds them to a global "
"map, used by the :func:`loop` function if you do not provide it with your "
"own *map*."
msgstr ""
"这两个模块背后的基本思想是创建一个或多个网络 *通道* ，类的实例 :class:`asyncore.dispatcher` 和 "
":class:`asynchat.async_chat` 。 创建通道会将它们添加到全局映射中，如果你不为它提供自己的 *映射* ，则由 "
":func:`loop` 函数使用。"

#: ../../library/asyncore.rst:59
msgid ""
"Once the initial channel(s) is(are) created, calling the :func:`loop` "
"function activates channel service, which continues until the last channel "
"(including any that have been added to the map during asynchronous service) "
"is closed."
msgstr ""
"一旦创建了初始通道，调用 :func:`loop` "
"函数将激活通道服务，该服务将一直持续到最后一个通道（包括在异步服务期间已添加到映射中的任何通道）关闭。"

#: ../../library/asyncore.rst:66
msgid ""
"Enter a polling loop that terminates after count passes or all open channels"
" have been closed.  All arguments are optional.  The *count* parameter "
"defaults to ``None``, resulting in the loop terminating only when all "
"channels have been closed.  The *timeout* argument sets the timeout "
"parameter for the appropriate :func:`~select.select` or :func:`~select.poll`"
" call, measured in seconds; the default is 30 seconds.  The *use_poll* "
"parameter, if true, indicates that :func:`~select.poll` should be used in "
"preference to :func:`~select.select` (the default is ``False``)."
msgstr ""
"进入一个轮询循环，其在循环计数超出或所有打开的通道关闭后终止。 所有参数都是可选的。 *count* 形参默认为 ``None`` "
"，导致循环仅在所有通道关闭时终止。 *timeout* 形参为适当的 :func:`~select.select` 或 "
":func:`~select.poll` 调用设置超时参数，以秒为单位; 默认值为30秒。 *use_poll* 形参，如果为 True ，则表示 "
":func:`~select.poll` 应优先使用 :func:`~select.select` (默认为 ``False``)。"

#: ../../library/asyncore.rst:75
msgid ""
"The *map* parameter is a dictionary whose items are the channels to watch. "
"As channels are closed they are deleted from their map.  If *map* is "
"omitted, a global map is used. Channels (instances of "
":class:`asyncore.dispatcher`, :class:`asynchat.async_chat` and subclasses "
"thereof) can freely be mixed in the map."
msgstr ""
"*map* 形参是一个条目为所监视通道的字典。 当通道关闭时它们会被从映射中删除。 如果省略 *map*，则会使用一个全局映射。 通道 "
"(:class:`asyncore.dispatcher`, :class:`asynchat.async_chat` 及其子类的实例) "
"可以在映射中任意混合。"

#: ../../library/asyncore.rst:84
msgid ""
"The :class:`dispatcher` class is a thin wrapper around a low-level socket "
"object. To make it more useful, it has a few methods for event-handling "
"which are called from the asynchronous loop.   Otherwise, it can be treated "
"as a normal non-blocking socket object."
msgstr ""
":class:`dispatcher` 类是对低层级套接字对象的轻量包装器。 要让它更有用处，可以从异步循环调用一些事件处理方法。 "
"在其他方面，它可以被当作是普通的非阻塞型套接字对象。"

#: ../../library/asyncore.rst:89
msgid ""
"The firing of low-level events at certain times or in certain connection "
"states tells the asynchronous loop that certain higher-level events have "
"taken place.  For example, if we have asked for a socket to connect to "
"another host, we know that the connection has been made when the socket "
"becomes writable for the first time (at this point you know that you may "
"write to it with the expectation of success).  The implied higher-level "
"events are:"
msgstr ""
"在特定时间或特定连接状态下触发的低层级事件可通知异步循环发生了特定的高层级事件。 "
"例如，如果我们请求了一个套接字以连接到另一台主机，我们会在套接字首次变得可写时得知连接已建立（在此刻你将知道可以向其写入并预期能够成功）。 "
"包含的高层级事件有:"

#: ../../library/asyncore.rst:98
msgid "Event"
msgstr "事件"

#: ../../library/asyncore.rst:98
msgid "Description"
msgstr "描述"

#: ../../library/asyncore.rst:100
msgid "``handle_connect()``"
msgstr "``handle_connect()``"

#: ../../library/asyncore.rst:100
msgid "Implied by the first read or write event"
msgstr "由首个读取或写入事件引起"

#: ../../library/asyncore.rst:103
msgid "``handle_close()``"
msgstr "``handle_close()``"

#: ../../library/asyncore.rst:103
msgid "Implied by a read event with no data available"
msgstr "由不带可用数据的读取事件引起"

#: ../../library/asyncore.rst:106
msgid "``handle_accepted()``"
msgstr "``handle_accepted()``"

#: ../../library/asyncore.rst:106
msgid "Implied by a read event on a listening socket"
msgstr "由在监听套接字上的读取事件引起"

#: ../../library/asyncore.rst:110
msgid ""
"During asynchronous processing, each mapped channel's :meth:`readable` and "
":meth:`writable` methods are used to determine whether the channel's socket "
"should be added to the list of channels :c:func:`select`\\ ed or "
":c:func:`poll`\\ ed for read and write events."
msgstr ""
"在异步处理过程中，每个已映射通道的 :meth:`readable` 和 :meth:`writable` "
"方法会被用来确定是否要将通道的套接字添加到已执行 :c:func:`select` 或 :c:func:`poll` 用于读取和写入事件的通道列表中。"

#: ../../library/asyncore.rst:115
msgid ""
"Thus, the set of channel events is larger than the basic socket events.  The"
" full set of methods that can be overridden in your subclass follows:"
msgstr "因此，通道事件的集合要大于基本套接字事件。 可以在你的子类中被重载的全部方法集合如下:"

#: ../../library/asyncore.rst:121
msgid ""
"Called when the asynchronous loop detects that a :meth:`read` call on the "
"channel's socket will succeed."
msgstr "当异步循环检测到通道的套接字上的 :meth:`read` 调用将要成功时会被调用。"

#: ../../library/asyncore.rst:127
msgid ""
"Called when the asynchronous loop detects that a writable socket can be "
"written.  Often this method will implement the necessary buffering for "
"performance.  For example::"
msgstr "当异步循环检测到一个可写套接字可以被写入时会被调用。 通常此方法将实现必要的缓冲机制以保证运行效率。 例如::"

#: ../../library/asyncore.rst:138
msgid ""
"Called when there is out of band (OOB) data for a socket connection.  This "
"will almost never happen, as OOB is tenuously supported and rarely used."
msgstr "当一个套接字连接存在带外（OOB）数据时会被调用。 这几乎从来不会发生，因为 OOB 虽然受支持但很少被使用。"

#: ../../library/asyncore.rst:144
msgid ""
"Called when the active opener's socket actually makes a connection.  Might "
"send a \"welcome\" banner, or initiate a protocol negotiation with the "
"remote endpoint, for example."
msgstr "当活动打开方的套接字实际建立连接时会被调用。 可能会发送一条“欢迎”消息，或者向远程端点发起协议协商等。"

#: ../../library/asyncore.rst:151
msgid "Called when the socket is closed."
msgstr "当套接字关闭时会被调用。"

#: ../../library/asyncore.rst:156
msgid ""
"Called when an exception is raised and not otherwise handled.  The default "
"version prints a condensed traceback."
msgstr "当一个异常被引发并且未获得其他处理时会被调用。 默认版本将打印精简的回溯信息。"

#: ../../library/asyncore.rst:162
msgid ""
"Called on listening channels (passive openers) when a connection can be "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint. Deprecated in version 3.2; use "
":meth:`handle_accepted` instead."
msgstr ""
"当可以与发起对本地端点的 :meth:`connect` 调用的新远程端点建立连接时会在侦听通道（被动打开方）上被调用。 在 3.2 "
"版中已被弃用；请改用 :meth:`handle_accepted`。"

#: ../../library/asyncore.rst:172
msgid ""
"Called on listening channels (passive openers) when a connection has been "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint.  *sock* is a *new* socket object usable to send"
" and receive data on the connection, and *addr* is the address bound to the "
"socket on the other end of the connection."
msgstr ""
"当与发起对本地端点的 :meth:`connect` 调用的新远程端点已建立连接时会在侦听通道（被动打开方）上被调用。 *sock* "
"是可被用于在连接上发送和接收数据的 *新建* 套接字对象，而 *addr* 是绑定到连接另一端的套接字的地址。"

#: ../../library/asyncore.rst:183
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which read events can occur."
"  The default method simply returns ``True``, indicating that by default, "
"all channels will be interested in read events."
msgstr ""
"每次在异步循环之外被调用以确定是否应当将一个通道的套接字添加到可能在其上发生读取事件的列表中。 默认方法会简单地返回 "
"``True``，表示在默认情况下，所有通道都希望能读取事件。"

#: ../../library/asyncore.rst:191
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which write events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in write events."
msgstr ""
"每次在异步循环之外被调用以确定是否应当将一个通道的套接字添加到可能在其上发生写入事件的列表中。 默认方法会简单地返回 "
"``True``，表示在默认情况下，所有通道都希望能写入事件。"

#: ../../library/asyncore.rst:197
msgid ""
"In addition, each channel delegates or extends many of the socket methods. "
"Most of these are nearly identical to their socket partners."
msgstr "此外，每个通道都委托或扩展了许多套接字方法。 它们大部分都与其套接字的对应方法几乎一样。"

#: ../../library/asyncore.rst:203
msgid ""
"This is identical to the creation of a normal socket, and will use the same "
"options for creation.  Refer to the :mod:`socket` documentation for "
"information on creating sockets."
msgstr "这与普通套接字的创建相同，并会使用同样的创建选项。 请参阅 :mod:`socket` 文档了解有关创建套接字的信息。"

#: ../../library/asyncore.rst:207
msgid "*family* and *type* arguments can be omitted."
msgstr "*family* 和 *type* 参数可以被省略。"

#: ../../library/asyncore.rst:213
msgid ""
"As with the normal socket object, *address* is a tuple with the first "
"element the host to connect to, and the second the port number."
msgstr "与普通套接字对象一样，*address* 是一个元组，它的第一个元素是要连接的主机，第二个元素是端口号。"

#: ../../library/asyncore.rst:219
msgid "Send *data* to the remote end-point of the socket."
msgstr "将 *data* 发送到套接字的远程端点。"

#: ../../library/asyncore.rst:224
msgid ""
"Read at most *buffer_size* bytes from the socket's remote end-point.  An "
"empty bytes object implies that the channel has been closed from the other "
"end."
msgstr "从套接字的远程端点读取至多 *buffer_size* 个字节。 读到空字节串表明通道已从另一端被关闭。"

#: ../../library/asyncore.rst:228
msgid ""
"Note that :meth:`recv` may raise :exc:`BlockingIOError` , even though "
":func:`select.select` or :func:`select.poll` has reported the socket ready "
"for reading."
msgstr ""
"请注意 :meth:`recv` 可能会引发 :exc:`BlockingIOError`，即使 :func:`select.select` 或 "
":func:`select.poll` 报告套接字已准备好被读取。"

#: ../../library/asyncore.rst:235
msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies"
" the maximum number of queued connections and should be at least 1; the "
"maximum value is system-dependent (usually 5)."
msgstr "侦听与套接字的连接。 *backlog* 参数指明排入连接队列的最大数量且至少应为 1；最大值取决于具体系统（通常为 5）。"

#: ../../library/asyncore.rst:242
msgid ""
"Bind the socket to *address*.  The socket must not already be bound.  (The "
"format of *address* depends on the address family --- refer to the "
":mod:`socket` documentation for more information.)  To mark the socket as "
"re-usable (setting the :const:`SO_REUSEADDR` option), call the "
":class:`dispatcher` object's :meth:`set_reuse_addr` method."
msgstr ""
"将套接字绑定到 *address*。 套接字必须尚未被绑定。  (*address* 的格式取决于具体的地址族 --- 请参阅 "
":mod:`socket` 文档了解更多信息。) 要将套接字标记为可重用的 (设置 :const:`SO_REUSEADDR` 选项)，请调用 "
":class:`dispatcher` 对象的 :meth:`set_reuse_addr` 方法。"

#: ../../library/asyncore.rst:251
msgid ""
"Accept a connection.  The socket must be bound to an address and listening "
"for connections.  The return value can be either ``None`` or a pair ``(conn,"
" address)`` where *conn* is a *new* socket object usable to send and receive"
" data on the connection, and *address* is the address bound to the socket on"
" the other end of the connection. When ``None`` is returned it means the "
"connection didn't take place, in which case the server should just ignore "
"this event and keep listening for further incoming connections."
msgstr ""
"接受一个连接。 此套接字必须绑定到一个地址上并且侦听连接。 返回值可以是 ``None`` 或一个 ``(conn, address)`` 对，其中 "
"*conn* 是一个可用来在此连接上发送和接收数据的  *新的* 套接字对象，而 *address* 是绑定到连接另一端套接字的地址。 当返回 "
"``None`` 时意味着连接没有建立，在此情况下服务器应当忽略此事件并继续侦听后续的入站连接。"

#: ../../library/asyncore.rst:263
msgid ""
"Close the socket.  All future operations on the socket object will fail. The"
" remote end-point will receive no more data (after queued data is flushed)."
"  Sockets are automatically closed when they are garbage-collected."
msgstr ""
"关闭套接字。 在此套接字对象上的后续操作都将失败。 远程端点将不再接收任何数据（在排入队列的数据被清空之后）。 当套接字被垃圾回收时会自动关闭。"

#: ../../library/asyncore.rst:271
msgid ""
"A :class:`dispatcher` subclass which adds simple buffered output capability,"
" useful for simple clients. For more sophisticated usage use "
":class:`asynchat.async_chat`."
msgstr ""
":class:`dispatcher` 的一个添加了简单缓冲输出功能的子类，适用于简单客户端。 对于更复杂的用法请使用 "
":class:`asynchat.async_chat`。"

#: ../../library/asyncore.rst:277
msgid ""
"A file_dispatcher takes a file descriptor or :term:`file object` along with "
"an optional map argument and wraps it for use with the :c:func:`poll` or "
":c:func:`loop` functions.  If provided a file object or anything with a "
":c:func:`fileno` method, that method will be called and passed to the "
":class:`file_wrapper` constructor."
msgstr ""
"file_dispatcher 接受一个文件描述符或 :term:`file object` 以及一个可选的 map 参数，并对其进行包装以配合 "
":c:func:`poll` 或 :c:func:`loop` 函数使用。 如果提供一个文件对象或任何具有 :c:func:`fileno` "
"方法的对象，其方法将被调用并传递给 :class:`file_wrapper` 构造器。"

#: ../../library/asyncore.rst:283 ../../library/asyncore.rst:292
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`可用性 <availability>`: Unix。"

#: ../../library/asyncore.rst:287
msgid ""
"A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to "
"duplicate the handle so that the original handle may be closed independently"
" of the file_wrapper.  This class implements sufficient methods to emulate a"
" socket for use by the :class:`file_dispatcher` class."
msgstr ""
"file_wrapper 接受一个整数形式的文件描述符并调用 :func:`os.dup` 来复制其句柄，以便原始句柄可以独立于 "
"file_wrapper 被关闭。 这个类实现了足够的方法来模拟套接字以供 :class:`file_dispatcher` 类使用。"

#: ../../library/asyncore.rst:298
msgid "asyncore Example basic HTTP client"
msgstr "asyncore 示例基本 HTTP 客户端"

#: ../../library/asyncore.rst:300
msgid ""
"Here is a very basic HTTP client that uses the :class:`dispatcher` class to "
"implement its socket handling::"
msgstr "下面是一个非常基本的 HTTP 客户端，它使用了 :class:`dispatcher` 类来实现套接字处理::"

#: ../../library/asyncore.rst:337
msgid "asyncore Example basic echo server"
msgstr "asyncore 示例基本回显服务器"

#: ../../library/asyncore.rst:339
msgid ""
"Here is a basic echo server that uses the :class:`dispatcher` class to "
"accept connections and dispatches the incoming connections to a handler::"
msgstr "下面是一个基本的回显服务器，它使用了 :class:`dispatcher` 类来接受连接并将入站连接发送给处理程序::"
