# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-15 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sys.monitoring.rst:2
msgid ":mod:`!sys.monitoring` --- Execution event monitoring"
msgstr ":mod:`!sys.monitoring` --- 执行事件监测"

#: ../../library/sys.monitoring.rst:13
msgid ""
":mod:`sys.monitoring` is a namespace within the :mod:`sys` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply"
" ``import sys`` and then use ``sys.monitoring``."
msgstr ""
":mod:`sys.monitoring` 是 :mod:`sys` 模块内部的一个命名空间，而不是一个独立模块，因此不需要 ``import "
"sys.monitoring``，只要简单地 ``import sys`` 然后使用 ``sys.monitoring``。"

#: ../../library/sys.monitoring.rst:19
msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr "这个命名空间提供了对于激活和控制事件监控所需的函数和常量的访问。"

#: ../../library/sys.monitoring.rst:22
msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""
"在程序执行过程中，会发生对于监控执行的工具来说值得关注的事件。 :mod:`sys.monitoring` "
"命名空间提供了在相应事件发生时接收回调的操作方式。"

#: ../../library/sys.monitoring.rst:26
msgid "The monitoring API consists of three components:"
msgstr "monitoring API由三个部分组成："

#: ../../library/sys.monitoring.rst:28
msgid "`Tool identifiers`_"
msgstr "`Tool identifiers`_"

#: ../../library/sys.monitoring.rst:29
msgid "`Events`_"
msgstr "`Events`_"

#: ../../library/sys.monitoring.rst:30
msgid ":ref:`Callbacks <callbacks>`"
msgstr ":ref:`回调 <callbacks>`"

#: ../../library/sys.monitoring.rst:33
msgid "Tool identifiers"
msgstr "工具标识符"

#: ../../library/sys.monitoring.rst:35
msgid ""
"A tool identifier is an integer and the associated name. Tool identifiers "
"are used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""
"工具标识符是一个整数及其所关联的名称。 工具标识符被用来防止工具之间的相互干扰并允许同时操作多个工作。 目前工具是完全独立的且不能被用于相互监控。 "
"这一限制在将来可能会被取消。"

#: ../../library/sys.monitoring.rst:41
msgid ""
"Before registering or activating events, a tool should choose an identifier."
" Identifiers are integers in the range 0 to 5 inclusive."
msgstr "在注册或激活事件之前，工具应选择一个标识符。 标识符是 0 到 5 的开区间内的整数。"

#: ../../library/sys.monitoring.rst:45
msgid "Registering and using tools"
msgstr "注册和使用工具"

#: ../../library/sys.monitoring.rst:49
msgid ""
"Must be called before *tool_id* can be used. *tool_id* must be in the range "
"0 to 5 inclusive. Raises a :exc:`ValueError` if *tool_id* is in use."
msgstr ""
"必须在 *tool_id* 可被使用之前调用。 *tool_id* 必须在 0 到 5 的开区间内。 如果 *tool_id* 已被使用则会引发 "
":exc:`ValueError`。"

#: ../../library/sys.monitoring.rst:55
msgid ""
"Unregister all events and callback functions associated with *tool_id*."
msgstr "注销与 *tool_id* 相关联的所有事件和回调函数。"

#: ../../library/sys.monitoring.rst:59
msgid ""
"Should be called once a tool no longer requires *tool_id*. Will call "
":func:`clear_tool_id` before releasing *tool_id*."
msgstr "应该在工具不再需要 *tool_id* 时调用。 在释放 *tool_id* 之前将调用 :func:`clear_tool_id`。"

#: ../../library/sys.monitoring.rst:64
msgid ""
"Returns the name of the tool if *tool_id* is in use, otherwise it returns "
"``None``. *tool_id* must be in the range 0 to 5 inclusive."
msgstr "如果 *tool_id* 已被使用则返回工具名称，否则返回 ``None``。 *tool_id* 取值必须在 0 至 5 的开区间内。"

#: ../../library/sys.monitoring.rst:68
msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr "虚拟机在处理事件时对所有 ID 都一视同仁，但为便于工具之间的协作而预定义了下列 ID::"

#: ../../library/sys.monitoring.rst:71
msgid ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"
msgstr ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"

#: ../../library/sys.monitoring.rst:78
msgid "Events"
msgstr "事件"

#: ../../library/sys.monitoring.rst:80
msgid "The following events are supported:"
msgstr "以下事件是受支持的："

#: ../../library/sys.monitoring.rst:84
msgid "A conditional branch goes left."
msgstr "条件分支向左。"

#: ../../library/sys.monitoring.rst:86
msgid ""
"It is up to the tool to determine how to present \"left\" and \"right\" "
"branches. There is no guarantee which branch is \"left\" and which is "
"\"right\", except that it will be consistent for the duration of the "
"program."
msgstr "由该工具决定如何表示“左”和“右”分支。不能保证哪个分支是“左”哪个分支是“右”，除非它在程序的持续时间内是一致的。"

#: ../../library/sys.monitoring.rst:92
msgid "A conditional branch goes right."
msgstr "条件分支向右。"

#: ../../library/sys.monitoring.rst:96
msgid "A call in Python code (event occurs before the call)."
msgstr "Python 代码中的调用（事件发生在调用之前）。"

#: ../../library/sys.monitoring.rst:100
msgid ""
"An exception raised from any callable, except for Python functions (event "
"occurs after the exit)."
msgstr "从任意可调用对象引发的异常。 Python 函数除外（事件发生在退出之后）。"

#: ../../library/sys.monitoring.rst:104
msgid ""
"Return from any callable, except for Python functions (event occurs after "
"the return)."
msgstr "从任意可调用对象返回，Python 函数除外（事件在返回之后发生）。"

#: ../../library/sys.monitoring.rst:108
msgid "An exception is handled."
msgstr "一个异常被处理。"

#: ../../library/sys.monitoring.rst:112
msgid "A VM instruction is about to be executed."
msgstr "一个 VM 指令即将被执行。"

#: ../../library/sys.monitoring.rst:116
msgid "An unconditional jump in the control flow graph is made."
msgstr "在控制流图中进行一次无条件的跳转。"

#: ../../library/sys.monitoring.rst:120
msgid ""
"An instruction is about to be executed that has a different line number from"
" the preceding instruction."
msgstr "一条与之前指令行号不同的指令即将被执行。"

#: ../../library/sys.monitoring.rst:124
msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for ``throw()`` calls."
msgstr "恢复执行一个 Python 函数（用于生成器和协程函数），``throw()`` 调用除外。"

#: ../../library/sys.monitoring.rst:128
msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr "从一个 Python 函数返回（在返回之前立即发生，被调用方的帧将在栈中）。"

#: ../../library/sys.monitoring.rst:132
msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr "开始一个 Python 函数（在调用之后立即发生，被调用方的帧将在栈中）"

#: ../../library/sys.monitoring.rst:136
msgid "A Python function is resumed by a ``throw()`` call."
msgstr "一个 Python 函数由 ``throw()`` 调用恢复执行。"

#: ../../library/sys.monitoring.rst:140
msgid ""
"Exit from a Python function during exception unwinding. This includes "
"exceptions raised directly within the function and that are allowed to "
"continue to propagate."
msgstr "在异常展开期间从一个 Python 函数退出。 这包括在该函数内直接引发的以及被允许继续传播的异常。"

#: ../../library/sys.monitoring.rst:145
msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr "从一个 Python 函数产出数据（在产出之前立即发生，被调用方的帧将在栈中）。"

#: ../../library/sys.monitoring.rst:149
msgid ""
"An exception is raised, except those that cause a :monitoring-"
"event:`STOP_ITERATION` event."
msgstr "一个异常被引发，导致 :monitoring-event:`STOP_ITERATION` 事件的异常除外。"

#: ../../library/sys.monitoring.rst:153
msgid ""
"An exception is re-raised, for example at the end of a :keyword:`finally` "
"block."
msgstr "一个异常被重新引发，例如在 :keyword:`finally` 代码块结束的时候。"

#: ../../library/sys.monitoring.rst:157
msgid ""
"An artificial :exc:`StopIteration` is raised; see `the STOP_ITERATION "
"event`_."
msgstr "一个 :exc:`StopIteration` 被人工引发；参见 `the STOP_ITERATION event`_。"

#: ../../library/sys.monitoring.rst:160
msgid "More events may be added in the future."
msgstr "将来可能会添加更多事件。"

#: ../../library/sys.monitoring.rst:162
msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise OR the individual events together. For example, to"
" specify both :monitoring-event:`PY_RETURN` and :monitoring-event:`PY_START`"
" events, use the expression ``PY_RETURN | PY_START``."
msgstr ""
"这些事件都是 :mod:`!sys.monitoring.events` 命名空间的属性。 每个事件用整数常量的 2 次幂来表示。 "
"要定义一组事件，只需对多个单独事件执行按位或运算即可。 例如，要同时指定 :monitoring-event:`PY_RETURN` 和 "
":monitoring-event:`PY_START` 事件，则使用表达式 ``PY_RETURN | PY_START``。"

#: ../../library/sys.monitoring.rst:170
msgid "An alias for ``0`` so users can do explicit comparisons like::"
msgstr "代表 ``0`` 的别名以便用户可以这样执行显式比较::"

#: ../../library/sys.monitoring.rst:172
msgid ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."
msgstr ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."

#: ../../library/sys.monitoring.rst:175
msgid "Setting this event deactivates all events."
msgstr "设置此事件将撤销所有事件的激活。"

#: ../../library/sys.monitoring.rst:180
msgid "Local events"
msgstr "本地事件"

#: ../../library/sys.monitoring.rst:182
msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr "本地事件与程序的正常执行相关联并且发生在明确定义的位置上。 所有本地事件都可以被禁用。 本地事件包括："

#: ../../library/sys.monitoring.rst:186
msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

#: ../../library/sys.monitoring.rst:187
msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

#: ../../library/sys.monitoring.rst:188
msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

#: ../../library/sys.monitoring.rst:189
msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

#: ../../library/sys.monitoring.rst:190
msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

#: ../../library/sys.monitoring.rst:191
msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

#: ../../library/sys.monitoring.rst:192
msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

#: ../../library/sys.monitoring.rst:193
msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

#: ../../library/sys.monitoring.rst:194
msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ":monitoring-event:`BRANCH_LEFT`"

#: ../../library/sys.monitoring.rst:195
msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ":monitoring-event:`BRANCH_RIGHT`"

#: ../../library/sys.monitoring.rst:196
msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

#: ../../library/sys.monitoring.rst:199
msgid "Deprecated event"
msgstr "已弃用的事件"

#: ../../library/sys.monitoring.rst:201
msgid "``BRANCH``"
msgstr "``BRANCH``"

#: ../../library/sys.monitoring.rst:203
msgid ""
"The ``BRANCH`` event is deprecated in 3.14. Using :monitoring-"
"event:`BRANCH_LEFT` and :monitoring-event:`BRANCH_RIGHT` events will give "
"much better performance as they can be disabled independently."
msgstr ""
"``BRANCH`` 事件已在3.14中被弃用。 使用 :monitoring-event:`BRANCH_LEFT` 和 :monitoring-"
"event:`BRANCH_RIGHT` 事件可以提供更好的性能，因为它们可以被单独禁用。"

#: ../../library/sys.monitoring.rst:209
msgid "Ancillary events"
msgstr "辅助事件"

#: ../../library/sys.monitoring.rst:211
msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr "辅助事件可以像其他事件一样被监视，但是由另一个事件来控制："

#: ../../library/sys.monitoring.rst:214
msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

#: ../../library/sys.monitoring.rst:215
msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

#: ../../library/sys.monitoring.rst:217
msgid ""
"The :monitoring-event:`C_RETURN` and :monitoring-event:`C_RAISE` events are "
"controlled by the :monitoring-event:`CALL` event. :monitoring-"
"event:`C_RETURN` and :monitoring-event:`C_RAISE` events will only be seen if"
" the corresponding :monitoring-event:`CALL` event is being monitored."
msgstr ""
":monitoring-event:`C_RETURN` 和 :monitoring-event:`C_RAISE` 事件是由 :monitoring-"
"event:`CALL` 事件控制的。 :monitoring-event:`C_RETURN` 和 :monitoring-"
"event:`C_RAISE` 事件只会在相应的 :monitoring-event:`CALL` 事件被监控时才能被看到。"

#: ../../library/sys.monitoring.rst:223
msgid "Other events"
msgstr "其他事件"

#: ../../library/sys.monitoring.rst:225
msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled."
msgstr "其他事件不一定与程序中的特定位置相关联并且不能被单独禁用。"

#: ../../library/sys.monitoring.rst:228
msgid "The other events that can be monitored are:"
msgstr "可以被监视的其他事件包括："

#: ../../library/sys.monitoring.rst:230
msgid ":monitoring-event:`PY_THROW`"
msgstr ":monitoring-event:`PY_THROW`"

#: ../../library/sys.monitoring.rst:231
msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":monitoring-event:`PY_UNWIND`"

#: ../../library/sys.monitoring.rst:232
msgid ":monitoring-event:`RAISE`"
msgstr ":monitoring-event:`RAISE`"

#: ../../library/sys.monitoring.rst:233
msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":monitoring-event:`EXCEPTION_HANDLED`"

#: ../../library/sys.monitoring.rst:237
msgid "The STOP_ITERATION event"
msgstr "STOP_ITERATION 事件"

#: ../../library/sys.monitoring.rst:239
msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a "
":exc:`StopIteration` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` "
"规定了当从生成器或协程返回值时可引发 :exc:`StopIteration` 异常。 不过，这是一种非常低效的返回值的方式，因此某些 Python "
"实现，比如 CPython 3.12+，只有在异常对其他代码可见时才会引发它。"

#: ../../library/sys.monitoring.rst:245
msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the :monitoring-event:`STOP_ITERATION` event is "
"provided. :monitoring-event:`STOP_ITERATION` can be locally disabled, unlike"
" :monitoring-event:`RAISE`."
msgstr ""
"为允许工具监视真正的异常而不会拖慢生成器和协程的运行，解释器提供了 :monitoring-event:`STOP_ITERATION` 事件。 "
":monitoring-event:`STOP_ITERATION` 可以被局部禁用，这与 :monitoring-event:`RAISE` 不同。"

#: ../../library/sys.monitoring.rst:250
msgid ""
"Note that the :monitoring-event:`STOP_ITERATION` event and the :monitoring-"
"event:`RAISE` event for a :exc:`StopIteration` exception are equivalent, and"
" are treated as interchangeable when generating events. Implementations will"
" favor :monitoring-event:`STOP_ITERATION` for performance reasons, but may "
"generate a :monitoring-event:`RAISE` event with a :exc:`StopIteration`."
msgstr ""
"请注意，:monitoring-event:`STOP_ITERATION` 事件和 :exc:`StopIteration` 异常的 "
":monitoring-event:`RAISE` 事件是等价的，并且在生成事件时被视为可互换的。 出于性能原因，实现将倾向于 :monitoring-"
"event:`STOP_ITERATION`，但可能会使用 :exc:`StopIteration` 生成 :monitoring-"
"event:`RAISE` 事件。"

#: ../../library/sys.monitoring.rst:258
msgid "Turning events on and off"
msgstr "开启和关闭事件"

#: ../../library/sys.monitoring.rst:260
msgid ""
"In order to monitor an event, it must be turned on and a corresponding "
"callback must be registered. Events can be turned on or off by setting the "
"events either globally and/or for a particular code object. An event will "
"trigger only once, even if it is turned on both globally and locally."
msgstr ""
"要监视一个事件，它必须被开启且相应的回调必须被注册。 可以通过将事件设置为全局的和/或针对特定代码对象的来开启或关闭事件。 "
"一个事件将只被触发一次，即使它在全局和局部都被开启。"

#: ../../library/sys.monitoring.rst:267
msgid "Setting events globally"
msgstr "全局设置事件"

#: ../../library/sys.monitoring.rst:269
msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr "通过修改被监视的事件集可以对事件进行全局控制。"

#: ../../library/sys.monitoring.rst:273
msgid "Returns the ``int`` representing all the active events."
msgstr "返回代表所有活动事件的 ``int``。"

#: ../../library/sys.monitoring.rst:277
msgid ""
"Activates all events which are set in *event_set*. Raises a "
":exc:`ValueError` if *tool_id* is not in use."
msgstr "激活在 *event_set* 中设置的所有事件。 如果 *tool_id* 未被使用则会引发 :exc:`ValueError`。"

#: ../../library/sys.monitoring.rst:280
msgid "No events are active by default."
msgstr "在默认情况下没有被激活的事件。"

#: ../../library/sys.monitoring.rst:283
msgid "Per code object events"
msgstr "针对特定代码对象的事件"

#: ../../library/sys.monitoring.rst:285
msgid ""
"Events can also be controlled on a per code object basis. The functions "
"defined below which accept a :class:`types.CodeType` should be prepared to "
"accept a look-alike object from functions which are not defined in Python "
"(see :ref:`c-api-monitoring`)."
msgstr ""
"事件也可以基于每个代码对象来控制。 下面定义的接受一个 :class:`types.CodeType` 的函数应当准备好接受来自不是在 Python "
"中定义的类似对象 (参见 :ref:`c-api-monitoring`)。"

#: ../../library/sys.monitoring.rst:292
msgid "Returns all the local events for *code*"
msgstr "返回 *code* 的所有局部事件"

#: ../../library/sys.monitoring.rst:296
msgid ""
"Activates all the local events for *code* which are set in *event_set*. "
"Raises a :exc:`ValueError` if *tool_id* is not in use."
msgstr ""
"激活在 *event_set* 中设置的针对 *code* 的所有局部事件。 如果 *tool_id* 未被使用则会引发 "
":exc:`ValueError`。"

#: ../../library/sys.monitoring.rst:301
msgid "Disabling events"
msgstr "禁用事件"

#: ../../library/sys.monitoring.rst:305
msgid ""
"A special value that can be returned from a callback function to disable "
"events for the current code location."
msgstr "一个可从回调函数返回以禁用当前代码位置上的事件的特殊值。"

#: ../../library/sys.monitoring.rst:308
msgid ""
"Local events can be disabled for a specific code location by returning "
":data:`sys.monitoring.DISABLE` from a callback function. This does not "
"change which events are set, or any other code locations for the same event."
msgstr ""
"可从回调函数返回 :data:`sys.monitoring.DISABLE` 以禁用特定代码位置上的局部事件。 "
"这不会改变已设置的事件，也不会改变同一事件的任何其他代码位置。"

#: ../../library/sys.monitoring.rst:312
msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr "禁用特定位置的事件对高性能的监控非常重要。 例如，如果调试器禁用了除几个断点外的所有监控那么程序在调试器下运行时就不会产生额外的开销。"

#: ../../library/sys.monitoring.rst:319
msgid ""
"Enable all the events that were disabled by :data:`sys.monitoring.DISABLE` "
"for all tools."
msgstr "启用 :data:`sys.monitoring.DISABLE` 针对所有工具禁用的所有事件。"

#: ../../library/sys.monitoring.rst:326
msgid "Registering callback functions"
msgstr "注册回调函数"

#: ../../library/sys.monitoring.rst:330
msgid "Registers the callable *func* for the *event* with the given *tool_id*"
msgstr "使用给定的 *tool_id* 为 *event* 注册可调用对象 *func*"

#: ../../library/sys.monitoring.rst:332
msgid ""
"If another callback was registered for the given *tool_id* and *event*, it "
"is unregistered and returned. Otherwise :func:`register_callback` returns "
"``None``."
msgstr ""
"如果已经为给定的 *tool_id* 和 *event* 注册了另一个回调，它将被注销并返回。 在其他情况下 "
":func:`register_callback` 将返回 ``None``。"

#: ../../library/sys.monitoring.rst:336
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sys.monitoring.register_callback`` with argument ``func``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>`，事件名称为 ``sys.monitoring.register_callback``，并传入参数"
" ``func``。"

#: ../../library/sys.monitoring.rst:338
msgid ""
"Functions can be unregistered by calling "
"``sys.monitoring.register_callback(tool_id, event, None)``."
msgstr ""
"函数可以通过调用 ``sys.monitoring.register_callback(tool_id, event, None)`` 来注销。"

#: ../../library/sys.monitoring.rst:341
msgid "Callback functions can be registered and unregistered at any time."
msgstr "回调函数可在任何时候被注册或注销。"

#: ../../library/sys.monitoring.rst:343
msgid ""
"Callbacks are called only once regardless if the event is turned on both "
"globally and locally. As such, if an event could be turned on for both "
"global and local events by your code then the callback needs to be written "
"to handle either trigger."
msgstr ""
"回调将只被调用一次，即使事件在全局和局部都被开启。 因此，如果一个事件可以被你的代码在全局和局部同时开启那么回调就需要被编写为同时处理两个触发器。"

#: ../../library/sys.monitoring.rst:350
msgid "Callback function arguments"
msgstr "回调函数参数"

#: ../../library/sys.monitoring.rst:354
msgid ""
"A special value that is passed to a callback function to indicate that there"
" are no arguments to the call."
msgstr "一个传给回调函数表明该调用不附带任何参数的特殊值。"

#: ../../library/sys.monitoring.rst:357
msgid ""
"When an active event occurs, the registered callback function is called. "
"Callback functions returning an object other than :data:`DISABLE` will have "
"no effect. Different events will provide the callback function with "
"different arguments, as follows:"
msgstr ""
"当一个激活的事件发生时，已注册的回调函数将被调用。 回调函数返回 :data:`DISABLE` 以外的对象将没有任何效果。 "
"不同的事件将提供具有不同参数的回调函数，如下所示："

#: ../../library/sys.monitoring.rst:361
msgid ":monitoring-event:`PY_START` and :monitoring-event:`PY_RESUME`::"
msgstr ":monitoring-event:`PY_START` 和 :monitoring-event:`PY_RESUME`::"

#: ../../library/sys.monitoring.rst:363 ../../library/sys.monitoring.rst:400
msgid "func(code: CodeType, instruction_offset: int) -> object"
msgstr "func(code: CodeType, instruction_offset: int) -> object"

#: ../../library/sys.monitoring.rst:365
msgid ":monitoring-event:`PY_RETURN` and :monitoring-event:`PY_YIELD`::"
msgstr ":monitoring-event:`PY_RETURN` 和 :monitoring-event:`PY_YIELD`::"

#: ../../library/sys.monitoring.rst:367
msgid ""
"func(code: CodeType, instruction_offset: int, retval: object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, retval: object) -> object"

#: ../../library/sys.monitoring.rst:369
msgid ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` and :monitoring-"
"event:`C_RETURN` (*arg0* can be :data:`MISSING` specifically)::"
msgstr ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` 和 :monitoring-"
"event:`C_RETURN` (特别地 *arg0* 可以为 :data:`MISSING`)::"

#: ../../library/sys.monitoring.rst:372
msgid ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"

#: ../../library/sys.monitoring.rst:374
msgid ""
"*code* represents the code object where the call is being made, while "
"*callable* is the object that is about to be called (and thus triggered the "
"event). If there are no arguments, *arg0* is set to "
":data:`sys.monitoring.MISSING`."
msgstr ""
"*code* 代表调用所在的代码对象，而 *callable* 是将要被调用的对象（并因此触发事件）。 如果没有参数，*arg0* 将被设为 "
":data:`sys.monitoring.MISSING`。"

#: ../../library/sys.monitoring.rst:379
msgid ""
"For instance methods, *callable* will be the function object as found on the"
" class with *arg0* set to the instance (i.e. the ``self`` argument to the "
"method)."
msgstr "对于实例方法，*callable* 将是在类上找到的 *arg0* 设为该实例的函数对象（该实例即方法的 ``self`` 参数）。"

#: ../../library/sys.monitoring.rst:383
msgid ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-"
"event:`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-"
"event:`PY_THROW` and :monitoring-event:`STOP_ITERATION`::"
msgstr ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-"
"event:`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-"
"event:`PY_THROW` 和 :monitoring-event:`STOP_ITERATION`::"

#: ../../library/sys.monitoring.rst:386
msgid ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"

#: ../../library/sys.monitoring.rst:388
msgid ":monitoring-event:`LINE`::"
msgstr ":monitoring-event:`LINE`::"

#: ../../library/sys.monitoring.rst:390
msgid "func(code: CodeType, line_number: int) -> object"
msgstr "func(code: CodeType, line_number: int) -> object"

#: ../../library/sys.monitoring.rst:392
msgid ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` and "
":monitoring-event:`JUMP`::"
msgstr ""
":monitoring-event:`BRANCH_LEFT`、 :monitoring-event:`BRANCH_RIGHT` 和 "
":monitoring-event:`JUMP`::"

#: ../../library/sys.monitoring.rst:394
msgid ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"

#: ../../library/sys.monitoring.rst:396
msgid ""
"Note that the *destination_offset* is where the code will next execute."
msgstr "注意，*destination_offset* 是代码下一次执行的地方。"

#: ../../library/sys.monitoring.rst:398
msgid ":monitoring-event:`INSTRUCTION`::"
msgstr ":monitoring-event:`INSTRUCTION`::"
