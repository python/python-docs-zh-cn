# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/urllib.request.rst:2
msgid ":mod:`!urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`!urllib.request` --- 用于打开 URL 的可扩展库"

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**源码：** :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in"
" opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
":mod:`urllib.request` 模块定义了适用于在各种复杂情况下打开 URL（主要为 HTTP）的函数和类 --- "
"例如基本认证、摘要认证、重定向、cookies 及其它。"

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"对于更高级别的 HTTP 客户端接口，建议使用 `Requests "
"<https://requests.readthedocs.io/en/master/>`_  。"

#: ../../library/urllib.request.rst:26
msgid ""
"On macOS it is unsafe to use this module in programs using :func:`os.fork` "
"because the :func:`getproxies` implementation for macOS uses a higher-level "
"system API. Set the environment variable ``no_proxy`` to ``*`` to avoid this"
" problem (e.g. ``os.environ[\"no_proxy\"] = \"*\"``)."
msgstr ""
"在 macOS 将此模块用于包含 :func:`os.fork` 的程序是不安全的，因为 macOS 的 :func:`getproxies` "
"实现使用了高层级的系统 API。 可将环境变量 ``no_proxy`` 设为 ``*`` 以避免此问题 (即 "
"``os.environ[\"no_proxy\"] = \"*\"``)。"

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr "此模块在 WebAssembly 平台上无效或不可用。 请参阅 :ref:`wasm-availability` 了解详情。"

#: ../../library/urllib.request.rst:34
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr ":mod:`urllib.request` 模块定义了以下函数："

#: ../../library/urllib.request.rst:39
msgid ""
"Open *url*, which can be either a string containing a valid, properly "
"encoded URL, or a :class:`Request` object."
msgstr "打开 *url*，它可以是一个包含有效的、被正确编码的 URL 的字符串，或是一个 :class:`Request` 对象。"

#: ../../library/urllib.request.rst:42
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* 必须是一个对象，用于给出要发送到服务器的附加数据，若不需要发送数据则为 ``None``。详情请参阅 :class:`Request` 。"

#: ../../library/urllib.request.rst:46
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header"
" in its HTTP requests."
msgstr ""
"urllib.request 模块采用 HTTP/1.1 协议，并且在其 HTTP 请求中包含 ``Connection:close`` 头部信息。"

#: ../../library/urllib.request.rst:49
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking"
" operations like the connection attempt (if not specified, the global "
"default timeout setting will be used).  This actually only works for HTTP, "
"HTTPS and FTP connections."
msgstr ""
"*timeout* 为可选参数，用于指定阻塞操作（如连接尝试）的超时时间，单位为秒。如未指定，将使用全局默认超时参数）。本参数实际仅对 "
"HTTP、HTTPS 和 FTP 连接有效。"

#: ../../library/urllib.request.rst:54
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See "
":class:`~http.client.HTTPSConnection` for more details."
msgstr ""
"如果给定了 *context* 参数，则必须是一个 :class:`ssl.SSLContext` 实例，用于描述各种 SSL 参数。更多详情请参阅 "
":class:`~http.client.HTTPSConnection` 。"

#: ../../library/urllib.request.rst:58
msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See "
":class:`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"本函数总会返回一个对象，该对象可作为 :term:`context manager` 使用，带有 *url*、*headers* 和 *status* "
"属性。有关这些属性的更多详细信息，请参阅 :class:`urllib.response.addinfourl` 。"

#: ../../library/urllib.request.rst:62
msgid ""
"For HTTP and HTTPS URLs, this function returns a "
":class:`http.client.HTTPResponse` object slightly modified. In addition to "
"the three new methods above, the msg attribute contains the same information"
" as the :attr:`~http.client.HTTPResponse.reason` attribute --- the reason "
"phrase returned by server --- instead of the response headers as it is "
"specified in the documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"对于 HTTP 和 HTTPS 的 URL 而言，本函数将返回一个稍经修改的 :class:`http.client.HTTPResponse` "
"对象。除了上述 3 个新的方法之外，还有 msg 属性包含了与 :attr:`~http.client.HTTPResponse.reason` "
"属性相同的信息---服务器返回的原因描述文字，而不是  :class:`~http.client.HTTPResponse` 的文档所述的响应头部信息。"

#: ../../library/urllib.request.rst:70
msgid ""
"For FTP, file, and data URLs and requests explicitly handled by legacy "
":class:`URLopener` and :class:`FancyURLopener` classes, this function "
"returns a :class:`urllib.response.addinfourl` object."
msgstr ""
"对于 FTP、文件、数据的URL，以及由传统的 :class:`URLopener`  和 :class:`FancyURLopener` "
"类处理的请求，本函数将返回一个 :class:`urllib.response.addinfourl` 对象。"

#: ../../library/urllib.request.rst:74
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "协议发生错误时，将会引发 :exc:`~urllib.error.URLError` 。"

#: ../../library/urllib.request.rst:76
msgid ""
"Note that ``None`` may be returned if no handler handles the request (though"
" the default installed global :class:`OpenerDirector` uses "
":class:`UnknownHandler` to ensure this never happens)."
msgstr ""
"请注意，如果没有处理函数对请求进行处理，则有可能会返回 ``None``  。尽管默认安装的全局 :class:`OpenerDirector` 会用 "
":class:`UnknownHandler` 来确保不会发生这种情况。"

#: ../../library/urllib.request.rst:80
msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy``"
" environment variable like :envvar:`!http_proxy` is set), "
":class:`ProxyHandler` is default installed and makes sure the requests are "
"handled through the proxy."
msgstr ""
"另外，如果检测到设置了代理（例如，当设置了 :envvar:`!http_proxy` 之类的 ``*_proxy`` 环境变量时），将默认安装 "
":class:`ProxyHandler` 并确保通过代理来处理请求。"

#: ../../library/urllib.request.rst:85
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary"
" parameter to ``urllib.urlopen``, can be obtained by using "
":class:`ProxyHandler` objects."
msgstr ""
"Python 2.6 以下版本中留存的 ``urllib.urlopen`` 函数已停止使用了； "
":func:`urllib.request.urlopen` 对应于传统的 ``urllib2.urlopen`` "
"。对代理服务的处理是通过将字典参数传给 ``urllib.urlopen`` 来完成的，可以用 :class:`ProxyHandler` "
"对象获取到代理处理函数。"

#: ../../library/urllib.request.rst:91 ../../library/urllib.request.rst:93
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` "
"``urllib.Request`` with arguments ``fullurl``, ``data``, ``headers``, "
"``method`` taken from the request object."
msgstr ""
"默认会为 ``urllib.Request`` 引发一条 :ref:`审计事件 <auditing>`，其参数 "
"``fullurl``、``data``、``headers``、``method`` 均取自请求对象。"

#: ../../library/urllib.request.rst:97
msgid "*cafile* and *capath* were added."
msgstr "增加了 *cafile* 与 *capath*。"

#: ../../library/urllib.request.rst:100
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if "
":const:`ssl.HAS_SNI` is true)."
msgstr "现在将在可能的情况下支持 HTTPS 虚拟主机（也就是说，如果 :const:`ssl.HAS_SNI` 为真值）。"

#: ../../library/urllib.request.rst:103
msgid "*data* can be an iterable object."
msgstr "*data* 可以是一个可迭代对象。"

#: ../../library/urllib.request.rst:105
msgid "*cadefault* was added."
msgstr "增加了 *cadefault*。"

#: ../../library/urllib.request.rst:108
msgid "*context* was added."
msgstr "增加了 *context*。"

#: ../../library/urllib.request.rst:111
msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN "
"protocols with :meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""
"当未给出 *context* 时 HTTPS 连接现在会发送一个带有 ``http/1.1`` 协议指示符的 ALPN 扩展。 自定义 "
"*context* 应当使用 :meth:`~ssl.SSLContext.set_alpn_protocols` 来设置 ALPN 协议。"

#: ../../library/urllib.request.rst:116
msgid ""
"Remove *cafile*, *capath* and *cadefault* parameters: use the *context* "
"parameter instead."
msgstr "移除了 *cafile*, *capath* 和 *cadefault* 形参：请改用 *context* 形参。"

#: ../../library/urllib.request.rst:123
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of "
":func:`~urllib.request.urlopen`.  The code does not check for a real "
":class:`OpenerDirector`, and any class with the appropriate interface will "
"work."
msgstr ""
"安装一个 :class:`OpenerDirector` 实例，作为默认的全局打开函数。仅当 urlopen 用到该打开函数时才需要安装；否则，只需调用"
" :meth:`OpenerDirector.open` 而不是 "
":func:`~urllib.request.urlopen`。代码不会检查是否真的属于 :class:`OpenerDirector` "
"类，所有具备适当接口的类都能适用。"

#: ../../library/urllib.request.rst:133
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the"
" order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler`"
" (if proxy settings are detected), :class:`UnknownHandler`, "
":class:`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, "
":class:`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, "
":class:`HTTPErrorProcessor`."
msgstr ""
"返回一个 :class:`OpenerDirector` 实例，以给定顺序把处理函数串联起来。处理函数可以是 :class:`BaseHandler` "
"的实例，也可以是 :class:`BaseHandler` 的子类（这时构造函数必须允许不带任何参数的调用）。以下类的实例将位于 *处理函数* "
"之前，除非 *处理函数* 已包含这些类、其实例或其子类： :class:`ProxyHandler` "
"（如果检测到代理设置）、:class:`UnknownHandler` 、:class:`HTTPHandler` "
"、:class:`HTTPDefaultErrorHandler` 、:class:`HTTPRedirectHandler` 、 "
":class:`FTPHandler` 、 :class:`FileHandler` 、:class:`HTTPErrorProcessor` 。"

#: ../../library/urllib.request.rst:143
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"若 Python 安装时已带了 SSL 支持（指可以导入 :mod:`ssl` 模块），则还会加入 :class:`HTTPSHandler` 。"

#: ../../library/urllib.request.rst:146
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
" :class:`BaseHandler`  的子类还可以修改 :attr:`handler_order` 属性，以便改变其在处理函数列表中的位置。"

#: ../../library/urllib.request.rst:152
msgid ""
"Convert the given local path to a ``file:`` URL. This function uses "
":func:`~urllib.parse.quote` function to encode the path. For historical "
"reasons, the return value omits the ``file:`` scheme prefix. This example "
"shows the function being used on Windows::"
msgstr ""
"将给定的本地路径转换为一个 ``file:`` URL。 此函数会使用 :func:`~urllib.parse.quote` 函数对路径进行编码。 "
"出于历史原因，返回值将省略 ``file:`` 类别前缀。 下面的例子演示该函数在 Windows 上的使用::"

#: ../../library/urllib.request.rst:157
msgid ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> 'file:' + pathname2url(path)\n"
"'file:///C:/Program%20Files'"
msgstr ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> 'file:' + pathname2url(path)\n"
"'file:///C:/Program%20Files'"

#: ../../library/urllib.request.rst:165
msgid ""
"Convert the given ``file:`` URL to a local path. This function uses "
":func:`~urllib.parse.unquote` to decode the URL. For historical reasons, the"
" given value *must* omit the ``file:`` scheme prefix. This example shows the"
" function being used on Windows::"
msgstr ""
"将给定的 ``file:`` URL 转换为一个本地路径。 此函数会使用 :func:`~urllib.parse.unquote` 对 URL "
"进行解码。 出于历史原因，给定的值 *必须* 省略 ``file:`` 类别前缀。 下面的例子演示该函数在 Windows 上的使用::"

#: ../../library/urllib.request.rst:170
msgid ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url.removeprefix('file:'))\n"
"'C:\\\\Program Files'"
msgstr ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url.removeprefix('file:'))\n"
"'C:\\\\Program Files'"

#: ../../library/urllib.request.rst:177
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it"
" cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is "
"preferred."
msgstr ""
"此辅助函数将返回一个将各个方案映射到代理服务器 URL 的字典。 它会先为所有操作系统以大小写不敏感的方式扫描名为 ``<scheme>_proxy``"
" 的环境变量，当无法找到时，则会在 macOS 上从系统配置中而在 Windows 上从 Windows 系统注册表中查找代理信息。 "
"如果同时存在小写和大写形式的环境变量（且内容不一致），则会首先小写形式。"

#: ../../library/urllib.request.rst:187
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"如果存在环境变量 ``REQUEST_METHOD`` ，通常表示脚本运行于 CGI 环境中，则环境变量 ``HTTP_PROXY`` （大写的 "
"``_PROXY``）将会被忽略。这是因其可以由客户端用 HTTP 头部信息 “Proxy:”注入。若要在 CGI 环境中使用 HTTP "
"代理，请显式使用 ```ProxyHandler`` ，或确保变量名称为小写（或至少是 ``_proxy`` 后缀）。"

#: ../../library/urllib.request.rst:196
msgid "The following classes are provided:"
msgstr "提供了以下类："

#: ../../library/urllib.request.rst:200
msgid "This class is an abstraction of a URL request."
msgstr "URL 请求对象的抽象类。"

#: ../../library/urllib.request.rst:202
msgid "*url* should be a string containing a valid, properly encoded URL."
msgstr "*url* 应为一个包含有效的、被正确编码的 URL 的字符串。"

#: ../../library/urllib.request.rst:204
msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only"
" ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other"
" iterables."
msgstr ""
"*data* 必须是一个对象，用于给定发往服务器的附加数据，若无需此类数据则为 ``None`` 。 目前 唯一用到 *data* 的只有 HTTP "
"请求。支持的对象类型包括字节串、类文件对象和可遍历的类字节串对象。如果没有提供 ``Content-Length`` 和  ``Transfer-"
"Encoding`` 头部字段， :class:`HTTPHandler` 会根据 *data* 的类型设置这些头部字段。``Content-"
"Length`` 将用于发送字节对象，而 :rfc:`7230` 第 3.3.1 节中定义的 ``Transfer-Encoding: "
"chunked`` 将用于发送文件和其他可遍历对象。"

#: ../../library/urllib.request.rst:214
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard "
":mimetype:`application/x-www-form-urlencoded` format.  The "
":func:`urllib.parse.urlencode` function takes a mapping or sequence of "
"2-tuples and returns an ASCII string in this format. It should be encoded to"
" bytes before being used as the *data* parameter."
msgstr ""
"对于 HTTP POST 请求方法而言，*data* 应该是标准 :mimetype:`application/x-www-form-"
"urlencoded` 格式的缓冲区。 :func:`urllib.parse.urlencode` "
"函数的参数为映射对象或二元组序列，并返回一个该编码格式的 ASCII 字符串。在用作 *data* 参数之前，应将其编码为字节串。"

#: ../../library/urllib.request.rst:220
msgid ""
"*headers* should be a dictionary, and will be treated as if "
":meth:`add_header` was called with each key and value as arguments. This is "
"often used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may"
" identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel"
" case."
msgstr ""
"*headers* 应当是一个字典，并将被视同附带了每个键和值作为参数去调用 :meth:`add_header`。 这通常被用于 \"伪装\" "
"``User-Agent`` 标头值，浏览器会使用标头值来标识自己 -- 某些 HTTP 服务器只允许来自普通浏览器的请求而不允许来自脚本的请求。 "
"例如，Mozilla Firefox 可能将自己标识为 ``\"Mozilla/5.0 (X11; U; Linux i686) "
"Gecko/20071127 Firefox/2.0.0.11\"``，而 :mod:`urllib` 的默认用户代理字符串则是 ``\"Python-"
"urllib/2.6\"`` (在 Python 2.6 中)。 所有发送的标头键都使用驼峰命名法。"

#: ../../library/urllib.request.rst:231
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not"
" ``None``, ``Content-Type: application/x-www-form-urlencoded`` will be added"
" as a default."
msgstr ""
"如果给出了 *data* 参数则应当包括一个合适的 ``Content-Type`` 标头。 如果未提供此标头并且 *data* 不为 "
"``None``，则会添加 ``Content-Type: application/x-www-form-urlencoded`` 作为默认值。"

#: ../../library/urllib.request.rst:236
msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr "接下来的两个参数，只对第三方 HTTP cookie 的处理才有用："

#: ../../library/urllib.request.rst:239
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to "
"``http.cookiejar.request_host(self)``.  This is the host name or IP address "
"of the original request that was initiated by the user. For example, if the "
"request is for an image in an HTML document, this should be the request-host"
" of the request for the page containing the image."
msgstr ""
"*origin_req_host* 应为发起初始会话的请求主机，定义参见 :rfc:`2965` 。默认指为 "
"``http.cookiejar.request_host(self)`` 。这是用户发起初始请求的主机名或 IP 地址。假设请求是针对 HTML "
"文档中的图片数据发起的，则本属性应为对包含图像的页面发起请求的主机。"

#: ../../library/urllib.request.rst:247
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifiable* 应该标示出请求是否无法验证，定义参见 :rfc:`2965` 。默认值为 ``False`` "
"。所谓无法验证的请求，是指用户没有机会对请求的 URL 做验证。例如，如果请求是针对 HTML "
"文档中的图像，用户没有机会去许可能自动读取图像，则本参数应为 True。"

#: ../../library/urllib.request.rst:254
msgid ""
"*method* should be a string that indicates the HTTP request method that will"
" be used (e.g. ``'HEAD'``).  If provided, its value is stored in the "
":attr:`~Request.method` attribute and is used by :meth:`get_method`. The "
"default is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. "
"Subclasses may indicate a different default method by setting the "
":attr:`~Request.method` attribute in the class itself."
msgstr ""
"*method* 应为一个指明要使用的 HTTP 请求方法的字符串 (例如 ``'HEAD'``)。 如果提供，其值将存储在 "
":attr:`~Request.method` 属性中并由 :meth:`get_method` 使用。 如果 *data* 为 ``None`` "
"则默认为 ``'GET'``，否则为 ``'POST'``。 子类可以通过在类自身设置 :attr:`~Request.method` "
"属性来指明不同的默认方法。"

#: ../../library/urllib.request.rst:262
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects"
" or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"如果 data 对象无法分多次传递其内容（比如文件或只能生成一次内容的可迭代对象）并且由于 HTTP "
"重定向或身份验证而发生请求重试行为，则该请求不会正常工作。 *data* 是紧挨着头部信息发送给 HTTP 服务器的。现有库不支持 HTTP "
"100-continue 的征询。"

#: ../../library/urllib.request.rst:269
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr "Request 类增加了 :attr:`Request.method` 参数。"

#: ../../library/urllib.request.rst:272
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr "默认 :attr:`Request.method` 可以在类中标明。"

#: ../../library/urllib.request.rst:275
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"如果给出了 ``Content-Length`` ，且 *data* 既不为 ``None`` "
"也不是字节串对象，则不会触发错误。而会退而求其次采用分块传输的编码格式。"

#: ../../library/urllib.request.rst:282
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
":class:`OpenerDirector` 类通过串接在一起的 :class:`BaseHandler` 打开 URL，并负责管理 handler "
"链及从错误中恢复。"

#: ../../library/urllib.request.rst:288
msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr "这是所有已注册 handler 的基类，只做了简单的注册机制。"

#: ../../library/urllib.request.rst:294
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"为 HTTP 错误响应定义的默认 handler，所有出错响应都会转为 :exc:`~urllib.error.HTTPError` 异常。"

#: ../../library/urllib.request.rst:300
msgid "A class to handle redirections."
msgstr "一个用于处理重定向的类。"

#: ../../library/urllib.request.rst:305
msgid "A class to handle HTTP Cookies."
msgstr "一个用于处理 HTTP Cookies 的类。"

#: ../../library/urllib.request.rst:310
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read"
" the list of proxies from the environment variables ``<protocol>_proxy``.  "
"If no proxy environment variables are set, then in a Windows environment "
"proxy settings are obtained from the registry's Internet Settings section, "
"and in a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"让请求转往代理服务。 如果给出了 *proxies*，则它必须是一个将协议名称映射到代理 URL 的字典。 默认是从环境变量 "
"``<protocol>_proxy`` 中读取代理列表。 如果没有设置代理服务的环境变量，则在 Windows 环境下代理设置会从注册表的 "
"Internet Settings 部分获取，而在 macOS 环境下代理信息会从 System Configuration Framework 获取。"

#: ../../library/urllib.request.rst:318
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr "若要禁用自动检测出来的代理，请传入空的字典对象。"

#: ../../library/urllib.request.rst:320
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated"
" list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
"环境变量 :envvar:`no_proxy` 可用于指定不必通过代理访问的主机；应为逗号分隔的主机名后缀列表，可加上 ``:port`` ，例如 "
"``cern.ch,ncsa.uiuc.edu,some.host:8080`` 。"

#: ../../library/urllib.request.rst:327
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"如果设置了 ``REQUEST_METHOD`` 变量，则会忽略 ``HTTP_PROXY`` ；参阅 "
":func:`~urllib.request.getproxies` 文档。"

#: ../../library/urllib.request.rst:333
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr "维护 ``(realm, uri) -> (user, password)`` 映射数据库。"

#: ../../library/urllib.request.rst:338
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"维护 ``(realm, uri) -> (user, password)`` 映射数据库。realm 为 ``None`` "
"视作全匹配，若没有其他合适的安全区域就会检索它。"

#: ../../library/urllib.request.rst:345
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
":class:`HTTPPasswordMgrWithDefaultRealm` 的一个变体，也带有 ``uri -> "
"is_authenticated`` 映射数据库。可被 BasicAuth 处理函数用于确定立即发送身份认证凭据的时机，而不是先等待 ``401`` "
"响应。"

#: ../../library/urllib.request.rst:355
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section "
":ref:`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are"
" not sent, and then if a ``401`` response is received the request is re-sent"
" with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"这是一个帮助完成 HTTP 身份认证的混合类，对远程主机和代理都适用。参数 *password_mgr* 应与 "
":class:`HTTPPasswordMgr` 兼容；关于必须支持哪些接口，请参阅 :ref:`http-password-mgr` 对象的章节。如果"
" *password_mgr* 还提供 ``is_authenticated`` 和 ``update_authenticated`` 方法（请参阅 "
":ref:`http-password-mgr-with-prior-auth` 对象），则 handler 将对给定 URI 用到 "
"``is_authenticated`` 的结果，来确定是否随请求发送身份认证凭据。如果该 URI 的 ``is_authenticated``  返回"
" ``True``，则发送凭据。如果 ``is_authenticated`` 为 ``False`` ，则不发送凭据，然后若收到 ``401`` "
"响应，则使用身份认证凭据重新发送请求。如果身份认证成功，则调用 ``update_authenticated`` 设置该 URI 的 "
"``is_authenticated`` 为 ``True``，这样后续对该 URI 或其所有父 URI 的请求将自动包含该身份认证凭据。"

#: ../../library/urllib.request.rst:372
msgid "Added ``is_authenticated`` support."
msgstr "增加了对 ``is_authenticated`` 的支持。"

#: ../../library/urllib.request.rst:378
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should"
" be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"处理远程主机的身份认证。 *password_mgr* 应与 :class:`HTTPPasswordMgr` 兼容；有关哪些接口是必须支持的，请参阅 "
":ref:`http-password-mgr` 章节。如果给出错误的身份认证方式， HTTPBasicAuthHandler 将会触发 "
":exc:`ValueError` 。"

#: ../../library/urllib.request.rst:387 ../../library/urllib.request.rst:421
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to section"
" :ref:`http-password-mgr` for information on the interface that must be "
"supported."
msgstr ""
"处理有代理服务时的身份认证。 *password_mgr* 应与 :class:`HTTPPasswordMgr` "
"兼容；有关哪些接口是必须支持的，请参阅 :ref:`http-password-mgr` 章节。"

#: ../../library/urllib.request.rst:395
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section "
":ref:`http-password-mgr` for information on the interface that must be "
"supported."
msgstr ""
"这是一个帮助完成 HTTP 身份认证的混合类，对远程主机和代理都适用。参数 *password_mgr* 应与 "
":class:`HTTPPasswordMgr` 兼容；关于必须支持哪些接口，请参阅 :ref:`http-password-mgr` 的章节。"

#: ../../library/urllib.request.rst:404
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should"
" be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried"
" first. If the Digest Authentication returns a 40x response again, it is "
"sent to Basic Authentication handler to Handle.  This Handler method will "
"raise a :exc:`ValueError` when presented with an authentication scheme other"
" than Digest or Basic."
msgstr ""
"处理远程主机的身份认证。 *password_mgr* 应与 :class:`HTTPPasswordMgr` 兼容；有关哪些接口是必须支持的，请参阅 "
":ref:`http-password-mgr` 章节。如果同时添加了 digest 身份认证 handler 和basic 身份认证 "
"handler，则会首先尝试 digest 身份认证。如果 digest 身份认证再返回 40x 响应，会再发送到 basic 身份验证 handler"
" 进行处理。如果给出 Digest 和 Basic 之外的身份认证方式， 本 handler 方法将会触发 :exc:`ValueError` 。"

#: ../../library/urllib.request.rst:414
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "碰到不支持的认证方式时，将会触发 :exc:`ValueError` 。"

#: ../../library/urllib.request.rst:429
msgid "A class to handle opening of HTTP URLs."
msgstr "用于打开 HTTP URL 的 handler 类。"

#: ../../library/urllib.request.rst:434
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"用于打开 HTTPS URL 的 handler 类。*context* 和 *check_hostname* 的含义与  "
":class:`http.client.HTTPSConnection` 的一样。"

#: ../../library/urllib.request.rst:437
msgid "*context* and *check_hostname* were added."
msgstr "添加 *context* 和 *check_hostname* 参数。"

#: ../../library/urllib.request.rst:443
msgid "Open local files."
msgstr "打开本地文件。"

#: ../../library/urllib.request.rst:447
msgid "Open data URLs."
msgstr "打开数据 URL。"

#: ../../library/urllib.request.rst:453
msgid "Open FTP URLs."
msgstr "打开 FTP URL。"

#: ../../library/urllib.request.rst:458
msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr "打开 FTP URL，并将打开的 FTP 连接存入缓存，以便最大程度减少延迟。"

#: ../../library/urllib.request.rst:463
msgid "A catch-all class to handle unknown URLs."
msgstr "处理所有未知类型 URL 的兜底类。"

#: ../../library/urllib.request.rst:468 ../../library/urllib.request.rst:1174
msgid "Process HTTP error responses."
msgstr "处理出错的 HTTP 响应。"

#: ../../library/urllib.request.rst:474
msgid "Request Objects"
msgstr "Request 对象"

#: ../../library/urllib.request.rst:476
msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"以下方法介绍了 :class:`Request` "
"的公开接口，因此子类可以覆盖所有这些方法。这里还定义了几个公开属性，客户端可以利用这些属性了解经过解析的请求。"

#: ../../library/urllib.request.rst:483
msgid "The original URL passed to the constructor."
msgstr "传给构造函数的原始 URL。"

#: ../../library/urllib.request.rst:487
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting "
":attr:`~Request.full_url` returns the original request URL with the "
"fragment, if it was present."
msgstr ""
"Request.full_url 是一个带有 setter、getter 和 deleter 的属性。读取 "
":attr:`~Request.full_url` 属性将会返回附带片段（fragment）的初始请求 URL。"

#: ../../library/urllib.request.rst:493
msgid "The URI scheme."
msgstr "URI 方式。"

#: ../../library/urllib.request.rst:497
msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr "URI 权限，通常是整个主机，但也有可能带有冒号分隔的端口号。"

#: ../../library/urllib.request.rst:502
msgid "The original host for the request, without port."
msgstr "请求的原始主机，不含端口。"

#: ../../library/urllib.request.rst:506
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr "URI 路径。若 :class:`Request` 使用代理，selector 将会是传给代理的完整 URL。"

#: ../../library/urllib.request.rst:511
msgid "The entity body for the request, or ``None`` if not specified."
msgstr "请求的数据体，未给出则为 ``None`` 。"

#: ../../library/urllib.request.rst:513
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header"
" if it was previously set or calculated."
msgstr "现在如果修改 :attr:`Request.data` 的值，则会删除之前设置或计算过的“Content-Length”头部信息。"

#: ../../library/urllib.request.rst:519
msgid ""
"boolean, indicates whether the request is unverifiable as defined by "
":rfc:`2965`."
msgstr "布尔值，标识本请求是否属于 :rfc:`2965` 中定义的无法验证的情况。"

#: ../../library/urllib.request.rst:524
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default"
" computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by"
" passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"要采用的 HTTP 请求方法。默认为 :const:`None`，表示 :meth:`~Request.get_method` "
"将对方法进行正常处理。设置本值可以覆盖 :meth:`~Request.get_method` 中的默认处理过程，设置方式可以是在 "
":class:`Request` 的子类中给出默认值，也可以通过 *method* 参数给 :class:`Request` 构造函数传入一个值。"

#: ../../library/urllib.request.rst:534
msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr "现在可以在子类中设置默认值；而之前只能通过构造函数的实参进行设置。"

#: ../../library/urllib.request.rst:541
msgid ""
"Return a string indicating the HTTP request method.  If "
":attr:`Request.method` is not ``None``, return its value, otherwise return "
"``'GET'`` if :attr:`Request.data` is ``None``, or ``'POST'`` if it's not. "
"This is only meaningful for HTTP requests."
msgstr ""
"返回表示 HTTP  请求方法的字符串。如果 :attr:`Request.method` 不为  ``None`` ，则返回其值。否则若  "
":attr:`Request.data` 为  则返回 ``'GET'``，不为 ``None`` 则返回 ``'POST'`` 。只对 HTTP "
"请求有效。"

#: ../../library/urllib.request.rst:546
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "现在 get_method 会兼顾 :attr:`Request.method` 的值。"

#: ../../library/urllib.request.rst:552
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the"
" same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific)"
" way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"向请求添加一个标头。 标头目前会被所有处理器忽略但只有 HTTP 处理器是例外，该处理器会将它们加入发给服务器的标头列表中。 "
"请注意同名的标头只能有一个，当 *key* 发生冲突时后续的调用将会覆盖之前的调用。 目前，这并不会造成 HTTP "
"功能的损失，因为所有可多次使用而仍有意义的标头都有（特定标头专属的）方式来获得与仅使用一个标头时相同的功能。 "
"请注意使用此方法添加的标头也会被添加到重定向的请求中。"

#: ../../library/urllib.request.rst:564
msgid "Add a header that will not be added to a redirected request."
msgstr "添加一项不会被加入重定向请求的头部信息。"

#: ../../library/urllib.request.rst:569
msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr "返回本实例是否带有命名头部信息（对常规数据和非重定向数据都会检测）。"

#: ../../library/urllib.request.rst:575
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr "从本请求实例中移除指定命名的头部信息（对常规数据和非重定向数据都会检测）。"

#: ../../library/urllib.request.rst:583
msgid "Return the URL given in the constructor."
msgstr "返回构造器中给定的 URL。"

#: ../../library/urllib.request.rst:587
msgid "Returns :attr:`Request.full_url`"
msgstr "返回 :attr:`Request.full_url`"

#: ../../library/urllib.request.rst:592
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr ""
"连接代理服务器，为当前请求做准备。 *host* 和 *type* 将会取代本实例中的对应值，selector 将会是构造函数中给出的初始 URL。"

#: ../../library/urllib.request.rst:599
msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr "返回给定头部信息的数据。如果该头部信息不存在，返回默认值。"

#: ../../library/urllib.request.rst:605
msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr "返回头部信息，形式为（名称, 数据）的元组列表。"

#: ../../library/urllib.request.rst:607
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"自 3.3 "
"起已弃用的下列方法已被删除：add_data、has_data、get_data、get_type、get_host、get_selector、get_origin_req_host"
" 和 is_unverifiable 。"

#: ../../library/urllib.request.rst:616
msgid "OpenerDirector Objects"
msgstr "OpenerDirector 对象"

#: ../../library/urllib.request.rst:618
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr ":class:`OpenerDirector` 实例有以下方法："

#: ../../library/urllib.request.rst:623
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example "
":meth:`http_response` would be the HTTP protocol response handler.  Also "
"*type* should be replaced with the actual HTTP code, for example "
":meth:`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* 应为 :class:`BaseHandler` 的实例。将检索以下类型的方法，并将其添加到对应的处理链中（注意 HTTP "
"错误是特殊情况）。请注意，下文中的 *protocol* 应替换为要处理的实际协议，例如 :meth:`http_response` 将是 HTTP "
"协议响应处理函数。并且 *type* 也应替换为实际的 HTTP 代码，例如 :meth:`http_error_404` 将处理 HTTP 404 "
"错误。"

#: ../../library/urllib.request.rst:631
msgid ""
":meth:`!<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ":meth:`!<protocol>_open` --- 表明该处理器知道如何打开 *protocol* URL。"

#: ../../library/urllib.request.rst:634
msgid "See |protocol_open|_ for more information."
msgstr "更多信息请参阅 |protocol_open|_ 。"

#: ../../library/urllib.request.rst:636
msgid ""
":meth:`!http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""
":meth:`!http_error_\\<type\\>` --- 表明该处理器知道如何处理 HTTP 错误代码 *type* 对应的 HTTP "
"错误。"

#: ../../library/urllib.request.rst:639
msgid "See |http_error_nnn|_ for more information."
msgstr "更多信息请参阅 |http_error_nnn|_ 。"

#: ../../library/urllib.request.rst:641
msgid ""
":meth:`!<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ""
":meth:`!<protocol>_error` --- 表明该处理器知道如何处理来自 (非 ``http``) *protocol* 的错误。"

#: ../../library/urllib.request.rst:644
msgid ""
":meth:`!<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ":meth:`!<protocol>_request` --- 表明该处理器知道如何预处理 *protocol* 请求。"

#: ../../library/urllib.request.rst:647
msgid "See |protocol_request|_ for more information."
msgstr "更多信息请参阅 |protocol_request|_ 。"

#: ../../library/urllib.request.rst:649
msgid ""
":meth:`!<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ":meth:`!<protocol>_response` --- 表明该处理器知道如何后继处理 *protocol* 响应。"

#: ../../library/urllib.request.rst:652
msgid "See |protocol_response|_ for more information."
msgstr "更多信息请参阅 |protocol_response|_ 。"

#: ../../library/urllib.request.rst:661
msgid ""
"Open the given *url* (which can be a request object or a string), optionally"
" passing the given *data*. Arguments, return values and exceptions raised "
"are the same as those of :func:`urlopen` (which simply calls the "
":meth:`open` method on the currently installed global "
":class:`OpenerDirector`).  The optional *timeout* parameter specifies a "
"timeout in seconds for blocking operations like the connection attempt (if "
"not specified, the global default timeout setting will be used). The timeout"
" feature actually works only for HTTP, HTTPS and FTP connections."
msgstr ""
"打开给定的 *url* (可以是一个请求对象或一个字符串），可以选择传入给定的 *data*。 参数、返回值和被引发的异常均与 "
":func:`urlopen` 的相同 (它只是简单地在当前安装的全局 :class:`OpenerDirector` 上调用 :meth:`open`"
" 方法)。 可选的 *timeout* 形参指定了针对阻塞操作例如连接尝试的超时值 (如果未指明，则将使用全局默认的超时设置)。 超时特性仅适用于 "
"HTTP, HTTPS 和 FTP 连接。"

#: ../../library/urllib.request.rst:673
msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol"
" specific).  The HTTP protocol is a special case which uses the HTTP "
"response code to determine the specific error handler; refer to the "
":meth:`!http_error_\\<type\\>` methods of the handler classes."
msgstr ""
"处理一个给定协议的错误。 这将调用针对给定协议的已注册错误处理器并附带给定的参数（这是协议专属的）。 HTTP 协议是一种特殊情况，它使用 HTTP "
"响应码来确定具体的错误处理器；请参阅错误处理器类的 :meth:`!http_error_\\<type\\>` 方法。"

#: ../../library/urllib.request.rst:679
msgid ""
"Return values and exceptions raised are the same as those of "
":func:`urlopen`."
msgstr "返回值和异常均与 :func:`urlopen` 相同。"

#: ../../library/urllib.request.rst:681
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "OpenerDirector 对象分 3 个阶段打开 URL："

#: ../../library/urllib.request.rst:683
msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr "每个阶段中调用这些方法的次序取决于 handler 实例的顺序。"

#: ../../library/urllib.request.rst:686
msgid ""
"Every handler with a method named like :meth:`!<protocol>_request` has that "
"method called to pre-process the request."
msgstr "每个具有名称为 :meth:`!<protocol>_request` 的方法的错误处理器都会调用该方法来对请求进行预处理。"

#: ../../library/urllib.request.rst:689
msgid ""
"Handlers with a method named like :meth:`!<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ "
":const:`None` value (ie. a response), or raises an exception (usually "
":exc:`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""
"具有名称为 :meth:`!<protocol>_open` 的方法的错误处理器将被调用以处理请求。 这一阶段将在错误处理器返回非 "
":const:`None` 值 (即一个响应) 或者引发异常 (通常为 :exc:`~urllib.error.URLError`) 时结束。 "
"异常将被允许传播。"

#: ../../library/urllib.request.rst:694
msgid ""
"In fact, the above algorithm is first tried for methods named "
":meth:`~BaseHandler.default_open`.  If all such methods return "
":const:`None`, the algorithm is repeated for methods named like "
":meth:`!<protocol>_open`.  If all such methods return :const:`None`, the "
"algorithm is repeated for methods named :meth:`~BaseHandler.unknown_open`."
msgstr ""
"实际上，以上算法会先尝试名为 :meth:`~BaseHandler.default_open` 的方法。 如果这些方法全都返回 "
":const:`None`，则会对名为 :meth:`!<protocol>_open` 的方法重复此算法。 如果这些方法也全都返回 "
":const:`None`，则会继承对名为 :meth:`~BaseHandler.unknown_open` 的方法重复此算法。"

#: ../../library/urllib.request.rst:700
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and "
":meth:`~OpenerDirector.error` methods."
msgstr ""
"请注意，这些方法的代码可能会调用 :class:`OpenerDirector` 父实例的 :meth:`~OpenerDirector.open` 和"
" :meth:`~OpenerDirector.error` 方法。"

#: ../../library/urllib.request.rst:704
msgid ""
"Every handler with a method named like :meth:`!<protocol>_response` has that"
" method called to post-process the response."
msgstr "每个具有名称为 :meth:`!<protocol>_response` 的方法的错误处理器都会调用该方法来对响应进行后续处理。"

#: ../../library/urllib.request.rst:711
msgid "BaseHandler Objects"
msgstr "BaseHandler 对象"

#: ../../library/urllib.request.rst:713
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ":class:`BaseHandler` 对象提供了一些直接可用的方法，以及其他一些可供派生类使用的方法。以下是可供直接使用的方法："

#: ../../library/urllib.request.rst:720
msgid "Add a director as parent."
msgstr "将 director 加为父 OpenerDirector。"

#: ../../library/urllib.request.rst:725
msgid "Remove any parents."
msgstr "移除所有父 OpenerDirector。"

#: ../../library/urllib.request.rst:727
msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr "以下属性和方法仅供 :class:`BaseHandler` 的子类使用："

#: ../../library/urllib.request.rst:732
msgid ""
"The convention has been adopted that subclasses defining "
":meth:`!<protocol>_request` or :meth:`!<protocol>_response` methods are "
"named :class:`!\\*Processor`; all others are named :class:`!\\*Handler`."
msgstr ""
"以下约定已被采纳：定义 :meth:`!<protocol>_request` 或 :meth:`!<protocol>_response` "
"方法的子类应当命名为 :class:`!\\*Processor`；所有其他子类应当命名为 :class:`!\\*Handler`。"

#: ../../library/urllib.request.rst:739
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different"
" protocol, or handle errors."
msgstr "一个可用的 :class:`OpenerDirector`，可用于以其他协议打开 URI，或处理错误。"

#: ../../library/urllib.request.rst:745
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr "本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要捕获所有 URL 则应进行定义。"

#: ../../library/urllib.request.rst:748
msgid ""
"This method, if implemented, will be called by the parent "
":class:`OpenerDirector`.  It should return a file-like object as described "
"in the return value of the :meth:`~OpenerDirector.open` method of "
":class:`OpenerDirector`, or ``None``. It should raise "
":exc:`~urllib.error.URLError`, unless a truly exceptional thing happens (for"
" example, :exc:`MemoryError` should not be mapped to "
":exc:`~urllib.error.URLError`)."
msgstr ""
"如果实现了本方法，则它将被上级 :class:`OpenerDirector` 所调用。 它应当返回一个如 "
":class:`OpenerDirector` 的 :meth:`~OpenerDirector.open` 方法的返回值所描述的文件型对象，或是返回 "
"``None``。 它应当引发 :exc:`~urllib.error.URLError`，除非发生真正的异常 "
"(例如，:exc:`MemoryError` 就不应被映射为 :exc:`~urllib.error.URLError`)。"

#: ../../library/urllib.request.rst:755
msgid "This method will be called before any protocol-specific open method."
msgstr "本方法将会在所有协议的 open 方法之前被调用。"

#: ../../library/urllib.request.rst:762
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr "本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要处理给定协议的 URL 则应进行定义。"

#: ../../library/urllib.request.rst:765
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. Return values should be the same as for  "
":meth:`~BaseHandler.default_open`."
msgstr ""
"此方法如果被定义，它将被上级 :class:`OpenerDirector` 调用。 返回值应当与 "
":meth:`~BaseHandler.default_open` 的相同。"

#: ../../library/urllib.request.rst:771
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler"
" to open it."
msgstr ""
"本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要捕获并打开所有未注册 handler 的 URL，则应进行定义。"

#: ../../library/urllib.request.rst:775
msgid ""
"This method, if implemented, will be called by the :attr:`parent` "
":class:`OpenerDirector`.  Return values should be the same as for "
":meth:`default_open`."
msgstr ""
"若实现了本方法，将会被 :attr:`parent` 属性指向的父 :class:`OpenerDirector` 调用。返回值和 "
":meth:`default_open` 的一样。"

#: ../../library/urllib.request.rst:782
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  "
":class:`OpenerDirector` getting the error, and should not normally be called"
" in other circumstances."
msgstr ""
"本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要为所有未定义 handler 的 HTTP "
"错误提供一个兜底方法，则应进行重写。:class:`OpenerDirector` 会自动调用本方法，获取错误信息，而通常在其他时候不应去调用。"

#: ../../library/urllib.request.rst:787
msgid ""
"*req* will be a :class:`Request` object, *fp* will be a file-like object "
"with the HTTP error body, *code* will be the three-digit code of the error, "
"*msg* will be the user-visible explanation of the code and *hdrs* will be a "
"mapping object with the headers of the error."
msgstr ""
"*req* 会是一个 :class:`Request` 对象，*fp* 是一个带有 HTTP 错误体的文件型对象，*code* "
"是三位数的错误码，*msg* 是供用户阅读的解释信息，*hdrs* 则是一个包含出错头部信息的字典对象。"

#: ../../library/urllib.request.rst:792
msgid ""
"Return values and exceptions raised should be the same as those of "
":func:`urlopen`."
msgstr "返回值和触发的异常应与 :func:`urlopen` 的相同。"

#: ../../library/urllib.request.rst:799
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* 应为三位数的 HTTP 错误码。本方法在 :class:`BaseHandler` 中也未予定义，但当子类的实例发生代码为 *nnn* 的 "
"HTTP 错误时，若方法存在则会被调用。"

#: ../../library/urllib.request.rst:803
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr "子类应该重写本方法，以便能处理相应的 HTTP 错误。"

#: ../../library/urllib.request.rst:805
msgid ""
"Arguments, return values and exceptions raised should be the same as for "
":meth:`~BaseHandler.http_error_default`."
msgstr "参数、返回值和被引发的异常应当与 :meth:`~BaseHandler.http_error_default` 的相同。"

#: ../../library/urllib.request.rst:813
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr "本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要对给定协议的请求进行预处理，则应进行定义。"

#: ../../library/urllib.request.rst:816
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. *req* will be a :class:`Request` object. The return"
" value should be a :class:`Request` object."
msgstr ""
"若实现了本方法，将会被父 :class:`OpenerDirector` 调用。*req* 将为 :class:`Request` 对象。返回值应为 "
":class:`Request` 对象。"

#: ../../library/urllib.request.rst:825
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr "本方法在 :class:`BaseHandler` 中 *未* 予定义，但其子类若要对给定协议的请求进行后处理，则应进行定义。"

#: ../../library/urllib.request.rst:828
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. *req* will be a :class:`Request` object. *response*"
" will be an object implementing the same interface as the return value of "
":func:`urlopen`.  The return value should implement the same interface as "
"the return value of :func:`urlopen`."
msgstr ""
"若实现了本方法，将会被父 :class:`OpenerDirector` 调用。*req* 将为 :class:`Request` "
"对象。*response* 应实现与  :func:`urlopen` 返回值相同的接口。返回值应实现与 :func:`urlopen` "
"返回值相同的接口。"

#: ../../library/urllib.request.rst:838
msgid "HTTPRedirectHandler Objects"
msgstr "HTTPRedirectHandler 对象"

#: ../../library/urllib.request.rst:842
msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616`"
" for details of the precise meanings of the various redirection codes."
msgstr ""
"某些 HTTP 重定向操作需要本模块的客户端代码提供的功能。这时会触发 "
":exc:`~urllib.error.HTTPError`。有关各种重定向代码的确切含义，请参阅 :rfc:`2616` 。"

#: ../../library/urllib.request.rst:846
msgid ""
"An :exc:`~urllib.error.HTTPError` exception raised as a security "
"consideration if the HTTPRedirectHandler is presented with a redirected URL "
"which is not an HTTP, HTTPS or FTP URL."
msgstr ""
"如果发给 HTTPRedirectHandler 的重定向 URL 不是 HTTP, HTTPS 或 FTP URL 则出于安全考虑将会引发 "
":exc:`~urllib.error.HTTPError` 异常。"

#: ../../library/urllib.request.rst:853
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`!http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow "
":meth:`!http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, "
"raise :exc:`~urllib.error.HTTPError` if no other handler should try to "
"handle this URL, or return ``None`` if you can't but another handler might."
msgstr ""
"返回一个 :class:`Request` 或 ``None`` 作为对重定义的响应。 此方法将在服务器接收到重定向请求时由 "
":meth:`!http_error_30\\*` 方法的默认实现执行调用。 如果确实应当发生重定向，则返回一个新的 :class:`Request` "
"以允许 :meth:`!http_error_30\\*` 重定向到 *newurl*。 在其他情况下，如果没有其他处理器来处理此 URL 则会引发 "
":exc:`~urllib.error.HTTPError`，或者如果此方法不能处理但或许还有其他处理器会处理则返回 ``None``。"

#: ../../library/urllib.request.rst:863
msgid ""
"The default implementation of this method does not strictly follow "
":rfc:`2616`, which says that 301 and 302 responses to ``POST`` requests must"
" not be automatically redirected without confirmation by the user.  In "
"reality, browsers do allow automatic redirection of these responses, "
"changing the POST to a ``GET``, and the default implementation reproduces "
"this behavior."
msgstr ""
"本方法的默认实现代码并未严格遵循 :rfc:`2616`，即 ``POST`` 请求的 301 和 302 "
"响应不得在未经用户确认的情况下自动进行重定向。现实情况下，浏览器确实允许自动重定向这些响应，将 POST 更改为 ``GET`` "
"，于是默认实现代码就复现了这种处理方式。"

#: ../../library/urllib.request.rst:872
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the"
" parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"重定向到 ``Location:`` 或 ``URI:`` URL。 当得到 HTTP 'moved permanently' 响应时，本方法会被父级 "
":class:`OpenerDirector` 调用。"

#: ../../library/urllib.request.rst:878
msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr "与  :meth:`http_error_301` 相同，不过是发生“found”响应时的调用。"

#: ../../library/urllib.request.rst:883
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr "与  :meth:`http_error_301` 相同，不过是发生“see other”响应时的调用。"

#: ../../library/urllib.request.rst:888
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"与 :meth:`http_error_301` 一样，但是针对 '临时重定向' 响应进行调用。 它不允许将请求方法从 ``POST`` 改为 "
"``GET``。"

#: ../../library/urllib.request.rst:895
msgid ""
"The same as :meth:`http_error_301`, but called for the 'permanent redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"与 :meth:`http_error_301` 一样，但是针对 '永久重定向' 响应进行调用。 它不允许将请求方法从 ``POST`` 改为 "
"``GET``。"

#: ../../library/urllib.request.rst:905
msgid "HTTPCookieProcessor Objects"
msgstr "HTTPCookieProcessor 对象"

#: ../../library/urllib.request.rst:907
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr ":class:`HTTPCookieProcessor` 的实例具备一个属性："

#: ../../library/urllib.request.rst:911
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr "cookie 存放在 :class:`http.cookiejar.CookieJar` 中。"

#: ../../library/urllib.request.rst:917
msgid "ProxyHandler Objects"
msgstr "ProxyHandler 对象"

#: ../../library/urllib.request.rst:923
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`!<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""
":class:`ProxyHandler` 将有对应每种 *protocol* 的 :meth:`!<protocol>_open` "
"方法，在构造函数给出的 *proxies* 字典中包含相应的代理。 通过调用 "
"``request.set_proxy()``，本方法将把请求修改为通过代理，并调用链中的下一个处理器来实际执行协议。"

#: ../../library/urllib.request.rst:933
msgid "HTTPPasswordMgr Objects"
msgstr "HTTPPasswordMgr 对象"

#: ../../library/urllib.request.rst:935
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and "
":class:`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"以下方法 :class:`HTTPPasswordMgr` 和 :class:`HTTPPasswordMgrWithDefaultRealm` "
"对象均有提供。"

#: ../../library/urllib.request.rst:941
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and"
" *passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any"
" of the given URIs is given."
msgstr ""
"*uri* 可以是单个 URI，也可以是 URI 列表。*realm*、*user* 和 *passwd* 必须是字符串。这使得在为 *realm* "
"和超级 URI 进行身份认证时，``(user, passwd)`` 可用作认证令牌。"

#: ../../library/urllib.request.rst:949
msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr "为给定 realm 和 URI 获取用户名和密码。如果没有匹配的用户名和密码，本方法将会返回 ``(None, None)`` 。"

#: ../../library/urllib.request.rst:952
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"对于 :class:`HTTPPasswordMgrWithDefaultRealm` 对象，如果给定 *realm* 没有匹配的用户名和密码，将搜索 "
"realm  ``None``。"

#: ../../library/urllib.request.rst:959
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "HTTPPasswordMgrWithPriorAuth 对象"

#: ../../library/urllib.request.rst:961
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr ""
"这是 :class:`HTTPPasswordMgrWithDefaultRealm` 的扩展，以便对那些需要一直发送认证凭证的 URI 进行跟踪。"

#: ../../library/urllib.request.rst:968
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for "
":meth:`HTTPPasswordMgr.add_password`.  *is_authenticated* sets the initial "
"value of the ``is_authenticated`` flag for the given URI or list of URIs. If"
" *is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*、*uri*、*user*、*passwd* 的含义与 :meth:`HTTPPasswordMgr.add_password` "
"的相同。*is_authenticated* 为给定 URI 或 URI 列表设置 ``is_authenticated`` 标志的初始值。如果 "
"*is_authenticated* 设为 ``True`` ，则会忽略 *realm*。"

#: ../../library/urllib.request.rst:976
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "与 :class:`HTTPPasswordMgrWithDefaultRealm` 对象的相同。"

#: ../../library/urllib.request.rst:982
msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr "更新给定 *uri* 或 URI 列表的 ``is_authenticated`` 标志。"

#: ../../library/urllib.request.rst:988
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given "
"URI."
msgstr "返回给定 URI ``is_authenticated`` 标志的当前状态。"

#: ../../library/urllib.request.rst:995
msgid "AbstractBasicAuthHandler Objects"
msgstr "AbstractBasicAuthHandler 对象"

#: ../../library/urllib.request.rst:1000
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the"
" URL and path to authenticate for, *req* should be the (failed) "
":class:`Request` object, and *headers* should be the error headers."
msgstr ""
"通过获取用户名和密码并重新尝试请求，以处理身份认证请求。 *authreq* 应该是请求中包含 realm 的头部信息名称，*host* "
"指定了需要进行身份认证的 URL 和路径，*req* 应为 (已失败的) :class:`Request` 对象 ,  *headers* "
"应该是出错的头部信息。"

#: ../../library/urllib.request.rst:1006
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* 要么是一个认证信息（例如 ``\"python.org\"`` ），要么是一个包含认证信息的 URL（如 "
"``\"http://python.org/\"`` ）。 不论是哪种格式，认证信息中都不能包含用户信息（因此， ``\"python.org\"`` "
"和 ``\"python.org:80\"`` 没问题，而 ``\"joe:password@python.org\"`` 则不行）。"

#: ../../library/urllib.request.rst:1015
msgid "HTTPBasicAuthHandler Objects"
msgstr "HTTPBasicAuthHandler 对象"

#: ../../library/urllib.request.rst:1020 ../../library/urllib.request.rst:1031
#: ../../library/urllib.request.rst:1056 ../../library/urllib.request.rst:1067
msgid "Retry the request with authentication information, if available."
msgstr "如果可用的话，请用身份认证信息重试请求。"

#: ../../library/urllib.request.rst:1026
msgid "ProxyBasicAuthHandler Objects"
msgstr "ProxyBasicAuthHandler 对象"

#: ../../library/urllib.request.rst:1037
msgid "AbstractDigestAuthHandler Objects"
msgstr "AbstractDigestAuthHandler 对象"

#: ../../library/urllib.request.rst:1042
msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* 应为请求中有关 realm 的头部信息名称，*host* 应为需要进行身份认证的主机，*req* 应为（已失败的） "
":class:`Request` 对象， *headers* 则应为出错的头部信息。"

#: ../../library/urllib.request.rst:1051
msgid "HTTPDigestAuthHandler Objects"
msgstr "HTTPDigestAuthHandler 对象"

#: ../../library/urllib.request.rst:1062
msgid "ProxyDigestAuthHandler Objects"
msgstr "ProxyDigestAuthHandler 对象"

#: ../../library/urllib.request.rst:1073
msgid "HTTPHandler Objects"
msgstr "HTTPHandler 对象"

#: ../../library/urllib.request.rst:1078
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on "
"``req.data``."
msgstr "发送 HTTP 请求，它可以是 GET 或 POST，这取决于 ``req.data``。"

#: ../../library/urllib.request.rst:1085
msgid "HTTPSHandler Objects"
msgstr "HTTPSHandler 对象"

#: ../../library/urllib.request.rst:1090
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on "
"``req.data``."
msgstr "发送 HTTPS 请求，它可以是 GET 或 POST，这取决于 ``req.data``。"

#: ../../library/urllib.request.rst:1097
msgid "FileHandler Objects"
msgstr "FileHandler 对象"

#: ../../library/urllib.request.rst:1102
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr "若无主机名或主机名为 ``'localhost'`` ，则打开本地文件。"

#: ../../library/urllib.request.rst:1105
msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, a :exc:`~urllib.error.URLError` is raised."
msgstr "本方法仅适用于本地主机名。 当给出一个远程主机名时，将会引发 :exc:`~urllib.error.URLError`。"

#: ../../library/urllib.request.rst:1113
msgid "DataHandler Objects"
msgstr "DataHandler 对象"

#: ../../library/urllib.request.rst:1117
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation"
" ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise a :exc:`ValueError` in that case."
msgstr ""
"读取一个数据 URL。 这种 URL 在 URL 本身就包含了已编码内容。 数据 URL 语法是在 :rfc:`2397` 中规定的。 当前的实现会忽略"
" base64 编码的数据 URL 中的空格以便 URL 可以被包装在任何其所在的源文件中。 但是即使某些浏览器不会在意 base64 编码的数据 "
"URL 末尾缺失的填充字符，当前的实现仍会在此情况下引发 :exc:`ValueError`。"

#: ../../library/urllib.request.rst:1128
msgid "FTPHandler Objects"
msgstr "FTPHandler 对象"

#: ../../library/urllib.request.rst:1133
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr "打开由 *req* 给出的 FTP 文件。登录时的用户名和密码总是为空。"

#: ../../library/urllib.request.rst:1140
msgid "CacheFTPHandler Objects"
msgstr "CacheFTPHandler 对象"

#: ../../library/urllib.request.rst:1142
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ":class:`CacheFTPHandler` 对象即为加入以下方法的 :class:`FTPHandler` 对象："

#: ../../library/urllib.request.rst:1148
msgid "Set timeout of connections to *t* seconds."
msgstr "设置连接超时为 *t* 秒。"

#: ../../library/urllib.request.rst:1153
msgid "Set maximum number of cached connections to *m*."
msgstr "设置已缓存的最大连接数为 *m* 。"

#: ../../library/urllib.request.rst:1159
msgid "UnknownHandler Objects"
msgstr "UnknownHandler 对象"

#: ../../library/urllib.request.rst:1164
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "触发 :exc:`~urllib.error.URLError` 异常。"

#: ../../library/urllib.request.rst:1170
msgid "HTTPErrorProcessor Objects"
msgstr "HTTPErrorProcessor 对象"

#: ../../library/urllib.request.rst:1176
msgid "For 200 error codes, the response object is returned immediately."
msgstr "对于 200 错误码，响应对象应立即返回。"

#: ../../library/urllib.request.rst:1178
msgid ""
"For non-200 error codes, this simply passes the job on to the "
":meth:`!http_error_\\<type\\>` handler methods, via "
":meth:`OpenerDirector.error`. Eventually, :class:`HTTPDefaultErrorHandler` "
"will raise an :exc:`~urllib.error.HTTPError` if no other handler handles the"
" error."
msgstr ""
"对于除 200 以外的错误代码，会仅通过 :meth:`OpenerDirector.error` 将任务传给 "
":meth:`!http_error_\\<type\\>` 处理器方法。 最终，如果没有其他处理器来处理该错误则 "
":class:`HTTPDefaultErrorHandler` 将引发 :exc:`~urllib.error.HTTPError`。"

#: ../../library/urllib.request.rst:1186
msgid "Process HTTPS error responses."
msgstr "HTTPS 出错响应的处理。"

#: ../../library/urllib.request.rst:1188
msgid "The behavior is same as :meth:`http_response`."
msgstr "与 :meth:`http_response` 方法相同。"

#: ../../library/urllib.request.rst:1194
msgid "Examples"
msgstr "例子"

#: ../../library/urllib.request.rst:1196
msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr ":ref:`urllib-howto` 中给出了更多的示例。"

#: ../../library/urllib.request.rst:1199
msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it::"
msgstr "以下示例将抓取 python.org 主页并显示前 300 个字节的内容::"

#: ../../library/urllib.request.rst:1202
msgid ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html class=\"no-js ie8 lt-ie9\">"
msgstr ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html class=\"no-js ie8 lt-ie9\">"

#: ../../library/urllib.request.rst:1208
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"请注意，urlopen 将返回字节对象。这是因为 urlopen 无法自动确定由 HTTP "
"服务器收到的字节流的编码。通常，只要能确定或猜出编码格式，就应将返回的字节对象解码为字符串。"

#: ../../library/urllib.request.rst:1214
msgid ""
"The following HTML spec document, https://html.spec.whatwg.org/#charset, "
"lists the various ways in which an HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"以下 HTML 规范文档 https://html.spec.whatwg.org/#charset 列出了 HTML 或 XML "
"文档可用来指明其编码格式信息的多种方式。"

#: ../../library/urllib.request.rst:1218
msgid ""
"For additional information, see the W3C document: "
"https://www.w3.org/International/questions/qa-html-encoding-declarations."
msgstr ""
"要了解更多信息，请参阅 W3C 文档: https://www.w3.org/International/questions/qa-html-"
"encoding-declarations."

#: ../../library/urllib.request.rst:1220
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object::"
msgstr "由于 python.org 网站如 meta 标记所指明的那样是使用 *utf-8* 编码格式，我们将用它来解码字节串对象::"

#: ../../library/urllib.request.rst:1223
msgid ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\n"
"<!-"
msgstr ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\n"
"<!-"

#: ../../library/urllib.request.rst:1230
msgid ""
"It is also possible to achieve the same result without using the "
":term:`context manager` approach::"
msgstr "不使用 :term:`context manager` 方式也可以获得同样的结果::"

#: ../../library/urllib.request.rst:1233
msgid ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\n"
"<!--"
msgstr ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <![endif]-->\n"
"<!--"

#: ../../library/urllib.request.rst:1244
msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI"
" and reading the data it returns to us. Note that this example will only "
"work when the Python installation supports SSL. ::"
msgstr "以下示例将会把数据流发送给某 CGI 的 stdin，并读取返回数据。请注意，该示例只能工作于 Python 装有 SSL 支持的环境。"

#: ../../library/urllib.request.rst:1248
msgid ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""
msgstr ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""

#: ../../library/urllib.request.rst:1256
msgid "The code for the sample CGI used in the above example is::"
msgstr "上述示例中的 CGI 代码如下所示："

#: ../../library/urllib.request.rst:1258
msgid ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"
msgstr ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"

#: ../../library/urllib.request.rst:1263
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr "下面是利用 :class:`Request` 发送 ``PUT`` 请求的示例："

#: ../../library/urllib.request.rst:1265
msgid ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"
msgstr ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"

#: ../../library/urllib.request.rst:1273
msgid "Use of Basic HTTP Authentication::"
msgstr "基本 HTTP 认证示例："

#: ../../library/urllib.request.rst:1275
msgid ""
"import urllib.request\n"
"# Create an OpenerDirector with support for Basic HTTP Authentication...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...and install it globally so it can be used with urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"# 创建一个带有 Basic HTTP Authentication 支持的 OpenerDirector...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...并全局安装以便其能配合 urlopen 使用。\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1288
msgid ""
":func:`build_opener` provides many handlers by default, including a "
":class:`ProxyHandler`.  By default, :class:`ProxyHandler` uses the "
"environment variables named ``<scheme>_proxy``, where ``<scheme>`` is the "
"URL scheme involved.  For example, the :envvar:`!http_proxy` environment "
"variable is read to obtain the HTTP proxy's URL."
msgstr ""
":func:`build_opener` 默认提供了许多处理器，包括 :class:`ProxyHandler`。 "
"在默认情况下，:class:`ProxyHandler` 会使用名为 ``<scheme>_proxy`` 的环境变量，其中 ``<scheme>`` "
"是对应的 URL 方案。 例如，可以读取 :envvar:`!http_proxy` 环境变量可获得 HTTP 代理的 URL."

#: ../../library/urllib.request.rst:1294
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"这个示例将默认的 :class:`ProxyHandler` 替换为使用以编程方式提供的代理 URL，并通过 "
":class:`ProxyBasicAuthHandler` 添加代理认证支持。 ::"

#: ../../library/urllib.request.rst:1298
msgid ""
"proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# This time, rather than install the OpenerDirector, we use it directly:\n"
"with opener.open('http://www.example.com/login.html') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""
"proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# 这次，我们不安装 OpenerDirector，而是直接使用它：\n"
"with opener.open('http://www.example.com/login.html') as f:\n"
"   print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1307
msgid "Adding HTTP headers:"
msgstr "添加 HTTP 头部信息："

#: ../../library/urllib.request.rst:1309
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr "可利用 :class:`Request` 构造函数的 *headers* 参数，或者是："

#: ../../library/urllib.request.rst:1311
msgid ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Customize the default User-Agent header value:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# 自定义默认的 User-Agent 标头值：\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1320
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header"
" to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` 自动会在每个 :class:`Request` 中加入一项 :mailheader:`User-"
"Agent` 头部信息。若要修改，请参见以下语句："

#: ../../library/urllib.request.rst:1323
msgid ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1329
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, "
":mailheader:`Content-Type` and :mailheader:`Host`) are added when the "
":class:`Request` is passed to :func:`urlopen` (or "
":meth:`OpenerDirector.open`)."
msgstr ""
"另请记得，当 :class:`Request` 传给  :func:`urlopen`  （或 "
":meth:`OpenerDirector.open`）时，会加入一些标准的头部信息（ :mailheader:`Content-Length` 、 "
":mailheader:`Content-Type` 和 :mailheader:`Host`）。"

#: ../../library/urllib.request.rst:1336
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr "以下会话示例用 ``GET`` 方法读取包含参数的 URL。"

#: ../../library/urllib.request.rst:1339
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

#: ../../library/urllib.request.rst:1347
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr "以下示例换用 ``POST`` 方法。请注意 urlencode 输出结果先被编码为字节串 data，再送入 urlopen。"

#: ../../library/urllib.request.rst:1350
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

#: ../../library/urllib.request.rst:1358
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr "以下示例显式指定了 HTTP 代理，以覆盖环境变量中的设置："

#: ../../library/urllib.request.rst:1361
msgid ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.FancyURLopener(proxies)\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.FancyURLopener(proxies)\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."

#: ../../library/urllib.request.rst:1368
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr "以下示例根本不用代理，也覆盖了环境变量中的设置："

#: ../../library/urllib.request.rst:1370
msgid ""
">>> import urllib.request\n"
">>> opener = urllib.request.FancyURLopener({})\n"
">>> with opener.open(\"http://www.python.org/\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> opener = urllib.request.FancyURLopener({})\n"
">>> with opener.open(\"http://www.python.org/\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."

#: ../../library/urllib.request.rst:1378
msgid "Legacy interface"
msgstr "已停用的接口"

#: ../../library/urllib.request.rst:1380
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr "以下函数和类是由 Python 2 模块 ``urllib`` （相对早于 ``urllib2`` ）移植过来的。将来某个时候可能会停用。"

#: ../../library/urllib.request.rst:1386
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to"
" a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the "
":meth:`!info` method of the object returned by :func:`urlopen` returned (for"
" a remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""
"将一个 URL 形式的网络对象复制为本地文件。 如果 URL 指向一个本地文件，则必须提供文件名才会复制对象。 返回一个元组 ``(filename, "
"headers)`` 其中 *filename* 为保存该对象的本地文件名，而 *headers* 是由 :func:`urlopen` 返回的对象的 "
":meth:`!info` 方法的返回结果（对于远程对象）。 可引发的异常与 :func:`urlopen` 的相同。"

#: ../../library/urllib.request.rst:1393
msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"第二个参数指定文件的保存位置（若未给出，则会是名称随机生成的临时文件）。第三个参数是个可调用对象，在建立网络连接时将会调用一次，之后每次读完数据块后会调用一次。该可调用对象将会传入"
" 3 个参数：已传输的块数、块的大小（以字节为单位）和文件总的大小。如果面对的是老旧 FTP 服务器，文件大小参数可能会是 ``-1`` "
"，这些服务器响应读取请求时不会返回文件大小。"

#: ../../library/urllib.request.rst:1402
msgid "The following example illustrates the most common usage scenario::"
msgstr "以下例子演示了大部分常用场景："

#: ../../library/urllib.request.rst:1404
msgid ""
">>> import urllib.request\n"
">>> local_filename, headers = urllib.request.urlretrieve('http://python.org/')\n"
">>> html = open(local_filename)\n"
">>> html.close()"
msgstr ""
">>> import urllib.request\n"
">>> local_filename, headers = urllib.request.urlretrieve('http://python.org/')\n"
">>> html = open(local_filename)\n"
">>> html.close()"

#: ../../library/urllib.request.rst:1409
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard "
":mimetype:`application/x-www-form-urlencoded` format; see the "
":func:`urllib.parse.urlencode` function."
msgstr ""
"如果 *url* 使用 :file:`http:` 方式的标识符，则可能给出可选的 *data* 参数来指定一个 ``POST`` 请求 "
"(通常的请求类型为 ``GET``)。 *data* 参数必须是标准 :mimetype:`application/x-www-form-"
"urlencoded` 格式的字节串对象；参见 :func:`urllib.parse.urlencode` 函数。"

#: ../../library/urllib.request.rst:1415
msgid ""
":func:`urlretrieve` will raise :exc:`~urllib.error.ContentTooShortError` "
"when it detects that the amount of data available  was less than the "
"expected amount (which is the size reported by a  *Content-Length* header). "
"This can occur, for example, when the  download is interrupted."
msgstr ""
":func:`urlretrieve` 在检测到可用数据少于预期大小（即由 *Content-Length* 标头所报告的大小）时将引发 "
":exc:`~urllib.error.ContentTooShortError`。 例如，这可能会在下载被中断时发生。 when it detects"
" that the amount of data available  was less than the expected amount (which"
" is the size reported by aheader). This can occur, for example, when the  "
"download is interrupted."

#: ../../library/urllib.request.rst:1420
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises"
" the exception."
msgstr ""
"*Content-Length* 会被视为大小的下限：如果存在更多的可用数据，urlretrieve "
"会读取更多的数据，但是如果可用数据少于该值，则会引发异常。"

#: ../../library/urllib.request.rst:1424
msgid ""
"You can still retrieve the downloaded data in this case, it is stored in the"
" :attr:`!content` attribute of the exception instance."
msgstr "在此情况下你仍然能够获取已下载的数据，它将保存在异常实例的 :attr:`!content` 属性中。"

#: ../../library/urllib.request.rst:1427
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"如果未提供 *Content-Length* 标头，urlretrieve 就无法检查它所下载的数据大小，只是简单地返回它。 "
"在这种情况下你只能假定下载是成功的。"

#: ../../library/urllib.request.rst:1433
msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr "清理之前调用 :func:`urlretrieve` 时可能留下的临时文件。"

#: ../../library/urllib.request.rst:1440
msgid ""
"Base class for opening and reading URLs.  Unless you need to support opening"
" objects using schemes other than :file:`http:`, :file:`ftp:`, or "
":file:`file:`, you probably want to use :class:`FancyURLopener`."
msgstr ""
"用于打开和读取 URL 的基类。 除非你需要支持使用 :file:`http:`, :file:`ftp:` 或 :file:`file:` "
"以外的方式来打开对象，那你也许可以使用 :class:`FancyURLopener`。"

#: ../../library/urllib.request.rst:1444
msgid ""
"By default, the :class:`URLopener` class sends a :mailheader:`User-Agent` "
"header of ``urllib/VVV``, where *VVV* is the :mod:`urllib` version number. "
"Applications can define their own :mailheader:`User-Agent` header by "
"subclassing :class:`URLopener` or :class:`FancyURLopener` and setting the "
"class attribute :attr:`version` to an appropriate string value in the "
"subclass definition."
msgstr ""
"在默认情况下，:class:`URLopener` 类会发送一个内容为 ``urllib/VVV`` 的 :mailheader:`User-"
"Agent` 标头，其中 *VVV* 是 :mod:`urllib` 的版本号。 应用程序可以通过子类化 :class:`URLopener` 或 "
":class:`FancyURLopener` 并在子类定义中将类属性 :attr:`version` 设为适当的字符串值来定义自己的 "
":mailheader:`User-Agent` 标头。"

#: ../../library/urllib.request.rst:1450
msgid ""
"The optional *proxies* parameter should be a dictionary mapping scheme names"
" to proxy URLs, where an empty dictionary turns proxies off completely.  Its"
" default value is ``None``, in which case environmental proxy settings will "
"be used if present, as discussed in the definition of :func:`urlopen`, "
"above."
msgstr ""
"可选的 *proxies* 形参应当是一个将方式名称映射到代理 URL 的字典，如为空字典则会完全关闭代理。 它的默认值为 "
"``None``，在这种情况下如果存在环境代理设置则将使用它，正如上文 :func:`urlopen` 的定义中所描述的。"

#: ../../library/urllib.request.rst:1455
msgid ""
"Additional keyword parameters, collected in *x509*, may be used for "
"authentication of the client when using the :file:`https:` scheme.  The "
"keywords *key_file* and *cert_file* are supported to provide an  SSL key and"
" certificate; both are needed to support client authentication."
msgstr ""
"一些归属于 *x509* 的额外关键字形参可在使用 :file:`https:` 方式时被用于客户端的验证。 支持通过关键字 *key_file* 和 "
"*cert_file* 来提供 SSL 密钥和证书；对客户端验证的支持需要提供这两个形参。"

#: ../../library/urllib.request.rst:1460
msgid ""
":class:`URLopener` objects will raise an :exc:`OSError` exception if the "
"server returns an error code."
msgstr "如果服务器返回错误代码则 :class:`URLopener` 对象将引发 :exc:`OSError` 异常。"

#: ../../library/urllib.request.rst:1465
msgid ""
"Open *fullurl* using the appropriate protocol.  This method sets up cache "
"and proxy information, then calls the appropriate open method with its input"
" arguments.  If the scheme is not recognized, :meth:`open_unknown` is "
"called. The *data* argument has the same meaning as the *data* argument of "
":func:`urlopen`."
msgstr ""
"使用适当的协议打开 *fullurl*。 此方法会设置缓存和代理信息，然后调用适当的打开方法并附带其输入参数。 如果方式无法被识别，则会调用 "
":meth:`open_unknown`。 *data* 参数的含义与 :func:`urlopen` 中的 *data* 参数相同。"

#: ../../library/urllib.request.rst:1471
msgid "This method always quotes *fullurl* using :func:`~urllib.parse.quote`."
msgstr "此方法总是会使用 :func:`~urllib.parse.quote` 来对 *fullurl* 进行转码。"

#: ../../library/urllib.request.rst:1475
msgid "Overridable interface to open unknown URL types."
msgstr "用于打开未知 URL 类型的可重载接口。"

#: ../../library/urllib.request.rst:1480
msgid ""
"Retrieves the contents of *url* and places it in *filename*.  The return "
"value is a tuple consisting of a local filename and either an "
":class:`email.message.Message` object containing the response headers (for "
"remote URLs) or ``None`` (for local URLs).  The caller must then open and "
"read the contents of *filename*.  If *filename* is not given and the URL "
"refers to a local file, the input filename is returned.  If the URL is non-"
"local and *filename* is not given, the filename is the output of "
":func:`tempfile.mktemp` with a suffix that matches the suffix of the last "
"path component of the input URL.  If *reporthook* is given, it must be a "
"function accepting three numeric parameters: A chunk number, the maximum "
"size chunks are read in and the total size of the download (-1 if unknown)."
"  It will be called once at the start and after each chunk of data is read "
"from the network.  *reporthook* is ignored for local URLs."
msgstr ""
"提取 *url* 的内容并将其存放到 *filename* 中。 返回值为元组，由一个本地文件名和一个包含响应标头 (对于远程 URL) 的 "
":class:`email.message.Message` 对象或者 ``None``  (对于本地 URL)。 之后调用方必须打开并读取 "
"*filename* 的内容。 如果 *filename* 未给出并且 URL 指向一个本地文件，则会返回输入文件名。 如果 URL 非本地并且 "
"*filename* 未给出，则文件名为带有与输入 URL 的路径末尾部分后缀相匹配的后缀的 :func:`tempfile.mktemp` 的输出。 "
"如果给出了 *reporthook*，它必须为接受三个数字形参的函数：数据分块编号、读入分块的最大数据量和下载的总数据量 (未知则为 -1)。 "
"它将在开始时和从网络读取每个数据分块之后被调用。 对于本地 URL *reporthook* 会被忽略。"

#: ../../library/urllib.request.rst:1493
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must in standard "
":mimetype:`application/x-www-form-urlencoded` format; see the "
":func:`urllib.parse.urlencode` function."
msgstr ""
"如果 *url* 使用 :file:`http:` 方式的标识符，则可能给出可选的 *data* 参数来指定一个 ``POST`` 请求 "
"(通常的请求类型为 ``GET``)。 *data* 参数必须为标准的 :mimetype:`application/x-www-form-"
"urlencoded` 格式 ；参见 :func:`urllib.parse.urlencode` 函数。"

#: ../../library/urllib.request.rst:1502
msgid ""
"Variable that specifies the user agent of the opener object.  To get "
":mod:`urllib` to tell servers that it is a particular user agent, set this "
"in a subclass as a class variable or in the constructor before calling the "
"base constructor."
msgstr ""
"指明打开器对象的用户代理名称的变量。  以便让 :mod:`urllib` "
"告诉服务器它是某个特定的用户代理，请在子类中将其作为类变量来设置或是在调用基类构造器之前在构造器中设置。"

#: ../../library/urllib.request.rst:1512
msgid ""
":class:`FancyURLopener` subclasses :class:`URLopener` providing default "
"handling for the following HTTP response codes: 301, 302, 303, 307 and 401."
"  For the 30x response codes listed above, the :mailheader:`Location` header"
" is used to fetch the actual URL.  For 401 response codes (authentication "
"required), basic HTTP authentication is performed.  For the 30x response "
"codes, recursion is bounded by the value of the *maxtries* attribute, which "
"defaults to 10."
msgstr ""
":class:`FancyURLopener` 子类化了 :class:`URLopener` 以提供对以下 HTTP 响应代码的默认处理: 301, "
"302, 303, 307 和 401。 对于上述的 30x 响应代码，会使用 :mailheader:`Location` 标头来获取实际 URL。 "
"对于 401 响应代码 (authentication required)，则会执行基本 HTTP 验证。 对于 30x 响应代码，递归层数会受 "
"*maxtries* 属性值的限制，该值默认为 10。"

#: ../../library/urllib.request.rst:1519
msgid ""
"For all other response codes, the method "
":meth:`~BaseHandler.http_error_default` is called which you can override in "
"subclasses to handle the error appropriately."
msgstr ""
"对于所有其他响应代码，将会调用 :meth:`~BaseHandler.http_error_default` "
"方法，你可以在子类中重写此方法来正确处理错误。"

#: ../../library/urllib.request.rst:1524
msgid ""
"According to the letter of :rfc:`2616`, 301 and 302 responses to POST "
"requests must not be automatically redirected without confirmation by the "
"user.  In reality, browsers do allow automatic redirection of these "
"responses, changing the POST to a GET, and :mod:`urllib` reproduces this "
"behaviour."
msgstr ""
"根据 :rfc:`2616` 的说明，对 POST 请求的 301 和 302 响应不可在未经用户确认的情况下自动进行重定向。 "
"在现实情况下，浏览器确实允许自动重定义这些响应，将 POST 更改为 GET，于是 :mod:`urllib` 就会复现这种行为。"

#: ../../library/urllib.request.rst:1529
msgid ""
"The parameters to the constructor are the same as those for "
":class:`URLopener`."
msgstr "传给此构造器的形参与 :class:`URLopener` 的相同。"

#: ../../library/urllib.request.rst:1533
msgid ""
"When performing basic authentication, a :class:`FancyURLopener` instance "
"calls its :meth:`prompt_user_passwd` method.  The default implementation "
"asks the users for the required information on the controlling terminal.  A "
"subclass may override this method to support more appropriate behavior if "
"needed."
msgstr ""
"当执行基本验证时，:class:`FancyURLopener` 实例会调用其 :meth:`prompt_user_passwd` 方法。 "
"默认的实现将向用户询问控制终端所要求的信息。 如有必要子类可以重写此方法来支持更适当的行为。"

#: ../../library/urllib.request.rst:1538
msgid ""
"The :class:`FancyURLopener` class offers one additional method that should "
"be overloaded to provide the appropriate behavior:"
msgstr ":class:`FancyURLopener` 类附带了一个额外方法，它应当被重载以提供适当的行为:"

#: ../../library/urllib.request.rst:1543
msgid ""
"Return information needed to authenticate the user at the given host in the "
"specified security realm.  The return value should be a tuple, ``(user, "
"password)``, which can be used for basic authentication."
msgstr ""
"返回指定的安全体系下在给定的主机上验证用户所需的信息。 返回的值应当是一个元组 ``(user, password)``，它可被用于基本验证。"

#: ../../library/urllib.request.rst:1547
msgid ""
"The implementation prompts for this information on the terminal; an "
"application should override this method to use an appropriate interaction "
"model in the local environment."
msgstr "该实现会在终端上提示此信息；应用程序应当重写此方法以使用本地环境下适当的交互模型。"

#: ../../library/urllib.request.rst:1553
msgid ":mod:`urllib.request` Restrictions"
msgstr ":mod:`urllib.request` 的限制"

#: ../../library/urllib.request.rst:1559
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr "目前，仅支持下列协议: HTTP (0.9 和 1.0 版), FTP, 本地文件, 以及数据 URL。"

#: ../../library/urllib.request.rst:1562
msgid "Added support for data URLs."
msgstr "增加了对数据URL 的支持。"

#: ../../library/urllib.request.rst:1564
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ":func:`urlretrieve` 的缓存特性已被禁用，等待有人有时间去正确地解决过期时间标头的处理问题。"

#: ../../library/urllib.request.rst:1567
msgid ""
"There should be a function to query whether a particular URL is in the "
"cache."
msgstr "应当有一个函数来查询特定 URL 是否在缓存中。"

#: ../../library/urllib.request.rst:1569
msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol."
"  This can sometimes cause confusing error messages."
msgstr ""
"为了保持向下兼容性，如果某个 URL 看起来是指向本地文件但该文件无法被打开，则该 URL 会使用 FTP 协议来重新解读。 "
"这有时可能会导致令人迷惑的错误消息。"

#: ../../library/urllib.request.rst:1573
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means"
" that it is difficult to build an interactive web client using these "
"functions without using threads."
msgstr ""
":func:`urlopen` 和 :func:`urlretrieve` 函数在等待网络连接建立时会导致任意长时间的延迟。 "
"这意味着在不使用线程的情况下搭建一个可交互的 Web 客户端是非常困难的。"

#: ../../library/urllib.request.rst:1582
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the "
":mailheader:`Content-Type` header.  If the returned data is HTML, you can "
"use the module :mod:`html.parser` to parse it."
msgstr ""
"由 :func:`urlopen` 或 :func:`urlretrieve` 返回的数据就是服务器所返回的原始数据。 "
"这可以是二进制数据（如图片）、纯文本或 HTML 代码等。 HTTP 协议在响应标头中提供了类型信息，这可以通过读取 "
":mailheader:`Content-Type` 标头来查看。 如果返回的数据是 HTML，你可以使用 :mod:`html.parser` "
"模块来解析它。"

#: ../../library/urllib.request.rst:1591
msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a"
" directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a "
"``/``, it is assumed to refer to a directory and will be handled "
"accordingly.  But if an attempt to read a file leads to a 550 error (meaning"
" the URL cannot be found or is not accessible, often for permission "
"reasons), then the path is treated as a directory in order to handle the "
"case when a directory is specified by a URL but the trailing ``/`` has been "
"left off.  This can cause misleading results when you try to fetch a file "
"whose read permissions make it inaccessible; the FTP code will try to read "
"it, fail with a 550 error, and then perform a directory listing for the "
"unreadable file. If fine-grained control is needed, consider using the "
":mod:`ftplib` module, subclassing :class:`FancyURLopener`, or changing "
"*_urlopener* to meet your needs."
msgstr ""
"处理 FTP 协议的代码无法区分文件和目录。 这在尝试读取指向不可访问的 URL 时可能导致意外的行为。 如果 URL 以一个 ``/`` "
"结束，它会被认为指向一个目录并将作相应的处理。 但是如果读取一个文件的尝试导致了 550 错误（表示 URL "
"无法找到或不可访问，这常常是由于权限原因），则该路径会被视为一个目录以便处理 URL 是指定一个目录但略去了末尾 ``/`` 的情况。 "
"这在你尝试获取一个因其设置了读取权限因而无法访问的文件时会造成误导性的结果；FTP 代码将尝试读取它，因 550 "
"错误而失败，然后又为这个不可读取的文件执行目录列表操作。 如果需要细粒度的控制，请考虑使用 :mod:`ftplib` 模块，子类化 "
":class:`FancyURLopener`，或是修改 *_urlopener* 来满足你的需求。"

#: ../../library/urllib.request.rst:1608
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- urllib 使用的 Response 类"

#: ../../library/urllib.request.rst:1613
msgid ""
"The :mod:`urllib.response` module defines functions and classes which define"
" a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the "
":mod:`urllib.request` module. The typical response object is a "
":class:`urllib.response.addinfourl` instance:"
msgstr ""
":mod:`urllib.response` 模块定义了一些函数和提供最小化文件类接口包括 ``read()`` 和 ``readline()`` "
"等的类。 此模块定义的函数会由 :mod:`urllib.request` 模块在内部使用。 典型的响应对象是一个 "
":class:`urllib.response.addinfourl` 实例:"

#: ../../library/urllib.request.rst:1622
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr "已读取资源的 URL，通常用于确定是否进行了重定向。"

#: ../../library/urllib.request.rst:1626
msgid ""
"Returns the headers of the response in the form of an "
":class:`~email.message.EmailMessage` instance."
msgstr "以 :class:`~email.message.EmailMessage` 实例的形式返回响应的标头。"

#: ../../library/urllib.request.rst:1632
msgid "Status code returned by server."
msgstr "由服务器返回的状态码。"

#: ../../library/urllib.request.rst:1636
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "已弃用，建议改用 :attr:`~addinfourl.url`。"

#: ../../library/urllib.request.rst:1641
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "已弃用，建议改用 :attr:`~addinfourl.headers`。"

#: ../../library/urllib.request.rst:1646 ../../library/urllib.request.rst:1651
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "已弃用，建议改用 :attr:`~addinfourl.status`。"

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1578
msgid "HTTP"
msgstr "HTTP"

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1578
msgid "protocol"
msgstr "协议"

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1589
msgid "FTP"
msgstr "FTP"

#: ../../library/urllib.request.rst:1578
msgid "HTML"
msgstr "HTML"
