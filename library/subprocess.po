# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# Arisaka97 <solitaire2312@gmail.com>, 2021
# Zombie110year <zombie110year@gmail.com>, 2021
# nick <2330458484@qq.com>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# ProgramRipper, 2023
# Wulian233 <xiguawulian@gmail.com>, 2024
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-20 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 01:14+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/subprocess.rst:2
msgid ":mod:`!subprocess` --- Subprocess management"
msgstr ":mod:`!subprocess` --- 子进程管理"

#: ../../library/subprocess.rst:10
msgid "**Source code:** :source:`Lib/subprocess.py`"
msgstr "**源代码:** :source:`Lib/subprocess.py`"

#: ../../library/subprocess.rst:14
msgid ""
"The :mod:`subprocess` module allows you to spawn new processes, connect to "
"their input/output/error pipes, and obtain their return codes.  This module "
"intends to replace several older modules and functions::"
msgstr ""
":mod:`subprocess` 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。此模块打算代替一些老旧的模块与功能："

#: ../../library/subprocess.rst:18
msgid ""
"os.system\n"
"os.spawn*"
msgstr ""
"os.system\n"
"os.spawn*"

#: ../../library/subprocess.rst:21
msgid ""
"Information about how the :mod:`subprocess` module can be used to replace "
"these modules and functions can be found in the following sections."
msgstr "在下面的段落中，你可以找到关于 :mod:`subprocess` 模块如何代替这些模块和功能的相关信息。"

#: ../../library/subprocess.rst:26
msgid ":pep:`324` -- PEP proposing the subprocess module"
msgstr ":pep:`324` -- 提出 subprocess 模块的 PEP"

#: ../../library/subprocess.rst:598 ../../library/subprocess.rst:605
#: ../../library/subprocess.rst:615 ../../library/subprocess.rst:624
#: ../../library/subprocess.rst:633 ../../library/subprocess.rst:639
#: ../../library/subprocess.rst:1494 ../../library/subprocess.rst:1516
#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"此模块在 :ref:`移动平台 <mobile-availability>` 或 :ref:`WebAssembly 平台 <wasm-"
"availability>` 上不受支持。"

#: ../../library/subprocess.rst:31
msgid "Using the :mod:`subprocess` Module"
msgstr "使用 :mod:`subprocess` 模块"

#: ../../library/subprocess.rst:33
msgid ""
"The recommended approach to invoking subprocesses is to use the :func:`run` "
"function for all use cases it can handle. For more advanced use cases, the "
"underlying :class:`Popen` interface can be used directly."
msgstr ""
"推荐的调用子进程的方式是在任何它支持的用例中使用 :func:`run` 函数。对于更进阶的用例，也可以使用底层的 :class:`Popen` 接口。"

#: ../../library/subprocess.rst:43
msgid ""
"Run the command described by *args*.  Wait for command to complete, then "
"return a :class:`CompletedProcess` instance."
msgstr "运行被 *arg* 描述的指令. 等待指令完成, 然后返回一个 :class:`CompletedProcess` 实例."

#: ../../library/subprocess.rst:46
msgid ""
"The arguments shown above are merely the most common ones, described below "
"in :ref:`frequently-used-arguments` (hence the use of keyword-only notation "
"in the abbreviated signature). The full function signature is largely the "
"same as that of the :class:`Popen` constructor - most of the arguments to "
"this function are passed through to that interface. (*timeout*,  *input*, "
"*check*, and *capture_output* are not.)"
msgstr ""
"以上显示的参数仅仅是最简单的一些，下面 :ref:`frequently-used-arguments` "
"描述（因此在缩写签名中使用仅关键字标示）。完整的函数头和 :class:`Popen` "
"的构造函数一样，此函数接受的大多数参数都被传递给该接口。（*timeout*, *input*, *check* 和 *capture_output* "
"除外）。"

#: ../../library/subprocess.rst:53
msgid ""
"If *capture_output* is true, stdout and stderr will be captured. When used, "
"the internal :class:`Popen` object is automatically created with *stdout* "
"and *stderr* both set to :data:`~subprocess.PIPE`. The *stdout* and *stderr*"
" arguments may not be supplied at the same time as *capture_output*. If you "
"wish to capture and combine both streams into one, set *stdout* to "
":data:`~subprocess.PIPE` and *stderr* to :data:`~subprocess.STDOUT`, instead"
" of using *capture_output*."
msgstr ""
"如果 *capture_output* 为真值，则 stdout 和 stderr 将被捕获。 当被使用时，内部 :class:`Popen` "
"对象将自动创建并把 *stdout* 和 *stderr* 均设为 :data:`~subprocess.PIPE`。 *stdout* 和 "
"*stderr* 参数不可与 *capture_output* 同时提供。 如果你希望捕获并将两个流合并在一起，请将 *stdout* 设为 "
":data:`~subprocess.PIPE` 并将 *stderr* 设为 :data:`~subprocess.STDOUT`，而不是使用 "
"*capture_output*。"

#: ../../library/subprocess.rst:62
msgid ""
"A *timeout* may be specified in seconds, it is internally passed on to "
":meth:`Popen.communicate`. If the timeout expires, the child process will be"
" killed and waited for. The :exc:`TimeoutExpired` exception will be re-"
"raised after the child process has terminated. The initial process creation "
"itself cannot be interrupted on many platform APIs so you are not guaranteed"
" to see a timeout exception until at least after however long process "
"creation takes."
msgstr ""
"可以指定以秒为单位的 *timeout*，它会在内部传递给 :meth:`Popen.communicate`。 "
"如果达到超时限制，子进程将被杀掉并等待。 :exc:`TimeoutExpired` 异常将在子进程终结后重新被引发。 在许多平台 API "
"上初始进程创建本身不可以被打断因此不保证你能看到超时异常直到至少进程创建花费的时间结束后。"

#: ../../library/subprocess.rst:70
msgid ""
"The *input* argument is passed to :meth:`Popen.communicate` and thus to the "
"subprocess's stdin.  If used it must be a byte sequence, or a string if "
"*encoding* or *errors* is specified or *text* is true.  When used, the "
"internal :class:`Popen` object is automatically created with *stdin* set to "
":data:`~subprocess.PIPE`, and the *stdin* argument may not be used as well."
msgstr ""
"*input* 参数将被传递给 :meth:`Popen.communicate` 以及子进程的 stdin。 "
"如果使用此参数则它必须是一个字节序列，或者如果指定了 *encoding* 或 *errors* 或 *text* 为真值则可以是一个字符串。 "
"当使用此参数时，将自动创建内部的 :class:`Popen` 对象并将其 *stdin* 设为 "
":data:`~subprocess.PIPE`，并且不可同时使用 *stdin* 参数。"

#: ../../library/subprocess.rst:77
msgid ""
"If *check* is true, and the process exits with a non-zero exit code, a "
":exc:`CalledProcessError` exception will be raised. Attributes of that "
"exception hold the arguments, the exit code, and stdout and stderr if they "
"were captured."
msgstr ""
"如果 *check* 设为 True, 并且进程以非零状态码退出, 一个 :exc:`CalledProcessError` 异常将被抛出. "
"这个异常的属性将设置为参数, 退出码, 以及标准输出和标准错误, 如果被捕获到."

#: ../../library/subprocess.rst:82
msgid ""
"If *encoding* or *errors* are specified, or *text* is true, file objects for"
" stdin, stdout and stderr are opened in text mode using the specified "
"*encoding* and *errors* or the :class:`io.TextIOWrapper` default. The "
"*universal_newlines* argument is equivalent  to *text* and is provided for "
"backwards compatibility. By default, file objects are opened in binary mode."
msgstr ""
"如果指定了 *encoding* 或 *error*，或者 *text* 被设为真值，标准输入、标准输出和标准错误的文件对象将使用指定的 "
"*encoding* 和 *errors* 或者 :class:`io.TextIOWrapper` 默认值以文本模式打开。 "
"*universal_newlines* 参数等同于 *text* 并且提供了向后兼容性。 默认情况下, 文件对象是以二进制模式打开的。"

#: ../../library/subprocess.rst:88
msgid ""
"If *env* is not ``None``, it must be a mapping that defines the environment "
"variables for the new process; these are used instead of the default "
"behavior of inheriting the current process' environment. It is passed "
"directly to :class:`Popen`. This mapping can be str to str on any platform "
"or bytes to bytes on POSIX platforms much like :data:`os.environ` or "
":data:`os.environb`."
msgstr ""
"如果 *env* 不为 ``None``，则它必须是一个为新进程定义环境变量的映射；它们将顶替继承当前进程环境的默认行为被使用。 它会被直接传递给 "
":class:`Popen`。 这个映射在任何平台上均可以是字符串到字符串的映射或者在 POSIX 平台上也可以是字节串到字节串的映射，就像是 "
":data:`os.environ` 或者 :data:`os.environb`。"

#: ../../library/subprocess.rst:95
msgid "Examples::"
msgstr "示例::"

#: ../../library/subprocess.rst:97
msgid ""
">>> subprocess.run([\"ls\", \"-l\"])  # doesn't capture output\n"
"CompletedProcess(args=['ls', '-l'], returncode=0)\n"
"\n"
">>> subprocess.run(\"exit 1\", shell=True, check=True)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n"
"\n"
">>> subprocess.run([\"ls\", \"-l\", \"/dev/null\"], capture_output=True)\n"
"CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\n"
"stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n', stderr=b'')"
msgstr ""
">>> subprocess.run([\"ls\", \"-l\"])  # 不捕获输出\n"
"CompletedProcess(args=['ls', '-l'], returncode=0)\n"
"\n"
">>> subprocess.run(\"exit 1\", shell=True, check=True)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n"
"\n"
">>> subprocess.run([\"ls\", \"-l\", \"/dev/null\"], capture_output=True)\n"
"CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\n"
"stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n', stderr=b'')"

#: ../../library/subprocess.rst:113
msgid "Added *encoding* and *errors* parameters"
msgstr "添加了 *encoding* 和 *errors* 形参."

#: ../../library/subprocess.rst:117
msgid ""
"Added the *text* parameter, as a more understandable alias of "
"*universal_newlines*. Added the *capture_output* parameter."
msgstr ""
"添加了 *text* 形参，作为 *universal_newlines* 的一个更好理解的别名。 添加了 *capture_output* 形参。"

#: ../../library/subprocess.rst:122 ../../library/subprocess.rst:506
#: ../../library/subprocess.rst:1214 ../../library/subprocess.rst:1254
#: ../../library/subprocess.rst:1317
msgid ""
"Changed Windows shell search order for ``shell=True``. The current directory"
" and ``%PATH%`` are replaced with ``%COMSPEC%`` and "
"``%SystemRoot%\\System32\\cmd.exe``. As a result, dropping a malicious "
"program named ``cmd.exe`` into a current directory no longer works."
msgstr ""
"针对 ``shell=True`` 改变的 Windows shell 搜索顺序。 当前目录和 ``%PATH%`` 会被替换为 "
"``%COMSPEC%`` 和 ``%SystemRoot%\\System32\\cmd.exe``。 因此，在当前目录中投放一个命名为 "
"``cmd.exe`` 的恶意程序不会再起作用。"

#: ../../library/subprocess.rst:130
msgid ""
"The return value from :func:`run`, representing a process that has finished."
msgstr ":func:`run` 的返回值, 代表一个进程已经结束."

#: ../../library/subprocess.rst:134
msgid ""
"The arguments used to launch the process. This may be a list or a string."
msgstr "被用作启动进程的参数. 可能是一个列表或字符串."

#: ../../library/subprocess.rst:138
msgid ""
"Exit status of the child process. Typically, an exit status of 0 indicates "
"that it ran successfully."
msgstr "子进程的退出状态码. 通常来说, 一个为 0 的退出码表示进程运行正常."

#: ../../library/subprocess.rst:141 ../../library/subprocess.rst:945
msgid ""
"A negative value ``-N`` indicates that the child was terminated by signal "
"``N`` (POSIX only)."
msgstr "一个负值 ``-N`` 表示子进程被信号 ``N`` 中断 (仅 POSIX)."

#: ../../library/subprocess.rst:146
msgid ""
"Captured stdout from the child process. A bytes sequence, or a string if "
":func:`run` was called with an encoding, errors, or text=True. ``None`` if "
"stdout was not captured."
msgstr ""
"从子进程捕获到的标准输出. 一个字节序列, 或一个字符串, 如果 :func:`run` 是设置了 *encoding*, *errors* 或者 "
"``text=True`` 来运行的. 如果未有捕获, 则为 ``None``."

#: ../../library/subprocess.rst:150
msgid ""
"If you ran the process with ``stderr=subprocess.STDOUT``, stdout and stderr "
"will be combined in this attribute, and :attr:`stderr` will be ``None``."
msgstr ""
"如果你通过 ``stderr=subprocess.STDOUT`` 运行进程，标准输入和标准错误将被组合在这个属性中，并且 "
":attr:`stderr` 将为 ``None``。"

#: ../../library/subprocess.rst:156
msgid ""
"Captured stderr from the child process. A bytes sequence, or a string if "
":func:`run` was called with an encoding, errors, or text=True. ``None`` if "
"stderr was not captured."
msgstr ""
"捕获到的子进程的标准错误. 一个字节序列, 或者一个字符串, 如果 :func:`run` 是设置了参数 *encoding*, *errors* 或者"
" ``text=True`` 运行的. 如果未有捕获, 则为 ``None``."

#: ../../library/subprocess.rst:162
msgid "If :attr:`returncode` is non-zero, raise a :exc:`CalledProcessError`."
msgstr "如果 :attr:`returncode` 非零, 抛出 :exc:`CalledProcessError`."

#: ../../library/subprocess.rst:168
msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* argument"
" to :class:`Popen` and indicates that the special file :data:`os.devnull` "
"will be used."
msgstr ""
"可被 :class:`Popen` 的 *stdin*, *stdout* 或者 *stderr* 参数使用的特殊值, 表示使用特殊文件 "
":data:`os.devnull`."

#: ../../library/subprocess.rst:177
msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* argument"
" to :class:`Popen` and indicates that a pipe to the standard stream should "
"be opened.  Most useful with :meth:`Popen.communicate`."
msgstr ""
"可被 :class:`Popen` 的 *stdin*, *stdout* 或者 *stderr* 参数使用的特殊值, 表示打开标准流的管道. 常用于 "
":meth:`Popen.communicate`."

#: ../../library/subprocess.rst:184
msgid ""
"Special value that can be used as the *stderr* argument to :class:`Popen` "
"and indicates that standard error should go into the same handle as standard"
" output."
msgstr "可被 :class:`Popen` 的 *stderr* 参数使用的特殊值， 表示标准错误与标准输出使用同一句柄。"

#: ../../library/subprocess.rst:191
msgid "Base class for all other exceptions from this module."
msgstr "此模块的其他异常的基类。"

#: ../../library/subprocess.rst:198
msgid ""
"Subclass of :exc:`SubprocessError`, raised when a timeout expires while "
"waiting for a child process."
msgstr ":exc:`SubprocessError` 的子类，等待子进程的过程中发生超时时被抛出。"

#: ../../library/subprocess.rst:203 ../../library/subprocess.rst:247
msgid "Command that was used to spawn the child process."
msgstr "用于创建子进程的指令。"

#: ../../library/subprocess.rst:207
msgid "Timeout in seconds."
msgstr "超时秒数。"

#: ../../library/subprocess.rst:211
msgid ""
"Output of the child process if it was captured by :func:`run` or "
":func:`check_output`.  Otherwise, ``None``.  This is always :class:`bytes` "
"when any output was captured regardless of the ``text=True`` setting.  It "
"may remain ``None`` instead of ``b''`` when no output was observed."
msgstr ""
"当被 :func:`run` 或 :func:`check_output` 捕获时的子进程的输出。 在其它情况下将为 "
"``None``。当有任何输出被捕获时这将始终为 :class:`bytes` 而不考虑是否设置了 ``text=True``。 "
"当未检测到输出时它可能会保持为 ``None`` 而不是 ``b''``。"

#: ../../library/subprocess.rst:219 ../../library/subprocess.rst:256
msgid "Alias for output, for symmetry with :attr:`stderr`."
msgstr "对 output 的别名，对应的有 :attr:`stderr`。"

#: ../../library/subprocess.rst:223
msgid ""
"Stderr output of the child process if it was captured by :func:`run`. "
"Otherwise, ``None``.  This is always :class:`bytes` when stderr output was "
"captured regardless of the ``text=True`` setting.  It may remain ``None`` "
"instead of ``b''`` when no stderr output was observed."
msgstr ""
"当被 :func:`run` 捕获时的标准错误输出。 在其它情况下将为 ``None``。 当有标准错误输出被捕获时这将始终为 "
":class:`bytes` 而不考虑是否设置了 ``text=True``。 当未检测到标准错误输出时它可能会保持为 ``None`` 而不是 "
"``b''``。"

#: ../../library/subprocess.rst:230 ../../library/subprocess.rst:263
msgid "*stdout* and *stderr* attributes added"
msgstr "添加了 *stdout* 和 *stderr* 属性。"

#: ../../library/subprocess.rst:235
msgid ""
"Subclass of :exc:`SubprocessError`, raised when a process run by "
":func:`check_call`, :func:`check_output`, or :func:`run` (with "
"``check=True``) returns a non-zero exit status."
msgstr ""
":exc:`SubprocessError` 的子类，当一个由 :func:`check_call`, :func:`check_output` 或 "
":func:`run` (附带 ``check=True``) 运行的进程返回了非零退出状态码时将被引发。"

#: ../../library/subprocess.rst:242
msgid ""
"Exit status of the child process.  If the process exited due to a signal, "
"this will be the negative signal number."
msgstr "子进程的退出状态。如果程序由一个信号终止，这将会被设为一个负的信号码。"

#: ../../library/subprocess.rst:251
msgid ""
"Output of the child process if it was captured by :func:`run` or "
":func:`check_output`.  Otherwise, ``None``."
msgstr "子进程的输出， 如果被 :func:`run` 或 :func:`check_output` 捕获。否则为 ``None``。"

#: ../../library/subprocess.rst:260
msgid ""
"Stderr output of the child process if it was captured by :func:`run`. "
"Otherwise, ``None``."
msgstr "子进程的标准错误输出，如果被 :func:`run` 捕获。 否则为 ``None``。"

#: ../../library/subprocess.rst:270
msgid "Frequently Used Arguments"
msgstr "常用参数"

#: ../../library/subprocess.rst:272
msgid ""
"To support a wide variety of use cases, the :class:`Popen` constructor (and "
"the convenience functions) accept a large number of optional arguments. For "
"most typical use cases, many of these arguments can be safely left at their "
"default values. The arguments that are most commonly needed are:"
msgstr ""
"为了支持丰富的使用案例， :class:`Popen` "
"的构造函数（以及方便的函数）接受大量可选的参数。对于大多数典型的用例，许多参数可以被安全地留以它们的默认值。通常需要的参数有："

#: ../../library/subprocess.rst:277
msgid ""
"*args* is required for all calls and should be a string, or a sequence of "
"program arguments. Providing a sequence of arguments is generally preferred,"
" as it allows the module to take care of any required escaping and quoting "
"of arguments (e.g. to permit spaces in file names). If passing a single "
"string, either *shell* must be :const:`True` (see below) or else the string "
"must simply name the program to be executed without specifying any "
"arguments."
msgstr ""
"*args* "
"被所有调用需要，应当为一个字符串，或者一个程序参数序列。提供一个参数序列通常更好，它可以更小心地使用参数中的转义字符以及引用（例如允许文件名中的空格）。如果传递一个简单的字符串，则"
" *shell* 参数必须为 :const:`True` （见下文）或者该字符串中将被运行的程序名必须用简单的命名而不指定任何参数。"

#: ../../library/subprocess.rst:285
msgid ""
"*stdin*, *stdout* and *stderr* specify the executed program's standard "
"input, standard output and standard error file handles, respectively.  Valid"
" values are ``None``, :data:`PIPE`, :data:`DEVNULL`, an existing file "
"descriptor (a positive integer), and an existing :term:`file object` with a "
"valid file descriptor.  With the default settings of ``None``, no "
"redirection will occur.  :data:`PIPE` indicates that a new pipe to the child"
" should be created.  :data:`DEVNULL` indicates that the special file "
":data:`os.devnull` will be used.  Additionally, *stderr* can be "
":data:`STDOUT`, which indicates that the stderr data from the child process "
"should be captured into the same file handle as for *stdout*."
msgstr ""
"*stdin*, *stdout* 和 *stderr* 分别指定被执行程序的标准输入、标准输出和标准错误文件句柄。 合法的值包括 ``None``, "
":data:`PIPE`, :data:`DEVNULL`, 现存的文件描述符（一个正整数），现存的具有合法文件描述符的 :term:`file "
"object`。 当使用默认设置 ``None`` 时，将不会进行任何重定向。 :data:`PIPE` 表示应当新建一个连接子进程的管道。 "
":data:`DEVNULL` 表示将使用特殊文件 :data:`os.devnull`。 此外，*stderr* 还可以为 "
":data:`STDOUT`，这表示来自子进程的 stderr 数据应当被捕获到与 *stdout* 相同的文件句柄中。"

#: ../../library/subprocess.rst:299
msgid ""
"If *encoding* or *errors* are specified, or *text* (also known as "
"*universal_newlines*) is true, the file objects *stdin*, *stdout* and "
"*stderr* will be opened in text mode using the *encoding* and *errors* "
"specified in the call or the defaults for :class:`io.TextIOWrapper`."
msgstr ""
"如果指定了 *encoding* 或 *errors*，或者 *text* (也称 *universal_newlines*) 为真，则文件对象 "
"*stdin*、 *stdout* 与 *stderr* 将会使用在此次调用中指定的 *encoding* 和 *errors* 或者 "
":class:`io.TextIOWrapper` 的默认值以文本模式打开。"

#: ../../library/subprocess.rst:305
msgid ""
"For *stdin*, line ending characters ``'\\n'`` in the input will be converted"
" to the default line separator :data:`os.linesep`. For *stdout* and "
"*stderr*, all line endings in the output will be converted to ``'\\n'``.  "
"For more information see the documentation of the :class:`io.TextIOWrapper` "
"class when the *newline* argument to its constructor is ``None``."
msgstr ""
"当构造函数的 *newline* 参数为 ``None`` 时。对于 *stdin*， 输入的换行符 ``'\\n'`` 将被转换为默认的换行符 "
":data:`os.linesep`。对于 *stdout* 和 *stderr*， 所有输出的换行符都被转换为 ``'\\n'``。更多信息，查看 "
":class:`io.TextIOWrapper` 类的文档。"

#: ../../library/subprocess.rst:311
msgid ""
"If text mode is not used, *stdin*, *stdout* and *stderr* will be opened as "
"binary streams. No encoding or line ending conversion is performed."
msgstr "如果文本模式未被使用， *stdin*， *stdout* 和 *stderr* 将会以二进制流模式打开。没有编码与换行符转换发生。"

#: ../../library/subprocess.rst:314 ../../library/subprocess.rst:1503
#: ../../library/subprocess.rst:1521
msgid "Added the *encoding* and *errors* parameters."
msgstr "增加了 *encoding* 和 *errors* 形参。"

#: ../../library/subprocess.rst:317
msgid "Added the *text* parameter as an alias for *universal_newlines*."
msgstr "添加了 *text* 形参作为 *universal_newlines* 的别名。"

#: ../../library/subprocess.rst:322
msgid ""
"The newlines attribute of the file objects :attr:`Popen.stdin`, "
":attr:`Popen.stdout` and :attr:`Popen.stderr` are not updated by the "
":meth:`Popen.communicate` method."
msgstr ""
"文件对象 :attr:`Popen.stdin` 、 :attr:`Popen.stdout` 和 :attr:`Popen.stderr` "
"的换行符属性不会被 :meth:`Popen.communicate` 方法更新。"

#: ../../library/subprocess.rst:326
msgid ""
"If *shell* is ``True``, the specified command will be executed through the "
"shell.  This can be useful if you are using Python primarily for the "
"enhanced control flow it offers over most system shells and still want "
"convenient access to other shell features such as shell pipes, filename "
"wildcards, environment variable expansion, and expansion of ``~`` to a "
"user's home directory.  However, note that Python itself offers "
"implementations of many shell-like features (in particular, :mod:`glob`, "
":mod:`fnmatch`, :func:`os.walk`, :func:`os.path.expandvars`, "
":func:`os.path.expanduser`, and :mod:`shutil`)."
msgstr ""
"如果 *shell* 设为 ``True``,，则使用 shell 执行指定的指令。如果您主要使用 Python 增强的控制流（它比大多数系统 "
"shell 提供的强大），并且仍然希望方便地使用其他 shell 功能，如 shell 管道、文件通配符、环境变量展开以及 ``~`` "
"展开到用户家目录，这将非常有用。但是，注意 Python 自己也实现了许多类似 shell 的特性（例如 :mod:`glob`, "
":mod:`fnmatch`, :func:`os.walk`, :func:`os.path.expandvars`, "
":func:`os.path.expanduser` 和 :mod:`shutil`）。"

#: ../../library/subprocess.rst:336
msgid ""
"When *universal_newlines* is ``True``, the class uses the encoding "
":func:`locale.getpreferredencoding(False) <locale.getpreferredencoding>` "
"instead of ``locale.getpreferredencoding()``.  See the "
":class:`io.TextIOWrapper` class for more information on this change."
msgstr ""
"当 *universal_newlines* 被设为 ``True``，则类将使用 "
":func:`locale.getpreferredencoding(False) <locale.getpreferredencoding>` "
"编码格式来代替 ``locale.getpreferredencoding()``。 关于它们的区别的更多信息，见 "
":class:`io.TextIOWrapper`。"

#: ../../library/subprocess.rst:344 ../../library/subprocess.rst:465
msgid ""
"Read the `Security Considerations`_ section before using ``shell=True``."
msgstr "在使用 ``shell=True`` 之前， 请阅读 `Security Considerations`_ 段落。"

#: ../../library/subprocess.rst:346
msgid ""
"These options, along with all of the other options, are described in more "
"detail in the :class:`Popen` constructor documentation."
msgstr "这些选项以及所有其他选项在 :class:`Popen` 构造函数文档中有更详细的描述。"

#: ../../library/subprocess.rst:351
msgid "Popen Constructor"
msgstr "Popen 构造函数"

#: ../../library/subprocess.rst:353
msgid ""
"The underlying process creation and management in this module is handled by "
"the :class:`Popen` class. It offers a lot of flexibility so that developers "
"are able to handle the less common cases not covered by the convenience "
"functions."
msgstr ""
"此模块的底层的进程创建与管理由 :class:`Popen` 类处理。它提供了很大的灵活性，因此开发者能够处理未被便利函数覆盖的不常见用例。"

#: ../../library/subprocess.rst:368
msgid ""
"Execute a child program in a new process.  On POSIX, the class uses "
":meth:`os.execvpe`-like behavior to execute the child program.  On Windows, "
"the class uses the Windows ``CreateProcess()`` function.  The arguments to "
":class:`Popen` are as follows."
msgstr ""
"在一个新的进程中执行子程序。 在 POSIX 上，该类会使用类似于 :meth:`os.execvpe` 的行为来执行子程序。 在 Windows "
"上，该类会使用 Windows ``CreateProcess()`` 函数。 :class:`Popen` 的参数如下。"

#: ../../library/subprocess.rst:373
msgid ""
"*args* should be a sequence of program arguments or else a single string or "
":term:`path-like object`. By default, the program to execute is the first "
"item in *args* if *args* is a sequence.  If *args* is a string, the "
"interpretation is platform-dependent and described below.  See the *shell* "
"and *executable* arguments for additional differences from the default "
"behavior.  Unless otherwise stated, it is recommended to pass *args* as a "
"sequence."
msgstr ""
"*args* 应当是一个程序参数的序列或者是一个单独的字符串或 :term:`path-like object`。 默认情况下，如果 *args* "
"是序列则要运行的程序为 *args* 中的第一项。 如果 *args* 是字符串，则其解读依赖于具体平台，如下所述。 请查看 *shell* 和 "
"*executable* 参数了解其与默认行为的其他差异。 除非另有说明，否则推荐以序列形式传入 *args*。"

#: ../../library/subprocess.rst:383
msgid ""
"For maximum reliability, use a fully qualified path for the executable. To "
"search for an unqualified name on :envvar:`PATH`, use :meth:`shutil.which`. "
"On all platforms, passing :data:`sys.executable` is the recommended way to "
"launch the current Python interpreter again, and use the ``-m`` command-line"
" format to launch an installed module."
msgstr ""
"为了最大化可靠性，请使用可执行文件的完整限定路径。 要在 :envvar:`PATH` 中搜索一个非限定名称，请使用 "
":meth:`shutil.which`。 在所有平台上，传入 :data:`sys.executable` 是再次启动当前 Python "
"解释器的推荐方式，并请使用 ``-m`` 命令行格式来启动已安装的模块。"

#: ../../library/subprocess.rst:389
msgid ""
"Resolving the path of *executable* (or the first item of *args*) is platform"
" dependent. For POSIX, see :meth:`os.execvpe`, and note that when resolving "
"or searching for the executable path, *cwd* overrides the current working "
"directory and *env* can override the ``PATH`` environment variable. For "
"Windows, see the documentation of the ``lpApplicationName`` and "
"``lpCommandLine`` parameters of WinAPI ``CreateProcess``, and note that when"
" resolving or searching for the executable path with ``shell=False``, *cwd* "
"does not override the current working directory and *env* cannot override "
"the ``PATH`` environment variable. Using a full path avoids all of these "
"variations."
msgstr ""
"对 *executable* (或 *args* 的第一项) 路径的解析方式依赖于具体平台。 对于 POSIX，请参阅 "
":meth:`os.execvpe`，并要注意当解析或搜索可执行文件路径时，*cwd* 会覆盖当前工作目录而 *env* 可以覆盖 ``PATH`` "
"环境变量。 对于 Windows，请参阅 ``lpApplicationName`` 的文档以及 ``lpCommandLine`` 形参 (传给 "
"WinAPI ``CreateProcess``)，并要注意当解析或搜索可执行文件路径时如果传入 ``shell=False``，则 *cwd* "
"不会覆盖当前工作目录而 *env* 无法覆盖 ``PATH`` 环境变量。 使用完整路径可避免所有这些变化情况。"

#: ../../library/subprocess.rst:400
msgid ""
"An example of passing some arguments to an external program as a sequence "
"is::"
msgstr "向外部函数传入序列形式参数的一个例子如下::"

#: ../../library/subprocess.rst:403
msgid "Popen([\"/usr/bin/git\", \"commit\", \"-m\", \"Fixes a bug.\"])"
msgstr "Popen([\"/usr/bin/git\", \"commit\", \"-m\", \"Fixes a bug.\"])"

#: ../../library/subprocess.rst:405
msgid ""
"On POSIX, if *args* is a string, the string is interpreted as the name or "
"path of the program to execute.  However, this can only be done if not "
"passing arguments to the program."
msgstr ""
"在 POSIX，如果 *args* 是一个字符串，此字符串被作为将被执行的程序的命名或路径解释。但是，只有在不传递任何参数给程序的情况下才能这么做。"

#: ../../library/subprocess.rst:411
msgid ""
"It may not be obvious how to break a shell command into a sequence of "
"arguments, especially in complex cases. :meth:`shlex.split` can illustrate "
"how to determine the correct tokenization for *args*::"
msgstr ""
"将 shell 命令拆分为参数序列的方式可能并不很直观，特别是在复杂的情况下。 :meth:`shlex.split` 可以演示如何确定 *args* "
"适当的拆分形式::"

#: ../../library/subprocess.rst:415
msgid ""
">>> import shlex, subprocess\n"
">>> command_line = input()\n"
"/bin/vikings -input eggs.txt -output \"spam spam.txt\" -cmd \"echo '$MONEY'\"\n"
">>> args = shlex.split(command_line)\n"
">>> print(args)\n"
"['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', \"echo '$MONEY'\"]\n"
">>> p = subprocess.Popen(args) # Success!"
msgstr ""
">>> import shlex, subprocess\n"
">>> command_line = input()\n"
"/bin/vikings -input eggs.txt -output \"spam spam.txt\" -cmd \"echo '$MONEY'\"\n"
">>> args = shlex.split(command_line)\n"
">>> print(args)\n"
"['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', \"echo '$MONEY'\"]\n"
">>> p = subprocess.Popen(args) # Success!"

#: ../../library/subprocess.rst:423
msgid ""
"Note in particular that options (such as *-input*) and arguments (such as "
"*eggs.txt*) that are separated by whitespace in the shell go in separate "
"list elements, while arguments that need quoting or backslash escaping when "
"used in the shell (such as filenames containing spaces or the *echo* command"
" shown above) are single list elements."
msgstr ""
"特别注意，由 shell 中的空格分隔的选项（例如 *-input*）和参数（例如 *eggs.txt* "
"）位于分开的列表元素中，而在需要时使用引号或反斜杠转义的参数在 shell （例如包含空格的文件名或上面显示的 *echo* 命令）是单独的列表元素。"

#: ../../library/subprocess.rst:429
msgid ""
"On Windows, if *args* is a sequence, it will be converted to a string in a "
"manner described in :ref:`converting-argument-sequence`.  This is because "
"the underlying ``CreateProcess()`` operates on strings."
msgstr ""
"在 Windows，如果 *args* 是一个序列，他将通过一个在 :ref:`converting-argument-sequence` "
"描述的方式被转换为一个字符串。这是因为底层的 ``CreateProcess()`` 只处理字符串。"

#: ../../library/subprocess.rst:433
msgid ""
"*args* parameter accepts a :term:`path-like object` if *shell* is ``False`` "
"and a sequence containing path-like objects on POSIX."
msgstr ""
"在 POSIX 上如果 *shell* 为 ``False`` 并且序列包含路径类对象则 *args* 形参可以接受一个 :term:`path-"
"like object`。"

#: ../../library/subprocess.rst:437
msgid ""
"*args* parameter accepts a :term:`path-like object` if *shell* is ``False`` "
"and a sequence containing bytes and path-like objects on Windows."
msgstr ""
"如果在Windows 上 *shell* 为 ``False`` 并且序列包含字节串和路径类对象则 *args* 形参可以接受一个 "
":term:`path-like object`。"

#: ../../library/subprocess.rst:442
msgid ""
"The *shell* argument (which defaults to ``False``) specifies whether to use "
"the shell as the program to execute.  If *shell* is ``True``, it is "
"recommended to pass *args* as a string rather than as a sequence."
msgstr ""
"参数 *shell* （默认为 ``False``）指定是否使用 shell 执行程序。如果 *shell* 为 ``True``，更推荐将 "
"*args* 作为字符串传递而非序列。"

#: ../../library/subprocess.rst:446
msgid ""
"On POSIX with ``shell=True``, the shell defaults to :file:`/bin/sh`.  If "
"*args* is a string, the string specifies the command to execute through the "
"shell.  This means that the string must be formatted exactly as it would be "
"when typed at the shell prompt.  This includes, for example, quoting or "
"backslash escaping filenames with spaces in them.  If *args* is a sequence, "
"the first item specifies the command string, and any additional items will "
"be treated as additional arguments to the shell itself.  That is to say, "
":class:`Popen` does the equivalent of::"
msgstr ""
"在 POSIX，当 ``shell=True``， shell 默认为 :file:`/bin/sh`。如果 *args* "
"是一个字符串，此字符串指定将通过 shell "
"执行的命令。这意味着字符串的格式必须和在命令提示符中所输入的完全相同。这包括，例如，引号和反斜杠转义包含空格的文件名。如果 *args* "
"是一个序列，第一项指定了命令，另外的项目将作为传递给 shell （而非命令） 的参数对待。也就是说， :class:`Popen` 等同于::"

#: ../../library/subprocess.rst:455
msgid "Popen(['/bin/sh', '-c', args[0], args[1], ...])"
msgstr "Popen(['/bin/sh', '-c', args[0], args[1], ...])"

#: ../../library/subprocess.rst:457
msgid ""
"On Windows with ``shell=True``, the :envvar:`COMSPEC` environment variable "
"specifies the default shell.  The only time you need to specify "
"``shell=True`` on Windows is when the command you wish to execute is built "
"into the shell (e.g. :command:`dir` or :command:`copy`).  You do not need "
"``shell=True`` to run a batch file or console-based executable."
msgstr ""
"在 Windows，使用 ``shell=True``，环境变量 :envvar:`COMSPEC` 指定了默认 shell。在 Windows "
"你唯一需要指定 ``shell=True`` 的情况是你想要执行内置在 shell 中的命令（例如 :command:`dir` 或者 "
":command:`copy`）。在运行一个批处理文件或者基于控制台的可执行文件时，不需要 ``shell=True``。"

#: ../../library/subprocess.rst:467
msgid ""
"*bufsize* will be supplied as the corresponding argument to the :func:`open`"
" function when creating the stdin/stdout/stderr pipe file objects:"
msgstr "*bufsize* 将在 :func:`open` 函数创建了 stdin/stdout/stderr 管道文件对象时作为对应的参数供应:"

#: ../../library/subprocess.rst:471
msgid ""
"``0`` means unbuffered (read and write are one system call and can return "
"short)"
msgstr "``0`` 表示不使用缓冲区（读取与写入是一个系统调用并且可以返回短内容）"

#: ../../library/subprocess.rst:473
msgid ""
"``1`` means line buffered (only usable if ``text=True`` or "
"``universal_newlines=True``)"
msgstr "``1`` 表示带有行缓冲（仅在 ``text=True`` 或 ``universal_newlines=True`` 时有用）"

#: ../../library/subprocess.rst:475
msgid "any other positive value means use a buffer of approximately that size"
msgstr "任何其他正值表示使用一个约为对应大小的缓冲区"

#: ../../library/subprocess.rst:477
msgid ""
"negative bufsize (the default) means the system default of "
"io.DEFAULT_BUFFER_SIZE will be used."
msgstr "负的 *bufsize* （默认）表示使用系统默认的 io.DEFAULT_BUFFER_SIZE。"

#: ../../library/subprocess.rst:480
msgid ""
"*bufsize* now defaults to -1 to enable buffering by default to match the "
"behavior that most code expects.  In versions prior to Python 3.2.4 and "
"3.3.1 it incorrectly defaulted to ``0`` which was unbuffered and allowed "
"short reads.  This was unintentional and did not match the behavior of "
"Python 2 as most code expected."
msgstr ""
"*bufsize* 现在默认为 -1 表示启用缓冲以符合大多数代码所期望的行为。 在 Python 3.2.4 和 3.3.1 "
"之前的版本中它错误地将默认值设为 ``0`` 即无缓冲并且允许短读取。 这是无意的失误并且与大多数代码所期望的 Python 2 的行为不一致。"

#: ../../library/subprocess.rst:487
msgid ""
"The *executable* argument specifies a replacement program to execute.   It "
"is very seldom needed.  When ``shell=False``, *executable* replaces the "
"program to execute specified by *args*.  However, the original *args* is "
"still passed to the program.  Most programs treat the program specified by "
"*args* as the command name, which can then be different from the program "
"actually executed.  On POSIX, the *args* name becomes the display name for "
"the executable in utilities such as :program:`ps`.  If ``shell=True``, on "
"POSIX the *executable* argument specifies a replacement shell for the "
"default :file:`/bin/sh`."
msgstr ""
"*executable* 参数指定一个要执行的替换程序。这很少需要。当 ``shell=True``， *executable* 替换 *args* "
"指定运行的程序。但是，原始的 *args* 仍然被传递给程序。大多数程序将被 *args* 指定的程序作为命令名对待，这可以与实际运行的程序不同。在 "
"POSIX， *args* 名作为实际调用程序中可执行文件的显示名称，例如 :program:`ps`。如果 ``shell=True``，在 "
"POSIX， *executable* 参数指定用于替换默认 shell :file:`/bin/sh` 的 shell。"

#: ../../library/subprocess.rst:497
msgid "*executable* parameter accepts a :term:`path-like object` on POSIX."
msgstr "在POSIX 上 *executable* 形参可以接受一个 :term:`path-like object`。"

#: ../../library/subprocess.rst:500
msgid ""
"*executable* parameter accepts a bytes and :term:`path-like object` on "
"Windows."
msgstr "在Windows 上 *executable* 形参可以接受一个字节串和 :term:`path-like object`。"

#: ../../library/subprocess.rst:512
msgid ""
"*stdin*, *stdout* and *stderr* specify the executed program's standard "
"input, standard output and standard error file handles, respectively.  Valid"
" values are ``None``, :data:`PIPE`, :data:`DEVNULL`, an existing file "
"descriptor (a positive integer), and an existing :term:`file object` with a "
"valid file descriptor.  With the default settings of ``None``, no "
"redirection will occur.  :data:`PIPE` indicates that a new pipe to the child"
" should be created.  :data:`DEVNULL` indicates that the special file "
":data:`os.devnull` will be used.  Additionally, *stderr* can be "
":data:`STDOUT`, which indicates that the stderr data from the applications "
"should be captured into the same file handle as for *stdout*."
msgstr ""
"*stdin*, *stdout* 和 *stderr* 分别指定被执行程序的标准输入、标准输出和标准错误文件句柄。 合法的值包括 ``None``, "
":data:`PIPE`, :data:`DEVNULL`, 现在的文件描述符（一个正整数），现存的具有合法文件描述符的 :term:`file "
"object`。 当使用默认设置 ``None`` 时，将不会进行任何重定向。 :data:`PIPE` 表示应当新建一个连接子进程的管道。 "
":data:`DEVNULL` 表示将使用特殊文件 :data:`os.devnull`。 此外，*stderr* 还可以为 "
":data:`STDOUT`，这表示来自子进程的 stderr 数据应当被捕获到与 *stdout* 相同的文件句柄中。"

#: ../../library/subprocess.rst:523
msgid ""
"If *preexec_fn* is set to a callable object, this object will be called in "
"the child process just before the child is executed. (POSIX only)"
msgstr "如果 *preexec_fn* 被设为一个可调用对象，此对象将在子进程刚创建时被调用。（仅 POSIX）"

#: ../../library/subprocess.rst:529
msgid ""
"The *preexec_fn* parameter is NOT SAFE to use in the presence of threads in "
"your application.  The child process could deadlock before exec is called."
msgstr "*preexec_fn* 形参在应用程序中存在多线程时是不安全的。 子进程在 exec 被调用之前可能会死锁。"

#: ../../library/subprocess.rst:535
msgid ""
"If you need to modify the environment for the child use the *env* parameter "
"rather than doing it in a *preexec_fn*. The *start_new_session* and "
"*process_group* parameters should take the place of code using *preexec_fn* "
"to call :func:`os.setsid` or :func:`os.setpgid` in the child."
msgstr ""
"如果你需要为子进程修改环境请使用 *env* 形参而不要在 *preexec_fn* 中操作。 *start_new_session* 和 "
"*process_group* 形参应当代替使用 *preexec_fn* 的代码来在子进程中调用 :func:`os.setsid` 或 "
":func:`os.setpgid`。"

#: ../../library/subprocess.rst:542
msgid ""
"The *preexec_fn* parameter is no longer supported in subinterpreters. The "
"use of the parameter in a subinterpreter raises :exc:`RuntimeError`. The new"
" restriction may affect applications that are deployed in mod_wsgi, uWSGI, "
"and other embedded environments."
msgstr ""
"*preexec_fn* 形参在子解释器中已不再受支持。 在子解释器中使用此形参将引发 :exc:`RuntimeError`。 "
"这个新限制可能会影响部署在 mod_wsgi, uWSGI 和其他嵌入式环境中的应用。"

#: ../../library/subprocess.rst:547
msgid ""
"If *close_fds* is true, all file descriptors except ``0``, ``1`` and ``2`` "
"will be closed before the child process is executed.  Otherwise when "
"*close_fds* is false, file descriptors obey their inheritable flag as "
"described in :ref:`fd_inheritance`."
msgstr ""
"如果 *close_fds* 为真值，则除 ``0``, ``1`` 和 ``2`` 之外的所有文件描述符都将在子进程执行前被关闭。 而当 "
"*close_fds* 为假值时，文件描述符将遵循它们的可继承旗标，如 :ref:`fd_inheritance` 所描述的。"

#: ../../library/subprocess.rst:552
msgid ""
"On Windows, if *close_fds* is true then no handles will be inherited by the "
"child process unless explicitly passed in the ``handle_list`` element of "
":attr:`STARTUPINFO.lpAttributeList`, or by standard handle redirection."
msgstr ""
"在 Windows，如果 *close_fds* 为真， 则子进程不会继承任何句柄，除非在 "
":attr:`STARTUPINFO.IpAttributeList` 的 ``handle_list`` 的键中显式传递，或者通过标准句柄重定向传递。"

#: ../../library/subprocess.rst:556
msgid ""
"The default for *close_fds* was changed from :const:`False` to what is "
"described above."
msgstr "*close_fds* 的默认值已经从 :const:`False` 修改为上述值。"

#: ../../library/subprocess.rst:560
msgid ""
"On Windows the default for *close_fds* was changed from :const:`False` to "
":const:`True` when redirecting the standard handles. It's now possible to "
"set *close_fds* to :const:`True` when redirecting the standard handles."
msgstr ""
"在 Windows，当重定向标准句柄时 *close_fds* 的默认值从 :const:`False` 变为 "
":const:`True`。现在重定向标准句柄时有可能设置 *close_fds* 为 :const:`True`。（标准句柄指三个 stdio "
"的句柄）"

#: ../../library/subprocess.rst:565
msgid ""
"*pass_fds* is an optional sequence of file descriptors to keep open between "
"the parent and child.  Providing any *pass_fds* forces *close_fds* to be "
":const:`True`.  (POSIX only)"
msgstr ""
"*pass_fds* 是一个可选的在父子进程间保持打开的文件描述符序列。提供任何 *pass_fds* 将强制 *close_fds* 为 "
":const:`True`。（仅 POSIX）"

#: ../../library/subprocess.rst:569
msgid "The *pass_fds* parameter was added."
msgstr "加入了 *pass_fds* 形参。"

#: ../../library/subprocess.rst:572
msgid ""
"If *cwd* is not ``None``, the function changes the working directory to "
"*cwd* before executing the child.  *cwd* can be a string, bytes or "
":term:`path-like <path-like object>` object.  On POSIX, the function looks "
"for *executable* (or for the first item in *args*) relative to *cwd* if the "
"executable path is a relative path."
msgstr ""
"如果 *cwd* 不为 ``None``，此函数在执行子进程前会将当前工作目录改为 *cwd*。 *cwd* 可以是一个字符串、字节串或 "
":term:`路径类对象 <path-like object>`。 在 POSIX 上，如果可执行文件路径为相对路径则此函数会相对于 *cwd* 来查找"
" *executable* (或 *args* 的第一项)。"

#: ../../library/subprocess.rst:578
msgid "*cwd* parameter accepts a :term:`path-like object` on POSIX."
msgstr "在 POSIX 上 *cwd* 形参接受一个 :term:`path-like object`。"

#: ../../library/subprocess.rst:581
msgid "*cwd* parameter accepts a :term:`path-like object` on Windows."
msgstr "在 Windows 上 *cwd* 形参接受一个 :term:`path-like object`。"

#: ../../library/subprocess.rst:584
msgid "*cwd* parameter accepts a bytes object on Windows."
msgstr "在 Windows 上 *cwd* 形参接受一个字节串对象。"

#: ../../library/subprocess.rst:587
msgid ""
"If *restore_signals* is true (the default) all signals that Python has set "
"to SIG_IGN are restored to SIG_DFL in the child process before the exec. "
"Currently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals. (POSIX "
"only)"
msgstr ""
" 如果 *restore_signals* 为 true（默认值），则 Python 设置为 SIG_IGN 的所有信号将在 exec "
"之前的子进程中恢复为 SIG_DFL。目前，这包括 SIGPIPE ，SIGXFZ 和 SIGXFSZ 信号。 （仅 POSIX）"

#: ../../library/subprocess.rst:592
msgid "*restore_signals* was added."
msgstr "*restore_signals* 被加入。"

#: ../../library/subprocess.rst:595
msgid ""
"If *start_new_session* is true the ``setsid()`` system call will be made in "
"the child process prior to the execution of the subprocess."
msgstr "如果 *start_new_session* 为真值则 ``setsid()`` 系统调用将在执行子进程之前在子进程中执行。"

#: ../../library/subprocess.rst:599
msgid "*start_new_session* was added."
msgstr "*start_new_session* 被添加。"

#: ../../library/subprocess.rst:602
msgid ""
"If *process_group* is a non-negative integer, the ``setpgid(0, value)`` "
"system call will be made in the child process prior to the execution of the "
"subprocess."
msgstr ""
"如果 *process_group* 为非负整数，则 ``setpgid(0, value)`` 系统调用将在执行子进程之前在子进程中执行。"

#: ../../library/subprocess.rst:606
msgid "*process_group* was added."
msgstr "添加了 *process_group*。"

#: ../../library/subprocess.rst:609
msgid ""
"If *group* is not ``None``, the setregid() system call will be made in the "
"child process prior to the execution of the subprocess. If the provided "
"value is a string, it will be looked up via :func:`grp.getgrnam` and the "
"value in ``gr_gid`` will be used. If the value is an integer, it will be "
"passed verbatim. (POSIX only)"
msgstr ""
"如果 *group* 不为 ``None``，则 setregid() 系统调用将在子进程执行之前在下级进程中进行。 如果所提供的值是一个字符串，将通过"
" :func:`grp.getgrnam` 来查找它并将使用 ``gr_gid`` 中的值。 如果该值是一个整数，它将被原样传递。 （POSIX 专属）"

#: ../../library/subprocess.rst:618
msgid ""
"If *extra_groups* is not ``None``, the setgroups() system call will be made "
"in the child process prior to the execution of the subprocess. Strings "
"provided in *extra_groups* will be looked up via :func:`grp.getgrnam` and "
"the values in ``gr_gid`` will be used. Integer values will be passed "
"verbatim. (POSIX only)"
msgstr ""
"如果 *extra_groups* 不为 ``None``，则 setgroups() 系统调用将在子进程执行之前在下级进程中进行。 在 "
"*extra_groups* 中提供的字符串将通过 :func:`grp.getgrnam` 来查找并将使用 ``gr_gid`` 中的值。 "
"整数值将被原样传递。 （POSIX 专属）"

#: ../../library/subprocess.rst:627
msgid ""
"If *user* is not ``None``, the setreuid() system call will be made in the "
"child process prior to the execution of the subprocess. If the provided "
"value is a string, it will be looked up via :func:`pwd.getpwnam` and the "
"value in ``pw_uid`` will be used. If the value is an integer, it will be "
"passed verbatim. (POSIX only)"
msgstr ""
"如果 *user* 不为 ``None``，则 setreuid() 系统调用将在子进程执行之前 在下级进程中进行。 如果所提供的值是一个字符串，将通过"
" :func:`pwd.getpwnam` 来查找它并将使用 ``pw_uid`` 中的值。 如果该值是一个整数，它将被原样传递。 （POSIX 专属）"

#: ../../library/subprocess.rst:636
msgid ""
"If *umask* is not negative, the umask() system call will be made in the "
"child process prior to the execution of the subprocess."
msgstr "如果 *umask* 不为负值，则 umask() 系统调用将在子进程执行之前在下级进程中进行。"

#: ../../library/subprocess.rst:642
msgid ""
"If *env* is not ``None``, it must be a mapping that defines the environment "
"variables for the new process; these are used instead of the default "
"behavior of inheriting the current process' environment. This mapping can be"
" str to str on any platform or bytes to bytes on POSIX platforms much like "
":data:`os.environ` or :data:`os.environb`."
msgstr ""
"如果 *env* 不为 ``None``，则它必须是一个为新进程定义环境变量的映射；它们将顶替继承当前环境的默认行为被使用。 "
"这个映射在任何平台上均可以是字符串到字符串的映射或者在 POSIX 平台上也可以是字节串到字节串的映射，就像是 :data:`os.environ` "
"或者 :data:`os.environb`。"

#: ../../library/subprocess.rst:650
msgid ""
"If specified, *env* must provide any variables required for the program to "
"execute.  On Windows, in order to run a `side-by-side assembly`_ the "
"specified *env* **must** include a valid :envvar:`SystemRoot`."
msgstr ""
"如果指定， *env* 必须提供所有被子进程需求的变量。在 Windows，为了运行一个 `side-by-side assembly`_ ，指定的 "
"*env* **必须** 包含一个有效的 :envvar:`SystemRoot`。"

#: ../../library/subprocess.rst:656
msgid ""
"If *encoding* or *errors* are specified, or *text* is true, the file objects"
" *stdin*, *stdout* and *stderr* are opened in text mode with the specified "
"*encoding* and *errors*, as described above in :ref:`frequently-used-"
"arguments`. The *universal_newlines* argument is equivalent  to *text* and "
"is provided for backwards compatibility. By default, file objects are opened"
" in binary mode."
msgstr ""
"如果指定了 *encoding* 或 *errors*，或者如果 *text* 为真值，则文件对象 *stdin*, *stdout* 和 "
"*stderr* 将使用指定的 *encoding* 和 *errors* 以文本模式打开，就如上文 :ref:`frequently-used-"
"arguments` 中所描述的。 *universal_newlines* 参数等同于 *text* 且是出于下向兼容性考虑而提供的。 "
"在默认情况下，文件对象将以二进制模式打开。"

#: ../../library/subprocess.rst:662
msgid "*encoding* and *errors* were added."
msgstr "*encoding* 和 *errors* 被添加。"

#: ../../library/subprocess.rst:665 ../../library/subprocess.rst:1312
msgid "*text* was added as a more readable alias for *universal_newlines*."
msgstr "*text* 作为 *universal_newlines* 的一个更具可读性的别名被添加。"

#: ../../library/subprocess.rst:668
msgid ""
"If given, *startupinfo* will be a :class:`STARTUPINFO` object, which is "
"passed to the underlying ``CreateProcess`` function."
msgstr ""
"如果给出，*startupinfo* 将是一个 :class:`STARTUPINFO` 对象，它会被传递给下层的 ``CreateProcess`` "
"函数。"

#: ../../library/subprocess.rst:671
msgid "If given, *creationflags*, can be one or more of the following flags:"
msgstr "如果给出，*creationflags* 可以是下列旗标中的一个或多个："

#: ../../library/subprocess.rst:673
msgid ":data:`CREATE_NEW_CONSOLE`"
msgstr ":data:`CREATE_NEW_CONSOLE`"

#: ../../library/subprocess.rst:674
msgid ":data:`CREATE_NEW_PROCESS_GROUP`"
msgstr ":data:`CREATE_NEW_PROCESS_GROUP`"

#: ../../library/subprocess.rst:675
msgid ":data:`ABOVE_NORMAL_PRIORITY_CLASS`"
msgstr ":data:`ABOVE_NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:676
msgid ":data:`BELOW_NORMAL_PRIORITY_CLASS`"
msgstr ":data:`BELOW_NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:677
msgid ":data:`HIGH_PRIORITY_CLASS`"
msgstr ":data:`HIGH_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:678
msgid ":data:`IDLE_PRIORITY_CLASS`"
msgstr ":data:`IDLE_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:679
msgid ":data:`NORMAL_PRIORITY_CLASS`"
msgstr ":data:`NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:680
msgid ":data:`REALTIME_PRIORITY_CLASS`"
msgstr ":data:`REALTIME_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:681
msgid ":data:`CREATE_NO_WINDOW`"
msgstr ":data:`CREATE_NO_WINDOW`"

#: ../../library/subprocess.rst:682
msgid ":data:`DETACHED_PROCESS`"
msgstr ":data:`DETACHED_PROCESS`"

#: ../../library/subprocess.rst:683
msgid ":data:`CREATE_DEFAULT_ERROR_MODE`"
msgstr ":data:`CREATE_DEFAULT_ERROR_MODE`"

#: ../../library/subprocess.rst:684
msgid ":data:`CREATE_BREAKAWAY_FROM_JOB`"
msgstr ":data:`CREATE_BREAKAWAY_FROM_JOB`"

#: ../../library/subprocess.rst:686
msgid ""
"*pipesize* can be used to change the size of the pipe when :data:`PIPE` is "
"used for *stdin*, *stdout* or *stderr*. The size of the pipe is only changed"
" on platforms that support this (only Linux at this time of writing). Other "
"platforms will ignore this parameter."
msgstr ""
"当 :data:`PIPE` 被用作 *stdin*, *stdout* 或 *stderr* 时 *pipesize* 可被用于改变管道的大小。 "
"管道的大小仅会在受支持的平台上被改变（当撰写本文档时只有 Linux 支持）。 其他平台将忽略此形参。"

#: ../../library/subprocess.rst:691
msgid "Added the *pipesize* parameter."
msgstr "增加了 *pipesize* 形参。"

#: ../../library/subprocess.rst:694
msgid ""
"Popen objects are supported as context managers via the :keyword:`with` "
"statement: on exit, standard file descriptors are closed, and the process is"
" waited for. ::"
msgstr "Popen 对象支持通过 :keyword:`with` 语句作为上下文管理器，在退出时关闭文件描述符并等待进程::"

#: ../../library/subprocess.rst:698
msgid ""
"with Popen([\"ifconfig\"], stdout=PIPE) as proc:\n"
"    log.write(proc.stdout.read())"
msgstr ""
"with Popen([\"ifconfig\"], stdout=PIPE) as proc:\n"
"    log.write(proc.stdout.read())"

#: ../../library/subprocess.rst:701 ../../library/subprocess.rst:703
msgid ""
"Popen and the other functions in this module that use it raise an "
":ref:`auditing event <auditing>` ``subprocess.Popen`` with arguments "
"``executable``, ``args``, ``cwd``, and ``env``. The value for ``args`` may "
"be a single string or a list of strings, depending on platform."
msgstr ""
"Popen 和此模块中用到它的其他函数会引发一个 :ref:`审计事件 <auditing>` ``subprocess.Popen``，附带参数 "
"``executable``, ``args``, ``cwd`` 和 ``env``。 ``args`` "
"的值可以是单个字符串或字符串列表，取决于具体的平台。"

#: ../../library/subprocess.rst:708
msgid "Added context manager support."
msgstr "添加了上下文管理器支持。"

#: ../../library/subprocess.rst:711
msgid ""
"Popen destructor now emits a :exc:`ResourceWarning` warning if the child "
"process is still running."
msgstr "现在，如果 Popen 析构时子进程仍然在运行，则析构器会发送一个 :exc:`ResourceWarning` 警告。"

#: ../../library/subprocess.rst:715
msgid ""
"Popen can use :func:`os.posix_spawn` in some cases for better performance. "
"On Windows Subsystem for Linux and QEMU User Emulation, Popen constructor "
"using :func:`os.posix_spawn` no longer raise an exception on errors like "
"missing program, but the child process fails with a non-zero "
":attr:`~Popen.returncode`."
msgstr ""
"在某些情况下 Popen 可以使用 :func:`os.posix_spawn` 以获得更好的性能。在适用于 Linux 的 Windows 子系统和 "
"QEMU 用户模拟器上，使用 :func:`os.posix_spawn` 的 Popen "
"构造器不再会因找不到程序等错误而引发异常，而是上下级进程失败并返回一个非零的 :attr:`~Popen.returncode`。"

#: ../../library/subprocess.rst:724
msgid "Exceptions"
msgstr "异常"

#: ../../library/subprocess.rst:726
msgid ""
"Exceptions raised in the child process, before the new program has started "
"to execute, will be re-raised in the parent."
msgstr "在子进程中抛出的异常，在新的进程开始执行前，将会被再次在父进程中抛出。"

#: ../../library/subprocess.rst:729
msgid ""
"The most common exception raised is :exc:`OSError`.  This occurs, for "
"example, when trying to execute a non-existent file.  Applications should "
"prepare for :exc:`OSError` exceptions. Note that, when ``shell=True``, "
":exc:`OSError` will be raised by the child only if the selected shell itself"
" was not found. To determine if the shell failed to find the requested "
"application, it is necessary to check the return code or output from the "
"subprocess."
msgstr ""
"被引发的最一般异常是 :exc:`OSError`。 例如这会在尝试执行一个不存在的文件时发生。 应用程序应当为 :exc:`OSError` "
"异常做好准备。 请注意，如果 ``shell=True``，则 :exc:`OSError` 仅会在未找到选定的 shell 本身时被引发。 要确定 "
"shell 是否未找到所请求的应用程序，必须检查来自子进程的返回码或输出。"

#: ../../library/subprocess.rst:736
msgid ""
"A :exc:`ValueError` will be raised if :class:`Popen` is called with invalid "
"arguments."
msgstr "如果 :class:`Popen` 调用时有无效的参数，则一个 :exc:`ValueError` 将被抛出。"

#: ../../library/subprocess.rst:739
msgid ""
":func:`check_call` and :func:`check_output` will raise "
":exc:`CalledProcessError` if the called process returns a non-zero return "
"code."
msgstr ""
":func:`check_call` 与 :func:`check_output` 在调用的进程返回非零退出码时将抛出 "
":exc:`CalledProcessError`。"

#: ../../library/subprocess.rst:743
msgid ""
"All of the functions and methods that accept a *timeout* parameter, such as "
":func:`run` and :meth:`Popen.communicate` will raise :exc:`TimeoutExpired` "
"if the timeout expires before the process exits."
msgstr ""
"所有接受 *timeout* 形参的函数与方法，例如 :func:`run` 和 :meth:`Popen.communicate` "
"将会在进程退出前超时到期时引发 :exc:`TimeoutExpired`。"

#: ../../library/subprocess.rst:747
msgid ""
"Exceptions defined in this module all inherit from :exc:`SubprocessError`."
msgstr "此模块中定义的异常都继承自 :exc:`SubprocessError`。"

#: ../../library/subprocess.rst:749
msgid "The :exc:`SubprocessError` base class was added."
msgstr "基类 :exc:`SubprocessError` 被添加。"

#: ../../library/subprocess.rst:755
msgid "Security Considerations"
msgstr "安全考量"

#: ../../library/subprocess.rst:757
msgid ""
"Unlike some other popen functions, this library will not implicitly choose "
"to call a system shell.  This means that all characters, including shell "
"metacharacters, can safely be passed to child processes. If the shell is "
"invoked explicitly, via ``shell=True``, it is the application's "
"responsibility to ensure that all whitespace and metacharacters are quoted "
"appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. On :ref:`some platforms <shlex-quote-warning>`, it is "
"possible to use :func:`shlex.quote` for this escaping."
msgstr ""
"不同于某些其他的 popen 函数，这个库将不会隐式地选择调用系统 shell。 这意味着所有字符，包括 shell 元字符都可以被安全地传递给子进程。"
" 如果 shell 是通过 ``shell=True`` 被显式地唤起的，则应用程序要负责确保所有空白符和元字符被适当地转义以避免 `shell 注入 "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ 安全漏洞。 在 "
":ref:`某些平台 <shlex-quote-warning>` 上，可以使用 :func:`shlex.quote` 来执行这种转义。"

#: ../../library/subprocess.rst:767
msgid ""
"On Windows, batch files (:file:`*.bat` or :file:`*.cmd`) may be launched by "
"the operating system in a system shell regardless of the arguments passed to"
" this library. This could result in arguments being parsed according to "
"shell rules, but without any escaping added by Python. If you are "
"intentionally launching a batch file with arguments from untrusted sources, "
"consider passing ``shell=True`` to allow Python to escape special "
"characters. See :gh:`114539` for additional discussion."
msgstr ""
"在 Windows 上，批处理文件 (:file:`*.bat` 或 :file:`*.cmd`) 可以在系统 shell "
"中通过操作系统调用来启动而忽略传给该库的参数。 这可能导致根据 shell 规则来解析参数，而没有任何 Python 添加的转义。 "
"如果你想要附带来自不受信任源的参数启动批处理文件，请考虑传入 ``shell=True`` 以允许 Python 转义特殊字符。 请参阅 "
":gh:`114539` 了解相关讨论。"

#: ../../library/subprocess.rst:777
msgid "Popen Objects"
msgstr "Popen 对象"

#: ../../library/subprocess.rst:779
msgid "Instances of the :class:`Popen` class have the following methods:"
msgstr ":class:`Popen` 类的实例拥有以下方法："

#: ../../library/subprocess.rst:784
msgid ""
"Check if child process has terminated.  Set and return "
":attr:`~Popen.returncode` attribute. Otherwise, returns ``None``."
msgstr "检查子进程是否已被终止。设置并返回 :attr:`~Popen.returncode` 属性。否则返回 ``None``。"

#: ../../library/subprocess.rst:790
msgid ""
"Wait for child process to terminate.  Set and return "
":attr:`~Popen.returncode` attribute."
msgstr "等待子进程被终止。设置并返回 :attr:`~Popen.returncode` 属性。"

#: ../../library/subprocess.rst:793
msgid ""
"If the process does not terminate after *timeout* seconds, raise a "
":exc:`TimeoutExpired` exception.  It is safe to catch this exception and "
"retry the wait."
msgstr "如果进程在 *timeout* 秒后未中断，抛出一个 :exc:`TimeoutExpired` 异常，可以安全地捕获此异常并重新等待。"

#: ../../library/subprocess.rst:799
msgid ""
"This will deadlock when using ``stdout=PIPE`` or ``stderr=PIPE`` and the "
"child process generates enough output to a pipe such that it blocks waiting "
"for the OS pipe buffer to accept more data. Use :meth:`Popen.communicate` "
"when using pipes to avoid that."
msgstr ""
"当 ``stdout=PIPE`` 或者 ``stderr=PIPE`` 并且子进程产生了足以阻塞 OS "
"管道缓冲区接收更多数据的输出到管道时，将会发生死锁。当使用管道时用 :meth:`Popen.communicate` 来规避它。"

#: ../../library/subprocess.rst:806
msgid ""
"When the ``timeout`` parameter is not ``None``, then (on POSIX) the function"
" is implemented using a busy loop (non-blocking call and short sleeps). Use "
"the :mod:`asyncio` module for an asynchronous wait: see "
":class:`asyncio.create_subprocess_exec`."
msgstr ""
"当 ``timeout`` 形参不为 ``None`` 时，该函数（在 POSIX 上）将使用一个忙循环（非阻塞调用及短睡眠）来实现。 使用 "
":mod:`asyncio` 模块进行异步等待：参见 :class:`asyncio.create_subprocess_exec`。"

#: ../../library/subprocess.rst:811 ../../library/subprocess.rst:852
#: ../../library/subprocess.rst:1209 ../../library/subprocess.rst:1249
#: ../../library/subprocess.rst:1303
msgid "*timeout* was added."
msgstr "*timeout* 被添加"

#: ../../library/subprocess.rst:816
msgid ""
"Interact with process: Send data to stdin.  Read data from stdout and "
"stderr, until end-of-file is reached.  Wait for process to terminate and set"
" the :attr:`~Popen.returncode` attribute.  The optional *input* argument "
"should be data to be sent to the child process, or ``None``, if no data "
"should be sent to the child.  If streams were opened in text mode, *input* "
"must be a string. Otherwise, it must be bytes."
msgstr ""
"与进程交互：将数据发送到 stdin。 从 stdout 和 stderr 读取数据，直到抵达文件结尾。 等待进程终止并设置 "
":attr:`~Popen.returncode` 属性。 可选的 *input* "
"参数应为要发送到下级进程的数据，或者如果没有要发送到下级进程的数据则为 ``None``。 如果流是以文本模式打开的，则 *input* 必须为字符串。"
" 在其他情况下，它必须为字节串。"

#: ../../library/subprocess.rst:823
msgid ""
":meth:`communicate` returns a tuple ``(stdout_data, stderr_data)``. The data"
" will be strings if streams were opened in text mode; otherwise, bytes."
msgstr ""
":meth:`communicate` 返回一个 ``(stdout_data, stderr_data)`` "
"元组。如果文件以文本模式打开则为字符串；否则字节。"

#: ../../library/subprocess.rst:827
msgid ""
"Note that if you want to send data to the process's stdin, you need to "
"create the Popen object with ``stdin=PIPE``.  Similarly, to get anything "
"other than ``None`` in the result tuple, you need to give ``stdout=PIPE`` "
"and/or ``stderr=PIPE`` too."
msgstr ""
"注意如果你想要向进程的 stdin 传输数据，你需要通过 ``stdin=PIPE`` 创建此 Popen 对象。类似的，要从结果元组获取任何非 "
"``None`` 值，你同样需要设置 ``stdout=PIPE`` 或者 ``stderr=PIPE``。"

#: ../../library/subprocess.rst:832
msgid ""
"If the process does not terminate after *timeout* seconds, a "
":exc:`TimeoutExpired` exception will be raised.  Catching this exception and"
" retrying communication will not lose any output."
msgstr ""
"如果进程在 *timeout* 秒后未终止，一个 :exc:`TimeoutExpired` 异常将被抛出。捕获此异常并重新等待将不会丢失任何输出。"

#: ../../library/subprocess.rst:836
msgid ""
"The child process is not killed if the timeout expires, so in order to "
"cleanup properly a well-behaved application should kill the child process "
"and finish communication::"
msgstr "如果超时到期，子进程不会被杀死，所以为了正确清理一个行为良好的应用程序应该杀死子进程并完成通讯。"

#: ../../library/subprocess.rst:840
msgid ""
"proc = subprocess.Popen(...)\n"
"try:\n"
"    outs, errs = proc.communicate(timeout=15)\n"
"except TimeoutExpired:\n"
"    proc.kill()\n"
"    outs, errs = proc.communicate()"
msgstr ""
"proc = subprocess.Popen(...)\n"
"try:\n"
"    outs, errs = proc.communicate(timeout=15)\n"
"except TimeoutExpired:\n"
"    proc.kill()\n"
"    outs, errs = proc.communicate()"

#: ../../library/subprocess.rst:849
msgid ""
"The data read is buffered in memory, so do not use this method if the data "
"size is large or unlimited."
msgstr "内存里数据读取是缓冲的，所以如果数据尺寸过大或无限，不要使用此方法。"

#: ../../library/subprocess.rst:858
msgid "Sends the signal *signal* to the child."
msgstr "将信号 *signal* 发送给子进程。"

#: ../../library/subprocess.rst:860
msgid "Do nothing if the process completed."
msgstr "如果进程已完成则不做任何操作。"

#: ../../library/subprocess.rst:864
msgid ""
"On Windows, SIGTERM is an alias for :meth:`terminate`. CTRL_C_EVENT and "
"CTRL_BREAK_EVENT can be sent to processes started with a *creationflags* "
"parameter which includes ``CREATE_NEW_PROCESS_GROUP``."
msgstr ""
"在 Windows 上，SIGTERM 是 :meth:`terminate` 的别名。 CTRL_C_EVENT 和 CTRL_BREAK_EVENT"
" 可被发送给以包括 ``CREATE_NEW_PROCESS_GROUP`` 的 *creationflags* 形参来启动的进程。"

#: ../../library/subprocess.rst:871
msgid ""
"Stop the child. On POSIX OSs the method sends :py:const:`~signal.SIGTERM` to"
" the child. On Windows the Win32 API function :c:func:`!TerminateProcess` is"
" called to stop the child."
msgstr ""
"停止子进程。 在 POSIX 操作系统上此方法会发送 :py:const:`~signal.SIGTERM` 给子进程。 在 Windows 上则会调用"
" Win32 API 函数 :c:func:`!TerminateProcess` 来停止子进程。"

#: ../../library/subprocess.rst:878
msgid ""
"Kills the child. On POSIX OSs the function sends SIGKILL to the child. On "
"Windows :meth:`kill` is an alias for :meth:`terminate`."
msgstr ""
"杀死子进程。 在 POSIX 操作系统上，此函数会发送 SIGKILL 给子进程。 在 Windows 上 :meth:`kill` 则是 "
":meth:`terminate` 的别名。"

#: ../../library/subprocess.rst:882
msgid ""
"The following attributes are also set by the class for you to access. "
"Reassigning them to new values is unsupported:"
msgstr "下列属性也会通过类来设置以供你访问。 将它们重赋新值是不受支持的:"

#: ../../library/subprocess.rst:887
msgid ""
"The *args* argument as it was passed to :class:`Popen` -- a sequence of "
"program arguments or else a single string."
msgstr "*args* 参数传递给 :class:`Popen` -- 一个程序参数的序列或者一个简单字符串。"

#: ../../library/subprocess.rst:894
msgid ""
"If the *stdin* argument was :data:`PIPE`, this attribute is a writeable "
"stream object as returned by :func:`open`. If the *encoding* or *errors* "
"arguments were specified or the *text* or *universal_newlines* argument was "
"``True``, the stream is a text stream, otherwise it is a byte stream. If the"
" *stdin* argument was not :data:`PIPE`, this attribute is ``None``."
msgstr ""
"如果 *stdin* 参数为 :data:`PIPE`，此属性是一个类似 :func:`open` 所返回对象的可写流对象。 如果指定了 "
"*encoding* 或 *errors* 参数或者 *text* 或 *universal_newlines* 参数为 "
"``True``，则这个流将是一个文本流，否则将是一个字节流。 如果 *stdin* 参数不为 :data:`PIPE`，则此属性将为 "
"``None``。"

#: ../../library/subprocess.rst:903
msgid ""
"If the *stdout* argument was :data:`PIPE`, this attribute is a readable "
"stream object as returned by :func:`open`. Reading from the stream provides "
"output from the child process. If the *encoding* or *errors* arguments were "
"specified or the *text* or *universal_newlines* argument was ``True``, the "
"stream is a text stream, otherwise it is a byte stream. If the *stdout* "
"argument was not :data:`PIPE`, this attribute is ``None``."
msgstr ""
"如果 *stdout* 参数为 :data:`PIPE`，此属性是一个类似 :func:`open` 所返回对象的可读流对象。 "
"从流中读取将会提供来自子进程的输出。 如果 *encoding* 或 *errors* 参数被指定或者 *text* 或 "
"*universal_newlines* 参数为 ``True``，则这个流将是一个文本流，否则将是一个字节流。 如果 *stdout* 参数不为 "
":data:`PIPE`，则此属性将为 ``None``。"

#: ../../library/subprocess.rst:913
msgid ""
"If the *stderr* argument was :data:`PIPE`, this attribute is a readable "
"stream object as returned by :func:`open`. Reading from the stream provides "
"error output from the child process. If the *encoding* or *errors* arguments"
" were specified or the *text* or *universal_newlines* argument was ``True``,"
" the stream is a text stream, otherwise it is a byte stream. If the *stderr*"
" argument was not :data:`PIPE`, this attribute is ``None``."
msgstr ""
"如果 *stderr* 参数为 :data:`PIPE`，此属性是一个类似 :func:`open` 所返回对象的可读流对象。 "
"从流中读取将会提供来自子进程的错误输出。 如果 *encoding* 或 *errors* 参数被指定或者 *text* 或 "
"*universal_newlines* 参数为 ``True``，则这个流将是一个文本流，否则将是一个字节流。 如果 *stderr* 参数不为 "
":data:`PIPE`，则此属性将为 ``None``。"

#: ../../library/subprocess.rst:922
msgid ""
"Use :meth:`~Popen.communicate` rather than :attr:`.stdin.write "
"<Popen.stdin>`, :attr:`.stdout.read <Popen.stdout>` or :attr:`.stderr.read "
"<Popen.stderr>` to avoid deadlocks due to any of the other OS pipe buffers "
"filling up and blocking the child process."
msgstr ""
"使用 :meth:`~Popen.communicate` 而非 :attr:`.stdin.write <Popen.stdin>`， "
":attr:`.stdout.read <Popen.stdout>` 或者 :attr:`.stderr.read <Popen.stderr>` "
"来避免由于任意其他 OS 管道缓冲区被子进程填满阻塞而导致的死锁。"

#: ../../library/subprocess.rst:930
msgid "The process ID of the child process."
msgstr "子进程的进程号。"

#: ../../library/subprocess.rst:932
msgid ""
"Note that if you set the *shell* argument to ``True``, this is the process "
"ID of the spawned shell."
msgstr "注意如果你设置了 *shell* 参数为 ``True``，则这是生成的子 shell 的进程号。"

#: ../../library/subprocess.rst:938
msgid ""
"The child return code. Initially ``None``, :attr:`returncode` is set by a "
"call to the :meth:`poll`, :meth:`wait`, or :meth:`communicate` methods if "
"they detect that the process has terminated."
msgstr ""
"子进程的返回码。 初始为 ``None``，:attr:`returncode` 是通过在检测到进程终结时调用 :meth:`poll`, "
":meth:`wait` 或 :meth:`communicate` 等方法来设置的。"

#: ../../library/subprocess.rst:942
msgid ""
"A ``None`` value indicates that the process hadn't yet terminated at the "
"time of the last method call."
msgstr "``None`` 值表示在最近一次方法调用时进程尚未终结"

#: ../../library/subprocess.rst:950
msgid "Windows Popen Helpers"
msgstr "Windows Popen 助手"

#: ../../library/subprocess.rst:952
msgid ""
"The :class:`STARTUPINFO` class and following constants are only available on"
" Windows."
msgstr ":class:`STARTUPINFO` 类和以下常数仅在 Windows 有效。"

#: ../../library/subprocess.rst:958
msgid ""
"Partial support of the Windows `STARTUPINFO <https://msdn.microsoft.com/en-"
"us/library/ms686331(v=vs.85).aspx>`__ structure is used for :class:`Popen` "
"creation.  The following attributes can be set by passing them as keyword-"
"only arguments."
msgstr ""
"在 :class:`Popen` 创建时部分支持 Windows 的 `STARTUPINFO "
"<https://msdn.microsoft.com/en-us/library/ms686331(v=vs.85).aspx>`__ "
"结构。接下来的属性仅能通过关键词参数设置。"

#: ../../library/subprocess.rst:963
msgid "Keyword-only argument support was added."
msgstr "仅关键词参数支持被加入。"

#: ../../library/subprocess.rst:968
msgid ""
"A bit field that determines whether certain :class:`STARTUPINFO` attributes "
"are used when the process creates a window. ::"
msgstr "一个位字段，用于确定进程在创建窗口时是否使用某些 :class:`STARTUPINFO` 属性。"

#: ../../library/subprocess.rst:971
msgid ""
"si = subprocess.STARTUPINFO()\n"
"si.dwFlags = subprocess.STARTF_USESTDHANDLES | subprocess.STARTF_USESHOWWINDOW"
msgstr ""
"si = subprocess.STARTUPINFO()\n"
"si.dwFlags = subprocess.STARTF_USESTDHANDLES | subprocess.STARTF_USESHOWWINDOW"

#: ../../library/subprocess.rst:976
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute is"
" the standard input handle for the process. If :data:`STARTF_USESTDHANDLES` "
"is not specified, the default for standard input is the keyboard buffer."
msgstr ""
"如果 :attr:`dwFlags` 被指定为 :data:`STARTF_USESTDHANDLES`，则此属性是进程的标准输入句柄，如果 "
":data:`STARTF_USESTDHANDLES` 未指定，则默认的标准输入是键盘缓冲区。"

#: ../../library/subprocess.rst:983
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute is"
" the standard output handle for the process. Otherwise, this attribute is "
"ignored and the default for standard output is the console window's buffer."
msgstr ""
"如果 :attr:`dwFlags` 被指定为 "
":data:`STARTF_USESTDHANDLES`，则此属性是进程的标准输出句柄。除此之外，此此属性将被忽略并且默认标准输出是控制台窗口缓冲区。"

#: ../../library/subprocess.rst:990
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute is"
" the standard error handle for the process. Otherwise, this attribute is "
"ignored and the default for standard error is the console window's buffer."
msgstr ""
"如果 :attr:`dwFlags` 被指定为 "
":data:`STARTF_USESTDHANDLES`，则此属性是进程的标准错误句柄。除此之外，此属性将被忽略并且默认标准错误为控制台窗口的缓冲区。"

#: ../../library/subprocess.rst:996
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESHOWWINDOW`, this attribute "
"can be any of the values that can be specified in the ``nCmdShow`` parameter"
" for the `ShowWindow <https://msdn.microsoft.com/en-"
"us/library/ms633548(v=vs.85).aspx>`__ function, except for "
"``SW_SHOWDEFAULT``. Otherwise, this attribute is ignored."
msgstr ""
"如果 :attr:`dwFlags` 指定了 :data:`STARTF_USESHOWWINDOW`，此属性可为能被指定为 函数 "
"`ShowWindow <https://msdn.microsoft.com/en-"
"us/library/ms633548(v=vs.85).aspx>`__ 的nCmdShow 的形参的任意值，除了 "
"``SW_SHOWDEFAULT``。如此之外，此属性被忽略。"

#: ../../library/subprocess.rst:1003
msgid ""
":data:`SW_HIDE` is provided for this attribute. It is used when "
":class:`Popen` is called with ``shell=True``."
msgstr ":data:`SW_HIDE` 被提供给此属性。它在 :class:`Popen` 由 ``shell=True`` 调用时使用。"

#: ../../library/subprocess.rst:1008
msgid ""
"A dictionary of additional attributes for process creation as given in "
"``STARTUPINFOEX``, see `UpdateProcThreadAttribute "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms686880(v=vs.85).aspx>`__."
msgstr ""
"``STARTUPINFOEX`` 给出的用于进程创建的额外属性字典，参阅 `UpdateProcThreadAttribute "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms686880(v=vs.85).aspx>`__。"

#: ../../library/subprocess.rst:1012
msgid "Supported attributes:"
msgstr "支持的属性："

#: ../../library/subprocess.rst:1014
msgid "**handle_list**"
msgstr "**handle_list**"

#: ../../library/subprocess.rst:1015
msgid ""
"Sequence of handles that will be inherited. *close_fds* must be true if non-"
"empty."
msgstr "将被继承的句柄的序列。如果非空， *close_fds* 必须为 true。"

#: ../../library/subprocess.rst:1018
msgid ""
"The handles must be temporarily made inheritable by "
":func:`os.set_handle_inheritable` when passed to the :class:`Popen` "
"constructor, else :class:`OSError` will be raised with Windows error "
"``ERROR_INVALID_PARAMETER`` (87)."
msgstr ""
"当传递给 :class:`Popen` 构造函数时，这些句柄必须暂时地能被 :func:`os.set_handle_inheritable` "
"继承，否则 :class:`OSError` 将以 Windows error ``ERROR_INVALID_PARAMETER`` (87) 抛出。"

#: ../../library/subprocess.rst:1025
msgid ""
"In a multithreaded process, use caution to avoid leaking handles that are "
"marked inheritable when combining this feature with concurrent calls to "
"other process creation functions that inherit all handles such as "
":func:`os.system`.  This also applies to standard handle redirection, which "
"temporarily creates inheritable handles."
msgstr ""
"在多线程进程中，请谨慎使用，以便在将此功能与对继承所有句柄的其他进程创建函数——例如 :func:`os.system` "
"的并发调用——相结合时，避免泄漏标记为可继承的句柄。这也应用于临时性创建可继承句柄的标准句柄重定向。"

#: ../../library/subprocess.rst:1035
msgid "Windows Constants"
msgstr "Windows 常数"

#: ../../library/subprocess.rst:1037
msgid "The :mod:`subprocess` module exposes the following constants."
msgstr ":mod:`subprocess` 模块曝出以下常数。"

#: ../../library/subprocess.rst:1041
msgid ""
"The standard input device. Initially, this is the console input buffer, "
"``CONIN$``."
msgstr "标准输入设备，这是控制台输入缓冲区 ``CONIN$``。"

#: ../../library/subprocess.rst:1046
msgid ""
"The standard output device. Initially, this is the active console screen "
"buffer, ``CONOUT$``."
msgstr "标准输出设备。最初，这是活动控制台屏幕缓冲区 ``CONOUT$``。"

#: ../../library/subprocess.rst:1051
msgid ""
"The standard error device. Initially, this is the active console screen "
"buffer, ``CONOUT$``."
msgstr "标准错误设备。最初，这是活动控制台屏幕缓冲区 ``CONOUT$``。"

#: ../../library/subprocess.rst:1056
msgid "Hides the window. Another window will be activated."
msgstr "隐藏窗口。另一个窗口将被激活。"

#: ../../library/subprocess.rst:1060
msgid ""
"Specifies that the :attr:`STARTUPINFO.hStdInput`, "
":attr:`STARTUPINFO.hStdOutput`, and :attr:`STARTUPINFO.hStdError` attributes"
" contain additional information."
msgstr ""
"指明 :attr:`STARTUPINFO.hStdInput`, :attr:`STARTUPINFO.hStdOutput` 和 "
":attr:`STARTUPINFO.hStdError` 属性包含额外的信息。"

#: ../../library/subprocess.rst:1066
msgid ""
"Specifies that the :attr:`STARTUPINFO.wShowWindow` attribute contains "
"additional information."
msgstr "指明 :attr:`STARTUPINFO.wShowWindow` 属性包含额外的信息。"

#: ../../library/subprocess.rst:1071
msgid ""
"A :attr:`STARTUPINFO.dwFlags` parameter to specify that the *Working in "
"Background* mouse cursor will be displayed while a process is launching. "
"This is the default behavior for GUI processes."
msgstr ""
":attr:`STARTUPINFO.dwFlags` 形参指明在进程启动时将显示一个 *正在后台操作* 鼠标提示。 这是 GUI 进程的默认行为。"

#: ../../library/subprocess.rst:1080
msgid ""
"A :attr:`STARTUPINFO.dwFlags` parameter to specify that the mouse cursor "
"will not be changed when launching a process."
msgstr "A :attr:`STARTUPINFO.dwFlags` 形参指明在启动进程时鼠标提示将不会改变。"

#: ../../library/subprocess.rst:1087
msgid ""
"The new process has a new console, instead of inheriting its parent's "
"console (the default)."
msgstr "新的进程将有新的控制台，而不是继承父进程的（默认）控制台。"

#: ../../library/subprocess.rst:1092
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"group will be created. This flag is necessary for using :func:`os.kill` on "
"the subprocess."
msgstr ""
"用于指明将创建一个新的进程组的 :class:`Popen` ``creationflags`` 形参。 这个旗标对于在子进程上使用 "
":func:`os.kill` 来说是必须的。"

#: ../../library/subprocess.rst:1096
msgid "This flag is ignored if :data:`CREATE_NEW_CONSOLE` is specified."
msgstr "如果指定了 :data:`CREATE_NEW_CONSOLE` 则这个旗标会被忽略。"

#: ../../library/subprocess.rst:1100
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have an above average priority."
msgstr "用于指明一个新进程将具有高于平均的优先级的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1107
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have a below average priority."
msgstr "用于指明一个新进程将具有低于平均的优先级的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1114
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have a high priority."
msgstr "用于指明一个新进程将具有高优先级的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1121
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have an idle (lowest) priority."
msgstr "用于指明一个新进程将具有空闲（最低）优先级的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1128
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have a normal priority. (default)"
msgstr "用于指明一个新进程将具有正常（默认）优先级的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1135
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will have realtime priority. You should almost never use "
"REALTIME_PRIORITY_CLASS, because this interrupts system threads that manage "
"mouse input, keyboard input, and background disk flushing. This class can be"
" appropriate for applications that \"talk\" directly to hardware or that "
"perform brief tasks that should have limited interruptions."
msgstr ""
"用于指明一个新进程将具有实时优先级的 :class:`Popen` ``creationflags`` 形参。 你应当几乎永远不使用 "
"REALTIME_PRIORITY_CLASS，因为这会中断管理鼠标输入、键盘输入以及后台磁盘刷新的系统线程。 "
"这个类只适用于直接与硬件“对话”，或者执行短暂任务具有受限中断的应用。"

#: ../../library/subprocess.rst:1146
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will not create a window."
msgstr "指明一个新进程将不会创建窗口的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1153
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"will not inherit its parent's console. This value cannot be used with "
"CREATE_NEW_CONSOLE."
msgstr ""
"指明一个新进程将不会继承其父控制台的 :class:`Popen` ``creationflags`` 形参。 这个值不能与 "
"CREATE_NEW_CONSOLE 一同使用。"

#: ../../library/subprocess.rst:1161
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"does not inherit the error mode of the calling process. Instead, the new "
"process gets the default error mode. This feature is particularly useful for"
" multithreaded shell applications that run with hard errors disabled."
msgstr ""
"指明一个新进程不会继承调用方进程的错误模式的 :class:`Popen` ``creationflags`` 形参。 新进程会转为采用默认的错误模式。"
" 这个特性特别适用于运行时禁用硬错误的多线程 shell 应用。"

#: ../../library/subprocess.rst:1171
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new process "
"is not associated with the job."
msgstr "指明一个新进程不会关联到任务的 :class:`Popen` ``creationflags`` 形参。"

#: ../../library/subprocess.rst:1179
msgid "Older high-level API"
msgstr "较旧的高阶 API"

#: ../../library/subprocess.rst:1181
msgid ""
"Prior to Python 3.5, these three functions comprised the high level API to "
"subprocess. You can now use :func:`run` in many cases, but lots of existing "
"code calls these functions."
msgstr ""
"在 Python 3.5 之前，这三个函数组成了 subprocess 的高阶 API。 现在你可以在许多情况下使用 "
":func:`run`，但有大量现在代码仍会调用这些函数。"

#: ../../library/subprocess.rst:1188
msgid ""
"Run the command described by *args*.  Wait for command to complete, then "
"return the :attr:`~Popen.returncode` attribute."
msgstr "运行由 *args* 所描述的命令。 等待命令完成，然后返回 :attr:`~Popen.returncode` 属性。"

#: ../../library/subprocess.rst:1191 ../../library/subprocess.rst:1231
msgid ""
"Code needing to capture stdout or stderr should use :func:`run` instead::"
msgstr "需要捕获 stdout 或 stderr 的代码应当改用 :func:`run`::"

#: ../../library/subprocess.rst:1193
msgid "run(...).returncode"
msgstr "run(...).returncode"

#: ../../library/subprocess.rst:1195 ../../library/subprocess.rst:1235
msgid "To suppress stdout or stderr, supply a value of :data:`DEVNULL`."
msgstr "要屏蔽 stdout 或 stderr，可提供 :data:`DEVNULL` 这个值。"

#: ../../library/subprocess.rst:1197 ../../library/subprocess.rst:1237
msgid ""
"The arguments shown above are merely some common ones. The full function "
"signature is the same as that of the :class:`Popen` constructor - this "
"function passes all supplied arguments other than *timeout* directly through"
" to that interface."
msgstr ""
"上面显示的参数只是常见的一些。 完整的函数签名与 :class:`Popen` 构造器的相同 —— 此函数会将所提供的 *timeout* "
"之外的全部参数直接传递给目标接口。"

#: ../../library/subprocess.rst:1204 ../../library/subprocess.rst:1244
msgid ""
"Do not use ``stdout=PIPE`` or ``stderr=PIPE`` with this function.  The child"
" process will block if it generates enough output to a pipe to fill up the "
"OS pipe buffer as the pipes are not being read from."
msgstr ""
"请不要在此函数中使用 ``stdout=PIPE`` 或 ``stderr=PIPE``。 如果子进程向管道生成了足以填满 OS "
"管理缓冲区的输出而管道还未被读取时它将会阻塞。"

#: ../../library/subprocess.rst:1224
msgid ""
"Run command with arguments.  Wait for command to complete. If the return "
"code was zero then return, otherwise raise :exc:`CalledProcessError`. The "
":exc:`CalledProcessError` object will have the return code in the "
":attr:`~CalledProcessError.returncode` attribute. If :func:`check_call` was "
"unable to start the process it will propagate the exception that was raised."
msgstr ""
"附带参数运行命令。 等待命令完成。 如果返回码为零则正常返回，否则引发 :exc:`CalledProcessError`。 "
":exc:`CalledProcessError` 对象将在 :attr:`~CalledProcessError.returncode` "
"属性中保存返回码。 如果 :func:`check_call` 无法开始进程则它将传播已被引发的异常。"

#: ../../library/subprocess.rst:1233
msgid "run(..., check=True)"
msgstr "run(..., check=True)"

#: ../../library/subprocess.rst:1266
msgid "Run command with arguments and return its output."
msgstr "附带参数运行命令并返回其输出。"

#: ../../library/subprocess.rst:1268
msgid ""
"If the return code was non-zero it raises a :exc:`CalledProcessError`. The "
":exc:`CalledProcessError` object will have the return code in the "
":attr:`~CalledProcessError.returncode` attribute and any output in the "
":attr:`~CalledProcessError.output` attribute."
msgstr ""
"如果返回码非零则会引发 :exc:`CalledProcessError`。 :exc:`CalledProcessError` 对象将在 "
":attr:`~CalledProcessError.returncode` 属性中保存返回码并在 "
":attr:`~CalledProcessError.output` 属性中保存所有输出。"

#: ../../library/subprocess.rst:1273
msgid "This is equivalent to::"
msgstr "这相当于："

#: ../../library/subprocess.rst:1275
msgid "run(..., check=True, stdout=PIPE).stdout"
msgstr "run(..., check=True, stdout=PIPE).stdout"

#: ../../library/subprocess.rst:1277
msgid ""
"The arguments shown above are merely some common ones. The full function "
"signature is largely the same as that of :func:`run` - most arguments are "
"passed directly through to that interface. One API deviation from "
":func:`run` behavior exists: passing ``input=None`` will behave the same as "
"``input=b''`` (or ``input=''``, depending on other arguments) rather than "
"using the parent's standard input file handle."
msgstr ""
"上面显示的参数只是常见的一些。 完整的函数签名与 :func:`run` 的大致相同 —— 大部分参数会通过该接口直接传递。 存在一个与 "
":func:`run` 行为不同的 API 差异：传递 ``input=None`` 的行为将与 ``input=b''`` (或 "
"``input=''``，具体取决于其他参数) 一样而不是使用父对象的标准输入文件处理。"

#: ../../library/subprocess.rst:1284
msgid ""
"By default, this function will return the data as encoded bytes. The actual "
"encoding of the output data may depend on the command being invoked, so the "
"decoding to text will often need to be handled at the application level."
msgstr ""
"默认情况下，此函数将把数据返回为已编码的字节串。 输出数据的实际编码格式将取决于唤起的命令，因此解码为文本的操作往往需要在应用程序层级上进行处理。"

#: ../../library/subprocess.rst:1288
msgid ""
"This behaviour may be overridden by setting *text*, *encoding*, *errors*, or"
" *universal_newlines* to ``True`` as described in :ref:`frequently-used-"
"arguments` and :func:`run`."
msgstr ""
"此行为可以通过设置 *text*, *encoding*, *errors* 或将 *universal_newlines* 设为 ``True`` "
"来重载，具体描述见 :ref:`frequently-used-arguments` 和 :func:`run`。"

#: ../../library/subprocess.rst:1292
msgid ""
"To also capture standard error in the result, use "
"``stderr=subprocess.STDOUT``::"
msgstr "要在结果中同时捕获标准错误，请使用 ``stderr=subprocess.STDOUT``::"

#: ../../library/subprocess.rst:1295
msgid ""
">>> subprocess.check_output(\n"
"...     \"ls non_existent_file; exit 0\",\n"
"...     stderr=subprocess.STDOUT,\n"
"...     shell=True)\n"
"'ls: non_existent_file: No such file or directory\\n'"
msgstr ""
">>> subprocess.check_output(\n"
"...     \"ls non_existent_file; exit 0\",\n"
"...     stderr=subprocess.STDOUT,\n"
"...     shell=True)\n"
"'ls: non_existent_file: No such file or directory\\n'"

#: ../../library/subprocess.rst:1306
msgid "Support for the *input* keyword argument was added."
msgstr "增加了对 *input* 关键字参数的支持。"

#: ../../library/subprocess.rst:1309
msgid "*encoding* and *errors* were added.  See :func:`run` for details."
msgstr "增加了 *encoding* 和 *errors*。 详情参见 :func:`run`。"

#: ../../library/subprocess.rst:1327
msgid "Replacing Older Functions with the :mod:`subprocess` Module"
msgstr "使用 :mod:`subprocess` 模块替换旧函数"

#: ../../library/subprocess.rst:1329
msgid ""
"In this section, \"a becomes b\" means that b can be used as a replacement "
"for a."
msgstr "在这一节中，\"a 改为 b\" 意味着 b 可以被用作 a 的替代。"

#: ../../library/subprocess.rst:1333
msgid ""
"All \"a\" functions in this section fail (more or less) silently if the "
"executed program cannot be found; the \"b\" replacements raise "
":exc:`OSError` instead."
msgstr "在这一节中的所有 \"a\" 函数会在找不到被执行的程序时（差不多）静默地失败；\"b\" 替代函数则会改为引发 :exc:`OSError`。"

#: ../../library/subprocess.rst:1337
msgid ""
"In addition, the replacements using :func:`check_output` will fail with a "
":exc:`CalledProcessError` if the requested operation produces a non-zero "
"return code. The output is still available as the "
":attr:`~CalledProcessError.output` attribute of the raised exception."
msgstr ""
"此外，在使用 :func:`check_output` 时如果替代函数所请求的操作产生了非零返回值则将失败并引发 "
":exc:`CalledProcessError`。 操作的输出仍能以所引发异常的 :attr:`~CalledProcessError.output`"
" 属性的方式被访问。"

#: ../../library/subprocess.rst:1342
msgid ""
"In the following examples, we assume that the relevant functions have "
"already been imported from the :mod:`subprocess` module."
msgstr "在下列例子中，我们假定相关的函数都已从 :mod:`subprocess` 模块中导入了。"

#: ../../library/subprocess.rst:1347
msgid "Replacing :program:`/bin/sh` shell command substitution"
msgstr "替代 :program:`/bin/sh` shell 命令替换"

#: ../../library/subprocess.rst:1349
msgid "output=$(mycmd myarg)"
msgstr "output=$(mycmd myarg)"

#: ../../library/subprocess.rst:1353 ../../library/subprocess.rst:1364
#: ../../library/subprocess.rst:1381
msgid "becomes::"
msgstr "改为::"

#: ../../library/subprocess.rst:1355
msgid "output = check_output([\"mycmd\", \"myarg\"])"
msgstr "output = check_output([\"mycmd\", \"myarg\"])"

#: ../../library/subprocess.rst:1358
msgid "Replacing shell pipeline"
msgstr "替代 shell 管道"

#: ../../library/subprocess.rst:1360 ../../library/subprocess.rst:1377
msgid "output=$(dmesg | grep hda)"
msgstr "output=$(dmesg | grep hda)"

#: ../../library/subprocess.rst:1366
msgid ""
"p1 = Popen([\"dmesg\"], stdout=PIPE)\n"
"p2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\n"
"p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.\n"
"output = p2.communicate()[0]"
msgstr ""
"p1 = Popen([\"dmesg\"], stdout=PIPE)\n"
"p2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\n"
"p1.stdout.close()  # 允许 p1 在 p2 退出时接收 SIGPIPE。\n"
"output = p2.communicate()[0]"

#: ../../library/subprocess.rst:1371
msgid ""
"The ``p1.stdout.close()`` call after starting the p2 is important in order "
"for p1 to receive a SIGPIPE if p2 exits before p1."
msgstr ""
"启动 p2 之后再执行 ``p1.stdout.close()`` 调用很重要，这是为了让 p1 能在 p2 先于 p1 退出时接收到 SIGPIPE。"

#: ../../library/subprocess.rst:1374
msgid ""
"Alternatively, for trusted input, the shell's own pipeline support may still"
" be used directly:"
msgstr "另外，对于受信任的输入，shell 本身的管道支持仍然可被直接使用:"

#: ../../library/subprocess.rst:1383
msgid "output = check_output(\"dmesg | grep hda\", shell=True)"
msgstr "output = check_output(\"dmesg | grep hda\", shell=True)"

#: ../../library/subprocess.rst:1387
msgid "Replacing :func:`os.system`"
msgstr "替代 :func:`os.system`"

#: ../../library/subprocess.rst:1391
msgid ""
"sts = os.system(\"mycmd\" + \" myarg\")\n"
"# becomes\n"
"retcode = call(\"mycmd\" + \" myarg\", shell=True)"
msgstr ""
"sts = os.system(\"mycmd\" + \" myarg\")\n"
"# 变为\n"
"retcode = call(\"mycmd\" + \" myarg\", shell=True)"

#: ../../library/subprocess.rst:1395
msgid "Notes:"
msgstr "注释："

#: ../../library/subprocess.rst:1397
msgid "Calling the program through the shell is usually not required."
msgstr "通过 shell 来调用程序通常是不必要的。"

#: ../../library/subprocess.rst:1398
msgid ""
"The :func:`call` return value is encoded differently to that of "
":func:`os.system`."
msgstr ":func:`call` 返回值的编码方式与 :func:`os.system` 的不同。"

#: ../../library/subprocess.rst:1401
msgid ""
"The :func:`os.system` function ignores SIGINT and SIGQUIT signals while the "
"command is running, but the caller must do this separately when using the "
":mod:`subprocess` module."
msgstr ""
":func:`os.system` 函数在命令运行期间会忽略 SIGINT 和 SIGQUIT 信号，但调用方必须在使用 "
":mod:`subprocess` 模块时分别执行此操作。"

#: ../../library/subprocess.rst:1405
msgid "A more realistic example would look like this::"
msgstr "一个更现实的例子如下所示::"

#: ../../library/subprocess.rst:1407
msgid ""
"try:\n"
"    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n"
"    if retcode < 0:\n"
"        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n"
"    else:\n"
"        print(\"Child returned\", retcode, file=sys.stderr)\n"
"except OSError as e:\n"
"    print(\"Execution failed:\", e, file=sys.stderr)"
msgstr ""
"try:\n"
"    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n"
"    if retcode < 0:\n"
"        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n"
"    else:\n"
"        print(\"Child returned\", retcode, file=sys.stderr)\n"
"except OSError as e:\n"
"    print(\"Execution failed:\", e, file=sys.stderr)"

#: ../../library/subprocess.rst:1418
msgid "Replacing the :func:`os.spawn <os.spawnl>` family"
msgstr "替代 :func:`os.spawn <os.spawnl>` 函数族"

#: ../../library/subprocess.rst:1420
msgid "P_NOWAIT example::"
msgstr "P_NOWAIT 示例::"

#: ../../library/subprocess.rst:1422
msgid ""
"pid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"pid = Popen([\"/bin/mycmd\", \"myarg\"]).pid"
msgstr ""
"pid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"pid = Popen([\"/bin/mycmd\", \"myarg\"]).pid"

#: ../../library/subprocess.rst:1426
msgid "P_WAIT example::"
msgstr "P_WAIT 示例::"

#: ../../library/subprocess.rst:1428
msgid ""
"retcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"retcode = call([\"/bin/mycmd\", \"myarg\"])"
msgstr ""
"retcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"retcode = call([\"/bin/mycmd\", \"myarg\"])"

#: ../../library/subprocess.rst:1432
msgid "Vector example::"
msgstr "Vector 示例::"

#: ../../library/subprocess.rst:1434
msgid ""
"os.spawnvp(os.P_NOWAIT, path, args)\n"
"==>\n"
"Popen([path] + args[1:])"
msgstr ""
"os.spawnvp(os.P_NOWAIT, path, args)\n"
"==>\n"
"Popen([path] + args[1:])"

#: ../../library/subprocess.rst:1438
msgid "Environment example::"
msgstr "Environment 示例::"

#: ../../library/subprocess.rst:1440
msgid ""
"os.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n"
"==>\n"
"Popen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})"
msgstr ""
"os.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n"
"==>\n"
"Popen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})"

#: ../../library/subprocess.rst:1447
msgid "Replacing :func:`os.popen`"
msgstr "替代 :func:`os.popen`"

#: ../../library/subprocess.rst:1449
msgid "Return code handling translates as follows::"
msgstr "返回码以如下方式处理转写::"

#: ../../library/subprocess.rst:1451
msgid ""
"pipe = os.popen(cmd, 'w')\n"
"...\n"
"rc = pipe.close()\n"
"if rc is not None and rc >> 8:\n"
"    print(\"There were some errors\")\n"
"==>\n"
"process = Popen(cmd, stdin=PIPE)\n"
"...\n"
"process.stdin.close()\n"
"if process.wait() != 0:\n"
"    print(\"There were some errors\")"
msgstr ""
"pipe = os.popen(cmd, 'w')\n"
"...\n"
"rc = pipe.close()\n"
"if rc is not None and rc >> 8:\n"
"    print(\"There were some errors\")\n"
"==>\n"
"process = Popen(cmd, stdin=PIPE)\n"
"...\n"
"process.stdin.close()\n"
"if process.wait() != 0:\n"
"    print(\"There were some errors\")"

#: ../../library/subprocess.rst:1465
msgid "Legacy Shell Invocation Functions"
msgstr "旧式的 Shell 发起函数"

#: ../../library/subprocess.rst:1467
msgid ""
"This module also provides the following legacy functions from the 2.x "
"``commands`` module. These operations implicitly invoke the system shell and"
" none of the guarantees described above regarding security and exception "
"handling consistency are valid for these functions."
msgstr ""
"此模块还提供了以下来自 2.x ``commands`` 模块的旧版函数。 这些操作会隐式地唤起系统 shell "
"并且上文所描述的有关安全与异常处理一致性保证都不适用于这些函数。"

#: ../../library/subprocess.rst:1474
msgid "Return ``(exitcode, output)`` of executing *cmd* in a shell."
msgstr "返回在 shell 中执行 *cmd* 产生的 ``(exitcode, output)``。"

#: ../../library/subprocess.rst:1476
msgid ""
"Execute the string *cmd* in a shell with :meth:`Popen.check_output` and "
"return a 2-tuple ``(exitcode, output)``. *encoding* and *errors* are used to"
" decode output; see the notes on :ref:`frequently-used-arguments` for more "
"details."
msgstr ""
"在 shell 中使用 :meth:`Popen.check_output` 来执行字符串 *cmd* 并返回一个 2 元组 ``(exitcode, "
"output)``。 将使用 *encoding* 和 *errors* 来对输出进行解码；请参阅 :ref:`frequently-used-"
"arguments` 中的说明来了解更多细节。"

#: ../../library/subprocess.rst:1481
msgid ""
"A trailing newline is stripped from the output. The exit code for the "
"command can be interpreted as the return code of subprocess.  Example::"
msgstr "末尾的一个换行符会从输出中被去除。 命令的退出码可被解读为子进程的返回码。 例如::"

#: ../../library/subprocess.rst:1485
msgid ""
">>> subprocess.getstatusoutput('ls /bin/ls')\n"
"(0, '/bin/ls')\n"
">>> subprocess.getstatusoutput('cat /bin/junk')\n"
"(1, 'cat: /bin/junk: No such file or directory')\n"
">>> subprocess.getstatusoutput('/bin/junk')\n"
"(127, 'sh: /bin/junk: not found')\n"
">>> subprocess.getstatusoutput('/bin/kill $$')\n"
"(-15, '')"
msgstr ""
">>> subprocess.getstatusoutput('ls /bin/ls')\n"
"(0, '/bin/ls')\n"
">>> subprocess.getstatusoutput('cat /bin/junk')\n"
"(1, 'cat: /bin/junk: No such file or directory')\n"
">>> subprocess.getstatusoutput('/bin/junk')\n"
"(127, 'sh: /bin/junk: not found')\n"
">>> subprocess.getstatusoutput('/bin/kill $$')\n"
"(-15, '')"

#: ../../library/subprocess.rst:1496
msgid "Windows support was added."
msgstr "添加了 Windows 支持。"

#: ../../library/subprocess.rst:1499
msgid ""
"The function now returns (exitcode, output) instead of (status, output) as "
"it did in Python 3.3.3 and earlier.  exitcode has the same value as "
":attr:`~Popen.returncode`."
msgstr ""
"此函数现在返回 (exitcode, output) 而不是像 Python 3.3.3 及更早的版本那样返回 (status, output)。 "
"exitcode 的值与 :attr:`~Popen.returncode` 相同。"

#: ../../library/subprocess.rst:1508
msgid "Return output (stdout and stderr) of executing *cmd* in a shell."
msgstr "返回在 shell 中执行 *cmd* 产生的输出（stdout 和 stderr）。"

#: ../../library/subprocess.rst:1510
msgid ""
"Like :func:`getstatusoutput`, except the exit code is ignored and the return"
" value is a string containing the command's output.  Example::"
msgstr "类似于 :func:`getstatusoutput`，但退出码会被忽略并且返回值为包含命令输出的字符串。 例如::"

#: ../../library/subprocess.rst:1513
msgid ""
">>> subprocess.getoutput('ls /bin/ls')\n"
"'/bin/ls'"
msgstr ""
">>> subprocess.getoutput('ls /bin/ls')\n"
"'/bin/ls'"

#: ../../library/subprocess.rst:1518
msgid "Windows support added"
msgstr "添加了 Windows 支持"

#: ../../library/subprocess.rst:1526
msgid "Notes"
msgstr "备注"

#: ../../library/subprocess.rst:1531
msgid "Timeout Behavior"
msgstr "超时行为"

#: ../../library/subprocess.rst:1533
msgid ""
"When using the ``timeout`` parameter in functions like :func:`run`, "
":meth:`Popen.wait`, or :meth:`Popen.communicate`, users should be aware of "
"the following behaviors:"
msgstr ""
"当在 :func:`run`、:meth:`Popen.wait` 或 :meth:`Popen.communicate` 等函数中使用 "
"``timeout`` 形参时，用户应该注意以下行为："

#: ../../library/subprocess.rst:1537
msgid ""
"**Process Creation Delay**: The initial process creation itself cannot be "
"interrupted on many platform APIs. This means that even when specifying a "
"timeout, you are not guaranteed to see a timeout exception until at least "
"after however long process creation takes."
msgstr ""
"**进程创建延迟**：在许多平台API上，初始进程创建本身不能被中断。这意味着，即使指定了超时，也不能保证在创建进程之前看到超时异常，无论创建进程花了多长时间。"

#: ../../library/subprocess.rst:1542
msgid ""
"**Extremely Small Timeout Values**: Setting very small timeout values (such "
"as a few milliseconds) may result in almost immediate :exc:`TimeoutExpired` "
"exceptions because process creation and system scheduling inherently require"
" time."
msgstr ""
"**非常小的超时值**: 设置非常小的超时值（比如几毫秒）可能会导致几乎立即出现 :exc:`TimeoutExpired` "
"异常，因为进程创建和系统调度本身就需要时间。"

#: ../../library/subprocess.rst:1549
msgid "Converting an argument sequence to a string on Windows"
msgstr "在 Windows 上将参数列表转换为一个字符串"

#: ../../library/subprocess.rst:1551
msgid ""
"On Windows, an *args* sequence is converted to a string that can be parsed "
"using the following rules (which correspond to the rules used by the MS C "
"runtime):"
msgstr "在 Windows 上，*args* 序列会被转换为可使用以下规则来解析的字符串（对应于 MS C 运行时所使用的规则）:"

#: ../../library/subprocess.rst:1555
msgid ""
"Arguments are delimited by white space, which is either a space or a tab."
msgstr "参数以空白符分隔，即空格符或制表符。"

#: ../../library/subprocess.rst:1558
msgid ""
"A string surrounded by double quotation marks is interpreted as a single "
"argument, regardless of white space contained within.  A quoted string can "
"be embedded in an argument."
msgstr "用双引号标示的字符串会被解读为单个参数，而不再考虑其中的空白符。 一个参数可以嵌套用引号标示的字符串。"

#: ../../library/subprocess.rst:1563
msgid ""
"A double quotation mark preceded by a backslash is interpreted as a literal "
"double quotation mark."
msgstr "带有一个反斜杠前缀的双引号会被解读为双引号字面值。"

#: ../../library/subprocess.rst:1566
msgid ""
"Backslashes are interpreted literally, unless they immediately precede a "
"double quotation mark."
msgstr "反斜杠会按字面值解读，除非它是作为双引号的前缀。"

#: ../../library/subprocess.rst:1569
msgid ""
"If backslashes immediately precede a double quotation mark, every pair of "
"backslashes is interpreted as a literal backslash.  If the number of "
"backslashes is odd, the last backslash escapes the next double quotation "
"mark as described in rule 3."
msgstr ""
"如果反斜杠被作为双引号的前缀，则每个反斜杠对会被解读为一个反斜杠字面值。 如果反斜杠数量为奇数，则最后一个反斜杠会如规则 3 "
"所描述的那样转义下一个双引号。"

#: ../../library/subprocess.rst:1578
msgid ":mod:`shlex`"
msgstr ":mod:`shlex`"

#: ../../library/subprocess.rst:1579
msgid "Module which provides function to parse and escape command lines."
msgstr "此模块提供了用于解析和转义命令行的函数。"

#: ../../library/subprocess.rst:1585
msgid "Disable use of ``posix_spawn()``"
msgstr "禁用``posix_spawn()``"

#: ../../library/subprocess.rst:1587
msgid ""
"On Linux, :mod:`subprocess` defaults to using the ``vfork()`` system call "
"internally when it is safe to do so rather than ``fork()``. This greatly "
"improves performance."
msgstr ""
"在 Linux 上，:mod:`subprocess` 默认会在内部使用 ``vfork()`` 系统调用而不是 "
"``fork()``，只要这样做是安全的。 这极大地提升了性能。"

#: ../../library/subprocess.rst:1593
msgid "subprocess._USE_POSIX_SPAWN = False  # See CPython issue gh-NNNNNN."
msgstr "subprocess._USE_POSIX_SPAWN = False  # 参见 CPython 程序问题 gh-NNNNNN。"

#: ../../library/subprocess.rst:1595
msgid ""
"It is safe to set this to false on any Python version. It will have no "
"effect on older or newer versions where unsupported. Do not assume the "
"attribute is available to read. Despite the name, a true value does not "
"indicate the corresponding function will be used, only that it may be."
msgstr ""
"在任何Python版本上将其设置为false都是安全的。它对不受支持的旧版本或新版本没有影响。不要假设该属性可以读取。除了名称之外，true值并不表示将使用相应的函数，只是表示可能会使用。"

#: ../../library/subprocess.rst:1600
msgid ""
"Please file issues any time you have to use these private knobs with a way "
"to reproduce the issue you were seeing. Link to that issue from a comment in"
" your code."
msgstr "当你不得不使用这些私有属性并遇到问题时请随时提交问题并附带你所看到的问题的重现方式。 请从你代码中的某条注释链接到该问题。"

#: ../../library/subprocess.rst:1604
msgid "``_USE_POSIX_SPAWN``"
msgstr "``_USE_POSIX_SPAWN``"

#: ../../library/subprocess.rst:296
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/subprocess.rst:296
msgid "subprocess module"
msgstr "subprocess 模块"
