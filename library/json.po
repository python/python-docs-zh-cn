# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# sgqy <sgqyzh@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# eric R <trencyclopedia@gmail.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# Xu Siyuan, 2021
# Jiu Hong Jiang <julse@qq.com>, 2021
# Naisen Xu <723648649@qq.com>, 2021
# Wulian233 <xiguawulian@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Kevin Deng <kevindeng55+transifex@gmail.com>, 2025
# Makdon <makdon@makdon.me>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/json.rst:2
msgid ":mod:`!json` --- JSON encoder and decoder"
msgstr ":mod:`!json` --- JSON 编码器和解码器"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**源代码:** :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by "
":rfc:`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript "
"<https://en.wikipedia.org/wiki/JavaScript>`_ object literal syntax (although"
" it is not a strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (JavaScript Object Notation) <https://json.org>`_，由 :rfc:`7159` (它取代了 "
":rfc:`4627`) 和 `ECMA-404 <https://ecma-international.org/publications-and-"
"standards/standards/ecma-404/>`_ 进行规范，是一个受到 `JavaScript "
"<https://en.wikipedia.org/wiki/JavaScript>`_ 对象字面值语法启发的轻量级数据交换格式 "
"(虽然它并不是严格意义上的 JavaScript 子集 [#rfc-errata]_ )。"

#: ../../library/json.rst:22
msgid ""
"The term \"object\" in the context of JSON processing in Python can be "
"ambiguous. All values in Python are objects. In JSON, an object refers to "
"any data wrapped in curly braces, similar to a Python dictionary."
msgstr ""
" 术语“对象”在 Python 语言 JSON 处理的上下文中存在歧义。 Python 中的所有值都是对象。 在 JSON "
"中，对象则是指包裹在花括号里的任何数据，这类似于 Python 字典。"

#: ../../library/json.rst:27
msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"在解析来自不受信任恶劣的 JSON 数据时要小心谨慎。 恶意的 JSON 字符串可能导致解码器消耗大量 CPU 和内存资源。 "
"建议对要解析的数据大小进行限制。"

#: ../../library/json.rst:31
msgid ""
"This module exposes an API familiar to users of the standard library "
":mod:`marshal` and :mod:`pickle` modules."
msgstr "本模块提供了会让标准库 :mod:`marshal` 和 :mod:`pickle` 模块的用户感到熟悉的 API。"

#: ../../library/json.rst:34
msgid "Encoding basic Python object hierarchies::"
msgstr "对基本的 Python 对象层次结构进行编码："

#: ../../library/json.rst:36
msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"

#: ../../library/json.rst:53
msgid "Compact encoding::"
msgstr "紧凑编码："

#: ../../library/json.rst:55
msgid ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"

#: ../../library/json.rst:59
msgid "Pretty printing::"
msgstr "美化输出："

#: ../../library/json.rst:61
msgid ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"

#: ../../library/json.rst:68
msgid "Customizing JSON object encoding::"
msgstr "定制 JSON 对象编码操作::"

#: ../../library/json.rst:70
msgid ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj.imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"
msgstr ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj.imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"

#: ../../library/json.rst:79
msgid "Decoding JSON::"
msgstr "JSON解码："

#: ../../library/json.rst:81
msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"

#: ../../library/json.rst:91
msgid "Customizing JSON object decoding::"
msgstr "定制 JSON 对象解码操作::"

#: ../../library/json.rst:93
msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"

#: ../../library/json.rst:106
msgid "Extending :class:`JSONEncoder`::"
msgstr "扩展 :class:`JSONEncoder`："

#: ../../library/json.rst:108
msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"

#: ../../library/json.rst:124
msgid "Using :mod:`json` from the shell to validate and pretty-print:"
msgstr "在 shell 中使用 :mod:`json` 来验证并美化输出："

#: ../../library/json.rst:126
msgid ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:135
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "详细文档请参见 :ref:`json-commandline`。"

#: ../../library/json.rst:139
msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON 是 `YAML <https://yaml.org/>`_ 1.2 的一个子集。 由该模块的默认设置所产生的 JSON（尤其是默认的 "
"*separators* 值）也是 YAML 1.0 和 1.1 的一个子集。 因此该模块也能被用作 YAML 序列化器。"

#: ../../library/json.rst:146
msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr "这个模块的编码器和解码器默认保护输入和输出的顺序。仅当底层的容器未排序时才会失去顺序。"

#: ../../library/json.rst:151
msgid "Basic Usage"
msgstr "基本使用"

#: ../../library/json.rst:158
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a "
"``.write()``-supporting :term:`file-like object`) using this :ref:`Python-"
"to-JSON conversion table <py-to-json-table>`."
msgstr ""
"使用这个 :ref:`Python 至 JSON 转换表 <py-to-json-table>` 将 *obj* 序列化为输出到 *fp* (一个支持 "
"``.write()`` 的 :term:`file-like object`) 的已格式化的 JSON 流。"

#: ../../library/json.rst:164
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"与 :mod:`pickle` 和 :mod:`marshal` 不同，JSON 不是一个具有框架的协议，所以尝试多次使用同一个 *fp* 调用 "
":func:`dump` 来序列化多个对象会产生一个不合规的 JSON 文件。"

#: ../../library/json.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/json.rst:168
msgid "The Python object to be serialized."
msgstr "要序列化的 Python 对象。"

#: ../../library/json.rst:171
msgid ""
"The file-like object *obj* will be serialized to. The :mod:`!json` module "
"always produces :class:`str` objects, not :class:`bytes` objects, therefore "
"``fp.write()`` must support :class:`str` input."
msgstr ""
"文件型对象 *obj* 将为序列化输出的目标。 :mod:`!json` 模块总是产生 :class:`str` 对象，而不是 "
":class:`bytes` 对象，因此 ``fp.write()`` 必须支持 :class:`str` 输入。"

#: ../../library/json.rst:178
msgid ""
"If ``True``, keys that are not of a basic type (:class:`str`, :class:`int`, "
":class:`float`, :class:`bool`, ``None``) will be skipped instead of raising "
"a :exc:`TypeError`. Default ``False``."
msgstr ""
"如为 ``True``，则不为基本类型 (:class:`str`, :class:`int`, :class:`float`, "
":class:`bool`, ``None``) 的键将被跳过而不会引发 :exc:`TypeError`。 默认为 ``False``。"

#: ../../library/json.rst:184
msgid ""
"If ``True`` (the default), the output is guaranteed to have all incoming "
"non-ASCII characters escaped. If ``False``, these characters will be "
"outputted as-is."
msgstr ""
"如为 ``True`` (默认值)，则输出将保证对所有输入的非 ASCII 字符进行转义。 如为 ``False``，这些字符将被原样输出。"

#: ../../library/json.rst:189
msgid ""
"If ``False``, the circular reference check for container types is skipped "
"and a circular reference will result in a :exc:`RecursionError` (or worse). "
"Default ``True``."
msgstr ""
"如为 ``False``，则对容器类型的循环引用检查会被跳过并且循环引用将导致 :exc:`RecursionError` (或更糟的情况)。 默认为 "
"``True``。"

#: ../../library/json.rst:194
msgid ""
"If ``False``, serialization of out-of-range :class:`float` values (``nan``, "
"``inf``, ``-inf``) will result in a :exc:`ValueError`, in strict compliance "
"with the JSON specification. If ``True`` (the default), their JavaScript "
"equivalents (``NaN``, ``Infinity``, ``-Infinity``) are used."
msgstr ""
"如为 ``False``，则对超范围的 :class:`float` 值 (``nan``, ``inf``, ``-inf``) 进行序列化将导致 "
":exc:`ValueError`，以严格遵循 JSON 规范。 如为 ``True`` (默认值)，则将使用它们的 JavaScript 等价形式 "
"(``NaN``, ``Infinity``, ``-Infinity``)。"

#: ../../library/json.rst:201
msgid ""
"If set, a custom JSON encoder with the :meth:`~JSONEncoder.default` method "
"overridden, for serializing into custom datatypes. If ``None`` (the "
"default), :class:`!JSONEncoder` is used."
msgstr ""
"如果设置，则重写为一个带有 :meth:`~JSONEncoder.default` 方法的自定义 JSON 编码器，用以序列化为自定义的数据类型。 "
"如为 ``None`` (默认值)，则使用 :class:`!JSONEncoder`。"

#: ../../library/json.rst:208
msgid ""
"If a positive integer or string, JSON array elements and object members will"
" be pretty-printed with that indent level. A positive integer indents that "
"many spaces per level; a string (such as ``\"\\t\"``) is used to indent each"
" level. If zero, negative, or ``\"\"`` (the empty string), only newlines are"
" inserted. If ``None`` (the default), the most compact representation is "
"used."
msgstr ""
"如为一个正整数或字符串，JSON 数组元素和对象成员将按其所指定的缩进层级美化打印。 正整数表示每级缩进指定数量的空格；字符串 (如 "
"``\"\\t\"``) 则被用于每级缩进。 如为零、负数或 ``\"\"`` (空字符串)，则仅插入换行符。 如为 ``None`` "
"(默认值)，则使用最紧凑表示形式。"

#: ../../library/json.rst:218
msgid ""
"A two-tuple: ``(item_separator, key_separator)``. If ``None`` (the default),"
" *separators* defaults to ``(', ', ': ')`` if *indent* is ``None``, and "
"``(',', ': ')`` otherwise. For the most compact JSON, specify ``(',', ':')``"
" to eliminate whitespace."
msgstr ""
"一个二元组: ``(item_separator, key_separator)``。 如为 ``None`` (默认值)，则默认当 *indent* "
"为 ``None`` 时 *separators* 为 ``(', ', ': ')``，否则为 ``(',', ': ')``。 要使用最紧凑形式的 "
"JSON，可指定 ``(',', ':')`` 来去除空格。"

#: ../../library/json.rst:227
msgid ""
"A function that is called for objects that can't otherwise be serialized. It"
" should return a JSON encodable version of the object or raise a "
":exc:`TypeError`. If ``None`` (the default), :exc:`!TypeError` is raised."
msgstr ""
"当对象无法被序列化时将被调用的函数。 它应该返回一个可被 JSON 编码的版本或是引发 :exc:`TypeError`。 如为 ``None`` "
"(默认值)，则会引发 :exc:`!TypeError`。"

#: ../../library/json.rst:234
msgid ""
"If ``True``, dictionaries will be outputted sorted by key. Default "
"``False``."
msgstr "如为 ``True``，则字典输出将按键排序。 默认为 ``False``。"

#: ../../library/json.rst:238 ../../library/json.rst:523
msgid "Allow strings for *indent* in addition to integers."
msgstr "现允许使用字符串作为 *indent* 而不再仅仅是整数。"

#: ../../library/json.rst:241 ../../library/json.rst:531
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "现当 *indent* 不是 ``None`` 时，采用 ``(',', ': ')`` 作为默认值。"

#: ../../library/json.rst:244 ../../library/json.rst:343
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-"
"only_parameter>`."
msgstr "所有可选形参现在都是 :ref:`仅限关键字参数 <keyword-only_parameter>`。"

#: ../../library/json.rst:253
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion"
" table <py-to-json-table>`.  The arguments have the same meaning as in "
":func:`dump`."
msgstr ""
"使用这个 :ref:`转换表 <py-to-json-table>` 将 *obj* 序列化为 JSON 格式的 :class:`str`。 "
"其参数的含义与 :func:`dump` 中的相同。"

#: ../../library/json.rst:259
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"JSON 中的键-值对中的键永远是 :class:`str` 类型的。当一个对象被转化为 JSON "
"时，字典中所有的键都会被强制转换为字符串。这所造成的结果是字典被转换为 JSON 然后转换回字典时可能和原来的不相等。换句话说，如果 x "
"具有非字符串的键，则有 ``loads(dumps(x)) != x``。"

#: ../../library/json.rst:270
msgid ""
"Deserialize *fp* to a Python object using the :ref:`JSON-to-Python "
"conversion table <json-to-py-table>`."
msgstr ""
"使用 :ref:`JSON 至 Python 转换表 <json-to-py-table>` 将 *fp* 反序列化为 Python 对象。"

#: ../../library/json.rst:273
msgid ""
"A ``.read()``-supporting :term:`text file` or :term:`binary file` containing"
" the JSON document to be deserialized."
msgstr ""
"一个包含要执行反序列化的 JSON 文档的支持 ``.read()`` 的 :term:`text file` 或 :term:`binary "
"file`。"

#: ../../library/json.rst:278
msgid ""
"If set, a custom JSON decoder. Additional keyword arguments to :func:`!load`"
" will be passed to the constructor of *cls*. If ``None`` (the default), "
":class:`!JSONDecoder` is used."
msgstr ""
"如果设定此参数，则使用自定义的JSON解码器。任何传递给 :func:`!load` 方法的多余关键字参数都会被传递给 *cls* 的构造器。如果传入 "
"``None`` （默认值），则会使用 :class:`!JSONDecoder` 。"

#: ../../library/json.rst:285
msgid ""
"If set, a function that is called with the result of any JSON object literal"
" decoded (a :class:`dict`). The return value of this function will be used "
"instead of the :class:`dict`. This feature can be used to implement custom "
"decoders, for example `JSON-RPC <https://www.jsonrpc.org>`_ class hinting. "
"Default ``None``."
msgstr ""
"如果设置，将是一个在调用时传入任意被解码的 JSON 对象字面值 (即 :class:`dict`) 的函数。 该函数的返回值将代替该 "
":class:`dict` 被使用。 此特性可被用于实现自定义解码器，例如 `JSON-RPC <https://www.jsonrpc.org>`_ "
"类提示。 默认值为 ``None``。"

#: ../../library/json.rst:295
msgid ""
"If set, a function that is called with the result of any JSON object literal"
" decoded with an ordered list of pairs. The return value of this function "
"will be used instead of the :class:`dict`. This feature can be used to "
"implement custom decoders. If *object_hook* is also set, *object_pairs_hook*"
" takes priority. Default ``None``."
msgstr ""
"如果设置，将是一个在调用时传入以对照值的有序列表进行解码的任意 JSON 对象字面值的函数。 该函数的返回值将代替该 :class:`dict` "
"被使用。 此特性可被用于实现自定义解码器。 如果还设置了 *object_hook*，则 *object_pairs_hook* 的优先级更高。 "
"默认值为 ``None``。"

#: ../../library/json.rst:305
msgid ""
"If set, a function that is called with the string of every JSON float to be "
"decoded. If ``None`` (the default), it is equivalent to ``float(num_str)``. "
"This can be used to parse JSON floats into custom datatypes, for example "
":class:`decimal.Decimal`."
msgstr ""
"如果设置，将是一个在调用时以代表每个要解码的 JSON 浮点数的字符串作为参数的函数。 如为 ``None`` (默认值)，则它等价于 "
"``float(num_str)``。 这可被用于将 JSON 浮点数解析为自定义数据类型，例如 :class:`decimal.Decimal`。"

#: ../../library/json.rst:313
msgid ""
"If set, a function that is called with the string of every JSON int to be "
"decoded. If ``None`` (the default), it is equivalent to ``int(num_str)``. "
"This can be used to parse JSON integers into custom datatypes, for example "
":class:`float`."
msgstr ""
"如果设置，将是一个在调用时以代表每个要解码的 JSON 整数的字符串作为参数的函数。 如为 ``None`` (默认值)，则它等价于 "
"``int(num_str)``。 这可被用于将 JSON 整数解析为自定义数据类型，例如 :class:`float`。"

#: ../../library/json.rst:321
msgid ""
"If set, a function that is called with one of the following strings: "
"``'-Infinity'``, ``'Infinity'``, or ``'NaN'``. This can be used to raise an "
"exception if invalid JSON numbers are encountered. Default ``None``."
msgstr ""
"如果设置，将是一个以下列字符串之一作为参数的函数: ``'-Infinity'``, ``'Infinity'`` 或 ``'NaN'``。 "
"这可被用于在遇到无效的 JSON 数字时引发异常。 默认值为 ``None``。"

#: ../../library/json.rst:0
msgid "Raises"
msgstr "引发"

#: ../../library/json.rst:329
msgid "When the data being deserialized is not a valid JSON document."
msgstr "当被反序列化的数据不是合法的 JSON 文档。"

#: ../../library/json.rst:332
msgid ""
"When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 "
"encoded data."
msgstr "当被反序列化的数据不包含 UTF-8, UTF-16 或 UTF-32 编码的数据。"

#: ../../library/json.rst:338
msgid "Added the optional *object_pairs_hook* parameter."
msgstr "增加了可选的 *object_pairs_hook* 形参。"

#: ../../library/json.rst:339
msgid ""
"*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr "*parse_constant* 不再调用 'null' ， 'true' ， 'false' 。"

#: ../../library/json.rst:344
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr "*fp* 现在可以是 :term:`binary file` 。输入编码应当是 UTF-8 ， UTF-16 或者 UTF-32 。"

#: ../../library/json.rst:347
msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
"现在 :func:`int` 默认的 *parse_int* 会通过解释器的 :ref:`整数字符串长度上限 <int_max_str_digits>`"
" 来限制整数字符串的最大长度以帮助避免拒绝服务攻击。"

#: ../../library/json.rst:355
msgid ""
"Identical to :func:`load`, but instead of a file-like object, deserialize "
"*s* (a :class:`str`, :class:`bytes` or :class:`bytearray` instance "
"containing a JSON document) to a Python object using this :ref:`conversion "
"table <json-to-py-table>`."
msgstr ""
"类似于 :func:`load`，但不是针对文件型对象，而是使用这个 :ref:`转换表 <json-to-py-table>` 将 *s* (一个包含"
" JSON 的 :class:`str`, :class:`bytes` 或 :class:`bytearray` 实例) 反序列化为 Python "
"对象。"

#: ../../library/json.rst:360
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"*s* 现在可以为 :class:`bytes` 或 :class:`bytearray` 类型。 输入编码应为 UTF-8, UTF-16 或 "
"UTF-32。"

#: ../../library/json.rst:364
msgid "The keyword argument *encoding* has been removed."
msgstr "关键字参数 *encoding* 已被移除。"

#: ../../library/json.rst:369
msgid "Encoders and Decoders"
msgstr "编码器和解码器"

#: ../../library/json.rst:373
msgid "Simple JSON decoder."
msgstr "简单的JSON解码器。"

#: ../../library/json.rst:375
msgid "Performs the following translations in decoding by default:"
msgstr "默认情况下，解码执行以下翻译:"

#: ../../library/json.rst:380 ../../library/json.rst:468
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:380 ../../library/json.rst:468
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:382 ../../library/json.rst:470
msgid "object"
msgstr "object -- 对象"

#: ../../library/json.rst:382 ../../library/json.rst:470
msgid "dict"
msgstr "dict"

#: ../../library/json.rst:384 ../../library/json.rst:472
msgid "array"
msgstr "array"

#: ../../library/json.rst:384
msgid "list"
msgstr "list -- 列表"

#: ../../library/json.rst:386 ../../library/json.rst:474
msgid "string"
msgstr "string"

#: ../../library/json.rst:386 ../../library/json.rst:474
msgid "str"
msgstr "str"

#: ../../library/json.rst:388
msgid "number (int)"
msgstr "number (int)"

#: ../../library/json.rst:388
msgid "int"
msgstr "int"

#: ../../library/json.rst:390
msgid "number (real)"
msgstr "number (real)"

#: ../../library/json.rst:390
msgid "float"
msgstr "float"

#: ../../library/json.rst:392 ../../library/json.rst:478
msgid "true"
msgstr "true"

#: ../../library/json.rst:392 ../../library/json.rst:478
msgid "True"
msgstr "True"

#: ../../library/json.rst:394 ../../library/json.rst:480
msgid "false"
msgstr "false"

#: ../../library/json.rst:394 ../../library/json.rst:480
msgid "False"
msgstr "False"

#: ../../library/json.rst:396 ../../library/json.rst:482
msgid "null"
msgstr "null"

#: ../../library/json.rst:396 ../../library/json.rst:482
msgid "None"
msgstr "None"

#: ../../library/json.rst:399
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr "它还将“NaN”、“Infinity”和“-Infinity”理解为它们对应的“float”值，这超出了JSON规范。"

#: ../../library/json.rst:402
msgid ""
"*object_hook* is an optional function that will be called with the result of"
" every JSON object decoded and its return value will be used in place of the"
" given :class:`dict`.  This can be used to provide custom deserializations "
"(e.g. to support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* 是一个可选的函数，它被调用时将传入每个要解码的 JSON 对象而其返回值将被用来替代给定的 :class:`dict`。 "
"它可被用于提供自定义的反序列化操作 (比如支持 `JSON-RPC <https://www.jsonrpc.org>`_ 类提示)。"

#: ../../library/json.rst:407
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of every JSON object decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the "
":class:`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* 是一个可选的函数，它被调用时将传入每个以一个对照值的有序列表进行解码的 JSON 对象的结果。 "
"*object_pairs_hook* 的返回值将被用于代替原本的 :class:`dict`。 此特性可被用于实现自定义的解码器。 如果还定义了 "
"*object_hook*，则 *object_pairs_hook* 的优先级更高。"

#: ../../library/json.rst:413
msgid "Added support for *object_pairs_hook*."
msgstr "添加了对 *object_pairs_hook* 的支持。"

#: ../../library/json.rst:416
msgid ""
"*parse_float* is an optional function that will be called with the string of"
" every JSON float to be decoded.  By default, this is equivalent to "
"``float(num_str)``.  This can be used to use another datatype or parser for "
"JSON floats (e.g. :class:`decimal.Decimal`)."
msgstr ""
"*parse_float* 是一个可选的函数，它被调用时将传入每个要解码的 JSON 浮点数。 默认情况下，这相当于 "
"``float(num_str)``。 它可被用于 JSON 浮点数使用其他类型或解析器的情况 (比如 "
":class:`decimal.Decimal`)。"

#: ../../library/json.rst:421
msgid ""
"*parse_int* is an optional function that will be called with the string of "
"every JSON int to be decoded.  By default, this is equivalent to "
"``int(num_str)``.  This can be used to use another datatype or parser for "
"JSON integers (e.g. :class:`float`)."
msgstr ""
"*parse_int* 是一个可选的函数，它被调用时将传入每个要解码的 JSON 整数。 默认情况下，这相当于 ``int(num_str)``。 "
"它可被用于 JSON 整数使用其他数据类型或解析器的情况 (比如 :class:`float`)。"

#: ../../library/json.rst:426
msgid ""
"*parse_constant* is an optional function that will be called with one of the"
" following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This can be"
" used to raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant* 是一个可选的函数，它被调用时将传入以下字符串之一: ``'-Infinity'``, ``'Infinity'``, "
"``'NaN'``。 它可被用于当遇到无效的 JSON 数字时引发一个异常。"

#: ../../library/json.rst:430
msgid ""
"If *strict* is false (``True`` is the default), then control characters will"
" be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"如果 *strict* 为 false （默认为 ``True`` ），那么控制字符将被允许在字符串内。在此上下文中的控制字符编码在范围 0--31 "
"内的字符，包括 ``'\\t'`` (制表符）， ``'\\n'`` ， ``'\\r'`` 和 ``'\\0'`` 。"

#: ../../library/json.rst:435
msgid ""
"If the data being deserialized is not a valid JSON document, a "
":exc:`JSONDecodeError` will be raised."
msgstr "如果反序列化的数据不是有效 JSON 文档，引发 :exc:`JSONDecodeError` 错误。"

#: ../../library/json.rst:438 ../../library/json.rst:539
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr "所有形参现在都是 :ref:`仅限关键字参数 <keyword-only_parameter>`。"

#: ../../library/json.rst:443
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr "返回 *s* 的 Python 表示形式（包含一个 JSON 文档的 :class:`str` 实例）。"

#: ../../library/json.rst:446
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr "如果给定的 JSON 文档无效则将引发 :exc:`JSONDecodeError`。"

#: ../../library/json.rst:451
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in"
" *s* where the document ended."
msgstr ""
"从 *s* 中解码出 JSON 文档（以 JSON 文档开头的一个 :class:`str` 对象）并返回一个 Python 表示形式为 2 "
"元组以及指明该文档在 *s* 中结束位置的序号。"

#: ../../library/json.rst:455
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr "这可以用于从一个字符串解码JSON文档，该字符串的末尾可能有无关的数据。"

#: ../../library/json.rst:461
msgid "Extensible JSON encoder for Python data structures."
msgstr "用于Python数据结构的可扩展JSON编码器。"

#: ../../library/json.rst:463
msgid "Supports the following objects and types by default:"
msgstr "默认支持以下对象和类型："

#: ../../library/json.rst:472
msgid "list, tuple"
msgstr "list, tuple"

#: ../../library/json.rst:476
msgid "int, float, int- & float-derived Enums"
msgstr "int, float, int 和 float 派生的枚举"

#: ../../library/json.rst:476
msgid "number"
msgstr "number"

#: ../../library/json.rst:485
msgid "Added support for int- and float-derived Enum classes."
msgstr "添加了对 int 和 float 派生的枚举类的支持"

#: ../../library/json.rst:488
msgid ""
"To extend this to recognize other objects, subclass and implement a "
":meth:`~JSONEncoder.default` method with another method that returns a "
"serializable object for ``o`` if possible, otherwise it should call the "
"superclass implementation (to raise :exc:`TypeError`)."
msgstr ""
"要将其扩展至识别其他对象，需要子类化并实现 :meth:`~JSONEncoder.default`，如果可能还要实现另一个返回 ``o`` "
"的可序列化对象的方法，否则它应当调用超类实现 (来引发 :exc:`TypeError`)。"

#: ../../library/json.rst:493
msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when"
" trying to encode keys that are not :class:`str`, :class:`int`, "
":class:`float`, :class:`bool` or ``None``.  If *skipkeys* is true, such "
"items are simply skipped."
msgstr ""
"如果 *skipkeys* 为假值（默认），则当尝试对不为 :class:`str`, :class:`int`, :class:`float`, "
":class:`bool` 或 ``None`` 的键进行编码时将会引发 :exc:`TypeError`。 如果 *skipkeys* "
"为真值，这样的条目将被直接跳过。"

#: ../../library/json.rst:497
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"如果 *ensure_ascii* 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 *ensure_ascii* 是 "
"false，这些字符会原样输出。"

#: ../../library/json.rst:501
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"如果 *check_circular* 为真值（默认），那么列表、字典和自定义的已编码对象将在编码期间进行循环引用检查以防止无限递归 (无限递归会导致 "
":exc:`RecursionError`)。 在其他情况下，将不会进行这种检查。"

#: ../../library/json.rst:506
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and "
"``-Infinity`` will be encoded as such.  This behavior is not JSON "
"specification compliant, but is consistent with most JavaScript based "
"encoders and decoders.  Otherwise, it will be a :exc:`ValueError` to encode "
"such floats."
msgstr ""
"如果 *allow_nan* 为 true （默认），那么 ``NaN`` ， ``Infinity`` ，和 ``-Infinity`` "
"进行编码。此行为不符合 JSON 规范，但与大多数的基于 Javascript 的编码器和解码器一致。否则，它将是一个 "
":exc:`ValueError` 来编码这些浮点数。"

#: ../../library/json.rst:512
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries"
" will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"如果 *sort_keys* 为 true （默认为： ``False`` ），那么字典的输出是按照键排序；这对回归测试很有用，以确保可以每天比较 "
"JSON 序列化。"

#: ../../library/json.rst:516
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent"
" level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the"
" default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as"
" ``\"\\t\"``), that string is used to indent each level."
msgstr ""
"如果 *indent* 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。 如果缩进等级为零、负数或者 "
"``\"\"``，则只会添加换行符。 ``None`` (默认值) 选择最紧凑的表达。 使用一个正整数会让每一层缩进同样数量的空格。 如果 "
"*indent* 是一个字符串 (比如 ``\"\\t\"``)，那个字符串会被用于缩进每一层。"

#: ../../library/json.rst:526
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"当被指定时，*separators* 应当是一个 ``(item_separator, key_separator)`` 元组。当 *indent* 为"
" ``None`` 时，默认值取 ``(', ', ': ')``，否则取 ``(',', ': ')``。为了得到最紧凑的 JSON "
"表达式，你应该指定其为 ``(',', ':')`` 以消除空白字符。"

#: ../../library/json.rst:534
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, "
":exc:`TypeError` is raised."
msgstr ""
"当 *default* 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个"
" :exc:`TypeError`。如果没有被指定，则会直接引发 :exc:`TypeError`。"

#: ../../library/json.rst:545
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a "
":exc:`TypeError`)."
msgstr "在子类中实现这种方法使其返回 *o* 的可序列化对象，或者调用基础实现（引发 :exc:`TypeError` ）。"

#: ../../library/json.rst:549
msgid ""
"For example, to support arbitrary iterators, you could implement "
":meth:`~JSONEncoder.default` like this::"
msgstr "例如，要支持任意的迭代器，你可以这样实现 :meth:`~JSONEncoder.default`::"

#: ../../library/json.rst:552
msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"
msgstr ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # 让基类的 default 方法引发 TypeError\n"
"   return super().default(o)"

#: ../../library/json.rst:565
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr "返回 Python *o* 数据结构的 JSON 字符串表达方式。例如::"

#: ../../library/json.rst:568
msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"

#: ../../library/json.rst:574
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr "编码给定对象 *o* ，并且让每个可用的字符串表达方式。例如::"

#: ../../library/json.rst:577
msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"

#: ../../library/json.rst:582
msgid "Exceptions"
msgstr "异常"

#: ../../library/json.rst:586
msgid ""
"Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr "拥有以下附加属性的 :exc:`ValueError` 的子类："

#: ../../library/json.rst:590
msgid "The unformatted error message."
msgstr "未格式化的错误消息。"

#: ../../library/json.rst:594
msgid "The JSON document being parsed."
msgstr "正在解析的 JSON 文档。"

#: ../../library/json.rst:598
msgid "The start index of *doc* where parsing failed."
msgstr " *doc* 解析失败的起始索引位置。"

#: ../../library/json.rst:602
msgid "The line corresponding to *pos*."
msgstr " *pos* 的对应行数。"

#: ../../library/json.rst:606
msgid "The column corresponding to *pos*."
msgstr " *pos* 的对应列数。"

#: ../../library/json.rst:612
msgid "Standard Compliance and Interoperability"
msgstr "标准符合性和互操作性"

#: ../../library/json.rst:614
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. This "
"section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"JSON 格式由 :rfc:`7159` 和 `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_ 进行规范说明。 "
"这一节详细介绍了本模块与 RFC 的相符程度级别。 简单起见，:class:`JSONEncoder` 和 :class:`JSONDecoder` "
"子类，以及明确提到的形参以外的形参，都未被纳入考量。"

#: ../../library/json.rst:620
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In "
"particular:"
msgstr "此模块不严格遵循于 RFC ，它实现了一些扩展是有效的 Javascript 但不是有效的 JSON。尤其是："

#: ../../library/json.rst:623
msgid "Infinite and NaN number values are accepted and output;"
msgstr "无限和 NaN 数值是被接受并输出；"

#: ../../library/json.rst:624
msgid ""
"Repeated names within an object are accepted, and only the value of the last"
" name-value pair is used."
msgstr "对象内的重复名称是接受的，并且仅使用最后一对属性-值对的值。"

#: ../../library/json.rst:627
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr "自从 RFC 允许符合 RFC 的语法分析程序接收 不符合 RFC 的输入文本以来，这个模块的解串器在默认状态下默认符合 RFC 。"

#: ../../library/json.rst:632
msgid "Character Encodings"
msgstr "字符编码"

#: ../../library/json.rst:634
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr "RFC 要求使用 UTF-8 ， UTF-16 ，或 UTF-32 之一来表示 JSON ，为了最大互通性推荐使用 UTF-8 。"

#: ../../library/json.rst:637
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets"
" *ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""
"RFC允许，尽管不是必须的，这个模块的序列化默认设置为 *ensure_ascii=True* ，这样消除输出以便结果字符串至容纳 ASCII 字符。"

#: ../../library/json.rst:641
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"*ensure_ascii* 参数以外，此模块是严格的按照在 Python 对象和 :class:`Unicode strings <str>` "
"间的转换定义的，并且因此不能直接解决字符编码的问题。"

#: ../../library/json.rst:646
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC"
" permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"RFC 禁止添加字符顺序标记（ BOM ）在 JSON 文本的开头，这个模块的序列化器不添加 BOM 标记在它的输出上。 RFC，准许 JSON "
"反序列化器忽略它们输入中的初始 BOM 标记，但不要求。此模块的反序列化器引发 :exc:`ValueError` 当存在初始 BOM 标记。"

#: ../../library/json.rst:652
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences"
" that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems."
" By default, this module accepts and outputs (when present in the original "
":class:`str`) code points for such sequences."
msgstr ""
"RFC 不会明确禁止包含字节序列的 JSON 字符串这不对应有效的 Unicode 字符（比如 不成对的 UTF-16 "
"的替代物），但是它确实指出它们可能会导致互操作性问题。默认下，模块对这样的序列接受和输出（当在原始 :class:`str` 存在时）代码点。"

#: ../../library/json.rst:660
msgid "Infinite and NaN Number Values"
msgstr "Infinite 和 NaN 数值"

#: ../../library/json.rst:662
msgid ""
"The RFC does not permit the representation of infinite or NaN number values."
" Despite that, by default, this module accepts and outputs ``Infinity``, "
"``-Infinity``, and ``NaN`` as if they were valid JSON number literal "
"values::"
msgstr ""
"RFC 不允许 infinite 或者 NaN 数值的表达方式。尽管这样，默认情况下，此模块接受并且输出 ``Infinity`` ， "
"``-Infinity``，和 ``NaN`` 好像它们是有效的JSON数字字面值 ::"

#: ../../library/json.rst:666
msgid ""
">>> # Neither of these calls raises an exception, but the results are not valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""
">>> # 这些调用均不会引发异常，但结果都不是合法的 JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # 当反序列化时也一样\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"

#: ../../library/json.rst:677
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr "序列化器中， *allow_nan* 参数可用于替代这个行为。反序列化器中， *parse_constant* 参数，可用于替代这个行为。"

#: ../../library/json.rst:683
msgid "Repeated Names Within an Object"
msgstr "对象中的重复名称"

#: ../../library/json.rst:685
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"RFC 具体说明了 在 "
"JSON对象里的名字应该是唯一的，但没有规定如何处理JSON对象中的重复名称。默认下，此模块不引发异常；作为替代，对于给定名它将忽略除姓-"
"值对之外的所有对::"

#: ../../library/json.rst:690
msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"

#: ../../library/json.rst:694
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr " *object_pairs_hook* 参数可用于替代此行为。"

#: ../../library/json.rst:698
msgid "Top-level Non-Object, Non-Array Values"
msgstr "顶级非对象，非数组值"

#: ../../library/json.rst:700
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and"
" this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"过时的 :rfc:`4627` 指定的旧版本 JSON 要求 JSON 文本顶级值必须是 JSON 对象或数组（ Python "
":class:`dict` 或 :class:`list` ），并且不能是 JSON null 值，布尔值，数值或者字符串值。 :rfc:`7159` "
"移除这个限制，此模块没有并且从未在序列化器和反序列化器中实现这个限制。"

#: ../../library/json.rst:707
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere"
" to the restriction yourself."
msgstr "无论如何，为了最大化地获取互操作性，你可能希望自己遵守该原则。"

#: ../../library/json.rst:712
msgid "Implementation Limitations"
msgstr "实现限制"

#: ../../library/json.rst:714
msgid "Some JSON deserializer implementations may set limits on:"
msgstr "一些 JSON 反序列化器的实现应该在以下方面做出限制："

#: ../../library/json.rst:716
msgid "the size of accepted JSON texts"
msgstr "可接受的 JSON 文本大小"

#: ../../library/json.rst:717
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "嵌套 JSON 对象和数组的最高水平"

#: ../../library/json.rst:718
msgid "the range and precision of JSON numbers"
msgstr "JSON 数字的范围和精度"

#: ../../library/json.rst:719
msgid "the content and maximum length of JSON strings"
msgstr "JSON 字符串的内容和最大长度"

#: ../../library/json.rst:721
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr "此模块不强制执行任何上述限制，除了相关的 Python 数据类型本身或者 Python 解释器本身的限制以外。"

#: ../../library/json.rst:724
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that"
" representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"当序列化为 JSON ，在应用中当心此类限制这可能破坏你的 JSON 。特别是，通常将 JSON 数字反序列化为 IEEE 754 "
"双精度数字，从而受到该表示方式的范围和精度限制。这是特别相关的，当序列化非常大的 Python :class:`int` 值时，或者当序列化 "
"\"exotic\" 数值类型的实例时比如 :class:`decimal.Decimal` 。"

#: ../../library/json.rst:737
msgid "Command-line interface"
msgstr "命令行接口"

#: ../../library/json.rst:742
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**源代码：** :source:`Lib/json/tool.py`"

#: ../../library/json.rst:746
msgid ""
"The :mod:`json` module can be invoked as a script via ``python -m json`` to "
"validate and pretty-print JSON objects. The :mod:`json.tool` submodule "
"implements this interface."
msgstr ""
":mod:`json` 模块可作为脚本通过 ``python -m json`` 唤起以验证和美化打印 JSON 对象。 "
":mod:`json.tool` 子模块实现了此接口。"

#: ../../library/json.rst:750
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, "
":data:`sys.stdin` and :data:`sys.stdout` will be used respectively:"
msgstr ""
"如果未指定可选的 ``infile`` 和 ``outfile`` 参数，则将分别使用 :data:`sys.stdin` 和 "
":data:`sys.stdout`:"

#: ../../library/json.rst:753
msgid ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:762
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr "输出现在将与输入顺序保持一致。 请使用 :option:`--sort-keys` 选项来将输出按照键的字母顺序排序。"

#: ../../library/json.rst:767
msgid ""
"The :mod:`json` module may now be directly executed as ``python -m json``. "
"For backwards compatibility, invoking the CLI as ``python -m json.tool`` "
"remains supported."
msgstr ""
"现在 :mod:`json` 模块可通过 ``python -m json`` 来直接执行。 为保持向下兼容，通过 ``python -m "
"json.tool`` 唤起 CLI 仍然是受支持的。"

#: ../../library/json.rst:774
msgid "Command-line options"
msgstr "命令行选项"

#: ../../library/json.rst:778
msgid "The JSON file to be validated or pretty-printed:"
msgstr "要被验证或美化打印的 JSON 文件："

#: ../../library/json.rst:780
msgid ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"
msgstr ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"

#: ../../library/json.rst:794
msgid "If *infile* is not specified, read from :data:`sys.stdin`."
msgstr "如果未指定 *infile*，则从 :data:`sys.stdin` 读取。"

#: ../../library/json.rst:798
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it"
" to :data:`sys.stdout`."
msgstr "将 *infile* 输出写入到给定的 *outfile*。 在其他情况下，将写入到 :data:`sys.stdout`。"

#: ../../library/json.rst:803
msgid "Sort the output of dictionaries alphabetically by key."
msgstr "将字典输出按照键的字母顺序排序。"

#: ../../library/json.rst:809
msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr "禁用非 ASCII 字符的转义，详情参见 :func:`json.dumps`。"

#: ../../library/json.rst:815
msgid "Parse every input line as separate JSON object."
msgstr "将每个输入行解析为单独的 JSON 对象。"

#: ../../library/json.rst:821
msgid "Mutually exclusive options for whitespace control."
msgstr "用于空白符控制的互斥选项。"

#: ../../library/json.rst:827
msgid "Show the help message."
msgstr "显示帮助消息。"

#: ../../library/json.rst:831
msgid "Footnotes"
msgstr "备注"

#: ../../library/json.rst:832
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-"
"editor.org/errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE "
"SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas "
"JavaScript (as of ECMAScript Edition 5.1) does not."
msgstr ""
"正如 `RFC 7159 的勘误表 <https://www.rfc-editor.org/errata_search.php?rfc=7159>`_ "
"所说明的，JSON 允许以字符串表示字面值字符 U+2028 (LINE SEPARATOR) 和 U+2029 (PARAGRAPH "
"SEPARATOR)，而 JavaScript (在 ECMAScript 5.1 版中) 不允许。"
