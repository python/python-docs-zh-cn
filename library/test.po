# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/test.rst:2
msgid ":mod:`!test` --- Regression tests package for Python"
msgstr ":mod:`!test` --- Python 回归测试包"

#: ../../library/test.rst:10
msgid ""
"The :mod:`test` package is meant for internal use by Python only. It is "
"documented for the benefit of the core developers of Python. Any use of this"
" package outside of Python's standard library is discouraged as code "
"mentioned here can change or be removed without notice between releases of "
"Python."
msgstr ""
":mod:`test` 包只供 Python 内部使用。它的记录是为了让 Python 的核心开发者受益。我们不鼓励在 Python "
"标准库之外使用这个包，因为这里提到的代码在 Python 的不同版本之间可能会改变或被删除而不另行通知。"

#: ../../library/test.rst:18
msgid ""
"The :mod:`test` package contains all regression tests for Python as well as "
"the modules :mod:`test.support` and :mod:`test.regrtest`. "
":mod:`test.support` is used to enhance your tests while :mod:`test.regrtest`"
" drives the testing suite."
msgstr ""
":mod:`test` 包包含了 Python 的所有回归测试，以及 :mod:`test.support` 和 "
":mod:`test.regrtest` 模块。  :mod:`test.support` 用于增强你的测试，而 "
":mod:`test.regrtest` 驱动测试套件。"

#: ../../library/test.rst:23
msgid ""
"Each module in the :mod:`test` package whose name starts with ``test_`` is a"
" testing suite for a specific module or feature. All new tests should be "
"written using the :mod:`unittest` or :mod:`doctest` module.  Some older "
"tests are written using a \"traditional\" testing style that compares output"
" printed to ``sys.stdout``; this style of test is considered deprecated."
msgstr ""
":mod:`test` 包中每个名字以 ``test_`` 开头的模块都是一个特定模块或功能的测试套件。所有新的测试应该使用 "
":mod:`unittest` 或 :mod:`doctest` 模块编写。一些旧的测试是使用“传统”的测试风格编写的，即比较打印出来的输出到 "
"``sys.stdout``；这种测试风格被认为是过时的。"

#: ../../library/test.rst:32
msgid "Module :mod:`unittest`"
msgstr "模块 :mod:`unittest`"

#: ../../library/test.rst:33
msgid "Writing PyUnit regression tests."
msgstr "编写 PyUnit 回归测试."

#: ../../library/test.rst:35
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` --- 文档测试模块"

#: ../../library/test.rst:36
msgid "Tests embedded in documentation strings."
msgstr "嵌入到文档字符串的测试。"

#: ../../library/test.rst:42
msgid "Writing Unit Tests for the :mod:`test` package"
msgstr "为 :mod:`test` 包编写单元测试"

#: ../../library/test.rst:44
msgid ""
"It is preferred that tests that use the :mod:`unittest` module follow a few "
"guidelines. One is to name the test module by starting it with ``test_`` and"
" end it with the name of the module being tested. The test methods in the "
"test module should start with ``test_`` and end with a description of what "
"the method is testing. This is needed so that the methods are recognized by "
"the test driver as test methods. Also, no documentation string for the "
"method should be included. A comment (such as ``# Tests function returns "
"only True or False``) should be used to provide documentation for test "
"methods. This is done because documentation strings get printed out if they "
"exist and thus what test is being run is not stated."
msgstr ""
"使用 :mod:`unittest` 模块的测试最好是遵循一些准则。 其中一条是测试模块的名称要以 ``test_`` 打头并以被测试模块的名称结尾。 "
"测试模块中的测试方法应当以 ``test_`` 打头并以该方法所测试的内容的说明结尾。 这很有必要因为这样测试驱动程序就会将这些方法识别为测试方法。 "
"此外，该方法不应当包括任何文档字符串。 应当使用注释 (例如 ``# Tests function returns only True or "
"False``) 来为测试方法提供文档说明。 这样做是因为文档字符串如果存在则会被打印出来因此无法指明正在运行哪个测试。"

#: ../../library/test.rst:55
msgid "A basic boilerplate is often used::"
msgstr "有一个基本模板经常会被使用::"

#: ../../library/test.rst:57
msgid ""
"import unittest\n"
"from test import support\n"
"\n"
"class MyTestCase1(unittest.TestCase):\n"
"\n"
"    # Only use setUp() and tearDown() if necessary\n"
"\n"
"    def setUp(self):\n"
"        ... code to execute in preparation for tests ...\n"
"\n"
"    def tearDown(self):\n"
"        ... code to execute to clean up after tests ...\n"
"\n"
"    def test_feature_one(self):\n"
"        # Test feature one.\n"
"        ... testing code ...\n"
"\n"
"    def test_feature_two(self):\n"
"        # Test feature two.\n"
"        ... testing code ...\n"
"\n"
"    ... more test methods ...\n"
"\n"
"class MyTestCase2(unittest.TestCase):\n"
"    ... same structure as MyTestCase1 ...\n"
"\n"
"... more test classes ...\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"import unittest\n"
"from test import support\n"
"\n"
"class MyTestCase1(unittest.TestCase):\n"
"\n"
"    # 仅在需要时使用 setUp() 和 tearDown()\n"
"\n"
"    def setUp(self):\n"
"        ... 为准备测试而执行的代码 ...\n"
"\n"
"    def tearDown(self):\n"
"        ... 为测试后的清理而执行的代码 ...\n"
"\n"
"    def test_feature_one(self):\n"
"        # 测试特性一。\n"
"        ... 测试代码 ...\n"
"\n"
"    def test_feature_two(self):\n"
"        # 测试特性二。\n"
"        ... 测试代码 ...\n"
"\n"
"    ... 更多的测试方法 ...\n"
"\n"
"class MyTestCase2(unittest.TestCase):\n"
"    ... 与 MyTestCase1 的结构相同 ...\n"
"\n"
"... 更多的测试类 ...\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/test.rst:88
msgid ""
"This code pattern allows the testing suite to be run by "
":mod:`test.regrtest`, on its own as a script that supports the "
":mod:`unittest` CLI, or via the ``python -m unittest`` CLI."
msgstr ""
"这种代码模式允许测试套件由 :mod:`test.regrtest` 运行，作为支持 :mod:`unittest` CLI 的脚本单独运行，或者通过 "
"``python -m unittest`` CLI 来运行。"

#: ../../library/test.rst:92
msgid ""
"The goal for regression testing is to try to break code. This leads to a few"
" guidelines to be followed:"
msgstr "回归测试的目标是尝试破坏代码。 这引出了一些需要遵循的准则:"

#: ../../library/test.rst:95
msgid ""
"The testing suite should exercise all classes, functions, and constants. "
"This includes not just the external API that is to be presented to the "
"outside world but also \"private\" code."
msgstr "测试套件应当测试所有的类、函数和常量。 这不仅包括要向外界展示的外部 API 也包括“私有”的代码。"

#: ../../library/test.rst:99
msgid ""
"Whitebox testing (examining the code being tested when the tests are being "
"written) is preferred. Blackbox testing (testing only the published user "
"interface) is not complete enough to make sure all boundary and edge cases "
"are tested."
msgstr "白盒测试（在编写测试时检查被测试的代码）是最推荐的。 黑盒测试（只测试已发布的用户接口）因不够完整而不能确保所有边界和边缘情况都被测试到。"

#: ../../library/test.rst:104
msgid ""
"Make sure all possible values are tested including invalid ones. This makes "
"sure that not only all valid values are acceptable but also that improper "
"values are handled correctly."
msgstr "确保所有可能的值包括无效的值都被测试到。 这能确保不仅全部的有效值都可被接受而且不适当的值也能被正确地处理。"

#: ../../library/test.rst:108
msgid ""
"Exhaust as many code paths as possible. Test where branching occurs and thus"
" tailor input to make sure as many different paths through the code are "
"taken."
msgstr "消耗尽可能多的代码路径。 测试发生分支的地方从而调整输入以确保通过代码采取尽可能多的不同路径。"

#: ../../library/test.rst:111
msgid ""
"Add an explicit test for any bugs discovered for the tested code. This will "
"make sure that the error does not crop up again if the code is changed in "
"the future."
msgstr "为受测试的代码所发现的任何代码缺陷添加明确的测试。 这将确保如果代码在将来被改变错误也不会再次出现。"

#: ../../library/test.rst:115
msgid ""
"Make sure to clean up after your tests (such as close and remove all "
"temporary files)."
msgstr "确保在你的测试完成后执行清理（例如关闭并删除所有临时文件）。"

#: ../../library/test.rst:118
msgid ""
"If a test is dependent on a specific condition of the operating system then "
"verify the condition already exists before attempting the test."
msgstr "如果某个测试依赖于操作系统上的特定条件那么要在尝试测试之前先验证该条件是否已存在。"

#: ../../library/test.rst:121
msgid ""
"Import as few modules as possible and do it as soon as possible. This "
"minimizes external dependencies of tests and also minimizes possible "
"anomalous behavior from side-effects of importing a module."
msgstr ""
"尽可能少地导入模块并尽可能快地完成操作。 这可以最大限度地减少测试的外部依赖性并且还可以最大限度地减少导入模块带来的附带影响所导致的异常行为。"

#: ../../library/test.rst:125
msgid ""
"Try to maximize code reuse. On occasion, tests will vary by something as "
"small as what type of input is used. Minimize code duplication by "
"subclassing a basic test class with a class that specifies the input::"
msgstr ""
"尝试最大限度地重用代码。 在某些情况下，测试结果会因使用不同类型的输入这样的小细节而变化。 "
"可通过一个指定输入的类来子类化一个基本测试类来最大限度地减少重复代码::"

#: ../../library/test.rst:129
msgid ""
"class TestFuncAcceptsSequencesMixin:\n"
"\n"
"    func = mySuperWhammyFunction\n"
"\n"
"    def test_func(self):\n"
"        self.func(self.arg)\n"
"\n"
"class AcceptLists(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = [1, 2, 3]\n"
"\n"
"class AcceptStrings(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = 'abc'\n"
"\n"
"class AcceptTuples(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = (1, 2, 3)"
msgstr ""
"class TestFuncAcceptsSequencesMixin:\n"
"\n"
"    func = mySuperWhammyFunction\n"
"\n"
"    def test_func(self):\n"
"        self.func(self.arg)\n"
"\n"
"class AcceptLists(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = [1, 2, 3]\n"
"\n"
"class AcceptStrings(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = 'abc'\n"
"\n"
"class AcceptTuples(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = (1, 2, 3)"

#: ../../library/test.rst:145
msgid ""
"When using this pattern, remember that all classes that inherit from "
":class:`unittest.TestCase` are run as tests.  The "
":class:`!TestFuncAcceptsSequencesMixin` class in the example above does not "
"have any data and so can't be run by itself, thus it does not inherit from "
":class:`unittest.TestCase`."
msgstr ""
"当使用这种模式时，请记住所有继承自 :class:`unittest.TestCase` 的类都会作为测试来运行。 上面例子中的 "
":class:`!TestFuncAcceptsSequencesMixin` 类没有任何数据所以其本身是无法运行的，因此它不是继承自 "
":class:`unittest.TestCase`。"

#: ../../library/test.rst:153
msgid "Test Driven Development"
msgstr "测试驱动的开发"

#: ../../library/test.rst:154
msgid "A book by Kent Beck on writing tests before code."
msgstr "Kent Beck 所著的阐述在实现代码之前编写驱动的书。"

#: ../../library/test.rst:160
msgid "Running tests using the command-line interface"
msgstr "使用命令行界面运行测试"

#: ../../library/test.rst:165
msgid ""
"The :mod:`test` package can be run as a script to drive Python's regression "
"test suite, thanks to the :option:`-m` option: :program:`python -m test`. "
"Under the hood, it uses :mod:`test.regrtest`; the call :program:`python -m "
"test.regrtest` used in previous Python versions still works.  Running the "
"script by itself automatically starts running all regression tests in the "
":mod:`test` package. It does this by finding all modules in the package "
"whose name starts with ``test_``, importing them, and executing the function"
" :func:`test_main` if present or loading the tests via "
"unittest.TestLoader.loadTestsFromModule if ``test_main`` does not exist.  "
"The names of tests to execute may also be passed to the script. Specifying a"
" single regression test (:program:`python -m test test_spam`) will minimize "
"output and only print whether the test passed or failed."
msgstr ""
"通过使用 :option:`-m` 选项 :mod:`test` 包可以作为脚本运行以驱动 Python 的回归测试套件: "
":program:`python -m test`。 在内部，它使用 :mod:`test.regrtest`；之前 Python 版本所使用的 "
":program:`python -m test.regrtest` 调用仍然有效。 运行该脚本自身会自动开始运行 :mod:`test` "
"包中的所有回归测试。 它通过在包中查找所有名称以 ``test_`` 打头的模块，导入它们，并在有 :func:`test_main` "
"函数时执行它或是在没有 ``test_main`` 时通过 unittest.TestLoader.loadTestsFromModule 载入测试。 "
"要执行的测试的名称也可以被传递给脚本。 指定一个单独的回归测试 (:program:`python -m test test_spam`) "
"将使输出最小化并且只打印测试通过或失败的消息。"

#: ../../library/test.rst:178
msgid ""
"Running :mod:`test` directly allows what resources are available for tests "
"to use to be set. You do this by using the ``-u`` command-line option. "
"Specifying ``all`` as the value for the ``-u`` option enables all possible "
"resources: :program:`python -m test -uall`. If all but one resource is "
"desired (a more common case), a comma-separated list of resources that are "
"not desired may be listed after ``all``. The command :program:`python -m "
"test -uall,-audio,-largefile` will run :mod:`test` with all resources except"
" the ``audio`` and ``largefile`` resources. For a list of all resources and "
"more command-line options, run :program:`python -m test -h`."
msgstr ""
"直接运行 :mod:`test` 将允许设置哪些资源可供测试使用。 你可以通过使用 ``-u`` 命令行选项来做到这一点。 指定 ``all`` 作为 "
"``-u`` 选项的值将启用所有可能的资源: :program:`python -m test -uall`。 "
"如果只需要一项资源（这是更为常见的情况），可以在 ``all`` 之后加一个以逗号分隔的列表来指明不需要的资源。 命令 :program:`python"
" -m test -uall,-audio,-largefile` 将运行 :mod:`test` 并使用除 ``audio`` 和 "
"``largefile`` 资源之外的所有资源。 要查看所有资源的列表和更多的命令行选项，请运行 :program:`python -m test "
"-h`。"

#: ../../library/test.rst:189
msgid ""
"Some other ways to execute the regression tests depend on what platform the "
"tests are being executed on. On Unix, you can run :program:`make test` at "
"the top-level directory where Python was built. On Windows, executing "
":program:`rt.bat` from your :file:`PCbuild` directory will run all "
"regression tests."
msgstr ""
"另外一些执行回归测试的方式依赖于执行测试所在的系统平台。 在 Unix 上，你可以在构建 Python 的最高层级目录中运行 "
":program:`make test`。 在 Windows 上，在你的 :file:`PCbuild` 目录中执行 "
":program:`rt.bat` 将运行所有的回归测试。"

#: ../../library/test.rst:195
msgid ""
"Output is colorized by default and can be :ref:`controlled using environment"
" variables <using-on-controlling-color>`."
msgstr "输出在默认情况下是彩色的并且可以 :ref:`使用环境变量控制 <using-on-controlling-color>`。"

#: ../../library/test.rst:201
msgid ":mod:`test.support` --- Utilities for the Python test suite"
msgstr ":mod:`test.support` --- 针对 Python 测试套件的工具"

#: ../../library/test.rst:207
msgid ""
"The :mod:`test.support` module provides support for Python's regression test"
" suite."
msgstr ":mod:`test.support` 模块提供了对 Python 的回归测试套件的支持。"

#: ../../library/test.rst:212
msgid ""
":mod:`test.support` is not a public module.  It is documented here to help "
"Python developers write tests.  The API of this module is subject to change "
"without backwards compatibility concerns between releases."
msgstr ""
":mod:`test.support` 不是一个公用模块。 这篇文档是为了帮助 Python 开发者编写测试。 此模块的 API "
"可能被改变而不顾及发行版本之间的向下兼容性问题。"

#: ../../library/test.rst:217
msgid "This module defines the following exceptions:"
msgstr "此模块定义了以下异常:"

#: ../../library/test.rst:221
msgid ""
"Exception to be raised when a test fails. This is deprecated in favor of "
":mod:`unittest`\\ -based tests and :class:`unittest.TestCase`'s assertion "
"methods."
msgstr ""
"当一个测试失败时将被引发的异常。 此异常已被弃用而应改用基于 :mod:`unittest` 的测试以及 "
":class:`unittest.TestCase` 的断言方法。"

#: ../../library/test.rst:228
msgid ""
"Subclass of :exc:`unittest.SkipTest`. Raised when a resource (such as a "
"network connection) is not available. Raised by the :func:`requires` "
"function."
msgstr ""
":exc:`unittest.SkipTest` 的子类。 当一个资源（例如网络连接）不可用时将被引发。 由 :func:`requires` "
"函数所引发。"

#: ../../library/test.rst:233
msgid "The :mod:`test.support` module defines the following constants:"
msgstr ":mod:`test.support` 模块定义了以下常量:"

#: ../../library/test.rst:237
msgid ""
"``True`` when verbose output is enabled. Should be checked when more "
"detailed information is desired about a running test. *verbose* is set by "
":mod:`test.regrtest`."
msgstr ""
"当启用详细输出时为 ``True``。 当需要有关运行中的测试的更详细信息时应当被选择。 *verbose* 是由 "
":mod:`test.regrtest` 来设置的。"

#: ../../library/test.rst:244
msgid "``True`` if the running interpreter is Jython."
msgstr "如果所运行的解释器是 Jython 时为 ``True``。"

#: ../../library/test.rst:249
msgid "``True`` if ``sys.platform`` is ``android``."
msgstr "如果 ``sys.platform`` 是 ``android`` 则为 ``True``。"

#: ../../library/test.rst:254
msgid "``True`` if ``sys.platform`` is ``emscripten``."
msgstr "如果 ``sys.platform`` 是 ``emscripten`` 则为 ``True``。"

#: ../../library/test.rst:259
msgid "``True`` if ``sys.platform`` is ``wasi``."
msgstr "如果 ``sys.platform`` 是 ``wasi`` 则为 ``True``。"

#: ../../library/test.rst:264
msgid "``True`` if ``sys.platform`` is ``ios``, ``tvos``, or ``watchos``."
msgstr "如果 ``sys.platform`` 是 ``ios``, ``tvos`` 或 ``watchos`` 则为 ``True``。"

#: ../../library/test.rst:269
msgid ""
"``True`` if ``sys.platform`` is ``darwin`` or ``is_apple_mobile`` is "
"``True``."
msgstr ""
"如果 ``sys.platform`` 是 ``darwin`` 或者 ``is_apple_mobile`` 是 ``True`` 则为 "
"``True``。"

#: ../../library/test.rst:274
msgid "Path for shell if not on Windows; otherwise ``None``."
msgstr "如果系统不是 Windows 时则为 shell 的路径；否则为 ``None``。"

#: ../../library/test.rst:279
msgid ""
"Timeout in seconds for tests using a network server listening on the network"
" local loopback interface like ``127.0.0.1``."
msgstr "使用网络服务器监听网络本地环回接口如 ``127.0.0.1`` 的测试的以秒为单位的超时值。"

#: ../../library/test.rst:282
msgid ""
"The timeout is long enough to prevent test failure: it takes into account "
"that the client and the server can run in different threads or even "
"different processes."
msgstr "该超时长到足以防止测试失败：它要考虑客户端和服务器可能会在不同线程甚至不同进程中运行。"

#: ../../library/test.rst:286
msgid ""
"The timeout should be long enough for :meth:`~socket.socket.connect`, "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` methods of "
":class:`socket.socket`."
msgstr ""
"该超时应当对于 :class:`socket.socket` 的 :meth:`~socket.socket.connect`, "
":meth:`~socket.socket.recv` 和 :meth:`~socket.socket.send` 方法都足够长。"

#: ../../library/test.rst:290
msgid "Its default value is 5 seconds."
msgstr "其默认值为5秒。"

#: ../../library/test.rst:292
msgid "See also :data:`INTERNET_TIMEOUT`."
msgstr "参见 :data:`INTERNET_TIMEOUT`。"

#: ../../library/test.rst:297
msgid "Timeout in seconds for network requests going to the internet."
msgstr "发往互联网的网络请求的以秒为单位的超时值。"

#: ../../library/test.rst:299
msgid ""
"The timeout is short enough to prevent a test to wait for too long if the "
"internet request is blocked for whatever reason."
msgstr "该超时短到足以避免测试在互联网请求因任何原因被阻止时等待太久。"

#: ../../library/test.rst:302
msgid ""
"Usually, a timeout using :data:`INTERNET_TIMEOUT` should not mark a test as "
"failed, but skip the test instead: see "
":func:`~test.support.socket_helper.transient_internet`."
msgstr ""
"通常使用 :data:`INTERNET_TIMEOUT` 的超时不应该将测试标记为失败，而是跳过测试：参见 "
":func:`~test.support.socket_helper.transient_internet`。"

#: ../../library/test.rst:306
msgid "Its default value is 1 minute."
msgstr "其默认值是1分钟。"

#: ../../library/test.rst:308
msgid "See also :data:`LOOPBACK_TIMEOUT`."
msgstr "参见 :data:`LOOPBACK_TIMEOUT`。"

#: ../../library/test.rst:313
msgid ""
"Timeout in seconds to mark a test as failed if the test takes \"too long\"."
msgstr "如果测试耗时“太长”而要将测试标记为失败的以秒为单位的超时值。"

#: ../../library/test.rst:315
msgid ""
"The timeout value depends on the regrtest ``--timeout`` command line option."
msgstr "该超时值取决于 regrtest ``--timeout`` 命令行选项。"

#: ../../library/test.rst:317
msgid ""
"If a test using :data:`SHORT_TIMEOUT` starts to fail randomly on slow "
"buildbots, use :data:`LONG_TIMEOUT` instead."
msgstr ""
"如果一个使用 :data:`SHORT_TIMEOUT` 的测试在慢速 buildbots 上开始随机失败，请使用 "
":data:`LONG_TIMEOUT` 来代替。"

#: ../../library/test.rst:320
msgid "Its default value is 30 seconds."
msgstr "其默认值为30秒。"

#: ../../library/test.rst:325
msgid "Timeout in seconds to detect when a test hangs."
msgstr "用于检测测试何时挂起的以秒为单位的超时值。"

#: ../../library/test.rst:327
msgid ""
"It is long enough to reduce the risk of test failure on the slowest Python "
"buildbots. It should not be used to mark a test as failed if the test takes "
"\"too long\".  The timeout value depends on the regrtest ``--timeout`` "
"command line option."
msgstr ""
"它的长度足够在最慢的 Python buildbot 上降低测试失败的风险。 如果测试耗时“过长”也不应当用它将该测试标记为失败。 此超时值依赖于 "
"regrtest ``--timeout`` 命令行选项。"

#: ../../library/test.rst:332
msgid "Its default value is 5 minutes."
msgstr "其默认值为5分钟。"

#: ../../library/test.rst:334
msgid ""
"See also :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` and "
":data:`SHORT_TIMEOUT`."
msgstr ""
"另请参见 :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` 和 "
":data:`SHORT_TIMEOUT`。"

#: ../../library/test.rst:340
msgid "Set when tests can be skipped when they are not useful for PGO."
msgstr "当测试对 PGO 没有用处时设置是否要跳过测试。"

#: ../../library/test.rst:345
msgid ""
"A constant that is likely larger than the underlying OS pipe buffer size, to"
" make writes blocking."
msgstr "一个通常大于下层 OS 管道缓冲区大小的常量，以产生写入阻塞。"

#: ../../library/test.rst:351
msgid ""
"``True`` if Python was built with the :c:macro:`Py_DEBUG` macro defined, "
"that is, if Python was :ref:`built in debug mode <debug-build>`."
msgstr ""
"如果 Python 编译时定义了 :c:macro:`Py_DEBUG` 宏则为 ``True``，也就是说，当 Python 是 "
":ref:`以调试模式编译 <debug-build>` 的时候。"

#: ../../library/test.rst:360
msgid ""
"A constant that is likely larger than the underlying OS socket buffer size, "
"to make writes blocking."
msgstr "一个通常大于下层 OS 套接字缓冲区大小的常量，以产生写入阻塞。"

#: ../../library/test.rst:366
msgid "Set to the top level directory that contains :mod:`test.support`."
msgstr "设为包含 :mod:`test.support` 的最高层级目录。"

#: ../../library/test.rst:371
msgid "Set to the top level directory for the test package."
msgstr "设为 test 包的最高层级目录。"

#: ../../library/test.rst:376
msgid "Set to the ``data`` directory within the test package."
msgstr "设为 test 包中的 ``data`` 目录。"

#: ../../library/test.rst:381
msgid "Set to :data:`sys.maxsize` for big memory tests."
msgstr "设为大内存测试的 :data:`sys.maxsize`。"

#: ../../library/test.rst:386
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests. "
"Limited by :data:`MAX_Py_ssize_t`."
msgstr "通过 :func:`set_memlimit` 设为针对大内存测试的内存限制。 受 :data:`MAX_Py_ssize_t` 的限制。"

#: ../../library/test.rst:392
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests.  Not "
"limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"通过 :func:`set_memlimit` 设为针对大内存测试的内存限制。 不受 :data:`MAX_Py_ssize_t` 的限制。"

#: ../../library/test.rst:398
msgid ""
"Set to ``True`` if Python is built without docstrings (the "
":c:macro:`WITH_DOC_STRINGS` macro is not defined). See the "
":option:`configure --without-doc-strings <--without-doc-strings>` option."
msgstr ""
"如果 Python 编译时不带文档字符串（即未定义 :c:macro:`WITH_DOC_STRINGS` 宏）则设为 ``True``。 参见 "
":option:`configure --without-doc-strings <--without-doc-strings>` 选项。"

#: ../../library/test.rst:402
msgid "See also the :data:`HAVE_DOCSTRINGS` variable."
msgstr "另请参阅 :data:`HAVE_DOCSTRINGS` 变量。"

#: ../../library/test.rst:407
msgid ""
"Set to ``True`` if function docstrings are available. See the "
":option:`python -OO <-O>` option, which strips docstrings of functions "
"implemented in Python."
msgstr ""
"如果函数带有文档字符串则设为 ``True``。 参见 :option:`python -OO <-O>` 选项，该选项会去除在 Python "
"中实现的函数的文档字符串。"

#: ../../library/test.rst:410
msgid "See also the :data:`MISSING_C_DOCSTRINGS` variable."
msgstr "另请参阅 :data:`MISSING_C_DOCSTRINGS` 变量。"

#: ../../library/test.rst:415
msgid "Define the URL of a dedicated HTTP server for the network tests."
msgstr "定义用于网络测试的韧性 HTTP 服务器的 URL。"

#: ../../library/test.rst:420
msgid "Object that is equal to anything.  Used to test mixed type comparison."
msgstr "等于任何对象的对象。 用于测试混合类型比较。"

#: ../../library/test.rst:425
msgid ""
"Object that is not equal to anything (even to :data:`ALWAYS_EQ`). Used to "
"test mixed type comparison."
msgstr "不等于任何对象的对象 (即使是 :data:`ALWAYS_EQ`)。 用于测试混合类型比较。"

#: ../../library/test.rst:431
msgid ""
"Object that is greater than anything (except itself). Used to test mixed "
"type comparison."
msgstr "大于任何对象的对象（除了其自身）。 用于测试混合类型比较。"

#: ../../library/test.rst:437
msgid ""
"Object that is less than anything (except itself). Used to test mixed type "
"comparison."
msgstr "小于任何对象的对象（除了其自身）。 用于测试混合类型比较。Used to test mixed type comparison."

#: ../../library/test.rst:441
msgid "The :mod:`test.support` module defines the following functions:"
msgstr ":mod:`test.support` 模块定义了以下函数:"

#: ../../library/test.rst:445
msgid "Run the loop body until ``break`` stops the loop."
msgstr "运行循环体直到以 ``break`` 停止循环。"

#: ../../library/test.rst:447
msgid ""
"After *timeout* seconds, raise an :exc:`AssertionError` if *error* is true, "
"or just stop the loop if *error* is false."
msgstr ""
"在 *timeout* 秒后，如果 *error* 为真值则引发 :exc:`AssertionError`，或者如果 *error* "
"为假值则只停止循环。"

#: ../../library/test.rst:450
msgid "Example::"
msgstr "示例："

#: ../../library/test.rst:452
msgid ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"
msgstr ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"

#: ../../library/test.rst:456 ../../library/test.rst:480
msgid "Example of error=False usage::"
msgstr "error=False 的用法示例::"

#: ../../library/test.rst:458
msgid ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"
msgstr ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"

#: ../../library/test.rst:466
msgid "Wait strategy that applies exponential backoff."
msgstr "应用指数回退的等待策略。"

#: ../../library/test.rst:468
msgid ""
"Run the loop body until ``break`` stops the loop. Sleep at each loop "
"iteration, but not at the first iteration. The sleep delay is doubled at "
"each iteration (up to *max_delay* seconds)."
msgstr ""
"运行循环体直到以 ``break`` 停止循环。 在每次循环迭代时休眠，但第一次迭代时除外。 每次迭代的休眠延时都将加倍（至多 *max_delay* "
"秒）。"

#: ../../library/test.rst:472
msgid "See :func:`busy_retry` documentation for the parameters usage."
msgstr "请参阅 :func:`busy_retry` 文档了解相关形参的用法。"

#: ../../library/test.rst:474
msgid "Example raising an exception after SHORT_TIMEOUT seconds::"
msgstr "在 SHORT_TIMEOUT 秒后引发异常的示例::"

#: ../../library/test.rst:476
msgid ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"
msgstr ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"

#: ../../library/test.rst:482
msgid ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"
msgstr ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"

#: ../../library/test.rst:490
msgid ""
"Return ``True`` if *resource* is enabled and available. The list of "
"available resources is only set when :mod:`test.regrtest` is executing the "
"tests."
msgstr ""
"如果 *resource* 已启用并可用则返回 ``True``。 可用资源列表只有当 :mod:`test.regrtest` "
"正在执行测试时才会被设置。"

#: ../../library/test.rst:497
msgid "Return ``True`` if Python was not built with ``-O0`` or ``-Og``."
msgstr "如果 Python 编译未使用 ``-O0`` 或 ``-Og`` 则返回 ``True``。"

#: ../../library/test.rst:502
msgid "Return :const:`_testcapi.WITH_PYMALLOC`."
msgstr "返回 :const:`_testcapi.WITH_PYMALLOC`。"

#: ../../library/test.rst:507
msgid ""
"Raise :exc:`ResourceDenied` if *resource* is not available. *msg* is the "
"argument to :exc:`ResourceDenied` if it is raised. Always returns ``True`` "
"if called by a function whose ``__name__`` is ``'__main__'``. Used when "
"tests are executed by :mod:`test.regrtest`."
msgstr ""
"如果 *resource* 不可用则引发 :exc:`ResourceDenied`。 如果该异常被引发则 *msg* 为传给 "
":exc:`ResourceDenied` 的参数。 如果被 ``__name__`` 为 ``'__main__'`` 的函数调用则总是返回 "
"``True``。 在测试由 :mod:`test.regrtest` 执行时使用。"

#: ../../library/test.rst:515
msgid "Return a repr of *dict* with keys sorted."
msgstr "返回 *dict* 按键排序的 repr。"

#: ../../library/test.rst:520
msgid ""
"Return the path to the file named *filename*. If no match is found "
"*filename* is returned. This does not equal a failure since it could be the "
"path to the file."
msgstr "返回名为 *filename* 的文件的路径。 如果未找到匹配结果则返回 *filename*。 这并不等于失败因为它也算是该文件的路径。"

#: ../../library/test.rst:524
msgid ""
"Setting *subdir* indicates a relative path to use to find the file rather "
"than looking directly in the path directories."
msgstr "设置 *subdir* 指明要用来查找文件的相对路径而不是直接在路径目录中查找。"

#: ../../library/test.rst:530
msgid "Get size of a page in bytes."
msgstr "获取以字节表示的分页大小。"

#: ../../library/test.rst:537
msgid ""
"Set the :func:`sys.setswitchinterval` to the given *interval*.  Defines a "
"minimum interval for Android systems to prevent the system from hanging."
msgstr ""
"将 :func:`sys.setswitchinterval` 设为给定的 *interval*。 请为 Android "
"系统定义一个最小间隔以防止系统挂起。"

#: ../../library/test.rst:543
msgid ""
"Use this check to guard CPython's implementation-specific tests or to run "
"them only on the implementations guarded by the arguments.  This function "
"returns ``True`` or ``False`` depending on the host platform. Example "
"usage::"
msgstr ""
"使用此检测来保护 CPython 实现专属的测试或者仅在有这些参数保护的实现上运行它们。 此函数将根据主机系统平台的不同返回 ``True`` 或 "
"``False``。 用法示例::"

#: ../../library/test.rst:548
msgid ""
"check_impl_detail()               # Only on CPython (default).\n"
"check_impl_detail(jython=True)    # Only on Jython.\n"
"check_impl_detail(cpython=False)  # Everywhere except CPython."
msgstr ""
"check_impl_detail()               # 仅限 CPython (默认)。\n"
"check_impl_detail(jython=True)    # 仅限 Jython。\n"
"check_impl_detail(cpython=False)  # 除 CPython 以外的任何地方。"

#: ../../library/test.rst:555
msgid ""
"Set the values for :data:`max_memuse` and :data:`real_max_memuse` for big "
"memory tests."
msgstr "针对大内存测试设置 :data:`max_memuse` 和 :data:`real_max_memuse` 的值。"

#: ../../library/test.rst:561
msgid ""
"Store the value from *stdout*.  It is meant to hold the stdout at the time "
"the regrtest began."
msgstr "存放来自 *stdout* 的值。 它会在回归测试开始时处理 stdout。"

#: ../../library/test.rst:567
msgid ""
"Return the original stdout set by :func:`record_original_stdout` or "
"``sys.stdout`` if it's not set."
msgstr ""
"返回 :func:`record_original_stdout` 所设置的原始 stdout 或者如果未设置则为 ``sys.stdout``。"

#: ../../library/test.rst:573
msgid ""
"Return a list of command line arguments reproducing the current settings in "
"``sys.flags`` and ``sys.warnoptions``."
msgstr "返回在 ``sys.flags`` 和 ``sys.warnoptions`` 中重新产生当前设置的命令行参数列表。"

#: ../../library/test.rst:579
msgid ""
"Return a list of command line arguments reproducing the current optimization"
" settings in ``sys.flags``."
msgstr "返回在 ``sys.flags`` 中重新产生当前优化设置的命令行参数列表。"

#: ../../library/test.rst:587
msgid ""
"A context managers that temporarily replaces the named stream with "
":class:`io.StringIO` object."
msgstr "使用 :class:`io.StringIO` 对象临时替换指定流的上下文管理器。"

#: ../../library/test.rst:590
msgid "Example use with output streams::"
msgstr "使用输出流的示例::"

#: ../../library/test.rst:592
msgid ""
"with captured_stdout() as stdout, captured_stderr() as stderr:\n"
"    print(\"hello\")\n"
"    print(\"error\", file=sys.stderr)\n"
"assert stdout.getvalue() == \"hello\\n\"\n"
"assert stderr.getvalue() == \"error\\n\""
msgstr ""
"with captured_stdout() as stdout, captured_stderr() as stderr:\n"
"    print(\"hello\")\n"
"    print(\"error\", file=sys.stderr)\n"
"assert stdout.getvalue() == \"hello\\n\"\n"
"assert stderr.getvalue() == \"error\\n\""

#: ../../library/test.rst:598
msgid "Example use with input stream::"
msgstr "使用输入流的示例::"

#: ../../library/test.rst:600
msgid ""
"with captured_stdin() as stdin:\n"
"    stdin.write('hello\\n')\n"
"    stdin.seek(0)\n"
"    # call test code that consumes from sys.stdin\n"
"    captured = input()\n"
"self.assertEqual(captured, \"hello\")"
msgstr ""
"with captured_stdin() as stdin:\n"
"    stdin.write('hello\\n')\n"
"    stdin.seek(0)\n"
"    # 调用接受 sys.stdin 的代码\n"
"    captured = input()\n"
"self.assertEqual(captured, \"hello\")"

#: ../../library/test.rst:610
msgid "A context manager that temporary disables :mod:`faulthandler`."
msgstr "临时禁用 :mod:`faulthandler` 的上下文管理器。"

#: ../../library/test.rst:615
msgid ""
"Force as many objects as possible to be collected.  This is needed because "
"timely deallocation is not guaranteed by the garbage collector.  This means "
"that ``__del__`` methods may be called later than expected and weakrefs may "
"remain alive for longer than expected."
msgstr ""
"强制收集尽可能多的对象。 这是有必要的因为垃圾回收器并不能保证及时回收资源。 这意味着 ``__del__`` "
"方法的调用可能会晚于预期而弱引用的存活长于预期。"

#: ../../library/test.rst:623
msgid ""
"A context manager that disables the garbage collector on entry. On exit, the"
" garbage collector is restored to its prior state."
msgstr "在进入时禁用垃圾回收器的上下文管理器。 在退出时，垃圾回收器将恢复到先前状态。"

#: ../../library/test.rst:629
msgid "Context manager to swap out an attribute with a new object."
msgstr "上下文管理器用一个新对象来交换一个属性。"

#: ../../library/test.rst:631 ../../library/test.rst:649
#: ../../library/test.rst:904 ../../library/test.rst:1370
msgid "Usage::"
msgstr "用法："

#: ../../library/test.rst:633
msgid ""
"with swap_attr(obj, \"attr\", 5):\n"
"    ..."
msgstr ""
"with swap_attr(obj, \"attr\", 5):\n"
"    ..."

#: ../../library/test.rst:636
msgid ""
"This will set ``obj.attr`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block.  If ``attr`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"这将把 ``obj.attr`` 设为 5 并在 ``with`` 语句块内保持，在语句块结束时恢复旧值。 如果 ``attr`` 不存在于 "
"``obj`` 中，它将被创建并在语句块结束时被删除。"

#: ../../library/test.rst:641 ../../library/test.rst:659
msgid ""
"The old value (or ``None`` if it doesn't exist) will be assigned to the "
"target of the \"as\" clause, if there is one."
msgstr "旧值 (或者如果不存在旧值则为 ``None``) 将被赋给 \"as\" 子句的目标，如果存在子句的话。"

#: ../../library/test.rst:647
msgid "Context manager to swap out an item with a new object."
msgstr "上下文件管理器用一个新对象来交换一个条目。"

#: ../../library/test.rst:651
msgid ""
"with swap_item(obj, \"item\", 5):\n"
"    ..."
msgstr ""
"with swap_item(obj, \"item\", 5):\n"
"    ..."

#: ../../library/test.rst:654
msgid ""
"This will set ``obj[\"item\"]`` to 5 for the duration of the ``with`` block,"
" restoring the old value at the end of the block. If ``item`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"这将把 ``obj[\"item\"]`` 设为 5 并在 ``with`` 语句块内保持，在语句块结束时恢复旧值。 如果 ``item`` 不存在于 "
"``obj`` 中，它将被创建并在语句块结束时被删除。"

#: ../../library/test.rst:665
msgid ""
"Call the ``flush()`` method on :data:`sys.stdout` and then on "
":data:`sys.stderr`. It can be used to make sure that the logs order is "
"consistent before writing into stderr."
msgstr ""
"在 :data:`sys.stdout` 然后又在 :data:`sys.stderr` 上调用 ``flush()`` 方法。 "
"它可被用来确保日志顺序在写入到 stderr 之前的一致性。"

#: ../../library/test.rst:674
msgid ""
"Print a warning into :data:`sys.__stderr__`. Format the message as: "
"``f\"Warning -- {msg}\"``. If *msg* is made of multiple lines, add "
"``\"Warning -- \"`` prefix to each line."
msgstr ""
"打印一个警告到 :data:`sys.__stderr__`。 将消息格式化为: ``f\"Warning -- {msg}\"``。 如果 *msg*"
" 包含多行，则为每行添加 ``\"Warning -- \"`` 前缀。"

#: ../../library/test.rst:683
msgid ""
"Wait until process *pid* completes and check that the process exit code is "
"*exitcode*."
msgstr "等待直到进程 *pid* 结束并检查进程退出代码是否为 *exitcode*。"

#: ../../library/test.rst:686
msgid ""
"Raise an :exc:`AssertionError` if the process exit code is not equal to "
"*exitcode*."
msgstr "如果进程退出代码不等于 *exitcode* 则引发 :exc:`AssertionError`。"

#: ../../library/test.rst:689
msgid ""
"If the process runs longer than *timeout* seconds (:data:`SHORT_TIMEOUT` by "
"default), kill the process and raise an :exc:`AssertionError`. The timeout "
"feature is not available on Windows."
msgstr ""
"如果进程运行时长超过 *timeout* 秒 (默认为 :data:`SHORT_TIMEOUT`)，则杀死进程并引发 "
":exc:`AssertionError`。 超时特性在 Windows 上不可用。"

#: ../../library/test.rst:698
msgid ""
"Return the size of the :c:type:`PyObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr "返回 :c:type:`PyObject` 的大小，其结构成员由 *fmt* 定义。 返回的值包括 Python 对象头的大小和对齐方式。"

#: ../../library/test.rst:704
msgid ""
"Return the size of the :c:type:`PyVarObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr ""
"返回 :c:type:`PyVarObject` 的大小，其结构成员由 *fmt* 定义。 返回的值包括 Python 对象头的大小和对齐方式。"

#: ../../library/test.rst:710
msgid ""
"For testcase *test*, assert that the ``sys.getsizeof`` for *o* plus the GC "
"header size equals *size*."
msgstr "对于测试用例 *test*，断言 *o* 的 ``sys.getsizeof`` 加 GC 头的大小等于 *size*。"

#: ../../library/test.rst:716
msgid ""
"A decorator to conditionally mark tests with "
":func:`unittest.expectedFailure`. Any use of this decorator should have an "
"associated comment identifying the relevant tracker issue."
msgstr ""
"一个有条件地用 :func:`unittest.expectedFailure` 来标记测试的装饰器。 "
"任何对此装饰器的使用都应当具有标识相应追踪事项的有关联注释。"

#: ../../library/test.rst:723
msgid ""
"A decorator that skips the decorated test on TLS certification validation "
"failures."
msgstr "一个在 TLS 证书验证失败时跳过被装饰测试的装饰器。"

#: ../../library/test.rst:728
msgid ""
"A decorator for running a function in a different locale, correctly "
"resetting it after it has finished.  *catstr* is the locale category as a "
"string (for example ``\"LC_ALL\"``).  The *locales* passed will be tried "
"sequentially, and the first valid locale will be used."
msgstr ""
"一个在不同语言区域下运行函数的装饰器，并在其结束后正确地重置语言区域。 *catstr* 是字符串形式的语言区域类别 (例如 "
"``\"LC_ALL\"``)。 传入的 *locales* 将依次被尝试，并将使用第一个有效的语言区域。"

#: ../../library/test.rst:736
msgid ""
"A decorator for running a function in a specific timezone, correctly "
"resetting it after it has finished."
msgstr "一个在指定时区下运行函数的装饰器，并在其结束后正确地重置时区。"

#: ../../library/test.rst:742
msgid ""
"Decorator for the minimum version when running test on FreeBSD.  If the "
"FreeBSD version is less than the minimum, the test is skipped."
msgstr "当在 FreeBSD 上运行测试时指定最低版本的装饰器。 如果 FreeBSD 版本号低于指定值，测试将被跳过。"

#: ../../library/test.rst:748
msgid ""
"Decorator for the minimum version when running test on Linux.  If the Linux "
"version is less than the minimum, the test is skipped."
msgstr "当在 Linux 上运行测试时指定最低版本的装饰器。 如果 Linux 版本号低于指定值，测试将被跳过。"

#: ../../library/test.rst:754
msgid ""
"Decorator for the minimum version when running test on macOS.  If the macOS "
"version is less than the minimum, the test is skipped."
msgstr "当在 macOS 上运行测试时指定最低版本的装饰器。 如果 macOS 版本号低于指定值，测试将被跳过。"

#: ../../library/test.rst:760
msgid ""
"Decorator for skipping tests on the free-threaded build.  If the :term:`GIL`"
" is disabled, the test is skipped."
msgstr "在自由线程编译版上跳过测试的装饰器。 如果禁用了 :term:`GIL`，测试将被跳过。"

#: ../../library/test.rst:766
msgid "Decorator for skipping tests on non-IEEE 754 platforms."
msgstr "用于在非 non-IEEE 754 平台上跳过测试的装饰器。"

#: ../../library/test.rst:771
msgid "Decorator for skipping tests if :mod:`zlib` doesn't exist."
msgstr "用于当 :mod:`zlib` 不存在时跳过测试的装饰器。"

#: ../../library/test.rst:776
msgid "Decorator for skipping tests if :mod:`gzip` doesn't exist."
msgstr "用于当 :mod:`gzip` 不存在时跳过测试的装饰器。"

#: ../../library/test.rst:781
msgid "Decorator for skipping tests if :mod:`bz2` doesn't exist."
msgstr "用于当 :mod:`bz2` 不存在时跳过测试的装饰器。"

#: ../../library/test.rst:786
msgid "Decorator for skipping tests if :mod:`lzma` doesn't exist."
msgstr "用于当 :mod:`lzma` 不存在时跳过测试的装饰器。"

#: ../../library/test.rst:791
msgid "Decorator for skipping tests if *resource* is not available."
msgstr "用于当 *resource* 不可用时跳过测试的装饰器。"

#: ../../library/test.rst:796
msgid "Decorator for only running the test if :data:`HAVE_DOCSTRINGS`."
msgstr "用于仅当 :data:`HAVE_DOCSTRINGS` 时才运行测试的装饰器。"

#: ../../library/test.rst:801
msgid ""
"Decorator for only running the test if :ref:`Limited C API <limited-c-api>` "
"is available."
msgstr "设置仅在 :ref:`受限 C API <limited-c-api>` 可用时运行测试的装饰器。"

#: ../../library/test.rst:807
msgid "Decorator for tests only applicable to CPython."
msgstr "表示仅适用于 CPython 的测试的装饰器。"

#: ../../library/test.rst:812
msgid ""
"Decorator for invoking :func:`check_impl_detail` on *guards*.  If that "
"returns ``False``, then uses *msg* as the reason for skipping the test."
msgstr ""
"用于在 *guards* 上唤起 :func:`check_impl_detail` 的装饰器。 如果调用返回 ``False``，则使用 *msg* "
"作为跳过测试的原因。"

#: ../../library/test.rst:817
msgid ""
"Decorator for marking tests as thread-unsafe.  This test always runs in one "
"thread even when invoked with ``--parallel-threads``."
msgstr "用于将测试标记为线程不安全的装饰器。 此测试即使在使用 ``--parallel-threads`` 唤起时也总是会在一个线程中运行。"

#: ../../library/test.rst:823
msgid ""
"Decorator to temporarily turn off tracing for the duration of the test."
msgstr "用于在测试期间临时关闭追踪的装饰器。"

#: ../../library/test.rst:828
msgid ""
"Decorator for tests which involve reference counting.  The decorator does "
"not run the test if it is not run by CPython.  Any trace function is unset "
"for the duration of the test to prevent unexpected refcounts caused by the "
"trace function."
msgstr ""
"用于涉及引用计数的测试的装饰器。 如果测试不是由 CPython 运行则该装饰器不会运行测试。 "
"在测试期间会取消设置任何追踪函数以由追踪函数导致的意外引用计数。"

#: ../../library/test.rst:836
msgid "Decorator for bigmem tests."
msgstr "用于大内存测试的装饰器。"

#: ../../library/test.rst:838
msgid ""
"*size* is a requested size for the test (in arbitrary, test-interpreted "
"units.)  *memuse* is the number of bytes per unit for the test, or a good "
"estimate of it.  For example, a test that needs two byte buffers, of 4 GiB "
"each, could be decorated with ``@bigmemtest(size=_4G, memuse=2)``."
msgstr ""
"*size* 是测试所请求的大小（以任意的，由测试解读的单位。）  *memuse* 是测试的每单元字节数，或是对它的良好估计。 "
"例如，一个需要两个字节缓冲区，每个缓冲区 4 GiB，则可以用 ``@bigmemtest(size=_4G, memuse=2)`` 来装饰。"

#: ../../library/test.rst:843
msgid ""
"The *size* argument is normally passed to the decorated test method as an "
"extra argument.  If *dry_run* is ``True``, the value passed to the test "
"method may be less than the requested value.  If *dry_run* is ``False``, it "
"means the test doesn't support dummy runs when ``-M`` is not specified."
msgstr ""
"*size* 参数通常作为额外参数传递给被测试的方法。 如果 *dry_run* 为 ``True``，则传给测试方法的值可能少于所请求的值。 如果 "
"*dry_run* 为 ``False``，则意味着当当未指定 ``-M`` 时测试将不支持虚拟运行。"

#: ../../library/test.rst:851
msgid "Decorator for tests that fill the address space."
msgstr "用于填充地址空间的测试的装饰器。"

#: ../../library/test.rst:856
msgid ""
"Return ``False`` if there is no evidence the interpreter was compiled with "
"``musl``, otherwise return a version triple, either ``(0, 0, 0)`` if the "
"version is unknown, or the actual version if it is known.  Intended for use "
"in ``skip`` decorators.  ``emscripten`` and ``wasi`` are assumed to be "
"compiled with ``musl``; otherwise ``platform.libc_ver`` is checked."
msgstr ""
"如果没有证据表明解释器是使用 ``musl`` 编译则返回 ``False``，在其他情况下返回版本号三元组，如果版本号未知则为 ``(0, 0, "
"0)``，或者如果已知则为实际版本号。 被设计用于 ``skip`` 装饰器。 ``emscripten`` 和 ``wasi`` 被认为是使用 "
"``musl`` 编译；在其他情况下将检查 ``platform.libc_ver``。"

#: ../../library/test.rst:865
msgid ""
"Test for syntax errors in *statement* by attempting to compile *statement*. "
"*testcase* is the :mod:`unittest` instance for the test.  *errtext* is the "
"regular expression which should match the string representation of the "
"raised :exc:`SyntaxError`.  If *lineno* is not ``None``, compares to the "
"line of the exception.  If *offset* is not ``None``, compares to the offset "
"of the exception."
msgstr ""
"用于通过尝试编译 *statement* 来测试 *statement* 中的语法错误。 *testcase* 是测试的 :mod:`unittest`"
" 实例。 *errtext* 是应当匹配所引发的 :exc:`SyntaxError` 的字符串表示形式的正则表达式。 如果 *lineno* 不为 "
"``None``，则与异常所在的行进行比较。 如果 *offset* 不为 ``None``，则与异常的偏移量进行比较。"

#: ../../library/test.rst:875
msgid "Open *url*.  If open fails, raises :exc:`TestFailed`."
msgstr "打开 *url*。 如果打开失败，则引发 :exc:`TestFailed`。"

#: ../../library/test.rst:880
msgid ""
"Use this at the end of ``test_main`` whenever sub-processes are started. "
"This will help ensure that no extra children (zombies) stick around to hog "
"resources and create problems when looking for refleaks."
msgstr ""
"只要有子进程启动就在 ``test_main`` 的末尾使用此函数。 这将有助于确保没有多余的子进程（僵尸）存在占用资源并在查找引用泄漏时造成问题。"

#: ../../library/test.rst:887
msgid ""
"Get an attribute, raising :exc:`unittest.SkipTest` if :exc:`AttributeError` "
"is raised."
msgstr "获取一个属性，如果引发了 :exc:`AttributeError` 则会引发 :exc:`unittest.SkipTest`。"

#: ../../library/test.rst:893
msgid ""
"Context manager catching unraisable exception using "
":func:`sys.unraisablehook`."
msgstr "使用 :func:`sys.unraisablehook` 来捕获不可引发的异常的上下文管理器。"

#: ../../library/test.rst:896
msgid ""
"Storing the exception value (``cm.unraisable.exc_value``) creates a "
"reference cycle. The reference cycle is broken explicitly when the context "
"manager exits."
msgstr "存储异常值 (``cm.unraisable.exc_value``) 会创建一个引用循环。 引用循环将在上下文管理器退出时被显式地打破。"

#: ../../library/test.rst:900
msgid ""
"Storing the object (``cm.unraisable.object``) can resurrect it if it is set "
"to an object which is being finalized. Exiting the context manager clears "
"the stored object."
msgstr ""
"存储对象 (``cm.unraisable.object``) 如果被设置为一个正在最终化的对象则可以恢复它。 退出上下文管理器将清除已存在对象。"

#: ../../library/test.rst:906
msgid ""
"with support.catch_unraisable_exception() as cm:\n"
"    # code creating an \"unraisable exception\"\n"
"    ...\n"
"\n"
"    # check the unraisable exception: use cm.unraisable\n"
"    ...\n"
"\n"
"# cm.unraisable attribute no longer exists at this point\n"
"# (to break a reference cycle)"
msgstr ""
"with support.catch_unraisable_exception() as cm:\n"
"    # 创建一个“不可引发的异常”的代码\n"
"    ...\n"
"\n"
"    # 检测这个不可引发的异常：使用 cm.unraisable\n"
"    ...\n"
"\n"
"# 此时 cm.unraisable 属性已不存在\n"
"# （以打破循环引用）"

#: ../../library/test.rst:921
msgid ""
"Generic implementation of the :mod:`unittest` ``load_tests`` protocol for "
"use in test packages.  *pkg_dir* is the root directory of the package; "
"*loader*, *standard_tests*, and *pattern* are the arguments expected by "
"``load_tests``.  In simple cases, the test package's ``__init__.py`` can be "
"the following::"
msgstr ""
"在测试包中使用的 :mod:`unittest` ``load_tests`` 协议的通用实现。 *pkg_dir* 是包的根目录；*loader*, "
"*standard_tests* 和 *pattern* 是 ``load_tests`` 所期望的参数。 在简单的情况下，测试包的 "
"``__init__.py`` 可以是下面这样的::"

#: ../../library/test.rst:927
msgid ""
"import os\n"
"from test.support import load_package_tests\n"
"\n"
"def load_tests(*args):\n"
"    return load_package_tests(os.path.dirname(__file__), *args)"
msgstr ""
"import os\n"
"from test.support import load_package_tests\n"
"\n"
"def load_tests(*args):\n"
"    return load_package_tests(os.path.dirname(__file__), *args)"

#: ../../library/test.rst:936
msgid ""
"Returns the set of attributes, functions or methods of *ref_api* not found "
"on *other_api*, except for a defined list of items to be ignored in this "
"check specified in *ignore*."
msgstr ""
"返回未在 *other_api* 中找到的 *ref_api* 的属性、函数或方法的集合，除去在 *ignore* "
"中指明的要在这个检查中忽略的已定义条目列表。"

#: ../../library/test.rst:940
msgid ""
"By default this skips private attributes beginning with '_' but includes all"
" magic methods, i.e. those starting and ending in '__'."
msgstr "在默认情况下这将跳过以 '_' 打头的私有属性但包括所有魔术方法，即以 '__' 打头和结尾的方法。"

#: ../../library/test.rst:948
msgid ""
"Override *object_to_patch.attr_name* with *new_value*.  Also add cleanup "
"procedure to *test_instance* to restore *object_to_patch* for *attr_name*.  "
"The *attr_name* should be a valid attribute for *object_to_patch*."
msgstr ""
"用 *new_value* 重载 *object_to_patch.attr_name*。并向 *test_instance* 添加清理过程以便为 "
"*attr_name* 恢复 *object_to_patch*。 *attr_name* 应当是 *object_to_patch* 的一个有效属性。"

#: ../../library/test.rst:956
msgid ""
"Run *code* in subinterpreter.  Raise :exc:`unittest.SkipTest` if "
":mod:`tracemalloc` is enabled."
msgstr ""
"在子解释器中运行 *code*。 如果启用了 :mod:`tracemalloc` 则会引发 :exc:`unittest.SkipTest`。"

#: ../../library/test.rst:962
msgid "Assert instances of *cls* are deallocated after iterating."
msgstr "断言 *cls* 的实例在迭代后被释放。"

#: ../../library/test.rst:967
msgid ""
"Check for the existence of the compiler executables whose names are listed "
"in *cmd_names* or all the compiler executables when *cmd_names* is empty and"
" return the first missing executable or ``None`` when none is found missing."
msgstr ""
"检查在 *cmd_names* 中列出名称的或者当 *cmd_names* "
"为空时所有的编译器可执行文件是否存在并返回第一个丢失的可执行文件或者如果未发现任何丢失则返回 ``None``。"

#: ../../library/test.rst:975
msgid ""
"Assert that the ``__all__`` variable of *module* contains all public names."
msgstr "断言 *module* 的 ``__all__`` 变量包含全部公共名称。"

#: ../../library/test.rst:977
msgid ""
"The module's public names (its API) are detected automatically based on "
"whether they match the public name convention and were defined in *module*."
msgstr "模块的公共名称（它的 API）是根据它们是否符合公共名称惯例并在 *module* 中被定义来自动检测的。"

#: ../../library/test.rst:981
msgid ""
"The *name_of_module* argument can specify (as a string or tuple thereof) "
"what module(s) an API could be defined in order to be detected as a public "
"API. One case for this is when *module* imports part of its public API from "
"other modules, possibly a C backend (like ``csv`` and its ``_csv``)."
msgstr ""
"*name_of_module* 参数可以（用字符串或元组的形式）指定一个 API 可以被定义为什么模块以便被检测为一个公共 API。 "
"一种这样的情况会在 *module* 从其他模块，可能是一个 C 后端 (如 ``csv`` 和它的 ``_csv``) 导入其公共 API "
"的某一组成部分时发生。"

#: ../../library/test.rst:986
msgid ""
"The *extra* argument can be a set of names that wouldn't otherwise be "
"automatically detected as \"public\", like objects without a proper "
":attr:`~definition.__module__` attribute. If provided, it will be added to "
"the automatically detected ones."
msgstr ""
"*extra* 参数可以是一个在其他情况下不会被自动检测为 \"public\" 的名称的集合，例如没有适当的 "
":attr:`~definition.__module__` 属性的对象。 如果提供该参数，它将被添加到被自动检测的对象中。"

#: ../../library/test.rst:990
msgid ""
"The *not_exported* argument can be a set of names that must not be treated "
"as part of the public API even though their names indicate otherwise."
msgstr "*not_exported* 参数可以是一个不可被当作公共 API 的一部分的名称集合，即使其名称没有显式指明这一点。"

#: ../../library/test.rst:993 ../../library/test.rst:1630
msgid "Example use::"
msgstr "用法示例::"

#: ../../library/test.rst:995
msgid ""
"import bar\n"
"import foo\n"
"import unittest\n"
"from test import support\n"
"\n"
"class MiscTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        support.check__all__(self, foo)\n"
"\n"
"class OtherTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        extra = {'BAR_CONST', 'FOO_CONST'}\n"
"        not_exported = {'baz'}  # Undocumented name.\n"
"        # bar imports part of its API from _bar.\n"
"        support.check__all__(self, bar, ('bar', '_bar'),\n"
"                             extra=extra, not_exported=not_exported)"
msgstr ""
"import bar\n"
"import foo\n"
"import unittest\n"
"from test import support\n"
"\n"
"class MiscTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        support.check__all__(self, foo)\n"
"\n"
"class OtherTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        extra = {'BAR_CONST', 'FOO_CONST'}\n"
"        not_exported = {'baz'}  # 未写入文档的名称。\n"
"        # bar 从 _bar 导入其 API 的一部分。\n"
"        support.check__all__(self, bar, ('bar', '_bar'),\n"
"                             extra=extra, not_exported=not_exported)"

#: ../../library/test.rst:1016
msgid ""
"Skip tests if the :mod:`multiprocessing.synchronize` module is missing, if "
"there is no available semaphore implementation, or if creating a lock raises"
" an :exc:`OSError`."
msgstr ""
"如果没有 :mod:`multiprocessing.synchronize` 模块，没有可用的 semaphore 实现，或者如果创建一个锁会引发 "
":exc:`OSError` 则跳过测试。"

#: ../../library/test.rst:1025
msgid "Assert that type *tp* cannot be instantiated using *args* and *kwds*."
msgstr "断言类型 *tp* 不能使用 *args* 和 *kwds* 来实例化。"

#: ../../library/test.rst:1032
msgid ""
"This function returns a context manager that will change the global "
":func:`sys.set_int_max_str_digits` setting for the duration of the context "
"to allow execution of test code that needs a different limit on the number "
"of digits when converting between an integer and string."
msgstr ""
"此函数返回一个将在上下文生效期间改变全局 :func:`sys.set_int_max_str_digits` "
"设置的上下文管理器以便允许执行当在整数和字符串之间进行转换时需要对位数有不同限制的测试代码。"

#: ../../library/test.rst:1040
msgid "The :mod:`test.support` module defines the following classes:"
msgstr ":mod:`test.support` 模块定义了以下的类:"

#: ../../library/test.rst:1045
msgid ""
"A context manager used to try to prevent crash dialog popups on tests that "
"are expected to crash a subprocess."
msgstr "一个用于在预期会使子进程崩溃的测试时尽量防止弹出崩溃对话框的上下文管理器。"

#: ../../library/test.rst:1048
msgid ""
"On Windows, it disables Windows Error Reporting dialogs using `SetErrorMode "
"<https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx>`_."
msgstr ""
"在 Windows 上，它会使用 `SetErrorMode <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms680621.aspx>`_ 来禁用 Windows 错误报告对话框。"

#: ../../library/test.rst:1051
msgid ""
"On UNIX, :func:`resource.setrlimit` is used to set "
":const:`resource.RLIMIT_CORE`'s soft limit to 0 to prevent coredump file "
"creation."
msgstr ""
"在 UNIX 上，会使用 :func:`resource.setrlimit` 来将 :const:`resource.RLIMIT_CORE` "
"的软限制设为 0 以防止创建核心转储文件。"

#: ../../library/test.rst:1055
msgid ""
"On both platforms, the old value is restored by :meth:`~object.__exit__`."
msgstr "在这两个平台上，旧值都可通过 :meth:`~object.__exit__` 恢复。"

#: ../../library/test.rst:1060
msgid ""
"Class to save and restore signal handlers registered by the Python signal "
"handler."
msgstr "用于保存和恢复由 Python 句柄的所注册的信号处理器。"

#: ../../library/test.rst:1065
msgid ""
"Save the signal handlers to a dictionary mapping signal numbers to the "
"current signal handler."
msgstr "将信号处理器保存到一个将信号编号映射到当前信号处理器的字典。"

#: ../../library/test.rst:1070
msgid ""
"Set the signal numbers from the :meth:`save` dictionary to the saved "
"handler."
msgstr "将来自 :meth:`save` 字典的信号编号设置到已保存的处理器上。"

#: ../../library/test.rst:1078
msgid "Try to match a single dict with the supplied arguments."
msgstr "尝试对单个字典与所提供的参数进行匹配。"

#: ../../library/test.rst:1083
msgid "Try to match a single stored value (*dv*) with a supplied value (*v*)."
msgstr "尝试对单个已存储值 (*dv*) 与所提供的值 (*v*) 进行匹配。"

#: ../../library/test.rst:1087
msgid ":mod:`test.support.socket_helper` --- Utilities for socket tests"
msgstr ":mod:`test.support.socket_helper` --- 用于套接字测试的工具"

#: ../../library/test.rst:1093
msgid ""
"The :mod:`test.support.socket_helper` module provides support for socket "
"tests."
msgstr ":mod:`test.support.socket_helper` 模块提供了对套接字测试的支持。"

#: ../../library/test.rst:1100
msgid "Set to ``True`` if IPv6 is enabled on this host, ``False`` otherwise."
msgstr "设置为 ``True`` 如果主机打开IPv6, 否则 ``False`` ."

#: ../../library/test.rst:1105
msgid ""
"Returns an unused port that should be suitable for binding.  This is "
"achieved by creating a temporary socket with the same family and type as the"
" ``sock`` parameter (default is :const:`~socket.AF_INET`, "
":const:`~socket.SOCK_STREAM`), and binding it to the specified host address "
"(defaults to ``0.0.0.0``) with the port set to 0, eliciting an unused "
"ephemeral port from the OS. The temporary socket is then closed and deleted,"
" and the ephemeral port is returned."
msgstr ""
"返回一个应当适合绑定的未使用端口。 这是通过创建一个与 ``sock`` 形参相同协议族和类型的临时套接字来达成的 (默认为 "
":const:`~socket.AF_INET`, :const:`~socket.SOCK_STREAM`)，并将其绑定到指定的主机地址 (默认为 "
"``0.0.0.0``) 并将端口设为 0，以从 OS 引出一个未使用的瞬时端口。 这个临时套接字随后将被关闭并删除，然后返回该瞬时端口。"

#: ../../library/test.rst:1114
msgid ""
"Either this method or :func:`bind_port` should be used for any tests where a"
" server socket needs to be bound to a particular port for the duration of "
"the test. Which one to use depends on whether the calling code is creating a"
" Python socket, or if an unused port needs to be provided in a constructor "
"or passed to an external program (i.e. the ``-accept`` argument to openssl's"
" s_server mode).  Always prefer :func:`bind_port` over "
":func:`find_unused_port` where possible.  Using a hard coded port is "
"discouraged since it can make multiple instances of the test impossible to "
"run simultaneously, which is a problem for buildbots."
msgstr ""
"这个方法或 :func:`bind_port` 应当被用于任何在测试期间需要绑定到特定端口的测试。 具体使用哪个取决于调用方代码是否会创建 Python"
" 套接字，或者是否需要在构造器中提供或向外部程序提供未使用的端口（例如传给 openssl 的 s_server 模式的 ``-accept`` "
"参数）。 在可能的情况下将总是优先使用 :func:`bind_port` 而非 :func:`find_unused_port`。 "
"不建议使用硬编码的端口因为将使测试的多个实例无法同时运行，这对 buildbot 来说是个问题。"

#: ../../library/test.rst:1128
msgid ""
"Bind the socket to a free port and return the port number.  Relies on "
"ephemeral ports in order to ensure we are using an unbound port.  This is "
"important as many tests may be running simultaneously, especially in a "
"buildbot environment.  This method raises an exception if the "
"``sock.family`` is :const:`~socket.AF_INET` and ``sock.type`` is "
":const:`~socket.SOCK_STREAM`, and the socket has "
":const:`~socket.SO_REUSEADDR` or :const:`~socket.SO_REUSEPORT` set on it. "
"Tests should never set these socket options for TCP/IP sockets. The only "
"case for setting these options is testing multicasting via multiple UDP "
"sockets."
msgstr ""
"将套接字绑定到一个空闲端口并返回端口号。 这依赖于瞬时端口以确保我们能使用一个未绑定端口。 这很重要因为可能会有许多测试同时运行，特别是在 "
"buildbot 环境中。 如果 ``sock.family`` 为 :const:`~socket.AF_INET` 而 ``sock.type`` "
"为 :const:`~socket.SOCK_STREAM`，并且套接字上设置了 :const:`~socket.SO_REUSEADDR` 或 "
":const:`~socket.SO_REUSEPORT` 则此方法将引发异常。 测试绝不应该为 TCP/IP 套接字设置这些套接字选项。 "
"唯一需要设置这些选项的情况是通过多个 UDP 套接字来测试组播。"

#: ../../library/test.rst:1139
msgid ""
"Additionally, if the :const:`~socket.SO_EXCLUSIVEADDRUSE` socket option is "
"available (i.e. on Windows), it will be set on the socket.  This will "
"prevent anyone else from binding to our host/port for the duration of the "
"test."
msgstr ""
"此外，如果 :const:`~socket.SO_EXCLUSIVEADDRUSE` 套接字选项是可用的（例如在 Windows "
"上），它将在套接字上被设置。 这将阻止其他任何人在测试期间绑定到我们的主机/端口。"

#: ../../library/test.rst:1147
msgid ""
"Bind a Unix socket, raising :exc:`unittest.SkipTest` if "
":exc:`PermissionError` is raised."
msgstr ""
"绑定一个 Unix 套接字，如果 :exc:`PermissionError` 被引发则会引发 :exc:`unittest.SkipTest`。"

#: ../../library/test.rst:1153
msgid ""
"A decorator for running tests that require a functional ``bind()`` for Unix "
"sockets."
msgstr "一个用于运行需要 Unix 套接字 ``bind()`` 功能的测试的装饰器。"

#: ../../library/test.rst:1159
msgid ""
"A context manager that raises :exc:`~test.support.ResourceDenied` when "
"various issues with the internet connection manifest themselves as "
"exceptions."
msgstr ""
"一个在互联网连接的各种问题以异常的形式表现出来时会引发 :exc:`~test.support.ResourceDenied` 的上下文管理器。"

#: ../../library/test.rst:1165
msgid ""
":mod:`test.support.script_helper` --- Utilities for the Python execution "
"tests"
msgstr ":mod:`test.support.script_helper` --- 用于 Python 执行测试工具"

#: ../../library/test.rst:1171
msgid ""
"The :mod:`test.support.script_helper` module provides support for Python's "
"script execution tests."
msgstr ":mod:`test.support.script_helper` 模块提供了对 Python 的脚本执行测试的支持。"

#: ../../library/test.rst:1176
msgid ""
"Return ``True`` if ``sys.executable interpreter`` requires environment "
"variables in order to be able to run at all."
msgstr "如果 ``sys.executable interpreter`` 需要环境变量才能运行则返回 ``True``。"

#: ../../library/test.rst:1179
msgid ""
"This is designed to be used with ``@unittest.skipIf()`` to annotate tests "
"that need to use an ``assert_python*()`` function to launch an isolated mode"
" (``-I``) or no environment mode (``-E``) sub-interpreter process."
msgstr ""
"这被设计用来配合 ``@unittest.skipIf()`` 以便标注需要使用to annotate tests that need to use "
"an ``assert_python*()`` 函数来启动隔离模式 (``-I``) 或无环境模式 (``-E``) 子解释器的测试。"

#: ../../library/test.rst:1183
msgid ""
"A normal build & test does not run into this situation but it can happen "
"when trying to run the standard library test suite from an interpreter that "
"doesn't have an obvious home with Python's current home finding logic."
msgstr ""
"正常的编译和测试运行不会进入这种状况但它在尝试从一个使用 Python 的当前家目录查找逻辑找不到明确的家目录的解释器运行标准库测试套件时有可能发生。"

#: ../../library/test.rst:1187
msgid ""
"Setting :envvar:`PYTHONHOME` is one way to get most of the testsuite to run "
"in that situation.  :envvar:`PYTHONPATH` or :envvar:`PYTHONUSERSITE` are "
"other common environment variables that might impact whether or not the "
"interpreter can start."
msgstr ""
"设置 :envvar:`PYTHONHOME` 是一种能让大多数测试套件在这种情况下运行的办法。 :envvar:`PYTHONPATH` 或 "
":envvar:`PYTHONUSERSITE` 是另外两个可影响解释器是否能启动的常见环境变量。"

#: ../../library/test.rst:1195
msgid ""
"Set up the environment based on *env_vars* for running the interpreter in a "
"subprocess.  The values can include ``__isolated``, ``__cleanenv``, "
"``__cwd``, and ``TERM``."
msgstr ""
"基于 *env_vars* 设置环境以便在子进程中运行解释器。 它的值可以包括 ``__isolated``, ``__cleanenv``, "
"``__cwd``, and ``TERM``。"

#: ../../library/test.rst:1199 ../../library/test.rst:1215
#: ../../library/test.rst:1227
msgid "The function no longer strips whitespaces from *stderr*."
msgstr "此函数不会再从 *stderr* 去除空格符。"

#: ../../library/test.rst:1205
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* succeeds (``rc == 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"断言附带 *args* 和可选的环境变量 *env_vars* 运行解释器会成功 (``rc == 0``) 并返回一个 ``(return code,"
" stdout, stderr)`` 元组。"

#: ../../library/test.rst:1209
msgid ""
"If the *__cleanenv* keyword-only parameter is set, *env_vars* is used as a "
"fresh environment."
msgstr "如果设置了 *__cleanenv* 仅限关键字形参，*env_vars* 会被用作一个全新的环境。"

#: ../../library/test.rst:1212
msgid ""
"Python is started in isolated mode (command line option ``-I``), except if "
"the *__isolated* keyword-only parameter is set to ``False``."
msgstr ""
"Python 是以隔离模式 (命令行选项 ``-I``) 启动的，除非 *__isolated* 仅限关键字形参被设为 ``False``。"

#: ../../library/test.rst:1221
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* fails (``rc != 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"断言附带 *args* 和可选的环境变量 *env_vars* 运行解释器会失败 (``rc != 0``) 并返回一个 ``(return code,"
" stdout, stderr)`` 元组。"

#: ../../library/test.rst:1225
msgid "See :func:`assert_python_ok` for more options."
msgstr "更多选项请参阅 :func:`assert_python_ok`。"

#: ../../library/test.rst:1233
msgid "Run a Python subprocess with the given arguments."
msgstr "使用给定的参数运行一个 Python 子进程。"

#: ../../library/test.rst:1235
msgid ""
"*kw* is extra keyword args to pass to :func:`subprocess.Popen`. Returns a "
":class:`subprocess.Popen` object."
msgstr ""
"*kw* 是要传给 :func:`subprocess.Popen` 的额外关键字参数。 返回一个 :class:`subprocess.Popen` "
"对象。"

#: ../../library/test.rst:1241
msgid ""
"Run the given :class:`subprocess.Popen` process until completion and return "
"stdout."
msgstr "运行给定的 :class:`subprocess.Popen` 进程直至完成并返回 stdout。"

#: ../../library/test.rst:1247
msgid ""
"Create script containing *source* in path *script_dir* and "
"*script_basename*. If *omit_suffix* is ``False``, append ``.py`` to the "
"name.  Return the full script path."
msgstr ""
"在路径 *script_dir* 和 *script_basename* 中创建包含 *source* 的脚本。 如果 *omit_suffix* 为 "
"``False``，则为名称添加 ``.py``。 返回完整的脚本路径。"

#: ../../library/test.rst:1254
msgid ""
"Create zip file at *zip_dir* and *zip_basename* with extension ``zip`` which"
" contains the files in *script_name*. *name_in_zip* is the archive name. "
"Return a tuple containing ``(full path, full path of archive name)``."
msgstr ""
"使用 *zip_dir* 和 *zip_basename* 创建扩展名为 ``zip`` 的 zip 文件，其中包含 *script_name* "
"中的文件。 *name_in_zip* 为归档名。 返回一个包含 ``(full path, full path of archive name)`` "
"的元组。"

#: ../../library/test.rst:1261
msgid ""
"Create a directory named *pkg_dir* containing an ``__init__`` file with "
"*init_source* as its contents."
msgstr "创建一个名为 *pkg_dir* 的目录，其中包含一个 ``__init__`` 文件并以 *init_source* 作为其内容。"

#: ../../library/test.rst:1268
msgid ""
"Create a zip package directory with a path of *zip_dir* and *zip_basename* "
"containing an empty ``__init__`` file and a file *script_basename* "
"containing the *source*.  If *compiled* is ``True``, both source files will "
"be compiled and added to the zip package.  Return a tuple of the full zip "
"path and the archive name for the zip file."
msgstr ""
"使用 *zip_dir* 和 *zip_basename* 创建一个 zip 包目录，其中包含一个空的 ``__init__`` 文件和一个包含 "
"*source* 的文件 *script_basename*。 如果 *compiled* 为 ``True``，则两个源文件将被编译并添加到 zip "
"包中。 返回一个以完整 zip 路径和 zip 文件归档名为元素的元组。"

#: ../../library/test.rst:1276
msgid ""
":mod:`test.support.bytecode_helper` --- Support tools for testing correct "
"bytecode generation"
msgstr ":mod:`test.support.bytecode_helper` --- 用于测试正确字节码生成的支持工具"

#: ../../library/test.rst:1281
msgid ""
"The :mod:`test.support.bytecode_helper` module provides support for testing "
"and inspecting bytecode generation."
msgstr ":mod:`test.support.bytecode_helper` 模块提供了对测试和检查字节码生成的支持。"

#: ../../library/test.rst:1286
msgid "The module defines the following class:"
msgstr " 此模块定义了以下类："

#: ../../library/test.rst:1290
msgid "This class has custom assertion methods for inspecting bytecode."
msgstr "这个类具有用于检查字节码的自定义断言。"

#: ../../library/test.rst:1294
msgid "Return the disassembly of *co* as string."
msgstr "以字符串形式返回 *co* 的汇编码。"

#: ../../library/test.rst:1299
msgid ""
"Return instr if *opname* is found, otherwise throws :exc:`AssertionError`."
msgstr "如果找到 *opname* 则返回 instr，否则抛出 :exc:`AssertionError`。"

#: ../../library/test.rst:1304
msgid "Throws :exc:`AssertionError` if *opname* is found."
msgstr "如果找到 *opname* 则抛出 :exc:`AssertionError`。"

#: ../../library/test.rst:1308
msgid ":mod:`test.support.threading_helper` --- Utilities for threading tests"
msgstr ":mod:`test.support.threading_helper` --- 用于线程测试的工具"

#: ../../library/test.rst:1313
msgid ""
"The :mod:`test.support.threading_helper` module provides support for "
"threading tests."
msgstr ":mod:`test.support.threading_helper` 模块提供了对线程测试的支持。"

#: ../../library/test.rst:1320
msgid ""
"Join a *thread* within *timeout*.  Raise an :exc:`AssertionError` if thread "
"is still alive after *timeout* seconds."
msgstr ""
"在 *timeout* 秒之内合并一个 *thread*。 如果线程在 *timeout* 秒后仍然存活则引发 "
":exc:`AssertionError`。"

#: ../../library/test.rst:1326
msgid "Decorator to ensure the threads are cleaned up even if the test fails."
msgstr "用于确保即使测试失败线程仍然会被清理的装饰器。"

#: ../../library/test.rst:1331
msgid ""
"Context manager to start *threads*, which is a sequence of threads. *unlock*"
" is a function called after the threads are started, even if an exception "
"was raised; an example would be :meth:`threading.Event.set`. "
"``start_threads`` will attempt to join the started threads upon exit."
msgstr ""
"启动 *threads* 的上下文管理器，该参数为一个线程序列。 *unlock* "
"是一个在所有线程启动之后被调用的函数，即使引发了异常也会执行；一个例子是 :meth:`threading.Event.set`。 "
"``start_threads`` 将在退出时尝试合并已启动的线程。"

#: ../../library/test.rst:1339
msgid ""
"Cleanup up threads not specified in *original_values*.  Designed to emit a "
"warning if a test leaves running threads in the background."
msgstr "清理未在 *original_values* 中指定的线程。 被设计为如果有一个测试在后台离开正在运行的线程时会发出警告。"

#: ../../library/test.rst:1345
msgid "Return current thread count and copy of dangling threads."
msgstr "返回当前线程计数和悬空线程的副本。"

#: ../../library/test.rst:1350
msgid ""
"Context manager to wait until all threads created in the ``with`` statement "
"exit."
msgstr "等待直到 ``with`` 语句中所有已创建线程退出的上下文管理器。"

#: ../../library/test.rst:1356
msgid ""
"Context manager catching :class:`threading.Thread` exception using "
":func:`threading.excepthook`."
msgstr ""
"使用 :func:`threading.excepthook` 来捕获 :class:`threading.Thread` 异常的上下文管理器。"

#: ../../library/test.rst:1359
msgid "Attributes set when an exception is caught:"
msgstr "当异常被捕获时要设置的属性:"

#: ../../library/test.rst:1361
msgid "``exc_type``"
msgstr "``exc_type``"

#: ../../library/test.rst:1362
msgid "``exc_value``"
msgstr "``exc_value``"

#: ../../library/test.rst:1363
msgid "``exc_traceback``"
msgstr "``exc_traceback``"

#: ../../library/test.rst:1364
msgid "``thread``"
msgstr "``thread``"

#: ../../library/test.rst:1366
msgid "See :func:`threading.excepthook` documentation."
msgstr "参见 :func:`threading.excepthook` 文档。"

#: ../../library/test.rst:1368
msgid "These attributes are deleted at the context manager exit."
msgstr "这些属性在上下文管理器退出时将被删除。"

#: ../../library/test.rst:1372
msgid ""
"with threading_helper.catch_threading_exception() as cm:\n"
"    # code spawning a thread which raises an exception\n"
"    ...\n"
"\n"
"    # check the thread exception, use cm attributes:\n"
"    # exc_type, exc_value, exc_traceback, thread\n"
"    ...\n"
"\n"
"# exc_type, exc_value, exc_traceback, thread attributes of cm no longer\n"
"# exists at this point\n"
"# (to avoid reference cycles)"
msgstr ""
"with threading_helper.catch_threading_exception() as cm:\n"
"    # 生成一个引发异常的线程的代码\n"
"    ...\n"
"\n"
"    # 检测这个线程异常，使用 cm 的属性：\n"
"    # exc_type, exc_value, exc_traceback, thread\n"
"    ...\n"
"\n"
"# 此时 cm 的 exc_type, exc_value, exc_traceback, thread 属性\n"
"# 已不存在\n"
"# （以避免循环引用）"

#: ../../library/test.rst:1389
msgid ""
"Run the worker function concurrently in multiple threads. Re-raises an "
"exception if any thread raises one, after all threads have finished."
msgstr "在多个线程中并发运行工作函数。若任一线程引发异常，将在所有线程执行完毕后重新引发该异常。"

#: ../../library/test.rst:1395
msgid ":mod:`test.support.os_helper` --- Utilities for os tests"
msgstr ":mod:`test.support.os_helper` --- 用于操作系统测试的工具"

#: ../../library/test.rst:1400
msgid ""
"The :mod:`test.support.os_helper` module provides support for os tests."
msgstr ":mod:`test.support.os_helper` 模块提供了对操作系统测试的支持。"

#: ../../library/test.rst:1407
msgid "A non-ASCII character encodable by :func:`os.fsencode`."
msgstr "一个可通过 :func:`os.fsencode` 编码的非 ASCII 字符。"

#: ../../library/test.rst:1412
msgid "Set to :func:`os.getcwd`."
msgstr "设置为 :func:`os.getcwd`。"

#: ../../library/test.rst:1417
msgid ""
"Set to a name that is safe to use as the name of a temporary file.  Any "
"temporary file that is created should be closed and unlinked (removed)."
msgstr "设置为一个可以安全地用作临时文件名的名称。 任何被创建的临时文件都应当被关闭和撤销链接（移除）。"

#: ../../library/test.rst:1423
msgid ""
"Set to a filename containing the :data:`FS_NONASCII` character, if it "
"exists. This guarantees that if the filename exists, it can be encoded and "
"decoded with the default filesystem encoding. This allows tests that require"
" a non-ASCII filename to be easily skipped on platforms where they can't "
"work."
msgstr ""
"如果存在的话，设置为一个包含 :data:`FS_NONASCII` 字符的文件名。 这会确保当文件名存在时，它可使用默认文件系统编码格式来编码和解码。"
" 这允许需要非 ASCII 文件名的测试在其不可用的平台上被方便地跳过。"

#: ../../library/test.rst:1431
msgid ""
"Set to a filename (str type) that should not be able to be encoded by file "
"system encoding in strict mode.  It may be ``None`` if it's not possible to "
"generate such a filename."
msgstr "设置为一个应当在严格模式下不可使用文件系统编码格式来编码的文件名（str 类型）。 如果无法生成这样的文件名则可以为 ``None``。"

#: ../../library/test.rst:1438
msgid ""
"Set to a filename (bytes type) that should not be able to be decoded by file"
" system encoding in strict mode.  It may be ``None`` if it's not possible to"
" generate such a filename."
msgstr ""
"设置为一个应当在严格模式下不可使用文件系统编码格式来编码的文件名（bytes 类型）。 如果无法生成这样的文件名则可以为 ``None``。"

#: ../../library/test.rst:1445
msgid "Set to a non-ASCII name for a temporary file."
msgstr "设置为用于临时文件的非 ASCII 名称。"

#: ../../library/test.rst:1450
msgid ""
"Class used to temporarily set or unset environment variables.  Instances can"
" be used as a context manager and have a complete dictionary interface for "
"querying/modifying the underlying ``os.environ``. After exit from the "
"context manager all changes to environment variables done through this "
"instance will be rolled back."
msgstr ""
"用于临时性地设置或取消设置环境变量的类。 其实例可被用作上下文管理器并具有完整的字典接口用来查询/修改下层的 ``os.environ``。 "
"在从上下文管理器退出之后所有通过此实例对环境变量进行的修改都将被回滚。"

#: ../../library/test.rst:1456
msgid "Added dictionary interface."
msgstr "增加了字典接口。"

#: ../../library/test.rst:1462
msgid ""
"Simple :term:`path-like object`.  It implements the "
":meth:`~os.PathLike.__fspath__` method which just returns the *path* "
"argument.  If *path* is an exception, it will be raised in "
":meth:`!__fspath__`."
msgstr ""
"简单的 :term:`path-like object`。 它实现了返回 *path* 参数的 "
":meth:`~os.PathLike.__fspath__` 方法。 如果 *path* 是一个异常，它将在 :meth:`!__fspath__` "
"中被引发。"

#: ../../library/test.rst:1470
msgid ""
"Temporarily set the environment variable ``envvar`` to the value of "
"``value``."
msgstr "临时性地将环境变量 ``envvar`` 的值设为 ``value``。"

#: ../../library/test.rst:1476
msgid "Temporarily unset one or more environment variables."
msgstr "临时性地取消一个或多个环境变量。"

#: ../../library/test.rst:1478
msgid "More than one environment variable can be unset."
msgstr "可以取消多个环境变量。"

#: ../../library/test.rst:1484
msgid ""
"Return ``True`` if the OS supports symbolic links, ``False`` otherwise."
msgstr "如果操作系统支持符号链接则返回 ``True``，否则返回 ``False``。"

#: ../../library/test.rst:1490
msgid "Return ``True`` if the OS supports xattr, ``False`` otherwise."
msgstr "如果操作系统支持 xattr 支返回 ``True``，否则返回 ``False``。"

#: ../../library/test.rst:1496
msgid ""
"A context manager that temporarily changes the current working directory to "
"*path* and yields the directory."
msgstr "一个临时性地将当前工作目录改为 *path* 并输出该目录的上下文管理器。"

#: ../../library/test.rst:1499
msgid ""
"If *quiet* is ``False``, the context manager raises an exception on error.  "
"Otherwise, it issues only a warning and keeps the current working directory "
"the same."
msgstr ""
"如果 *quiet* 为 ``False``，此上下文管理器将在发生错误时引发一个异常。 在其他情况下，它将只发出一个警告并将当前工作目录保持原状。"

#: ../../library/test.rst:1506
msgid ""
"Create an empty file with *filename*.  If it already exists, truncate it."
msgstr "创建一个名为 *filename* 的空文件。 如果文件已存在，则清空其内容。"

#: ../../library/test.rst:1511
msgid "Count the number of open file descriptors."
msgstr "统计打开的文件描述符数量。"

#: ../../library/test.rst:1516
msgid ""
"Return ``True`` if the file system for *directory* is case-insensitive."
msgstr "如果 *directory* 的文件系统对大小写敏感则返回 ``True``。"

#: ../../library/test.rst:1521
msgid ""
"Create an invalid file descriptor by opening and closing a temporary file, "
"and returning its descriptor."
msgstr "通过打开并关闭临时文件来创建一个无效的文件描述符，并返回其描述器。"

#: ../../library/test.rst:1527
msgid ""
"Call :func:`os.rmdir` on *filename*.  On Windows platforms, this is wrapped "
"with a wait loop that checks for the existence of the file, which is needed "
"due to antivirus programs that can hold files open and prevent deletion."
msgstr ""
"在 *filename* 上调用 :func:`os.rmdir`。 在 Windows "
"平台上，这将使用一个检测文件是否存在的等待循环来包装，需要这样做是因为反病毒程序会保持文件打开并阻止其被删除。"

#: ../../library/test.rst:1535
msgid ""
"Call :func:`shutil.rmtree` on *path* or call :func:`os.lstat` and "
":func:`os.rmdir` to remove a path and its contents.  As with :func:`rmdir`, "
"on Windows platforms this is wrapped with a wait loop that checks for the "
"existence of the files."
msgstr ""
"在 *path* 上调用 :func:`shutil.rmtree` 或者调用 :func:`os.lstat` 和 :func:`os.rmdir` "
"来移除一个路径及其内容。 与 :func:`rmdir` 一样，在 Windows 平台上这将使用一个检测文件是否存在的等待循环来包装。"

#: ../../library/test.rst:1543
msgid "A decorator for running tests that require support for symbolic links."
msgstr "一个用于运行需要符号链接支持的测试的装饰器。"

#: ../../library/test.rst:1548
msgid "A decorator for running tests that require support for xattr."
msgstr "一个用于运行需要 xattr 支持的测试的装饰器。"

#: ../../library/test.rst:1553
msgid ""
"A context manager that temporarily creates a new directory and changes the "
"current working directory (CWD)."
msgstr "一个临时性地创建新目录并改变当前工作目录（CWD）的上下文管理器。"

#: ../../library/test.rst:1556
msgid ""
"The context manager creates a temporary directory in the current directory "
"with name *name* before temporarily changing the current working directory."
"  If *name* is ``None``, the temporary directory is created using "
":func:`tempfile.mkdtemp`."
msgstr ""
"临时性地改变当前工作目录之前此上下文管理器会在当前目录下创建一个名为 *name* 的临时目录。 如果 *name* 为 ``None``，则会使用 "
":func:`tempfile.mkdtemp` 创建临时目录。"

#: ../../library/test.rst:1561
msgid ""
"If *quiet* is ``False`` and it is not possible to create or change the CWD, "
"an error is raised.  Otherwise, only a warning is raised and the original "
"CWD is used."
msgstr ""
"如果 *quiet* 为 ``False`` 并且无法创建或修改 CWD，则会引发一个错误。 在其他情况下，只会引发一个警告并使用原始 CWD。"

#: ../../library/test.rst:1568
msgid ""
"A context manager that creates a temporary directory at *path* and yields "
"the directory."
msgstr "一个在 *path* 上创建临时目录并输出该目录的上下文管理器。"

#: ../../library/test.rst:1571
msgid ""
"If *path* is ``None``, the temporary directory is created using "
":func:`tempfile.mkdtemp`.  If *quiet* is ``False``, the context manager "
"raises an exception on error.  Otherwise, if *path* is specified and cannot "
"be created, only a warning is issued."
msgstr ""
"如果 *path* 为 ``None``，则会使用 :func:`tempfile.mkdtemp` 来创建临时目录。 如果 *quiet* 为 "
"``False``，则该上下文管理器在发生错误时会引发一个异常。 在其他情况下，如果 *path* 已被指定并且无法创建，则只会发出一个警告。"

#: ../../library/test.rst:1579
msgid "A context manager that temporarily sets the process umask."
msgstr "一个临时性地设置进程掩码的上下文管理器。"

#: ../../library/test.rst:1584
msgid ""
"Call :func:`os.unlink` on *filename*.  As with :func:`rmdir`, on Windows "
"platforms, this is wrapped with a wait loop that checks for the existence of"
" the file."
msgstr ""
"在 *filename* 上调用 :func:`os.unlink`。 与 :func:`rmdir` 一样，在 Windows "
"平台上这将使用一个检测文本是否存在的等待循环来包装。"

#: ../../library/test.rst:1590
msgid ":mod:`test.support.import_helper` --- Utilities for import tests"
msgstr ":mod:`test.support.import_helper` --- 用于导入测试的工具"

#: ../../library/test.rst:1595
msgid ""
"The :mod:`test.support.import_helper` module provides support for import "
"tests."
msgstr ":mod:`test.support.import_helper` 模块提供了对导入测试的支持。"

#: ../../library/test.rst:1602
msgid ""
"Remove the module named *module_name* from ``sys.modules`` and delete any "
"byte-compiled files of the module."
msgstr "从 ``sys.modules`` 移除名为 *module_name* 的模块并删除该模块的已编译字节码文件。"

#: ../../library/test.rst:1608
msgid ""
"This function imports and returns a fresh copy of the named Python module by"
" removing the named module from ``sys.modules`` before doing the import. "
"Note that unlike :func:`reload`, the original module is not affected by this"
" operation."
msgstr ""
"此函数会在执行导入之前通过从 ``sys.modules`` 移除指定模块来导入并返回指定 Python 模块的新副本。 请注意这不同于 "
":func:`reload`，原来的模块不会受到此操作的影响。"

#: ../../library/test.rst:1613
msgid ""
"*fresh* is an iterable of additional module names that are also removed from"
" the ``sys.modules`` cache before doing the import."
msgstr "*fresh* 是包含在执行导入之前还要从 ``sys.modules`` 缓存中移除的附加模块名称的可迭代对象。"

#: ../../library/test.rst:1616
msgid ""
"*blocked* is an iterable of module names that are replaced with ``None`` in "
"the module cache during the import to ensure that attempts to import them "
"raise :exc:`ImportError`."
msgstr ""
"*blocked* 是包含模块名称的可迭代对象，导入期间在模块缓存中它会被替换为 ``None`` 以确保尝试导入将引发 "
":exc:`ImportError`。"

#: ../../library/test.rst:1620
msgid ""
"The named module and any modules named in the *fresh* and *blocked* "
"parameters are saved before starting the import and then reinserted into "
"``sys.modules`` when the fresh import is complete."
msgstr ""
"指定名称的模块以及任何在 *fresh* 和 *blocked* 形参中指明的模块会在开始导入之前被保存并在全新导入完成时被重新插入到 "
"``sys.modules`` 中。"

#: ../../library/test.rst:1624
msgid ""
"Module and package deprecation messages are suppressed during this import if"
" *deprecated* is ``True``."
msgstr "如果 *deprecated* 为 ``True`` 则在此导入操作期间模块和包的弃用消息会被屏蔽。"

#: ../../library/test.rst:1627
msgid ""
"This function will raise :exc:`ImportError` if the named module cannot be "
"imported."
msgstr "如果指定名称的模块无法被导入则此函数将引发 :exc:`ImportError`。"

#: ../../library/test.rst:1632
msgid ""
"# Get copies of the warnings module for testing without affecting the\n"
"# version being used by the rest of the test suite. One copy uses the\n"
"# C implementation, the other is forced to use the pure Python fallback\n"
"# implementation\n"
"py_warnings = import_fresh_module('warnings', blocked=['_warnings'])\n"
"c_warnings = import_fresh_module('warnings', fresh=['_warnings'])"
msgstr ""
"# 获取 warnings 模块的副本用于测试而会不影响\n"
"# 测试套件的其他部分所使用的版本。 一个副本\n"
"# 使用 C 实现，另一个被强制使用纯 Python 的\n"
"# 回退实现\n"
"py_warnings = import_fresh_module('warnings', blocked=['_warnings'])\n"
"c_warnings = import_fresh_module('warnings', fresh=['_warnings'])"

#: ../../library/test.rst:1644
msgid ""
"This function imports and returns the named module. Unlike a normal import, "
"this function raises :exc:`unittest.SkipTest` if the module cannot be "
"imported."
msgstr "此函数会导入并返回指定名称的模块。 不同于正常的导入，如果模块无法被导入则此函数将引发 :exc:`unittest.SkipTest`。"

#: ../../library/test.rst:1648
msgid ""
"Module and package deprecation messages are suppressed during this import if"
" *deprecated* is ``True``.  If a module is required on a platform but "
"optional for others, set *required_on* to an iterable of platform prefixes "
"which will be compared against :data:`sys.platform`."
msgstr ""
"如果 *deprecated* 为 ``True`` 则在此导入操作期间模块和包的弃用消息会被屏蔽。 "
"如果某个模块在特定平台上是必需的而在其他平台上是可选的，请为包含平台前缀的可迭代对象设置 *required_on*，此对象将与 "
":data:`sys.platform` 进行比对。"

#: ../../library/test.rst:1658
msgid "Return a copy of :data:`sys.modules`."
msgstr "返回 :data:`sys.modules` 的副本。"

#: ../../library/test.rst:1663
msgid ""
"Remove modules except for *oldmodules* and ``encodings`` in order to "
"preserve internal cache."
msgstr "移除 *oldmodules* 和 ``encodings`` 以外的模块以保留内部缓冲区。"

#: ../../library/test.rst:1669
msgid "Delete *name* from ``sys.modules``."
msgstr "从 ``sys.modules`` 中删除 *name*。"

#: ../../library/test.rst:1674
msgid ""
"Move a :pep:`3147`/:pep:`488` pyc file to its legacy pyc location and return"
" the file system path to the legacy pyc file.  The *source* value is the "
"file system path to the source file.  It does not need to exist, however the"
" PEP 3147/488 pyc file must exist."
msgstr ""
"将 :pep:`3147`/:pep:`488` pyc 文件移至旧版 pyc 位置并返回该旧版 pyc 文件的文件系统路径。 *source* "
"的值是源文件的文件系统路径。 它不必真实存在，但是 PEP 3147/488 pyc 文件必须存在。"

#: ../../library/test.rst:1682
msgid ""
"A context manager to force import to return a new module reference.  This is"
" useful for testing module-level behaviors, such as the emission of a "
":exc:`DeprecationWarning` on import.  Example usage::"
msgstr ""
"强制导入以返回一个新的模块引用的上下文管理器。 这适用于测试模块层级的行为，例如在导入时发出 :exc:`DeprecationWarning`。 "
"示例用法::"

#: ../../library/test.rst:1686
msgid ""
"with CleanImport('foo'):\n"
"    importlib.import_module('foo')  # New reference."
msgstr ""
"with CleanImport('foo'):\n"
"    importlib.import_module('foo')  # 新引用"

#: ../../library/test.rst:1692
msgid "A context manager to temporarily add directories to :data:`sys.path`."
msgstr "一个临时性地向 :data:`sys.path` 添加目录的上下文管理器。"

#: ../../library/test.rst:1694
msgid ""
"This makes a copy of :data:`sys.path`, appends any directories given as "
"positional arguments, then reverts :data:`sys.path` to the copied settings "
"when the context ends."
msgstr ""
"这将创建 :data:`sys.path` 的一个副本，添加作为位置参数传入的任何目录，然后在上下文结束时将 :data:`sys.path` "
"还原到副本的设置。"

#: ../../library/test.rst:1698
msgid ""
"Note that *all* :data:`sys.path` modifications in the body of the context "
"manager, including replacement of the object, will be reverted at the end of"
" the block."
msgstr "请注意该上下文管理器代码块中 *所有* 对 :data:`sys.path` 的修改，包括对象的替换，都将在代码块结束时被还原。"

#: ../../library/test.rst:1704
msgid ":mod:`test.support.warnings_helper` --- Utilities for warnings tests"
msgstr ":mod:`test.support.warnings_helper` --- 用于警告测试的工具"

#: ../../library/test.rst:1709
msgid ""
"The :mod:`test.support.warnings_helper` module provides support for warnings"
" tests."
msgstr ":mod:`test.support.warnings_helper` 模块提供了对警告测试的支持。"

#: ../../library/test.rst:1716
msgid ""
"Suppress warnings that are instances of *category*, which must be "
":exc:`Warning` or a subclass. Roughly equivalent to "
":func:`warnings.catch_warnings` with :meth:`warnings.simplefilter('ignore', "
"category=category) <warnings.simplefilter>`. For example::"
msgstr ""
"抑制作为 *category* 实例的警告，它必须为 :exc:`Warning` 或其子类。 大致等价于 "
":func:`warnings.catch_warnings` 设置 :meth:`warnings.simplefilter('ignore', "
"category=category) <warnings.simplefilter>`。 例如::"

#: ../../library/test.rst:1722
msgid ""
"@warning_helper.ignore_warnings(category=DeprecationWarning)\n"
"def test_suppress_warning():\n"
"    # do something"
msgstr ""
"@warning_helper.ignore_warnings(category=DeprecationWarning)\n"
"def test_suppress_warning():\n"
"    # 做些什么"

#: ../../library/test.rst:1731
msgid ""
"Context manager to check that no :exc:`ResourceWarning` was raised.  You "
"must remove the object which may emit :exc:`ResourceWarning` before the end "
"of the context manager."
msgstr ""
"检测是否没有任何 :exc:`ResourceWarning` 被引发的上下文管理器。 你必须在该上下文管理器结束之前移除可能发出 "
":exc:`ResourceWarning` 的对象。"

#: ../../library/test.rst:1738
msgid ""
"Test for syntax warning in *statement* by attempting to compile *statement*."
" Test also that the :exc:`SyntaxWarning` is emitted only once, and that it "
"will be converted to a :exc:`SyntaxError` when turned into error. *testcase*"
" is the :mod:`unittest` instance for the test.  *errtext* is the regular "
"expression which should match the string representation of the emitted "
":exc:`SyntaxWarning` and raised :exc:`SyntaxError`.  If *lineno* is not "
"``None``, compares to the line of the warning and exception. If *offset* is "
"not ``None``, compares to the offset of the exception."
msgstr ""
"用于通过尝试编译 *statement* 来测试 *statement* 中的语法警告。 还会测试 :exc:`SyntaxWarning` "
"是否只发出了一次，以及它在转成错误时是否将被转换为 :exc:`SyntaxError`。 *testcase* 是用于测试的 "
":mod:`unittest` 实例。  *errtext* 是应当匹配所发出的 :exc:`SyntaxWarning` 以及所引发的 "
":exc:`SyntaxError` 的字符串表示形式的正则表达式。 如果 *lineno* 不为 ``None``，则与警告和异常所在的行进行比较。 "
"如果 *offset* 不为 ``None``，则与异常的偏移量进行比较。"

#: ../../library/test.rst:1752
msgid ""
"A convenience wrapper for :func:`warnings.catch_warnings` that makes it "
"easier to test that a warning was correctly raised.  It is approximately "
"equivalent to calling ``warnings.catch_warnings(record=True)`` with "
":meth:`warnings.simplefilter` set to ``always`` and with the option to "
"automatically validate the results that are recorded."
msgstr ""
"一个用于 :func:`warnings.catch_warnings` 以更容易地测试特定警告是否被正确引发的便捷包装器。 它大致等价于调用 "
"``warnings.catch_warnings(record=True)`` 并将 :meth:`warnings.simplefilter` 设为"
" ``always`` 并附带自动验证已记录结果的选项。"

#: ../../library/test.rst:1758
msgid ""
"``check_warnings`` accepts 2-tuples of the form ``(\"message regexp\", "
"WarningCategory)`` as positional arguments. If one or more *filters* are "
"provided, or if the optional keyword argument *quiet* is ``False``, it "
"checks to make sure the warnings are as expected:  each specified filter "
"must match at least one of the warnings raised by the enclosed code or the "
"test fails, and if any warnings are raised that do not match any of the "
"specified filters the test fails.  To disable the first of these checks, set"
" *quiet* to ``True``."
msgstr ""
"``check_warnings`` 接受 ``(\"message regexp\", WarningCategory)`` 形式的 2 "
"元组作为位置参数。 如果提供了一个或多个 *filters*，或者如果可选的关键字参数 *quiet* 为 "
"``False``，则它会检查确认警告是符合预期的：每个已指定的过滤器必须匹配至少一个被包围的代码或测试失败时引发的警告，并且如果有任何未能匹配已指定过滤器的警告被引发则测试将失败。"
" 要禁用这些检查中的第一项，请将 *quiet* 设为 ``True``。"

#: ../../library/test.rst:1767
msgid "If no arguments are specified, it defaults to::"
msgstr "如果未指定任何参数，则默认为::"

#: ../../library/test.rst:1769
msgid "check_warnings((\"\", Warning), quiet=True)"
msgstr "check_warnings((\"\", Warning), quiet=True)"

#: ../../library/test.rst:1771
msgid "In this case all warnings are caught and no errors are raised."
msgstr "在此情况下所有警告都会被捕获而不会引发任何错误。"

#: ../../library/test.rst:1773
msgid ""
"On entry to the context manager, a :class:`WarningRecorder` instance is "
"returned. The underlying warnings list from :func:`~warnings.catch_warnings`"
" is available via the recorder object's :attr:`warnings` attribute.  As a "
"convenience, the attributes of the object representing the most recent "
"warning can also be accessed directly through the recorder object (see "
"example below).  If no warning has been raised, then any of the attributes "
"that would otherwise be expected on an object representing a warning will "
"return ``None``."
msgstr ""
"在进入该上下文管理器时，将返回一个 :class:`WarningRecorder` 实例。 来自 "
":func:`~warnings.catch_warnings` 的下层警告列表可通过该记录器对象的 :attr:`warnings` 属性来访问。 "
"作为一个便捷方式，该对象中代表最近的警告的属性也可通过该记录器对象来直接访问（参见以下示例）。 "
"如果未引发任何警告，则在其他情况下预期代表一个警告的任何对象属性都将返回 ``None``。"

#: ../../library/test.rst:1782
msgid ""
"The recorder object also has a :meth:`reset` method, which clears the "
"warnings list."
msgstr "该记录器对象还有一个 :meth:`reset` 方法，该方法会清空警告列表。"

#: ../../library/test.rst:1785
msgid "The context manager is designed to be used like this::"
msgstr "该上下文管理器被设计为像这样来使用::"

#: ../../library/test.rst:1787
msgid ""
"with check_warnings((\"assertion is always true\", SyntaxWarning),\n"
"                    (\"\", UserWarning)):\n"
"    exec('assert(False, \"Hey!\")')\n"
"    warnings.warn(UserWarning(\"Hide me!\"))"
msgstr ""
"with check_warnings((\"assertion is always true\", SyntaxWarning),\n"
"                    (\"\", UserWarning)):\n"
"    exec('assert(False, \"Hey!\")')\n"
"    warnings.warn(UserWarning(\"Hide me!\"))"

#: ../../library/test.rst:1792
msgid ""
"In this case if either warning was not raised, or some other warning was "
"raised, :func:`check_warnings` would raise an error."
msgstr "在此情况下如果两个警告都未被引发，或是引发了其他的警告，则 :func:`check_warnings` 将会引发一个错误。"

#: ../../library/test.rst:1795
msgid ""
"When a test needs to look more deeply into the warnings, rather than just "
"checking whether or not they occurred, code like this can be used::"
msgstr "当一个测试需要更深入地查看这些警告，而不是仅仅检查它们是否发生时，可以使用这样的代码::"

#: ../../library/test.rst:1798
msgid ""
"with check_warnings(quiet=True) as w:\n"
"    warnings.warn(\"foo\")\n"
"    assert str(w.args[0]) == \"foo\"\n"
"    warnings.warn(\"bar\")\n"
"    assert str(w.args[0]) == \"bar\"\n"
"    assert str(w.warnings[0].args[0]) == \"foo\"\n"
"    assert str(w.warnings[1].args[0]) == \"bar\"\n"
"    w.reset()\n"
"    assert len(w.warnings) == 0"
msgstr ""
"with check_warnings(quiet=True) as w:\n"
"    warnings.warn(\"foo\")\n"
"    assert str(w.args[0]) == \"foo\"\n"
"    warnings.warn(\"bar\")\n"
"    assert str(w.args[0]) == \"bar\"\n"
"    assert str(w.warnings[0].args[0]) == \"foo\"\n"
"    assert str(w.warnings[1].args[0]) == \"bar\"\n"
"    w.reset()\n"
"    assert len(w.warnings) == 0"

#: ../../library/test.rst:1809
msgid ""
"Here all warnings will be caught, and the test code tests the captured "
"warnings directly."
msgstr "在这里所有的警告都将被捕获，而测试代码会直接测试被捕获的警告。"

#: ../../library/test.rst:1812
msgid "New optional arguments *filters* and *quiet*."
msgstr "新增可选参数 *filters* 和 *quiet*。"

#: ../../library/test.rst:1818
msgid ""
"Class used to record warnings for unit tests. See documentation of "
":func:`check_warnings` above for more details."
msgstr "用于为单元测试记录警告的类。 请参阅以上 :func:`check_warnings` 的文档来了解详情。"
