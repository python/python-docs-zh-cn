# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/cmd.rst:2
msgid ":mod:`!cmd` --- Support for line-oriented command interpreters"
msgstr ":mod:`!cmd` --- 对面向行的命令解释器的支持"

#: ../../library/cmd.rst:9
msgid "**Source code:** :source:`Lib/cmd.py`"
msgstr "**源代码:** :source:`Lib/cmd.py`"

#: ../../library/cmd.rst:13
msgid ""
"The :class:`Cmd` class provides a simple framework for writing line-oriented"
" command interpreters.  These are often useful for test harnesses, "
"administrative tools, and prototypes that will later be wrapped in a more "
"sophisticated interface."
msgstr ""
":class:`Cmd` 类提供简单框架用于编写面向行的命令解释器。  这些通常对测试工具，管理工具和原型有用，这些工具随后将被包含在更复杂的接口中。"

#: ../../library/cmd.rst:20
msgid ""
"A :class:`Cmd` instance or subclass instance is a line-oriented interpreter "
"framework.  There is no good reason to instantiate :class:`Cmd` itself; "
"rather, it's useful as a superclass of an interpreter class you define "
"yourself in order to inherit :class:`Cmd`'s methods and encapsulate action "
"methods."
msgstr ""
"一个 :class:`Cmd` 实例或子类实例是面向行的解释器框架结构。 实例化 :class:`Cmd` 本身是没有充分理由的， "
"它作为自定义解释器类的超类是非常有用的为了继承 :class:`Cmd` 的方法并且封装动作方法。"

#: ../../library/cmd.rst:25
msgid ""
"The optional argument *completekey* is the :mod:`readline` name of a "
"completion key; it defaults to :kbd:`Tab`. If *completekey* is not "
":const:`None` and :mod:`readline` is available, command completion is done "
"automatically."
msgstr ""
"可选参数 *completekey* 是完成键的 :mod:`readline` 名称；默认是 :kbd:`Tab` 。如果 *completekey*"
" 不是 :const:`None` 并且 :mod:`readline` 是可用的， 命令完成会自动完成。"

#: ../../library/cmd.rst:29
msgid ""
"The default, ``'tab'``, is treated specially, so that it refers to the "
":kbd:`Tab` key on every :data:`readline.backend`. Specifically, if "
":data:`readline.backend` is ``editline``, ``Cmd`` will use ``'^I'`` instead "
"of ``'tab'``. Note that other values are not treated this way, and might "
"only work with a specific backend."
msgstr ""
"默认值 ``'tab'`` 会被特殊对待，以使其在任何 :data:`readline.backend` 上都指向 :kbd:`Tab` 键。 "
"根据特殊规则，如果 :data:`readline.backend` 是 ``editline``，``Cmd`` 将使用 ``'^I'`` 而不是 "
"``'tab'``。 请注意其它的值不会以这种方式来处理，并可能仅适用于特定的后端。"

#: ../../library/cmd.rst:36
msgid ""
"The optional arguments *stdin* and *stdout* specify the  input and output "
"file objects that the Cmd instance or subclass  instance will use for input "
"and output. If not specified, they will default to :data:`sys.stdin` and "
":data:`sys.stdout`."
msgstr ""
"可选参数 *stdin* 和 *stdout* 指定了Cmd实例或子类实例将用于输入和输出的输入和输出文件对象。如果没有指定，他们将默认为 "
":data:`sys.stdin` 和 :data:`sys.stdout` 。"

#: ../../library/cmd.rst:41
msgid ""
"If you want a given *stdin* to be used, make sure to set the instance's "
":attr:`use_rawinput` attribute to ``False``, otherwise *stdin* will be "
"ignored."
msgstr ""
"如果你想要使用一个给定的 *stdin* ，确保将实例的 :attr:`use_rawinput` 属性设置为 ``False`` ，否则 "
"*stdin* 将被忽略。"

#: ../../library/cmd.rst:45
msgid "``completekey='tab'`` is replaced by ``'^I'`` for ``editline``."
msgstr "对于 ``editline`` 来说 ``completekey='tab'`` 将被替换为 ``'^I'``。"

#: ../../library/cmd.rst:52
msgid "Cmd Objects"
msgstr "Cmd 对象"

#: ../../library/cmd.rst:54
msgid "A :class:`Cmd` instance has the following methods:"
msgstr ":class:`Cmd` 实例有下列方法："

#: ../../library/cmd.rst:59
msgid ""
"Repeatedly issue a prompt, accept input, parse an initial prefix off the "
"received input, and dispatch to action methods, passing them the remainder "
"of the line as argument."
msgstr "反复发出提示，接受输入，从收到的输入中解析出一个初始前缀，并分派给操作方法，将其余的行作为参数传递给它们。"

#: ../../library/cmd.rst:63
msgid ""
"The optional argument is a banner or intro string to be issued before the "
"first prompt (this overrides the :attr:`intro` class attribute)."
msgstr "可选参数是在第一个提示之前发布的横幅或介绍字符串（这将覆盖 :attr:`intro` 类属性）。"

#: ../../library/cmd.rst:66
msgid ""
"If the :mod:`readline` module is loaded, input will automatically inherit "
":program:`bash`\\ -like history-list editing (e.g. :kbd:`Control-P` scrolls "
"back to the last command, :kbd:`Control-N` forward to the next one, "
":kbd:`Control-F` moves the cursor to the right non-destructively, "
":kbd:`Control-B` moves the cursor to the left non-destructively, etc.)."
msgstr ""
"如果 :mod:`readline` 继承模块被加载，输入将自动继承类似 :program:`bash`\\ 的历史列表编辑（例如， "
":kbd:`Control-P` 滚动回到最后一个命令， :kbd:`Control-N` 转到下一个命令，以 :kbd:`Control-F` "
"非破坏性的方式向右 :kbd:`Control-B` 移动光标，破坏性地等）。"

#: ../../library/cmd.rst:72
msgid "An end-of-file on input is passed back as the string ``'EOF'``."
msgstr "输入的文件结束符被作为字符串传回 ``'EOF'`` 。"

#: ../../library/cmd.rst:78
msgid ""
"An interpreter instance will recognize a command name ``foo`` if and only if"
" it has a method :meth:`!do_foo`.  As a special case, a line beginning with "
"the character ``'?'`` is dispatched to the method :meth:`do_help`.  As "
"another special case, a line beginning with the character ``'!'`` is "
"dispatched to the method :meth:`!do_shell` (if such a method is defined)."
msgstr ""
"当且仅当命令名称 ``foo`` 具有 :meth:`!do_foo` 方法时解释器实例才会识别它。 存在一种特殊情况，以字符 ``'?'`` "
"开头的行将被分派给 :meth:`do_help` 方法。 还存在另一种特殊情况，以字符 ``'!'`` 开头的行将被分派给 "
":meth:`!do_shell` 方法（如果定义了该方法的话）。"

#: ../../library/cmd.rst:84
msgid ""
"This method will return when the :meth:`postcmd` method returns a true "
"value. The *stop* argument to :meth:`postcmd` is the return value from the "
"command's corresponding :meth:`!do_\\*` method."
msgstr ""
"当 :meth:`postcmd` 方法返回真值时此方法将返回。  :meth:`postcmd` 的 *stop* 参数是命令对应的 "
":meth:`!do_\\*` 方法的返回值。"

#: ../../library/cmd.rst:88
msgid ""
"If completion is enabled, completing commands will be done automatically, "
"and completing of commands args is done by calling :meth:`!complete_foo` "
"with arguments *text*, *line*, *begidx*, and *endidx*.  *text* is the string"
" prefix we are attempting to match: all returned matches must begin with it."
" *line* is the current input line with leading whitespace removed, *begidx* "
"and *endidx* are the beginning and ending indexes of the prefix text, which "
"could be used to provide different completion depending upon which position "
"the argument is in."
msgstr ""
"如果启用了补全，则会自动完成命令的补全，命令参数的补全则是通过调用 :meth:`!complete_foo` 并附带参数 *text*, "
"*line*, *begidx* 和 *endidx* 来完成的。 *text* 是我们要尝试匹配的字符串前缀：所有被返回的匹配必须以它为开头。 "
"*line* 是去除了开头空白符的当前输入行，*begidx* 和 *endidx* "
"是前缀文本的开始和结束索引号，它们可被用来根据参数所在的位置提供不同的补全。"

#: ../../library/cmd.rst:99
msgid ""
"All subclasses of :class:`Cmd` inherit a predefined :meth:`!do_help`.  This "
"method, called with an argument ``'bar'``, invokes the corresponding method "
":meth:`!help_bar`, and if that is not present, prints the docstring of "
":meth:`!do_bar`, if available.  With no argument, :meth:`!do_help` lists all"
" available help topics (that is, all commands with corresponding "
":meth:`!help_\\*` methods or commands that have docstrings), and also lists "
"any undocumented commands."
msgstr ""
"所有 :class:`Cmd` 的子类都继承了一个预定义的 :meth:`!do_help`。 调用该方法时传入一个参数 "
"``'bar'``，将唤起对应的方法 :meth:`!help_bar`，如果该方法不存在，则将打印 :meth:`!do_bar` "
"的文档字符串，如果有文档字符串的话。 在没有参数的情况下，:meth:`!do_help` 将列出所有可用的帮助主题（即任何具有对应的 "
":meth:`!help_\\*` 方法的命令或具有文档字符串的命令），还会列出任何未写入文档的命令。"

#: ../../library/cmd.rst:110
msgid ""
"Interpret the argument as though it had been typed in response to the "
"prompt. This may be overridden, but should not normally need to be; see the "
":meth:`precmd` and :meth:`postcmd` methods for useful execution hooks.  The "
"return value is a flag indicating whether interpretation of commands by the "
"interpreter should stop.  If there is a :meth:`!do_\\*` method for the "
"command *str*, the return value of that method is returned, otherwise the "
"return value from the :meth:`default` method is returned."
msgstr ""
"解释该参数就好像它是为响应提示而键入的一样。 此方法可以被重写，但通常不需要这样做；请参阅针对有用的执行钩子的 :meth:`precmd` 和 "
":meth:`postcmd` 方法。 返回值是一个指明解释器对命令的解释是否应停止的旗标。 如果对于命令 *str* 存在 "
":meth:`!do_\\*` 方法，则将返回该方法的返回值，否则将返回 :meth:`default` 方法的返回值。"

#: ../../library/cmd.rst:121
msgid ""
"Method called when an empty line is entered in response to the prompt. If "
"this method is not overridden, it repeats the last nonempty command entered."
msgstr "在响应提示输入空行时调用的方法。如果此方法未被覆盖，则重复输入的最后一个非空命令。"

#: ../../library/cmd.rst:127
msgid ""
"Method called on an input line when the command prefix is not recognized. If"
" this method is not overridden, it prints an error message and returns."
msgstr "当命令前缀不能被识别的时候在输入行调用的方法。如果此方法未被覆盖，它将输出一个错误信息并返回。"

#: ../../library/cmd.rst:133
msgid ""
"Method called to complete an input line when no command-specific "
":meth:`!complete_\\*` method is available.  By default, it returns an empty "
"list."
msgstr "当没有命令专属的 :meth:`!complete_\\*` 方法可供使用时将被调用以完成输入行的方法。 在默认情况下，它将返回一个空列表。"

#: ../../library/cmd.rst:139
msgid ""
"Method called to display a list of strings as a compact set of columns. Each"
" column is only as wide as necessary. Columns are separated by two spaces "
"for readability."
msgstr "调用以将一个字符串列表显示为紧凑的列集的方法。 每列的宽度仅够显示其内容。 各列之间以两个空格分隔以保证可读性。"

#: ../../library/cmd.rst:146
msgid ""
"Hook method executed just before the command line *line* is interpreted, but"
" after the input prompt is generated and issued.  This method is a stub in "
":class:`Cmd`; it exists to be overridden by subclasses.  The return value is"
" used as the command which will be executed by the :meth:`onecmd` method; "
"the :meth:`precmd` implementation may re-write the command or simply return "
"*line* unchanged."
msgstr ""
"钩方法在命令行 *line* 被解释之前执行，但是在输入提示被生成和发出后。这个方法是一个在 :class:`Cmd` "
"中的存根；它的存在是为了被子类覆盖。返回值被用作  :meth:`onecmd` 方法执行的命令； :meth:`precmd` "
"的实现或许会重写命令或者简单的返回 *line* 不变。"

#: ../../library/cmd.rst:156
msgid ""
"Hook method executed just after a command dispatch is finished.  This method"
" is a stub in :class:`Cmd`; it exists to be overridden by subclasses.  "
"*line* is the command line which was executed, and *stop* is a flag which "
"indicates whether execution will be terminated after the call to "
":meth:`postcmd`; this will be the return value of the :meth:`onecmd` method."
"  The return value of this method will be used as the new value for the "
"internal flag which corresponds to *stop*; returning false will cause "
"interpretation to continue."
msgstr ""
"钩方法只在命令调度完成后执行。这个方法是一个在 :class:`Cmd` 中的存根；它的存在是为了子类被覆盖。 *line* 是被执行的命令行， "
"*stop* 是一个表示在调用 :meth:`postcmd` 之后是否终止执行的标志；这将作为 :meth:`onecmd` "
"方法的返回值。这个方法的返回值被用作与 *stop* 相关联的内部标志的新值；返回 false 将导致解释继续。"

#: ../../library/cmd.rst:167
msgid ""
"Hook method executed once when :meth:`cmdloop` is called.  This method is a "
"stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr "钩方法当 :meth:`cmdloop` 被调用时执行一次。方法是一个在 :class:`Cmd` 中的存根；它的存在是为了被子类覆盖。"

#: ../../library/cmd.rst:173
msgid ""
"Hook method executed once when :meth:`cmdloop` is about to return. This "
"method is a stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
"钩方法在 :meth:`cmdloop` 即将返回时执行一次。这个方法是一个在 :class:`Cmd` 中的存根；它的存在是为了被子类覆盖。"

#: ../../library/cmd.rst:177
msgid ""
"Instances of :class:`Cmd` subclasses have some public instance variables:"
msgstr " :class:`Cmd` 的子类的实例有一些公共实例变量："

#: ../../library/cmd.rst:181
msgid "The prompt issued to solicit input."
msgstr "发出提示以请求输入。"

#: ../../library/cmd.rst:186
msgid "The string of characters accepted for the command prefix."
msgstr "接受命令前缀的字符串。"

#: ../../library/cmd.rst:191
msgid "The last nonempty command prefix seen."
msgstr "看到最后一个非空命令前缀。"

#: ../../library/cmd.rst:196
msgid ""
"A list of queued input lines.  The cmdqueue list is checked in "
":meth:`cmdloop` when new input is needed; if it is nonempty, its elements "
"will be processed in order, as if entered at the prompt."
msgstr ""
"排队的输入行列表。当需要新的输入时，在 :meth:`cmdloop` 中检查 cmdqueue "
"列表；如果它不是空的，它的元素将被按顺序处理，就像在提示符处输入一样。"

#: ../../library/cmd.rst:203
msgid ""
"A string to issue as an intro or banner.  May be overridden by giving the "
":meth:`cmdloop` method an argument."
msgstr "要作为简介或横幅发出的字符串。 可以通过给 :meth:`cmdloop` 方法一个参数来覆盖它。"

#: ../../library/cmd.rst:209
msgid ""
"The header to issue if the help output has a section for documented "
"commands."
msgstr "如果帮助输出具有记录命令的段落，则发出头文件。"

#: ../../library/cmd.rst:214
msgid ""
"The header to issue if the help output has a section for miscellaneous  help"
" topics (that is, there are :meth:`!help_\\*` methods without corresponding "
":meth:`!do_\\*` methods)."
msgstr ""
"如果帮助输出包含一个杂项帮助主题小节时（也就是说，存在没有对应 :meth:`!do_\\*` 方法的 :meth:`!help_\\*` "
"方法）要发出的标题。"

#: ../../library/cmd.rst:221
msgid ""
"The header to issue if the help output has a section for undocumented  "
"commands (that is, there are :meth:`!do_\\*` methods without corresponding "
":meth:`!help_\\*` methods)."
msgstr ""
"如果帮助输出包含一个未写入文档的命令小节时（也就是说，存在没有对应 :meth:`!help_\\*` 方法的 :meth:`!do_\\*` "
"方法）要发出的标题。"

#: ../../library/cmd.rst:228
msgid ""
"The character used to draw separator lines under the help-message headers.  "
"If empty, no ruler line is drawn.  It defaults to ``'='``."
msgstr "用于在帮助信息标题的下方绘制分隔符的字符，如果为空，则不绘制标尺线。这个字符默认是 ``'='`` 。"

#: ../../library/cmd.rst:234
msgid ""
"A flag, defaulting to true.  If true, :meth:`cmdloop` uses :func:`input` to "
"display a prompt and read the next command; if false, "
":data:`sys.stdout.write() <sys.stdout>` and :data:`sys.stdin.readline() "
"<sys.stdin>` are used. (This means that by importing :mod:`readline`, on "
"systems that support it, the interpreter will automatically support "
":program:`Emacs`\\ -like line editing  and command-history keystrokes.)"
msgstr ""
"一个旗标，默认为真值。 如为真值，:meth:`cmdloop` 将使用 :func:`input` 显示一条提示并读取下一个命令；如为假值，则将使用 "
":data:`sys.stdout.write() <sys.stdout>` 和 :data:`sys.stdin.readline() "
"<sys.stdin>`。 （这意味着通过在受支持的系统上导入 :mod:`readline`，解释器将自动支持类似 :program:`Emacs` "
"的行编辑和命令历史按键操作。）"

#: ../../library/cmd.rst:244
msgid "Cmd Example"
msgstr "Cmd 例子"

#: ../../library/cmd.rst:248
msgid ""
"The :mod:`cmd` module is mainly useful for building custom shells that let a"
" user work with a program interactively."
msgstr " :mod:`cmd` 模块主要被用于构建自定义 shell 让用户以交互的方式使用一个程序。"

#: ../../library/cmd.rst:251
msgid ""
"This section presents a simple example of how to build a shell around a few "
"of the commands in the :mod:`turtle` module."
msgstr "这部分提供了一个简单的例子来介绍如何使用一部分在 :mod:`turtle` 模块中的命令构建一个 shell 。"

#: ../../library/cmd.rst:254
msgid ""
"Basic turtle commands such as :meth:`~turtle.forward` are added to a "
":class:`Cmd` subclass with method named :meth:`!do_forward`.  The argument "
"is converted to a number and dispatched to the turtle module.  The docstring"
" is used in the help utility provided by the shell."
msgstr ""
"基本 turtle 命令比如 :meth:`~turtle.forward` 将被添加到一个具有名为 :meth:`!do_forward` 的方法的 "
":class:`Cmd` 子类。 参数将被转换为数字并发送给 turtle 模块。 文档字符串将被用于 shell 所提供的帮助工具。"

#: ../../library/cmd.rst:259
msgid ""
"The example also includes a basic record and playback facility implemented "
"with the :meth:`~Cmd.precmd` method which is responsible for converting the "
"input to lowercase and writing the commands to a file.  The "
":meth:`!do_playback` method reads the file and adds the recorded commands to"
" the :attr:`~Cmd.cmdqueue` for immediate playback::"
msgstr ""
"该示例还包括一个通过 :meth:`~Cmd.precmd` 方法实现的基本录制和回放工具，这个方法负责将输入转换为小写形式并将命令写入到文件。 "
":meth:`!do_playback` 方法将读取文件并将被录制的命令添加到 :attr:`~Cmd.cmdqueue` 用于立即回放::"

#: ../../library/cmd.rst:265
msgid ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Welcome to the turtle shell.   Type help or ? to list commands.\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- basic turtle commands -----\n"
"    def do_forward(self, arg):\n"
"        'Move the turtle forward by the specified distance:  FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Turn turtle right by given number of degrees:  RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Turn turtle left by given number of degrees:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Move turtle to an absolute position with changing orientation.  GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Return turtle to the home position:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Draw circle with given radius an options extent and steps:  CIRCLE 50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Print the current turtle position:  POSITION'\n"
"        print('Current position is %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Print the current turtle heading in degrees:  HEADING'\n"
"        print('Current heading is %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Set the color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Undo (repeatedly) the last turtle action(s):  UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Clear the screen and return turtle to center:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Stop recording, close the turtle window, and exit:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- record and playback -----\n"
"    def do_record(self, arg):\n"
"        'Save future commands to filename:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Playback commands from a file:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convert a series of zero or more numbers to an argument tuple'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"
msgstr ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Welcome to the turtle shell.   Type help or ? to list commands.\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- 基本 turtle 命令 -----\n"
"    def do_forward(self, arg):\n"
"        'Move the turtle forward by the specified distance:  FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Turn turtle right by given number of degrees:  RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Turn turtle left by given number of degrees:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Move turtle to an absolute position with changing orientation.  GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Return turtle to the home position:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Draw circle with given radius an options extent and steps:  CIRCLE 50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Print the current turtle position:  POSITION'\n"
"        print('Current position is %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Print the current turtle heading in degrees:  HEADING'\n"
"        print('Current heading is %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Set the color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Undo (repeatedly) the last turtle action(s):  UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Clear the screen and return turtle to center:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Stop recording, close the turtle window, and exit:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- 记录和回放 -----\n"
"    def do_record(self, arg):\n"
"        'Save future commands to filename:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Playback commands from a file:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convert a series of zero or more numbers to an argument tuple'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"

#: ../../library/cmd.rst:340
msgid ""
"Here is a sample session with the turtle shell showing the help functions, "
"using blank lines to repeat commands, and the simple record and playback "
"facility:"
msgstr "这是一个示例会话，其中 turtle shell 显示帮助功能，使用空行重复命令，以及简单的记录和回放功能："

#: ../../library/cmd.rst:343
msgid ""
"Welcome to the turtle shell.   Type help or ? to list commands.\n"
"\n"
"(turtle) ?\n"
"\n"
"Documented commands (type help <topic>):\n"
"========================================\n"
"bye     color    goto     home  playback  record  right\n"
"circle  forward  heading  left  position  reset   undo\n"
"\n"
"(turtle) help forward\n"
"Move the turtle forward by the specified distance:  FORWARD 10\n"
"(turtle) record spiral.cmd\n"
"(turtle) position\n"
"Current position is 0 0\n"
"\n"
"(turtle) heading\n"
"Current heading is 0\n"
"\n"
"(turtle) reset\n"
"(turtle) circle 20\n"
"(turtle) right 30\n"
"(turtle) circle 40\n"
"(turtle) right 30\n"
"(turtle) circle 60\n"
"(turtle) right 30\n"
"(turtle) circle 80\n"
"(turtle) right 30\n"
"(turtle) circle 100\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) heading\n"
"Current heading is 180\n"
"\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 500\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 300\n"
"(turtle) playback spiral.cmd\n"
"Current position is 0 0\n"
"\n"
"Current heading is 0\n"
"\n"
"Current heading is 180\n"
"\n"
"(turtle) bye\n"
"Thank you for using Turtle"
msgstr ""
"Welcome to the turtle shell.   Type help or ? to list commands.\n"
"\n"
"(turtle) ?\n"
"\n"
"Documented commands (type help <topic>):\n"
"========================================\n"
"bye     color    goto     home  playback  record  right\n"
"circle  forward  heading  left  position  reset   undo\n"
"\n"
"(turtle) help forward\n"
"Move the turtle forward by the specified distance:  FORWARD 10\n"
"(turtle) record spiral.cmd\n"
"(turtle) position\n"
"Current position is 0 0\n"
"\n"
"(turtle) heading\n"
"Current heading is 0\n"
"\n"
"(turtle) reset\n"
"(turtle) circle 20\n"
"(turtle) right 30\n"
"(turtle) circle 40\n"
"(turtle) right 30\n"
"(turtle) circle 60\n"
"(turtle) right 30\n"
"(turtle) circle 80\n"
"(turtle) right 30\n"
"(turtle) circle 100\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) heading\n"
"Current heading is 180\n"
"\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 500\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 300\n"
"(turtle) playback spiral.cmd\n"
"Current position is 0 0\n"
"\n"
"Current heading is 0\n"
"\n"
"Current heading is 180\n"
"\n"
"(turtle) bye\n"
"Thank you for using Turtle"

#: ../../library/cmd.rst:74
msgid "? (question mark)"
msgstr "? (问号)"

#: ../../library/cmd.rst:74
msgid "in a command interpreter"
msgstr "在命令解释器中"

#: ../../library/cmd.rst:74
msgid "! (exclamation)"
msgstr "! (感叹号)"
