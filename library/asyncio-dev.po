# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-dev.rst:7
msgid "Developing with asyncio"
msgstr "用 asyncio 开发"

#: ../../library/asyncio-dev.rst:9
msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr "异步编程与传统的“顺序”编程不同。"

#: ../../library/asyncio-dev.rst:12
msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr "本页列出常见的错误和陷阱，并解释如何避免它们。"

#: ../../library/asyncio-dev.rst:19
msgid "Debug Mode"
msgstr "Debug 模式"

#: ../../library/asyncio-dev.rst:21
msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr "默认情况下，asyncio以生产模式运行。为了简化开发，asyncio还有一种*debug 模式* 。"

#: ../../library/asyncio-dev.rst:24
msgid "There are several ways to enable asyncio debug mode:"
msgstr "有几种方法可以启用异步调试模式:"

#: ../../library/asyncio-dev.rst:26
msgid ""
"Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr "将 :envvar:`PYTHONASYNCIODEBUG` 环境变量设置为 ``1`` 。"

#: ../../library/asyncio-dev.rst:28
msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "使用 :ref:`Python 开发模式 <devmode>`。"

#: ../../library/asyncio-dev.rst:30
msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "将 ``debug=True`` 传递给 :func:`asyncio.run` 。"

#: ../../library/asyncio-dev.rst:32
msgid "Calling :meth:`loop.set_debug`."
msgstr "调用 :meth:`loop.set_debug` 。"

#: ../../library/asyncio-dev.rst:34
msgid "In addition to enabling the debug mode, consider also:"
msgstr "除了启用调试模式外，还要考虑:"

#: ../../library/asyncio-dev.rst:36
msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to "
":py:const:`logging.DEBUG`, for example the following snippet of code can be "
"run at startup of the application::"
msgstr ""
"将 :ref:`asyncio logger <asyncio-logger>` 的级别设为 "
":py:const:`logging.DEBUG`，例如下面的代码片段可以在应用程序启动时运行::"

#: ../../library/asyncio-dev.rst:40
msgid "logging.basicConfig(level=logging.DEBUG)"
msgstr "logging.basicConfig(level=logging.DEBUG)"

#: ../../library/asyncio-dev.rst:42
msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"配置 :mod:`warnings` 模块以显示 :exc:`ResourceWarning` 警告。一种方法是使用 :option:`-W` "
"``default`` 命令行选项。"

#: ../../library/asyncio-dev.rst:47
msgid "When the debug mode is enabled:"
msgstr "启用调试模式时:"

#: ../../library/asyncio-dev.rst:49
msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and "
":meth:`loop.call_at` methods) raise an exception if they are called from a "
"wrong thread."
msgstr ""
"许多非线程安全的异步 APIs (例如 :meth:`loop.call_soon` 和 :meth:`loop.call_at` "
"方法)，如果从错误的线程调用，则会引发异常。"

#: ../../library/asyncio-dev.rst:53
msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr "如果执行I/O操作花费的时间太长，则记录I/O选择器的执行时间。"

#: ../../library/asyncio-dev.rst:56
msgid ""
"Callbacks taking longer than 100 milliseconds are logged.  The "
":attr:`loop.slow_callback_duration` attribute can be used to set the minimum"
" execution duration in seconds that is considered \"slow\"."
msgstr ""
"执行时间超过 100 毫秒的回调会被写入日志。 :attr:`loop.slow_callback_duration` "
"属性可用于设置以秒为单位的将被视为“缓慢”的最小执行持续时间。"

#: ../../library/asyncio-dev.rst:64
msgid "Concurrency and Multithreading"
msgstr "并发性和多线程"

#: ../../library/asyncio-dev.rst:66
msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"事件循环在线程中运行(通常是主线程)，并在其线程中执行所有回调和任务。当一个任务在事件循环中运行时，没有其他任务可以在同一个线程中运行。当一个任务执行一个"
" ``await`` 表达式时，正在运行的任务被挂起，事件循环执行下一个任务。"

#: ../../library/asyncio-dev.rst:72
msgid ""
"To schedule a :term:`callback` from another OS thread, the "
":meth:`loop.call_soon_threadsafe` method should be used. Example::"
msgstr ""
"要调度来自另一 OS 线程的 :term:`callback`，应该使用 :meth:`loop.call_soon_threadsafe` 方法。 "
"例如::"

#: ../../library/asyncio-dev.rst:75
msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr "loop.call_soon_threadsafe(callback, *args)"

#: ../../library/asyncio-dev.rst:77
msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"几乎所有异步对象都不是线程安全的，这通常不是问题，除非在任务或回调函数之外有代码可以使用它们。如果需要这样的代码来调用低级异步API，应该使用 "
":meth:`loop.call_soon_threadsafe` 方法，例如::"

#: ../../library/asyncio-dev.rst:83
msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr "loop.call_soon_threadsafe(fut.cancel)"

#: ../../library/asyncio-dev.rst:85
msgid ""
"To schedule a coroutine object from a different OS thread, the "
":func:`run_coroutine_threadsafe` function should be used. It returns a "
":class:`concurrent.futures.Future` to access the result::"
msgstr ""
"要从不同的OS线程调度一个协程对象，应该使用 :func:`run_coroutine_threadsafe` 函数。它返回一个 "
":class:`concurrent.futures.Future` 。查询结果::"

#: ../../library/asyncio-dev.rst:89
msgid ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"
msgstr ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# 随后在另一个 OS 线程中：\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# 等待结果：\n"
"result = future.result()"

#: ../../library/asyncio-dev.rst:98
msgid "To handle signals the event loop must be run in the main thread."
msgstr "为了能处理信号事件循环必须在主线程中运行。"

#: ../../library/asyncio-dev.rst:101
msgid ""
"The :meth:`loop.run_in_executor` method can be used with a "
":class:`concurrent.futures.ThreadPoolExecutor` to execute blocking code in a"
" different OS thread without blocking the OS thread that the event loop runs"
" in."
msgstr ""
"方法 :meth:`loop.run_in_executor` 可以和 "
":class:`concurrent.futures.ThreadPoolExecutor` "
"一起使用，用于在一个不同的操作系统线程中执行阻塞代码，并避免阻塞运行事件循环的那个操作系统线程。"

#: ../../library/asyncio-dev.rst:106
msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The "
":ref:`asyncio-event-loop-methods` section lists APIs that can read from "
"pipes and watch file descriptors without blocking the event loop. In "
"addition, asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a "
"way to start a process and communicate with it from the event loop. Lastly, "
"the aforementioned :meth:`loop.run_in_executor` method can also be used with"
" a :class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"目前没有办法直接从另一个进程（如使用 :mod:`multiprocessing` 启动的进程）安排协程或回调。 :ref:`asyncio-"
"event-loop-methods` 小节列出了一些可以从管道读取并监视文件描述符而不会阻塞事件循环的 API。 此外，asyncio 的 "
":ref:`子进程 <asyncio-subprocess>` API 提供了一种启动进程并在事件循环中与其通信的办法。 最后，之前提到的 "
":meth:`loop.run_in_executor` 方法也可以配合 "
":class:`concurrent.futures.ProcessPoolExecutor` 使用以在另一个进程中执行代码。"

#: ../../library/asyncio-dev.rst:120
msgid "Running Blocking Code"
msgstr "运行阻塞的代码"

#: ../../library/asyncio-dev.rst:122
msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"不应该直接调用阻塞( CPU 绑定)代码。例如，如果一个函数执行1秒的 CPU 密集型计算，那么所有并发异步任务和 IO 操作都将延迟1秒。"

#: ../../library/asyncio-dev.rst:127
msgid ""
"An executor can be used to run a task in a different thread or even in a "
"different process to avoid blocking the OS thread with the event loop.  See "
"the :meth:`loop.run_in_executor` method for more details."
msgstr ""
"可以用执行器在不同的线程甚至不同的进程中运行任务，以避免使用事件循环阻塞 OS 线程。 请参阅 :meth:`loop.run_in_executor`"
" 方法了解详情。"

#: ../../library/asyncio-dev.rst:136
msgid "Logging"
msgstr "日志记录"

#: ../../library/asyncio-dev.rst:138
msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr "asyncio使用 :mod:`logging` 模块，所有日志记录都是通过 ``\"asyncio\"`` logger执行的。"

#: ../../library/asyncio-dev.rst:141
msgid ""
"The default log level is :py:const:`logging.INFO`, which can be easily "
"adjusted::"
msgstr "默认的日志级别是 :py:const:`logging.INFO`，它可以被方便地调整::"

#: ../../library/asyncio-dev.rst:144
msgid "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"
msgstr "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"

#: ../../library/asyncio-dev.rst:147
msgid ""
"Network logging can block the event loop. It is recommended to use a "
"separate thread for handling logs or use non-blocking IO. For example, see "
":ref:`blocking-handlers`."
msgstr ""
"网络日志会阻塞事件循环。 建议使用一个单独进程来处理日志或者使用非阻塞式 IO。 例如，可以参阅 :ref:`blocking-handlers`。"

#: ../../library/asyncio-dev.rst:155
msgid "Detect never-awaited coroutines"
msgstr "检测 never-awaited 协同程序"

#: ../../library/asyncio-dev.rst:157
msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with "
":meth:`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"当协程函数被调用而不是被等待时 (即执行 ``coro()`` 而不是 ``await coro()``) 或者协程没有通过 "
":meth:`asyncio.create_task` 被排入计划日程，asyncio 将会发出一条 :exc:`RuntimeWarning`::"

#: ../../library/asyncio-dev.rst:162
msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:172 ../../library/asyncio-dev.rst:217
msgid "Output::"
msgstr "输出::"

#: ../../library/asyncio-dev.rst:174
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"

#: ../../library/asyncio-dev.rst:177 ../../library/asyncio-dev.rst:233
msgid "Output in debug mode::"
msgstr "调试模式的输出::"

#: ../../library/asyncio-dev.rst:179
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"

#: ../../library/asyncio-dev.rst:190
msgid ""
"The usual fix is to either await the coroutine or call the "
":meth:`asyncio.create_task` function::"
msgstr "通常的修复方法是等待协程或者调用 :meth:`asyncio.create_task` 函数::"

#: ../../library/asyncio-dev.rst:193
msgid ""
"async def main():\n"
"    await test()"
msgstr ""
"async def main():\n"
"    await test()"

#: ../../library/asyncio-dev.rst:198
msgid "Detect never-retrieved exceptions"
msgstr "检测就再也没异常"

#: ../../library/asyncio-dev.rst:200
msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"如果调用 :meth:`Future.set_exception` ，但不等待 Future 对象，将异常传播到用户代码。在这种情况下，当 Future"
" 对象被垃圾收集时，asyncio将发出一条日志消息。"

#: ../../library/asyncio-dev.rst:205
msgid "Example of an unhandled exception::"
msgstr "未处理异常的例子::"

#: ../../library/asyncio-dev.rst:207
msgid ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:219
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"

#: ../../library/asyncio-dev.rst:228
msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where"
" the task was created::"
msgstr ":ref:`激活调试模式 <asyncio-debug-mode>` 以获取任务创建处的跟踪信息::"

#: ../../library/asyncio-dev.rst:231
msgid "asyncio.run(main(), debug=True)"
msgstr "asyncio.run(main(), debug=True)"

#: ../../library/asyncio-dev.rst:235
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
