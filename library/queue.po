# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/queue.rst:2
msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ":mod:`!queue` --- 同步队列类"

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**源代码:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It"
" is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this"
" module implements all the required locking semantics."
msgstr ""
":mod:`queue` 模块实现了多生产者、多消费者队列。这特别适用于消息必须安全地在多线程间交换的线程编程。模块中的 :class:`Queue` "
"类实现了所有所需的锁定语义。"

#: ../../library/queue.rst:16
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)`"
" queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"本模块实现了三种类型的队列，它们的区别仅仅是条目的提取顺序。 在 :abbr:`FIFO (first-in, first-out)` "
"队列中，先添加的任务会先被提取。 在 :abbr:`LIFO (last-in, first-out)` 队列中，最近添加的条目会先被提取 "
"(类似于一个栈)。 在优先级队列中，条目将保持已排序状态 (使用 :mod:`heapq` 模块) 并且值最小的条目会先被提取。"

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr "在内部，这三个类型的队列使用锁来临时阻塞竞争线程；然而，它们并未被设计用于线程的重入性处理。"

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, "
"first-out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"此外，模块实现了一个 \"简单的\"  :abbr:`FIFO (first-in, first-out)` 队列类型， "
":class:`SimpleQueue` ，这个特殊实现为小功能在交换中提供额外的保障。"

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr ":mod:`queue` 模块定义了下列类和异常："

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an"
" integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero,"
" the queue size is infinite."
msgstr ""
" :abbr:`FIFO (first-in, first-out)` 队列构造函数。 *maxsize* "
"是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 *maxsize* "
"小于等于零，队列尺寸为无限大。"

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero,"
" the queue size is infinite."
msgstr ""
":abbr:`LIFO (last-in, first-out)` 队列构造函数。 *maxsize* "
"是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 *maxsize* "
"小于等于零，队列尺寸为无限大。"

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"优先级队列构造函数。 *maxsize* "
"是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 *maxsize* "
"小于等于零，队列尺寸为无限大。"

#: ../../library/queue.rst:59
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"值最小的条目会先被提取 (值最小的条目是由the lowest valued entry is the one that would be "
"returned by ``min(entries)`` 返回的)。 条目的典型模式是如下形式的元组: ``(priority_number, "
"data)``。"

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr "如果 *data* 元素没有可比性，数据将被包装在一个类中，忽略数据值，仅仅比较优先级数字 ："

#: ../../library/queue.rst:66
msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr "无界的 :abbr:`FIFO (first-in, first-out)` 队列构造函数。简单的队列，缺少任务跟踪等高级功能。"

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or "
":meth:`~Queue.get_nowait`) is called on a :class:`Queue` object which is "
"empty."
msgstr ""
"对空的 :class:`Queue` 对象，调用非阻塞的 :meth:`~Queue.get` (or  "
":meth:`~Queue.get_nowait`) 时，引发的异常。"

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or "
":meth:`~Queue.put_nowait`) is called on a :class:`Queue` object which is "
"full."
msgstr ""
"对满的 :class:`Queue` 对象，调用非阻塞的 :meth:`~Queue.put` (or "
":meth:`~Queue.put_nowait`) 时，引发的异常。"

#: ../../library/queue.rst:98
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a :class:`Queue` object which has been shut down."
msgstr ""
"当在已被关闭的 :class:`Queue` 对象上调用 :meth:`~Queue.put` 或 :meth:`~Queue.get` 时引发的异常。"

#: ../../library/queue.rst:107
msgid "Queue Objects"
msgstr "Queue对象"

#: ../../library/queue.rst:109
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or "
":class:`PriorityQueue`) provide the public methods described below."
msgstr ""
"队列对象 (:class:`Queue`, :class:`LifoQueue`, 或者 :class:`PriorityQueue`) "
"提供下列描述的公共方法。"

#: ../../library/queue.rst:115
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize"
" guarantee that put() will not block."
msgstr ""
"返回队列的大致大小。注意，qsize() > 0 不保证后续的 get() 不被阻塞，qsize() < maxsize 也不保证 put() "
"不被阻塞。"

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"如果队列为空，返回 ``True`` ，否则返回 ``False`` 。如果 empty() 返回 ``True`` ，不保证后续调用的 put() "
"不被阻塞。类似的，如果 empty() 返回 ``False`` ，也不保证后续调用的 get() 不被阻塞。"

#: ../../library/queue.rst:130
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that"
" a subsequent call to put() will not block."
msgstr ""
"如果队列是满的返回 ``True`` ，否则返回 ``False`` 。如果 full() 返回 ``True`` 不保证后续调用的 get() "
"不被阻塞。类似的，如果 full() 返回 ``False`` 也不保证后续调用的 put() 不被阻塞。"

#: ../../library/queue.rst:138
msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"将 *item* 加入队列。 如果可选参数 *block* 为真值并且 *timeout* 为 ``None`` "
"(默认值)，则会在必要时阻塞直到有空闲槽位可用。 如为 *timeout* 为正数，则将阻塞最多 *timeout* 秒并会在没有可用的空闲槽位时引发 "
":exc:`Full` 异常。 在其他情况下 (*block* 为假值)，则如果空闲槽位立即可用则将条目加入队列，否则将引发 :exc:`Full` "
"异常 (*timeout* 在此情况下将被忽略)。"

#: ../../library/queue.rst:146
msgid "Raises :exc:`ShutDown` if the queue has been shut down."
msgstr "如果队列已被关闭则会引发 :exc:`ShutDown`。"

#: ../../library/queue.rst:151
msgid "Equivalent to ``put(item, block=False)``."
msgstr "相当于 ``put(item, block=False)``。"

#: ../../library/queue.rst:156 ../../library/queue.rst:297
msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is"
" available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"从队列中移除并返回一个项目。如果可选参数 *block* 是 true 并且 *timeout* 是 ``None`` "
"(默认值)，则在必要时阻塞至项目可得到。如果 *timeout* 是个正数，将最多阻塞 *timeout* 秒，如果在这段时间内项目不能得到，将引发 "
":exc:`Empty` 异常。反之 (*block* 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 :exc:`Empty`"
" 异常 (这种情况下，*timeout* 将被忽略)。"

#: ../../library/queue.rst:163
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a "
":exc:`KeyboardInterrupt`."
msgstr ""
"POSIX 系统上在 3.0 之前，以及在 Windows 上的所有版本中，如果 *block* 为真值并且 *timeout* 为 "
"``None``，此操作将进入在底层锁上的不可中断的等待。 这意味着不会发生任何异常，特别是 SIGINT 将不会触发 "
":exc:`KeyboardInterrupt`。"

#: ../../library/queue.rst:168
msgid ""
"Raises :exc:`ShutDown` if the queue has been shut down and is empty, or if "
"the queue has been shut down immediately."
msgstr "如果队列已被关闭并且为空，或者如果队列已被立即关闭则会引发 :exc:`ShutDown`。"

#: ../../library/queue.rst:174 ../../library/queue.rst:307
msgid "Equivalent to ``get(False)``."
msgstr "相当于 ``get(False)`` 。"

#: ../../library/queue.rst:176
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been"
" fully processed by daemon consumer threads."
msgstr "提供了两个方法，用于支持跟踪 排队的任务 是否 被守护的消费者线程 完整的处理。"

#: ../../library/queue.rst:182
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to "
":meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 :meth:`get` 被用于获取一个任务， 后续调用 :meth:`task_done` "
"告诉队列，该任务的处理已经完成。"

#: ../../library/queue.rst:186
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every"
" item that had been :meth:`put` into the queue)."
msgstr ""
"如果 :meth:`join` 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 :meth:`put` 进队列的条目的 "
":meth:`task_done` 都被收到)。"

#: ../../library/queue.rst:190
msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining item"
" in the queue."
msgstr "``shutdown(immediate=True)`` 将为队列中每个剩余的项调用 :meth:`task_done`。"

#: ../../library/queue.rst:193
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "如果被调用的次数多于放入队列中的项目数量，将引发 :exc:`ValueError` 异常 。"

#: ../../library/queue.rst:199
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "阻塞至队列中所有的元素都被接收和处理完毕。"

#: ../../library/queue.rst:201
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls "
":meth:`task_done` to indicate that the item was retrieved and all work on it"
" is complete.  When the count of unfinished tasks drops to zero, "
":meth:`join` unblocks."
msgstr ""
"当一个条目被添加到队列的时候未完成任务的计数将会增加。 每当一个消费者线程调用 :meth:`task_done` "
"来表明该条目已被提取且其上的所有工作已完成时未完成计数将会减少。 当未完成计数降为零时，:meth:`join` 将解除阻塞。"

#: ../../library/queue.rst:207
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "如何等待排队的任务被完成的示例："

#: ../../library/queue.rst:209
msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# 启动工作线程。\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# 向工作线程发送三十个任务请求。\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# 阻塞直到所有任务完成。\n"
"q.join()\n"
"print('All work completed')"

#: ../../library/queue.rst:234
msgid "Terminating queues"
msgstr "终结队列"

#: ../../library/queue.rst:236
msgid ""
":class:`Queue` objects can be made to prevent further interaction by "
"shutting them down."
msgstr ":class:`Queue` 可以通过将其关闭以防止继续交互。"

#: ../../library/queue.rst:241
msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` raise "
":exc:`ShutDown`."
msgstr "关闭队列，让 :meth:`~Queue.get` 和 :meth:`~Queue.put` 引发 :exc:`ShutDown`。"

#: ../../library/queue.rst:244
msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once the"
" queue is empty. Set *immediate* to true to make :meth:`~Queue.get` raise "
"immediately instead."
msgstr ""
"在默认情况下，在已关闭的队列上执行 :meth:`~Queue.get` 只会在队列为空时引发异常。 将 *immediate* 设为真值以改为让 "
":meth:`~Queue.get` 立即引发异常。"

#: ../../library/queue.rst:248
msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each "
"remaining item in the queue, which may unblock callers of "
":meth:`~Queue.join`."
msgstr ""
"所有 :meth:`~Queue.put` 和 :meth:`~Queue.get` 被阻塞的调用方将被撤销阻塞。 如果 *immediate* "
"为真值，一个任务将对队列中每个剩余的项标记为已完成，它可能撤销对 :meth:`~Queue.join` 的调用方的阻塞。"

#: ../../library/queue.rst:257
msgid "SimpleQueue Objects"
msgstr "SimpleQueue 对象"

#: ../../library/queue.rst:259
msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ":class:`SimpleQueue` 对象提供下列描述的公共方法。"

#: ../../library/queue.rst:263
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr "返回队列的大致大小。注意，qsize() > 0 不保证后续的 get() 不被阻塞。"

#: ../../library/queue.rst:269
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"如果队列为空则返回 ``True``，否则返回 ``False``。 如果 empty() 返回 ``False`` 则不保证后续对 get() "
"的调用将不会阻塞。"

#: ../../library/queue.rst:276
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"将 *item* 放入队列。此方法永不阻塞，始终成功（除了潜在的低级错误，例如内存分配失败）。可选参数 *block* 和 *timeout* "
"仅仅是为了保持 :meth:`Queue.put` 的兼容性而提供，其值被忽略。"

#: ../../library/queue.rst:282
msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()``"
" or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods"
" or :mod:`weakref` callbacks."
msgstr ""
"此方法具有一个可重入的 C 实现。 也就是说，一个 ``put()`` 或 ``get()`` 调用可以被同一线程中的另一个 ``put()`` "
"调用打断而不会发生死锁或破坏队列内部的状态。 这使得它适用于析构器如 ``__del__`` 方法或 :mod:`weakref` 回调。"

#: ../../library/queue.rst:291
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with "
":meth:`Queue.put_nowait`."
msgstr "相当于 ``put(item, block=False)``，为保持与 :meth:`Queue.put_nowait` 的兼容性而提供。"

#: ../../library/queue.rst:312
msgid "Class :class:`multiprocessing.Queue`"
msgstr "类 :class:`multiprocessing.Queue`"

#: ../../library/queue.rst:313
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr "一个用于多进程上下文的队列类（而不是多线程）。"

#: ../../library/queue.rst:316
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and "
":meth:`~collections.deque.popleft` operations that do not require locking "
"and also support indexing."
msgstr ""
":class:`collections.deque` 是无界队列的一个替代实现，具有快速的不需要锁并且支持索引的原子化 "
":meth:`~collections.deque.append` 和 :meth:`~collections.deque.popleft` 操作。"
