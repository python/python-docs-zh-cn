# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-09-18 09:12+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Shengjing Zhu <zsj950618@gmail.com>, 2018\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr ""

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""

#: ../../library/asyncio-task.rst:19
msgid "Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:21
msgid ""
"Coroutines declared with async/await syntax is the preferred way of writing "
"asyncio applications.  For example, the following snippet of code prints "
"\"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""

#: ../../library/asyncio-task.rst:36
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""

#: ../../library/asyncio-task.rst:42
msgid "To actually run a coroutine asyncio provides three main mechanisms:"
msgstr ""

#: ../../library/asyncio-task.rst:44
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\""
" function (see the above example.)"
msgstr ""

#: ../../library/asyncio-task.rst:47
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\""
" after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""

#: ../../library/asyncio-task.rst:68
msgid "Expected output::"
msgstr ""

#: ../../library/asyncio-task.rst:75
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:78
msgid ""
"Let's modify the above example and run two \"set_after\" coroutines "
"*concurrently*::"
msgstr ""

#: ../../library/asyncio-task.rst:97
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""

#: ../../library/asyncio-task.rst:105
msgid ""
"Note that in this documentation the term \"coroutine\" can be used for two "
"closely related concepts:"
msgstr ""

#: ../../library/asyncio-task.rst:108
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr ""

#: ../../library/asyncio-task.rst:110
msgid ""
"a *coroutine object*: object returned by calling a *coroutine function*."
msgstr ""

#: ../../library/asyncio-task.rst:115
msgid "Running an asyncio Program"
msgstr ""

#: ../../library/asyncio-task.rst:119
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio"
" event loop and finalizing asynchronous generators."
msgstr ""

#: ../../library/asyncio-task.rst:123
msgid ""
"This function cannot be called when another asyncio event loop is running in"
" the same thread."
msgstr ""

#: ../../library/asyncio-task.rst:126
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""

#: ../../library/asyncio-task.rst:128
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""

#: ../../library/asyncio-task.rst:132
msgid ""
"**Important:** this function has been added to asyncio in Python 3.7 on a "
":term:`provisional basis <provisional api>`."
msgstr ""

#: ../../library/asyncio-task.rst:138
msgid "Creating Tasks"
msgstr ""

#: ../../library/asyncio-task.rst:142
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a task and schedule its "
"execution. Return the task object."
msgstr ""

#: ../../library/asyncio-task.rst:145
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, "
":exc:`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""

#: ../../library/asyncio-task.rst:153
msgid "Sleeping"
msgstr ""

#: ../../library/asyncio-task.rst:157
msgid "Block for *delay* seconds."
msgstr ""

#: ../../library/asyncio-task.rst:159
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""

#: ../../library/asyncio-task.rst:164
msgid ""
"Example of coroutine displaying the current date every second for 5 "
"seconds::"
msgstr ""

#: ../../library/asyncio-task.rst:183
msgid "Running Tasks Concurrently"
msgstr ""

#: ../../library/asyncio-task.rst:187
msgid ""
"Return a Future aggregating results from the given coroutine objects, Tasks,"
" or Futures."
msgstr ""

#: ../../library/asyncio-task.rst:190
msgid ""
"If all Tasks/Futures are completed successfully, the result is an aggregate "
"list of returned values.  The result values are in the order of the original"
" *fs* sequence."
msgstr ""

#: ../../library/asyncio-task.rst:194
msgid ""
"All coroutines in the *fs* list are automatically scheduled as :class:`Tasks"
" <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:197
msgid ""
"If *return_exceptions* is ``True``, exceptions in the Tasks/Futures are "
"treated the same as successful results, and gathered in the result list.  "
"Otherwise, the first raised exception is immediately propagated to the "
"returned Future."
msgstr ""

#: ../../library/asyncio-task.rst:202
msgid ""
"If the outer Future is *cancelled*, all submitted Tasks/Futures (that have "
"not completed yet) are also *cancelled*."
msgstr ""

#: ../../library/asyncio-task.rst:205
msgid ""
"If any child is *cancelled*, it is treated as if it raised "
":exc:`CancelledError` -- the outer Future is **not** cancelled in this case."
"  This is to prevent the cancellation of one submitted Task/Future to cause "
"other Tasks/Futures to be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:210
msgid "All futures must share the same event loop."
msgstr ""

#: ../../library/asyncio-task.rst:212
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""

#: ../../library/asyncio-task.rst:218 ../../library/asyncio-task.rst:317
#: ../../library/asyncio-task.rst:400
msgid "Example::"
msgstr ""

#: ../../library/asyncio-task.rst:253
msgid "Shielding Tasks From Cancellation"
msgstr ""

#: ../../library/asyncio-task.rst:257
msgid "Wait for a Future/Task while protecting it from being cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:259 ../../library/asyncio-task.rst:297
msgid ""
"*fut* can be a coroutine, a Task, or a Future-like object.  If *fut* is a "
"coroutine it is automatically scheduled as a :class:`Task`."
msgstr ""

#: ../../library/asyncio-task.rst:263
msgid "The statement::"
msgstr ""

#: ../../library/asyncio-task.rst:267
msgid "is equivalent to::"
msgstr ""

#: ../../library/asyncio-task.rst:271
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a "
":exc:`CancelledError`."
msgstr ""

#: ../../library/asyncio-task.rst:277
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""

#: ../../library/asyncio-task.rst:280
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""

#: ../../library/asyncio-task.rst:291
msgid "Timeouts"
msgstr ""

#: ../../library/asyncio-task.rst:295
msgid "Wait for a coroutine, Task, or Future to complete with timeout."
msgstr ""

#: ../../library/asyncio-task.rst:301
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait"
" for.  If *timeout* is ``None``, block until the future completes."
msgstr ""

#: ../../library/asyncio-task.rst:305
msgid ""
"If a timeout occurs, it cancels the task and raises "
":exc:`asyncio.TimeoutError`."
msgstr ""

#: ../../library/asyncio-task.rst:308
msgid "To avoid the task cancellation, wrap it in :func:`shield`."
msgstr ""

#: ../../library/asyncio-task.rst:310
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*."
msgstr ""

#: ../../library/asyncio-task.rst:313
msgid "If the wait is cancelled, the future *fut* is also cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:337
msgid ""
"When *fut* is cancelled due to a timeout, ``wait_for`` waits for *fut* to be"
" cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""

#: ../../library/asyncio-task.rst:344
msgid "Waiting Primitives"
msgstr ""

#: ../../library/asyncio-task.rst:349
msgid "Wait for a set of coroutines, Tasks, or Futures to complete."
msgstr ""

#: ../../library/asyncio-task.rst:351
msgid ""
"*fs* is a list of coroutines, Futures, and/or Tasks.  Coroutines are "
"automatically scheduled as :class:`Tasks <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:354
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr ""

#: ../../library/asyncio-task.rst:356
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum"
" number of seconds to wait before returning."
msgstr ""

#: ../../library/asyncio-task.rst:359
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the"
" second set."
msgstr ""

#: ../../library/asyncio-task.rst:363
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants:"
msgstr ""

#: ../../library/asyncio-task.rst:369
msgid "Constant"
msgstr ""

#: ../../library/asyncio-task.rst:369
msgid "Description"
msgstr ""

#: ../../library/asyncio-task.rst:371
msgid ":const:`FIRST_COMPLETED`"
msgstr ""

#: ../../library/asyncio-task.rst:371
msgid "The function will return when any future finishes or is cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:374
msgid ":const:`FIRST_EXCEPTION`"
msgstr ""

#: ../../library/asyncio-task.rst:374
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""

#: ../../library/asyncio-task.rst:380
msgid ":const:`ALL_COMPLETED`"
msgstr ""

#: ../../library/asyncio-task.rst:380
msgid "The function will return when all futures finish or are cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:384
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""

#: ../../library/asyncio-task.rst:387
msgid "Usage::"
msgstr ""

#: ../../library/asyncio-task.rst:394
msgid ""
"Return an iterator of awaitables which return :class:`Future` instances."
msgstr ""

#: ../../library/asyncio-task.rst:397
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""

#: ../../library/asyncio-task.rst:408
msgid "Scheduling From Other Threads"
msgstr ""

#: ../../library/asyncio-task.rst:412
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""

#: ../../library/asyncio-task.rst:414
msgid "Return a :class:`concurrent.futures.Future` to access the result."
msgstr ""

#: ../../library/asyncio-task.rst:416
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""

#: ../../library/asyncio-task.rst:428
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""

#: ../../library/asyncio-task.rst:442
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "查看 :ref:`并发和多线程<asyncio-multithreading>` 章节的文档。"

#: ../../library/asyncio-task.rst:445
msgid ""
"Unlike other asyncio functions this functions requires the *loop* argument "
"to be passed explicitly."
msgstr ""

#: ../../library/asyncio-task.rst:452
msgid "Introspection"
msgstr ""

#: ../../library/asyncio-task.rst:457
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""

#: ../../library/asyncio-task.rst:460
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""

#: ../../library/asyncio-task.rst:468
msgid ""
"Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""

#: ../../library/asyncio-task.rst:471
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""

#: ../../library/asyncio-task.rst:478
msgid "Task Object"
msgstr ""

#: ../../library/asyncio-task.rst:482
msgid ""
"A :class:`Future`-like object that wraps a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""

#: ../../library/asyncio-task.rst:485
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""

#: ../../library/asyncio-task.rst:491
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""

#: ../../library/asyncio-task.rst:496
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""

#: ../../library/asyncio-task.rst:501
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:506
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method"
" returns ``True`` if the wrapped coroutine did not suppress the "
":exc:`CancelledError` exception and was actually cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:511
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except "
":meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""

#: ../../library/asyncio-task.rst:515
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""

#: ../../library/asyncio-task.rst:519
msgid "Added support for the :mod:`contextvars` module."
msgstr ""

#: ../../library/asyncio-task.rst:524
msgid "Request the Task to be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:526
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:529
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike "
":meth:`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task "
"will be cancelled, although suppressing cancellation completely is not "
"common and is actively discouraged."
msgstr ""

#: ../../library/asyncio-task.rst:539
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""

#: ../../library/asyncio-task.rst:578
msgid "Return ``True`` if the Task is *cancelled*."
msgstr ""

#: ../../library/asyncio-task.rst:580
msgid ""
"The Task is *cancelled* when the cancellation was requested with "
":meth:`cancel` and the wrapped coroutine propagated the "
":exc:`CancelledError` exception thrown into it."
msgstr ""

#: ../../library/asyncio-task.rst:586
msgid "Return ``True`` if the Task is *done*."
msgstr ""

#: ../../library/asyncio-task.rst:588
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:593
msgid "Return the list of stack frames for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:595
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception,"
" this returns the list of traceback frames."
msgstr ""

#: ../../library/asyncio-task.rst:601
msgid "The frames are always ordered from oldest to newest."
msgstr ""

#: ../../library/asyncio-task.rst:603
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr ""

#: ../../library/asyncio-task.rst:605
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""

#: ../../library/asyncio-task.rst:614
msgid "Print the stack or traceback for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:616
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""

#: ../../library/asyncio-task.rst:619
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr ""

#: ../../library/asyncio-task.rst:621
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""

#: ../../library/asyncio-task.rst:626
msgid "Return a set of all tasks for an event loop."
msgstr ""

#: ../../library/asyncio-task.rst:628
msgid ""
"By default all tasks for the current event loop are returned. If *loop* is "
"``None``, the :func:`get_event_loop` function is used to get the current "
"loop."
msgstr ""

#: ../../library/asyncio-task.rst:632
msgid ""
"This method is **deprecated** and will be removed in Python 3.9.  Use the "
":func:`all_tasks` function instead."
msgstr ""

#: ../../library/asyncio-task.rst:637
msgid "Return the currently running task or ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:639
msgid ""
"If *loop* is ``None``, the :func:`get_event_loop` function is used to get "
"the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:642
msgid ""
"This method is **deprecated** and will be removed in Python 3.9.  Use the "
":func:`current_task` function instead."
msgstr ""

#: ../../library/asyncio-task.rst:649
msgid "Generator-based Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:653
msgid ""
"Support for generator-based coroutines is **deprecated** and is scheduled "
"for removal in Python 4.0."
msgstr ""

#: ../../library/asyncio-task.rst:656
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other"
" coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:660
msgid ""
"Generator-based coroutines should be decorated with "
":func:`@asyncio.coroutine <asyncio.coroutine>`, although this is not "
"enforced."
msgstr ""

#: ../../library/asyncio-task.rst:667
msgid "Decorator to mark generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:669
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""

#: ../../library/asyncio-task.rst:679
msgid ""
"This decorator is **deprecated** and is scheduled for removal in Python 4.0."
msgstr ""

#: ../../library/asyncio-task.rst:682
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:687
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:689
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns"
" ``True`` for generator-based coroutines decorated with :func:`@coroutine "
"<coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:695
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:698
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it"
" returns ``True`` for generator-based coroutine functions decorated with "
":func:`@coroutine <coroutine>`."
msgstr ""
