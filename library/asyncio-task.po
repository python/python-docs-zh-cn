# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "协程与任务"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr "本节将简述用于协程与任务的高层级 API。"

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "协程"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "*源码：* :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints "
"\"world\"::"
msgstr ""
"通过 async/await 语法来声明 :term:`协程 <coroutine>` 是编写 asyncio 应用的推荐方式。 例如，以下代码段会打印"
" \"hello\"，等待 1 秒，再打印 \"world\"::"

#: ../../library/asyncio-task.rst:30
msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "注意：简单地调用一个协程并不会使其被调度执行"

#: ../../library/asyncio-task.rst:44
msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"

#: ../../library/asyncio-task.rst:47
msgid ""
"To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr "要实际运行一个协程，asyncio 提供了以下几种机制:"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\""
" function (see the above example.)"
msgstr ":func:`asyncio.run` 函数用来运行最高层级的入口点 \"main()\" 函数 (参见上面的示例。)"

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\""
" after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr "对协程执行 await。以下代码段会在等待 1 秒后打印 \"hello\"，然后 *再次* 等待 2 秒后打印 \"world\"::"

#: ../../library/asyncio-task.rst:56
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "预期的输出::"

#: ../../library/asyncio-task.rst:75
msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
":func:`asyncio.create_task` 函数用来并发运行作为 asyncio :class:`任务 <Task>` 的多个协程。"

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr "让我们修改以上示例，*并发* 运行两个 ``say_after`` 协程::"

#: ../../library/asyncio-task.rst:86
msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # 等待直到两个任务都完成\n"
"    # （会花费约 2 秒钟。）\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr "注意，预期的输出显示代码段的运行时间比之前快了 1 秒::"

#: ../../library/asyncio-task.rst:105
msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to "
":func:`create_task`. Using this API, the last example becomes::"
msgstr ""
":class:`asyncio.TaskGroup` 类提供了 :func:`create_task` 的更现代化的替代。 使用此 "
"API，之前的例子将变为::"

#: ../../library/asyncio-task.rst:114
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # 当存在上下文管理器时 await 是隐式执行的。\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr "用时和输出结果应当与之前的版本相同。"

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`。"

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "可等待对象"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an "
":keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"如果一个对象可以在 :keyword:`await`  语句中使用，那么它就是 **可等待** 对象。许多 asyncio API "
"都被设计为接受可等待对象。"

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr "*可等待* 对象有三种主要类型: **协程**, **任务** 和 **Future**."

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr "Python 协程属于 *可等待* 对象，因此可以在其他协程中被等待::"

#: ../../library/asyncio-task.rst:152
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # 如果我们只调用 \"nested()\" 则无事发生。\n"
"    # 一个协程对象会被创建但是不会被等待，\n"
"    # 因此它 *根本不会运行*。\n"
"    nested()  # 将引发 \"RuntimeWarning\"。\n"
"\n"
"    # 现在让我们改为等待它：\n"
"    print(await nested())  # 将打印 \"42\"。\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr "在本文档中 \"协程\" 可用来表示两个紧密关联的概念:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*协程函数*: 定义形式为 :keyword:`async def` 的函数;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "*协程对象*: 调用 *协程函数* 所返回的对象。"

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "任务"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*任务* 被用来“并行的”调度协程"

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like "
":func:`asyncio.create_task` the coroutine is automatically scheduled to run "
"soon::"
msgstr "当一个协程通过 :func:`asyncio.create_task` 等函数被封装为一个 *任务*，该协程会被自动调度执行::"

#: ../../library/asyncio-task.rst:187
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # 将 nested() 加入计划任务\n"
"    # 立即与 \"main()\" 并发运行。\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # 现在可以使用 \"task\" 来取消 \"nested()\"，or\n"
"    # 或简单地等待它直到它被完成：\n"
"    await task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Futures"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ":class:`Future` 是一种特殊的 **低层级** 可等待对象，表示一个异步操作的 **最终结果**。"

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr "当一个 Future 对象 *被等待*，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。"

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used"
" with async/await."
msgstr "在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。"

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr "通常情况下 **没有必要** 在应用层级的代码中创建 Future 对象。"

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be"
" awaited::"
msgstr "Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象::"

#: ../../library/asyncio-task.rst:221
msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # 这样也可以：\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is "
":meth:`loop.run_in_executor`."
msgstr "一个很好的返回对象的低层级函数的示例是 :meth:`loop.run_in_executor`。"

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "创建任务"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**源码：** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr "将 *coro* :ref:`协程 <coroutine>` 封装为一个 :class:`Task` 并调度其执行。返回 Task 对象。"

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using "
":meth:`Task.set_name`."
msgstr "*name* 不为 ``None``，它将使用 :meth:`Task.set_name` 来设为任务的名称。"

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"可选的 *context* 参数允许指定自定义的 :class:`contextvars.Context` 供 *coro* 运行。 当未提供 "
"*context* 时将创建当前上下文的副本。"

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, "
":exc:`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"该任务会在 :func:`get_running_loop` 返回的循环中执行，如果当前线程没有在运行的循环则会引发 "
":exc:`RuntimeError`。"

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` 是一个平衡了结构化并发的新选择；它允许等待一组相关任务并具有极强的安全保证。"

#: ../../library/asyncio-task.rst:265
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background"
" tasks, gather them in a collection::"
msgstr ""
"保存一个指向此函数的结果的引用，以避免任务在执行过程中消失。 事件循环将只保留对任务的弱引用。 "
"未在其他地方被引用的任务可能在任何时候被作为垃圾回收，即使是在它被完成之前。 如果需要可靠的“发射后不用管”后台任务，请将它们放到一个多项集中::"

#: ../../library/asyncio-task.rst:272
msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # 将任务加入集合。 这将创建一个强引用。\n"
"    background_tasks.add(task)\n"
"\n"
"    # 为避免永远保留对已结束任务的引用，\n"
"    # 让每个任务在完成后将对自己的引用\n"
"    # 移出集合：\n"
"    task.add_done_callback(background_tasks.discard)"

#: ../../library/asyncio-task.rst:287 ../../library/asyncio-task.rst:1192
msgid "Added the *name* parameter."
msgstr "增加了 *name* 形参。"

#: ../../library/asyncio-task.rst:290 ../../library/asyncio-task.rst:1199
msgid "Added the *context* parameter."
msgstr "增加了 *context* 形参。"

#: ../../library/asyncio-task.rst:295
msgid "Task Cancellation"
msgstr "任务取消"

#: ../../library/asyncio-task.rst:297
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, "
":exc:`asyncio.CancelledError` will be raised in the task at the next "
"opportunity."
msgstr "任务可以便捷和安全地取消。 当任务被取消时，:exc:`asyncio.CancelledError` 将在遇到机会时在任务中被引发。"

#: ../../library/asyncio-task.rst:301
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. "
":exc:`asyncio.CancelledError` directly subclasses :exc:`BaseException` so "
"most code will not need to be aware of it."
msgstr ""
"推荐协程使用 ``try/finally`` 代码块来可靠地执行清理逻辑。 对于 :exc:`asyncio.CancelledError` "
"被显式捕获的情况，它通常应当在清理完成时被传播。 :exc:`asyncio.CancelledError` 会直接子类化 "
":exc:`BaseException` 因此大多数代码都不需要关心这一点。"

#: ../../library/asyncio-task.rst:307
msgid ""
"The asyncio components that enable structured concurrency, like "
":class:`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented "
"using cancellation internally and might misbehave if a coroutine swallows "
":exc:`asyncio.CancelledError`. Similarly, user code should not generally "
"call :meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when "
"suppressing :exc:`asyncio.CancelledError` is truly desired, it is necessary "
"to also call ``uncancel()`` to completely remove the cancellation state."
msgstr ""
"启用结构化并发的 asyncio 组件，如 :class:`asyncio.TaskGroup` 和 "
":func:`asyncio.timeout`，在内部是使用撤销操作来实现的因而在协程屏蔽了 :exc:`asyncio.CancelledError`"
" 时可能无法正常工作。 类似地，用户代码通常也不应调用 :meth:`uncancel <asyncio.Task.uncancel>`。 "
"但是，在确实想要屏蔽 :exc:`asyncio.CancelledError` 的情况下，则还有必要调用 ``uncancel()`` "
"来完全移除撤销状态。"

#: ../../library/asyncio-task.rst:319
msgid "Task Groups"
msgstr "任务组"

#: ../../library/asyncio-task.rst:321
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr "任务组合并了一套用于等待分组中所有任务完成的方便可靠方式的任务创建 API。"

#: ../../library/asyncio-task.rst:326
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"持有一个任务分组的 :ref:`异步上下文管理器 <async-context-managers>`。 可以使用 :meth:`create_task`"
" 将任务添加到分组中。 当该上下文管理器退出时所有任务都将被等待。"

#: ../../library/asyncio-task.rst:335
msgid ""
"Create a task in this task group. The signature matches that of "
":func:`asyncio.create_task`. If the task group is inactive (e.g. not yet "
"entered, already finished, or in the process of shutting down), we will "
"close the given ``coro``."
msgstr ""
"在该任务组中创建一个任务。 签名与 :func:`asyncio.create_task` 的签名相匹配。 "
"如果该任务组未激活（例如尚未进入、已经结束或在关闭过程中），我们将关闭所给出的 ``coro``。"

#: ../../library/asyncio-task.rst:343
msgid "Close the given coroutine if the task group is not active."
msgstr "如果任务组未激活则关闭所给出的协程。"

#: ../../library/asyncio-task.rst:345 ../../library/asyncio-task.rst:551
#: ../../library/asyncio-task.rst:724 ../../library/asyncio-task.rst:782
#: ../../library/asyncio-task.rst:808 ../../library/asyncio-task.rst:849
msgid "Example::"
msgstr "示例::"

#: ../../library/asyncio-task.rst:347
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2.result()}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2.result()}\")"

#: ../../library/asyncio-task.rst:353
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish."
" While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"``async with`` 语句将等待分组中的所有任务结束。 在等待期间，仍可将新任务添加到分组中 (例如，通过将 ``tg`` "
"传入某个协程并在该协程中调用 ``tg.create_task()``)。 一旦最后的任务完成并退出 ``async with`` "
"代码块，将无法再向分组添加新任务。"

#: ../../library/asyncio-task.rst:360
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At"
" this point, if the body of the ``async with`` statement is still active "
"(i.e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting "
":exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"当首次有任何属于分组的任务因 :exc:`asyncio.CancelledError` 以外的异常而失败时，分组中的剩余任务将被取消。 "
"在此之后将无法添加更多任务到该分组中。 在这种情况下，如果 ``async with`` 语句体仍然为激活状态（即 "
":meth:`~object.__aexit__` 尚未被调用），则直接包含 ``async with`` 语句的任务也会被取消。 结果 "
":exc:`asyncio.CancelledError` 将中断一个 ``await``，但它将不会跳出包含的 ``async with`` 语句。"

#: ../../library/asyncio-task.rst:370
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"一旦所有任务被完成，如果有任何任务因 :exc:`asyncio.CancelledError` 以外的异常而失败，这些异常会被组合在 "
":exc:`ExceptionGroup` 或 :exc:`BaseExceptionGroup` 中（选择其中较适合的一个；参见其文档）并将随后引发。"

#: ../../library/asyncio-task.rst:377
msgid ""
"Two base exceptions are treated specially: If any task fails with "
":exc:`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels "
"the remaining tasks and waits for them, but then the initial "
":exc:`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of "
":exc:`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"两个基础异常会被特别对待：如果有任何任务因 :exc:`KeyboardInterrupt` 或 :exc:`SystemExit` "
"而失败，任务分组仍然会取消剩余的任务并等待它们，但随后初始 :exc:`KeyboardInterrupt` 或 :exc:`SystemExit` "
"而不是 :exc:`ExceptionGroup` 或 :exc:`BaseExceptionGroup` 会被重新引发。"

#: ../../library/asyncio-task.rst:383
msgid ""
"If the body of the ``async with`` statement exits with an exception (so "
":meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into "
":meth:`~object.__aexit__`, unless it is :exc:`asyncio.CancelledError`, is "
"also included in the exception group. The same special case is made for "
":exc:`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"如果 ``async with`` 语句体因异常而退出（这样将调用 :meth:`~object.__aexit__` "
"并附带一个异常），此种情况会与有任务失败时一样对待：剩余任务将被取消然后被等待，而非取消类异常会被加入到一个异常分组并被引发。 传入到 "
":meth:`~object.__aexit__` 的异常，除了 :exc:`asyncio.CancelledError` "
"以外，也都会被包括在该异常分组中。 同样的特殊对待也适用于上一段所说的 :exc:`KeyboardInterrupt` 和 "
":exc:`SystemExit`。"

#: ../../library/asyncio-task.rst:395
msgid ""
"Task groups are careful not to mix up the internal cancellation used to "
"\"wake up\" their :meth:`~object.__aexit__` with cancellation requests for "
"the task in which they are running made by other parties. In particular, "
"when one task group is syntactically nested in another, and both experience "
"an exception in one of their child tasks simultaneously, the inner task "
"group will process its exceptions, and then the outer task group will "
"receive another cancellation and process its own exceptions."
msgstr ""
"对于任务组应当注意不要将用于“唤醒”其 :meth:`~object.__aexit__` 的内部取消请求与其他地方对其运行的任务提出的取消请求相混淆。"
" "
"具体来说，当一个任务组在语法上嵌套于另一个任务组中，而两个任务组的某个子任务同时发生异常时，内层的任务组将处理其异常，然后外层的任务组将收到另一个取消请求并处理它自己的异常。"

#: ../../library/asyncio-task.rst:403
msgid ""
"In the case where a task group is cancelled externally and also must raise "
"an :exc:`ExceptionGroup`, it will call the parent task's "
":meth:`~asyncio.Task.cancel` method. This ensures that a "
":exc:`asyncio.CancelledError` will be raised at the next :keyword:`await`, "
"so the cancellation is not lost."
msgstr ""
"对于任务组在外部被取消同时必须引发 :exc:`ExceptionGroup` 的情况，它将调用父任务的 "
":meth:`~asyncio.Task.cancel` 方法。 这样可以确保 :exc:`asyncio.CancelledError` 会在下一次 "
":keyword:`await` 时被引发，因此取消操作不会丢失。"

#: ../../library/asyncio-task.rst:409
msgid ""
"Task groups preserve the cancellation count reported by "
":meth:`asyncio.Task.cancelling`."
msgstr "任务组将保留 :meth:`asyncio.Task.cancelling` 所报告的取消次数。"

#: ../../library/asyncio-task.rst:414
msgid ""
"Improved handling of simultaneous internal and external cancellations and "
"correct preservation of cancellation counts."
msgstr "改进了同时处理内部和外部取消操作以及正确保留取消计数的功能。"

#: ../../library/asyncio-task.rst:418
msgid "Terminating a Task Group"
msgstr "终结一个任务组"

#: ../../library/asyncio-task.rst:420
msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr "虽然标准库没有对终结任务组的原生支持，但可通过向任务组添加一个引发异常的任务并无视被引发的异常来达成终结效果："

#: ../../library/asyncio-task.rst:424
msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # 创建一些任务\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # 休眠 1 秒\n"
"            await asyncio.sleep(1)\n"
"            # 添加一个引发异常的任务以强制终结分组\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:456
msgid "Expected output:"
msgstr "期待的输出:"

#: ../../library/asyncio-task.rst:458
msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"

#: ../../library/asyncio-task.rst:465
msgid "Sleeping"
msgstr "休眠"

#: ../../library/asyncio-task.rst:470
msgid "Block for *delay* seconds."
msgstr "阻塞 *delay* 指定的秒数。"

#: ../../library/asyncio-task.rst:472
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr "如果指定了 *result*，则当协程完成时将其返回给调用者。"

#: ../../library/asyncio-task.rst:475
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr "``sleep()`` 总是会挂起当前任务，以允许其他任务运行。"

#: ../../library/asyncio-task.rst:478
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr "将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行。 这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。"

#: ../../library/asyncio-task.rst:484
msgid ""
"Example of coroutine displaying the current date every second for 5 "
"seconds::"
msgstr "以下协程示例运行 5 秒，每秒显示一次当前日期::"

#: ../../library/asyncio-task.rst:487
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"

#: ../../library/asyncio-task.rst:502 ../../library/asyncio-task.rst:600
#: ../../library/asyncio-task.rst:699 ../../library/asyncio-task.rst:874
#: ../../library/asyncio-task.rst:929 ../../library/asyncio-task.rst:986
msgid "Removed the *loop* parameter."
msgstr "移除了 *loop* 形参。"

#: ../../library/asyncio-task.rst:505
msgid "Raises :exc:`ValueError` if *delay* is :data:`~math.nan`."
msgstr "如果 *delay* 为 :data:`~math.nan` 则会引发 :exc:`ValueError`。"

#: ../../library/asyncio-task.rst:510
msgid "Running Tasks Concurrently"
msgstr "并发运行任务"

#: ../../library/asyncio-task.rst:514
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr "*并发* 运行 *aws* 序列中的 :ref:`可等待对象 <asyncio-awaitables>`。"

#: ../../library/asyncio-task.rst:517
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a"
" Task."
msgstr "如果 *aws* 中的某个可等待对象为协程，它将自动被作为一个任务调度。"

#: ../../library/asyncio-task.rst:520
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr "如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 *aws* 中可等待对象的顺序一致。"

#: ../../library/asyncio-task.rst:524
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is"
" immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to"
" run."
msgstr ""
"如果 *return_exceptions* 为 ``False`` (默认)，所引发的首个异常会立即传播给等待 ``gather()`` "
"的任务。*aws* 序列中的其他可等待对象 **不会被取消** 并将继续运行。"

#: ../../library/asyncio-task.rst:529
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr "如果 *return_exceptions* 为 ``True``，异常会和成功的结果一样处理，并聚合至结果列表。"

#: ../../library/asyncio-task.rst:532
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr "如果 ``gather()`` *被取消*，所有被提交 (尚未完成) 的可等待对象也会 *被取消*。"

#: ../../library/asyncio-task.rst:535
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"如果 *aws* 序列中的任一 Task 或 Future 对象 *被取消*，它将被当作引发了 :exc:`CancelledError` 一样处理 "
"-- 在此情况下 ``gather()`` 调用 **不会** 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 "
"Tasks/Future 也被取消。"

#: ../../library/asyncio-task.rst:542
msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""
"一个创建然后并发地运行任务等待它们完成的新选择是 :class:`asyncio.TaskGroup`。 *TaskGroup* "
"提供了针对调度嵌套子任务的比 *gather* 更强的安全保证：如果一个任务（或子任务，即由一个任务调度的任务）引发了异常，*TaskGroup* "
"将取消剩余的已排期任务）。"

#: ../../library/asyncio-task.rst:553
msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}...\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}...\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # 将三个调用 *并发地* 加入计划任务：\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# 预期的输出：\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"

#: ../../library/asyncio-task.rst:589
msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"如果 *return_exceptions* 为假值，则在 gather() 被标记为完成后取消它将不会取消任何已提交的可等待对象。 "
"例如，在将一个异常传播给调用者之后，gather 可被标记为已完成，因此，在从 gather 捕获一个（由可等待对象所引发的）异常之后调用 "
"``gather.cancel()`` 将不会取消任何其他可等待对象。"

#: ../../library/asyncio-task.rst:596
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr "如果 *gather* 本身被取消，则无论 *return_exceptions* 取值为何，消息都会被传播。"

#: ../../library/asyncio-task.rst:603
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running"
" event loop."
msgstr "如果未提供位置参数或者并非所有位置参数均为 Future 类对象并且没有正在运行的事件循环则会发出弃用警告。"

#: ../../library/asyncio-task.rst:612
msgid "Eager Task Factory"
msgstr "主动任务工厂"

#: ../../library/asyncio-task.rst:616
msgid "A task factory for eager task execution."
msgstr "用于主动任务执行的任务工厂"

#: ../../library/asyncio-task.rst:618
msgid ""
"When using this factory (via "
":meth:`loop.set_task_factory(asyncio.eager_task_factory) "
"<loop.set_task_factory>`), coroutines begin execution synchronously during "
":class:`Task` construction. Tasks are only scheduled on the event loop if "
"they block. This can be a performance improvement as the overhead of loop "
"scheduling is avoided for coroutines that complete synchronously."
msgstr ""
"当使用这个工厂函数时 (通过 :meth:`loop.set_task_factory(asyncio.eager_task_factory) "
"<loop.set_task_factory>`)，协程将在 :class:`Task` 构造期间同步地开始执行。 "
"任务仅会在它们阻塞时被加入事件循环上的计划任务。 这可以达成性能提升因为对同步完成的协程来说可以避免循环调度的开销。"

#: ../../library/asyncio-task.rst:624
msgid ""
"A common example where this is beneficial is coroutines which employ caching"
" or memoization to avoid actual I/O when possible."
msgstr "此特性会带来好处的一个常见例子是应用了缓存或记忆功能以便在可能的情况避免实际 I/O 的协程。"

#: ../../library/asyncio-task.rst:629
msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example,"
" the application's task execution order is likely to change."
msgstr ""
"协程是立即执行是一项语言改变。 如果协程返回或引发异常，其任务将不会被加入事件循环上的计划任务。 "
"如果协程执行发生阻塞，其任务将被加入事件循环上的计划任务。 这项改变可能会向现有应用程序引入行为变化。 例如，应用程序的任务执行顺序可能会发生改变。"

#: ../../library/asyncio-task.rst:640
msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""
"创建一个主动型任务工厂，类似于 :func:`eager_task_factory`，在创建新任务时使用所提供的 "
"*custom_task_constructor* 而不是默认的 :class:`Task`。"

#: ../../library/asyncio-task.rst:644
msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a "
":class:`asyncio.Task`-compatible object."
msgstr ""
"*custom_task_constructor* 必须是一个 *可调用对象*，其签名与 :class:`Task.__init__ <Task>` "
"的签名相匹配。 该可调用对象必须返回一个兼容 :class:`asyncio.Task` 的对象。"

#: ../../library/asyncio-task.rst:648
msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) "
"<loop.set_task_factory>`)."
msgstr ""
"此函数返回一个 *可调用对象*，将通过 :meth:`loop.set_task_factory(factory) "
"<loop.set_task_factory>`) 被用作一个事件循环的任务工厂。"

#: ../../library/asyncio-task.rst:655
msgid "Shielding From Cancellation"
msgstr "屏蔽取消操作"

#: ../../library/asyncio-task.rst:659
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being "
":meth:`cancelled <Task.cancel>`."
msgstr "保护一个 :ref:`可等待对象 <asyncio-awaitables>` 防止其被 :meth:`取消 <Task.cancel>`。"

#: ../../library/asyncio-task.rst:662 ../../library/asyncio-task.rst:829
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "如果 *aw* 是一个协程，它将自动被作为任务调度。"

#: ../../library/asyncio-task.rst:664
msgid "The statement::"
msgstr "以下语句::"

#: ../../library/asyncio-task.rst:666
msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"

#: ../../library/asyncio-task.rst:669
msgid "is equivalent to::"
msgstr "相当于::"

#: ../../library/asyncio-task.rst:671
msgid "res = await something()"
msgstr "res = await something()"

#: ../../library/asyncio-task.rst:673
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a "
":exc:`CancelledError`."
msgstr ""
"*不同之处* 在于如果包含它的协程被取消，在 ``something()`` 中运行的任务不会被取消。从 ``something()`` "
"的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 \"await\" 表达式仍然会引发 :exc:`CancelledError`。"

#: ../../library/asyncio-task.rst:679
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr "如果通过其他方式取消 ``something()`` (例如在其内部操作) 则 ``shield()`` 也会取消。"

#: ../../library/asyncio-task.rst:682
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr "如果希望完全忽略取消操作 (不推荐) 则 ``shield()`` 函数需要配合一个 try/except 代码段，如下所示::"

#: ../../library/asyncio-task.rst:686
msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"

#: ../../library/asyncio-task.rst:694
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"保存一个传给此函数的任务的引用，以避免任务在执行过程中消失。 事件循环将只保留对任务的弱引用。 "
"未在其他地方被引用的任务可能在任何时候被作为垃圾回收，即使是在它被完成之前。"

#: ../../library/asyncio-task.rst:702
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr "如果 *aw* 不是 Future 类对象并且没有正在运行的事件循环则会发出弃用警告。"

#: ../../library/asyncio-task.rst:708
msgid "Timeouts"
msgstr "超时"

#: ../../library/asyncio-task.rst:712
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr "返回一个可被用于限制等待某个操作所耗费时间的 :ref:`异步上下文管理器 <async-context-managers>`。"

#: ../../library/asyncio-task.rst:716
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If"
" *delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* 可以为 ``None``，或是一个表示等待秒数的浮点数/整数。 如果 *delay* 为 "
"``None``，将不会应用时间限制；如果当创建上下文管理器时无法确定延时则此设置将很适用。"

#: ../../library/asyncio-task.rst:721
msgid ""
"In either case, the context manager can be rescheduled after creation using "
":meth:`Timeout.reschedule`."
msgstr "在两种情况下，该上下文管理器都可以在创建之后使用 :meth:`Timeout.reschedule` 来重新安排计划。"

#: ../../library/asyncio-task.rst:726
msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"

#: ../../library/asyncio-task.rst:730
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context"
" manager will cancel the current task and handle the resulting "
":exc:`asyncio.CancelledError` internally, transforming it into a "
":exc:`TimeoutError` which can be caught and handled."
msgstr ""
"如果 ``long_running_task`` 耗费 10 秒以上完成，该上下文管理器将取消当前任务并在内部处理所引发的 "
":exc:`asyncio.CancelledError`，将其转化为可被捕获和处理的 :exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:737
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the "
":exc:`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the "
":exc:`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
":func:`asyncio.timeout` 上下文管理器负责将 :exc:`asyncio.CancelledError` 转化为 "
":exc:`TimeoutError`，这意味着 :exc:`TimeoutError` 只能在该上下文管理器 *之外* 被捕获。"

#: ../../library/asyncio-task.rst:742
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "捕获 :exc:`TimeoutError` 的示例::"

#: ../../library/asyncio-task.rst:744
msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"

#: ../../library/asyncio-task.rst:753
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ":func:`asyncio.timeout` 所产生的上下文管理器可以被重新调整到不同的终止点并执行检查。"

#: ../../library/asyncio-task.rst:758
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr "一个用于撤销已过期协程的 :ref:`异步上下文管理器 <async-context-managers>`。"

#: ../../library/asyncio-task.rst:761
msgid ""
"``when`` should be an absolute time at which the context should time out, as"
" measured by the event loop's clock:"
msgstr "``when`` 应当是一个指明上下文将要过期的绝对时间，由事件循环的时钟来计时。"

#: ../../library/asyncio-task.rst:764
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "如果 ``when`` 为 ``None``，则超时将永远不会被触发。"

#: ../../library/asyncio-task.rst:765
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of"
" the event loop."
msgstr "如果 ``when < loop.time()``，则超时将在事件循环的下一次迭代中被触发。"

#: ../../library/asyncio-task.rst:770
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr "返回当前终止点，或者如果未设置当前终止点则返回 ``None``。"

#: ../../library/asyncio-task.rst:775
msgid "Reschedule the timeout."
msgstr "重新安排超时。"

#: ../../library/asyncio-task.rst:779
msgid ""
"Return whether the context manager has exceeded its deadline (expired)."
msgstr "返回上下文管理器是否已超出时限（过期）。"

#: ../../library/asyncio-task.rst:784
msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        # 当开始时我们并不知道超时值，所以我们传入 ``None``。\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # 现在我们知道超时值了，所以我们将它重新加入计划任务。\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"

#: ../../library/asyncio-task.rst:799
msgid "Timeout context managers can be safely nested."
msgstr "超时上下文管理器可以被安全地嵌套。"

#: ../../library/asyncio-task.rst:805
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr "类似于 :func:`asyncio.timeout`，不同之处在于 *when* 是停止等待的绝对时间，或者为 ``None``。"

#: ../../library/asyncio-task.rst:810
msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"

#: ../../library/asyncio-task.rst:826
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr "等待 *aw* :ref:`可等待对象 <asyncio-awaitables>` 完成，指定 timeout 秒数后超时。"

#: ../../library/asyncio-task.rst:831
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait"
" for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* 可以为 ``None``，也可以为 float 或 int 型数值表示的等待秒数。如果 *timeout* 为 "
"``None``，则等待直到完成。"

#: ../../library/asyncio-task.rst:835
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr "如果发生超时，将取消任务并引发 :exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:838
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in "
":func:`shield`."
msgstr "要避免任务 :meth:`取消 <Task.cancel>`，可以加上 :func:`shield`。"

#: ../../library/asyncio-task.rst:841
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr "此函数将等待直到 Future 确实被取消，所以总等待时间可能超过 *timeout*。 如果在取消期间发生了异常，异常将会被传播。"

#: ../../library/asyncio-task.rst:845
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "如果等待被取消，则 *aw* 指定的对象也会被取消。"

#: ../../library/asyncio-task.rst:851
msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""
"async def eternity():\n"
"    # 休眠一小时\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # 等待至多 1 秒\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# 预期的输出：\n"
"#\n"
"#     timeout!"

#: ../../library/asyncio-task.rst:869
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"当 *aw* 由于超时被取消时，``wait_for`` 会等待 *aw* 被取消。 在之前版本中，它会立即引发 "
":exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:877
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "引发 :exc:`TimeoutError` 而不是 :exc:`asyncio.TimeoutError`。"

#: ../../library/asyncio-task.rst:882
msgid "Waiting Primitives"
msgstr "简单等待"

#: ../../library/asyncio-task.rst:887
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"并发地运行 *aws* 可迭代对象中的 :class:`~asyncio.Future` 和 :class:`~asyncio.Task` "
"实例并进入阻塞状态直到满足 *return_when* 所指定的条件。"

#: ../../library/asyncio-task.rst:891
msgid "The *aws* iterable must not be empty."
msgstr "*aws* 可迭代对象必须不为空。"

#: ../../library/asyncio-task.rst:893
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "返回两个 Task/Future 集合: ``(done, pending)``。"

#: ../../library/asyncio-task.rst:895
msgid "Usage::"
msgstr "用法："

#: ../../library/asyncio-task.rst:897
msgid "done, pending = await asyncio.wait(aws)"
msgstr "done, pending = await asyncio.wait(aws)"

#: ../../library/asyncio-task.rst:899
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum"
" number of seconds to wait before returning."
msgstr "如指定 *timeout* (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。"

#: ../../library/asyncio-task.rst:902
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks"
" that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"请注意此函数不会引发 :exc:`TimeoutError`。 当超时发生时尚未完成的 Future 或 Task 会在设定的秒数后被直接返回。"

#: ../../library/asyncio-task.rst:906
msgid ""
"*return_when* indicates when this function should return.  It must be one of"
" the following constants:"
msgstr "*return_when* 指定此函数应在何时返回。它必须为以下常数之一:"

#: ../../library/asyncio-task.rst:912
msgid "Constant"
msgstr "常量"

#: ../../library/asyncio-task.rst:913
msgid "Description"
msgstr "描述"

#: ../../library/asyncio-task.rst:916
msgid "The function will return when any future finishes or is cancelled."
msgstr "函数将在任意可等待对象结束或取消时返回。"

#: ../../library/asyncio-task.rst:919
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""
"该函数将在任何 future 对象由于引发异常而结束时返回。 如果没有任何 future 对象引发异常，则其等价于 "
":const:`ALL_COMPLETED`。"

#: ../../library/asyncio-task.rst:924
msgid "The function will return when all futures finish or are cancelled."
msgstr "函数将在所有可等待对象结束或取消时返回。"

#: ../../library/asyncio-task.rst:926
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr "与 :func:`~asyncio.wait_for` 不同，``wait()`` 在超时发生时不会取消可等待对象。"

#: ../../library/asyncio-task.rst:932
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "直接向 ``wait()`` 传入协程对象的方式已被弃用。"

#: ../../library/asyncio-task.rst:935 ../../library/asyncio-task.rst:993
msgid "Added support for generators yielding tasks."
msgstr "增加了对产生任务的生成器的支持。"

#: ../../library/asyncio-task.rst:941
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. The returned object can be iterated to obtain the results of "
"the awaitables as they finish."
msgstr ""
"并发地运行 *aws* 可迭代对象中的 :ref:`可等待对象 <asyncio-awaitables>`。 "
"返回的对象可以被迭代以获取可等待对象结束时的结果。"

#: ../../library/asyncio-task.rst:945
msgid ""
"The object returned by ``as_completed()`` can be iterated as an "
":term:`asynchronous iterator` or a plain :term:`iterator`. When asynchronous"
" iteration is used, the originally-supplied awaitables are yielded if they "
"are tasks or futures. This makes it easy to correlate previously-scheduled "
"tasks with their results. Example::"
msgstr ""
"由 ``as_completed()`` 返回的对象可作为 :term:`asynchronous iterator` 或普通的 "
":term:`iterator` 被迭代。 当使用异步迭代时，原来提供的可等待对象如果为 Task 或 Future 对象则会被产出。 "
"这样可以更容易地将之前加入计划的任务与其结果进行对应。 例如::"

#: ../../library/asyncio-task.rst:951
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect 已完成。 要获取结果可通过等待它\n"
"    # 或是调用 calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"

#: ../../library/asyncio-task.rst:965
msgid ""
"During asynchronous iteration, implicitly-created tasks will be yielded for "
"supplied awaitables that aren't tasks or futures."
msgstr "在异步迭代期间，将为不属于 Task 或 Future 对象的可等待对象产出隐式创建的任务。"

#: ../../library/asyncio-task.rst:968
msgid ""
"When used as a plain iterator, each iteration yields a new coroutine that "
"returns the result or raises the exception of the next completed awaitable. "
"This pattern is compatible with Python versions older than 3.13::"
msgstr ""
"当被用作普通的迭代器时，每次迭代将产出一个返回结果的新协程或是引发下一个完成的等待对象对应的异常。 此模式将与 Python 3.13 "
"之前的版本保持兼容::"

#: ../../library/asyncio-task.rst:972
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect 不是原始任务对象之一。\n"
"    # 它必须被等待以获取结果值或是引发\n"
"    # 接下来要结束的可等待对象的异常。\n"
"    reader, writer = await next_connect"

#: ../../library/asyncio-task.rst:982
msgid ""
"A :exc:`TimeoutError` is raised if the timeout occurs before all awaitables "
"are done. This is raised by the ``async for`` loop during asynchronous "
"iteration or by the coroutines yielded during plain iteration."
msgstr ""
"如果在所有可等待对象完成之前达到超时限制则会引发 :exc:`TimeoutError`。 这将在异步迭代期间由 ``async for`` "
"循环引发或是在普通迭代期间由所产出的协程引发。"

#: ../../library/asyncio-task.rst:989
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr "如果 *aws* 可迭代对象中的可等待对象不全为 Future 类对象并且没有正在运行的事件循环则会发出弃用警告。"

#: ../../library/asyncio-task.rst:996
msgid ""
"The result can now be used as either an :term:`asynchronous iterator` or as "
"a plain :term:`iterator` (previously it was only a plain iterator)."
msgstr ""
"该结果现在可被用作 :term:`asynchronous iterator` 或是普通的 :term:`iterator` "
"(在之前它只是普通的迭代器)。"

#: ../../library/asyncio-task.rst:1002
msgid "Running in Threads"
msgstr "在线程中运行"

#: ../../library/asyncio-task.rst:1007
msgid "Asynchronously run function *func* in a separate thread."
msgstr "在不同的线程中异步地运行函数 *func*。"

#: ../../library/asyncio-task.rst:1009
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"向此函数提供的任何 \\*args 和 \\*\\*kwargs 会被直接传给 *func*。 并且，当前 "
":class:`contextvars.Context` 会被传播，允许在不同的线程中访问来自事件循环的上下文变量。"

#: ../../library/asyncio-task.rst:1014
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr "返回一个可被等待以获取 *func* 的最终结果的协程。"

#: ../../library/asyncio-task.rst:1016
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr "这个协程函数主要是用于执行在其他情况下会阻塞事件循环的 IO 密集型函数/方法。 例如::"

#: ../../library/asyncio-task.rst:1020
msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # 请注意 time.sleep() 可被替换为任意一种\n"
"    # 阻塞式 IO 密集型操作，例如文件操作。\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# 预期的输出：\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"

#: ../../library/asyncio-task.rst:1046
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"在任何协程中直接调用 ``blocking_io()`` 将会在调用期间阻塞事件循环，导致额外的 1 秒运行时间。 但是，通过改用 "
"``asyncio.to_thread()``，我们可以在单独的线程中运行它从而不会阻塞事件循环。"

#: ../../library/asyncio-task.rst:1053
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that"
" release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"由于 :term:`GIL` 的存在，``asyncio.to_thread()`` 通常只能被用来将 IO 密集型函数变为非阻塞的。 但是，对于会释放"
" GIL 的扩展模块或无此限制的替代性 Python 实现来说，``asyncio.to_thread()`` 也可被用于 CPU 密集型函数。"

#: ../../library/asyncio-task.rst:1062
msgid "Scheduling From Other Threads"
msgstr "跨线程调度"

#: ../../library/asyncio-task.rst:1066
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "向指定事件循环提交一个协程。（线程安全）"

#: ../../library/asyncio-task.rst:1068
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr "返回一个 :class:`concurrent.futures.Future` 以等待来自其他 OS 线程的结果。"

#: ../../library/asyncio-task.rst:1071
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr "此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例::"

#: ../../library/asyncio-task.rst:1074
msgid ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"
msgstr ""
"# 创建一个协程\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# 将协程提交到给定的循环\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# 等待结果并可选择设置超时参数\n"
"assert future.result(timeout) == 3"

#: ../../library/asyncio-task.rst:1083
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr "如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务::"

#: ../../library/asyncio-task.rst:1087
msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"

#: ../../library/asyncio-task.rst:1097
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"参见 :ref:`concurrency and multithreading <asyncio-multithreading>` 部分的文档。"

#: ../../library/asyncio-task.rst:1100
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to"
" be passed explicitly."
msgstr "不同于其他 asyncio 函数，此函数要求显式地传入 *loop* 参数。"

#: ../../library/asyncio-task.rst:1107
msgid "Introspection"
msgstr "内省"

#: ../../library/asyncio-task.rst:1112
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr "返回当前运行的 :class:`Task` 实例，如果没有正在运行的任务则返回 ``None``。"

#: ../../library/asyncio-task.rst:1115
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr "如果 *loop* 为 ``None`` 则会使用 :func:`get_running_loop` 获取当前事件循环。"

#: ../../library/asyncio-task.rst:1123
msgid ""
"Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr "返回事件循环所运行的未完成的 :class:`Task` 对象的集合。"

#: ../../library/asyncio-task.rst:1126
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr "如果 *loop* 为 ``None``，则会使用 :func:`get_running_loop` 获取当前事件循环。"

#: ../../library/asyncio-task.rst:1134
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "如果 *obj* 是一个协程对象则返回 ``True``。"

#: ../../library/asyncio-task.rst:1140
msgid "Task Object"
msgstr "Task 对象"

#: ../../library/asyncio-task.rst:1144
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"一个与 :class:`Future 类似 <Future>` 的对象，可运行 Python :ref:`协程 <coroutine>`。非线程安全。"

#: ../../library/asyncio-task.rst:1147
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future "
"对象完成。当该 Future 对象 *完成*，被打包的协程将恢复执行。"

#: ../../library/asyncio-task.rst:1153
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 "
"Task、回调或执行 IO 操作。"

#: ../../library/asyncio-task.rst:1158
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"使用高层级的 :func:`asyncio.create_task` 函数来创建 Task 对象，也可用低层级的 "
":meth:`loop.create_task` 或 :func:`ensure_future` 函数。不建议手动实例化 Task 对象。"

#: ../../library/asyncio-task.rst:1163
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"要取消一个正在运行的 Task 对象可使用 :meth:`cancel` 方法。调用此方法将使该 Task 对象抛出一个 "
":exc:`CancelledError` 异常给打包的协程。如果取消期间一个协程正在对 Future 对象执行 await，该 Future "
"对象也将被取消。"

#: ../../library/asyncio-task.rst:1168
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method"
" returns ``True`` if the wrapped coroutine did not suppress the "
":exc:`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` 可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制 :exc:`CancelledError` "
"异常并且确实被取消，该方法将返回 ``True``。"

#: ../../library/asyncio-task.rst:1173
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except "
":meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` 从 :class:`Future` 继承了其除 :meth:`Future.set_result` 和 "
":meth:`Future.set_exception` 以外的所有 API。"

#: ../../library/asyncio-task.rst:1177
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"可选的仅限关键字参数 *context* 允许指定自定义的 :class:`contextvars.Context` 供 *coro* 运行。 "
"如果未提供 *context*，Task 将拷贝当前上下文并随后在拷贝的上下文中运行其协程。"

#: ../../library/asyncio-task.rst:1182
msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""
"可选的仅限关键字参数 *eager_start* 允许在任务创建时主动开始 :class:`asyncio.Task` 的执行。 如果设为 "
"``True`` 并且事件循环正在运行，任务将立即开始执行协程，直到该协程第一次阻塞。 "
"如果协程未发生阻塞即返回或引发异常，任务将主动结束并将跳过向事件循环添加计划任务。"

#: ../../library/asyncio-task.rst:1189
msgid "Added support for the :mod:`contextvars` module."
msgstr "加入对 :mod:`contextvars` 模块的支持。"

#: ../../library/asyncio-task.rst:1195
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr "如果未指定 *loop* 并且没有正在运行的事件循环则会发出弃用警告。"

#: ../../library/asyncio-task.rst:1202
msgid "Added the *eager_start* parameter."
msgstr "增加了 *eager_start* 形参。"

#: ../../library/asyncio-task.rst:1207
msgid "Return ``True`` if the Task is *done*."
msgstr "如果 Task 对象 *已完成* 则返回 ``True``。"

#: ../../library/asyncio-task.rst:1209
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr "当 Task 所封包的协程返回一个值、引发一个异常或 Task 本身被取消时，则会被认为 *已完成*。"

#: ../../library/asyncio-task.rst:1214
msgid "Return the result of the Task."
msgstr "返回 Task 的结果。"

#: ../../library/asyncio-task.rst:1216
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr "如果 Task 对象 *已完成*，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发。)"

#: ../../library/asyncio-task.rst:1220 ../../library/asyncio-task.rst:1234
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError`"
" exception."
msgstr "如果 Task 对象 *被取消*，此方法会引发一个 :exc:`CancelledError` 异常。"

#: ../../library/asyncio-task.rst:1223
msgid ""
"If the Task's result isn't yet available, this method raises an "
":exc:`InvalidStateError` exception."
msgstr "如果 Task 对象的结果还不可用，此方法会引发一个 :exc:`InvalidStateError` 异常。"

#: ../../library/asyncio-task.rst:1228
msgid "Return the exception of the Task."
msgstr "返回 Task 对象的异常。"

#: ../../library/asyncio-task.rst:1230
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If"
" the wrapped coroutine returned normally this method returns ``None``."
msgstr "如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 ``None``。"

#: ../../library/asyncio-task.rst:1237
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError`"
" exception."
msgstr "如果 Task 对象尚未 *完成*，此方法将引发一个 :exc:`InvalidStateError` 异常。"

#: ../../library/asyncio-task.rst:1242
msgid "Add a callback to be run when the Task is *done*."
msgstr "添加一个回调，将在 Task 对象 *完成* 时被运行。"

#: ../../library/asyncio-task.rst:1244 ../../library/asyncio-task.rst:1253
msgid "This method should only be used in low-level callback-based code."
msgstr "此方法应该仅在低层级的基于回调的代码中使用。"

#: ../../library/asyncio-task.rst:1246
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr "要了解更多细节请查看 :meth:`Future.add_done_callback` 的文档。"

#: ../../library/asyncio-task.rst:1251
msgid "Remove *callback* from the callbacks list."
msgstr "从回调列表中移除 *callback* 。"

#: ../../library/asyncio-task.rst:1255
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr "要了解更多细节请查看 :meth:`Future.remove_done_callback` 的文档。"

#: ../../library/asyncio-task.rst:1260
msgid "Return the list of stack frames for this Task."
msgstr "返回此 Task 对象的栈框架列表。"

#: ../../library/asyncio-task.rst:1262
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception,"
" this returns the list of traceback frames."
msgstr ""
"如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯框架列表。"

#: ../../library/asyncio-task.rst:1268
msgid "The frames are always ordered from oldest to newest."
msgstr "框架总是从按从旧到新排序。"

#: ../../library/asyncio-task.rst:1270
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "每个被挂起的协程只返回一个栈框架。"

#: ../../library/asyncio-task.rst:1272
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"可选的 *limit* "
"参数指定返回框架的数量上限；默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架，回溯返回最旧的框架。(这与 "
"traceback 模块的行为保持一致。)"

#: ../../library/asyncio-task.rst:1281
msgid "Print the stack or traceback for this Task."
msgstr "打印此 Task 对象的栈或回溯。"

#: ../../library/asyncio-task.rst:1283
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr "此方法产生的输出类似于 traceback 模块通过 :meth:`get_stack` 所获取的框架。"

#: ../../library/asyncio-task.rst:1286
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "*limit* 参数会直接传递给 :meth:`get_stack`。"

#: ../../library/asyncio-task.rst:1288
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr "*file* 参数是输出所写入的 I/O 流；在默认情况下输出会写入到 :data:`sys.stdout`。"

#: ../../library/asyncio-task.rst:1293
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "返回由 :class:`Task` 包装的协程对象。"

#: ../../library/asyncio-task.rst:1297
msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr "这对于已经主动完成的任务将返回 ``None``。 参见 :ref:`主动任务工厂 <eager-task-factory>`。"

#: ../../library/asyncio-task.rst:1304
msgid "Newly added eager task execution means result may be ``None``."
msgstr "新增加的主动任务执行意味着结果可能为 ``None``。"

#: ../../library/asyncio-task.rst:1308
msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr "返回关联到该任务的 :class:`contextvars.Context` 对象。"

#: ../../library/asyncio-task.rst:1315
msgid "Return the name of the Task."
msgstr "返回 Task 的名称。"

#: ../../library/asyncio-task.rst:1317
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr "如果没有一个 Task 名称被显式地赋值，默认的 asyncio Task 实现会在实例化期间生成一个默认名称。"

#: ../../library/asyncio-task.rst:1325
msgid "Set the name of the Task."
msgstr "设置 Task 的名称。"

#: ../../library/asyncio-task.rst:1327
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr "*value* 参数可以为任意对象，它随后会被转换为字符串。"

#: ../../library/asyncio-task.rst:1330
msgid ""
"In the default Task implementation, the name will be visible in the "
":func:`repr` output of a task object."
msgstr "在默认的 Task 实现中，名称将在任务对象的 :func:`repr` 输出中可见。"

#: ../../library/asyncio-task.rst:1337
msgid "Request the Task to be cancelled."
msgstr "请求取消 Task 对象。"

#: ../../library/asyncio-task.rst:1339
msgid ""
"If the Task is already *done* or *cancelled*, return ``False``, otherwise, "
"return ``True``."
msgstr "如果该 Task 已经 *完成* 或 *取消*，则返回 ``False``，否则，将返回 ``True``。"

#: ../../library/asyncio-task.rst:1342
msgid ""
"The method arranges for a :exc:`CancelledError` exception to be thrown into "
"the wrapped coroutine on the next cycle of the event loop."
msgstr "该方法将安排在下一轮事件循环中将 :exc:`CancelledError` 异常抛出给被封包的协程。"

#: ../../library/asyncio-task.rst:1345
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike "
":meth:`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task "
"will be cancelled, although suppressing cancellation completely is not "
"common and is actively discouraged.  Should the coroutine nevertheless "
"decide to suppress the cancellation, it needs to call :meth:`Task.uncancel` "
"in addition to catching the exception."
msgstr ""
"协程随后将有机会进行清理甚至通过 :keyword:`try` ... ... ``except CancelledError`` ... "
":keyword:`finally` 代码块抑制异常来拒绝请求。 因此，不同于 :meth:`Future.cancel`, "
":meth:`Task.cancel` 不保证 Task 会被取消，虽然完全抑制撤销并不常见也很不建议这样做。 "
"但是如果协程决定要抑制撤销，那么它需要额外调用 :meth:`Task.uncancel` 来捕获异常。"

#: ../../library/asyncio-task.rst:1355
msgid "Added the *msg* parameter."
msgstr "增加了 *msg* 形参。"

#: ../../library/asyncio-task.rst:1358
msgid ""
"The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr "``msg`` 形参将从被取消的任务传播到其等待方。"

#: ../../library/asyncio-task.rst:1363
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr "以下示例演示了协程是如何侦听取消请求的::"

#: ../../library/asyncio-task.rst:1366
msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # 等待 1 小时\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # 创建一个 \"cancel_me\" 任务\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # 等待 1 秒\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# 预期的输出：\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"

#: ../../library/asyncio-task.rst:1402
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "如果 Task 对象 *被取消* 则返回 ``True``。"

#: ../../library/asyncio-task.rst:1404
msgid ""
"The Task is *cancelled* when the cancellation was requested with "
":meth:`cancel` and the wrapped coroutine propagated the "
":exc:`CancelledError` exception thrown into it."
msgstr ""
"当使用 :meth:`cancel` 发出取消请求时 Task 会被 *取消*，其封包的协程将传播被抛入的 :exc:`CancelledError` "
"异常。"

#: ../../library/asyncio-task.rst:1410
msgid "Decrement the count of cancellation requests to this Task."
msgstr "递减对此任务的取消请求计数。"

#: ../../library/asyncio-task.rst:1412
msgid "Returns the remaining number of cancellation requests."
msgstr "返回剩余的取消请求数量。"

#: ../../library/asyncio-task.rst:1414
msgid ""
"Note that once execution of a cancelled task completed, further calls to "
":meth:`uncancel` are ineffective."
msgstr "请注意一旦被取消的任务执行完成，继续调用 :meth:`uncancel` 将是低效的。"

#: ../../library/asyncio-task.rst:1419
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this"
" allows for elements of structured concurrency like :ref:`taskgroups` and "
":func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"此方法是供 asyncio 内部使用而不应被最终用户代码所使用。 特别地，在一个 Task 成功地保持未取消状态的时候使用，这可以允许结构化的并发元素如"
" :ref:`taskgroups` 和 :func:`asyncio.timeout` 继续运行，将取消操作隔离在相应的结构化代码块中。 例如::"

#: ../../library/asyncio-task.rst:1426
msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # 受超时影响的结构块：\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # 不受超时影响的外层代码：\n"
"    await unrelated_code()"

#: ../../library/asyncio-task.rst:1437
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might"
" get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with "
":meth:`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` "
"in a similar fashion."
msgstr ""
"带有 ``make_request()`` 和 ``make_another_request()`` 的代码块可能因超时而被取消，而 "
"``unrelated_code()`` 应当在超时的情况下继续运行。 这是通过 :meth:`uncancel` 实现的。  "
":class:`TaskGroup` 上下文管理器也会以类似的方式来使用 :func:`uncancel`。"

#: ../../library/asyncio-task.rst:1443
msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching "
":exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr "如果最终用户代码出于某种原因通过捕获 :exc:`CancelledError` 抑制撤销操作，那么它需要调用此方法来移除撤销状态。"

#: ../../library/asyncio-task.rst:1447
msgid ""
"When this method decrements the cancellation count to zero, the method "
"checks if a previous :meth:`cancel` call had arranged for "
":exc:`CancelledError` to be thrown into the task. If it hasn't been thrown "
"yet, that arrangement will be rescinded (by resetting the internal "
"``_must_cancel`` flag)."
msgstr ""
"当该方法将取消计数递减至零，该方法会检查之前的 :meth:`cancel` 调用是否已安排将 :exc:`CancelledError` "
"抛出到任务中。 如果尚未抛出，则该安排将被撤销（通过重置内部的 ``_must_cancel`` 旗标 ）。"

#: ../../library/asyncio-task.rst:1453
msgid "Changed to rescind pending cancellation requests upon reaching zero."
msgstr "更改为在到达零值时撤回待处理的取消请求。"

#: ../../library/asyncio-task.rst:1458
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr "返回对此 Task 的挂起请求次数，即对 :meth:`cancel` 的调用次数减去 :meth:`uncancel` 的调用次数。"

#: ../../library/asyncio-task.rst:1462
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"请注意如果该数字大于零但相应 Task 仍在执行，:meth:`cancelled` 仍将返回 ``False``。 这是因此该数字可通过调用 "
":meth:`uncancel` 来减少，这会导致任务在取消请求降到零时尚未被取消。"

#: ../../library/asyncio-task.rst:1468
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr "此方法是供 asyncio 内部使用而不应被最终用户代码所使用。 请参阅 :meth:`uncancel` 了解详情。"
