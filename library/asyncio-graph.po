# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-graph.rst:8
msgid "Call Graph Introspection"
msgstr "调用图内省"

#: ../../library/asyncio-graph.rst:10
msgid "**Source code:** :source:`Lib/asyncio/graph.py`"
msgstr "**源代码:** :source:`Lib/asyncio/graph.py`"

#: ../../library/asyncio-graph.rst:14
msgid ""
"asyncio has powerful runtime call graph introspection utilities to trace the"
" entire call graph of a running *coroutine* or *task*, or a suspended "
"*future*.  These utilities and the underlying machinery can be used from "
"within a Python program or by external profilers and debuggers."
msgstr ""
"asyncio具有强大的运行时调用图自检实用程序，可以跟踪正在运行的 *协程* 或 *任务* 或挂起的 *future* "
"的整个调用图。这些实用程序和底层机制可以在Python程序中使用，也可以由外部分析器和调试器使用。"

#: ../../library/asyncio-graph.rst:25
msgid ""
"Print the async call graph for the current task or the provided "
":class:`Task` or :class:`Future`."
msgstr "打印当前任务或提供的 :class:`Task` 或 :class:`Future` 的异步调用图。"

#: ../../library/asyncio-graph.rst:28
msgid ""
"This function prints entries starting from the top frame and going down "
"towards the invocation point."
msgstr "此函数从顶部帧开始打印条目，并向下打印到调用点。"

#: ../../library/asyncio-graph.rst:31
msgid ""
"The function receives an optional *future* argument. If not passed, the "
"current running task will be used."
msgstr "该函数接收一个可选的 *future* 参数。如果没有传入，则使用当前运行的任务。"

#: ../../library/asyncio-graph.rst:34 ../../library/asyncio-graph.rst:93
msgid ""
"If the function is called on *the current task*, the optional keyword-only "
"*depth* argument can be used to skip the specified number of frames from top"
" of the stack."
msgstr "如果在 *当前任务* 上调用该函数，可选的仅限关键字 *depth* 参数可用于从堆栈顶部跳过指定的帧数。"

#: ../../library/asyncio-graph.rst:38
msgid ""
"If the optional keyword-only *limit* argument is provided, each call stack "
"in the resulting graph is truncated to include at most ``abs(limit)`` "
"entries. If *limit* is positive, the entries left are the closest to the "
"invocation point. If *limit* is negative, the topmost entries are left. If "
"*limit* is omitted or ``None``, all entries are present. If *limit* is "
"``0``, the call stack is not printed at all, only \"awaited by\" information"
" is printed."
msgstr ""
"如果提供了可选的仅限关键字 *limit* 参数，则结果图中的每个调用堆栈将被截断，以最多包含``abs(limit)``项。如果 *limit* "
"为正数，则剩下的条目是最接近调用点的。如果 *limit* 为负数，则保留最上面的项。如果 *limit* "
"省略或为``None``，则所有条目都存在。如果 *limit* 为``0``，则根本不打印调用堆栈，只打印“awaited by”信息。"

#: ../../library/asyncio-graph.rst:46
msgid ""
"If *file* is omitted or ``None``, the function will print to "
":data:`sys.stdout`."
msgstr "如果 *file* 省略或为``None``，该函数将打印到 :data:`sys.stdout`。"

#: ../../library/asyncio-graph.rst:49
msgid "**Example:**"
msgstr "**示例:**"

#: ../../library/asyncio-graph.rst:51
msgid "The following Python code:"
msgstr "以下 Python 代码："

#: ../../library/asyncio-graph.rst:53
msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    asyncio.print_call_graph()\n"
"\n"
"async def main():\n"
"    async with asyncio.TaskGroup() as g:\n"
"        g.create_task(test(), name='test')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    asyncio.print_call_graph()\n"
"\n"
"async def main():\n"
"    async with asyncio.TaskGroup() as g:\n"
"        g.create_task(test(), name='test')\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-graph.rst:66
msgid "will print::"
msgstr "将打印::"

#: ../../library/asyncio-graph.rst:68
msgid ""
"* Task(name='test', id=0x1039f0fe0)\n"
"+ Call stack:\n"
"|   File 't2.py', line 4, in async test()\n"
"+ Awaited by:\n"
"   * Task(name='Task-1', id=0x103a5e060)\n"
"      + Call stack:\n"
"      |   File 'taskgroups.py', line 107, in async TaskGroup.__aexit__()\n"
"      |   File 't2.py', line 7, in async main()"
msgstr ""
"* Task(name='test', id=0x1039f0fe0)\n"
"+ Call stack:\n"
"|   File 't2.py', line 4, in async test()\n"
"+ Awaited by:\n"
"   * Task(name='Task-1', id=0x103a5e060)\n"
"      + Call stack:\n"
"      |   File 'taskgroups.py', line 107, in async TaskGroup.__aexit__()\n"
"      |   File 't2.py', line 7, in async main()"

#: ../../library/asyncio-graph.rst:79
msgid ""
"Like :func:`print_call_graph`, but returns a string. If *future* is ``None``"
" and there's no current task, the function returns an empty string."
msgstr ""
"类似于 :func:`print_call_graph`，但返回一个字符串。如果 *future* 为 ``None`` "
"并且没有当前任务，则该函数返回一个空字符串。"

#: ../../library/asyncio-graph.rst:86
msgid ""
"Capture the async call graph for the current task or the provided "
":class:`Task` or :class:`Future`."
msgstr "捕获当前任务或提供的 :class:`Task` 或 :class:`Future` 的异步调用图。"

#: ../../library/asyncio-graph.rst:89
msgid ""
"The function receives an optional *future* argument. If not passed, the "
"current running task will be used. If there's no current task, the function "
"returns ``None``."
msgstr "该函数接收一个可选的 *future* 参数。如果没有传入，则使用当前运行的任务。如果当前没有任务，该函数返回``None``。"

#: ../../library/asyncio-graph.rst:97
msgid "Returns a ``FutureCallGraph`` data class object:"
msgstr "返回``FutureCallGraph``数据类对象。"

#: ../../library/asyncio-graph.rst:99
msgid "``FutureCallGraph(future, call_stack, awaited_by)``"
msgstr "``FutureCallGraph(future, call_stack, awaited_by)``"

#: ../../library/asyncio-graph.rst:101
msgid ""
"Where *future* is a reference to a :class:`Future` or a :class:`Task` (or "
"their subclasses.)"
msgstr "其中 *future* 是一个指向 :class:`Future` 或 :class:`Task` (或其子类) 的引用。"

#: ../../library/asyncio-graph.rst:104
msgid "``call_stack`` is a tuple of ``FrameCallGraphEntry`` objects."
msgstr "``call_stack`` 是一个 ``FrameCallGraphEntry`` 对象的元组。"

#: ../../library/asyncio-graph.rst:106
msgid "``awaited_by`` is a tuple of ``FutureCallGraph`` objects."
msgstr "``awaited_by`` 是一个 ``FutureCallGraph`` 对象的元组。"

#: ../../library/asyncio-graph.rst:108
msgid "``FrameCallGraphEntry(frame)``"
msgstr "``FrameCallGraphEntry(frame)``"

#: ../../library/asyncio-graph.rst:110
msgid ""
"Where *frame* is a frame object of a regular Python function in the call "
"stack."
msgstr "其中 *frame* 是调用栈中常规Python函数的帧对象。"

#: ../../library/asyncio-graph.rst:115
msgid "Low level utility functions"
msgstr "底层实用工具函数"

#: ../../library/asyncio-graph.rst:117
msgid ""
"To introspect an async call graph asyncio requires cooperation from control "
"flow structures, such as :func:`shield` or :class:`TaskGroup`. Any time an "
"intermediate :class:`Future` object with low-level APIs like "
":meth:`Future.add_done_callback() <asyncio.Future.add_done_callback>` is "
"involved, the following two functions should be used to inform asyncio about"
" how exactly such intermediate future objects are connected with the tasks "
"they wrap or control."
msgstr ""
"要自检一个异步调用图，asyncio 需要控制流结构的配合，比如 :func:`shield` 或 :class:`TaskGroup`。 "
"任何时候涉及到具有底层 API (如 :meth:`Future.add_done_callback() "
"<asyncio.Future.add_done_callback>`) 的中间 :class:`Future` 对象时，都应该使用以下两个函数来通知 "
"asyncio 这些中间 Future 对象是如何与它们包装或控制的任务连接的。"

#: ../../library/asyncio-graph.rst:128
msgid "Record that *future* is awaited on by *waiter*."
msgstr "*future* 被 *waiter* 等待的记录。"

#: ../../library/asyncio-graph.rst:130 ../../library/asyncio-graph.rst:143
msgid ""
"Both *future* and *waiter* must be instances of :class:`Future` or "
":class:`Task` or their subclasses, otherwise the call would have no effect."
msgstr ""
"*future* 和 *waiter* 都必须是 :class:`Future` 或 :class:`Task` "
"或它们的子类的实例，否则该调用将不起作用。"

#: ../../library/asyncio-graph.rst:134
msgid ""
"A call to ``future_add_to_awaited_by()`` must be followed by an eventual "
"call to the :func:`future_discard_from_awaited_by` function with the same "
"arguments."
msgstr ""
"调用 ``future_add_to_awaited_by()`` 必须随后使用相同的参数最终调用 "
":func:`future_discard_from_awaited_by` 函数。"

#: ../../library/asyncio-graph.rst:141
msgid "Record that *future* is no longer awaited on by *waiter*."
msgstr "*future* 不再被 *waiter* 等待的记录。"
