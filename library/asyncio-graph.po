# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-05-08 06:04+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-graph.rst:8
msgid "Call Graph Introspection"
msgstr "调用图内省"

#: ../../library/asyncio-graph.rst:10
msgid "**Source code:** :source:`Lib/asyncio/graph.py`"
msgstr "**源代码:** :source:`Lib/asyncio/graph.py`"

#: ../../library/asyncio-graph.rst:14
msgid ""
"asyncio has powerful runtime call graph introspection utilities to trace the"
" entire call graph of a running *coroutine* or *task*, or a suspended "
"*future*.  These utilities and the underlying machinery can be used from "
"within a Python program or by external profilers and debuggers."
msgstr ""

#: ../../library/asyncio-graph.rst:25
msgid ""
"Print the async call graph for the current task or the provided "
":class:`Task` or :class:`Future`."
msgstr ""

#: ../../library/asyncio-graph.rst:28
msgid ""
"This function prints entries starting from the top frame and going down "
"towards the invocation point."
msgstr ""

#: ../../library/asyncio-graph.rst:31
msgid ""
"The function receives an optional *future* argument. If not passed, the "
"current running task will be used."
msgstr ""

#: ../../library/asyncio-graph.rst:34 ../../library/asyncio-graph.rst:93
msgid ""
"If the function is called on *the current task*, the optional keyword-only "
"*depth* argument can be used to skip the specified number of frames from top"
" of the stack."
msgstr ""

#: ../../library/asyncio-graph.rst:38
msgid ""
"If the optional keyword-only *limit* argument is provided, each call stack "
"in the resulting graph is truncated to include at most ``abs(limit)`` "
"entries. If *limit* is positive, the entries left are the closest to the "
"invocation point. If *limit* is negative, the topmost entries are left. If "
"*limit* is omitted or ``None``, all entries are present. If *limit* is "
"``0``, the call stack is not printed at all, only \"awaited by\" information"
" is printed."
msgstr ""

#: ../../library/asyncio-graph.rst:46
msgid ""
"If *file* is omitted or ``None``, the function will print to "
":data:`sys.stdout`."
msgstr ""

#: ../../library/asyncio-graph.rst:49
msgid "**Example:**"
msgstr "**示例:**"

#: ../../library/asyncio-graph.rst:51
msgid "The following Python code:"
msgstr "以下 Python 代码："

#: ../../library/asyncio-graph.rst:53
msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    asyncio.print_call_graph()\n"
"\n"
"async def main():\n"
"    async with asyncio.TaskGroup() as g:\n"
"        g.create_task(test(), name='test')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    asyncio.print_call_graph()\n"
"\n"
"async def main():\n"
"    async with asyncio.TaskGroup() as g:\n"
"        g.create_task(test(), name='test')\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-graph.rst:66
msgid "will print::"
msgstr "将打印::"

#: ../../library/asyncio-graph.rst:68
msgid ""
"* Task(name='test', id=0x1039f0fe0)\n"
"+ Call stack:\n"
"|   File 't2.py', line 4, in async test()\n"
"+ Awaited by:\n"
"   * Task(name='Task-1', id=0x103a5e060)\n"
"      + Call stack:\n"
"      |   File 'taskgroups.py', line 107, in async TaskGroup.__aexit__()\n"
"      |   File 't2.py', line 7, in async main()"
msgstr ""
"* Task(name='test', id=0x1039f0fe0)\n"
"+ Call stack:\n"
"|   File 't2.py', line 4, in async test()\n"
"+ Awaited by:\n"
"   * Task(name='Task-1', id=0x103a5e060)\n"
"      + Call stack:\n"
"      |   File 'taskgroups.py', line 107, in async TaskGroup.__aexit__()\n"
"      |   File 't2.py', line 7, in async main()"

#: ../../library/asyncio-graph.rst:79
msgid ""
"Like :func:`print_call_graph`, but returns a string. If *future* is ``None``"
" and there's no current task, the function returns an empty string."
msgstr ""

#: ../../library/asyncio-graph.rst:86
msgid ""
"Capture the async call graph for the current task or the provided "
":class:`Task` or :class:`Future`."
msgstr ""

#: ../../library/asyncio-graph.rst:89
msgid ""
"The function receives an optional *future* argument. If not passed, the "
"current running task will be used. If there's no current task, the function "
"returns ``None``."
msgstr ""

#: ../../library/asyncio-graph.rst:97
msgid "Returns a ``FutureCallGraph`` data class object:"
msgstr ""

#: ../../library/asyncio-graph.rst:99
msgid "``FutureCallGraph(future, call_stack, awaited_by)``"
msgstr "``FutureCallGraph(future, call_stack, awaited_by)``"

#: ../../library/asyncio-graph.rst:101
msgid ""
"Where *future* is a reference to a :class:`Future` or a :class:`Task` (or "
"their subclasses.)"
msgstr "其中 *future* 是一个指向 :class:`Future` 或 :class:`Task` (或其子类) 的引用。"

#: ../../library/asyncio-graph.rst:104
msgid "``call_stack`` is a tuple of ``FrameCallGraphEntry`` objects."
msgstr "``call_stack`` 是一个 ``FrameCallGraphEntry`` 对象的元组。"

#: ../../library/asyncio-graph.rst:106
msgid "``awaited_by`` is a tuple of ``FutureCallGraph`` objects."
msgstr ""

#: ../../library/asyncio-graph.rst:108
msgid "``FrameCallGraphEntry(frame)``"
msgstr ""

#: ../../library/asyncio-graph.rst:110
msgid ""
"Where *frame* is a frame object of a regular Python function in the call "
"stack."
msgstr ""

#: ../../library/asyncio-graph.rst:115
msgid "Low level utility functions"
msgstr ""

#: ../../library/asyncio-graph.rst:117
msgid ""
"To introspect an async call graph asyncio requires cooperation from control "
"flow structures, such as :func:`shield` or :class:`TaskGroup`. Any time an "
"intermediate :class:`Future` object with low-level APIs like "
":meth:`Future.add_done_callback() <asyncio.Future.add_done_callback>` is "
"involved, the following two functions should be used to inform asyncio about"
" how exactly such intermediate future objects are connected with the tasks "
"they wrap or control."
msgstr ""

#: ../../library/asyncio-graph.rst:128
msgid "Record that *future* is awaited on by *waiter*."
msgstr ""

#: ../../library/asyncio-graph.rst:130 ../../library/asyncio-graph.rst:143
msgid ""
"Both *future* and *waiter* must be instances of :class:`Future` or "
":class:`Task` or their subclasses, otherwise the call would have no effect."
msgstr ""

#: ../../library/asyncio-graph.rst:134
msgid ""
"A call to ``future_add_to_awaited_by()`` must be followed by an eventual "
"call to the :func:`future_discard_from_awaited_by` function with the same "
"arguments."
msgstr ""

#: ../../library/asyncio-graph.rst:141
msgid "Record that *future* is no longer awaited on by *waiter*."
msgstr ""
