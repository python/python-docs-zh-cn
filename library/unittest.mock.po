# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.mock.rst:2
msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`!unittest.mock` --- 模拟对象库"

#: ../../library/unittest.mock.rst:12
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**源代码：** :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:16
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` "
"是一个用于测试的Python库。它允许使用模拟对象来替换受测系统的一些部分，并对这些部分如何被使用进行断言判断。"

#: ../../library/unittest.mock.rst:20
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` 提供的 :class:`Mock` "
"类，能在整个测试套件中模拟大量的方法。创建后，就可以断言调用了哪些方法/属性及其参数。还可以以常规方式指定返回值并设置所需的属性。"

#: ../../library/unittest.mock.rst:26
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with "
":const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and "
":func:`patch`."
msgstr ""
"此外，mock 还提供了用于修补测试范围内模块和类级别属性的 :func:`patch` 装饰器，和用于创建独特对象的 "
":const:`sentinel` 。 阅读 `quick guide`_ 中的案例了解如何使用 :class:`Mock` "
"，:class:`MagicMock` 和 :func:`patch` 。"

#: ../../library/unittest.mock.rst:32
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action ->"
" assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"mock 被设计为配合 :mod:`unittest` 使用且它是基于 'action -> assertion' 模式而非许多模拟框架所使用的 "
"'record -> replay' 模式。"

#: ../../library/unittest.mock.rst:36
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as :pypi:`mock` on PyPI."
msgstr ""
"对于较早版本的 Python 有一个反向移植的 :mod:`unittest.mock`，即在 PyPI 上可用的 :pypi:`mock`。"

#: ../../library/unittest.mock.rst:41
msgid "Quick Guide"
msgstr "快速上手"

#: ../../library/unittest.mock.rst:59
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You"
" can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
"当您访问对象时， :class:`Mock` 和 :class:`MagicMock` "
"将创建所有属性和方法，并保存他们在使用时的细节。你可以通过配置，指定返回值或者限制可访问属性，然后断言他们如何被调用："

#: ../../library/unittest.mock.rst:71
msgid ""
":attr:`~Mock.side_effect` allows you to perform side effects, including "
"raising an exception when a mock is called:"
msgstr ":attr:`~Mock.side_effect` 允许你执行附带影响，包括在 mock 被调用时引发一个异常："

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For"
" example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock 还可以通过其他方法配置和控制其行为。例如 mock 可以通过设置 *spec* "
"参数来从一个对象中获取其规格(specification)。如果访问 mock 的属性或方法不在 spec 中，会报 "
":exc:`AttributeError` 错误。"

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
"使用 :func:`patch` 装饰去/上下文管理器，可以更方便地测试一个模块下的类或对象。你指定的对象会在测试过程中替换成 mock "
"（或者其他对象），测试结束后恢复。"

#: ../../library/unittest.mock.rst:101
msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"当你嵌套 patch 装饰器时，mock 将以执行顺序传递给装饰器函数（*Python* 装饰器正常顺序）。由于从下至上，因此在上面的示例中，首先 "
"mock 传入的 ``module.ClassName1`` 。"

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"在查找对象的名称空间中修补对象使用 :func:`patch` 。使用起来很简单，阅读 :ref:`在哪里打补丁 <where-to-patch>` "
"来快速上手。"

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ":func:`patch` 也可以 with 语句中使用上下文管理。"

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr "还有一个 :func:`patch.dict` 用于在一定范围内设置字典中的值，并在测试结束时将字典恢复为其原始状态："

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class."
" It allows you to do things like:"
msgstr ""
"Mock支持 Python :ref:`魔术方法 <magic-methods>` 。使用模式方法最简单的方式是使用 "
":class:`MagicMock` class. 。它可以做如下事情："

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you"
" (well, all the useful ones anyway)."
msgstr ""
"Mock 能指定函数（或其他 Mock 实例）为魔术方法，它们将被适当地调用。  :class:`MagicMock` "
"是预先创建了所有魔术方法（所有有用的方法） 的 Mock 。"

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr "下面是一个使用了普通 Mock 类的魔术方法的例子"

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"使用 :ref:`auto-speccing <auto-speccing>` 可以保证测试中的模拟对象与要替换的对象具有相同的api 。在 patch"
"  中可以通过 *autospec* 参数实现自动推断，或者使用 :func:`create_autospec` "
"函数。自动推断会创建一个与要替换对象相同的属相和方法的模拟对象，并且任何函数和方法（包括构造函数）都具有与真实对象相同的调用签名。"

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr "这么做是为了因确保不当地使用 mock 导致与生产代码相同的失败："

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
"在类中使用 :func:`create_autospec` 时，会复制 ``__init__`` 方法的签名，另外在可调用对象上使用时，会复制 "
"``__call__`` 方法的签名。"

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "Mock 类"

#: ../../library/unittest.mock.rst:213
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs"
" and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` 是一个可以灵活的替换存根 (stubs) 的对象，可以测试所有代码。 Mock 是可调用的，在访问其属性时创建一个新的 "
"mock [#]_ 。访问相同的属性只会返回相同的 mock 。 Mock 会保存调用记录，可以通过断言获悉代码的调用。"

#: ../../library/unittest.mock.rst:219
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods"
" pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: "
":class:`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` 是  :class:`Mock` 的子类，它有所有预创建且可使用的魔术方法。在需要模拟不可调用对象时，可以使用 "
":class:`NonCallableMock`  和 :class:`NonCallableMagicMock`"

#: ../../library/unittest.mock.rst:224
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in"
" a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
":func:`patch` 装饰器使得用 :class:`Mock` 对象临时替换特定模块中的类非常方便。 默认情况下 :func:`patch` "
"将为你创建一个 :class:`MagicMock`。 你可以使用 :func:`patch` 的 *new_callable* 参数指定替代 "
":class:`Mock` 的类。"

#: ../../library/unittest.mock.rst:232
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr "创建一个新的  :class:`Mock` 对象。通过可选参数指定 :class:`Mock` 对象的行为："

#: ../../library/unittest.mock.rst:235
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass"
" in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*: 可以是要给字符串列表，也可以是充当模拟对象规范的现有对象（类或实例）。如果传入一个对象，则通过在该对象上调用 dir "
"来生成字符串列表（不支持的魔法属性和方法除外）。访问不在此列表中的任何属性都将触发 :exc:`AttributeError` 。"

#: ../../library/unittest.mock.rst:241
msgid ""
"If *spec* is an object (rather than a list of strings) then "
":attr:`~object.__class__` returns the class of the spec object. This allows "
"mocks to pass :func:`isinstance` tests."
msgstr ""
"如果 *spec* 是一个对象（而不是字符串列表）则 :attr:`~object.__class__` 将返回 spec 对象的类。 这允许 mock"
" 通过 :func:`isinstance` 测试。"

#: ../../library/unittest.mock.rst:245
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set* ：*spec* 的更严格的变体。如果使用了该属性，尝试模拟 *set* 或 *get* 的属性不在 *spec_set* "
"所包含的对象中时，会抛出 :exc:`AttributeError` 。"

#: ../../library/unittest.mock.rst:249
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the "
":attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect* ：每当调用 Mock 时都会调用的函数。 参见  :attr:`~Mock.side_effect`  属性。 "
"对于引发异常或动态更改返回值很有用。 该函数使用与 mock 函数相同的参数调用，并且除非返回 :data:`DEFAULT` "
"，否则该函数的返回值将用作返回值。"

#: ../../library/unittest.mock.rst:255
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr "另外， *side_effect* 可以是异常类或实例。 此时，调用模拟程序时将引发异常。"

#: ../../library/unittest.mock.rst:258
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr "如果 *side_effect* 是可迭代对象，则每次调用 mock 都将返回可迭代对象的下一个值。"

#: ../../library/unittest.mock.rst:261
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "设置 *side_effect* 为 ``None`` 即可清空。"

#: ../../library/unittest.mock.rst:263
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value* ：调用 mock 的返回值。 默认情况下，是一个新的Mock（在首次访问时创建）。 参见 "
":attr:`return_value` 属性 。"

#: ../../library/unittest.mock.rst:267
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an "
":exc:`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*unsafe*: 在默认情况下，访问任何名字以 *assert*, *assret*, *asert*, *aseert* 或 *assrt* "
"开头的属性都将引发 :exc:`AttributeError`。 传入 ``unsafe=True`` 将允许访问这些属性。"

#: ../../library/unittest.mock.rst:274
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning"
" the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an "
":exc:`AttributeError`)."
msgstr ""
"*wraps* ：要包装的 mock 对象。 如果 *wraps* 不是 ``None`` ，那么调用 Mock 会将调用传递给 *wraps* "
"的对象（返回实际结果）。 对模拟的属性访问将返回一个 Mock 对象，该对象包装了 *wraps* 对象的相应属性（因此，尝试访问不存在的属性将引发  "
":exc:`AttributeError` ）。"

#: ../../library/unittest.mock.rst:281
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr "如果明确指定 *return_value* ，则调用时不会返回包装对象，而是返回 *return_value* 。"

#: ../../library/unittest.mock.rst:284
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock."
" This can be useful for debugging. The name is propagated to child mocks."
msgstr "*name* ：mock 的名称。 在调试时很有用。 名称会传递到子 mock 。"

#: ../../library/unittest.mock.rst:288
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the "
":meth:`configure_mock` method for details."
msgstr ""
"还可以使用任意关键字参数来调用 mock 。 创建模拟后，将使用这些属性来设置 mock 的属性。 有关详细信息，请参见 "
":meth:`configure_mock`  方法。"

#: ../../library/unittest.mock.rst:294
msgid "Assert that the mock was called at least once."
msgstr "断言 mock 已被调用至少一次。"

#: ../../library/unittest.mock.rst:305
msgid "Assert that the mock was called exactly once."
msgstr "断言 mock 已被调用恰好一次。"

#: ../../library/unittest.mock.rst:324
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr "此方法是断言上次调用已以特定方式进行的一种便捷方法："

#: ../../library/unittest.mock.rst:334
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr "断言 mock 已被调用恰好一次，并且向该调用传入了指定的参数。"

#: ../../library/unittest.mock.rst:349
msgid "assert the mock has been called with the specified arguments."
msgstr "断言 mock 已被调用并附带了指定的参数。"

#: ../../library/unittest.mock.rst:351
msgid ""
"The assert passes if the mock has *ever* been called, unlike "
":meth:`assert_called_with` and :meth:`assert_called_once_with` that only "
"pass if the call is the most recent one, and in the case of "
":meth:`assert_called_once_with` it must also be the only call."
msgstr ""
"如果 mock *曾经* 被调用过则断言通过，不同于 :meth:`assert_called_with` 和 "
":meth:`assert_called_once_with` 那样只有在调用是最近的一次时才会通过，而对于 "
":meth:`assert_called_once_with` 则它还必须是唯一的一次调用。"

#: ../../library/unittest.mock.rst:364
msgid ""
"assert the mock has been called with the specified calls. The "
":attr:`mock_calls` list is checked for the calls."
msgstr "断言 mock 已附带指定的参数被调用。 将针对这些调用检查 :attr:`mock_calls` 列表。"

#: ../../library/unittest.mock.rst:367
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr "如果 *any_order* 为假值则调用必须是顺序进行的。 在指定的调用之前或之后还可以有额外的调用。"

#: ../../library/unittest.mock.rst:371
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all"
" appear in :attr:`mock_calls`."
msgstr "如果 *any_order* 为真值则调用可以是任意顺序的，但它们都必须在 :attr:`mock_calls` 中出现。"

#: ../../library/unittest.mock.rst:386
msgid "Assert the mock was never called."
msgstr "断言 mock 从未被调用过。"

#: ../../library/unittest.mock.rst:402
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "reset_mock 方法将在 mock 对象上重围所有的调用属性:"

#: ../../library/unittest.mock.rst:404
msgid ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hello')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"
msgstr ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hello')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"

#: ../../library/unittest.mock.rst:414
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object."
msgstr "这在你希望执行重用相同对象的一系列断言的场合下将会很有用处。"

#: ../../library/unittest.mock.rst:417
msgid ""
"*return_value* parameter when set to ``True`` resets :attr:`return_value`:"
msgstr "*return_value* 形参在设为 ``True`` 时将重置 :attr:`return_value`:"

#: ../../library/unittest.mock.rst:419
msgid ""
">>> mock = Mock(return_value=5)\n"
">>> mock('hello')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
">>> mock = Mock(return_value=5)\n"
">>> mock('hello')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"

#: ../../library/unittest.mock.rst:428
msgid ""
"*side_effect* parameter when set to ``True`` resets :attr:`side_effect`:"
msgstr "*side_effect* 形参在设为 ``True`` 将重置 :attr:`side_effect`:"

#: ../../library/unittest.mock.rst:430
msgid ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('hello')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('hello')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"

#: ../../library/unittest.mock.rst:441
msgid ""
"Note that :meth:`reset_mock` *doesn't* clear the :attr:`return_value`, "
":attr:`side_effect` or any child attributes you have set using normal "
"assignment by default."
msgstr ""
"请注意 :meth:`reset_mock` 在默认情况下 *不会* 清除 :attr:`return_value`, "
":attr:`side_effect` 或任何你使用普通赋值设置的子属性。"

#: ../../library/unittest.mock.rst:445
msgid "Child mocks are reset as well."
msgstr "子 mock 也会被重置。"

#: ../../library/unittest.mock.rst:447
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr "向 reset_mock 函数添加了两个仅限关键字参数。"

#: ../../library/unittest.mock.rst:452
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr "为 mock 添加描述。 *spec* 可以是一个对象或字符串列表。 只有 *spec* 上的属性可以作为来自 mock 的属性被获取。"

#: ../../library/unittest.mock.rst:456
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr "如果 *spec_set* 为真值则只有 spec 上的属性可以被设置。"

#: ../../library/unittest.mock.rst:461
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and "
":attr:`mock_calls` attributes of this one."
msgstr ""
"附加一个 mock 作为这一个的属性，替换它的名称和上级。 对附加 mock 的调用将记录在这一个的 :attr:`method_calls` 和 "
":attr:`mock_calls` 属性中。"

#: ../../library/unittest.mock.rst:468
msgid "Set attributes on the mock through keyword arguments."
msgstr "通过关键字参数在 mock 上设置属性。"

#: ../../library/unittest.mock.rst:470
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr "属性加返回值和附带影响可以使用标准点号标记在子 mock 上设置并在方法调用中解包一个字典:"

#: ../../library/unittest.mock.rst:484
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "同样的操作可在对 mock 的构造器调用中达成:"

#: ../../library/unittest.mock.rst:497
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ":meth:`configure_mock` 的存在是使得 mock 被创建之后的配置更为容易。"

#: ../../library/unittest.mock.rst:503
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
":class:`Mock` 对象会将 ``dir(some_mock)`` 的结果限制为有用结果。 对于带有 *spec* 的 mock 这还包括 "
"mock 的所有被允许的属性。"

#: ../../library/unittest.mock.rst:507
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr "请查看 :data:`FILTER_DIR` 了解此过滤做了什么，以及如何停用它。"

#: ../../library/unittest.mock.rst:513
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"创建针对属性和返回值的子 mock。 默认情况下子 mock 将为与其上级相同的类型。 Mock 的子类可能需要重载它来定制子 mock 的创建方式。"

#: ../../library/unittest.mock.rst:518
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr "对于非可调用的 mock 将会使用可调用的变化形式（而非不是任意的自定义子类）。"

#: ../../library/unittest.mock.rst:524
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "一个表示 mock 对象是否已被调用的布尔值:"

#: ../../library/unittest.mock.rst:535
msgid "An integer telling you how many times the mock object has been called:"
msgstr "一个告诉你 mock 对象已被调用多少次的整数值:"

#: ../../library/unittest.mock.rst:547
msgid "Set this to configure the value returned by calling the mock:"
msgstr "设置这个来配置通过调用该 mock 所返回的值:"

#: ../../library/unittest.mock.rst:554
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr "默认的返回值是一个 mock 对象并且你可以通过正常方式来配置它:"

#: ../../library/unittest.mock.rst:563
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` 也可以在构造器中设置:"

#: ../../library/unittest.mock.rst:574
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"这可以是当该This can either be a function to be called when the mock "
"被调用时将被调用的一个函数，可调用对象或者要被引发的异常（类或实例）。"

#: ../../library/unittest.mock.rst:577
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from the"
" :attr:`return_value`)."
msgstr ""
"如果你传入一个函数则它将附带与该 mock 相同的参数被调用并且除了该函数返回 :data:`DEFAULT` 单例的情况以外对该 mock "
"的调用都将随后返回该函数所返回的任何东西。 如果该函数返回 :data:`DEFAULT` 则该 mock 将返回其正常值 (来自 "
":attr:`return_value`)。"

#: ../../library/unittest.mock.rst:583
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance"
" to be raised, or a value to be returned from the call to the mock "
"(:data:`DEFAULT` handling is identical to the function case)."
msgstr ""
"如果你传入一个可迭代对象，它会被用来获取一个在每次调用时必须产生一个值的迭代器。 这个值可以是一个要被引发的异常实例，或是一个要从该调用返回给 mock"
" 的值 (:data:`DEFAULT` 处理与函数的情况一致)。"

#: ../../library/unittest.mock.rst:588
msgid ""
"An example of a mock that raises an exception (to test exception handling of"
" an API):"
msgstr "一个引发异常（来测试 API 的异常处理）的 mock 的示例:"

#: ../../library/unittest.mock.rst:598
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "使用 :attr:`side_effect` 来返回包含多个值的序列:"

#: ../../library/unittest.mock.rst:605
msgid "Using a callable:"
msgstr "使用一个可调用对象:"

#: ../../library/unittest.mock.rst:615
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ":attr:`side_effect` 可以在构造器中设置。 下面是在 mock 被调用时增加一个该属性值并返回它的例子:"

#: ../../library/unittest.mock.rst:625
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "将 :attr:`side_effect` 设为 ``None`` 可以清除它:"

#: ../../library/unittest.mock.rst:639
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the"
" first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"这可以是 ``None`` (如果 mock 没有被调用)，或是 mock 最近一次被调用时附带的参数。 这将采用元组的形式：第一个成员也可以通过 "
"``args`` 特征属性来访问，它是 mock 被调用时所附带的任何位置参数 (或为空元组)，而第二个成员也可以通过 ``kwargs`` "
"特征属性来访问，它则是任何关键字参数 (或为空字典)。"

#: ../../library/unittest.mock.rst:672
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, "
":attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args`，以及列表 :attr:`call_args_list`, :attr:`method_calls` 和 "
":attr:`mock_calls` 的成员都是 :data:`call` 对象。 "
"这些对象属性元组，因此它们可被解包以获得单独的参数并创建更复杂的断言。 参见 :ref:`作为元组的 call <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:678
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "增加了 ``args`` 和 ``kwargs`` 特征属性。properties."

#: ../../library/unittest.mock.rst:684
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with "
":attr:`call_args_list`."
msgstr ""
"这是一个已排序的对 mock 对象的所有调用的列表（因此该列表的长度就是它已被调用的次数）。 在执行任何调用之前它将是一个空列表。 "
":data:`call` 对象可以被用来方便地构造调用列表以与 :attr:`call_args_list` 相比较。"

#: ../../library/unittest.mock.rst:700
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list` 的成员均为 :data:`call` 对象。 它们可作为元组被解包以获得单个参数。 参见 "
":ref:`作为元组的 call <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:707
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr "除了会追踪对其自身的调用，mock 还会追踪对方法和属性，以及 *它们的* 方法和属性的访问:"

#: ../../library/unittest.mock.rst:718
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls` 的成员均为 :data:`call` 对象。 它们可以作为元组被解包以获得单个参数。 参见 "
":ref:`作为元组的 call <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:725
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ":attr:`mock_calls` 会记录 *所有* 对 mock 对象、它的方法、魔术方法的调用 *以及* 返回值的 mock。"

#: ../../library/unittest.mock.rst:743
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`mock_calls` 的成员均为 :data:`call` 对象。 它们可以作为元组被解包以获得单个参数。 参见 :ref:`作为元组的"
" call <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:749
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ":attr:`mock_calls` 的记录方式意味着在进行嵌套调用时，之前调用的形参不会被记录因而这样的比较将总是相等:"

#: ../../library/unittest.mock.rst:763
msgid ""
"Normally the :attr:`!__class__` attribute of an object will return its type."
" For a mock object with a :attr:`!spec`, :attr:`!__class__` returns the spec"
" class instead. This allows mock objects to pass :func:`isinstance` tests "
"for the object they are replacing / masquerading as:"
msgstr ""
"通常一个对象的 :attr:`!__class__` 属性将返回其类型。 对于具有 :attr:`!spec` 的 mock "
"对象，:attr:`!__class__` 将改为返回 spec 类。 这允许 mock 为它们所替换 / 屏蔽的对象跳过 "
":func:`isinstance` 测试："

#: ../../library/unittest.mock.rst:772
msgid ""
":attr:`!__class__` is assignable to, this allows a mock to pass an "
":func:`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`!__class__` 是可以被赋值的，这允许 mock 跳过 :func:`isinstance` 检测而不强制要求你使用 spec："

#: ../../library/unittest.mock.rst:782
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the"
" same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"不可调用的 :class:`Mock` 版本。 其构造器的形参具有与 :class:`Mock` 相同的含义，区别在于 *return_value* 和"
" *side_effect* 在不可调用的 mock 上没有意义。"

#: ../../library/unittest.mock.rst:786
msgid ""
"Mock objects that use a class or an instance as a :attr:`!spec` or "
":attr:`!spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"使用一个类或实例作为 :attr:`!spec` 或 :attr:`!spec_set` 的对象能够跳过 :func:`isinstance` 测试："

#: ../../library/unittest.mock.rst:796
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See "
":ref:`magic methods <magic-methods>` for the full details."
msgstr ""
":class:`Mock` 类具有对 mock 操作魔术方法的支持。 请参阅 :ref:`魔术方法 <magic-methods>` 了解完整细节。"

#: ../../library/unittest.mock.rst:799
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword"
" arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"mock 操作类和 :func:`patch` 装饰器都接受任意关键字参数用于配置。 对于 :func:`patch` "
"装饰器来说关键字参数会被传给所创建 mock 的构造器。 这些关键字被用于配置  mock 的属性:"

#: ../../library/unittest.mock.rst:810
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"子 mock 的返回值和附带效果也可使用带点号的标记通过相同的方式来设置。 由于你无法直接在调用中使用带点号的名称因此你需要创建一个字典并使用 "
"``**`` 来解包它:"

#: ../../library/unittest.mock.rst:825
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"使用 *spec* (或 *spec_set*) 创建的可调用 mock 将在匹配调用与 mock 时内省规格说明对象的签名。 "
"因此，它可以匹配实际调用的参数而不必关心它们是按位置还是按名称传入的::"

#: ../../library/unittest.mock.rst:830
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock.rst:838
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, "
":meth:`~Mock.assert_called_once_with`, :meth:`~Mock.assert_has_calls` and "
":meth:`~Mock.assert_any_call`.  When :ref:`auto-speccing`, it will also "
"apply to method calls on the mock object."
msgstr ""
"这适用于 :meth:`~Mock.assert_called_with`, "
":meth:`~Mock.assert_called_once_with`, :meth:`~Mock.assert_has_calls` 和 "
":meth:`~Mock.assert_any_call`。 当执行 :ref:`auto-speccing` 时，它还将应用于 mock "
"对象的方法调用。"

#: ../../library/unittest.mock.rst:843
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr "添加了在附带规格说明和自动规格说明的 mock 对象上的签名内省"

#: ../../library/unittest.mock.rst:849
msgid ""
"A mock intended to be used as a :class:`property`, or other "
":term:`descriptor`, on a class. :class:`PropertyMock` provides "
":meth:`~object.__get__` and :meth:`~object.__set__` methods so you can "
"specify a return value when it is fetched."
msgstr ""
"旨在作为类的 :class:`property` 或其他 :term:`descriptor` 的 mock。 "
":class:`PropertyMock` 提供了 :meth:`~object.__get__` 和 :meth:`~object.__set__` "
"方法以便你可以在它被提取时指定一个返回值。"

#: ../../library/unittest.mock.rst:854
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"当从一个对象提取 :class:`PropertyMock` 实例时将不附带任何参数地调用该 mock。 如果设置它则调用该 mock "
"时将附带被设置的值。 ::"

#: ../../library/unittest.mock.rst:857
msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"

#: ../../library/unittest.mock.rst:875
msgid ""
"Because of the way mock attributes are stored you can't directly attach a "
":class:`PropertyMock` to a mock object. Instead you can attach it to the "
"mock type object::"
msgstr ""
"由于 mock 属性的存储方式你无法直接将 :class:`PropertyMock` 附加到一个 mock 对象。 但是你可以将它附加到 mock "
"类型对象::"

#: ../../library/unittest.mock.rst:879
msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"

#: ../../library/unittest.mock.rst:888
msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will be "
"interpreted as a missing descriptor and :meth:`~object.__getattr__` will be "
"called on the parent mock::"
msgstr ""
"如果由 :class:`PropertyMock` 引发了 :exc:`AttributeError`，它将被解读为缺少描述器并将在父 mock 上调用"
" :meth:`~object.__getattr__`::"

#: ../../library/unittest.mock.rst:892
msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"

#: ../../library/unittest.mock.rst:898
msgid "See :meth:`~object.__getattr__` for details."
msgstr "请参阅 :meth:`~object.__getattr__` 了解详情。"

#: ../../library/unittest.mock.rst:903
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object"
" will behave so the object is recognized as an async function, and the "
"result of a call is an awaitable."
msgstr ""
":class:`MagicMock` 的异步版本。 :class:`AsyncMock` "
"对象的行为方式将使该对象被识别为异步函数，其调用的结果将为可等待对象。"

#: ../../library/unittest.mock.rst:913
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of"
" ``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"调用 ``mock()`` 的结果是一个异步函数，它在被等待之后将具有 ``side_effect`` 或 ``return_value`` 的结果:"

#: ../../library/unittest.mock.rst:916
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr "如果 ``side_effect`` 是一个函数，则异步函数将返回该函数的结果,"

#: ../../library/unittest.mock.rst:918
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr "如果 ``side_effect`` 是一个异常，则异步函数将引发该异常,"

#: ../../library/unittest.mock.rst:920
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"如果 ``side_effect`` 是一个可迭代对象，则异步函数将返回该可迭代对象的下一个值，但是，如果结果序列被耗尽，则会立即引发 "
"``StopAsyncIteration``,"

#: ../../library/unittest.mock.rst:923
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a"
" new :class:`AsyncMock` object."
msgstr ""
"如果 ``side_effect`` 未被定义，则异步函数将返回is not defined, the async function will "
"return the value defined by ``return_value`` 所定义的值，因而，在默认情况下，异步函数会返回一个新的 "
":class:`AsyncMock` 对象。"

#: ../../library/unittest.mock.rst:928
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr "将 :class:`Mock` 或 :class:`MagicMock` 的 *spec* 设为异步函数将导致在调用后返回一个协程对象。"

#: ../../library/unittest.mock.rst:940
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or "
":class:`AsyncMock` to a class with asynchronous and synchronous functions "
"will automatically detect the synchronous functions and set them as "
":class:`MagicMock` (if the parent mock is :class:`AsyncMock` or "
":class:`MagicMock`) or :class:`Mock` (if the parent mock is :class:`Mock`). "
"All asynchronous functions will be :class:`AsyncMock`."
msgstr ""
"将 :class:`Mock`, :class:`MagicMock` 或 :class:`AsyncMock` 的 *spec* "
"设为带有异步和同步函数的类将自动删除其中的同步函数并将它们设为 :class:`MagicMock` (如果上级 mock 是 "
":class:`AsyncMock` 或 :class:`MagicMock`) 或者 :class:`Mock` (如果上级 mock 是 "
":class:`Mock`)。 所有异步函数都将为 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:968
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr "断言 mock 已被等待至少一次。 请注意这是从被调用的对象中分离出来的，必须要使用 ``await`` 关键字:"

#: ../../library/unittest.mock.rst:987
msgid "Assert that the mock was awaited exactly once."
msgstr "断言 mock 已被等待恰好一次。"

#: ../../library/unittest.mock.rst:1003
msgid "Assert that the last await was with the specified arguments."
msgstr "断言上一次等待传入了指定的参数。"

#: ../../library/unittest.mock.rst:1020
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr "断言 mock 已被等待恰好一次并且附带了指定的参数。"

#: ../../library/unittest.mock.rst:1037
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "断言 mock 已附带了指定的参数被等待。"

#: ../../library/unittest.mock.rst:1053
msgid ""
"Assert the mock has been awaited with the specified calls. The "
":attr:`await_args_list` list is checked for the awaits."
msgstr "断言 mock 已附带了指定的调用被等待。 将针对这些等待检查 :attr:`await_args_list` 列表。"

#: ../../library/unittest.mock.rst:1056
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr "如果 *any_order* 为假值则等待必须是顺序进行的。 在指定的等待之前或之后还可以有额外的调用。"

#: ../../library/unittest.mock.rst:1060
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr "如果 *any_order* 为真值则等待可以是任意顺序的，但它们都必须在 :attr:`await_args_list` 中出现。"

#: ../../library/unittest.mock.rst:1080
msgid "Assert that the mock was never awaited."
msgstr "断言 mock 从未被等待过。"

#: ../../library/unittest.mock.rst:1087
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, "
":attr:`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"参见 :func:`Mock.reset_mock`。 还会将 :attr:`await_count` 设为 0，将 "
":attr:`await_args` 设为 None，并清空 :attr:`await_args_list`。"

#: ../../library/unittest.mock.rst:1092
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "一个追踪 mock 对象已被等待多少次的整数值。"

#: ../../library/unittest.mock.rst:1107
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as "
":attr:`Mock.call_args`."
msgstr ""
"这可能为 ``None`` (如果 mock 从未被等待)，或为该 mock 上一次被等待所附带的参数。 其功能与 "
":attr:`Mock.call_args` 相同。"

#: ../../library/unittest.mock.rst:1125
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the"
" length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr "这是由对 mock 对象按顺序执行的所有等待组成的列表（因此该列表的长度即它被等待的次数）。 在有任何等待被执行之前它将为一个空列表。"

#: ../../library/unittest.mock.rst:1145
msgid ""
"A version of :class:`MagicMock` for multithreading tests. The "
":class:`ThreadingMock` object provides extra methods to wait for a call to "
"be invoked, rather than assert on it immediately."
msgstr ""
"针对多线程测试的 :class:`MagicMock` 版本。 :class:`ThreadingMock` "
"对象提供了额外的方法用来等待调用被唤起，而不是立即对其执行断言。"

#: ../../library/unittest.mock.rst:1149
msgid ""
"The default timeout is specified by the ``timeout`` argument, or if unset by"
" the :attr:`ThreadingMock.DEFAULT_TIMEOUT` attribute, which defaults to "
"blocking (``None``)."
msgstr ""
"默认的超时值由 ``timeout`` 参数指定，或者由 :attr:`ThreadingMock.DEFAULT_TIMEOUT` "
"属性来重置，该属性默认为阻塞型 (``None``)。"

#: ../../library/unittest.mock.rst:1152
msgid ""
"You can configure the global default timeout by setting "
":attr:`ThreadingMock.DEFAULT_TIMEOUT`."
msgstr "你可以通过设置 :attr:`ThreadingMock.DEFAULT_TIMEOUT` 来配置全局默认超时。"

#: ../../library/unittest.mock.rst:1156
msgid "Waits until the mock is called."
msgstr "等待直到 mock 被调用。"

#: ../../library/unittest.mock.rst:1158
msgid ""
"If a timeout was passed at the creation of the mock or if a timeout argument"
" is passed to this function, the function raises an :exc:`AssertionError` if"
" the call is not performed in time."
msgstr ""
"如果在创建 mock 时传入了 timeout 值或者如果向该函数传入了 timeout 参数，那么当调用未在时限内执行完毕则会引发 "
":exc:`AssertionError`。"

#: ../../library/unittest.mock.rst:1170
msgid "Waits until the mock is called with the specified arguments."
msgstr "等待直到该 mock 附带指定参数被调用。"

#: ../../library/unittest.mock.rst:1172
msgid ""
"If a timeout was passed at the creation of the mock the function raises an "
":exc:`AssertionError` if the call is not performed in time."
msgstr "如果在创建该 mock 时传入了 timeout 值则当调用未在时限内执行完成则会引发 :exc:`AssertionError`。"

#: ../../library/unittest.mock.rst:1183
msgid ""
"Global default timeout in seconds to create instances of "
":class:`ThreadingMock`."
msgstr "创建 :class:`ThreadingMock` 实例的全局默认超时秒数。"

#: ../../library/unittest.mock.rst:1189
msgid "Calling"
msgstr "调用"

#: ../../library/unittest.mock.rst:1191
msgid ""
"Mock objects are callable. The call will return the value set as the "
":attr:`~Mock.return_value` attribute. The default return value is a new Mock"
" object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Mock 对象是可调用对象。 调用将把值集合作为 :attr:`~Mock.return_value` 属性返回。 默认的返回值是一个新的 Mock "
"对象；它会在对返回值的首次访问（不论是显式访问还是通过调用 Mock）时被创建 —— 但它会被保存并且每次都返回相同的对象。"

#: ../../library/unittest.mock.rst:1197
msgid ""
"Calls made to the object will be recorded in the attributes like "
":attr:`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"对该对象的调用将被记录在 :attr:`~Mock.call_args` 和 :attr:`~Mock.call_args_list` 等属性中。"

#: ../../library/unittest.mock.rst:1200
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`!side_effect` raises an exception the call "
"is still recorded."
msgstr ""
"如果设置了 :attr:`~Mock.side_effect` 则它将在调用被记录之后被调用，因此如果 :attr:`!side_effect` "
"引发了异常该调用仍然会被记录。"

#: ../../library/unittest.mock.rst:1204
msgid ""
"The simplest way to make a mock raise an exception when called is to make "
":attr:`~Mock.side_effect` an exception class or instance:"
msgstr "让一个 mock 在被调用时引发异常的最简单方式是将 :attr:`~Mock.side_effect` 设为一个异常类或实例:"

#: ../../library/unittest.mock.rst:1222
msgid ""
"If :attr:`~Mock.side_effect` is a function then whatever that function "
"returns is what calls to the mock return. The :attr:`!side_effect` function "
"is called with the same arguments as the mock. This allows you to vary the "
"return value of the call dynamically, based on the input:"
msgstr ""
"如果 :attr:`~Mock.side_effect` 是一个函数则该函数所返回的对象就是调用该 mock 所返回的对象。 "
":attr:`!side_effect` 函数在被调用时将附带与该 mock 相同的参数。 这允许你根据输入动态地改变返回值："

#: ../../library/unittest.mock.rst:1238
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`~Mock.return_value` from inside :attr:`~Mock.side_effect`, or "
"return :data:`DEFAULT`:"
msgstr ""
"如果你想让该 mock 仍然返回默认的返回值（一个新的 mock 对象），或是任何设定的返回值，那么有两种方式可以做到这一点。 从 "
":attr:`~Mock.side_effect` 内部返回 :attr:`~Mock.return_value`，或者返回 "
":data:`DEFAULT`:"

#: ../../library/unittest.mock.rst:1257
msgid ""
"To remove a :attr:`~Mock.side_effect`, and return to the default behaviour, "
"set the :attr:`!side_effect` to ``None``:"
msgstr ""
"要移除一个 :attr:`~Mock.side_effect`，并返回到默认行为，请将 :attr:`!side_effect` 设为 "
"``None``:"

#: ../../library/unittest.mock.rst:1271
msgid ""
"The :attr:`~Mock.side_effect` can also be any iterable object. Repeated "
"calls to the mock will return values from the iterable (until the iterable "
"is exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`~Mock.side_effect` 也可以是任意可迭代对象。 对该 mock "
"的重复调用将返回来自该可迭代对象的值（直到该可迭代对象被耗尽并导致 :exc:`StopIteration` 被引发）:"

#: ../../library/unittest.mock.rst:1287
msgid ""
"If any members of the iterable are exceptions they will be raised instead of"
" returned::"
msgstr "如果该可迭代对象有任何成员属于异常则它们将被引发而不是被返回::"

#: ../../library/unittest.mock.rst:1290
msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"

#: ../../library/unittest.mock.rst:1305
msgid "Deleting Attributes"
msgstr "删除属性"

#: ../../library/unittest.mock.rst:1307
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr "Mock 对象会根据需要创建属性。 这允许它们可以假装成任意类型的对象。"

#: ../../library/unittest.mock.rst:1310
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or"
" raise an :exc:`AttributeError` when an attribute is fetched. You can do "
"this by providing an object as a :attr:`!spec` for a mock, but that isn't "
"always convenient."
msgstr ""
"你可能想要一个 mock 对象在调用 :func:`hasattr` 时返回 ``False``，或者在获取某个属性时引发 "
":exc:`AttributeError`。 你可以通过提供一个对象作为 mock 的 :attr:`!spec` 来做到这点，但这并不总是很方便。"

#: ../../library/unittest.mock.rst:1314
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr "你可以通过删除属性来“屏蔽”它们。 属性一旦被删除，访问它将引发 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:1331
msgid "Mock names and the name attribute"
msgstr "Mock 的名称与 name 属性"

#: ../../library/unittest.mock.rst:1333
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use "
":meth:`~Mock.configure_mock`::"
msgstr ""
"由于 \"name\" 是 :class:`Mock` 构造器的参数之一，如果你想让你的 mock 对象具有 \"name\" "
"属性你不可以在创建时传入该参数。 有两个替代方式。 一个选项是使用 :meth:`~Mock.configure_mock`::"

#: ../../library/unittest.mock.rst:1338
msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"

#: ../../library/unittest.mock.rst:1343
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr "一个更简单的选项是在 mock 创建之后简单地设置 \"name\" 属性::"

#: ../../library/unittest.mock.rst:1345
msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""

#: ../../library/unittest.mock.rst:1350
msgid "Attaching Mocks as Attributes"
msgstr "附加 Mock 作为属性"

#: ../../library/unittest.mock.rst:1352
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of"
" the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"当你附加一个 mock 作为另一个 mock 的属性（或作为返回值）时它会成为该 mock 的 \"子对象\"。 对子对象的调用会被记录在父对象的 "
":attr:`~Mock.method_calls` 和 :attr:`~Mock.mock_calls` 属性中。 这适用于配置子 mock "
"然后将它们附加到父对象，或是将 mock 附加到将记录所有对子对象的调用的父对象上并允许你创建有关 mock 之间的调用顺序的断言:"

#: ../../library/unittest.mock.rst:1370
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr "这里有一个例外情况是如果 mock 设置了名称。 这允许你在出于某些理由不希望其发生时避免 \"父对象\" 的影响。"

#: ../../library/unittest.mock.rst:1381
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the "
":meth:`~Mock.attach_mock` method::"
msgstr ""
"通过 :func:`patch` 创建的 mock 会被自动赋予名称。 要将具有名称的 mock 附加到父对象上你应当使用 "
":meth:`~Mock.attach_mock` 方法::"

#: ../../library/unittest.mock.rst:1385
msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"

#: ../../library/unittest.mock.rst:1399
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get"
" a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"仅有的例外是魔术方法和属性（其名称前后都带有双下划线）。 Mock 不会创建它们而是将引发 :exc:`AttributeError`。 "
"这是因为解释器将会经常隐式地请求这些方法，并且在它准备接受一个魔术方法却得到一个新的 Mock 对象时会 *相当* 困惑。 如果你需要魔术方法支持请参阅"
" :ref:`魔术方法 <magic-methods>`。"

#: ../../library/unittest.mock.rst:1408
msgid "The patchers"
msgstr "patch 装饰器"

#: ../../library/unittest.mock.rst:1410
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"patch 装饰器仅被用于在它们所装饰的函数作用域内部为对象添加补丁。 它们会自动为你执行去除补丁的处理，即使是在引发了异常的情况下。 "
"所有这些函数都还可在 with 语句中使用或是作为类装饰器。"

#: ../../library/unittest.mock.rst:1417
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1421
msgid ""
"The key is to do the patching in the right namespace. See the section `where"
" to patch`_."
msgstr "问题的关键是要在正确的命名空间中打补丁。 参见 `where to patch`_ 一节。"

#: ../../library/unittest.mock.rst:1425
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` 可以作为函数装饰器、类装饰器或上下文管理器。 在函数或 with 语句的内部，*target* 会打上一个 *new* "
"对象补丁。 当函数/with 语句退出时补丁将被撤销。"

#: ../../library/unittest.mock.rst:1430
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the"
" created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"如果 *new* 被省略，那么如果被打补丁的对象是一个异步函数则 target 将被替换为 :class:`AsyncMock` 否则替换为 "
":class:`MagicMock`。 如果 :func:`patch` 被用作装饰器并且 *new* 被省略，那么已创建的 mock "
"将作为一个附加参数传入被装饰的函数。 如果 :func:`patch` 被用作上下文管理器那么已创建的 mock 将被该上下文管理器所返回。"

#: ../../library/unittest.mock.rst:1438
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* 应当为 ``'package.module.ClassName'`` 形式的字符串。 *target* "
"将被导入并且该指定对象会被替换为 *new* 对象，因此 *target* 必须是可以从你调用 :func:`patch` 的环境中导入的。 "
"target 会在被装饰的函数被执行的时候被导入，而非在装饰的时候。"

#: ../../library/unittest.mock.rst:1444
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the "
":class:`MagicMock` if patch is creating one for you."
msgstr ""
"*spec* 和 *spec_set* 关键字参数会被传递给 :class:`MagicMock`，如果 patch 为你创建了此对象的话。"

#: ../../library/unittest.mock.rst:1447
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"此外你还可以传入 ``spec=True`` 或 ``spec_set=True``，这将使 patch 将被模拟的对象作为 spec/spec_set"
" 对象传入。"

#: ../../library/unittest.mock.rst:1450
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default "
":class:`AsyncMock` is used for async functions and :class:`MagicMock` for "
"the rest."
msgstr ""
"*new_callable* 允许你指定一个不同的类，或者可调用对象，它将被调用以创建 *新的* 对象。 在默认情况下将指定 "
":class:`AsyncMock` 用于异步函数，:class:`MagicMock` 用于其他函数。"

#: ../../library/unittest.mock.rst:1454
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the "
":func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"另一种更强形式的 *spec* 是 *autospec*。 如果你设置了 ``autospec=True`` 则将以来自被替换对象的 spec 来创建 "
"mock。 mock 的所有属性也将具有被替换对象相应属性的 spec。 被模拟的方法和函数将检查它们的参数并且如果使用了错误的签名调用它们则将引发 "
":exc:`TypeError`。 对于替换了一个类的 mock，它们的返回值（即‘实例’）将具有与该类相同的 spec。 请参阅 "
":func:`create_autospec` 函数以及 :ref:`auto-speccing`。"

#: ../../library/unittest.mock.rst:1464
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an"
" arbitrary object as the spec instead of the one being replaced."
msgstr ""
"除了 ``autospec=True`` 你还可以传入 ``autospec=some_object`` 以使用任意对象而不是被替换的对象作为 "
"spec。"

#: ../../library/unittest.mock.rst:1467
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete"
" it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is"
" off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"在默认情况下 :func:`patch` 将无法替换不存在的属性。 如果你传入 ``create=True``，且该属性并不存在，则 patch "
"将在调用被打补丁的函数时为你创建该属性，并在退出被打补丁的函数时再次删除它。 这适用于编写针对生产代码在运行时创建的属性的测试。 "
"它默认是被关闭的因为这具有危险性。 当它被开启时你将能够针对实际上并不存在的 API 编写通过测试！"

#: ../../library/unittest.mock.rst:1477
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr "如果你要给某个模块的内置函数打补丁则不必传入 ``create=True``，它默认就会被添加。"

#: ../../library/unittest.mock.rst:1481
msgid ""
"Patch can be used as a :class:`~unittest.TestCase` class decorator. It works"
" by decorating each test method in the class. This reduces the boilerplate "
"code when your test methods share a common patchings set. :func:`patch` "
"finds tests by looking for method names that start with "
"``patch.TEST_PREFIX``. By default this is ``'test'``, which matches the way "
":mod:`unittest` finds tests. You can specify an alternative prefix by "
"setting ``patch.TEST_PREFIX``."
msgstr ""
"Patch 可以被用作 :class:`~unittest.TestCase` 类装饰器。 它是通过装饰类中的每个测试方法来发挥作用的。 "
"当你的测试方法共享同一个补丁集时这将减少模板代码。 :func:`patch` 会通过查找以 ``patch.TEST_PREFIX`` "
"打头的名称来找到测试。 其默认值为 ``'test'``，这与 :mod:`unittest` 找到测试的方式一致。 你可以通过设置 "
"``patch.TEST_PREFIX`` 来指定其他的前缀。"

#: ../../library/unittest.mock.rst:1488
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"Patch 可以通过 with 语句作为上下文管理器使用。 这时补丁将应用于 with 语句的缩进代码块。 如果你使用了 \"as\" "
"则打补丁的对象将被绑定到 \"as\" 之后的名称；这非常适用于当 :func:`patch` 为你创建 mock 对象的情况。"

#: ../../library/unittest.mock.rst:1493
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to "
":class:`AsyncMock` if the patched object is asynchronous, to "
":class:`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` 可接受任意关键字参数。 如果打补丁的对象是异步的则这些参数将被传给 :class:`AsyncMock`，否则传给 "
":class:`MagicMock`，或者是指定的 *new_callable*。"

#: ../../library/unittest.mock.rst:1497
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` 和 ``patch.object(...)`` "
"可用于其他使用场景。"

#: ../../library/unittest.mock.rst:1500
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ":func:`patch` 作为函数装饰器，为你创建 mock 并将其传入被装饰的函数::"

#: ../../library/unittest.mock.rst:1503
msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"

#: ../../library/unittest.mock.rst:1510
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If"
" the class is instantiated in the code under test then it will be the "
":attr:`~Mock.return_value` of the mock that will be used."
msgstr ""
"为类打补丁将把该类替换为 :class:`MagicMock` 的 *实例*。 如果该类是在受测试的代码中被实例化的则它将为所要使用的 mock 的 "
":attr:`~Mock.return_value`。"

#: ../../library/unittest.mock.rst:1514
msgid ""
"If the class is instantiated multiple times you could use "
":attr:`~Mock.side_effect` to return a new mock each time. Alternatively you "
"can set the *return_value* to be anything you want."
msgstr ""
"如果该类被多次实例化则你可以使用 :attr:`~Mock.side_effect` 来每次返回一个新 mock。 或者你也可以将 "
"*return_value* 设为你希望的任何对象。"

#: ../../library/unittest.mock.rst:1518
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`~Mock.return_value`. For example::"
msgstr "要在被打补丁的类的 *实例* 的方法上配置返回值你必须在 :attr:`~Mock.return_value` 进行操作。 例如::"

#: ../../library/unittest.mock.rst:1521
msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."

#: ../../library/unittest.mock.rst:1532
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"如果你使用 *spec* 或 *spec_set* 并且 :func:`patch` 替换的是 *class*，那么所创建的 mock "
"的返回值将具有同样的 spec。 ::"

#: ../../library/unittest.mock.rst:1535
msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"

#: ../../library/unittest.mock.rst:1542
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"*new_callable* 参数适用于当你想要使用其他类来替代所创建的 mock 默认的 :class:`MagicMock` 的场合。 "
"例如，如果你想要使用 :class:`NonCallableMock`::"

#: ../../library/unittest.mock.rst:1546
msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"

#: ../../library/unittest.mock.rst:1555
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr "另一个使用场景是用 :class:`io.StringIO` 实例来替换某个对象::"

#: ../../library/unittest.mock.rst:1557
msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1568
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"当 :func:`patch` 为你创建 mock 时，通常你需要做的第一件事就是配置该 mock。 某些配置可以在对 patch 的调用中完成。 "
"你在调用时传入的任何关键字参数都将被用来在所创建的 mock 上设置属性::"

#: ../../library/unittest.mock.rst:1573
msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"

#: ../../library/unittest.mock.rst:1580
msgid ""
"As well as attributes on the created mock attributes, like the "
":attr:`~Mock.return_value` and :attr:`~Mock.side_effect`, of child mocks can"
" also be configured. These aren't syntactically valid to pass in directly as"
" keyword arguments, but a dictionary with these as keys can still be "
"expanded into a :func:`patch` call using ``**``::"
msgstr ""
"除了所创建的 mock 的属性上的属性，例如 :attr:`~Mock.return_value` 和 "
":attr:`~Mock.side_effect`，还可以配置子 mock 的属性。 将这些属性直接作为关键字参数传入在语义上是无效的，但是仍然能够使用"
" ``**`` 将以这些属性为键的字典扩展至一个 :func:`patch` 调用中 ::"

#: ../../library/unittest.mock.rst:1586
msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"

#: ../../library/unittest.mock.rst:1596
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with "
":exc:`AttributeError`::"
msgstr ""
"在默认情况下，尝试给某个模块中并不存在的函数（或者某个类中的方法或属性）打补丁将会失败并引发 :exc:`AttributeError`::"

#: ../../library/unittest.mock.rst:1599
msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute 'non_existing_attribute'"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute 'non_existing_attribute'"

#: ../../library/unittest.mock.rst:1608
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr "但在对 :func:`patch` 的调用中添加 ``create=True`` 将使之前示例的效果符合预期::"

#: ../../library/unittest.mock.rst:1611
msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1619
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr "如果目标为异步函数那么 :func:`patch` 现在将返回一个 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:1623
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1627
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr "用一个 mock 对象为对象 (*target*) 中指定名称的成员 (*attribute*) 打补丁。"

#: ../../library/unittest.mock.rst:1630
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like "
":func:`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` 可以被用作装饰器、类装饰器或上下文管理器。 *new*, *spec*, *create*, "
"*spec_set*, *autospec* 和 *new_callable* 等参数的含义与 :func:`patch` 的相同。 与 "
":func:`patch` 类似，:func:`patch.object` 接受任意关键字参数用于配置它所创建的 mock 对象。"

#: ../../library/unittest.mock.rst:1636
msgid ""
"When used as a class decorator :func:`patch.object` honours "
"``patch.TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"当用作类装饰器时 :func:`patch.object` 将认可 ``patch.TEST_PREFIX`` 作为选择所要包装方法的标准。"

#: ../../library/unittest.mock.rst:1639
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"你可以附带三个参数或两个参数来调用 :func:`patch.object`。 三个参数的形式将接受要打补丁的对象、属性的名称以及将要替换该属性的对象。"

#: ../../library/unittest.mock.rst:1643
msgid ""
"When calling with the two argument form you omit the replacement object, and"
" a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr "将附带两个参数的形式调用时你将省略替换对象，还会为你创建一个 mock 并作为附加参数传入被装饰的函数:"

#: ../../library/unittest.mock.rst:1654
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"传给 :func:`patch.object` 的 *spec*, *create* 和其他参数的含义与 :func:`patch` 的同名参数相同。"

#: ../../library/unittest.mock.rst:1659
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1663
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to"
" its original state after the test, where the restored dictionary is a copy "
"of the dictionary as it was before the test."
msgstr "给一个字典，或字典型对象打补丁，并在测试之后将该目录恢复到其初始状态，被保存的目录将是测试之前的目录的一个副本。"

#: ../../library/unittest.mock.rst:1667
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr "*in_dict* 可以是一个字典或映射类容器。 如果它是一个映射则它必须至少支持获取、设置和删除条目以及对键执行迭代。"

#: ../../library/unittest.mock.rst:1671
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr "*in_dict* 也可以是一个指定字典名称的字符串，然后将通过导入操作来获取该字典。"

#: ../../library/unittest.mock.rst:1674
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* 可以是一个要在字典中设置的值的字典。 *values* 也可以是一个包含 ``(key, value)`` 对的可迭代对象。"

#: ../../library/unittest.mock.rst:1677
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values"
" are set."
msgstr "如果 *clear* 为真值则该字典将在设置新值之前先被清空。"

#: ../../library/unittest.mock.rst:1680
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ":func:`patch.dict` 也可以附带任意关键字参数调用以设置字典中的值。"

#: ../../library/unittest.mock.rst:1685
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context"
" manager."
msgstr ""
"现在当 :func:`patch.dict` 被用作上下文管理器时将返回被打补丁的字典。now returns the patched "
"dictionary when used as a context manager."

#: ../../library/unittest.mock.rst:1688
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ":func:`patch.dict` 可被用作上下文管理器、装饰器或类装饰器:"

#: ../../library/unittest.mock.rst:1699
msgid ""
"When used as a class decorator :func:`patch.dict` honours "
"``patch.TEST_PREFIX`` (default to ``'test'``) for choosing which methods to "
"wrap:"
msgstr ""
"当被用作类装饰器时 :func:`patch.dict` 将认可 ``patch.TEST_PREFIX`` (默认值为 ``'test'``) "
"作为选择所在包装方法的标准:"

#: ../../library/unittest.mock.rst:1710
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"如果你在为你的测试使用不同的前缀，你可以通过设置 ``patch.TEST_PREFIX`` 来将不同的前缀告知打补丁方。 有关如何修改该值的详情请参阅"
" :ref:`test-prefix`。"

#: ../../library/unittest.mock.rst:1714
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let"
" a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ":func:`patch.dict` 可被用来向一个字典添加成员，或者简单地让测试修改一个字典，并确保当测试结束时恢复该字典。"

#: ../../library/unittest.mock.rst:1735
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr "可以在 :func:`patch.dict` 调用中使用关键字来设置字典的值:"

#: ../../library/unittest.mock.rst:1745
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, "
":meth:`~object.__setitem__`, :meth:`~object.__delitem__` and either "
":meth:`~container.__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict` 可被用于实际上不是字典的字典类对象。 它们至少必须支持条目获取、设置、删除以及迭代或成员检测两者之一。 "
"这对应于魔术方法 :meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__delitem__` 以及 :meth:`~container.__iter__` 或 "
":meth:`~object.__contains__` 两者之一。"

#: ../../library/unittest.mock.rst:1775
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1779
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched"
" (either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr "在单个调用中执行多重补丁。 它接受要打补丁的对象（一个对象或一个通过导入来获取对象的字符串）以及用于补丁的关键字参数::"

#: ../../library/unittest.mock.rst:1783
msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."

#: ../../library/unittest.mock.rst:1786
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when "
":func:`patch.multiple` is used as a context manager."
msgstr ""
"如果你希望 :func:`patch.multiple` 为你创建 mock 则要使用 :data:`DEFAULT` 作为值。 在此情况下所创建的 "
"mock 会通过关键字参数传入被装饰的函数，而当 :func:`patch.multiple` 被用作上下文管理器时则将返回一个字典。"

#: ../../library/unittest.mock.rst:1791
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` 可以被用作装饰器、类装饰器或上下文管理器。 *spec*, *spec_set*, *create*, "
"*autospec* 和 *new_callable* 等参数的含义与 :func:`patch` 的相同。 这些参数将被应用到 "
":func:`patch.multiple` 所打的 *所有* 补丁。"

#: ../../library/unittest.mock.rst:1796
msgid ""
"When used as a class decorator :func:`patch.multiple` honours "
"``patch.TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"当被用作类装饰器时 :func:`patch.multiple` 将认可 ``patch.TEST_PREFIX`` 作为选择所要包装方法的标准。"

#: ../../library/unittest.mock.rst:1799
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can use"
" :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"如果你希望 :func:`patch.multiple` 为你创建 mock，那么你可以使用 :data:`DEFAULT` 作为值。 如果你使用 "
":func:`patch.multiple` 作为装饰器则所创建的 mock 会作为关键字参数传入被装饰的函数。 ::"

#: ../../library/unittest.mock.rst:1803
msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"

#: ../../library/unittest.mock.rst:1813
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` 可以与其他 ``patch`` 装饰器嵌套使用，但要将作为关键字传入的参数要放在 "
":func:`patch` 所创建的标准参数 *之后*::"

#: ../../library/unittest.mock.rst:1816
msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"

#: ../../library/unittest.mock.rst:1825
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"如果 :func:`patch.multiple` 被用作上下文管理器，则上下文管理器的返回值将是一个以所创建的 mock 的名称为键的字典::"

#: ../../library/unittest.mock.rst:1828
msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."

#: ../../library/unittest.mock.rst:1839
msgid "patch methods: start and stop"
msgstr "补丁方法: start 和 stop"

#: ../../library/unittest.mock.rst:1841
msgid ""
"All the patchers have :meth:`!start` and :meth:`!stop` methods. These make "
"it simpler to do patching in ``setUp`` methods or where you want to do "
"multiple patches without nesting decorators or with statements."
msgstr ""
"所有 patcher 对象都具有 :meth:`!start` 和 :meth:`!stop` 方法。 使用这些方法可以更简单地在 ``setUp`` "
"方法上打补丁，还可以让你不必嵌套使用装饰器或 with 语句就能打多重补丁。"

#: ../../library/unittest.mock.rst:1845
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`!start` to put the patch in place and :meth:`!stop` to undo"
" it."
msgstr ""
"要使用这些方法请按正常方式调用 :func:`patch`, :func:`patch.object` 或 :func:`patch.dict` "
"并保留一个指向所返回 ``patcher`` 对象的引用。 你可以随后调用 :meth:`!start` 来原地打补丁并调用 :meth:`!stop`"
" 来恢复它。"

#: ../../library/unittest.mock.rst:1849
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr "如果你使用 :func:`patch` 来创建自己的 mock 那么将可通过调用 ``patcher.start`` 来返回它。 ::"

#: ../../library/unittest.mock.rst:1852
msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"

#: ../../library/unittest.mock.rst:1863
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`~unittest.TestCase`::"
msgstr "此操作的一个典型应用场景是在一个 :class:`~unittest.TestCase` 的 ``setUp`` 方法中执行多重补丁::"

#: ../../library/unittest.mock.rst:1866
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"

#: ../../library/unittest.mock.rst:1885
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by"
" calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. "
":meth:`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你要使用这个技巧则你必须通过调用 ``stop`` 来确保补丁被“恢复”。 这可能要比你想像的更麻烦，因为如果在 ``setUp`` "
"中引发了异常那么 ``tearDown`` 将不会被调用。 :meth:`unittest.TestCase.addCleanup` 可以简化此操作::"

#: ../../library/unittest.mock.rst:1890
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."

#: ../../library/unittest.mock.rst:1900
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr "一项额外的好处是你不再需要保留指向 ``patcher`` 对象的引用。"

#: ../../library/unittest.mock.rst:1903
msgid ""
"It is also possible to stop all patches which have been started by using "
":func:`patch.stopall`."
msgstr "还可以通过使用 :func:`patch.stopall` 来停止已启动的所有补丁。"

#: ../../library/unittest.mock.rst:1908
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr "停止所有激活的补丁。 仅会停止通过 ``start`` 启动的补丁。"

#: ../../library/unittest.mock.rst:1914
msgid "patch builtins"
msgstr "为内置函数打补丁"

#: ../../library/unittest.mock.rst:1915
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr "你可以为一个模块中的任何内置函数打补丁。 以以示例是为内置函数 :func:`ord` 打补丁::"

#: ../../library/unittest.mock.rst:1918
msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"

#: ../../library/unittest.mock.rst:1930
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1932
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"所有补丁都可被用作类装饰器。 当以这种方式使用时它们将会包装类中的每个测试方法。 补丁会将以名字以 ``'test'`` 开头的方法识别为测试方法。 "
"这与 :class:`unittest.TestLoader` 查找测试方法的默认方式相同。"

#: ../../library/unittest.mock.rst:1937
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting "
"``patch.TEST_PREFIX``::"
msgstr "你可能会想要为你的测试使用不同的前缀。 你可以通过设置 ``patch.TEST_PREFIX`` 来告知打补丁方不同的前缀::"

#: ../../library/unittest.mock.rst:1940
msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"

#: ../../library/unittest.mock.rst:1960
msgid "Nesting Patch Decorators"
msgstr "嵌套补丁装饰器"

#: ../../library/unittest.mock.rst:1962
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr "如果你想要应用多重补丁那么你可以简单地堆叠多个装饰器。"

#: ../../library/unittest.mock.rst:1965
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "你可以使用以下模式来堆叠多个补丁装饰器:"

#: ../../library/unittest.mock.rst:1981
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"请注意装饰器是从下往上被应用的。 这是 Python 应用装饰器的标准方式。 被创建并传入你的测试函数的 mock 的顺序也将匹配这个顺序。"

#: ../../library/unittest.mock.rst:1989
msgid "Where to patch"
msgstr "补丁的位置"

#: ../../library/unittest.mock.rst:1991
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` 通过（临时性地）修改某一个对象的 *名称* 指向另一个对象来发挥作用。 "
"可以有多个名称指向任意单独对象，因此要让补丁起作用你必须确保已为被测试的系统所使用的名称打上补丁。"

#: ../../library/unittest.mock.rst:1996
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr "基本原则是你要在对象 *被查找* 的地方打补丁，这不一定就是它被定义的地方。 一组示例将有助于厘清这一点。"

#: ../../library/unittest.mock.rst:2000
msgid ""
"Imagine we have a project that we want to test with the following "
"structure::"
msgstr "想像我们有一个想要测试的具有如下结构的项目::"

#: ../../library/unittest.mock.rst:2002
msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"

#: ../../library/unittest.mock.rst:2009
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do when it imports ``SomeClass`` from module a. If we use "
":func:`patch` to mock out ``a.SomeClass`` then it will have no effect on our"
" test; module b already has a reference to the *real* ``SomeClass`` and it "
"looks like our patching had no effect."
msgstr ""
"现在我们想要测试 ``some_function`` 但我们想使用 :func:`patch` 来模拟 ``SomeClass``。 "
"问题在于当我们导入模块 b 时，我们必须让它从模块 a 导入 ``SomeClass``。 如果我们使用 :func:`patch` 来模拟 "
"``a.SomeClass`` 那么它将不会对我们的测试造成影响；模块 b 已经拥有对 *真正的* ``SomeClass`` "
"的血此看起来我们的补丁不会有任何影响。"

#: ../../library/unittest.mock.rst:2016
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"关键在于对 ``SomeClass`` 打补丁操作是在它被使用（或它被查找）的地方。 在此情况下实际上 ``some_function`` 将在模块 b"
" 中查找 ``SomeClass``，而我们已经在那里导入了它。 补丁看上去应该是这样::"

#: ../../library/unittest.mock.rst:2020
msgid "@patch('b.SomeClass')"
msgstr "@patch('b.SomeClass')"

#: ../../library/unittest.mock.rst:2022
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses "
"``a.SomeClass``. Both of these import forms are common. In this case the "
"class we want to patch is being looked up in the module and so we have to "
"patch ``a.SomeClass`` instead::"
msgstr ""
"但是，再考虑另一个场景，其中不是 ``from a import SomeClass`` 而是模块 b 执行了 ``import a`` 并且 "
"``some_function`` 使用了 ``a.SomeClass``。 这两个导入形式都很常见。 "
"在这种情况下我们要打补丁的类将在该模块中被查找因而我们必须改为对 ``a.SomeClass`` 打补丁::"

#: ../../library/unittest.mock.rst:2027
msgid "@patch('a.SomeClass')"
msgstr "@patch('a.SomeClass')"

#: ../../library/unittest.mock.rst:2031
msgid "Patching Descriptors and Proxy Objects"
msgstr "对描述器和代理对象打补丁"

#: ../../library/unittest.mock.rst:2033
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class"
" methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object "
"<https://web.archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"patch_ 和 patch.object_ 都能正确地对描述器打补丁并恢复：包含类方法、静态方法和特征属性。 你应当在 *类* "
"而不是实例上为它们打补丁。 它们也适用于代理属性访问的 *部分* 对象，例如 `django settings object "
"<https://web.archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_。"

#: ../../library/unittest.mock.rst:2041
msgid "MagicMock and magic method support"
msgstr "MagicMock 与魔术方法支持"

#: ../../library/unittest.mock.rst:2046
msgid "Mocking Magic Methods"
msgstr "模拟魔术方法"

#: ../../library/unittest.mock.rst:2048
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as "
":term:`\"magic methods\" <magic method>`. This allows mock objects to "
"replace containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock` 支持模拟 Python 协议方法，或称 :term:`\"魔术方法\" <magic method>`。 这允许 mock "
"对象替代容器或其他实现了 Python 协议的对象。"

#: ../../library/unittest.mock.rst:2052
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"因为查找魔术方法的方式不同于普通方法 [#]_，这种支持采用了特别的实现。 这意味着只有特定的魔术方法受到支持。 受支持的是 *几乎* 所有魔术方法。 "
"如果有你需要但被遗漏的请告知我们。"

#: ../../library/unittest.mock.rst:2057
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take"
" ``self`` as the first argument [#]_."
msgstr ""
"你可以通过在某个函数或 mock 实例中设置魔术方法来模拟它们。 如果你是使用函数则它 *必须* 接受 ``self`` 作为第一个参数 [#]_。"

#: ../../library/unittest.mock.rst:2080
msgid ""
"One use case for this is for mocking objects used as context managers in a "
":keyword:`with` statement:"
msgstr "一个这样的应用场景是在 :keyword:`with` 语句中模拟作为上下文管理器的对象:"

#: ../../library/unittest.mock.rst:2092
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they"
" are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"对魔术方法的调用不会在 :attr:`~Mock.method_calls` 中出现，但它们会被记录在 :attr:`~Mock.mock_calls`"
" 中。"

#: ../../library/unittest.mock.rst:2097
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an "
":exc:`AttributeError`."
msgstr ""
"如果你使用 *spec* 关键字参数来创建 mock 那么尝试设置不包含在 spec 中的魔术方法将引发 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:2100
msgid "The full list of supported magic methods is:"
msgstr "受支持魔术方法的完整列表如下:"

#: ../../library/unittest.mock.rst:2102
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` 和 ``__str__``"

#: ../../library/unittest.mock.rst:2103
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` 和 ``__subclasses__``"

#: ../../library/unittest.mock.rst:2104
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` 和 ``__ceil__``"

#: ../../library/unittest.mock.rst:2105
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"比较运算: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` 和 "
"``__ne__``"

#: ../../library/unittest.mock.rst:2107
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"容器方法: ``__getitem__``, ``__setitem__``, ``__delitem__``, ``__contains__``, "
"``__len__``, ``__iter__``, ``__reversed__`` 和 ``__missing__``"

#: ../../library/unittest.mock.rst:2110
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr "上下文管理器: ``__enter__``, ``__exit__``, ``__aenter__`` 和 ``__aexit__``"

#: ../../library/unittest.mock.rst:2111
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "单目数值运算方法: ``__neg__``, ``__pos__`` 和 ``__invert__``"

#: ../../library/unittest.mock.rst:2112
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"数值运算方法（包括右侧和原地两种形式）: ``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, "
"``__truediv__``, ``__floordiv__``, ``__mod__``, ``__divmod__``, "
"``__lshift__``, ``__rshift__``, ``__and__``, ``__xor__``, ``__or__`` 和 "
"``__pow__``"

#: ../../library/unittest.mock.rst:2116
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr "数值转换方法: ``__complex__``, ``__int__``, ``__float__`` 和 ``__index__``"

#: ../../library/unittest.mock.rst:2118
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "描述器方法: ``__get__``, ``__set__`` and ``__delete__``"

#: ../../library/unittest.mock.rst:2119
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"封存方法: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` 和 ``__setstate__``"

#: ../../library/unittest.mock.rst:2121
msgid "File system path representation: ``__fspath__``"
msgstr "文件系统路径表示: ``__fspath__``"

#: ../../library/unittest.mock.rst:2122
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "异步迭代方法: ``__aiter__`` and ``__anext__``"

#: ../../library/unittest.mock.rst:2124
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "增加了对 :func:`os.PathLike.__fspath__` 的支持。"

#: ../../library/unittest.mock.rst:2127
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"增加了对 ``__aenter__``, ``__aexit__``, ``__aiter__`` 和 ``__anext__`` 的支持。"

#: ../../library/unittest.mock.rst:2131
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr "下列方法均存在但是 *不受* 支持，因为它们或者被 mock 所使用，或者无法动态设置，或者可能导致问题:"

#: ../../library/unittest.mock.rst:2134
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` 和 ``__new__``"

#: ../../library/unittest.mock.rst:2135
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

#: ../../library/unittest.mock.rst:2140
msgid "Magic Mock"
msgstr "MagicMock"

#: ../../library/unittest.mock.rst:2142
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and "
":class:`NonCallableMagicMock`."
msgstr ""
"存在两个版本的 ``MagicMock``: :class:`MagicMock` 和 :class:`NonCallableMagicMock`."

#: ../../library/unittest.mock.rst:2147
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of"
" most of the :term:`magic methods <magic method>`. You can use ``MagicMock``"
" without having to configure the magic methods yourself."
msgstr ""
"``MagicMock`` 是具有大部分 :term:`魔术方法 <magic method>` 的默认实现的 :class:`Mock` 的子类。 "
"你可以使用 ``MagicMock`` 而无法自行配置这些魔术方法。"

#: ../../library/unittest.mock.rst:2151
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "构造器形参的含义与 :class:`Mock` 的相同。"

#: ../../library/unittest.mock.rst:2153
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that"
" exist in the spec will be created."
msgstr "如果你使用了 *spec* 或 *spec_set* 参数则将 *只有* 存在于 spec 中的魔术方法会被创建。"

#: ../../library/unittest.mock.rst:2159
msgid "A non-callable version of :class:`MagicMock`."
msgstr ":class:`MagicMock` 的不可调用版本。"

#: ../../library/unittest.mock.rst:2161
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning"
" on a non-callable mock."
msgstr ""
"其构造器的形参具有与 :class:`MagicMock` 相同的含义，区别在于 *return_value* 和 *side_effect* "
"在不可调用的 mock 上没有意义。"

#: ../../library/unittest.mock.rst:2165
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr "魔术方法是通过 :class:`MagicMock` 对象来设置的，因此你可以用通常的方式来配置它们并使用它们:"

#: ../../library/unittest.mock.rst:2175
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"在默认情况下许多协议方法都需要返回特定类型的对象。 这些方法都预先配置了默认的返回值，以便它们在你对返回值不感兴趣时可以不做任何事就能被使用。 "
"如果你想要修改默认值则你仍然可以手动 *设置* 返回值。"

#: ../../library/unittest.mock.rst:2181
msgid "Methods and their defaults:"
msgstr "方法及其默认返回值:"

#: ../../library/unittest.mock.rst:2183
msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``: :data:`NotImplemented`"

#: ../../library/unittest.mock.rst:2184
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2185
msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2186
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2187
msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

#: ../../library/unittest.mock.rst:2188
msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

#: ../../library/unittest.mock.rst:2189
msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

#: ../../library/unittest.mock.rst:2190
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

#: ../../library/unittest.mock.rst:2191
msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

#: ../../library/unittest.mock.rst:2192
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

#: ../../library/unittest.mock.rst:2193
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

#: ../../library/unittest.mock.rst:2194
msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

#: ../../library/unittest.mock.rst:2195
msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

#: ../../library/unittest.mock.rst:2196
msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

#: ../../library/unittest.mock.rst:2197
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: mock 的默认 hash"

#: ../../library/unittest.mock.rst:2198
msgid "``__str__``: default str for the mock"
msgstr "``__str__``: mock 的默认 str"

#: ../../library/unittest.mock.rst:2199
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: mock 的默认 sizeof"

#: ../../library/unittest.mock.rst:2201
msgid "For example:"
msgstr "例如:"

#: ../../library/unittest.mock.rst:2213
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the "
":attr:`~Mock.side_effect` attribute, unless you change their return value to"
" return something else::"
msgstr ""
"两个相等性方法 :meth:`!__eq__` 和 :meth:`!__ne__` 是特殊的。 它们会基于标识号进行默认的相等性比较，使用 "
":attr:`~Mock.side_effect` 属性，除非你修改它们的返回值以返回其他内容::"

#: ../../library/unittest.mock.rst:2218
msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"

#: ../../library/unittest.mock.rst:2227
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ":meth:`MagicMock.__iter__` 的返回值可以是任意可迭代对象而不要求必须是迭代器:"

#: ../../library/unittest.mock.rst:2237
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr "如果返回值 *是* 迭代器，则对其执行一次迭代就会将它耗尽因而后续执行的迭代将会输出空列表:"

#: ../../library/unittest.mock.rst:2246
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr "``MagicMock`` 已配置了所有受支持的魔术方法，只有某些晦涩和过时的魔术方法是例外。 如果你需要仍然可以设置它们。"

#: ../../library/unittest.mock.rst:2249
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr "在 ``MagicMock`` 中受到支持但默认未被设置的魔术方法有:"

#: ../../library/unittest.mock.rst:2251
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2252
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2253
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2254
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` 和 ``__delete__``"

#: ../../library/unittest.mock.rst:2255
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` 和 ``__missing__``"

#: ../../library/unittest.mock.rst:2256
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` 和 ``__setstate__``"

#: ../../library/unittest.mock.rst:2258
msgid "``__getformat__``"
msgstr "``__getformat__``"

#: ../../library/unittest.mock.rst:2262
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of "
"Python."
msgstr ""
"魔术方法 *应当* 是在类中而不是在实例中查找。 不同的 Python 版本对这个规则的应用并不一致。 受支持的协议方法应当适用于所有受支持的 "
"Python 版本。"

#: ../../library/unittest.mock.rst:2266
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance"
" is kept isolated from the others."
msgstr "该函数基本上是与类挂钩的，但每个 ``Mock`` 实例都会与其他实例保持隔离。"

#: ../../library/unittest.mock.rst:2271
msgid "Helpers"
msgstr "辅助对象"

#: ../../library/unittest.mock.rst:2274
msgid "sentinel"
msgstr "sentinel"

#: ../../library/unittest.mock.rst:2278
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr "``sentinel`` 对象提供了一种为你的测试提供独特对象的便捷方式。"

#: ../../library/unittest.mock.rst:2281
msgid ""
"Attributes are created on demand when you access them by name. Accessing the"
" same attribute will always return the same object. The objects returned "
"have a sensible repr so that test failure messages are readable."
msgstr ""
"属性是在你通过名称访问它们时按需创建的。 访问相同的属性将始终返回相同的对象。 返回的对象会有一个合理的 repr 以使测试失败消息易于理解。"

#: ../../library/unittest.mock.rst:2285
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are "
":mod:`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"现在 ``sentinel`` 属性会在它们被 :mod:`copy <copy>` 或 :mod:`pickle <pickle>` 时保存其标识。"

#: ../../library/unittest.mock.rst:2289
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named"
" sentinel objects to test this. :data:`sentinel` provides a convenient way "
"of creating and testing the identity of objects like this."
msgstr ""
"在测试时你可能需要测试是否有一个特定的对象作为参数被传给了另一个方法，或是被其返回。 通常的做法是创建一个指定名称的 sentinel "
"对象来执行这种测试。 :data:`sentinel` 提供了一种创建和测试此类对象的标识的便捷方式。"

#: ../../library/unittest.mock.rst:2294
msgid ""
"In this example we monkey patch ``method`` to return "
"``sentinel.some_object``:"
msgstr "在这个示例中我们为 ``method`` 打上便捷补丁以返回 ``sentinel.some_object``:"

#: ../../library/unittest.mock.rst:2306
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2311
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually "
"``sentinel.DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions"
" to indicate that the normal return value should be used."
msgstr ""
":data:`DEFAULT` 对象是一个预先创建的 sentinel (实际为 ``sentinel.DEFAULT``)。 它可被 "
":attr:`~Mock.side_effect` 函数用来指明其应当使用正常的返回值。"

#: ../../library/unittest.mock.rst:2317
msgid "call"
msgstr "call"

#: ../../library/unittest.mock.rst:2321
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing"
" with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, "
":attr:`~Mock.mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can "
"also be used with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` 是一个可创建更简单断言的辅助对象，用于同 :attr:`~Mock.call_args`, "
":attr:`~Mock.call_args_list`, :attr:`~Mock.mock_calls` 和 "
":attr:`~Mock.method_calls` 进行比较。 :func:`call` 也可配合 "
":meth:`~Mock.assert_has_calls` 使用。"

#: ../../library/unittest.mock.rst:2334
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr "对于代表多个调用的 call 对象，:meth:`call_list` 将返回一个包含所有中间调用以及最终调用的列表。"

#: ../../library/unittest.mock.rst:2338
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` 特别适用于创建针对“链式调用”的断言。 链式调用是指在一行代码中执行的多个调用。 这将使得一个 mock 的中存在多个条目 "
":attr:`~Mock.mock_calls`。 手动构造调用的序列将会很烦琐。"

#: ../../library/unittest.mock.rst:2343
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ":meth:`~call.call_list` 可以根据同一个链式调用构造包含多个调用的序列:"

#: ../../library/unittest.mock.rst:2360
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, "
":attr:`Mock.call_args_list` and :attr:`Mock.mock_calls` attributes can be "
"introspected to get at the individual arguments they contain."
msgstr ""
"根据构造方式的不同，``call`` 对象可以是一个 (位置参数, 关键字参数) 或 (名称, 位置参数, 关键字参数) 元组。 "
"当你自行构造它们时这没有什么关系，但是 :attr:`Mock.call_args`, :attr:`Mock.call_args_list` 和 "
":attr:`Mock.mock_calls` 属性当中的 ``call`` 对象可以被反查以获取它们所包含的单个参数。"

#: ../../library/unittest.mock.rst:2367
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and "
":attr:`Mock.call_args_list` are two-tuples of (positional args, keyword "
"args) whereas the ``call`` objects in :attr:`Mock.mock_calls`, along with "
"ones you construct yourself, are three-tuples of (name, positional args, "
"keyword args)."
msgstr ""
":attr:`Mock.call_args` 和 :attr:`Mock.call_args_list` 中的 ``call`` 对象是 (位置参数, "
"关键字参数) 二元组而 :attr:`Mock.mock_calls` 中以及你自行构造的 ``call`` 对象则是 (名称, 位置参数, "
"关键字参数) 三元组。"

#: ../../library/unittest.mock.rst:2372
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"你可以使用它们作为“元组”的特性来为更复杂的内省和断言功能获取单个参数。 位置参数是一个元组（如无位置参数则为空元组）而关键字参数是一个字典:"

#: ../../library/unittest.mock.rst:2405
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2409
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr "使用另一对象作为 spec 来创建 mock 对象。 mock 的属性将使用 *spec* 对象上的对应属性作为其 spec。"

#: ../../library/unittest.mock.rst:2413
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr "被模拟的函数或方法的参数将会被检查以确保它们是附带了正确的签名被调用的。"

#: ../../library/unittest.mock.rst:2416
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist"
" on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"如果 *spec_set* 为 ``True`` 则尝试设置不存在于 spec 对象中的属性将引发 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:2419
msgid ""
"If a class is used as a spec then the return value of the mock (the instance"
" of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only"
" be callable if instances of the mock are callable."
msgstr ""
"如果将类用作 spec 则 mock（该类的实例）的返回值将为这个 spec。 你可以通过传入 ``instance=True`` "
"来将某个类用作一个实例对象的 spec。 被返回的 mock 将仅在该 mock 的实例为可调用对象时才会是可调用对象。"

#: ../../library/unittest.mock.rst:2424
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ":func:`create_autospec` 也接受被传入所创建 mock 的构造器的任意关键字参数。"

#: ../../library/unittest.mock.rst:2427
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with "
":func:`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"请参阅 :ref:`auto-speccing` 来了解如何通过 :func:`create_autospec` 以及 :func:`patch` 的 "
"*autospec* 参数来自动设置 spec。"

#: ../../library/unittest.mock.rst:2433
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr "如果目标为异步函数那么 :func:`create_autospec` 现在将返回一个 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:2438
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2442
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a"
" call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"有时你可能需要设置关于要模拟的调用中的 *某些* 参数的断言，但是又不想理会其他参数或者想要从 :attr:`~Mock.call_args` "
"中单独拿出它们并针对它们设置更复杂的断言。"

#: ../../library/unittest.mock.rst:2447
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and "
":meth:`~Mock.assert_called_once_with` will then succeed no matter what was "
"passed in."
msgstr ""
"为了忽略某些参数你可以传入与 *任意对象* 相等的对象。 这样再调用 :meth:`~Mock.assert_called_with` 和 "
":meth:`~Mock.assert_called_once_with` 时无论传入什么参数都将执行成功。"

#: ../../library/unittest.mock.rst:2456
msgid ""
":data:`ANY` can also be used in comparisons with call lists like "
":attr:`~Mock.mock_calls`:"
msgstr ":data:`ANY` 也可被用在与 :attr:`~Mock.mock_calls` 这样的调用列表相比较的场合:"

#: ../../library/unittest.mock.rst:2466
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ":data:`ANY` 并不仅限于同调用对象的比较而是也可被用于测试断言::"

#: ../../library/unittest.mock.rst:2469
msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"

#: ../../library/unittest.mock.rst:2477
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2481
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set "
"``mock.FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` 是一个控制 mock 对象响应 :func:`dir` 的方式的模块组变量。 默认值为 "
"``True``，这将使用下文所描述的过滤操作，以便只显示有用的成员。 如果你不喜欢这样的过滤，或是出于诊断目的需要将其关闭，则应设置 "
"``mock.FILTER_DIR = False``。"

#: ../../library/unittest.mock.rst:2487
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the"
" attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"当启用过滤时，``dir(some_mock)`` 将只显示有用的属性并将包括正常情况下不会被显示的任何动态创建的属性。 如果 mock 是使用 "
"*spec* (当然也可以是 *autospec*) 创建的则原有的所有属性都将被显示，即使它们还未被访问过:"

#: ../../library/unittest.mock.rst:2493
msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."

#: ../../library/unittest.mock.rst:2514
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been"
" filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"许多不太有用的（是 :class:`Mock` 的而不是被模拟对象的私有成员）开头带有下划线和双下划线的属性已从在 :class:`Mock` 上对 "
":func:`dir` 的调用的结果中被过滤。 如果你不喜欢此行为你可以通过设置模块级开关 :data:`FILTER_DIR` 来将其关闭:"

#: ../../library/unittest.mock.rst:2520
msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."

#: ../../library/unittest.mock.rst:2535
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`FILTER_DIR`."
msgstr ""
"或者你也可以直接使用 ``vars(my_mock)`` (实例成员) 和 ``dir(type(my_mock))`` (类型成员) 来绕过不考虑 "
":const:`FILTER_DIR` 的过滤。"

#: ../../library/unittest.mock.rst:2541
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2545
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"创建 mock 来代替使用 :func:`open` 的辅助函数。 它对于 :func:`open` 被直接调用或被用作上下文管理器的情况都适用。"

#: ../../library/unittest.mock.rst:2548
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"*mock* 参数是要配置的 mock 对象。 如为 ``None`` (默认值) 则将为你创建一个 :class:`MagicMock`，其 API "
"会被限制为可用于标准文件处理的方法或属性。"

#: ../../library/unittest.mock.rst:2552
msgid ""
"*read_data* is a string for the :meth:`~io.RawIOBase.read`, "
":meth:`~io.IOBase.readline`, and :meth:`~io.IOBase.readlines` methods of the"
" file handle to return.  Calls to those methods will take data from "
"*read_data* until it is depleted.  The mock of these methods is pretty "
"simplistic: every time the *mock* is called, the *read_data* is rewound to "
"the start.  If you need more control over the data that you are feeding to "
"the tested code you will need to customize this mock for yourself.  When "
"that is insufficient, one of the in-memory filesystem packages on `PyPI "
"<https://pypi.org>`_ can offer a realistic filesystem for testing."
msgstr ""
"*read_data* 是供文件句柄的 :meth:`~io.RawIOBase.read`, :meth:`~io.IOBase.readline` "
"和 :meth:`~io.IOBase.readlines` 方法返回的字符串。 调用这些方法将会从 *read_data* 获取数据直到它被耗尽。 "
"对这些方法的模拟是相当简化的：每次 *mock* 被调用时，*read_data* 都将从头开始。 "
"如果你需要对你提供给测试代码的数据有更多控制那么你将需要自行定制这个 mock。 如果这还不够用，那么通过一些 `PyPI "
"<https://pypi.org>`_ 上的内存文件系统包可以提供更真实的测试用文件系统。"

#: ../../library/unittest.mock.rst:2562
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.RawIOBase.read` changed to consume *read_data* rather"
" than returning it on each call."
msgstr ""
"增加了对 :meth:`~io.IOBase.readline` 和 :meth:`~io.IOBase.readlines` 的支持。 对 "
":meth:`~io.RawIOBase.read` 的模拟被改为消耗 *read_data* 而不是每次调用时返回它。"

#: ../../library/unittest.mock.rst:2567
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* 现在会在每次 *mock* 的调用时重置。"

#: ../../library/unittest.mock.rst:2570
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""
"为实现增加了 :meth:`~container.__iter__` 以便迭代操作（例如在 for 循环中）能正确地使用 *read_data*。"

#: ../../library/unittest.mock.rst:2574
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr "将 :func:`open` 用作上下文管理器一确保你的文件处理被正确关闭的最佳方式因而十分常用::"

#: ../../library/unittest.mock.rst:2577
msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"

#: ../../library/unittest.mock.rst:2580
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has "
":meth:`~object.__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"这里的问题在于即使你模拟了对 :func:`open` 的调用但被用作上下文管理器（并调用其 :meth:`~object.__enter__` 和 "
":meth:`~object.__exit__` 方法）的却是 *被返回的对象*。"

#: ../../library/unittest.mock.rst:2584
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr "通过 :class:`MagicMock` 来模拟上下文管理器是十分常见且十分麻烦的因此需要使用一个辅助函数。 ::"

#: ../../library/unittest.mock.rst:2587
msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"

#: ../../library/unittest.mock.rst:2601
msgid "And for reading files::"
msgstr "以及针对读取文件::"

#: ../../library/unittest.mock.rst:2603
msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"

#: ../../library/unittest.mock.rst:2614
msgid "Autospeccing"
msgstr "自动 spec"

#: ../../library/unittest.mock.rst:2616
msgid ""
"Autospeccing is based on the existing :attr:`!spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a "
":exc:`TypeError` if they are called incorrectly."
msgstr ""
"自动 spec 是基于 mock 现有的 :attr:`!spec` 特性。 它将 mock 的 api 限制为原始对象（spec）的 "
"api，但它是递归（惰性实现）的因而 mock 的属性只有与 spec 的属性相同的 api。 除此之外被模拟的函数 / "
"方法具有与原对应物相同的调用签名因此如果它们被不正确地调用时会引发 :exc:`TypeError`。"

#: ../../library/unittest.mock.rst:2623
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr "在我开始解释自动 spec 如何运作之前，先说明一下它的必要性。"

#: ../../library/unittest.mock.rst:2625
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from a "
"flaw which is general to mocking. If you refactor some of your code, rename "
"members and so on, any tests for code that is still using the *old api* but "
"uses mocks instead of the real objects will still pass. This means your "
"tests can all pass even though your code is broken."
msgstr ""
":class:`Mock` 是个非常强大和灵活的对象，但对 mock 操作来说有一个普遍存在的缺陷。 "
"如果你重构了你的部分代码，如修改成员的名称等，则针对仍然使用 *旧 API* 但其使用的是 mock 而非真实对象的代码的测试仍将通过。 "
"这意味着即使你的代码已被破坏你的测试却仍可能全部通过。"

#: ../../library/unittest.mock.rst:2633
msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when "
"they should raise an error. You can still achieve this behavior by passing "
"``unsafe=True`` to Mock."
msgstr ""
"在 3.5 之前，在词断言中带有拼写错误应当引发错误的测试将会静默地通过。 你仍然可通过向 Mock 传入 ``unsafe=True`` "
"来实现此行为。"

#: ../../library/unittest.mock.rst:2636
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"请注意这是为什么你在单元测试之外还需要集成测试的原因之一。 "
"孤立地测试每个部分时全都正常而顺滑，但是如果你没有测试你的各个单元“联成一体”的情况如何那么就仍然存在测试可以发现大量错误的空间。"

#: ../../library/unittest.mock.rst:2641
msgid ""
":mod:`unittest.mock` already provides a feature to help with this, called "
"speccing. If you use a class or instance as the :attr:`!spec` for a mock "
"then you can only access attributes on the mock that exist on the real "
"class:"
msgstr ""
":mod:`unittest.mock` 已经提供了一个对此有帮助的特性，称为 spec 控制。 如果你使用类或实例作为一个 mock 的 "
":attr:`!spec` 那么你将仅能访问 mock 中只存在于实际的类中的属性："

#: ../../library/unittest.mock.rst:2652
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr "这个 spec 仅会应用于 mock 本身，因此对于 mock 中的任意方法我们仍然面临相同的问题:"

#: ../../library/unittest.mock.rst:2655
msgid ""
">>> mock.header_items()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.header_items.assret_called_with()  # Intentional typo!"
msgstr ""
">>> mock.header_items()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.header_items.assret_called_with()  # 故意的拼写错误！"

#: ../../library/unittest.mock.rst:2661
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to "
":func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"自动 spec 解决了这个问题。 你可以将 ``autospec=True`` 传给 :func:`patch` / "
":func:`patch.object` 或是使用 :func:`create_autospec` 函数来创建带有 spec 的 mock。 如果你是将"
" ``autospec=True`` 参数传给 :func:`patch` 那么被替代的那个对象将被用作 spec 对象。 因为 spec "
"控制是“惰性地”执行的（spec 在 mock "
"中的属性被访问时才会被创建）所以即使是非常复杂或深度嵌套的对象（例如需要导入本身已导入了多个模块的模块）你也可以使用它而不会有太大的性能损失。"

#: ../../library/unittest.mock.rst:2670
msgid "Here's an example of it in use::"
msgstr "以下是一个实际应用的示例::"

#: ../../library/unittest.mock.rst:2672
msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2680
msgid ""
"You can see that :class:`!request.Request` has a spec. "
":class:`!request.Request` takes two arguments in the constructor (one of "
"which is *self*). Here's what happens if we try to call it incorrectly::"
msgstr ""
"你可以看到 :class:`!request.Request` 有一个 spec。 :class:`!request.Request` "
"构造器接受两个参数 (其中一个是 *self*)。 如果我们尝试不正确地调用它就会是这样的结果::"

#: ../../library/unittest.mock.rst:2684
msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"

#: ../../library/unittest.mock.rst:2689
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr "该 spec 也将应用于被实例化的类（即附带i.e. the return value of spec 的 mock 的返回值）::"

#: ../../library/unittest.mock.rst:2692
msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2696
msgid ""
":class:`!Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`!request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct"
" error::"
msgstr ""
":class:`!Request` 对象不是可调用对象，因此实例化我们的被模拟 :class:`!request.Request` "
"的返回值是一个不可调用的 mock。 有了这个 spec 我们的断言中出现的任何拼写问题都将引发正确的报错::"

#: ../../library/unittest.mock.rst:2700
msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # 故意的拼写错误！\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"

#: ../../library/unittest.mock.rst:2708
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos"
" and api changes."
msgstr ""
"在许多情况下你将只需将 ``autospec=True`` 添加到你现有的 :func:`patch` 调用中即可防止拼写错误和 api "
"变化所导致的问题。"

#: ../../library/unittest.mock.rst:2712
msgid ""
"As well as using *autospec* through :func:`patch` there is a "
":func:`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"除了通过 :func:`patch` 来使用 *autospec*  还有一个 :func:`create_autospec` 可以直接创建带有自动 "
"spec 的 mock:"

#: ../../library/unittest.mock.rst:2720
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the"
" spec object, autospec has to introspect (access attributes) the spec. As "
"you traverse attributes on the mock a corresponding traversal of the "
"original object is happening under the hood. If any of your specced objects "
"have properties or descriptors that can trigger code execution then you may "
"not be able to use autospec. On the other hand it is much better to design "
"your objects so that introspection is safe [#]_."
msgstr ""
"不过这并非没有缺点和限制，这也就是为什么它不是默认行为。 为了知道在 spec 对象上有哪些属性是可用的，autospec 必须对 spec "
"进行自省（访问其属性）。 当你遍历 mock 上的属性时在原始对象上的对应遍历也将在底层进行。 如果你的任何带 spec "
"的对象具有可触发代码执行的特征属性或描述器则你可能会无法使用 autospec。 在另一方面更好的的做法是将你的对象设计为可以安全地执行自省 [#]_。"

#: ../../library/unittest.mock.rst:2729
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class"
" at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""
"一个更严重的问题在于实例属性通常是在 :meth:`~object.__init__` 方法中被创建而在类中完全不存在。 *autospec* "
"无法获取动态创建的属性而使得 api 被限制于可见的属性。 ::"

#: ../../library/unittest.mock.rst:2734
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"

#: ../../library/unittest.mock.rst:2746
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow"
" you to fetch attributes that don't exist on the spec it doesn't prevent you"
" setting them::"
msgstr ""
"要解决这个问题有几种不同的方式。 最容易但多少有些烦扰的方式是简单地在 mock 创建完成后再设置所需的属性。 Just because "
"*autospec* 只是不允许你获取不存在于 spec 上的属性但并不会阻止你设置它们::"

#: ../../library/unittest.mock.rst:2752
msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."

#: ../../library/unittest.mock.rst:2757
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does*"
" prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents"
" this particular scenario:"
msgstr ""
"*spec* 和 *autospec* 都有更严格的版本 *确实能* 阻止你设置不存在的属性。 这在你希望确保你的代码只能 *设置* "
"有效的属性时也很有用，但显然它会阻止下面这个特定的应用场景:"

#: ../../library/unittest.mock.rst:2770
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`."
" Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""
"解决此问题的最好方式可能是添加类属性作为在 :meth:`~object.__init__` 中初始化的实例属性的默认值。 请注意如果你只在. Note"
" that if you are only setting default attributes in :meth:`!__init__` "
"中设置默认属性那么通过类属性来提供它们（当然会在实例之间共享）也将有更快的速度。 例如"

#: ../../library/unittest.mock.rst:2776
msgid ""
"class Something:\n"
"    a = 33"
msgstr ""
"class Something:\n"
"    a = 33"

#: ../../library/unittest.mock.rst:2781
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access"
" *any* attributes or methods on it. As ``None`` is *never* going to be "
"useful as a spec, and probably indicates a member that will normally of some"
" other type, autospec doesn't use a spec for members that are set to "
"``None``. These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"这带来了另一个问题。 为今后将变为不同类型对象的那些成员提供默认值 ``None`` 是比较常见的做法。 ``None`` 作为 spec "
"是没有用处的，因为它会使你无法访问 *any* 任何属性或方法。 由于 ``None`` 作为 spec 将 *永远不会* "
"有任何用处，并且有可能要指定某个通常为其他类型的成员，因此 autospec 不会为被设为 ``None`` 的成员使用 spec。 它们将为普通的 "
"mock (嗯 —— 应为 MagicMocks):"

#: ../../library/unittest.mock.rst:2796
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"如果你不喜欢修改你的生产类来添加默认值那么还有其他的选项。 其中之一是简单地使用一个实例而非类作为 spec。 "
"另一选项则是创建一个生产类的子类并向该子类添加默认值而不影响到生产类。 这两个选项都需要你使用一个替代对象作为 spec。 值得庆幸的是 "
":func:`patch` 支持这样做 —— 你可以简单地传入替代对象作为 *autospec* 参数::"

#: ../../library/unittest.mock.rst:2804
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"

#: ../../library/unittest.mock.rst:2817
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It"
" is only attribute lookups - along with calls to :func:`dir` - that are "
"done."
msgstr ""
"这仅适用于类或已实例化的对象。 调用一个被模拟的类来创建一个 mock 实例 *不会* 创建真的实例。 只有属性查找 —— 以及对 "
":func:`dir` 的调用 —— 会被执行。"

#: ../../library/unittest.mock.rst:2822
msgid "Sealing mocks"
msgstr "将 mock 封包"

#: ../../library/unittest.mock.rst:2831
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already"
" mocks recursively."
msgstr "封包将在访问被封包的 mock 的属性或其任何已经被递归地模拟的属性时禁止自动创建 mock。"

#: ../../library/unittest.mock.rst:2834
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"如果一个带有名称或 spec 的 mock 实例被分配给一个属性则将不会在封包链中处理它。 这可以防止人们对 mock 对象的固定部分执行封包。 ::"

#: ../../library/unittest.mock.rst:2838
msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # 这将引发 AttributeError。\n"
">>> mock.submock.attribute2  # 这将引发 AttributeError。\n"
">>> mock.not_submock.attribute2  # 这不会引发异常。"

#: ../../library/unittest.mock.rst:2850
msgid ""
"Order of precedence of :attr:`!side_effect`, :attr:`!return_value` and "
"*wraps*"
msgstr ":attr:`!side_effect`, :attr:`!return_value` 和 *wraps* 的优先顺序"

#: ../../library/unittest.mock.rst:2852
msgid "The order of their precedence is:"
msgstr "它们的优先顺序是："

#: ../../library/unittest.mock.rst:2854
msgid ":attr:`~Mock.side_effect`"
msgstr ":attr:`~Mock.side_effect`"

#: ../../library/unittest.mock.rst:2855
msgid ":attr:`~Mock.return_value`"
msgstr ":attr:`~Mock.return_value`"

#: ../../library/unittest.mock.rst:2856
msgid "*wraps*"
msgstr "*wraps*"

#: ../../library/unittest.mock.rst:2858
msgid ""
"If all three are set, mock will return the value from "
":attr:`~Mock.side_effect`, ignoring :attr:`~Mock.return_value` and the "
"wrapped object altogether. If any two are set, the one with the higher "
"precedence will return the value. Regardless of the order of which was set "
"first, the order of precedence remains unchanged."
msgstr ""
"如果三个均已设置，模拟对象将返回来自 :attr:`~Mock.side_effect` 的值，完全忽略 "
":attr:`~Mock.return_value` 和被包装的对象。 如果设置任意两个，则具有更高优先级的那个将返回值。 "
"无论设置的顺序是哪个在前，优先级顺序将保持不变。"

#: ../../library/unittest.mock.rst:2876
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked"
" between :attr:`~Mock.return_value` and the wrapped object, ignoring "
":attr:`~Mock.side_effect`."
msgstr ""
"由于 ``None`` 是 :attr:`~Mock.side_effect` 的默认值，如果你将其值重新赋为 ``None``，则优先级顺序将在 "
":attr:`~Mock.return_value` 和被包装的对象之间进行检查，并忽略 :attr:`~Mock.side_effect`。"

#: ../../library/unittest.mock.rst:2885
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`,"
" it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""
"如果 :attr:`~Mock.side_effect` 所返回的值为 "
":data:`DEFAULT`，它将被忽略并且优先级顺序将移至后继者来获取要返回的值。"

#: ../../library/unittest.mock.rst:2894
msgid ""
"When :class:`Mock` wraps an object, the default value of "
":attr:`~Mock.return_value` will be :data:`DEFAULT`."
msgstr ""
"当 :class:`Mock` 包装一个对象时，:attr:`~Mock.return_value` 的默认值将为 :data:`DEFAULT`。"

#: ../../library/unittest.mock.rst:2903
msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr "优先级顺序将忽略该值并且它将移至末尾的后继者即被包装的对象。"

#: ../../library/unittest.mock.rst:2906
msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr "由于真正调用的是被包装的对象，创建该模拟对象的实例将返回真正的该类实例。 被包装的对象所需要的任何位置参数都必须被传入。"

#: ../../library/unittest.mock.rst:2924
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr "但是如果你将其赋值为 ``None``，由于它是一个显式赋值所以不会被忽略。 因此，优先级顺序将不会移至被包装的对象。"

#: ../../library/unittest.mock.rst:2932
msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr "即使你在初始化模拟对象时立即立即全部设置这三者，优先级顺序仍会保持原样："

#: ../../library/unittest.mock.rst:2949
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration``"
" exception is raised."
msgstr ""
"如果 :attr:`~Mock.side_effect` 已耗尽，优先级顺序将不会导致从后续者获取值。 而是会引发 ``StopIteration`` "
"异常。"
