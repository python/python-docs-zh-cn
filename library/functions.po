# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:03+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/functions.rst:5 ../../library/functions.rst:11
msgid "Built-in Functions"
msgstr "内置函数"

#: ../../library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr "Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。"

#: ../../library/functions.rst:0
msgid "**A**"
msgstr "**A**"

#: ../../library/functions.rst:0
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/functions.rst:0
msgid ":func:`aiter`"
msgstr ":func:`aiter`"

#: ../../library/functions.rst:0
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../../library/functions.rst:0
msgid ":func:`anext`"
msgstr ":func:`anext`"

#: ../../library/functions.rst:0
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../../library/functions.rst:0
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/functions.rst:0
msgid "**B**"
msgstr "**B**"

#: ../../library/functions.rst:0
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../../library/functions.rst:0
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../../library/functions.rst:0
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../../library/functions.rst:0
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../../library/functions.rst:0
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../../library/functions.rst:0
msgid "**C**"
msgstr "**C**"

#: ../../library/functions.rst:0
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../../library/functions.rst:0
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../../library/functions.rst:0
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../../library/functions.rst:0
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../../library/functions.rst:0
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/functions.rst:0
msgid "**D**"
msgstr "**D**"

#: ../../library/functions.rst:0
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../../library/functions.rst:0
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../../library/functions.rst:0
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../../library/functions.rst:0
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/functions.rst:0
msgid "**E**"
msgstr "**E**"

#: ../../library/functions.rst:0
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../../library/functions.rst:0
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../../library/functions.rst:0
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../../library/functions.rst:0
msgid "**F**"
msgstr "**F**"

#: ../../library/functions.rst:0
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../../library/functions.rst:0
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/functions.rst:0
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../../library/functions.rst:0
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../../library/functions.rst:0
msgid "**G**"
msgstr "**G**"

#: ../../library/functions.rst:0
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../../library/functions.rst:0
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../../library/functions.rst:0
msgid "**H**"
msgstr "**H**"

#: ../../library/functions.rst:0
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../../library/functions.rst:0
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../../library/functions.rst:0
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../../library/functions.rst:0
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../../library/functions.rst:0
msgid "**I**"
msgstr "**I**"

#: ../../library/functions.rst:0
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../../library/functions.rst:0
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../../library/functions.rst:0
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/functions.rst:0
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../../library/functions.rst:0
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../../library/functions.rst:0
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../../library/functions.rst:0
msgid "**L**"
msgstr "**L**"

#: ../../library/functions.rst:0
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../../library/functions.rst:0
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../../library/functions.rst:0
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../../library/functions.rst:0
msgid "**M**"
msgstr "**M**"

#: ../../library/functions.rst:0
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../../library/functions.rst:0
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../../library/functions.rst:0
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../../library/functions.rst:0
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../../library/functions.rst:0
msgid "**N**"
msgstr "**N**"

#: ../../library/functions.rst:0
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../../library/functions.rst:0
msgid "**O**"
msgstr "**O**"

#: ../../library/functions.rst:0
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../../library/functions.rst:0
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../../library/functions.rst:0
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../../library/functions.rst:0
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../../library/functions.rst:0
msgid "**P**"
msgstr "**P**"

#: ../../library/functions.rst:0
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/functions.rst:0
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../library/functions.rst:0
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../../library/functions.rst:0
msgid "**R**"
msgstr "**R**"

#: ../../library/functions.rst:0
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../../library/functions.rst:0
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/functions.rst:0
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../../library/functions.rst:0
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../../library/functions.rst:0
msgid "**S**"
msgstr "**S**"

#: ../../library/functions.rst:0
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../../library/functions.rst:0
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../../library/functions.rst:0
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../../library/functions.rst:0
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../../library/functions.rst:0
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../../library/functions.rst:0
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../../library/functions.rst:0
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../../library/functions.rst:0
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../../library/functions.rst:0
msgid "**T**"
msgstr "**T**"

#: ../../library/functions.rst:0
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../../library/functions.rst:0
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../../library/functions.rst:0
msgid "**V**"
msgstr "**V**"

#: ../../library/functions.rst:0
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../../library/functions.rst:0
msgid "**Z**"
msgstr "**Z**"

#: ../../library/functions.rst:0
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../../library/functions.rst:0
msgid "**_**"
msgstr "**_**"

#: ../../library/functions.rst:0
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../../library/functions.rst:59
msgid ""
"Return the absolute value of a number.  The argument may be an integer, a "
"floating-point number, or an object implementing :meth:`~object.__abs__`. If"
" the argument is a complex number, its magnitude is returned."
msgstr ""
"返回一个数字的绝对值。 参数可以是整数、浮点数或任何实现了 :meth:`~object.__abs__` 的对象。 如果参数是一个复数，则返回它的模。"

#: ../../library/functions.rst:67
msgid ""
"Return an :term:`asynchronous iterator` for an :term:`asynchronous "
"iterable`. Equivalent to calling ``x.__aiter__()``."
msgstr ""
"返回  :term:`asynchronous iterable` 的 :term:`asynchronous iterator` 。相当于调用 "
"``x.__aiter__()``。"

#: ../../library/functions.rst:70
msgid "Note: Unlike :func:`iter`, :func:`aiter` has no 2-argument variant."
msgstr "注意：与 :func:`iter` 不同，:func:`aiter` 没有两个参数的版本。"

#: ../../library/functions.rst:76
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr "如果 *iterable* 的所有元素均为真值（或可迭代对象为空）则返回 ``True`` 。 等价于："

#: ../../library/functions.rst:79
msgid ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"
msgstr ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"

#: ../../library/functions.rst:89
msgid ""
"When awaited, return the next item from the given :term:`asynchronous "
"iterator`, or *default* if given and the iterator is exhausted."
msgstr ""
"当进入 await 状态时，从给定 :term:`asynchronous iterator` 返回下一数据项，迭代完毕则返回 *default*。"

#: ../../library/functions.rst:92
msgid ""
"This is the async variant of the :func:`next` builtin, and behaves "
"similarly."
msgstr "这是内置函数 :func:`next` 的异步版本，类似于："

#: ../../library/functions.rst:95
msgid ""
"This calls the :meth:`~object.__anext__` method of *async_iterator*, "
"returning an :term:`awaitable`. Awaiting this returns the next value of the "
"iterator. If *default* is given, it is returned if the iterator is "
"exhausted, otherwise :exc:`StopAsyncIteration` is raised."
msgstr ""
"调用 *async_iterator* 的 :meth:`~object.__anext__` 方法，返回一个 "
":term:`awaitable`。等待返回迭代器的下一个值。若有给出 *default*，则在迭代完毕后会返回给出的值，否则会触发 "
":exc:`StopAsyncIteration`。"

#: ../../library/functions.rst:104
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr "如果 *iterable* 的任一元素为真值则返回 ``True``。 如果可迭代对象为空，返回 ``False``。 等价于::"

#: ../../library/functions.rst:107
msgid ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"
msgstr ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"

#: ../../library/functions.rst:116
msgid ""
"As :func:`repr`, return a string containing a printable representation of an"
" object, but escape the non-ASCII characters in the string returned by "
":func:`repr` using ``\\x``, ``\\u``, or ``\\U`` escapes.  This generates a "
"string similar to that returned by :func:`repr` in Python 2."
msgstr ""
"与 :func:`repr` 类似，返回一个包含对象的可打印表示形式的字符串，但是使用 ``\\x``、``\\u`` 和 ``\\U`` 对 "
":func:`repr` 返回的字符串中非 ASCII 编码的字符进行转义。生成的字符串和 Python 2 的 :func:`repr` "
"返回的结果相似。"

#: ../../library/functions.rst:124
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an"
" integer. Some examples:"
msgstr ""
"将一个整数转换为带前缀 \"0b\" 的二进制数字符串。 结果是一个合法的 Python 表达式。 如果 *x* 不是一个 Python "
":class:`int` 对象，则它必须定义返回一个整数的 :meth:`~object.__index__` 方法。 下面是一些例子:"

#: ../../library/functions.rst:134
msgid ""
"If the prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr "若要控制是否显示前缀“0b”，可以采用以下两种方案："

#: ../../library/functions.rst:141 ../../library/functions.rst:921
#: ../../library/functions.rst:1260
msgid "See also :func:`format` for more information."
msgstr "另见 :func:`format` 获取更多信息。"

#: ../../library/functions.rst:146
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  The argument is "
"converted using the standard :ref:`truth testing procedure <truth>`. If the "
"argument is false or omitted, this returns ``False``; otherwise, it returns "
"``True``.  The :class:`bool` class is a subclass of :class:`int` (see "
":ref:`typesnumeric`). It cannot be subclassed further.  Its only instances "
"are ``False`` and ``True`` (see :ref:`typebool`)."
msgstr ""
"返回布尔值，即 ``True`` 或 ``False`` 中的一个。 其参数将使用标准的 :ref:`真值测试过程 <truth>` 来转换。 "
"如果该参数为假值或被省略，则返回 ``False``；在其他情况下，将返回 ``True``。 :class:`bool` 类是 "
":class:`int` 的子类 (参见 :ref:`typesnumeric`)。 它不能被继续子类化。 它只有 ``False`` 和 "
"``True`` 这两个实例 (参见 :ref:`typebool`)。"

#: ../../library/functions.rst:156 ../../library/functions.rst:786
msgid "The parameter is now positional-only."
msgstr "该形参现在为仅限位置形参。"

#: ../../library/functions.rst:161
msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace` "
"expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing"
" you to drop into the debugger of choice. If :func:`sys.breakpointhook` is "
"not accessible, this function will raise :exc:`RuntimeError`."
msgstr ""
"此函数会在调用位置进入调试器。 具体来说，它将调用 :func:`sys.breakpointhook`，直接传递 ``args`` 和 "
"``kws``。 在默认情况下，``sys.breakpointhook()`` 将不带参数地调用 :func:`pdb.set_trace`。 "
"在此情况下，它纯粹是一个便捷函数让你不必显式地导入 :mod:`pdb` 或键入过多代码即可进入调试器。 "
"不过，:func:`sys.breakpointhook` 也可被设置为某些其他函数并被 :func:`breakpoint` "
"自动调用，允许你进入选定的调试器。 如果 :func:`sys.breakpointhook` 不可用，此函数将引发 "
":exc:`RuntimeError`。"

#: ../../library/functions.rst:173
msgid ""
"By default, the behavior of :func:`breakpoint` can be changed with the "
":envvar:`PYTHONBREAKPOINT` environment variable. See "
":func:`sys.breakpointhook` for usage details."
msgstr ""
"在默认情况下，:func:`breakpoint` 的行为可使用 :envvar:`PYTHONBREAKPOINT` 环境变量来改变。 请参阅 "
":func:`sys.breakpointhook` 了解详细用法。"

#: ../../library/functions.rst:177
msgid ""
"Note that this is not guaranteed if :func:`sys.breakpointhook` has been "
"replaced."
msgstr "请注意这并不保证 :func:`sys.breakpointhook` 会被替换。"

#: ../../library/functions.rst:180
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.breakpoint`` with "
"argument ``breakpointhook``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``builtins.breakpoint`` 并附带参数 "
"``breakpointhook``。"

#: ../../library/functions.rst:190
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"返回一个新的 bytes 数组。 :class:`bytearray` 类是一个可变序列，包含范围为 0 <= x < 256 "
"的整数。它有可变序列大部分常见的方法，见 :ref:`typesseq-mutable` 的描述；同时有 :class:`bytes` "
"类型的大部分方法，参见 :ref:`bytes-methods`。"

#: ../../library/functions.rst:195
msgid ""
"The optional *source* parameter can be used to initialize the array in a few"
" different ways:"
msgstr "可选形参 *source* 可以用不同的方式来初始化数组："

#: ../../library/functions.rst:198
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"如果是一个 *string*，您必须提供 *encoding* 参数（*errors* 参数仍是可选的）；:func:`bytearray` 会使用 "
":meth:`str.encode` 方法来将 string 转变成 bytes。"

#: ../../library/functions.rst:202
msgid ""
"If it is an *integer*, the array will have that size and will be initialized"
" with null bytes."
msgstr "如果是一个 *integer*，会初始化大小为该数字的数组，并使用 null 字节填充。"

#: ../../library/functions.rst:205
msgid ""
"If it is an object conforming to the :ref:`buffer interface "
"<bufferobjects>`, a read-only buffer of the object will be used to "
"initialize the bytes array."
msgstr "如果是一个遵循 :ref:`缓冲区接口 <bufferobjects>` 的对象，该对象的只读缓冲区将被用来初始化字节数组。"

#: ../../library/functions.rst:208
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr "如果是一个 *iterable* 可迭代对象，它的元素的范围必须是 ``0 <= x < 256`` 的整数，它会被用作数组的初始内容。"

#: ../../library/functions.rst:211
msgid "Without an argument, an array of size 0 is created."
msgstr "如果没有实参，则创建大小为 0 的数组。"

#: ../../library/functions.rst:213
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "另见 :ref:`binaryseq` 和 :ref:`typebytearray`。"

#: ../../library/functions.rst:222
msgid ""
"Return a new \"bytes\" object which is an immutable sequence of integers in "
"the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of "
":class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 ``0 <= x < 256`` 的整数。:class:`bytes` 是 "
":class:`bytearray` 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。"

#: ../../library/functions.rst:227
msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr "因此，构造函数的实参和 :func:`bytearray` 相同。"

#: ../../library/functions.rst:229
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr "字节对象还可以用字面值创建，参见 :ref:`strings`。"

#: ../../library/functions.rst:231
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr "另见 :ref:`binaryseq`，:ref:`typebytes` 和 :ref:`bytes-methods`。"

#: ../../library/functions.rst:236
msgid ""
"Return :const:`True` if the *object* argument appears callable, "
":const:`False` if not.  If this returns ``True``, it is still possible that "
"a call fails, but if it is ``False``, calling *object* will never succeed. "
"Note that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`~object.__call__` method."
msgstr ""
"如果 *object* 参数是可调用的则返回 :const:`True`，否则返回 :const:`False`。 如果返回 "
"``True``，调用仍可能失败，但如果返回 ``False``，则调用 *object* 肯定不会成功。 "
"请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 :meth:`~object.__call__` 方法则它就是可调用的。"

#: ../../library/functions.rst:242
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。"

#: ../../library/functions.rst:249
msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of "
":func:`ord`."
msgstr ""
"返回 Unicode 码位为整数 *i* 的字符的字符串格式。例如，``chr(97)`` 返回字符串 ``'a'``，``chr(8364)`` "
"返回字符串 ``'€'``。这是 :func:`ord` 的逆函数。"

#: ../../library/functions.rst:253
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 *i* 超过这个范围，会触发 "
":exc:`ValueError` 异常。"

#: ../../library/functions.rst:259
msgid "Transform a method into a class method."
msgstr "把一个方法封装成类方法。"

#: ../../library/functions.rst:261
msgid ""
"A class method receives the class as an implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr "类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案："

#: ../../library/functions.rst:265
msgid ""
"class C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."
msgstr ""
"class C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."

#: ../../library/functions.rst:269
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see "
":ref:`function` for details."
msgstr ""
"``@classmethod`` 这样的形式称为函数的 :term:`decorator` -- 详情参阅 :ref:`function`。"

#: ../../library/functions.rst:272
msgid ""
"A class method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class "
"object is passed as the implied first argument."
msgstr ""
"类方法的调用可以在类上进行 (例如 ``C.f()``) 也可以在实例上进行 (例如 ``C().f()``)。 其所属类以外的类实例会被忽略。 "
"如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。"

#: ../../library/functions.rst:277
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section. For more information on "
"class methods, see :ref:`types`."
msgstr ""
"类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 :func:`staticmethod`。 "
"有关类方法的更多信息，请参阅 :ref:`types`。"

#: ../../library/functions.rst:281
msgid ""
"Class methods can now wrap other :term:`descriptors <descriptor>` such as "
":func:`property`."
msgstr "类方法现在可以包装其他 :term:`描述器 <descriptor>` 例如 :func:`property`。"

#: ../../library/functions.rst:285
msgid ""
"Class methods now inherit the method attributes "
"(:attr:`~function.__module__`, :attr:`~function.__name__`, "
":attr:`~function.__qualname__`, :attr:`~function.__doc__` and "
":attr:`~function.__annotations__`) and have a new ``__wrapped__`` attribute."
msgstr ""
"类方法现在继承了方法的属性 (:attr:`~function.__module__`, :attr:`~function.__name__`, "
":attr:`~function.__qualname__`, :attr:`~function.__doc__` 和 "
":attr:`~function.__annotations__`) 并具有新的 ``__wrapped__`` 属性。"

#: ../../library/functions.rst:292
msgid ""
"Class methods can no longer wrap other :term:`descriptors <descriptor>` such"
" as :func:`property`."
msgstr "类方法不再可以包装其他 :term:`descriptors <descriptor>`  例如 :func:`property`。"

#: ../../library/functions.rst:299
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"将 *source* 编译成代码或 AST 对象。代码对象可以被 :func:`exec` 或 :func:`eval` 执行。*source* "
"可以是常规的字符串、字节字符串，或者 AST 对象。参见 :mod:`ast` 模块的文档了解如何使用 AST 对象。"

#: ../../library/functions.rst:304
msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"*filename* 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 ``'<string>'``）。"

#: ../../library/functions.rst:308
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that"
" evaluate to something other than ``None`` will be printed)."
msgstr ""
"*mode* 实参指定了编译代码必须用的模式。如果 *source* 是语句序列，可以是 ``'exec'``；如果是单一表达式，可以是 "
"``'eval'``；如果是单个交互式语句，可以是 ``'single'``。（在最后一种情况下，如果表达式执行结果不是 ``None`` "
"将会被打印出来。）"

#: ../../library/functions.rst:314
msgid ""
"The optional arguments *flags* and *dont_inherit* control which "
":ref:`compiler options <ast-compiler-flags>` should be activated and which "
":ref:`future features <future>` should be allowed. If neither is present (or"
" both are zero) the code is compiled with the same flags that affect the "
"code that is calling :func:`compile`. If the *flags* argument is given and "
"*dont_inherit* is not (or is zero) then the compiler options and the future "
"statements specified by the *flags* argument are used in addition to those "
"that would be used anyway. If *dont_inherit* is a non-zero integer then the "
"*flags* argument is it -- the flags (future features and compiler options) "
"in the surrounding code are ignored."
msgstr ""
"可选参数 *flags* 和 *dont_inherit* 控制应当激活哪个 :ref:`编译器选项 <ast-compiler-flags>` "
"以及应当允许哪个 :ref:`future 特性 <future>`。 如果两者都未提供 (或都为零) 则代码会应用与调用 "
":func:`compile` 的代码相同的旗标来编译。 如果给出了 *flags* 参数而未给出 *dont_inherit* (或者为零) "
"则会在无论如何都将被使用的旗标之外还会额外使用 *flags* 参数所指定的编译器选项和 future 语句。 如果 *dont_inherit* "
"为非零整数，则只使用 *flags* 参数 -- 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。"

#: ../../library/functions.rst:325
msgid ""
"Compiler options and future statements are specified by bits which can be "
"bitwise ORed together to specify multiple options. The bitfield required to "
"specify a given future feature can be found as the "
":attr:`~__future__._Feature.compiler_flag` attribute on the "
":class:`~__future__._Feature` instance in the :mod:`__future__` module. "
":ref:`Compiler flags <ast-compiler-flags>` can be found in :mod:`ast` "
"module, with ``PyCF_`` prefix."
msgstr ""
"编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 "
":mod:`__future__` 模块的 :class:`~__future__._Feature` 实例的 "
":attr:`~__future__._Feature.compiler_flag` 属性中找到。 :ref:`编译器旗标 <ast-compiler-"
"flags>` 可以在 :mod:`ast` 模块中查找带有 ``PyCF_`` 前缀的名称。"

#: ../../library/functions.rst:333
msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no"
" optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"*optimize* 实参指定编译器的优化级别；默认值 ``-1``  选择与解释器的 :option:`-O` 选项相同的优化级别。显式级别为 "
"``0`` （没有优化；``__debug__``  为真）、``1`` （断言被删除， ``__debug__`` 为假）或 ``2`` "
"（文档字符串也被删除）。"

#: ../../library/functions.rst:339
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"如果编译的源码不合法，此函数会触发 :exc:`SyntaxError` 异常；如果源码包含 null 字节，则会触发 "
":exc:`ValueError` 异常。"

#: ../../library/functions.rst:342
msgid ""
"If you want to parse Python code into its AST representation, see "
":func:`ast.parse`."
msgstr "如果您想分析 Python 代码的 AST 表示，请参阅 :func:`ast.parse`。"

#: ../../library/functions.rst:345 ../../library/functions.rst:347
msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source`` and ``filename``. This event may also be raised by implicit "
"compilation."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``compile`` 附带参数 ``source`` 和 ``filename``。 "
"此事件也可通过隐式编译来引发。"

#: ../../library/functions.rst:353
msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the "
":mod:`code` module."
msgstr ""
"在 ``'single'``  或 ``'eval'`` 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 :mod:`code` "
"模块更容易检测语句的完整性。"

#: ../../library/functions.rst:360
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr "在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。"

#: ../../library/functions.rst:364
msgid ""
"Allowed use of Windows and Mac newlines.  Also, input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr ""
"Windows 和 Mac 的换行符均可使用。而且在 ``'exec'`` 模式下的输入不必再以换行符结尾了。另增加了 *optimize* 参数。"

#: ../../library/functions.rst:368
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr "之前 *source* 中包含 null 字节的话会触发 :exc:`TypeError` 异常。"

#: ../../library/functions.rst:372
msgid ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` can now be passed in flags to enable "
"support for top-level ``await``, ``async for``, and ``async with``."
msgstr ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` 现在可在旗标中传入以启用对最高层级 ``await``, ``async "
"for`` 和 ``async with`` 的支持。"

#: ../../library/functions.rst:381
msgid ""
"Convert a single string or number to a complex number, or create a complex "
"number from real and imaginary parts."
msgstr "将特定的字符串或数字转换为一个复数，或基于特定的实部和虚部创建一个复数。"

#: ../../library/functions.rst:384 ../../library/functions.rst:731
#: ../../library/functions.rst:977
msgid "Examples:"
msgstr "示例："

#: ../../library/functions.rst:386
msgid ""
">>> complex('+1.23')\n"
"(1.23+0j)\n"
">>> complex('-4.5j')\n"
"-4.5j\n"
">>> complex('-1.23+4.5j')\n"
"(-1.23+4.5j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-1.23+4.5j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(1.23)\n"
"(1.23+0j)\n"
">>> complex(imag=-4.5)\n"
"-4.5j\n"
">>> complex(-1.23, 4.5)\n"
"(-1.23+4.5j)"
msgstr ""
">>> complex('+1.23')\n"
"(1.23+0j)\n"
">>> complex('-4.5j')\n"
"-4.5j\n"
">>> complex('-1.23+4.5j')\n"
"(-1.23+4.5j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-1.23+4.5j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(1.23)\n"
"(1.23+0j)\n"
">>> complex(imag=-4.5)\n"
"-4.5j\n"
">>> complex(-1.23, 4.5)\n"
"(-1.23+4.5j)"

#: ../../library/functions.rst:405
msgid ""
"If the argument is a string, it must contain either a real part (in the same"
" format as for :func:`float`) or an imaginary part (in the same format but "
"with a ``'j'`` or ``'J'`` suffix), or both real and imaginary parts (the "
"sign of the imaginary part is mandatory in this case). The string can "
"optionally be surrounded by whitespaces and the round parentheses ``'('`` "
"and ``')'``, which are ignored. The string must not contain whitespace "
"between ``'+'``, ``'-'``, the ``'j'`` or ``'J'`` suffix, and the decimal "
"number. For example, ``complex('1+2j')`` is fine, but ``complex('1 + 2j')`` "
"raises :exc:`ValueError`. More precisely, the input must conform to the "
":token:`~float:complexvalue` production rule in the following grammar, after"
" parentheses and leading and trailing whitespace characters are removed:"
msgstr ""
"如果该参数为字符串，则它必须包含一个实部（格式与 :func:`float` 接受格式相同）或一个虚部（与实部格式相同但带有 ``'j'`` 或 "
"``'J'`` 后缀），或者同时包含实部和虚部（在此情况下虚部必须加上正负号）。 该字符串首尾可以被空白字符和圆括号 ``'('`` and "
"``')'`` 包裹，但它们会被忽略。 该字符串中的 ``'+'``, ``'-'``, ``'j'`` 或 ``'J'`` "
"后缀以及十进制数字之间不可存在空格。 例如，``complex('1+2j')`` 是可以的，但 ``complex('1 + 2j')`` 则会引发 "
":exc:`ValueError`。 更准确地说，输入在移除圆括号以及开头和末尾的空白字符之后，必须符合以下 "
":token:`~float:complexvalue` 产生式规则："

#: ../../library/functions.rst:424
msgid ""
"If the argument is a number, the constructor serves as a numeric conversion "
"like :class:`int` and :class:`float`. For a general Python object ``x``, "
"``complex(x)`` delegates to ``x.__complex__()``. If "
":meth:`~object.__complex__` is not defined then it falls back to "
":meth:`~object.__float__`. If :meth:`!__float__` is not defined then it "
"falls back to :meth:`~object.__index__`."
msgstr ""
"如果该参数为数字，则此构造器将进行与 :class:`int` 和 :class:`float` 类似的数值转换。 对于一个普通的 Python 对象 "
"``x``，``complex(x)`` 会委托给 ``x.__complex__()``。 如果未定义 "
":meth:`~object.__complex__` 则它将回退至 :meth:`~object.__float__`。 如果未定义 "
":meth:`!__float__` 则它将回退至 :meth:`~object.__index__`。"

#: ../../library/functions.rst:433
msgid ""
"If two arguments are provided or keyword arguments are used, each argument "
"may be any numeric type (including complex). If both arguments are real "
"numbers, return a complex number with the real component *real* and the "
"imaginary component *imag*. If both arguments are complex numbers, return a "
"complex number with the real component ``real.real-imag.imag`` and the "
"imaginary component ``real.imag+imag.real``. If one of arguments is a real "
"number, only its real component is used in the above expressions."
msgstr ""
"如果提供了两个参数或是使用了关键字参数，则每个参数可以为任意数字类型（包括复数）。 如果两个参数均为实数值，则会返回一个实部为 *real* 而虚部为 "
"*imag* 的复数。 如果两个参数均为复数值，则会返回一个实部为 ``real.real-imag.imag`` 而虚部为 "
"``real.imag+imag.real`` 的复数。 如果有一个参数为实数值，则上面的表达式中将只用到实部。"

#: ../../library/functions.rst:443
msgid "If all arguments are omitted, returns ``0j``."
msgstr "如果省略所有参数，则返回 ``0j``。"

#: ../../library/functions.rst:445
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr ":ref:`typesnumeric` 描述了复数类型。"

#: ../../library/functions.rst:447 ../../library/functions.rst:783
#: ../../library/functions.rst:1026
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "您可以使用下划线将代码文字中的数字进行分组。"

#: ../../library/functions.rst:450
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__complex__` and "
":meth:`~object.__float__` are not defined."
msgstr ""
"如果 :meth:`~object.__complex__` 和 :meth:`~object.__float__` 均未定义则回退至 "
":meth:`~object.__index__`。"

#: ../../library/functions.rst:457
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The"
" function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``. *name* "
"need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"这是 :func:`setattr` 的相关函数。 其参数是一个对象和一个字符串。 其中字符串必须是对象的某个属性的名称。 "
"该函数会删除指定的属性，如果对象允许这样做的话。 例如，``delattr(x, 'foobar')`` 等价于 ``del x.foobar``。 "
"*name* 不要求必须是 Python 标识符 (参见 :func:`setattr`)。"

#: ../../library/functions.rst:470
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this "
"class."
msgstr ""
"创建一个新的字典。:class:`dict` 对象是一个字典类。参见 :class:`dict` 和 :ref:`typesmapping` "
"了解这个类。"

#: ../../library/functions.rst:473
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and "
":class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"其他容器类型，请参见内置的 :class:`list`、:class:`set` 和 :class:`tuple` 类，以及 "
":mod:`collections` 模块。"

#: ../../library/functions.rst:480
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr "如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。"

#: ../../library/functions.rst:483
msgid ""
"If the object has a method named :meth:`~object.__dir__`, this method will "
"be called and must return the list of attributes. This allows objects that "
"implement a custom :func:`~object.__getattr__` or "
":func:`~object.__getattribute__` function to customize the way :func:`dir` "
"reports their attributes."
msgstr ""
"如果对象有一个名为 :meth:`~object.__dir__` 的方法，则该方法将被调用并且必须返回由属列组成的列表。 这允许实现自定义This "
"allows objects that implement a custom :func:`~object.__getattr__` 或 "
":func:`~object.__getattribute__` 函数的对象能够定制 :func:`dir` 报告其属性的方式。"

#: ../../library/functions.rst:490
msgid ""
"If the object does not provide :meth:`~object.__dir__`, the function tries "
"its best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is not "
"necessarily complete and may be inaccurate when the object has a custom "
":func:`~object.__getattr__`."
msgstr ""
"如果对象未提供 :meth:`~object.__dir__`，该函数会尽量从对象所定义的 :attr:`~object.__dict__` "
"属性和其类型对象中收集信息。 结果列表不一定是完整的，并且当对象具有自定义的 :func:`~object.__getattr__` "
"时还可能是不准确的。"

#: ../../library/functions.rst:496
msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr "默认的 :func:`dir` 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息："

#: ../../library/functions.rst:500
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "如果对象是模块对象，则列表包含模块的属性名称。"

#: ../../library/functions.rst:503
msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr "如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。"

#: ../../library/functions.rst:506
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr "否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。"

#: ../../library/functions.rst:510
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "返回的列表按字母表排序。例如："

#: ../../library/functions.rst:530
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than"
" it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"因为 :func:`dir` "
"主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass"
" 的属性不包含在结果列表中。"

#: ../../library/functions.rst:540
msgid ""
"Take two (non-complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating-"
"point numbers the result is ``(q, a % b)``, where *q* is usually "
"``math.floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a "
"% b`` is very close to *a*, if ``a % b`` is non-zero it has the same sign as"
" *b*, and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"接受两个（非复数）数字作为参数并返回由当对其使用整数除法时的商和余数组成的数字对。 在混用不同的操作数类型时，则会应用二元算术运算符的规则。 "
"对于整数来说，结果与 ``(a // b, a % b)`` 相同。 对于浮点数来说则结果为 ``(q, a % b)``，其中 *q* 通常为 "
"``math.floor(a / b)`` 但可能会比它小 1。 在任何情况下 ``q * b + a % b`` 都非常接近 *a*，如果 ``a %"
" b`` 为非零值则它将具有与 *b* 相同的正负号，并且 ``0 <= abs(a % b) < abs(b)``。"

#: ../../library/functions.rst:552
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an "
":term:`iterator`, or some other object which supports iteration. The "
":meth:`~iterator.__next__` method of the iterator returned by "
":func:`enumerate` returns a tuple containing a count (from *start* which "
"defaults to 0) and the values obtained from iterating over *iterable*."
msgstr ""
"返回一个枚举对象。*iterable* 必须是一个序列，或 :term:`iterator`，或其他支持迭代的对象。 :func:`enumerate`"
" 返回的迭代器的 :meth:`~iterator.__next__` 方法返回一个元组，里面包含一个计数值（从 *start* 开始，默认为 "
"0）和通过迭代 *iterable* 获得的值。"

#: ../../library/functions.rst:564
msgid "Equivalent to::"
msgstr "等价于::"

#: ../../library/functions.rst:566
msgid ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"
msgstr ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"

#: ../../library/functions.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../library/functions.rst:576
msgid "A Python expression."
msgstr "一个 Python 表达式。"

#: ../../library/functions.rst:580
msgid "The global namespace (default: ``None``)."
msgstr "全局命名空间 (默认值: ``None``)。"

#: ../../library/functions.rst:584
msgid "The local namespace (default: ``None``)."
msgstr "局部命名空间 (默认值: ``None``)。"

#: ../../library/functions.rst:0
msgid "Returns"
msgstr "返回"

#: ../../library/functions.rst:588
msgid "The result of the evaluated expression."
msgstr "被求值表达式的求值结果。"

#: ../../library/functions.rst:0
msgid "raises"
msgstr "引发"

#: ../../library/functions.rst:589
msgid "Syntax errors are reported as exceptions."
msgstr "语法错误将作为异常被报告。"

#: ../../library/functions.rst:593 ../../library/functions.rst:644
msgid ""
"This function executes arbitrary code. Calling it with user-supplied input "
"may lead to security vulnerabilities."
msgstr "此函数可执行任意代码。 调用它时附带用户提供的输入可能导致安全弱点。"

#: ../../library/functions.rst:596
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"dictionaries as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed.  That way you can "
"control what builtins are available to the executed code by inserting your "
"own ``__builtins__`` dictionary into *globals* before passing it to "
":func:`eval`.  If the *locals* dictionary is omitted it defaults to the "
"*globals* dictionary.  If both dictionaries are omitted, the expression is "
"executed with the *globals* and *locals* in the environment where "
":func:`eval` is called.  Note, *eval()* does not have access to the "
":term:`nested scopes <nested scope>` (non-locals) in the enclosing "
"environment."
msgstr ""
"表达式解析参数 *expression* 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 *globals* 和 "
"*locals* 字典作为全局和局部命名空间。 如果存在 *globals* 字典，并且不包含 ``__builtins__`` 键的值，则在解析 "
"*expression* 之前会插入以该字符串为键以对内置模块 :mod:`builtins` 的字典的引用为值的项。 这样就可以在将 "
"*globals* 传给 :func:`eval` 之前通过向其传入你自己的 ``__builtins__`` "
"字典来控制可供被执行代码可以使用哪些内置模块。 如果 *locals* 字典被省略则它默认为 *globals* 字典。 "
"如果两个字典都被省略，则将使用调用 :func:`eval` 的环境中的 *globals* 和 *locals* 来执行该表达式。 "
"注意，*eval()* 无法访问闭包环境中的 :term:`嵌套作用域 <nested scope>` (非局部变量)。"

#: ../../library/functions.rst:611
msgid "Example:"
msgstr "示例:"

#: ../../library/functions.rst:617
msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case, pass a code object instead"
" of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"该函数还可用于执行任意代码对象（比如由 :func:`compile` 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为"
"  *mode* 的 ``'exec'`` 进行了编译，那么 :func:`eval` 的返回值将为 ``None``。"

#: ../../library/functions.rst:622
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions return the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"提示： :func:`exec` 函数支持语句的动态执行。 :func:`globals` 和 :func:`locals` "
"函数分别返回当前的全局和本地字典，可供传给 :func:`eval` 或 :func:`exec` 使用。"

#: ../../library/functions.rst:627
msgid ""
"If the given source is a string, then leading and trailing spaces and tabs "
"are stripped."
msgstr "如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。"

#: ../../library/functions.rst:630
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings"
" with expressions containing only literals."
msgstr "另外可以参阅 :func:`ast.literal_eval`，该函数可以安全执行仅包含文字的表达式字符串。"

#: ../../library/functions.rst:633 ../../library/functions.rst:635
#: ../../library/functions.rst:683 ../../library/functions.rst:685
msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with the code object as "
"the argument. Code compilation events may also be raised."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``exec`` 附带代码对象作为参数。 代码编译事件也可能被引发。"

#: ../../library/functions.rst:647
msgid ""
"This function supports dynamic execution of Python code. *object* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section :ref:`file-input` in the Reference Manual). Be aware that the "
":keyword:`nonlocal`, :keyword:`yield`,  and :keyword:`return` statements may"
" not be used outside of function definitions even within the context of code"
" passed to the :func:`exec` function. The return value is ``None``."
msgstr ""

#: ../../library/functions.rst:658
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the"
" current scope.  If only *globals* is provided, it must be a dictionary (and"
" not a subclass of dictionary), which will be used for both the global and "
"the local variables.  If *globals* and *locals* are given, they are used for"
" the global and local variables, respectively.  If provided, *locals* can be"
" any mapping object.  Remember that at the module level, globals and locals "
"are the same dictionary."
msgstr ""
"在所有情况下，如果省略了可选部分，代码将在当前作用域中执行。 如果只提供了 "
"*globals*，则它必须是一个字典（并且不能是字典的子类），它将被同时用于全局和局部变量。 如果给出了 *globals* 和 "
"*locals*，它们将被分别用于全局和局部变量。 如果提供了 *locals*，它可以是任何映射对象。 请记住在模块层级上，globals 和 "
"locals 是同一个字典。"

#: ../../library/functions.rst:668
msgid ""
"Most users should just pass a *globals* argument and never *locals*. If exec"
" gets two separate objects as *globals* and *locals*, the code will be "
"executed as if it were embedded in a class definition."
msgstr ""

#: ../../library/functions.rst:672
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module "
":mod:`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to "
":func:`exec`."
msgstr ""
"如果 *globals* 字典不包含 ``__builtins__`` 键值，则将为该键插入对内建 :mod:`builtins` "
"模块字典的引用。因此，在将执行的代码传递给 :func:`exec` 之前，可以通过将自己的 ``__builtins__`` 字典插入到 "
"*globals* 中来控制可以使用哪些内置代码。"

#: ../../library/functions.rst:678
msgid ""
"The *closure* argument specifies a closure--a tuple of cellvars. It's only "
"valid when the *object* is a code object containing free variables. The "
"length of the tuple must exactly match the number of free variables "
"referenced by the code object."
msgstr ""
"*closure* 参数指定一个闭包  -- 即由 cellvar 组成的元组。 它仅在 *object* 是一个包含自由变量的代码对象时才可用。 "
"该元组的长度必须与代码对象所引用的自由变量的数量完全一致。"

#: ../../library/functions.rst:690
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current"
" global and local dictionary, respectively, which may be useful to pass "
"around for use as the second and third argument to :func:`exec`."
msgstr ""
"内置 :func:`globals` 和 :func:`locals` 函数各自返回当前的全局和本地字典，因此可以将它们传递给 :func:`exec`"
" 的第二个和第三个实参。"

#: ../../library/functions.rst:696
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""

#: ../../library/functions.rst:701
msgid "Added the *closure* parameter."
msgstr "添加了 *closure* 参数。"

#: ../../library/functions.rst:707
msgid ""
"Construct an iterator from those elements of *iterable* for which *function*"
" is true.  *iterable* may be either a sequence, a container which supports "
"iteration, or an iterator.  If *function* is ``None``, the identity function"
" is assumed, that is, all elements of *iterable* that are false are removed."
msgstr ""
"使用 *iterable* 中 *function* 返回真值的元素构造一个迭代器。 *iterable* "
"可以是一个序列，一个支持迭代的容器或者一个迭代器。 如果 *function* 为 ``None``，则会使用标识号函数，也就是说，*iterable*"
" 中所有具有假值的元素都将被移除。"

#: ../../library/functions.rst:713
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"请注意， ``filter(function, iterable)`` 相当于一个生成器表达式，当 function 不是 ``None`` 的时候为 "
"``(item for item in iterable if function(item))``；function 是 ``None`` 的时候为 "
"``(item for item in iterable if item)`` 。"

#: ../../library/functions.rst:718
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* is false."
msgstr ""
"请参阅 :func:`itertools.filterfalse` 来了解返回 *iterable* 中 *function* "
"返回假值的元素的补充函数。"

#: ../../library/functions.rst:729
msgid "Return a floating-point number constructed from a number or a string."
msgstr "返回基于一个数字或字符串构建的浮点数。"

#: ../../library/functions.rst:733
msgid ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"
msgstr ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"

#: ../../library/functions.rst:746
msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN (not-a-"
"number), or positive or negative infinity. More precisely, the input must "
"conform to the :token:`~float:floatvalue` production rule in the following "
"grammar, after leading and trailing whitespace characters are removed:"
msgstr ""
"如果该参数是一个字符串，则它应当包含一个十进制数字，前面可以选择带一个符号，也可以选择嵌入空格。 可选的符号有 ``'+'`` 或 "
"``'-'``；``'+'`` 符号对所产生的值没有影响。 该参数还可以是一个代表 NaN (not-a-number) 或者正负无穷大的字符串。 "
"更确切地说，在移除前导和尾随的空格之后，输入必须为符合以下语法的 :token:`~float:floatvalue` 产生规则："

#: ../../library/functions.rst:767
msgid ""
"Case is not significant, so, for example, \"inf\", \"Inf\", \"INFINITY\", "
"and \"iNfINity\" are all acceptable spellings for positive infinity."
msgstr "大小写是无影响的，因此举例来说，\"inf\", \"Inf\", \"INFINITY\" 和 \"iNfINity\" 都是正无穷可接受的拼写形式。"

#: ../../library/functions.rst:770
msgid ""
"Otherwise, if the argument is an integer or a floating-point number, a "
"floating-point number with the same value (within Python's floating-point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""
"另一方面，如果参数是整数或浮点数，则返回一个具有相同值（在 Python 浮点精度范围内）的浮点数。 如果参数超出了 Python "
"浮点数的取值范围，则会引发 :exc:`OverflowError`。"

#: ../../library/functions.rst:775
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to "
"``x.__float__()``.  If :meth:`~object.__float__` is not defined then it "
"falls back to :meth:`~object.__index__`."
msgstr ""
"对于一个普通 Python 对象 ``x``，``float(x)`` 会委托给 ``x.__float__()``。 如果 "
":meth:`~object.__float__` 未定义则将回退至 :meth:`~object.__index__`。"

#: ../../library/functions.rst:779
msgid "If no argument is given, ``0.0`` is returned."
msgstr "如果没有实参，则返回 ``0.0`` 。"

#: ../../library/functions.rst:781
msgid "The float type is described in :ref:`typesnumeric`."
msgstr ":ref:`typesnumeric` 描述了浮点类型。"

#: ../../library/functions.rst:789
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__float__` is not "
"defined."
msgstr "如果 :meth:`~object.__float__` 未定义则回退至 :meth:`~object.__index__`。"

#: ../../library/functions.rst:799
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument; however, there is a standard formatting syntax that"
" is used by most built-in types: :ref:`formatspec`."
msgstr ""
"将 *value* 转换为“格式化后”的形式，格式由 *format_spec* 进行控制。*format_spec* 的解释方式取决于 *value*"
" 参数的类型；但大多数内置类型使用一种标准的格式化语法： :ref:`formatspec`。"

#: ../../library/functions.rst:804
msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr "默认的 *format_spec* 是一个空字符串，它通常给出与调用 :func:`str(value)<str>` 相同的结果。"

#: ../../library/functions.rst:807
msgid ""
"A call to ``format(value, format_spec)`` is translated to "
"``type(value).__format__(value, format_spec)`` which bypasses the instance "
"dictionary when searching for the value's :meth:`~object.__format__` method."
" A :exc:`TypeError` exception is raised if the method search reaches "
":mod:`object` and the *format_spec* is non-empty, or if either the "
"*format_spec* or the return value are not strings."
msgstr ""
"对 ``format(value, format_spec)`` 的调用会转写为 ``type(value).__format__(value, "
"format_spec)``，这样在搜索值的 :meth:`~object.__format__` 方法时将绕过实例字典。 如果方法搜索到达 "
":mod:`object` 并且 *format_spec* 不为空，或者如果 *format_spec* 或返回值不为字符串则会引发 "
":exc:`TypeError` 异常。"

#: ../../library/functions.rst:814
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"当 *format_spec* 不是空字符串时， ``object().__format__(format_spec)`` 会触发  "
":exc:`TypeError`。"

#: ../../library/functions.rst:823
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and "
":ref:`types-set` for documentation about this class."
msgstr ""
"返回一个新的 :class:`frozenset` 对象，它包含可选参数 *iterable* 中的元素。 ``frozenset`` "
"是一个内置的类。有关此类的文档，请参阅 :class:`frozenset` 和 :ref:`types-set`。"

#: ../../library/functions.rst:827
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections`"
" module."
msgstr ""
"请参阅内建的 :class:`set`、:class:`list`、:class:`tuple` 和 :class:`dict` 类，以及 "
":mod:`collections` 模块来了解其它的容器。"

#: ../../library/functions.rst:835
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is"
" raised. *name* need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"*object* 中指定名称的属性的值。  *name* 必须是字符串。 如果该字符串是对象的某一属性的名称，则结果将为该属性的值。 "
"例如，``getattr(x, 'foobar')`` 等同于 ``x.foobar``。 如果指定名称的属性不存在，则如果提供了 *default* "
"则返回该值，否则将引发 :exc:`AttributeError`。 *name* 不必是一个 Python 标识符 (参见 "
":func:`setattr`)。"

#: ../../library/functions.rst:844
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes"
" with two leading underscores) name in order to retrieve it with "
":func:`getattr`."
msgstr ""
"由于 :ref:`私有名称混合 <private-name-mangling>` "
"发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以使用 :func:`getattr` 来提取它。"

#: ../../library/functions.rst:852
msgid ""
"Return the dictionary implementing the current module namespace. For code "
"within functions, this is set when the function is defined and remains the "
"same regardless of where the function is called."
msgstr "返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数在哪里被调用都保持不变。"

#: ../../library/functions.rst:859
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether"
" it raises an :exc:`AttributeError` or not.)"
msgstr ""
"该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 ``True``，否则返回 ``False``。（此功能是通过调用 "
"``getattr(object, name)`` 看是否有 :exc:`AttributeError` 异常来实现的。）"

#: ../../library/functions.rst:867
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 "
"和 1.0）。"

#: ../../library/functions.rst:874
msgid ""
"For objects with custom :meth:`~object.__hash__` methods, note that "
":func:`hash` truncates the return value based on the bit width of the host "
"machine."
msgstr ""
"对于具有自定义 :meth:`~object.__hash__` 方法的对象，请注意 :func:`hash` 会根据宿主机的字长来截断返回值。"

#: ../../library/functions.rst:881
msgid ""
"Invoke the built-in help system.  (This function is intended for interactive"
" use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked"
" up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is "
"generated."
msgstr ""
"启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。"

#: ../../library/functions.rst:888
msgid ""
"Note that if a slash(/) appears in the parameter list of a function when "
"invoking :func:`help`, it means that the parameters prior to the slash are "
"positional-only. For more info, see :ref:`the FAQ entry on positional-only "
"parameters <faq-positional-only-arguments>`."
msgstr ""
"请注意，如果在调用 :func:`help` 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。详情请参阅 "
":ref:`有关仅限位置形参的 FAQ 条目 <faq-positional-only-arguments>`。"

#: ../../library/functions.rst:893
msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "该函数通过 :mod:`site` 模块加入到内置命名空间。"

#: ../../library/functions.rst:895
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures"
" for callables are now more comprehensive and consistent."
msgstr ":mod:`pydoc` 和 :mod:`inspect` 的变更使得可调用对象的签名信息更加全面和一致。"

#: ../../library/functions.rst:902
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an "
":meth:`~object.__index__` method that returns an integer. Some examples:"
msgstr ""
"将整数转换为带前缀 \"0x\" 前缀的小写十六进制数字符串。 如果 *x* 不是一个 Python :class:`int` "
"对象，则它必须定义返回一个整数的 :meth:`~object.__index__` 方法。 下面是一些例子:"

#: ../../library/functions.rst:911
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr "如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法："

#: ../../library/functions.rst:923
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using"
" a base of 16."
msgstr "另请参阅 :func:`int` 将十六进制字符串转换为以 16 为基数的整数。"

#: ../../library/functions.rst:928
msgid ""
"To obtain a hexadecimal string representation for a float, use the "
":meth:`float.hex` method."
msgstr "如果要获取浮点数的十六进制字符串形式，请使用 :meth:`float.hex` 方法。"

#: ../../library/functions.rst:934
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 :func:`id` 值。"

#: ../../library/functions.rst:939
msgid "This is the address of the object in memory."
msgstr "这是对象在内存中的地址。"

#: ../../library/functions.rst:941
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.id`` with argument "
"``id``."
msgstr "引发一个 :ref:`审计事件 <auditing>` ``builtins.id`` 并附带参数 ``id``。"

#: ../../library/functions.rst:947
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"如果存在 *prompt* "
"实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 "
":exc:`EOFError`。例如::"

#: ../../library/functions.rst:952
msgid ""
">>> s = input('--> ')\n"
"--> Monty Python's Flying Circus\n"
">>> s\n"
"\"Monty Python's Flying Circus\""
msgstr ""
">>> s = input('--> ')\n"
"--> Monty Python's Flying Circus\n"
">>> s\n"
"\"Monty Python's Flying Circus\""

#: ../../library/functions.rst:957
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr "如果加载了 :mod:`readline` 模块，:func:`input` 将使用它来提供复杂的行编辑和历史记录功能。"

#: ../../library/functions.rst:960 ../../library/functions.rst:962
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt`` before reading input"
msgstr "在读取输入前引发一个 :ref:`审计事件 <auditing>` ``builtins.input`` 附带参数 ``prompt``"

#: ../../library/functions.rst:965 ../../library/functions.rst:967
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"the result after successfully reading input."
msgstr "在成功读取输入之后引发一个 :ref:`审计事件 <auditing>` ``builtins.input/result`` 附带结果。"

#: ../../library/functions.rst:974
msgid ""
"Return an integer object constructed from a number or a string, or return "
"``0`` if no arguments are given."
msgstr "返回从一个数字或字符串构建的整数对象，或者如果未给出参数则返回 ``0``。"

#: ../../library/functions.rst:979
msgid ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"
msgstr ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"

#: ../../library/functions.rst:994
msgid ""
"If the argument defines :meth:`~object.__int__`, ``int(x)`` returns "
"``x.__int__()``.  If the argument defines :meth:`~object.__index__`, it "
"returns ``x.__index__()``.  If the argument defines "
":meth:`~object.__trunc__`, it returns ``x.__trunc__()``. For floating-point "
"numbers, this truncates towards zero."
msgstr ""
"如果参数定义了 :meth:`~object.__int__`，``int(x)`` 将返回 ``x.__int__()``。 如果参数定义了 "
":meth:`~object.__index__`，它将返回 ``x.__index__()``。 如果参数定义了 "
":meth:`~object.__trunc__`，它将返回 ``x.__trunc__()``。 对于浮点数，这将向零方向截断。"

#: ../../library/functions.rst:1000
msgid ""
"If the argument is not a number or if *base* is given, then it must be a "
"string, :class:`bytes`, or :class:`bytearray` instance representing an "
"integer in radix *base*.  Optionally, the string can be preceded by ``+`` or"
" ``-`` (with no space in between), have leading zeros, be surrounded by "
"whitespace, and have single underscores interspersed between digits."
msgstr ""
"如果参数不是数字或者如果给定了 *base*，则它必须是表示一个以 *base* 为基数的整数的字符串、:class:`bytes` 或 "
":class:`bytearray` 实例。 字符串前面还可选择加上 ``+`` 或 ``-`` "
"(中间没有空格)，带有前导的零，带有两侧的空格，以及带有数位之间的单个下划线。"

#: ../../library/functions.rst:1006
msgid ""
"A base-n integer string contains digits, each representing a value from 0 to"
" n-1. The values 0--9 can be represented by any Unicode decimal digit. The "
"values 10--35 can be represented by ``a`` to ``z`` (or ``A`` to ``Z``). The "
"default *base* is 10. The allowed bases are 0 and 2--36. Base-2, -8, and -16"
" strings can be optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or "
"``0x``/``0X``, as with integer literals in code.  For base 0, the string is "
"interpreted in a similar way to an :ref:`integer literal in code "
"<integers>`, in that the actual base is 2, 8, 10, or 16 as determined by the"
" prefix. Base 0 also disallows leading zeros: ``int('010', 0)`` is not "
"legal, while ``int('010')`` and ``int('010', 8)`` are."
msgstr ""
"一个以 n 为基数的整数字符串包含多个数位，每个数位代表从 0 到 n-1 范围内的值。 0--9 的值可以用任何 Unicode 十进制数码来表示。 "
"10--35 的值可以用 ``a`` 到 ``z`` (或 ``A`` 到 ``Z``) 来表示。 默认的 *base* 为 10。 允许的基数为 0 "
"和 2--36。 对于基数 2, -8 和 -16 来说字符串前面还能加上可选的 ``0b``/``0B``, ``0o``/``0O`` 或 "
"``0x``/``0X`` 前缀，就像代码中的整数字面值那样。 对于基数 0 来说，字符串会以与 :ref:`代码中的整数字面值 <integers>`"
" 类似的方式来解读，即实际的基数将由前缀确定为 2, 8, 10 或 16。 基数为 0 还会禁用前导的零: ``int('010', 0)`` "
"将是无效的，而 ``int('010')`` 和 ``int('010', 8)`` 则是有效的。"

#: ../../library/functions.rst:1017
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "整数类型定义请参阅 :ref:`typesnumeric` 。"

#: ../../library/functions.rst:1019
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a "
":meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"如果 *base* 不是 :class:`int` 的实例，但 *base* 对象有 :meth:`base.__index__ "
"<object.__index__>` 方法，则会调用该方法来获取进制数。以前的版本使用 :meth:`base.__int__ "
"<object.__int__>` 而不是 :meth:`base.__index__ <object.__index__>`。"

#: ../../library/functions.rst:1029
msgid "The first parameter is now positional-only."
msgstr "第一个形参现在是仅限位置形参。"

#: ../../library/functions.rst:1032
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__int__` is not "
"defined."
msgstr "如果 :meth:`~object.__int__` 未定义则回退至 :meth:`~object.__index__`。"

#: ../../library/functions.rst:1035
msgid "The delegation to :meth:`~object.__trunc__` is deprecated."
msgstr "委托给 :meth:`~object.__trunc__` 的做法已被弃用。"

#: ../../library/functions.rst:1038
msgid ""
":class:`int` string inputs and string representations can be limited to help"
" avoid denial of service attacks. A :exc:`ValueError` is raised when the "
"limit is exceeded while converting a string to an :class:`int` or when "
"converting an :class:`int` into a string would exceed the limit. See the "
":ref:`integer string conversion length limitation <int_max_str_digits>` "
"documentation."
msgstr ""
":class:`int` 字符串输入和字符串表示形式可受到限制以帮助避免拒绝服务攻击。当将一个字符串转换为 :class:`int` 或者将一个 "
":class:`int` 转换为字符串的操作走出限制时会引发 :exc:`ValueError`。 请参阅 :ref:`整数字符串转换长度限制 "
"<int_max_str_digits>` 文档。"

#: ../../library/functions.rst:1048
msgid ""
"Return ``True`` if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect, or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns ``False``. If *classinfo* is a tuple of type "
"objects (or recursively, other such tuples) or a :ref:`types-union` of "
"multiple types, return ``True`` if *object* is an instance of any of the "
"types. If *classinfo* is not a type or tuple of types and such tuples, a "
":exc:`TypeError` exception is raised. :exc:`TypeError` may not be raised for"
" an invalid type if an earlier check succeeds."
msgstr ""
"如果 *object* 参数是 *classinfo* 参数的实例，或者是其 (直接、间接或 :term:`虚拟 <abstract base "
"class>`) 子类的实例则返回 ``True``。 如果 *object* 不是给定类型的对象，则该函数总是返回 ``False``。 如果 "
"*classinfo* 是由类型对象结成的元组 (或是由其他此类元组递归生成) 或者是多个类型的 :ref:`types-union`，则如果 "
"*object* 是其中任一类型的实例时将会返回 ``True``。 如果 *classinfo* 不是一个类型或类型元组及此类元组，则会引发 "
":exc:`TypeError` 异常。 如果之前的检查成功执行则可以不会为无效的类型引发 :exc:`TypeError`。"

#: ../../library/functions.rst:1059 ../../library/functions.rst:1073
msgid "*classinfo* can be a :ref:`types-union`."
msgstr "*classinfo* 可以是一个 :ref:`types-union`。"

#: ../../library/functions.rst:1065
msgid ""
"Return ``True`` if *class* is a subclass (direct, indirect, or "
":term:`virtual <abstract base class>`) of *classinfo*.  A class is "
"considered a subclass of itself. *classinfo* may be a tuple of class objects"
" (or recursively, other such tuples) or a :ref:`types-union`, in which case "
"return ``True`` if *class* is a subclass of any entry in *classinfo*.  In "
"any other case, a :exc:`TypeError` exception is raised."
msgstr ""
"如果 *class* 是 *classinfo* 的子类（直接、间接或 :term:`虚的 <abstract base class>` ），则返回 "
"``True``。类将视为自己的子类。*classinfo* 可为类对象的元组（或递归地，其他这样的元组）或 :ref:`types-"
"union`，这时如果 *class* 是 *classinfo* 中任何条目的子类，则返回 ``True`` 。任何其他情况都会触发 "
":exc:`TypeError` 异常。"

#: ../../library/functions.rst:1080
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the "
":term:`iterable` protocol (the :meth:`~object.__iter__` method), or it must "
"support the sequence protocol (the :meth:`~object.__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The iterator"
" created in this case will call *object* with no arguments for each call to "
"its :meth:`~iterator.__next__` method; if the value returned is equal to "
"*sentinel*, :exc:`StopIteration` will be raised, otherwise the value will be"
" returned."
msgstr ""
"返回一个 :term:`iterator` 对象。 根据是否存在第二个参数，对第一个参数的解读会有很大的不同。 如果没有第二个参数，*object* "
"必须是一个支持 :term:`iterable` 协议 (有 :meth:`~object.__iter__` 方法) "
"的多项集对象，或者必须支持序列协议 (有 :meth:`~object.__getitem__` 方法并使用从 ``0`` 开始的整数参数)。 "
"如果它不支持这些协议，则会引发 :exc:`TypeError`。 如果给出了第二个参数 *sentinel*，则 *object* "
"必须是一个可调用对象。 在这种情况下创建的迭代器将针对每次调用其 :meth:`~iterator.__next__` 方法不带参数地调用 "
"*object*；如果返回的值等于 *sentinel*，则会引发 :exc:`StopIteration`，否则将返回该值。"

#: ../../library/functions.rst:1094
msgid "See also :ref:`typeiter`."
msgstr "另请参阅 :ref:`typeiter`。"

#: ../../library/functions.rst:1096
msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database"
" file until the end of file is reached::"
msgstr "适合 :func:`iter` 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾::"

#: ../../library/functions.rst:1100
msgid ""
"from functools import partial\n"
"with open('mydata.db', 'rb') as f:\n"
"    for block in iter(partial(f.read, 64), b''):\n"
"        process_block(block)"
msgstr ""
"from functools import partial\n"
"with open('mydata.db', 'rb') as f:\n"
"    for block in iter(partial(f.read, 64), b''):\n"
"        process_block(block)"

#: ../../library/functions.rst:1108
msgid ""
"Return the length (the number of items) of an object.  The argument may be a"
" sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 "
"dictionary、set 或 frozen set 等）。"

#: ../../library/functions.rst:1114
msgid ""
"``len`` raises :exc:`OverflowError` on lengths larger than "
":data:`sys.maxsize`, such as :class:`range(2 ** 100) <range>`."
msgstr ""
"``len`` 对于大于 :data:`sys.maxsize` 的长度如 :class:`range(2 ** 100) <range>` 会引发 "
":exc:`OverflowError`。"

#: ../../library/functions.rst:1123
msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"虽然被称为函数，:class:`list` 实际上是一种可变序列类型，详情请参阅 :ref:`typesseq-list` 和 "
":ref:`typesseq`。"

#: ../../library/functions.rst:1129
msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by :func:`locals` when it is called in function "
"blocks, but not in class blocks. Note that at the module level, "
":func:`locals` and :func:`globals` are the same dictionary."
msgstr ""

#: ../../library/functions.rst:1135
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""

#: ../../library/functions.rst:1140
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterables* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when"
" the shortest iterable is exhausted.  For cases where the function inputs "
"are already arranged into argument tuples, see :func:`itertools.starmap`\\."
msgstr ""
"返回一个将 *function* 应用于 *iterable* 的每一项，并产生其结果的迭代器。 如果传入了额外的 *iterables* 参数，则 "
"*function* 必须接受相同个数的参数并被用于到从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，当最短的可迭代对象耗尽则整个迭代将会停止。"
"  对于函数的输入已经是参数元组的情况，请参阅 :func:`itertools.starmap`。"

#: ../../library/functions.rst:1152
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr "返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。"

#: ../../library/functions.rst:1155
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"如果只提供了一个位置参数，它必须是非空 "
":term:`iterable`，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。"

#: ../../library/functions.rst:1160 ../../library/functions.rst:1198
msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is"
" empty. If the iterable is empty and *default* is not provided, a "
":exc:`ValueError` is raised."
msgstr ""
"有两个可选只能用关键字的实参。*key* 实参指定排序函数用的参数，如传给 :meth:`list.sort` 的。*default* "
"实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 *default* ，则会触发 :exc:`ValueError`。"

#: ../../library/functions.rst:1166
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and "
"``heapq.nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 ``sorted(iterable, key=keyfunc, "
"reverse=True)[0]`` 和 ``heapq.nlargest(1, iterable, key=keyfunc)`` 保持一致。"

#: ../../library/functions.rst:1171 ../../library/functions.rst:1209
msgid "Added the *default* keyword-only parameter."
msgstr "增加了 *default* 仅限关键字形参。"

#: ../../library/functions.rst:1174 ../../library/functions.rst:1212
msgid "The *key* can be ``None``."
msgstr "*key* 可以为 ``None``。"

#: ../../library/functions.rst:1182
msgid ""
"Return a \"memory view\" object created from the given argument.  See "
":ref:`typememoryview` for more information."
msgstr "返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 :ref:`typememoryview`。"

#: ../../library/functions.rst:1190
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr "返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。"

#: ../../library/functions.rst:1193
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is "
"returned."
msgstr ""
"如果只提供了一个位置参数，它必须是 :term:`iterable`，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。"

#: ../../library/functions.rst:1204
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 ``sorted(iterable, key=keyfunc)[0]`` 和 "
"``heapq.nsmallest(1, iterable, key=keyfunc)`` 保持一致。"

#: ../../library/functions.rst:1219
msgid ""
"Retrieve the next item from the :term:`iterator` by calling its "
":meth:`~iterator.__next__` method.  If *default* is given, it is returned if"
" the iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"通过调用 :term:`iterator` 的 :meth:`~iterator.__next__` 方法获取下一个元素。如果迭代器耗尽，则返回给定的 "
"*default*，如果没有默认值则触发 :exc:`StopIteration`。"

#: ../../library/functions.rst:1226
msgid ""
"This is the ultimate base class of all other classes. It has methods that "
"are common to all instances of Python classes. When the constructor is "
"called, it returns a new featureless object. The constructor does not accept"
" any arguments."
msgstr ""
"这是所有其他类的终极基类。 它提供了所有 Python 类实例均具有的方法。 当其构造器被调用时，它将返回一个新的基本对象。 该构造器不接受任何参数。"

#: ../../library/functions.rst:1233
msgid ""
":class:`object` instances do *not* have :attr:`~object.__dict__` attributes,"
" so you can't assign arbitrary attributes to an instance of :class:`object`."
msgstr ""
":class:`object` 实例 *没有* :attr:`~object.__dict__` 属性，因此你无法将任意属性赋给 "
":class:`object` 的实例。"

#: ../../library/functions.rst:1240
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an"
" integer. For example:"
msgstr ""
"将整数转换为带前缀 \"0o\" 的八进制数字符串。 结果是一个合法的 Python 表达式。 如果 *x* 不是一个 Python "
":class:`int` 对象，则它必须定义返回一个整数的 :meth:`~object.__index__` 方法。 例如:"

#: ../../library/functions.rst:1250
msgid ""
"If you want to convert an integer number to an octal string either with the "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr "若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法："

#: ../../library/functions.rst:1267
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised. See :ref:`tut-files` for more"
" examples of how to use this function."
msgstr ""
"打开 *file* 并返回对应的 :term:`file object`。 如果该文件不能被打开，则引发 :exc:`OSError`。 请参阅 "
":ref:`tut-files` 获取此函数的更多用法示例。"

#: ../../library/functions.rst:1271
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is"
" given, it is closed when the returned I/O object is closed unless *closefd*"
" is set to ``False``.)"
msgstr ""
"*file* 是一个 :term:`path-like "
"object`，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的"
" I/O 对象关闭时它也会关闭，除非将 *closefd* 设为 ``False`` 。）"

#: ../../library/functions.rst:1277
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation, and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform-dependent: "
":func:`locale.getencoding` is called to get the current locale encoding. "
"(For reading and writing raw bytes use binary mode and leave *encoding* "
"unspecified.)  The available modes are:"
msgstr ""
"*mode* 是一个指明文件打开模式的可选字符串。 它默认为 ``'r'`` 表示以文本模式读取。 其他常见模式有表示写入的 ``'w'`` "
"(若文件已存在则将其清空)，表示独占创建的 ``'x'``，以及表示追加写入的 ``'a'`` (在 *某些* Unix "
"系统上，这意味着无论当前查找位置在哪里 *所有* 写入操作都将追加到文件末尾)。 在文本模式下，如果未指定 *encoding* "
"则所使用的编码格式将依赖于具体平台: :func:`locale.getencoding()` 会被调用以获取当前语言区域的编码格式。 "
"(对于读取和写入原始字节数据请使用二进制模式并且不要指定 *encoding*。) 可用的模式有:"

#: ../../library/functions.rst:1294
msgid "Character"
msgstr "字符"

#: ../../library/functions.rst:1294
msgid "Meaning"
msgstr "含意"

#: ../../library/functions.rst:1296
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/functions.rst:1296
msgid "open for reading (default)"
msgstr "读取（默认）"

#: ../../library/functions.rst:1297
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/functions.rst:1297
msgid "open for writing, truncating the file first"
msgstr "写入，并先截断文件"

#: ../../library/functions.rst:1298
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/functions.rst:1298
msgid "open for exclusive creation, failing if the file already exists"
msgstr "排它性创建，如果文件已存在则失败"

#: ../../library/functions.rst:1299
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/functions.rst:1299
msgid "open for writing, appending to the end of file if it exists"
msgstr "打开文件用于写入，如果文件存在则在末尾追加"

#: ../../library/functions.rst:1300
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/functions.rst:1300 ../../library/functions.rst:1444
msgid "binary mode"
msgstr "二进制模式"

#: ../../library/functions.rst:1301
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/functions.rst:1301
msgid "text mode (default)"
msgstr "文本模式（默认）"

#: ../../library/functions.rst:1302
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/functions.rst:1302
msgid "open for updating (reading and writing)"
msgstr "打开用于更新（读取与写入）"

#: ../../library/functions.rst:1305
msgid ""
"The default mode is ``'r'`` (open for reading text, a synonym of ``'rt'``). "
"Modes ``'w+'`` and ``'w+b'`` open and truncate the file.  Modes ``'r+'`` and"
" ``'r+b'`` open the file with no truncation."
msgstr ""
"默认模式为 ``'r'`` （打开文件用于读取文本，与 ``'rt'`` 同义）。``'w+'`` 和 ``'w+b'`` 模式将打开文件并清空内容。而"
" ``'r+'`` 和 ``'r+b'`` 模式将打开文件但不清空内容。"

#: ../../library/functions.rst:1309
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"正如在 :ref:`io-overview` 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 *mode* 参数中的 "
"``'b'`` ）返回的内容为 :class:`bytes` 对象，不进行任何解码。在文本模式下（默认情况下，或者在 *mode* 参数中包含 "
"``'t'`` ）时，文件内容返回为 :class:`str` ，首先使用指定的 *encoding* （如果给定）或者使用平台默认的的字节编码解码。"

#: ../../library/functions.rst:1319
msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr "Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。"

#: ../../library/functions.rst:1323
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0"
" to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable when writing in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer. Note that "
"specifying a buffer size this way applies for binary buffered I/O, but "
"``TextIOWrapper`` (i.e., files opened with ``mode='r+'``) would have another"
" buffering. To disable buffering in ``TextIOWrapper``, consider using the "
"``write_through`` flag for :func:`io.TextIOWrapper.reconfigure`. When no "
"*buffering* argument is given, the default buffering policy works as "
"follows:"
msgstr ""
"*buffering* 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（仅在二进制模式下允许），传入 1 "
"来选择行缓冲（仅在文本模式下写入时可用），传一个整数 > 1 来表示固定大小的块缓冲区的字节大小。 注意这样指定缓冲区的大小适用于二进制缓冲的 "
"I/O,但 ``TextIOWrapper`` (即用 ``mode='r+'`` 打开的文件) 会有另一种缓冲。 要禁用 "
"``TextIOWrapper`` 中的缓冲，请考虑为 :func:`io.TextIOWrapper.reconfigure` 使用 "
"``write_through`` 旗标。 当没有给出 *buffering* 参数时，默认的缓冲策略规则如下:"

#: ../../library/functions.rst:1333
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block"
" size\" and falling back on :const:`io.DEFAULT_BUFFER_SIZE`.  On many "
"systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"二进制文件以固定大小的块进行缓冲；缓冲区的大小是使用启发方式来尝试确定底层设备的“块大小”并会回退至 "
":const:`io.DEFAULT_BUFFER_SIZE`。 在许多系统上，缓冲区的长度通常为 4096 或 8192 字节。"

#: ../../library/functions.rst:1338
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"“交互式”文本文件（ :meth:`~io.IOBase.isatty` 返回 ``True`` "
"的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。"

#: ../../library/functions.rst:1342
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getencoding` returns), but any :term:`text"
" encoding` supported by Python can be used. See the :mod:`codecs` module for"
" the list of supported encodings."
msgstr ""
"*encoding* 是用于编码或编码文件的编码格式名称。 这应当只有文本模式下使用。 默认的编码格式依赖于具体平台 (即 "
":func:`locale.getencoding` 所返回的值)，但是任何 Python 支持的 :term:`text encoding` "
"都可以被使用。 请参阅 :mod:`codecs` 模块获取受支持的编码格式列表。"

#: ../../library/functions.rst:1348
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with "
":func:`codecs.register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 "
":ref:`error-handlers` ），但是使用 :func:`codecs.register_error` "
"注册的任何错误处理名称也是有效的。标准名称包括:"

#: ../../library/functions.rst:1356
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr "如果存在编码错误，``'strict'`` 会引发 :exc:`ValueError` 异常。 默认值 ``None`` 具有相同的效果。"

#: ../../library/functions.rst:1360
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to"
" data loss."
msgstr "``'ignore'`` 忽略错误。请注意，忽略编码错误可能会导致数据丢失。"

#: ../../library/functions.rst:1363
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr "``'replace'`` 会将替换标记（例如 ``'?'`` ）插入有错误数据的地方。"

#: ../../library/functions.rst:1366
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as low surrogate "
"code units ranging from U+DC80 to U+DCFF. These surrogate code units will "
"then be turned back into the same bytes when the ``surrogateescape`` error "
"handler is used when writing data.  This is useful for processing files in "
"an unknown encoding."
msgstr ""
"``'surrogateescape'`` 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 "
"``surrogateescape`` 错误处理器时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。"

#: ../../library/functions.rst:1373
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters"
" not supported by the encoding are replaced with the appropriate XML "
"character reference :samp:`&#{nnn};`."
msgstr ""
"``'xmlcharrefreplace'`` 仅在写入文件时才受到支持。 编码格式不支持的字符将被替换为相应的 XML 字符引用 "
":samp:`&#{nnn};`。"

#: ../../library/functions.rst:1377
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr "``'backslashreplace'`` 用Python的反向转义序列替换格式错误的数据。"

#: ../../library/functions.rst:1380
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr "``'namereplace'`` （也只在编写时支持）用 ``\\N{...}`` 转义序列替换不支持的字符。"

#: ../../library/functions.rst:1388
msgid ""
"*newline* determines how to parse newline characters from the stream. It can"
" be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as "
"follows:"
msgstr ""
"*newline* 决定如何解析来自流的换行符。 它可以为 ``None``, ``''``, ``'\\n'``, ``'\\r'`` 和 "
"``'\\r\\n'``。 它的工作原理如下:"

#: ../../library/functions.rst:1392
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"从流中读取输入时，如果 *newline* 为 ``None``，则启用通用换行模式。输入中的行可以以 ``'\\n'``，``'\\r'`` 或 "
"``'\\r\\n'`` 结尾，这些行被翻译成 ``'\\n'`` 在返回呼叫者之前。如果它是 "
"``''``，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且返回给调用者时行结尾不会被转换。"

#: ../../library/functions.rst:1400
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, "
":data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"将输出写入流时，如果 *newline* 为 ``None``，则写入的任何 ``'\\n'`` 字符都将转换为系统默认行分隔符 "
":data:`os.linesep`。如果 *newline* 是 ``''`` 或 ``'\\n'``，则不进行翻译。如果 *newline* "
"是任何其他合法值，则写入的任何 ``'\\n'`` 字符将被转换为给定的字符串。"

#: ../../library/functions.rst:1406
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default); "
"otherwise, an error will be raised."
msgstr ""
"如果 *closefd* 为 ``False`` "
"且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 *closefd* 必须为 ``True`` "
"（默认值），否则将触发错误。"

#: ../../library/functions.rst:1411
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"可以通过传递可调用的 *opener* 来使用自定义开启器。然后通过使用参数（ *file*，*flags* ）调用 *opener* "
"获得文件对象的基础文件描述符。 *opener* 必须返回一个打开的文件描述符（使用 :mod:`os.open` as *opener* 时与传递 "
"``None`` 的效果相同）。"

#: ../../library/functions.rst:1417
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新创建的文件是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/functions.rst:1419
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the "
":func:`os.open` function to open a file relative to a given directory::"
msgstr ""
"下面的示例使用 :func:`os.open` 函数的 :ref:`dir_fd <dir_fd>` 的形参，从给定的目录中用相对路径打开文件::"

#: ../../library/functions.rst:1422
msgid ""
">>> import os\n"
">>> dir_fd = os.open('somedir', os.O_RDONLY)\n"
">>> def opener(path, flags):\n"
"...     return os.open(path, flags, dir_fd=dir_fd)\n"
"...\n"
">>> with open('spamspam.txt', 'w', opener=opener) as f:\n"
"...     print('This will be written to somedir/spamspam.txt', file=f)\n"
"...\n"
">>> os.close(dir_fd)  # don't leak a file descriptor"
msgstr ""
">>> import os\n"
">>> dir_fd = os.open('somedir', os.O_RDONLY)\n"
">>> def opener(path, flags):\n"
"...     return os.open(path, flags, dir_fd=dir_fd)\n"
"...\n"
">>> with open('spamspam.txt', 'w', opener=opener) as f:\n"
"...     print('This will be written to somedir/spamspam.txt', file=f)\n"
"...\n"
">>> os.close(dir_fd)  # 不要泄漏文件描述符"

#: ../../library/functions.rst:1432
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of "
":class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in "
"read/write mode, it returns an :class:`io.BufferedRandom`.  When buffering "
"is disabled, the raw stream, a subclass of :class:`io.RawIOBase`, "
":class:`io.FileIO`, is returned."
msgstr ""
":func:`open` 函数所返回的 :term:`file object` 类型取决于所用模式。 当使用 :func:`open` 以文本模式 "
"(``'w'``, ``'r'``, ``'wt'``, ``'rt'`` 等) 打开文件时，它将返回 :class:`io.TextIOBase` "
"(具体为 :class:`io.TextIOWrapper`) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 "
":class:`io.BufferedIOBase` 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 "
":class:`io.BufferedReader`；在写入二进制和追加二进制模式下，它将返回 "
":class:`io.BufferedWriter`，而在读/写模式下，它将返回 :class:`io.BufferedRandom`。 "
"当禁用缓冲时，则会返回原始流，即 :class:`io.RawIOBase` 的一个子类 :class:`io.FileIO`。"

#: ../../library/functions.rst:1453
msgid ""
"See also the file handling modules, such as :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, "
":mod:`tempfile`, and :mod:`shutil`."
msgstr ""
"另请参阅文件操作模块，如 :mod:`fileinput`、:mod:`io` （声明了 "
":func:`open`）、:mod:`os`、:mod:`os.path`、:mod:`tempfile` 和 :mod:`shutil`。"

#: ../../library/functions.rst:1457
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``,"
" ``mode``, ``flags``."
msgstr ""
"引发一个 :ref:`审计事件 <auditing>` ``open`` 并附带参数 ``path``, ``mode``, ``flags``。"

#: ../../library/functions.rst:1459
msgid ""
"The ``mode`` and ``flags`` arguments may have been modified or inferred from"
" the original call."
msgstr "``mode`` 与 ``flags`` 参数可以在原始调用的基础上被修改或传递。"

#: ../../library/functions.rst:1464
msgid "The *opener* parameter was added."
msgstr "增加了 *opener* 形参。"

#: ../../library/functions.rst:1465
msgid "The ``'x'`` mode was added."
msgstr "增加了 ``'x'`` 模式。"

#: ../../library/functions.rst:1466
msgid ""
":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr "过去触发的 :exc:`IOError`，现在是 :exc:`OSError` 的别名。"

#: ../../library/functions.rst:1467
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr "如果文件已存在但使用了排它性创建模式（ ``'x'`` ），现在会触发 :exc:`FileExistsError`。"

#: ../../library/functions.rst:1472
msgid "The file is now non-inheritable."
msgstr "文件现在禁止继承。"

#: ../../library/functions.rst:1476
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an "
":exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 :exc:`InterruptedError` 异常 (原因详见 "
":pep:`475`)。"

#: ../../library/functions.rst:1479
msgid "The ``'namereplace'`` error handler was added."
msgstr "增加了 ``'namereplace'`` 错误处理接口。"

#: ../../library/functions.rst:1483
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr "增加对实现了 :class:`os.PathLike` 对象的支持。"

#: ../../library/functions.rst:1484
msgid ""
"On Windows, opening a console buffer may return a subclass of "
":class:`io.RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"在 Windows 上，打开一个控制台缓冲区将返回 :class:`io.RawIOBase` 的子类，而不是 :class:`io.FileIO`。"

#: ../../library/functions.rst:1487
msgid "The ``'U'`` mode has been removed."
msgstr "``'U'`` 模式已被移除。"

#: ../../library/functions.rst:1492
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns"
" ``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 ``ord('a')`` 返回整数 ``97``， "
"``ord('€')`` （欧元符号）返回 ``8364`` 。这是 :func:`chr` 的逆函数。"

#: ../../library/functions.rst:1500
msgid ""
"Return *base* to the power *exp*; if *mod* is present, return *base* to the "
"power *exp*, modulo *mod* (computed more efficiently than ``pow(base, exp) %"
" mod``). The two-argument form ``pow(base, exp)`` is equivalent to using the"
" power operator: ``base**exp``."
msgstr ""
"返回 *base* 的 *exp* 次幂；如果 *mod* 存在，则返回 *base* 的 *exp* 次幂对 *mod* 取余（比 "
"``pow(base, exp) % mod`` 更高效）。 两参数形式 ``pow(base, exp)`` 等价于乘方运算符: "
"``base**exp``。"

#: ../../library/functions.rst:1505
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``pow(10, "
"2)`` returns ``100``, but ``pow(10, -2)`` returns ``0.01``.  For a negative "
"base of type :class:`int` or :class:`float` and a non-integral exponent, a "
"complex result is delivered.  For example, ``pow(-9, 0.5)`` returns a value "
"close to ``3j``. Whereas, for a negative base of type :class:`int` or "
":class:`float` with an integral exponent, a float result is delivered. For "
"example, ``pow(-9, 2.0)`` returns ``81.0``."
msgstr ""
"这些参数必须为数字类型。 对于混用的操作数类型，将应用二元算术运算的强制转换规则。 对于 :class:`int` "
"操作数，结果具有与操作数相同的类型（转换之后）除非第二个参数为负值；在那种情况下，所有参数将被转换为浮点数并输出浮点数的结果。 例如，``pow(10,"
" 2)`` 返回 ``100``，而 ``pow(10, -2)`` 返回 ``0.01``。 对于 :class:`int` 或 "
":class:`float` 类型的基数为负值而幂为非整数的情况，将产生一个复数的结果。 例如，``pow(-9, 0.5)`` 将返回一个接近 "
"``3j`` 的值。 最后，对于 :class:`int` 或 :class:`float` 类型的基数为负值而幂为整数的情况，将产生一个浮点数的结果。"
" 例如，``pow(-9, 2.0)`` 将返回 ``81.0``。"

#: ../../library/functions.rst:1517
msgid ""
"For :class:`int` operands *base* and *exp*, if *mod* is present, *mod* must "
"also be of integer type and *mod* must be nonzero. If *mod* is present and "
"*exp* is negative, *base* must be relatively prime to *mod*. In that case, "
"``pow(inv_base, -exp, mod)`` is returned, where *inv_base* is an inverse to "
"*base* modulo *mod*."
msgstr ""
"对于 :class:`int` 操作数 *base* 和 *exp*，如果给出 *mod*，则 *mod* 必须为整数类型并且 *mod* 必须不为零。"
" 如果给出 *mod* 并且 *exp* 为负值，则 *base* 必须相对于 *mod* 不可整除。 在这种情况下，将会返回 "
"``pow(inv_base, -exp, mod)``，其中 *inv_base* 为 *base* 的倒数对 *mod* 取余。"

#: ../../library/functions.rst:1523
msgid "Here's an example of computing an inverse for ``38`` modulo ``97``::"
msgstr "下面的例子是 ``38`` 的倒数对 ``97`` 取余::"

#: ../../library/functions.rst:1525
msgid ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"
msgstr ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"

#: ../../library/functions.rst:1530
msgid ""
"For :class:`int` operands, the three-argument form of ``pow`` now allows the"
" second argument to be negative, permitting computation of modular inverses."
msgstr "对于 :class:`int` 操作数，三参数形式的 ``pow`` 现在允许第二个参数为负值，即可以计算倒数的余数。"

#: ../../library/functions.rst:1535
msgid ""
"Allow keyword arguments.  Formerly, only positional arguments were "
"supported."
msgstr "允许关键字参数。 之前只支持位置参数。"

#: ../../library/functions.rst:1542
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file*, and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""
"将 *objects* 打印输出至 *file* 指定的文本流，以 *sep* 分隔并在末尾加上 *end*。 *sep* 、 *end* 、 "
"*file* 和 *flush* 必须以关键字参数的形式给出。"

#: ../../library/functions.rst:1546
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and"
" written to the stream, separated by *sep* and followed by *end*.  Both "
"*sep* and *end* must be strings; they can also be ``None``, which means to "
"use the default values.  If no *objects* are given, :func:`print` will just "
"write *end*."
msgstr ""
"所有非关键字参数都会被转换为字符串，就像是执行了 :func:`str` 一样，并会被写入到流，以 *sep* 分隔并在末尾加上 *end*。 "
"*sep* 和 *end* 都必须为字符串；它们也可以为 ``None``，这意味着使用默认值。 如果没有给出 *objects*，则 "
":func:`print` 将只写入 *end*。"

#: ../../library/functions.rst:1552
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it"
" is not present or ``None``, :data:`sys.stdout` will be used.  Since printed"
" arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""
"*file* 参数必须是一个具有 ``write(string)`` 方法的对象；如果参数不存在或为 ``None``，则将使用 "
":data:`sys.stdout`。 由于要打印的参数会被转换为文本字符串，因此 :func:`print` 不能用于二进制模式的文件对象。 "
"对于这些对象，应改用 ``file.write(...)``。"

#: ../../library/functions.rst:1557
msgid ""
"Output buffering is usually determined by *file*. However, if *flush* is "
"true, the stream is forcibly flushed."
msgstr "输出缓冲通常由 *file* 确定。 但是，如果 *flush* 为真值，流将被强制刷新。"

#: ../../library/functions.rst:1561
msgid "Added the *flush* keyword argument."
msgstr "增加了 *flush* 关键字参数。"

#: ../../library/functions.rst:1567
msgid "Return a property attribute."
msgstr "返回 property 属性。"

#: ../../library/functions.rst:1569
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* 是获取属性值的函数。 *fset* 是用于设置属性值的函数。 *fdel* 是用于删除属性值的函数。并且 *doc* "
"为属性对象创建文档字符串。"

#: ../../library/functions.rst:1573
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "一个典型的用法是定义一个托管属性 ``x``::"

#: ../../library/functions.rst:1575
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"

#: ../../library/functions.rst:1590
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter, and ``del c.x`` the deleter."
msgstr ""
"如果 *c* 为 *C* 的实例，``c.x`` 将调用 getter，``c.x = value`` 将调用 setter， ``del c.x`` "
"将调用 deleter。"

#: ../../library/functions.rst:1593
msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a "
":term:`decorator`::"
msgstr ""
"如果给出，*doc* 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 *fget* 的文档字符串（如果存在）。 "
"这令使用 :func:`property` 作为 :term:`decorator` 来创建只读的特征属性可以很容易地实现::"

#: ../../library/functions.rst:1597
msgid ""
"class Parrot:\n"
"    def __init__(self):\n"
"        self._voltage = 100000\n"
"\n"
"    @property\n"
"    def voltage(self):\n"
"        \"\"\"Get the current voltage.\"\"\"\n"
"        return self._voltage"
msgstr ""
"class Parrot:\n"
"    def __init__(self):\n"
"        self._voltage = 100000\n"
"\n"
"    @property\n"
"    def voltage(self):\n"
"        \"\"\"Get the current voltage.\"\"\"\n"
"        return self._voltage"

#: ../../library/functions.rst:1606
msgid ""
"The ``@property`` decorator turns the :meth:`!voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"``@property`` 装饰器会将 :meth:`!voltage` 方法转化为一个具有相同名称的只读属性 \"getter\"，并将 "
"*voltage* 的文档字符串设为 \"Get the current voltage.\""

#: ../../library/functions.rst:1614
msgid ""
"A property object has ``getter``, ``setter``, and ``deleter`` methods usable"
" as decorators that create a copy of the property with the corresponding "
"accessor function set to the decorated function.  This is best explained "
"with an example:"
msgstr ""
"特征属性对象具有 ``getter``, ``setter`` 和 ``deleter`` "
"方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来说明："

#: ../../library/functions.rst:1619
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"I'm the 'x' property.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"
msgstr ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"I'm the 'x' property.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"

#: ../../library/functions.rst:1638
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr "上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 ``x``。)"

#: ../../library/functions.rst:1642
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and"
" ``fdel`` corresponding to the constructor arguments."
msgstr "返回的特征属性对象同样具有与构造器参数相对应的属性 ``fget``, ``fset`` 和 ``fdel``。"

#: ../../library/functions.rst:1645
msgid "The docstrings of property objects are now writeable."
msgstr "特征属性对象的文档字符串现在是可写的。"

#: ../../library/functions.rst:1654
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""
"虽然被称为函数，但 :class:`range` 实际上是一个不可变的序列类型，参见在 :ref:`typesseq-range` 与 "
":ref:`typesseq` 中的文档说明。"

#: ../../library/functions.rst:1660
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`; otherwise, "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this"
" function returns for its instances by defining a :meth:`~object.__repr__` "
"method. If :func:`sys.displayhook` is not accessible, this function will "
"raise :exc:`RuntimeError`."
msgstr ""
"返回包含一个对象的可打印表示形式的字符串。 对于许多类型而言，此函数会尝试返回一个具有与传给 :func:`eval` "
"时相同的值的字符串；在其他情况下，其表示形式将为一个包含对象类型名称和通常包括对象名称和地址的额外信息的用尖括号括起来的字符串。 一个类可以通过定义 "
":meth:`~object.__repr__` 方法来控制此函数为其实例所返回的内容。 如果 :func:`sys.displayhook` "
"不可访问，则此函数将会引发 :exc:`RuntimeError`。"

#: ../../library/functions.rst:1671
msgid "This class has a custom representation that can be evaluated::"
msgstr "该类具有自定义的表示形式，它可被求值为::"

#: ../../library/functions.rst:1673
msgid ""
"class Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""
msgstr ""
"class Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""

#: ../../library/functions.rst:1684
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a "
":meth:`~object.__reversed__` method or supports the sequence protocol (the "
":meth:`~object.__len__` method and the :meth:`~object.__getitem__` method "
"with integer arguments starting at ``0``)."
msgstr ""
"返回一个反向的 :term:`iterator`。 *seq* 必须是一个具有 :meth:`~object.__reversed__` "
"方法或是支持序列协议（具有 :meth:`~object.__len__` 方法和从 ``0`` 开始的整数参数的 "
":meth:`~object.__getitem__` 方法）的对象。"

#: ../../library/functions.rst:1692
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""
"返回 *number* 舍入到小数点后 *ndigits* 位精度的值。 如果 *ndigits* 被省略或为 "
"``None``，则返回最接近输入值的整数。"

#: ../../library/functions.rst:1696
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise, the return value has the same type as *number*."
msgstr ""
"对于支持 :func:`round` 方法的内置类型，结果值会舍入至最接近的 10 的负 *ndigits* "
"次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，``round(0.5)`` 和 ``round(-0.5)`` 均得出 ``0`` 而 "
"``round(1.5)`` 则为 ``2``。*ndigits* 可为任意整数值（正数、零或负数）。如果省略了 *ndigits* 或为 "
"``None`` ，则返回值将为整数。否则返回值与 *number* 的类型相同。"

#: ../../library/functions.rst:1705
msgid ""
"For a general Python object ``number``, ``round`` delegates to "
"``number.__round__``."
msgstr "对于一般的 Python 对象 ``number``, ``round`` 将委托给 ``number.__round__``。"

#: ../../library/functions.rst:1710
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is"
" not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""
"对浮点数执行 :func:`round` 的行为可能会令人惊讶：例如，``round(2.675, 2)`` 将给出 ``2.67`` 而不是期望的 "
"``2.68``。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 :ref:`tut-fp-issues` "
"了解更多信息。"

#: ../../library/functions.rst:1722
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""
"返回一个新的 :class:`set` 对象，可以选择带有从 *iterable* 获取的元素。 ``set`` 是一个内置类型。 请查看 "
":class:`set` 和 :ref:`types-set` 获取关于这个类的文档。"

#: ../../library/functions.rst:1726
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections`"
" module."
msgstr ""
"有关其他容器请参看内置的 :class:`frozenset`, :class:`list`, :class:`tuple` 和 "
":class:`dict` 类，以及 :mod:`collections` 模块。"

#: ../../library/functions.rst:1733
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string, and an arbitrary value.  The string may name an existing attribute "
"or a new attribute.  The function assigns the value to the attribute, "
"provided the object allows it.  For example, ``setattr(x, 'foobar', 123)`` "
"is equivalent to ``x.foobar = 123``."
msgstr ""
"本函数与 :func:`getattr` "
"相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 "
"``setattr(x, 'foobar', 123)`` 等价于 ``x.foobar = 123``。"

#: ../../library/functions.rst:1739
msgid ""
"*name* need not be a Python identifier as defined in :ref:`identifiers` "
"unless the object chooses to enforce that, for example in a custom "
":meth:`~object.__getattribute__` or via :attr:`~object.__slots__`. An "
"attribute whose name is not an identifier will not be accessible using the "
"dot notation, but is accessible through :func:`getattr` etc.."
msgstr ""
"*name* 无需为在 :ref:`identifiers` 中定义的 Python 标识符除非对象选择强制这样做，例如在一个自定义的 "
":meth:`~object.__getattribute__` 中或是通过 :attr:`~object.__slots__`。 "
"一个名称不为标识符的属性将不可使用点号标记来访问，但是可以通过 :func:`getattr` 等来访问。"

#: ../../library/functions.rst:1747
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes"
" with two leading underscores) name in order to set it with :func:`setattr`."
msgstr ""
"由于 :ref:`私有名称混合 <private-name-mangling>` "
"发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 :func:`setattr` 来设置它。"

#: ../../library/functions.rst:1756
msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``."
msgstr ""
"返回一个表示由 ``range(start, stop, step)`` 指定的索引集的 :term:`slice` 对象。 *start* 和 "
"*step* 参数默认为 ``None``。"

#: ../../library/functions.rst:1764
msgid ""
"Slice objects have read-only data attributes :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` which merely return the argument values (or their "
"default).  They have no other explicit functionality; however, they are used"
" by NumPy and other third-party packages."
msgstr ""
"切片对象具有只读的数据属性 :attr:`!start`, :attr:`!stop` 和 "
":attr:`!step`，它们将简单地返回相应的参数值（或其默认值）。 它们没有其他显式的功能；但是，它们会被 NumPy 和其他第三方包所使用。"

#: ../../library/functions.rst:1769
msgid ""
"Slice objects are also generated when extended indexing syntax is used.  For"
" example: ``a[start:stop:step]`` or ``a[start:stop, i]``.  See "
":func:`itertools.islice` for an alternate version that returns an "
":term:`iterator`."
msgstr ""
"当使用扩展索引语法时也会生成切片对象。 例如: ``a[start:stop:step]`` 或 ``a[start:stop, i]``。 请参阅 "
":func:`itertools.islice` 了解返回 :term:`iterator` 的替代版本。"

#: ../../library/functions.rst:1774
msgid ""
"Slice objects are now :term:`hashable` (provided :attr:`~slice.start`, "
":attr:`~slice.stop`, and :attr:`~slice.step` are hashable)."
msgstr ""
"Slice 对象现在将为 :term:`hashable` (如果 :attr:`~slice.start`, :attr:`~slice.stop` "
"和 :attr:`~slice.step` 均为可哈希对象)。"

#: ../../library/functions.rst:1780
msgid "Return a new sorted list from the items in *iterable*."
msgstr "根据 *iterable* 中的项返回一个新的已排序列表。"

#: ../../library/functions.rst:1782
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr "具有两个可选参数，它们都必须指定为关键字参数。"

#: ../../library/functions.rst:1784
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, "
"``key=str.lower``).  The default value is ``None`` (compare the elements "
"directly)."
msgstr ""
"*key* 指定带有单个参数的函数，用于从 *iterable* 的每个元素中提取用于比较的键 (例如 ``key=str.lower``)。 默认值为"
" ``None`` (直接比较元素)。"

#: ../../library/functions.rst:1788
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* 为一个布尔值。 如果设为 ``True``，则每个列表元素将按反向顺序比较进行排序。"

#: ../../library/functions.rst:1791
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a"
" *key* function."
msgstr "使用 :func:`functools.cmp_to_key` 可将老式的 *cmp* 函数转换为 *key* 函数。"

#: ../../library/functions.rst:1794
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""
"内置的 :func:`sorted` 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- "
"这有利于进行多重排序（例如先按部门、再按薪级排序）。"

#: ../../library/functions.rst:1799
msgid ""
"The sort algorithm uses only ``<`` comparisons between items.  While "
"defining an :meth:`~object.__lt__` method will suffice for sorting, :PEP:`8`"
" recommends that all six :ref:`rich comparisons <comparisons>` be "
"implemented.  This will help avoid bugs when using the same data with other "
"ordering tools such as :func:`max` that rely on a different underlying "
"method.  Implementing all six comparisons also helps avoid confusion for "
"mixed type comparisons which can call reflected the :meth:`~object.__gt__` "
"method."
msgstr ""
"排序算法只使用 ``<`` 在项目之间比较。 虽然定义一个 :meth:`~object.__lt__` 方法就足以进行排序，但 :PEP:`8` "
"建议实现所有六个 :ref:`富比较 <comparisons>` 。 这将有助于避免在与其他排序工具（如 :func:`max` "
"）使用相同的数据时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较的混乱，因为混合类型比较可以调用反射到 "
":meth:`~object.__gt__` 的方法。"

#: ../../library/functions.rst:1808
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有关排序示例和简要排序教程，请参阅 :ref:`sortinghowto` 。"

#: ../../library/functions.rst:1812
msgid "Transform a method into a static method."
msgstr "将方法转换为静态方法。"

#: ../../library/functions.rst:1814
msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr "静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法 ::"

#: ../../library/functions.rst:1817
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."
msgstr ""
"class C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."

#: ../../library/functions.rst:1821
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see "
":ref:`function` for details."
msgstr ""
"``@staticmethod`` 这样的形式称为函数的 :term:`decorator` -- 详情参阅 :ref:`function`。"

#: ../../library/functions.rst:1824
msgid ""
"A static method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``). Moreover, the static method "
":term:`descriptor` is also callable, so it can be used in the class "
"definition (such as ``f()``)."
msgstr ""
"静态方式既可以在类上调用 (如 ``C.f()``)，也可以在实例上调用 (如 ``C().f()``)。 此外，静态方法 "
":term:`descriptor` 也属于可调用对象，因而它们可以在类定义中使用 (如 ``f()``)。"

#: ../../library/functions.rst:1829
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also, "
"see :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr "Python 的静态方法与 Java 或 C++ 类似。另请参阅 :func:`classmethod` ，可用于创建另一种类构造函数。"

#: ../../library/functions.rst:1833
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""
"像所有装饰器一样，也可以像常规函数一样调用 ``staticmethod`` "
"，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法::"

#: ../../library/functions.rst:1839
msgid ""
"def regular_function():\n"
"    ...\n"
"\n"
"class C:\n"
"    method = staticmethod(regular_function)"
msgstr ""
"def regular_function():\n"
"    ...\n"
"\n"
"class C:\n"
"    method = staticmethod(regular_function)"

#: ../../library/functions.rst:1845
msgid "For more information on static methods, see :ref:`types`."
msgstr "想了解更多有关静态方法的信息，请参阅 :ref:`types` 。"

#: ../../library/functions.rst:1847
msgid ""
"Static methods now inherit the method attributes "
"(:attr:`~function.__module__`, :attr:`~function.__name__`, "
":attr:`~function.__qualname__`, :attr:`~function.__doc__` and "
":attr:`~function.__annotations__`), have a new ``__wrapped__`` attribute, "
"and are now callable as regular functions."
msgstr ""
"静态方法现在继承了方法的属性 (:attr:`~function.__module__`, :attr:`~function.__name__`, "
":attr:`~function.__qualname__`, :attr:`~function.__doc__` 和 "
":attr:`~function.__annotations__`)，并具有新的 ``__wrapped__`` "
"属性，现在是属于与常规函数类似的可调用对象。"

#: ../../library/functions.rst:1863
msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr "返回一个 :class:`str` 版本的 *object* 。有关详细信息，请参阅 :func:`str` 。"

#: ../../library/functions.rst:1865
msgid ""
"``str`` is the built-in string :term:`class`.  For general information about"
" strings, see :ref:`textseq`."
msgstr "``str`` 是内置字符串 :term:`class` 。更多关于字符串的信息查看 :ref:`textseq`。"

#: ../../library/functions.rst:1871
msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  The *iterable*'s items are normally numbers, and the start value"
" is not allowed to be a string."
msgstr ""
"从 *start* 开始自左向右对 *iterable* 的项求和并返回总计值。 *iterable* 的项通常为数字，而 start "
"值则不允许为字符串。"

#: ../../library/functions.rst:1875
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling "
"``''.join(sequence)``.  To add floating-point values with extended "
"precision, see :func:`math.fsum`\\.  To concatenate a series of iterables, "
"consider using :func:`itertools.chain`."
msgstr ""
"对于某些用例，存在 :func:`sum` 的更好替代。 拼接字符串序列的更好、更快的方式是调用 ``''.join(sequence)``。 "
"要以扩展的精度执行浮点数值的求和，请参阅 :func:`math.fsum`。 要拼接一系列可迭代对象，请考虑使用 "
":func:`itertools.chain`。"

#: ../../library/functions.rst:1881
msgid "The *start* parameter can be specified as a keyword argument."
msgstr "*start* 形参可用关键字参数形式来指定。"

#: ../../library/functions.rst:1884
msgid ""
"Summation of floats switched to an algorithm that gives higher accuracy on "
"most builds."
msgstr ""

#: ../../library/functions.rst:1891
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class."
msgstr "返回一个代理对象，它会将方法调用委托给 *type* 的父类或兄弟类。 这对于访问已在类中被重写的继承方法很有用。"

#: ../../library/functions.rst:1895
msgid ""
"The *object_or_type* determines the :term:`method resolution order` to be "
"searched.  The search starts from the class right after the *type*."
msgstr ""
"*object_or_type* 确定要用于搜索的 :term:`method resolution order`。 搜索会从 *type* "
"之后的类开始。"

#: ../../library/functions.rst:1899
msgid ""
"For example, if :attr:`~type.__mro__` of *object_or_type* is ``D -> B -> C "
"-> A -> object`` and the value of *type* is ``B``, then :func:`super` "
"searches ``C -> A -> object``."
msgstr ""
"举例来说，如果 *object_or_type* 的 :attr:`~type.__mro__` 为 ``D -> B -> C -> A -> "
"object`` 并且 *type* 的值为 ``B``，则 :func:`super` 将会搜索 ``C -> A -> object``。"

#: ../../library/functions.rst:1903
msgid ""
"The :attr:`~type.__mro__` attribute of the class corresponding to "
"*object_or_type* lists the method resolution search order used by both "
":func:`getattr` and :func:`super`.  The attribute is dynamic and can change "
"whenever the inheritance hierarchy is updated."
msgstr ""
"对应于 *object_or_type* 的类的 :attr:`~type.__mro__` 属性列出了 :func:`getattr` 和 "
":func:`super` 所共同使用的方法解析搜索顺序。 该属性是动态的并可在任何继承层级结构更新时被改变。"

#: ../../library/functions.rst:1908
msgid ""
"If the second argument is omitted, the super object returned is unbound.  If"
" the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""
"如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 ``isinstance(obj, type)`` 必须为真值。 "
"如果第二个参数为一个类型，则 ``issubclass(type2, type)`` 必须为真值（这适用于类方法）。"

#: ../../library/functions.rst:1913
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""
"*super* 有两个典型用例。 在具有单继承的类层级结构中，*super* 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 "
"这种用法与其他编程语言中 *super* 的用法非常相似。"

#: ../../library/functions.rst:1918
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not"
" found in statically compiled languages or languages that only support "
"single inheritance.  This makes it possible to implement \"diamond "
"diagrams\" where multiple base classes implement the same method.  Good "
"design dictates that such implementations have the same calling signature in"
" every case (because the order of calls is determined at runtime, because "
"that order adapts to changes in the class hierarchy, and because that order "
"can include sibling classes that are unknown prior to runtime)."
msgstr ""
"第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 "
"这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 "
"好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。"

#: ../../library/functions.rst:1928
msgid "For both use cases, a typical superclass call looks like this::"
msgstr "对于以上两个用例，典型的超类调用看起来是这样的::"

#: ../../library/functions.rst:1930
msgid ""
"class C(B):\n"
"    def method(self, arg):\n"
"        super().method(arg)    # This does the same thing as:\n"
"                               # super(C, self).method(arg)"
msgstr ""
"class C(B):\n"
"    def method(self, arg):\n"
"        super().method(arg)    # 它的作用像：\n"
"                               # super(C, self).method(arg)"

#: ../../library/functions.rst:1935
msgid ""
"In addition to method lookups, :func:`super` also works for attribute "
"lookups.  One possible use case for this is calling :term:`descriptors "
"<descriptor>` in a parent or sibling class."
msgstr ""
"除了方法查找之外，:func:`super` 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 :term:`描述器 "
"<descriptor>`。"

#: ../../library/functions.rst:1939
msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`~object.__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""
"请注意 :func:`super` 被实现为为显式的带点号属性查找的绑定过程的组成部分，例如 "
"``super().__getitem__(name)``。 它做到这一点是通过实现自己的 "
":meth:`~object.__getattribute__` 方法以便能够按支持协作多重继承的可预测的顺序来搜索类。 "
"相应地，:func:`super` 在像 ``super()[name]`` 这样使用语句或运算符进行隐式查找时则是未定义的。"

#: ../../library/functions.rst:1947
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""
"还要注意的是，除了零个参数的形式以外，:func:`super` 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 "
"零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。"

#: ../../library/functions.rst:1954
msgid ""
"For practical suggestions on how to design cooperative classes using "
":func:`super`, see `guide to using super() "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_."
msgstr ""
"对于有关如何使用 :func:`super` 来如何设计协作类的实用建议，请参阅 `使用 super() 的指南 "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_。"

#: ../../library/functions.rst:1964
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""
"虽然被称为函数，但 :class:`tuple` 实际上是一个不可变的序列类型，参见在 :ref:`typesseq-tuple` 与 "
":ref:`typesseq` 中的文档说明。"

#: ../../library/functions.rst:1973
msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by "
":attr:`object.__class__`."
msgstr ""
"传入一个参数时，返回 *object* 的类型。 返回值是一个 type 对象并且通常与 :attr:`object.__class__` "
"所返回的对象相同。"

#: ../../library/functions.rst:1977
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type"
" of an object, because it takes subclasses into account."
msgstr "推荐使用 :func:`isinstance` 内置函数来检测对象的类型，因为它会考虑子类的情况。"

#: ../../library/functions.rst:1980
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~type.__name__` attribute. The *bases* "
"tuple contains the base classes and becomes the :attr:`~type.__bases__` "
"attribute; if empty, :class:`object`, the ultimate base of all classes, is "
"added.  The *dict* dictionary contains attribute and method definitions for "
"the class body; it may be copied or wrapped before becoming the "
":attr:`~type.__dict__` attribute. The following two statements create "
"identical :class:`!type` objects:"
msgstr ""
"传入三个参数时，返回一个新的 type 对象。 这在本质上是 :keyword:`class` 语句的一种动态形式。 *name* 字符串即类名并会成为"
" :attr:`~type.__name__` 属性；*bases* 元组包含基类并会成为 :attr:`~type.__bases__` "
"属性；如果为空，则会添加所有类的终极基类，即 :class:`object`。 *dict* 字典包含类体的属性和方法定义；它在成为 "
":attr:`~type.__dict__` 属性之前可能会被拷贝或包装。 下面两条语句会创建同样的 :class:`!type` 对象："

#: ../../library/functions.rst:1995
msgid "See also:"
msgstr "另请参阅："

#: ../../library/functions.rst:1997
msgid ""
":ref:`Documentation on attributes and methods on classes <class-attrs-and-"
"methods>`."
msgstr ":ref:`有关类的属性和方法的文档 <class-attrs-and-methods>`。"

#: ../../library/functions.rst:1998
msgid ":ref:`bltin-type-objects`"
msgstr ":ref:`bltin-type-objects`"

#: ../../library/functions.rst:2000
msgid ""
"Keyword arguments provided to the three argument form are passed to the "
"appropriate metaclass machinery (usually :meth:`~object.__init_subclass__`) "
"in the same way that keywords in a class definition (besides *metaclass*) "
"would."
msgstr ""
"提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 "
":meth:`~object.__init_subclass__`)，相当于类定义中关键字 (除了 *metaclass*) 的行为方式。"

#: ../../library/functions.rst:2005
msgid "See also :ref:`class-customization`."
msgstr "另请参阅 :ref:`class-customization`。"

#: ../../library/functions.rst:2007
msgid ""
"Subclasses of :class:`!type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ":class:`!type` 的子类如果未重写 ``type.__new__`` 将不再能使用一个参数的形式来获取对象的类型。"

#: ../../library/functions.rst:2014
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance,"
" or any other object with a :attr:`!__dict__` attribute."
msgstr ""
"返回模块、类、实例或任何其他具有 :attr:`!__dict__` 属性的对象的 :attr:`~object.__dict__` 属性。"

#: ../../library/functions.rst:2017
msgid ""
"Objects such as modules and instances have an updateable "
":attr:`~object.__dict__` attribute; however, other objects may have write "
"restrictions on their :attr:`!__dict__` attributes (for example, classes use"
" a :class:`types.MappingProxyType` to prevent direct dictionary updates)."
msgstr ""
"模块和实例这样的对象具有可更新的 :attr:`~object.__dict__` 属性；但是，其他对象的 :attr:`!__dict__` "
"属性可能会设置写入限制（例如，类会使用 :class:`types.MappingProxyType` 来防止直接更新字典）。"

#: ../../library/functions.rst:2022
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""
"不带参数时，:func:`vars` 的行为类似 :func:`locals`。 请注意，locals 字典仅对于读取起作用，因为对 locals "
"字典的更新会被忽略。"

#: ../../library/functions.rst:2026
msgid ""
"A :exc:`TypeError` exception is raised if an object is specified but it "
"doesn't have a :attr:`~object.__dict__` attribute (for example, if its class"
" defines the :attr:`~object.__slots__` attribute)."
msgstr ""
"如果指定了一个对象但它没有 :attr:`~object.__dict__` 属性（例如，当它所属的类定义了 "
":attr:`~object.__slots__` 属性时）则会引发 :exc:`TypeError` 异常。"

#: ../../library/functions.rst:2032
msgid ""
"Iterate over several iterables in parallel, producing tuples with an item "
"from each one."
msgstr "在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。"

#: ../../library/functions.rst:2035
msgid "Example::"
msgstr "示例::"

#: ../../library/functions.rst:2037
msgid ""
">>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(item)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"
msgstr ""
">>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(item)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"

#: ../../library/functions.rst:2044
msgid ""
"More formally: :func:`zip` returns an iterator of tuples, where the *i*-th "
"tuple contains the *i*-th element from each of the argument iterables."
msgstr "更正式的说法： :func:`zip` 返回元组的迭代器，其中第 *i* 个元组包含的是每个参数迭代器的第 *i* 个元素。"

#: ../../library/functions.rst:2047
msgid ""
"Another way to think of :func:`zip` is that it turns rows into columns, and "
"columns into rows.  This is similar to `transposing a matrix "
"<https://en.wikipedia.org/wiki/Transpose>`_."
msgstr ""
"不妨换一种方式认识 :func:`zip` ：它会把行变成列，把列变成行。这类似于 `矩阵转置 "
"<https://en.wikipedia.org/wiki/Transpose>`_ 。"

#: ../../library/functions.rst:2051
msgid ""
":func:`zip` is lazy: The elements won't be processed until the iterable is "
"iterated on, e.g. by a :keyword:`!for` loop or by wrapping in a "
":class:`list`."
msgstr ""
":func:`zip` 是延迟执行的：直至迭代时才会对元素进行处理，比如 :keyword:`!for` 循环或放入 :class:`list` 中。"

#: ../../library/functions.rst:2055
msgid ""
"One thing to consider is that the iterables passed to :func:`zip` could have"
" different lengths; sometimes by design, and sometimes because of a bug in "
"the code that prepared these iterables.  Python offers three different "
"approaches to dealing with this issue:"
msgstr ""
"值得考虑的是，传给 :func:`zip` 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python "
"提供了三种不同的处理方案："

#: ../../library/functions.rst:2060
msgid ""
"By default, :func:`zip` stops when the shortest iterable is exhausted. It "
"will ignore the remaining items in the longer iterables, cutting off the "
"result to the length of the shortest iterable::"
msgstr "默认情况下，:func:`zip` 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度："

#: ../../library/functions.rst:2064
msgid ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"
msgstr ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"

#: ../../library/functions.rst:2067
msgid ""
":func:`zip` is often used in cases where the iterables are assumed to be of "
"equal length.  In such cases, it's recommended to use the ``strict=True`` "
"option. Its output is the same as regular :func:`zip`::"
msgstr ""
"通常 :func:`zip` 用于可迭代对象等长的情况下。这时建议用 ``strict=True`` 的选项。输出与普通的 :func:`zip` "
"相同：。"

#: ../../library/functions.rst:2071
msgid ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"
msgstr ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"

#: ../../library/functions.rst:2074
msgid ""
"Unlike the default behavior, it raises a :exc:`ValueError` if one iterable "
"is exhausted before the others:"
msgstr "与默认行为不同，如果一个可迭代对象在其他几个之前被耗尽则会引发 :exc:`ValueError`:"

#: ../../library/functions.rst:2092
msgid ""
"Without the ``strict=True`` argument, any bug that results in iterables of "
"different lengths will be silenced, possibly manifesting as a hard-to-find "
"bug in another part of the program."
msgstr ""
"如果未指定 ``strict=True`` 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。"

#: ../../library/functions.rst:2096
msgid ""
"Shorter iterables can be padded with a constant value to make all the "
"iterables have the same length.  This is done by "
":func:`itertools.zip_longest`."
msgstr ""
"为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 :func:`itertools.zip_longest` 来完成。"

#: ../../library/functions.rst:2100
msgid ""
"Edge cases: With a single iterable argument, :func:`zip` returns an iterator"
" of 1-tuples.  With no arguments, it returns an empty iterator."
msgstr "极端例子是只有一个可迭代对象参数，:func:`zip` 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。"

#: ../../library/functions.rst:2103
msgid "Tips and tricks:"
msgstr "小技巧："

#: ../../library/functions.rst:2105
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n, strict=True)``.  This repeats the *same* iterator "
"``n`` times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"可确保迭代器的求值顺序是从左到右的。这样就能用 ``zip(*[iter(s)]*n, strict=True)`` 将数据列表按长度 n "
"进行分组。这将重复 *相同* 的迭代器 ``n`` 次，输出的每个元组都包含 ``n`` 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n "
"的块。"

#: ../../library/functions.rst:2111
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ":func:`zip` 与 ``*`` 运算符相结合可以用来拆解一个列表::"

#: ../../library/functions.rst:2114
msgid ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"
msgstr ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"

#: ../../library/functions.rst:2122
msgid "Added the ``strict`` argument."
msgstr "增加了 ``strict`` 参数。"

#: ../../library/functions.rst:2134
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr "与 :func:`importlib.import_module` 不同，这是一个日常 Python 编程中不需要用到的高级函数。"

#: ../../library/functions.rst:2137
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the "
":keyword:`!import` statement, but doing so is **strongly** discouraged as it"
" is usually simpler to use import hooks (see :pep:`302`) to attain the same "
"goals and does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"此函数会由 :keyword:`import` 语句唤起。 它可以被替换 (通过导入 :mod:`builtins` 模块并赋值给 "
"``builtins.__import__``) 以便修改 :keyword:`!import` 语句的语义，但是 **强烈** "
"不建议这样做，因为使用导入钩子 (参见 :pep:`302`) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 "
"同样也不建议直接使用 :func:`__import__` 而应该用 :func:`importlib.import_module`。"

#: ../../library/functions.rst:2146
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should"
" be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""
"本函数会导入模块 *name*，利用 *globals* 和 *locals* 来决定如何在包的上下文中解释该名称。*fromlist* 给出了应从 "
"*name* 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 *locals* 参数，只用到了 *globals* 用于确定 "
":keyword:`import` 语句所在的包上下文。"

#: ../../library/functions.rst:2153
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""
"*level* 指定是使用绝对还是相对导入。 ``0`` (默认值) 意味着仅执行绝对导入。 *level* 为正数值表示相对于模块调用 "
":func:`__import__` 的目录，将要搜索的父目录层数 (详情参见 :pep:`328`)。"

#: ../../library/functions.rst:2159
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""
"当 *name* 变量的形式为 ``package.module`` 时，通常将会返回最高层级的包（第一个点号之前的名称），而 *不是* 以 "
"*name* 命名的模块。 但是，当给出了非空的 *fromlist* 参数时，则将返回以 *name* 命名的模块。"

#: ../../library/functions.rst:2164
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr "例如，语句 ``import spam`` 的结果将为与以下代码作用相同的字节码::"

#: ../../library/functions.rst:2167
msgid "spam = __import__('spam', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2169
msgid "The statement ``import spam.ham`` results in this call::"
msgstr "语句 ``import spam.ham`` 的结果将为以下调用::"

#: ../../library/functions.rst:2171
msgid "spam = __import__('spam.ham', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam.ham', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2173
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is"
" the object that is bound to a name by the :keyword:`import` statement."
msgstr ""
"请注意在这里 :func:`__import__` 是如何返回顶层模块的，因为这是通过 :keyword:`import` 语句被绑定到特定名称的对象。"

#: ../../library/functions.rst:2176
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr "另一方面，语句 ``from spam.ham import eggs, sausage as saus`` 的结果将为 ::"

#: ../../library/functions.rst:2179
msgid ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"
msgstr ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"

#: ../../library/functions.rst:2183
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"在这里， ``spam.ham`` 模块会由 :func:`__import__` 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。"

#: ../../library/functions.rst:2187
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr "如果您只想按名称导入模块（可能在包中），请使用 :func:`importlib.import_module`"

#: ../../library/functions.rst:2190
msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr "*level* 的值不再支持负数（默认值也修改为0）。"

#: ../../library/functions.rst:2194
msgid ""
"When the command line options :option:`-E` or :option:`-I` are being used, "
"the environment variable :envvar:`PYTHONCASEOK` is now ignored."
msgstr ""
"当使用了命令行参数 :option:`-E` 或 :option:`-I` 时，环境变量 :envvar:`PYTHONCASEOK` 现在将被忽略。"

#: ../../library/functions.rst:2199
msgid "Footnotes"
msgstr "备注"

#: ../../library/functions.rst:2200
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr "解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换 Windows 或 Mac 风格的换行符。"

#: ../../library/functions.rst:154
msgid "Boolean"
msgstr "布尔值"

#: ../../library/functions.rst:154 ../../library/functions.rst:1971
msgid "type"
msgstr "type"

#: ../../library/functions.rst:638
msgid "built-in function"
msgstr "内置函数"

#: ../../library/functions.rst:638
msgid "exec"
msgstr "exec"

#: ../../library/functions.rst:725
msgid "NaN"
msgstr "NaN"

#: ../../library/functions.rst:725
msgid "Infinity"
msgstr "Infinity"

#: ../../library/functions.rst:793
msgid "__format__"
msgstr "__format__"

#: ../../library/functions.rst:793 ../../library/functions.rst:1855
msgid "string"
msgstr "string"

#: ../../library/functions.rst:793
msgid "format() (built-in function)"
msgstr "format() (内置函数)"

#: ../../library/functions.rst:1262
msgid "file object"
msgstr "file object -- 文件对象"

#: ../../library/functions.rst:1262 ../../library/functions.rst:1383
msgid "open() built-in function"
msgstr "open() 内置函数"

#: ../../library/functions.rst:1290
msgid "file"
msgstr "文件"

#: ../../library/functions.rst:1290
msgid "modes"
msgstr "模式"

#: ../../library/functions.rst:1383
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../library/functions.rst:1444
msgid "line-buffered I/O"
msgstr "带行缓冲的 I/O"

#: ../../library/functions.rst:1444
msgid "unbuffered I/O"
msgstr "不带缓冲的 I/O"

#: ../../library/functions.rst:1444
msgid "buffer size, I/O"
msgstr "缓冲区大小, I/O"

#: ../../library/functions.rst:1444
msgid "I/O control"
msgstr "I/O 控制"

#: ../../library/functions.rst:1444
msgid "buffering"
msgstr "缓冲"

#: ../../library/functions.rst:1444
msgid "text mode"
msgstr "文本模式"

#: ../../library/functions.rst:1444 ../../library/functions.rst:2128
msgid "module"
msgstr "module"

#: ../../library/functions.rst:1444
msgid "sys"
msgstr "sys"

#: ../../library/functions.rst:1855
msgid "str() (built-in function)"
msgstr "str() (内置函数)"

#: ../../library/functions.rst:1971
msgid "object"
msgstr "object -- 对象"

#: ../../library/functions.rst:2128
msgid "statement"
msgstr "statement -- 语句"

#: ../../library/functions.rst:2128
msgid "import"
msgstr "import"

#: ../../library/functions.rst:2128
msgid "builtins"
msgstr "builtins"
