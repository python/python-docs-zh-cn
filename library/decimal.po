# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-23 14:20+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/decimal.rst:2
msgid ":mod:`!decimal` --- Decimal fixed-point and floating-point arithmetic"
msgstr ":mod:`!decimal` --- 十进制定点和浮点算术"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**源码：** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating-point arithmetic. It offers several advantages over the "
":class:`float` datatype:"
msgstr ""
":mod:`decimal` 模块提供了对快速且正确舍入的十进制浮点运算的支持。 与 :class:`float` 数据类型相比它具有以下优势:"

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must"
" provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal 类型的“设计是基于考虑人类习惯的浮点数模型，并且因此具有以下最高指导原则 —— 计算机必须提供与人们在学校所学习的算术相一致的算术。” "
"—— 摘自 decimal 算术规范描述。"

#: ../../library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"Decimal 数字可以完全精确地表示。 相比之下，``1.1`` 和 ``2.2`` 这样的数字在二进制浮点形式下没有精确的表示。 最终用户通常不希望"
" ``1.1 + 2.2`` 像在二进制浮点形式下那样被显示为 ``3.3000000000000003``。"

#: ../../library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, the "
"differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications"
" which have strict equality invariants."
msgstr ""
"这样的精确性会延续到算术运算中。 对于 decimal 浮点数，``0.1 + 0.1 + 0.1 - 0.3`` 会精确地等于零。 "
"而对于二进制浮点数，结果则为 ``5.5511151231257827e-017``。 "
"虽然接近于零，但其中的误差将妨碍到可靠的相等性检测并且这样的误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。"

#: ../../library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives ``1.56`` while ``1.30 * "
"1.20`` gives ``1.5600``."
msgstr ""
"decimal 模块包含有效位的概念因而使得 ``1.30 + 1.20`` 等于 ``2.50``。 末尾的零会被保留以表明有效位。 "
"这是货币相关应用的惯例表示方式。 对于乘法，则按“教科书”方式来使用被乘数中的所有数位。 例如，``1.3 * 1.2`` 结果为 ``1.56`` 而"
" ``1.30 * 1.20`` 结果为 ``1.5600``。"

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr "与基于硬件的二进制浮点不同，十进制模块具有用户可更改的精度（默认为28位），可以与给定问题所需的一样大："

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published"
" standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"二进制和 decimal 浮点数都是根据已发布的标准实现的。 虽然内置浮点类型只公开其功能的一小部分，但 decimal 模块公开了标准的所有必需部分。"
" 在需要时，程序员可以完全控制舍入和信号处理。 这包括通过使用异常来阻止任何不精确操作来强制执行精确算术的选项。"

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic"
" specification."
msgstr ""
"decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术”。 —— 摘自 decimal 算术规范说明。"

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr "该模块的设计以三个概念为中心：decimal 数值，算术上下文和信号。"

#: ../../library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as ``Infinity``, "
"``-Infinity``, and ``NaN``.  The standard also differentiates ``-0`` from "
"``+0``."
msgstr ""
"decimal 数值属于不可变对象。 它由一个符号、一个系数值及一个指数值组成。 为了保留有效位，系数值不会截去末尾的零。 decimal "
"数值还包括特殊值如 ``Infinity``, ``-Infinity`` 和 ``NaN``。 该标准还会区分 ``-0`` 和 ``+0``。"

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, "
":const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, "
":const:`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"算术的上下文是指定精度、舍入规则、指数限制、指示操作结果的标志以及确定符号是否被视为异常的陷阱启用器的环境。 舍入选项包括 "
":const:`ROUND_CEILING` 、 :const:`ROUND_DOWN` 、 :const:`ROUND_FLOOR` 、 "
":const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN` 、 :const:`ROUND_HALF_UP` "
"、 :const:`ROUND_UP` 以及 :const:`ROUND_05UP`."

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, "
":const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, "
":const:`Subnormal`, :const:`Overflow`, :const:`Underflow` and "
":const:`FloatOperation`."
msgstr ""
"信号是在计算过程中出现的异常条件组。 根据应用程序的需要，信号可能会被忽略，被视为信息，或被视为异常。 "
"十进制模块中的信号有：:const:`Clamped` 、 :const:`InvalidOperation` 、 "
":const:`DivisionByZero` 、 :const:`Inexact` 、 :const:`Rounded` 、 "
":const:`Subnormal` 、 :const:`Overflow` 、 :const:`Underflow` 以及 "
":const:`FloatOperation` 。"

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"对于每个信号，都有一个标志和一个陷阱启动器。 遇到信号时，其标志设置为 1 ，然后，如果陷阱启用器设置为 1 ，则引发异常。 "
"标志是粘性的，因此用户需要在监控计算之前重置它们。"

#: ../../library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"IBM 的通用十进制算术规范描述，`The General Decimal Arithmetic Specification "
"<https://speleotrove.com/decimal/decarith.html>`_。"

#: ../../library/decimal.rst:125
msgid "Quick-start tutorial"
msgstr "快速入门教程"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"通常使用 decimal 的方式是先导入该模块，通过 :func:`getcontext` "
"查看当前上下文，并在必要时为精度、舍入或启用的陷阱设置新值::"

#: ../../library/decimal.rst:131
msgid ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Set a new precision"
msgstr ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # 设置新的精度"

#: ../../library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion"
" of the value of that integer or float.  Decimal numbers include special "
"values such as ``NaN`` which stands for \"Not a number\", positive and "
"negative ``Infinity``, and ``-0``::"
msgstr ""
"Decimal 实例可以基于整数、字符串、浮点数或元组来构建。 基于整数或浮点数进行构建将执行该整数或浮点数值的精确转换。 Decimal "
"数字包括特殊值如代表“非数字”的 ``NaN``，正的和负的 ``Infinity`` 以及 ``-0``::"

#: ../../library/decimal.rst:145
msgid ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"
msgstr ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr "如果 :exc:`FloatOperation` 信号被捕获，构造函数中的小数和浮点数的意外混合或排序比较会引发异常 ::"

#: ../../library/decimal.rst:167
msgid ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"
msgstr ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr "新 Decimal 的重要性仅由输入的位数决定。 上下文精度和舍入仅在算术运算期间发挥作用。"

#: ../../library/decimal.rst:186
msgid ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"
msgstr ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal"
" raises :class:`InvalidOperation`::"
msgstr "如果超出了 C 版本的内部限制，则构造一个 decimal 将引发 :class:`InvalidOperation` ::"

#: ../../library/decimal.rst:202
msgid ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"
msgstr ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"

#: ../../library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating-point flying circus:"
msgstr "Decimal 能很好地与 Python 的其余部分交互。 以下是一个小小的 decimal 浮点数飞行马戏团："

#: ../../library/decimal.rst:212
msgid ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"
msgstr ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "Decimal 也可以使用一些数学函数："

#: ../../library/decimal.rst:253
msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent.  "
"This method is useful for monetary applications that often round results to "
"a fixed number of places:"
msgstr ":meth:`~Decimal.quantize` 方法将舍入为固定的指数。 此方法对于将结果舍入到固定位置的货币应用程序来说很有用处:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context"
" and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr "如上所示，:func:`getcontext` 函数访问当前上下文并允许更改设置。 这种方法满足大多数应用程序的需求。"

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the "
":func:`setcontext` function."
msgstr ""
"对于更高级的工作，使用 Context() 构造函数创建备用上下文可能很有用。 要使用备用活动，请使用 :func:`setcontext` 函数。"

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and "
":const:`ExtendedContext`. The former is especially useful for debugging "
"because many of the traps are enabled:"
msgstr ""
"根据标准，:mod:`decimal` 模块提供了两个现成的标准上下文 :const:`BasicContext` 和 "
":const:`ExtendedContext` 。 前者对调试特别有用，因为许多陷阱都已启用："

#: ../../library/decimal.rst:275
msgid ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"

#: ../../library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"上下文还具有用于监视计算期间遇到的异常情况的信号旗标。 这些旗标将保持设置直到被显式地清除，因此最好是通过使用 "
":meth:`~Context.clear_flags` 方法来清除每组受监控的计算之前的旗标。 ::"

#: ../../library/decimal.rst:304
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"

#: ../../library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded "
"(digits beyond the context precision were thrown away) and that the result "
"is inexact (some of the discarded digits were non-zero)."
msgstr "*flags* 条目显示对 pi 的有理逼近被舍入（超出上下文精度的数字会被丢弃）并且结果是不精确的（某些被丢弃的数字为非零值）。"

#: ../../library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`~Context.traps` "
"attribute of a context:"
msgstr "单个陷阱是使用上下文的 :attr:`~Context.traps` 属性中的字典来设置的:"

#: ../../library/decimal.rst:319
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"大多数程序仅在程序开始时调整当前上下文一次。 并且，在许多应用程序中，数据在循环内单个强制转换为 :class:`Decimal` 。 "
"通过创建上下文集和小数，程序的大部分操作数据与其他 Python 数字类型没有区别。"

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Decimal 对象"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "根据 *value* 构造一个新的 :class:`Decimal` 对象。"

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another "
":class:`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  "
"If *value* is a string, it should conform to the decimal numeric string "
"syntax after leading and trailing whitespace characters, as well as "
"underscores throughout, are removed::"
msgstr ""
"*value* 可以是整数，字符串，元组，:class:`float` ，或另一个 :class:`Decimal` 对象。 如果没有给出 "
"*value*，则返回 ``Decimal('0')``。 如果 *value* "
"是一个字符串，它应该在前导和尾随空格字符以及下划线被删除之后符合十进制数字字符串语法::"

#: ../../library/decimal.rst:355
msgid ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"
msgstr ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits"
" ``'\\uff10'`` through ``'\\uff19'``. Case is not significant, so, for "
"example, ``inf``, ``Inf``, ``INFINITY``, and ``iNfINity`` are all acceptable"
" spellings for positive infinity."
msgstr ""
"上面 ``digit`` 出现的地方也允许其他的 Unicode 十进制数码。 这包括来自各种其他语言字母表的十进制数码（例如，Arabic-Indic"
" 和 Devanāgarī 数码）以及全宽数码 ``'\\uff10'`` 至 ``'\\uff19'``。 对大小写不敏感，因此，例如 "
"``inf``, ``Inf``, ``INFINITY`` 和 ``iNfINity`` 都是可接受的正无穷大拼写形式。"

#: ../../library/decimal.rst:373
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, and "
"an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns"
" ``Decimal('1.414')``."
msgstr ""
"如果 *value* 是一个 :class:`tuple`，它应当有三个组成部分，一个符号 (``0`` 表示正数 ``1`` "
"表示负数)，一个由数字组成的 :class:`tuple`，以及一个整数指数值。 例如，``Decimal((0, (1, 4, 1, 4), "
"-3))`` 将返回 ``Decimal('1.414')``。"

#: ../../library/decimal.rst:378
msgid ""
"If *value* is a :class:`float`, the binary floating-point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"如果 *value* 是 :class:`float`，则二进制浮点值将无损地转换为其精确的十进制等效值。 此转换通常需要53位或更多位数的精度。 "
"例如，``Decimal(float('1.1'))`` 转换为 "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``。"

#: ../../library/decimal.rst:384
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"*context* 精度不会影响存储的位数。 这完全由 *value* 中的位数决定。 例如，``Decimal('3.00000')`` "
"记录所有五个零，即使上下文精度只有三。"

#: ../../library/decimal.rst:389
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of ``NaN``."
msgstr ""
"*context* 参数的目的是确定当 *value* 为错误格式的字符串时要怎么做。 如果上下文捕获了 "
":const:`InvalidOperation`，将会引发异常；在其他情况下，构造器将返回一个值为 ``NaN`` 的新 Decimal。"

#: ../../library/decimal.rst:394
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "构造完成后， :class:`Decimal` 对象是不可变的。"

#: ../../library/decimal.rst:396
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "现在允许构造函数的参数为 :class:`float` 实例。"

#: ../../library/decimal.rst:400
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ":class:`float` 参数在设置 :exc:`FloatOperation` 陷阱时引发异常。 默认情况下，陷阱已关闭。"

#: ../../library/decimal.rst:404
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr "允许下划线进行分组，就像代码中的整数和浮点文字一样。"

#: ../../library/decimal.rst:408
msgid ""
"Decimal floating-point objects share many properties with the other built-in"
" numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be"
" copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or "
":class:`int`)."
msgstr ""
"十进制浮点对象与其他内置数值类型共享许多属性，例如 :class:`float` 和 :class:`int` 。 所有常用的数学运算和特殊方法都适用。"
" 同样，十进制对象可以复制、pickle、打印、用作字典键、用作集合元素、比较、排序和强制转换为另一种类型（例如 :class:`float` 或 "
":class:`int` 等）。"

#: ../../library/decimal.rst:415
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"算术对十进制对象和算术对整数和浮点数有一些小的差别。 当余数运算符 ``%`` 应用于Decimal对象时，结果的符号是 *被除数* "
"的符号，而不是除数的符号::"

#: ../../library/decimal.rst:420
msgid ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"
msgstr ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"

#: ../../library/decimal.rst:425
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"整数除法运算符 ``//`` 的行为类似，返回真商的整数部分（截断为零）而不是它的向下取整，以便保留通常的标识 ``x == (x // y) * y "
"+ x % y``::"

#: ../../library/decimal.rst:429
msgid ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"
msgstr ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"

#: ../../library/decimal.rst:434
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"``%`` 和 ``//`` 运算符实现了 ``remainder`` 和 ``divide-integer`` 操作（分别），如规范中所述。"

#: ../../library/decimal.rst:438
msgid ""
"Decimal objects cannot generally be combined with floats or instances of "
":class:`fractions.Fraction` in arithmetic operations: an attempt to add a "
":class:`Decimal` to a :class:`float`, for example, will raise a "
":exc:`TypeError`.  However, it is possible to use Python's comparison "
"operators to compare a :class:`Decimal` instance ``x`` with another number "
"``y``.  This avoids confusing results when doing equality comparisons "
"between numbers of different types."
msgstr ""
"十进制对象通常不能与浮点数或 :class:`fractions.Fraction` 实例在算术运算中结合使用：例如,尝试将 "
":class:`Decimal` 加到 :class:`float` ，将引发 :exc:`TypeError`。 但是，可以使用 Python "
"的比较运算符来比较 :class:`Decimal` 实例 ``x`` 和另一个数字 ``y`` 。 "
"这样可以避免在对不同类型的数字进行相等比较时混淆结果。"

#: ../../library/decimal.rst:446
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr "现在完全支持 :class:`Decimal` 实例和其他数字类型之间的混合类型比较。"

#: ../../library/decimal.rst:450
msgid ""
"In addition to the standard numeric properties, decimal floating-point "
"objects also have a number of specialized methods:"
msgstr "除了标准的数字属性，十进制浮点对象还有许多专门的方法："

#: ../../library/decimal.rst:456
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"在移出系数最右边的数字之后返回调整后的指数，直到只剩下前导数字：``Decimal('321e+5').adjusted()`` 返回 7 。 "
"用于确定最高有效位相对于小数点的位置。"

#: ../../library/decimal.rst:463
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given "
":class:`Decimal` instance as a fraction, in lowest terms and with a positive"
" denominator::"
msgstr "返回一对 ``(n, d)`` 整数，表示给定的 :class:`Decimal` 实例作为分数、最简形式项并带有正分母::"

#: ../../library/decimal.rst:467
msgid ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"
msgstr ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"

#: ../../library/decimal.rst:470
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr "转换是精确的。 在 Infinity 上引发 OverflowError ，在 NaN 上引起 ValueError 。"

#: ../../library/decimal.rst:477
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"返回一个 :term:`named tuple` 表示的数字： ``DecimalTuple(sign, digits, exponent)``。"

#: ../../library/decimal.rst:483
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of a"
" :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr "返回参数的规范编码。 目前，一个 :class:`Decimal` 实例的编码始终是规范的，因此该操作返回其参数不变。"

#: ../../library/decimal.rst:489
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"比较两个 Decimal 实例的值。 :meth:`compare` 返回一个 Decimal 实例，如果任一操作数是 NaN ，那么结果是 NaN "
"::"

#: ../../library/decimal.rst:493
msgid ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"
msgstr ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"

#: ../../library/decimal.rst:500
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"除了所有 NaN 信号之外，此操作与 :meth:`compare` 方法相同。 也就是说，如果两个操作数都不是信令NaN，那么任何静默的 NaN "
"操作数都被视为信令NaN。"

#: ../../library/decimal.rst:506
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"使用它们的抽象表示而不是它们的数值来比较两个操作数。 类似于 :meth:`compare` 方法，但结果给出了一个总排序 "
":class:`Decimal` 实例。 两个 :class:`Decimal` 实例具有相同的数值但不同的表示形式在此排序中比较不相等："

#: ../../library/decimal.rst:515
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total"
" order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"静默和发出信号的 NaN 也包括在总排序中。 这个函数的结果是 ``Decimal('0')`` 如果两个操作数具有相同的表示，或是 "
"``Decimal('-1')`` 如果第一个操作数的总顺序低于第二个操作数，或是 ``Decimal('1')`` "
"如果第一个操作数在总顺序中高于第二个操作数。 有关总排序的详细信息，请参阅规范。"

#: ../../library/decimal.rst:522 ../../library/decimal.rst:533
#: ../../library/decimal.rst:561 ../../library/decimal.rst:865
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。"

#: ../../library/decimal.rst:528
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to "
"``x.copy_abs().compare_total(y.copy_abs())``."
msgstr ""
"比较两个操作数使用它们的抽象表示而不是它们的值，如 :meth:`compare_total`，但忽略每个操作数的符号。 "
"``x.compare_total_mag(y)`` 相当于 ``x.copy_abs().compare_total(y.copy_abs())``。"

#: ../../library/decimal.rst:539
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr "只返回self，这种方法只符合 Decimal 规范。"

#: ../../library/decimal.rst:544
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr "返回参数的绝对值。 此操作不受上下文影响并且是静默的：没有更改标志且不执行舍入。"

#: ../../library/decimal.rst:550
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr "回到参数的否定。 此操作不受上下文影响并且是静默的：没有标志更改且不执行舍入。"

#: ../../library/decimal.rst:555
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr "返回第一个操作数的副本，其符号设置为与第二个操作数的符号相同。 例如："

#: ../../library/decimal.rst:567
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given"
" number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN`"
" rounding mode."
msgstr "返回给定数字的（自然）指数函数 ``e**x`` 的值。结果使用 :const:`ROUND_HALF_EVEN` 舍入模式正确舍入。"

#: ../../library/decimal.rst:578
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or "
":class:`int`."
msgstr "另一个构造函数，只接受 :class:`float` 或 :class:`int` 的实例。"

#: ../../library/decimal.rst:581
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"请注意 ``Decimal.from_float(0.1)`` 与 ``Decimal('0.1')`` 是不同的。 由于 0.1 "
"不能以二进制浮点数精确表示，该值将被存储为最接受的可表示值 ``0x1.999999999999ap-4``。 与其等价的十进制值为 "
"``0.1000000000000000055511151231257827021181583404541015625``。"

#: ../../library/decimal.rst:587
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed"
" directly from a :class:`float`."
msgstr "从 Python 3.2 开始，:class:`Decimal` 实例也可以直接从 :class:`float` 构造。"

#: ../../library/decimal.rst:590
msgid ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"
msgstr ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"

#: ../../library/decimal.rst:605
msgid ""
"Alternative constructor that only accepts instances of :class:`float`, "
":class:`int` or :class:`Decimal`, but not strings or tuples."
msgstr ""
"另一个构造器，它只接受 :class:`float`, :class:`int` 或 :class:`Decimal` 的实例，但不接受字符串或元组。"

#: ../../library/decimal.rst:609
msgid ""
">>> Decimal.from_number(314)\n"
"Decimal('314')\n"
">>> Decimal.from_number(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_number(Decimal('3.14'))\n"
"Decimal('3.14')"
msgstr ""
">>> Decimal.from_number(314)\n"
"Decimal('314')\n"
">>> Decimal.from_number(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_number(Decimal('3.14'))\n"
"Decimal('3.14')"

#: ../../library/decimal.rst:622
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr "混合乘法加法。 返回 self*other+third ，中间乘积 self*other 没有舍入。"

#: ../../library/decimal.rst:630
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"如果参数是规范的，则为返回 :const:`True`，否则为 :const:`False` 。 目前，:class:`Decimal` "
"实例总是规范的，所以这个操作总是返回 :const:`True` 。"

#: ../../library/decimal.rst:636
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr "如果参数是一个有限的数，则返回为 :const:`True` ；如果参数为无穷大或 NaN ，则返回为 :const:`False`。"

#: ../../library/decimal.rst:641
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity"
" and :const:`False` otherwise."
msgstr "如果参数为正负无穷大，则返回为 :const:`True` ，否则为 :const:`False` 。"

#: ../../library/decimal.rst:646
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and "
":const:`False` otherwise."
msgstr "如果参数为 NaN （无论是否静默），则返回为 :const:`True` ，否则为 :const:`False` 。"

#: ../../library/decimal.rst:651
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return "
":const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"如果参数是一个 *标准的* 有限数则返回 :const:`True`。 如果参数为零、次标准数、无穷大或 NaN 则返回 :const:`False`。"

#: ../../library/decimal.rst:656
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr "如果参数为静默 NaN，返回 :const:`True`，否则返回 :const:`False`。"

#: ../../library/decimal.rst:661
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr "如果参数带有负号，则返回为 :const:`True`，否则返回 :const:`False`。注意，0 和 NaN 都可带有符号。"

#: ../../library/decimal.rst:666
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr "如果参数为显式 NaN，则返回 :const:`True`，否则返回 :const:`False`。"

#: ../../library/decimal.rst:671
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr "如果参数为次标准数，则返回 :const:`True`，否则返回 :const:`False`。"

#: ../../library/decimal.rst:676
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and "
":const:`False` otherwise."
msgstr "如果参数是0（正负皆可），则返回 :const:`True`，否则返回 :const:`False`。"

#: ../../library/decimal.rst:681
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "返回操作数的自然对数（以 e 为底）。结果是使用 :const:`ROUND_HALF_EVEN` 舍入模式正确舍入的。"

#: ../../library/decimal.rst:686
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "返回操作数的以十为底的对数。结果是使用 :const:`ROUND_HALF_EVEN` 舍入模式正确舍入的。"

#: ../../library/decimal.rst:691
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a "
":class:`Decimal` instance.  If the operand is a zero then "
"``Decimal('-Infinity')`` is returned and the :const:`DivisionByZero` flag is"
" raised.  If the operand is an infinity then ``Decimal('Infinity')`` is "
"returned."
msgstr ""
"对于一个非零数，返回其运算数的调整后指数作为一个 :class:`Decimal` 实例。 如果运算数为零将返回 "
"``Decimal('-Infinity')`` 并且产生 the :const:`DivisionByZero` 标志。如果运算数是无限大则返回 "
"``Decimal('Infinity')`` 。"

#: ../../library/decimal.rst:699
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise"
" ``and`` of the two operands."
msgstr ""
":meth:`logical_and` 是需要两个 *逻辑运算数* 的逻辑运算（参考 :ref:`logical_operands_label` "
"）。按位输出两运算数的 ``and`` 运算的结果。"

#: ../../library/decimal.rst:705
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise"
" inversion of the operand."
msgstr ":meth:`logical_invert` 是一个逻辑运算。结果是操作数的按位求反。"

#: ../../library/decimal.rst:710
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands*"
" (see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` "
"of the two operands."
msgstr ""
":meth:`logical_or` 是需要两个 *logical operands* 的逻辑运算（请参阅 "
":ref:`logical_operands_label` ）。结果是两个运算数的按位的 ``or`` 运算。"

#: ../../library/decimal.rst:716
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise"
" exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` 是需要两个 *逻辑运算数* 的逻辑运算（参考 :ref:`logical_operands_label` "
"）。结果是按位输出的两运算数的异或运算。"

#: ../../library/decimal.rst:722
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"类似于 ``max(self, other)`` 只是上下文舍入规则是在返回之前被应用并且对于 ``NaN`` "
"值会发出信号或忽略（依赖于上下文以及它们是否要发送信号或保持静默）。"

#: ../../library/decimal.rst:729
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr "与 :meth:`.max` 方法相似，但是操作数使用绝对值完成比较。"

#: ../../library/decimal.rst:734
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"类似于 ``min(self, other)`` 只是上下文舍入规则是在返回之前被应用并且对于 ``NaN`` "
"值会发出信号或忽略（依赖于上下文以及它们是发出了信号还是保持静默）。"

#: ../../library/decimal.rst:741
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr "与 :meth:`.min` 方法相似，但是操作数使用绝对值完成比较。"

#: ../../library/decimal.rst:746
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr "返回小于给定操作数的上下文中可表示的最大数字（或者当前线程的上下文中的可表示的最大数字如果没有给定上下文）。"

#: ../../library/decimal.rst:752
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr "返回大于给定操作数的上下文中可表示的最小数字（或者当前线程的上下文中的可表示的最小数字如果没有给定上下文）。"

#: ../../library/decimal.rst:758
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"如果两运算数不相等，返回在第二个操作数的方向上最接近第一个操作数的数。如果两操作数数值上相等，返回将符号设置为与第二个运算数相同的第一个运算数的拷贝。"

#: ../../library/decimal.rst:765
msgid ""
"Used for producing canonical values of an equivalence class within either "
"the current context or the specified context."
msgstr "用于在当前上下文或指定上下文中产生等价的类的规范值。"

#: ../../library/decimal.rst:768
msgid ""
"This has the same semantics as the unary plus operation, except that if the "
"final result is finite it is reduced to its simplest form, with all trailing"
" zeros removed and its sign preserved. That is, while the coefficient is "
"non-zero and a multiple of ten the coefficient is divided by ten and the "
"exponent is incremented by 1. Otherwise (the coefficient is zero) the "
"exponent is set to 0. In all cases the sign is unchanged."
msgstr ""
"该操作具有与单目取正值运算相同的语义，区别在于如果最终结果为有限值则将缩减到最简形式，即移除所有末尾的零并保留正负号。 "
"也就是说，当系数为非零值且为十的倍数时则将该系数除以十并将指数加 1。 否则（当系数为零）则将指数设为 0。 在任何情况下正负号都将保持不变。"

#: ../../library/decimal.rst:775
msgid ""
"For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both "
"normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""
"例如，``Decimal('32.100')`` 和 ``Decimal('0.321000e+2')`` 均将标准化为等价的值 "
"``Decimal('32.1')``。"

#: ../../library/decimal.rst:778
msgid "Note that rounding is applied *before* reducing to simplest form."
msgstr "请注意舍入的应用将在缩减到最简形式 *之前* 执行。"

#: ../../library/decimal.rst:780
msgid ""
"In the latest versions of the specification, this operation is also known as"
" ``reduce``."
msgstr "在此规范的最新版本中，该操作也被称为 ``reduce``。"

#: ../../library/decimal.rst:785
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr "返回一个字符串描述运算数的 *class* 。返回值是以下十个字符串中的一个。"

#: ../../library/decimal.rst:788
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"`` ，指示运算数为负无穷大。"

#: ../../library/decimal.rst:789
msgid "``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"`` ，指示该运算数是负正常数字。"

#: ../../library/decimal.rst:790
msgid "``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"`` ，指示该运算数是负的次标准数。"

#: ../../library/decimal.rst:791
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"`` ，指示该运算数是负零。"

#: ../../library/decimal.rst:792
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"-Zero\"`` ，指示该运算数是正零。"

#: ../../library/decimal.rst:793
msgid "``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"`` ，指示该运算数是正的次标准数。"

#: ../../library/decimal.rst:794
msgid "``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"`` ，指示该运算数是正的标准数。"

#: ../../library/decimal.rst:795
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"`` ，指示该运算数是正无穷。"

#: ../../library/decimal.rst:796
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"`` ，指示该运算数是肃静 NaN （非数字）。"

#: ../../library/decimal.rst:797
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"`` ，指示该运算数是信号 NaN 。"

#: ../../library/decimal.rst:801
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr "返回的值等于舍入后的第一个运算数并且具有第二个操作数的指数。"

#: ../../library/decimal.rst:807
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize"
" operation would be greater than precision, then an "
":const:`InvalidOperation` is signaled. This guarantees that, unless there is"
" an error condition, the quantized exponent is always equal to that of the "
"right-hand operand."
msgstr ""
"与其他运算不同，如果量化运算后的系数长度大于精度，那么会发出一个 :const:`InvalidOperation` "
"信号。这保证了除非有一个错误情况，量化指数恒等于右手运算数的指数。"

#: ../../library/decimal.rst:813
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr "与其他运算不同，量化永不信号下溢，即使结果不正常且不精确。"

#: ../../library/decimal.rst:816
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by"
" the ``rounding`` argument if given, else by the given ``context`` argument;"
" if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"如果第二个运算数的指数大于第一个运算数的指数那或许需要舍入。在这种情况下，舍入模式由给定 ``rounding`` 参数决定，其余的由给定 "
"``context`` 参数决定；如果参数都未给定，使用当前线程上下文的舍入模式。"

#: ../../library/decimal.rst:822
msgid ""
"An error is returned whenever the resulting exponent is greater than "
":attr:`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr "每当结果的指数大于 :attr:`~Context.Emax` 或小于 :meth:`~Context.Etiny` 就将返回一个错误。"

#: ../../library/decimal.rst:827
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class"
" does all its arithmetic.  Included for compatibility with the "
"specification."
msgstr ""
"返回 ``Decimal(10)``，即 :class:`Decimal` 类进行所有算术运算所用的数制（基数）。 "
"这是为保持与规范描述的兼容性而加入的。"

#: ../../library/decimal.rst:833
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n"
" * other`` where ``n`` is the integer nearest to the exact value of ``self /"
" other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"返回 *self* 除以 *other* 的余数。 这与 ``self % other`` 的区别在于所选择的余数要使其绝对值最小化。 "
"更准确地说，返回值为 ``self - n * other`` 其中 ``n`` 是最接近 ``self / other`` "
"的实际值的整数，并且如果两个整数与实际值的差相等则会选择其中的偶数。"

#: ../../library/decimal.rst:840
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "如果结果为零则其符号将为 *self* 的符号。"

#: ../../library/decimal.rst:851
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"返回对第一个操作数的数码按第二个操作数所指定的数量进行轮转的结果。 第二个操作数必须为 -precision 至 precision 精度范围内的整数。"
" 第二个操作数的绝对值给出要轮转的位数。 如果第二个操作数为正值则向左轮转；否则向右轮转。 如有必要第一个操作数的系数会在左侧填充零以达到 "
"precision 所指定的长度。 第一个操作数的符号和指数保持不变。"

#: ../../library/decimal.rst:862
msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr "检测自身与 other 是否具有相同的指数或是否均为 ``NaN``。"

#: ../../library/decimal.rst:871
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently,"
" return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"返回第一个操作数使用第二个操作数对指数进行调整的结果。 等价于返回第一个操作数乘以 ``10**other`` 的结果。 第二个操作数必须为整数。"

#: ../../library/decimal.rst:877
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the right."
"  Digits shifted into the coefficient are zeros.  The sign and exponent of "
"the first operand are unchanged."
msgstr ""
"返回第一个操作数的数码按第二个操作数所指定的数量进行移位的结果。 第二个操作数必须为 -precision 至 precision 范围内的整数。 "
"第二个操作数的绝对值给出要移动的位数。 如果第二个操作数为正值则向左移位；否则向右移位。 移入系数的数码为零。 第一个操作数的符号和指数保持不变。"

#: ../../library/decimal.rst:887
msgid "Return the square root of the argument to full precision."
msgstr "返回参数的平方根精确到完整精度。"

#: ../../library/decimal.rst:892 ../../library/decimal.rst:1549
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr "转换为字符串，如果需要指数则会使用工程标注法。"

#: ../../library/decimal.rst:894 ../../library/decimal.rst:1551
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr "工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。"

#: ../../library/decimal.rst:898
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr "例如，此方法会将 ``Decimal('123E+1')`` 转换为 ``Decimal('1.23E+3')``。"

#: ../../library/decimal.rst:902
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name"
" has been kept for compatibility with older versions."
msgstr "与 :meth:`to_integral_value` 方法相同。 保留 ``to_integral`` 名称是为了与旧版本兼容。"

#: ../../library/decimal.rst:907
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded`"
" as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"舍入到最接近的整数，发出信号 :const:`Inexact` 或者如果发生舍入则相应地发出信号 :const:`Rounded`。 如果给出 "
"``rounding`` 形参则由其确定舍入模式，否则由给定的 ``context`` 来确定。 如果没有给定任何形参则会使用当前上下文的舍入模式。"

#: ../../library/decimal.rst:915
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or "
":const:`Rounded`.  If given, applies *rounding*; otherwise, uses the "
"rounding method in either the supplied *context* or the current context."
msgstr ""
"舍入到最接近的整数而不发出 :const:`Inexact` 或 :const:`Rounded` 信号。 如果给出 *rounding* "
"则会应用其所指定的舍入模式；否则使用所提供的 *context* 或当前上下文的舍入方法。"

#: ../../library/decimal.rst:919
msgid "Decimal numbers can be rounded using the :func:`.round` function:"
msgstr "可以使用 :func:`.round` 函数对 Decimal 数字执行舍入："

#: ../../library/decimal.rst:924
msgid ""
"If *ndigits* is not given or ``None``, returns the nearest :class:`int` to "
"*number*, rounding ties to even, and ignoring the rounding mode of the "
":class:`Decimal` context.  Raises :exc:`OverflowError` if *number* is an "
"infinity or :exc:`ValueError` if it is a (quiet or signaling) NaN."
msgstr ""
"如果 *ndigits* 未给出或为 ``None``，则返回最接近 *number* 的 :class:`int`，同样接近时向偶数舍入，并忽略 "
":class:`Decimal` 上下文的舍入模式。 如果 *number* 为无穷大则引发 :exc:`OverflowError` "
"或者如果为（静默或有信号）NaN 则引发 :exc:`ValueError`。"

#: ../../library/decimal.rst:930
msgid ""
"If *ndigits* is an :class:`int`, the context's rounding mode is respected "
"and a :class:`Decimal` representing *number* rounded to the nearest multiple"
" of ``Decimal('1E-ndigits')`` is returned; in this case, ``round(number, "
"ndigits)`` is equivalent to ``self.quantize(Decimal('1E-ndigits'))``.  "
"Returns ``Decimal('NaN')`` if *number* is a quiet NaN.  Raises "
":class:`InvalidOperation` if *number* is an infinity, a signaling NaN, or if"
" the length of the coefficient after the quantize operation would be greater"
" than the current context's precision.  In other words, for the non-corner "
"cases:"
msgstr ""
"如果 *ndigits* 是一个 :class:`int`，则将遵循上下文的舍入模式并返回代表 *number* 的舍入到最接近 "
"``Decimal('1E-ndigits')`` 的倍数的 :class:`Decimal`；在此情况下，``round(number, "
"ndigits)`` 等价于 ``self.quantize(Decimal('1E-ndigits'))``。 如果 *number* 是一个静默 "
"NaN 则返回 ``Decimal('NaN')``。 如果 *number* 为无穷大、有信号 "
"NaN，或者如果量化操作后的系数长度大于当前上下文的精度则会引发 :class:`InvalidOperation`。 换句话说，对于非边际情况："

#: ../../library/decimal.rst:940
msgid ""
"if *ndigits* is positive, return *number* rounded to *ndigits* decimal "
"places;"
msgstr "如果 *ndigits* 为正值，则返回 *number* 舍入到 *ndigits* 个十进制数位的结果；"

#: ../../library/decimal.rst:942
msgid "if *ndigits* is zero, return *number* rounded to the nearest integer;"
msgstr "如果 *ndigits* 为零，则返回 *number* 舍入到最接近整数的结果；"

#: ../../library/decimal.rst:943
msgid ""
"if *ndigits* is negative, return *number* rounded to the nearest multiple of"
" ``10**abs(ndigits)``."
msgstr "如果 *ndigits* 为负值，则返回 *number* 舍入到最接近 ``10**abs(ndigits)`` 的倍数的结果。"

#: ../../library/decimal.rst:946
msgid "For example::"
msgstr "例如::"

#: ../../library/decimal.rst:948
msgid ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # context rounding ignored\n"
"4\n"
">>> round(Decimal('3.5'))      # round-ties-to-even\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # uses the context rounding\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"
msgstr ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # 上下文舍入设置将被忽略\n"
"4\n"
">>> round(Decimal('3.5'))      # 两边相等则舍入到偶数\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # 使用上下文舍入设置\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"

#: ../../library/decimal.rst:965
msgid "Logical operands"
msgstr "逻辑操作数"

#: ../../library/decimal.rst:967
msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, "
":meth:`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods expect"
" their arguments to be *logical operands*.  A *logical operand* is a "
":class:`Decimal` instance whose exponent and sign are both zero, and whose "
"digits are all either ``0`` or ``1``."
msgstr ""
":meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, "
":meth:`~Decimal.logical_or` 和 :meth:`~Decimal.logical_xor` 方法均期望其参数为 "
"*逻辑操作数*。 *逻辑操作数* 即指数位和符号位均为零，且其数字位均为 ``0`` 或 ``1`` 的 :class:`Decimal` 实例。"

#: ../../library/decimal.rst:979
msgid "Context objects"
msgstr "上下文对象"

#: ../../library/decimal.rst:981
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision,"
" set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr "上下文是算术运算所在的环境。 它们管理精度、设置舍入规则、确定将哪些信号视为异常，并限制指数的范围。"

#: ../../library/decimal.rst:985
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr "每个线程都有自己的当前上下文，可使用 :func:`getcontext` 和 :func:`setcontext` 函数来读取或修改："

#: ../../library/decimal.rst:991
msgid "Return the current context for the active thread."
msgstr "返回活动线程的当前上下文。"

#: ../../library/decimal.rst:996
msgid "Set the current context for the active thread to *c*."
msgstr "将活动线程的当前上下文设为 *c*。"

#: ../../library/decimal.rst:998
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr "你也可以使用 :keyword:`with` 语句和 :func:`localcontext` 函数来临时改变活动上下文。"

#: ../../library/decimal.rst:1003
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument is "
"used to set the attributes of the new context."
msgstr ""
"返回一个将在进入 with 语句时将活动线程的上下文设为 *ctx* 的一个副本并在退出该 with 语句时恢复之前上下文的上下文管理器。 "
"如果未指定上下文，则会使用当前上下文的一个副本。 *kwargs* 参数将被用来设置新上下文的属性。"

#: ../../library/decimal.rst:1009
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous"
" context::"
msgstr "例如，以下代码会将当前 decimal 精度设为 42 位，执行一个运算，然后自动恢复之前的上下文::"

#: ../../library/decimal.rst:1012
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Perform a high precision calculation\n"
"    s = calculate_something()\n"
"s = +s  # Round the final result back to the default precision"
msgstr ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # 执行高精度的运算\n"
"    s = calculate_something()\n"
"s = +s  # 将最终结果舍入到默认精度"

#: ../../library/decimal.rst:1019
msgid "Using keyword arguments, the code would be the following::"
msgstr "使用关键字参数，代码将如下所示::"

#: ../../library/decimal.rst:1021
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"
msgstr ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"

#: ../../library/decimal.rst:1027
msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that "
":class:`Context` doesn't support.  Raises either :exc:`TypeError` or "
":exc:`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""
"如果 *kwargs* 提供了 :class:`Context` 所不支持的属性则会引发 :exc:`TypeError`。 如果 *kwargs* "
"提供了无效的属性值则会引发 :exc:`TypeError` 或 :exc:`ValueError`。"

#: ../../library/decimal.rst:1031
msgid ""
":meth:`localcontext` now supports setting context attributes through the use"
" of keyword arguments."
msgstr ":meth:`localcontext` 现在支持通过使用关键字参数来设置上下文属性。"

#: ../../library/decimal.rst:1036
msgid ""
"Return a context object initialized to the proper values for one of the IEEE"
" interchange formats.  The argument must be a multiple of 32 and less than "
":const:`IEEE_CONTEXT_MAX_BITS`."
msgstr ""
"返回一个初始化为 IEEE 交换格式之一的正确值的上下文对象。 参数必须是 32 的倍数且小于 "
":const:`IEEE_CONTEXT_MAX_BITS`。"

#: ../../library/decimal.rst:1042
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr "新的上下文也可使用下述的 :class:`Context` 构造器来创建。 此外，模块还提供了三种预设的上下文:"

#: ../../library/decimal.rst:1048
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled "
"(treated as exceptions) except :const:`Inexact`, :const:`Rounded`, and "
":const:`Subnormal`."
msgstr ""
"这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 :const:`ROUND_HALF_UP`。 清除所有旗标。 "
"启用所有陷阱（视为异常），但 :const:`Inexact`, :const:`Rounded` 和 :const:`Subnormal` 除外。"

#: ../../library/decimal.rst:1054
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr "由于启用了许多陷阱，此上下文适用于进行调试。"

#: ../../library/decimal.rst:1059
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so "
"that exceptions are not raised during computations)."
msgstr ""
"这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 :const:`ROUND_HALF_EVEN`。 清除所有旗标。 "
"不启用任何陷阱（因此在计算期间不会引发异常）。"

#: ../../library/decimal.rst:1064
msgid ""
"Because the traps are disabled, this context is useful for applications that"
" prefer to have result value of ``NaN`` or ``Infinity`` instead of raising "
"exceptions.  This allows an application to complete a run in the presence of"
" conditions that would otherwise halt the program."
msgstr ""
"由于禁用了陷阱，此上下文适用于希望结果值为 ``NaN`` 或 ``Infinity`` 而不是引发异常的应用程序。 "
"这允许应用程序在出现当其他情况下会中止程序的条件时仍能完成运行。"

#: ../../library/decimal.rst:1072
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"此上下文被 :class:`Context` 构造器用作新上下文的原型。 改变一个字段（例如精度）的效果将是改变 :class:`Context` "
"构造器所创建的新上下文的默认值。"

#: ../../library/decimal.rst:1076
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of"
" the fields before threads are started has the effect of setting system-wide"
" defaults.  Changing the fields after threads have started is not "
"recommended as it would require thread synchronization to prevent race "
"conditions."
msgstr ""
"此上下文最适用于多线程环境。 在线程开始前改变一个字段具有设置全系统默认值的效果。 不推荐在线程开始后改变字段，因为这会要求线程同步避免竞争条件。"

#: ../../library/decimal.rst:1081
msgid ""
"In single threaded environments, it is preferable to not use this context at"
" all.  Instead, simply create contexts explicitly as described below."
msgstr "在单线程环境中，最好完全不使用此上下文。 而是简单地电显式创建上下文，具体如下所述。"

#: ../../library/decimal.rst:1084
msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, "
":attr:`Context.rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled traps "
"for :class:`Overflow`, :class:`InvalidOperation`, and "
":class:`DivisionByZero`."
msgstr ""
"默认值为 :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context.rounding`\\ =\\ "
":const:`ROUND_HALF_EVEN`，并为 :class:`Overflow`, :class:`InvalidOperation` 和 "
":class:`DivisionByZero` 启用陷阱。"

#: ../../library/decimal.rst:1089
msgid ""
"In addition to the three supplied contexts, new contexts can be created with"
" the :class:`Context` constructor."
msgstr "在已提供的三种上下文之外，还可以使用 :class:`Context` 构造器创建新的上下文。"

#: ../../library/decimal.rst:1095
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the"
" default values are copied from the :const:`DefaultContext`.  If the *flags*"
" field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"创建一个新上下文。 如果某个字段未指定或为 :const:`None`，则从 :const:`DefaultContext` 拷贝默认值。 如果 "
"*flags* 字段未指定或为 :const:`None`，则清空所有旗标。"

#: ../../library/decimal.rst:1101
msgid ""
"An integer in the range [``1``, :const:`MAX_PREC`] that sets the precision "
"for arithmetic operations in the context."
msgstr "一个 [``1``, :const:`MAX_PREC`] 范围内的整数，用于设置上下文中算术运算符的精度。"

#: ../../library/decimal.rst:1106
msgid "One of the constants listed in the section `Rounding Modes`_."
msgstr "在 `Rounding Modes`_ 小节中列出的常量之一。"

#: ../../library/decimal.rst:1111
msgid ""
"Lists of any signals to be set. Generally, new contexts should only set "
"traps and leave the flags clear."
msgstr "由要设置的任何信号组成的列表。 通常，新上下文应当只设置 traps 而让 flags 为空。"

#: ../../library/decimal.rst:1117
msgid ""
"Integers specifying the outer limits allowable for exponents. *Emin* must be"
" in the range [:const:`MIN_EMIN`, ``0``], *Emax* in the range [``0``, "
":const:`MAX_EMAX`]."
msgstr ""
"指明指数所允许的外部上限的整数。 *Emin* 必须在 [:const:`MIN_EMIN`, ``0``] 范围内，*Emax* 必须在 "
"[``0``, :const:`MAX_EMAX`] 范围内。"

#: ../../library/decimal.rst:1123
msgid ""
"Either ``0`` or ``1`` (the default). If set to ``1``, exponents are printed "
"with a capital ``E``; otherwise, a lowercase ``e`` is used: "
"``Decimal('6.02e+23')``."
msgstr ""
"值为 ``0`` 或 ``1`` (默认值)。 如果设为 ``1``，打印指数时将附带一个大写的 ``E``；在其他情况下，将使用小写的 ``e``: "
"``Decimal('6.02e+23')``。"

#: ../../library/decimal.rst:1129
msgid ""
"Either ``0`` (the default) or ``1``.  If set to ``1``, the exponent ``e`` of"
" a :class:`Decimal` instance representable in this context is strictly "
"limited to the range ``Emin - prec + 1 <= e <= Emax - prec + 1``. If *clamp*"
" is ``0`` then a weaker condition holds: the adjusted exponent of the "
":class:`Decimal` instance is at most :attr:`~Context.Emax`.  When *clamp* is"
" ``1``, a large normal number will, where possible, have its exponent "
"reduced and a corresponding number of zeros added to its coefficient, in "
"order to fit the exponent constraints; this preserves the value of the "
"number but loses information about significant trailing zeros.  For "
"example::"
msgstr ""
"值为 ``0`` (默认值) 或 ``1``。 如果设为 ``1``，则 :class:`Decimal` 实例的指数 ``e`` "
"在此上下文中将严格限制表示范围在 ``Emin - prec + 1 <= e <= Emax - prec + 1`` 之内。 如果 *clamp* "
"为 ``0`` 则将适用较弱的条件：调整后的 :class:`Decimal` 实例指数最大值为 :attr:`~Context.Emax`。 当 "
"*clamp* 为 ``1`` "
"时，一个很大的普通数值将在可能的情况下减小其指数并为其系数添加相应数量的零，以便符合指数值范围的限制；这可以保持数字值但会丢失有效末尾零的信息。 "
"例如::"

#: ../../library/decimal.rst:1140
msgid ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"
msgstr ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"

#: ../../library/decimal.rst:1143
msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width decimal "
"interchange formats specified in IEEE 754."
msgstr "将 *clamp* 值设为 ``1`` 即允许与 IEEE 754 所描述的固定宽度十进制交换格式保持兼容性。"

#: ../../library/decimal.rst:1146
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`~Decimal.adjusted` and "
":meth:`~Decimal.as_tuple` methods) there is a corresponding :class:`Context`"
" method.  For example, for a :class:`Context` instance ``C`` and "
":class:`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to "
"``x.exp(context=C)``.  Each :class:`Context` method accepts a Python integer"
" (an instance of :class:`int`) anywhere that a Decimal instance is accepted."
msgstr ""
":class:`Context` 类定义了几种通用方法以及大量直接在给定上下文中进行算术运算的方法。 此外，对于上述的每种 "
":class:`Decimal` 方法（除了 :meth:`~Decimal.adjusted` 和 :meth:`~Decimal.as_tuple`"
" 方法）都有一个对应的 :class:`Context` 方法。 例如，对于一个 :class:`Context` 的实例 ``C`` 和 "
":class:`Decimal` 的实例 ``x``，``C.exp(x)`` 就等价于 ``x.exp(context=C)``。 每个 "
":class:`Context` 方法都接受一个 Python 整数（即 :class:`int` 的实例）在任何接受 Decimal 实例的地方使用。"

#: ../../library/decimal.rst:1159
msgid "Resets all of the flags to ``0``."
msgstr "将所有旗标重置为 ``0``。"

#: ../../library/decimal.rst:1163
msgid "Resets all of the traps to ``0``."
msgstr "将所有陷阱重置为 ``0``。"

#: ../../library/decimal.rst:1169
msgid "Return a duplicate of the context."
msgstr "返回上下文的一个副本。"

#: ../../library/decimal.rst:1173
msgid "Return a copy of the Decimal instance num."
msgstr "返回 Decimal 实例 num 的一个副本。"

#: ../../library/decimal.rst:1177
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"基于 *num* 创建一个新 Decimal 实例但使用 *self* 作为上下文。 与 :class:`Decimal` "
"构造器不同，该上下文的精度、舍入方法、旗标和陷阱会被应用于转换过程。"

#: ../../library/decimal.rst:1181
msgid ""
"This is useful because constants are often given to a greater precision than"
" is needed by the application.  Another benefit is that rounding immediately"
" eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"此方法很有用处，因为常量往往被给予高于应用所需的精度。 另一个好处在于立即执行舍入可以消除超出当前精度的数位所导致的意外效果。 "
"在下面的示例中，使用未舍入的输入意味着在总和中添加零会改变结果："

#: ../../library/decimal.rst:1187
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"

#: ../../library/decimal.rst:1195
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr "此方法实现了 IBM 规格描述中的转换为数字操作。 如果参数为字符串，则不允许有开头或末尾的空格或下划线。"

#: ../../library/decimal.rst:1201
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as"
" the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"基于浮点数 *f* 创建一个新的 Decimal 实例，但会使用 *self* 作为上下文来执行舍入。 与 "
":meth:`Decimal.from_float` 类方法不同，上下文的精度、舍入方法、旗标和陷阱会应用到转换中。"

#: ../../library/decimal.rst:1206
msgid ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"
msgstr ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"

#: ../../library/decimal.rst:1221
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to "
":const:`Etiny`."
msgstr ""
"返回一个等于 ``Emin - prec + 1`` 的值即次标准化结果中的最小指数值。 当发生向下溢出时，指数会设为 :const:`Etiny`。"

#: ../../library/decimal.rst:1227
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "返回一个等于 ``Emax - prec + 1`` 的值。"

#: ../../library/decimal.rst:1229
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"使用 decimal 的通常方式是创建 :class:`Decimal` 实例然后对其应用算术运算,这些运算发生在活动线程的当前上下文中。 "
"一种替代方式则是使用上下文的方法在特定上下文中进行计算。 这些方法类似于 :class:`Decimal` 类的方法，在此仅简单地重新列出。"

#: ../../library/decimal.rst:1239
msgid "Returns the absolute value of *x*."
msgstr "返回 *x* 的绝对值。"

#: ../../library/decimal.rst:1244
msgid "Return the sum of *x* and *y*."
msgstr "返回 *x* 与 *y* 的和。"

#: ../../library/decimal.rst:1249
msgid "Returns the same Decimal object *x*."
msgstr "返回相同的 Decimal 对象 *x*。"

#: ../../library/decimal.rst:1254
msgid "Compares *x* and *y* numerically."
msgstr "对 *x* 与 *y* 进行数值比较。"

#: ../../library/decimal.rst:1259
msgid "Compares the values of the two operands numerically."
msgstr "对两个操作数进行数值比较。"

#: ../../library/decimal.rst:1264
msgid "Compares two operands using their abstract representation."
msgstr "对两个操作数使用其抽象表示进行比较。"

#: ../../library/decimal.rst:1269
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr "对两个操作数使用其抽象表示进行比较，忽略符号。"

#: ../../library/decimal.rst:1274
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "返回 *x* 的副本，符号设为 0。"

#: ../../library/decimal.rst:1279
msgid "Returns a copy of *x* with the sign inverted."
msgstr "返回 *x* 的副本，符号取反。"

#: ../../library/decimal.rst:1284
msgid "Copies the sign from *y* to *x*."
msgstr "从 *y* 拷贝符号至 *x*。"

#: ../../library/decimal.rst:1289
msgid "Return *x* divided by *y*."
msgstr "返回 *x* 除以 *y* 的结果。"

#: ../../library/decimal.rst:1294
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "返回 *x* 除以 *y* 的结果，截短为整数。"

#: ../../library/decimal.rst:1299
msgid "Divides two numbers and returns the integer part of the result."
msgstr "两个数字相除并返回结果的整数部分。"

#: ../../library/decimal.rst:1304
msgid "Returns ``e ** x``."
msgstr "返回 ``e ** x``。"

#: ../../library/decimal.rst:1309
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "返回 *x* 乘以 *y* 再加 *z* 的结果。"

#: ../../library/decimal.rst:1314
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "如果 *x* 是规范的则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1319
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "如果 *x* 为有限的则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1324
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "如果 *x* 是无限的则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1329
msgid ""
"Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr "如果 *x* 是 qNaN 或 sNaN 则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1334
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr "如果 *x* 是标准数则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1339
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr "如果 *x* 是静默 NaN 则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1344
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "*x* 是负数则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1349
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr "如果 *x* 是显式 NaN 则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1354
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr "如果 *x* 是次标准数则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1359
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "如果 *x* 为零则返回 ``True``；否则返回 ``False``。"

#: ../../library/decimal.rst:1364
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "返回 *x* 的自然对数（以 e 为底）。"

#: ../../library/decimal.rst:1369
msgid "Returns the base 10 logarithm of *x*."
msgstr "返回 *x* 的以 10 为底的对数。"

#: ../../library/decimal.rst:1374
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "返回操作数的 MSD 等级的指数。"

#: ../../library/decimal.rst:1379
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "在操作数的每个数位间应用逻辑运算 *and*。"

#: ../../library/decimal.rst:1384
msgid "Invert all the digits in *x*."
msgstr "反转 *x* 中的所有数位。"

#: ../../library/decimal.rst:1389
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "在操作数的每个数位间应用逻辑运算 *or*。"

#: ../../library/decimal.rst:1394
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "在操作数的每个数位间应用逻辑运算 *xor*。"

#: ../../library/decimal.rst:1399
msgid "Compares two values numerically and returns the maximum."
msgstr "对两个值执行数字比较并返回其中的最大值。"

#: ../../library/decimal.rst:1404 ../../library/decimal.rst:1414
msgid "Compares the values numerically with their sign ignored."
msgstr "对两个值执行忽略正负号的数字比较。"

#: ../../library/decimal.rst:1409
msgid "Compares two values numerically and returns the minimum."
msgstr "对两个值执行数字比较并返回其中的最小值。"

#: ../../library/decimal.rst:1419
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "对应于 Python 中的单目前缀取负运算符执行取负操作。"

#: ../../library/decimal.rst:1424
msgid "Return the product of *x* and *y*."
msgstr "返回 *x* 和 *y* 的积。"

#: ../../library/decimal.rst:1429
msgid "Returns the largest representable number smaller than *x*."
msgstr "返回小于 *x* 的最大数字表示形式。"

#: ../../library/decimal.rst:1434
msgid "Returns the smallest representable number larger than *x*."
msgstr "返回大于 *x* 的最小数字表示形式。"

#: ../../library/decimal.rst:1439
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "返回 *x* 趋向于 *y* 的最接近的数字。"

#: ../../library/decimal.rst:1444
msgid "Reduces *x* to its simplest form."
msgstr "将 *x* 改写为最简形式。"

#: ../../library/decimal.rst:1449
msgid "Returns an indication of the class of *x*."
msgstr "返回 *x* 的类的表示。"

#: ../../library/decimal.rst:1454
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr "对应于 Python 中的单目前缀取正运算符执行取正操作。 此操作将应用上下文精度和舍入，因此它 *不是* 标识运算。"

#: ../../library/decimal.rst:1461
msgid ""
"Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr "返回 ``x`` 的 ``y`` 次方，如果给出了模数 ``modulo`` 则取其余数。"

#: ../../library/decimal.rst:1463
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""
"传入两个参数时，计算 ``x**y``。 如果 ``x`` 为负值则 ``y`` 必须为整数。 除非 ``y`` 为整数且结果为有限值并可在 "
"'precision' 位内精确表示否则结果将是不精确的。 所在上下文的舍入模式将被使用。 结果在 Python 版中总是会被正确地舍入。"

#: ../../library/decimal.rst:1469
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` 结果为 ``InvalidOperation``，而如果 "
"``InvalidOperation`` 未被捕获，则结果为 ``Decimal('NaN')``。"

#: ../../library/decimal.rst:1472
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded "
":meth:`exp` and :meth:`ln` functions. The result is well-defined but only "
"\"almost always correctly rounded\"."
msgstr ""
"C 模块计算 :meth:`power` 时会使用已正确舍入的 :meth:`exp` 和 :meth:`ln` 函数。 "
"结果是有良好定义的但仅限于“几乎总是正确舍入”。"

#: ../../library/decimal.rst:1477
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr "带有三个参数时，计算 ``(x**y) % modulo``。 对于三个参数的形式，参数将会应用以下限制："

#: ../../library/decimal.rst:1480
msgid "all three arguments must be integral"
msgstr "三个参数必须都是整数"

#: ../../library/decimal.rst:1481
msgid "``y`` must be nonnegative"
msgstr "``y`` 必须是非负数"

#: ../../library/decimal.rst:1482
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "``x`` 或 ``y`` 至少有一个不为零"

#: ../../library/decimal.rst:1483
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` 必须不为零且至多有 'precision' 位"

#: ../../library/decimal.rst:1485
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded"
" precision, but is computed more efficiently.  The exponent of the result is"
" zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"来自 ``Context.power(x, y, modulo)`` 的结果值等于使用无限精度计算 ``(x**y) % modulo`` "
"所得到的值，但其计算过程更高效。 结果的指数为零，无论 ``x``, ``y`` 和 ``modulo`` 的指数是多少。 结果值总是完全精确的。"

#: ../../library/decimal.rst:1495
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "返回的值等于 *x* (舍入后)，并且指数为 *y*。"

#: ../../library/decimal.rst:1500
msgid "Just returns 10, as this is Decimal, :)"
msgstr "恰好返回 10，因为这是 Decimal 对象 :)"

#: ../../library/decimal.rst:1505
msgid "Returns the remainder from integer division."
msgstr "返回整除所得到的余数。"

#: ../../library/decimal.rst:1507
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr "结果的符号，如果不为零，则与原始除数的符号相同。"

#: ../../library/decimal.rst:1513
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"返回 ``x - y * n``，其中 *n* 为最接近 ``x / y`` 实际值的整数（如结果为 0 则其符号将与 *x* 的符号相同）。"

#: ../../library/decimal.rst:1519
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "返回 *x* 翻转 *y* 次的副本。"

#: ../../library/decimal.rst:1524
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "如果两个操作数具有相同的指数则返回 ``True``。"

#: ../../library/decimal.rst:1529
msgid "Returns the first operand after adding the second value its exp."
msgstr "返回第一个操作数添加第二个值的指数后的结果。"

#: ../../library/decimal.rst:1534
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "返回 *x* 变换 *y* 次的副本。"

#: ../../library/decimal.rst:1539
msgid "Square root of a non-negative number to context precision."
msgstr "非负数基于上下文精度的平方根。"

#: ../../library/decimal.rst:1544
msgid "Return the difference between *x* and *y*."
msgstr "返回 *x* 和 *y* 的差。"

#: ../../library/decimal.rst:1558
msgid "Rounds to an integer."
msgstr "舍入到一个整数。"

#: ../../library/decimal.rst:1563
msgid "Converts a number to a string using scientific notation."
msgstr "使用科学计数法将一个数字转换为字符串。"

#: ../../library/decimal.rst:1570
msgid "Constants"
msgstr "常量"

#: ../../library/decimal.rst:1572
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr "本节中的常量仅与 C 模块相关。 它们也被包含在纯 Python 版本以保持兼容性。"

#: ../../library/decimal.rst:1576
msgid "32-bit"
msgstr "32位"

#: ../../library/decimal.rst:1576
msgid "64-bit"
msgstr "64位"

#: ../../library/decimal.rst:1578 ../../library/decimal.rst:1580
msgid "``425000000``"
msgstr "``425000000``"

#: ../../library/decimal.rst:1578 ../../library/decimal.rst:1580
msgid "``999999999999999999``"
msgstr "``999999999999999999``"

#: ../../library/decimal.rst:1582
msgid "``-425000000``"
msgstr "``-425000000``"

#: ../../library/decimal.rst:1582
msgid "``-999999999999999999``"
msgstr "``-999999999999999999``"

#: ../../library/decimal.rst:1584
msgid "``-849999999``"
msgstr "``-849999999``"

#: ../../library/decimal.rst:1584
msgid "``-1999999999999999997``"
msgstr "``-1999999999999999997``"

#: ../../library/decimal.rst:1586
msgid "``256``"
msgstr "``256``"

#: ../../library/decimal.rst:1586
msgid "``512``"
msgstr "``512``"

#: ../../library/decimal.rst:1591
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr "该值为 ``True``。 已弃用，因为 Python 现在总是启用线程。"

#: ../../library/decimal.rst:1597
msgid ""
"The default value is ``True``. If Python is :option:`configured using the "
"--without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"默认值为 ``True``。 如果 Python 编译版本 :option:`使用了 --without-decimal-contextvar "
"选项来配置 <--without-decimal-contextvar>`，则 C 版本会使用线程局部而非协程局部上下文并且该值为 ``False``。"
" 这在某些嵌套上下文场景中将会稍快一些。"

#: ../../library/decimal.rst:1606
msgid "Rounding modes"
msgstr "舍入模式"

#: ../../library/decimal.rst:1610
msgid "Round towards ``Infinity``."
msgstr "舍入方向为 ``Infinity``。"

#: ../../library/decimal.rst:1614
msgid "Round towards zero."
msgstr "舍入方向为零。"

#: ../../library/decimal.rst:1618
msgid "Round towards ``-Infinity``."
msgstr "舍入方向为 ``-Infinity``。"

#: ../../library/decimal.rst:1622
msgid "Round to nearest with ties going towards zero."
msgstr "舍入到最接近的数，同样接近则舍入方向为零。"

#: ../../library/decimal.rst:1626
msgid "Round to nearest with ties going to nearest even integer."
msgstr "舍入到最接近的数，同样接近则舍入到最接近的偶数。"

#: ../../library/decimal.rst:1630
msgid "Round to nearest with ties going away from zero."
msgstr "舍入到最接近的数，同样接近则舍入到零的反方向。"

#: ../../library/decimal.rst:1634
msgid "Round away from zero."
msgstr "舍入到零的反方向。"

#: ../../library/decimal.rst:1638
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr "如果最后一位朝零的方向舍入后为 0 或 5 则舍入到零的反方向；否则舍入方向为零。"

#: ../../library/decimal.rst:1645
msgid "Signals"
msgstr "信号"

#: ../../library/decimal.rst:1647
msgid ""
"Signals represent conditions that arise during computation. Each corresponds"
" to one context flag and one context trap enabler."
msgstr "信号代表在计算期间引发的条件。 每个信号对应于一个上下文旗标和一个上下文陷阱启用器。"

#: ../../library/decimal.rst:1650
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"上下文旗标将在遇到特定条件时被设定。 在完成计算之后，将为了获得信息而检测旗标（例如确定计算是否精确）。 "
"在检测旗标后，请确保在开始下一次计算之前清除所有旗标。"

#: ../../library/decimal.rst:1655
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the "
":class:`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception "
"is raised upon encountering the condition."
msgstr ""
"如果为信号设定了上下文的陷阱启用器，则条件会导致特定的 Python 异常被引发。 举例来说，如果设定了 :class:`DivisionByZero`"
" 陷阱，则当遇到此条件时就将引发 :exc:`DivisionByZero` 异常。"

#: ../../library/decimal.rst:1663
msgid "Altered an exponent to fit representation constraints."
msgstr "修改一个指数以符合表示限制。"

#: ../../library/decimal.rst:1665
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's "
":attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the "
"exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"通常，限位将在一个指数值超出上下文的 :attr:`~Context.Emin` 和 :attr:`~Context.Emax` 限制时发生。 "
"在可能的情况下，会通过向系数添加零来将指数缩减至符合限制。"

#: ../../library/decimal.rst:1672
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "其他信号的基类，并且也是 :exc:`ArithmeticError` 的一个子类。"

#: ../../library/decimal.rst:1677
msgid "Signals the division of a non-infinite number by zero."
msgstr "非无限数被零除的信号。"

#: ../../library/decimal.rst:1679
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or "
"``-Infinity`` with the sign determined by the inputs to the calculation."
msgstr ""
"可在除法、取余除法或对一个数执行负数次幂运算时发生。 如果此信号未被陷阱捕获，则返回 ``Infinity`` 或 ``-Infinity`` "
"并由对计算的输入来确定正负符号。"

#: ../../library/decimal.rst:1686
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "表明发生了舍入且结果是不精确的。"

#: ../../library/decimal.rst:1688
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr "有非零数位在舍入期间被丢弃的信号。 舍入结果将被返回。 此信号旗标或陷阱被用于检测结果不精确的情况。"

#: ../../library/decimal.rst:1695
msgid "An invalid operation was performed."
msgstr "执行了一个无效的操作。"

#: ../../library/decimal.rst:1697
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns ``NaN``.  Possible causes include::"
msgstr "表明请求了一个无意义的运算。 如果未被捕获，则返回 ``NaN``。 可能的原因包括::"

#: ../../library/decimal.rst:1700
msgid ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"
msgstr ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"

#: ../../library/decimal.rst:1713
msgid "Numerical overflow."
msgstr "数值的溢出。"

#: ../../library/decimal.rst:1715
msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding "
"has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or rounding"
" outward to ``Infinity``.  In either case, :class:`Inexact` and "
":class:`Rounded` are also signaled."
msgstr ""
"表明在发生舍入之后指数值大于 :attr:`Context.Emax`。 "
"如果未被捕获，则结果将取决于舍入模式，或是向下舍入为最大的可表示有限数值，或是向上舍入为 ``Infinity``。 无论是哪种情况，都将发出 "
":class:`Inexact` 和 :class:`Rounded` 信号。"

#: ../../library/decimal.rst:1724
msgid "Rounding occurred though possibly no information was lost."
msgstr "发生了舍入，但或许并没有信息丢失。"

#: ../../library/decimal.rst:1726
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the result "
"unchanged.  This signal is used to detect loss of significant digits."
msgstr ""
"一旦舍入操作丢弃了数位就会发出此信号；即使被丢弃的数位是零（如将 ``5.00`` 舍入到 ``5.0`` 的情况）。 "
"如果未被捕获，则不加修改地返回结果。 此信号用于检测有效位数的丢弃。"

#: ../../library/decimal.rst:1734
msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr "在舍入之前指数值低于 :attr:`~Context.Emin`。"

#: ../../library/decimal.rst:1736
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If"
" not trapped, returns the result unchanged."
msgstr "当操作结果是次标准数（即指数过小）时就会发出此信号。 如果未被陷阱捕获，则不经修改过返回结果。"

#: ../../library/decimal.rst:1742
msgid "Numerical underflow with result rounded to zero."
msgstr "数字向下溢出导致结果舍入到零。"

#: ../../library/decimal.rst:1744
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. "
":class:`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"当一个次标准数结果通过舍入转为零时就会发出此信号。 同时还将引发 :class:`Inexact` 和 :class:`Subnormal` 信号。"

#: ../../library/decimal.rst:1750
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "为 float 和 Decimal 的混合启用更严格的语义。"

#: ../../library/decimal.rst:1752
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, "
":meth:`~decimal.Context.create_decimal` and all comparison operators. Both "
"conversion and comparisons are exact. Any occurrence of a mixed operation is"
" silently recorded by setting :exc:`FloatOperation` in the context flags. "
"Explicit conversions with :meth:`~decimal.Decimal.from_float` or "
":meth:`~decimal.Context.create_decimal_from_float` do not set the flag."
msgstr ""
"如果信号未被捕获（默认），则在 :class:`~decimal.Decimal` "
"构造器、:meth:`~decimal.Context.create_decimal` 和所有比较运算中允许 float 和 Decimal 的混合。 "
"转换和比较都是完全精确的。 发生的任何混合运算都将通过在上下文旗标中设置 :exc:`FloatOperation` 来静默地记录。 通过 "
":meth:`~decimal.Decimal.from_float` 或 "
":meth:`~decimal.Context.create_decimal_from_float` 进行显式转换则不会设置旗标。"

#: ../../library/decimal.rst:1760
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise "
":exc:`FloatOperation`."
msgstr "在其他情况下（即信号被捕获），则只静默执行相等性比较和显式转换。 所有其他混合运算都将引发 :exc:`FloatOperation`。"

#: ../../library/decimal.rst:1764
msgid "The following table summarizes the hierarchy of signals::"
msgstr "以下表格总结了信号的层级结构::"

#: ../../library/decimal.rst:1766
msgid ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"
msgstr ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"

#: ../../library/decimal.rst:1785
msgid "Floating-point notes"
msgstr "浮点数说明"

#: ../../library/decimal.rst:1789
msgid "Mitigating round-off error with increased precision"
msgstr "通过提升精度来解决舍入错误"

#: ../../library/decimal.rst:1791
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent ``0.1`` exactly); however, some operations "
"can still incur round-off error when non-zero digits exceed the fixed "
"precision."
msgstr ""
"使用 decimal 浮点数可以消除十进制表示错误（即能够精确地表示 ``0.1`` "
"这样的数）；然而，某些运算在非零数位超出了给定的精度时仍然可能导至舍入错误。"

#: ../../library/decimal.rst:1795
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating-point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"舍入错误的影响可能因接近相互抵销的加减运算被放大从而导致丢失有效位。 Knuth "
"提供了两个指导性示例，其中出现了精度不足的浮点算术舍入，导致加法的交换律和分配律被打破："

#: ../../library/decimal.rst:1801
msgid ""
"# Examples from Seminumerical Algorithms, Section 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
"# 来自 Seminumerical Algorithms, Section 4.2.2 的示例。\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

#: ../../library/decimal.rst:1819
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ":mod:`decimal` 模块则可以通过充分地扩展精度来避免有效位的丢失："

#: ../../library/decimal.rst:1822
msgid ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

#: ../../library/decimal.rst:1839
msgid "Special values"
msgstr "特殊的值"

#: ../../library/decimal.rst:1841
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
":mod:`decimal` 模块的数字系统提供了一些特殊的值包括 ``NaN``, ``sNaN``, ``-Infinity``, "
"``Infinity``, 和两种零值，``+0`` 和 ``-0``。"

#: ../../library/decimal.rst:1845
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also,"
" they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"无穷大可以使用 ``Decimal('Infinity')`` 来构建。 它们也可以在不捕获 :exc:`DivisionByZero` "
"信号捕获时通过除以零来产生。 类似地，当不捕获 :exc:`Overflow` 信号时，也可以通过舍入到超出最大可表示数字限制的方式产生无穷大的结果。"

#: ../../library/decimal.rst:1850
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr "无穷大是有符号的（仿射）并可用于算术运算，它们会被当作极其巨大的不确定数字来处理。 例如，无穷大加一个常量结果也将为无穷大。"

#: ../../library/decimal.rst:1854
msgid ""
"Some operations are indeterminate and return ``NaN``, or if the "
":exc:`InvalidOperation` signal is trapped, raise an exception.  For example,"
" ``0/0`` returns ``NaN`` which means \"not a number\".  This variety of "
"``NaN`` is quiet and, once created, will flow through other computations "
"always resulting in another ``NaN``.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"某些运算没有确定的结果并将返回 ``NaN``，或者如果捕获了 :exc:`InvalidOperation` 信号，则会引发一个异常。 "
"例如，``0/0`` 将返回 ``NaN`` 表示 \"not a number\"。 这样的 ``NaN`` "
"将静默产生，并且一旦产生就将在参与其他运算时始终得到 ``NaN`` 的结果。 这种行为对于偶尔缺少输入的各类计算都很有用处 --- "
"它允许在将特定结果标记为无效的同时让计算继续进行。"

#: ../../library/decimal.rst:1862
msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after every "
"operation.  This is a useful return value when an invalid result needs to "
"interrupt a calculation for special handling."
msgstr ""
"一种变体形式是 ``sNaN``，它在每次运算后会发出信号而不是保持静默。 当对于无效结果需要中断计算进行特别处理时这是一个很有用的返回值。"

#: ../../library/decimal.rst:1866
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the operands "
"is a quiet or signaling ``NaN`` always returns :const:`False` (even when "
"doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality "
"always returns :const:`True`.  An attempt to compare two Decimals using any "
"of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the "
":exc:`InvalidOperation` signal if either operand is a ``NaN``, and return "
":const:`False` if this signal is not trapped.  Note that the General Decimal"
" Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a ``NaN`` were taken from"
" the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`~Decimal.compare` and "
":meth:`~Decimal.compare_signal` methods instead."
msgstr ""
"Python 中比较运算符的行为在涉及 ``NaN`` 时可能会令人有点惊讶。 相等性检测在操作数中有静默型或信号型 ``NaN`` 时总是会返回 "
":const:`False` (即使是执行 ``Decimal('NaN')==Decimal('NaN')``)，而不等性检测总是会返回 "
":const:`True`。 当尝试使用 ``<``, ``<=``, ``>`` 或 ``>=`` 运算符中的任何一个来比较两个 Decimal "
"值时，如果运算数中有 ``NaN`` 则将引发 :exc:`InvalidOperation` 信号，如果此信号未被捕获则将返回 "
":const:`False`。 请注意通用十进制算术规范并未规定直接比较行为；这些涉及 ``NaN`` 的比较规则来自于 IEEE 854 标准 (见第"
" 5.7 节表 3)。 要确保严格符合标准，请改用 :meth:`~Decimal.compare` 和 "
":meth:`~Decimal.compare_signal` 方法。"

#: ../../library/decimal.rst:1879
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"有符号零值可以由向下溢出的运算产生。 它们保留符号是为了让运算结果能以更高的精度传递。 "
"由于它们的大小为零，正零和负零会被视为相等，且它们的符号具有信息。"

#: ../../library/decimal.rst:1884
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating-point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"在这两个不相同但却相等的有符号零之外，还存在几种零的不同表示形式，它们的精度不同但值也都相等。 这需要一些时间来逐渐适应。 "
"对于习惯了标准浮点表示形式的眼睛来说，以下运算返回等于零的值并不是显而易见的："

#: ../../library/decimal.rst:1899
msgid "Working with threads"
msgstr "使用线程"

#: ../../library/decimal.rst:1901
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object"
" for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
":func:`getcontext` 函数会为每个线程访问不同的 :class:`Context` 对象。 具有单独线程上下文意味着线程可以修改上下文 "
"(例如 ``getcontext().prec=10``) 而不影响其他线程。"

#: ../../library/decimal.rst:1905
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr "类似的 :func:`setcontext` 会为当前上下文的目标自动赋值。"

#: ../../library/decimal.rst:1908
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then "
":func:`getcontext` will automatically create a new context for use in the "
"current thread.  New context objects have default values set from the "
":data:`decimal.DefaultContext` object."
msgstr ""
"如果在调用 :func:`setcontext` 之前调用了 :func:`getcontext`，则 :func:`getcontext` "
"将自动创建一个新的上下文在当前线程中使用。 新的上下文对象具有从 :data:`decimal.DefaultContext` 对象设置的默认值。"

#: ../../library/decimal.rst:1913
msgid ""
"The :data:`sys.flags.thread_inherit_context` flag affects the context for "
"new threads.  If the flag is false, new threads will start with an empty "
"context.  In this case, :func:`getcontext` will create a new context object "
"when called and use the default values from *DefaultContext*.  If the flag "
"is true, new threads will start with a copy of context from the caller of "
":meth:`threading.Thread.start`."
msgstr ""
":data:`sys.flags.thread_inherit_context` 标志影响新线程的上下文。 如果该标志为 "
"false，则新线程将以空上下文启动。 在这种情况下，:func:`getcontext` 将在调用时创建一个新的上下文对象，并使用 "
"*DefaultContext* 中的默认值。 如果该标志为 true，则新线程将从 :meth:`threading.Thread.start` "
"调用者的上下文副本启动。"

#: ../../library/decimal.rst:1920
msgid ""
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"要控制默认值以便每个线程在应用运行期间都使用相同的值，可以直接修改 *DefaultContext* 对象。 这应当在任何线程启动 *之前* "
"完成以使得调用 :func:`getcontext` 的线程之间不会产生竞争条件。 例如::"

#: ../../library/decimal.rst:1925
msgid ""
"# Set applicationwide defaults for all threads about to be launched\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Afterwards, the threads can be started\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."
msgstr ""
"# 为所有将要启动的线程设置应用程序级默认值\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# 在此之后，即可启动线程\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."

#: ../../library/decimal.rst:1944
msgid "Recipes"
msgstr "例程"

#: ../../library/decimal.rst:1946
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr "以下是一些用作工具函数的例程，它们演示了使用 :class:`Decimal` 类的各种方式::"

#: ../../library/decimal.rst:1949
msgid ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Convert Decimal to a money formatted string.\n"
"\n"
"    places:  required number of places after the decimal point\n"
"    curr:    optional currency symbol before the sign (may be blank)\n"
"    sep:     optional grouping separator (comma, period, space, or blank)\n"
"    dp:      decimal point indicator (comma or period)\n"
"             only specify as blank when places is zero\n"
"    pos:     optional sign for positive numbers: '+', space or blank\n"
"    neg:     optional sign for negative numbers: '-', '(', space or blank\n"
"    trailneg:optional trailing minus indicator:  '-', ')', space or blank\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 places --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Compute Pi to the current precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # extra digits for intermediate steps\n"
"    three = Decimal(3)      # substitute \"three=3.0\" for regular floats\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # unary plus applies the new precision\n"
"\n"
"def exp(x):\n"
"    \"\"\"Return e raised to the power of x.  Result type matches input type.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Return the cosine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Return the sine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"
msgstr ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"将 Decimal 值转换为以货币形式格式化的字符串。\n"
"\n"
"    places:  小数点之后要保留的位数\n"
"    curr:    正负号之前可选的货币符号 (可以为空)\n"
"    sep:     可选的千位分隔符 (逗点, 句点, 空格或为空)\n"
"    dp:      小数点符号 (逗点或句点)\n"
"             仅在保留零位小数时设为空\n"
"    pos:     可选的正值符号: '+', 空格或为空\n"
"    neg:     可选的负值符号: '-', '(', 空格或为空\n"
"    trailneg:可选的末尾负值符号:  '-', ')', 空格或为空\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 个小数位 --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"计算 Pi 到当前精度。\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # 用于中间步骤的额外位数\n"
"    three = Decimal(3)      # 替换常规浮点数的 \"three=3.0\"\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # 单目取正值运算将应用新的精度\n"
"\n"
"def exp(x):\n"
"    \"\"\"返回 e 的 x 次方。 结果类型将与输入类型相匹配。\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"返回以弧度衡量的 x 的余弦。\n"
"\n"
"    泰勒级数近似算法对较小的 x 值效果最好。\n"
"    对于较大的值，则先计算 x = x % (2 * pi)。\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"返回以弧度衡量的 x 的正弦。\n"
"\n"
"    泰勒级数近似算法对较小的 x 值效果最好。\n"
"    对于较大的值，则先计算 x = x % (2 * pi)。\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"

#: ../../library/decimal.rst:2101
msgid "Decimal FAQ"
msgstr "Decimal 常见问题"

#: ../../library/decimal.rst:2103
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr "Q. 总是输入 ``decimal.Decimal('1234.5')`` 是否过于笨拙。 在使用交互解释器时有没有最小化输入量的方式？"

#: ../../library/decimal.rst:2106
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. 有些用户会将构造器简写为一个字母："

#: ../../library/decimal.rst:2112
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"Q. 在带有两个十进制位的定点数应用中，有些输入值具有许多位，需要被舍入。 另一些数则不应具有多余位，需要验证有效性。 这种情况应该用什么方法？"

#: ../../library/decimal.rst:2116
msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of decimal "
"places. If the :const:`Inexact` trap is set, it is also useful for "
"validation:"
msgstr ""
"A. 用 :meth:`~Decimal.quantize` 方法舍入到固定数目的十进制位。 如果设置了 :const:`Inexact` "
"陷阱，它也适用于验证有效性:"

#: ../../library/decimal.rst:2134
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr "Q. 当我使用两个有效位的输入时，我要如何在一个应用中保持有效位不变？"

#: ../../library/decimal.rst:2137
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`~Decimal.quantize` step:"
msgstr ""
"A. 某些运算如与整数相加、相减和相乘将会自动保留固定的小数位数。 其他运算，如相除和非整数相乘则会改变小数位数，需要再加上 "
":meth:`~Decimal.quantize` 处理步骤:"

#: ../../library/decimal.rst:2155
msgid ""
"In developing fixed-point applications, it is convenient to define functions"
" to handle the :meth:`~Decimal.quantize` step:"
msgstr "在开发定点数应用时，更方便的做法是定义处理 :meth:`~Decimal.quantize` 步骤的函数:"

#: ../../library/decimal.rst:2169
msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"Q. 表示同一个值有许多方式。 数字 ``200``, ``200.000``, ``2E2`` 和 ``.02E+4`` 都具有相同的值但其精度不同。"
" 是否有办法将它们转换为一个可识别的规范值？"

#: ../../library/decimal.rst:2174
msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr "A. :meth:`~Decimal.normalize` 方法可将所有相等的值映射为单一表示形式:"

#: ../../library/decimal.rst:2181
msgid "Q. When does rounding occur in a computation?"
msgstr "Q. 计算中的舍入是在什么时候发生的？"

#: ../../library/decimal.rst:2183
msgid ""
"A. It occurs *after* the computation.  The philosophy of the decimal "
"specification is that numbers are considered exact and are created "
"independent of the current context.  They can even have greater precision "
"than current context.  Computations process with those exact inputs and then"
" rounding (or other context operations) is applied to the *result* of the "
"computation::"
msgstr ""
"A. 是在计算 *之后* 发生的。 decimal 设计规范认为数字应当被视为是精确的并且是不依赖于当前上下文而创建的。 "
"它们甚至可以具有比当前上下文更高的精确度。 计算过程将使用精确的输入然后再对计算的 *结果* 应用舍入（或其他的上下文操作）::"

#: ../../library/decimal.rst:2190
msgid ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # More than 5 digits\n"
">>> pi                             # All digits are retained\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # Rounded after an addition\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # Subtract unrounded numbers, then round\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005').   # Intermediate values are rounded\n"
"Decimal('3.1416')"
msgstr ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # 超过 5 个数位\n"
">>> pi                             # 所有数位都将保留\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # 加法运算后将执行舍入\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # 减去未舍入的数值，然后执行舍入\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005').   # 中间值将执行舍入\n"
"Decimal('3.1416')"

#: ../../library/decimal.rst:2201
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr "Q. 有些十进制值总是被打印为指数表示形式。 是否有办法得到一个非指数表示形式？"

#: ../../library/decimal.rst:2204
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
"``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. 对于某些值来说，指数表示法是表示系数中有效位的唯一方式。 例如，将 ``5.0E+3`` 表示为 ``5000`` "
"可以让值保持恒定但是无法显示原本的两位有效位。"

#: ../../library/decimal.rst:2209
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr "如果一个应用不必关心追踪有效位，则可以很容易地移除指数和末尾的零，丢弃有效位但让值保持不变："

#: ../../library/decimal.rst:2219
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "Q. 是否有办法将一个普通浮点数转换为 :class:`Decimal`？"

#: ../../library/decimal.rst:2221
msgid ""
"A. Yes, any binary floating-point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr "A. 是的，任何二进制浮点数都可以精确地表示为 Decimal 值，但完全精确的转换可能需要比平常感觉更高的精度："

#: ../../library/decimal.rst:2225
msgid ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"
msgstr ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"

#: ../../library/decimal.rst:2230
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a"
" spurious result because of insufficient precision or rounding anomalies."
msgstr "Q. 在一个复杂的计算中，我怎样才能保证不会得到由精度不足和舍入异常所导致的虚假结果。"

#: ../../library/decimal.rst:2233
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes."
" Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"A. 使用 decimal 模块可以很容易地检测结果。 最好的做法是使用更高的精度和不同的舍入模式重新进行计算。 "
"明显不同的结果表明存在精度不足、舍入模式问题、不符合条件的输入或是结果不稳定的算法。"

#: ../../library/decimal.rst:2238
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr "Q. 我发现上下文精度的应用只针对运算结果而不针对输入。在混合使用不同精度的值时有什么需要注意的吗？"

#: ../../library/decimal.rst:2242
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"A. 是的。 原则上所有值都会被视为精确值，在这些值上进行的算术运算也是如此。 只有结果会被舍入。 对于输入来说其好处是“所输入即所得”。 "
"而其缺点则是如果你忘记了输入没有被舍入，结果看起来可能会很奇怪："

#: ../../library/decimal.rst:2247
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"

#: ../../library/decimal.rst:2255
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr "解决办法是提高精度或使用单目加法运算对输入执行强制舍入："

#: ../../library/decimal.rst:2258
msgid ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # unary plus triggers rounding\n"
"Decimal('1.23')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # 单目取正运算符将触发舍入\n"
"Decimal('1.23')"

#: ../../library/decimal.rst:2264
msgid ""
"Alternatively, inputs can be rounded upon creation using the "
":meth:`Context.create_decimal` method:"
msgstr "此外，还可以使用 :meth:`Context.create_decimal` 方法在创建输入时执行舍入："

#: ../../library/decimal.rst:2270
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Q. CPython 实现对于巨大数字是否足够快速？"

#: ../../library/decimal.rst:2272
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec "
"<https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ library for "
"arbitrary precision correctly rounded decimal floating-point arithmetic "
"[#]_. ``libmpdec`` uses `Karatsuba multiplication "
"<https://en.wikipedia.org/wiki/Karatsuba_algorithm>`_ for medium-sized "
"numbers and the `Number Theoretic Transform "
"<https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-"
"theoretic_transform>`_ for very large numbers."
msgstr ""
"A. 是的。 在 CPython 和 PyPy3 实现中，decimal 模块的 C/CFFI 版本集成了高速 `libmpdec "
"<https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ "
"库用于实现任意精度正确舍入的十进制浮点算术 [#]_。 ``libmpdec`` 会对中等大小的数字使用 `Karatsuba 乘法 "
"<https://en.wikipedia.org/wiki/Karatsuba_algorithm>`_ 而对非常巨大的数字使用 `数字原理变换 "
"<https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-"
"theoretic_transform>`_。"

#: ../../library/decimal.rst:2282
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. "
":attr:`~Context.Emin` and :attr:`~Context.Emax` should always be set to the "
"maximum values, :attr:`~Context.clamp` should always be 0 (the default).  "
"Setting :attr:`~Context.prec` requires some care."
msgstr ""
"上下文必须针对任意精度算术进行适配。 :attr:`~Context.Emin` 和 :attr:`~Context.Emax` "
"应当总是被设为最大值，:attr:`~Context.clamp` 应当总是为 0 (默认值)。 设置 :attr:`~Context.prec` "
"需要十分谨慎。requires some care."

#: ../../library/decimal.rst:2286
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`~Context.prec` as well [#]_::"
msgstr "进行大数字算术的最便捷方式同样是使用 :attr:`~Context.prec` 的最大值 [#]_::"

#: ../../library/decimal.rst:2289
msgid ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"
msgstr ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"

#: ../../library/decimal.rst:2295
msgid ""
"For inexact results, :const:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr "对于不精确的结果，在 64 位平台上 :const:`MAX_PREC` 的值太大因而会导致可用内存不足::"

#: ../../library/decimal.rst:2298
msgid ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"
msgstr ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"

#: ../../library/decimal.rst:2303
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`~Context.prec` to the amount of available RAM.  Suppose "
"that you have 8GB of RAM and expect 10 simultaneous operands using a maximum"
" of 500MB each::"
msgstr ""
"在具有超量分配的系统上 (如 Linux)，一种更复杂的方式是根据可用的 RAM 大小来调整 :attr:`~Context.prec`。 假设你有 "
"8GB 的 RAM 并期望同时有 10 个操作数，每个最多使用 500MB::"

#: ../../library/decimal.rst:2307
msgid ""
">>> import sys\n"
">>>\n"
">>> # Maximum number of digits for a single operand using 500MB in 8-byte words\n"
">>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Check that this works:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Fill the available precision with nines:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"
msgstr ""
">>> import sys\n"
">>>\n"
">>> # 字长 8 字节使用 500MB 的单个操作数的最大位数\n"
">>> # 每字 19 个数位（32 位构建版则为字长 4 字节每字 9 个数位）：\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # 检测此代码有效。\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # 以数字九填满可用的精度：\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"

#: ../../library/decimal.rst:2327
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap"
" if all calculations are expected to be exact."
msgstr "总体而言（特别是在没有超量分配的系统上），如果期望所有计算都是精确的则推荐预估更严格的边界并设置 :attr:`Inexact` 陷阱。"

#: ../../library/decimal.rst:2336
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr "此方式现在适用于除了非整数乘方以外的所有精确结果。"
