# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-30 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`!multiprocessing` --- 基于进程的并行"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**源代码** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "Availability"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"此模块在 :ref:`移动平台 <mobile-availability>` 或 :ref:`WebAssembly 平台 <wasm-"
"availability>` 上不受支持。"

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "概述"

#: ../../library/multiprocessing.rst:16
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""
":mod:`multiprocessing` 是一个支持使用与 :mod:`threading` 模块类似的 API 来产生进程的包。 "
":mod:`multiprocessing` 包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了 :term:`全局解释器锁 "
"<global interpreter lock>`。 因此，:mod:`multiprocessing` "
"模块允许程序员充分利用给定机器上的多个处理器。 它在 POSIX 和 Windows 上均可运行。"

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`~multiprocessing.pool.Pool` object which offers a convenient means "
"of parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using "
":class:`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` 模块还引入了在 :mod:`threading` 模块中没有的API。一个主要的例子就是 "
":class:`~multiprocessing.pool.Pool` "
"对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。下面的例子演示了在模块中定义此类函数的常见做法，以便子进程可以成功导入该模块。这个数据并行的基本例子使用了"
" :class:`~multiprocessing.pool.Pool` ， ::"

#: ../../library/multiprocessing.rst:34
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"

#: ../../library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "将在标准输出中打印 ::"

#: ../../library/multiprocessing.rst:45
msgid "[1, 4, 9]"
msgstr "[1, 4, 9]"

#: ../../library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the "
":class:`~multiprocessing.pool.Pool` interface directly, the "
":mod:`concurrent.futures` API more readily allows the submission of work to "
"the underlying process pool to be separated from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` "
"提供了一个更高层级的接口用来将任务推送到后台进程而不会阻塞调用方进程的执行。 与直接使用 "
":class:`~multiprocessing.pool.Pool` 接口相比，:mod:`concurrent.futures` API "
"能更好地允许将工作单元发往无需等待结果的下层进程池。"

#: ../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr ":class:`Process` 类"

#: ../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` method."
"  :class:`Process` follows the API of :class:`threading.Thread`.  A trivial "
"example of a multiprocess program is ::"
msgstr ""
"在 :mod:`multiprocessing` 中，通过创建一个 :class:`Process` 对象然后调用它的 "
":meth:`~process.start` 方法来生成进程。 :class:`Process` 和 :class:`threading.Thread`"
" API 相同。 一个简单的多进程程序示例是::"

#: ../../library/multiprocessing.rst:66
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "要显示所涉及的各个进程ID，这是一个扩展示例::"

#: ../../library/multiprocessing.rst:78
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"关于为什么 ``if __name__ == '__main__'`` 部分是必需的解释，请参见 :ref:`multiprocessing-"
"programming`。"

#: ../../library/multiprocessing.rst:105
msgid "Contexts and start methods"
msgstr "上下文和启动方法"

#: ../../library/multiprocessing.rst:107
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr "根据不同的平台， :mod:`multiprocessing` 支持三种启动进程的方法。这些 *启动方法* 有"

#: ../../library/multiprocessing.rst:110
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:111
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork*"
" or *forkserver*."
msgstr ""
"父进程会启动一个新的 Python 解释器进程。 子进程将只继承那些运行进程对象的 :meth:`~Process.run` 方法所必须的资源。 "
"特别地，来自父进程的非必需文件描述符和句柄将不会被继承。 使用此方法启动进程相比使用 *fork* 或 *forkserver* 要慢上许多。"

#: ../../library/multiprocessing.rst:118
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr "在 POSIX 和 Windows 平台上可用。 默认在 Windows 和 macOS 上。"

#: ../../library/multiprocessing.rst:120
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:121
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The"
" child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"父进程使用 :func:`os.fork` 来产生 Python "
"解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。"

#: ../../library/multiprocessing.rst:127
msgid ""
"Available on POSIX systems.  Currently the default on POSIX except macOS."
msgstr "在 POSIX 系统上可用。 目前在除 macOS 之外的 POSIX 上为默认值。"

#: ../../library/multiprocessing.rst:130
msgid ""
"The default start method will change away from *fork* in Python 3.14. Code "
"that requires *fork* should explicitly specify that via :func:`get_context` "
"or :func:`set_start_method`."
msgstr ""
"在 Python 3.14 上默认的启动方法将不再为 *fork*。 需要 *fork* 的代码应当显式地通过 :func:`get_context` "
"或 :func:`set_start_method` 来指定。"

#: ../../library/multiprocessing.rst:134
msgid ""
"If Python is able to detect that your process has multiple threads, the "
":func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the "
":func:`os.fork` documentation for further explanation."
msgstr ""
"如果 Python 能够检测到你的进程有多个线程，那么在该启动方法内部调用 :func:`os.fork` 函数将引发 "
":exc:`DeprecationWarning`。 请使用其他启动方法。 进一步的解释参见 :func:`os.fork` 文档。"

#: ../../library/multiprocessing.rst:140
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:141
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries"
" or preloaded imports spawn threads as a side-effect so it is generally safe"
" for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""
"当程序启动并选择 *forkserver* 启动方法时，将产生一个服务器进程。 "
"从那时起，每当需要一个新进程时，父进程就会连接到该服务器并请求它分叉一个新进程。 "
"分叉服务器进程是单线程的，除非因系统库或预加载导入的附带影响改变了这一点，因此使用 :func:`os.fork` 通常是安全的。 "
"没有不必要的资源被继承。"

#: ../../library/multiprocessing.rst:149
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux."
msgstr "在支持通过 Unix 管道传递文件描述符的 POSIX 平台上可用，例如 Linux。"

#: ../../library/multiprocessing.rst:153
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"在所有 POSIX 平台上添加了 *spawn*，并为某些 POSIX 平台添加了 *forkserver*。 在 Windows "
"上子进程将不再继承父进程的所有可继承句柄。"

#: ../../library/multiprocessing.rst:161
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"在 macOS 上，现在 *spawn* 启动方法是默认值。 由于 *fork* 启动方法可能因 macOS "
"系统库也许会启动线程导致子进程崩溃因而应当被视为是不安全的。 参见 :issue:`33725`。"

#: ../../library/multiprocessing.rst:165
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or "
":class:`~multiprocessing.shared_memory.SharedMemory` objects) created by "
"processes of the program.  When all processes have exited the resource "
"tracker unlinks any remaining tracked object. Usually there should be none, "
"but if a process was killed by a signal there may be some \"leaked\" "
"resources.  (Neither leaked semaphores nor shared memory segments will be "
"automatically unlinked until the next reboot. This is problematic for both "
"objects because the system allows only a limited number of named semaphores,"
" and shared memory segments occupy some space in the main memory.)"
msgstr ""
"在 POSIX 上使用 *spawn* 或 *forkserver* 启动方法将同时启动一个 *资源追踪器* "
"进程，负责追踪当前程序的进程产生的已取消连接的命名系统资源（如命名信号量或 "
":class:`~multiprocessing.shared_memory.SharedMemory` 对象）。 "
"当所有进程退出后资源追踪器会负责取消链接任何仍然被追踪的对象。 "
"在通常情况下应该是没有此种对象的，但是如果一个子进程是被某个信号杀掉的则可能存在一些“泄露”的资源。 "
"（泄露的信号量或共享的内存段不会被自动取消链接直到下一次重启。 "
"对于这两种对象来说会有问题因为系统只允许有限数量的命名信号量，而共享的内存段在主内存中占用一些空间。）"

#: ../../library/multiprocessing.rst:178
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"要选择一个启动方法，你应该在主模块的 ``if __name__ == '__main__'`` 子句中调用 "
":func:`set_start_method` 。例如："

#: ../../library/multiprocessing.rst:182
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:195
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr "在程序中 :func:`set_start_method` 不应该被多次调用。"

#: ../../library/multiprocessing.rst:198
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"或者，你可以使用 :func:`get_context` 来获取上下文对象。上下文对象与 multiprocessing "
"模块具有相同的API，并允许在同一程序中使用多种启动方法。::"

#: ../../library/multiprocessing.rst:203
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:216
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"请注意，对象在不同上下文创建的进程间可能并不兼容。 特别是，使用 *fork* 上下文创建的锁不能传递给使用 *spawn* 或 "
"*forkserver* 启动方法启动的进程。"

#: ../../library/multiprocessing.rst:221
msgid ""
"A library which wants to use a particular start method should probably use "
":func:`get_context` to avoid interfering with the choice of the library "
"user."
msgstr "想要使用特定启动方法的库应该使用 :func:`get_context` 以避免干扰库用户的选择。"

#: ../../library/multiprocessing.rst:227
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""
"``'spawn'`` 和 ``'forkserver'`` 启动方法在 POSIX 系统上通常不能与“已冻结”可执行程序一同使用（例如由 "
"**PyInstaller** 和 **cx_Freeze** 等软件包产生的二进制文件）。 如果代码没有使用线程则可以使用 ``'fork'`` "
"启动方法。"

#: ../../library/multiprocessing.rst:234
msgid "Exchanging objects between processes"
msgstr "在进程之间交换对象"

#: ../../library/multiprocessing.rst:236
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ":mod:`multiprocessing` 支持进程之间的两种通信通道："

#: ../../library/multiprocessing.rst:239
msgid "**Queues**"
msgstr "**队列**"

#: ../../library/multiprocessing.rst:241
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ":class:`Queue` 类是一个近似 :class:`queue.Queue` 的克隆。 例如::"

#: ../../library/multiprocessing.rst:244
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # 打印 \"[42, None, 'hello']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:256
msgid ""
"Queues are thread and process safe. Any object put into a "
":mod:`~multiprocessing` queue will be serialized."
msgstr "队列是线程和进程安全的。 任何放入 :mod:`~multiprocessing` 队列的对象都将被序列化。"

#: ../../library/multiprocessing.rst:259
msgid "**Pipes**"
msgstr "**管道**"

#: ../../library/multiprocessing.rst:261
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ":func:`Pipe` 函数返回一个由管道连接的连接对象，默认情况下是双工（双向）。例如::"

#: ../../library/multiprocessing.rst:264
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # 打印 \"[42, None, 'hello']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:277
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and "
":meth:`~Connection.recv` methods (among others).  Note that data in a pipe "
"may become corrupted if two processes (or threads) try to read from or write"
" to the *same* end of the pipe at the same time.  Of course there is no risk"
" of corruption from processes using different ends of the pipe at the same "
"time."
msgstr ""
"返回的两个连接对象 :func:`Pipe` 表示管道的两端。每个连接对象都有 :meth:`~Connection.send` 和 "
":meth:`~Connection.recv` 方法（相互之间的）。请注意，如果两个进程（或线程）同时尝试读取或写入管道的 *同一* "
"端，则管道中的数据可能会损坏。当然，在不同进程中同时使用管道的不同端的情况下不存在损坏的风险。"

#: ../../library/multiprocessing.rst:285
msgid ""
"The :meth:`~Connection.send` method serializes the object and "
":meth:`~Connection.recv` re-creates the object."
msgstr ":meth:`~Connection.send` 方法将序列化对象而 :meth:`~Connection.recv` 将重新创建对象。"

#: ../../library/multiprocessing.rst:289
msgid "Synchronization between processes"
msgstr "进程间同步"

#: ../../library/multiprocessing.rst:291
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure"
" that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` 包含来自 :mod:`threading` "
"的所有同步原语的等价物。例如，可以使用锁来确保一次只有一个进程打印到标准输出::"

#: ../../library/multiprocessing.rst:295
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"

#: ../../library/multiprocessing.rst:310
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr "不使用锁的情况下，来自于多进程的输出很容易产生混淆。"

#: ../../library/multiprocessing.rst:315
msgid "Sharing state between processes"
msgstr "进程间共享状态"

#: ../../library/multiprocessing.rst:317
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when"
" using multiple processes."
msgstr "如上所述，在进行并发编程时，通常最好尽量避免使用共享状态。使用多个进程时尤其如此。"

#: ../../library/multiprocessing.rst:321
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr "但是，如果你真的需要使用一些共享数据，那么 :mod:`multiprocessing` 提供了两种方法。"

#: ../../library/multiprocessing.rst:324
msgid "**Shared memory**"
msgstr "**共享内存**"

#: ../../library/multiprocessing.rst:326
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr "可以使用 :class:`Value` 或 :class:`Array` 将数据存储在共享内存映射中。例如，以下代码::"

#: ../../library/multiprocessing.rst:329
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"

#: ../../library/multiprocessing.rst:347 ../../library/multiprocessing.rst:393
msgid "will print ::"
msgstr "将打印 ::"

#: ../../library/multiprocessing.rst:349
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"

#: ../../library/multiprocessing.rst:352
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are"
" typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared"
" objects will be process and thread-safe."
msgstr ""
"创建 ``num`` 和 ``arr`` 时使用的 ``'d'`` 和 ``'i'`` 参数是 :mod:`array` 模块使用的类型的 "
"typecode ： ``'d'`` 表示双精度浮点数， ``'i'`` 表示有符号整数。这些共享对象将是进程和线程安全的。"

#: ../../library/multiprocessing.rst:357
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"为了更灵活地使用共享内存，可以使用 :mod:`multiprocessing.sharedctypes` "
"模块，该模块支持创建从共享内存分配的任意ctypes对象。"

#: ../../library/multiprocessing.rst:361
msgid "**Server process**"
msgstr "**服务进程**"

#: ../../library/multiprocessing.rst:363
msgid ""
"A manager object returned by :func:`Manager` controls a server process which"
" holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr "由 :func:`Manager` 返回的管理器对象控制一个服务进程，该进程保存Python对象并允许其他进程使用代理操作它们。"

#: ../../library/multiprocessing.rst:367
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and "
":class:`Array`.  For example, ::"
msgstr ""
":func:`Manager` 返回的管理器支持类型： :class:`list` 、 :class:`dict` 、 "
":class:`~managers.Namespace` 、 :class:`Lock` 、 :class:`RLock` 、 "
":class:`Semaphore` 、 :class:`BoundedSemaphore` 、 :class:`Condition` 、 "
":class:`Event` 、 :class:`Barrier` 、 :class:`Queue` 、 :class:`Value` 和 "
":class:`Array` 。例如 ::"

#: ../../library/multiprocessing.rst:373
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"\n"
"        p = Process(target=f, args=(d, l))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)"
msgstr ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"\n"
"        p = Process(target=f, args=(d, l))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)"

#: ../../library/multiprocessing.rst:395
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"

#: ../../library/multiprocessing.rst:398
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"使用服务进程的管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。此外，单个管理器可以通过网络由不同计算机上的进程共享。但是，它们比使用共享内存慢。"

#: ../../library/multiprocessing.rst:405
msgid "Using a pool of workers"
msgstr "使用工作进程"

#: ../../library/multiprocessing.rst:407
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
":class:`~multiprocessing.pool.Pool` 类表示一个工作进程池。它具有允许以几种不同方式将任务分配到工作进程的方法。"

#: ../../library/multiprocessing.rst:411
msgid "For example::"
msgstr "例如："

#: ../../library/multiprocessing.rst:413
msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing.TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # 启动 4 个工作进程\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # 打印 \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # 以任意顺序打印同样的数字\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # 异步地对 \"f(20)\" 求值\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # 异步地对 \"os.getpid()\" 求值\n"
"        res = pool.apply_async(os.getpid, ()) # *仅在* 一个进程中运行\n"
"        print(res.get(timeout=1))             # 打印进程的 PID\n"
"\n"
"        # 异步地进行多次求值 *可能* 会使用更多进程\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # 让一个工作进程休眠 10 秒\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing.TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # 退出 'with' 代码块将停止进程池\n"
"    print(\"Now the pool is closed and no longer available\")"

#: ../../library/multiprocessing.rst:455
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "请注意，进程池的方法只能由创建它的进程使用。"

#: ../../library/multiprocessing.rst:460
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"这个包中的功能要求子进程可以导入 ``__main__`` 模块。虽然这在 :ref:`multiprocessing-programming` "
"中有描述，但还是需要提前说明一下。这意味着一些示例在交互式解释器中不起作用，比如 :class:`multiprocessing.pool.Pool` "
"示例。例如::"

#: ../../library/multiprocessing.rst:466
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>"
msgstr ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class '_frozen_importlib.BuiltinImporter'>)>"

#: ../../library/multiprocessing.rst:483
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr "（如果尝试执行上面的代码，它会以一种半随机的方式将三个完整的堆栈内容交替输出，然后你只能以某种方式停止父进程。)"

#: ../../library/multiprocessing.rst:489
msgid "Reference"
msgstr "参考"

#: ../../library/multiprocessing.rst:491
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` 包主要复制了 :mod:`threading` 模块的API。"

#: ../../library/multiprocessing.rst:496
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` 和异常"

#: ../../library/multiprocessing.rst:501
msgid ""
"Process objects represent activity that is run in a separate process. The "
":class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr ""
"进程对象表示在单独进程中运行的活动。 :class:`Process` 类拥有和 :class:`threading.Thread` 等价的大部分方法。"

#: ../../library/multiprocessing.rst:505
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked by"
" the :meth:`run` method.  It defaults to ``None``, meaning nothing is "
"called. *name* is the process name (see :attr:`name` for more details). "
"*args* is the argument tuple for the target invocation.  *kwargs* is a "
"dictionary of keyword arguments for the target invocation.  If provided, the"
" keyword-only *daemon* argument sets the process :attr:`daemon` flag to "
"``True`` or ``False``.  If ``None`` (the default), this flag will be "
"inherited from the creating process."
msgstr ""
"构造器被调用时应当总是传入关键字参数。 *group* 应当始终为 ``None``；它的存在仅是为了与 "
":class:`threading.Thread` 兼容。 *target* 是由 :meth:`run` 方法来唤起的可调用对象。 它的默认值为 "
"``None``，表示不调用任何东西。 *name* 是进程名称（请参阅 :attr:`name` 了解详情）。 *args* "
"是针对目标调用的参数元组。 *kwargs* 是针对目标调用的关键字参数字典。 如果提供，则仅限关键字参数 *daemon* 会将进程的 "
":attr:`daemon` 旗标设为 ``True`` 或 ``False``。 如果为 ``None`` (默认值)，则该旗标将从创建方进程继承。"

#: ../../library/multiprocessing.rst:516
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"在默认情况下，不会将任何参数传递给 *target*。 *args* 参数默认值为 ``()``，可被用来指定要传递给 *target* "
"的参数列表或元组。"

#: ../../library/multiprocessing.rst:520
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else"
" to the process."
msgstr "如果子类重写构造函数，它必须确保它在对进程执行任何其他操作之前调用基类构造函数（ :meth:`Process.__init__` ）。"

#: ../../library/multiprocessing.rst:524
msgid "Added the *daemon* parameter."
msgstr "增加了 *daemon* 形参。"

#: ../../library/multiprocessing.rst:529
msgid "Method representing the process's activity."
msgstr "表示进程活动的方法。"

#: ../../library/multiprocessing.rst:531
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"target argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"你可以在子类中重写此方法。标准 :meth:`run` 方法调用传递给对象构造函数的可调用对象作为目标参数（如果有），分别从 *args* 和 "
"*kwargs* 参数中获取顺序和关键字参数。"

#: ../../library/multiprocessing.rst:536
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr "使用列表或元组作为传给 :class:`Process` 的 *args* 参数可以达成同样的效果。"

#: ../../library/multiprocessing.rst:539
msgid "Example::"
msgstr "示例："

#: ../../library/multiprocessing.rst:541
msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"

#: ../../library/multiprocessing.rst:551
msgid "Start the process's activity."
msgstr "启动进程活动。"

#: ../../library/multiprocessing.rst:553
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr "这个方法每个进程对象最多只能调用一次。它会将对象的 :meth:`run` 方法安排在一个单独的进程中调用。"

#: ../../library/multiprocessing.rst:558
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"如果可选参数 *timeout* 是 ``None`` （默认值），则该方法将阻塞，直到调用 :meth:`join` 方法的进程终止。如果 "
"*timeout* 是一个正数，它最多会阻塞 *timeout* 秒。请注意，如果进程终止或方法超时，则该方法返回 ``None`` 。检查进程的 "
":attr:`exitcode` 以确定它是否终止。"

#: ../../library/multiprocessing.rst:565
msgid "A process can be joined many times."
msgstr "一个进程可以被 join 多次。"

#: ../../library/multiprocessing.rst:567
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr "进程无法join自身，因为这会导致死锁。尝试在启动进程之前join进程是错误的。"

#: ../../library/multiprocessing.rst:572
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr "进程的名称。该名称是一个字符串，仅用于识别目的。它没有语义。可以为多个进程指定相同的名称。"

#: ../../library/multiprocessing.rst:576
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided"
" to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ "
":sub:`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the "
"N-th child of its parent."
msgstr ""
"初始名称由构造器设定。 如果没有为构造器提供显式名称，则会构造一个形式为 'Process-N\\ :sub:`1`:N\\ "
":sub:`2`:...:N\\ :sub:`k`' 的名称，其中每个 N\\ :sub:`k` 是其父亲的第 N 个孩子。"

#: ../../library/multiprocessing.rst:583
msgid "Return whether the process is alive."
msgstr "返回进程是否还活着。"

#: ../../library/multiprocessing.rst:585
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr "粗略地说，从 :meth:`start` 方法返回到子进程终止之前，进程对象仍处于活动状态。"

#: ../../library/multiprocessing.rst:590
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr "进程的守护标志，一个布尔值。这必须在 :meth:`start` 被调用之前设置。"

#: ../../library/multiprocessing.rst:593
msgid "The initial value is inherited from the creating process."
msgstr "初始值继承自创建进程。"

#: ../../library/multiprocessing.rst:595
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "当进程退出时，它会尝试终止其所有守护进程子进程。"

#: ../../library/multiprocessing.rst:598
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"请注意，不允许在守护进程中创建子进程。这是因为当守护进程由于父进程退出而中断时，其子进程会变成孤儿进程。 另外，这些 **不是** Unix "
"守护进程或服务，它们是正常进程，如果非守护进程已经退出，它们将被终止（并且不被合并）。"

#: ../../library/multiprocessing.rst:604
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr "除了 :class:`threading.Thread` API ，:class:`Process` 对象还支持以下属性和方法："

#: ../../library/multiprocessing.rst:609
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "返回进程ID。在生成该进程之前，这将是 ``None`` 。"

#: ../../library/multiprocessing.rst:614
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr "子进程的退出代码。如果该进程尚未终止则为 ``None`` 。"

#: ../../library/multiprocessing.rst:617
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"如果子进程的 :meth:`run` 方法正常返回，退出代码将是 0 。 如果它通过 :func:`sys.exit` 终止，并有一个整数参数 *N* "
"，退出代码将是 *N* 。"

#: ../../library/multiprocessing.rst:621
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"如果子进程由于在 :meth:`run` 内的未捕获异常而终止，退出代码将是 1 。 如果它是由信号 *N* 终止的，退出代码将是负值 *-N* 。"

#: ../../library/multiprocessing.rst:627
msgid "The process's authentication key (a byte string)."
msgstr "进程的身份验证密钥（字节字符串）。"

#: ../../library/multiprocessing.rst:629
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr "当 :mod:`multiprocessing` 初始化时，主进程使用 :func:`os.urandom` 分配一个随机字符串。"

#: ../../library/multiprocessing.rst:632
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"当创建 :class:`Process` 对象时，它将继承其父进程的身份验证密钥，尽管可以通过将 :attr:`authkey` "
"设置为另一个字节字符串来更改。"

#: ../../library/multiprocessing.rst:636
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "参见 :ref:`multiprocessing-auth-keys` 。"

#: ../../library/multiprocessing.rst:640
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr "系统对象的数字句柄，当进程结束时将变为 \"ready\" 。"

#: ../../library/multiprocessing.rst:643
msgid ""
"You can use this value if you want to wait on several events at once using "
":func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join` is "
"simpler."
msgstr ""
"如果你想使用 :func:`multiprocessing.connection.wait` 来一次等待多个事件则可以使用此值。 在其他情况下调用 "
":meth:`join` 更为简单。"

#: ../../library/multiprocessing.rst:647
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and"
" ``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"在 Windows 上，这是一个可以与 ``WaitForSingleObject`` 和 ``WaitForMultipleObjects`` API"
" 调用族一起使用的 OS 句柄。 在 POSIX 上，这是一个可以与来自 :mod:`select` 模块的原语一起使用的文件描述符。"

#: ../../library/multiprocessing.rst:655
msgid ""
"Terminate the process.  On POSIX this is done using the "
":py:const:`~signal.SIGTERM` signal; on Windows :c:func:`!TerminateProcess` "
"is used.  Note that exit handlers and finally clauses, etc., will not be "
"executed."
msgstr ""
"终结进程。 在 POSIX 上这是使用 :py:const:`~signal.SIGTERM` 信号来完成的；在 Windows 上则会使用 "
":c:func:`!TerminateProcess`。 请注意 exit 处理器和 finally 子句等将不会被执行。"

#: ../../library/multiprocessing.rst:659
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr "请注意，进程的后代进程将不会被终止 —— 它们将简单地变成孤立的。"

#: ../../library/multiprocessing.rst:664
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable"
" by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"如果在关联进程使用管道或队列时使用此方法，则管道或队列可能会损坏，并可能无法被其他进程使用。类似地，如果进程已获得锁或信号量等，则终止它可能导致其他进程死锁。"

#: ../../library/multiprocessing.rst:672
msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr "与 :meth:`terminate` 相同但在 POSIX 上将使用 ``SIGKILL`` 信号。"

#: ../../library/multiprocessing.rst:678
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still running."
"  Once :meth:`close` returns successfully, most other methods and attributes"
" of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"关闭 :class:`Process` 对象，释放与之关联的所有资源。如果底层进程仍在运行，则会引发 :exc:`ValueError` 。一旦 "
":meth:`close` 成功返回， :class:`Process` 对象的大多数其他方法和属性将引发 :exc:`ValueError` 。"

#: ../../library/multiprocessing.rst:686
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"注意 :meth:`start` 、 :meth:`join` 、 :meth:`is_alive` 、 :meth:`terminate` 和 "
":attr:`exitcode` 方法只能由创建进程对象的进程调用。"

#: ../../library/multiprocessing.rst:690
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr ":class:`Process` 一些方法的示例用法："

#: ../../library/multiprocessing.rst:692
msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"

#: ../../library/multiprocessing.rst:711
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "所有 :mod:`multiprocessing` 异常的基类。"

#: ../../library/multiprocessing.rst:715
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr "当所提供的缓冲区对象太小而无法读取消息时由 :meth:`Connection.recv_bytes_into` 引发的异常。"

#: ../../library/multiprocessing.rst:718
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr "如果 ``e`` 是一个 :exc:`BufferTooShort` 实例，那么 ``e.args[0]`` 将把消息作为字节字符串给出。"

#: ../../library/multiprocessing.rst:723
msgid "Raised when there is an authentication error."
msgstr "出现身份验证错误时引发。"

#: ../../library/multiprocessing.rst:727
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "有超时的方法超时时引发。"

#: ../../library/multiprocessing.rst:730
msgid "Pipes and Queues"
msgstr "管道和队列"

#: ../../library/multiprocessing.rst:732
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization"
" primitives like locks."
msgstr "使用多进程时，一般使用消息机制实现进程间通信，尽可能避免使用同步原语，例如锁。"

#: ../../library/multiprocessing.rst:736
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr "消息机制包含： :func:`Pipe` (可以用于在两个进程间传递消息)，以及队列(能够在多个生产者和消费者之间通信)。"

#: ../../library/multiprocessing.rst:739
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues"
" modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and "
":meth:`~queue.Queue.join` methods introduced into Python 2.5's "
":class:`queue.Queue` class."
msgstr ""
":class:`Queue`, :class:`SimpleQueue` 以及 :class:`JoinableQueue` "
"都是多生产者，多消费者，并且实现了 :abbr:`FIFO (first-in, first-out)` 的队列类型，其表现与标准库中的 "
":class:`queue.Queue` 类相似。 不同之处在于 :class:`Queue`  缺少标准库的 :class:`queue.Queue`"
" 从 Python 2.5 开始引入的 :meth:`~queue.Queue.task_done` 和 "
":meth:`~queue.Queue.join` 方法。"

#: ../../library/multiprocessing.rst:746
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or else"
" the semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"如果你使用了 :class:`JoinableQueue` ，那么你 **必须** 对每个已经移出队列的任务调用 "
":meth:`JoinableQueue.task_done`。 不然的话用于统计未完成任务的信号量最终会溢出并抛出异常。"

#: ../../library/multiprocessing.rst:751
msgid ""
"One difference from other Python queue implementations, is that "
":mod:`multiprocessing` queues serializes all objects that are put into them "
"using :mod:`pickle`. The object return by the get method is a re-created "
"object that does not share memory with the original object."
msgstr ""
"与其他 Python 队列实现的区别之一，在于 :mod:`multiprocessing` 队列会使用 :mod:`pickle` "
"来序列化所有被放入的对象。 由获取方法所返回的对象是重新创建的对象，它不会与原始对象共享内存。"

#: ../../library/multiprocessing.rst:756
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr "另外还可以通过使用一个管理器对象创建一个共享队列，详见  :ref:`multiprocessing-managers` 。"

#: ../../library/multiprocessing.rst:761
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and "
":exc:`queue.Full` exceptions to signal a timeout.  They are not available in"
" the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`queue`."
msgstr ""
":mod:`multiprocessing` 使用了普通的 :exc:`queue.Empty` 和 :exc:`queue.Full` "
"异常去表示超时。 你需要从 :mod:`queue` 中导入它们，因为它们并不在 :mod:`multiprocessing` 的命名空间中。"

#: ../../library/multiprocessing.rst:768
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use"
" a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"当一个对象被放入一个队列中时，这个对象首先会被一个后台线程用 pickle 序列化，并将序列化后的数据通过一个底层管道的管道传递到队列中。 "
"这种做法会有点让人惊讶，但一般不会出现什么问题。 如果它们确实妨碍了你，你可以使用一个由管理器 :ref:`manager "
"<multiprocessing-managers>` 创建的队列替换它。"

#: ../../library/multiprocessing.rst:775
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"将一个对象放入一个空队列后，可能需要极小的延迟，队列的方法 :meth:`~Queue.empty`  才会返回  :const:`False` 。而"
"  :meth:`~Queue.get_nowait` 可以不抛出 :exc:`queue.Empty` 直接返回。"

#: ../../library/multiprocessing.rst:780
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"如果有多个进程同时将对象放入队列，那么在队列的另一端接受到的对象可能是无序的。但是由同一个进程放入的多个对象的顺序在另一端输出时总是一样的。"

#: ../../library/multiprocessing.rst:787
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"如果一个进程在尝试使用 :class:`Queue` 期间被 :meth:`Process.terminate` 或 :func:`os.kill` "
"调用终止了，那么队列中的数据很可能被破坏。 这可能导致其他进程在尝试使用该队列时发生异常。"

#: ../../library/multiprocessing.rst:794
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr ""
"正如刚才提到的，如果一个子进程将一些对象放进队列中 (并且它没有用  :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` "
"方法)，那么这个进程在所有缓冲区的对象被刷新进管道之前，是不会终止的。"

#: ../../library/multiprocessing.rst:799
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"这意味着，除非你确定所有放入队列中的对象都已经被消费了，否则如果你试图等待这个进程，你可能会陷入死锁中。相似地，如果该子进程不是后台进程，那么父进程可能在试图等待所有非后台进程退出时挂起。"

#: ../../library/multiprocessing.rst:804
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr "注意用管理器创建的队列不存在这个问题，详见  :ref:`multiprocessing-programming` 。"

#: ../../library/multiprocessing.rst:807
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "该 :ref:`multiprocessing-examples` 展示了如何使用队列实现进程间通信。"

#: ../../library/multiprocessing.rst:813
msgid ""
"Returns a pair ``(conn1, conn2)`` of "
":class:`~multiprocessing.connection.Connection` objects representing the "
"ends of a pipe."
msgstr ""
"返回一对 :class:`~multiprocessing.connection.Connection` 对象 ``(conn1, conn2)`` ，"
" 分别表示管道的两端。"

#: ../../library/multiprocessing.rst:817
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be"
" used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"如果 *duplex* 被置为 ``True`` (默认值)，那么该管道是双向的。如果 *duplex* 被置为 ``False`` "
"，那么该管道是单向的，即 ``conn1`` 只能用于接收消息，而  ``conn2`` 仅能用于发送消息。"

#: ../../library/multiprocessing.rst:822
msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the object "
"using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` re-"
"creates the object."
msgstr ""
"The :meth:`~multiprocessing.Connection.send` 方法将使用 :mod:`pickle` 来序列化对象而 "
":meth:`~multiprocessing.Connection.recv` 将重新创建对象。"

#: ../../library/multiprocessing.rst:827
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a feeder "
"thread is started which transfers objects from a buffer into the pipe."
msgstr "返回一个使用一个管道和少量锁和信号量实现的共享队列实例。当一个进程将一个对象放进队列中时，一个写入线程会启动并将对象从缓冲区写入管道中。"

#: ../../library/multiprocessing.rst:831
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"一旦超时，将抛出标准库 :mod:`queue`  模块中常见的异常 :exc:`queue.Empty` 和 :exc:`queue.Full`。"

#: ../../library/multiprocessing.rst:834
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except for"
" :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
"除了 :meth:`~queue.Queue.task_done` 和 :meth:`~queue.Queue.join` "
"之外，:class:`Queue`  实现了标准库类 :class:`queue.Queue` 中所有的方法。"

#: ../../library/multiprocessing.rst:839
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "返回队列的大致长度。由于多线程或者多进程的上下文，这个数字是不可靠的。"

#: ../../library/multiprocessing.rst:842
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""
"请注意这可能会在未实现 ``sem_getvalue()`` 的平台如 macOS 上引发 :exc:`NotImplementedError`。"

#: ../../library/multiprocessing.rst:847
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "如果队列是空的，返回 ``True`` ，反之返回 ``False`` 。 由于多线程或多进程的环境，该状态是不可靠的。"

#: ../../library/multiprocessing.rst:850
msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr "在已关闭的队列上可能会引发 :exc:`OSError`。 （但不保证如此）"

#: ../../library/multiprocessing.rst:854
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "如果队列是满的，返回 ``True`` ，反之返回 ``False`` 。 由于多线程或多进程的环境，该状态是不可靠的。"

#: ../../library/multiprocessing.rst:859
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a"
" free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free"
" slot was available within that time.  Otherwise (*block* is ``False``), put"
" an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"将 obj 放入队列。如果可选参数 *block* 是 ``True`` (默认值) 而且 *timeout* 是 ``None`` (默认值), "
"将会阻塞当前进程，直到有空的缓冲槽。如果 *timeout* 是正数，将会在阻塞了最多 *timeout* 秒之后还是没有可用的缓冲槽时抛出 "
":exc:`queue.Full`  异常。反之 (*block* 是 ``False`` 时)，仅当有可用缓冲槽时才放入对象，否则抛出 "
":exc:`queue.Full` 异常 (在这种情形下 *timeout* 参数会被忽略)。"

#: ../../library/multiprocessing.rst:868
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of "
":exc:`AssertionError`."
msgstr "如果队列已经关闭，会抛出  :exc:`ValueError`  而不是  :exc:`AssertionError` 。"

#: ../../library/multiprocessing.rst:874
msgid "Equivalent to ``put(obj, False)``."
msgstr "相当于 ``put(obj, False)``。"

#: ../../library/multiprocessing.rst:878
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it"
" blocks at most *timeout* seconds and raises the :exc:`queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is "
"``False``), return an item if one is immediately available, else raise the "
":exc:`queue.Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"从队列中取出并返回对象。如果可选参数 *block* 是 ``True`` (默认值) 而且 *timeout* 是 ``None`` (默认值), "
"将会阻塞当前进程，直到队列中出现可用的对象。如果 *timeout* 是正数，将会在阻塞了最多 *timeout* 秒之后还是没有可用的对象时抛出 "
":exc:`queue.Empty` 异常。反之 (*block* 是 ``False`` 时)，仅当有可用对象能够取出时返回，否则抛出 "
":exc:`queue.Empty` 异常 (在这种情形下 *timeout* 参数会被忽略)。"

#: ../../library/multiprocessing.rst:886
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of "
":exc:`OSError`."
msgstr "如果队列已经关闭，会抛出 :exc:`ValueError` 而不是 :exc:`OSError` 。"

#: ../../library/multiprocessing.rst:892
msgid "Equivalent to ``get(False)``."
msgstr "相当于 ``get(False)`` 。"

#: ../../library/multiprocessing.rst:894
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in "
":class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` 类有一些在 :class:`queue.Queue` "
"类中没有出现的方法。这些方法在大多数情形下并不是必须的。"

#: ../../library/multiprocessing.rst:900
msgid ""
"Indicate that no more data will be put on this queue by the current process."
"  The background thread will quit once it has flushed all buffered data to "
"the pipe.  This is called automatically when the queue is garbage collected."
msgstr "指示当前进程将不会再往队列中放入对象。一旦所有缓冲区中的数据被写入管道之后，后台的线程会退出。这个方法在队列被gc回收时会自动调用。"

#: ../../library/multiprocessing.rst:907
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all"
" data in the buffer has been flushed to the pipe."
msgstr ""
"等待后台线程。这个方法仅在调用了 :meth:`close` 方法之后可用。这会阻塞当前进程，直到后台线程退出，确保所有缓冲区中的数据都被写入管道中。"

#: ../../library/multiprocessing.rst:911
msgid ""
"By default if a process is not the creator of the queue then on exit it will"
" attempt to join the queue's background thread.  The process can call "
":meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"默认情况下，如果一个不是队列创建者的进程试图退出，它会尝试等待这个队列的后台线程。这个进程可以使用  "
":meth:`cancel_join_thread` 让  :meth:`join_thread` 方法什么都不做直接跳过。"

#: ../../library/multiprocessing.rst:917
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the"
" background thread from being joined automatically when the process exits --"
" see :meth:`join_thread`."
msgstr ""
"防止 :meth:`join_thread` 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。详见 "
":meth:`join_thread`。"

#: ../../library/multiprocessing.rst:921
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying"
" pipe, and you don't care about lost data."
msgstr ""
"这个方法更好的名字可能是 ``allow_exit_without_flush()``。 "
"这可能会导致已排入队列的数据丢失，几乎可以肯定你将不需要用到这个方法。 "
"实际上它仅适用于当你需要当前进程立即退出而不必等待将已排入的队列更新到下层管道，并且你不担心丢失数据的时候。"

#: ../../library/multiprocessing.rst:930
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue`"
" will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"该类的功能依赖于宿主操作系统具有可用的共享信号量实现。否则该类将被禁用，任何试图实例化一个 :class:`Queue` 对象的操作都会抛出 "
":exc:`ImportError` 异常，更多信息详见 :issue:`3770` 。后续说明的任何专用队列对象亦如此。"

#: ../../library/multiprocessing.rst:939
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked "
":class:`Pipe`."
msgstr "这是一个简化的 :class:`Queue` 类的实现，很像带锁的 :class:`Pipe` 。"

#: ../../library/multiprocessing.rst:943
msgid "Close the queue: release internal resources."
msgstr "关闭队列：释放内部资源。"

#: ../../library/multiprocessing.rst:945
msgid ""
"A queue must not be used anymore after it is closed. For example, "
":meth:`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr "队列在被关闭后就不可再被使用。 例如不可再调用 :meth:`get`, :meth:`put` 和 :meth:`empty` 等方法。"

#: ../../library/multiprocessing.rst:953
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "如果队列为空返回 ``True`` ，否则返回 ``False`` 。"

#: ../../library/multiprocessing.rst:955
msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr "如果 SimpleQueue 已关闭则总是会引发 :exc:`OSError`。"

#: ../../library/multiprocessing.rst:959
msgid "Remove and return an item from the queue."
msgstr "从队列中移出并返回一个对象。"

#: ../../library/multiprocessing.rst:963
msgid "Put *item* into the queue."
msgstr "将  *item* 放入队列。"

#: ../../library/multiprocessing.rst:968
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue` 类是 :class:`Queue` 的子类，额外添加了 :meth:`task_done` 和 "
":meth:`join` 方法。"

#: ../../library/multiprocessing.rst:973
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue consumers."
"  For each :meth:`~Queue.get` used to fetch a task, a subsequent call to "
":meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"指出之前进入队列的任务已经完成。由队列的消费者进程使用。对于每次调用  :meth:`~Queue.get`  获取的任务，执行完成后调用  "
":meth:`task_done`  告诉队列该任务已经处理完成。"

#: ../../library/multiprocessing.rst:978
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"如果 :meth:`~queue.Queue.join` 方法正在阻塞之中，该方法会在所有对象都被处理完的时候返回 (即对之前使用  "
":meth:`~Queue.put`  放进队列中的所有对象都已经返回了对应的  :meth:`task_done`  ) 。"

#: ../../library/multiprocessing.rst:982
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "如果被调用的次数多于放入队列中的项目数量，将引发 :exc:`ValueError` 异常 。"

#: ../../library/multiprocessing.rst:988
msgid "Block until all items in the queue have been gotten and processed."
msgstr "阻塞至队列中所有的元素都被接收和处理完毕。"

#: ../../library/multiprocessing.rst:990
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者进程调用 :meth:`task_done` "
"表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， :meth:`join` 阻塞被解除。"

#: ../../library/multiprocessing.rst:998
msgid "Miscellaneous"
msgstr "杂项"

#: ../../library/multiprocessing.rst:1002
msgid "Return list of all live children of the current process."
msgstr "返回当前进程存活的子进程的列表。"

#: ../../library/multiprocessing.rst:1004
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "调用该方法有“等待”已经结束的进程的副作用。"

#: ../../library/multiprocessing.rst:1009
msgid "Return the number of CPUs in the system."
msgstr "返回系统的CPU数量。"

#: ../../library/multiprocessing.rst:1011
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with "
":func:`os.process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""
"该数值不等于当前进程可使用的 CPU 数量。 可用的 CPU 数量可以通过 :func:`os.process_cpu_count` (或 "
"``len(os.sched_getaffinity(0))``) 获得。"

#: ../../library/multiprocessing.rst:1015
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is"
" raised."
msgstr "当 CPU 的数量无法确定时，会引发 :exc:`NotImplementedError` 。"

#: ../../library/multiprocessing.rst:1019
msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ":func:`os.cpu_count` :func:`os.process_cpu_count`"

#: ../../library/multiprocessing.rst:1024
msgid ""
"The return value can also be overridden using the :option:`-X cpu_count "
"<-X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper around "
"the :mod:`os` cpu count APIs."
msgstr ""
"返回值也可使用 :option:`-X cpu_count <-X>` 旗标或 :envvar:`PYTHON_CPU_COUNT` "
"来覆盖因为这只是一个针对 :mod:`os` cpu count API 的包装器。"

#: ../../library/multiprocessing.rst:1030
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "返回与当前进程相对应的 :class:`Process` 对象。"

#: ../../library/multiprocessing.rst:1032
msgid "An analogue of :func:`threading.current_thread`."
msgstr "和 :func:`threading.current_thread` 相同。"

#: ../../library/multiprocessing.rst:1036
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"返回父进程  :class:`Process`  对象，和父进程调用 :func:`current_process` "
"返回的对象一样。如果一个进程已经是主进程， ``parent_process`` 会返回 ``None``."

#: ../../library/multiprocessing.rst:1044
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce an executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"增加对于使用 :mod:`multiprocessing` 的程序已被冻结以产生可执行文件的支持。 （针对 **py2exe**, "
"**PyInstaller** 和 **cx_Freeze** 时行了测试。）"

#: ../../library/multiprocessing.rst:1048
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "需要在 main 模块的 ``if __name__ == '__main__'`` 该行之后马上调用该函数。例如："

#: ../../library/multiprocessing.rst:1051
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"

#: ../../library/multiprocessing.rst:1060
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"如果没有调用  ``freeze_support()`` 在尝试运行被冻结的可执行文件时会抛出 :exc:`RuntimeError` 异常。"

#: ../../library/multiprocessing.rst:1063
msgid ""
"Calling ``freeze_support()`` has no effect when the start method is not "
"*spawn*. In addition, if the module is being run normally by the Python "
"interpreter (the program has not been frozen), then ``freeze_support()`` has"
" no effect."
msgstr ""
"当启动方法不是 *spawn* 时调用 ``freeze_support()`` 不会有效果。 此外，如果该模块被 Python "
"解释器正常运行（程序未被冻结），则 ``freeze_support()`` 也不会有效果。"

#: ../../library/multiprocessing.rst:1070
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See "
":ref:`multiprocessing-start-methods`."
msgstr ""
"返回由受支持的启动方法组成的列表，其中第一项将为默认值。 可用的启动方法有 ``'fork'``, ``'spawn'`` 和 "
"``'forkserver'``。 并非所有的平台都支持所有的方法。 参见 :ref:`multiprocessing-start-methods`。"

#: ../../library/multiprocessing.rst:1079
msgid ""
"Return a context object which has the same attributes as the "
":mod:`multiprocessing` module."
msgstr "返回一个 Context 对象。该对象具有和 :mod:`multiprocessing` 模块相同的API。"

#: ../../library/multiprocessing.rst:1082
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  "
":exc:`ValueError` is raised if the specified start method is not available."
"  See :ref:`multiprocessing-start-methods`."
msgstr ""
"如果 *method* 为 ``None`` 则将返回默认的上下文。 否则 *method* 应为 ``'fork'``, ``'spawn'``, "
"``'forkserver'``。 如果指定的启动方法不可用则将引发 :exc:`ValueError`。 参见 "
":ref:`multiprocessing-start-methods`。"

#: ../../library/multiprocessing.rst:1091
msgid "Return the name of start method used for starting processes."
msgstr "返回启动进程时使用的启动方法名。"

#: ../../library/multiprocessing.rst:1093
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start"
" method has not been fixed and *allow_none* is true then ``None`` is "
"returned."
msgstr ""
"如果启动方法已经固定，并且   *allow_none* 被设置成 False "
"，那么启动方法将被固定为默认的启动方法，并且返回其方法名。如果启动方法没有设定，并且 *allow_none* 被设置成 True ，那么将返回  "
"``None``  。"

#: ../../library/multiprocessing.rst:1098
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"返回值可以为 ``'fork'``, ``'spawn'``, ``'forkserver'`` 或 ``None``。 参见 "
":ref:`multiprocessing-start-methods`。"

#: ../../library/multiprocessing.rst:1105
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"对于 macOS，*spawn* 启动方式是默认方式。 因为 *fork* 可能导致subprocess崩溃，被认为是不安全的，查看 "
":issue:`33725` 。"

#: ../../library/multiprocessing.rst:1111
msgid ""
"Set the path of the Python interpreter to use when starting a child process."
" (By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"设置在启动子进程时使用的 Python 解释器路径。 ( 默认使用  :data:`sys.executable`  ) 嵌入式编程人员可能需要这样做："

#: ../../library/multiprocessing.rst:1115
msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"

#: ../../library/multiprocessing.rst:1117
msgid "before they can create child processes."
msgstr "以使他们可以创建子进程。"

#: ../../library/multiprocessing.rst:1119
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr "当使用 ``'spawn'`` 启动方法时在 POSIX 上受到支持。"

#: ../../library/multiprocessing.rst:1122
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../library/multiprocessing.rst:1127
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""
"为 forkserver 主进程设置一个可尝试导入的模块名称列表以使得它们已导入的状态被分叉进程所继承。 当执行操作时引发的任何 "
":exc:`ImportError` 会被静默地忽略。 这可被用作一种性能增强措施以避免在每个进程中的重复操作。"

#: ../../library/multiprocessing.rst:1133
msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""
"要让此方法发挥作用，它必须在 forkserver 进程执行之前被调用（在创建 :class:`Pool` 或启动 :class:`Process` "
"之前）。"

#: ../../library/multiprocessing.rst:1136
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See "
":ref:`multiprocessing-start-methods`."
msgstr ""
"仅在使用 ``'forkserver'`` 启动方法时是有意义的。 参见 :ref:`multiprocessing-start-methods`。"

#: ../../library/multiprocessing.rst:1143
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises "
":exc:`RuntimeError` if the start method has already been set and *force* is "
"not ``True``.  If *method* is ``None`` and *force* is ``True`` then the "
"start method is set to ``None``.  If *method* is ``None`` and *force* is "
"``False`` then the context is set to the default context."
msgstr ""
"设置应当被用于启动子进程的方法。 *method* 方法可以为 ``'fork'``, ``'spawn'`` 或 ``'forkserver'``。 "
"如果启动方法已经设置且 *force* 不为 ``True`` 则会引发 :exc:`RuntimeError`。 如果 *method* 为 "
"``None`` 而 *force* 为 ``True`` 则启动方法会被设为 ``None``。 如果 *method* 为 ``None`` 而 "
"*force* 为 ``False`` 则上下文会被设为默认的上下文。"

#: ../../library/multiprocessing.rst:1150
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr "注意这最多只能调用一次，并且需要藏在 main 模块中，由  ``if __name__ == '__main__'`` 保护着。"

#: ../../library/multiprocessing.rst:1154
msgid "See :ref:`multiprocessing-start-methods`."
msgstr "参见 :ref:`multiprocessing-start-methods`。"

#: ../../library/multiprocessing.rst:1160
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ""
":mod:`multiprocessing`   并没有包含类似  :func:`threading.active_count` , "
":func:`threading.enumerate` ,  :func:`threading.settrace` , "
":func:`threading.setprofile`, :class:`threading.Timer` ,  或者 "
":class:`threading.local`  的方法和类。"

#: ../../library/multiprocessing.rst:1167
msgid "Connection Objects"
msgstr "连接对象（Connection）"

#: ../../library/multiprocessing.rst:1171
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr "Connection 对象允许收发可以序列化的对象或字符串。它们可以看作面向消息的连接套接字。"

#: ../../library/multiprocessing.rst:1174
msgid ""
"Connection objects are usually created using :func:`Pipe "
"<multiprocessing.Pipe>` -- see also :ref:`multiprocessing-listeners-"
"clients`."
msgstr ""
"通常使用  :func:`Pipe <multiprocessing.Pipe>`   创建 Connection 对象。详见 ：  "
":ref:`multiprocessing-listeners-clients`."

#: ../../library/multiprocessing.rst:1182
msgid ""
"Send an object to the other end of the connection which should be read using"
" :meth:`recv`."
msgstr "将一个对象发送到连接的另一端，可以用  :meth:`recv`  读取。"

#: ../../library/multiprocessing.rst:1185
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"发送的对象必须是可以序列化的，过大的对象 (  接近 32MiB+ ，这个值取决于操作系统 ) 有可能引发   :exc:`ValueError`   "
"异常。"

#: ../../library/multiprocessing.rst:1190
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there is something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was "
"closed."
msgstr ""
"返回一个由另一端使用 :meth:`send` 发送的对象。该方法会一直阻塞直到接收到对象。 如果对端关闭了连接或者没有东西可接收，将抛出   "
":exc:`EOFError` 异常。"

#: ../../library/multiprocessing.rst:1197
msgid "Return the file descriptor or handle used by the connection."
msgstr "返回由连接对象使用的描述符或者句柄。"

#: ../../library/multiprocessing.rst:1201
msgid "Close the connection."
msgstr "关闭连接对象。"

#: ../../library/multiprocessing.rst:1203
msgid "This is called automatically when the connection is garbage collected."
msgstr "当连接对象被垃圾回收时会自动调用。"

#: ../../library/multiprocessing.rst:1207
msgid "Return whether there is any data available to be read."
msgstr "返回连接对象中是否有可以读取的数据。"

#: ../../library/multiprocessing.rst:1209
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout*"
" is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"如果未指定  *timeout* ，此方法会马上返回。如果  *timeout* 是一个数字，则指定了最大阻塞的秒数。如果  *timeout* 是"
"   ``None``，那么将一直等待，不会超时。"

#: ../../library/multiprocessing.rst:1213
msgid ""
"Note that multiple connection objects may be polled at once by using "
":func:`multiprocessing.connection.wait`."
msgstr "注意通过使用  :func:`multiprocessing.connection.wait`   可以一次轮询多个连接对象。"

#: ../../library/multiprocessing.rst:1218
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr "从一个  :term:`bytes-like object` 对象中取出字节数组并作为一条完整消息发送。"

#: ../../library/multiprocessing.rst:1220
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a "
":exc:`ValueError` exception"
msgstr ""
"如果由  *offset*  给定了在 *buffer* 中读取数据的位置。 如果给定了 *size* ，那么将会从缓冲区中读取多个字节。 过大的缓冲区"
" ( 接近 32MiB+ ，此值依赖于操作系统 ) 有可能引发   :exc:`ValueError`  异常。"

#: ../../library/multiprocessing.rst:1227
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises "
":exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"以字符串形式返回一条从连接对象另一端发送过来的字节数据。此方法在接收到数据前将一直阻塞。 如果连接对象被对端关闭或者没有数据可读取，将抛出  "
":exc:`EOFError` 异常。"

#: ../../library/multiprocessing.rst:1232
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then "
":exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"如果给定了  *maxlength* 并且消息长于  *maxlength* 那么将抛出 :exc:`OSError` 并且该连接对象将不再可读。"

#: ../../library/multiprocessing.rst:1236
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of "
":exc:`OSError`."
msgstr "曾经该函数抛出 :exc:`IOError`  ，现在这是 :exc:`OSError` 的别名。"

#: ../../library/multiprocessing.rst:1243
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"将一条完整的字节数据消息读入  *buffer*  中并返回消息的字节数。 此方法在接收到数据前将一直阻塞。 "
"如果连接对象被对端关闭或者没有数据可读取，将抛出  :exc:`EOFError`  异常。"

#: ../../library/multiprocessing.rst:1249
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given"
" then the message will be written into the buffer from that position.  "
"Offset must be a non-negative integer less than the length of *buffer* (in "
"bytes)."
msgstr ""
" *buffer*  必须是一个可写的 :term:`bytes-like object`  。 如果给定了  *offset*  "
"该消息会被写入缓冲区对应的位置。   *offset* 必须是一个小于   *buffer* 长度 ( 以字节计 ) 的非负整数。"

#: ../../library/multiprocessing.rst:1254
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"如果缓冲区太小，则将引发  :exc:`BufferTooShort`  异常，并且完整的消息将会存放在异常实例      ``e``  的 "
"``e.args[0]``  中。  "

#: ../../library/multiprocessing.rst:1258
msgid ""
"Connection objects themselves can now be transferred between processes using"
" :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"现在连接对象自身可以通过 :meth:`Connection.send`   和  :meth:`Connection.recv`  在进程之间传递。"

#: ../../library/multiprocessing.rst:1262
msgid ""
"Connection objects also now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"连接对象现在支持上下文管理协议 -- 参见 :ref:`typecontextmanager`。 "
":meth:`~contextmanager.__enter__` 返回连接对象，而 :meth:`~contextmanager.__exit__` "
"将调用 :meth:`close`。"

#: ../../library/multiprocessing.rst:1266
msgid "For example:"
msgstr "例如:"

#: ../../library/multiprocessing.rst:1268
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"

#: ../../library/multiprocessing.rst:1291
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ":meth:`Connection.recv` 方法会自动解封它收到的数据，除非你能够信任发送消息的进程，否则此处可能有安全风险。"

#: ../../library/multiprocessing.rst:1295
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See "
":ref:`multiprocessing-auth-keys`."
msgstr ""
"因此，  除非连接对象是由 :func:`Pipe` 产生的，否则你应该仅在使用了某种认证手段之后才使用 "
":meth:`~Connection.recv` 和 :meth:`~Connection.send` 方法。 参考 "
":ref:`multiprocessing-auth-keys`。"

#: ../../library/multiprocessing.rst:1302
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr "如果一个进程在试图读写管道时被终止了，那么管道中的数据很可能是不完整的，因为此时可能无法确定消息的边界。"

#: ../../library/multiprocessing.rst:1308
msgid "Synchronization primitives"
msgstr "同步原语"

#: ../../library/multiprocessing.rst:1312
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for "
":mod:`threading` module."
msgstr "通常来说同步原语在多进程环境中并不像它们在多线程环境中那么必要。参考  :mod:`threading` 模块的文档。"

#: ../../library/multiprocessing.rst:1316
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr "注意可以使用管理器对象创建同步原语，参考 :ref:`multiprocessing-managers` 。"

#: ../../library/multiprocessing.rst:1321
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "类似  :class:`threading.Barrier` 的栅栏对象。"

#: ../../library/multiprocessing.rst:1327
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "非常类似 :class:`threading.BoundedSemaphore`  的有界信号量对象。"

#: ../../library/multiprocessing.rst:1330
#: ../../library/multiprocessing.rst:1468
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's"
" first argument is named *block*, as is consistent with "
":meth:`Lock.acquire`."
msgstr ""
"一个小小的不同在于，它的  ``acquire``  方法的第一个参数名是和  :meth:`Lock.acquire` 一样的 *block* 。"

#: ../../library/multiprocessing.rst:1334
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"在 macOS 平台上， 该对象于  :class:`Semaphore`  不同在于  ``sem_getvalue()`` "
"方法并没有在该平台上实现。"

#: ../../library/multiprocessing.rst:1339
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "条件变量：   :class:`threading.Condition` 的别名。"

#: ../../library/multiprocessing.rst:1341
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"指定的 *lock* 参数应该是 :mod:`multiprocessing`  模块中的   :class:`Lock`   或者  "
":class:`RLock` 对象。"

#: ../../library/multiprocessing.rst:1344
#: ../../library/multiprocessing.rst:1882
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "新增了 :meth:`~threading.Condition.wait_for`  方法。"

#: ../../library/multiprocessing.rst:1349
msgid "A clone of :class:`threading.Event`."
msgstr "  :class:`threading.Event`  的复制品。"

#: ../../library/multiprocessing.rst:1354
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once"
" a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or threads, "
"except as noted."
msgstr ""
"原始锁（非递归锁）对象，类似于   :class:`threading.Lock`  "
"。一旦一个进程或者线程拿到了锁，后续的任何其他进程或线程的其他请求都会被阻塞直到锁被释放。任何进程或线程都可以释放锁。除非另有说明，否则 "
":class:`multiprocessing.Lock`  用于进程或者线程的概念和行为都和 :class:`threading.Lock`  一致。"

#: ../../library/multiprocessing.rst:1362
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"注意   :class:`Lock`  实际上是一个工厂函数。它返回由默认上下文初始化的  "
"``multiprocessing.synchronize.Lock``  对象。"

#: ../../library/multiprocessing.rst:1366
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
"  :class:`Lock`  支持   :term:`context manager`  协议，可以在 :keyword:`with`  "
"语句中使用。"

#: ../../library/multiprocessing.rst:1371
#: ../../library/multiprocessing.rst:1422
msgid "Acquire a lock, blocking or non-blocking."
msgstr "可以阻塞或非阻塞地获得锁。"

#: ../../library/multiprocessing.rst:1373
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and"
" return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"如果  *block*   参数被设为  ``True``   ( 默认值 ) ， "
"对该方法的调用在锁处于释放状态之前都会阻塞，然后将锁设置为锁住状态并返回   ``True``  。需要注意的是第一个参数名与   "
":meth:`threading.Lock.acquire`  的不同。"

#: ../../library/multiprocessing.rst:1378
msgid ""
"With the *block* argument set to ``False``, the method call does not block."
"  If the lock is currently in a locked state, return ``False``; otherwise "
"set the lock to a locked state and return ``True``."
msgstr ""
"如果 *block* 参数被设置成 ``False`` ，方法的调用将不会阻塞。 如果锁当前处于锁住状态，将返回   ``False``  ； "
"否则将锁设置成锁住状态，并返回 ``True`` 。"

#: ../../library/multiprocessing.rst:1382
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can"
" not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"当  *timeout* 是一个正浮点数时，会在等待锁的过程中最多阻塞等待 *timeout* 秒，当  *timeout* 是负数时，效果和  "
"*timeout* 为0时一样，当  *timeout* 是 ``None`` （默认值）时，等待时间是无限长。需要注意的是，对于 *timeout* "
"参数是负数和 ``None`` 的情况, 其行为与  :meth:`threading.Lock.acquire` 是不一样的。当 *block* 参数"
" 为 ``False`` 时，  *timeout* 并没有实际用处，会直接忽略。否则，函数会在拿到锁后返回 ``True`` 或者 超时没拿到锁后返回"
" ``False`` 。"

#: ../../library/multiprocessing.rst:1397
msgid ""
"Release a lock.  This can be called from any process or thread, not only the"
" process or thread which originally acquired the lock."
msgstr "释放锁，可以在任何进程、线程使用，并不限于锁的拥有者。"

#: ../../library/multiprocessing.rst:1400
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"当尝试释放一个没有被持有的锁时，会抛出 :exc:`ValueError` 异常，除此之外其行为与 "
":meth:`threading.Lock.release` 一样。"

#: ../../library/multiprocessing.rst:1406
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"递归锁对象: 类似于 :class:`threading.RLock` "
"。递归锁必须由持有线程、进程亲自释放。如果某个进程或者线程拿到了递归锁，这个进程或者线程可以再次拿到这个锁而不需要等待。但是这个进程或者线程的拿锁操作和释放锁操作的次数必须相同。"

#: ../../library/multiprocessing.rst:1412
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default"
" context."
msgstr ""
"注意 :class:`RLock` 是一个工厂函数，调用后返回一个使用默认 context 初始化的 "
"``multiprocessing.synchronize.RLock`` 实例。"

#: ../../library/multiprocessing.rst:1416
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be"
" used in :keyword:`with` statements."
msgstr ""
":class:`RLock` 支持 :term:`context manager` 协议，因此可在 :keyword:`with` 语句内使用。"

#: ../../library/multiprocessing.rst:1424
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock"
" is in an unlocked state (not owned by any process or thread) unless the "
"lock is already owned by the current process or thread.  The current process"
" or thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation"
" of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"当 *block* 参数设置为 ``True`` "
"时，会一直阻塞直到锁处于空闲状态（没有被任何进程、线程拥有），除非当前进程或线程已经拥有了这把锁。然后当前进程/线程会持有这把锁（在锁没有其他持有者的情况下），锁内的递归等级加一，并返回"
" ``True`` . 注意， 这个函数第一个参数的行为和 :meth:`threading.RLock.acquire` "
"的实现有几个不同点，包括参数名本身。"

#: ../../library/multiprocessing.rst:1434
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or"
" thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"当 *block* 参数是 ``False`` , "
"将不会阻塞，如果此时锁被其他进程或者线程持有，当前进程、线程获取锁操作失败，锁的递归等级也不会改变，函数返回 ``False`` ,  "
"如果当前锁已经处于释放状态，则当前进程、线程则会拿到锁，并且锁内的递归等级加一，函数返回 ``True`` 。"

#: ../../library/multiprocessing.rst:1442
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that some of these behaviors of *timeout* differ"
" from the implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* 参数的使用方法及行为与 :meth:`Lock.acquire` 一样。但是要注意 *timeout* 的其中一些行为和 "
":meth:`threading.RLock.acquire` 中实现的行为是不同的。"

#: ../../library/multiprocessing.rst:1449
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting"
" for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"释放锁，使锁内的递归等级减一。如果释放后锁内的递归等级降低为0，则会重置锁的状态为释放状态（即没有被任何进程、线程持有），重置后如果有有其他进程和线程在等待这把锁，他们中的一个会获得这个锁而继续运行。如果释放后锁内的递归等级还没到达0，则这个锁仍将保持未释放状态且当前进程和线程仍然是持有者。"

#: ../../library/multiprocessing.rst:1457
msgid ""
"Only call this method when the calling process or thread owns the lock. An "
":exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"只有当前进程或线程是锁的持有者时，才允许调用这个方法。如果当前进程或线程不是这个锁的拥有者，或者这个锁处于已释放的状态(即没有任何拥有者)，调用这个方法会抛出"
" :exc:`AssertionError` 异常。注意这里抛出的异常类型和 :meth:`threading.RLock.release` "
"中实现的行为不一样。"

#: ../../library/multiprocessing.rst:1466
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "一种信号量对象:  类似于  :class:`threading.Semaphore`."

#: ../../library/multiprocessing.rst:1473
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"在 macOS 上，不支持  ``sem_timedwait`` ，所以，调用 ``acquire()`` 时如果使用 timeout "
"参数，会通过循环sleep来模拟这个函数的行为。"

#: ../../library/multiprocessing.rst:1478
msgid ""
"Some of this package's functionality requires a functioning shared semaphore"
" implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"这个包的某些功能依赖于宿主机系统的共享信号量的实现，如果系统没有这个特性， :mod:`multiprocessing.synchronize` "
"会被禁用，尝试导入这个模块会引发 :exc:`ImportError` 异常，详细信息请查看 :issue:`3770` 。"

#: ../../library/multiprocessing.rst:1486
msgid "Shared :mod:`ctypes` Objects"
msgstr "共享 :mod:`ctypes` 对象"

#: ../../library/multiprocessing.rst:1488
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "在共享内存上创建可被子进程继承的共享对象时是可行的。"

#: ../../library/multiprocessing.rst:1493
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"返回一个从共享内存上创建的 :mod:`ctypes` 对象。默认情况下返回的对象实际上是经过了同步器包装过的。可以通过 :class:`Value` "
"的 *value* 属性访问这个对象本身。"

#: ../../library/multiprocessing.rst:1497
#: ../../library/multiprocessing.rst:1584
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr ""
"*typecode_or_type* 指明了返回的对象类型: 它可能是一个 ctypes 类型或者  :mod:`array`  "
"模块中每个类型对应的单字符长度的字符串。 *\\*args* 会透传给这个类的构造函数。"

#: ../../library/multiprocessing.rst:1501
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` or"
" :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"如果 *lock* 参数是 ``True`` （默认值）, 将会新建一个递归锁用于同步对于此值的访问操作。 如果 *lock* 是 "
":class:`Lock` 或者 :class:`RLock` 对象，那么这个传入的锁将会用于同步对这个值的访问操作，如果 *lock* 是 "
"``False`` , 那么对这个对象的访问将没有锁保护，也就是说这个变量不是进程安全的。"

#: ../../library/multiprocessing.rst:1508
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"诸如 ``+=`` "
"这类的操作会引发独立的读操作和写操作，也就是说这类操作符并不具有原子性。所以，如果你想让递增共享变量的操作具有原子性，仅仅以这样的方式并不能达到要求::"

#: ../../library/multiprocessing.rst:1512
msgid "counter.value += 1"
msgstr "counter.value += 1"

#: ../../library/multiprocessing.rst:1514
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr "共享对象内部关联的锁是递归锁(默认情况下就是)的情况下， 你可以采用这种方式 ::"

#: ../../library/multiprocessing.rst:1517
msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""
"with counter.get_lock():\n"
"    counter.value += 1"

#: ../../library/multiprocessing.rst:1520
#: ../../library/multiprocessing.rst:1610
#: ../../library/multiprocessing.rst:1625
msgid "Note that *lock* is a keyword-only argument."
msgstr "注意 *lock* 只能是命名参数。"

#: ../../library/multiprocessing.rst:1524
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr "从共享内存中申请并返回一个具有ctypes类型的数组对象。默认情况下返回值实际上是被同步器包装过的数组对象。"

#: ../../library/multiprocessing.rst:1527
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* 指明了返回的数组中的元素类型: 它可能是一个 ctypes 类型或者  :mod:`array` "
"模块中每个类型对应的单字符长度的字符串。 如果 *size_or_initializer* "
"是一个整数，那就会当做数组的长度，并且整个数组的内存会初始化为0。否则，如果  *size_or_initializer* "
"会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。"

#: ../../library/multiprocessing.rst:1534
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"如果 *lock* 为 ``True`` (默认值) 则将创建一个新的锁对象用于同步对值的访问。 如果 *lock* 为一个 :class:`Lock`"
" 或 :class:`RLock` 对象则该对象将被用于同步对值的访问。 如果 *lock* 为 ``False`` "
"则对返回对象的访问将不会自动得到锁的保护，也就是说它不是“进程安全的”。"

#: ../../library/multiprocessing.rst:1541
msgid "Note that *lock* is a keyword only argument."
msgstr "请注意 *lock* 是一个仅限关键字参数。"

#: ../../library/multiprocessing.rst:1543
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes"
" which allow one to use it to store and retrieve strings."
msgstr "请注意 :data:`ctypes.c_char` 的数组具有 *value* 和 *raw* 属性，允许被用来保存和提取字符串。"

#: ../../library/multiprocessing.rst:1548
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` 模块"

#: ../../library/multiprocessing.rst:1553
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` 模块提供了一些函数，用于分配来自共享内存的、可被子进程继承的 "
":mod:`ctypes` 对象。"

#: ../../library/multiprocessing.rst:1559
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process"
" may cause a crash."
msgstr ""
"虽然可以将指针存储在共享内存中，但请记住它所引用的是特定进程地址空间中的位置。 "
"而且，指针很可能在第二个进程的上下文中无效，尝试从第二个进程对指针进行解引用可能会导致崩溃。"

#: ../../library/multiprocessing.rst:1567
msgid "Return a ctypes array allocated from shared memory."
msgstr "从共享内存中申请并返回一个 ctypes 数组。"

#: ../../library/multiprocessing.rst:1569
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* 指明了返回的数组中的元素类型: 它可能是一个 ctypes 类型或者  :mod:`array` "
"模块中使用的类型字符。 如果 *size_or_initializer* 是一个整数，那就会当做数组的长度，并且整个数组的内存会初始化为0。否则，如果"
"  *size_or_initializer* 会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。"

#: ../../library/multiprocessing.rst:1576
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use "
":func:`Array` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "注意对元素的访问、赋值操作可能是非原子操作 - 使用 :func:`Array` , 从而借助其中的锁保证操作的原子性。"

#: ../../library/multiprocessing.rst:1582
msgid "Return a ctypes object allocated from shared memory."
msgstr "从共享内存中申请并返回一个 ctypes 对象。"

#: ../../library/multiprocessing.rst:1588
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "注意对 value 的访问、赋值操作可能是非原子操作 - 使用 :func:`Value` ，从而借助其中的锁保证操作的原子性。"

#: ../../library/multiprocessing.rst:1592
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"请注意 :data:`ctypes.c_char` 的数组具有 *value* 和 *raw* 属性，允许被用来保存和提取字符串 - 请查看 "
":mod:`ctypes` 文档。"

#: ../../library/multiprocessing.rst:1598
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" array."
msgstr ""
"返回一个纯 ctypes 数组, 或者在此之上经过同步器包装过的进程安全的对象，这取决于 *lock* 参数的值，除此之外，和 "
":func:`RawArray` 一样。"

#: ../../library/multiprocessing.rst:1602
#: ../../library/multiprocessing.rst:1618
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr ""
"如果 *lock* 为 ``True`` (默认值) 则将创建一个新的锁对象用于同步对值的访问。 如果 *lock* 为一个 "
":class:`~multiprocessing.Lock` 或 :class:`~multiprocessing.RLock` "
"对象则该对象将被用于同步对值的访问。 如果 *lock* 为 ``False`` "
"则对所返回对象的访问将不会自动得到锁的保护，也就是说它将不是“进程安全的”。"

#: ../../library/multiprocessing.rst:1614
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" object."
msgstr ""
"返回一个纯 ctypes 数组, 或者在此之上经过同步器包装过的进程安全的对象，这取决于 *lock* 参数的值，除此之外，和 "
":func:`RawArray` 一样。"

#: ../../library/multiprocessing.rst:1629
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr "从共享内存中申请一片空间将 ctypes 对象 *obj* 过来，然后返回一个新的 ctypes 对象。"

#: ../../library/multiprocessing.rst:1634
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a "
":class:`multiprocessing.RLock` object is created automatically."
msgstr ""
"将一个 ctypes 对象包装为进程安全的对象并返回，使用 *lock* 同步对于它的操作。如果 *lock* 是 ``None`` (默认值) "
"，则会自动创建一个 :class:`multiprocessing.RLock` 对象。"

#: ../../library/multiprocessing.rst:1638
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr ""
"同步器包装后的对象会在原有对象基础上额外增加两个方法: :meth:`get_obj` 返回被包装的对象，  :meth:`get_lock` "
"返回内部用于同步的锁。"

#: ../../library/multiprocessing.rst:1642
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "需要注意的是，访问包装后的ctypes对象会比直接访问原来的纯 ctypes 对象慢得多。"

#: ../../library/multiprocessing.rst:1645
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "同步器包装后的对象支持 :term:`context manager` 协议。"

#: ../../library/multiprocessing.rst:1649
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"下面的表格对比了创建普通ctypes对象和基于共享内存上创建共享ctypes对象的语法。（表格中的 ``MyStruct`` 是 "
":class:`ctypes.Structure` 的子类）"

#: ../../library/multiprocessing.rst:1654
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using type"
msgstr "使用类型的共享ctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using typecode"
msgstr "使用 typecode 的共享 ctypes"

#: ../../library/multiprocessing.rst:1656
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1657
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1657
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1658
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1659
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1663
msgid ""
"Below is an example where a number of ctypes objects are modified by a child"
" process::"
msgstr "下面是一个在子进程中修改多个ctypes对象的例子。"

#: ../../library/multiprocessing.rst:1666
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"

#: ../../library/multiprocessing.rst:1701
msgid "The results printed are ::"
msgstr "输出如下 ::"

#: ../../library/multiprocessing.rst:1703
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"

#: ../../library/multiprocessing.rst:1714
msgid "Managers"
msgstr "管理器"

#: ../../library/multiprocessing.rst:1716
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages"
" *shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"管理器提供了一种创建共享数据的方法，从而可以在不同进程中共享，甚至可以通过网络跨机器共享数据。管理器维护一个用于管理 *共享对象* "
"的服务。其他进程可以通过代理访问这些共享对象。"

#: ../../library/multiprocessing.rst:1725
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"返回一个已启动的 :class:`~multiprocessing.managers.SyncManager` "
"管理器对象，这个对象可以用于在不同进程中共享数据。返回的管理器对象对应了一个已经启动的子进程，并且拥有一系列方法可以用于创建共享对象、返回对应的代理。"

#: ../../library/multiprocessing.rst:1733
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr ""
"当管理器被垃圾回收或者父进程退出时，管理器进程会立即退出。管理器类定义在 :mod:`multiprocessing.managers` 模块:"

#: ../../library/multiprocessing.rst:1739
msgid "Create a BaseManager object."
msgstr "创建一个 BaseManager 对象。"

#: ../../library/multiprocessing.rst:1741
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers to"
" a started manager process."
msgstr ""
"一旦创建，应该及时调用 :meth:`start` 或者  ``get_server().serve_forever()`` "
"以确保管理器对象对应的管理进程已经启动。"

#: ../../library/multiprocessing.rst:1744
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr "*address* 是管理器服务进程监听的地址。如果 *address* 是 ``None`` ,则允许和任意主机的请求建立连接。"

#: ../../library/multiprocessing.rst:1747
msgid ""
"*authkey* is the authentication key which will be used to check the validity"
" of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* 是认证标识，用于检查连接服务进程的请求合法性。如果 *authkey* 是 ``None``, 则会使用 "
"``current_process().authkey`` , 否则，就使用 *authkey* , 需要保证它必须是 byte 类型的字符串。"

#: ../../library/multiprocessing.rst:1752
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* 必须为 ``'pickle'`` (使用 :mod:`pickle` 序列化) 或 ``'xmlrpclib'`` (使用 "
":mod:`xmlrpc.client` 序列化)。"

#: ../../library/multiprocessing.rst:1755
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the "
":func:`get_context` function."
msgstr "*ctx* 是一个上下文对象，或者为 ``None`` (使用当前上下文)。 参见 :func:`get_context` 函数。"

#: ../../library/multiprocessing.rst:1758
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* 是用于等待直到 :meth:`shutdown` 方法中的管理器所使用的进程结束的超时秒数。 "
"如果关闭超时，进程将被终结。 如果终结进程的操作也超时，进程将被杀掉。"

#: ../../library/multiprocessing.rst:1763
msgid "Added the *shutdown_timeout* parameter."
msgstr "添加了 *shutdown_timeout* 形参。"

#: ../../library/multiprocessing.rst:1768
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"为管理器开启一个子进程，如果 *initializer* 不是 ``None`` , 子进程在启动时将会调用  "
"``initializer(*initargs)`` 。"

#: ../../library/multiprocessing.rst:1773
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr ""
"返回一个  :class:`Server`  对象，它是管理器在后台控制的真实的服务。 :class:`Server`  对象拥有 "
":meth:`serve_forever` 方法。"

#: ../../library/multiprocessing.rst:1777
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"

#: ../../library/multiprocessing.rst:1782
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` 额外拥有一个 :attr:`address` 属性。"

#: ../../library/multiprocessing.rst:1786
msgid "Connect a local manager object to a remote manager process::"
msgstr "将本地管理器对象连接到一个远程管理器进程::"

#: ../../library/multiprocessing.rst:1788
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"

#: ../../library/multiprocessing.rst:1794
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr "停止管理器的进程。这个方法只能用于已经使用 :meth:`start` 启动的服务进程。"

#: ../../library/multiprocessing.rst:1797
msgid "This can be called multiple times."
msgstr "它可以被多次调用。"

#: ../../library/multiprocessing.rst:1801
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr "一个 classmethod，可以将一个类型或者可调用对象注册到管理器类。"

#: ../../library/multiprocessing.rst:1804
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* 是一种 \"类型标识符\"，用于唯一表示某种共享对象类型，必须是一个字符串。"

#: ../../library/multiprocessing.rst:1807
msgid ""
"*callable* is a callable used for creating objects for this type identifier."
"  If a manager instance will be connected to the server using the "
":meth:`connect` method, or if the *create_method* argument is ``False`` then"
" this can be left as ``None``."
msgstr ""
"*callable* 是一个用来为此类型标识符创建对象的可调用对象。如果一个管理器实例将使用 :meth:`connect` 方法连接到服务器，或者 "
"*create_method* 参数为 ``False``，那么这里可留下 ``None``。"

#: ../../library/multiprocessing.rst:1813
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* 是  :class:`BaseProxy`  的子类，可以根据 *typeid* 为共享对象创建一个代理，如果是 "
"``None`` , 则会自动创建一个代理类。"

#: ../../library/multiprocessing.rst:1817
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy._callmethod`."
"  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is used instead"
" if it exists.)  In the case where no exposed list is specified, all "
"\"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* 是一个函数名组成的序列，用来指明只有这些方法可以使用 :meth:`BaseProxy._callmethod` 代理。(如果 "
"*exposed* 是 ``None``, 则会在 :attr:`proxytype._exposed_` 存在的情况下转而使用它) "
"当暴露的方法列表没有指定的时候，共享对象的所有 “公共方法” 都会被代理。（这里的“公共方法”是指所有拥有 "
":meth:`~object.__call__` 方法并且不是以 ``'_'`` 开头的属性）"

#: ../../library/multiprocessing.rst:1826
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid"
" strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a "
"method's name is not a key of this mapping or if the mapping is ``None`` "
"then the object returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* 是一个映射，用来指定那些应该返回代理对象的暴露方法所返回的类型。（如果 *method_to_typeid* 是 "
"``None``, 则 :attr:`proxytype._method_to_typeid_` "
"会在存在的情况下被使用）如果方法名称不在这个映射中或者映射是 ``None`` ,则方法返回的对象会是一个值拷贝。"

#: ../../library/multiprocessing.rst:1833
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared"
" object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* 指明，是否要创建一个以 *typeid* 命名并返回一个代理对象的方法，这个函数会被服务进程用于创建共享对象，默认为 "
"``True`` 。"

#: ../../library/multiprocessing.rst:1837
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` 实例也有一个只读属性。"

#: ../../library/multiprocessing.rst:1841
msgid "The address used by the manager."
msgstr "管理器所用的地址。"

#: ../../library/multiprocessing.rst:1843
msgid ""
"Manager objects support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the "
"server process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"管理器对象支持上下文管理协议 - 查看 :ref:`typecontextmanager` "
"。:meth:`~contextmanager.__enter__` 启动服务进程（如果它还没有启动）并且返回管理器对象， "
":meth:`~contextmanager.__exit__` 会调用 :meth:`shutdown` 。"

#: ../../library/multiprocessing.rst:1849
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr "在之前的版本中，如果管理器服务进程没有启动， :meth:`~contextmanager.__enter__` 不会负责启动它。"

#: ../../library/multiprocessing.rst:1854
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization"
" of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr ""
":class:`BaseManager` 的子类，可用于进程的同步。这个类型的对象使用 :func:`multiprocessing.Manager` "
"创建。"

#: ../../library/multiprocessing.rst:1858
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This"
" notably includes shared lists and dictionaries."
msgstr ""
"它拥有一系列方法，可以为大部分常用数据类型创建并返回 :ref:`multiprocessing-proxy_objects` "
"代理，用于进程间同步。甚至包括共享列表和字典。"

#: ../../library/multiprocessing.rst:1864
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr "创建一个共享的 :class:`threading.Barrier` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1871
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "创建一个共享的 :class:`threading.BoundedSemaphore` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1876
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr "创建一个共享的 :class:`threading.Condition` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1879
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr ""
"如果提供了 *lock* 参数，那它必须是 :class:`threading.Lock` 或 :class:`threading.RLock` "
"的代理对象。"

#: ../../library/multiprocessing.rst:1887
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "创建一个共享的 :class:`threading.Event` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1891
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "创建一个共享的 :class:`threading.Lock` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1895
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "创建一个共享的 :class:`Namespace` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1899
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "创建一个共享的 :class:`queue.Queue` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1903
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "创建一个共享的 :class:`threading.RLock` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1907
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr "创建一个共享的 :class:`threading.Semaphore` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1912
msgid "Create an array and return a proxy for it."
msgstr "创建一个数组并返回它的代理。"

#: ../../library/multiprocessing.rst:1916
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "创建一个具有可写 ``value`` 属性的对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1923
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "创建一个共享的 :class:`dict` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1928
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "创建一个共享的 :class:`list` 对象并返回它的代理。"

#: ../../library/multiprocessing.rst:1930
msgid ""
"Shared objects are capable of being nested.  For example, a shared container"
" object such as a shared list can contain other shared objects which will "
"all be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"共享对象能够嵌套。例如, 共享的容器对象如共享列表，可以包含另一个共享对象，他们全都会在 :class:`SyncManager` 中进行管理和同步。"

#: ../../library/multiprocessing.rst:1937
msgid "A type that can register with :class:`SyncManager`."
msgstr "一个可以注册到 :class:`SyncManager` 的类型。"

#: ../../library/multiprocessing.rst:1939
msgid ""
"A namespace object has no public methods, but does have writable attributes."
" Its representation shows the values of its attributes."
msgstr "命名空间对象没有公共方法，但是拥有可写的属性。直接print会显示所有属性的值。"

#: ../../library/multiprocessing.rst:1942
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr "值得一提的是，当对命名空间对象使用代理的时候，访问所有名称以 ``'_'`` 开头的属性都只是代理器上的属性，而不是命名空间对象的属性。"

#: ../../library/multiprocessing.rst:1946
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # 这是该代理的一个属性\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"

#: ../../library/multiprocessing.rst:1959
msgid "Customized managers"
msgstr "自定义管理器"

#: ../../library/multiprocessing.rst:1961
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types"
" or callables with the manager class.  For example::"
msgstr ""
"要创建一个自定义的管理器，需要新建一个 :class:`BaseManager` 的子类，然后使用这个管理器类上的 "
":meth:`~BaseManager.register` 类方法将新类型或者可调用方法注册上去。例如::"

#: ../../library/multiprocessing.rst:1965
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # 打印 7\n"
"        print(maths.mul(7, 8))         # 打印 56"

#: ../../library/multiprocessing.rst:1986
msgid "Using a remote manager"
msgstr "使用远程管理器"

#: ../../library/multiprocessing.rst:1988
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr "可以将管理器服务运行在一台机器上，然后使用客户端从其他机器上访问。(假设它们的防火墙允许)"

#: ../../library/multiprocessing.rst:1991
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr "运行下面的代码可以启动一个服务，此付包含了一个共享队列，允许远程客户端访问::"

#: ../../library/multiprocessing.rst:1994
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2003
msgid "One client can access the server as follows::"
msgstr "远程客户端可以通过下面的方式访问服务::"

#: ../../library/multiprocessing.rst:2005
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"

#: ../../library/multiprocessing.rst:2013
msgid "Another client can also use it::"
msgstr "也可以通过下面的方式::"

#: ../../library/multiprocessing.rst:2015
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"

#: ../../library/multiprocessing.rst:2024
msgid ""
"Local processes can also access that queue, using the code from above on the"
" client to access it remotely::"
msgstr "本地进程也可以访问这个队列，利用上面的客户端代码通过远程方式访问::"

#: ../../library/multiprocessing.rst:2027
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2049
msgid "Proxy Objects"
msgstr "代理对象"

#: ../../library/multiprocessing.rst:2051
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"代理是一个 *指向* 其他共享对象的对象，这个对象(很可能)在另外一个进程中。共享对象也可以说是代理 *指涉* "
"的对象。多个代理对象可能指向同一个指涉对象。"

#: ../../library/multiprocessing.rst:2055
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"代理对象代理了指涉对象的一系列方法调用(虽然并不是指涉对象的每个方法都有必要被代理)。通过这种方式，代理的使用方法可以和它的指涉对象一样::"

#: ../../library/multiprocessing.rst:2059
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"

#: ../../library/multiprocessing.rst:2073
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"注意，对代理使用 :func:`str` 函数会返回指涉对象的字符串表示，但是 :func:`repr` 却会返回代理本身的内部字符串表示。"

#: ../../library/multiprocessing.rst:2077
msgid ""
"An important feature of proxy objects is that they are picklable so they can"
" be passed between processes.  As such, a referent can contain "
":ref:`multiprocessing-proxy_objects`.  This permits nesting of these managed"
" lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"被代理的对象很重要的一点是必须可以被序列化，这样才能允许他们在进程间传递。因此，指涉对象可以包含 :ref:`multiprocessing-"
"proxy_objects` 。这允许管理器中列表、字典或者其他 :ref:`multiprocessing-proxy_objects` "
"对象之间的嵌套。"

#: ../../library/multiprocessing.rst:2082
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # a 的引用对象现在包含 b 的引用对象\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"

#: ../../library/multiprocessing.rst:2093
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "类似地，字典和列表代理也可以相互嵌套::"

#: ../../library/multiprocessing.rst:2095
msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"

#: ../../library/multiprocessing.rst:2106
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained"
" in a referent, modifications to those mutable values will not be propagated"
" through the manager because the proxy has no way of knowing when the values"
" contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"如果指涉对象包含了普通 :class:`list` 或 :class:`dict` "
"对象，对这些内部可变对象的修改不会通过管理器传播，因为代理无法得知被包含的值什么时候被修改了。但是把存放在容器代理中的值本身是会通过管理器传播的（会触发代理对象中的"
" ``__setitem__`` ）从而有效修改这些对象，所以可以把修改过的值重新赋值给容器代理::"

#: ../../library/multiprocessing.rst:2114
msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""
"# 创建一个代理列表并添加一个可变对象（字典）\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# 现在改变该字典\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# 这时，对 d 的改变尚未同步，但通过更新该字典，\n"
"# 代理将得到改变的通知\n"
"lproxy[0] = d"

#: ../../library/multiprocessing.rst:2125
msgid ""
"This approach is perhaps less convenient than employing nested "
":ref:`multiprocessing-proxy_objects` for most use cases but also "
"demonstrates a level of control over the synchronization."
msgstr ""
"在大多是使用情形下，这种实现方式并不比嵌套 :ref:`multiprocessing-proxy_objects` "
"方便，但是依然演示了对于同步的一种控制级别。"

#: ../../library/multiprocessing.rst:2131
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ":mod:`multiprocessing` 中的代理类并没有提供任何对于代理值比较的支持。所以，我们会得到如下结果::"

#: ../../library/multiprocessing.rst:2134
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"

#: ../../library/multiprocessing.rst:2139
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "当需要比较值的时候，应该替换为使用指涉对象的拷贝。"

#: ../../library/multiprocessing.rst:2143
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "代理对象是 :class:`BaseProxy` 派生类的实例。"

#: ../../library/multiprocessing.rst:2147
msgid "Call and return the result of a method of the proxy's referent."
msgstr "调用指涉对象的方法并返回结果。"

#: ../../library/multiprocessing.rst:2149
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "如果 ``proxy`` 是一个代理且其指涉的是 ``obj`` , 那么下面的表达式::"

#: ../../library/multiprocessing.rst:2151
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr "proxy._callmethod(methodname, args, kwds)"

#: ../../library/multiprocessing.rst:2153
msgid "will evaluate the expression ::"
msgstr "相当于求取以下表达式的值::"

#: ../../library/multiprocessing.rst:2155
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr "getattr(obj, methodname)(*args, **kwds)"

#: ../../library/multiprocessing.rst:2157
msgid "in the manager's process."
msgstr "于管理器进程。"

#: ../../library/multiprocessing.rst:2159
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"返回结果会是一个值拷贝或者一个新的共享对象的代理 - 见函数 :meth:`BaseManager.register` 中关于参数 "
"*method_to_typeid* 的文档。"

#: ../../library/multiprocessing.rst:2163
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is "
"raised by :meth:`_callmethod`."
msgstr ""
"如果这个调用熬出了异常，则这个异常会被 :meth:`_callmethod` 透传出来。如果是管理器进程本身抛出的一些其他异常，则会被 "
":meth:`_callmethod` 转换为 :exc:`RemoteError` 异常重新抛出。"

#: ../../library/multiprocessing.rst:2168
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr "特别注意，如果 *methodname* 没有 *暴露* 出来，将会引发一个异常。"

#: ../../library/multiprocessing.rst:2171
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` 的一个使用示例:"

#: ../../library/multiprocessing.rst:2173
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # 等价于 l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # 等价于 l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"

#: ../../library/multiprocessing.rst:2187
msgid "Return a copy of the referent."
msgstr "返回指涉对象的一份拷贝。"

#: ../../library/multiprocessing.rst:2189
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "如果指涉对象无法序列化，则会抛出一个异常。"

#: ../../library/multiprocessing.rst:2193
msgid "Return a representation of the proxy object."
msgstr "返回代理对象的内部字符串表示。"

#: ../../library/multiprocessing.rst:2197
msgid "Return the representation of the referent."
msgstr "返回指涉对象的内部字符串表示。"

#: ../../library/multiprocessing.rst:2201
msgid "Cleanup"
msgstr "清理"

#: ../../library/multiprocessing.rst:2203
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "代理对象使用了一个弱引用回调函数，当它被垃圾回收时，会将自己从拥有此指涉对象的管理器上反注册，"

#: ../../library/multiprocessing.rst:2206
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "当共享对象没有被任何代理器引用时，会被管理器进程删除。"

#: ../../library/multiprocessing.rst:2211
msgid "Process Pools"
msgstr "进程池"

#: ../../library/multiprocessing.rst:2216
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr "可以创建一个进程池，它将使用 :class:`Pool` 类执行提交给它的任务。"

#: ../../library/multiprocessing.rst:2221
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr "一个进程池对象，它控制可以提交作业的工作进程池。它支持带有超时和回调的异步结果，以及一个并行的 map 实现。"

#: ../../library/multiprocessing.rst:2225
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* 是要使用的工作进程数量。 如果 *processes* 为 ``None`` 则使用 "
":func:`os.process_cpu_count` 所返回的数值。"

#: ../../library/multiprocessing.rst:2228
#: ../../library/multiprocessing.rst:2792
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"如果 *initializer* 不为 ``None``，则每个工作进程将会在启动时调用 ``initializer(*initargs)``。"

#: ../../library/multiprocessing.rst:2231
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* 是一个工作进程在它退出或被一个新的工作进程代替之前能完成的任务数量，为了释放未使用的资源。默认的 "
"*maxtasksperchild* 是 ``None``，意味着工作进程寿与池齐。"

#: ../../library/multiprocessing.rst:2236
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function "
":func:`multiprocessing.Pool` or the :meth:`Pool` method of a context object."
"  In both cases *context* is set appropriately."
msgstr ""
"*context* 可被用于指定启动的工作进程的上下文。通常一个进程池是使用函数 :func:`multiprocessing.Pool` "
"或者一个上下文对象的 :meth:`Pool` 方法创建的。在这两种情况下， *context* 都是适当设置的。"

#: ../../library/multiprocessing.rst:2242
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "注意，进程池对象的方法只有创建它的进程能够调用。"

#: ../../library/multiprocessing.rst:2246
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context"
" manager or by calling :meth:`close` and :meth:`terminate` manually. Failure"
" to do this can lead to the process hanging on finalization."
msgstr ""
":class:`multiprocessing.pool` 对象具有需要正确管理的内部资源 "
"（像任何其他资源一样），具体方式是将进程池用作上下文管理器，或者手动调用 :meth:`close` 和 :meth:`terminate`。 "
"未做此类操作将导致进程在终结阶段挂起。"

#: ../../library/multiprocessing.rst:2251
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"请注意依赖垃圾回收器来销毁进程池是 **不正确的** 做法，因为 CPython 并不保证进程池终结器会被调用（请参阅 "
":meth:`object.__del__` 来了解详情）。"

#: ../../library/multiprocessing.rst:2255
msgid "Added the *maxtasksperchild* parameter."
msgstr "增加了 *maxtasksperchild* 形参。"

#: ../../library/multiprocessing.rst:2258
msgid "Added the *context* parameter."
msgstr "增加了 *context* 形参。"

#: ../../library/multiprocessing.rst:2261
msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of "
":func:`os.cpu_count`."
msgstr ""
"在默认情况下 *processes* 将使用 :func:`os.process_cpu_count`，而不是 "
":func:`os.cpu_count`。"

#: ../../library/multiprocessing.rst:2267
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems"
" (such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old"
" one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"通常来说，:class:`Pool` 中的 Worker 进程的生命周期和进程池的工作队列一样长。一些其他系统中（如 Apache, mod_wsgi "
"等）也可以发现另一种模式，他们会让工作进程在完成一些任务后退出，清理、释放资源，然后启动一个新的进程代替旧的工作进程。 :class:`Pool` 的 "
"*maxtasksperchild* 参数给用户提供了这种能力。"

#: ../../library/multiprocessing.rst:2277
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"使用 *args* 参数以及 *kwds* 命名参数调用 *func* , 它会返回结果前阻塞。这种情况下，:meth:`apply_async` "
"更适合并行化工作。另外 *func* 只会在一个进程池中的一个工作进程中执行。"

#: ../../library/multiprocessing.rst:2284
msgid ""
"A variant of the :meth:`apply` method which returns a "
":class:`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":meth:`apply` 方法的一个变种，返回一个 :class:`~multiprocessing.pool.AsyncResult` 对象。"

#: ../../library/multiprocessing.rst:2287
#: ../../library/multiprocessing.rst:2318
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it,"
" that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"如果指定了 *callback* , 它必须是一个接受单个参数的可调用对象。当执行成功时， *callback* "
"会被用于处理执行后的返回结果，否则，调用 *error_callback* 。"

#: ../../library/multiprocessing.rst:2292
#: ../../library/multiprocessing.rst:2323
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"如果指定了 *error_callback* , 它必须是一个接受单个参数的可调用对象。当目标函数执行失败时， 会将抛出的异常对象作为参数传递给 "
"*error_callback* 执行。"

#: ../../library/multiprocessing.rst:2296
#: ../../library/multiprocessing.rst:2327
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr "回调函数应该立即执行完成，否则会阻塞负责处理结果的线程。"

#: ../../library/multiprocessing.rst:2301
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only"
" one *iterable* argument though, for multiple iterables see "
":meth:`starmap`). It blocks until the result is ready."
msgstr ""
"内置 :func:`map` 函数的并行版本 (但它只支持一个 *iterable* 参数，对于多个可迭代对象请参阅 :meth:`starmap`)。"
" 它会保持阻塞直到获得结果。"

#: ../../library/multiprocessing.rst:2305
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr "这个方法会将可迭代对象分割为许多块，然后提交给进程池。 可以将 *chunksize* 设置为一个正整数来指定每个块的（近似）大小。"

#: ../../library/multiprocessing.rst:2309
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"注意对于很长的迭代对象，可能消耗很多内存。可以考虑使用 :meth:`imap` 或 :meth:`imap_unordered` 并且显式指定 "
"*chunksize* 以提升效率。"

#: ../../library/multiprocessing.rst:2315
msgid ""
"A variant of the :meth:`.map` method which returns a "
":class:`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":meth:`.map` 方法的一个变种，返回一个 :class:`~multiprocessing.pool.AsyncResult` 对象。"

#: ../../library/multiprocessing.rst:2332
msgid "A lazier version of :meth:`.map`."
msgstr ":meth:`.map` 的延迟执行版本。"

#: ../../library/multiprocessing.rst:2334
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"*chunksize* 参数的作用和 :meth:`.map` 方法的一样。对于很长的迭代器，给 *chunksize* 设置一个很大的值会比默认值 "
"``1`` **极大** 地加快执行速度。"

#: ../../library/multiprocessing.rst:2339
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"同样，如果 *chunksize* 是 ``1`` , 那么 :meth:`imap` 方法所返回的迭代器的 :meth:`!next` "
"方法拥有一个可选的 *timeout* 参数： 如果无法在 *timeout* 秒内执行得到结果，则 ``next(timeout)`` 会抛出 "
":exc:`multiprocessing.TimeoutError` 异常。"

#: ../../library/multiprocessing.rst:2346
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"和 :meth:`imap` 相同，只不过通过迭代器返回的结果是任意的。（当进程池中只有一个工作进程的时候，返回结果的顺序才能认为是\"有序\"的）"

#: ../../library/multiprocessing.rst:2352
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"和 :meth:`~multiprocessing.pool.Pool.map` 类似，不过 *iterable* 中的每一项会被解包再作为函数参数。"

#: ../../library/multiprocessing.rst:2356
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr "比如可迭代对象 ``[(1,2), (3, 4)]`` 会转化为等价于 ``[func(1,2), func(3,4)]`` 的调用。"

#: ../../library/multiprocessing.rst:2363
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"相当于 :meth:`starmap` 与 :meth:`map_async` 的结合，迭代 *iterable* 的每一项，解包作为 *func* "
"的参数并执行，返回用于获取结果的对象。"

#: ../../library/multiprocessing.rst:2371
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "阻止后续任务提交到进程池，当所有任务执行完成后，工作进程会退出。"

#: ../../library/multiprocessing.rst:2376
msgid ""
"Stops the worker processes immediately without completing outstanding work."
"  When the pool object is garbage collected :meth:`terminate` will be called"
" immediately."
msgstr "不必等待未完成的任务，立即停止工作进程。当进程池对象被垃圾回收时，会立即调用 :meth:`terminate`。"

#: ../../library/multiprocessing.rst:2382
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr "等待工作进程结束。调用 :meth:`join` 前必须先调用 :meth:`close` 或者 :meth:`terminate` 。"

#: ../../library/multiprocessing.rst:2385
msgid ""
"Pool objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"pool object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"进程池对象现在支持上下文管理器协议 - 参见 :ref:`typecontextmanager` "
"。:meth:`~contextmanager.__enter__` 返回进程池对象, :meth:`~contextmanager.__exit__`"
" 会调用 :meth:`terminate` 。"

#: ../../library/multiprocessing.rst:2393
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async` 和 :meth:`Pool.map_async` 返回对象所属的类。"

#: ../../library/multiprocessing.rst:2398
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised an"
" exception then that exception will be reraised by :meth:`get`."
msgstr ""
"用于获取执行结果。如果 *timeout* 不是 ``None`` 并且在 *timeout* 秒内仍然没有执行完得到结果，则抛出 "
":exc:`multiprocessing.TimeoutError` 异常。如果远程调用发生异常，这个异常会通过 :meth:`get` 重新抛出。"

#: ../../library/multiprocessing.rst:2405
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "阻塞，直到返回结果，或者 *timeout* 秒后超时。"

#: ../../library/multiprocessing.rst:2409
msgid "Return whether the call has completed."
msgstr "返回执行状态，是否已经完成。"

#: ../../library/multiprocessing.rst:2413
msgid ""
"Return whether the call completed without raising an exception.  Will raise "
":exc:`ValueError` if the result is not ready."
msgstr "判断调用是否已经完成并且未引发异常。 如果还未获得结果则将引发 :exc:`ValueError`。"

#: ../../library/multiprocessing.rst:2416
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of "
":exc:`AssertionError`."
msgstr "如果没有执行完，会抛出 :exc:`ValueError`  异常而不是 :exc:`AssertionError` 。"

#: ../../library/multiprocessing.rst:2420
msgid "The following example demonstrates the use of a pool::"
msgstr "下面的例子演示了进程池的用法::"

#: ../../library/multiprocessing.rst:2422
msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing.TimeoutError"
msgstr ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # 启动 4 个工作进程\n"
"        result = pool.apply_async(f, (10,)) # 在单个进程中异步地对 \"f(10)\" 求值\n"
"        print(result.get(timeout=1))        # 打印 \"100\" 除非你的计算机 *非常* 慢\n"
"\n"
"        print(pool.map(f, range(10)))       # 打印 \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # 打印 \"0\"\n"
"        print(next(it))                     # 打印 \"1\"\n"
"        print(it.next(timeout=1))           # 打印 \"4\" 除非你的计算机 *非常* 慢\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # 引发 multiprocessing.TimeoutError"

#: ../../library/multiprocessing.rst:2447
msgid "Listeners and Clients"
msgstr "监听器及客户端"

#: ../../library/multiprocessing.rst:2452
msgid ""
"Usually message passing between processes is done using queues or by using "
":class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"通常情况下，进程间通过队列或者 :func:`~multiprocessing.Pipe` 返回的 :class:`~Connection` 传递消息。"

#: ../../library/multiprocessing.rst:2456
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"不过，:mod:`multiprocessing.connection` "
"模块其实提供了一些更灵活的特性。最基础的用法是通过它抽象出来的高级API来操作socket或者Windows命名管道。也提供一些高级用法，如通过 "
":mod:`hmac` 模块来支持 *摘要认证*，以及同时监听多个管道连接。"

#: ../../library/multiprocessing.rst:2465
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "发送一个随机生成的消息到另一端，并等待回复。"

#: ../../library/multiprocessing.rst:2468
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"如果收到的回复与使用 *authkey* 作为键生成的信息摘要匹配成功，就会发送一个欢迎信息给管道另一端。否则抛出 "
":exc:`~multiprocessing.AuthenticationError` 异常。"

#: ../../library/multiprocessing.rst:2474
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr "接收一条信息，使用 *authkey* 作为键计算信息摘要，然后将摘要发送回去。"

#: ../../library/multiprocessing.rst:2477
msgid ""
"If a welcome message is not received, then "
":exc:`~multiprocessing.AuthenticationError` is raised."
msgstr "如果没有收到欢迎消息，就抛出 :exc:`~multiprocessing.AuthenticationError` 异常。"

#: ../../library/multiprocessing.rst:2482
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr "尝试使用 *address* 地址上的监听器建立一个连接，返回 :class:`~Connection` 。"

#: ../../library/multiprocessing.rst:2485
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"连接的类型取决于 *family* 参数，但是通常可以省略，因为可以通过 *address* 的格式推导出来。(查看 "
":ref:`multiprocessing-address-formats` )"

#: ../../library/multiprocessing.rst:2489
#: ../../library/multiprocessing.rst:2524
msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is ``None``. "
":exc:`~multiprocessing.AuthenticationError` is raised if authentication "
"fails. See :ref:`multiprocessing-auth-keys`."
msgstr ""
"如果给出了 *authkey* 并且不为 ``None``，则它应为一个字节串并且会被用作基于 HMAC 认证的密钥。 如果 *authkey* 为 "
"``None`` 则不会执行认证。 如果认证失败则会引发 :exc:`~multiprocessing.AuthenticationError`。 参见"
" :ref:`multiprocessing-auth-keys`。"

#: ../../library/multiprocessing.rst:2497
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr "可以监听连接请求，是对于绑定套接字或者 Windows 命名管道的封装。"

#: ../../library/multiprocessing.rst:2500
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the"
" listener object."
msgstr "*address* 是监听器对象中的绑定套接字或命名管道使用的地址。"

#: ../../library/multiprocessing.rst:2505
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use"
" '127.0.0.1'."
msgstr ""
"如果使用 '0.0.0.0' 作为监听地址，那么在Windows上这个地址无法建立连接。想要建立一个可连接的端点，应该使用 '127.0.0.1' 。"

#: ../../library/multiprocessing.rst:2509
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* 是套接字(或者命名管道)使用的类型。它可以是以下一种:  ``'AF_INET'`` ( TCP 套接字类型), "
"``'AF_UNIX'`` ( Unix 域套接字) 或者 ``'AF_PIPE'`` ( Windows "
"命名管道)。其中只有第一个保证各平台可用。如果 *family* 是 ``None`` ,那么 family 会根据 *address* "
"的格式自动推导出来。如果 *address* 也是 ``None`` , 则取默认值。默认值为可用类型中速度最快的。见 "
":ref:`multiprocessing-address-formats` 。注意，如果 *family* 是 ``'AF_UNIX'`` "
"而address是 ``None`` ,套接字会在一个 :func:`tempfile.mkstemp` 创建的私有临时目录中创建。"

#: ../../library/multiprocessing.rst:2520
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed"
" to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"如果监听器对象使用了套接字，*backlog* (默认值为1) 会在套接字绑定后传递给它的 :meth:`~socket.socket.listen` "
"方法。"

#: ../../library/multiprocessing.rst:2532
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object"
" and return a :class:`~Connection` object. If authentication is attempted "
"and fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"接受一个连接并返回一个 :class:`~Connection` "
"对象，其连接到的监听器对象已绑定套接字或者命名管道。如果已经尝试过认证并且失败了，则会抛出 "
":exc:`~multiprocessing.AuthenticationError` 异常。"

#: ../../library/multiprocessing.rst:2539
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called"
" automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr "关闭监听器对象上的绑定套接字或者命名管道。此函数会在监听器被垃圾回收后自动调用。不过仍然建议显式调用函数关闭。"

#: ../../library/multiprocessing.rst:2543
msgid "Listener objects have the following read-only properties:"
msgstr "监听器对象拥有下列只读属性:"

#: ../../library/multiprocessing.rst:2547
msgid "The address which is being used by the Listener object."
msgstr "监听器对象使用的地址。"

#: ../../library/multiprocessing.rst:2551
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "最后一个连接所使用的地址。如果没有的话就是 ``None`` 。"

#: ../../library/multiprocessing.rst:2554
msgid ""
"Listener objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"监听器对象现在支持了上下文管理协议 - 见 :ref:`typecontextmanager` 。 "
":meth:`~contextmanager.__enter__` 返回一个监听器对象, "
":meth:`~contextmanager.__exit__` 会调用 :meth:`close` 。"

#: ../../library/multiprocessing.rst:2561
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it"
" will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"一直等待直到 *object_list* 中某个对象处于就绪状态。返回 *object_list* 中处于就绪状态的对象。如果 *timeout* "
"是一个浮点型，该方法会最多阻塞这么多秒。如果 *timeout* 是 ``None`` "
"，则会允许阻塞的事件没有限制。timeout为负数的情况下和为0的情况相同。"

#: ../../library/multiprocessing.rst:2567
msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr "对于 POSIX 和 Windows，满足下列条件的对象可以出现在 *object_list* 中"

#: ../../library/multiprocessing.rst:2570
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "可读的 :class:`~multiprocessing.connection.Connection` 对象；"

#: ../../library/multiprocessing.rst:2571
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "一个已连接并且可读的 :class:`socket.socket` 对象；或者"

#: ../../library/multiprocessing.rst:2572
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a "
":class:`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` 对象中的 "
":attr:`~multiprocessing.Process.sentinel` 属性。"

#: ../../library/multiprocessing.rst:2575
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr "当一个连接或者套接字对象拥有有效的数据可被读取的时候，或者另一端关闭后，这个对象就处于就绪状态。"

#: ../../library/multiprocessing.rst:2578
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent "
"``select.select(object_list, [], [], timeout)``.  The difference is that, if"
" :func:`select.select` is interrupted by a signal, it can raise "
":exc:`OSError` with an error number of ``EINTR``, whereas :func:`wait` will "
"not."
msgstr ""
"**POSIX**: ``wait(object_list, timeout)`` 和 ``select.select(object_list, [],"
" [], timeout)`` 几乎相同。 差别在于，如果 :func:`select.select` 被信号中断，它会引发 "
":exc:`OSError` 并附带错误号 ``EINTR``，而 :func:`wait` 则不会。"

#: ../../library/multiprocessing.rst:2584
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which"
" is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a "
":meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""
"**Windows**: *object_list* 中的条目必须是一个可等待的整数句柄 (根据 Win32 函数 "
"``WaitForMultipleObjects()`` 文档所使用的定义) 或者一个具有 :meth:`~io.IOBase.fileno` "
"方法的对象，该方法返回一个套接字句柄或管道句柄。 （注意管道句柄和套接字句柄 **不是** 可等待的句柄。）"

#: ../../library/multiprocessing.rst:2594
msgid "**Examples**"
msgstr "**示例**"

#: ../../library/multiprocessing.rst:2596
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr "下面的服务代码创建了一个使用 ``'secret password'`` 作为认证密码的监听器。它会等待连接然后发送一些数据给客户端::"

#: ../../library/multiprocessing.rst:2600
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # 协议簇缩减为 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"

#: ../../library/multiprocessing.rst:2615
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "下面的代码连接到服务然后从服务器上j接收一些数据::"

#: ../../library/multiprocessing.rst:2618
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"
msgstr ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"

#: ../../library/multiprocessing.rst:2632
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for"
" messages from multiple processes at once::"
msgstr "下面的代码使用了 :func:`~multiprocessing.connection.wait` ，以便在同时等待多个进程发来消息。"

#: ../../library/multiprocessing.rst:2635
msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # 现在我们关闭管道的可写端以确定\n"
"        # p 是拥有其所对应句柄的唯一进程。\n"
"        # 这将确保当 p 关闭可写端的句柄时，\n"
"        # wait() 将立即报告可读端已经就绪。\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"

#: ../../library/multiprocessing.rst:2670
msgid "Address Formats"
msgstr "地址格式"

#: ../../library/multiprocessing.rst:2672
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` 地址是 ``(hostname, port)``  形式的元组类型，其中 *hostname* 是一个字符串，*port* "
"是整数。"

#: ../../library/multiprocessing.rst:2675
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` 地址是文件系统上文件名的字符串。"

#: ../../library/multiprocessing.rst:2678
msgid ""
"An ``'AF_PIPE'`` address is a string of the form "
":samp:`r'\\\\\\\\\\\\.\\\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` "
"to connect to a named pipe on a remote computer called *ServerName* one "
"should use an address of the form "
":samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` instead."
msgstr ""
"``'AF_PIPE'`` 地址是一个 :samp:`r'\\\\\\\\\\\\.\\\\pipe\\\\\\\\{PipeName}'` "
"形式的字符串。 要使用 :func:`Client` 来连接到远程计算机上一个名为 *ServerName* 的命名管道则应当改用 "
":samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` 形式的地址。"

#: ../../library/multiprocessing.rst:2683
msgid ""
"Note that any string beginning with two backslashes is assumed by default to"
" be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr "注意，使用两个反斜线开头的字符串默认被当做 ``'AF_PIPE'`` 地址而不是 ``'AF_UNIX'`` 地址。"

#: ../../library/multiprocessing.rst:2690
msgid "Authentication keys"
msgstr "认证密码"

#: ../../library/multiprocessing.rst:2692
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"当使用 :meth:`Connection.recv <Connection.recv>` "
"接收数据时，数据会自动被反序列化。不幸的是，对于一个不可信的数据源发来的数据，反序列化是存在安全风险的。所以 :class:`Listener` 和 "
":func:`Client` 之间使用 :mod:`hmac` 模块进行摘要认证。"

#: ../../library/multiprocessing.rst:2698
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the "
"connection.)"
msgstr ""
"认证密钥是一个 byte "
"类型的字符串，可以认为是和密码一样的东西，连接建立好后，双方都会要求另一方证明知道认证密钥。（这个证明过程不会通过连接发送密钥）"

#: ../../library/multiprocessing.rst:2704
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will be automatically "
"inherited by any :class:`~multiprocessing.Process` object that the current "
"process creates. This means that (by default) all processes of a multi-"
"process program will share a single authentication key which can be used "
"when setting up connections between themselves."
msgstr ""
"如果要求认证但是没有指定认证密钥，则会使用 ``current_process().authkey`` 的返回值 (参见 "
":class:`~multiprocessing.Process`)。 这个值将被当前进程所创建的任何 "
":class:`~multiprocessing.Process` 对象自动继承。 这意味着 (在默认情况下) "
"一个包含多进程的程序中的所有进程会在相互间建立连接的时候共享单个认证密钥。"

#: ../../library/multiprocessing.rst:2712
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr ":func:`os.urandom` 也可以用来生成合适的认证密钥。"

#: ../../library/multiprocessing.rst:2716
msgid "Logging"
msgstr "日志记录"

#: ../../library/multiprocessing.rst:2718
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get"
" mixed up."
msgstr ""
"当前模块也提供了一些对 logging 的支持。注意， :mod:`logging` "
"模块本身并没有使用进程间共享的锁，所以来自于多个进程的日志可能（具体取决于使用的日志 handler 类型）相互覆盖或者混杂。"

#: ../../library/multiprocessing.rst:2725
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr "返回 :mod:`multiprocessing` 使用的 logger，必要的话会创建一个新的。"

#: ../../library/multiprocessing.rst:2728
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"当首次创建时日志记录器级别为 :const:`logging.NOTSET` 并且没有默认处理器。 "
"发送到这个日志记录器的消息默认将不会传播到根日志记录器。"

#: ../../library/multiprocessing.rst:2732
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be"
" inherited."
msgstr "注意在 Windows 上，子进程只会继承父进程 logger 的日志级别 - 对于logger的其他自定义项不会继承。"

#: ../../library/multiprocessing.rst:2739
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s]"
" %(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"此函数会调用 :func:`get_logger` 但是会在返回的 logger 上增加一个 handler，将所有输出都使用 "
"``'[%(levelname)s/%(processName)s] %(message)s'`` 的格式发送到 :data:`sys.stderr` "
"。你可以通过传递一个 ``level`` 参数来修改记录器的 ``levelname`` 。"

#: ../../library/multiprocessing.rst:2745
msgid "Below is an example session with logging turned on::"
msgstr "下面是一个在交互式解释器中打开日志功能的例子::"

#: ../../library/multiprocessing.rst:2747
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"

#: ../../library/multiprocessing.rst:2760
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "要查看日志等级的完整列表，见 :mod:`logging` 模块。"

#: ../../library/multiprocessing.rst:2764
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` 模块"

#: ../../library/multiprocessing.rst:2769
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` 复制了 :mod:`multiprocessing` 的 API，不过是在 "
":mod:`threading` 模块之上包装了一层。"

#: ../../library/multiprocessing.rst:2774
msgid ""
"In particular, the ``Pool`` function provided by "
":mod:`multiprocessing.dummy` returns an instance of :class:`ThreadPool`, "
"which is a subclass of :class:`Pool` that supports all the same method calls"
" but uses a pool of worker threads rather than worker processes."
msgstr ""
"特别地，:mod:`multiprocessing.dummy` 所提供的 ``Pool`` 函数会返回一个 :class:`ThreadPool` "
"的实例，该类是 :class:`Pool` 的子类，它支持所有相同的方法调用但会使用一个工作线程池而非工作进程池。"

#: ../../library/multiprocessing.rst:2782
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and "
":meth:`~multiprocessing.pool.Pool.terminate` manually."
msgstr ""
"一个线程池对象，用来控制可向其提交任务的工作线程池。 :class:`ThreadPool` 实例与 :class:`Pool` "
"实例是完全接口兼容的，并且它们的资源也必须被正确地管理，或者是将线程池作为上下文管理器来使用，或者是通过手动调用 "
":meth:`~multiprocessing.pool.Pool.close` 和 "
":meth:`~multiprocessing.pool.Pool.terminate`。"

#: ../../library/multiprocessing.rst:2789
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* 是要使用的工作线程数量。 如果 *processes* 为 ``None`` 则使用 "
":func:`os.process_cpu_count` 所返回的数值。"

#: ../../library/multiprocessing.rst:2795
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr "不同于 :class:`Pool`，*maxtasksperchild* 和 *context* 不可被提供。"

#: ../../library/multiprocessing.rst:2799
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the "
":class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that"
" is not understood by any other libraries."
msgstr ""
":class:`ThreadPool` 具有与 :class:`Pool` 相同的接口，它围绕一个进程池进行设计并且先于 "
":class:`concurrent.futures` 模块的引入。 "
"因此，它继承了一些对于基于线程的池来说没有意义的操作，并且它具有自己的用于表示异步任务状态的类型 "
":class:`AsyncResult`，该类型不为任何其他库所知。"

#: ../../library/multiprocessing.rst:2806
msgid ""
"Users should generally prefer to use "
":class:`concurrent.futures.ThreadPoolExecutor`, which has a simpler "
"interface that was designed around threads from the start, and which returns"
" :class:`concurrent.futures.Future` instances that are compatible with many "
"other libraries, including :mod:`asyncio`."
msgstr ""
"用户通常应该倾向于使用 "
":class:`concurrent.futures.ThreadPoolExecutor`，它拥有从一开始就围绕线程进行设计的更简单接口，并且返回与许多其他库相兼容的"
" :class:`concurrent.futures.Future` 实例，包括 :mod:`asyncio` 库。"

#: ../../library/multiprocessing.rst:2816
msgid "Programming guidelines"
msgstr "编程指导"

#: ../../library/multiprocessing.rst:2818
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr "使用 :mod:`multiprocessing` 时，应遵循一些指导原则和习惯用法。"

#: ../../library/multiprocessing.rst:2823
msgid "All start methods"
msgstr "所有start方法"

#: ../../library/multiprocessing.rst:2825
msgid "The following applies to all start methods."
msgstr "下面这些适用于所有start方法。"

#: ../../library/multiprocessing.rst:2827
msgid "Avoid shared state"
msgstr "避免共享状态"

#: ../../library/multiprocessing.rst:2829
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr "应该尽可能避免在进程间传递大量数据，越少越好。"

#: ../../library/multiprocessing.rst:2832
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr "最好坚持使用队列或者管道进行进程间通信，而不是底层的同步原语。"

#: ../../library/multiprocessing.rst:2836
msgid "Picklability"
msgstr "可序列化"

#: ../../library/multiprocessing.rst:2838
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "保证所代理的方法的参数是可以序列化的。"

#: ../../library/multiprocessing.rst:2840
msgid "Thread safety of proxies"
msgstr "代理的线程安全性"

#: ../../library/multiprocessing.rst:2842
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr "不要在多线程中同时使用一个代理对象，除非你用锁保护它。"

#: ../../library/multiprocessing.rst:2845
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "（而在不同进程中使用 *相同* 的代理对象却没有问题。）"

#: ../../library/multiprocessing.rst:2847
msgid "Joining zombie processes"
msgstr "使用 Join 避免僵尸进程"

#: ../../library/multiprocessing.rst:2849
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed"
" processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` will join the process.  Even so it is "
"probably good practice to explicitly join all the processes that you start."
msgstr ""
"在 POSIX 上当一个进程结束但没有被合并则它将变成僵尸进程。 这样的进程应该不会很多因为每次启动新进程（或 "
":func:`~multiprocessing.active_children` 被调用）时所有尚未被合并的已完成进程都将被合并。 "
"而且调用一个已结束进程的 :meth:`Process.is_alive <multiprocessing.Process.is_alive>` "
"也会合并这个进程。 虽然如此但显式地合并你所启动的所有进程仍然是个好习惯。"

#: ../../library/multiprocessing.rst:2857
msgid "Better to inherit than pickle/unpickle"
msgstr "继承优于序列化、反序列化"

#: ../../library/multiprocessing.rst:2859
msgid ""
"When using the *spawn* or *forkserver* start methods many types from "
":mod:`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can"
" inherit it from an ancestor process."
msgstr ""
"当使用 *spawn* 或者 *forkserver* 的启动方式时，:mod:`multiprocessing`  "
"中的许多类型都必须是可序列化的，这样子进程才能使用它们。但是通常我们都应该避免使用管道和队列发送共享对象到另外一个进程，而是重新组织代码，对于其他进程创建出来的共享对象，让那些需要访问这些对象的子进程可以直接将这些对象从父进程继承过来。"

#: ../../library/multiprocessing.rst:2867
msgid "Avoid terminating processes"
msgstr "避免杀死进程"

#: ../../library/multiprocessing.rst:2869
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"通过 :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"停止一个进程很容易导致这个进程正在使用的共享资源（如锁、信号量、管道和队列）损坏或者变得不可用，无法在其他进程中继续使用。"

#: ../../library/multiprocessing.rst:2875
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on processes "
"which never use any shared resources."
msgstr ""
"所以，最好只对那些从来不使用共享资源的进程调用 :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` 。"

#: ../../library/multiprocessing.rst:2879
msgid "Joining processes that use queues"
msgstr "Join 使用队列的进程"

#: ../../library/multiprocessing.rst:2881
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to"
" the underlying pipe.  (The child process can call the "
":meth:`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` "
"method of the queue to avoid this behaviour.)"
msgstr ""
"记住，往队列放入数据的进程会一直等待直到队列中所有项被\"feeder\" 线程传给底层管道。（子进程可以调用队列的 "
":meth:`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` "
"方法禁止这种行为）"

#: ../../library/multiprocessing.rst:2887
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the"
" process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"这意味着，任何使用队列的时候，你都要确保在进程join之前，所有存放到队列中的项将会被其他进程、线程完全消费。否则不能保证这个写过队列的进程可以正常终止。记住非精灵进程会自动"
" join 。"

#: ../../library/multiprocessing.rst:2893
msgid "An example which will deadlock is the following::"
msgstr "下面是一个会导致死锁的例子::"

#: ../../library/multiprocessing.rst:2895
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # 这将死锁\n"
"    obj = queue.get()"

#: ../../library/multiprocessing.rst:2907
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr "交换最后两行可以修复这个问题（或者直接删掉 ``p.join()``）。"

#: ../../library/multiprocessing.rst:2910
msgid "Explicitly pass resources to child processes"
msgstr "显式传递资源给子进程"

#: ../../library/multiprocessing.rst:2912
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"在 POSIX 上使用 *fork* 启动方法，子进程将能够访问使用全局资源在父进程中创建的共享资源。 "
"但是，更好的做法是将对象作为子进程构造器的参数来传入。"

#: ../../library/multiprocessing.rst:2917
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process."
"  This might be important if some resource is freed when the object is "
"garbage collected in the parent process."
msgstr ""
"除了（部分原因）让代码兼容 Windows "
"以及其他的进程启动方式外，这种形式还保证了在子进程生命期这个对象是不会被父进程垃圾回收的。如果父进程中的某些对象被垃圾回收会导致资源释放，这就变得很重要。"

#: ../../library/multiprocessing.rst:2924
msgid "So for instance ::"
msgstr "所以对于实例："

#: ../../library/multiprocessing.rst:2926
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... 使用锁进行一些操作 ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"

#: ../../library/multiprocessing.rst:2936
msgid "should be rewritten as ::"
msgstr "应当重写成这样："

#: ../../library/multiprocessing.rst:2938
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... 使用 \"l\" 进行一些操作 ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"

#: ../../library/multiprocessing.rst:2948
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr "谨防将 :data:`sys.stdin` 数据替换为 “类似文件的对象”"

#: ../../library/multiprocessing.rst:2950
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` 原本会无条件地这样调用::"

#: ../../library/multiprocessing.rst:2952
msgid "os.close(sys.stdin.fileno())"
msgstr "os.close(sys.stdin.fileno())"

#: ../../library/multiprocessing.rst:2954
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"在  :meth:`multiprocessing.Process._bootstrap`  方法中 —— "
"这会导致与\"进程中的进程\"相关的一些问题。这已经被修改成了::"

#: ../../library/multiprocessing.rst:2957
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"

#: ../../library/multiprocessing.rst:2960
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call "
":meth:`~io.IOBase.close` on this file-like object, it could result in the "
"same data being flushed to the object multiple times, resulting in "
"corruption."
msgstr ""
"它解决于进程相互冲突导致文件描述符损坏错误的基础性问题，但是又对使用带输出缓冲的“文件型对象”替代 :func:`sys.stdin` "
"的应用程序引入了潜在的危险。 这种危险在于如果有多个进程在此文件型对象上调用 "
":meth:`~io.IOBase.close`，可能导致相同的数据被多次刷写到对象，造成数据损坏。"

#: ../../library/multiprocessing.rst:2967
msgid ""
"If you write a file-like object and implement your own caching, you can make"
" it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"如果你写入文件型对象并实现了自己的缓存，可以在每次追加缓存数据时记录当前进程id，从而将其变成 fork "
"安全的，当发现进程id变化后舍弃之前的缓存，例如::"

#: ../../library/multiprocessing.rst:2971
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"

#: ../../library/multiprocessing.rst:2979
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "需要更多信息，请查看 :issue:`5155`, :issue:`5313` 以及 :issue:`5331`"

#: ../../library/multiprocessing.rst:2982
msgid "The *spawn* and *forkserver* start methods"
msgstr "*spawn* 和 *forkserver* 启动方式"

#: ../../library/multiprocessing.rst:2984
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr "还有一些没有被应用到 *fork* 启动方法的额外限制。"

#: ../../library/multiprocessing.rst:2987
msgid "More picklability"
msgstr "更依赖序列化"

#: ../../library/multiprocessing.rst:2989
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
":meth:`Process.__init__` 的所有参数都必须可序列化。同样的，当你继承 "
":class:`~multiprocessing.Process` 时，需要保证当调用 :meth:`Process.start "
"<multiprocessing.Process.start>` 方法时，实例可以被序列化。"

#: ../../library/multiprocessing.rst:2994
msgid "Global variables"
msgstr "全局变量"

#: ../../library/multiprocessing.rst:2996
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr ""
"记住，如果子进程中的代码尝试访问一个全局变量，它所看到的值（如果有）可能和父进程中执行 :meth:`Process.start "
"<multiprocessing.Process.start>` 那一刻的值不一样。"

#: ../../library/multiprocessing.rst:3001
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "当全局变量只是模块级别的常量时，是不会有问题的。"

#: ../../library/multiprocessing.rst:3006
msgid "Safe importing of main module"
msgstr "安全导入主模块"

#: ../../library/multiprocessing.rst:3008
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr "确保新的 Python 解释器可以安全地导入主模块，而不会导致意想不到的副作用（如启动新进程）。"

#: ../../library/multiprocessing.rst:3012
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"例如，使用 *spawn* 或 *forkserver* 启动方式执行下面的模块，会引发 :exc:`RuntimeError` 异常而失败。"

#: ../../library/multiprocessing.rst:3016
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"

#: ../../library/multiprocessing.rst:3024
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr "应该通过下面的方法使用 ``if __name__ == '__main__':`` ，从而保护程序\"入口点\"::"

#: ../../library/multiprocessing.rst:3027
msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"

#: ../../library/multiprocessing.rst:3038
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "（如果程序将正常运行而不是冻结，则可以省略 ``freeze_support()`` 行）"

#: ../../library/multiprocessing.rst:3041
msgid ""
"This allows the newly spawned Python interpreter to safely import the module"
" and then run the module's ``foo()`` function."
msgstr "这允许新启动的 Python 解释器安全导入模块然后运行模块中的 ``foo()`` 函数。"

#: ../../library/multiprocessing.rst:3044
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "如果主模块中创建了进程池或者管理器，这个规则也适用。"

#: ../../library/multiprocessing.rst:3051
msgid "Examples"
msgstr "例子"

#: ../../library/multiprocessing.rst:3053
msgid ""
"Demonstration of how to create and use customized managers and proxies:"
msgstr "创建和使用自定义管理器、代理的示例::"

#: ../../library/multiprocessing.rst:3055
msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# 一个简单的生成器函数\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# 针对生成器对象的代理类型\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# 返回 operator 模块的函数\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# 注册 Foo 类；使 `f()` 和 `g()` 可通过代理访问\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# 注册 Foo 类；使 `g()` 和 `_h()` 可通过代理访问\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# 注册生成器函数 baz；使用 `GeneratorProxy` 来作为代理\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# 注册 get_operator_module()；使公有函数可通过代理访问\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"

#: ../../library/multiprocessing.rst:3059
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "使用 :class:`~multiprocessing.pool.Pool`:"

#: ../../library/multiprocessing.rst:3061
msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool.imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator.next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# 供测试代码使用的函数\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# 测试代码\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # 测试\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool.imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator.next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # 测试超时\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"

#: ../../library/multiprocessing.rst:3065
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker"
" processes and collect the results:"
msgstr "一个演示如何使用队列来向一组工作进程提供任务并收集结果的例子："

#: ../../library/multiprocessing.rst:3068
msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# 由工作进程运行的函数\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# 用于计算结果的函数\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# 被任务引用的函数\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # 创建队列\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # 提交任务\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # 启动工作进程\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # 获取并打印结果\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # 使用 `put()` 添加更多任务\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # 获取并打印更多结果\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # 通知子进程停止运行\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
