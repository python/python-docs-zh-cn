# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Arisaka97 <solitaire2312@gmail.com>, 2021
# Claude Manchester <atlanmatrix@gmail.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# KaMingChung <zjm947373@gmail.com>, 2021
# dogn he <hedogn@163.com>, 2021
# Jack Wu <bitlabwzh@gmail.com>, 2021
# Jann <l33klin@gmail.com>, 2021
# ChenYuan <github@qiushi.ac.cn>, 2021
# Xiao Xu <cxbats@gmail.com>, 2021
# helloworldSB <warningfor163@foxmail.com>, 2021
# Xu Siyuan, 2021
# Justin Chu <justinchuby@foxmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# ProgramRipper, 2023
# Makdon <makdon@makdon.me>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-20 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.rst:2
msgid ":mod:`!unittest` --- Unit testing framework"
msgstr ":mod:`!unittest` --- 单元测试框架"

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**源代码：** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr "（如果你已经对测试的概念比较熟悉了，你可能想直接跳转到这一部分 :ref:`断言方法<assert-methods>`。）"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
":mod:`unittest` 单元测试框架是受到 JUnit "
"的启发，与其他语言中的主流单元测试框架有着相似的风格。其支持测试自动化，配置共享和关机代码测试。支持将测试样例聚合到测试集中，并将测试与报告框架独立。"

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr "为了实现这些，:mod:`unittest` 通过面向对象的方式支持了一些重要的概念。"

#: ../../library/unittest.rst:28
msgid "test fixture"
msgstr "测试脚手架"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
":dfn:`test fixture` "
"表示为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。举个例子，这可能包含创建临时或代理的数据库、目录，再或者启动一个服务器进程。"

#: ../../library/unittest.rst:34
msgid "test case"
msgstr "测试用例"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a"
" base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"一个测试用例是一个独立的测试单元。它检查输入特定的数据时的响应。 :mod:`unittest` 提供一个基类： :class:`TestCase` "
"，用于新建测试用例。"

#: ../../library/unittest.rst:39
msgid "test suite"
msgstr "测试套件"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It"
" is used to aggregate tests that should be executed together."
msgstr ":dfn:`test suite` 是一系列的测试用例，或测试套件，或两者皆有。它用于归档需要一起执行的测试。"

#: ../../library/unittest.rst:43
msgid "test runner"
msgstr "测试运行器（test runner）"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
":dfn:`test runner` 是一个用于执行和输出测试结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。"

#: ../../library/unittest.rst:51
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` --- 文档测试模块"

#: ../../library/unittest.rst:52
msgid "Another test-support module with a very different flavor."
msgstr "另一个风格完全不同的测试模块。"

#: ../../library/unittest.rst:54
msgid ""
"`Simple Smalltalk Testing: With Patterns "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`简单 Smalltalk 测试：便用模式 "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:55
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared by"
" :mod:`unittest`."
msgstr "Kent Beck 有关使用 :mod:`unittest` 所共享的模式的测试框架的原创论文。"

#: ../../library/unittest.rst:58
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:59
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr "第三方单元测试框架，提供轻量化的语法来编写测试，例如：``assert func(10) == 42``。"

#: ../../library/unittest.rst:62
msgid ""
"`The Python Testing Tools Taxonomy "
"<https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"
msgstr ""
"`Python 测试工具分类 <https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:63
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr "一个 Python 测试工具的详细列表，包含测试框架和模拟对象库。"

#: ../../library/unittest.rst:66
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr "Python 中的测试 邮件列表"

#: ../../library/unittest.rst:67
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr "一个讨论 Python 中的测试和测试工具的特别兴趣小组。"

#: ../../library/unittest.rst:70
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions "
"<https://github.com/features/actions>`_, or `AppVeyor "
"<https://www.appveyor.com/>`_."
msgstr ""
"Python 源代码分发包中的脚本 :file:`Tools/unittestgui/unittestgui.py` 是一个用于发现和执行测试的 GUI"
" 工具。 这主要是为了方便单元测试的新手使用。 在生产环境中推荐通过持续集成系统如 `Buildbot "
"<https://buildbot.net/>`_, `Jenkins <https://www.jenkins.io/>`_, `GitHub "
"Actions <https://github.com/features/actions>`_ 或 `AppVeyor "
"<https://www.appveyor.com/>`_ 来驱动测试过程。"

#: ../../library/unittest.rst:82
msgid "Basic example"
msgstr "基本实例"

#: ../../library/unittest.rst:84
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and"
" running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ":mod:`unittest` 模块提供了一系列创建和运行测试的工具。这一段落演示了这些工具的一小部分，但也足以满足大部分用户的需求。"

#: ../../library/unittest.rst:88
msgid "Here is a short script to test three string methods::"
msgstr "这是一段简短的代码，来测试三种字符串方法::"

#: ../../library/unittest.rst:90
msgid ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # 检查当分隔符不为字符串时 s.split 是否失败\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:112
msgid ""
"A test case is created by subclassing :class:`unittest.TestCase`.  The three"
" individual tests are defined with methods whose names start with the "
"letters ``test``.  This naming convention informs the test runner about "
"which methods represent tests."
msgstr ""
"测试用例是通过子类化 :class:`unittest.TestCase` 来创建的。 这三个单独的测试是使用名称以 ``test`` "
"打头的方法来定义的。 这样的命名惯例可告知测试运行者哪些方法是表示测试的。"

#: ../../library/unittest.rst:117
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or "
":meth:`~TestCase.assertFalse` to verify a condition; or "
":meth:`~TestCase.assertRaises` to verify that a specific exception gets "
"raised.  These methods are used instead of the :keyword:`assert` statement "
"so the test runner can accumulate all test results and produce a report."
msgstr ""
"每个测试的关键是：调用 :meth:`~TestCase.assertEqual` 来检查预期的输出； 调用 "
":meth:`~TestCase.assertTrue` 或 :meth:`~TestCase.assertFalse` 来验证一个条件；调用 "
":meth:`~TestCase.assertRaises` 来验证抛出了一个特定的异常。使用这些方法而不是 :keyword:`assert` "
"语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。"

#: ../../library/unittest.rst:124
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you"
" to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"通过 :meth:`~TestCase.setUp` 和 :meth:`~TestCase.tearDown` "
"方法，可以设置测试开始前与完成后需要执行的指令。 在  :ref:`organizing-tests` 中，对此有更为详细的描述。"

#: ../../library/unittest.rst:128
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"最后的代码块中，演示了运行测试的一个简单的方法。 :func:`unittest.main` "
"提供了一个测试脚本的命令行接口。当在命令行运行该测试脚本，上文的脚本生成如以下格式的输出::"

#: ../../library/unittest.rst:132
msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"

#: ../../library/unittest.rst:138
msgid ""
"Passing the ``-v`` option to your test script will instruct "
":func:`unittest.main` to enable a higher level of verbosity, and produce the"
" following output::"
msgstr "在调用测试脚本时添加 ``-v`` 参数使 :func:`unittest.main` 显示更为详细的信息，生成如以下形式的输出::"

#: ../../library/unittest.rst:141
msgid ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"
msgstr ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"

#: ../../library/unittest.rst:150
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr "以上例子演示了 :mod:`unittest` 中最常用的、足够满足许多日常测试需求的特性。文档的剩余部分详述该框架的完整特性。"

#: ../../library/unittest.rst:154
msgid ""
"The behavior of returning a value from a test method (other than the default"
" ``None`` value), is now deprecated."
msgstr "从测试方法返回一个值（而非返回默认的 ``None`` 值）现在已被弃用。"

#: ../../library/unittest.rst:162
msgid "Command-Line Interface"
msgstr "命令行接口"

#: ../../library/unittest.rst:164
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr "unittest 模块可以通过命令行运行模块、类和独立测试方法的测试::"

#: ../../library/unittest.rst:167
msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"

#: ../../library/unittest.rst:171
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr "你可以传入模块名、类或方法名或他们的任意组合。"

#: ../../library/unittest.rst:174
msgid "Test modules can be specified by file path as well::"
msgstr "同样的，测试模块可以通过文件路径指定::"

#: ../../library/unittest.rst:176
msgid "python -m unittest tests/test_something.py"
msgstr "python -m unittest tests/test_something.py"

#: ../../library/unittest.rst:178
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is"
" converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"这样就可以使用 shell 的文件名补全指定测试模块。所指定的文件仍需要可以被作为模块导入。路径通过去除 '.py' 、把分隔符转换为 '.' "
"转换为模块名。若你需要执行不能被作为模块导入的测试文件，你需要直接执行该测试文件。"

#: ../../library/unittest.rst:184
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr "在运行测试时，你可以通过添加 -v 参数获取更详细（更多的冗余）的信息。"

#: ../../library/unittest.rst:186
msgid "python -m unittest -v test_module"
msgstr "python -m unittest -v test_module"

#: ../../library/unittest.rst:188
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr "当运行时不包含参数，开始 :ref:`unittest-test-discovery` ::"

#: ../../library/unittest.rst:190
msgid "python -m unittest"
msgstr "python -m unittest"

#: ../../library/unittest.rst:192
msgid "For a list of all the command-line options::"
msgstr "用于获取命令行选项列表："

#: ../../library/unittest.rst:194
msgid "python -m unittest -h"
msgstr "python -m unittest -h"

#: ../../library/unittest.rst:196
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr "在早期版本中，只支持运行独立的测试方法，而不支持模块和类。"

#: ../../library/unittest.rst:200
msgid ""
"Output is colorized by default and can be :ref:`controlled using environment"
" variables <using-on-controlling-color>`."
msgstr "输出在默认情况下是彩色的并且可以 :ref:`使用环境变量控制 <using-on-controlling-color>`。"

#: ../../library/unittest.rst:205
msgid "Command-line options"
msgstr "命令行选项"

#: ../../library/unittest.rst:207
msgid ":program:`unittest` supports these command-line options:"
msgstr " :program:`unittest` 支持以下命令行选项："

#: ../../library/unittest.rst:213
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on"
" test fail or error and is added to the failure messages."
msgstr ""
"在测试运行时，标准输出流与标准错误流会被放入缓冲区。成功的测试的运行时输出会被丢弃；测试不通过时，测试运行中的输出会正常显示，错误会被加入到测试失败信息。"

#: ../../library/unittest.rst:219
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"当测试正在运行时， :kbd:`Control-C` 会等待当前测试完成，并在完成后报告已执行的测试的结果。当再次按下 :kbd:`Control-C`"
" 时，引发平常的 :exc:`KeyboardInterrupt` 异常。"

#: ../../library/unittest.rst:223
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr " `Signal Handling`_ 中详述了提供此功能的函数。"

#: ../../library/unittest.rst:227
msgid "Stop the test run on the first error or failure."
msgstr "当出现第一个错误或者失败时，停止运行测试。"

#: ../../library/unittest.rst:231
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr "只运行匹配模式或子字符串的测试方法和类。 此选项可以被多次使用，在此情况下将会包括匹配任何给定模式的所有测试用例。"

#: ../../library/unittest.rst:235
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive"
" substring matching is used."
msgstr "包含通配符（*）的模式使用 :meth:`fnmatch.fnmatchcase` 对测试名称进行匹配。另外，该匹配是大小写敏感的。"

#: ../../library/unittest.rst:239
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr "模式对测试加载器导入的测试方法全名进行匹配。"

#: ../../library/unittest.rst:242
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not "
"``bar_tests.FooTest.test_something``."
msgstr ""
"例如，``-k foo`` 可以匹配到 ``foo_tests.SomeTest.test_something``  和 "
"``bar_tests.SomeTest.test_foo`` ，但是不能匹配到 "
"``bar_tests.FooTest.test_something`` 。"

#: ../../library/unittest.rst:247
msgid "Show local variables in tracebacks."
msgstr "在回溯中显示局部变量。"

#: ../../library/unittest.rst:251
msgid "Show the N slowest test cases (N=0 for all)."
msgstr "显示 N 个最慢的测试用例 (N=0 表示全部)。"

#: ../../library/unittest.rst:253
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "添加命令行选项 ``-b``, ``-c`` 和 ``-f`` 。"

#: ../../library/unittest.rst:256
msgid "The command-line option ``--locals``."
msgstr "命令行选项 ``--locals`` 。"

#: ../../library/unittest.rst:259
msgid "The command-line option ``-k``."
msgstr "命令行选项 ``-k`` 。"

#: ../../library/unittest.rst:262
msgid "The command-line option ``--durations``."
msgstr "命令行选项 ``--durations``。"

#: ../../library/unittest.rst:265
msgid ""
"The command line can also be used for test discovery, for running all of the"
" tests in a project or just a subset."
msgstr "命令行亦可用于探索性测试，以运行一个项目的所有测试或其子集。"

#: ../../library/unittest.rst:271
msgid "Test Discovery"
msgstr "探索性测试"

#: ../../library/unittest.rst:275
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test"
" discovery, all of the test files must be :ref:`modules <tut-modules>` or "
":ref:`packages <tut-packages>` importable from the top-level directory of "
"the project (this means that their filenames must be valid :ref:`identifiers"
" <identifiers>`)."
msgstr ""
"unittest 支持简单的测试发现。 为了与测试发现兼容，所有测试文件都必须是可从项目的最高层级目录导入的 :ref:`模块 <tut-"
"modules>` 或 :ref:`包 <tut-packages>` (这意味着它们的文件名必须是有效的 :ref:`标识符 "
"<identifiers>`)。"

#: ../../library/unittest.rst:281
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr "探索性测试在 :meth:`TestLoader.discover` 中实现，但也可以通过命令行使用。它在命令行中的基本用法如下："

#: ../../library/unittest.rst:284
msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""
"cd project_directory\n"
"python -m unittest discover"

#: ../../library/unittest.rst:289
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"方便起见， ``python -m unittest`` 与 ``python -m unittest discover`` "
"等价。如果你需要向探索性测试传入参数，必须显式地使用 ``discover`` 子命令。"

#: ../../library/unittest.rst:293
msgid "The ``discover`` sub-command has the following options:"
msgstr "``discover`` 有以下选项："

#: ../../library/unittest.rst:299
msgid "Verbose output"
msgstr "更详细地输出结果。"

#: ../../library/unittest.rst:303
msgid "Directory to start discovery (``.`` default)"
msgstr "开始进行搜索的目录(默认值为当前目录 ``.`` )。"

#: ../../library/unittest.rst:307
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "用于匹配测试文件的模式（默认为 ``test*.py`` ）。"

#: ../../library/unittest.rst:311
msgid "Top level directory of project (defaults to start directory)"
msgstr "指定项目的最上层目录（通常为开始时所在目录）。"

#: ../../library/unittest.rst:313
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as"
" positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ":option:`-s` ，:option:`-p` 和 :option:`-t` 选项可以按顺序作为位置参数传入。以下两条命令是等价的："

#: ../../library/unittest.rst:317
msgid ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""
msgstr ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""

#: ../../library/unittest.rst:320
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used"
" as the start directory."
msgstr ""
"正如可以传入路径那样，传入一个包名作为起始目录也是可行的，如 ``myproject.subpackage.test`` "
"。你提供的包名会被导入，它在文件系统中的位置会被作为起始目录。"

#: ../../library/unittest.rst:327
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"探索性测试通过导入测试对测试进行加载。在找到所有你指定的开始目录下的所有测试文件后，它把路径转换为包名并进行导入。如 "
":file:`foo/bar/baz.py` 会被导入为 ``foo.bar.baz`` 。"

#: ../../library/unittest.rst:332
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr "如果你有一个全局安装的包，并尝试对这个包的副本进行探索性测试，可能会从错误的地方开始导入。如果出现这种情况，测试会输出警告并退出。"

#: ../../library/unittest.rst:336
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr "如果你使用包名而不是路径作为开始目录，搜索时会假定它导入的是你想要的目录，所以你不会收到警告。"

#: ../../library/unittest.rst:341
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr "测试模块和包可以通过 `load_tests protocol`_ 自定义测试的加载和搜索。"

#: ../../library/unittest.rst:344
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>`."
msgstr "探索性测试支持命名空间包（ :term:`namespace packages <namespace package>` ）。"

#: ../../library/unittest.rst:347
msgid ""
"Test discovery dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and its "
"subdirectories containing tests must be regular package that have "
"``__init__.py`` file."
msgstr ""
"测试发现丢弃了对 :term:`命名空间包 <namespace package>` 的支持。 它自 Python 3.7 起就不再可用。 "
"包含测试的起始目录及其子目录都必须是具有 ``__init__.py`` 文件的常规包。"

#: ../../library/unittest.rst:353
msgid ""
"If the start directory is the dotted name of the package, the ancestor "
"packages can be namespace packages."
msgstr "如果起始目录是带点号的包名称，则其上级包可以是命名空间包。"

#: ../../library/unittest.rst:356
msgid ""
"Test discovery supports :term:`namespace package` as start directory again. "
"To avoid scanning directories unrelated to Python, tests are not searched in"
" subdirectories that do not contain ``__init__.py``."
msgstr ""
"测试发现再次支持以 :term:`namespace package` 作为起始目录。 为避免扫描与 Python 无关的目录，将不会在不包含 "
"``__init__.py`` 的子目录中搜索测试。"

#: ../../library/unittest.rst:365
msgid "Organizing test code"
msgstr "组织你的测试代码"

#: ../../library/unittest.rst:367
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In "
":mod:`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of "
":class:`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"单元测试的构建单位是 :dfn:`test cases` ：独立的、包含执行条件与正确性检查的方案。在 :mod:`unittest` "
"中，测试用例表示为 :class:`unittest.TestCase` 的实例。通过编写 :class:`TestCase` 的子类或使用 "
":class:`FunctionTestCase` 编写你自己的测试用例。"

#: ../../library/unittest.rst:373
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr "一个 :class:`TestCase` 实例的测试代码必须是完全自含的，因此它可以独立运行，或与其它任意组合任意数量的测试用例一起运行。"

#: ../../library/unittest.rst:377
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific"
" testing code::"
msgstr ""
":class:`TestCase` 的最简单的子类需要实现一个测试方法（例如一个命名以 ``test`` 开头的方法）以执行特定的测试代码："

#: ../../library/unittest.rst:381
msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"
msgstr ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"

#: ../../library/unittest.rst:388
msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, and"
" :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any other"
" exceptions will be treated as :dfn:`errors`."
msgstr ""
"请注意为了进行测试，我们使用了 :class:`TestCase` 基类提供的某个 :ref:`assert\\* 方法 <assert-"
"methods>`。 如果测试不通过，将会引发一个异常并附带解释性的消息，并且 :mod:`unittest` 会将这个测试用例标记为 "
":dfn:`failure`。 任何其它异常都将被视为 :dfn:`errors`。"

#: ../../library/unittest.rst:394
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called "
":meth:`~TestCase.setUp`, which the testing framework will automatically call"
" for every single test we run::"
msgstr ""
"可能同时存在多个前置操作相同的测试，我们可以把测试的前置操作从测试代码中拆解出来，并实现测试前置方法 :meth:`~TestCase.setUp` "
"。在运行测试时，测试框架会自动地为每个单独测试调用前置方法。"

#: ../../library/unittest.rst:399
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"

#: ../../library/unittest.rst:415
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr "多个测试运行的顺序由内置字符串排序方法对测试名进行排序的结果决定。"

#: ../../library/unittest.rst:419
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and"
" the test method will not be executed."
msgstr "在测试运行时，若 :meth:`~TestCase.setUp` 方法引发异常，测试框架会认为测试发生了错误，因此测试方法不会被运行。"

#: ../../library/unittest.rst:423
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up"
" after the test method has been run::"
msgstr "相似的，我们提供了一个 :meth:`~TestCase.tearDown` 方法在测试方法运行后进行清理工作。"

#: ../../library/unittest.rst:426
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"

#: ../../library/unittest.rst:435
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run"
" whether the test method succeeded or not."
msgstr ""
"若 :meth:`~TestCase.setUp` 成功运行，无论测试方法是否成功，都会运行 :meth:`~TestCase.tearDown` 。"

#: ../../library/unittest.rst:438
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, "
":meth:`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called "
"once per test."
msgstr ""
"这样的一个测试代码运行的环境被称为 :dfn:`test fixture` 。一个新的 TestCase "
"实例作为一个测试脚手架，用于运行各个独立的测试方法。在运行每个测试时，:meth:`~TestCase.setUp` "
"、:meth:`~TestCase.tearDown` 和 :meth:`~TestCase.__init__` 会被调用一次。"

#: ../../library/unittest.rst:444
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s "
":class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will"
" do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"推荐你根据用例所测试的功能将测试用 TestCase 分组。:mod:`unittest` 为此提供了 :dfn:`test "
"suite`：:mod:`unittest` 的 :class:`TestSuite` 类是一个代表。通常情况下，调用 "
":func:`unittest.main` 就能正确地找到并执行这个模块下所有用 TestCase 分组的测试。"

#: ../../library/unittest.rst:451
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr "然而，如果你需要自定义你的测试套件的话，你可以参考以下方法组织你的测试："

#: ../../library/unittest.rst:454
msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"
msgstr ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"

#: ../../library/unittest.rst:464
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"你可以把测试用例和测试套件放在与被测试代码相同的模块中（比如 :file:`widget.py`），但将测试代码放在单独的模块中（比如 "
":file:`test_widget.py`）有几个优势。"

#: ../../library/unittest.rst:469
msgid "The test module can be run standalone from the command line."
msgstr "测试模块可以从命令行被独立调用。"

#: ../../library/unittest.rst:471
msgid "The test code can more easily be separated from shipped code."
msgstr "更容易在分发的代码中剥离测试代码。"

#: ../../library/unittest.rst:473
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr "降低没有好理由的情况下修改测试代码以通过测试的诱惑。"

#: ../../library/unittest.rst:476
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "测试代码应比被测试代码更少地被修改。"

#: ../../library/unittest.rst:478
msgid "Tested code can be refactored more easily."
msgstr "被测试代码可以更容易地被重构。"

#: ../../library/unittest.rst:480
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr "对用 C 语言写成的模块无论如何都得单独写成一个模块，为什么不保持一致呢？"

#: ../../library/unittest.rst:483
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr "如果测试策略发生了改变，没有必要修改源代码。"

#: ../../library/unittest.rst:489
msgid "Re-using old test code"
msgstr "复用已有的测试代码"

#: ../../library/unittest.rst:491
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to a"
" :class:`TestCase` subclass."
msgstr ""
"一些用户希望直接使用 :mod:`unittest` 运行已有的测试代码，而不需要把已有的每个测试函数转化为一个 :class:`TestCase` "
"的子类。"

#: ../../library/unittest.rst:495
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class."
" This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"因此， :mod:`unittest` 提供 :class:`FunctionTestCase` 类。这个 :class:`TestCase` "
"的子类可用于打包已有的测试函数，并支持设置前置与后置函数。"

#: ../../library/unittest.rst:499
msgid "Given the following test function::"
msgstr "假定有一个测试函数："

#: ../../library/unittest.rst:501
msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."

#: ../../library/unittest.rst:506
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr "可以创建等价的测试用例如下，其中前置和后置方法是可选的。"

#: ../../library/unittest.rst:509
msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"

#: ../../library/unittest.rst:515
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"用 :class:`FunctionTestCase` 可以快速将现有的测试转换成基于 :mod:`unittest` "
"的测试，但不推荐你这样做。花点时间继承 :class:`TestCase` 会让以后重构测试无比轻松。"

#: ../../library/unittest.rst:520
msgid ""
"In some cases, the existing tests may have been written using the "
":mod:`doctest` module.  If so, :mod:`doctest` provides a "
":class:`DocTestSuite` class that can automatically build "
":class:`unittest.TestSuite` instances from the existing :mod:`doctest`\\ "
"-based tests."
msgstr ""
"在某些情况下，现有的测试可能是用 :mod:`doctest` 模块编写的。 如果是这样， :mod:`doctest` 提供了一个 "
":class:`DocTestSuite` 类，可以从现有基于 :mod:`doctest` 的测试中自动构建 "
":class:`unittest.TestSuite` 用例。"

#: ../../library/unittest.rst:529
msgid "Skipping tests and expected failures"
msgstr "跳过测试与预计的失败"

#: ../../library/unittest.rst:533
msgid ""
"Unittest supports skipping individual test methods and even whole classes of"
" tests.  In addition, it supports marking a test as an \"expected failure,\""
" a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest 支持跳过单个或整组的测试用例。它还支持把测试标注成“预期失败”的测试。这些坏测试会失败，但不会算进 "
":class:`TestResult` 的失败里。"

#: ../../library/unittest.rst:538
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` "
":term:`decorator` or one of its conditional variants, calling "
":meth:`TestCase.skipTest` within a :meth:`~TestCase.setUp` or test method, "
"or raising :exc:`SkipTest` directly."
msgstr ""
"要跳过测试只需使用 :func:`skip` :term:`decorator` 或其附带条件的版本，在 :meth:`~TestCase.setUp`"
" 内部使用 :meth:`TestCase.skipTest`，或是直接引发 :exc:`SkipTest`。"

#: ../../library/unittest.rst:542
msgid "Basic skipping looks like this::"
msgstr "跳过测试的基本用法如下::"

#: ../../library/unittest.rst:544
msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"
msgstr ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # 测试其是否仅适用于特定的库版本。\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires Windows\")\n"
"    def test_windows_support(self):\n"
"        # Windows 专属的测试代码\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # 依赖于外部资源的测试代码\n"
"        pass"

#: ../../library/unittest.rst:567
msgid "This is the output of running the example above in verbose mode::"
msgstr "在啰嗦模式下运行以上测试例子时，程序输出如下："

#: ../../library/unittest.rst:569
msgid ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped 'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped 'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"
msgstr ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped 'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped 'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"

#: ../../library/unittest.rst:579
msgid "Classes can be skipped just like methods::"
msgstr "跳过测试类的写法跟跳过测试方法的写法相似::"

#: ../../library/unittest.rst:581
msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"

#: ../../library/unittest.rst:586
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ":meth:`TestCase.setUp`  也可以跳过测试。可以用于所需资源不可用的情况下跳过接下来的测试。"

#: ../../library/unittest.rst:589
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "使用 :func:`expectedFailure` 装饰器表明这个测试预计失败。::"

#: ../../library/unittest.rst:591
msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"

#: ../../library/unittest.rst:596
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"你可以很容易地编写在测试时调用 :func:`skip` 的装饰器作为自定义的跳过测试装饰器。 "
"下面这个装饰器会跳过测试，除非所传入的对象具有特定的属性::"

#: ../../library/unittest.rst:600
msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"

#: ../../library/unittest.rst:605
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr "以下的装饰器和异常实现了跳过测试和预期失败两种功能："

#: ../../library/unittest.rst:609
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr "跳过被此装饰器装饰的测试。 *reason*  为测试被跳过的原因。"

#: ../../library/unittest.rst:614
msgid "Skip the decorated test if *condition* is true."
msgstr "当 *condition* 为真时，跳过被装饰的测试。"

#: ../../library/unittest.rst:618
msgid "Skip the decorated test unless *condition* is true."
msgstr "跳过被装饰的测试，除非 *condition* 为真。"

#: ../../library/unittest.rst:622
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"将测试标记为预期的失败或错误。 如果测试失败或在测试函数自身（而非在某个 :dfn:`test fixture` 方法）中出现错误则将认为是测试成功。 "
"如果测试通过，则将认为是测试失败。"

#: ../../library/unittest.rst:629
msgid "This exception is raised to skip a test."
msgstr "引发此异常以跳过一个测试。"

#: ../../library/unittest.rst:631
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"通常来说，你可以使用 :meth:`TestCase.skipTest` 或其中一个跳过测试的装饰器实现跳过测试的功能，而不是直接引发此异常。"

#: ../../library/unittest.rst:634
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or "
":meth:`~TestCase.tearDown` run around them. Skipped classes will not have "
":meth:`~TestCase.setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped"
" modules will not have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"被跳过的测试的 :meth:`~TestCase.setUp`  和 :meth:`~TestCase.tearDown` 不会被运行。被跳过的类的 "
":meth:`~TestCase.setUpClass` 和 :meth:`~TestCase.tearDownClass` 不会被运行。被跳过的模组的"
" :func:`setUpModule` 和 :func:`tearDownModule` 不会被运行。"

#: ../../library/unittest.rst:642
msgid "Distinguishing test iterations using subtests"
msgstr "使用子测试区分测试迭代"

#: ../../library/unittest.rst:646
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"当你的几个测试之间的差异非常小，例如只有某些形参不同时，unittest 允许你使用 :meth:`~TestCase.subTest` "
"上下文管理器在一个测试方法体的内部区分它们。"

#: ../../library/unittest.rst:650
msgid "For example, the following test::"
msgstr "例如，以下测试::"

#: ../../library/unittest.rst:652
msgid ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"
msgstr ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"

#: ../../library/unittest.rst:662
msgid "will produce the following output::"
msgstr "可以得到以下输出::"

#: ../../library/unittest.rst:664
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"

#: ../../library/unittest.rst:694
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't"
" be displayed::"
msgstr "如果不使用子测试，程序遇到第一次错误之后就会停止。而且因为 ``i`` 的值不显示，错误也更难找。"

#: ../../library/unittest.rst:698
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"

#: ../../library/unittest.rst:710
msgid "Classes and functions"
msgstr "类与函数"

#: ../../library/unittest.rst:712
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "本节深入介绍了 :mod:`unittest` 的 API。"

#: ../../library/unittest.rst:718
msgid "Test cases"
msgstr "测试用例"

#: ../../library/unittest.rst:722
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in"
" the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
":class:`TestCase` 类的实例代表了 :mod:`unittest` 宇宙中的逻辑测试单元。 "
"该类旨在被当作基类使用，特定的测试将由其实体子类来实现。 "
"该类实现了测试运行器所需的接口以允许它驱动测试，并实现了可被测试代码用来检测和报告各种类型的失败的方法。"

#: ../../library/unittest.rst:729
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method"
" named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"每个 :class:`TestCase` 实例将运行一个单位的基础方法：即名为 *methodName* 的方法。 在使用 "
":class:`TestCase` 的大多数场景中，你都不需要修改 *methodName* 或重新实现默认的 ``runTest()`` 方法。"

#: ../../library/unittest.rst:734
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from"
" the interactive interpreter."
msgstr ""
":class:`TestCase` 不需要提供 *methodName* 即可成功实例化。 这使得从交互式解释器试验 :class:`TestCase`"
" 更为容易。"

#: ../../library/unittest.rst:739
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions"
" and report failures, and some inquiry methods allowing information about "
"the test itself to be gathered."
msgstr ""
":class:`TestCase` "
"的实例提供了三组方法：一组用来运行测试，另一组被测试实现用来检查条件和报告失败，还有一些查询方法用来收集有关测试本身的信息。"

#: ../../library/unittest.rst:744
msgid "Methods in the first group (running the test) are:"
msgstr "第一组（用于运行测试的）方法是："

#: ../../library/unittest.rst:748
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or "
":exc:`SkipTest`, any exception raised by this method will be considered an "
"error rather than a test failure. The default implementation does nothing."
msgstr ""
"为测试预备而调用的方法。 此方法会在调用测试方法之前被调用；除了 :exc:`AssertionError` 或 "
":exc:`SkipTest`，此方法所引发的任何异常都将被视为错误而非测试失败。 默认的实现将不做任何事情。"

#: ../../library/unittest.rst:756
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than "
":exc:`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if the"
" :meth:`setUp` succeeds, regardless of the outcome of the test method. The "
"default implementation does nothing."
msgstr ""
"在测试方法被调用并记录结果之后立即被调用的方法。 此方法即使在测试方法引发异常时仍会被调用，因此子类中的实现将需要特别注意检查内部状态。 除 "
":exc:`AssertionError` 或 :exc:`SkipTest` "
"外，此方法所引发的任何异常都将被视为额外的错误而非测试失败（因而会增加总计错误报告数）。 此方法将只在 :meth:`setUp` "
"成功执行时被调用，无论测试方法的结果如何。 默认的实现将不做任何事情。"

#: ../../library/unittest.rst:769
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"在一个单独类中的测试运行之前被调用的类方法。 ``setUpClass`` 会被作为唯一的参数在类上调用且必须使用 "
":func:`classmethod` 装饰器::"

#: ../../library/unittest.rst:773
msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:777 ../../library/unittest.rst:792
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "查看 `Class and Module Fixtures`_ 获取更详细的说明。"

#: ../../library/unittest.rst:784
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"在一个单独类的测试完成运行之后被调用的类方法。 ``tearDownClass`` 会被作为唯一的参数在类上调用且必须使用 "
":meth:`classmethod` 装饰器::"

#: ../../library/unittest.rst:788
msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."

#: ../../library/unittest.rst:799
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"运行测试，将结果收集至作为 *result* 传入的 :class:`TestResult`。 如果 *result* 被省略或为 "
"``None``，则会创建一个临时的结果对象（通过调用 :meth:`defaultTestResult` 方法）并使用它。 结果对象会被返回给 "
":meth:`run` 的调用方。"

#: ../../library/unittest.rst:805
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr "同样的效果也可通过简单地调用 :class:`TestCase` 实例来达成。"

#: ../../library/unittest.rst:808
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr "之前版本的 ``run`` 不会返回结果。 也不会对实例执行调用。"

#: ../../library/unittest.rst:814
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr "在测试方法或 :meth:`setUp` 执行期间调用此方法将跳过当前测试。 详情参见 :ref:`unittest-skipping`。"

#: ../../library/unittest.rst:822
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"返回一个上下文管理器以将其中的代码块作为子测试来执行。 可选的 *msg* 和 *params* "
"是将在子测试失败时显示的任意值，以便让你能清楚地标识它们。"

#: ../../library/unittest.rst:827
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr "一个测试用例可以包含任意数量的子测试声明，并且它们可以任意地嵌套。"

#: ../../library/unittest.rst:830
msgid "See :ref:`subtests` for more information."
msgstr "查看 :ref:`subtests` 获取更详细的信息。"

#: ../../library/unittest.rst:837
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr "运行测试而不收集结果。 这允许测试所引发的异常被传递给调用方，并可被用于支持在调试器中运行测试。"

#: ../../library/unittest.rst:843
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and"
" report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
":class:`TestCase` 类提供了一些断言方法用于检查并报告失败。 下表列出了最常用的方法（请查看下文的其他表来了解更多的断言方法）:"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198 ../../library/unittest.rst:1368
msgid "Method"
msgstr "方法"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198
msgid "Checks that"
msgstr "检查对象"

#: ../../library/unittest.rst:848 ../../library/unittest.rst:984
#: ../../library/unittest.rst:1198 ../../library/unittest.rst:1368
msgid "New in"
msgstr "引入版本"

#: ../../library/unittest.rst:850
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:850
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:853
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:853
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:856
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:856
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:859
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:859
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:862
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:862
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:862 ../../library/unittest.rst:865
#: ../../library/unittest.rst:868 ../../library/unittest.rst:871
#: ../../library/unittest.rst:874 ../../library/unittest.rst:877
#: ../../library/unittest.rst:989 ../../library/unittest.rst:1206
#: ../../library/unittest.rst:1209 ../../library/unittest.rst:1212
#: ../../library/unittest.rst:1215 ../../library/unittest.rst:1218
#: ../../library/unittest.rst:1370 ../../library/unittest.rst:1373
#: ../../library/unittest.rst:1376 ../../library/unittest.rst:1379
#: ../../library/unittest.rst:1382 ../../library/unittest.rst:1385
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:865
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:865
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:868
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:868
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:871
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:871
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:874
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:874
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:877
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:877
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:880
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:880
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:880 ../../library/unittest.rst:883
#: ../../library/unittest.rst:992 ../../library/unittest.rst:995
#: ../../library/unittest.rst:1221 ../../library/unittest.rst:1224
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:883
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:883
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:886
msgid ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"
msgstr ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"

#: ../../library/unittest.rst:886
msgid "``issubclass(a, b)``"
msgstr "``issubclass(a, b)``"

#: ../../library/unittest.rst:886 ../../library/unittest.rst:889
#: ../../library/unittest.rst:1228 ../../library/unittest.rst:1231
#: ../../library/unittest.rst:1234 ../../library/unittest.rst:1237
#: ../../library/unittest.rst:1240 ../../library/unittest.rst:1243
msgid "3.14"
msgstr "3.14"

#: ../../library/unittest.rst:889
msgid ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"
msgstr ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"

#: ../../library/unittest.rst:889
msgid "``not issubclass(a, b)``"
msgstr "``not issubclass(a, b)``"

#: ../../library/unittest.rst:893
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, "
":meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` "
"only when they are used as a context manager."
msgstr ""
"这些断言方法都支持 *msg* 参数，如果指定了该参数，它将被用作测试失败时的错误消息 (另请参阅 :data:`longMessage`)。 请注意将"
" *msg* 关键字参数传给 :meth:`assertRaises`, :meth:`assertRaisesRegex`, "
":meth:`assertWarns`, :meth:`assertWarnsRegex` 的前提是它们必须被用作上下文管理器。"

#: ../../library/unittest.rst:901
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr "测试 *first* 和 *second* 是否相等。 如果两个值的比较结果是不相等，则测试将失败。"

#: ../../library/unittest.rst:904
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"此外，如果 *first* 和 *second* 的类型完全相同且属于 list, tuple, dict, set, frozenset 或 str "
"或者属于通过 :meth:`addTypeEqualityFunc` 注册子类的类型则将会调用类型专属的相等判断函数以便生成更有用的默认错误消息 "
"(另请参阅 :ref:`类型专属方法列表 <type-specific-methods>`)。"

#: ../../library/unittest.rst:911
msgid "Added the automatic calling of type-specific equality function."
msgstr "增加了对类型专属的相等判断函数的自动调用。"

#: ../../library/unittest.rst:914
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for"
" comparing strings."
msgstr "增加了 :meth:`assertMultiLineEqual` 作为用于比较字符串的默认类型相等判断函数。"

#: ../../library/unittest.rst:921
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr "测试 *first* 和 *second* 是否不等。 如果两个值的比较结果是相等，则测试将失败。"

#: ../../library/unittest.rst:927
msgid "Test that *expr* is true (or false)."
msgstr "测试 *expr* 是否为真值（或假值）。"

#: ../../library/unittest.rst:929
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"请注意这等价于 ``bool(expr) is True`` 而不等价于 ``expr is True`` (后者要使用 "
"``assertIs(expr, True)``)。 当存在更专门的方法时也应避免使用此方法 (例如应使用 ``assertEqual(a, b)`` "
"而不是 ``assertTrue(a == b)``)，因为它们在测试失败时会提供更有用的错误消息。"

#: ../../library/unittest.rst:939
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "测试 *first* 和 *second* 是 (或不是) 同一个对象。"

#: ../../library/unittest.rst:947
msgid "Test that *expr* is (or is not) ``None``."
msgstr "测试 *expr* 是 (或不是) ``None``。"

#: ../../library/unittest.rst:955
msgid "Test that *member* is (or is not) in *container*."
msgstr "测试 *member* 是 (或不是) *container* 的成员。"

#: ../../library/unittest.rst:963
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or"
" a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"测试 *obj* 是 (或不是) *cls* (此参数可以为一个类或包含类的元组，即 :func:`isinstance` 所接受的参数) 的实例。 "
"要检测是否为指定类型，请使用 :func:`assertIs(type(obj), cls) <assertIs>`。"

#: ../../library/unittest.rst:973
msgid ""
"Test that *cls* is (or is not) a subclass of *superclass* (which can be a "
"class or a tuple of classes, as supported by :func:`issubclass`). To check "
"for the exact type, use :func:`assertIs(cls, superclass) <assertIs>`."
msgstr ""
"测试 *cls* 是 (或不是) *superclass* 的子类 (此参数可以是一个类或由类组成的元组，即 :func:`issubclass` "
"所接受的值)。 要检测是否为特定类型，请使用 :func:`assertIs(cls, superclass) <assertIs>`。"

#: ../../library/unittest.rst:980
msgid ""
"It is also possible to check the production of exceptions, warnings, and log"
" messages using the following methods:"
msgstr "还可以使用下列方法来检查异常、警告和日志消息的产生:"

#: ../../library/unittest.rst:986
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:986
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` 引发了 *exc*"

#: ../../library/unittest.rst:989
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"

#: ../../library/unittest.rst:989
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)`` 引发了 *exc* 并且消息可与正则表达式 *r* 相匹配"

#: ../../library/unittest.rst:992
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:992
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` 引发了 *warn*"

#: ../../library/unittest.rst:995
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"

#: ../../library/unittest.rst:995
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)`` 引发了 *warn* 并且消息可与正则表达式 *r* 相匹配"

#: ../../library/unittest.rst:998
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:998
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "``with`` 代码块在 *logger* 上使用了最小的 *level* 级别写入日志"

#: ../../library/unittest.rst:998
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:1001
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:1001
msgid "The ``with`` block does not log on"
msgstr "``with`` 代码块没有在"

#: ../../library/unittest.rst:1002
msgid "*logger* with minimum *level*"
msgstr "*logger* 上使用最小的 *level* 级别写入日志"

#: ../../library/unittest.rst:1001
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:1008
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to "
":meth:`assertRaises`.  The test passes if *exception* is raised, is an error"
" if another exception is raised, or fails if no exception is raised. To "
"catch any of a group of exceptions, a tuple containing the exception classes"
" may be passed as *exception*."
msgstr ""
"测试当 *callable* 附带任何同时被传给 :meth:`assertRaises` 的位置或关键字参数被调用时是否引发了异常。 如果引发了 "
"*exception* 则测试通过，如果引发了另一个异常则报错，或者如果未引发任何异常则测试失败。 "
"要捕获一组异常中的任何一个，可以将包含多个异常类的元组作为 *exception* 传入。"

#: ../../library/unittest.rst:1015
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a"
" context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"如果只给出了 *exception* 和可能的 *msg* 参数，则返回一个上下文管理器以便被测试的代码可以被写成内联形式而不是被写成函数::"

#: ../../library/unittest.rst:1019
msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr ""
"with self.assertRaises(SomeException):\n"
"    do_something()"

#: ../../library/unittest.rst:1022
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr "当被作为上下文管理器使用时，:meth:`assertRaises` 接受额外的关键字参数 *msg*。"

#: ../../library/unittest.rst:1025
msgid ""
"The context manager will store the caught exception object in its "
":attr:`exception` attribute.  This can be useful if the intention is to "
"perform additional checks on the exception raised::"
msgstr "上下文管理器将把捕获的异常对象存入在其 :attr:`exception` 属性中。 这适用于需要对所引发异常执行额外检查的场合::"

#: ../../library/unittest.rst:1029
msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"

#: ../../library/unittest.rst:1035
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr "添加了将 :meth:`assertRaises` 用作上下文管理器的功能。"

#: ../../library/unittest.rst:1038
msgid "Added the :attr:`exception` attribute."
msgstr "增加了 :attr:`exception` 属性。"

#: ../../library/unittest.rst:1041 ../../library/unittest.rst:1067
#: ../../library/unittest.rst:1108 ../../library/unittest.rst:1131
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr "增加了 *msg* 关键字参数在作为上下文管理器时使用。"

#: ../../library/unittest.rst:1048
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression"
" object or a string containing a regular expression suitable for use by "
":func:`re.search`.  Examples::"
msgstr ""
"与 :meth:`assertRaises` 类似但还会测试 *regex* 是否匹配被引发异常的字符串表示形式。 *regex* "
"可以是一个正则表达式对象或包含正则表达式的字符串以提供给 :func:`re.search` 使用。 例如::"

#: ../../library/unittest.rst:1053
msgid ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"
msgstr ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"

#: ../../library/unittest.rst:1056 ../../library/unittest.rst:1124
msgid "or::"
msgstr "或者："

#: ../../library/unittest.rst:1058
msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"

#: ../../library/unittest.rst:1061
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "以方法名 ``assertRaisesRegexp`` 添加。"

#: ../../library/unittest.rst:1064
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "重命名为 :meth:`assertRaisesRegex`。"

#: ../../library/unittest.rst:1074
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:`assertWarns`."
"  The test passes if *warning* is triggered and fails if it isn't.  Any "
"exception is an error. To catch any of a group of warnings, a tuple "
"containing the warning classes may be passed as *warnings*."
msgstr ""
"测试当 *callable* 附带任何同时被传给 :meth:`assertWarns` 的位置或关键字参数被调用时是否触发了警告。 如果触发了 "
"*warning* 则测试通过，否则测试失败。 引发任何异常则报错。 要捕获一组警告中的任何一个，可将包含多个警告类的元组作为 *warnings* "
"传入。"

#: ../../library/unittest.rst:1081
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr "如果只给出了 *warning* 和可能的 *msg* 参数，则返回一个上下文管理器以便被测试的代码可以被写成内联形式而不是被写成函数::"

#: ../../library/unittest.rst:1085
msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"

#: ../../library/unittest.rst:1088
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr "当被作为上下文管理器使用时，:meth:`assertWarns` 接受额外的关键字参数 *msg*。"

#: ../../library/unittest.rst:1091
msgid ""
"The context manager will store the caught warning object in its "
":attr:`warning` attribute, and the source line which triggered the warnings "
"in the :attr:`filename` and :attr:`lineno` attributes. This can be useful if"
" the intention is to perform additional checks on the warning caught::"
msgstr ""
"上下文管理器将把捕获的警告对象保存在其 :attr:`warning` 属性中，并把触发警告的源代码行保存在 :attr:`filename` 和 "
":attr:`lineno` 属性中。 这适用于需要对捕获的警告执行额外检查的场合::"

#: ../../library/unittest.rst:1097
msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"

#: ../../library/unittest.rst:1103
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr "无论被调用时警告过滤器是否就位此方法均可工作。"

#: ../../library/unittest.rst:1115
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by "
":func:`re.search`.  Example::"
msgstr ""
"与 :meth:`assertWarns` 类似但还会测试 *regex* 是否匹配被触发警告的消息文本。 *regex* "
"可以是一个正则表达式对象或包含正则表达式的字符串以提供给 :func:`re.search` 使用。 例如::"

#: ../../library/unittest.rst:1120
msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"

#: ../../library/unittest.rst:1126
msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"

#: ../../library/unittest.rst:1136
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr "一个上下文管理器，它测试在 *logger* 或其子对象上是否至少记录了一条至少为指定 *level* 以上级别的消息。"

#: ../../library/unittest.rst:1140
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a "
":class:`str` giving the name of a logger.  The default is the root logger, "
"which will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"如果给出了 *logger* 则它应为一个 :class:`logging.Logger` 对象或为一个指定日志记录器名称的 :class:`str`。"
" 默认为根日志记录器，它将捕获未被非传播型后继日志记录器所拦阻的所有消息。"

#: ../../library/unittest.rst:1145 ../../library/unittest.rst:1186
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""
"如果给出了 *level*，它应为一个用数字表示的日志记录级别或其字符串等价形式 (例如为 ``\"ERROR\"`` 或 "
":const:`logging.ERROR`)。 默认为 :const:`logging.INFO`。"

#: ../../library/unittest.rst:1149
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr "如果在 ``with`` 代码块内部发出了至少一条与 *logger* 和 *level* 条件相匹配的消息则测试通过，否则测试失败。"

#: ../../library/unittest.rst:1152
msgid ""
"The object returned by the context manager is a recording helper which keeps"
" tracks of the matching log messages.  It has two attributes:"
msgstr "上下文管理器返回的对象是一个记录辅助器，它会记录所匹配的日志消息。 它有两个属性:"

#: ../../library/unittest.rst:1158
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr "所匹配的日志消息 :class:`logging.LogRecord` 对象组成的列表。"

#: ../../library/unittest.rst:1163
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr "由 :class:`str` 对象组成的列表，内容为所匹配消息经格式化后的输出。"

#: ../../library/unittest.rst:1166
msgid "Example::"
msgstr "示例::"

#: ../../library/unittest.rst:1168
msgid ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"
msgstr ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"

#: ../../library/unittest.rst:1178
msgid ""
"A context manager to test that no messages are logged on the *logger* or one"
" of its children, with at least the given *level*."
msgstr "一个上下文管理器，它测试在 *logger* 或其子对象上是否未记录任何至少为指定 *level* 以上级别的消息。"

#: ../../library/unittest.rst:1182
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a "
":class:`str` giving the name of a logger.  The default is the root logger, "
"which will catch all messages."
msgstr ""
"如果给出了 *logger* 则它应为一个 :class:`logging.Logger` 对象或为一个指定日志记录器名称的 :class:`str`。"
" 默认为根日志记录器，它将捕获所有消息。"

#: ../../library/unittest.rst:1190
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr "与 :meth:`assertLogs` 不同，上下文管理器将不返回任何对象。"

#: ../../library/unittest.rst:1195
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr "还有其他一些方法可用于执行更专门的检查，例如:"

#: ../../library/unittest.rst:1200
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1200
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1203
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1203
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1206
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1206
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1209
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1209
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1212
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1212
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1215
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1215
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1218
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1218
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1221
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1221
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../../library/unittest.rst:1224
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1224
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr "*a* 和 *b* 具有同样数量的相同元素，无论其顺序如何。"

#: ../../library/unittest.rst:1228
msgid ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"
msgstr ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"

#: ../../library/unittest.rst:1228
msgid "``a.startswith(b)``"
msgstr "``a.startswith(b)``"

#: ../../library/unittest.rst:1231
msgid ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"
msgstr ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"

#: ../../library/unittest.rst:1231
msgid "``not a.startswith(b)``"
msgstr "``not a.startswith(b)``"

#: ../../library/unittest.rst:1234
msgid ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"
msgstr ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"

#: ../../library/unittest.rst:1234
msgid "``a.endswith(b)``"
msgstr "``a.endswith(b)``"

#: ../../library/unittest.rst:1237
msgid ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"
msgstr ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"

#: ../../library/unittest.rst:1237
msgid "``not a.endswith(b)``"
msgstr "``not a.endswith(b)``"

#: ../../library/unittest.rst:1240
msgid ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"
msgstr ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"

#: ../../library/unittest.rst:1240
msgid "``hastattr(a, b)``"
msgstr "``hastattr(a, b)``"

#: ../../library/unittest.rst:1243
msgid ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"
msgstr ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"

#: ../../library/unittest.rst:1243
msgid "``not hastattr(a, b)``"
msgstr "``not hastattr(a, b)``"

#: ../../library/unittest.rst:1251
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the "
":func:`round` function) and not *significant digits*."
msgstr ""
"测试 *first* 与 *second* 是否几乎相等，比较的标准是计算差值并舍入到 *places* 所指定的十进制位数 (默认为 7 "
"位)，再与零相比较。 请注意此方法是将结果值舍入到指定的 *十进制位数* (即相当于 :func:`round` 函数) 而非 *有效位数*。"

#: ../../library/unittest.rst:1257
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"如果提供了 *delta* 而非 *places* 则 *first* 和 *second* 之间的差值必须小于等于 (或大于) *delta*。"

#: ../../library/unittest.rst:1260
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "同时提供 *delta* 和 *places* 将引发 :exc:`TypeError`。"

#: ../../library/unittest.rst:1262
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` 会自动将几乎相等的对象视为相等。 而如果对象相等则 "
":meth:`assertNotAlmostEqual` 会自动测试失败。 增加了 *delta* 关键字参数。"

#: ../../library/unittest.rst:1273
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr "根据方法名分别测试 *first* 是否 >, >=, < 或 <= *second*。 如果不是，则测试失败::"

#: ../../library/unittest.rst:1276
msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""

#: ../../library/unittest.rst:1285
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a"
" regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"测试一个 *regex* 搜索匹配（或不匹配） *文本*。如果不匹配，错误信息中将包含匹配模式和 *文本*（或部分匹配失败的 *文本*）。*regex*"
" 可以是正则表达式对象或能够用于 :func:`re.search` 的包含正则表达式的字符串。"

#: ../../library/unittest.rst:1291
msgid "Added under the name ``assertRegexpMatches``."
msgstr "以方法名 ``assertRegexpMatches`` 添加。"

#: ../../library/unittest.rst:1293
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to "
":meth:`.assertRegex`."
msgstr "方法 ``assertRegexpMatches()`` 已被改名为 :meth:`.assertRegex`。"

#: ../../library/unittest.rst:1296
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`"

#: ../../library/unittest.rst:1302
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"测试序列 *first* 与 *second* 是否包含同样的元素，无论其顺序如何。 当存在差异时，将生成一条错误消息来列出两个序列之间的差异。"

#: ../../library/unittest.rst:1306
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It"
" verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"重复的元素 *不会* 在 *first* 和 *second* 的比较中被忽略。 它会检查每个元素在两个序列中的出现次数是否相同。 等价于: "
"``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"但还适用于包含不可哈希对象的序列。"

#: ../../library/unittest.rst:1318
msgid ""
"Test that the Unicode or byte string *s* starts (or does not start) with a "
"*prefix*. *prefix* can also be a tuple of strings to try."
msgstr "测试 Unicode 字符串或字节串 *s* 是（或不是）以 *prefix* 开头。 *prefix* 也可以是供测试的字符串元组。"

#: ../../library/unittest.rst:1328
msgid ""
"Test that the Unicode or byte string *s* ends (or does not end) with a "
"*suffix*. *suffix* can also be a tuple of strings to try."
msgstr "测试 Unicode 字符串或字节串 *s* 是（或不是）以 *suffix* 结尾。 *suffix* 也可以是供测试的字节串元组。"

#: ../../library/unittest.rst:1338
msgid "Test that the object *obj* has (or has not) an attribute *name*."
msgstr "测试对象 *obj* 具有（或不具有）属性 *name*。"

#: ../../library/unittest.rst:1345
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already"
" implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
":meth:`assertEqual` 方法会将相同类型对象的相等性检查分派给不同的类型专属方法。 这些方法已被大多数内置类型所实现，但也可以使用 "
":meth:`addTypeEqualityFunc` 来注册新的方法:"

#: ../../library/unittest.rst:1352
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise "
":data:`self.failureException(msg) <failureException>` when inequality "
"between the first two parameters is detected -- possibly providing useful "
"information and explaining the inequalities in details in the error message."
msgstr ""
"注册一个由 :meth:`assertEqual` 调用的特定类型专属方法来检查恰好为相同 *typeobj* (而非子类) 的两个对象是否相等。 "
"*function* 必须接受两个位置参数和第三个 msg=None 关键字参数，就像 :meth:`assertEqual` 那样。 "
"当检测到前两个形参之间不相等时它必须引发 :data:`self.failureException(msg) <failureException>` "
"-- 可能还会提供有用的信息并在错误消息中详细解释不相等的原因。"

#: ../../library/unittest.rst:1363
msgid ""
"The list of type-specific methods automatically used by "
":meth:`~TestCase.assertEqual` are summarized in the following table.  Note "
"that it's usually not necessary to invoke these methods directly."
msgstr ""
"以下是 :meth:`~TestCase.assertEqual` 自动选用的不同类型的比较方法。一般情况下不需要直接在测试中调用这些方法。"

#: ../../library/unittest.rst:1368
msgid "Used to compare"
msgstr "用作比较"

#: ../../library/unittest.rst:1370
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1370
msgid "strings"
msgstr "字符串"

#: ../../library/unittest.rst:1373
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1373
msgid "sequences"
msgstr "序列"

#: ../../library/unittest.rst:1376
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1376
msgid "lists"
msgstr "列表"

#: ../../library/unittest.rst:1379
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1379
msgid "tuples"
msgstr "元组"

#: ../../library/unittest.rst:1382
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1382
msgid "sets or frozensets"
msgstr "集合"

#: ../../library/unittest.rst:1385
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1385
msgid "dicts"
msgstr "字典"

#: ../../library/unittest.rst:1393
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When"
" not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing"
" strings with :meth:`assertEqual`."
msgstr ""
"测试多行字符串 *first* 是否与字符串 *second* 相等。 当不相等时将在错误消息中包括两个字符串之间差异的高亮显示。 此方法会在通过 "
":meth:`assertEqual` 进行字符串比较时默认被使用。"

#: ../../library/unittest.rst:1403
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that"
" shows the difference between the two."
msgstr ""
"测试两个序列是否相等。 如果提供了 *seq_type*，则 *first* 和 *second* 都必须为 *seq_type* "
"的实例否则将引发失败。 如果两个序列不相等则会构造一个错误消息来显示两者之间的差异。"

#: ../../library/unittest.rst:1408
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"此方法不会被 :meth:`assertEqual` 直接调用，但它会被用于实现 :meth:`assertListEqual` 和 "
":meth:`assertTupleEqual`。"

#: ../../library/unittest.rst:1418
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods"
" are used by default when comparing lists or tuples with "
":meth:`assertEqual`."
msgstr ""
"测试两个列表或元组是否相等。 如果不相等，则会构造一个错误消息来显示两者之间的差异。 如果某个形参的类型不正确也会引发错误。 这些方法会在通过 "
":meth:`assertEqual` 进行列表或元组比较时默认被使用。"

#: ../../library/unittest.rst:1429
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that"
" lists the differences between the sets.  This method is used by default "
"when comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"测试两个集合是否相等。 如果不相等，则会构造一个错误消息来列出两者之间的差异。 此方法会在通过 :meth:`assertEqual` "
"进行集合或冻结集合比较时默认被使用。"

#: ../../library/unittest.rst:1433
msgid ""
"Fails if either of *first* or *second* does not have a "
":meth:`set.difference` method."
msgstr "如果 *first* 或 *second* 没有 :meth:`set.difference` 方法则测试失败。"

#: ../../library/unittest.rst:1441
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will"
" be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"测试两个字典是否相等。 如果不相等，则会构造一个错误消息来显示两个字典的差异。 此方法会在对 :meth:`assertEqual` "
"的调用中默认被用来进行字典的比较。"

#: ../../library/unittest.rst:1452
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "最后 :class:`TestCase` 还提供了以下的方法和属性:"

#: ../../library/unittest.rst:1457
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error"
" message."
msgstr "无条件地发出测试失败消息，附带错误消息 *msg* 或 ``None``。"

#: ../../library/unittest.rst:1463
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is "
":exc:`AssertionError`."
msgstr ""
"这个类属性给出测试方法所引发的异常。 如果某个测试框架需要使用专门的异常，并可能附带额外的信息，则必须子类化该类以便与框架“正常互动”。 "
"这个属性的初始值为 :exc:`AssertionError`。"

#: ../../library/unittest.rst:1472
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"这个类属性决定当将一个自定义失败消息作为 msg 参数传给一个失败的 assertXYY 调用时会发生什么。默认值为 ``True``。 "
"在此情况下，自定义消息会被添加到标准失败消息的末尾。 当设为 ``False`` 时，自定义消息会替换标准消息。"

#: ../../library/unittest.rst:1478
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"类设置可以通过在调用断言方法之前将一个实例属性 self.longMessage 赋值为 ``True`` 或 ``False`` "
"在单个测试方法中进行重载。"

#: ../../library/unittest.rst:1482
msgid "The class setting gets reset before each test call."
msgstr "类设置会在每个测试调用之前被重置。"

#: ../../library/unittest.rst:1489
msgid ""
"This attribute controls the maximum length of diffs output by assert methods"
" that report diffs on failure. It defaults to 80*8 characters. Assert "
"methods affected by this attribute are :meth:`assertSequenceEqual` "
"(including all the sequence comparison methods that delegate to it), "
":meth:`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"这个属性控制来自在测试失败时报告 diffs 的断言方法的 diffs 输出的最大长度。 它默认为 80*8 个字符。 这个属性所影响的断言方法有 "
":meth:`assertSequenceEqual` (包括所有委托给它的序列比较方法), :meth:`assertDictEqual` 以及 "
":meth:`assertMultiLineEqual`。"

#: ../../library/unittest.rst:1496
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr "将 ``maxDiff`` 设为 ``None`` 表示不限制 diffs 的最大长度。"

#: ../../library/unittest.rst:1502
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr "测试框架可使用下列方法来收集测试的有关信息:"

#: ../../library/unittest.rst:1508
msgid ""
"Return the number of tests represented by this test object.  For "
":class:`TestCase` instances, this will always be ``1``."
msgstr "返回此测试对象所提供的测试数量。 对于 :class:`TestCase` 实例，该数量将总是为 ``1``。"

#: ../../library/unittest.rst:1514
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr "返回此测试类所要使用的测试结果类的实例（如果未向 :meth:`run` 方法提供其他结果实例）。"

#: ../../library/unittest.rst:1518
msgid ""
"For :class:`TestCase` instances, this will always be an instance of "
":class:`TestResult`; subclasses of :class:`TestCase` should override this as"
" necessary."
msgstr ""
"对于 :class:`TestCase` 实例，该返回值将总是为 :class:`TestResult` 的实例；:class:`TestCase` "
"的子类应当在有必要时重写此方法。"

#: ../../library/unittest.rst:1525
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr "返回一个标识指定测试用例的字符串。 该返回值通常为测试方法的完整名称，包括模块名和类名。"

#: ../../library/unittest.rst:1531
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"返回测试的描述，如果未提供描述则返回 ``None``。 此方法的默认实现将在可用的情况下返回测试方法的文档字符串的第一行，或者返回 ``None``。"

#: ../../library/unittest.rst:1536
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the "
":class:`TextTestResult` in Python 3.2."
msgstr ""
"在 3.1 中已修改此方法将测试名称添加到简短描述中，即使存在文档字符串。 这导致了与单元测试扩展的兼容性问题因而在 Python 3.2 "
"中将添加测试名称操作改到 :class:`TextTestResult` 中。"

#: ../../library/unittest.rst:1545
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used"
" during the test. Functions will be called in reverse order to the order "
"they are added (:abbr:`LIFO (last-in, first-out)`).  They are called with "
"any arguments and keyword arguments passed into :meth:`addCleanup` when they"
" are added."
msgstr ""
"在 :meth:`tearDown` 之后添加了一个要调用的函数来清理测试期间所使用的资源。 函数将按它们被添加的相反顺序被调用 "
"(:abbr:`LIFO (last-in, first-out)`)。 它们在调用时将附带它们被添加时传给 :meth:`addCleanup` "
"的任何参数和关键字参数。"

#: ../../library/unittest.rst:1551
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr "如果 :meth:`setUp` 失败，即意味着 :meth:`tearDown` 未被调用，则已添加的任何清理函数仍将被调用。"

#: ../../library/unittest.rst:1559
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"进入所提供的 :term:`context manager`。 如果成功，还会将其 :meth:`~object.__exit__` 方法作为使用 "
":meth:`addCleanup` 的清理函数并返回 :meth:`~object.__enter__` 方法的结果。"

#: ../../library/unittest.rst:1569
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after "
":meth:`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"此方法会在 :meth:`tearDown` 之后，或者如果 :meth:`setUp` 引发了异常则会在 :meth:`setUp` 之后被调用。"

#: ../../library/unittest.rst:1572
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addCleanup`. If you need cleanup functions to be called *prior* to "
":meth:`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"它将负责调用由 :meth:`addCleanup` 添加的所有清理函数。 如果你需要在 :meth:`tearDown` *之前* "
"调用清理函数则可以自行调用 :meth:`doCleanups`。"

#: ../../library/unittest.rst:1577
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ":meth:`doCleanups` 每次会弹出清理函数栈中的一个方法，因此它可以在任何时候被调用。"

#: ../../library/unittest.rst:1585
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources"
" used during the test class. Functions will be called in reverse order to "
"the order they are added (:abbr:`LIFO (last-in, first-out)`). They are "
"called with any arguments and keyword arguments passed into "
":meth:`addClassCleanup` when they are added."
msgstr ""
"在Add a function to be called after :meth:`tearDownClass` "
"之后添加了一个要调用的函数来清理测试类运行期间所使用的资源。 函数将按它们被添加的相反顺序被调用 (:abbr:`LIFO (last-in, "
"first-out)`)。 它们在调用时将附带它们被添加时传给 :meth:`addClassCleanup` 的任何参数和关键字参数。"

#: ../../library/unittest.rst:1591
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"如果 :meth:`setUpClass` 失败，即意味着 :meth:`tearDownClass` 未被调用，则已添加的任何清理函数仍将被调用。"

#: ../../library/unittest.rst:1599
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by "
":meth:`addClassCleanup` and return the result of the "
":meth:`~object.__enter__` method."
msgstr ""
"进入所提供的 :term:`context manager`。 如果成功，还会将其 :meth:`~object.__exit__` 方法作为使用 "
":meth:`addClassCleanup` 的清理函数并返回 :meth:`~object.__enter__` 方法的结果。"

#: ../../library/unittest.rst:1609
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after "
":meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"此方法会在 :meth:`tearDownClass` 之后无条件地被调用，或者如果 :meth:`setUpClass` 引发了异常则会在 "
":meth:`setUpClass` 之后被调用。"

#: ../../library/unittest.rst:1612
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addClassCleanup`. If you need cleanup functions to be called *prior* "
"to :meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"它将负责访问由 :meth:`addClassCleanup` 添加的所有清理函数。 如果你需要在 :meth:`tearDownClass` *之前*"
" 调用清理函数则可以自行调用 :meth:`doClassCleanups`。"

#: ../../library/unittest.rst:1617
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ":meth:`doClassCleanups` 每次会弹出清理函数栈中的一个方法，因此它在任何时候被调用。"

#: ../../library/unittest.rst:1625
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr "这个类提供了与 :class:`TestCase` 类似的 API 并也接受协程作为测试函数。"

#: ../../library/unittest.rst:1632
msgid ""
"The *loop_factory* passed to :class:`asyncio.Runner`. Override in subclasses"
" with :class:`asyncio.EventLoop` to avoid using the asyncio policy system."
msgstr ""
"传给 :class:`asyncio.Runner` 的 *loop_factory*。 通过 :class:`asyncio.EventLoop` "
"重写子类以避免使用 asyncio 策略系统。"

#: ../../library/unittest.rst:1641
msgid ""
"Method called to prepare the test fixture. This is called after "
":meth:`setUp`. This is called immediately before calling the test method; "
"other than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by"
" this method will be considered an error rather than a test failure. The "
"default implementation does nothing."
msgstr ""
"为测试预备而调用的方法。 此方法会在 :meth:`setUp` 之后被调用。 此方法将在调用测试方法之前立即被调用；除了 "
":exc:`AssertionError` 或 :exc:`SkipTest`，此方法所引发的任何异常都将被视为错误而非测试失败。 "
"默认的实现将不做任何事情。"

#: ../../library/unittest.rst:1650
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of"
" the outcome of the test method. The default implementation does nothing."
msgstr ""
"在测试方法被调用并记录结果之后立即被调用的方法。 此方法会在 :meth:`tearDown` 之前被调用。 "
"此方法即使在测试方法引发异常时仍会被调用，因此子类中的实现将需要特别注意检查内部状态。 除 :exc:`AssertionError` 或 "
":exc:`SkipTest` 外，此方法所引发的任何异常都将被视为额外的错误而非测试失败（因而会增加总计错误报告数）。 此方法将只在 "
":meth:`asyncSetUp` 成功执行时被调用，无论测试方法的结果如何。 默认的实现将不做任何事情。"

#: ../../library/unittest.rst:1662
msgid ""
"This method accepts a coroutine that can be used as a cleanup function."
msgstr "此方法接受一个可被用作清理函数的协程。"

#: ../../library/unittest.rst:1667
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by "
":meth:`addAsyncCleanup` and return the result of the "
":meth:`~object.__aenter__` method."
msgstr ""
"进入所提供的 :term:`asynchronous context manager`。 如果成功，还会将其 "
":meth:`~object.__aexit__` 方法作为使用 :meth:`addAsyncCleanup` 的清理函数并返回 "
":meth:`~object.__aenter__` 方法的结果。"

#: ../../library/unittest.rst:1677
msgid ""
"Sets up a new event loop to run the test, collecting the result into the "
":class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the "
":meth:`defaultTestResult` method) and used. The result object is returned to"
" :meth:`run`'s caller. At the end of the test all the tasks in the event "
"loop are cancelled."
msgstr ""
"设置一个新的事件循环来运行测试，将结果收集至作为 *result* 传入的 :class:`TestResult`。 如果 *result* 被省略或为"
" ``None``，则会创建一个临时的结果对象（通过调用 :meth:`defaultTestResult` 方法）并使用它。 结果对象会被返回给 "
":meth:`run` 的调用方。 在测试结束时事件循环中的所有任务都将被取消。"

#: ../../library/unittest.rst:1685
msgid "An example illustrating the order::"
msgstr "一个显示先后顺序的例子::"

#: ../../library/unittest.rst:1687
msgid ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example.com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example.com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"

#: ../../library/unittest.rst:1721
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"在运行测试之后，``events`` 将会包含 ``[\"setUp\", \"asyncSetUp\", \"test_response\", "
"\"asyncTearDown\", \"tearDown\", \"cleanup\"]``。"

#: ../../library/unittest.rst:1726
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a "
":mod:`unittest`-based test framework."
msgstr ""
"这个类实现了 :class:`TestCase` 的部分接口，允许测试运行方驱动测试，但不提供可被测试代码用来检查和报告错误的方法。 "
"这个类被用于创建使用传统测试代码的测试用例，允许它被集成到基于 :mod:`unittest` 的测试框架中。"

#: ../../library/unittest.rst:1736
msgid "Grouping tests"
msgstr "分组测试"

#: ../../library/unittest.rst:1740
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"这个类代表对单独测试用例和测试套件的聚合。 这个类提供给测试运行方所需的接口以允许其像任何其他测试用例一样运行。 运行一个 "
":class:`TestSuite` 实例与对套件执行迭代来逐一运行每个测试的效果相同。"

#: ../../library/unittest.rst:1745
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional"
" methods are provided to add test cases and suites to the collection later "
"on."
msgstr ""
"如果给出了 *tests*，则它必须是一个包含单独测试用例的可迭代对象或是将被用于初始构建测试套件的其他测试套件。 "
"还有一些附加的方法会被提供用来在随后向测试集添加测试用例和测试套件。"

#: ../../library/unittest.rst:1749
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite` 对象的行为与 :class:`TestCase` 对象很相似，区别在于它们并不会真正实现一个测试。 "
"它们会被用来将测试聚合为多个要同时运行的测试分组。 还有一些附加的方法会被用来向 :class:`TestSuite` 实例添加测试:"

#: ../../library/unittest.rst:1757
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "向测试套件添加 :class:`TestCase` 或 :class:`TestSuite`。"

#: ../../library/unittest.rst:1762
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and "
":class:`TestSuite` instances to this test suite."
msgstr "将来自包含 :class:`TestCase` 和 :class:`TestSuite` 实例的可迭代对象的所有测试添加到这个测试套件。"

#: ../../library/unittest.rst:1765
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr "这等价于对 *tests* 进行迭代，并为其中的每个元素调用 :meth:`addTest`。"

#: ../../library/unittest.rst:1768
msgid ""
":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite` 与 :class:`TestCase` 共享下列方法:"

#: ../../library/unittest.rst:1773
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike "
":meth:`TestCase.run`, :meth:`TestSuite.run` requires the result object to be"
" passed in."
msgstr ""
"运行与这个套件相关联的测试，将结果收集到作为 *result* 传入的测试结果对象中。 请注意与 :meth:`TestCase.run` "
"的区别，:meth:`TestSuite.run` 必须传入结果对象。"

#: ../../library/unittest.rst:1781
msgid ""
"Run the tests associated with this suite without collecting the result. This"
" allows exceptions raised by the test to be propagated to the caller and can"
" be used to support running tests under a debugger."
msgstr "运行与这个套件相关联的测试而不收集结果。 这允许测试所引发的异常被传递给调用方并可被用于支持在调试器中运行测试。"

#: ../../library/unittest.rst:1788
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr "返回此测试对象所提供的测试数量，包括单独的测试和子套件。"

#: ../../library/unittest.rst:1794
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"由 :class:`TestSuite` 分组的测试总是可以通过迭代来访问。 其子类可以通过重载 :meth:`!__iter__` 来惰性地提供测试。"
" 请注意此方法可在单个套件上多次被调用（例如在计数或相等性比较时），为此在 :meth:`TestSuite.run` "
"之前重复迭代所返回的测试对于每次调用迭代都必须相同。 在 :meth:`TestSuite.run` "
"之后，调用方不应继续访问此方法所返回的测试，除非调用方使用重载了 :meth:`TestSuite._removeTestAtIndex` "
"的子类来保留对测试的引用。"

#: ../../library/unittest.rst:1804
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""
"在较早的版本中 :class:`TestSuite` 会直接访问测试而不是通过迭代，因此只重载 :meth:`!__iter__` "
"并不足以提供所有测试。"

#: ../../library/unittest.rst:1809
msgid ""
"In earlier versions the :class:`TestSuite` held references to each "
":class:`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that "
"behavior by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"在较早的版本中 :class:`TestSuite` 会在 :meth:`TestSuite.run` 之后保留对每个 "
":class:`TestCase` 的引用。 其子类可以通过重载 :meth:`TestSuite._removeTestAtIndex` "
"来恢复此行为。"

#: ../../library/unittest.rst:1814
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test "
"harness."
msgstr ""
"在 :class:`TestSuite` 对象的典型应用中，:meth:`run` 方法是由 :class:`TestRunner` "
"唤起而不是由最终用户测试来控制。"

#: ../../library/unittest.rst:1819
msgid "Loading and running tests"
msgstr "加载和运行测试"

#: ../../library/unittest.rst:1823
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and"
" modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as "
":data:`unittest.defaultTestLoader`.  Using a subclass or instance, however, "
"allows customization of some configurable properties."
msgstr ""
":class:`TestLoader` 类可被用来基于类和模块创建测试套件。 通常，没有必要创建该类的实例；:mod:`unittest` "
"模块提供了一个可作为 :data:`unittest.defaultTestLoader` 共享的实例。 "
"但是，使用子类或实例允许对某些配置属性进行定制。"

#: ../../library/unittest.rst:1829
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` 对象具有下列属性:"

#: ../../library/unittest.rst:1834
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by"
" the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a"
" synthetic test that will raise the original error when run."
msgstr ""
"由在加载测试期间遇到的非致命错误组成的列表。 在任何时候都不会被加载方重围。 致命错误是通过相关方法引发一个异常来向调用方发出信号的。 "
"非致命错误也是由一个将在运行时引发原始错误的合成测试来提示的。"

#: ../../library/unittest.rst:1843
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader` 对象具有下列方法:"

#: ../../library/unittest.rst:1848
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ "
"-derived :class:`testCaseClass`."
msgstr "返回一个包含在 :class:`TestCase` 所派生的 :class:`testCaseClass` 中的所有测试用例的测试套件。"

#: ../../library/unittest.rst:1851
msgid ""
"A test case instance is created for each method named by "
":meth:`getTestCaseNames`. By default these are the method names beginning "
"with ``test``. If :meth:`getTestCaseNames` returns no methods, but the "
":meth:`runTest` method is implemented, a single test case is created for "
"that method instead."
msgstr ""
"会为每个由 :meth:`getTestCaseNames` 指明的方法创建一个测试用例实例。 在默认情况下这些都是以 ``test`` "
"开头的方法名称。 如果 :meth:`getTestCaseNames` 不返回任何方法，但 :meth:`runTest` "
"方法已被实现，则会为该方法创建一个单独的测试用例。"

#: ../../library/unittest.rst:1860
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"返回包含在给定模块中的所有测试用例的测试套件。 此方法会在 *module* 中搜索从派生自 :class:`TestCase` "
"的类并为该类定义的每个测试方法创建一个类实例。"

#: ../../library/unittest.rst:1867
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"虽然使用 :class:`TestCase` "
"所派生的类的层级结构可以方便地共享配置和辅助函数，但在不打算直接实例化的基类上定义测试方法并不能很好地配合此方法使用。 "
"不过，当配置有差异并且定义在子类当中时这样做还是有用处的。"

#: ../../library/unittest.rst:1873
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the"
" tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"如果一个模块提供了 ``load_tests`` 函数则它将被调用以加载测试。 这允许模块自行定制测试加载过程。 这就称为 `load_tests "
"protocol`_。 *pattern* 参数会被作为传给 ``load_tests`` 的第三个参数。"

#: ../../library/unittest.rst:1878
msgid "Support for ``load_tests`` added."
msgstr "添加了对 ``load_tests`` 的支持。"

#: ../../library/unittest.rst:1881
msgid "Support for a keyword-only argument *pattern* has been added."
msgstr "增加了对仅限关键字参数 *pattern* 的支持。"

#: ../../library/unittest.rst:1884
msgid ""
"The undocumented and unofficial *use_load_tests* parameter has been removed."
msgstr "未写入文档的非正式 *use_load_tests* 形参已被移除。"

#: ../../library/unittest.rst:1891
msgid "Return a suite of all test cases given a string specifier."
msgstr "返回由给出了字符串形式规格描述的所有测试用例组成的测试套件。"

#: ../../library/unittest.rst:1893
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a "
":class:`TestSuite` instance, or a callable object which returns a "
":class:`TestCase` or :class:`TestSuite` instance.  These checks are applied "
"in the order listed here; that is, a method on a possible test case class "
"will be picked up as \"a test method within a test case class\", rather than"
" \"a callable object\"."
msgstr ""
"描述名称 *name* 是一个“带点号的名称”，它可以被解析为一个模块、一个测试用例类、一个测试用例类内部的测试方法、一个 "
":class:`TestSuite` 实例，或者一个返回 :class:`TestCase` 或 :class:`TestSuite` "
"实例的可调用对象。 "
"这些检查将按在此列出的顺序执行；也就是说，一个可能的测试用例类上的方法将作为“一个测试用例内部的测试方法”而非作为“一个可调用对象”被选定。"

#: ../../library/unittest.rst:1901
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a "
":class:`TestCase`\\ -derived class :class:`SampleTestCase` with three test "
"methods (:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the "
"specifier ``'SampleTests.SampleTestCase'`` would cause this method to return"
" a suite which will run all three test methods. Using the specifier "
"``'SampleTests.SampleTestCase.test_two'`` would cause it to return a test "
"suite which will run only the :meth:`test_two` test method. The specifier "
"can refer to modules and packages which have not been imported; they will be"
" imported as a side-effect."
msgstr ""
"举例来说，如果你有一个模块 :mod:`SampleTests`，其中包含一个派生自 :class:`TestCase` 的类 "
":class:`SampleTestCase`，其中包含三个测试方法 (:meth:`test_one`, :meth:`test_two` 和 "
":meth:`test_three`)。 则描述名称 ``'SampleTests.SampleTestCase'`` "
"将使此方法返回一个测试套件，它将运行全部三个测试方法。 使用描述名称 ``'SampleTests.SampleTestCase.test_two'``"
" 将使它返回一个测试套件，它将仅运行 :meth:`test_two` 测试方法。 描述名称可以指向尚未被导入的模块和包；它们将作为附带影响被导入。"

#: ../../library/unittest.rst:1911
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "本模块可以选择相对于给定的 *module* 来解析 *name*。"

#: ../../library/unittest.rst:1913
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by "
"self.errors."
msgstr ""
"如果在遍历 *name* 时发生了 :exc:`ImportError` 或 :exc:`AttributeError` "
"则在运行时引发该错误的合成测试将被返回。 这些错误被包括在由 self.errors 所积累的错误中。"

#: ../../library/unittest.rst:1922
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the"
" tests defined for each name."
msgstr ""
"类似于 :meth:`loadTestsFromName`，但是接受一个名称序列而不是单个名称。 "
"返回值是一个测试套件，它支持为每个名称所定义的所有测试。"

#: ../../library/unittest.rst:1929
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr "返回由 *testCaseClass* 中找到的方法名称组成的已排序的序列；这应当是 :class:`TestCase` 的一个子类。"

#: ../../library/unittest.rst:1935
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"通过从指定的开始目录向其子目录递归来找出所有测试模块，并返回一个包含该结果的 TestSuite 对象。 只有与 *pattern* "
"匹配的测试文件才会被加载。 （使用 shell 风格的模式匹配。） 只有可导入的模块名称（即有效的 Python 标识符）将会被加载。"

#: ../../library/unittest.rst:1941
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then *top_level_dir* must"
" be specified separately."
msgstr "所有测试模块都必须可以从项目的最高层级上导入。 如果起始目录不是最高层级则必须单独指明 *top_level_dir*。"

#: ../../library/unittest.rst:1945
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"如果导入某个模块失败，比如因为存在语法错误，则会将其记录为单独的错误并将继续查找模块。 如果导入失败是因为引发了 "
":exc:`SkipTest`，则会将其记录为跳过而不是错误。"

#: ../../library/unittest.rst:1950
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function"
" itself calls ``loader.discover``."
msgstr ""
"如果找到了一个包（即包含名为 :file:`__init__.py` 的文件的目录），则将在包中查找 ``load_tests`` 函数。 "
"如果存在此函数则将对其执行调用 ``package.load_tests(loader, tests, pattern)``。 "
"测试发现操作会确保在执行期间仅检查测试一次，即使 load_tests 函数本身调用了 ``loader.discover`` 也是如此。."

#: ../../library/unittest.rst:1958
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package,"
" ``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"如果 ``load_tests`` 存在则发现操作 *不会* 对包执行递归处理，``load_tests`` 将负责加载包中的所有测试。is "
"responsible for loading all tests in the package."

#: ../../library/unittest.rst:1962
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves."
msgstr "该模式故意不被保存为加载器属性以使得包可以继续发自其自身。"

#: ../../library/unittest.rst:1965
msgid ""
"*top_level_dir* is stored internally, and used as a default to any nested "
"calls to ``discover()``. That is, if a package's ``load_tests`` calls "
"``loader.discover()``, it does not need to pass this argument."
msgstr ""
"*top_level_dir* 是在内部保存的，并被用作任何对 ``discover()`` 的嵌套调用的默认值。 也就是说，如果一个包的 "
"``load_tests`` 调用了 ``loader.discover()``，则无需传递此参数。"

#: ../../library/unittest.rst:1969
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* 可以是一个带点号的名称或是一个目录。"

#: ../../library/unittest.rst:1973
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr "在导入时引发 :exc:`SkipTest` 的模块会被记录为跳过，而不是错误。"

#: ../../library/unittest.rst:1977
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr "*start_dir* 可以是一个 :term:`命名空间包 <namespace package>`。"

#: ../../library/unittest.rst:1979
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr "路径在被导入之前会先被排序以使得执行顺序保持一致，即使下层文件系统的顺序不是取决于文件名的。"

#: ../../library/unittest.rst:1983
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to"
" match the default pattern."
msgstr "现在 ``load_tests`` 会检查已找到的包，无论它们的路径是否与 *pattern* 匹配，因为包名称是无法与默认的模式匹配的。"

#: ../../library/unittest.rst:1988
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7, and Python 3.11 officially removes it."
msgstr ""
"*start_dir* 不能是一个 :term:`命名空间包 <namespace package>`。 它自 Python 3.7 开始已不可用而 "
"Python 3.11 正式将其移除。"

#: ../../library/unittest.rst:1992
msgid "*top_level_dir* is only stored for the duration of *discover* call."
msgstr "*top_level_dir* 仅会在 *discover* 调用期间被保存。"

#: ../../library/unittest.rst:1995
msgid "*start_dir* can once again be a :term:`namespace package`."
msgstr "*start_dir* 又可以是一个 :term:`namespace package`。"

#: ../../library/unittest.rst:1998
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ":class:`TestLoader` 的下列属性可通过子类化或在实例上赋值来配置:"

#: ../../library/unittest.rst:2004
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr "给出将被解读为测试方法的方法名称的前缀的字符串。 默认值为 ``'test'``。"

#: ../../library/unittest.rst:2007
msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` "
"methods."
msgstr "这会影响 :meth:`getTestCaseNames` 以及所有 ``loadTestsFrom*`` 方法。"

#: ../../library/unittest.rst:2013
msgid ""
"Function to be used to compare method names when sorting them in "
":meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"将被用来在 :meth:`getTestCaseNames` 以及所有 ``loadTestsFrom*`` 方法中比较方法名称以便对它们进行排序。"

#: ../../library/unittest.rst:2019
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the "
":class:`TestSuite` class."
msgstr "根据一个测试列表来构造测试套件的可调用对象。 不需要结果对象上的任何方法。 默认值为 :class:`TestSuite` 类。"

#: ../../library/unittest.rst:2023 ../../library/unittest.rst:2036
msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr "这会影响所有 ``loadTestsFrom*`` 方法。"

#: ../../library/unittest.rst:2027
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr "由 Unix shell 风格通配符的测试名称模式组成的列表，供测试方法进行匹配以包括在测试套件中 （参见 ``-k`` 选项）。"

#: ../../library/unittest.rst:2030
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"如果该属性不为 ``None`` (默认值)，则将要包括在测试套件中的所有测试方法都必须匹配该列表中的某个模式。 请注意匹配总是使用 "
":meth:`fnmatch.fnmatchcase`，因此不同于传给 ``-k`` 选项的模式，简单的子字符串模式将必须使用 ``*`` "
"通配符来进行转换。"

#: ../../library/unittest.rst:2043
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr "这个类被用于编译有关哪些测试执行成功而哪些失败的信息。"

#: ../../library/unittest.rst:2046
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The "
":class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"存放一组测试的结果的 :class:`TestResult` 对象。 :class:`TestCase` 和 :class:`TestSuite` "
"类将确保结果被正确地记录；测试创建者无须担心如何记录测试的结果。"

#: ../../library/unittest.rst:2051
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the "
":class:`TestResult` object generated by running a set of tests for reporting"
" purposes; a :class:`TestResult` instance is returned by the "
":meth:`TestRunner.run` method for this purpose."
msgstr ""
"建立在 :mod:`unittest` 之上的测试框架可能会想要访问通过运行一组测试所产生的 :class:`TestResult` "
"对象用来报告信息；:meth:`TestRunner.run` 方法是出于这个目的而返回 :class:`TestResult` 实例的。"

#: ../../library/unittest.rst:2056
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ":class:`TestResult` 实例具有下列属性，在检查运行一组测试的结果的时候很有用处。"

#: ../../library/unittest.rst:2062
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"一个包含 :class:`TestCase` 实例和保存了格式化回溯信息的字符串 2 元组的列表。 每个元组代表一个引发了非预期的异常的测试。"

#: ../../library/unittest.rst:2068
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-"
"methods>`."
msgstr ""
"一个包含 :class:`TestCase` 实例和保存了格式化回溯信息的字符串的 2 元组的列表。 每个元素代表一个使用 "
":ref:`assert\\* 方法 <assert-methods>` 显式地发出失败信号的测试。"

#: ../../library/unittest.rst:2074
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr "一个包含 2-tuples of :class:`TestCase` 实例和保存了跳过测试原因的字符串 2 元组的列表。"

#: ../../library/unittest.rst:2081
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"一个包含 :class:`TestCase` 实例和保存了格式化回溯信息的 2 元组的列表。 每个元组代表测试用例的一个已预期的失败或错误。"

#: ../../library/unittest.rst:2087
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr "一个包含被标记为已预期失败，但却测试成功的 :class:`TestCase` 实例的列表。"

#: ../../library/unittest.rst:2092
msgid ""
"A list containing 2-tuples of test case names and floats representing the "
"elapsed time of each test which was run."
msgstr "一个包含测试用例名称和代表所运行的每个测试所用时间的浮点数 2 元组的列表。"

#: ../../library/unittest.rst:2099
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "当测试的执行应当被 :meth:`stop` 停止时则设为 ``True``。"

#: ../../library/unittest.rst:2103
msgid "The total number of tests run so far."
msgstr "目前已运行的测试的总数量。"

#: ../../library/unittest.rst:2107
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"如果设为真值，``sys.stdout`` 和 ``sys.stderr`` 将在 :meth:`startTest` 和 "
":meth:`stopTest` 被调用之间被缓冲。 被收集的输出将仅在测试失败或发生错误时才会被回显到真正的 ``sys.stdout`` 和 "
"``sys.stderr``。 任何输出还会被附加到失败/错误消息中。"

#: ../../library/unittest.rst:2116
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr "如果设为真值则 :meth:`stop` 将在首次失败或错误时被调用，停止测试运行。"

#: ../../library/unittest.rst:2123
msgid "If set to true then local variables will be shown in tracebacks."
msgstr "如果设为真值则局部变量将被显示在回溯信息中。"

#: ../../library/unittest.rst:2129
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr "如果当前所有测试都已通过则返回 ``True``，否则返回 ``False``。"

#: ../../library/unittest.rst:2132
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"如果有任何来自测试的 :attr:`unexpectedSuccesses` 被 :func:`expectedFailure` 装饰器所标记则返回 "
"``False``。"

#: ../../library/unittest.rst:2138
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. "
":class:`TestRunner` objects should respect this flag and return without "
"running any additional tests."
msgstr ""
"此方法可被调用以提示正在运行的测试集要将 :attr:`shouldStop` 属性设为 ``True`` 来表示其应当被中止。 "
":class:`TestRunner` 对象应当认同此旗标并返回而不再运行任何额外的测试。"

#: ../../library/unittest.rst:2143
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"例如，该特性会被 :class:`TextTestRunner` 类用来在当用户从键盘发出一个中断信号时停止测试框架。 提供了 "
":class:`TestRunner` 实现的交互式工具也可通过类似方式来使用该特性。"

#: ../../library/unittest.rst:2148
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
":class:`TestResult` 类的下列方法被用于维护内部数据结构，并可在子类中被扩展以支持额外的报告需求。 "
"这特别适用于构建支持在运行测试时提供交互式报告的工具。"

#: ../../library/unittest.rst:2156
msgid "Called when the test case *test* is about to be run."
msgstr "当测试用例 *test* 即将运行时被调用。"

#: ../../library/unittest.rst:2160
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "在测试用例 *test* 已经执行后被调用，无论其结果如何。"

#: ../../library/unittest.rst:2165
msgid "Called once before any tests are executed."
msgstr "在任何测试被执行之前被调用一次。"

#: ../../library/unittest.rst:2172
msgid "Called once after all tests are executed."
msgstr "在所有测试被执行之后被调用一次。"

#: ../../library/unittest.rst:2179
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"当测试用例 *test* 引发了非预期的异常时将被调用。 *err* 是一个元组，其形式与 :func:`sys.exc_info` 的返回值相同: "
"``(type, value, traceback)``。"

#: ../../library/unittest.rst:2183
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"默认实现会将一个元组 ``(test, formatted_err)`` 添加到实例的 :attr:`errors` 属性，其中 "
"*formatted_err* 是派生自 *err* 的已格式化回溯信息。"

#: ../../library/unittest.rst:2190
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"当测试用例 *test* 发出了失败信号时将被调用。 *err* 是一个元组，其形式与 :func:`sys.exc_info` 的返回值相同: "
"``(type, value, traceback)``。"

#: ../../library/unittest.rst:2193
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"默认实现会将一个元组 ``(test, formatted_err)`` 添加到实例的 :attr:`failures` 属性，其中 "
"*formatted_err* 是派生自 *err* 的已格式化回溯信息。"

#: ../../library/unittest.rst:2200
msgid "Called when the test case *test* succeeds."
msgstr "当测试用例 *test* 成功时被调用。"

#: ../../library/unittest.rst:2202
msgid "The default implementation does nothing."
msgstr "默认实现将不做任何操作。"

#: ../../library/unittest.rst:2207
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr "当测试用例 *test* 被跳过时将被调用。 *reason* 是给出的跳过测试的理由。"

#: ../../library/unittest.rst:2210
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr "默认实现会将一个元组 ``(test, reason)`` 添加到实例的 :attr:`skipped` 属性。"

#: ../../library/unittest.rst:2216
msgid ""
"Called when the test case *test* fails or errors, but was marked with the "
":func:`expectedFailure` decorator."
msgstr "当测试用例 *test* 失败或发生错误，但是使用了 :func:`expectedFailure` 装饰器来标记时将被调用。"

#: ../../library/unittest.rst:2219
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"默认实现会将一个元组 ``(test, formatted_err)`` 添加到实例的 :attr:`expectedFailures` 属性，其中 "
"*formatted_err* 是派生自 *err* 的已格式化回溯信息。"

#: ../../library/unittest.rst:2226
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure`"
" decorator, but succeeded."
msgstr ""
"当测试用例 *test* 使用了was marked with the :func:`expectedFailure` "
"装饰器来标记，但是却执行成功时将被调用。"

#: ../../library/unittest.rst:2229
msgid ""
"The default implementation appends the test to the instance's "
":attr:`unexpectedSuccesses` attribute."
msgstr "默认实现会将该测试添加到实例的 :attr:`unexpectedSuccesses` 属性。"

#: ../../library/unittest.rst:2235
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"当一个子测试结束时将被调用。 *test* 是对应于该测试方法的测试用例。 *subtest* 是一个描述该子测试的 :class:`TestCase`"
" 实例。"

#: ../../library/unittest.rst:2239
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by "
":func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"如果 *outcome* 为 :const:`None`，则该子测试执行成功。 否则，它将失败并引发一个异常，*outcome* 是一个元组，其形式与 "
":func:`sys.exc_info` 的返回值相同: ``(type, value, traceback)``。"

#: ../../library/unittest.rst:2243
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr "默认实现在测试结果为成功时将不做任何事，并会将子测试的失败记录为普通的失败。"

#: ../../library/unittest.rst:2250
msgid ""
"Called when the test case finishes.  *elapsed* is the time represented in "
"seconds, and it includes the execution of cleanup functions."
msgstr "在测试用例结束时被调用。 *elapsed* 是以秒数表示的时间，并且它包括执行清理函数的时间。"

#: ../../library/unittest.rst:2257
msgid ""
"A concrete implementation of :class:`TestResult` used by the "
":class:`TextTestRunner`. Subclasses should accept ``**kwargs`` to ensure "
"compatibility as the interface changes."
msgstr ""
"供 :class:`TextTestRunner` 使用的 :class:`TestResult` 的具体实现。 子类应当接受 ``**kwargs``"
" 以确保在接口改变时的兼容性。"

#: ../../library/unittest.rst:2263
msgid "Added the *durations* keyword parameter."
msgstr "增加了 *durations* 关键字形参。"

#: ../../library/unittest.rst:2268
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"用于分享的 :class:`TestLoader` 类实例。 如果不需要自制 "
":class:`TestLoader`，则可以使用该实例而不必重复创建新的实例。"

#: ../../library/unittest.rst:2277
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"一个将结果输出到流的基本测试运行器。 如果 *stream* 为默认的 ``None``，则会使用 :data:`sys.stderr` 作为输出流。 "
"这个类具有一些配置形参，但实际上都非常简单。 运行测试套件的图形化应用程序应当提供替代实现。 这样的实现应当在添加新特性到 unittest 时接受 "
"``**kwargs`` 作为修改构造运行器的接口。"

#: ../../library/unittest.rst:2284
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, "
":exc:`PendingDeprecationWarning`, :exc:`ResourceWarning` and "
":exc:`ImportWarning` even if they are :ref:`ignored by default <warning-"
"ignored>`.  This behavior can be overridden using Python's :option:`!-Wd` or"
" :option:`!-Wa` options (see :ref:`Warning control <using-on-warnings>`) and"
" leaving *warnings* to ``None``."
msgstr ""
"在默认情况下该运行器将显示 :exc:`DeprecationWarning`, :exc:`PendingDeprecationWarning`, "
":exc:`ResourceWarning` 和 :exc:`ImportWarning` 即使它们 :ref:`默认会被忽略 <warning-"
"ignored>`。 此行为可使用 Python 的 :option:`!-Wd` 或 :option:`!-Wa` 选项 并将 *warnings* "
"保持为 ``None`` 来覆盖 (参见 :ref:`警告控制 <using-on-warnings>`)。"

#: ../../library/unittest.rst:2292
msgid "Added the *warnings* parameter."
msgstr "增加了 *warnings* 形参。"

#: ../../library/unittest.rst:2295
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather"
" than import time."
msgstr "默认流会在实例化而不是在导入时被设为 :data:`sys.stderr`。"

#: ../../library/unittest.rst:2299
msgid "Added the *tb_locals* parameter."
msgstr "增加了 *tb_locals* 形参。"

#: ../../library/unittest.rst:2302
msgid "Added the *durations* parameter."
msgstr "增加了 *durations* 形参。"

#: ../../library/unittest.rst:2307
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"此方法将返回由 :meth:`run` 使用的 ``TestResult`` 实例。 它不应当被直接调用，但可在子类中被重载以提供自定义的 "
"``TestResult``。"

#: ../../library/unittest.rst:2311
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` 会实例化传给 ``TextTestRunner`` 构造器的 ``resultclass`` "
"参数所指定的类或可迭代对象。 如果没有提供 ``resultclass`` 则默认为 :class:`TextTestResult`。 "
"结果类会使用以下参数来实例化::"

#: ../../library/unittest.rst:2316
msgid "stream, descriptions, verbosity"
msgstr "stream, descriptions, verbosity"

#: ../../library/unittest.rst:2320
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A "
":class:`TestResult` is created by calling :func:`_makeResult` and the "
"test(s) are run and the results printed to stdout."
msgstr ""
"此方法是 ``TextTestRunner`` 的主要公共接口。 此方法接受一个 :class:`TestSuite` 或 "
":class:`TestCase` 实例。 通过调用 :func:`_makeResult` 创建 :class:`TestResult` "
"来运行测试并将结果打印到标准输出。"

#: ../../library/unittest.rst:2331
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The"
" simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"从 *module* 加载一组测试并运行它们的命令行程序；这主要是为了让测试模块能方便地执行。 此函数的最简单用法是在测试脚本末尾包括下列行::"

#: ../../library/unittest.rst:2336
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main()"

#: ../../library/unittest.rst:2339
msgid ""
"You can run tests with more detailed information by passing in the verbosity"
" argument::"
msgstr "你可以通过传入冗余参数运行测试以获得更详细的信息::"

#: ../../library/unittest.rst:2342
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"

#: ../../library/unittest.rst:2345
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If"
" not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"*defaultTest* 参数是要运行的单个测试名称，或者如果未通过 *argv* 指定任何测试名称则是包含多个测试名称的可迭代对象。 如果未指定或为"
" ``None`` 且未通过 *argv* 指定任何测试名称，则会运行在 *module* 中找到的所有测试。"

#: ../../library/unittest.rst:2350
msgid ""
"The *argv* argument can be a list of options passed to the program, with the"
" first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"*argv* 参数可以是传给程序的选项列表，其中第一个元素是程序名。 如未指定或为 ``None``，则会使用 :data:`sys.argv` 的值。"

#: ../../library/unittest.rst:2354
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success (0) or failure (1) of the tests run. An exit "
"code of 5 indicates that no tests were run or skipped."
msgstr ""
"*testRunner* 参数可以是一个测试运行器类或是其已创建的实例。 在默认情况下 ``main`` 会调用 :func:`sys.exit` "
"并附带一个退出码来指明测试运行是成功 (0) 还是失败 (1)。 退出码为 5 表示没有运行或跳过任何测试。"

#: ../../library/unittest.rst:2359
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"*testLoader* 参数必须是一个 :class:`TestLoader` 实例，其默认值为 :data:`defaultTestLoader`。"

#: ../../library/unittest.rst:2362
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` 支持通过传入 ``exit=False`` 参数以便在交互式解释器中使用。 这将在标准输出中显示结果而不调用 "
":func:`sys.exit`::"

#: ../../library/unittest.rst:2366
msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"

#: ../../library/unittest.rst:2369
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as"
" the same-name `command-line options`_."
msgstr ""
"*failfast*, *catchbreak* 和 *buffer* 形参的效果与同名的 `command-line options`_ 一致。"

#: ../../library/unittest.rst:2372
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>`"
" that should be used while running the tests.  If it's not specified, it "
"will remain ``None`` if a :option:`!-W` option is passed to "
":program:`python` (see :ref:`Warning control <using-on-warnings>`), "
"otherwise it will be set to ``'default'``."
msgstr ""
"*warnings* 参数指定在运行测试时所应使用的 :ref:`警告过滤器 <warning-filter>`。 如果未指定，则默认的 "
"``None`` 会在将 :option:`!-W` 选项传给 :program:`python` 命令时被保留 (参见 :ref:`警告控制 "
"<using-on-warnings>`)，而在其他情况下将被设为 ``'default'``。"

#: ../../library/unittest.rst:2378
msgid ""
"Calling ``main`` returns an object with the ``result`` attribute that "
"contains the result of the tests run as a :class:`unittest.TestResult`."
msgstr ""
"调用 ``main`` 将返回一个带有 ``result`` 属性的对象，该属性包含 :class:`unittest.TestResult` "
"形式的测试运行结果。"

#: ../../library/unittest.rst:2381
msgid "The *exit* parameter was added."
msgstr "增加了 *exit* 形参。"

#: ../../library/unittest.rst:2384
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr "增加了 *verbosity*, *failfast*, *catchbreak*, *buffer* 和 *warnings* 形参。"

#: ../../library/unittest.rst:2388
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr "*defaultTest* 形参被修改为也接受一个由测试名称组成的迭代器。"

#: ../../library/unittest.rst:2396
msgid "load_tests Protocol"
msgstr "load_tests 协议"

#: ../../library/unittest.rst:2400
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr "模块或包可以通过实现一个名为 ``load_tests`` 的函数来定制在正常测试运行或测试发现期间要如何从中加载测试。"

#: ../../library/unittest.rst:2403
msgid ""
"If a test module defines ``load_tests`` it will be called by "
":meth:`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"如果一个测试模块定义了 ``load_tests`` 则它将被 :meth:`TestLoader.loadTestsFromModule` "
"调用并传入下列参数::"

#: ../../library/unittest.rst:2406 ../../library/unittest.rst:2438
msgid "load_tests(loader, standard_tests, pattern)"
msgstr "load_tests(loader, standard_tests, pattern)"

#: ../../library/unittest.rst:2408
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It"
" defaults to ``None``."
msgstr "其中 *pattern* 会通过 ``loadTestsFromModule`` 传入。 它的默认值为 ``None``。"

#: ../../library/unittest.rst:2411
msgid "It should return a :class:`TestSuite`."
msgstr "它应当返回一个 :class:`TestSuite`。"

#: ../../library/unittest.rst:2413
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* 是执行载入操作的 :class:`TestLoader` 实例。 *standard_tests* 是默认要从该模块载入的测试。 "
"测试模块通常只需从标准测试集中添加或移除测试。 第三个参数是在作为测试发现的一部分载入包时使用的。"

#: ../../library/unittest.rst:2419
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of "
":class:`TestCase` classes may look like::"
msgstr "一个从指定 :class:`TestCase` 类集合中载入测试的 ``load_tests`` 函数看起来可能是这样的::"

#: ../../library/unittest.rst:2422
msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"

#: ../../library/unittest.rst:2431
msgid ""
"If discovery is started in a directory containing a package, either from the"
" command line or by calling :meth:`TestLoader.discover`, then the package "
":file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be"
" left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"如果发现操作是在一个包含包的目录中开始的，不论是通过命令行还是通过调用 :meth:`TestLoader.discover`，则将在包 "
":file:`__init__.py` 中检查 ``load_tests``。 如果不存在此函数，则发现将在包内部执行递归，就像它是另一个目录一样。 "
"在其他情况下，包中测试的发现操作将留给 ``load_tests`` 执行，它将附带下列参数被调用::"

#: ../../library/unittest.rst:2440
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from "
":file:`__init__.py`.)"
msgstr ""
"这应当返回代表包中所有测试的 :class:`TestSuite`。 (``standard_tests`` 将只包含从 "
":file:`__init__.py` 获取的测试。)"

#: ../../library/unittest.rst:2444
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"因为模式已被传入 ``load_tests`` 所以包可以自由地继续（还可能修改）测试发现操作。 针对一个测试包的 '无操作' "
"``load_tests`` 函数看起来是这样的::"

#: ../../library/unittest.rst:2448
msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # 在加载器实例上缓存的最高层级目录\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"

#: ../../library/unittest.rst:2455
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr "发现操作不会再检查包名称是否匹配 *pattern*，因为包名称不可能匹配默认的模式。"

#: ../../library/unittest.rst:2462
msgid "Class and Module Fixtures"
msgstr "类与模块设定"

#: ../../library/unittest.rst:2464
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass`"
" from the previous class (if there is one) is called, followed by "
":meth:`setUpClass` from the new class."
msgstr ""
"类与模块设定是在 :class:`TestSuite` 中实现的。 当测试套件遇到来自新类的测试时则来自之前的类（如果存在）的 "
":meth:`tearDownClass` 会被调用，然后再调用来自新类的 :meth:`setUpClass`。"

#: ../../library/unittest.rst:2469
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"类似地如果测试是来自之前的测试的另一个模块则来自之前模块的 ``tearDownModule`` 将被运行，然后再运行来自新模块的 "
"``setUpModule``。"

#: ../../library/unittest.rst:2473
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr "在所有测试运行完毕后最终的 ``tearDownClass`` 和 ``tearDownModule`` 将被运行。"

#: ../../library/unittest.rst:2476
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with"
" care."
msgstr "请注意共享设定不适用于一些 [潜在的] 特性例如测试并行化并且它们会破坏测试隔离。 它们应当被谨慎地使用。"

#: ../../library/unittest.rst:2479
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"由 unittest 测试加载器创建的测试的默认顺序是将所有来自相同模块和类的测试归入相同分组。 这将导致 ``setUpClass`` / "
"``setUpModule`` (等) 对于每个类和模块都恰好被调用一次。 "
"如果你将顺序随机化，以便使得来自不同模块和类的测试彼此相邻，那么这些共享的设定函数就可能会在一次测试运行中被多次调用。"

#: ../../library/unittest.rst:2486
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to"
" support shared fixtures."
msgstr "共享的设定不适用与非标准顺序的套件。 对于不想支持共享设定的框架来说 ``BaseTestSuite`` 仍然可用。"

#: ../../library/unittest.rst:2490
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"如果在共享的设定函数中引发了任何异常则测试将被报告错误。 因为没有对应的测试实例，所以会创建一个 ``_ErrorHolder`` 对象（它具有与 "
":class:`TestCase` 相同的接口）来代表该错误。 如果你只是使用标准 unittest "
"测试运行器那么这个细节并不重要，但是如果你是一个框架开发者那么这可能会有关系。"

#: ../../library/unittest.rst:2499
msgid "setUpClass and tearDownClass"
msgstr "setUpClass 和 tearDownClass"

#: ../../library/unittest.rst:2501
msgid "These must be implemented as class methods::"
msgstr "这些必须被实现为类方法::"

#: ../../library/unittest.rst:2503
msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"

#: ../../library/unittest.rst:2514
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in "
":class:`TestCase` are empty."
msgstr ""
"如果你希望在基类上的 ``setUpClass`` 和 ``tearDownClass`` 被调用则你必须自己去调用它们。 在 "
":class:`TestCase` 中的实现是空的。"

#: ../../library/unittest.rst:2518
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will"
" not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a "
":exc:`SkipTest` exception then the class will be reported as having been "
"skipped instead of as an error."
msgstr ""
"如果在 ``setUpClass`` 中引发了异常则类中的测试将不会被运行并且 ``tearDownClass`` 也不会被运行。 跳过的类中的 "
"``setUpClass`` 或 ``tearDownClass`` 将不会被运行。 如果引发的异常是 :exc:`SkipTest` "
"异常则类将被报告为已跳过而非发生错误。"

#: ../../library/unittest.rst:2526
msgid "setUpModule and tearDownModule"
msgstr "setUpModule 和 tearDownModule"

#: ../../library/unittest.rst:2528
msgid "These should be implemented as functions::"
msgstr "这些应当被实现为函数::"

#: ../../library/unittest.rst:2530
msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"

#: ../../library/unittest.rst:2536
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the"
" module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as"
" having been skipped instead of as an error."
msgstr ""
"如果在 ``setUpModule`` 中引发了异常则模块中的任何测试都将不会被运行并且 ``tearDownModule`` 也不会被运行。 "
"如果引发的异常是 :exc:`SkipTest` 异常则模块将被报告为已跳过而非发生错误。"

#: ../../library/unittest.rst:2541
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr "要添加即使在发生异常时也必须运行的清理代码，请使用 ``addModuleCleanup``:"

#: ../../library/unittest.rst:2547
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into "
":meth:`addModuleCleanup` when they are added."
msgstr ""
"在 :func:`tearDownModule` 之后添加一个要调用的函数来清理测试类运行期间所使用的资源。 函数将按它们被添加的相反顺序被调用 "
"(:abbr:`LIFO (last-in, first-out)`)。 它们在调用时将附带它们被添加时传给 "
":meth:`addModuleCleanup` 的任何参数和关键字参数。"

#: ../../library/unittest.rst:2553
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"如果 :meth:`setUpModule` 失败，即意味着 :func:`tearDownModule` 未被调用，则已添加的任何清理函数仍将被调用。"

#: ../../library/unittest.rst:2561
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by "
":func:`addModuleCleanup` and return the result of the "
":meth:`~object.__enter__` method."
msgstr ""
"进入所提供的 :term:`context manager`。 如果成功，还会将其 :meth:`~object.__exit__` 方法作为使用 "
":func:`addModuleCleanup` 的清理函数并返回 :meth:`~object.__enter__` 方法的结果。"

#: ../../library/unittest.rst:2571
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"此函数会在 :func:`tearDownModule` 之后无条件地被调用，或者如果 :func:`setUpModule` 引发了异常则会在 "
":func:`setUpModule` 之后被调用。"

#: ../../library/unittest.rst:2574
msgid ""
"It is responsible for calling all the cleanup functions added by "
":func:`addModuleCleanup`. If you need cleanup functions to be called *prior*"
" to :func:`tearDownModule` then you can call :func:`doModuleCleanups` "
"yourself."
msgstr ""
"它将负责调用由It is responsible for calling all the cleanup functions added by "
":func:`addModuleCleanup` 添加的所有清理函数。 如果你需要在 :func:`tearDownModule` *之前* "
"调用清理函数则可以自行调用 :func:`doModuleCleanups`。"

#: ../../library/unittest.rst:2579
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one"
" at a time, so it can be called at any time."
msgstr ":func:`doModuleCleanups` 每次会弹出清理函数栈中的一个方法，因此它可以在任何时候被调用。"

#: ../../library/unittest.rst:2586
msgid "Signal Handling"
msgstr "信号处理"

#: ../../library/unittest.rst:2590
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"用于 unittest 的 :option:`-c/--catch <unittest -c>` 命令行选项，加上传给 "
":func:`unittest.main` 的 ``catchbreak`` 形参，提供了在测试运行期间处理 Ctrl-C 的更友好方式。 "
"在捕获中断行为被启用时 Ctrl-C 将允许当前运行的测试能够完成，而测试运行将随后结束并报告已有的全部结果。 第二个 Ctrl-C 将会正常地引发 "
":exc:`KeyboardInterrupt`。"

#: ../../library/unittest.rst:2597
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed "
":const:`signal.SIGINT` handler, i.e. it has been replaced by the system "
"under test and delegated to, then it calls the default handler. This will "
"normally be the expected behavior by code that replaces an installed handler"
" and delegates to it. For individual tests that need ``unittest`` control-c "
"handling disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"处理 control-C 信号的处理器会尝试与安装了自定义 :const:`signal.SIGINT` 处理器的测试代码保持兼容。 如果是 "
"``unittest`` 处理器而 *不是* 已安装的 :const:`signal.SIGINT` "
"处理器被调用，即它被系统在测试的下层替换并委托处理，则它会调用默认的处理器。 这通常会是替换了已安装处理器并委托处理的代码所预期的行为。 对于需要禁用 "
"``unittest`` control-C 处理的单个测试则可以使用 :func:`removeHandler` 装饰器。"

#: ../../library/unittest.rst:2606
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr "还有一些工具函数让框架开发者可以在测试框架内部启用 control-C 处理功能。"

#: ../../library/unittest.rst:2611
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"安装 control-C 处理器。 当接收到 :const:`signal.SIGINT` 时（通常是响应用户按下 "
"control-C）所有已注册的结果都会执行 :meth:`~TestResult.stop` 调用。"

#: ../../library/unittest.rst:2618
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"注册一个 :class:`TestResult` 对象用于 control-C 的处理。 "
"注册一个结果将保存指向它的弱引用，因此这并不能防止结果被作为垃圾回收。"

#: ../../library/unittest.rst:2622
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all"
" results they create independently of whether or not handling is enabled."
msgstr ""
"如果 control-C 未被启用则注册 :class:`TestResult` "
"对象将没有任何附带影响，因此不论是否启用了该项处理测试框架都可以无条件地注册他们独立创建的所有结果。"

#: ../../library/unittest.rst:2629
msgid ""
"Remove a registered result. Once a result has been removed then "
":meth:`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"移除一个已注册的结果。 一旦结果被移除则 :meth:`~TestResult.stop` 将不再会作为针对 control-C "
"的响应在结果对象上被调用。"

#: ../../library/unittest.rst:2636
msgid ""
"When called without arguments this function removes the control-c handler if"
" it has been installed. This function can also be used as a test decorator "
"to temporarily remove the handler while the test is being executed::"
msgstr ""
"当不附带任何参数被调用时此函数将移除已被安装的 control-C 处理器。 此函数还可被用作测试装饰器以在测试被执行时临时性地移除处理器::"

#: ../../library/unittest.rst:2640
msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
