# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Zombie110year <zombie110year@gmail.com>, 2019
# Menghua Xiao <arieshout@gmail.com>, 2019
# walkinrain <walkinrain2008@outlook.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:02+0000\n"
"PO-Revision-Date: 2019-09-01 03:28+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/shelve.rst:2
msgid ":mod:`shelve` --- Python object persistence"
msgstr ":mod:`shelve` --- Python 对象持久化"

#: ../../library/shelve.rst:7
msgid "**Source code:** :source:`Lib/shelve.py`"
msgstr "**源代码:** :source:`Lib/shelve.py`"

#: ../../library/shelve.rst:13
msgid ""
"A \"shelf\" is a persistent, dictionary-like object.  The difference with "
"\"dbm\" databases is that the values (not the keys!) in a shelf can be "
"essentially arbitrary Python objects --- anything that the :mod:`pickle` "
"module can handle. This includes most class instances, recursive data types,"
" and objects containing lots of shared  sub-objects.  The keys are ordinary "
"strings."
msgstr ""
"\"shelf\" 是一种持久化的类似字典的对象。 与 \"dbm\" 数据库的区别在于 shelf 中的值（不是键！）实际上可以为任意 Python "
"对象 --- 即 :mod:`pickle` 模块能够处理的任何东西。 这包括大部分类实例、递归数据类型，以及包含大量共享子对象的对象。 "
"键则为普通的字符串。"

#: ../../library/shelve.rst:22
msgid ""
"Open a persistent dictionary.  The filename specified is the base filename "
"for the underlying database.  As a side-effect, an extension may be added to"
" the filename and more than one file may be created.  By default, the "
"underlying database file is opened for reading and writing.  The optional "
"*flag* parameter has the same interpretation as the *flag* parameter of "
":func:`dbm.open`."
msgstr ""
"打开一个持久化字典。 filename 指定下层数据库的基准文件名。 作为附带效果，会为 filename 添加一个扩展名并且可能创建更多的文件。 "
"默认情况下，下层数据库会以读写模式打开。 可选的 *flag* 形参具有与 :func:`dbm.open` *flag* 形参相同的含义。"

#: ../../library/shelve.rst:28
msgid ""
"By default, version 3 pickles are used to serialize values.  The version of "
"the pickle protocol can be specified with the *protocol* parameter."
msgstr "默认会使用第 3 版 pickle 协议来序列化值。  pickle 协议版本可通过 *protocol* 形参来指定。"

#: ../../library/shelve.rst:31
msgid ""
"Because of Python semantics, a shelf cannot know when a mutable persistent-"
"dictionary entry is modified.  By default modified objects are written "
"*only* when assigned to the shelf (see :ref:`shelve-example`).  If the "
"optional *writeback* parameter is set to ``True``, all entries accessed are "
"also cached in memory, and written back on :meth:`~Shelf.sync` and "
":meth:`~Shelf.close`; this can make it handier to mutate mutable entries in "
"the persistent dictionary, but, if many entries are accessed, it can consume"
" vast amounts of memory for the cache, and it can make the close operation "
"very slow since all accessed entries are written back (there is no way to "
"determine which accessed entries are mutable, nor which ones were actually "
"mutated)."
msgstr ""
"由于 Python 语义的限制，shelf 无法确定一个可变的持久化字典条目在何时被修改。 默认情况下 *只有* 在被修改对象再赋值给 shelf "
"时才会写入该对象 (参见 :ref:`shelve-example`)。 如果可选的 *writeback* 形参设为 "
"``True``，则所有被访问的条目都将在内存中被缓存，并会在 :meth:`~Shelf.sync` 和 :meth:`~Shelf.close` "
"时被写入；这可以使得对持久化字典中可变条目的修改更方便，但是如果访问的条目很多，这会消耗大量内存作为缓存，并会使得关闭操作变得非常缓慢，因为所有被访问的条目都需要写回到字典（无法确定被访问的条目中哪个是可变的，也无法确定哪个被实际修改了）。"

#: ../../library/shelve.rst:45
msgid ""
"Do not rely on the shelf being closed automatically; always call "
":meth:`~Shelf.close` explicitly when you don't need it any more, or use "
":func:`shelve.open` as a context manager::"
msgstr ""
"请不要依赖于 shelf 的自动关闭功能；当你不再需要时应当总是显式地调用 :meth:`~Shelf.close`，或者使用 "
":func:`shelve.open` 作为上下文管理器::"

#: ../../library/shelve.rst:54
msgid ""
"Because the :mod:`shelve` module is backed by :mod:`pickle`, it is insecure "
"to load a shelf from an untrusted source.  Like with pickle, loading a shelf"
" can execute arbitrary code."
msgstr ""
"由于 :mod:`shelve` 模块需要 :mod:`pickle` 的支持，因此从不可靠的来源载入 shelf 是不安全的。 与 pickle "
"一样，载入 shelf 时可以执行任意代码。"

#: ../../library/shelve.rst:58
msgid ""
"Shelf objects support all methods supported by dictionaries.  This eases the"
" transition from dictionary based scripts to those requiring persistent "
"storage."
msgstr "字典所支持的所有方法都被 shelf 对象所支持。 因此很容易将基于字典的代码转换为需要持久化存储的代码。"

#: ../../library/shelve.rst:61
msgid "Two additional methods are supported:"
msgstr "额外支持的两个方法："

#: ../../library/shelve.rst:65
msgid ""
"Write back all entries in the cache if the shelf was opened with *writeback*"
" set to :const:`True`.  Also empty the cache and synchronize the persistent "
"dictionary on disk, if feasible.  This is called automatically when the "
"shelf is closed with :meth:`close`."
msgstr ""
"如果 shelf 打开时将 *writeback* 设为 :const:`True` 则写回缓存中的所有条目。 "
"如果可行还会清空缓存并将持久化字典同步到磁盘。 此方法会在使用 :meth:`close` 关闭 shelf 时自动被调用。"

#: ../../library/shelve.rst:72
msgid ""
"Synchronize and close the persistent *dict* object.  Operations on a closed "
"shelf will fail with a :exc:`ValueError`."
msgstr "同步并关闭持久化 *dict* 对象。 对已关闭 shelf 的操作将失败并引发 :exc:`ValueError`。"

#: ../../library/shelve.rst:78
msgid ""
"`Persistent dictionary recipe "
"<https://code.activestate.com/recipes/576642/>`_ with widely supported "
"storage formats and having the speed of native dictionaries."
msgstr ""
"`持久化字典方案 "
"<https://code.activestate.com/recipes/576642/>`_，使用了广泛支持的存储格式并具有原生字典的速度。"

#: ../../library/shelve.rst:84
msgid "Restrictions"
msgstr "限制"

#: ../../library/shelve.rst:90
msgid ""
"The choice of which database package will be used (such as :mod:`dbm.ndbm` "
"or :mod:`dbm.gnu`) depends on which interface is available.  Therefore it is"
" not safe to open the database directly using :mod:`dbm`.  The database is "
"also (unfortunately) subject to the limitations of :mod:`dbm`, if it is used"
" --- this means that (the pickled representation of) the objects stored in "
"the database should be fairly small, and in rare cases key collisions may "
"cause the database to refuse updates."
msgstr ""
"可选择使用哪种数据库包 (例如 :mod:`dbm.ndbm` 或 :mod:`dbm.gnu`) 取决于支持哪种接口。 因此使用 :mod:`dbm`"
" 直接打开数据库是不安全的。 如果使用了 :mod:`dbm`，数据库同样会（不幸地）受限于它 --- "
"这意味着存储在数据库中的（封存形式的）对象尺寸应当较小，并且在少数情况下键冲突有可能导致数据库拒绝更新。"

#: ../../library/shelve.rst:98
msgid ""
"The :mod:`shelve` module does not support *concurrent* read/write access to "
"shelved objects.  (Multiple simultaneous read accesses are safe.)  When a "
"program has a shelf open for writing, no other program should have it open "
"for reading or writing.  Unix file locking can be used to solve this, but "
"this differs across Unix versions and requires knowledge about the database "
"implementation used."
msgstr ""
":mod:`shelve` 模块不支持对 shelve 对象的 *并发* 读/写访问。 （多个同时读取访问则是安全的。） 当一个程序打开一个 "
"shelve 对象来写入时，不应再有其他程序同时打开它来读取或写入。 Unix 文件锁定可被用来解决此问题，但这在不同 Unix "
"版本上会存在差异，并且需要有关所用数据库实现的细节知识。"

#: ../../library/shelve.rst:108
msgid ""
"A subclass of :class:`collections.abc.MutableMapping` which stores pickled "
"values in the *dict* object."
msgstr ":class:`collections.abc.MutableMapping` 的一个子类，它会将封存的值保存在 *dict* 对象中。"

#: ../../library/shelve.rst:111
msgid ""
"By default, version 3 pickles are used to serialize values.  The version of "
"the pickle protocol can be specified with the *protocol* parameter. See the "
":mod:`pickle` documentation for a discussion of the pickle protocols."
msgstr ""
"默认会使用第 3 版 pickle 协议来序列化值。 pickle 协议版本可通过 *protocol* 形参来指定。 请参阅 "
":mod:`pickle` 文档来查看 pickle 协议的相关讨论。"

#: ../../library/shelve.rst:115
msgid ""
"If the *writeback* parameter is ``True``, the object will hold a cache of "
"all entries accessed and write them back to the *dict* at sync and close "
"times. This allows natural operations on mutable entries, but can consume "
"much more memory and make sync and close take a long time."
msgstr ""
"如果 *writeback* 形参为 ``True``，对象将为所有访问过的条目保留缓存并在同步和关闭时将它们写回到 *dict*。 "
"这允许对可变的条目执行自然操作，但是会消耗更多内存并让同步和关闭花费更长时间。"

#: ../../library/shelve.rst:120
msgid ""
"The *keyencoding* parameter is the encoding used to encode keys before they "
"are used with the underlying dict."
msgstr "*keyencoding* 形参是在下层字典被使用之前用于编码键的编码格式。"

#: ../../library/shelve.rst:123
msgid ""
"A :class:`Shelf` object can also be used as a context manager, in which case"
" it will be automatically closed when the :keyword:`with` block ends."
msgstr ":class:`Shelf` 对象还可以被用作上下文管理器，在这种情况下它将在 :keyword:`with` 语句块结束时自动被关闭。"

#: ../../library/shelve.rst:126
msgid ""
"Added the *keyencoding* parameter; previously, keys were always encoded in "
"UTF-8."
msgstr "添加了 *keyencoding* 形参；之前，键总是使用 UTF-8 编码。"

#: ../../library/shelve.rst:130
msgid "Added context manager support."
msgstr "添加了上下文管理器支持。"

#: ../../library/shelve.rst:136
msgid ""
"A subclass of :class:`Shelf` which exposes :meth:`first`, :meth:`!next`, "
":meth:`previous`, :meth:`last` and :meth:`set_location` which are available "
"in the third-party :mod:`bsddb` module from `pybsddb "
"<https://www.jcea.es/programacion/pybsddb.htm>`_ but not in other database "
"modules.  The *dict* object passed to the constructor must support those "
"methods.  This is generally accomplished by calling one of "
":func:`bsddb.hashopen`, :func:`bsddb.btopen` or :func:`bsddb.rnopen`.  The "
"optional *protocol*, *writeback*, and *keyencoding* parameters have the same"
" interpretation as for the :class:`Shelf` class."
msgstr ""
":class:`Shelf` 的一个子类，将 :meth:`first`, :meth:`!next`, :meth:`previous`, "
":meth:`last` 和 :meth:`set_location` 对外公开，在来自 `pybsddb "
"<https://www.jcea.es/programacion/pybsddb.htm>`_ 的第三方 :mod:`bsddb` "
"模块中可用，但在其他数据库模块中不可用。 传给构造器的 *dict* 对象必须支持这些方法。 这通常是通过调用 "
":func:`bsddb.hashopen`, :func:`bsddb.btopen` 或 :func:`bsddb.rnopen` 之一来完成的。"
"  可选的 *protocol*, *writeback* 和 *keyencoding* 形参具有与 :class:`Shelf` 类相同的含义。"

#: ../../library/shelve.rst:149
msgid ""
"A subclass of :class:`Shelf` which accepts a *filename* instead of a dict-"
"like object.  The underlying file will be opened using :func:`dbm.open`.  By"
" default, the file will be created and opened for both read and write.  The "
"optional *flag* parameter has the same interpretation as for the "
":func:`.open` function.  The optional *protocol* and *writeback* parameters "
"have the same interpretation as for the :class:`Shelf` class."
msgstr ""
":class:`Shelf` 的一个子类，它接受一个 *filename* 而非字典类对象。 下层文件将使用 :func:`dbm.open` 来打开。"
" 默认情况下，文件将以读写模式打开。 可选的 *flag* 形参具有与 :func:`.open` 函数相同的含义。 可选的 *protocol* 和 "
"*writeback* 形参具有与 :class:`Shelf` 类相同的含义。"

#: ../../library/shelve.rst:160
msgid "Example"
msgstr "示例"

#: ../../library/shelve.rst:162
msgid ""
"To summarize the interface (``key`` is a string, ``data`` is an arbitrary "
"object)::"
msgstr "对接口的总结如下 (``key`` 为字符串，``data`` 为任意对象)::"

#: ../../library/shelve.rst:199
msgid "Module :mod:`dbm`"
msgstr "模块 :mod:`dbm`"

#: ../../library/shelve.rst:199
msgid "Generic interface to ``dbm``-style databases."
msgstr "``dbm`` 风格数据库的泛型接口。"

#: ../../library/shelve.rst:201
msgid "Module :mod:`pickle`"
msgstr "模块 :mod:`pickle`"

#: ../../library/shelve.rst:202
msgid "Object serialization used by :mod:`shelve`."
msgstr ":mod:`shelve` 所使用的对象序列化。"
