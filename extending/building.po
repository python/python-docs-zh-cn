# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2021
# Harry Liu. <harry.python@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Harry Liu. <harry.python@gmail.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/building.rst:7
msgid "Building C and C++ Extensions"
msgstr "构建C/C++扩展"

#: ../../extending/building.rst:9
msgid ""
"A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux,"
" ``.pyd`` on Windows), which exports an *initialization function*."
msgstr ""
"一个CPython的C扩展是一个共享库(例如一个Linux上的 ``.so`` ，或者Windows上的 ``.pyd`` )，其会导出一个 "
"*初始化函数* 。"

#: ../../extending/building.rst:12
msgid ""
"To be importable, the shared library must be available on "
":envvar:`PYTHONPATH`, and must be named after the module name, with an "
"appropriate extension. When using distutils, the correct filename is "
"generated automatically."
msgstr ""
"为了可导入，共享库必须在 :envvar:`PYTHONPATH` "
"中有效，且必须命名遵循模块名字，通过适当的扩展。当使用distutils时，会自动生成正确的文件名。"

#: ../../extending/building.rst:16
msgid "The initialization function has the signature:"
msgstr "初始化函数的声明如下："

#: ../../extending/building.rst:20
msgid ""
"It returns either a fully-initialized module, or a :c:type:`PyModuleDef` "
"instance. See :ref:`initializing-modules` for details."
msgstr ""
"该函数返回完整初始化过的模块，或一个 :c:type:`PyModuleDef` 实例。查看 :ref:`initializing-modules` "
"了解更多细节。"

#: ../../extending/building.rst:25
msgid ""
"For modules with ASCII-only names, the function must be named "
"``PyInit_<modulename>``, with ``<modulename>`` replaced by the name of the "
"module. When using :ref:`multi-phase-initialization`, non-ASCII module names"
" are allowed. In this case, the initialization function name is "
"``PyInitU_<modulename>``, with ``<modulename>`` encoded using Python's "
"*punycode* encoding with hyphens replaced by underscores. In Python::"
msgstr ""
"对于仅有ASCII编码的模块名，函数必须是 ``PyInit_<modulename>`` ，将 ``<modulename>`` "
"替换为模块的名字。当使用 :ref:`multi-phase-initialization` "
"时，允许使用非ASCII编码的模块名。此时初始化函数的名字是 ``PyInitU_<modulename>`` ，而 ``<modulename>`` "
"需要用Python的 *punycode* 编码，连字号需替换为下划线。在Python里::"

#: ../../extending/building.rst:39
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires"
" using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the *\"Multiple modules"
" in one library\"* section in :pep:`489` for details."
msgstr ""
"可以在一个动态库里导出多个模块，通过定义多个初始化函数。而导入他们需要符号链接或自定义导入器，因为缺省时只有对应了文件名的函数才会被发现。查看 "
"*\"一个库里的多模块\"* 章节，在 :pep:`489` 了解更多细节。"

#: ../../extending/building.rst:49
msgid "Building C and C++ Extensions with distutils"
msgstr "使用distutils构建C和C++扩展"

#: ../../extending/building.rst:53
msgid ""
"Extension modules can be built using distutils,  which is included in "
"Python. Since distutils also supports creation of binary packages, users "
"don't necessarily need a compiler and distutils to install the extension."
msgstr ""
"扩展模块可以用distutils来构建，这是Python自带的。distutils也支持创建二进制包，用户无需编译器而distutils就能安装扩展。"

#: ../../extending/building.rst:57
msgid ""
"A distutils package contains a driver script, :file:`setup.py`. This is a "
"plain Python file, which, in the most simple case, could look like this:"
msgstr "一个distutils包包含了一个驱动脚本 :file:`setup.py` 。这是个纯Python文件，大多数时候也很简单，看起来如下："

#: ../../extending/building.rst:73
msgid "With this :file:`setup.py`, and a file :file:`demo.c`, running ::"
msgstr "通过文件 :file:`setup.py` ，和文件 :file:`demo.c` ，运行如下 ::"

#: ../../extending/building.rst:77
msgid ""
"will compile :file:`demo.c`, and produce an extension module named ``demo`` "
"in the :file:`build` directory. Depending on the system, the module file "
"will end up in a subdirectory :file:`build/lib.system`, and may have a name "
"like :file:`demo.so` or :file:`demo.pyd`."
msgstr ""
"这会编译 :file:`demo.c` ，然后产生一个扩展模块叫做 ``demo`` 在目录 :file:`build` "
"里。依赖于系统，模块文件会放在某个子目录形如 :file:`build/lib.system` ，名字可能是 :file:`demo.so` 或 "
":file:`demo.pyd` 。"

#: ../../extending/building.rst:82
msgid ""
"In the :file:`setup.py`, all execution is performed by calling the ``setup``"
" function. This takes a variable number of keyword arguments, of which the "
"example above uses only a subset. Specifically, the example specifies meta-"
"information to build packages, and it specifies the contents of the package."
"  Normally, a package will contain additional modules, like Python source "
"modules, documentation, subpackages, etc. Please refer to the distutils "
"documentation in :ref:`distutils-index` to learn more about the features of "
"distutils; this section explains building extension modules only."
msgstr ""
"在文件 :file:`setup.py` 里，所有动作的入口通过 ``setup`` "
"函数。该函数可以接受可变数量个关键字参数，上面的例子只使用了一个子集。特别需要注意的例子指定了构建包的元信息，以及指定了包内容。通常一个包会包括多个模块，就像Python的源码模块、文档、子包等。请参数distutils的文档，在"
" :ref:`distutils-index` 来了解更多distutils的特性；本章节只解释构建扩展模块的部分。"

#: ../../extending/building.rst:91
msgid ""
"It is common to pre-compute arguments to :func:`setup`, to better structure "
"the driver script. In the example above, the ``ext_modules`` argument to "
":func:`~distutils.core.setup` is a list of extension modules, each of which "
"is an instance of the :class:`~distutils.extension.Extension`. In the "
"example, the instance defines an extension named ``demo`` which is build by "
"compiling a single source file, :file:`demo.c`."
msgstr ""
"通常预计算参数给 :func:`setup` ，想要更好的结构化驱动脚本。有如如上例子函数 :func:`~distutils.core.setup` "
"的 ``ext_modules`` 参数是一列扩展模块，每个是一个 :class:`~distutils.extension.Extension` "
"类的实例。例子中的实例定义了扩展命名为 ``demo`` ，从单一源码文件构建 :file:`demo.c` 。"

#: ../../extending/building.rst:99
msgid ""
"In many cases, building an extension is more complex, since additional "
"preprocessor defines and libraries may be needed. This is demonstrated in "
"the example below."
msgstr "更多时候，构建一个扩展会复杂的多，需要额外的预处理器定义和库。如下例子展示了这些。"

#: ../../extending/building.rst:127
msgid ""
"In this example, :func:`~distutils.core.setup` is called with additional "
"meta-information, which is recommended when distribution packages have to be"
" built. For the extension itself, it specifies preprocessor defines, include"
" directories, library directories, and libraries. Depending on the compiler,"
" distutils passes this information in different ways to the compiler. For "
"example, on Unix, this may result in the compilation commands ::"
msgstr ""
"例子中函数 :func:`~distutils.core.setup` "
"在调用时额外传递了元信息，是推荐发布包构建时的内容。对于这个扩展，其指定了预处理器定义，include目录，库目录，库。依赖于编译器，distutils还会用其他方式传递信息给编译器。例如在Unix上，结果是如下编译命令"
" ::"

#: ../../extending/building.rst:139
msgid ""
"These lines are for demonstration purposes only; distutils users should "
"trust that distutils gets the invocations right."
msgstr "这些行代码仅用于展示目的；distutils用户应该相信distutils能正确调用。"

#: ../../extending/building.rst:146
msgid "Distributing your extension modules"
msgstr "发布你的扩展模块"

#: ../../extending/building.rst:148
msgid ""
"When an extension has been successfully built, there are three ways to use "
"it."
msgstr "当一个扩展已经成功地被构建时，有三种方式来使用它。"

#: ../../extending/building.rst:150
msgid ""
"End-users will typically want to install the module, they do so by running "
"::"
msgstr "最终用户通常想要安装模块，可以这么运行 ::"

#: ../../extending/building.rst:154
msgid ""
"Module maintainers should produce source packages; to do so, they run ::"
msgstr "模块维护者应该制作源码包；要实现可以运行 ::"

#: ../../extending/building.rst:158
msgid ""
"In some cases, additional files need to be included in a source "
"distribution; this is done through a :file:`MANIFEST.in` file; see "
":ref:`manifest` for details."
msgstr ""
"有些情况下，需要在源码发布包里包含额外的文件；这通过 :file:`MANIFEST.in` 文件实现，查看 :ref:`manifest` 了解细节。"

#: ../../extending/building.rst:161
msgid ""
"If the source distribution has been built successfully, maintainers can also"
" create binary distributions. Depending on the platform, one of the "
"following commands can be used to do so. ::"
msgstr "如果源码发行包被成功地构建，维护者还可以创建二进制发行包。 取决于具体平台，以下命令中的一个可以用来完成此任务 ::"
