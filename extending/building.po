# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-30 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/building.rst:7
msgid "Building C and C++ Extensions"
msgstr "构建C/C++扩展"

#: ../../extending/building.rst:9
msgid ""
"A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux,"
" ``.pyd`` on Windows), which exports an *initialization function*."
msgstr ""
"一个CPython的C扩展是一个共享库(例如一个Linux上的 ``.so`` ，或者Windows上的 ``.pyd`` )，其会导出一个 "
"*初始化函数* 。"

#: ../../extending/building.rst:12
msgid ""
"To be importable, the shared library must be available on "
":envvar:`PYTHONPATH`, and must be named after the module name, with an "
"appropriate extension. When using setuptools, the correct filename is "
"generated automatically."
msgstr ""
"为了可导入，共享库必须在 :envvar:`PYTHONPATH` 中列出，且必须按照模块名称命名，并带有正确的扩展名。 当使用 setuptools "
"时，会自动生成正确的文件名。"

#: ../../extending/building.rst:16
msgid "The initialization function has the signature:"
msgstr "初始化函数的声明如下："

#: ../../extending/building.rst:20
msgid ""
"It returns either a fully initialized module, or a :c:type:`PyModuleDef` "
"instance. See :ref:`initializing-modules` for details."
msgstr ""
"该函数返回完整初始化过的模块，或一个 :c:type:`PyModuleDef` 实例。 请查看 :ref:`initializing-modules`"
" 了解详情。"

#: ../../extending/building.rst:25
msgid ""
"For modules with ASCII-only names, the function must be named "
":samp:`PyInit_{<name>}`, with ``<name>`` replaced by the name of the module."
" When using :ref:`multi-phase-initialization`, non-ASCII module names are "
"allowed. In this case, the initialization function name is "
":samp:`PyInitU_{<name>}`, with ``<name>`` encoded using Python's *punycode* "
"encoding with hyphens replaced by underscores. In Python::"
msgstr ""

#: ../../extending/building.rst:32
msgid ""
"def initfunc_name(name):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"
msgstr ""
"def initfunc_name(name):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"

#: ../../extending/building.rst:39
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires"
" using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the *\"Multiple modules"
" in one library\"* section in :pep:`489` for details."
msgstr ""
"可以在一个动态库里导出多个模块，通过定义多个初始化函数。而导入他们需要符号链接或自定义导入器，因为缺省时只有对应了文件名的函数才会被发现。查看 "
"*\"一个库里的多模块\"* 章节，在 :pep:`489` 了解更多细节。"

#: ../../extending/building.rst:52
msgid "Building C and C++ Extensions with setuptools"
msgstr "使用 setuptools 构建 C 和 C++ 扩展"

#: ../../extending/building.rst:54
msgid ""
"Python 3.12 and newer no longer come with distutils. Please refer to the "
"``setuptools`` documentation at "
"https://setuptools.readthedocs.io/en/latest/setuptools.html to learn more "
"about how build and distribute C/C++ extensions with setuptools."
msgstr ""
"Python 3.12 及更新的版本不再包含 distutils。 请参考 "
"https://setuptools.readthedocs.io/en/latest/setuptools.html 上的 "
"``setuptools`` 文档来更多地了解如何使用 setuptools 来构建和分发 C/C++ 扩展。"
