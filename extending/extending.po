# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 15:05+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "使用 C 或 C++ 扩展 Python"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be"
" done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"如果你会用 C，添加新的 Python 内置模块会很简单。以下两件不能用 Python 直接做的事，可以通过 :dfn:`extension "
"modules` 来实现：实现新的内置对象类型；调用 C 的库函数和系统调用。"

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most"
" aspects of the Python run-time system.  The Python API is incorporated in a"
" C source file by including the header ``\"Python.h\"``."
msgstr ""
"为了支持扩展，Python API（应用程序编程接口）定义了一系列函数、宏和变量，可以访问 Python 运行时系统的大部分内容。Python 的 "
"API 可以通过在一个 C 源文件中引用 ``\"Python.h\"`` 头文件来使用。"

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr "扩展模块的编写方式取决与你的目的以及系统设置；下面章节会详细介绍。"

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"C扩展接口特指CPython，扩展模块无法在其他Python实现上工作。在大多数情况下，应该避免写C扩展，来保持可移植性。举个例子，如果你的用例调用了C库或系统调用，你应该考虑使用"
" :mod:`ctypes` 模块或 `cffi <https://cffi.readthedocs.io/>`_ "
"库，而不是自己写C代码。这些模块允许你写Python代码来接口C代码，并且相较于编写和编译C扩展模块，该方法在不同Python实现之间具有更高的可移植性。"

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "一个简单的例子"

#: ../../extending/extending.rst:42
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty"
" Python fans...) and let's say we want to create a Python interface to the C"
" library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""
"让我们创建一个扩展模块 ``spam`` (Monty Python 粉丝最喜欢的食物...) 并且想要创建对应 C 库函数 "
":c:func:`system` [#]_ 的 Python 接口。 这个函数接受一个以 null 结尾的字符串参数并返回一个整数。 我们希望可以在 "
"Python 中以如下方式调用此函数:"

#: ../../extending/extending.rst:48
msgid ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"
msgstr ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"

#: ../../extending/extending.rst:53
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called "
":file:`spammodule.c`; if the module name is very long, like ``spammify``, "
"the module name can be just :file:`spammify.c`.)"
msgstr ""
"首先创建一个 :file:`spammodule.c` 文件。（传统上，如果一个模块叫 ``spam``，则对应实现它的 C 文件叫 "
":file:`spammodule.c`；如果这个模块名字非常长，比如 ``spammify``，则这个模块的文件可以直接叫 "
":file:`spammify.c`。）"

#: ../../extending/extending.rst:58
msgid "The first two lines of our file can be::"
msgstr "文件中开始的两行是："

#: ../../extending/extending.rst:60 ../../extending/extending.rst:706
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"

#: ../../extending/extending.rst:63
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr "这会导入 Python API（如果你喜欢，你可以在这里添加描述模块目标和版权信息的注释)。"

#: ../../extending/extending.rst:68
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr ""
"由于 Python 可能会定义一些能在某些系统上影响标准头文件的预处理器定义，因此在包含任何标准头文件之前，你 *必须* 先包含 "
":file:`Python.h`。"

#: ../../extending/extending.rst:72
msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should"
" be used in some APIs instead of ``int``. It is not necessary since Python "
"3.13, but we keep it here for backward compatibility. See :ref:`arg-parsing-"
"string-and-buffers` for a description of this macro."
msgstr ""
"``#define PY_SSIZE_T_CLEAN`` 被用来指明 ``Py_ssize_t`` 应当在某些 API 中代替 ``int`` 使用。 "
"它从 Python 3.13 起已不再需要，但我们保留它用于向下兼容。 请参阅 :ref:`arg-parsing-string-and-"
"buffers` 获取该宏的描述。"

#: ../../extending/extending.rst:77
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py``"
" or ``PY``, except those defined in standard header files."
msgstr ""

#: ../../extending/extending.rst:82
msgid ""
"For backward compatibility, :file:`Python.h` includes several standard "
"header files. C extensions should include the standard headers that they "
"use, and should not rely on these implicit includes. If using the limited C "
"API version 3.13 or newer, the implicit includes are:"
msgstr ""

#: ../../extending/extending.rst:87
msgid "``<assert.h>``"
msgstr ""

#: ../../extending/extending.rst:88
msgid "``<intrin.h>`` (on Windows)"
msgstr ""

#: ../../extending/extending.rst:89
msgid "``<inttypes.h>``"
msgstr ""

#: ../../extending/extending.rst:90
msgid "``<limits.h>``"
msgstr ""

#: ../../extending/extending.rst:91
msgid "``<math.h>``"
msgstr ""

#: ../../extending/extending.rst:92
msgid "``<stdarg.h>``"
msgstr ""

#: ../../extending/extending.rst:93
msgid "``<wchar.h>``"
msgstr ""

#: ../../extending/extending.rst:94
msgid "``<sys/types.h>`` (if present)"
msgstr ""

#: ../../extending/extending.rst:96
msgid ""
"If :c:macro:`Py_LIMITED_API` is not defined, or is set to version 3.12 or "
"older, the headers below are also included:"
msgstr ""

#: ../../extending/extending.rst:99
msgid "``<ctype.h>``"
msgstr ""

#: ../../extending/extending.rst:100
msgid "``<unistd.h>`` (on POSIX)"
msgstr ""

#: ../../extending/extending.rst:102
msgid ""
"If :c:macro:`Py_LIMITED_API` is not defined, or is set to version 3.10 or "
"older, the headers below are also included:"
msgstr ""

#: ../../extending/extending.rst:105
msgid "``<errno.h>``"
msgstr ""

#: ../../extending/extending.rst:106
msgid "``<stdio.h>``"
msgstr ""

#: ../../extending/extending.rst:107
msgid "``<stdlib.h>``"
msgstr ""

#: ../../extending/extending.rst:108
msgid "``<string.h>``"
msgstr ""

#: ../../extending/extending.rst:110
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr "下面添加C函数到扩展模块，当调用 ``spam.system(string)`` 时会做出响应，(我们稍后会看到调用)："

#: ../../extending/extending.rst:114
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:126
msgid ""
"There is a straightforward translation from the argument list in Python (for"
" example, the single expression ``\"ls -l\"``) to the arguments passed to "
"the C function.  The C function always has two arguments, conventionally "
"named *self* and *args*."
msgstr ""
"有个直接翻译参数列表的方法(举个例子，单独的 ``\"ls -l\"`` )到要传递给C函数的参数。C函数总是有两个参数，通常名字是 *self* 和 "
"*args* 。"

#: ../../extending/extending.rst:131
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr "对模块级函数， *self* 参数指向模块对象；对于方法则指向对象实例。"

#: ../../extending/extending.rst:134
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"*args* 参数是指向一个 Python 的 tuple 对象的指针，其中包含参数。 每个 tuple 项对应一个调用参数。 这些参数也全都是 "
"Python 对象 --- 要在我们的 C 函数中使用它们就需要先将其转换为 C 值。 Python API 中的函数 "
":c:func:`PyArg_ParseTuple` 会检查参数类型并将其转换为 C 值。 它使用模板字符串确定需要的参数类型以及存储被转换的值的 C "
"变量类型。 细节将稍后说明。"

#: ../../extending/extending.rst:143
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return ``NULL`` immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` "
"在所有参数都有正确类型且组成部分按顺序放在传递进来的地址里时，返回真(非零)。其在传入无效参数时返回假(零)。在后续例子里，还会抛出特定异常，使得调用的函数可以理解返回"
" ``NULL`` (也就是例子里所见)。"

#: ../../extending/extending.rst:153
msgid "Intermezzo: Errors and Exceptions"
msgstr "关于错误和异常"

#: ../../extending/extending.rst:155
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually ``-1`` or a ``NULL`` pointer).  Exception information "
"is stored in three members of the interpreter's thread state.  These are "
"``NULL`` if there is no exception.  Otherwise they are the C equivalents of "
"the members of the Python tuple returned by :meth:`sys.exc_info`.  These are"
" the exception type, exception instance, and a traceback object.  It is "
"important to know about them to understand how errors are passed around."
msgstr ""
"整个 Python 解释器系统有一个如下所述的重要惯例：当一个函数运行失败时，它应当设置一个异常条件并返回一个错误值（通常为 ``-1`` 或 "
"``NULL`` 指针）。 异常信息保存在解释器线程状态的三个成员中。 如果没有异常则它们的值为 ``NULL``。 在其他情况下它们是 "
":meth:`sys.exc_info` 所返回的 Python 元组的成员的 C 对应物。 它们分别是异常类型、异常实例和回溯对象。 "
"理解它们对于理解错误是如何被传递的非常重要。"

#: ../../extending/extending.rst:164
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr "Python API中定义了一些函数来设置这些变量。"

#: ../../extending/extending.rst:166
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"最常用的就是 :c:func:`PyErr_SetString`。 其参数是异常对象和 C 字符串。 异常对象一般是像 "
":c:data:`PyExc_ZeroDivisionError` 这样的预定义对象。 C 字符串指明异常原因，并被转换为一个 Python "
"字符串对象存储为异常的“关联值”。"

#: ../../extending/extending.rst:172
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an"
" exception argument and constructs the associated value by inspection of the"
" global variable :c:data:`errno`.  The most general function is "
":c:func:`PyErr_SetObject`, which takes two object arguments, the exception "
"and its associated value.  You don't need to :c:func:`Py_INCREF` the objects"
" passed to any of these functions."
msgstr ""
"另一个有用的函数是 :c:func:`PyErr_SetFromErrno` ，仅接受一个异常对象，异常描述包含在全局变量 "
":c:data:`errno` 中。最通用的函数还是 :c:func:`PyErr_SetObject` "
"，包含两个参数，分别为异常对象和异常描述。你不需要使用 :c:func:`Py_INCREF` 来增加传递到其他函数的参数对象的引用计数。"

#: ../../extending/extending.rst:179
msgid ""
"You can test non-destructively whether an exception has been set with "
":c:func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call "
":c:func:`PyErr_Occurred` to see whether an error occurred in a function "
"call, since you should be able to tell from the return value."
msgstr ""
"你可以通过 :c:func:`PyErr_Occurred` 在不造成破坏的情况下检测是否设置了异常。 这将返回当前异常对象，或者如果未发生异常则返回 "
"``NULL``。 你通常不需要调用 :c:func:`PyErr_Occurred` 来查看函数调用中是否发生了错误，因为你应该能从返回值中看出来。"

#: ../../extending/extending.rst:185
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually ``NULL`` or ``-1``)."
"  It should *not* call one of the ``PyErr_*`` functions --- one has already "
"been called by *g*. *f*'s caller is then supposed to also return an error "
"indication to *its* caller, again *without* calling ``PyErr_*``, and so on "
"--- the most detailed cause of the error was already reported by the "
"function that first detected it.  Once the error reaches the Python "
"interpreter's main loop, this aborts the currently executing Python code and"
" tries to find an exception handler specified by the Python programmer."
msgstr ""
"当一个函数 *f* 调用另一个函数 *g* 时检测到后者出错了，*f* 应当自己返回一个错误值 (通常为 ``NULL`` 或 ``-1``)。 它 "
"*不应* 调用某个 ``PyErr_*`` 函数 --- 这类函数已经被 *g* 调用过了。 *f* 的调用者随后也应当返回一个错误来提示 *它的* "
"调用者，同样 *不应* 调用 ``PyErr_*``，依此类推 --- 错误的最详细原因已经由首先检测到它的函数报告了。 一旦这个错误到达 Python"
" 解释器的主循环，它会中止当前执行的 Python 代码并尝试找出由 Python 程序员所指定的异常处理器。"

#: ../../extending/extending.rst:195
msgid ""
"(There are situations where a module can actually give a more detailed error"
" message by calling another ``PyErr_*`` function, and in such cases it is "
"fine to do so.  As a general rule, however, this is not necessary, and can "
"cause information about the cause of the error to be lost: most operations "
"can fail for a variety of reasons.)"
msgstr ""
"（在某些情况下模块确实能够通过调用其它 ``PyErr_*`` 函数来给出更为详细的错误消息，并且在这些情况下是可以这样做的。 "
"但是按照一般规则，这是不必要的，并可能导致有关错误的信息丢失：大多数操作会由于种种原因而失败。）"

#: ../../extending/extending.rst:201
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went "
"wrong)."
msgstr ""
"想要忽略由一个失败的函数调用所设置的异常，异常条件必须通过调用 :c:func:`PyErr_Clear` 显式地被清除。 C 代码应当调用 "
":c:func:`PyErr_Clear` 的唯一情况是如果它不想将错误传给解释器而是想完全由自己来处理它（可能是尝试其他方法，或是假装没有出错）。"

#: ../../extending/extending.rst:207
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the"
" direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call "
":c:func:`PyErr_NoMemory` and return a failure indicator itself.  All the "
"object-creating functions (for example, :c:func:`PyLong_FromLong`) already "
"do this, so this note is only relevant to those who call :c:func:`malloc` "
"directly."
msgstr ""
"每次失败的 :c:func:`malloc` 调用必须转换为一个异常。 :c:func:`malloc` (或 :c:func:`realloc` "
")的直接调用者必须调用 :c:func:`PyErr_NoMemory` 来返回错误来提示。所有对象创建函数(例如 "
":c:func:`PyLong_FromLong` )已经这么做了，所以这个提示仅用于直接调用 :c:func:`malloc` 的情况。"

#: ../../extending/extending.rst:213
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"还要注意的是，除了 :c:func:`PyArg_ParseTuple` 等重要的例外，返回整数状态码的函数通常都是返回正值或零来表示成功，而以 "
"``-1`` 表示失败，如同 Unix 系统调用一样。"

#: ../../extending/extending.rst:217
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or "
":c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"最后，当你返回一个错误指示器时要注意清理垃圾（通过为你已经创建的对象执行 :c:func:`Py_XDECREF` 或 "
":c:func:`Py_DECREF` 调用）！"

#: ../../extending/extending.rst:221
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course,"
" you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError`"
" to mean that a file couldn't be opened (that should probably be "
":c:data:`PyExc_OSError`). If something's wrong with the argument list, the "
":c:func:`PyArg_ParseTuple` function usually raises "
":c:data:`PyExc_TypeError`.  If you have an argument whose value must be in a"
" particular range or must satisfy other conditions, "
":c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"选择引发哪个异常完全取决于你的喜好。 所有 Python 内置异常都有对应的预声明 C 对象，例如 "
":c:data:`PyExc_ZeroDivisionError`，你可以直接使用它们。 当然，你应当明智地选择异常 --- 不要使用 "
":c:data:`PyExc_TypeError` 来表示文件无法打开（可能应该用 :c:data:`PyExc_OSError` 比较好）。 "
"如果参数列表有问题，:c:func:`PyArg_ParseTuple` 函数通常会引发 :c:data:`PyExc_TypeError`。 "
"如果你希望一个参数的值必须在特定范围内或必须满足其他条件，则适宜使用 :c:data:`PyExc_ValueError`。"

#: ../../extending/extending.rst:231
msgid ""
"You can also define a new exception that is unique to your module. The "
"simplest way to do this is to declare a static global object variable at the"
" beginning of the file::"
msgstr "你也可以定义你的模块独有的新异常。 做到这点的最简单方式是在文件的开头声明一个静态全局对象变量::"

#: ../../extending/extending.rst:235
msgid "static PyObject *SpamError = NULL;"
msgstr "static PyObject *SpamError = NULL;"

#: ../../extending/extending.rst:237
msgid ""
"and initialize it by calling :c:func:`PyErr_NewException` in the module's "
":c:data:`Py_mod_exec` function (:c:func:`!spam_module_exec`)::"
msgstr ""
"并通过在模块的 :c:data:`Py_mod_exec` 函数 (:c:func:`!spam_module_exec`) 中调用 "
":c:func:`PyErr_NewException` 来初始化它::"

#: ../../extending/extending.rst:240
msgid "SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);"
msgstr "SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);"

#: ../../extending/extending.rst:242
msgid ""
"Since :c:data:`!SpamError` is a global variable, it will be overwitten every"
" time the module is reinitialized, when the :c:data:`Py_mod_exec` function "
"is called."
msgstr ""
"由于 :c:data:`!SpamError` 是一个全局变量，它将在模块每次重新初始化时被覆盖，即当 :c:data:`Py_mod_exec` "
"函数被调用时。"

#: ../../extending/extending.rst:245
msgid ""
"For now, let's avoid the issue: we will block repeated initialization by "
"raising an :py:exc:`ImportError`::"
msgstr "在目前，让我们避免这个问题：我们将通过引发 :py:exc:`ImportError` 来阻止重复的初始化::"

#: ../../extending/extending.rst:248
msgid ""
"static PyObject *SpamError = NULL;\n"
"\n"
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    if (SpamError != NULL) {\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"cannot initialize spam module more than once\");\n"
"        return -1;\n"
"    }\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot spam_module_slots[] = {\n"
"    {Py_mod_exec, spam_module_exec},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    .m_size = 0,  // non-negative\n"
"    .m_slots = spam_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"static PyObject *SpamError = NULL;\n"
"\n"
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    if (SpamError != NULL) {\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"cannot initialize spam module more than once\");\n"
"        return -1;\n"
"    }\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot spam_module_slots[] = {\n"
"    {Py_mod_exec, spam_module_exec},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    .m_size = 0,  // non-negative\n"
"    .m_slots = spam_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

#: ../../extending/extending.rst:284
msgid ""
"Note that the Python name for the exception object is :exc:`!spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""
"请注意该异常对象的 Python 名称为 :exc:`!spam.error`。 :c:func:`PyErr_NewException` "
"函数可以创建基类为 :exc:`Exception` 的类 (除非传入了另一个类而不是 ``NULL``)，如 :ref:`bltin-"
"exceptions` 中所描述的。"

#: ../../extending/extending.rst:289
msgid ""
"Note also that the :c:data:`!SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the"
" class is needed to ensure that it will not be discarded, causing "
":c:data:`!SpamError` to become a dangling pointer. Should it become a "
"dangling pointer, C code which raises the exception could cause a core dump "
"or other unintended side effects."
msgstr ""
"请注意 :c:data:`!SpamError` 变量保留了一个对新创建的异常类的引用；这是有意为之的！ "
"由于异常可能会被外部代码从模块中删除，因此需要拥有一个对该类的引用以确保它不会被丢弃，从而导致 :c:data:`!SpamError` "
"成为一个悬空指针。 如果异常类成为悬空指针，则引发该异常的 C 代码可能会导致核心转储或其他预期之外的附带影响。"

#: ../../extending/extending.rst:296
msgid ""
"For now, the :c:func:`Py_DECREF` call to remove this reference is missing. "
"Even when the Python interpreter shuts down, the global :c:data:`!SpamError`"
" variable will not be garbage-collected. It will \"leak\". We did, however, "
"ensure that this will happen at most once per process."
msgstr ""
"在目前，用于移除该引用的 :c:func:`Py_DECREF` 调用是缺失的。 即使是在 Python 解释器关闭时，全局变量 "
":c:data:`!SpamError` 也不会被当作垃圾回收。 它将会“泄漏”。 不过，我们确实能保证这在每个进程中最多发生一次。"

#: ../../extending/extending.rst:301
msgid ""
"We discuss the use of :c:macro:`PyMODINIT_FUNC` as a function return type "
"later in this sample."
msgstr "本样例稍后将讨论 :c:macro:`PyMODINIT_FUNC` 作为函数返回类型的用法。"

#: ../../extending/extending.rst:304
msgid ""
"The :exc:`!spam.error` exception can be raised in your extension module "
"using a call to :c:func:`PyErr_SetString` as shown below::"
msgstr "可在扩展模块中调用 :c:func:`PyErr_SetString` 来引发 :exc:`!spam.error` 异常，如下所示::"

#: ../../extending/extending.rst:307
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:327
msgid "Back to the Example"
msgstr "回到例子"

#: ../../extending/extending.rst:329
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr "回到前面的例子，你应该明白下面的代码:"

#: ../../extending/extending.rst:332
msgid ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"
msgstr ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"

#: ../../extending/extending.rst:335
msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`!command`.  This"
" is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`!command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"如果在参数列表中检测到错误，它将返回 ``NULL`` (该值是返回对象指针的函数的错误提示)，这取决于 "
":c:func:`PyArg_ParseTuple` 设置的异常。 在其他情况下参数的字符串值会被拷贝到局部变量 :c:data:`!command`。"
" 这是一个指针赋值并且你不应该修改它所指向的字符串 (因此在标准 C 中，变量 :c:data:`!command` 应当被正确地声明为 ``const"
" char *command``)。"

#: ../../extending/extending.rst:343
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"下一个语句使用UNIX系统函数 :c:func:`system` ，传递给他的参数是刚才从 :c:func:`PyArg_ParseTuple` "
"取出的:"

#: ../../extending/extending.rst:346
msgid "sts = system(command);"
msgstr "sts = system(command);"

#: ../../extending/extending.rst:348
msgid ""
"Our :func:`!spam.system` function must return the value of :c:data:`!sts` as"
" a Python object.  This is done using the function "
":c:func:`PyLong_FromLong`. ::"
msgstr ""
"我们的 :func:`!spam.system` 函数必须以 Python 对象的形式返回 :c:data:`!sts` 的值。 这是通过使用函数 "
":c:func:`PyLong_FromLong` 完成的。 ::"

#: ../../extending/extending.rst:351
msgid "return PyLong_FromLong(sts);"
msgstr "return PyLong_FromLong(sts);"

#: ../../extending/extending.rst:353
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr "在这种情况下，会返回一个整数对象，(这个对象会在Python堆里面管理)。"

#: ../../extending/extending.rst:356
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the "
":c:macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"如果你有一个不返回有用参数的 C 函数（即返回 :c:expr:`void` 的函数），则对应的 Python 函数必须返回 ``None``。 "
"你必须使用这种写法（它是通过 :c:macro:`Py_RETURN_NONE` 宏来实现的） ::"

#: ../../extending/extending.rst:361
msgid ""
"Py_INCREF(Py_None);\n"
"return Py_None;"
msgstr ""
"Py_INCREF(Py_None);\n"
"return Py_None;"

#: ../../extending/extending.rst:364
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a ``NULL`` pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` 是特殊 Python 对象 ``None`` 所对应的 C 名称。 它是一个真正的 Python 对象而不是 "
"``NULL`` 指针，如我们所见，后者在大多数上下文中都意味着“错误”。"

#: ../../extending/extending.rst:372
msgid "The Module's Method Table and Initialization Function"
msgstr "模块方法表和初始化函数"

#: ../../extending/extending.rst:374
msgid ""
"I promised to show how :c:func:`!spam_system` is called from Python "
"programs. First, we need to list its name and address in a \"method "
"table\"::"
msgstr ""
"我承诺过要向大家展示如何从 Python 程序中调用 :c:func:`!spam_system`。 首先，我们需要在“方法表”中列出它的名称和地址::"

#: ../../extending/extending.rst:377
msgid ""
"static PyMethodDef spam_methods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"
msgstr ""
"static PyMethodDef spam_methods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"

#: ../../extending/extending.rst:385
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should"
" normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"注意第三个参数 ( ``METH_VARARGS`` ) ，这个标志指定会使用C的调用惯例。可选值有  ``METH_VARARGS`` 、 "
"``METH_VARARGS | METH_KEYWORDS`` 。值 ``0`` 代表使用 :c:func:`PyArg_ParseTuple` "
"的陈旧变量。"

#: ../../extending/extending.rst:390
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via "
":c:func:`PyArg_ParseTuple`; more information on this function is provided "
"below."
msgstr ""
"如果单独使用 ``METH_VARARGS`` ，函数会等待Python传来tuple格式的参数，并最终使用  "
":c:func:`PyArg_ParseTuple` 进行解析。"

#: ../../extending/extending.rst:394
msgid ""
"The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of"
" keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
"如果应当将关键字参数传给该函数则可以在第三个字段中设置 :c:macro:`METH_KEYWORDS` 比特位。 在此情况下，C 函数应当接受第三个 "
"``PyObject *`` 形参，它将为一个由关键字组成的字典。 使用 :c:func:`PyArg_ParseTupleAndKeywords` "
"来将参数解析为函数。"

#: ../../extending/extending.rst:400
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr "这个方法表必须被模块定义结构所引用。"

#: ../../extending/extending.rst:402
msgid ""
"static struct PyModuleDef spam_module = {\n"
"    ...\n"
"    .m_methods = spam_methods,\n"
"    ...\n"
"};"
msgstr ""
"static struct PyModuleDef spam_module = {\n"
"    ...\n"
"    .m_methods = spam_methods,\n"
"    ...\n"
"};"

#: ../../extending/extending.rst:408
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named "
":c:func:`!PyInit_name`, where *name* is the name of the module, and should "
"be the only non-\\ ``static`` item defined in the module file::"
msgstr ""
"这个结构体必须在模块的初始化函数中传递给解释器。 初始化函数必须命名为 :c:func:`!PyInit_name`，其中 *name* "
"是模块的名称，并且应该是模块文件中定义的唯一非 ``static`` 条目::"

#: ../../extending/extending.rst:413
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

#: ../../extending/extending.rst:419
msgid ""
"Note that :c:macro:`PyMODINIT_FUNC` declares the function as ``PyObject *`` "
"return type, declares any special linkage declarations required by the "
"platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"请注意 :c:macro:`PyMODINIT_FUNC` 将函数声明为 ``PyObject *`` "
"返回类型，声明了平台所要求的任何特殊链接声明，并针对于= C++ 将函数声明为 ``extern \"C\"``。"

#: ../../extending/extending.rst:423
msgid ""
":c:func:`!PyInit_spam` is called when each interpreter imports its module "
":mod:`!spam` for the first time.  (See below for comments about embedding "
"Python.) A pointer to the module definition must be returned via "
":c:func:`PyModuleDef_Init`, so that the import machinery can create the "
"module and store it in ``sys.modules``."
msgstr ""
":c:func:`!PyInit_spam` 会在每个解释器首次导入其 :mod:`!spam` 模块时被调用。 （请参看下文中有关嵌入式 Python"
" 的说明。） 必须通过 :c:func:`PyModuleDef_Init` 返回一个指向模块定义的指针，以便导入机制能够创建该模块并将其保存到 "
"``sys.modules`` 中。"

#: ../../extending/extending.rst:428
msgid ""
"When embedding Python, the :c:func:`!PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use "
":c:func:`PyImport_AppendInittab`, optionally followed by an import of the "
"module::"
msgstr ""
"当嵌入 Python 时，除非 :c:data:`PyImport_Inittab` 表中有条目，否则不会自动调用 "
":c:func:`!PyInit_spam` 函数。 要将模块添加到初始化表中，请使用 "
":c:func:`PyImport_AppendInittab`，可选择随后导入该模块::"

#: ../../extending/extending.rst:433
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... use Python C API here ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* 添加一个内置模块，在 Py_Initialize 之前 */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* 将 argv[0] 传给 Python 解释器 */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* 初始化 Python 解释器。 必需的操作。\n"
"       如果此步骤失败，将导致致命错误。 */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* 可以选择导入模块；或是作为替代，\n"
"       导入可以被延迟直到由嵌入的脚本\n"
"       来导入它。 */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... 在此使用 Python C API ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"

#: ../../extending/extending.rst:483
msgid ""
"If you declare a global variable or a local static one, the module may "
"experience unintended side-effects on re-initialisation, for example when "
"removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`). If module state is not yet fully "
":ref:`isolated <isolating-extensions-howto>`, authors should consider "
"marking the module as having no support for subinterpreters (via "
":c:macro:`Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED`)."
msgstr ""
"如果你声明一个全局变量或局部静态变量，模块可能在重新初始化时出现预料之外的附带影响，例如在从 ``sys.modules`` "
"中移除条目或将已编译的模块导入到一个进程中的多个解释器（或者在未干预 :c:func:`exec` 的情况下执行 :c:func:`fork` "
"之后）的时候。 如果模块状态没有被完全 :ref:`隔离<isolating-extensions-"
"howto>`，开发者应当考虑将模块标记为不支持子解释器 (通过 "
":c:macro:`Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED`)。"

#: ../../extending/extending.rst:492
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxlimited.c`.  This file may be used as a "
"template or simply read as an example."
msgstr ""
"在 Python 源代码发布包的 :file:`Modules/xxlimited.c` 中包括了一个更详细的示例。 "
"此文件可被用作代码模板或是学习样例。"

#: ../../extending/extending.rst:500
msgid "Compilation and Linkage"
msgstr "编译和链接"

#: ../../extending/extending.rst:502
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter "
":ref:`building`) and additional information that pertains only to building "
"on Windows (chapter :ref:`building-on-windows`) for more information about "
"this."
msgstr ""
"在你能使用你的新写的扩展之前，你还需要做两件事情：使用 Python "
"系统来编译和链接。如果你使用动态加载，这取决于你使用的操作系统的动态加载机制；更多信息请参考编译扩展模块的章节（ :ref:`building` "
"章节），以及在 Windows 上编译需要的额外信息（ :ref:`building-on-windows` 章节）。"

#: ../../extending/extending.rst:509
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"如果你不使用动态加载，或者想要让模块永久性的作为Python解释器的一部分，就必须修改配置设置，并重新构建解释器。幸运的是在Unix上很简单，只需要把你的文件"
" ( :file:`spammodule.c` 为例) 放在解压缩源码发行包的 :file:`Modules/` 目录下，添加一行到 "
":file:`Modules/Setup.local` 来描述你的文件："

#: ../../extending/extending.rst:516
msgid "spam spammodule.o"
msgstr "spam spammodule.o"

#: ../../extending/extending.rst:520
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change"
" the :file:`Setup` file.)"
msgstr ""
"然后在顶层目录运行 :program:`make` 来重新构建解释器。你也可以在 :file:`Modules/` 子目录使用 "
":program:`make`，但是你必须先重建 :file:`Makefile` 文件，然后运行 ':program:`make` Makefile'"
" 命令。（你每次修改 :file:`Setup` 文件都需要这样操作。）"

#: ../../extending/extending.rst:526
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr "如果你的模块需要额外的链接，这些内容可以列出在配置文件里，举个实例："

#: ../../extending/extending.rst:529
msgid "spam spammodule.o -lX11"
msgstr "spam spammodule.o -lX11"

#: ../../extending/extending.rst:537
msgid "Calling Python Functions from C"
msgstr "在C中调用Python函数"

#: ../../extending/extending.rst:539
msgid ""
"So far we have concentrated on making C functions callable from Python.  The"
" reverse is also useful: calling Python functions from C. This is especially"
" the case for libraries that support so-called \"callback\" functions.  If a"
" C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other"
" uses are also imaginable."
msgstr ""
"迄今为止，我们一直把注意力集中于让Python调用C函数，其实反过来也很有用，就是用C调用Python函数。这在回调函数中尤其有用。如果一个C接口使用回调，那么就要实现这个回调机制。"

#: ../../extending/extending.rst:547
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to"
" call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"幸运的是，Python解释器是比较方便回调的，并给标准Python函数提供了标准接口。(这里就不再详述解析Python字符串作为输入的方式，如果有兴趣可以参考"
" :file:`Python/pythonmain.c` 中的 :option:`-c` 命令行代码。)"

#: ../../extending/extending.rst:553
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some"
" other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"调用Python函数很简单，首先Python程序要传递Python函数对象。应该提供个函数(或其他接口)来实现。当调用这个函数时，用全局变量保存Python函数对象的指针，还要调用"
" (:c:func:`Py_INCREF`) 来增加引用计数，当然不用全局变量也没什么关系。举个例子，如下函数可能是模块定义的一部分："

#: ../../extending/extending.rst:560
msgid ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* Add a reference to new callback */\n"
"        Py_XDECREF(my_callback);  /* Dispose of previous callback */\n"
"        my_callback = temp;       /* Remember new callback */\n"
"        /* Boilerplate to return \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* 添加一个指向新回调的引用 */\n"
"        Py_XDECREF(my_callback);  /* 丢弃之前的回调 */\n"
"        my_callback = temp;       /* 记住新的回调 */\n"
"        /* 返回 \"None\" 的样例 */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"

#: ../../extending/extending.rst:583
msgid ""
"This function must be registered with the interpreter using the "
":c:macro:`METH_VARARGS` flag; this is described in section "
":ref:`methodtable`.  The :c:func:`PyArg_ParseTuple` function and its "
"arguments are documented in section :ref:`parsetuple`."
msgstr ""
"此函数必须使用 :c:macro:`METH_VARARGS` 旗标注册到解释器；这将在 :ref:`methodtable` 一节中详细描述。 "
":c:func:`PyArg_ParseTuple` 函数及其参数的文档见 :ref:`parsetuple` 一节。"

#: ../../extending/extending.rst:588
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement"
" the reference count of an object and are safe in the presence of ``NULL`` "
"pointers (but note that *temp* will not be  ``NULL`` in this context).  More"
" info on them in section :ref:`refcounts`."
msgstr ""
":c:func:`Py_XINCREF` 和 :c:func:`Py_XDECREF` 这两个宏可增加/减少一个对象的引用计数，并且当存在 "
"``NULL`` 指针时仍可保证安全 (但请注意在这个上下文中 *temp* 将不为  ``NULL``)。 更多相关信息请参考 "
":ref:`refcounts` 章节。"

#: ../../extending/extending.rst:595
msgid ""
"Later, when it is time to call the function, you call the C function "
":c:func:`PyObject_CallObject`.  This function has two arguments, both "
"pointers to arbitrary Python objects: the Python function, and the argument "
"list.  The argument list must always be a tuple object, whose length is the "
"number of arguments.  To call the Python function with no arguments, pass in"
" ``NULL``, or an empty tuple; to call it with one argument, pass a singleton"
" tuple. :c:func:`Py_BuildValue` returns a tuple when its format string "
"consists of zero or more format codes between parentheses.  For example::"
msgstr ""
"随后，当要调用此函数时，你将调用 C 函数 :c:func:`PyObject_CallObject`。 该函数有两个参数，它们都属于指针，指向任意 "
"Python 对象：即 Python 函数，及其参数列表。 参数列表必须总是一个元组对象，其长度即参数的个数量。 要不带参数地调用 Python "
"函数，则传入 ``NULL`` 或一个空元组；要带一个参数调用它，则传入一个单元组。 :c:func:`Py_BuildValue` "
"会在其格式字符串包含一对圆括号内的零个或多个格式代码时返回一个元组。 例如::"

#: ../../extending/extending.rst:604
msgid ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Time to call the callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"
msgstr ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* 此时将调用回调 */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"

#: ../../extending/extending.rst:615
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a"
" new tuple was created to serve as the argument list, which is "
":c:func:`Py_DECREF`\\ -ed immediately after the "
":c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` 返回Python对象指针，这也是Python函数的返回值。 "
":c:func:`PyObject_CallObject` 是一个对其参数 \"引用计数无关\" 的函数。例子中新的元组创建用于参数列表，并且在  "
":c:func:`PyObject_CallObject` 之后立即使用了 :c:func:`Py_DECREF` 。"

#: ../../extending/extending.rst:622
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a"
" brand new object, or it is an existing object whose reference count has "
"been incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are"
" not interested in its value."
msgstr ""
":c:func:`PyObject_CallObject` "
"的返回值总是“新”的：要么是一个新建的对象；要么是已有对象，但增加了引用计数。所以除非你想把结果保存在全局变量中，你需要对这个值使用 "
":c:func:`Py_DECREF`，即使你对里面的内容（特别！）不感兴趣。"

#: ../../extending/extending.rst:628
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't ``NULL``.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called"
" from Python, it should now return an error indication to its Python caller,"
" so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"但是在你这么做之前，很重要的一点是检查返回值不是 ``NULL``。 如果是的话，Python 函数会终止并引发异常。 如果调用 "
":c:func:`PyObject_CallObject` 的 C 代码是在 Python 中唤起的，它应当立即返回一个错误来告知其 Python "
"调用者，以便解释器能打印栈回溯信息，或者让调用方 Python 代码能处理该异常。 如果这无法做到或不合本意，则应当通过调用 "
":c:func:`PyErr_Clear` 来清除异常。 例如::"

#: ../../extending/extending.rst:636
msgid ""
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"...use result...\n"
"Py_DECREF(result);"
msgstr ""
"if (result == NULL)\n"
"    return NULL; /* 回传错误 */\n"
"...使用 result...\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:641
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through"
" the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if"
" you want to pass an integral event code, you might use the following code::"
msgstr ""
"依赖于具体的回调函数，你还要提供一个参数列表到 :c:func:`PyObject_CallObject` "
"。在某些情况下参数列表是由Python程序提供的，通过接口再传到回调函数对象。这样就可以不改变形式直接传递。另外一些时候你要构造一个新的元组来传递参数。最简单的方法就是"
" :c:func:`Py_BuildValue` 函数构造tuple。举个例子，你要传递一个事件代码时可以用如下代码:"

#: ../../extending/extending.rst:650
msgid ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* 可以在此使用 result */\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:660
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"注意 ``Py_DECREF(arglist)`` 所在处会立即调用，在错误检查之前。当然还要注意一些常规的错误，比如 "
":c:func:`Py_BuildValue` 可能会遭遇内存不足等等。"

#: ../../extending/extending.rst:664
msgid ""
"You may also call a function with keyword arguments by using "
":c:func:`PyObject_Call`, which supports arguments and keyword arguments.  As"
" in the above example, we use :c:func:`Py_BuildValue` to construct the "
"dictionary. ::"
msgstr ""
"当你调用函数时还需要注意，用关键字参数调用 :c:func:`PyObject_Call` ，需要支持普通参数和关键字参数。有如如上例子中，我们使用 "
":c:func:`Py_BuildValue` 来构造字典。"

#: ../../extending/extending.rst:668
msgid ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* 回传错误 */\n"
"/* 可以在此使用 result */\n"
"Py_DECREF(result);"

#: ../../extending/extending.rst:682
msgid "Extracting Parameters in Extension Functions"
msgstr "提取扩展函数的参数"

#: ../../extending/extending.rst:686
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr "函数 :c:func:`PyArg_ParseTuple` 的声明如下："

#: ../../extending/extending.rst:688
msgid "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"
msgstr "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"

#: ../../extending/extending.rst:690
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed"
" from Python to a C function.  The *format* argument must be a format "
"string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"参数 *arg* 必须是一个元组对象，包含从 Python 传递给 C 函数的参数列表。*format* 参数必须是一个格式字符串，语法请参考 "
"Python C/API 手册中的 :ref:`arg-parsing`。剩余参数是各个变量的地址，类型要与格式字符串对应。"

#: ../../extending/extending.rst:696
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"注意 :c:func:`PyArg_ParseTuple` "
"会检测他需要的Python参数类型，却无法检测传递给他的C变量地址，如果这里出错了，可能会在内存中随机写入东西，小心。"

#: ../../extending/extending.rst:701
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr "注意任何由调用者提供的 Python 对象引用是 *借来的* 引用；不要递减它们的引用计数！"

#: ../../extending/extending.rst:704
msgid "Some example calls::"
msgstr "一些调用的例子："

#: ../../extending/extending.rst:711
msgid ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* No arguments */\n"
"    /* Python call: f() */"
msgstr ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* 无参数 */\n"
"    /* Python 调用: f() */"

#: ../../extending/extending.rst:722
msgid ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */\n"
"    /* Possible Python call: f('whoops!') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* 一个字符串 */\n"
"    /* 可能的 Python 调用: f('whoops!') */"

#: ../../extending/extending.rst:727
msgid ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a string */\n"
"    /* Possible Python call: f(1, 2, 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* 两个长整型和一个字符串 */\n"
"    /* 可能的 Python 调用: f(1, 2, 'three') */"

#: ../../extending/extending.rst:732
msgid ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* A pair of ints and a string, whose size is also returned */\n"
"    /* Possible Python call: f((1, 2), 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* 一对整数和一个字符串，其大小也将被返回 */\n"
"    /* 可能的 Python 调用: f((1, 2), 'three') */"

#: ../../extending/extending.rst:738
msgid ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* A string, and optionally another string and an integer */\n"
"    /* Possible Python calls:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"
msgstr ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* 一个字符串，并可选择传入另一个字符串和一个整数 */\n"
"    /* 可能的 Python 调用:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"

#: ../../extending/extending.rst:752
msgid ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* A rectangle and a point */\n"
"    /* Possible Python call:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"
msgstr ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* 一个矩型和一个点 */\n"
"    /* 可能的 Python 调用:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"

#: ../../extending/extending.rst:763
msgid ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* a complex, also providing a function name for errors */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"
msgstr ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* 一个复数，并提供一个函数名用于错误处理 */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"

#: ../../extending/extending.rst:774
msgid "Keyword Parameters for Extension Functions"
msgstr "给扩展函数的关键字参数"

#: ../../extending/extending.rst:778
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr "函数 :c:func:`PyArg_ParseTupleAndKeywords` 声明如下："

#: ../../extending/extending.rst:780
msgid ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const *kwlist, ...);"
msgstr ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const *kwlist, ...);"

#: ../../extending/extending.rst:783
msgid ""
"The *arg* and *format* parameters are identical to those of the "
":c:func:`PyArg_ParseTuple` function.  The *kwdict* parameter is the "
"dictionary of keywords received as the third parameter from the Python "
"runtime.  The *kwlist* parameter is a ``NULL``-terminated list of strings "
"which identify the parameters; the names are matched with the type "
"information from *format* from left to right.  On success, "
":c:func:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns "
"false and raises an appropriate exception."
msgstr ""
"*arg* 与 *format* 形参与 :c:func:`PyArg_ParseTuple` 函数所定义的一致。 *kwdict* "
"形参是作为第三个参数从 Python 运行时接收的关键字字典。 *kwlist* 形参是以 ``NULL`` "
"结尾的字符串列表，它被用来标识形参；名称从左至右与来自 *format* 的类型信息相匹配。 "
"如果执行成功，:c:func:`PyArg_ParseTupleAndKeywords` 会返回真值，否则返回假值并引发一个适当的异常。"

#: ../../extending/extending.rst:793
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause "
":exc:`TypeError` to be raised."
msgstr "嵌套的元组在使用关键字参数时无法生效，不在 *kwlist* 中的关键字参数会导致 :exc:`TypeError` 异常。"

#: ../../extending/extending.rst:799
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr "如下例子是使用关键字参数的例子模块，作者是 Geoff Philbrick (philbrick@hks.com):"

#: ../../extending/extending.rst:802
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int voltage;\n"
"    const char *state = \"a stiff\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"Norwegian Blue\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* The cast of the function is necessary since PyCFunction values\n"
"     * only take two PyObject* parameters, and keywdarg_parrot() takes\n"
"     * three.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,\n"
"     \"Print a lovely skit to standard output.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdarg_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"keywdarg\",\n"
"    .m_size = 0,\n"
"    .m_methods = keywdarg_methods,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModuleDef_Init(&keywdarg_module);\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"int voltage;\n"
"const char *state = \"a stiff\";\n"
"const char *action = \"voom\";\n"
"const char *type = \"Norwegian Blue\";\n"
"\n"
"static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};\n"
"\n"
"if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"&voltage, &state, &action, &type))\n"
"return NULL;\n"
"\n"
"printf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",\n"
"action, voltage);\n"
"printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"/* 函数的转换是必要的因为 PyCFunction 值\n"
"* 仅接受两个 PyObject* 形参，而 keywdarg_parrot()\n"
"* 接受三个。\n"
"*/\n"
"{\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,\n"
"\"Print a lovely skit to standard output.\"},\n"
"{NULL, NULL, 0, NULL} /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdarg_module = {\n"
".m_base = PyModuleDef_HEAD_INIT,\n"
".m_name = \"keywdarg\",\n"
".m_size = 0,\n"
".m_methods = keywdarg_methods,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"return PyModuleDef_Init(&keywdarg_module);\n"
"}"

#: ../../extending/extending.rst:853
msgid "Building Arbitrary Values"
msgstr "构造任意值"

#: ../../extending/extending.rst:855
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr "这个函数与 :c:func:`PyArg_ParseTuple` 很相似，声明如下："

#: ../../extending/extending.rst:858
msgid "PyObject *Py_BuildValue(const char *format, ...);"
msgstr "PyObject *Py_BuildValue(const char *format, ...);"

#: ../../extending/extending.rst:860
msgid ""
"It recognizes a set of format units similar to the ones recognized by "
":c:func:`PyArg_ParseTuple`, but the arguments (which are input to the "
"function, not output) must not be pointers, just values.  It returns a new "
"Python object, suitable for returning from a C function called from Python."
msgstr ""
"接受一个格式字符串，与 :c:func:`PyArg_ParseTuple` "
"相同，但是参数必须是原变量的地址指针(输入给函数，而非输出)。最终返回一个Python对象适合于返回C函数调用给Python代码。"

#: ../../extending/extending.rst:865
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it"
" contains exactly one format unit, it returns whatever object is described "
"by that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
"一个与 :c:func:`PyArg_ParseTuple` "
"的不同是，后面可能需要的要求返回一个元组(Python参数里诶包总是在内部描述为元组)，比如用于传递给其他Python函数以参数。 "
":c:func:`Py_BuildValue` 并不总是生成元组，在多于1个格式字符串时会生成元组，而如果格式字符串为空则返回 ``None`` "
"，一个参数则直接返回该参数的对象。如果要求强制生成一个长度为0的元组，或包含一个元素的元组，需要在格式字符串中加上括号。"

#: ../../extending/extending.rst:873
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr "例子(左侧是调用，右侧是Python值结果)："

#: ../../extending/extending.rst:875
msgid ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"

#: ../../extending/extending.rst:899
msgid "Reference Counts"
msgstr "引用计数"

#: ../../extending/extending.rst:901
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using"
" the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"在C/C++语言中，程序员负责动态分配和回收堆heap当中的内存。在C里，通过函数 :c:func:`malloc` 和 :c:func:`free` "
"来完成。在C++里是操作 ``new`` 和 ``delete`` 来实现相同的功能。"

#: ../../extending/extending.rst:907
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to "
":c:func:`free`. It is important to call :c:func:`free` at the right time.  "
"If a block's address is forgotten but :c:func:`free` is not called for it, "
"the memory it occupies cannot be reused until the program terminates.  This "
"is called a :dfn:`memory leak`.  On the other hand, if a program calls "
":c:func:`free` for a block and then continues to use the block, it creates a"
" conflict with reuse of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""
"每个使用 :c:func:`malloc` 分配的内存块最终都应当通过恰好一次对 :c:func:`free` 的调用返回到可用内存池中。 调用 "
":c:func:`free` 的时机非常重要。 如果一个块地址被遗忘而没有为它执行 :c:func:`free` "
"调用，它所占用的内存在程序终结之前将无法被重新使用。 这就称为 :dfn:`内存泄漏`。 另一方面，如果程序为一个块地址调用了 "
":c:func:`free` 然后却继续使用该内存块，它将与通过另一个 :c:func:`malloc` 调用对该内存块的重新使用产生冲突。 这就称为 "
":dfn:`使用已释放的内存`。 它所造成的后果与引用未初始化数据一样糟糕 --- 核心转储、错误结果、意外崩溃等等。"

#: ../../extending/extending.rst:918
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction"
" of all calls, and most modern machines have plenty of virtual memory, so "
"the leak only becomes apparent in a long-running process that uses the "
"leaking function frequently.  Therefore, it's important to prevent leaks "
"from happening by having a coding convention or strategy that minimizes this"
" kind of errors."
msgstr ""
"内存泄露往往发生在一些并不常见的代码流程上面。比如一个函数申请了内存以后，做了些计算，然后释放内存块。现在一些对函数的修改可能增加对计算的测试并检测错误条件，然后过早的从函数返回了。这很容易忘记在退出前释放内存，特别是后期修改的代码。这种内存泄漏，一旦引入，通常很长时间都难以检测到，错误退出被调用的频度较低，而现代电脑又有非常巨大的虚拟内存，所以泄漏仅在长期运行或频繁调用泄漏函数时才会变得明显。因此，有必要避免内存泄漏，通过代码规范会策略来最小化此类错误。"

#: ../../extending/extending.rst:931
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a"
" reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"Python通过 :c:func:`malloc` 和 :c:func:`free` "
"包含大量的内存分配和释放，同样需要避免内存泄漏和野指针。他选择的方法就是 :dfn:`引用计数` "
"。其原理比较简单：每个对象都包含一个计数器，计数器的增减与对象引用的增减直接相关，当引用计数为0时，表示对象已经没有存在的意义了，对象就可以删除了。"

#: ../../extending/extending.rst:939
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The"
" disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic"
" garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"另一个叫法是 :dfn:`自动垃圾回收` "
"。(有时引用计数也被看作是垃圾回收策略，于是这里的\"自动\"用以区分两者)。自动垃圾回收的优点是用户不需要明确的调用 :c:func:`free` "
"。(另一个优点是改善速度或内存使用，然而这并不难)。缺点是对C，没有可移植的自动垃圾回收器，而引用计数则可以可移植的实现(只要 "
":c:func:`malloc` 和 :c:func:`free` "
"函数是可用的，这也是C标准担保的)。也许以后有一天会出现可移植的自动垃圾回收器，但在此前我们必须与引用计数一起工作。"

#: ../../extending/extending.rst:951
msgid ""
"While Python uses the traditional reference counting implementation, it also"
" offers a cycle detector that works to detect reference cycles.  This allows"
" applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"Python使用传统的引用计数实现，也提供了循环监测器，用以检测引用循环。这使得应用无需担心直接或间接的创建了循环引用，这是引用计数垃圾收集的一个弱点。引用循环是对象(可能直接)的引用了本身，所以循环中的每个对象的引用计数都不是0。典型的引用计数实现无法回收处于引用循环中的对象，或者被循环所引用的对象，哪怕没有循环以外的引用了。"

#: ../../extending/extending.rst:962
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the "
":func:`~gc.collect` function), as well as configuration interfaces and the "
"ability to disable the detector at runtime."
msgstr ""
"循环检测器能够检测垃圾回收循环并能回收它们。 :mod:`gc` 模块提供了一种运行该检测器的方式 (:func:`~gc.collect` "
"函数)，以及多个配置接口和在运行时禁用该检测器的功能。"

#: ../../extending/extending.rst:971
msgid "Reference Counting in Python"
msgstr "Python中的引用计数"

#: ../../extending/extending.rst:973
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. "
":c:func:`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"有两个宏 ``Py_INCREF(x)`` 和 ``Py_DECREF(x)`` ，会处理引用计数的增减。 :c:func:`Py_DECREF` "
"也会在引用计数到达0时释放对象。为了灵活，并不会直接调用 :c:func:`free` ，而是通过对象的 :dfn:`类型对象` "
"的函数指针来调用。为了这个目的(或其他的)，每个对象同时包含一个指向自身类型对象的指针。"

#: ../../extending/extending.rst:980
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The"
" owner of a reference is responsible for calling :c:func:`Py_DECREF` when "
"the reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it"
" on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an "
"owned reference creates a memory leak."
msgstr ""
"最大的问题依旧：何时使用 ``Py_INCREF(x)`` 和 ``Py_DECREF(x)`` "
"？我们首先引入一些概念。没有人\"拥有\"一个对象，你可以 :dfn:`拥有一个引用` "
"到一个对象。一个对象的引用计数定义为拥有引用的数量。引用的拥有者有责任调用 :c:func:`Py_DECREF` "
"，在引用不再需要时。引用的拥有关系可以被传递。有三种办法来处置拥有的引用：传递、存储、调用 :c:func:`Py_DECREF` "
"。忘记处置一个拥有的引用会导致内存泄漏。"

#: ../../extending/extending.rst:989
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""
"还可以 :dfn:`借用` [#]_ 一个对象的引用。借用的引用不应该调用 :c:func:`Py_DECREF` "
"。借用者必须确保不能持有对象超过拥有者借出的时间。在拥有者处置对象后使用借用的引用是有风险的，应该完全避免 [#]_ 。"

#: ../../extending/extending.rst:995
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to"
" take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of"
" leaking when a premature exit is taken.  The disadvantage of borrowing over"
" owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"借用相对于引用的优点是你无需担心整条路径上代码的引用，或者说，通过借用你无需担心内存泄漏的风险。借用的缺点是一些看起来正确代码上的借用可能会在拥有者处置后使用对象。"

#: ../../extending/extending.rst:1003
msgid ""
"A borrowed reference can be changed into an owned reference by calling "
":c:func:`Py_INCREF`.  This does not affect the status of the owner from "
"which the reference was borrowed --- it creates a new owned reference, and "
"gives full owner responsibilities (the new owner must dispose of the "
"reference properly, as well as the previous owner)."
msgstr ""
"借用可以变为拥有引用，通过调用 :c:func:`Py_INCREF`。 这不会影响已经借出的拥有者的状态。 "
"这会创建一个新的拥有引用，并给予完全的拥有者责任（新的拥有者必须恰当的处置引用，就像之前的拥有者那样）。"

#: ../../extending/extending.rst:1013
msgid "Ownership Rules"
msgstr "拥有规则"

#: ../../extending/extending.rst:1015
msgid ""
"Whenever an object reference is passed into or out of a function, it is part"
" of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr "当一个对象引用传递进出一个函数时，函数的接口应该指定拥有关系的传递是否包含引用。"

#: ../../extending/extending.rst:1019
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`,"
" pass ownership to the receiver.  Even if the object is not actually new, "
"you still receive ownership of a new reference to that object.  For "
"instance, :c:func:`PyLong_FromLong` maintains a cache of popular values and "
"can return a reference to a cached item."
msgstr ""
"大多数函数返回一个对象的引用，并传递引用拥有关系。通常，所有创建对象的函数，例如 :c:func:`PyLong_FromLong` 和 "
":c:func:`Py_BuildValue` ，会传递拥有关系给接收者。即便是对象不是真正新的，你仍然可以获得对象的新引用。一个实例是 "
":c:func:`PyLong_FromLong` 维护了一个流行值的缓存，并可以返回已缓存项目的新引用。"

#: ../../extending/extending.rst:1027
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:`PyObject_GetAttrString`."
"  The picture is less clear, here, however, since a few common routines are "
"exceptions: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem`, and :c:func:`PyDict_GetItemString` all return "
"references that you borrow from the tuple, list or dictionary."
msgstr ""
"很多另一个对象提取对象的函数，也会传递引用关系，例如 :c:func:`PyObject_GetAttrString` "
"。这里的情况不够清晰，一些不太常用的例程是例外的 :c:func:`PyTuple_GetItem` ， "
":c:func:`PyList_GetItem` ， :c:func:`PyDict_GetItem` ， "
":c:func:`PyDict_GetItemString` 都是返回从元组、列表、字典里借用的引用。"

#: ../../extending/extending.rst:1034
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference,"
" even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"函数 :c:func:`PyImport_AddModule` 也会返回借用的引用，哪怕可能会返回创建的对象：这个可能因为一个拥有的引用对象是存储在 "
"``sys.modules`` 里。"

#: ../../extending/extending.rst:1038
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will"
" use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and "
":c:func:`PyList_SetItem`.  These functions take over ownership of the item "
"passed to them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` "
"and friends don't take over ownership --- they are \"normal.\")"
msgstr ""
"当你传递一个对象引用到另一个函数时，通常函数是借用出去的。如果需要存储，就使用 :c:func:`Py_INCREF` "
"来变成独立的拥有者。这个规则有两个重要的例外： :c:func:`PyTuple_SetItem` 和 :c:func:`PyList_SetItem`"
" 。这些函数接受传递来的引用关系，哪怕会失败！(注意 :c:func:`PyDict_SetItem` "
"及其同类不会接受引用关系，他们是\"正常的\")。"

#: ../../extending/extending.rst:1046
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns."
"  Only when such a borrowed reference must be stored or passed on, it must "
"be turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"当一个C函数被Python调用时，会从调用方传来的参数借用引用。调用者拥有对象的引用，所以借用的引用生命周期可以保证到函数返回。只要当借用的引用需要存储或传递时，就必须转换为拥有的引用，通过调用"
" :c:func:`Py_INCREF` 。"

#: ../../extending/extending.rst:1052
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to"
" its caller."
msgstr "Python调用从C函数返回的对象引用时必须是拥有的引用---拥有关系被从函数传递给调用者。"

#: ../../extending/extending.rst:1060
msgid "Thin Ice"
msgstr "危险的薄冰"

#: ../../extending/extending.rst:1062
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr "有少数情况下，借用的引用看起来无害，但却可能导致问题。这通常是因为解释器的隐式调用，并可能导致引用拥有者处置这个引用。"

#: ../../extending/extending.rst:1066
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF`"
" on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr "首先需要特别注意的情况是使用 :c:func:`Py_DECREF` 到一个无关对象，而这个对象的引用是借用自一个列表的元素。举个实例："

#: ../../extending/extending.rst:1069
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"

#: ../../extending/extending.rst:1078
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference."
" Looks harmless, right?  But it's not!"
msgstr ""
"这个函数首先借用一个引用 ``list[0]`` ，然后替换 ``list[1]`` 为值 ``0`` ，最后打印借用的引用。看起来无害是吧，但却不是。"

#: ../../extending/extending.rst:1082
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`!__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`!__del__` method."
msgstr ""
"让我们跟随控制流进入 :c:func:`PyList_SetItem`。 列表拥有对其所有条目的引用，因此当条目 1 被替换时，它必须丢弃原始条目 1。"
" 现在我们假设原始条目 1 是一个用户定义类的实例，并进一步假设该类定义了一个 :meth:`!__del__` 方法。 如果该类实例的引用计数为 "
"1，那么丢弃它时将调用其 :meth:`!__del__` 方法。"

#: ../../extending/extending.rst:1089
msgid ""
"Since it is written in Python, the :meth:`!__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`!bug`?  You bet!  Assuming that the list "
"passed into :c:func:`!bug` is accessible to the :meth:`!__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""
"由于它是用 Python 编写的，因此 :meth:`!__del__` 方法可以执行任意 Python 代码。 它是否可以使 "
":c:func:`!bug` 中对 ``item`` 的引用失效呢？ 当然可以！ 假定传入 :c:func:`!bug` 的列表可以被 "
":meth:`!__del__` 方法访问，它就可以执行一条语句实现 ``del list[0]`` "
"的效果，假定这是对该对象的最后一次引用，它就会释放与之相关联的内存，从而使 ``item`` 失效。"

#: ../../extending/extending.rst:1097
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr "解决方法是，当你知道了问题的根源，就容易了：临时增加引用计数。正确版本的函数代码如下："

#: ../../extending/extending.rst:1100
msgid ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"
msgstr ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"

#: ../../extending/extending.rst:1111
msgid ""
"This is a true story.  An older version of Python contained variants of this"
" bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`!__del__` methods would fail..."
msgstr ""
"这是一个真实的故事。 一个较旧版本的 Python 曾经包含此问题的变化形式，有人在 C 语言调试器中花费了大量时间，才弄明白为什么他的 "
":meth:`!__del__` 方法会失败……"

#: ../../extending/extending.rst:1115
msgid ""
"The second case of problems with a borrowed reference is a variant involving"
" threads.  Normally, multiple threads in the Python interpreter can't get in"
" each other's way, because there is a :term:`global lock <global interpreter"
" lock>` protecting Python's entire object space. However, it is possible to "
"temporarily release this lock using the macro "
":c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it using "
":c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O calls, "
"to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""
"有关借入引用的问题的第二种情况是涉及线程的变种。 通常， Python 解释器中的多个线程不会相互影响，因为有一个 :term:`全局锁 <global"
" interpreter lock>` 在保护 Python 的整个对象空间。 不过，有可能使用宏 "
":c:macro:`Py_BEGIN_ALLOW_THREADS` 来临时释放这个锁，并使用 "
":c:macro:`Py_END_ALLOW_THREADS` 来重新获取它。 这在阻塞型 I/O 调用操作中很常见，可以让其他线程在等待 I/O "
"结束期间使用处理器。 显然，下面的函数与之前那个存在相同的问题::"

#: ../../extending/extending.rst:1125
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"

#: ../../extending/extending.rst:1139
msgid "NULL Pointers"
msgstr "NULL指针"

#: ../../extending/extending.rst:1141
msgid ""
"In general, functions that take object references as arguments do not expect"
" you to pass them ``NULL`` pointers, and will dump core (or cause later core"
" dumps) if you do so.  Functions that return object references generally "
"return ``NULL`` only to indicate that an exception occurred.  The reason for"
" not testing for ``NULL`` arguments is that functions often pass the objects"
" they receive on to other function --- if each function were to test for "
"``NULL``, there would be a lot of redundant tests and the code would run "
"more slowly."
msgstr ""
"通常，接受对象引用作为参数的函数不希望你传给它们 ``NULL`` 指针，并且当你这样做时将会转储核心（或在以后导致核心转储）。 "
"返回对象引用的函数通常只在要指明发生了异常时才返回 ``NULL``。 不检测 ``NULL`` "
"参数的原因在于这些函数经常要将它们所接收的对象传给其他函数 --- 如果每个函数都检测 ``NULL``，将会导致大量的冗余检测而使代码运行得更缓慢。"

#: ../../extending/extending.rst:1149
msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or from"
" a function that may raise an exception."
msgstr ""
"更好的做法是仅在“源头”上检测 ``NULL``，即在接收到一个可能为 ``NULL`` 的指针，例如来自 :c:func:`malloc` "
"或是一个可能引发异常的函数的时候。"

#: ../../extending/extending.rst:1153
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and "
":c:func:`Py_XDECREF` do."
msgstr ""
":c:func:`Py_INCREF` 和 :c:func:`Py_DECREF` 等宏不会检测 ``NULL`` 指针 --- 但是，它们的变种 "
":c:func:`Py_XINCREF` 和 :c:func:`Py_XDECREF` 则会检测。"

#: ../../extending/extending.rst:1157
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for ``NULL`` pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with ``NULL`` checking."
msgstr ""
"用于检测特定对象类型的宏 (``Pytype_Check()``) 不会检测 ``NULL`` 指针 --- "
"同样地，有大量代码会连续调用这些宏来测试一个对象是否为几种不同预期类型之一，这将会生成冗余的测试。 不存在带有 ``NULL`` 检测的变体。"

#: ../../extending/extending.rst:1163
msgid ""
"The C function calling mechanism guarantees that the argument list passed to"
" C functions (``args`` in the examples) is never ``NULL`` --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""
"C 函数调用机制会保证传给 C 函数的参数列表 (本示例中为 ``args``) 绝不会为 ``NULL`` --- 实际上它会保证其总是为一个元组 "
"[#]_。"

#: ../../extending/extending.rst:1167
msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the Python"
" user."
msgstr "任何时候将 ``NULL`` 指针“泄露”给 Python 用户都会是个严重的错误。"

#: ../../extending/extending.rst:1178
msgid "Writing Extensions in C++"
msgstr "在C++中编写扩展"

#: ../../extending/extending.rst:1180
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply."
"  If the main program (the Python interpreter) is compiled and linked by the"
" C compiler, global or static objects with constructors cannot be used.  "
"This is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``."
" It is unnecessary to enclose the Python header files in ``extern \"C\" "
"{...}`` --- they use this form already if the symbol ``__cplusplus`` is "
"defined (all recent C++ compilers define this symbol)."
msgstr ""
"还可以在C++中编写扩展模块，只是有些限制。如果主程序(Python解释器)是使用C编译器来编译和链接的，全局或静态对象的构造器就不能使用。而如果是C++编译器来链接的就没有这个问题。函数会被Python解释器调用(通常就是模块初始化函数)必须声明为"
" ``extern \"C\"`` 。而是否在 ``extern \"C\" {...}`` 里包含Python头文件则不是那么重要，因为如果定义了符号"
" ``__cplusplus`` 则已经是这么声明的了(所有现代C++编译器都会定义这个符号)。"

#: ../../extending/extending.rst:1194
msgid "Providing a C API for an Extension Module"
msgstr "给扩展模块提供C API"

#: ../../extending/extending.rst:1199
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C"
" functions for direct manipulation from other extension modules."
msgstr ""
"很多扩展模块提供了新的函数和类型供Python使用，但有时扩展模块里的代码也可以被其他扩展模块使用。例如，一个扩展模块可以实现一个类型 "
"\"collection\" 看起来是没有顺序的。就像是Python列表类型，拥有C "
"API允许扩展模块来创建和维护列表，这个新的集合类型可以有一堆C函数用于给其他扩展模块直接使用。"

#: ../../extending/extending.rst:1207
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not"
" be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others"
" require an explicit list of imported symbols at module link time (AIX is "
"one example), or offer a choice of different strategies (most Unices). And "
"even if symbols are globally visible, the module whose functions one wishes "
"to call might not have been loaded yet!"
msgstr ""
"开始看起来很简单：只需要编写函数(无需声明为 ``static`` )，提供恰当的头文件，以及C "
"API的文档。实际上在所有扩展模块都是静态链接到Python解释器时也是可以正常工作的。当模块以共享库链接时，一个模块中的符号定义对另一个模块不可见。可见的细节依赖于操作系统，一些系统的Python解释器使用全局命名空间(例如Windows)，有些则在链接时需要一个严格的已导入符号列表(一个例子是AIX)，或者提供可选的不同策略(如Unix系列)。即便是符号是全局可见的，你要调用的模块也可能尚未加载。"

#: ../../extending/extending.rst:1219
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"可移植性需要不能对符号可见性做任何假设。这意味着扩展模块里的所有符号都应该声明为 ``static`` "
"，除了模块的初始化函数，来避免与其他扩展模块的命名冲突(在段落 :ref:`methodtable` 中讨论) 。这意味着符号应该 *必须* "
"通过其他导出方式来供其他扩展模块访问。"

#: ../../extending/extending.rst:1226
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:expr:`void \\*`).  Capsules can only be"
" created and accessed via their C API, but they can be passed around like "
"any other Python object. In particular,  they can be assigned to a name in "
"an extension module's namespace. Other extension modules can then import "
"this module, retrieve the value of this name, and then retrieve the pointer "
"from the Capsule."
msgstr ""
"Python 提供了一个特别的机制用来从一个扩展模块向另一个扩展模块传递 C 层级的信息 (指针): Capsule。 一个 Capsule "
"就是一个存储了指针 (:c:expr:`void \\*`) 的 Python 数据类型。 Capsule 只能通过其 C API "
"来创建和访问，但它们可以像任何其他 Python 对象一样被传递。 特别地，它们可以被赋值给扩展模块命名空间中的一个名称。 "
"其他扩展模块将可以导入这个模块，获取该名称对应的值，然后从 Capsule 中获取指针。"

#: ../../extending/extending.rst:1234
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be"
" distributed in different ways between the module providing the code and the"
" client modules."
msgstr ""
"Capsule可以用多种方式导出C API给扩展模块。每个函数可以用自己的Capsule，或者所有C "
"API指针可以存储在一个数组里，数组地址再发布给Capsule。存储和获取指针也可以用多种方式，供客户端模块使用。"

#: ../../extending/extending.rst:1240
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:expr:`const "
"char \\*`); you're permitted to pass in a ``NULL`` name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule"
" from another."
msgstr ""
"无论你选择哪个方法，为你的 Capsule 指定适当的名称都很重要。 函数 :c:func:`PyCapsule_New` 接受一个 name 形参 "
"(:c:expr:`const char \\*`)；允许你传入一个 ``NULL`` 作为名称，但我们强烈推荐你指定名称。 正确地命名的 "
"Capsule 提供了一定的运行时类型安全性；没有可行的方式能区别两个未命名的 Capsule。"

#: ../../extending/extending.rst:1247
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr "通常来说，Capsule用于暴露C API，其名字应该遵循如下规范："

#: ../../extending/extending.rst:1250
msgid "modulename.attributename"
msgstr "modulename.attributename"

#: ../../extending/extending.rst:1252
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that"
" the Capsule they load contains the correct C API."
msgstr ""
"便利函数 :c:func:`PyCapsule_Import` 可以方便的载入通过Capsule提供的C "
"API，仅在Capsule的名字匹配时。这个行为为C API用户提供了高度的确定性来载入正确的C API。"

#: ../../extending/extending.rst:1257
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:expr:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that"
" takes care of importing the module and retrieving its C API pointers; "
"client modules only have to call this macro before accessing the C API."
msgstr ""
"下面的例子演示了一种将大部分负担交给导出模块编写者的处理方式，这对于常用的库模块来说是合适的。 它会将所有 C API "
"指针（在这个例子里只有一个！）储存到一个 :c:expr:`void` 指针数组，它将成为一个 Capsule 的值。 "
"与模块对应的头文件提供了一个宏用来管理导入模块和获取其 C API 指针；客户端模块只需要在访问 C API 之前调用这个宏即可。"

#: ../../extending/extending.rst:1265
msgid ""
"The exporting module is a modification of the :mod:`!spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`!spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`!PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`!PySpam_System` is also exported to other extension "
"modules."
msgstr ""
"导出模块是对 :ref:`extending-simpleexample` 部分的 :mod:`!spam` 模块的修改。 函数 "
":func:`!spam.system` 并不直接调用 C 库函数 :c:func:`system`，而是调用一个函数 "
":c:func:`!PySpam_System`，这个函数在现实中当然会做一些更复杂的事情（比如在每条命令中添加“sapm”）。 该函数 "
":c:func:`!PySpam_System` 也会导出给其他扩展模块。"

#: ../../extending/extending.rst:1272
msgid ""
"The function :c:func:`!PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr "函数 :c:func:`!PySpam_System` 是一个纯 C 函数，像其他函数一样声明为 ``static``::"

#: ../../extending/extending.rst:1275
msgid ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"
msgstr ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"

#: ../../extending/extending.rst:1281
msgid "The function :c:func:`!spam_system` is modified in a trivial way::"
msgstr "函数 :c:func:`!spam_system` 已按如下方式修改::"

#: ../../extending/extending.rst:1283
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"

#: ../../extending/extending.rst:1295
msgid "In the beginning of the module, right after the line ::"
msgstr "在模块开头，在此行后::"

#: ../../extending/extending.rst:1297
msgid "#include <Python.h>"
msgstr "#include <Python.h>"

#: ../../extending/extending.rst:1299
msgid "two more lines must be added::"
msgstr "添加另外两行::"

#: ../../extending/extending.rst:1301
msgid ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""
msgstr ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""

#: ../../extending/extending.rst:1304
msgid ""
"The ``#define`` is used to tell the header file that it is being included in"
" the exporting module, not a client module. Finally, the module's "
":c:data:`mod_exec <Py_mod_exec>` function must take care of initializing the"
" C API pointer array::"
msgstr ""
"``#define`` 被用来告知头文件它被包括在导出的模块中，而不是客户端模块。 最终，模块的 :c:data:`mod_exec "
"<Py_mod_exec>` 函数必须负责初始化 C API 指针数组::"

#: ../../extending/extending.rst:1308
msgid ""
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    /* 初始化 C API 指针数组 */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* 创建包含 API 指针数组地址的 Capsule */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../extending/extending.rst:1327
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array"
" would disappear when :c:func:`!PyInit_spam` terminates!"
msgstr ""
"请注意 ``PySpam_API`` 被声明为 ``static``；否则指针数组会在 :c:func:`!PyInit_spam` 终结时消失！"

#: ../../extending/extending.rst:1330
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks"
" like this::"
msgstr "头文件 :file:`spammodule.h` 里的一堆工作，看起来如下所示::"

#: ../../extending/extending.rst:1333
msgid ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Header file for spammodule */\n"
"\n"
"/* C API functions */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Total number of C API pointers */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* This section is used when compiling spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* This section is used in modules that use spammodule's API */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Return -1 on error, 0 on success.\n"
" * PyCapsule_Import will set an exception if there's an error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* 用于 spammodule 的头文件 */\n"
"\n"
"/* C API 函数 */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* C API 指针的总数 */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* 该节将在编译 spammodule.c 时使用 */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* 该节将在使用 spammodule 的 API 的模块中使用 */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* 出错时返回 -1，成功时返回 0。\n"
" * 如果有异常 PyCapsule_Import 将设置一个异常。\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"

#: ../../extending/extending.rst:1381
msgid ""
"All that a client module must do in order to have access to the function "
":c:func:`!PySpam_System` is to call the function (or rather macro) "
":c:func:`!import_spam` in its :c:data:`mod_exec <Py_mod_exec>` function::"
msgstr ""
"客户端模块要访问函数 :c:func:`!PySpam_System` 所必须做的全部事情就是在其 :c:data:`mod_exec "
"<Py_mod_exec>` 函数中调用函数 :c:func:`!import_spam` (更准确地说是宏)::"

#: ../../extending/extending.rst:1385
msgid ""
"static int\n"
"client_module_exec(PyObject *m)\n"
"{\n"
"    if (import_spam() < 0) {\n"
"        return -1;\n"
"    }\n"
"    /* additional initialization can happen here */\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"client_module_exec(PyObject *m)\n"
"{\n"
"    if (import_spam() < 0) {\n"
"        return -1;\n"
"    }\n"
"    /* 额外的初始化可在此进行 */\n"
"    return 0;\n"
"}"

#: ../../extending/extending.rst:1395
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h`"
" is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""
"这种方法的主要缺点是，文件 :file:`spammodule.h` 过于复杂。当然，对每个要导出的函数，基本结构是相似的，所以只需要学习一次。"

#: ../../extending/extending.rst:1399
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality,"
" which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of"
" Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c`"
" in the Python source code distribution)."
msgstr ""
"最后需要提醒的是Capsule提供了额外的功能，用于存储在Capsule里的指针的内存分配和释放。细节参考 Python/C API参考手册的章节 "
":ref:`capsules` 和Capsule的实现(在Python源码发行包的 :file:`Include/pycapsule.h` 和 "
":file:`Objects/pycapsule.c` )。"

#: ../../extending/extending.rst:1407
msgid "Footnotes"
msgstr "备注"

#: ../../extending/extending.rst:1408
msgid ""
"An interface for this function already exists in the standard module "
":mod:`os` --- it was chosen as a simple and straightforward example."
msgstr "这个函数的接口已经在标准模块 :mod:`os` 里了，这里作为一个简单而直接的例子。"

#: ../../extending/extending.rst:1411
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr "术语\"借用\"一个引用是不完全正确的：拥有者仍然有引用的拷贝。"

#: ../../extending/extending.rst:1414
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr "检查引用计数至少为1 **没有用** ，引用计数本身可以在已经释放的内存里，并有可能被其他对象所用。"

#: ../../extending/extending.rst:1418
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr "当你使用 \"旧式\" 风格调用约定时，这些保证不成立，尽管这依旧存在于很多旧代码中。"

#: ../../extending/extending.rst:593
msgid "PyObject_CallObject (C function)"
msgstr "PyObject_CallObject (C 函数)"

#: ../../extending/extending.rst:684
msgid "PyArg_ParseTuple (C function)"
msgstr "PyArg_ParseTuple (C 函数)"

#: ../../extending/extending.rst:776
msgid "PyArg_ParseTupleAndKeywords (C function)"
msgstr "PyArg_ParseTupleAndKeywords (C 函数)"

#: ../../extending/extending.rst:797
msgid "Philbrick, Geoff"
msgstr "Philbrick, Geoff"
