# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 8af080f2e6702c64bedd01873aed27e8_25aec74 <fd99d14239138a1f987c22e7736dde81_777475>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# Jiuh-star <jiuh.star@gmail.com>, 2021
# 高乐喆 <gaolezhe@outlook.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-01 21:24+0000\n"
"PO-Revision-Date: 2017-02-16 17:39+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Unicode对象和编解码器"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Unicode对象"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"自从python3.3中实现了 :pep:`393` "
"以来，Unicode对象在内部使用各种表示形式，以便在保持内存效率的同时处理完整范围的Unicode字符。对于所有代码点都低于128、256或65536的字符串，有一些特殊情况；否则，代码点必须低于1114112（这是完整的Unicode范围）。"

#: ../../c-api/unicode.rst:20
msgid ""
":c:type:`Py_UNICODE*` and UTF-8 representations are created on demand and "
"cached in the Unicode object.  The :c:type:`Py_UNICODE*` representation is "
"deprecated and inefficient."
msgstr ""

#: ../../c-api/unicode.rst:24
msgid ""
"Due to the transition between the old APIs and the new APIs, Unicode objects"
" can internally be in two states depending on how they were created:"
msgstr "由于旧API和新API之间的转换，Unicode对象内部可以处于两种状态，这取决于它们的创建方式："

#: ../../c-api/unicode.rst:27
msgid ""
"\"canonical\" Unicode objects are all objects created by a non-deprecated "
"Unicode API.  They use the most efficient representation allowed by the "
"implementation."
msgstr "“规范”Unicode对象是由非弃用的Unicode API创建的所有对象。它们使用实现所允许的最有效的表示。"

#: ../../c-api/unicode.rst:31
msgid ""
"\"legacy\" Unicode objects have been created through one of the deprecated "
"APIs (typically :c:func:`PyUnicode_FromUnicode`) and only bear the "
":c:type:`Py_UNICODE*` representation; you will have to call "
":c:func:`PyUnicode_READY` on them before calling any other API."
msgstr ""

#: ../../c-api/unicode.rst:37
msgid ""
"The \"legacy\" Unicode object will be removed in Python 3.12 with deprecated"
" APIs. All Unicode objects will be \"canonical\" since then. See :pep:`623` "
"for more information."
msgstr ""

#: ../../c-api/unicode.rst:43
msgid "Unicode Type"
msgstr "Unicode类型"

#: ../../c-api/unicode.rst:45
msgid ""
"These are the basic Unicode object types used for the Unicode implementation"
" in Python:"
msgstr "以下是用于Python中Unicode实现的基本Unicode对象类型："

#: ../../c-api/unicode.rst:52
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"这些类型是无符号整数类型的类型定义，其宽度足以分别包含 32 位、16 位和 8 位字符。 当需要处理单个 Unicode 字符时，请使用 "
":c:type:`Py_UCS4`。"

#: ../../c-api/unicode.rst:61
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr "这是 :c:type:`wchar_t` 的类型定义，根据平台的不同它可能为 16 位类型或 32 位类型。"

#: ../../c-api/unicode.rst:64
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr "在以前的版本中，这是16位类型还是32位类型，这取决于您在构建时选择的是“窄”还是“宽”Unicode版本的Python。"

#: ../../c-api/unicode.rst:74
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"这些关于 :c:type:`PyObject` 的子类型表示了一个 Python Unicode 对象。 "
"在几乎所有情形下，它们不应该被直接使用，因为所有处理 Unicode 对象的 API 函数都接受并返回 :c:type:`PyObject` "
"类型的指针。"

#: ../../c-api/unicode.rst:83
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type."
"  It is exposed to Python code as ``str``."
msgstr ""
"这个 :c:type:`PyTypeObject` 实例代表 Python Unicode 类型。 它作为 ``str`` 公开给 Python 代码。"

#: ../../c-api/unicode.rst:87
msgid ""
"The following APIs are really C macros and can be used to do fast checks and"
" to access internal read-only data of Unicode objects:"
msgstr ""

#: ../../c-api/unicode.rst:92
msgid ""
"Return true if the object *o* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr "如果对象*o*是Unicode对象或Unicode子类型的实例，则返回“真\"。此函数始终成功。"

#: ../../c-api/unicode.rst:98
msgid ""
"Return true if the object *o* is a Unicode object, but not an instance of a "
"subtype.  This function always succeeds."
msgstr "如果对象*o*是Unicode对象，但不是子类型的实例，则返回“真”。此函数始终成功。"

#: ../../c-api/unicode.rst:104
msgid ""
"Ensure the string object *o* is in the \"canonical\" representation.  This "
"is required before using any of the access macros described below."
msgstr "确保字符串对象*o*处于“规范”表示形式。在使用下面描述的任何访问宏之前，这是必需的。"

#: ../../c-api/unicode.rst:109
msgid ""
"Returns ``0`` on success and ``-1`` with an exception set on failure, which "
"in particular happens if memory allocation fails."
msgstr ""

#: ../../c-api/unicode.rst:115
msgid "This API will be removed with :c:func:`PyUnicode_FromUnicode`."
msgstr ""

#: ../../c-api/unicode.rst:120
msgid ""
"Return the length of the Unicode string, in code points.  *o* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr "返回Unicode字符串的长度（以代码点为单位）*o*必须是“规范”表达方式中的Unicode对象（未选中）。"

#: ../../c-api/unicode.rst:130
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use "
":c:func:`PyUnicode_KIND` to select the right macro.  Make sure "
":c:func:`PyUnicode_READY` has been called before accessing this."
msgstr ""

#: ../../c-api/unicode.rst:144
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "返回 :c:func:`PyUnicode_KIND` 宏的值。"

#: ../../c-api/unicode.rst:149
msgid "``PyUnicode_WCHAR_KIND`` is deprecated."
msgstr "``PyUnicode_WCHAR_KIND`` 已被弃用。"

#: ../../c-api/unicode.rst:154
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  *o* "
"has to be a Unicode object in the \"canonical\" representation (not "
"checked)."
msgstr ""
"返回一个PyUnicode类常量（见上文），指示此Unicode对象用于存储其数据的每个字符的字节数*o*必须是“规范”表达方式中的Unicode对象（未选中）。"

#: ../../c-api/unicode.rst:165
msgid ""
"Return a void pointer to the raw Unicode buffer.  *o* has to be a Unicode "
"object in the \"canonical\" representation (not checked)."
msgstr "返回指向原始Unicode缓冲区的空指针*o*必须是“规范”表达方式中的Unicode对象（未选中）。"

#: ../../c-api/unicode.rst:174
msgid ""
"Write into a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  This macro does not do any sanity checks and is "
"intended for usage in loops.  The caller should cache the *kind* value and "
"*data* pointer as obtained from other macro calls.  *index* is the index in "
"the string (starts at 0) and *value* is the new code point value which "
"should be written to that location."
msgstr ""

#: ../../c-api/unicode.rst:186
msgid ""
"Read a code point from a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr "从规范表示的 *data* (如同用 :c:func:`PyUnicode_DATA` 获取) 中读取一个码位。 不会执行检查或就绪调用。"

#: ../../c-api/unicode.rst:194
msgid ""
"Read a character from a Unicode object *o*, which must be in the "
"\"canonical\" representation.  This is less efficient than "
":c:func:`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"从 Unicode 对象 *o* 读取一个字符，必须使用“规范”表示形式。 如果你执行行多次连续读取则此函数的效率将低于 "
":c:func:`PyUnicode_READ`。"

#: ../../c-api/unicode.rst:203
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *o*, which must be in the \"canonical\" representation.  This is "
"always an approximation but more efficient than iterating over the string."
msgstr "返回适合于基于*o*创建另一个字符串的最大代码点，该字符串必须在“规范”表达方式中。这始终是一种近似，但比在字符串上迭代更有效。"

#: ../../c-api/unicode.rst:212
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units).  *o* has to be a "
"Unicode object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:218 ../../c-api/unicode.rst:228
#: ../../c-api/unicode.rst:772
msgid ""
"Part of the old-style Unicode API, please migrate to using "
":c:func:`PyUnicode_GET_LENGTH`."
msgstr "旧式 Unicode API 的一部分，请迁移到使用 :c:func:`PyUnicode_GET_LENGTH`。"

#: ../../c-api/unicode.rst:223
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation in "
"bytes.  *o* has to be a Unicode object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:234
msgid ""
"Return a pointer to a :c:type:`Py_UNICODE` representation of the object.  "
"The returned buffer is always terminated with an extra null code point.  It "
"may also contain embedded null code points, which would cause the string to "
"be truncated when used in most C functions.  The ``AS_DATA`` form casts the "
"pointer to :c:type:`const char *`.  The *o* argument has to be a Unicode "
"object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:241
msgid ""
"This macro is now inefficient -- because in many cases the "
":c:type:`Py_UNICODE` representation does not exist and needs to be created "
"-- and can fail (return ``NULL`` with an exception set).  Try to port the "
"code to use the new :c:func:`PyUnicode_nBYTE_DATA` macros or use "
":c:func:`PyUnicode_WRITE` or :c:func:`PyUnicode_READ`."
msgstr ""

#: ../../c-api/unicode.rst:250
msgid ""
"Part of the old-style Unicode API, please migrate to using the "
":c:func:`PyUnicode_nBYTE_DATA` family of macros."
msgstr "旧式 Unicode API 的一部分，请迁移到使用 :c:func:`PyUnicode_nBYTE_DATA` 宏族。"

#: ../../c-api/unicode.rst:255
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr "如果字符串按照语言定义是合法的标识符则返回 ``1``，参见 :ref:`identifiers` 小节。 否则返回 ``0``。"

#: ../../c-api/unicode.rst:258
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr "如果字符串尚未就绪则此函数不会再调用 :c:func:`Py_FatalError`。"

#: ../../c-api/unicode.rst:264
msgid "Unicode Character Properties"
msgstr "Unicode字符属性"

#: ../../c-api/unicode.rst:266
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr "Unicode提供了许多不同的字符特性。最常需要的宏可以通过这些宏获得，这些宏根据Python配置映射到C函数。"

#: ../../c-api/unicode.rst:273
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr "根据 *ch* 是否为空白字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:278
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr "根据 *ch* 是否为小写字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:283
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr "根据 *ch* 是否为大写字符返回 ``1`` 或 ``0``"

#: ../../c-api/unicode.rst:288
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr "根据 *ch* 是否为标题化的大小写返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:293
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr "根据 *ch* 是否为换行类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:298
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "根据 *ch* 是否为十进制数字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:303
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "根据 *ch* 是否为数码类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:308
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr "根据 *ch* 是否为数值类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:313
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr "根据 *ch* 是否为字母类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:318
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric "
"character."
msgstr "根据 *ch* 是否为字母数字类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:323
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character. "
"Nonprintable characters are those characters defined in the Unicode "
"character database as \"Other\" or \"Separator\", excepting the ASCII space "
"(0x20) which is considered printable.  (Note that printable characters in "
"this context are those which should not be escaped when :func:`repr` is "
"invoked on a string. It has no bearing on the handling of strings written to"
" :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"根据 *ch* 是否为可打印字符返回 ``1`` 或``0``。 不可打印字符是指在 Unicode 字符数据库中被定义为 \"Other\" 或 "
"\"Separator\" 的字符，例外情况是 ASCII 空格 (0x20) 被视为可打印字符。 (请注意在此语境下可打印字符是指当在字符串上发起调用"
" :func:`repr` 时不应被转义的字符。 它们字符串写入 :data:`sys.stdout` 或 :data:`sys.stderr` "
"时所需的处理无关)。"

#: ../../c-api/unicode.rst:332
msgid "These APIs can be used for fast direct character conversions:"
msgstr "这些 API 可用于快速直接的字符转换："

#: ../../c-api/unicode.rst:337
msgid "Return the character *ch* converted to lower case."
msgstr "返回转换为小写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:339 ../../c-api/unicode.rst:347
#: ../../c-api/unicode.rst:355
msgid "This function uses simple case mappings."
msgstr "此函数使用简单的大小写映射。"

#: ../../c-api/unicode.rst:345
msgid "Return the character *ch* converted to upper case."
msgstr "返回转换为大写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:353
msgid "Return the character *ch* converted to title case."
msgstr "返回转换为标题大小写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:361
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:367
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1``"
" if this is not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:373
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:377
msgid "These APIs can be used to work with surrogates:"
msgstr "这些 API 可被用来操作代理项："

#: ../../c-api/unicode.rst:381
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "检测 *ch* 是否为代理项 (``0xD800 <= ch <= 0xDFFF``)。"

#: ../../c-api/unicode.rst:385
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "检测 *ch* 是否为高代理项 (``0xD800 <= ch <= 0xDBFF``)。"

#: ../../c-api/unicode.rst:389
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "检测 *ch* 是否为低代理项 (``0xDC00 <= ch <= 0xDFFF``)。"

#: ../../c-api/unicode.rst:393
msgid ""
"Join two surrogate characters and return a single Py_UCS4 value. *high* and "
"*low* are respectively the leading and trailing surrogates in a surrogate "
"pair."
msgstr ""

#: ../../c-api/unicode.rst:399
msgid "Creating and accessing Unicode strings"
msgstr "创建和访问 Unicode 字符串"

#: ../../c-api/unicode.rst:401
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr "要创建 Unicode 对象和访问其基本序列属性，请使用这些 API："

#: ../../c-api/unicode.rst:406
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up"
" to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"创建一个新的 Unicode 对象。 *maxchar* 应为可放入字符串的实际最大码位。 作为一个近似值，它可被向上舍入到序列 127, 255, "
"65535, 1114111 中最接近的值。"

#: ../../c-api/unicode.rst:410
msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr "这是分配新的 Unicode 对象的推荐方式。 使用此函数创建的对象不可改变大小。"

#: ../../c-api/unicode.rst:419
msgid ""
"Create a new Unicode object with the given *kind* (possible values are "
":c:macro:`PyUnicode_1BYTE_KIND` etc., as returned by "
":c:func:`PyUnicode_KIND`).  The *buffer* must point to an array of *size* "
"units of 1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"以给定的 *kind* 创建一个新的 Unicode 对象（可能的值为 :c:macro:`PyUnicode_1BYTE_KIND` 等，即 "
":c:func:`PyUnicode_KIND` 所返回的值）。 *buffer* 必须指向由此分类所给出的，以每字符 1, 2 或 4 字节单位的 "
"*size* 大小的数组。"

#: ../../c-api/unicode.rst:429
msgid ""
"Create a Unicode object from the char buffer *u*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. If the buffer is not ``NULL``, the return value might be a shared "
"object, i.e. modification of the data is not allowed."
msgstr ""

#: ../../c-api/unicode.rst:434
msgid ""
"If *u* is ``NULL``, this function behaves like "
":c:func:`PyUnicode_FromUnicode` with the buffer set to ``NULL``.  This usage"
" is deprecated in favor of :c:func:`PyUnicode_New`, and will be removed in "
"Python 3.12."
msgstr ""

#: ../../c-api/unicode.rst:441
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*u*."
msgstr "根据 UTF-8 编码的以空值结束的字符缓冲区 *u* 创建一个 Unicode 对象。"

#: ../../c-api/unicode.rst:447
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string. The following format characters are allowed:"
msgstr ""

#: ../../c-api/unicode.rst:462
msgid "Format Characters"
msgstr "格式字符"

#: ../../c-api/unicode.rst:462
msgid "Type"
msgstr "类型"

#: ../../c-api/unicode.rst:462
msgid "Comment"
msgstr "注释"

#: ../../c-api/unicode.rst:464
msgid ":attr:`%%`"
msgstr ":attr:`%%`"

#: ../../c-api/unicode.rst:464
msgid "*n/a*"
msgstr "*不适用*"

#: ../../c-api/unicode.rst:464
msgid "The literal % character."
msgstr "文字%字符。"

#: ../../c-api/unicode.rst:466
msgid ":attr:`%c`"
msgstr ":attr:`%c`"

#: ../../c-api/unicode.rst:466 ../../c-api/unicode.rst:469
#: ../../c-api/unicode.rst:502 ../../c-api/unicode.rst:505
msgid "int"
msgstr "int"

#: ../../c-api/unicode.rst:466
msgid "A single character, represented as a C int."
msgstr "单个字符，表示为C 语言的整型。"

#: ../../c-api/unicode.rst:469
msgid ":attr:`%d`"
msgstr ":attr:`%d`"

#: ../../c-api/unicode.rst:469
msgid "Equivalent to ``printf(\"%d\")``. [1]_"
msgstr "相当于 ``printf(\"%d\")``. [1]_"

#: ../../c-api/unicode.rst:472
msgid ":attr:`%u`"
msgstr ":attr:`%u`"

#: ../../c-api/unicode.rst:472
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/unicode.rst:472
msgid "Equivalent to ``printf(\"%u\")``. [1]_"
msgstr "相当于 ``printf(\"%u\")``. [1]_"

#: ../../c-api/unicode.rst:475
msgid ":attr:`%ld`"
msgstr ":attr:`%ld`"

#: ../../c-api/unicode.rst:475 ../../c-api/unicode.rst:478
msgid "long"
msgstr "长整型"

#: ../../c-api/unicode.rst:475
msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
msgstr "相当于 ``printf(\"%ld\")``. [1]_"

#: ../../c-api/unicode.rst:478
msgid ":attr:`%li`"
msgstr ":attr:`%li`"

#: ../../c-api/unicode.rst:478
msgid "Equivalent to ``printf(\"%li\")``. [1]_"
msgstr "相当于 ``printf(\"%li\")``. [1]_"

#: ../../c-api/unicode.rst:481
msgid ":attr:`%lu`"
msgstr ":attr:`%lu`"

#: ../../c-api/unicode.rst:481
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/unicode.rst:481
msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
msgstr "相当于 ``printf(\"%lu\")``. [1]_"

#: ../../c-api/unicode.rst:484
msgid ":attr:`%lld`"
msgstr ":attr:`%lld`"

#: ../../c-api/unicode.rst:484 ../../c-api/unicode.rst:487
msgid "long long"
msgstr "long long"

#: ../../c-api/unicode.rst:484
msgid "Equivalent to ``printf(\"%lld\")``. [1]_"
msgstr "相当于 ``printf(\"%lld\")``. [1]_"

#: ../../c-api/unicode.rst:487
msgid ":attr:`%lli`"
msgstr ":attr:`%lli`"

#: ../../c-api/unicode.rst:487
msgid "Equivalent to ``printf(\"%lli\")``. [1]_"
msgstr "相当于 ``printf(\"%lli\")``. [1]_"

#: ../../c-api/unicode.rst:490
msgid ":attr:`%llu`"
msgstr ":attr:`%llu`"

#: ../../c-api/unicode.rst:490
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../c-api/unicode.rst:490
msgid "Equivalent to ``printf(\"%llu\")``. [1]_"
msgstr "相当于 ``printf(\"%llu\")``. [1]_"

#: ../../c-api/unicode.rst:493
msgid ":attr:`%zd`"
msgstr ":attr:`%zd`"

#: ../../c-api/unicode.rst:493 ../../c-api/unicode.rst:496
msgid ":c:type:`\\ Py_ssize_t`"
msgstr ":c:type:`\\ Py_ssize_t`"

#: ../../c-api/unicode.rst:493
msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
msgstr "相当于 ``printf(\"%zd\")``. [1]_"

#: ../../c-api/unicode.rst:496
msgid ":attr:`%zi`"
msgstr ":attr:`%zi`"

#: ../../c-api/unicode.rst:496
msgid "Equivalent to ``printf(\"%zi\")``. [1]_"
msgstr "相当于 ``printf(\"%zi\")``. [1]_"

#: ../../c-api/unicode.rst:499
msgid ":attr:`%zu`"
msgstr ":attr:`%zu`"

#: ../../c-api/unicode.rst:499
msgid "size_t"
msgstr "size_t"

#: ../../c-api/unicode.rst:499
msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
msgstr "相当于 ``printf(\"%zu\")``. [1]_"

#: ../../c-api/unicode.rst:502
msgid ":attr:`%i`"
msgstr ":attr:`%i`"

#: ../../c-api/unicode.rst:502
msgid "Equivalent to ``printf(\"%i\")``. [1]_"
msgstr "相当于 ``printf(\"%i\")``. [1]_"

#: ../../c-api/unicode.rst:505
msgid ":attr:`%x`"
msgstr ":attr:`%x`"

#: ../../c-api/unicode.rst:505
msgid "Equivalent to ``printf(\"%x\")``. [1]_"
msgstr "相当于 ``printf(\"%x\")``. [1]_"

#: ../../c-api/unicode.rst:508
msgid ":attr:`%s`"
msgstr ":attr:`%s`"

#: ../../c-api/unicode.rst:508
msgid "const char\\*"
msgstr "const char\\*"

#: ../../c-api/unicode.rst:508
msgid "A null-terminated C character array."
msgstr "以 null 为终止符的 C 字符数组。"

#: ../../c-api/unicode.rst:511
msgid ":attr:`%p`"
msgstr ":attr:`%p`"

#: ../../c-api/unicode.rst:511
msgid "const void\\*"
msgstr "const void\\*"

#: ../../c-api/unicode.rst:511
msgid ""
"The hex representation of a C pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"一个 C 指针的十六进制表示形式。 基本等价于 ``printf(\"%p\")`` 但它会确保以字面值 ``0x`` 开头，不论系统平台上 "
"``printf`` 的输出是什么。"

#: ../../c-api/unicode.rst:519
msgid ":attr:`%A`"
msgstr ":attr:`%A`"

#: ../../c-api/unicode.rst:519 ../../c-api/unicode.rst:522
#: ../../c-api/unicode.rst:531 ../../c-api/unicode.rst:534
msgid "PyObject\\*"
msgstr "PyObject\\*"

#: ../../c-api/unicode.rst:519
msgid "The result of calling :func:`ascii`."
msgstr ":func:`ascii` 调用的结果。"

#: ../../c-api/unicode.rst:522
msgid ":attr:`%U`"
msgstr ":attr:`%U`"

#: ../../c-api/unicode.rst:522
msgid "A Unicode object."
msgstr "一个 Unicode 对象。"

#: ../../c-api/unicode.rst:524
msgid ":attr:`%V`"
msgstr ":attr:`%V`"

#: ../../c-api/unicode.rst:524
msgid "PyObject\\*, const char\\*"
msgstr ""

#: ../../c-api/unicode.rst:524
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"一个 Unicode 对象 (可以为 ``NULL``) 和一个以空值结束的 C 字符数组作为第二个形参（如果第一个形参为 "
"``NULL``，第二个形参将被使用）。"

#: ../../c-api/unicode.rst:531
msgid ":attr:`%S`"
msgstr ":attr:`%S`"

#: ../../c-api/unicode.rst:531
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "调用 :c:func:`PyObject_Str` 的结果。"

#: ../../c-api/unicode.rst:534
msgid ":attr:`%R`"
msgstr ":attr:`%R`"

#: ../../c-api/unicode.rst:534
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "调用 :c:func:`PyObject_Repr` 的结果。"

#: ../../c-api/unicode.rst:538
msgid ""
"An unrecognized format character causes all the rest of the format string to"
" be copied as-is to the result string, and any extra arguments discarded."
msgstr ""

#: ../../c-api/unicode.rst:542
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes for ``\"%s\"`` and ``\"%V\"`` "
"(if the ``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""

#: ../../c-api/unicode.rst:548
msgid ""
"For integer specifiers (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, i, x): "
"the 0-conversion flag has effect even when a precision is given."
msgstr ""

#: ../../c-api/unicode.rst:551
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "增加了对 ``\"%lld\"`` 和 ``\"%llu\"`` 的支持。"

#: ../../c-api/unicode.rst:554
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "增加了对 ``\"%li\"``, ``\"%lli\"`` 和 ``\"%zi\"`` 的支持。"

#: ../../c-api/unicode.rst:557
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr "增加了对 ``\"%s\"``, ``\"%A\"``, ``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` 的宽度和精度格式符支持。"

#: ../../c-api/unicode.rst:564
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two"
" arguments."
msgstr "等同于 :c:func:`PyUnicode_FromFormat` 但它将接受恰好两个参数。"

#: ../../c-api/unicode.rst:571
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "将一个已编码的对象 *obj* 解码为 Unicode 对象。"

#: ../../c-api/unicode.rst:573
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using"
" the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` 和其他 :term:`字节类对象 <bytes-like object>` "
"将按照给定的 *encoding* 来解码并使用由 *errors* 定义的错误处理方式。 两者均可为 ``NULL`` 即让接口使用默认值（请参阅 "
":ref:`builtincodecs` 了解详情）。"

#: ../../c-api/unicode.rst:579
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be"
" set."
msgstr "所有其他对象，包括 Unicode 对象，都将导致设置 :exc:`TypeError`。"

#: ../../c-api/unicode.rst:582
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr "如有错误该 API 将返回 ``NULL``。 调用方要负责递减指向所返回对象的引用。"

#: ../../c-api/unicode.rst:588
msgid "Return the length of the Unicode object, in code points."
msgstr "返回 Unicode 对象码位的长度。"

#: ../../c-api/unicode.rst:599
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to "
":c:func:`memcpy` if possible.  Returns ``-1`` and sets an exception on "
"error, otherwise returns the number of copied characters."
msgstr ""

#: ../../c-api/unicode.rst:610
msgid ""
"Fill a string with a character: write *fill_char* into "
"``unicode[start:start+length]``."
msgstr "使用一个字符填充字符串：将 *fill_char* 写入 ``unicode[start:start+length]``。"

#: ../../c-api/unicode.rst:613
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr "如果 *fill_char* 值大于字符串最大字符值，或者如果字符串有 1 以上的引用将执行失败。"

#: ../../c-api/unicode.rst:616
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr "返回写入的字符数量，或者在出错时返回 ``-1`` 并引发一个异常。"

#: ../../c-api/unicode.rst:625
msgid ""
"Write a character to a string.  The string must have been created through "
":c:func:`PyUnicode_New`.  Since Unicode strings are supposed to be "
"immutable, the string must not be shared, or have been hashed yet."
msgstr ""
"将一个字符写入到字符串。 字符串必须通过 :c:func:`PyUnicode_New` 创建。 由于 Unicode "
"字符串应当是不可变的，因此该字符串不能被共享，或是被哈希。"

#: ../../c-api/unicode.rst:629
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object can be modified safely (i.e. that it "
"its reference count is one)."
msgstr "该函数将检查 *unicode* 是否为 Unicode 对象，索引是否未越界，并且对象是否可被安全地修改（即其引用计数为一）。"

#: ../../c-api/unicode.rst:638
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to the macro "
"version :c:func:`PyUnicode_READ_CHAR`."
msgstr ""

#: ../../c-api/unicode.rst:648
msgid ""
"Return a substring of *str*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported."
msgstr "返回 *str* 的一个子串，从字符索引 *start* (包括) 到字符索引 *end* (不包括)。 不支持负索引号。"

#: ../../c-api/unicode.rst:657
msgid ""
"Copy the string *u* into a UCS4 buffer, including a null character, if "
"*copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*u*).  *buffer* is returned on success."
msgstr ""
"将字符串 *u* 拷贝到一个 UCS4 缓冲区，包括一个空字符，如果设置了 *copy_null* 的话。 出错时返回 ``NULL`` "
"并设置一个异常（特别是当 *buflen* 小于 *u* 的长度时，:exc:`SystemError` 将被设置）。 成功时返回 *buffer*。"

#: ../../c-api/unicode.rst:667
msgid ""
"Copy the string *u* into a new UCS4 buffer that is allocated using "
":c:func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a "
":exc:`MemoryError` set.  The returned buffer always has an extra null code "
"point appended."
msgstr ""
"将字符串 *u* 拷贝到使用 :c:func:`PyMem_Malloc` 分配的新 UCS4 缓冲区。 如果执行失败，将返回 ``NULL`` 并设置"
" :exc:`MemoryError`。 返回的缓冲区将总是会添加一个额外的空码位。"

#: ../../c-api/unicode.rst:676
msgid "Deprecated Py_UNICODE APIs"
msgstr ""

#: ../../c-api/unicode.rst:680
msgid ""
"These API functions are deprecated with the implementation of :pep:`393`. "
"Extension modules can continue using them, as they will not be removed in "
"Python 3.x, but need to be aware that their use can now cause performance "
"and memory hits."
msgstr ""

#: ../../c-api/unicode.rst:687
msgid ""
"Create a Unicode object from the Py_UNICODE buffer *u* of the given size. "
"*u* may be ``NULL`` which causes the contents to be undefined. It is the "
"user's responsibility to fill in the needed data.  The buffer is copied into"
" the new object."
msgstr ""

#: ../../c-api/unicode.rst:692
msgid ""
"If the buffer is not ``NULL``, the return value might be a shared object. "
"Therefore, modification of the resulting Unicode object is only allowed when"
" *u* is ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:696
msgid ""
"If the buffer is ``NULL``, :c:func:`PyUnicode_READY` must be called once the"
" string content has been filled before using any of the access macros such "
"as :c:func:`PyUnicode_KIND`."
msgstr ""

#: ../../c-api/unicode.rst:703
msgid ""
"Part of the old-style Unicode API, please migrate to using "
":c:func:`PyUnicode_FromKindAndData`, :c:func:`PyUnicode_FromWideChar`, or "
":c:func:`PyUnicode_New`."
msgstr ""

#: ../../c-api/unicode.rst:708
msgid ""
"Return a read-only pointer to the Unicode object's internal "
":c:type:`Py_UNICODE` buffer, or ``NULL`` on error. This will create the "
":c:type:`Py_UNICODE*` representation of the object if it is not yet "
"available. The buffer is always terminated with an extra null code point. "
"Note that the resulting :c:type:`Py_UNICODE` string may also contain "
"embedded null code points, which would cause the string to be truncated when"
" used in most C functions."
msgstr ""

#: ../../c-api/unicode.rst:720 ../../c-api/unicode.rst:748
msgid ""
"Part of the old-style Unicode API, please migrate to using "
":c:func:`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, "
":c:func:`PyUnicode_ReadChar` or similar new APIs."
msgstr ""

#: ../../c-api/unicode.rst:726
msgid ""
"Create a Unicode object by replacing all decimal digits in "
":c:type:`Py_UNICODE` buffer of the given *size* by ASCII digits 0--9 "
"according to their decimal value.  Return ``NULL`` if an exception occurs."
msgstr ""

#: ../../c-api/unicode.rst:732
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`Py_UNICODE_TODECIMAL`."
msgstr ""

#: ../../c-api/unicode.rst:737
msgid ""
"Like :c:func:`PyUnicode_AsUnicode`, but also saves the :c:func:`Py_UNICODE` "
"array length (excluding the extra null terminator) in *size*. Note that the "
"resulting :c:type:`Py_UNICODE*` string may contain embedded null code "
"points, which would cause the string to be truncated when used in most C "
"functions."
msgstr ""

#: ../../c-api/unicode.rst:753
msgid ""
"Create a copy of a Unicode string ending with a null code point. Return "
"``NULL`` and raise a :exc:`MemoryError` exception on memory allocation "
"failure, otherwise return a new allocated buffer (use :c:func:`PyMem_Free` "
"to free the buffer). Note that the resulting :c:type:`Py_UNICODE*` string "
"may contain embedded null code points, which would cause the string to be "
"truncated when used in most C functions."
msgstr ""

#: ../../c-api/unicode.rst:762
msgid ""
"Please migrate to using :c:func:`PyUnicode_AsUCS4Copy` or similar new APIs."
msgstr ""

#: ../../c-api/unicode.rst:767
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units)."
msgstr ""

#: ../../c-api/unicode.rst:777
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return"
" the reference with incremented refcount."
msgstr ""

#: ../../c-api/unicode.rst:781
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr "非 Unicode 或其子类型的对象将导致 :exc:`TypeError`。"

#: ../../c-api/unicode.rst:785
msgid "Locale Encoding"
msgstr "语言区域编码格式"

#: ../../c-api/unicode.rst:787
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr "当前语言区域编码格式可被用来解码来自操作系统的文本。"

#: ../../c-api/unicode.rst:794
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a"
" null character but cannot contain embedded null characters."
msgstr ""
"解码字符串在 Android 和 VxWorks 上使用 UTF-8，在其他平台上则使用当前语言区域编码格式。 支持的错误处理句柄有 "
"``\"strict\"`` 和 ``\"surrogateescape\"`` (:pep:`383`)。 如果 *errors* 为 "
"``NULL`` 则解码器将使用 ``\"strict\"`` 错误处理句柄。 *str* 必须以一个空字符结束但不可包含嵌入的空字符。"

#: ../../c-api/unicode.rst:801
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from "
":c:data:`Py_FileSystemDefaultEncoding` (the locale encoding read at Python "
"startup)."
msgstr ""

#: ../../c-api/unicode.rst:805 ../../c-api/unicode.rst:841
msgid "This function ignores the Python UTF-8 mode."
msgstr ""

#: ../../c-api/unicode.rst:809 ../../c-api/unicode.rst:913
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "The :c:func:`Py_DecodeLocale` 函数。"

#: ../../c-api/unicode.rst:813
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_DecodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"此函数现在也会为 ``surrogateescape`` 错误处理句柄使用当前语言区域编码格式，但在 Android 上例外。 "
"在之前版本中，:c:func:`Py_DecodeLocale` 将被用于 ``surrogateescape``，而当前语言区域编码格式将被用于 "
"``strict``。"

#: ../../c-api/unicode.rst:822
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`strlen`."
msgstr ""

#: ../../c-api/unicode.rst:830
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a "
":class:`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"编码 Unicode 对象在 Android 和 VxWorks 上使用 UTF-8，在其他平台上使用当前语言区域编码格式。 支持的错误处理句柄有 "
"``\"strict\"`` 和 ``\"surrogateescape\"`` (:pep:`383`)。 如果 *errors* 为 "
"``NULL`` 则编码器将使用 ``\"strict\"`` 错误处理句柄。 返回一个 :class:`bytes` 对象。 *unicode* "
"不可包含嵌入的空字符。"

#: ../../c-api/unicode.rst:837
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to "
":c:data:`Py_FileSystemDefaultEncoding` (the locale encoding read at Python "
"startup)."
msgstr ""

#: ../../c-api/unicode.rst:845 ../../c-api/unicode.rst:949
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr ":c:func:`Py_EncodeLocale` 函数。"

#: ../../c-api/unicode.rst:849
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_EncodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"此函数现在也会为 ``surrogateescape`` 错误处理句柄使用当前语言区域编码格式，但在 Android 上例外。 "
"在之前版本中，:c:func:`Py_EncodeLocale` 将被用于 ``surrogateescape``，而当前语言区域编码格式将被用于 "
"``strict``。"

#: ../../c-api/unicode.rst:858
msgid "File System Encoding"
msgstr "文件系统编码格式"

#: ../../c-api/unicode.rst:860
msgid ""
"To encode and decode file names and other environment strings, "
":c:data:`Py_FileSystemDefaultEncoding` should be used as the encoding, and "
":c:data:`Py_FileSystemDefaultEncodeErrors` should be used as the error "
"handler (:pep:`383` and :pep:`529`). To encode file names to :class:`bytes` "
"during argument parsing, the ``\"O&\"`` converter should be used, passing "
":c:func:`PyUnicode_FSConverter` as the conversion function:"
msgstr ""

#: ../../c-api/unicode.rst:869
msgid ""
"ParseTuple converter: encode :class:`str` objects -- obtained directly or "
"through the :class:`os.PathLike` interface -- to :class:`bytes` using "
":c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes` objects are output as-"
"is. *result* must be a :c:type:`PyBytesObject*` which must be released when "
"it is no longer used."
msgstr ""

#: ../../c-api/unicode.rst:877 ../../c-api/unicode.rst:894
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../c-api/unicode.rst:880
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"``"
" converter should be used, passing :c:func:`PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"要在参数解析期间将文件名解码为 :class:`str`，应当使用 ``\"O&\"`` 转换器，传入 "
":c:func:`PyUnicode_FSDecoder` 作为转换函数："

#: ../../c-api/unicode.rst:886
msgid ""
"ParseTuple converter: decode :class:`bytes` objects -- obtained either "
"directly or indirectly through the :class:`os.PathLike` interface -- to "
":class:`str` using :c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` "
"objects are output as-is. *result* must be a :c:type:`PyUnicodeObject*` "
"which must be released when it is no longer used."
msgstr ""

#: ../../c-api/unicode.rst:900
msgid ""
"Decode a string using :c:data:`Py_FileSystemDefaultEncoding` and the "
":c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
msgstr ""

#: ../../c-api/unicode.rst:903 ../../c-api/unicode.rst:924
#: ../../c-api/unicode.rst:940
msgid ""
"If :c:data:`Py_FileSystemDefaultEncoding` is not set, fall back to the "
"locale encoding."
msgstr ""

#: ../../c-api/unicode.rst:906
msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to decode a string"
" from the current locale encoding, use "
":c:func:`PyUnicode_DecodeLocaleAndSize`."
msgstr ""

#: ../../c-api/unicode.rst:915 ../../c-api/unicode.rst:929
#: ../../c-api/unicode.rst:953
msgid "Use :c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
msgstr ""

#: ../../c-api/unicode.rst:921
msgid ""
"Decode a null-terminated string using :c:data:`Py_FileSystemDefaultEncoding`"
" and the :c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
msgstr ""

#: ../../c-api/unicode.rst:927
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` if you know the string "
"length."
msgstr ""

#: ../../c-api/unicode.rst:935
msgid ""
"Encode a Unicode object to :c:data:`Py_FileSystemDefaultEncoding` with the "
":c:data:`Py_FileSystemDefaultEncodeErrors` error handler, and return "
":class:`bytes`. Note that the resulting :class:`bytes` object may contain "
"null bytes."
msgstr ""

#: ../../c-api/unicode.rst:943
msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to encode a string"
" to the current locale encoding, use :c:func:`PyUnicode_EncodeLocale`."
msgstr ""

#: ../../c-api/unicode.rst:957
msgid "wchar_t Support"
msgstr "wchar_t 支持"

#: ../../c-api/unicode.rst:959
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr "在受支持的平台上支持 :c:type:`wchar_t`:"

#: ../../c-api/unicode.rst:963
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *w* of the given "
"*size*. Passing ``-1`` as the *size* indicates that the function must itself"
" compute the length, using wcslen. Return ``NULL`` on failure."
msgstr ""
"根据给定 *size* 的 :c:type:`wchar_t` 缓冲区 *w* 创建一个 Unicode 对象。 传入 ``-1`` 作为 *size*"
" 表示该函数必须使用 wcslen 自行计算缓冲区长度。 失败时将返回 ``NULL``。"

#: ../../c-api/unicode.rst:971
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *w*.  At "
"most *size* :c:type:`wchar_t` characters are copied (excluding a possibly "
"trailing null termination character).  Return the number of "
":c:type:`wchar_t` characters copied or ``-1`` in case of an error.  Note "
"that the resulting :c:type:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the "
":c:type:`wchar_t*` string is null-terminated in case this is required by the"
" application. Also, note that the :c:type:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with"
" most C functions."
msgstr ""

#: ../../c-api/unicode.rst:984
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the "
":c:type:`wchar_t*` string contains null characters a :exc:`ValueError` is "
"raised."
msgstr ""

#: ../../c-api/unicode.rst:992
msgid ""
"Returns a buffer allocated by :c:func:`PyMem_Alloc` (use "
":c:func:`PyMem_Free` to free it) on success. On error, returns ``NULL`` and "
"*\\*size* is undefined. Raises a :exc:`MemoryError` if memory allocation is "
"failed."
msgstr ""

#: ../../c-api/unicode.rst:999
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:type:`wchar_t*` "
"string contains null characters."
msgstr ""

#: ../../c-api/unicode.rst:1007
msgid "Built-in Codecs"
msgstr "内置编解码器"

#: ../../c-api/unicode.rst:1009
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr "Python 提供了一组以 C 编写以保证运行速度的内置编解码器。 所有这些编解码器均可通过下列函数直接使用。"

#: ../../c-api/unicode.rst:1012
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"下列 API 大都接受 encoding 和 errors 两个参数，它们具有与在内置 :func:`str` 字符串对象构造器中同名参数相同的语义。"

#: ../../c-api/unicode.rst:1016
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is"
" UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` "
"for encoding file names. This uses the variable "
":c:data:`Py_FileSystemDefaultEncoding` internally. This variable should be "
"treated as read-only: on some systems, it will be a pointer to a static "
"string, on others, it will change at run-time (such as when the application "
"invokes setlocale)."
msgstr ""

#: ../../c-api/unicode.rst:1024
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to"
" use the default handling defined for the codec.  Default error handling for"
" all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"错误处理方式由 errors 设置并且也可以设为 ``NULL`` 表示使用为编解码器定义的默认处理方式。 所有内置编解码器的默认错误处理方式是 "
"\"strict\" (会引发 :exc:`ValueError`)。"

#: ../../c-api/unicode.rst:1028
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr "编解码器都使用类似的接口。 为了保持简单只有与下列泛型编解码器的差异才会记录在文档中。"

#: ../../c-api/unicode.rst:1033
msgid "Generic Codecs"
msgstr "泛型编解码器"

#: ../../c-api/unicode.rst:1035
msgid "These are the generic codec APIs:"
msgstr "以下是泛型编解码器的 API:"

#: ../../c-api/unicode.rst:1041
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *s*. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the :func:`str` built-in function.  The codec to be used is looked "
"up using the Python codec registry.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"通过解码已编码字符串 *s* 的 *size* 个字节创建一个 Unicode 对象。 *encoding* 和 *errors* 具有与 "
":func:`str` 内置函数中同名形参相同的含义。 要使用的编解码器将使用 Python 编解码器注册表来查找。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1051
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"编码一个 Unicode 对象并将结果作为 Python 字节串对象返回。 *encoding* 和 *errors* 具有与 Unicode "
":meth:`~str.encode` 方法中同名形参相同的含义。 要使用的编解码器将使用 Python 编解码器注册表来查找。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1061
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer *s* of the given *size* and return a "
"Python bytes object.  *encoding* and *errors* have the same meaning as the "
"parameters of the same name in the Unicode :meth:`~str.encode` method.  The "
"codec to be used is looked up using the Python codec registry.  Return "
"``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1069 ../../c-api/unicode.rst:1327
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1073
msgid "UTF-8 Codecs"
msgstr "UTF-8 编解码器"

#: ../../c-api/unicode.rst:1075
msgid "These are the UTF-8 codec APIs:"
msgstr "以下是 UTF-8 编解码器 API:"

#: ../../c-api/unicode.rst:1080
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string"
" *s*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 UTF-8 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1087
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF8`。 如果 "
"*consumed* 不为 ``NULL``，则末尾的不完整 UTF-8 字节序列将不被视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 "
"*consumed* 中。"

#: ../../c-api/unicode.rst:1095
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 UTF-8 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1102
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned"
" buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"返回一个指向 Unicode 对象的 UTF-8 编码格式数据的指针，并将已编码数据的大小（以字节为单位）存储在 *size* 中。 *size* "
"参数可以为 ``NULL``；在此情况下数据的大小将不会被存储。 返回的缓冲区总是会添加一个额外的空字节（不包括在 *size* "
"中），无论是否存在任何其他的空码位。"

#: ../../c-api/unicode.rst:1108
msgid ""
"In the case of an error, ``NULL`` is returned with an exception set and no "
"*size* is stored."
msgstr "在发生错误的情况下，将返回 ``NULL`` 附带设置一个异常并且不会存储 *size* 值。"

#: ../../c-api/unicode.rst:1111
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"这将缓存 Unicode 对象中字符串的 UTF-8 表示形式，并且后续调用将返回指向同一缓存区的指针。 调用方不必负责释放该缓冲区。 缓冲区会在 "
"Unicode 对象被作为垃圾回收时被释放并使指向它的指针失效。"

#: ../../c-api/unicode.rst:1118 ../../c-api/unicode.rst:1128
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "返回类型现在是 ``const char *`` 而不是 ``char *``。"

#: ../../c-api/unicode.rst:1124
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "类似于 :c:func:`PyUnicode_AsUTF8AndSize`，但不会存储大小值。"

#: ../../c-api/unicode.rst:1134
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer *s* of the given *size* using UTF-8 "
"and return a Python bytes object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1141
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsUTF8String`, :c:func:`PyUnicode_AsUTF8AndSize` or "
":c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1145
msgid "UTF-32 Codecs"
msgstr "UTF-32 编解码器"

#: ../../c-api/unicode.rst:1147
msgid "These are the UTF-32 codec APIs:"
msgstr "以下是 UTF-32 编解码器 API:"

#: ../../c-api/unicode.rst:1153
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"从 UTF-32 编码的缓冲区数据解码 *size* 个字节并返回相应的 Unicode 对象。 *errors* (如果不为 ``NULL``) "
"定义了错误处理方式。 默认为 \"strict\"。"

#: ../../c-api/unicode.rst:1157 ../../c-api/unicode.rst:1230
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr "如果 *byteorder* 不为 ``NULL``，解码器将使用给定的字节序进行解码::"

#: ../../c-api/unicode.rst:1164
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"如果 ``*byteorder`` 为零，且输入数据的前四个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 "
"Unicode 字符串中。 如果 ``*byteorder`` 为 ``-1`` 或 ``1``，则字节序标记会被拷贝到输出中。"

#: ../../c-api/unicode.rst:1169
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end"
" of input data."
msgstr "在完成后，*\\*byteorder* 将在输入数据的末尾被设为当前字节序。"

#: ../../c-api/unicode.rst:1172 ../../c-api/unicode.rst:1246
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr "如果 *byteorder* 为 ``NULL``，编解码器将使用本机字节序。"

#: ../../c-api/unicode.rst:1174 ../../c-api/unicode.rst:1210
#: ../../c-api/unicode.rst:1248 ../../c-api/unicode.rst:1285
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1180
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not"
" treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF32`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeUTF32Stateful` 将不把末尾的不完整 "
"UTF-32 字节序列（如字节数不可被四整除）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1189
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"返回使用 UTF-32 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1197
msgid ""
"Return a Python bytes object holding the UTF-32 encoded value of the Unicode"
" data in *s*.  Output is written according to the following byte order::"
msgstr ""

#: ../../c-api/unicode.rst:1204 ../../c-api/unicode.rst:1278
msgid ""
"If byteorder is ``0``, the output string will always start with the Unicode "
"BOM mark (U+FEFF). In the other two modes, no BOM mark is prepended."
msgstr ""

#: ../../c-api/unicode.rst:1207
msgid ""
"If ``Py_UNICODE_WIDE`` is not defined, surrogate pairs will be output as a "
"single code point."
msgstr ""

#: ../../c-api/unicode.rst:1214
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsUTF32String` or :c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1218
msgid "UTF-16 Codecs"
msgstr "UTF-16 编解码器"

#: ../../c-api/unicode.rst:1220
msgid "These are the UTF-16 codec APIs:"
msgstr "以下是 UTF-16 编解码器的 API:"

#: ../../c-api/unicode.rst:1226
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"从 UTF-16 编码的缓冲区数据解码 *size* 个字节并返回相应的 Unicode 对象。 *errors* (如果不为 ``NULL``) "
"定义了错误处理方式。 默认为 \"strict\"。"

#: ../../c-api/unicode.rst:1237
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"如果 ``*byteorder`` 为零，且输入数据的前两个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 "
"Unicode 字符串中。 如果 ``*byteorder`` 为 ``-1`` 或 ``1``，则字节序标记会被拷贝到输出中 (它将是一个 "
"``\\ufeff`` 或 ``\\ufffe`` 字符)。"

#: ../../c-api/unicode.rst:1243
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end"
" of input data."
msgstr "在完成后，``*byteorder`` 将在输入数据的末尾被设为当前字节序。"

#: ../../c-api/unicode.rst:1254
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not"
" treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF16`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeUTF16Stateful` 将不把末尾的不完整 "
"UTF-16 字节序列（如为奇数个字节或为分开的替代对）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1263
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"返回使用 UTF-16 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1271
msgid ""
"Return a Python bytes object holding the UTF-16 encoded value of the Unicode"
" data in *s*.  Output is written according to the following byte order::"
msgstr ""

#: ../../c-api/unicode.rst:1281
msgid ""
"If ``Py_UNICODE_WIDE`` is defined, a single :c:type:`Py_UNICODE` value may "
"get represented as a surrogate pair. If it is not defined, each "
":c:type:`Py_UNICODE` values is interpreted as a UCS-2 character."
msgstr ""

#: ../../c-api/unicode.rst:1289
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsUTF16String` or :c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1293
msgid "UTF-7 Codecs"
msgstr "UTF-7 编解码器"

#: ../../c-api/unicode.rst:1295
msgid "These are the UTF-7 codec APIs:"
msgstr "以下是 UTF-7 编解码器 API:"

#: ../../c-api/unicode.rst:1300
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string"
" *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 UTF-7 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1307
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF7`。 如果 "
"*consumed* 不为 ``NULL``，则末尾的不完整 UTF-7 base-64 部分将不被视为错误。 "
"这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1316
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given size using UTF-7 and "
"return a Python bytes object.  Return ``NULL`` if an exception was raised by"
" the codec."
msgstr ""

#: ../../c-api/unicode.rst:1320
msgid ""
"If *base64SetO* is nonzero, \"Set O\" (punctuation that has no otherwise "
"special meaning) will be encoded in base-64.  If *base64WhiteSpace* is "
"nonzero, whitespace will be encoded in base-64.  Both are set to zero for "
"the Python \"utf-7\" codec."
msgstr ""

#: ../../c-api/unicode.rst:1331
msgid "Unicode-Escape Codecs"
msgstr "Unicode-Escape 编解码器"

#: ../../c-api/unicode.rst:1333
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "以下是 \"Unicode Escape\" 编解码器的 API:"

#: ../../c-api/unicode.rst:1339
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *s*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"通过解码 Unicode-Escape 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1345
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"使用 Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1352
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using Unicode-"
"Escape and return a bytes object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1357
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsUnicodeEscapeString`."
msgstr ""

#: ../../c-api/unicode.rst:1361
msgid "Raw-Unicode-Escape Codecs"
msgstr "Raw-Unicode-Escape 编解码器"

#: ../../c-api/unicode.rst:1363
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "以下是 \"Raw Unicode Escape\" 编解码器的 API:"

#: ../../c-api/unicode.rst:1369
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *s*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"通过解码 Raw-Unicode-Escape 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1375
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"使用 Raw-Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1383
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using Raw-"
"Unicode-Escape and return a bytes object.  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1389
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsRawUnicodeEscapeString` or "
":c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1393
msgid "Latin-1 Codecs"
msgstr "Latin-1 编解码器"

#: ../../c-api/unicode.rst:1395
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr "以下是 Latin-1 编解码器的 API: Latin-1 对应于前 256 个 Unicode 码位且编码器在编码期间只接受这些码位。"

#: ../../c-api/unicode.rst:1401
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 Latin-1 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1407
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 Latin-1 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1414
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using Latin-1 and"
" return a Python bytes object.  Return ``NULL`` if an exception was raised "
"by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1421
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsLatin1String` or :c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1425
msgid "ASCII Codecs"
msgstr "ASCII 编解码器"

#: ../../c-api/unicode.rst:1427
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr "以下是 ASCII 编解码器的 API。 只接受 7 位 ASCII 数据。 任何其他编码的数据都将导致错误。"

#: ../../c-api/unicode.rst:1433
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string"
" *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 ASCII 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1439
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 ASCII 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1446
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using ASCII and "
"return a Python bytes object.  Return ``NULL`` if an exception was raised by"
" the codec."
msgstr ""

#: ../../c-api/unicode.rst:1453
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsASCIIString` or :c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1457
msgid "Character Map Codecs"
msgstr "字符映射编解码器"

#: ../../c-api/unicode.rst:1459
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`encodings` package). The codec uses mappings to"
" encode and decode characters.  The mapping objects provided must support "
"the :meth:`__getitem__` mapping interface; dictionaries and sequences work "
"well."
msgstr ""

#: ../../c-api/unicode.rst:1465
msgid "These are the mapping codec APIs:"
msgstr "以下是映射编解码器的 API:"

#: ../../c-api/unicode.rst:1470
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *s* "
"using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"通过使用给定的 *mapping* 对象解码已编码字节串 *s* 的 *size* 个字节创建 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1474
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"如果 *mapping* 为 ``NULL``，则将应用 Latin-1 编码格式。 否则 *mapping* 必须为字节码位值（0 至 255 "
"范围内的整数）到 Unicode 字符串的映射、整数（将被解读为 Unicode 码位）或 ``None``。 未映射的数据字节 -- 这样的数据将导致"
" :exc:`LookupError`，以及被映射到 ``None`` 的数据，``0xFFFE`` 或 "
"``'\\ufffe'``，将被视为未定义的映射并导致报错。"

#: ../../c-api/unicode.rst:1485
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if"
" an exception was raised by the codec."
msgstr ""
"使用给定的 *mapping* 对象编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1489
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"*mapping* 对象必须将整数 Unicode 码位映射到字节串对象、0 至 255 范围内的整数或 ``None``。 未映射的字符码位（将导致 "
":exc:`LookupError` 的数据）以及映射到 ``None`` 的数据将被视为“未定义的映射”并导致报错。"

#: ../../c-api/unicode.rst:1498
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using the given "
"*mapping* object and return the result as a bytes object.  Return ``NULL`` "
"if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1505
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsCharmapString` or :c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1508
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr "以下特殊的编解码器 API 会将 Unicode 映射至 Unicode。"

#: ../../c-api/unicode.rst:1512
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr "通过应用字符映射表来转写字符串并返回结果 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1516
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr "字符映射表必须将整数 Unicode 码位映射到整数 Unicode 码位或 ``None`` (这将删除相应的字符)。"

#: ../../c-api/unicode.rst:1519
msgid ""
"Mapping tables need only provide the :meth:`__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""

#: ../../c-api/unicode.rst:1523
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr "*errors* 具有用于编解码器的通常含义。 它可以为 ``NULL`` 表示使用默认的错误处理方式。"

#: ../../c-api/unicode.rst:1530
msgid ""
"Translate a :c:type:`Py_UNICODE` buffer of the given *size* by applying a "
"character *mapping* table to it and return the resulting Unicode object. "
"Return ``NULL`` when an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1537
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_Translate`. or :ref:`generic codec based API <codec-"
"registry>`"
msgstr ""

#: ../../c-api/unicode.rst:1541
msgid "MBCS codecs for Windows"
msgstr "Windows 中的 MBCS 编解码器"

#: ../../c-api/unicode.rst:1543
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"以下是 MBCS 编解码器的 API。 目前它们仅在 Windows 中可用并使用 Win32 MBCS 转换器来实现转换。 请注意 MBCS（或 "
"DBCS）是一类编码格式，而非只有一个。 目标编码格式是由运行编解码器的机器上的用户设置定义的。"

#: ../../c-api/unicode.rst:1550
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*s*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 MBCS 编码的字节串 *s* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1557
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeMBCS`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeMBCSStateful` "
"将不会解码末尾的不完整字节并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1565
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 MBCS 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1572
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use "
":c:data:`CP_ACP` code page to get the MBCS encoder."
msgstr ""

#: ../../c-api/unicode.rst:1581
msgid ""
"Encode the :c:type:`Py_UNICODE` buffer of the given *size* using MBCS and "
"return a Python bytes object.  Return ``NULL`` if an exception was raised by"
" the codec."
msgstr ""

#: ../../c-api/unicode.rst:1588
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using "
":c:func:`PyUnicode_AsMBCSString`, :c:func:`PyUnicode_EncodeCodePage` or "
":c:func:`PyUnicode_AsEncodedString`."
msgstr ""

#: ../../c-api/unicode.rst:1592
msgid "Methods & Slots"
msgstr "方法和槽位"

#: ../../c-api/unicode.rst:1598
msgid "Methods and Slot Functions"
msgstr "方法与槽位函数"

#: ../../c-api/unicode.rst:1600
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr "以下 API 可以处理输入的 Unicode 对象和字符串（在描述中我们称其为字符串）并返回适当的 Unicode 或整数值。"

#: ../../c-api/unicode.rst:1604
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr "如果发生异常它们都将返回 ``NULL`` 或 ``-1``。"

#: ../../c-api/unicode.rst:1609
msgid "Concat two strings giving a new Unicode string."
msgstr "拼接两个字符串得到一个新的 Unicode 字符串。"

#: ../../c-api/unicode.rst:1614
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"拆分一个字符串得到一个 Unicode 字符串的列表。 如果 *sep* 为 ``NULL``，则将根据空格来拆分所有子字符串。 "
"否则，将根据指定的分隔符来拆分。 最多拆分数为 *maxsplit*。 如为负值，则没有限制。 分隔符不包括在结果列表中。"

#: ../../c-api/unicode.rst:1622
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepend* is ``0``, the line "
"break characters are not included in the resulting strings."
msgstr ""
"根据分行符来拆分 Unicode 字符串，返回一个 Unicode 字符串的列表。 CRLF 将被视为一个分行符。 如果 *keepend* 为 "
"``0``，则行分隔符不包括在结果列表中。"

#: ../../c-api/unicode.rst:1629
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""

#: ../../c-api/unicode.rst:1636
msgid ""
"Return ``1`` if *substr* matches ``str[start:end]`` at the given tail end "
"(*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` a "
"suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""

#: ../../c-api/unicode.rst:1644
msgid ""
"Return the first position of *substr* in ``str[start:end]`` using the given "
"*direction* (*direction* == ``1`` means to do a forward search, *direction* "
"== ``-1`` a backward search).  The return value is the index of the first "
"match; a value of ``-1`` indicates that no match was found, and ``-2`` "
"indicates that an error occurred and an exception has been set."
msgstr ""

#: ../../c-api/unicode.rst:1654
msgid ""
"Return the first position of the character *ch* in ``str[start:end]`` using "
"the given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""

#: ../../c-api/unicode.rst:1662
msgid "*start* and *end* are now adjusted to behave like ``str[start:end]``."
msgstr ""

#: ../../c-api/unicode.rst:1669
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``str[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""

#: ../../c-api/unicode.rst:1676
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *str* with *replstr* "
"and return the resulting Unicode object. *maxcount* == ``-1`` means replace "
"all occurrences."
msgstr ""

#: ../../c-api/unicode.rst:1683
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""

#: ../../c-api/unicode.rst:1686
msgid ""
"This function returns ``-1`` upon failure, so one should call "
":c:func:`PyErr_Occurred` to check for errors."
msgstr ""

#: ../../c-api/unicode.rst:1692
msgid ""
"Compare a Unicode object, *uni*, with *string* and return ``-1``, ``0``, "
"``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""

#: ../../c-api/unicode.rst:1697
msgid "This function does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:1702
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "对两个 Unicode 字符串执行富比较并返回以下值之一:"

#: ../../c-api/unicode.rst:1704
msgid "``NULL`` in case an exception was raised"
msgstr ""

#: ../../c-api/unicode.rst:1705
msgid ":const:`Py_True` or :const:`Py_False` for successful comparisons"
msgstr ""

#: ../../c-api/unicode.rst:1706
msgid ":const:`Py_NotImplemented` in case the type combination is unknown"
msgstr ""

#: ../../c-api/unicode.rst:1708
msgid ""
"Possible values for *op* are :const:`Py_GT`, :const:`Py_GE`, :const:`Py_EQ`,"
" :const:`Py_NE`, :const:`Py_LT`, and :const:`Py_LE`."
msgstr ""

#: ../../c-api/unicode.rst:1714
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""

#: ../../c-api/unicode.rst:1720
msgid ""
"Check whether *element* is contained in *container* and return true or false"
" accordingly."
msgstr ""

#: ../../c-api/unicode.rst:1723
msgid ""
"*element* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""

#: ../../c-api/unicode.rst:1729
msgid ""
"Intern the argument *\\*string* in place.  The argument must be the address "
"of a pointer variable pointing to a Python Unicode string object.  If there "
"is an existing interned string that is the same as *\\*string*, it sets "
"*\\*string* to it (decrementing the reference count of the old string object"
" and incrementing the reference count of the interned string object), "
"otherwise it leaves *\\*string* alone and interns it (incrementing its "
"reference count). (Clarification: even though there is a lot of talk about "
"reference counts, think of this function as reference-count-neutral; you own"
" the object after the call if and only if you owned it before the call.)"
msgstr ""

#: ../../c-api/unicode.rst:1742
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace`, returning either a new Unicode string "
"object that has been interned, or a new (\"owned\") reference to an earlier "
"interned string object with the same value."
msgstr ""
