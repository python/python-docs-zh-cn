# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 8af080f2e6702c64bedd01873aed27e8_25aec74 <fd99d14239138a1f987c22e7736dde81_777475>, 2021
# 1lin24 <1lin24@sina.com>, 2021
# Jiuh.star <jiuh.star@gmail.com>, 2021
# 高乐喆 <gaolezhe@outlook.com>, 2023
# 钢 彭 <szhairui@gmail.com>, 2023
# ww song <sww4718168@gmail.com>, 2023
# WH-2099 <wh2099@outlook.com>, 2023
# ppcfish <ppcfish@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Unicode对象和编解码器"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Unicode对象"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"自从python3.3中实现了 :pep:`393` "
"以来，Unicode对象在内部使用各种表示形式，以便在保持内存效率的同时处理完整范围的Unicode字符。对于所有代码点都低于128、256或65536的字符串，有一些特殊情况；否则，代码点必须低于1114112（这是完整的Unicode范围）。"

#: ../../c-api/unicode.rst:20
msgid ""
"UTF-8 representation is created on demand and cached in the Unicode object."
msgstr "UTF-8 表示将按需创建并缓存在 Unicode 对象中。"

#: ../../c-api/unicode.rst:23
msgid ""
"The :c:type:`Py_UNICODE` representation has been removed since Python 3.12 "
"with deprecated APIs. See :pep:`623` for more information."
msgstr ""
":c:type:`Py_UNICODE` 表示形式在 Python 3.12 中同被弃用的 API 一起被移除了，查阅 :pep:`623` "
"以获得更多信息。"

#: ../../c-api/unicode.rst:29
msgid "Unicode Type"
msgstr "Unicode类型"

#: ../../c-api/unicode.rst:31
msgid ""
"These are the basic Unicode object types used for the Unicode implementation"
" in Python:"
msgstr "以下是用于Python中Unicode实现的基本Unicode对象类型："

#: ../../c-api/unicode.rst:36
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type. "
"It is exposed to Python code as :py:class:`str`."
msgstr ""

#: ../../c-api/unicode.rst:42
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode "
"iterator type. It is used to iterate over Unicode string objects."
msgstr ""
"这是 :c:type:`PyTypeObject` 实例代表 Python Unicode 迭代器类型。 它被用来迭代 Unicode 字符串对象。"

#: ../../c-api/unicode.rst:50
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"这些类型是无符号整数类型的类型定义，其宽度足以分别包含 32 位、16 位和 8 位字符。 当需要处理单个 Unicode 字符时，请使用 "
":c:type:`Py_UCS4`。"

#: ../../c-api/unicode.rst:61
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"这些关于 :c:type:`PyObject` 的子类型表示了一个 Python Unicode 对象。 "
"在几乎所有情形下，它们不应该被直接使用，因为所有处理 Unicode 对象的 API 函数都接受并返回 :c:type:`PyObject` "
"类型的指针。"

#: ../../c-api/unicode.rst:68
msgid ""
"The following APIs are C macros and static inlined functions for fast checks"
" and access to internal read-only data of Unicode objects:"
msgstr "以下API是C宏和静态内联函数，用于快速检查和访问Unicode对象的内部只读数据："

#: ../../c-api/unicode.rst:73
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr "如果对象 *obj* 是 Unicode 对象或 Unicode 子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/unicode.rst:79
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance of "
"a subtype.  This function always succeeds."
msgstr "如果对象 *obj* 是一个 Unicode 对象，但不是某个子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/unicode.rst:85
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has to "
"be a Unicode object in the \"canonical\" representation (not checked)."
msgstr "返回以码位点数量表示的 Unicode 字符串长度。 *unicode* 必须为“规范”表示的 Unicode 对象（不会检查这一点）。"

#: ../../c-api/unicode.rst:95
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use "
":c:func:`PyUnicode_KIND` to select the right function."
msgstr ""
"返回一个用于直接字符访问的指向转换为 UCS1、UCS2 或 UCS4 整数类型的规范表示的指针。 如果规范表示具有正确的字符大小，则不执行检查；使用 "
":c:func:`PyUnicode_KIND` 选择正确的函数。"

#: ../../c-api/unicode.rst:107
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "返回 :c:func:`PyUnicode_KIND` 宏的值。"

#: ../../c-api/unicode.rst:111
msgid "``PyUnicode_WCHAR_KIND`` has been removed."
msgstr "``PyUnicode_WCHAR_KIND`` 已被移除。"

#: ../../c-api/unicode.rst:117
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""
"返回一个 PyUnicode 类型的常量（见上文），指明此see above) that indicate how many bytes per "
"character this Unicode 对象用来存储每个字符所使用的字节数。 *unicode* 必须为“规范”表示的 Unicode "
"对象（不会检查这一点）。"

#: ../../c-api/unicode.rst:126
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr "返回一个指向原始 Unicode 缓冲区的空指针。 *unicode* 必须为“规范”表示的 Unicode 对象（不会检查这一点）。"

#: ../../c-api/unicode.rst:135
msgid ""
"Write the code point *value* to the given zero-based *index* in a string."
msgstr ""

#: ../../c-api/unicode.rst:137
msgid ""
"The *kind* value and *data* pointer must have been obtained from a string "
"using :c:func:`PyUnicode_KIND` and :c:func:`PyUnicode_DATA` respectively. "
"You must hold a reference to that string while calling "
":c:func:`!PyUnicode_WRITE`. All requirements of "
":c:func:`PyUnicode_WriteChar` also apply."
msgstr ""

#: ../../c-api/unicode.rst:143
msgid ""
"The function performs no checks for any of its requirements, and is intended"
" for usage in loops."
msgstr ""

#: ../../c-api/unicode.rst:152
msgid ""
"Read a code point from a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr "从规范表示的 *data* (如同用 :c:func:`PyUnicode_DATA` 获取) 中读取一个码位。 不会执行检查或就绪调用。"

#: ../../c-api/unicode.rst:160
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than "
":c:func:`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"从 Unicode 对象 *unicode* 读取一个字符，必须为“规范”表示形式。 如果你执行多次连续读取则此函数的效率将低于 "
":c:func:`PyUnicode_READ`。"

#: ../../c-api/unicode.rst:169
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *unicode*, which must be in the \"canonical\" representation.  This"
" is always an approximation but more efficient than iterating over the "
"string."
msgstr ""
"返回适合基于 *unicode* 创建另一个字符串的最大码位点，该参数必须为“规范”表示形式。 这始终是一种近似但比在字符串上执行迭代更高效。"

#: ../../c-api/unicode.rst:178
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr "如果字符串按照语言定义是合法的标识符则返回 ``1``，参见 :ref:`identifiers` 小节。 否则返回 ``0``。"

#: ../../c-api/unicode.rst:181
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr "如果字符串尚未就绪则此函数不会再调用 :c:func:`Py_FatalError`。"

#: ../../c-api/unicode.rst:188
msgid ""
"Return true if the string only contains ASCII characters. Equivalent to "
":py:meth:`str.isascii`."
msgstr ""

#: ../../c-api/unicode.rst:195
msgid "Unicode Character Properties"
msgstr "Unicode字符属性"

#: ../../c-api/unicode.rst:197
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr "Unicode提供了许多不同的字符特性。最常需要的宏可以通过这些宏获得，这些宏根据Python配置映射到C函数。"

#: ../../c-api/unicode.rst:204
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr "根据 *ch* 是否为空白字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:209
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr "根据 *ch* 是否为小写字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:214
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr "根据 *ch* 是否为大写字符返回 ``1`` 或 ``0``"

#: ../../c-api/unicode.rst:219
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr "根据 *ch* 是否为标题化的大小写返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:224
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr "根据 *ch* 是否为换行类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:229
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "根据 *ch* 是否为十进制数字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:234
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "根据 *ch* 是否为数码类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:239
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr "根据 *ch* 是否为数值类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:244
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr "根据 *ch* 是否为字母类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:249
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric "
"character."
msgstr "根据 *ch* 是否为字母数字类字符返回 ``1`` 或 ``0``。"

#: ../../c-api/unicode.rst:254
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character, in"
" the sense of :meth:`str.isprintable`."
msgstr "根据 *ch* 是否为可打印字符返回 ``1`` 或 ``0``，基于 :meth:`str.isprintable` 来判断。"

#: ../../c-api/unicode.rst:258
msgid "These APIs can be used for fast direct character conversions:"
msgstr "这些 API 可用于快速直接的字符转换："

#: ../../c-api/unicode.rst:263
msgid "Return the character *ch* converted to lower case."
msgstr "返回转换为小写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:268
msgid "Return the character *ch* converted to upper case."
msgstr "返回转换为大写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:273
msgid "Return the character *ch* converted to title case."
msgstr "返回转换为标题大小写形式的字符 *ch*。"

#: ../../c-api/unicode.rst:278
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This function does not raise exceptions."
msgstr "将字符 *ch* 转换为十进制正整数返回。 如果无法转换则返回 ``-1``。 此函数不会引发异常。"

#: ../../c-api/unicode.rst:284
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1``"
" if this is not possible.  This function does not raise exceptions."
msgstr "将字符 *ch* 转换为单个数码位的整数返回。 如果无法转换则返回 ``-1``。 此函数不会引发异常。"

#: ../../c-api/unicode.rst:290
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This function does not raise exceptions."
msgstr "将字符 *ch* 转换为双精度浮点数返回。 如果无法转换则返回 ``-1.0``。 此函数不会引发异常。"

#: ../../c-api/unicode.rst:294
msgid "These APIs can be used to work with surrogates:"
msgstr "这些 API 可被用来操作代理项："

#: ../../c-api/unicode.rst:298
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "检测 *ch* 是否为代理项 (``0xD800 <= ch <= 0xDFFF``)。"

#: ../../c-api/unicode.rst:302
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "检测 *ch* 是否为高代理项 (``0xD800 <= ch <= 0xDBFF``)。"

#: ../../c-api/unicode.rst:306
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "检测 *ch* 是否为低代理项 (``0xDC00 <= ch <= 0xDFFF``)。"

#: ../../c-api/unicode.rst:310
msgid ""
"Join two surrogate code points and return a single :c:type:`Py_UCS4` value. "
"*high* and *low* are respectively the leading and trailing surrogates in a "
"surrogate pair. *high* must be in the range [0xD800; 0xDBFF] and *low* must "
"be in the range [0xDC00; 0xDFFF]."
msgstr ""
"合并两个代理码位并返回单个 :c:type:`Py_UCS4` 值。 *high* 和 *low* 分别为一个代理对的开头和末尾代理项。 *high* "
"必须在 [0xD800; 0xDBFF] 范围内而 *low* 必须在 [0xDC00; 0xDFFF] 范围内。"

#: ../../c-api/unicode.rst:317
msgid "Creating and accessing Unicode strings"
msgstr "创建和访问 Unicode 字符串"

#: ../../c-api/unicode.rst:319
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr "要创建 Unicode 对象和访问其基本序列属性，请使用这些 API："

#: ../../c-api/unicode.rst:324
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up"
" to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"创建一个新的 Unicode 对象。 *maxchar* 应为可放入字符串的实际最大码位。 作为一个近似值，它可被向上舍入到序列 127, 255, "
"65535, 1114111 中最接近的值。"

#: ../../c-api/unicode.rst:328
msgid "On error, set an exception and return ``NULL``."
msgstr "发生错误时，将设置异常并返回 ``NULL``。"

#: ../../c-api/unicode.rst:330
msgid ""
"After creation, the string can be filled by :c:func:`PyUnicode_WriteChar`, "
":c:func:`PyUnicode_CopyCharacters`, :c:func:`PyUnicode_Fill`, "
":c:func:`PyUnicode_WRITE` or similar. Since strings are supposed to be "
"immutable, take care to not “use” the result while it is being modified. In "
"particular, before it's filled with its final contents, a string:"
msgstr ""

#: ../../c-api/unicode.rst:337
msgid "must not be hashed,"
msgstr ""

#: ../../c-api/unicode.rst:338
msgid ""
"must not be :c:func:`converted to UTF-8 <PyUnicode_AsUTF8AndSize>`, or "
"another non-\"canonical\" representation,"
msgstr ""

#: ../../c-api/unicode.rst:340
msgid "must not have its reference count changed,"
msgstr ""

#: ../../c-api/unicode.rst:341
msgid "must not be shared with code that might do one of the above."
msgstr ""

#: ../../c-api/unicode.rst:343
msgid ""
"This list is not exhaustive. Avoiding these uses is your responsibility; "
"Python does not always check these requirements."
msgstr ""

#: ../../c-api/unicode.rst:346
msgid ""
"To avoid accidentally exposing a partially-written string object, prefer "
"using the :c:type:`PyUnicodeWriter` API, or one of the ``PyUnicode_From*`` "
"functions below."
msgstr ""

#: ../../c-api/unicode.rst:357
msgid ""
"Create a new Unicode object with the given *kind* (possible values are "
":c:macro:`PyUnicode_1BYTE_KIND` etc., as returned by "
":c:func:`PyUnicode_KIND`).  The *buffer* must point to an array of *size* "
"units of 1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"以给定的 *kind* 创建一个新的 Unicode 对象（可能的值为 :c:macro:`PyUnicode_1BYTE_KIND` 等，即 "
":c:func:`PyUnicode_KIND` 所返回的值）。 *buffer* 必须指向由此分类所给出的，以每字符 1, 2 或 4 字节单位的 "
"*size* 大小的数组。"

#: ../../c-api/unicode.rst:362
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string "
"(:c:macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the "
"UCS1 range, it will be transformed into UCS1 "
"(:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""
"如有必要，输入 *buffer* 将被拷贝并转换为规范表示形式。 例如，如果 *buffer* 是一个 UCS4 字符串 "
"(:c:macro:`PyUnicode_4BYTE_KIND`) 且仅由 UCS1 范围内的码位组成，它将被转换为 UCS1 "
"(:c:macro:`PyUnicode_1BYTE_KIND`)。"

#: ../../c-api/unicode.rst:373
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. The return value might be a shared object, i.e. modification of the "
"data is not allowed."
msgstr ""
"根据字符缓冲区 *str* 创建一个 Unicode 对象。 字节数据将按 UTF-8 编码格式来解读。 缓冲区会被拷贝到新的对象中。 "
"返回值可以是一个共享对象，即其数据不允许修改。"

#: ../../c-api/unicode.rst:379
msgid "This function raises :exc:`SystemError` when:"
msgstr "此函数会因以下情况而引发 :exc:`SystemError`:"

#: ../../c-api/unicode.rst:381
msgid "*size* < 0,"
msgstr "*size* < 0,"

#: ../../c-api/unicode.rst:382
msgid "*str* is ``NULL`` and *size* > 0"
msgstr "*str* 为 ``NULL`` 且 *size* > 0"

#: ../../c-api/unicode.rst:384
msgid "*str* == ``NULL`` with *size* > 0 is not allowed anymore."
msgstr "*str* == ``NULL`` 且 *size* > 0 不再被允许。"

#: ../../c-api/unicode.rst:390
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr "根据 UTF-8 编码的以空值结束的字符缓冲区 *str* 创建一个 Unicode 对象。"

#: ../../c-api/unicode.rst:396
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string."
msgstr ""
"接受一个 C :c:func:`printf` 风格的 *format* 字符串和可变数量的参数，计算结果 Python Unicode "
"字符串的大小并返回包含已格式化值的字符串。 可变数量的参数必须均为 C 类型并且必须恰好与 *format* ASCII 编码字符串中的格式字符相对应。"

#: ../../c-api/unicode.rst:402
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr "转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序："

#: ../../c-api/unicode.rst:405
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "``'%'`` 字符，用于标记转换符的起始。"

#: ../../c-api/unicode.rst:407
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "转换旗标（可选），用于影响某些转换类型的结果。"

#: ../../c-api/unicode.rst:410
msgid ""
"Minimum field width (optional). If specified as an ``'*'`` (asterisk), the "
"actual width is given in the next argument, which must be of type "
":c:expr:`int`, and the object to convert comes after the minimum field width"
" and optional precision."
msgstr ""
"最小字段宽度（可选）。 如果指定为 ``'*'`` (星号)，则实际宽度会在下一参数中给出，该参数必须为 :c:expr:`int` "
"类型，要转换的对象则放在最小字段宽度和可选精度之后。"

#: ../../c-api/unicode.rst:415
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision. If"
" specified as ``'*'`` (an asterisk), the actual precision is given in the "
"next argument, which must be of type :c:expr:`int`, and the value to convert"
" comes after the precision."
msgstr ""
"精度（可选），以在 ``'.'`` (点号) 之后加精度值的形式给出。 如果指定为 ``'*'`` (星号)，则实际精度会在下一参数中给出，该参数必须为"
" :c:expr:`int` 类型，要转换的对象则放在精度之后。"

#: ../../c-api/unicode.rst:420
msgid "Length modifier (optional)."
msgstr "长度修饰符（可选）。"

#: ../../c-api/unicode.rst:422
msgid "Conversion type."
msgstr "转换类型。"

#: ../../c-api/unicode.rst:424
msgid "The conversion flag characters are:"
msgstr "转换旗标为："

#: ../../c-api/unicode.rst:429
msgid "Flag"
msgstr "标志"

#: ../../c-api/unicode.rst:429
msgid "Meaning"
msgstr "含意"

#: ../../c-api/unicode.rst:431
msgid "``0``"
msgstr "``0``"

#: ../../c-api/unicode.rst:431
msgid "The conversion will be zero padded for numeric values."
msgstr "转换将为数字值填充零字符。"

#: ../../c-api/unicode.rst:433
msgid "``-``"
msgstr "``-``"

#: ../../c-api/unicode.rst:433
msgid ""
"The converted value is left adjusted (overrides the ``0`` flag if both are "
"given)."
msgstr "转换值将靠左对齐（如果同时给出则会覆盖 ``0`` 旗标）。"

#: ../../c-api/unicode.rst:437
msgid ""
"The length modifiers for following integer conversions (``d``, ``i``, ``o``,"
" ``u``, ``x``, or ``X``) specify the type of the argument (:c:expr:`int` by "
"default):"
msgstr ""
"以下整数转换的长度修饰符 (``d``, ``i``, ``o``, ``u``, ``x``, or ``X``) 指明参数的类型 (默认为 "
":c:expr:`int`):"

#: ../../c-api/unicode.rst:444
msgid "Modifier"
msgstr "修饰符"

#: ../../c-api/unicode.rst:444
msgid "Types"
msgstr "类型"

#: ../../c-api/unicode.rst:446
msgid "``l``"
msgstr "``l``"

#: ../../c-api/unicode.rst:446
msgid ":c:expr:`long` or :c:expr:`unsigned long`"
msgstr ":c:expr:`long` 或 :c:expr:`unsigned long`"

#: ../../c-api/unicode.rst:448
msgid "``ll``"
msgstr "``ll``"

#: ../../c-api/unicode.rst:448
msgid ":c:expr:`long long` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`long long` 或 :c:expr:`unsigned long long`"

#: ../../c-api/unicode.rst:450
msgid "``j``"
msgstr "``j``"

#: ../../c-api/unicode.rst:450
msgid ":c:type:`intmax_t` or :c:type:`uintmax_t`"
msgstr ":c:type:`intmax_t` 或 :c:type:`uintmax_t`"

#: ../../c-api/unicode.rst:452
msgid "``z``"
msgstr "``z``"

#: ../../c-api/unicode.rst:452
msgid ":c:type:`size_t` or :c:type:`ssize_t`"
msgstr ":c:type:`size_t` 或 :c:type:`ssize_t`"

#: ../../c-api/unicode.rst:454
msgid "``t``"
msgstr "``t``"

#: ../../c-api/unicode.rst:454
msgid ":c:type:`ptrdiff_t`"
msgstr ":c:type:`ptrdiff_t`"

#: ../../c-api/unicode.rst:457
msgid ""
"The length modifier ``l`` for following conversions ``s`` or ``V`` specify "
"that the type of the argument is :c:expr:`const wchar_t*`."
msgstr "针对以下转换 ``s`` 或 ``V`` 的长度修饰符 ``l`` 指明参数的类型为 :c:expr:`const wchar_t*`。"

#: ../../c-api/unicode.rst:460
msgid "The conversion specifiers are:"
msgstr "转换指示符如下:"

#: ../../c-api/unicode.rst:466
msgid "Conversion Specifier"
msgstr "转换指示符"

#: ../../c-api/unicode.rst:467
msgid "Type"
msgstr "类型"

#: ../../c-api/unicode.rst:468
msgid "Comment"
msgstr "注释"

#: ../../c-api/unicode.rst:470
msgid "``%``"
msgstr "``%``"

#: ../../c-api/unicode.rst:471
msgid "*n/a*"
msgstr "*不适用*"

#: ../../c-api/unicode.rst:472
msgid "The literal ``%`` character."
msgstr "字面的 ``%`` 字符。"

#: ../../c-api/unicode.rst:474
msgid "``d``, ``i``"
msgstr "``d``, ``i``"

#: ../../c-api/unicode.rst:475 ../../c-api/unicode.rst:479
#: ../../c-api/unicode.rst:483 ../../c-api/unicode.rst:487
#: ../../c-api/unicode.rst:491
msgid "Specified by the length modifier"
msgstr "由长度修饰符指明"

#: ../../c-api/unicode.rst:476
msgid "The decimal representation of a signed C integer."
msgstr "有符号 C 整数的十进制表示。"

#: ../../c-api/unicode.rst:478
msgid "``u``"
msgstr "``u``"

#: ../../c-api/unicode.rst:480
msgid "The decimal representation of an unsigned C integer."
msgstr "无符号 C 整数的十进制表示。"

#: ../../c-api/unicode.rst:482
msgid "``o``"
msgstr "``o``"

#: ../../c-api/unicode.rst:484
msgid "The octal representation of an unsigned C integer."
msgstr "无符号 C 整数的八进制表示。"

#: ../../c-api/unicode.rst:486
msgid "``x``"
msgstr "``x``"

#: ../../c-api/unicode.rst:488
msgid "The hexadecimal representation of an unsigned C integer (lowercase)."
msgstr "无符号 C 整数的十六进制表示（小写）。"

#: ../../c-api/unicode.rst:490
msgid "``X``"
msgstr "``X``"

#: ../../c-api/unicode.rst:492
msgid "The hexadecimal representation of an unsigned C integer (uppercase)."
msgstr "无符号 C 整数的十六进制表示（大写）。"

#: ../../c-api/unicode.rst:494
msgid "``c``"
msgstr "``c``"

#: ../../c-api/unicode.rst:495
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/unicode.rst:496
msgid "A single character."
msgstr "单个字符。"

#: ../../c-api/unicode.rst:498
msgid "``s``"
msgstr "``s``"

#: ../../c-api/unicode.rst:499
msgid ":c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ":c:expr:`const char*` 或 :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:500
msgid "A null-terminated C character array."
msgstr "以 null 为终止符的 C 字符数组。"

#: ../../c-api/unicode.rst:502
msgid "``p``"
msgstr "``p``"

#: ../../c-api/unicode.rst:503
msgid ":c:expr:`const void*`"
msgstr ":c:expr:`const void*`"

#: ../../c-api/unicode.rst:504
msgid ""
"The hex representation of a C  pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"一个 C  指针的十六进制表示形式。 基本等价于 ``printf(\"%p\")`` 但它会确保以字面值 ``0x`` 开头而不管系统平台上的 "
"``printf`` 输出是什么。"

#: ../../c-api/unicode.rst:509
msgid "``A``"
msgstr "``A``"

#: ../../c-api/unicode.rst:510 ../../c-api/unicode.rst:514
#: ../../c-api/unicode.rst:524 ../../c-api/unicode.rst:528
#: ../../c-api/unicode.rst:532 ../../c-api/unicode.rst:537
msgid ":c:expr:`PyObject*`"
msgstr ":c:expr:`PyObject*`"

#: ../../c-api/unicode.rst:511
msgid "The result of calling :func:`ascii`."
msgstr ":func:`ascii` 调用的结果。"

#: ../../c-api/unicode.rst:513
msgid "``U``"
msgstr "``U``"

#: ../../c-api/unicode.rst:515
msgid "A Unicode object."
msgstr "一个 Unicode 对象。"

#: ../../c-api/unicode.rst:517
msgid "``V``"
msgstr "``V``"

#: ../../c-api/unicode.rst:518
msgid ":c:expr:`PyObject*`, :c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ":c:expr:`PyObject*`, :c:expr:`const char*` 或 :c:expr:`const wchar_t*`"

#: ../../c-api/unicode.rst:519
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"一个 Unicode 对象 (可以为 ``NULL``) 和一个以空值结束的 C 字符数组作为第二个形参（如果第一个形参为 "
"``NULL``，第二个形参将被使用）。"

#: ../../c-api/unicode.rst:523
msgid "``S``"
msgstr "``S``"

#: ../../c-api/unicode.rst:525
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "调用 :c:func:`PyObject_Str` 的结果。"

#: ../../c-api/unicode.rst:527
msgid "``R``"
msgstr "``R``"

#: ../../c-api/unicode.rst:529
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "调用 :c:func:`PyObject_Repr` 的结果。"

#: ../../c-api/unicode.rst:531
msgid "``T``"
msgstr "``T``"

#: ../../c-api/unicode.rst:533
msgid ""
"Get the fully qualified name of an object type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr "要获取对象类型的完整限定名称；请调用 :c:func:`PyType_GetFullyQualifiedName`。"

#: ../../c-api/unicode.rst:536
msgid "``#T``"
msgstr "``#T``"

#: ../../c-api/unicode.rst:538
msgid ""
"Similar to ``T`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr "类似于 ``T`` 格式，但会使用冒号 (``:``) 作为模块名称和限定名称之间的分隔符。"

#: ../../c-api/unicode.rst:541
msgid "``N``"
msgstr "``N``"

#: ../../c-api/unicode.rst:542 ../../c-api/unicode.rst:547
msgid ":c:expr:`PyTypeObject*`"
msgstr ":c:expr:`PyTypeObject*`"

#: ../../c-api/unicode.rst:543
msgid ""
"Get the fully qualified name of a type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr "获取类型的完整限定名称；调用 :c:func:`PyType_GetFullyQualifiedName`。"

#: ../../c-api/unicode.rst:546
msgid "``#N``"
msgstr "``#N``"

#: ../../c-api/unicode.rst:548
msgid ""
"Similar to ``N`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr "类似于 ``N`` 格式，但会使用冒号 (``:``) 作为模块名称和限定名称之间的分隔符。"

#: ../../c-api/unicode.rst:552
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes or :c:type:`wchar_t` items (if "
"the length modifier ``l`` is used) for ``\"%s\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""
"格式符的宽度单位是字符数而不是字节数。 格式符的精度单位对于 ``\"%s\"`` 和 ``\"%V\"`` (如果 ``PyObject*`` 参数为"
" ``NULL``) 是字节数或 :c:type:`wchar_t` 项数 (如果使用了长度修饰符 ``l``)，而对于 ``\"%A\"``, "
"``\"%U\"``, ``\"%S\"``, ``\"%R\"`` 和 ``\"%V\"`` (如果 ``PyObject*`` 参数不为 "
"``NULL``) 则为字符数。"

#: ../../c-api/unicode.rst:560
msgid ""
"Unlike to C :c:func:`printf` the ``0`` flag has effect even when a precision"
" is given for integer conversions (``d``, ``i``, ``u``, ``o``, ``x``, or "
"``X``)."
msgstr ""
"与 C :c:func:`printf` 不同的是 ``0`` 旗标即使在为整数转换 (``d``, ``i``, ``u``, ``o``, "
"``x``, or ``X``) 指定精度时也是有效的。"

#: ../../c-api/unicode.rst:564
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "增加了对 ``\"%lld\"`` 和 ``\"%llu\"`` 的支持。"

#: ../../c-api/unicode.rst:567
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "增加了对 ``\"%li\"``, ``\"%lli\"`` 和 ``\"%zi\"`` 的支持。"

#: ../../c-api/unicode.rst:570
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr "增加了对 ``\"%s\"``, ``\"%A\"``, ``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` 的宽度和精度格式符支持。"

#: ../../c-api/unicode.rst:574
msgid ""
"Support for conversion specifiers ``o`` and ``X``. Support for length "
"modifiers ``j`` and ``t``. Length modifiers are now applied to all integer "
"conversions. Length modifier ``l`` is now applied to conversion specifiers "
"``s`` and ``V``. Support for variable width and precision ``*``. Support for"
" flag ``-``."
msgstr ""
"支持转换说明符 ``o`` 和 ``X``。 支持长度修饰符 ``j`` 和 ``t``。 长度修饰符现在将应用于所有整数转换。 长度修饰符 ``l``"
" 现在将应用于转换说明符 ``s`` 和 ``V``。 支持可变宽度和精度 ``*``。 支持旗标 ``-``。"

#: ../../c-api/unicode.rst:582
msgid ""
"An unrecognized format character now sets a :exc:`SystemError`. In previous "
"versions it caused all the rest of the format string to be copied as-is to "
"the result string, and any extra arguments discarded."
msgstr ""
"不可识别的格式字符现在会设置一个 :exc:`SystemError`。 "
"在之前版本中它会导致所有剩余格式字符串被原样拷贝到结果字符串，并丢弃任何额外的参数。"

#: ../../c-api/unicode.rst:586
msgid "Support for ``%T``, ``%#T``, ``%N`` and ``%#N`` formats added."
msgstr "增加了对 ``%T``, ``%#T``, ``%N`` 和 ``%#N`` 等格式的支持。"

#: ../../c-api/unicode.rst:592
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two"
" arguments."
msgstr "等同于 :c:func:`PyUnicode_FromFormat` 但它将接受恰好两个参数。"

#: ../../c-api/unicode.rst:598
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return"
" a new :term:`strong reference` to the object."
msgstr ""
"如有必要将把一个 Unicode 子类型的实例拷贝为新的真实 Unicode 对象。 如果 *obj* 已经是一个真实 Unicode "
"对象（而非子类型），则返回一个新的指向该对象的 :term:`strong reference`。"

#: ../../c-api/unicode.rst:602
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr "非 Unicode 或其子类型的对象将导致 :exc:`TypeError`。"

#: ../../c-api/unicode.rst:607
msgid "Create a Unicode Object from the given Unicode code point *ordinal*."
msgstr "根据给定的 Unicode 码点 *ordinal* 创建一个 Unicode 对象。"

#: ../../c-api/unicode.rst:609
msgid ""
"The ordinal must be in ``range(0x110000)``. A :exc:`ValueError` is raised in"
" the case it is not."
msgstr "码点必须在 ``range(0x110000)`` 范围内。 如果超出范围则会引发 :exc:`ValueError`。"

#: ../../c-api/unicode.rst:616
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "将一个已编码的对象 *obj* 解码为 Unicode 对象。"

#: ../../c-api/unicode.rst:618
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using"
" the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` 和其他 :term:`字节类对象 <bytes-like object>` "
"将按照给定的 *encoding* 来解码并使用由 *errors* 定义的错误处理方式。 两者均可为 ``NULL`` 即让接口使用默认值（请参阅 "
":ref:`builtincodecs` 了解详情）。"

#: ../../c-api/unicode.rst:624
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be"
" set."
msgstr "所有其他对象，包括 Unicode 对象，都将导致设置 :exc:`TypeError`。"

#: ../../c-api/unicode.rst:627
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr "如有错误该 API 将返回 ``NULL``。 调用方要负责递减指向所返回对象的引用。"

#: ../../c-api/unicode.rst:633
msgid ""
"Append the string *right* to the end of *p_left*. *p_left* must point to a "
":term:`strong reference` to a Unicode object; :c:func:`!PyUnicode_Append` "
"releases (\"steals\") this reference."
msgstr ""

#: ../../c-api/unicode.rst:637
msgid "On error, set *\\*p_left* to ``NULL`` and set an exception."
msgstr ""

#: ../../c-api/unicode.rst:639
msgid "On success, set *\\*p_left* to a new strong reference to the result."
msgstr ""

#: ../../c-api/unicode.rst:644
msgid ""
"The function is similar to :c:func:`PyUnicode_Append`, with the only "
"difference being that it decrements the reference count of *right* by one."
msgstr ""

#: ../../c-api/unicode.rst:650
msgid ""
"Return the name of the default string encoding, ``\"utf-8\"``. See "
":func:`sys.getdefaultencoding`."
msgstr "返回默认字符编码格式名称，即 ``\"utf-8\"``。 参见 :func:`sys.getdefaultencoding`。"

#: ../../c-api/unicode.rst:653
msgid ""
"The returned string does not need to be freed, and is valid until "
"interpreter shutdown."
msgstr "返回的字符串不需要被释放，并将保持可用直到解释器关闭。"

#: ../../c-api/unicode.rst:659
msgid "Return the length of the Unicode object, in code points."
msgstr "返回 Unicode 对象码位的长度。"

#: ../../c-api/unicode.rst:661
msgid "On error, set an exception and return ``-1``."
msgstr "发生错误时，将设置异常并返回 ``-1``。"

#: ../../c-api/unicode.rst:672
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to "
":c:func:`!memcpy` if possible.  Returns ``-1`` and sets an exception on "
"error, otherwise returns the number of copied characters."
msgstr ""
"将一个 Unicode 对象中的字符拷贝到另一个对象中。 此函数会在必要时执行字符转换并会在可能的情况下回退到 :c:func:`!memcpy`。 "
"在出错时将返回 ``-1`` 并设置一个异常，在其他情况下将返回拷贝的字符数量。"

#: ../../c-api/unicode.rst:677 ../../c-api/unicode.rst:707
#: ../../c-api/unicode.rst:727
msgid ""
"The string must not have been “used” yet. See :c:func:`PyUnicode_New` for "
"details."
msgstr ""

#: ../../c-api/unicode.rst:685
msgid "Resize a Unicode object *\\*unicode* to the new *length* in code points."
msgstr ""

#: ../../c-api/unicode.rst:687
msgid ""
"Try to resize the string in place (which is usually faster than allocating a"
" new string and copying characters), or create a new string."
msgstr ""

#: ../../c-api/unicode.rst:690
msgid ""
"*\\*unicode* is modified to point to the new (resized) object and ``0`` is "
"returned on success. Otherwise, ``-1`` is returned and an exception is set, "
"and *\\*unicode* is left untouched."
msgstr ""

#: ../../c-api/unicode.rst:694
msgid ""
"The function doesn't check string content, the result may not be a string in"
" canonical representation."
msgstr ""

#: ../../c-api/unicode.rst:701
msgid ""
"Fill a string with a character: write *fill_char* into "
"``unicode[start:start+length]``."
msgstr "使用一个字符填充字符串：将 *fill_char* 写入 ``unicode[start:start+length]``。"

#: ../../c-api/unicode.rst:704
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr "如果 *fill_char* 值大于字符串最大字符值，或者如果字符串有 1 以上的引用将执行失败。"

#: ../../c-api/unicode.rst:710
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr "返回写入的字符数量，或者在出错时返回 ``-1`` 并引发一个异常。"

#: ../../c-api/unicode.rst:719
msgid ""
"Write a *character* to the string *unicode* at the zero-based *index*. "
"Return ``0`` on success, ``-1`` on error with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:722
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object's reference count is one). See "
":c:func:`PyUnicode_WRITE` for a version that skips these checks, making them"
" your responsibility."
msgstr ""

#: ../../c-api/unicode.rst:735
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to "
":c:func:`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""
"从字符串读取一个字符。 该函数将检查 *unicode* 是否为 Unicode 对象且索引是否未越界，这不同于 "
":c:func:`PyUnicode_READ_CHAR`，后者不会执行任何错误检查。"

#: ../../c-api/unicode.rst:739
msgid "Return character on success, ``-1`` on error with an exception set."
msgstr "成功时返回字符，出错时返回 ``-1`` 并设置一个异常。"

#: ../../c-api/unicode.rst:747
msgid ""
"Return a substring of *unicode*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported. On "
"error, set an exception and return ``NULL``."
msgstr ""
"返回 *unicode* 的一个子串，从字符索引 *start* (含) 到字符索引 *end* (不含)。 不支持负索引号。 "
"出错时，将设置一个异常并返回 ``NULL``。"

#: ../../c-api/unicode.rst:757
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character, if"
" *copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*unicode*).  *buffer* is returned on success."
msgstr ""
"将字符串 *unicode* 拷贝到一个 UCS4 缓冲区，包括一个空字符，如果设置了 *copy_null* 的话。 出错时返回 ``NULL`` "
"并设置一个异常（特别是当 *buflen* 小于 *unicode* 的长度时，将设置 :exc:`SystemError` 异常）。 成功时返回 "
"*buffer*。"

#: ../../c-api/unicode.rst:767
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using "
":c:func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a "
":exc:`MemoryError` set.  The returned buffer always has an extra null code "
"point appended."
msgstr ""
"将字符串 *unicode* 拷贝到使用 :c:func:`PyMem_Malloc` 分配的新 UCS4 缓冲区。 如果执行失败，将返回 "
"``NULL`` 并设置 :exc:`MemoryError`。 返回的缓冲区将总是会添加一个额外的空码位。"

#: ../../c-api/unicode.rst:776
msgid "Locale Encoding"
msgstr "语言区域编码格式"

#: ../../c-api/unicode.rst:778
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr "当前语言区域编码格式可被用来解码来自操作系统的文本。"

#: ../../c-api/unicode.rst:785
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a"
" null character but cannot contain embedded null characters."
msgstr ""
"解码字符串在 Android 和 VxWorks 上使用 UTF-8，在其他平台上则使用当前语言区域编码格式。 支持的错误处理器有 "
"``\"strict\"`` 和 ``\"surrogateescape\"`` (:pep:`383`)。 如果 *errors* 为 "
"``NULL`` 则解码器将使用 ``\"strict\"`` 错误处理器。 *str* 必须以一个空字符结束但不可包含嵌入的空字符。"

#: ../../c-api/unicode.rst:792
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from the "
":term:`filesystem encoding and error handler`."
msgstr ""
"使用 :c:func:`PyUnicode_DecodeFSDefaultAndSize` 以 :term:`filesystem encoding "
"and error handler` 来解码字符串。"

#: ../../c-api/unicode.rst:795 ../../c-api/unicode.rst:830
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "此函数将忽略 :ref:`Python UTF-8 模式 <utf8-mode>`。"

#: ../../c-api/unicode.rst:799 ../../c-api/unicode.rst:915
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "The :c:func:`Py_DecodeLocale` 函数。"

#: ../../c-api/unicode.rst:803
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_DecodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"此函数现在也会为 ``surrogateescape`` 错误处理器使用当前语言区域编码格式，但在 Android 上例外。 "
"在之前版本中，:c:func:`Py_DecodeLocale` 将被用于 ``surrogateescape``，而当前语言区域编码格式将被用于 "
"``strict``。"

#: ../../c-api/unicode.rst:812
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`!strlen`."
msgstr ""
"类似于 :c:func:`PyUnicode_DecodeLocaleAndSize`，但会使用 :c:func:`!strlen` 来计算字符串长度。"

#: ../../c-api/unicode.rst:820
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a "
":class:`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"编码 Unicode 对象在 Android 和 VxWorks 上使用 UTF-8，在其他平台上使用当前语言区域编码格式。 支持的错误处理器有 "
"``\"strict\"`` 和 ``\"surrogateescape\"`` (:pep:`383`)。 如果 *errors* 为 "
"``NULL`` 则编码器将使用 ``\"strict\"`` 错误处理器。 返回一个 :class:`bytes` 对象。 *unicode* "
"不可包含嵌入的空字符。"

#: ../../c-api/unicode.rst:827
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to the "
":term:`filesystem encoding and error handler`."
msgstr ""
"使用 :c:func:`PyUnicode_EncodeFSDefault` 将字符串编码为 :term:`filesystem encoding "
"and error handler`。"

#: ../../c-api/unicode.rst:834 ../../c-api/unicode.rst:946
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr ":c:func:`Py_EncodeLocale` 函数。"

#: ../../c-api/unicode.rst:838
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_EncodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"此函数现在也会为 ``surrogateescape`` 错误处理器使用当前语言区域编码格式，但在 Android 上例外。 "
"在之前版本中，:c:func:`Py_EncodeLocale` 将被用于 ``surrogateescape``，而当前语言区域编码格式将被用于 "
"``strict``。"

#: ../../c-api/unicode.rst:847
msgid "File System Encoding"
msgstr "文件系统编码格式"

#: ../../c-api/unicode.rst:849
msgid ""
"Functions encoding to and decoding from the :term:`filesystem encoding and "
"error handler` (:pep:`383` and :pep:`529`)."
msgstr ""
"使用 :term:`filesystem encoding and error handler` 的编码和解码函数 (:pep:`383` 和 "
":pep:`529`)。"

#: ../../c-api/unicode.rst:852
msgid ""
"To encode file names to :class:`bytes` during argument parsing, the "
"``\"O&\"`` converter should be used, passing "
":c:func:`!PyUnicode_FSConverter` as the conversion function:"
msgstr ""
"要在参数解析期间将文件名编码为 :class:`bytes`，应当使用 ``\"O&\"`` 转换器，传入 "
":c:func:`!PyUnicode_FSConverter` 作为转换函数："

#: ../../c-api/unicode.rst:858
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: encode :class:`str` objects "
"-- obtained directly or through the :class:`os.PathLike` interface -- to "
":class:`bytes` using :c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes` "
"objects are output as-is. *result* must be an address of a C variable of "
"type :c:expr:`PyObject*` (or :c:expr:`PyBytesObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`bytes object "
"<bytesobjects>` which must be released when it is no longer used and return "
"a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null bytes are "
"not allowed in the result. On failure, return ``0`` with an exception set."
msgstr ""
":ref:`PyArg_Parse\\* 转换器 <arg-parsing>`: 使用 "
":c:func:`PyUnicode_EncodeFSDefault` 编码 :class:`str` 对象 -- 直接获取或通过 "
":class:`os.PathLike` 接口 -- 为 :class:`bytes`; :class:`bytes` 对象将被原样输出。 "
"*result* 必须是一个类型为 :c:expr:`PyObject*` (或 :c:expr:`PyBytesObject*`) 的 C "
"变量的地址。 执行成功时，将把该变量设为指向一个 :ref:`字节串对象 <bytesobjects>` 的新的 :term:`strong "
"reference`，它必须在其不再使用时被释放并返回一个非零值 (:c:macro:`Py_CLEANUP_SUPPORTED`)。 "
"结果中不允许嵌入空字节。 执行失败时，将返回 ``0`` 并设置一个异常。"

#: ../../c-api/unicode.rst:870
msgid ""
"If *obj* is ``NULL``, the function releases a strong reference stored in the"
" variable referred by *result* and returns ``1``."
msgstr "如果 *obj* 为 ``NULL``，该函数将释放存放在 *result* 所引用的变量中的强引用并返回 ``1``。"

#: ../../c-api/unicode.rst:875 ../../c-api/unicode.rst:902
msgid "Accepts a :term:`path-like object`."
msgstr "接受一个 :term:`path-like object`。"

#: ../../c-api/unicode.rst:878
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"``"
" converter should be used, passing :c:func:`!PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"要在参数解析期间将文件名解码为 :class:`str`，应当使用 ``\"O&\"`` 转换器，传入 "
":c:func:`!PyUnicode_FSDecoder` 作为转换函数："

#: ../../c-api/unicode.rst:884
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: decode :class:`bytes` objects"
" -- obtained either directly or indirectly through the :class:`os.PathLike` "
"interface -- to :class:`str` using "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` objects are output "
"as-is. *result* must be an address of a C variable of type "
":c:expr:`PyObject*` (or :c:expr:`PyUnicodeObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`Unicode object "
"<unicodeobjects>` which must be released when it is no longer used and "
"return a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null "
"characters are not allowed in the result. On failure, return ``0`` with an "
"exception set."
msgstr ""
":ref:`PyArg_Parse\\* 转换器 <arg-parsing>`: 使用 "
":c:func:`PyUnicode_DecodeFSDefaultAndSize` 解码 :class:`bytes` 对象 -- 直接获取或通过 "
":class:`os.PathLike` 接口 -- 为 :class:`str`; :class:`str` 对象将被原样输出。 *result* "
"必须是一个类型为 :c:expr:`PyObject*` (或 :c:expr:`PyUnicodeObject*`) 的 C 变量的地址。 "
"执行成功时，将把该变量设为指向一个 :ref:`Unicode 对象 <unicodeobjects>` 的新的 :term:`strong "
"reference`，它必须在其不再使用时被释放并返回一个非零值 (:c:macro:`Py_CLEANUP_SUPPORTED`)。 "
"结果中不允许嵌入空字节。 执行失败时，将返回 ``0`` 并设置一个异常。"

#: ../../c-api/unicode.rst:897
msgid ""
"If *obj* is ``NULL``, release the strong reference to the object referred to"
" by *result* and return ``1``."
msgstr "如果 *obj* 为 ``NULL``，则释放指向 *result* 所引用的对象的强引用并返回 ``1``。"

#: ../../c-api/unicode.rst:908
msgid ""
"Decode a string from the :term:`filesystem encoding and error handler`."
msgstr "使用 :term:`filesystem encoding and error handler` 解码字符串。"

#: ../../c-api/unicode.rst:910
msgid ""
"If you need to decode a string from the current locale encoding, use "
":c:func:`PyUnicode_DecodeLocaleAndSize`."
msgstr "如果你需要以当前语言区域编码格式解码字符串，请使用 :c:func:`PyUnicode_DecodeLocaleAndSize`。"

#: ../../c-api/unicode.rst:917 ../../c-api/unicode.rst:930
#: ../../c-api/unicode.rst:950
msgid ""
"The :term:`filesystem error handler <filesystem encoding and error handler>`"
" is now used."
msgstr "现在将使用 :term:`文件系统编码格式和错误处理器 <filesystem encoding and error handler>`。"

#: ../../c-api/unicode.rst:924
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr "使用 :term:`filesystem encoding and error handler` 解码以空值结尾的字符串。"

#: ../../c-api/unicode.rst:927
msgid ""
"If the string length is known, use "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`."
msgstr "如果字符串长度已知，则使用 :c:func:`PyUnicode_DecodeFSDefaultAndSize`。"

#: ../../c-api/unicode.rst:937
msgid ""
"Encode a Unicode object to the :term:`filesystem encoding and error "
"handler`, and return :class:`bytes`. Note that the resulting :class:`bytes` "
"object can contain null bytes."
msgstr ""
"使用 :term:`filesystem encoding and error handler` 编码一个 Unicode 对象，并返回 "
":class:`bytes`。 请注意结果 :class:`bytes` 对象可以包含空字节。"

#: ../../c-api/unicode.rst:941
msgid ""
"If you need to encode a string to the current locale encoding, use "
":c:func:`PyUnicode_EncodeLocale`."
msgstr "如果你需要以当前语言区域编码格式编码字符串，请使用 :c:func:`PyUnicode_EncodeLocale`。"

#: ../../c-api/unicode.rst:955
msgid "wchar_t Support"
msgstr "wchar_t 支持"

#: ../../c-api/unicode.rst:957
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr "在受支持的平台上支持 :c:type:`wchar_t`:"

#: ../../c-api/unicode.rst:961
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function must "
"itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` on "
"failure."
msgstr ""
"根据给定的 *size* 的 :c:type:`wchar_t` 缓冲区 *wstr* 创建一个 Unicode 对象。 传入 ``-1`` 作为 "
"*size* 表示该函数必须使用 :c:func:`!wcslen` 自动计算缓冲区长度。 失败时将返回 ``NULL``。"

#: ../../c-api/unicode.rst:969
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *wstr*.  "
"At most *size* :c:type:`wchar_t` characters are copied (excluding a possibly"
" trailing null termination character).  Return the number of "
":c:type:`wchar_t` characters copied or ``-1`` in case of an error."
msgstr ""
"将 Unicode 对象的内容拷贝到 :c:type:`wchar_t` 缓冲区 *wstr* 中。 至多拷贝 *size* 个 "
":c:type:`wchar_t` 字符（不包括可能存在的末尾空结束字符）。 返回拷贝的 :c:type:`wchar_t` 字符数或在出错时返回 "
"``-1``。"

#: ../../c-api/unicode.rst:974
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required to"
" store all of *unicode* including a terminating null."
msgstr "当 *wstr* 为 ``NULL`` 时，则改为返回存储包括结束空值在内的所有 *unicode* 内容所需的 *size*。"

#: ../../c-api/unicode.rst:977
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the "
":c:expr:`wchar_t*` string is null-terminated in case this is required by the"
" application. Also, note that the :c:expr:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with"
" most C functions."
msgstr ""
"请注意结果 :c:expr:`wchar_t*` 字符串可能是以空值结束也可能不是。 调用方要负责确保 :c:expr:`wchar_t*` "
"字符串以空值结束以防应用有此要求。 此外，请注意 :c:expr:`wchar_t*` 字符串有可能包含空字符，这将导致字符串在与大多数 C "
"函数一起使用时被截断。"

#: ../../c-api/unicode.rst:987
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the "
":c:expr:`wchar_t*` string contains null characters a :exc:`ValueError` is "
"raised."
msgstr ""
"将 Unicode 对象转换为宽字符串。 输出字符串将总是以空字符结尾。 如果 *size* 不为 "
"``NULL``，则会将宽字符的数量（不包括结尾空字符）写入到 *\\*size* 中。 请注意结果 :c:type:`wchar_t` "
"字符串可能包含空字符，这将导致在大多数 C 函数中使用时字符串被截断。 如果 *size* 为 ``NULL`` 并且 "
":c:expr:`wchar_t*` 字符串包含空字符则将引发 :exc:`ValueError`。"

#: ../../c-api/unicode.rst:995
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use :c:func:`PyMem_Free`"
" to free it) on success. On error, returns ``NULL`` and *\\*size* is "
"undefined. Raises a :exc:`MemoryError` if memory allocation is failed."
msgstr ""
"成功时返回由 :c:macro:`PyMem_New` 分配的缓冲区（使用 :c:func:`PyMem_Free` 来释放它）。 发生错误时，则返回 "
"``NULL`` 并且 *\\*size* 将是未定义的。 如果内存分配失败则会引发 :exc:`MemoryError`。"

#: ../../c-api/unicode.rst:1002
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""
"如果 *size* 为 ``NULL`` 且 :c:expr:`wchar_t*` 字符串包含空字符则会引发 :exc:`ValueError`。"

#: ../../c-api/unicode.rst:1010
msgid "Built-in Codecs"
msgstr "内置编解码器"

#: ../../c-api/unicode.rst:1012
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr "Python 提供了一组以 C 编写以保证运行速度的内置编解码器。 所有这些编解码器均可通过下列函数直接使用。"

#: ../../c-api/unicode.rst:1015
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"下列 API 大都接受 encoding 和 errors 两个参数，它们具有与在内置 :func:`str` 字符串对象构造器中同名参数相同的语义。"

#: ../../c-api/unicode.rst:1019
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is"
" UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` "
"for encoding file names. This uses the :term:`filesystem encoding and error "
"handler` internally."
msgstr ""
"将 encoding 设为 ``NULL`` 将使用默认编码格式即 UTF-8。 文件系统调用应当使用 "
":c:func:`PyUnicode_FSConverter` 来编码文件名。 这将在内部使用 :term:`filesystem encoding "
"and error handler`。"

#: ../../c-api/unicode.rst:1024
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to"
" use the default handling defined for the codec.  Default error handling for"
" all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"错误处理方式由 errors 设置并且也可以设为 ``NULL`` 表示使用为编解码器定义的默认处理方式。 所有内置编解码器的默认错误处理方式是 "
"\"strict\" (会引发 :exc:`ValueError`)。"

#: ../../c-api/unicode.rst:1028
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr "编解码器都使用类似的接口。 为了保持简单只有与下列泛型编解码器的差异才会记录在文档中。"

#: ../../c-api/unicode.rst:1033
msgid "Generic Codecs"
msgstr "泛型编解码器"

#: ../../c-api/unicode.rst:1035
msgid "The following macro is provided:"
msgstr ""

#: ../../c-api/unicode.rst:1040
msgid "The Unicode code point ``U+FFFD`` (replacement character)."
msgstr ""

#: ../../c-api/unicode.rst:1042
msgid ""
"This Unicode character is used as the replacement character during decoding "
"if the *errors* argument is set to \"replace\"."
msgstr ""

#: ../../c-api/unicode.rst:1046
msgid "These are the generic codec APIs:"
msgstr "以下是泛型编解码器的 API:"

#: ../../c-api/unicode.rst:1052
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of "
"the same name in the :func:`str` built-in function.  The codec to be used is"
" looked up using the Python codec registry.  Return ``NULL`` if an exception"
" was raised by the codec."
msgstr ""
"通过解码已编码字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 *encoding* 和 *errors* 具有与 "
":func:`str` 内置函数中同名形参相同的含义。 要使用的编解码将使用 Python 编解码器注册表来查找。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1062
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"编码一个 Unicode 对象并将结果作为 Python 字节串对象返回。 *encoding* 和 *errors* 具有与 Unicode "
":meth:`~str.encode` 方法中同名形参相同的含义。 要使用的编解码器将使用 Python 编解码器注册表来查找。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1070
msgid "UTF-8 Codecs"
msgstr "UTF-8 编解码器"

#: ../../c-api/unicode.rst:1072
msgid "These are the UTF-8 codec APIs:"
msgstr "以下是 UTF-8 编解码器 API:"

#: ../../c-api/unicode.rst:1077
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string"
" *str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 UTF-8 编码的字节串 *str* 的的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1084
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF8`。 如果 "
"*consumed* 不为 ``NULL``，则末尾的不完整 UTF-8 字节序列将不被视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 "
"*consumed* 中。"

#: ../../c-api/unicode.rst:1092
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 UTF-8 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1096 ../../c-api/unicode.rst:1111
msgid ""
"The function fails if the string contains surrogate code points (``U+D800`` "
"- ``U+DFFF``)."
msgstr "如果字符串包含代理码位 (``U+D800`` - ``U+DFFF``) 则该函数的执行将失败。"

#: ../../c-api/unicode.rst:1102
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned"
" buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"返回一个指向 Unicode 对象的 UTF-8 编码格式数据的指针，并将已编码数据的大小（以字节为单位）存储在 *size* 中。 *size* "
"参数可以为 ``NULL``；在此情况下数据的大小将不会被存储。 返回的缓冲区总是会添加一个额外的空字节（不包括在 *size* "
"中），无论是否存在任何其他的空码位。"

#: ../../c-api/unicode.rst:1108
msgid ""
"On error, set an exception, set *size* to ``-1`` (if it's not NULL) and "
"return ``NULL``."
msgstr "发生错误时，设置一个异常，将 *size* 设为 ``-1`` (如果不为 NULL) 并返回 ``NULL``。"

#: ../../c-api/unicode.rst:1114
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"这将缓存 Unicode 对象中字符串的 UTF-8 表示形式，并且后续调用将返回指向同一缓存区的指针。 调用方不必负责释放该缓冲区。 缓冲区会在 "
"Unicode 对象被作为垃圾回收时被释放并使指向它的指针失效。"

#: ../../c-api/unicode.rst:1121 ../../c-api/unicode.rst:1143
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "返回类型现在是 ``const char *`` 而不是 ``char *``。"

#: ../../c-api/unicode.rst:1124
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr "此函数是 :ref:`受限 API <limited-c-api>` 的组成部分。"

#: ../../c-api/unicode.rst:1130
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "类似于 :c:func:`PyUnicode_AsUTF8AndSize`，但不会存储大小值。"

#: ../../c-api/unicode.rst:1134
msgid ""
"This function does not have any special behavior for `null characters "
"<https://en.wikipedia.org/wiki/Null_character>`_ embedded within *unicode*. "
"As a result, strings containing null characters will remain in the returned "
"string, which some C functions might interpret as the end of the string, "
"leading to truncation. If truncation is an issue, it is recommended to use "
":c:func:`PyUnicode_AsUTF8AndSize` instead."
msgstr ""
"此函数没有任何针对嵌入 *unicode* 内部的 `空字符 "
"<https://en.wikipedia.org/wiki/Null_character>`_ 的特殊行为。 "
"因此，字符串中包含的空字符将保留在返回的字符串中，这在某些 C 函数中可能会被解读为字符串的结束，导致其被截断。 如果截断会带来问题，建议改用 "
":c:func:`PyUnicode_AsUTF8AndSize`。"

#: ../../c-api/unicode.rst:1148
msgid "UTF-32 Codecs"
msgstr "UTF-32 编解码器"

#: ../../c-api/unicode.rst:1150
msgid "These are the UTF-32 codec APIs:"
msgstr "以下是 UTF-32 编解码器 API:"

#: ../../c-api/unicode.rst:1156
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"从 UTF-32 编码的缓冲区数据解码 *size* 个字节并返回相应的 Unicode 对象。 *errors* (如果不为 ``NULL``) "
"定义了错误处理方式。 默认为 \"strict\"。"

#: ../../c-api/unicode.rst:1160 ../../c-api/unicode.rst:1210
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr "如果 *byteorder* 不为 ``NULL``，解码器将使用给定的字节序进行解码::"

#: ../../c-api/unicode.rst:1163 ../../c-api/unicode.rst:1213
msgid ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"
msgstr ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"

#: ../../c-api/unicode.rst:1167
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"如果 ``*byteorder`` 为零，且输入数据的前四个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 "
"Unicode 字符串中。 如果 ``*byteorder`` 为 ``-1`` 或 ``1``，则字节序标记会被拷贝到输出中。"

#: ../../c-api/unicode.rst:1172
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end"
" of input data."
msgstr "在完成后，*\\*byteorder* 将在输入数据的末尾被设为当前字节序。"

#: ../../c-api/unicode.rst:1175 ../../c-api/unicode.rst:1226
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr "如果 *byteorder* 为 ``NULL``，编解码器将使用本机字节序。"

#: ../../c-api/unicode.rst:1177 ../../c-api/unicode.rst:1228
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1183
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not"
" treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF32`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeUTF32Stateful` 将不把末尾的不完整 "
"UTF-32 字节序列（如字节数不可被四整除）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1192
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"返回使用 UTF-32 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1198
msgid "UTF-16 Codecs"
msgstr "UTF-16 编解码器"

#: ../../c-api/unicode.rst:1200
msgid "These are the UTF-16 codec APIs:"
msgstr "以下是 UTF-16 编解码器的 API:"

#: ../../c-api/unicode.rst:1206
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"从 UTF-16 编码的缓冲区数据解码 *size* 个字节并返回相应的 Unicode 对象。 *errors* (如果不为 ``NULL``) "
"定义了错误处理方式。 默认为 \"strict\"。"

#: ../../c-api/unicode.rst:1217
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"如果 ``*byteorder`` 为零，且输入数据的前两个字节为字节序标记 (BOM)，则解码器将切换为该字节序并且 BOM 将不会被拷贝到结果 "
"Unicode 字符串中。 如果 ``*byteorder`` 为 ``-1`` 或 ``1``，则字节序标记会被拷贝到输出中 (它将是一个 "
"``\\ufeff`` 或 ``\\ufffe`` 字符)。"

#: ../../c-api/unicode.rst:1223
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end"
" of input data."
msgstr "在完成后，``*byteorder`` 将在输入数据的末尾被设为当前字节序。"

#: ../../c-api/unicode.rst:1234
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not"
" treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF16`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeUTF16Stateful` 将不把末尾的不完整 "
"UTF-16 字节序列（如为奇数个字节或为分开的替代对）视为错误。 这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1243
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"返回使用 UTF-16 编码格式本机字节序的 Python 字节串。 字节串将总是以 BOM 标记打头。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1249
msgid "UTF-7 Codecs"
msgstr "UTF-7 编解码器"

#: ../../c-api/unicode.rst:1251
msgid "These are the UTF-7 codec APIs:"
msgstr "以下是 UTF-7 编解码器 API:"

#: ../../c-api/unicode.rst:1256
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string"
" *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 UTF-7 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1263
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeUTF7`。 如果 "
"*consumed* 不为 ``NULL``，则末尾的不完整 UTF-7 base-64 部分将不被视为错误。 "
"这些字节将不会被解码并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1270
msgid "Unicode-Escape Codecs"
msgstr "Unicode-Escape 编解码器"

#: ../../c-api/unicode.rst:1272
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "以下是 \"Unicode Escape\" 编解码器的 API:"

#: ../../c-api/unicode.rst:1278
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"通过解码 Unicode-Escape 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回"
" ``NULL``。"

#: ../../c-api/unicode.rst:1284
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"使用 Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1290
msgid "Raw-Unicode-Escape Codecs"
msgstr "Raw-Unicode-Escape 编解码器"

#: ../../c-api/unicode.rst:1292
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "以下是 \"Raw Unicode Escape\" 编解码器的 API:"

#: ../../c-api/unicode.rst:1298
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"通过解码 Raw-Unicode-Escape 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1304
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"使用 Raw-Unicode-Escape 编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1310
msgid "Latin-1 Codecs"
msgstr "Latin-1 编解码器"

#: ../../c-api/unicode.rst:1312
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr "以下是 Latin-1 编解码器的 API: Latin-1 对应于前 256 个 Unicode 码位且编码器在编码期间只接受这些码位。"

#: ../../c-api/unicode.rst:1318
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 Latin-1 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1324
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 Latin-1 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1330
msgid "ASCII Codecs"
msgstr "ASCII 编解码器"

#: ../../c-api/unicode.rst:1332
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr "以下是 ASCII 编解码器的 API。 只接受 7 位 ASCII 数据。 任何其他编码的数据都将导致错误。"

#: ../../c-api/unicode.rst:1338
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string"
" *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 ASCII 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 "
"``NULL``。"

#: ../../c-api/unicode.rst:1344
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 ASCII 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1350
msgid "Character Map Codecs"
msgstr "字符映射编解码器"

#: ../../c-api/unicode.rst:1352
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses mappings "
"to encode and decode characters.  The mapping objects provided must support "
"the :meth:`~object.__getitem__` mapping interface; dictionaries and "
"sequences work well."
msgstr ""
"此编解码器的特殊之处在于它可被用来实现许多不同的编解码器（而且这实际上就是包括在 :mod:`!encodings` "
"包中的大部分标准编解码器的实现方式）。 此编解码器使用映射来编码和解码字符。 所提供的映射对象必须支持 "
":meth:`~object.__getitem__` 映射接口；字典和序列均可胜任。"

#: ../../c-api/unicode.rst:1358
msgid "These are the mapping codec APIs:"
msgstr "以下是映射编解码器的 API:"

#: ../../c-api/unicode.rst:1363
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *str*"
" using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"通过使用给定的 *mapping* 对象解码已编码字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 "
"如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1367
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"如果 *mapping* 为 ``NULL``，则将应用 Latin-1 编码格式。 否则 *mapping* 必须为字节码位值（0 至 255 "
"范围内的整数）到 Unicode 字符串的映射、整数（将被解读为 Unicode 码位）或 ``None``。 未映射的数据字节 -- 这样的数据将导致"
" :exc:`LookupError`，以及被映射到 ``None`` 的数据，``0xFFFE`` 或 "
"``'\\ufffe'``，将被视为未定义的映射并导致报错。"

#: ../../c-api/unicode.rst:1378
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if"
" an exception was raised by the codec."
msgstr ""
"使用给定的 *mapping* 对象编码 Unicode 对象并将结果作为字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1382
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"*mapping* 对象必须将整数 Unicode 码位映射到字节串对象、0 至 255 范围内的整数或 ``None``。 未映射的字符码位（将导致 "
":exc:`LookupError` 的数据）以及映射到 ``None`` 的数据将被视为“未定义的映射”并导致报错。"

#: ../../c-api/unicode.rst:1388
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr "以下特殊的编解码器 API 会将 Unicode 映射至 Unicode。"

#: ../../c-api/unicode.rst:1392
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr "通过应用字符映射表来转写字符串并返回结果 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1396
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr "字符映射表必须将整数 Unicode 码位映射到整数 Unicode 码位或 ``None`` (这将删除相应的字符)。"

#: ../../c-api/unicode.rst:1399
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""
"映射表只需提供 :meth:`~object.__getitem__` 接口；字典和序列均可胜任。 未映射的字符码位（将导致 "
":exc:`LookupError` 的数据）将保持不变并被原样拷贝。"

#: ../../c-api/unicode.rst:1403
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr "*errors* 具有用于编解码器的通常含义。 它可以为 ``NULL`` 表示使用默认的错误处理方式。"

#: ../../c-api/unicode.rst:1408
msgid "MBCS codecs for Windows"
msgstr "Windows 中的 MBCS 编解码器"

#: ../../c-api/unicode.rst:1410
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"以下是 MBCS 编解码器的 API。 目前它们仅在 Windows 中可用并使用 Win32 MBCS 转换器来实现转换。 请注意 MBCS（或 "
"DBCS）是一类编码格式，而非只有一个。 目标编码格式是由运行编解码器的机器上的用户设置定义的。"

#: ../../c-api/unicode.rst:1417
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"通过解码 MBCS 编码的字节串 *str* 的 *size* 个字节创建一个 Unicode 对象。 如果编解码器引发了异常则返回 ``NULL``。"

#: ../../c-api/unicode.rst:1424
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"如果 *consumed* 为 ``NULL``，则行为类似于 :c:func:`PyUnicode_DecodeMBCS`。 如果 "
"*consumed* 不为 ``NULL``，则 :c:func:`PyUnicode_DecodeMBCSStateful` "
"将不会解码末尾的不完整字节并且已被解码的字节数将存储在 *consumed* 中。"

#: ../../c-api/unicode.rst:1433
msgid ""
"Similar to :c:func:`PyUnicode_DecodeMBCSStateful`, except uses the code page"
" specified by *code_page*."
msgstr ""
"类似于 :c:func:`PyUnicode_DecodeMBCSStateful`，区别在于使用由 *code_page* 所指定的代码页。"

#: ../../c-api/unicode.rst:1439
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"使用 MBCS 编码 Unicode 对象并将结果作为 Python 字节串对象返回。 错误处理方式为 \"strict\"。 "
"如果编解码器引发了异常则将返回 ``NULL``。"

#: ../../c-api/unicode.rst:1446
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use "
":c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""
"使用指定的代码页编码 Unicode 对象并返回一个 Python 字节串对象。 如果编解码器引发了异常则返回 ``NULL``。 使用 "
":c:macro:`!CP_ACP` 代码页来获取 MBCS 解码器。"

#: ../../c-api/unicode.rst:1454
msgid "Methods & Slots"
msgstr "方法和槽位"

#: ../../c-api/unicode.rst:1460
msgid "Methods and Slot Functions"
msgstr "方法与槽位函数"

#: ../../c-api/unicode.rst:1462
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr "以下 API 可以处理输入的 Unicode 对象和字符串（在描述中我们称其为字符串）并返回适当的 Unicode 对象或整数值。"

#: ../../c-api/unicode.rst:1466
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr "如果发生异常它们都将返回 ``NULL`` 或 ``-1``。"

#: ../../c-api/unicode.rst:1471
msgid "Concat two strings giving a new Unicode string."
msgstr "拼接两个字符串得到一个新的 Unicode 字符串。"

#: ../../c-api/unicode.rst:1476
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"拆分一个字符串得到一个 Unicode 字符串的列表。 如果 *sep* 为 ``NULL``，则将根据空格来拆分所有子字符串。 "
"否则，将根据指定的分隔符来拆分。 最多拆分数为 *maxsplit*。 如为负值，则没有限制。 分隔符不包括在结果列表中。"

#: ../../c-api/unicode.rst:1481 ../../c-api/unicode.rst:1491
#: ../../c-api/unicode.rst:1512 ../../c-api/unicode.rst:1525
msgid "On error, return ``NULL`` with an exception set."
msgstr "当失败时，将返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/unicode.rst:1483
msgid "Equivalent to :py:meth:`str.split`."
msgstr "等价于 :py:meth:`str.split`。"

#: ../../c-api/unicode.rst:1488
msgid ""
"Similar to :c:func:`PyUnicode_Split`, but splitting will be done beginning "
"at the end of the string."
msgstr "类似于 :c:func:`PyUnicode_Split`，但拆分将从字符串末尾开始进行。"

#: ../../c-api/unicode.rst:1493
msgid "Equivalent to :py:meth:`str.rsplit`."
msgstr "等价于 :py:meth:`str.rsplit`。"

#: ../../c-api/unicode.rst:1498
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepends* is ``0``, the Line "
"break characters are not included in the resulting strings."
msgstr ""
"根据分行符来拆分 Unicode 字符串，返回一个 Unicode 字符串的列表。 CRLF 将被视为一个分行符。 如果 *keepends* 为 "
"``0``，则行分隔符将不包括在结果字符串中。"

#: ../../c-api/unicode.rst:1505
msgid ""
"Split a Unicode string at the first occurrence of *sep*, and return a "
"3-tuple containing the part before the separator, the separator itself, and "
"the part after the separator. If the separator is not found, return a "
"3-tuple containing the string itself, followed by two empty strings."
msgstr ""
"在 *sep* 首次出现的位置拆分 Unicode 字符串，并返回一个包含分隔符之前部分、分隔符本身，以及分隔符之后部分的 3 元组。 "
"如果分隔符未找到，则返回一个包含字符串本身，后面附带两个空字符串的 3 元组。"

#: ../../c-api/unicode.rst:1510 ../../c-api/unicode.rst:1523
msgid "*sep* must not be empty."
msgstr "*sep* 必须不为空。"

#: ../../c-api/unicode.rst:1514
msgid "Equivalent to :py:meth:`str.partition`."
msgstr "等价于 :py:meth:`str.partition`。"

#: ../../c-api/unicode.rst:1519
msgid ""
"Similar to :c:func:`PyUnicode_Partition`, but split a Unicode string at the "
"last occurrence of *sep*. If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"类似于 :c:func:`PyUnicode_Partition`，但会在 *sep* 最后一次出现的位置拆分 Unicode 字符串。 "
"如果分隔符未找到，则返回一个包含两个空字符串，后面附带字符串本身的 3 元组。"

#: ../../c-api/unicode.rst:1527
msgid "Equivalent to :py:meth:`str.rpartition`."
msgstr "等价于 :py:meth:`str.rpartition`。"

#: ../../c-api/unicode.rst:1532
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr "使用给定的 *separator* 合并一个字符串列表并返回结果 Unicode 字符串。"

#: ../../c-api/unicode.rst:1539
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail "
"end (*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` "
"a suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""
"如果 *substr* 在给定的端点 (*direction* == ``-1`` 表示前缀匹配, *direction* == ``1`` "
"表示后缀匹配) 与 ``unicode[start:end]`` 相匹配则返回 ``1``，否则返回 ``0``。 如果发生错误则返回 ``-1``。"

#: ../../c-api/unicode.rst:1547
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the "
"given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""
"返回使用给定的 *direction* (*direction* == ``1`` 表示前向搜索，*direction* == ``-1`` "
"表示后向搜索) 时 *substr* 在 ``unicode[start:end]`` 中首次出现的位置。 返回值为首个匹配的索引号；值为 ``-1``"
" 表示未找到匹配，``-2`` 则表示发生了错误并设置了异常。"

#: ../../c-api/unicode.rst:1557
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]`` "
"using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is the "
"index of the first match; a value of ``-1`` indicates that no match was "
"found, and ``-2`` indicates that an error occurred and an exception has been"
" set."
msgstr ""
"返回使用给定的 *direction* (*direction* == ``1`` 表示前向搜索，*direction* == ``-1`` "
"表示后向搜索) 时字符 *ch* 在 ``unicode[start:end]`` 中首次出现的位置。 返回值为首个匹配的索引号；值为 ``-1`` "
"表示未找到匹配，``-2`` 则表示发生错误并设置了异常。"

#: ../../c-api/unicode.rst:1565
msgid ""
"*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr "现在 *start* 和 *end* 被调整为与 ``unicode[start:end]`` 类似的行为。"

#: ../../c-api/unicode.rst:1572
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr "返回 *substr* 在 ``unicode[start:end]`` 中不重叠出现的次数。 如果发生错误则返回 ``-1``。"

#: ../../c-api/unicode.rst:1579
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""
"将 *unicode* 中 *substr* 替换为 *replstr* 至多 *maxcount* 次并返回结果 Unicode 对象。 "
"*maxcount* == ``-1`` 表示全部替换。"

#: ../../c-api/unicode.rst:1586
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr "比较两个字符串并返回 ``-1``, ``0``, ``1`` 分别表示小于、等于和大于。"

#: ../../c-api/unicode.rst:1589
msgid ""
"This function returns ``-1`` upon failure, so one should call "
":c:func:`PyErr_Occurred` to check for errors."
msgstr "此函数执行失败时返回 ``-1``，因此应当调用 :c:func:`PyErr_Occurred` 来检查错误。"

#: ../../c-api/unicode.rst:1594
msgid "The :c:func:`PyUnicode_Equal` function."
msgstr ""

#: ../../c-api/unicode.rst:1599
msgid "Test if two strings are equal:"
msgstr ""

#: ../../c-api/unicode.rst:1601
msgid "Return ``1`` if *a* is equal to *b*."
msgstr ""

#: ../../c-api/unicode.rst:1602
msgid "Return ``0`` if *a* is not equal to *b*."
msgstr ""

#: ../../c-api/unicode.rst:1603
msgid ""
"Set a :exc:`TypeError` exception and return ``-1`` if *a* or *b* is not a "
":class:`str` object."
msgstr ""

#: ../../c-api/unicode.rst:1606
msgid "The function always succeeds if *a* and *b* are :class:`str` objects."
msgstr ""

#: ../../c-api/unicode.rst:1608
msgid ""
"The function works for :class:`str` subclasses, but does not honor custom "
"``__eq__()`` method."
msgstr ""

#: ../../c-api/unicode.rst:1613
msgid "The :c:func:`PyUnicode_Compare` function."
msgstr ""

#: ../../c-api/unicode.rst:1620
msgid ""
"Compare a Unicode object with a char buffer which is interpreted as being "
"UTF-8 or ASCII encoded and return true (``1``) if they are equal, or false "
"(``0``) otherwise. If the Unicode object contains surrogate code points "
"(``U+D800`` - ``U+DFFF``) or the C string is not valid UTF-8, false (``0``) "
"is returned."
msgstr ""
"将一个 Unicode 对象与一个按 UTF-8 或 ASCII 编码来解读的字符缓冲区进行比较并在两者相等时返回真值 (``1``)，否则返回假值 "
"(``0``)。 如果 Unicode 对象包含代理码位 (``U+D800`` - ``U+DFFF``) 或者如果 C 字符串不是有效的 UTF-8"
" 编码，则返回假值 (``0``)。"

#: ../../c-api/unicode.rst:1627 ../../c-api/unicode.rst:1648
msgid "This function does not raise exceptions."
msgstr "此函数不会引发异常。"

#: ../../c-api/unicode.rst:1634
msgid ""
"Similar to :c:func:`PyUnicode_EqualToUTF8AndSize`, but compute *string* "
"length using :c:func:`!strlen`. If the Unicode object contains null "
"characters, false (``0``) is returned."
msgstr ""
"类似于 :c:func:`PyUnicode_EqualToUTF8AndSize`，但会使用 :c:func:`!strlen` 来计算 "
"*string* 的长度。 如果 Unicode 对象包含空字符，则返回假值 (``0``)。"

#: ../../c-api/unicode.rst:1643
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, ``0``,"
" ``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"将 Unicode 对象 *unicode* 与 *string* 进行比较并返回 ``-1``, ``0``, ``1`` 分别表示小于、等于和大于。"
" 最好只传入 ASCII 编码的字符串，但如果输入字符串包含非 ASCII 字符则此函数会将其按 ISO-8859-1 编码格式来解读。"

#: ../../c-api/unicode.rst:1653
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "对两个 Unicode 字符串执行富比较并返回以下值之一:"

#: ../../c-api/unicode.rst:1655
msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` 用于引发了异常的情况"

#: ../../c-api/unicode.rst:1656
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr ":c:data:`Py_True` 或 :c:data:`Py_False` 用于成功完成比较的情况"

#: ../../c-api/unicode.rst:1657
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr ":c:data:`Py_NotImplemented` 用于类型组合未知的情况"

#: ../../c-api/unicode.rst:1659
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, "
":c:macro:`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`."
msgstr ""
"可能的 *op* 值有 :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:`Py_EQ`, "
":c:macro:`Py_NE`, :c:macro:`Py_LT`, 和 :c:macro:`Py_LE`。"

#: ../../c-api/unicode.rst:1665
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr "根据 *format* 和 *args* 返回一个新的字符串对象；这等同于 ``format % args``。"

#: ../../c-api/unicode.rst:1671
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false "
"accordingly."
msgstr "检查 *substr* 是否包含在 *unicode* 中并相应返回真值或假值。"

#: ../../c-api/unicode.rst:1674
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr "*substr* 必须强制转为一个单元素 Unicode 字符串。 如果发生错误则返回 ``-1``。"

#: ../../c-api/unicode.rst:1680
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be the"
" address of a pointer variable pointing to a Python Unicode string object.  "
"If there is an existing interned string that is the same as "
":c:expr:`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the "
"reference to the old string object and creating a new :term:`strong "
"reference` to the interned string object), otherwise it leaves "
":c:expr:`*p_unicode` alone and interns it."
msgstr ""
"原地内部化参数 :c:expr:`*p_unicode`。 该参数必须是一个指向 Python Unicode 字符串对象的指针变量的地址。 "
"如果已存在与 :c:expr:`*p_unicode` 相同的内部化字符串，则将其设为 :c:expr:`*p_unicode` "
"(释放对旧字符串的引用并新建一个指向该内部化字符串对象的 :term:`strong reference`)，否则将保持 "
":c:expr:`*p_unicode` 不变并将其内部化。"

#: ../../c-api/unicode.rst:1687
msgid ""
"(Clarification: even though there is a lot of talk about references, think "
"of this function as reference-neutral. You must own the object you pass in; "
"after the call you no longer own the passed-in reference, but you newly own "
"the result.)"
msgstr ""
"（澄清说明：虽然这里大量提及了引用，但请将此函数视为引用无关的。你必须拥有你传入的对象；在调用之后你将不再拥有传入的引用，但你将新拥有结果对象。）"

#: ../../c-api/unicode.rst:1692
msgid ""
"This function never raises an exception. On error, it leaves its argument "
"unchanged without interning it."
msgstr "此函数绝不会引发异常。 在发生错误时，它将保持其参数不变而不会将其内部化。"

#: ../../c-api/unicode.rst:1695
msgid ""
"Instances of subclasses of :py:class:`str` may not be interned, that is, "
":c:expr:`PyUnicode_CheckExact(*p_unicode)` must be true. If it is not, then "
"-- as with any other error -- the argument is left unchanged."
msgstr ""
":py:class:`str` 的子类的实例不可被内部化，也就是说，:c:expr:`PyUnicode_CheckExact(*p_unicode)`"
" 必须为真值。 如果其不为真值，那么 -- 就像发生其他错误时一样 -- 该参数将保持不变。"

#: ../../c-api/unicode.rst:1699
msgid ""
"Note that interned strings are not “immortal”. You must keep a reference to "
"the result to benefit from interning."
msgstr "请注意被内部化的字符串不是“永生的”。 你必须保留对结果的引用才能从内部化获益。"

#: ../../c-api/unicode.rst:1705
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace`, meant for statically allocated strings."
msgstr ""
":c:func:`PyUnicode_FromString` 和 :c:func:`PyUnicode_InternInPlace` "
"的结合，用于静态分配的字符串。"

#: ../../c-api/unicode.rst:1708
msgid ""
"Return a new (\"owned\") reference to either a new Unicode string object "
"that has been interned, or an earlier interned string object with the same "
"value."
msgstr "返回一个新的（“拥有的”）引用，它指向一个已被内部化的新 Unicode 字符串，或一个具有相同值的先前已被内部化的字符串对象。"

#: ../../c-api/unicode.rst:1712
msgid ""
"Python may keep a reference to the result, or make it :term:`immortal`, "
"preventing it from being garbage-collected promptly. For interning an "
"unbounded number of different strings, such as ones coming from user input, "
"prefer calling :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace` directly."
msgstr ""
"Python 可以保留一个指向结果的引用，或是使其成为 :term:`immortal` 对象，以防止其被立即被作为垃圾回收。 "
"对于内部化未限定数量的不同字符串，例如来自用户输入的字符串，建议直接调用 :c:func:`PyUnicode_FromString` 和 "
":c:func:`PyUnicode_InternInPlace`。"

#: ../../c-api/unicode.rst:1720
msgid "Strings interned this way are made :term:`immortal`."
msgstr "用此方式被内部化的字符串将成为 :term:`immortal` 对象。"

#: ../../c-api/unicode.rst:1725
msgid ""
"Return a non-zero value if *str* is interned, zero if not. The *str* "
"argument must be a string; this is not checked. This function always "
"succeeds."
msgstr ""

#: ../../c-api/unicode.rst:1731
msgid ""
"A non-zero return value may carry additional information about *how* the "
"string is interned. The meaning of such non-zero values, as well as each "
"specific string's intern-related details, may change between CPython "
"versions."
msgstr ""

#: ../../c-api/unicode.rst:1738
msgid "PyUnicodeWriter"
msgstr ""

#: ../../c-api/unicode.rst:1740
msgid ""
"The :c:type:`PyUnicodeWriter` API can be used to create a Python "
":class:`str` object."
msgstr ""

#: ../../c-api/unicode.rst:1747
msgid "A Unicode writer instance."
msgstr ""

#: ../../c-api/unicode.rst:1749
msgid ""
"The instance must be destroyed by :c:func:`PyUnicodeWriter_Finish` on "
"success, or :c:func:`PyUnicodeWriter_Discard` on error."
msgstr ""

#: ../../c-api/unicode.rst:1754
msgid "Create a Unicode writer instance."
msgstr ""

#: ../../c-api/unicode.rst:1756
msgid "*length* must be greater than or equal to ``0``."
msgstr ""

#: ../../c-api/unicode.rst:1758
msgid ""
"If *length* is greater than ``0``, preallocate an internal buffer of "
"*length* characters."
msgstr ""

#: ../../c-api/unicode.rst:1761 ../../c-api/unicode.rst:1767
msgid "Set an exception and return ``NULL`` on error."
msgstr ""

#: ../../c-api/unicode.rst:1765
msgid ""
"Return the final Python :class:`str` object and destroy the writer instance."
msgstr ""

#: ../../c-api/unicode.rst:1769 ../../c-api/unicode.rst:1777
msgid "The writer instance is invalid after this call."
msgstr ""

#: ../../c-api/unicode.rst:1773
msgid "Discard the internal Unicode buffer and destroy the writer instance."
msgstr ""

#: ../../c-api/unicode.rst:1775
msgid "If *writer* is ``NULL``, no operation is performed."
msgstr ""

#: ../../c-api/unicode.rst:1781
msgid "Write the single Unicode character *ch* into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1783 ../../c-api/unicode.rst:1793
#: ../../c-api/unicode.rst:1805 ../../c-api/unicode.rst:1814
#: ../../c-api/unicode.rst:1821 ../../c-api/unicode.rst:1828
#: ../../c-api/unicode.rst:1839 ../../c-api/unicode.rst:1846
#: ../../c-api/unicode.rst:1865
msgid ""
"On success, return ``0``. On error, set an exception, leave the writer "
"unchanged, and return ``-1``."
msgstr ""

#: ../../c-api/unicode.rst:1788
msgid ""
"Decode the string *str* from UTF-8 in strict mode and write the output into "
"*writer*."
msgstr ""

#: ../../c-api/unicode.rst:1790 ../../c-api/unicode.rst:1854
msgid ""
"*size* is the string length in bytes. If *size* is equal to ``-1``, call "
"``strlen(str)`` to get the string length."
msgstr ""

#: ../../c-api/unicode.rst:1796
msgid "See also :c:func:`PyUnicodeWriter_DecodeUTF8Stateful`."
msgstr ""

#: ../../c-api/unicode.rst:1800
msgid "Writer the wide string *str* into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1802
msgid ""
"*size* is a number of wide characters. If *size* is equal to ``-1``, call "
"``wcslen(str)`` to get the string length."
msgstr ""

#: ../../c-api/unicode.rst:1810
msgid "Writer the UCS4 string *str* into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1812
msgid "*size* is a number of UCS4 characters."
msgstr ""

#: ../../c-api/unicode.rst:1819
msgid ""
"Call :c:func:`PyObject_Str` on *obj* and write the output into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1826
msgid ""
"Call :c:func:`PyObject_Repr` on *obj* and write the output into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1833
msgid "Write the substring ``str[start:end]`` into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1835
msgid ""
"*str* must be Python :class:`str` object. *start* must be greater than or "
"equal to 0, and less than or equal to *end*. *end* must be less than or "
"equal to *str* length."
msgstr ""

#: ../../c-api/unicode.rst:1844
msgid ""
"Similar to :c:func:`PyUnicode_FromFormat`, but write the output directly "
"into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1851
msgid ""
"Decode the string *str* from UTF-8 with *errors* error handler and write the"
" output into *writer*."
msgstr ""

#: ../../c-api/unicode.rst:1857
msgid ""
"*errors* is an :ref:`error handler <error-handlers>` name, such as "
"``\"replace\"``. If *errors* is ``NULL``, use the strict error handler."
msgstr ""

#: ../../c-api/unicode.rst:1860
msgid ""
"If *consumed* is not ``NULL``, set *\\*consumed* to the number of decoded "
"bytes on success. If *consumed* is ``NULL``, treat trailing incomplete UTF-8"
" byte sequences as an error."
msgstr ""

#: ../../c-api/unicode.rst:1868
msgid "See also :c:func:`PyUnicodeWriter_WriteUTF8`."
msgstr ""

#: ../../c-api/unicode.rst:1871
msgid "Deprecated API"
msgstr ""

#: ../../c-api/unicode.rst:1873
msgid "The following API is deprecated."
msgstr ""

#: ../../c-api/unicode.rst:1877
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform. Please use :c:type:`wchar_t` directly "
"instead."
msgstr ""

#: ../../c-api/unicode.rst:1881
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr "在以前的版本中，这是16位类型还是32位类型，这取决于您在构建时选择的是“窄”还是“宽”Unicode版本的Python。"

#: ../../c-api/unicode.rst:1891
msgid ""
"Do nothing and return ``0``. This API is kept only for backward "
"compatibility, but there are no plans to remove it."
msgstr ""

#: ../../c-api/unicode.rst:1897
msgid ""
"This API does nothing since Python 3.12. Previously, this needed to be "
"called for each string created using the old API "
"(:c:func:`!PyUnicode_FromUnicode` or similar)."
msgstr ""

#: ../../c-api/unicode.rst:1905
msgid ""
"Do nothing and return ``1``. This API is kept only for backward "
"compatibility, but there are no plans to remove it."
msgstr ""

#: ../../c-api/unicode.rst:1911
msgid ""
"This API does nothing since Python 3.12. Previously, this could be called to"
" check if :c:func:`PyUnicode_READY` is necessary."
msgstr ""
