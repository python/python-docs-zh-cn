# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# lian Wu (Wulian) <xiguawulian@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2024-05-11 01:07+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/monitoring.rst:6
msgid "Monitoring C API"
msgstr "监控 C API"

#: ../../c-api/monitoring.rst:8
msgid "Added in version 3.13."
msgstr "在 3.13 版中添加。"

#: ../../c-api/monitoring.rst:10
msgid ""
"An extension may need to interact with the event monitoring system. "
"Subscribing to events and registering callbacks can be done via the Python "
"API exposed in :mod:`sys.monitoring`."
msgstr ""
"一个扩展可能需要与事件监视系统进行交互。 订阅事件和注册回调都可通过在 :mod:`sys.monitoring` 中暴露的 Python API "
"来完成。"

#: ../../c-api/monitoring.rst:15
msgid "Generating Execution Events"
msgstr "生成执行事件"

#: ../../c-api/monitoring.rst:17
msgid ""
"The functions below make it possible for an extension to fire monitoring "
"events as it emulates the execution of Python code. Each of these functions "
"accepts a ``PyMonitoringState`` struct which contains concise information "
"about the activation state of events, as well as the event arguments, which "
"include a ``PyObject*`` representing the code object, the instruction offset"
" and sometimes additional, event-specific arguments (see "
":mod:`sys.monitoring` for details about the signatures of the different "
"event callbacks). The ``codelike`` argument should be an instance of "
":class:`types.CodeType` or of a type that emulates it."
msgstr ""
"下面的函数使得扩展可以在模拟执行 Python 代码时触发监控事件。 这样的函数都接受一个 ``PyMonitoringState`` "
"结构体，其中包含有关事件激活状态的简明信息以及事件参数 ，此类参数包括代表代码对象的 "
"``PyObject*``、指令偏移量，有时还包括额外的、事件专属的参数（请参阅 :mod:`sys.monitoring` "
"了解有关不同事件回调签名的详情）。 ``codelike`` 参数应为 :class:`types.CodeType` 的实例或是某个模拟它的类型。"

#: ../../c-api/monitoring.rst:27
msgid ""
"The VM disables tracing when firing an event, so there is no need for user "
"code to do that."
msgstr "VM 会在触发事件时禁用跟踪，因此用户不需要额外的操作。"

#: ../../c-api/monitoring.rst:30
msgid ""
"Monitoring functions should not be called with an exception set, except "
"those listed below as working with the current exception."
msgstr "监控函数被调用时不应设置异常，除非是下面列出的用于处理当前异常的函数。"

#: ../../c-api/monitoring.rst:35
msgid ""
"Representation of the state of an event type. It is allocated by the user "
"while its contents are maintained by the monitoring API functions described "
"below."
msgstr "事件类型状态的表示形式。 它由用户分配，但其内容则由下文描述的监控 API 函数来维护。"

#: ../../c-api/monitoring.rst:39
msgid ""
"All of the functions below return 0 on success and -1 (with an exception "
"set) on error."
msgstr "下面的所有函数均在成功时返回 0 并在失败时返回 -1 (同时设置一个异常)。"

#: ../../c-api/monitoring.rst:41
msgid "See :mod:`sys.monitoring` for descriptions of the events."
msgstr "请参阅 :mod:`sys.monitoring` 获取事件的描述。"

#: ../../c-api/monitoring.rst:45
msgid "Fire a ``PY_START`` event."
msgstr "发出 ``PY_START`` 事件。"

#: ../../c-api/monitoring.rst:50
msgid "Fire a ``PY_RESUME`` event."
msgstr "发出 ``PY_RESUME`` 事件。"

#: ../../c-api/monitoring.rst:55
msgid "Fire a ``PY_RETURN`` event."
msgstr "发出 ``PY_RETURN`` 事件。"

#: ../../c-api/monitoring.rst:60
msgid "Fire a ``PY_YIELD`` event."
msgstr "发出 ``PY_YIELD`` 事件。"

#: ../../c-api/monitoring.rst:65
msgid "Fire a ``CALL`` event."
msgstr "发出 ``CALL`` 事件。"

#: ../../c-api/monitoring.rst:70
msgid "Fire a ``LINE`` event."
msgstr "发出 ``LINE`` 事件。"

#: ../../c-api/monitoring.rst:75
msgid "Fire a ``JUMP`` event."
msgstr "发出 ``JUMP`` 事件。"

#: ../../c-api/monitoring.rst:80
msgid "Fire a ``BRANCH_LEFT`` event."
msgstr ""

#: ../../c-api/monitoring.rst:85
msgid "Fire a ``BRANCH_RIGHT`` event."
msgstr ""

#: ../../c-api/monitoring.rst:90
msgid "Fire a ``C_RETURN`` event."
msgstr "发出 ``C_RETURN`` 事件。"

#: ../../c-api/monitoring.rst:95
msgid ""
"Fire a ``PY_THROW`` event with the current exception (as returned by "
":c:func:`PyErr_GetRaisedException`)."
msgstr "使用当前（即 :c:func:`PyErr_GetRaisedException` 返回的）异常发出 ``PY_THROW`` 事件。"

#: ../../c-api/monitoring.rst:101
msgid ""
"Fire a ``RAISE`` event with the current exception (as returned by "
":c:func:`PyErr_GetRaisedException`)."
msgstr ""
"使用当前（即 :c:func:`PyErr_GetRaisedException` 所返回的）异常发出 ``RAISE`` 事件。event with "
"the current )."

#: ../../c-api/monitoring.rst:107
msgid ""
"Fire a ``C_RAISE`` event with the current exception (as returned by "
":c:func:`PyErr_GetRaisedException`)."
msgstr "使用当前（即 :c:func:`PyErr_GetRaisedException` 所返回的）异常发出 ``C_RAISE`` 事件。"

#: ../../c-api/monitoring.rst:113
msgid ""
"Fire a ``RERAISE`` event with the current exception (as returned by "
":c:func:`PyErr_GetRaisedException`)."
msgstr "使用当前（即 :c:func:`PyErr_GetRaisedException` 所返回的）异常发出 ``RERAISE`` 事件。"

#: ../../c-api/monitoring.rst:119
msgid ""
"Fire an ``EXCEPTION_HANDLED`` event with the current exception (as returned "
"by :c:func:`PyErr_GetRaisedException`)."
msgstr ""
"使用当前（即 :c:func:`PyErr_GetRaisedException` 所返回的）异常发出 ``EXCEPTION_HANDLED`` "
"事件。"

#: ../../c-api/monitoring.rst:125
msgid ""
"Fire a ``PY_UNWIND`` event with the current exception (as returned by "
":c:func:`PyErr_GetRaisedException`)."
msgstr "使用当前（即 :c:func:`PyErr_GetRaisedException` 所返回的）异常发出 ``PY_UNWIND`` 事件。"

#: ../../c-api/monitoring.rst:131
msgid ""
"Fire a ``STOP_ITERATION`` event. If ``value`` is an instance of "
":exc:`StopIteration`, it is used. Otherwise, a new :exc:`StopIteration` "
"instance is created with ``value`` as its argument."
msgstr ""
"发出 ``STOP_ITERATION`` 事件。 如果 ``value`` 是一个 :exc:`StopIteration` 实例，它将被使用。 "
"在其他情况下，将新建一个 :exc:`StopIteration` 实例并以 ``value`` 作为其参数。"

#: ../../c-api/monitoring.rst:136
msgid "Managing the Monitoring State"
msgstr "管理监控状态"

#: ../../c-api/monitoring.rst:138
msgid ""
"Monitoring states can be managed with the help of monitoring scopes. A scope"
" would typically correspond to a python function."
msgstr "监控状态可在监控作用域的协助下进行管理。 一个作用域通常对应一个 python 函数。"

#: ../../c-api/monitoring.rst:143
msgid ""
"Enter a monitored scope. ``event_types`` is an array of the event IDs for "
"events that may be fired from the scope. For example, the ID of a "
"``PY_START`` event is the value ``PY_MONITORING_EVENT_PY_START``, which is "
"numerically equal to the base-2 logarithm of "
"``sys.monitoring.events.PY_START``. ``state_array`` is an array with a "
"monitoring state entry for each event in ``event_types``, it is allocated by"
" the user but populated by :c:func:`!PyMonitoring_EnterScope` with "
"information about the activation state of the event. The size of "
"``event_types`` (and hence also of ``state_array``) is given in ``length``."
msgstr ""
"进入一个监控作用域。 ``event_types`` 是由可从该作用域发生事件的事件 ID 组成的数组。 例如，``PY_START`` 事件的 ID "
"值为 ``PY_MONITORING_EVENT_PY_START``，其对应数字等于 "
"``sys.monitoring.events.PY_START`` 的以 2 为底的对数。 ``state_array`` 是由对应 "
"``event_types`` 中每个事件的监控状态组成的数组，它由用户进行分配但是由 "
":c:func:`!PyMonitoring_EnterScope` 使用事件激活状态相关信息填充。 ``event_types`` 的大小 (因而也是"
" ``state_array`` 的大小) 由 ``length`` 给出。"

#: ../../c-api/monitoring.rst:153
msgid ""
"The ``version`` argument is a pointer to a value which should be allocated "
"by the user together with ``state_array`` and initialized to 0, and then set"
" only by :c:func:`!PyMonitoring_EnterScope` itself. It allows this function "
"to determine whether event states have changed since the previous call, and "
"to return quickly if they have not."
msgstr ""
"``version`` 是一个指向应与 ``state_array`` 一起由用户分配的值并初始化为 0，然后仅由 "
":c:func:`!PyMonitoring_EnterScope` 本身来设置。 "
"它允许此函数确定事件状态自上次调用以来是否发生改变，并在它们未改变时立即返回。"

#: ../../c-api/monitoring.rst:159
msgid ""
"The scopes referred to here are lexical scopes: a function, class or method."
" :c:func:`!PyMonitoring_EnterScope` should be called whenever the lexical "
"scope is entered. Scopes can be reentered, reusing the same *state_array* "
"and *version*, in situations like when emulating a recursive Python "
"function. When a code-like's execution is paused, such as when emulating a "
"generator, the scope needs to be exited and re-entered."
msgstr ""
"这里所称的作用域是词法意义下的作用域：一个函数、类或方法。 :c:func:`!PyMonitoring_EnterScope` "
"应当在进入词法作用域时被调用。 在模拟一个递归 Python 函数之类的情况下，作用域可被重进入，并重用相同的 *state_array* 和 "
"*version*。 当某个代码执行暂停时，例如在模拟一个生成器时，此作用域需要被退出并重进入。"

#: ../../c-api/monitoring.rst:166
msgid "The macros for *event_types* are:"
msgstr "对应 *event_types* 的宏如下："

#: ../../c-api/monitoring.rst:174
msgid "Macro"
msgstr "宏"

#: ../../c-api/monitoring.rst:174
msgid "Event"
msgstr "事件"

#: ../../c-api/monitoring.rst:176
msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ""

#: ../../c-api/monitoring.rst:177
msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ""

#: ../../c-api/monitoring.rst:178
msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

#: ../../c-api/monitoring.rst:179
msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

#: ../../c-api/monitoring.rst:180
msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

#: ../../c-api/monitoring.rst:181
msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":monitoring-event:`EXCEPTION_HANDLED`"

#: ../../c-api/monitoring.rst:182
msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

#: ../../c-api/monitoring.rst:183
msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

#: ../../c-api/monitoring.rst:184
msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

#: ../../c-api/monitoring.rst:185
msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

#: ../../c-api/monitoring.rst:186
msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

#: ../../c-api/monitoring.rst:187
msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

#: ../../c-api/monitoring.rst:188
msgid ":monitoring-event:`PY_THROW`"
msgstr ":monitoring-event:`PY_THROW`"

#: ../../c-api/monitoring.rst:189
msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":monitoring-event:`PY_UNWIND`"

#: ../../c-api/monitoring.rst:190
msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

#: ../../c-api/monitoring.rst:191
msgid ":monitoring-event:`RAISE`"
msgstr ":monitoring-event:`RAISE`"

#: ../../c-api/monitoring.rst:192
msgid ":monitoring-event:`RERAISE`"
msgstr ":monitoring-event:`RERAISE`"

#: ../../c-api/monitoring.rst:193
msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

#: ../../c-api/monitoring.rst:198
msgid ""
"Exit the last scope that was entered with "
":c:func:`!PyMonitoring_EnterScope`."
msgstr "退出使用 :c:func:`!PyMonitoring_EnterScope` 进入的上一个作用域。"

#: ../../c-api/monitoring.rst:203
msgid ""
"Return true if the event corresponding to the event ID *ev* is a :ref:`local"
" event <monitoring-event-local>`."
msgstr "如果对应事件 ID *ev* 的事件属于 :ref:`局部事件 <monitoring-event-local>` 则返回真值。"

#: ../../c-api/monitoring.rst:210
msgid "This function is :term:`soft deprecated`."
msgstr "此函数状态为 :term:`soft deprecated`。"
