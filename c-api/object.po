# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 汪心禾 <wangxinhe06@gmail.com>, 2024
# 钢 彭 <szhairui@gmail.com>, 2024
# Zombie110year <zombie110year@gmail.com>, 2024
# ppcfish <ppcfish@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Alpha Du <alphanow@gmail.com>, 2024
# 稀饭~~ <wangwhai@qq.com>, 2024
# Dai Xu <daixu61@hotmail.com>, 2024
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/object.rst:6
msgid "Object Protocol"
msgstr "对象协议"

#: ../../c-api/object.rst:11
msgid "Get a :term:`strong reference` to a constant."
msgstr "获取一个指向常量的 :term:`strong reference`。"

#: ../../c-api/object.rst:13
msgid "Set an exception and return ``NULL`` if *constant_id* is invalid."
msgstr "如果 *constant_id* 无效则设置一个异常并返回 ``NULL``。"

#: ../../c-api/object.rst:15
msgid "*constant_id* must be one of these constant identifiers:"
msgstr "*constant_id* 必须是下列常量标识符之一："

#: ../../c-api/object.rst:20
msgid "Constant Identifier"
msgstr "常量标识符"

#: ../../c-api/object.rst:20
msgid "Value"
msgstr "值"

#: ../../c-api/object.rst:20
msgid "Returned object"
msgstr "返回的对象"

#: ../../c-api/object.rst:22 ../../c-api/object.rst:27
msgid "``0``"
msgstr "``0``"

#: ../../c-api/object.rst:22
msgid ":py:data:`None`"
msgstr ":py:data:`None`"

#: ../../c-api/object.rst:23 ../../c-api/object.rst:28
msgid "``1``"
msgstr "``1``"

#: ../../c-api/object.rst:23
msgid ":py:data:`False`"
msgstr ":py:data:`False`"

#: ../../c-api/object.rst:24
msgid "``2``"
msgstr "``2``"

#: ../../c-api/object.rst:24
msgid ":py:data:`True`"
msgstr ":py:data:`True`"

#: ../../c-api/object.rst:25
msgid "``3``"
msgstr "``3``"

#: ../../c-api/object.rst:25
msgid ":py:data:`Ellipsis`"
msgstr ":py:data:`Ellipsis`"

#: ../../c-api/object.rst:26
msgid "``4``"
msgstr "``4``"

#: ../../c-api/object.rst:26
msgid ":py:data:`NotImplemented`"
msgstr ":py:data:`NotImplemented`"

#: ../../c-api/object.rst:27
msgid "``5``"
msgstr "``5``"

#: ../../c-api/object.rst:28
msgid "``6``"
msgstr "``6``"

#: ../../c-api/object.rst:29
msgid "``7``"
msgstr "``7``"

#: ../../c-api/object.rst:29
msgid "``''``"
msgstr "``''``"

#: ../../c-api/object.rst:30
msgid "``8``"
msgstr "``8``"

#: ../../c-api/object.rst:30
msgid "``b''``"
msgstr "``b''``"

#: ../../c-api/object.rst:31
msgid "``9``"
msgstr "``9``"

#: ../../c-api/object.rst:31
msgid "``()``"
msgstr "``()``"

#: ../../c-api/object.rst:34
msgid ""
"Numeric values are only given for projects which cannot use the constant "
"identifiers."
msgstr "仅对无法使用常量标识符的项目才会给出数字值。"

#: ../../c-api/object.rst:42
msgid "In CPython, all of these constants are :term:`immortal`."
msgstr "在 CPython 中，所有这些常量都属于 :term:`immortal` 对象。"

#: ../../c-api/object.rst:47
msgid ""
"Similar to :c:func:`Py_GetConstant`, but return a :term:`borrowed "
"reference`."
msgstr "类似于 :c:func:`Py_GetConstant`，但会返回一个 :term:`borrowed reference`。"

#: ../../c-api/object.rst:50
msgid ""
"This function is primarily intended for backwards compatibility: using "
":c:func:`Py_GetConstant` is recommended for new code."
msgstr "此函数的主要目的是用于向下兼容：对于新代码推荐使用 :c:func:`Py_GetConstant`。"

#: ../../c-api/object.rst:53
msgid ""
"The reference is borrowed from the interpreter, and is valid until the "
"interpreter finalization."
msgstr "该引用是从解释器借入的，并将保持可用直到解释器最终化。"

#: ../../c-api/object.rst:61
msgid ""
"The ``NotImplemented`` singleton, used to signal that an operation is not "
"implemented for the given type combination."
msgstr "``NotImplemented`` 单例，用于标记某个操作没有针对给定类型组合的实现。"

#: ../../c-api/object.rst:67
msgid ""
"Properly handle returning :c:data:`Py_NotImplemented` from within a C "
"function (that is, create a new :term:`strong reference` to "
":const:`NotImplemented` and return it)."
msgstr ""
"正确处理从 C 函数内部返回 :c:data:`Py_NotImplemented` 的问题（即新建一个指向 "
":const:`NotImplemented` 的 :term:`strong reference` 并返回它）。"

#: ../../c-api/object.rst:74
msgid ""
"Flag to be used with multiple functions that print the object (like "
":c:func:`PyObject_Print` and :c:func:`PyFile_WriteObject`). If passed, these"
" function would use the :func:`str` of the object instead of the "
":func:`repr`."
msgstr ""
"要与多个打印对象的函数 (如 :c:func:`PyObject_Print` 和 :c:func:`PyFile_WriteObject`) "
"一起使用的旗标。 如果传入，这些函数应当使用对象的 :func:`str` 而不是 :func:`repr`。"

#: ../../c-api/object.rst:82
msgid ""
"Print an object *o*, on file *fp*.  Returns ``-1`` on error.  The flags "
"argument is used to enable certain printing options.  The only option "
"currently supported is :c:macro:`Py_PRINT_RAW`; if given, the :func:`str` of"
" the object is written instead of the :func:`repr`."
msgstr ""
"打印对象 *o* 到文件 *fp*。 出错时返回 ``-1``。 flags 参数被用于启用特定的打印选项。 目前唯一支持的选项是 "
":c:macro:`Py_PRINT_RAW`；如果给出该选项，则将写入对象的 :func:`str` 而不是 :func:`repr`。"

#: ../../c-api/object.rst:90
msgid ""
"Returns ``1`` if *o* has the attribute *attr_name*, and ``0`` otherwise. "
"This is equivalent to the Python expression ``hasattr(o, attr_name)``. On "
"failure, return ``-1``."
msgstr ""
"如果 *o* 具有属性 *attr_name* 则返回 ``1``，否则返回 ``0``。 这相当于 Python 表达式 ``hasattr(o, "
"attr_name)``。 当失败时，将返回 ``-1``。"

#: ../../c-api/object.rst:99
msgid ""
"This is the same as :c:func:`PyObject_HasAttrWithError`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than"
" a :c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_HasAttrWithError` 相同，但 *attr_name* 被指定为 :c:expr:`const "
"char*` UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:108
msgid ""
"Returns ``1`` if *o* has the attribute *attr_name*, and ``0`` otherwise. "
"This function always succeeds."
msgstr "如果 *o* 具有属性 *attr_name* 则返回 ``1``，否则返回 ``0``。 此函数总是会成功执行。"

#: ../../c-api/object.rst:113
msgid ""
"Exceptions that occur when this calls :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` methods aren't propagated, but instead "
"given to :func:`sys.unraisablehook`. For proper error handling, use "
":c:func:`PyObject_HasAttrWithError`, :c:func:`PyObject_GetOptionalAttr` or "
":c:func:`PyObject_GetAttr` instead."
msgstr ""
"当其调用 :meth:`~object.__getattr__` 和 :meth:`~object.__getattribute__` "
"方法时发生的异常将不会被传播，而是交给 :func:`sys.unraisablehook`。 想要进行适当的错误处理，请改用 "
":c:func:`PyObject_HasAttrWithError`, :c:func:`PyObject_GetOptionalAttr` 或 "
":c:func:`PyObject_GetAttr`。"

#: ../../c-api/object.rst:122
msgid ""
"This is the same as :c:func:`PyObject_HasAttr`, but *attr_name* is specified"
" as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_HasAttr` 相同，但 *attr_name* 被指定为 :c:expr:`const char*` "
"UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:128
msgid ""
"Exceptions that occur when this calls :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` methods or while creating the temporary "
":class:`str` object are silently ignored. For proper error handling, use "
":c:func:`PyObject_HasAttrStringWithError`, "
":c:func:`PyObject_GetOptionalAttrString` or :c:func:`PyObject_GetAttrString`"
" instead."
msgstr ""
"在其调用 :meth:`~object.__getattr__` 和 :meth:`~object.__getattribute__` 方法或创建临时 "
":class:`str` 对象期间发生的异常将被静默地忽略。 想要进行适当的错误处理，请改用 "
":c:func:`PyObject_HasAttrStringWithError`, "
":c:func:`PyObject_GetOptionalAttrString` 或 :c:func:`PyObject_GetAttrString`。"

#: ../../c-api/object.rst:138
msgid ""
"Retrieve an attribute named *attr_name* from object *o*. Returns the "
"attribute value on success, or ``NULL`` on failure.  This is the equivalent "
"of the Python expression ``o.attr_name``."
msgstr ""
"从对象 *o* 中读取名为 *attr_name* 的属性。成功返回属性值，失败则返回  ``NULL``。 这相当于 Python 表达式 "
"``o.attr_name``。"

#: ../../c-api/object.rst:142
msgid ""
"If the missing attribute should not be treated as a failure, you can use "
":c:func:`PyObject_GetOptionalAttr` instead."
msgstr "如果缺少属性不应被视为执行失败，你可以改用 :c:func:`PyObject_GetOptionalAttr`。"

#: ../../c-api/object.rst:148
msgid ""
"This is the same as :c:func:`PyObject_GetAttr`, but *attr_name* is specified"
" as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_GetAttr` 相同，但 *attr_name* 被指定为 :c:expr:`const char*` "
"UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:152
msgid ""
"If the missing attribute should not be treated as a failure, you can use "
":c:func:`PyObject_GetOptionalAttrString` instead."
msgstr "如果缺少属性不应被视为执行失败，你可以改用 :c:func:`PyObject_GetOptionalAttrString`。"

#: ../../c-api/object.rst:158
msgid ""
"Variant of :c:func:`PyObject_GetAttr` which doesn't raise "
":exc:`AttributeError` if the attribute is not found."
msgstr ":c:func:`PyObject_GetAttr` 的变化形式，它在未找到键时不会引发 :exc:`AttributeError`。"

#: ../../c-api/object.rst:161
msgid ""
"If the attribute is found, return ``1`` and set *\\*result* to a new "
":term:`strong reference` to the attribute. If the attribute is not found, "
"return ``0`` and set *\\*result* to ``NULL``; the :exc:`AttributeError` is "
"silenced. If an error other than :exc:`AttributeError` is raised, return "
"``-1`` and set *\\*result* to ``NULL``."
msgstr ""
"如果找到该属性，则返回 ``1`` 并将 *\\*result* 设为指向该属性的新 :term:`strong reference`。 "
"如果未找到该属性，则返回 ``0`` 并将 *\\*result* 设为 ``NULL``；:exc:`AttributeError` 会被静默。 "
"如果引发了 :exc:`AttributeError` 以外的错误，则返回 ``-1`` 并将 *\\*result* 设为 ``NULL``。"

#: ../../c-api/object.rst:173
msgid ""
"This is the same as :c:func:`PyObject_GetOptionalAttr`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than"
" a :c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_GetOptionalAttr` 相同，但 *attr_name* 被指定为 :c:expr:`const "
"char*` UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:181
msgid ""
"Generic attribute getter function that is meant to be put into a type "
"object's ``tp_getattro`` slot.  It looks for a descriptor in the dictionary "
"of classes in the object's MRO as well as an attribute in the object's "
":attr:`~object.__dict__` (if present).  As outlined in :ref:`descriptors`, "
"data descriptors take preference over instance attributes, while non-data "
"descriptors don't.  Otherwise, an :exc:`AttributeError` is raised."
msgstr ""
"通用的属性获取函数，用于放入类型对象的 ``tp_getattro`` 槽中。它在类的字典中（位于对象的 MRO 中）查找某个描述符，并在对象的 "
":attr:`~object.__dict__` 中查找某个属性。正如 :ref:`descriptors` "
"所述，数据描述符优先于实例属性，而非数据描述符则不优先。失败则会触发 :exc:`AttributeError` 。"

#: ../../c-api/object.rst:191
msgid ""
"Set the value of the attribute named *attr_name*, for object *o*, to the "
"value *v*. Raise an exception and return ``-1`` on failure; return ``0`` on "
"success.  This is the equivalent of the Python statement ``o.attr_name = "
"v``."
msgstr ""
"将对象 *o* 中名为 *attr_name* 的属性值设为 *v* 。失败时引发异常并返回 ``-1``；成功时返 回 ``0`` 。这相当于 "
"Python 语句 ``o.attr_name = v``。"

#: ../../c-api/object.rst:196
msgid ""
"If *v* is ``NULL``, the attribute is deleted. This behaviour is deprecated "
"in favour of using :c:func:`PyObject_DelAttr`, but there are currently no "
"plans to remove it."
msgstr ""
"如果 *v* 为 ``NULL``，该属性将被删除。 此行为已被弃用而应改用 "
":c:func:`PyObject_DelAttr`，但目前还没有移除它的计划。"

#: ../../c-api/object.rst:203
msgid ""
"This is the same as :c:func:`PyObject_SetAttr`, but *attr_name* is specified"
" as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_SetAttr` 相同，但 *attr_name* 被指定为 :c:expr:`const char*` "
"UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:207
msgid ""
"If *v* is ``NULL``, the attribute is deleted, but this feature is deprecated"
" in favour of using :c:func:`PyObject_DelAttrString`."
msgstr ""
"如果 *v* 为 ``NULL``，该属性将被删除，但是此功能已被弃用而应改用 :c:func:`PyObject_DelAttrString`。"

#: ../../c-api/object.rst:210
msgid ""
"The number of different attribute names passed to this function should be "
"kept small, usually by using a statically allocated string as *attr_name*. "
"For attribute names that aren't known at compile time, prefer calling "
":c:func:`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For "
"more details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""
"传给该函数的不同属性名称应当保持在较少的数量，通常是通过使用静态分配的字符串作为 *attr_name* 来做到这一点。 "
"对于编译时未知的属性名称，建议直接调用 :c:func:`PyUnicode_FromString` 和 "
":c:func:`PyObject_SetAttr`。 更多相关细节，请参阅 "
":c:func:`PyUnicode_InternFromString`，它可在内部用于创建键对象。"

#: ../../c-api/object.rst:220
msgid ""
"Generic attribute setter and deleter function that is meant to be put into a"
" type object's :c:member:`~PyTypeObject.tp_setattro` slot.  It looks for a "
"data descriptor in the dictionary of classes in the object's MRO, and if "
"found it takes preference over setting or deleting the attribute in the "
"instance dictionary. Otherwise, the attribute is set or deleted in the "
"object's :attr:`~object.__dict__` (if present). On success, ``0`` is "
"returned, otherwise an :exc:`AttributeError` is raised and ``-1`` is "
"returned."
msgstr ""
"通用的属性设置和删除函数，用于放入类型对象的 :c:member:`~PyTypeObject.tp_setattro` "
"槽。它在类的字典中（位于对象的MRO中）查找数据描述器，如果找到，则将比在实例字典中设置或删除属性优先执行。否则，该属性将在对象的 "
":attr:`~object.__dict__` 中设置或删除。如果成功将返回 ``0``，否则将引发 :exc:`AttributeError` "
"并返回 ``-1``。"

#: ../../c-api/object.rst:232
msgid ""
"Delete attribute named *attr_name*, for object *o*. Returns ``-1`` on "
"failure. This is the equivalent of the Python statement ``del o.attr_name``."
msgstr ""
"删除对象 *o* 中名为 *attr_name* 的属性。失败时返回 ``-1``。这相当于 Python 语句 ``del "
"o.attr_name``。"

#: ../../c-api/object.rst:238
msgid ""
"This is the same as :c:func:`PyObject_DelAttr`, but *attr_name* is specified"
" as a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_DelAttr` 相同，但 *attr_name* 被指定为 :c:expr:`const char*` "
"UTF-8 编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:242
msgid ""
"The number of different attribute names passed to this function should be "
"kept small, usually by using a statically allocated string as *attr_name*. "
"For attribute names that aren't known at compile time, prefer calling "
":c:func:`PyUnicode_FromString` and :c:func:`PyObject_DelAttr` directly. For "
"more details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object for lookup."
msgstr ""
"传给该函数的不同属性名称应当保持在较少的数量，通过是通过使用静态分配的字符串作为 *attr_name* 来做到这一点。 "
"对于编译时未知的属性名称，建议直接调用 :c:func:`PyUnicode_FromString` 和 "
":c:func:`PyObject_DelAttr`。 更多相关细节，请参阅 "
":c:func:`PyUnicode_InternFromString`，它可在内部用于创建供查找的键对象。"

#: ../../c-api/object.rst:253
msgid ""
"A generic implementation for the getter of a ``__dict__`` descriptor. It "
"creates the dictionary if necessary."
msgstr "``__dict__`` 描述符的获取函数的一种通用实现。必要时会创建该字典。"

#: ../../c-api/object.rst:256
msgid ""
"This function may also be called to get the :py:attr:`~object.__dict__` of "
"the object *o*. Pass ``NULL`` for *context* when calling it. Since this "
"function may need to allocate memory for the dictionary, it may be more "
"efficient to call :c:func:`PyObject_GetAttr` when accessing an attribute on "
"the object."
msgstr ""
"此函数还可能会被调用以获取对象 *o* 的 :py:attr:`~object.__dict__`。 当调用它时可传入 ``NULL`` 作为 "
"*context*。 由于此函数可能需要为字典分配内存，所以在访问对象上的属性时调用 :c:func:`PyObject_GetAttr` "
"可能会更为高效。"

#: ../../c-api/object.rst:262
msgid "On failure, returns ``NULL`` with an exception set."
msgstr "当失败时，将返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/object.rst:269
msgid ""
"A generic implementation for the setter of a ``__dict__`` descriptor. This "
"implementation does not allow the dictionary to be deleted."
msgstr "``__dict__`` 描述符设置函数的一种通用实现。这里不允许删除该字典。"

#: ../../c-api/object.rst:277
msgid ""
"Return a pointer to :py:attr:`~object.__dict__` of the object *obj*. If "
"there is no ``__dict__``, return ``NULL`` without setting an exception."
msgstr ""
"返回一个指向对象 *obj* 的 :py:attr:`~object.__dict__` 的指针。 如果不存在 ``__dict__``，则返回 "
"``NULL`` 并且不设置异常。"

#: ../../c-api/object.rst:280
msgid ""
"This function may need to allocate memory for the dictionary, so it may be "
"more efficient to call :c:func:`PyObject_GetAttr` when accessing an "
"attribute on the object."
msgstr "此函数可能需要为字典分配内存，所以在访问对象上的属性时调用 :c:func:`PyObject_GetAttr` 可能会更为高效。"

#: ../../c-api/object.rst:287
msgid ""
"Compare the values of *o1* and *o2* using the operation specified by *opid*,"
" which must be one of :c:macro:`Py_LT`, :c:macro:`Py_LE`, :c:macro:`Py_EQ`, "
":c:macro:`Py_NE`, :c:macro:`Py_GT`, or :c:macro:`Py_GE`, corresponding to "
"``<``, ``<=``, ``==``, ``!=``, ``>``, or ``>=`` respectively. This is the "
"equivalent of the Python expression ``o1 op o2``, where ``op`` is the "
"operator corresponding to *opid*. Returns the value of the comparison on "
"success, or ``NULL`` on failure."
msgstr ""
"使用由 *opid* 指定的操作来比较 *o1* 和 *o2* 的值，操作必须为 :c:macro:`Py_LT`, :c:macro:`Py_LE`,"
" :c:macro:`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_GT` 或 :c:macro:`Py_GE` "
"中的一个，分别对应于 ``<``, ``<=``, ``==``, ``!=``, ``>`` 或 ``>=``。 这等价于 Python 表达式 "
"``o1 op o2``，其中 ``op`` 是与 *opid* 对应的运算符。 成功时返回比较结果值，失败时返回 ``NULL``。"

#: ../../c-api/object.rst:297
msgid ""
"Compare the values of *o1* and *o2* using the operation specified by *opid*,"
" like :c:func:`PyObject_RichCompare`, but returns ``-1`` on error, ``0`` if "
"the result is false, ``1`` otherwise."
msgstr ""
"使用 *opid* 所指定的操作，例如 :c:func:`PyObject_RichCompare` 来比较 *o1* 和 *o2* "
"的值，但在出错时返回 ``-1``，在结果为假值时返回 ``0``，在其他情况下返回 ``1``。"

#: ../../c-api/object.rst:302
msgid ""
"If *o1* and *o2* are the same object, :c:func:`PyObject_RichCompareBool` "
"will always return ``1`` for :c:macro:`Py_EQ` and ``0`` for "
":c:macro:`Py_NE`."
msgstr ""
"如果 *o1* 和 *o2* 是同一个对象，:c:func:`PyObject_RichCompareBool` 将总是为 "
":c:macro:`Py_EQ` 返回 ``1`` 并为 :c:macro:`Py_NE` 返回 ``0``。"

#: ../../c-api/object.rst:307
msgid ""
"Format *obj* using *format_spec*. This is equivalent to the Python "
"expression ``format(obj, format_spec)``."
msgstr ""
"格式 *obj* 使用 *format_spec*。 这等价于 Python 表达式 ``format(obj, format_spec)``。"

#: ../../c-api/object.rst:310
msgid ""
"*format_spec* may be ``NULL``. In this case the call is equivalent to "
"``format(obj)``. Returns the formatted string on success, ``NULL`` on "
"failure."
msgstr ""
"*format_spec* 可以为 ``NULL``。 在此情况下调用将等价于 ``format(obj)``。 成功时返回已格式化的字符串，失败时返回"
" ``NULL``。"

#: ../../c-api/object.rst:318
msgid ""
"Compute a string representation of object *o*.  Returns the string "
"representation on success, ``NULL`` on failure.  This is the equivalent of "
"the Python expression ``repr(o)``.  Called by the :func:`repr` built-in "
"function."
msgstr ""
"计算对象 *o* 的字符串形式。 成功时返回字符串，失败时返回 ``NULL``。 这相当于 Python 表达式 ``repr(o)``。 由内置函数"
" :func:`repr`  调用。"

#: ../../c-api/object.rst:322 ../../c-api/object.rst:346
msgid ""
"This function now includes a debug assertion to help ensure that it does not"
" silently discard an active exception."
msgstr "该函数现在包含一个调试断言，用以确保不会静默地丢弃活动的异常。"

#: ../../c-api/object.rst:330
msgid ""
"As :c:func:`PyObject_Repr`, compute a string representation of object *o*, "
"but escape the non-ASCII characters in the string returned by "
":c:func:`PyObject_Repr` with ``\\x``, ``\\u`` or ``\\U`` escapes.  This "
"generates a string similar to that returned by :c:func:`PyObject_Repr` in "
"Python 2. Called by the :func:`ascii` built-in function."
msgstr ""
"与 :c:func:`PyObject_Repr` 一样，计算对象 *o* 的字符串形式，但在 :c:func:`PyObject_Repr` "
"返回的字符串中用 ``\\x``、``\\u`` 或 ``\\U`` 转义非 ASCII 字符。这将生成一个类似于 Python 2 中由 "
":c:func:`PyObject_Repr` 返回的字符串。由内置函数 :func:`ascii` 调用。"

#: ../../c-api/object.rst:341
msgid ""
"Compute a string representation of object *o*.  Returns the string "
"representation on success, ``NULL`` on failure.  This is the equivalent of "
"the Python expression ``str(o)``.  Called by the :func:`str` built-in "
"function and, therefore, by the :func:`print` function."
msgstr ""
"计算对象 *o* 的字符串形式。 成功时返回字符串，失败时返回 ``NULL``。 这相当于 Python 表达式 ``str(o)``。由内置函数 "
":func:`str` 调用，因此也由 :func:`print` 函数调用。"

#: ../../c-api/object.rst:355
msgid ""
"Compute a bytes representation of object *o*.  ``NULL`` is returned on "
"failure and a bytes object on success.  This is equivalent to the Python "
"expression ``bytes(o)``, when *o* is not an integer.  Unlike ``bytes(o)``, a"
" TypeError is raised when *o* is an integer instead of a zero-initialized "
"bytes object."
msgstr ""
"计算对象 *o* 的字节形式。失败时返回 ``NULL``，成功时返回一个字节串对象。这相当于 *o* 不是整数时的 Python 表达式 "
"``bytes(o)`` 。与 ``bytes(o)`` 不同的是，当 *o* 是整数而不是初始为 0 的字节串对象时，会触发 TypeError。"

#: ../../c-api/object.rst:364
msgid ""
"Return ``1`` if the class *derived* is identical to or derived from the "
"class *cls*, otherwise return ``0``.  In case of an error, return ``-1``."
msgstr "如果 *derived* 类与 *cls* 类相同或为其派生类，则返回 ``1``，否则返回 ``0``。 如果出错则返回 ``-1``。"

#: ../../c-api/object.rst:367 ../../c-api/object.rst:386
msgid ""
"If *cls* is a tuple, the check will be done against every entry in *cls*. "
"The result will be ``1`` when at least one of the checks returns ``1``, "
"otherwise it will be ``0``."
msgstr ""
"如果 *cls* 是元组，则会对 *cls* 进行逐项检测。如果至少有一次检测返回 ``1``，结果将为 ``1``，否则将是 ``0``。"

#: ../../c-api/object.rst:371
msgid ""
"If *cls* has a :meth:`~type.__subclasscheck__` method, it will be called to "
"determine the subclass status as described in :pep:`3119`.  Otherwise, "
"*derived* is a subclass of *cls* if it is a direct or indirect subclass, "
"i.e. contained in :attr:`cls.__mro__ <type.__mro__>`."
msgstr ""
"如果 *cls* 具有 :meth:`~type.__subclasscheck__` 方法，它将被调用以确定 :pep:`3119` "
"所描述的子类状态。 在其他情况下，如果 *derived* 是一个直接或间接子类即包含在 :attr:`cls.__mro__ "
"<type.__mro__>` 中则它就是 *cls* 的子类。"

#: ../../c-api/object.rst:376
msgid ""
"Normally only class objects, i.e. instances of :class:`type` or a derived "
"class, are considered classes.  However, objects can override this by having"
" a :attr:`~type.__bases__` attribute (which must be a tuple of base "
"classes)."
msgstr ""
"通常只有类对象，即 :class:`type` 或其派生类的实例才会被视为类。 但是，对象可以通过设置 :attr:`~type.__bases__` "
"属性（它必须是由基类组成的元组）来覆盖此定义。"

#: ../../c-api/object.rst:383
msgid ""
"Return ``1`` if *inst* is an instance of the class *cls* or a subclass of "
"*cls*, or ``0`` if not.  On error, returns ``-1`` and sets an exception."
msgstr ""
"如果 *inst* 是 *cls* 类或其子类的实例，则返回 ``1``，如果不是则返回 ``0``。 如果出错则返回 ``-1`` 并设置一个异常。"

#: ../../c-api/object.rst:390
msgid ""
"If *cls* has a :meth:`~type.__instancecheck__` method, it will be called to "
"determine the subclass status as described in :pep:`3119`.  Otherwise, "
"*inst* is an instance of *cls* if its class is a subclass of *cls*."
msgstr ""
"如果 *cls* 具有 :meth:`~type.__instancecheck__` 方法，它将被调用以确定 :pep:`3119` "
"所描述的子类状态。 在其他情况下，如果 *inst* 的类是 *cls* 的子类则它就是 *cls* 的实例。"

#: ../../c-api/object.rst:394
msgid ""
"An instance *inst* can override what is considered its class by having a "
":attr:`~object.__class__` attribute."
msgstr "实例 *inst* 可以通过设置 :attr:`~object.__class__` 属性来覆盖它是否会被视为类。"

#: ../../c-api/object.rst:397
msgid ""
"An object *cls* can override if it is considered a class, and what its base "
"classes are, by having a :attr:`~type.__bases__` attribute (which must be a "
"tuple of base classes)."
msgstr ""
"对象 *cls* 可以通过设置 :attr:`~type.__bases__` 属性（它必须是由基类组成的元组）来覆盖它是否会被视为类，及其有哪些基类。"

#: ../../c-api/object.rst:406
msgid ""
"Compute and return the hash value of an object *o*.  On failure, return "
"``-1``. This is the equivalent of the Python expression ``hash(o)``."
msgstr "计算并返回对象的哈希值 *o*。 失败时返回 ``-1``。这相当于 Python 表达式 ``hash(o)``。"

#: ../../c-api/object.rst:409
msgid ""
"The return type is now Py_hash_t.  This is a signed integer the same size as"
" :c:type:`Py_ssize_t`."
msgstr "现在的返回类型是 Py_hash_t。 这是一个大小与 :c:type:`Py_ssize_t` 相同的有符号整数。"

#: ../../c-api/object.rst:416
msgid ""
"Set a :exc:`TypeError` indicating that ``type(o)`` is not :term:`hashable` "
"and return ``-1``. This function receives special treatment when stored in a"
" ``tp_hash`` slot, allowing a type to explicitly indicate to the interpreter"
" that it is not hashable."
msgstr ""
"设置一个 :exc:`TypeError` 来指明 ``type(o)`` 不是 :term:`hashable` 并返回 ``-1``。 "
"此函数在存储于 ``tp_hash`` 槽位内时会获得特别对待，允许某个类型显式地向解释器指明它是不可哈希对象。"

#: ../../c-api/object.rst:424
msgid ""
"Returns ``1`` if the object *o* is considered to be true, and ``0`` "
"otherwise. This is equivalent to the Python expression ``not not o``.  On "
"failure, return ``-1``."
msgstr ""
"如果对象 *o* 被认为是 true，则返回 ``1``，否则返回 ``0``。这相当于 Python 表达式 ``not not o``。 失败则返回"
" ``-1``。"

#: ../../c-api/object.rst:431
msgid ""
"Returns ``0`` if the object *o* is considered to be true, and ``1`` "
"otherwise. This is equivalent to the Python expression ``not o``.  On "
"failure, return ``-1``."
msgstr ""
"如果对象 *o* 被认为是 true，则返回 ``1``，否则返回 ``0``。这相当于 Python 表达式 ``not not o``。 失败则返回"
" ``-1``。"

#: ../../c-api/object.rst:440
msgid ""
"When *o* is non-``NULL``, returns a type object corresponding to the object "
"type of object *o*. On failure, raises :exc:`SystemError` and returns "
"``NULL``.  This is equivalent to the Python expression ``type(o)``. This "
"function creates a new :term:`strong reference` to the return value. There's"
" really no reason to use this function instead of the :c:func:`Py_TYPE()` "
"function, which returns a pointer of type :c:expr:`PyTypeObject*`, except "
"when a new :term:`strong reference` is needed."
msgstr ""
"当 *o* 不为 ``NULL`` 时，返回一个与对象 *o* 的类型相对应的类型对象。 当失败时，将引发 :exc:`SystemError` 并返回"
" ``NULL``。 这等同于 Python 表达式 ``type(o)``。 该函数会新建一个指向返回值的 :term:`strong "
"reference`。 实际上没有多少理由使用此函数来替代 :c:func:`Py_TYPE()` 函数，后者将返回一个 "
":c:expr:`PyTypeObject*` 类型的指针，除非是需要一个新的 :term:`strong reference`。"

#: ../../c-api/object.rst:452
msgid ""
"Return non-zero if the object *o* is of type *type* or a subtype of *type*, "
"and ``0`` otherwise.  Both parameters must be non-``NULL``."
msgstr "如果对象 *o* 是 *type* 类型或其子类型，则返回非零，否则返回 ``0``。两个参数都必须非 ``NULL``。"

#: ../../c-api/object.rst:461
msgid ""
"Return the length of object *o*.  If the object *o* provides either the "
"sequence and mapping protocols, the sequence length is returned.  On error, "
"``-1`` is returned.  This is the equivalent to the Python expression "
"``len(o)``."
msgstr ""
"返回对象 *o* 的长度。 如果对象 *o* 支持序列和映射协议，则返回序列长度。 出错时返回 ``-1``。这等同于 Python 表达式 "
"``len(o)``。"

#: ../../c-api/object.rst:468
msgid ""
"Return an estimated length for the object *o*. First try to return its "
"actual length, then an estimate using :meth:`~object.__length_hint__`, and "
"finally return the default value. On error return ``-1``. This is the "
"equivalent to the Python expression ``operator.length_hint(o, "
"defaultvalue)``."
msgstr ""
"返回对象 *o* 的估计长度。首先尝试返回实际长度，然后用  :meth:`~object.__length_hint__` "
"进行估计，最后返回默认值。出错时返回 ``-1``。这等同于 Python 表达式 ``operator.length_hint(o, "
"defaultvalue)``。"

#: ../../c-api/object.rst:478
msgid ""
"Return element of *o* corresponding to the object *key* or ``NULL`` on "
"failure. This is the equivalent of the Python expression ``o[key]``."
msgstr "返回对象 *key* 对应的 *o* 元素，或在失败时返回 ``NULL``。这等同于 Python 表达式 ``o[key]``。"

#: ../../c-api/object.rst:484
msgid ""
"Map the object *key* to the value *v*.  Raise an exception and return ``-1``"
" on failure; return ``0`` on success.  This is the equivalent of the Python "
"statement ``o[key] = v``.  This function *does not* steal a reference to "
"*v*."
msgstr ""
"将对象 *key* 映射到值 *v*。 失败时引发异常并返回 ``-1``；成功时返回 ``0``。 这相当于 Python 语句 ``o[key] ="
" v``。该函数 *不会* 偷取 *v* 的引用计数。"

#: ../../c-api/object.rst:492
msgid ""
"Remove the mapping for the object *key* from the object *o*.  Return ``-1`` "
"on failure.  This is equivalent to the Python statement ``del o[key]``."
msgstr "从对象 *o* 中移除对象 *key* 的映射。失败时返回 ``-1``。 这相当于 Python 语句 ``del o[key]``。"

#: ../../c-api/object.rst:498
msgid ""
"This is the same as :c:func:`PyObject_DelItem`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyObject_DelItem` 相同，但 *key* 被指定为 :c:expr:`const char*` UTF-8 "
"编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/object.rst:505
msgid ""
"This is equivalent to the Python expression ``dir(o)``, returning a "
"(possibly empty) list of strings appropriate for the object argument, or "
"``NULL`` if there was an error.  If the argument is ``NULL``, this is like "
"the Python ``dir()``, returning the names of the current locals; in this "
"case, if no execution frame is active then ``NULL`` is returned but "
":c:func:`PyErr_Occurred` will return false."
msgstr ""
"相当于 Python 表达式 ``dir(o)``，返回一个（可能为空）适合对象参数的字符串列表，如果出错则返回 ``NULL``。 如果参数为 "
"``NULL``，类似 Python 的 ``dir()``，则返回当前 locals 的名字；这时如果没有活动的执行框架，则返回 ``NULL``，但"
" :c:func:`PyErr_Occurred` 将返回 false。"

#: ../../c-api/object.rst:514
msgid ""
"This is equivalent to the Python expression ``iter(o)``. It returns a new "
"iterator for the object argument, or the object  itself if the object is "
"already an iterator.  Raises :exc:`TypeError` and returns ``NULL`` if the "
"object cannot be iterated."
msgstr ""
"等同于 Python 表达式 "
"``iter(o)``。为对象参数返回一个新的迭代器，如果该对象已经是一个迭代器，则返回对象本身。如果对象不能被迭代，会引发  "
":exc:`TypeError` ，并返回  ``NULL``。"

#: ../../c-api/object.rst:522
msgid ""
"This is equivalent to the Python ``__iter__(self): return self`` method. It "
"is intended for :term:`iterator` types, to be used in the "
":c:member:`PyTypeObject.tp_iter` slot."
msgstr ""
"这等价于 Python ``__iter__(self): return self`` 方法。 它是针对 :term:`iterator` "
"类型设计的，将在 :c:member:`PyTypeObject.tp_iter` 槽位中使用。"

#: ../../c-api/object.rst:528
msgid ""
"This is the equivalent to the Python expression ``aiter(o)``. Takes an "
":class:`AsyncIterable` object and returns an :class:`AsyncIterator` for it. "
"This is typically a new iterator but if the argument is an "
":class:`AsyncIterator`, this returns itself. Raises :exc:`TypeError` and "
"returns ``NULL`` if the object cannot be iterated."
msgstr ""
"等同于 Python 表达式 ``aiter(o)``。接受一个 :class:`AsyncIterable` 对象，并为其返回一个 "
":class:`AsyncIterator`。通常返回的是一个新迭代器，但如果参数是一个 "
":class:`AsyncIterator`，将返回其自身。如果该对象不能被迭代，会引发 :exc:`TypeError`，并返回 ``NULL``。"

#: ../../c-api/object.rst:538
msgid "Get a pointer to subclass-specific data reserved for *cls*."
msgstr "获取一个指向为 *cls* 保留的子类专属数据的指针。"

#: ../../c-api/object.rst:540
msgid ""
"The object *o* must be an instance of *cls*, and *cls* must have been "
"created using negative :c:member:`PyType_Spec.basicsize`. Python does not "
"check this."
msgstr ""
"对象 *o* 必须为 *cls* 的实例，而 *cls* 必须使用负的 :c:member:`PyType_Spec.basicsize` 来创建。 "
"Python 不会检查这一点。"

#: ../../c-api/object.rst:544
msgid "On error, set an exception and return ``NULL``."
msgstr "发生错误时，将设置异常并返回 ``NULL``。"

#: ../../c-api/object.rst:550
msgid ""
"Return the size of the instance memory space reserved for *cls*, i.e. the "
"size of the memory :c:func:`PyObject_GetTypeData` returns."
msgstr "返回为 *cls* 保留的实例内存空间大小，即 :c:func:`PyObject_GetTypeData` 所返回的内存大小。"

#: ../../c-api/object.rst:553
msgid ""
"This may be larger than requested using :c:member:`-PyType_Spec.basicsize "
"<PyType_Spec.basicsize>`; it is safe to use this larger size (e.g. with "
":c:func:`!memset`)."
msgstr ""
"这可能会大于使用 :c:member:`-PyType_Spec.basicsize <PyType_Spec.basicsize>` "
"请求到的大小；可以安全地使用这个更大的值 (例如通过 :c:func:`!memset`)。"

#: ../../c-api/object.rst:556
msgid ""
"The type *cls* **must** have been created using negative "
":c:member:`PyType_Spec.basicsize`. Python does not check this."
msgstr ""
"类型 *cls* **必须** 使用负的 :c:member:`PyType_Spec.basicsize` 来创建。 Python 不会检查这一点。"

#: ../../c-api/object.rst:560
msgid "On error, set an exception and return a negative value."
msgstr "当失败时，将设置异常并返回一个负值。"

#: ../../c-api/object.rst:566
msgid ""
"Get a pointer to per-item data for a class with "
":c:macro:`Py_TPFLAGS_ITEMS_AT_END`."
msgstr "使用 :c:macro:`Py_TPFLAGS_ITEMS_AT_END` 获取一个指向类的单独条目数据的指针。"

#: ../../c-api/object.rst:569
msgid ""
"On error, set an exception and return ``NULL``. :py:exc:`TypeError` is "
"raised if *o* does not have :c:macro:`Py_TPFLAGS_ITEMS_AT_END` set."
msgstr ""
"出错时，将设置异常并返回 ``NULL``。 如果 *o* 没有设置 :c:macro:`Py_TPFLAGS_ITEMS_AT_END` 则会引发 "
":py:exc:`TypeError`。"

#: ../../c-api/object.rst:577
msgid "Visit the managed dictionary of *obj*."
msgstr "访问被管理的 *obj* 的字典。"

#: ../../c-api/object.rst:579 ../../c-api/object.rst:588
msgid ""
"This function must only be called in a traverse function of the type which "
"has the :c:macro:`Py_TPFLAGS_MANAGED_DICT` flag set."
msgstr "此函数必须只在设置了 :c:macro:`Py_TPFLAGS_MANAGED_DICT` 旗标的类型的遍历函数中被调用。"

#: ../../c-api/object.rst:586
msgid "Clear the managed dictionary of *obj*."
msgstr "清空被管理的 *obj* 的字典。."

#: ../../c-api/object.rst:595
msgid ""
"Enable `deferred reference counting "
"<https://peps.python.org/pep-0703/#deferred-reference-counting>`_ on *obj*, "
"if supported by the runtime.  In the :term:`free-threaded <free threading>` "
"build, this allows the interpreter to avoid reference count adjustments to "
"*obj*, which may improve multi-threaded performance.  The tradeoff is that "
"*obj* will only be deallocated by the tracing garbage collector."
msgstr ""
"在 *obj* 上启用 `推迟引用计数 <https://peps.python.org/pep-0703/#deferred-reference-"
"counting>`_，如果运行时支持的话。 在 :term:`自由线程 <free threading>` 构建版中，这将允许解释器避免对 *obj*"
" 的引用计数调整，这可以提升多线程性能。 其代价是 *obj* 将只能由在追踪的垃圾回收器来释放。"

#: ../../c-api/object.rst:601
msgid ""
"This function returns ``1`` if deferred reference counting is enabled on "
"*obj* (including when it was enabled before the call), and ``0`` if deferred"
" reference counting is not supported or if the hint was ignored by the "
"runtime. This function is thread-safe, and cannot fail."
msgstr ""
"如果在 *obj* 上启用了推迟引用计数（包括在调用之前已启用的情况）则此函数将返回 ``1``，如果推迟引用计数不受运行时支持或者被其忽略 则返回 "
"``0``。 此函数是线程安全的，并且一定不会执行失败。"

#: ../../c-api/object.rst:606
msgid ""
"This function does nothing on builds with the :term:`GIL` enabled, which do "
"not support deferred reference counting. This also does nothing if *obj* is "
"not an object tracked by the garbage collector (see :func:`gc.is_tracked` "
"and :c:func:`PyObject_GC_IsTracked`)."
msgstr ""
"此函数在启用了 :term:`GIL` 的构建版上将不做任何事，因为该版本不支持推迟引用计数。 如果 *obj* "
"未被垃圾回收器追踪则此函数也不会做任何事 (参见 :func:`gc.is_tracked` 和 "
":c:func:`PyObject_GC_IsTracked`)。"

#: ../../c-api/object.rst:611
msgid ""
"This function is intended to be used soon after *obj* is created, by the "
"code that creates it."
msgstr "此函数应当在 *obj* 被创建之后立即供创建它的代码使用。"

#: ../../c-api/object.rst:618
msgid ""
"Check if *obj* is a unique temporary object. Returns ``1`` if *obj* is known"
" to be a unique temporary object, and ``0`` otherwise.  This function cannot"
" fail, but the check is conservative, and may return ``0`` in some cases "
"even if *obj* is a unique temporary object."
msgstr ""
"检测 *obj* 是否是一个单独临时对象。 如果确定 *obj* 是一个单独临时对象则返回 ``1``，否则返回 ``0``。 "
"此函数一定不会执行失败，但该检测是偏保守的，在某些情况下即使 *obj* 是一个单独临时对象也可能返回 ``0``。"

#: ../../c-api/object.rst:624
msgid ""
"If an object is a unique temporary, it is guaranteed that the current code "
"has the only reference to the object. For arguments to C functions, this "
"should be used instead of checking if the reference count is ``1``. Starting"
" with Python 3.14, the interpreter internally avoids some reference count "
"modifications when loading objects onto the operands stack by "
":term:`borrowing <borrowed reference>` references when possible, which means"
" that a reference count of ``1`` by itself does not guarantee that a "
"function argument uniquely referenced."
msgstr ""
"如果一个对象是唯一的临时对象，则可以保证当前代码对该对象有唯一的引用。对于C函数的参数，应该这样做，而不是检查引用计数是否为``1``。从Python "
"3.14开始，解释器在将对象加载到操作数堆栈时，通过在可能的情况下 :term:`借用 <borrowed reference>` "
"引用，在内部避免了一些引用计数修改，这意味着引用计数``1``本身并不能保证函数参数被唯一引用。"

#: ../../c-api/object.rst:633
msgid ""
"In the example below, ``my_func`` is called with a unique temporary object "
"as its argument::"
msgstr "在下面的例子中，调用``my_func``时使用一个唯一的临时对象作为参数::"

#: ../../c-api/object.rst:636
msgid "my_func([1, 2, 3])"
msgstr "my_func([1, 2, 3])"

#: ../../c-api/object.rst:638
msgid ""
"In the example below, ``my_func`` is **not** called with a unique temporary "
"object as its argument, even if its refcount is ``1``::"
msgstr "在下面的例子中，调用``my_func``时 *不是* 使用一个唯一的临时对象作为参数，即使它的refcount是``1``::"

#: ../../c-api/object.rst:641
msgid ""
"my_list = [1, 2, 3]\n"
"my_func(my_list)"
msgstr ""
"my_list = [1, 2, 3]\n"
"my_func(my_list)"

#: ../../c-api/object.rst:644
msgid "See also the function :c:func:`Py_REFCNT`."
msgstr "另请参阅 :c:func:`Py_REFCNT` 函数。"

#: ../../c-api/object.rst:650
msgid ""
"This function returns non-zero if *obj* is :term:`immortal`, and zero "
"otherwise. This function cannot fail."
msgstr "如果 *obj* 是 :term:`immortal`，这个函数返回非零，否则返回零。 这个函数不会失败。"

#: ../../c-api/object.rst:655
msgid ""
"Objects that are immortal in one CPython version are not guaranteed to be "
"immortal in another."
msgstr "在一个CPython版本中是不朽的对象不能保证在另一个CPython版本中还是不朽的。"

#: ../../c-api/object.rst:662
msgid ""
"Increments the reference count of *obj* if it is not zero.  Returns ``1`` if"
" the object's reference count was successfully incremented. Otherwise, this "
"function returns ``0``."
msgstr "如果 *obj* 的引用计数不为零，则增加引用计数。如果对象的引用计数已成功递增，则返回``1``。否则，此函数返回``0``。"

#: ../../c-api/object.rst:666
msgid ""
":c:func:`PyUnstable_EnableTryIncRef` must have been called earlier on *obj* "
"or this function may spuriously return ``0`` in the :term:`free threading` "
"build."
msgstr ""
":c:func:`PyUnstable_EnableTryIncRef` 必须先前在 *obj* 上被调用，否则此函数可能在 :term:`free "
"threading` 构建中错误地返回 ``0``。"

#: ../../c-api/object.rst:670
msgid ""
"This function is logically equivalent to the following C code, except that "
"it behaves atomically in the :term:`free threading` build::"
msgstr "此函数在逻辑上等效于以下C代码，除了它在 :term:`free threading` 构建中的行为是原子性的::"

#: ../../c-api/object.rst:673
msgid ""
"if (Py_REFCNT(op) > 0) {\n"
"   Py_INCREF(op);\n"
"   return 1;\n"
"}\n"
"return 0;"
msgstr ""
"if (Py_REFCNT(op) > 0) {\n"
"   Py_INCREF(op);\n"
"   return 1;\n"
"}\n"
"return 0;"

#: ../../c-api/object.rst:679
msgid ""
"This is intended as a building block for managing weak references without "
"the overhead of a Python :ref:`weak reference object <weakrefobjects>`."
msgstr "这旨在作为一个构建块，用于管理弱引用，而不会产生Python :ref:`弱引用对象 <weakrefobjects>` 的开销。"

#: ../../c-api/object.rst:682
msgid ""
"Typically, correct use of this function requires support from *obj*'s "
"deallocator (:c:member:`~PyTypeObject.tp_dealloc`). For example, the "
"following sketch could be adapted to implement a \"weakmap\" that works like"
" a :py:class:`~weakref.WeakValueDictionary` for a specific type:"
msgstr ""
"通常，正确使用此函数需要 *obj* 的释放器 (:c:member:`~PyTypeObject.tp_dealloc`) 的支持。 "
"例如，下面的草图可以用来实现一个“weakmap”，就像一个特定类型的 :py:class:`~weakref.WeakValueDictionary`"
" 一样："

#: ../../c-api/object.rst:688
msgid ""
"PyMutex mutex;\n"
"\n"
"PyObject *\n"
"add_entry(weakmap_key_type *key, PyObject *value)\n"
"{\n"
"    PyUnstable_EnableTryIncRef(value);\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    weakmap_add_entry(weakmap, key, value);\n"
"    PyMutex_Unlock(&mutex);\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"PyObject *\n"
"get_value(weakmap_key_type *key)\n"
"{\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    PyObject *result = weakmap_find(weakmap, key);\n"
"    if (PyUnstable_TryIncRef(result)) {\n"
"        // `result` is safe to use\n"
"        PyMutex_Unlock(&mutex);\n"
"        return result;\n"
"    }\n"
"    // if we get here, `result` is starting to be garbage-collected,\n"
"    // but has not been removed from the weakmap yet\n"
"    PyMutex_Unlock(&mutex);\n"
"    return NULL;\n"
"}\n"
"\n"
"// tp_dealloc function for weakmap values\n"
"void\n"
"value_dealloc(PyObject *value)\n"
"{\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    weakmap_remove_value(weakmap, value);\n"
"\n"
"    ...\n"
"    PyMutex_Unlock(&mutex);\n"
"}"
msgstr ""
"PyMutex mutex;\n"
"\n"
"PyObject *\n"
"add_entry(weakmap_key_type *key, PyObject *value)\n"
"{\n"
"    PyUnstable_EnableTryIncRef(value);\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    weakmap_add_entry(weakmap, key, value);\n"
"    PyMutex_Unlock(&mutex);\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"PyObject *\n"
"get_value(weakmap_key_type *key)\n"
"{\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    PyObject *result = weakmap_find(weakmap, key);\n"
"    if (PyUnstable_TryIncRef(result)) {\n"
"        // `result` 可以安全使用\n"
"        PyMutex_Unlock(&mutex);\n"
"        return result;\n"
"    }\n"
"    // 如果我们到这里，`result` 开始被垃圾回收，\n"
"    // 但还没有从弱映射中移除\n"
"    PyMutex_Unlock(&mutex);\n"
"    return NULL;\n"
"}\n"
"\n"
"// weakmap 值的tp_dealloc 函数\n"
"void\n"
"value_dealloc(PyObject *value)\n"
"{\n"
"    weakmap_type weakmap = ...;\n"
"    PyMutex_Lock(&mutex);\n"
"    weakmap_remove_value(weakmap, value);\n"
"\n"
"    ...\n"
"    PyMutex_Unlock(&mutex);\n"
"}"

#: ../../c-api/object.rst:736
msgid ""
"Enables subsequent uses of :c:func:`PyUnstable_TryIncRef` on *obj*.  The "
"caller must hold a :term:`strong reference` to *obj* when calling this."
msgstr ""
"允许在 *obj* 上后续使用 :c:func:`PyUnstable_TryIncRef`。 调用者在调用时必须持有 *obj* 的 "
":term:`strong reference`。"

#: ../../c-api/object.rst:743
msgid "Determine if *op* only has one reference."
msgstr "确定 *op* 是否只有一个引用。"

#: ../../c-api/object.rst:745
msgid ""
"On GIL-enabled builds, this function is equivalent to :c:expr:`Py_REFCNT(op)"
" == 1`."
msgstr "在启用GIL的构建中，此函数等价于 :c:expr:`Py_REFCNT(op) == 1`。"

#: ../../c-api/object.rst:748
msgid ""
"On a :term:`free threaded <free threading>` build, this checks if *op*'s "
":term:`reference count` is equal to one and additionally checks if *op* is "
"only used by this thread. :c:expr:`Py_REFCNT(op) == 1` is **not** thread-"
"safe on free threaded builds; prefer this function."
msgstr ""
"在 :term:`自由线程 <free threading>` 构建中，这将检查 *op* 的 :term:`reference count` "
"是否等于1，并检查 *op* 是否仅由该线程使用。 :c:expr:`Py_REFCNT(op) == 1` 在自由线程构建中 *不是* "
"线程安全的；更喜欢这个函数。"

#: ../../c-api/object.rst:753
msgid ""
"The caller must hold an :term:`attached thread state`, despite the fact that"
" this function doesn't call into the Python interpreter. This function "
"cannot fail."
msgstr "调用者必须持有一个 :term:`attached thread state`，尽管这个函数不调用Python解释器。这个函数不会失败。"

#: ../../c-api/object.rst:316 ../../c-api/object.rst:328
#: ../../c-api/object.rst:353 ../../c-api/object.rst:404
#: ../../c-api/object.rst:438 ../../c-api/object.rst:459
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/object.rst:316
msgid "repr"
msgstr "repr"

#: ../../c-api/object.rst:328
msgid "ascii"
msgstr "ascii"

#: ../../c-api/object.rst:336
msgid "string"
msgstr "string"

#: ../../c-api/object.rst:336
msgid "PyObject_Str (C function)"
msgstr "PyObject_Str (C 函数)"

#: ../../c-api/object.rst:353
msgid "bytes"
msgstr "字节串"

#: ../../c-api/object.rst:404
msgid "hash"
msgstr "hash"

#: ../../c-api/object.rst:438
msgid "type"
msgstr "type"

#: ../../c-api/object.rst:459
msgid "len"
msgstr "len"
