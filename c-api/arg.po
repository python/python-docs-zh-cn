# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# dhcn, 2021
# 操旭 <caoxu3000@126.com>, 2021
# cdarlint <cdarling@126.com>, 2021
# QR Wang <wangqirui1996@gmail.com>, 2021
# Woko <banbooliu@gmail.com>, 2021
# dannyvi <dannyvis@icloud.com>, 2021
# Jing Li <tes286.lijing@gmail.com>, 2021
# 高乐喆 <gaolezhe@outlook.com>, 2023
# ProgramRipper, 2023
# taotieren <admin@taotieren.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# lqks, 2024
# Nyuan Zhang, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:47+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "解析参数并构建值变量"

#: ../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extension functions and "
"methods.  Additional information and examples are available in "
":ref:`extending-index`."
msgstr "这些函数在创建你自己的扩展函数和方法时很有用处。 更多信息和示例可在 :ref:`extending-index` 查看。"

#: ../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, "
":c:func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"这些函数描述的前三个，:c:func:`PyArg_ParseTuple`，:c:func:`PyArg_ParseTupleAndKeywords`，以及"
" :c:func:`PyArg_Parse`，它们都使用 *格式化字符串* 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。"

#: ../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "解析参数"

#: ../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"一个格式化字符串包含 0 或者更多的格式单元。一个格式单元用来描述一个 Python "
"对象；它通常是一个字符或者由括号括起来的格式单元序列。除了少数例外，一个非括号序列的格式单元通常对应这些函数的具有单一地址的参数。在接下来的描述中，双引号内的表达式是格式单元；圆括号"
" () 内的是对应这个格式单元的 Python 对象类型；方括号 [] 内的是传递的 C 变量(变量集)类型。"

#: ../../c-api/arg.rst:33
msgid "Strings and buffers"
msgstr "字符串和缓存区"

#: ../../c-api/arg.rst:37
msgid ""
"On Python 3.12 and older, the macro :c:macro:`!PY_SSIZE_T_CLEAN` must be "
"defined before including :file:`Python.h` to use all ``#`` variants of "
"formats (``s#``, ``y#``, etc.) explained below. This is not necessary on "
"Python 3.13 and later."
msgstr ""
"在 Python 3.12 和之前的版本中，宏 :c:macro:`!PY_SSIZE_T_CLEAN` 必须在包括 :file:`Python.h` "
"之前定义以使用下文介绍的所有 ``#`` 类格式 (``s#``, ``y#`` 等)。 这在 Python 3.13 和之后的版本中已不再必要。"

#: ../../c-api/arg.rst:42
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You"
" don't have to provide raw storage for the returned unicode or bytes area."
msgstr "这些格式允许将对象按照连续的内存块形式进行访问。你没必要提供返回的 unicode 字符或者字节区的原始数据存储。"

#: ../../c-api/arg.rst:46
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "除非另有说明，缓冲区是不会以空终止的。"

#: ../../c-api/arg.rst:48
msgid "There are three ways strings and buffers can be converted to C:"
msgstr "有三种办法可以将字符串和缓冲区转换到 C 类型:"

#: ../../c-api/arg.rst:50
msgid ""
"Formats such as ``y*`` and ``s*`` fill a :c:type:`Py_buffer` structure. This"
" locks the underlying buffer so that the caller can subsequently use the "
"buffer even inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk"
" of mutable data being resized or destroyed. As a result, **you have to "
"call** :c:func:`PyBuffer_Release` after you have finished processing the "
"data (or in any early abort case)."
msgstr ""
"像 ``y*`` 和 ``s*`` 这样的格式会填充一个 :c:type:`Py_buffer` 结构体。 "
"这将锁定下层缓冲区以便调用者随后使用这个缓冲区即使是在 :c:type:`Py_BEGIN_ALLOW_THREADS` "
"块中也不会有可变数据因大小调整或销毁所带来的风险。 因此，在你结束处理数据（或任何更早的中止场景）之前 **你必须调用** "
":c:func:`PyBuffer_Release`。"

#: ../../c-api/arg.rst:57
msgid ""
"The ``es``, ``es#``, ``et`` and ``et#`` formats allocate the result buffer. "
"**You have to call** :c:func:`PyMem_Free` after you have finished processing"
" the data (or in any early abort case)."
msgstr ""
"``es``, ``es#``, ``et`` 和 ``et#`` 等格式会分配结果缓冲区。 在你结束处理数据（或任何更早的中止场景）之后 "
"**你必须调用** :c:func:`PyMem_Free`。"

#: ../../c-api/arg.rst:63
msgid ""
"Other formats take a :class:`str` or a read-only :term:`bytes-like object`, "
"such as :class:`bytes`, and provide a ``const char *`` pointer to its "
"buffer. In this case the buffer is \"borrowed\": it is managed by the "
"corresponding Python object, and shares the lifetime of this object. You "
"won't have to release any memory yourself."
msgstr ""
"其他格式接受一个 :class:`str` 或只读的 :term:`bytes-like object`，如 "
":class:`bytes`，并向其缓冲区提供一个 ``const char *`` 指针。 在缓冲区是“被借入”的情况下：它将由对应的 Python "
"对象来管理，并共享此对象的生命期。 你不需要自行释放任何内存。"

#: ../../c-api/arg.rst:70
msgid ""
"To ensure that the underlying buffer may be safely borrowed, the object's "
":c:member:`PyBufferProcs.bf_releasebuffer` field must be ``NULL``. This "
"disallows common mutable objects such as :class:`bytearray`, but also some "
"read-only objects such as :class:`memoryview` of :class:`bytes`."
msgstr ""
"为确保下层缓冲区可以安全地被借入，对象的 :c:member:`PyBufferProcs.bf_releasebuffer` 字段必须为 "
"``NULL``。 这将不允许普通的可变对象如 :class:`bytearray`，以及某些只读对象如 :class:`bytes` 的 "
":class:`memoryview`。"

#: ../../c-api/arg.rst:76
msgid ""
"Besides this ``bf_releasebuffer`` requirement, there is no check to verify "
"whether the input object is immutable (e.g. whether it would honor a request"
" for a writable buffer, or whether another thread can mutate the data)."
msgstr ""
"在这个 ``bf_releasebuffer`` "
"要求以外，没有用于验证输入对象是否为不可变对象的检查（例如它是否会接受可写缓冲区的请求，或者另一个线程是否能改变此数据）。"

#: ../../c-api/arg.rst:80
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

#: ../../c-api/arg.rst:81
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address"
" you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception"
" is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"将一个 Unicode 对象转换成一个指向字符串的 C 指针。一个指针指向一个已经存在的字符串，这个字符串存储的是传如的字符指针变量。C "
"字符串是已空结束的。Python 字符串不能包含嵌入的无效的代码点；如果由，一个 :exc:`ValueError` 异常会被引发。Unicode "
"对象被转化成 ``'utf-8'`` 编码的 C 字符串。如果转换失败，一个 :exc:`UnicodeError` 异常被引发。"

#: ../../c-api/arg.rst:90
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`."
"  If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with "
":c:func:`PyUnicode_FSConverter` as *converter*."
msgstr ""
"这个表达式不接受 :term:`bytes-like objects <bytes-like object>`。如果你想接受文件系统路径并将它们转化成 "
"C 字符串，建议使用 ``O&`` 表达式配合 :c:func:`PyUnicode_FSConverter` 作为 *转化函数*。"

#: ../../c-api/arg.rst:96
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr "以前，当 Python 字符串中遇到了嵌入的 null 代码点会引发 :exc:`TypeError` 。"

#: ../../c-api/arg.rst:100
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:101
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"这个表达式既接受 Unicode 对象也接受类字节类型对象。它为由调用者提供的 :c:type:`Py_buffer` 结构赋值。这里结果的 C "
"字符串可能包含嵌入的 NUL 字节。Unicode 对象通过 ``'utf-8'`` 编码转化成 C 字符串。"

#: ../../c-api/arg.rst:106
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, "
":c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, "
":c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:107
msgid ""
"Like ``s*``, except that it provides a :ref:`borrowed buffer <c-arg-"
"borrowed-buffer>`. The result is stored into two C variables, the first one "
"a pointer to a C string, the second one its length. The string may contain "
"embedded null bytes. Unicode objects are converted to C strings using "
"``'utf-8'`` encoding."
msgstr ""
"像是 ``s*``，区别在于它提供了一个 :ref:`借入的缓冲区 <c-arg-borrowed-buffer>`。 结果存储在两个 C "
"变量中，第一个是指向 C 字符串的指针，第二个是其长度。 该字符串可能包含嵌入的空字节。 Unicode 对象会使用 ``'utf-8'`` "
"编码格式转换为 C 字符串。"

#: ../../c-api/arg.rst:113 ../../c-api/arg.rst:629
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` or ``None``) [const char \\*]"

#: ../../c-api/arg.rst:114
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``. It is the same as ``s?`` with the C pointer was "
"initialized to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:118
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"

#: ../../c-api/arg.rst:119
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``. It "
"is the same as ``s*?`` with the ``buf`` member of the :c:type:`Py_buffer` "
"structure was initialized to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:124
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` 或者 ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:125
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C"
" pointer is set to ``NULL``. It is the same as ``s#?`` with the C pointer "
"was initialized to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:129
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (read-only :term:`bytes-like object`) [const char \\*]"

#: ../../c-api/arg.rst:130
msgid ""
"This format converts a bytes-like object to a C pointer to a :ref:`borrowed "
"<c-arg-borrowed-buffer>` character string; it does not accept Unicode "
"objects.  The bytes buffer must not contain embedded null bytes; if it does,"
" a :exc:`ValueError` exception is raised."
msgstr ""
"这个格式会将一个类字节对象转换为一个指向 :ref:`借入的 <c-arg-borrowed-buffer>` 字符串的 C 指针；它不接受 "
"Unicode 对象。 字节缓冲区不可包含嵌入的空字节；如果包含这样的内容，将会引发 :exc:`ValueError` 异常。exception is"
" raised."

#: ../../c-api/arg.rst:136
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr "以前，当字节缓冲区中遇到了嵌入的 null 字节会引发 :exc:`TypeError` 。"

#: ../../c-api/arg.rst:140
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:141
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr "``s*`` 的变式，不接受 Unicode 对象，只接受类字节类型变量。**这是接受二进制数据的推荐方法。**"

#: ../../c-api/arg.rst:145
msgid ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, "
":c:type:`Py_ssize_t`]"
msgstr ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, "
":c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:146
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr "``s#`` 的变式，不接受 Unicode 对象，只接受类字节类型变量。"

#: ../../c-api/arg.rst:149
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

#: ../../c-api/arg.rst:150
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"要求 Python 对象为 :class:`bytes` 对象，不尝试进行任何转换。 如果该对象不为 bytes 对象则会引发 "
":exc:`TypeError`。 C 变量也可被声明为 :c:expr:`PyObject*`。"

#: ../../c-api/arg.rst:154
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

#: ../../c-api/arg.rst:155
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
":class:`bytearray` object. The C variable may also be declared as "
":c:expr:`PyObject*`."
msgstr ""
"要求 Python 对象为 :class:`bytearray` 对象，不尝试进行任何转换。 如果该对象不为 :class:`bytearray` "
"对象则会引发 :exc:`TypeError`。 C 变量也可被声明为 :c:expr:`PyObject*`。"

#: ../../c-api/arg.rst:159
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

#: ../../c-api/arg.rst:160
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object."
"  The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"要求 Python 对象为 Unicode 对象，不尝试进行任何转换。 如果该对象不为 Unicode 对象则会引发 :exc:`TypeError`。"
" C 变量也可被声明为 :c:expr:`PyObject*`。"

#: ../../c-api/arg.rst:164
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (可读写 :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:165
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call "
":c:func:`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"这个表达式接受任何实现可读写缓存区接口的对象。它为调用者提供的 :c:type:`Py_buffer` 结构赋值。缓冲区可能存在嵌入的 null "
"字节。当缓冲区使用完后调用者需要调用 :c:func:`PyBuffer_Release`。"

#: ../../c-api/arg.rst:170
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:171
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr "``s`` 的变式，它将编码后的 Unicode 字符存入字符缓冲区。它只处理没有嵌 NUL 字节的已编码数据。"

#: ../../c-api/arg.rst:174
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:expr:`const char*` which points to the name of an encoding as a"
" NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument."
msgstr ""
"此格式需要两个参数。 第一个仅用作输入，并且必须为 :c:expr:`const char*`，它指向一个以 NUL "
"结束的字符串表示的编码格式名称，或者为 ``NULL``，这种情况会使用 ``'utf-8'`` 编码格式。 如果 Python "
"无法识别指定的编码格式则会引发异常。 第二个参数必须为 :c:expr:`char**`；它所引用的指针值将被设为带有参数文本内容的缓冲区。 "
"文本将以第一个参数所指定的编码格式进行编码。"

#: ../../c-api/arg.rst:182
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling "
":c:func:`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` 会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 *\\*buffer* "
"引用这个新分配的内存空间。调用者有责任在使用后调用 :c:func:`PyMem_Free` 去释放已经分配的缓冲区。"

#: ../../c-api/arg.rst:187
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:188
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr "和 ``es`` 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。"

#: ../../c-api/arg.rst:192
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, "
":c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, "
":c:type:`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:193
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer."
" Unlike the ``es`` format, this variant allows input data which contains NUL"
" characters."
msgstr "``s#`` 的变式，它将已编码的 Unicode 字符存入字符缓冲区。不像 ``es`` 表达式，它允许传入的数据包含 NUL 字符。"

#: ../../c-api/arg.rst:197
msgid ""
"It requires three arguments.  The first is only used as input, and must be a"
" :c:expr:`const char*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"它需要三个参数。 第一个仅用作输入，并且必须为 :c:expr:`const char*`，它指向一个以  NUL "
"结束的字符串表示的编码格式名称，或者为 ``NULL``，这种情况会使用 ``'utf-8'`` 编码格式。 如果 Python "
"无法识别指定的编码格式则会引发异常。 第二个参数必须为 :c:expr:`char**`；它所引用的指针值将被设为带有参数文本内容的缓冲区。 "
"文本将以第一个参数所指定的编码格式进行编码。 第三个参数必须为指向一个整数的指针；被引用的整数将被设为输出缓冲区中的字节数。"

#: ../../c-api/arg.rst:207
msgid "There are two modes of operation:"
msgstr "有两种操作方式："

#: ../../c-api/arg.rst:209
msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"如果 *\\*buffer* 指向 ``NULL`` 指针，则函数将分配所需大小的缓冲区，将编码的数据复制到此缓冲区，并设置 *\\*buffer* "
"以引用新分配的存储。 呼叫者负责调用 :c:func:`PyMem_Free` 以在使用后释放分配的缓冲区。"

#: ../../c-api/arg.rst:214
msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and"
" interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"如果 *\\*buffer* 指向非 ``NULL`` 指针（已分配的缓冲区），则 :c:func:`PyArg_ParseTuple` "
"将使用此位置作为缓冲区，并将 *\\*buffer_length* 的初始值解释为缓冲区大小。 然后，它将将编码的数据复制到缓冲区，并终止它。 "
"如果缓冲区不够大，将设置一个 :exc:`ValueError`。"

#: ../../c-api/arg.rst:220
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr "在这两个例子中，*\\*buffer_length* 被设置为编码后结尾不为 NUL 的数据的长度。"

#: ../../c-api/arg.rst:223
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` 或 :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:224
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr "和 ``es#`` 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。"

#: ../../c-api/arg.rst:228
msgid ""
"``u``, ``u#``, ``Z``, and ``Z#`` are removed because they used a legacy "
"``Py_UNICODE*`` representation."
msgstr "``u``, ``u#``, ``Z`` 和 ``Z#`` 已被移除因为它们只用于旧式的 ``Py_UNICODE*`` 表示形式。"

#: ../../c-api/arg.rst:234
msgid "Numbers"
msgstr "数字"

#: ../../c-api/arg.rst:236
msgid ""
"These formats allow representing Python numbers or single characters as C "
"numbers. Formats that require :class:`int`, :class:`float` or "
":class:`complex` can also use the corresponding special methods "
":meth:`~object.__index__`, :meth:`~object.__float__` or "
":meth:`~object.__complex__` to convert the Python object to the required "
"type."
msgstr ""
"这些格式允许将 Python 数字或单个字符表示为 C 数字。 需要 :class:`int`, :class:`float` 或 "
":class:`complex` 的格式还可以使用相应的特殊方法 :meth:`~object.__index__`, "
":meth:`~object.__float__` 或 :meth:`~object.__complex__` 将 Python 对象转换为所需的类型。"

#: ../../c-api/arg.rst:242
msgid ""
"For signed integer formats, :exc:`OverflowError` is raised if the value is "
"out of range for the C type. For unsigned integer formats, no range checking"
" is done --- the most significant bits are silently truncated when the "
"receiving field is too small to receive the value."
msgstr ""
"对于有符号整数格式，如果值超出了 C 类型的范围则会引发 :exc:`OverflowError`。 对于无符号整数格式，则不会进行取值范围检查 ---"
" 当接受字段太小而无法接受值时将静默地截断最高有效位。"

#: ../../c-api/arg.rst:248
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:249
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny integer, stored in "
"a C :c:expr:`unsigned char`."
msgstr "将一个非负的 Python 整数转换为无符号微整数，存储于 C :c:expr:`unsigned char` 中。"

#: ../../c-api/arg.rst:252 ../../c-api/arg.rst:663
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:253
msgid ""
"Convert a Python integer to a tiny integer without overflow checking, stored"
" in a C :c:expr:`unsigned char`."
msgstr "将一个 Python 整数转换为微整数并且不进行溢出检查，存储于 C :c:expr:`unsigned char` 中。"

#: ../../c-api/arg.rst:256 ../../c-api/arg.rst:657
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [short int]"

#: ../../c-api/arg.rst:257
msgid "Convert a Python integer to a C :c:expr:`short int`."
msgstr "将 Python 整数转换为 C :c:expr:`short int`。"

#: ../../c-api/arg.rst:259 ../../c-api/arg.rst:666
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

#: ../../c-api/arg.rst:260
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned short int`, without "
"overflow checking."
msgstr "将 Python 整数转换为 C :c:expr:`unsigned short int`，不进行溢出检查。"

#: ../../c-api/arg.rst:263 ../../c-api/arg.rst:651
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

#: ../../c-api/arg.rst:264
msgid "Convert a Python integer to a plain C :c:expr:`int`."
msgstr "将 Python 整数转换为 C :c:expr:`int`。"

#: ../../c-api/arg.rst:266 ../../c-api/arg.rst:669
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

#: ../../c-api/arg.rst:267
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned int`, without overflow "
"checking."
msgstr "将 Python 整数转换为 C :c:expr:`unsigned int`，不进行溢出检查。"

#: ../../c-api/arg.rst:270 ../../c-api/arg.rst:660
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

#: ../../c-api/arg.rst:271
msgid "Convert a Python integer to a C :c:expr:`long int`."
msgstr "将 Python 整数转换为 C :c:expr:`long int`。"

#: ../../c-api/arg.rst:273 ../../c-api/arg.rst:672
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

#: ../../c-api/arg.rst:274
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long` without overflow "
"checking."
msgstr "将 Python 整数转换为 C :c:expr:`unsigned long`，不进行溢出检查。"

#: ../../c-api/arg.rst:277 ../../c-api/arg.rst:287
msgid "Use :meth:`~object.__index__` if available."
msgstr "如果可能将使用 :meth:`~object.__index__`。"

#: ../../c-api/arg.rst:280 ../../c-api/arg.rst:675
msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [long long]"

#: ../../c-api/arg.rst:281
msgid "Convert a Python integer to a C :c:expr:`long long`."
msgstr "将 Python 整数转换为 C :c:expr:`long long`。"

#: ../../c-api/arg.rst:283 ../../c-api/arg.rst:680
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [unsigned long long]"

#: ../../c-api/arg.rst:284
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long long` without "
"overflow checking."
msgstr "将Python整数转换为C:C:expr:'unsigned long-long'，而不进行溢出检查。"

#: ../../c-api/arg.rst:290 ../../c-api/arg.rst:683
msgid "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"
msgstr "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:291
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "将一个 Python 整型转化成一个 C :c:type:`Py_ssize_t` Python 元大小类型。"

#: ../../c-api/arg.rst:293
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` 或者 :class:`bytearray` 长度为 1) [char]"

#: ../../c-api/arg.rst:294
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray`"
" object of length 1, to a C :c:expr:`char`."
msgstr ""
"将一个 Python 字节类型，如一个长度为 1 的 :class:`bytes` 或 :class:`bytearray` 对象，转换为 C "
":c:expr:`char` 。"

#: ../../c-api/arg.rst:297
msgid "Allow :class:`bytearray` objects."
msgstr "允许 :class:`bytearray` 类型的对象。"

#: ../../c-api/arg.rst:300 ../../c-api/arg.rst:694
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` 长度为 1) [int]"

#: ../../c-api/arg.rst:301
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:expr:`int`."
msgstr "将一个 Python 字符，如一个长度为 1 的 :class:`str` 对象，转换为 C :c:expr:`int`。"

#: ../../c-api/arg.rst:304 ../../c-api/arg.rst:701
msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

#: ../../c-api/arg.rst:305
msgid "Convert a Python floating-point number to a C :c:expr:`float`."
msgstr "将Python浮点数转换成C的:c:expr:`float`"

#: ../../c-api/arg.rst:307 ../../c-api/arg.rst:698
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

#: ../../c-api/arg.rst:308
msgid "Convert a Python floating-point number to a C :c:expr:`double`."
msgstr "将Python浮点数转换成C的:c:expr:`double`"

#: ../../c-api/arg.rst:310
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

#: ../../c-api/arg.rst:311
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr "将一个 Python 复数类型转化成一个 C :c:type:`Py_complex` Python 复数类型。"

#: ../../c-api/arg.rst:314
msgid "Other objects"
msgstr "其他对象"

#: ../../c-api/arg.rst:316 ../../c-api/arg.rst:707
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:317
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C"
" program thus receives the actual object that was passed.  A new "
":term:`strong reference` to the object is not created (i.e. its reference "
"count is not increased). The pointer stored is not ``NULL``."
msgstr ""
"将 Python 对象（未经任何转换）存储到一个 C 对象指针中。 这样 C 程序就能接收到实际传递的对象。 对象的新 :term:`strong "
"reference` 不会被创建（即其引用计数不会增加）。 存储的指针将不为 ``NULL``。"

#: ../../c-api/arg.rst:323
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (object) [*typeobject*, PyObject \\*]"

#: ../../c-api/arg.rst:324
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the"
" second is the address of the C variable (of type :c:expr:`PyObject*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""
"将一个 Python 对象存入一个 C 对象指针。 这类似于 ``O``，但是接受两个 C 参数：第一个是 Python "
"类型对象的地址，第二个是存储对象指针的 C 变量 (类型为 :c:expr:`PyObject*`)。 如果 Python "
"对象不具有所要求的类型，则会引发 :exc:`TypeError`。"

#: ../../c-api/arg.rst:332
msgid "``O&`` (object) [*converter*, *address*]"
msgstr "``O&`` (object) [*converter*, *address*]"

#: ../../c-api/arg.rst:333
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address"
" of a C variable (of arbitrary type), converted to :c:expr:`void *`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"通过 *converter* 函数将 Python 对象转换为 C 变量。这需要两个参数：第一个是函数，第二个是 C 变量（任意类型）的地址，转换为 "
":c:expr:`void *`。*转换器* 函数依次调用如下："

#: ../../c-api/arg.rst:338
msgid "status = converter(object, address);"
msgstr "status = converter(object, address);"

#: ../../c-api/arg.rst:340
msgid ""
"where *object* is the Python object to be converted and *address* is the "
":c:expr:`void*` argument that was passed to the ``PyArg_Parse*`` function. "
"The returned *status* should be ``1`` for a successful conversion and ``0`` "
"if the conversion has failed.  When the conversion fails, the *converter* "
"function should raise an exception and leave the content of *address* "
"unmodified."
msgstr ""
"其中 *object* 是待转换的 Python 对象而 *address* 为传给 ``PyArg_Parse*`` 函数的 "
":c:expr:`void*` 参数。 返回的 *status* 应当以 ``1`` 代表转换成功而以 ``0`` 代表转换失败。 "
"当转换失败时，*converter* 函数应当引发异常并让 *address* 的内容保持未修改状态。"

#: ../../c-api/arg.rst:349
msgid ""
"If the *converter* returns :c:macro:`!Py_CLEANUP_SUPPORTED`, it may get "
"called a second time if the argument parsing eventually fails, giving the "
"converter a chance to release any memory that it had already allocated. In "
"this second call, the *object* parameter will be ``NULL``; *address* will "
"have the same value as in the original call."
msgstr ""
"如果 *converter* 返回 "
":c:macro:`!Py_CLEANUP_SUPPORTED`，则如果参数解析最终失败它可能会再次被调用，以使转换器有机会释放已分配的任何内存。 "
"在第二次调用中，*object* 形参将为 ``NULL``; *address* 将具有与原始调用相同的值。"

#: ../../c-api/arg.rst:355
msgid ""
"Examples of converters: :c:func:`PyUnicode_FSConverter` and "
":c:func:`PyUnicode_FSDecoder`."
msgstr ""
"转换器的例子: :c:func:`PyUnicode_FSConverter` 和 :c:func:`PyUnicode_FSDecoder`。"

#: ../../c-api/arg.rst:358
msgid ":c:macro:`!Py_CLEANUP_SUPPORTED` was added."
msgstr "增加了 :c:macro:`!Py_CLEANUP_SUPPORTED`。"

#: ../../c-api/arg.rst:361 ../../c-api/arg.rst:686
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

#: ../../c-api/arg.rst:362
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about"
" how Python tests values for truth."
msgstr ""
"测试传入的值是否为真(一个布尔判断)并且将结果转化为相对应的 C true/false 整型值。如果表达式为真置 ``1``，假则置 "
"``0``。它接受任何合法的 Python 值。参见 :ref:`truth` 获取更多关于 Python 如何测试值为真的信息。"

#: ../../c-api/arg.rst:370
msgid "``(items)`` (sequence) [*matching-items*]"
msgstr ""

#: ../../c-api/arg.rst:371
msgid ""
"The object must be a Python sequence (except :class:`str`, :class:`bytes` or"
" :class:`bytearray`) whose length is the number of format units in *items*."
"  The C arguments must correspond to the individual format units in *items*."
"  Format units for sequences may be nested."
msgstr ""

#: ../../c-api/arg.rst:376
msgid ""
"If *items* contains format units which store a :ref:`borrowed buffer <c-arg-"
"borrowed-buffer>` (``s``, ``s#``, ``z``, ``z#``, ``y``, or ``y#``) or a "
":term:`borrowed reference` (``S``, ``Y``, ``U``, ``O``, or ``O!``), the "
"object must be a Python tuple. The *converter* for the ``O&`` format unit in"
" *items* must not store a borrowed buffer or a borrowed reference."
msgstr ""

#: ../../c-api/arg.rst:383
msgid ""
":class:`str` and :class:`bytearray` objects no longer accepted as a "
"sequence."
msgstr ""

#: ../../c-api/arg.rst:386
msgid ""
"Non-tuple sequences are deprecated if *items* contains format units which "
"store a borrowed buffer or a borrowed reference."
msgstr ""

#: ../../c-api/arg.rst:390
msgid "``unit?`` (anything or ``None``) [*matching-variable(s)*]"
msgstr ""

#: ../../c-api/arg.rst:391
msgid ""
"``?`` modifies the behavior of the preceding format unit. The C variable(s) "
"corresponding to that parameter should be initialized to their default value"
" --- when the argument is ``None``, :c:func:`PyArg_ParseTuple` does not "
"touch the contents of the corresponding C variable(s). If the argument is "
"not ``None``, it is parsed according to the specified format unit."
msgstr ""

#: ../../c-api/arg.rst:401
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr "格式化字符串中还有一些其他的字符具有特殊的涵义。这些可能并不嵌套在圆括号中。它们是："

#: ../../c-api/arg.rst:404
msgid "``|``"
msgstr "``|``"

#: ../../c-api/arg.rst:405
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"表明在 Python 参数列表中剩下的参数都是可选的。C 变量对应的可选参数需要初始化为默认值——当一个可选参数没有指定时， "
":c:func:`PyArg_ParseTuple`  不能访问相应的 C 变量(变量集)的内容。"

#: ../../c-api/arg.rst:411
msgid "``$``"
msgstr "``$``"

#: ../../c-api/arg.rst:412
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always"
" be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` only：表明在 Python "
"参数列表中剩下的参数都是强制关键字参数。当前，所有强制关键字参数都必须也是可选参数，所以格式化字符串中  ``|`` 必须一直在 ``$`` 前面。"

#: ../../c-api/arg.rst:420
msgid "``:``"
msgstr "``:``"

#: ../../c-api/arg.rst:421
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"格式单元的列表结束标志；冒号后的字符串被用来作为错误消息中的函数名(:c:func:`PyArg_ParseTuple` 函数引发的“关联值”异常)。"

#: ../../c-api/arg.rst:425
msgid "``;``"
msgstr "``;``"

#: ../../c-api/arg.rst:426
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and "
"``;`` mutually exclude each other."
msgstr "格式单元的列表结束标志；分号后的字符串被用来作为错误消息取代默认的错误消息。 ``:`` 和 ``;`` 相互排斥。"

#: ../../c-api/arg.rst:430
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not release them (i.e. do not decrement their "
"reference count)!"
msgstr "请注意提供给调用者的任何 Python 对象引用都是 *借入* 引用；不要释放它们（即不要递减它们的引用计数）！"

#: ../../c-api/arg.rst:434
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"传递给这些函数的附加参数必须是由格式化字符串确定的变量的地址；这些都是用来存储输入元组的值。有一些情况，如上面的格式单元列表中所描述的，这些参数作为输入值使用；在这种情况下，它们应该匹配指定的相应的格式单元。"

#: ../../c-api/arg.rst:440
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the ``PyArg_Parse*`` functions "
"return true, otherwise they return false and raise an appropriate exception."
" When the ``PyArg_Parse*`` functions fail due to conversion failure in one "
"of the format units, the variables at the addresses corresponding to that "
"and the following format units are left untouched."
msgstr ""
"为了让转换成功，*arg* 对象必须匹配格式并且格式必须被用尽。 当成功时，``PyArg_Parse*`` "
"函数将返回真值，否则将返回假值并引发适当的异常。 当 ``PyArg_Parse*`` "
"函数由于某个格式单元转换出错而失败时，该格式单元及其后续格式单元对应的地址上的变量都将保持原样。"

#: ../../c-api/arg.rst:449
msgid "API Functions"
msgstr "API 函数"

#: ../../c-api/arg.rst:453
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false"
" and raises the appropriate exception."
msgstr "解析一个函数的参数，表达式中的参数按参数位置顺序存入局部变量中。成功返回 true；失败返回 false 并且引发相应的异常。"

#: ../../c-api/arg.rst:460
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr "和 :c:func:`PyArg_ParseTuple` 相同，然而它接受一个 va_list 类型的参数而不是可变数量的参数集。"

#: ../../c-api/arg.rst:466
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables. The *keywords* argument is a "
"``NULL``-terminated array of keyword parameter names specified as null-"
"terminated ASCII or UTF-8 encoded C strings. Empty names denote "
":ref:`positional-only parameters <positional-only_parameter>`. Returns true "
"on success; on failure, it returns false and raises the appropriate "
"exception."
msgstr ""
"解析一个将位置参数和关键字参数同时转为局部变量的函数的形参。 *keywords* 参数是由以空值结束的 ASCII 和 UTF-8 编码 C "
"字符串表示的关键字形参名称组成的以 ``NULL`` 结束的数组。 空名称代表 :ref:`仅限位置形参 <positional-"
"only_parameter>`。 成功时返回真值；失败时，它将返回假值并引发相应的异常。"

#: ../../c-api/arg.rst:477
msgid ""
"The *keywords* parameter declaration is :c:expr:`char * const *` in C and "
":c:expr:`const char * const *` in C++. This can be overridden with the "
":c:macro:`PY_CXX_CONST` macro."
msgstr ""
"*keywords* 形参声明在 C 中为 :c:expr:`char * const *` 而在 C++ 中为 :c:expr:`const char"
" * const *`。 这可以通过 :c:macro:`PY_CXX_CONST` 宏来重写。"

#: ../../c-api/arg.rst:481
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""
"添加了 :ref:`positional-only parameters <positional-only_parameter>` 的支持。"

#: ../../c-api/arg.rst:485
msgid ""
"The *keywords* parameter has now type :c:expr:`char * const *` in C and "
":c:expr:`const char * const *` in C++, instead of :c:expr:`char **`. Added "
"support for non-ASCII keyword parameter names."
msgstr ""
"现在 *keywords* 形参类型在 C 中为 :c:expr:`char * const *` 而在 C++ 中为 :c:expr:`const "
"char * const *`，而不是 :c:expr:`char **`。 增加了对非 ASCII 关键字形参名称的支持。"

#: ../../c-api/arg.rst:494
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a"
" va_list rather than a variable number of arguments."
msgstr ""
"和 :c:func:`PyArg_ParseTupleAndKeywords` 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。"

#: ../../c-api/arg.rst:500
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"确保字典中的关键字参数都是字符串。这个函数只被使用于 :c:func:`PyArg_ParseTupleAndKeywords` "
"不被使用的情况下，后者已经不再做这样的检查。"

#: ../../c-api/arg.rst:509
msgid ""
"Parse the parameter of a function that takes a single positional parameter "
"into a local variable.  Returns true on success; on failure, it returns "
"false and raises the appropriate exception."
msgstr "解析一个将单独位置形参转为局部变量的函数的形参。 成功时返回真值；失败时，它将返回假值并引发相应的异常。"

#: ../../c-api/arg.rst:513
msgid "Example::"
msgstr "示例::"

#: ../../c-api/arg.rst:515
msgid ""
"// Function using METH_O calling convention\n"
"static PyObject*\n"
"my_function(PyObject *module, PyObject *arg)\n"
"{\n"
"    int value;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        return NULL;\n"
"    }\n"
"    // ... use value ...\n"
"}"
msgstr ""
"// 使用 METH_O 调用规范的函数\n"
"static PyObject*\n"
"my_function(PyObject *module, PyObject *arg)\n"
"{\n"
"    int value;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        return NULL;\n"
"    }\n"
"    // ... 使用 value ...\n"
"}"

#: ../../c-api/arg.rst:529
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :c:macro:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:expr:`PyObject*` variable; these will be filled "
"in with the values from *args*; they will contain :term:`borrowed references"
" <borrowed reference>`. The variables which correspond to optional "
"parameters not given by *args* will not be filled in; these should be "
"initialized by the caller. This function returns true on success and false "
"if *args* is not a tuple or contains the wrong number of elements; an "
"exception will be set if there was a failure."
msgstr ""
"一个更简单的形参提取形式，它不使用格式字符串来指定参数类型。 使用此方法来提取其形参的函数应当在函数或方法表中声明为 "
":c:macro:`METH_VARARGS`。 包含实际形参的元组应当作为 *args* 传入；它必须确实是一个元组。 该元组的长度必须至少为 "
"*min* 且不超过 *max*； *min* 和 *max* 可能相等。 额外的参数必须被传给函数，每个参数应当是一个指向 "
":c:expr:`PyObject*` 变量的指针；它们将以来自 *args* 的值来填充； 它们将包含 :term:`借入引用 <borrowed "
"reference>`。 对应于 *args* 未给出的可选形参的变量不会被填充； 它们应当由调用方来初始化。 此函数在执行成功时返回真值而在 "
"*args* 不为元组或包含错误数量的元素时返回假值；如果执行失败则还将设置一个异常。"

#: ../../c-api/arg.rst:544
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`!_weakref` helper module for weak references::"
msgstr "这是一个使用该函数的示例，取自 :mod:`!_weakref` 弱引用辅助模块的源代码::"

#: ../../c-api/arg.rst:547
msgid ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"

#: ../../c-api/arg.rst:560
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"这个例子中调用 :c:func:`PyArg_UnpackTuple` 完全等价于调用 :c:func:`PyArg_ParseTuple`::"

#: ../../c-api/arg.rst:563
msgid "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"
msgstr "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"

#: ../../c-api/arg.rst:567
msgid ""
"The value to be inserted, if any, before :c:expr:`char * const *` in the "
"*keywords* parameter declaration of :c:func:`PyArg_ParseTupleAndKeywords` "
"and :c:func:`PyArg_VaParseTupleAndKeywords`. Default empty for C and "
"``const`` for C++ (:c:expr:`const char * const *`). To override, define it "
"to the desired value before including :file:`Python.h`."
msgstr ""
"要插入到 :c:func:`PyArg_ParseTupleAndKeywords` 和 "
":c:func:`PyArg_VaParseTupleAndKeywords` 的 *keywords* 形参声明中位于 :c:expr:`char *"
" const *` 之前的值，如果有的话。 默认在 C 中为空而在 C++ 中为 ``const`` (:c:expr:`const char * "
"const *`)。 如需重写，可在包括 :file:`Python.h` 之前将其定义为想要的值。"

#: ../../c-api/arg.rst:581
msgid "Building values"
msgstr "创建变量"

#: ../../c-api/arg.rst:585
msgid ""
"Create a new value based on a format string similar to those accepted by the"
" ``PyArg_Parse*`` family of functions and a sequence of values.  Returns the"
" value or ``NULL`` in the case of an error; an exception will be raised if "
"``NULL`` is returned."
msgstr ""
"基于类似 ``PyArg_Parse*`` 函数族所接受内容的格式字符串和一个值序列来创建一个新值。 返回该值或在发生错误的情况下返回 "
"``NULL``；如果返回 ``NULL`` 则将引发一个异常。"

#: ../../c-api/arg.rst:590
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force"
" it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` "
"并不一直创建一个元组。只有当它的格式化字符串包含两个或更多的格式单元才会创建一个元组。如果格式化字符串是空，它返回 "
"``None``；如果它包含一个格式单元，它返回由格式单元描述的的任一对象。用圆括号包裹格式化字符串可以强制它返回一个大小为 0 或者 1 的元组。"

#: ../../c-api/arg.rst:596
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes "
":c:func:`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`,"
" your code is responsible for calling :c:func:`free` for that memory once "
":c:func:`Py_BuildValue` returns."
msgstr ""
"当内存缓存区的数据以参数形式传递用来构建对象时，如 ``s`` 和 ``s#`` 格式单元，会拷贝需要的数据。调用者提供的缓冲区从来都不会被由 "
":c:func:`Py_BuildValue` 创建的对象来引用。换句话说，如果你的代码调用 :c:func:`malloc` "
"并且将分配的内存空间传递给 :c:func:`Py_BuildValue`，你的代码就有责任在 :c:func:`Py_BuildValue` "
"返回时调用 :c:func:`free` 。"

#: ../../c-api/arg.rst:604
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"在下面的描述中，双引号的表达式使格式单元；圆括号 () 内的是格式单元将要返回的 Python 对象类型；方括号 [] 内的是传递的 C "
"变量(变量集)的类型。"

#: ../../c-api/arg.rst:608
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long"
" format strings a tad more readable."
msgstr ""
"字符例如空格，制表符，冒号和逗号在格式化字符串中会被忽略(但是不包括格式单元，如 ``s#``)。这可以使很长的格式化字符串具有更好的可读性。"

#: ../../c-api/arg.rst:612
msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` 或 ``None``) [const char \\*]"

#: ../../c-api/arg.rst:613
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""
"使用 ``'utf-8'`` 编码将空终止的 C 字符串转换为 Python :class:`str` 对象。如果 C 字符串指针为 "
"``NULL``，则使用 ``None``。"

#: ../../c-api/arg.rst:616
msgid "``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``s#`` (:class:`str` 或 ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:617
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"使用 ``'utf-8'`` 编码将 C 字符串及其长度转换为 Python :class:`str` 对象。如果 C 字符串指针为 "
"``NULL``，则长度将被忽略，并返回 ``None``。"

#: ../../c-api/arg.rst:621
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

#: ../../c-api/arg.rst:622
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string"
" pointer is ``NULL``, ``None`` is returned."
msgstr ""
"这将 C 字符串转换为 Python :class:`bytes` 对象。 如果 C 字符串指针为 ``NULL``，则返回 ``None``。"

#: ../../c-api/arg.rst:625
msgid "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:626
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr "这会将 C 字符串及其长度转换为一个 Python 对象。 如果该 C 字符串指针为 ``NULL``，则返回 ``None``。"

#: ../../c-api/arg.rst:630 ../../c-api/arg.rst:646
msgid "Same as ``s``."
msgstr "和 ``s`` 一样。"

#: ../../c-api/arg.rst:632
msgid "``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``z#`` (:class:`str` 或 ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:633 ../../c-api/arg.rst:649
msgid "Same as ``s#``."
msgstr "和 ``s#`` 一样。"

#: ../../c-api/arg.rst:635
msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [const wchar_t \\*]"

#: ../../c-api/arg.rst:636
msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""
"将空终止的 :c:type:`wchar_t` 的 Unicode （UTF-16 或 UCS-4） 数据缓冲区转换为 Python Unicode "
"对象。 如果 Unicode 缓冲区指针为 ``NULL``，则返回 ``None``。"

#: ../../c-api/arg.rst:640
msgid "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:641
msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"将 Unicode （UTF-16 或 UCS-4） 数据缓冲区及其长度转换为 Python Unicode 对象。  如果 Unicode "
"缓冲区指针为 ``NULL``，则长度将被忽略，并返回 ``None``。"

#: ../../c-api/arg.rst:645
msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` 或 ``None``) [const char \\*]"

#: ../../c-api/arg.rst:648
msgid "``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``U#`` (:class:`str` 或 ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:652
msgid "Convert a plain C :c:expr:`int` to a Python integer object."
msgstr "将一个基本 C :c:expr:`int` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:654
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

#: ../../c-api/arg.rst:655
msgid "Convert a plain C :c:expr:`char` to a Python integer object."
msgstr "将一个基本 C :c:expr:`char` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:658
msgid "Convert a plain C :c:expr:`short int` to a Python integer object."
msgstr "将一个基本 C :c:expr:`short int` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:661
msgid "Convert a C :c:expr:`long int` to a Python integer object."
msgstr "将一个 C :c:expr:`long int` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:664
msgid "Convert a C :c:expr:`unsigned char` to a Python integer object."
msgstr "将一个 C :c:expr:`unsigned char` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:667
msgid "Convert a C :c:expr:`unsigned short int` to a Python integer object."
msgstr "将一个 C :c:expr:`unsigned short int` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:670
msgid "Convert a C :c:expr:`unsigned int` to a Python integer object."
msgstr "将一个 C :c:expr:`unsigned int` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:673
msgid "Convert a C :c:expr:`unsigned long` to a Python integer object."
msgstr "将一个 C :c:expr:`unsigned long` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:676
msgid "Convert a C :c:expr:`long long` to a Python integer object."
msgstr "将一个 C :c:expr:`long long` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:681
msgid "Convert a C :c:expr:`unsigned long long` to a Python integer object."
msgstr "将一个 C :c:expr:`unsigned long long` 转换为 Python 整数对象。"

#: ../../c-api/arg.rst:684
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "将一个 C :c:type:`Py_ssize_t` 类型转化为 Python 整型。"

#: ../../c-api/arg.rst:687
msgid ""
"Convert a C :c:expr:`int` to a Python :class:`bool` object. .. "
"versionadded:: 3.14"
msgstr ""

#: ../../c-api/arg.rst:690
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` 长度为1 ) [char]"

#: ../../c-api/arg.rst:691
msgid ""
"Convert a C :c:expr:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr "将一个代表单个字节的 C :c:expr:`int` 转换为长度为 1 的 Python :class:`bytes` 对象。"

#: ../../c-api/arg.rst:695
msgid ""
"Convert a C :c:expr:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr "将一个代表单个字符的 C :c:expr:`int` 转换为长度为 1 的 Python :class:`str` 对象。"

#: ../../c-api/arg.rst:699
msgid "Convert a C :c:expr:`double` to a Python floating-point number."
msgstr "将 C :c:expr:`double` 转换成 Python 浮点数"

#: ../../c-api/arg.rst:702
msgid "Convert a C :c:expr:`float` to a Python floating-point number."
msgstr "将 C :c:expr:`float` 转换成 Python 浮点数"

#: ../../c-api/arg.rst:704
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

#: ../../c-api/arg.rst:705
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr "将一个 C :c:type:`Py_complex` 类型的结构转化为 Python 复数类型。"

#: ../../c-api/arg.rst:708
msgid ""
"Pass a Python object untouched but create a new :term:`strong reference` to "
"it (i.e. its reference count is incremented by one). If the object passed in"
" is a ``NULL`` pointer, it is assumed that this was caused because the call "
"producing the argument found an error and set an exception. Therefore, "
":c:func:`Py_BuildValue` will return ``NULL`` but won't raise an exception.  "
"If no exception has been raised yet, :exc:`SystemError` is set."
msgstr ""
"原封不动地传递一个 Python 对象，但为其创建一个新的 :term:`strong reference` (即其引用计数加一)。 "
"如果传入的对象是一个 ``NULL`` 指针，则会假定这是因为产生该参数的调用发现了错误并设置了异常。 "
"因此，:c:func:`Py_BuildValue` 将返回 ``NULL`` 但不会引发异常。 如果尚未引发异常，则会设置 "
":exc:`SystemError`。"

#: ../../c-api/arg.rst:717
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:718
msgid "Same as ``O``."
msgstr "和 ``O`` 相同。"

#: ../../c-api/arg.rst:720
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:721
msgid ""
"Same as ``O``, except it doesn't create a new :term:`strong reference`. "
"Useful when the object is created by a call to an object constructor in the "
"argument list."
msgstr ""
"与 ``O`` 相同，但它不会创建新的 :term:`strong reference`。 "
"如果对象是通过调用参数列表中的对象构造器来创建的则该方法将很有用处。"

#: ../../c-api/arg.rst:725
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (object) [*converter*, *anything*]"

#: ../../c-api/arg.rst:726
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with "
":c:expr:`void*`) as its argument and should return a \"new\" Python object, "
"or ``NULL`` if an error occurred."
msgstr ""
"通过 *converter* 函数将 *anything* 转换为 Python 对象。 该函数在调用时附带 *anything* (它应当兼容 "
":c:expr:`void*`) 作为其参数并且应返回一个 \"新的\" Python 对象，或者如果发生错误则返回 ``NULL``。"

#: ../../c-api/arg.rst:731
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../../c-api/arg.rst:732
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr "将一个 C 变量序列转换成 Python 元组并保持相同的元素数量。"

#: ../../c-api/arg.rst:734
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*相关的元素*]"

#: ../../c-api/arg.rst:735
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr "将一个 C 变量序列转换成 Python 列表并保持相同的元素数量。"

#: ../../c-api/arg.rst:737
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*相关的元素*]"

#: ../../c-api/arg.rst:738
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr "将一个C变量序列转换成 Python 字典。每一对连续的 C 变量对作为一个元素插入字典中，分别作为关键字和值。"

#: ../../c-api/arg.rst:742
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr "如果格式字符串中出现错误，则设置 :exc:`SystemError` 异常并返回 ``NULL``。"

#: ../../c-api/arg.rst:747
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr "和 :c:func:`Py_BuildValue` 相同，然而它接受一个 va_list 类型的参数而不是可变数量的参数集。"
