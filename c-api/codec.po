# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/codec.rst:4
msgid "Codec registry and support functions"
msgstr "编解码器注册与支持功能"

#: ../../c-api/codec.rst:8
msgid "Register a new codec search function."
msgstr "注册一个新的编解码器搜索函数。"

#: ../../c-api/codec.rst:10
msgid ""
"As side effect, this tries to load the :mod:`!encodings` package, if not yet"
" done, to make sure that it is always first in the list of search functions."
msgstr "作为其附带影响，如果 :mod:`!encodings` 包尚未加载，则会尝试加载它，以确保它在搜索函数列表中始终排在第一位。"

#: ../../c-api/codec.rst:15
msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing. Return 0 on success. Raise an"
" exception and return -1 on error."
msgstr "注销一个编解码器搜索函数并清空注册表缓存。 如果指定搜索函数未被注册，则不做任何操作。 成功时返回 0。 出错时引发一个异常并返回 -1。"

#: ../../c-api/codec.rst:23
msgid ""
"Return ``1`` or ``0`` depending on whether there is a registered codec for "
"the given *encoding*.  This function always succeeds."
msgstr "根据注册的给定 *encoding* 的编解码器是否已存在而返回 ``1`` 或 ``0``。此函数总能成功。"

#: ../../c-api/codec.rst:28
msgid "Generic codec based encoding API."
msgstr "泛型编解码器基本编码 API。"

#: ../../c-api/codec.rst:30
msgid ""
"*object* is passed through the encoder function found for the given "
"*encoding* using the error handling method defined by *errors*.  *errors* "
"may be ``NULL`` to use the default method defined for the codec.  Raises a "
":exc:`LookupError` if no encoder can be found."
msgstr ""
"*object* 使用由 *errors* 所定义的错误处理方法传递给定 *encoding* 的编码器函数。 *errors* 可以为 "
"``NULL`` 表示使用为编码器所定义的默认方法。 如果找不到编码器则会引发 :exc:`LookupError`。"

#: ../../c-api/codec.rst:37
msgid "Generic codec based decoding API."
msgstr "泛型编解码器基本解码 API。"

#: ../../c-api/codec.rst:39
msgid ""
"*object* is passed through the decoder function found for the given "
"*encoding* using the error handling method defined by *errors*.  *errors* "
"may be ``NULL`` to use the default method defined for the codec.  Raises a "
":exc:`LookupError` if no encoder can be found."
msgstr ""
"*object* 使用由 *errors* 所定义的错误处理方法传递给定 *encoding* 的解码器函数。 *errors* 可以为 "
"``NULL`` 表示使用为编解码器所定义的默认方法。 如果找不到编解码器则会引发 :exc:`LookupError`。"

#: ../../c-api/codec.rst:46
msgid "Codec lookup API"
msgstr "Codec 查找API"

#: ../../c-api/codec.rst:48
msgid ""
"In the following functions, the *encoding* string is looked up converted to "
"all lower-case characters, which makes encodings looked up through this "
"mechanism effectively case-insensitive.  If no codec is found, a "
":exc:`KeyError` is set and ``NULL`` returned."
msgstr ""
"在下列函数中，*encoding* 字符串会被查找并转换为小写字母形式，这使得通过此机制查找编码格式实际上对大小写不敏感。 "
"如果未找到任何编解码器，则将设置 :exc:`KeyError` 并返回 ``NULL``。"

#: ../../c-api/codec.rst:55
msgid "Get an encoder function for the given *encoding*."
msgstr "为给定的 *encoding* 获取一个编码器函数。"

#: ../../c-api/codec.rst:59
msgid "Get a decoder function for the given *encoding*."
msgstr "为给定的 *encoding* 获取一个解码器函数。"

#: ../../c-api/codec.rst:63
msgid ""
"Get an :class:`~codecs.IncrementalEncoder` object for the given *encoding*."
msgstr "为给定的 *encoding* 获取一个 :class:`~codecs.IncrementalEncoder` 对象。"

#: ../../c-api/codec.rst:67
msgid ""
"Get an :class:`~codecs.IncrementalDecoder` object for the given *encoding*."
msgstr "为给定的 *encoding* 获取一个 :class:`~codecs.IncrementalDecoder` 对象。"

#: ../../c-api/codec.rst:71
msgid ""
"Get a :class:`~codecs.StreamReader` factory function for the given "
"*encoding*."
msgstr "为给定的 *encoding* 获取一个 :class:`~codecs.StreamReader` 工厂函数。"

#: ../../c-api/codec.rst:75
msgid ""
"Get a :class:`~codecs.StreamWriter` factory function for the given "
"*encoding*."
msgstr "为给定的 *encoding* 获取一个 :class:`~codecs.StreamWriter` 工厂函数。"

#: ../../c-api/codec.rst:79
msgid "Registry API for Unicode encoding error handlers"
msgstr "用于Unicode编码错误处理程序的注册表API"

#: ../../c-api/codec.rst:83
msgid ""
"Register the error handling callback function *error* under the given "
"*name*. This callback function will be called by a codec when it encounters "
"unencodable characters/undecodable bytes and *name* is specified as the "
"error parameter in the call to the encode/decode function."
msgstr ""
"在给定的 *name* 之下注册错误处理回调函数 *error*。 该回调函数将在一个编解码器遇到无法编码的字符/无法解码的字节数据并且 *name* "
"被指定为 encode/decode 函数调用的 error 形参时由该编解码器来调用。"

#: ../../c-api/codec.rst:88
msgid ""
"The callback gets a single argument, an instance of "
":exc:`UnicodeEncodeError`, :exc:`UnicodeDecodeError` or "
":exc:`UnicodeTranslateError` that holds information about the problematic "
"sequence of characters or bytes and their offset in the original string (see"
" :ref:`unicodeexceptions` for functions to extract this information).  The "
"callback must either raise the given exception, or return a two-item tuple "
"containing the replacement for the problematic sequence, and an integer "
"giving the offset in the original string at which encoding/decoding should "
"be resumed."
msgstr ""
"该回调函数会接受一个 :exc:`UnicodeEncodeError`, :exc:`UnicodeDecodeError` 或 "
":exc:`UnicodeTranslateError` 的实例作为单独参数，其中包含关于有问题字符或字节序列及其在原始序列的偏移量信息（请参阅 "
":ref:`unicodeexceptions` 了解提取此信息的函数详情）。 "
"该回调函数必须引发给定的异常，或者返回一个包含有问题序列及相应替换序列的二元组，以及一个表示偏移量的整数，该整数指明应在什么位置上恢复编码/解码操作。"

#: ../../c-api/codec.rst:98
msgid "Return ``0`` on success, ``-1`` on error."
msgstr "成功则返回 ``0``，失败则返回 ``-1``。"

#: ../../c-api/codec.rst:102
msgid ""
"Lookup the error handling callback function registered under *name*.  As a "
"special case ``NULL`` can be passed, in which case the error handling "
"callback for \"strict\" will be returned."
msgstr ""
"查找在 *name* 之下注册的错误处理回调函数。 作为特例还可以传入 ``NULL``，在此情况下将返回针对 \"strict\" "
"的错误处理回调函数。"

#: ../../c-api/codec.rst:108
msgid "Raise *exc* as an exception."
msgstr "引发 *exc* 作为异常。"

#: ../../c-api/codec.rst:112
msgid "Ignore the unicode error, skipping the faulty input."
msgstr "忽略 unicode 错误，跳过错误的输入。"

#: ../../c-api/codec.rst:116
msgid "Replace the unicode encode error with ``?`` or ``U+FFFD``."
msgstr "使用 ``?`` 或 ``U+FFFD`` 替换 unicode 编码错误。"

#: ../../c-api/codec.rst:120
msgid "Replace the unicode encode error with XML character references."
msgstr "使用 XML 字符引用替换 unicode 编码错误。"

#: ../../c-api/codec.rst:124
msgid ""
"Replace the unicode encode error with backslash escapes (``\\x``, ``\\u`` "
"and ``\\U``)."
msgstr "使用反斜杠转义符 (``\\x``, ``\\u`` 和 ``\\U``) 替换 unicode 编码错误。"

#: ../../c-api/codec.rst:129
msgid "Replace the unicode encode error with ``\\N{...}`` escapes."
msgstr "使用 ``\\N{...}`` 转义符替换 unicode 编码错误。"
