# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/tuple.rst:6
msgid "Tuple Objects"
msgstr "元组对象"

#: ../../c-api/tuple.rst:13
msgid "This subtype of :c:type:`PyObject` represents a Python tuple object."
msgstr "这个 :c:type:`PyObject` 的子类型代表一个 Python 的元组对象。"

#: ../../c-api/tuple.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python tuple type; it"
" is the same object as :class:`tuple` in the Python layer."
msgstr ""
":c:type:`PyTypeObject` 的实例代表一个 Python 元组类型，这与 Python 层面的 :class:`tuple` "
"是相同的对象。"

#: ../../c-api/tuple.rst:24
msgid ""
"Return true if *p* is a tuple object or an instance of a subtype of the "
"tuple type.  This function always succeeds."
msgstr "如果 *p* 是一个 tuple 对象或者 tuple 类型的子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/tuple.rst:30
msgid ""
"Return true if *p* is a tuple object, but not an instance of a subtype of "
"the tuple type.  This function always succeeds."
msgstr "如果 *p* 是一个 tuple 对象但不是 tuple 类型的子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/tuple.rst:36
msgid ""
"Return a new tuple object of size *len*, or ``NULL`` with an exception set "
"on failure."
msgstr "返回一个长度为 *len* 的新元组对象，或者失败时返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/tuple.rst:42
msgid ""
"Return a new tuple object of size *n*, or ``NULL`` with an exception set on "
"failure. The tuple values are initialized to the subsequent *n* C arguments "
"pointing to Python objects. ``PyTuple_Pack(2, a, b)`` is equivalent to "
"``Py_BuildValue(\"(OO)\", a, b)``."
msgstr ""
"返回一个长度为 *n* 的新元组对象，或者失败时返回 ``NULL`` 并设置一个异常。 元组值初始化为指向 Python 对象的后续 *n* 个 C "
"参数。 ``PyTuple_Pack(2, a, b)`` 等价于 ``Py_BuildValue(\"(OO)\", a, b)``。"

#: ../../c-api/tuple.rst:50
msgid ""
"Take a pointer to a tuple object, and return the size of that tuple. On "
"error, return ``-1`` and with an exception set."
msgstr "接受一个指向元组对象的指针，并返回该元组的大小。 失败时，返回 ``-1`` 并设置一个异常。"

#: ../../c-api/tuple.rst:56
msgid "Like :c:func:`PyTuple_Size`, but without error checking."
msgstr "类似于 :c:func:`PyTuple_Size`，但是不带错误检测。"

#: ../../c-api/tuple.rst:61
msgid ""
"Return the object at position *pos* in the tuple pointed to by *p*.  If "
"*pos* is negative or out of bounds, return ``NULL`` and set an "
":exc:`IndexError` exception."
msgstr ""
"返回 *p* 所指向的元组中位于 *pos* 处的对象。 如果 *pos* 为负值或超出范围，则返回 ``NULL`` 并设置一个 "
":exc:`IndexError` 异常。"

#: ../../c-api/tuple.rst:64
msgid ""
"The returned reference is borrowed from the tuple *p* (that is: it is only "
"valid as long as you hold a reference to *p*). To get a :term:`strong "
"reference`, use :c:func:`Py_NewRef(PyTuple_GetItem(...)) <Py_NewRef>` or "
":c:func:`PySequence_GetItem`."
msgstr ""
"返回的引用是从元组 *p* 借入的（也就是说：它只在你持有对 *p* 的引用时才是可用的）。 要获取 :term:`strong "
"reference`，请使用 :c:func:`Py_NewRef(PyTuple_GetItem(...)) <Py_NewRef>` 或 "
":c:func:`PySequence_GetItem`。"

#: ../../c-api/tuple.rst:73
msgid "Like :c:func:`PyTuple_GetItem`, but does no checking of its arguments."
msgstr "类似于 :c:func:`PyTuple_GetItem`，但不检查其参数。"

#: ../../c-api/tuple.rst:78
msgid ""
"Return the slice of the tuple pointed to by *p* between *low* and *high*, or"
" ``NULL`` with an exception set on failure."
msgstr "返回一个 *p* 指向的元组的 *low* 和 *high* 之间的切片，或者失败时返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/tuple.rst:81
msgid ""
"This is the equivalent of the Python expression ``p[low:high]``. Indexing "
"from the end of the tuple is not supported."
msgstr "这等价于 Python 表达式 ``p[low:high]``。 不支持从元组末尾进行索引。"

#: ../../c-api/tuple.rst:87
msgid ""
"Insert a reference to object *o* at position *pos* of the tuple pointed to "
"by *p*.  Return ``0`` on success.  If *pos* is out of bounds, return ``-1`` "
"and set an :exc:`IndexError` exception."
msgstr ""
"在 *p* 指向的元组的 *pos* 位置插入对对象 *o* 的引用。 成功时返回 ``0``；如果 *pos* 越界，则返回 ``-1``，并抛出一个"
" :exc:`IndexError` 异常。"

#: ../../c-api/tuple.rst:93
msgid ""
"This function \"steals\" a reference to *o* and discards a reference to an "
"item already in the tuple at the affected position."
msgstr "此函数会“窃取”对 *o* 的引用，并丢弃对元组中已在受影响位置的条目的引用。"

#: ../../c-api/tuple.rst:99
msgid ""
"Like :c:func:`PyTuple_SetItem`, but does no error checking, and should "
"*only* be used to fill in brand new tuples."
msgstr "类似于 :c:func:`PyTuple_SetItem`，但不进行错误检查，并且应该 *只是* 被用来填充全新的元组。"

#: ../../c-api/tuple.rst:102 ../../c-api/tuple.rst:224
#: ../../c-api/tuple.rst:242
msgid ""
"Bounds checking is performed as an assertion if Python is built in "
":ref:`debug mode <debug-build>` or :option:`with assertions <--with-"
"assertions>`."
msgstr ""
"当 Python 以 :ref:`调试模式 <debug-build>` 或 :option:`启用断言 <--with-assertions>` "
"构建时将把绑定检测作为断言来执行。"

#: ../../c-api/tuple.rst:107
msgid ""
"This function \"steals\" a reference to *o*, and, unlike "
":c:func:`PyTuple_SetItem`, does *not* discard a reference to any item that "
"is being replaced; any reference in the tuple at position *pos* will be "
"leaked."
msgstr ""
"这个函数会“窃取”一个对 *o* 的引用，但是，不与 :c:func:`PyTuple_SetItem` 不同，它 *不会* "
"丢弃对任何被替换项的引用；元组中位于 *pos* 位置的任何引用都将被泄漏。"

#: ../../c-api/tuple.rst:114
msgid ""
"This macro should *only* be used on tuples that are newly created. Using "
"this macro on a tuple that is already in use (or in other words, has a "
"refcount > 1) could lead to undefined behavior."
msgstr "这个宏应该只用于新创建的元组。在一个已经在使用的元组上使用这个宏（换句话说，重计数> 1）可能会导致未定义的行为。"

#: ../../c-api/tuple.rst:121
msgid ""
"Can be used to resize a tuple.  *newsize* will be the new length of the "
"tuple. Because tuples are *supposed* to be immutable, this should only be "
"used if there is only one reference to the object.  Do *not* use this if the"
" tuple may already be known to some other part of the code.  The tuple will "
"always grow or shrink at the end.  Think of this as destroying the old tuple"
" and creating a new one, only more efficiently.  Returns ``0`` on success. "
"Client code should never assume that the resulting value of ``*p`` will be "
"the same as before calling this function. If the object referenced by ``*p``"
" is replaced, the original ``*p`` is destroyed.  On failure, returns ``-1`` "
"and sets ``*p`` to ``NULL``, and raises :exc:`MemoryError` or "
":exc:`SystemError`."
msgstr ""
"可以用于调整元组的大小。 *newsize* 将是元组的新长度。 因为元组 *被认为* 是不可变的，所以只有在对象仅有一个引用时，才应该使用它。 "
"如果元组已经被代码的其他部分所引用，请不要使用此项。 元组在最后总是会增长或缩小。 把它看作是销毁旧元组并创建一个新元组，只会更有效。 成功时返回 "
"``0`` 。 客户端代码不应假定 ``*p`` 的结果值将与调用此函数之前的值相同。 如果替换了 ``*p`` 引用的对象，则原始的 ``*p`` "
"将被销毁。 失败时，返回 ``-1``，将 ``*p`` 设置为 ``NULL``，并引发 :exc:`MemoryError` 或者 "
":exc:`SystemError`。"

#: ../../c-api/tuple.rst:136
msgid "Struct Sequence Objects"
msgstr "结构序列对象"

#: ../../c-api/tuple.rst:138
msgid ""
"Struct sequence objects are the C equivalent of "
":func:`~collections.namedtuple` objects, i.e. a sequence whose items can "
"also be accessed through attributes. To create a struct sequence, you first "
"have to create a specific struct sequence type."
msgstr ""
"结构序列对象是等价于 :func:`~collections.namedtuple` 的 C 对象，即一个序列，其中的条目也可以通过属性访问。 "
"要创建结构序列，你首先必须创建特定的结构序列类型。"

#: ../../c-api/tuple.rst:145
msgid ""
"Create a new struct sequence type from the data in *desc*, described below. "
"Instances of the resulting type can be created with "
":c:func:`PyStructSequence_New`."
msgstr ""
"根据 *desc* 中的数据创建一个新的结构序列类型，如下所述。 可以使用 :c:func:`PyStructSequence_New` "
"创建结果类型的实例。"

#: ../../c-api/tuple.rst:148 ../../c-api/tuple.rst:217
msgid "Return ``NULL`` with an exception set on failure."
msgstr "失败时返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/tuple.rst:153
msgid "Initializes a struct sequence type *type* from *desc* in place."
msgstr "从 *desc* 就地初始化结构序列类型 *type*。"

#: ../../c-api/tuple.rst:158
msgid ""
"Like :c:func:`PyStructSequence_InitType`, but returns ``0`` on success and "
"``-1`` with an exception set on failure."
msgstr ""
"类似于 :c:func:`PyStructSequence_InitType`，但成功时返回 ``0`` 而失败时返回 ``-1`` 并设置一个异常。"

#: ../../c-api/tuple.rst:166
msgid "Contains the meta information of a struct sequence type to create."
msgstr "包含要创建的结构序列类型的元信息。"

#: ../../c-api/tuple.rst:170
msgid ""
"Fully qualified name of the type; null-terminated UTF-8 encoded. The name "
"must contain the module name."
msgstr "类型的完整限定名称；使用以空值结束的 UTF-8 编码。 该名称必须包含模块名。"

#: ../../c-api/tuple.rst:175
msgid "Pointer to docstring for the type or ``NULL`` to omit."
msgstr "指向类型的文档字符串的指针或以 ``NULL`` 表示忽略。"

#: ../../c-api/tuple.rst:179
msgid "Pointer to ``NULL``-terminated array with field names of the new type."
msgstr "指向以 ``NULL`` 结尾的数组的指针，该数组包含新类型的字段名。"

#: ../../c-api/tuple.rst:183
msgid "Number of fields visible to the Python side (if used as tuple)."
msgstr "Python 端可见的字段数（如果用作元组）。"

#: ../../c-api/tuple.rst:188
msgid ""
"Describes a field of a struct sequence. As a struct sequence is modeled as a"
" tuple, all fields are typed as :c:expr:`PyObject*`.  The index in the "
":c:member:`~PyStructSequence_Desc.fields` array of the "
":c:type:`PyStructSequence_Desc` determines which field of the struct "
"sequence is described."
msgstr ""
"描述结构序列的一个字段。 由于结构序列是以元组为模型的，因此所有字段的类型都是 :c:expr:`PyObject*`。 "
":c:type:`PyStructSequence_Desc` 的 :c:member:`~PyStructSequence_Desc.fields` "
"数组中的索引决定了描述结构序列的是哪个字段。"

#: ../../c-api/tuple.rst:196
msgid ""
"Name for the field or ``NULL`` to end the list of named fields, set to "
":c:data:`PyStructSequence_UnnamedField` to leave unnamed."
msgstr ""
"字段的名称或 ``NULL`` 表示结束已命名字段列表，设为 :c:data:`PyStructSequence_UnnamedField` "
"则保持未命名状态。"

#: ../../c-api/tuple.rst:201
msgid "Field docstring or ``NULL`` to omit."
msgstr "字段文档字符串或 ``NULL`` 表示省略。"

#: ../../c-api/tuple.rst:206
msgid "Special value for a field name to leave it unnamed."
msgstr "字段名的特殊值将保持未命名状态。"

#: ../../c-api/tuple.rst:208
msgid "The type was changed from ``char *``."
msgstr "这个类型已从 ``char *`` 更改。"

#: ../../c-api/tuple.rst:214
msgid ""
"Creates an instance of *type*, which must have been created with "
":c:func:`PyStructSequence_NewType`."
msgstr "创建 *type* 的实例，该实例必须使用 :c:func:`PyStructSequence_NewType` 创建。"

#: ../../c-api/tuple.rst:222
msgid ""
"Return the object at position *pos* in the struct sequence pointed to by "
"*p*."
msgstr "返回 *p* 所指向的结构序列中位于 *pos* 处的对象。"

#: ../../c-api/tuple.rst:230
msgid "Alias to :c:func:`PyStructSequence_GetItem`."
msgstr ":c:func:`PyStructSequence_GetItem` 的别名。"

#: ../../c-api/tuple.rst:232
msgid "Now implemented as an alias to :c:func:`PyStructSequence_GetItem`."
msgstr "现在被实现为 :c:func:`PyStructSequence_GetItem` 的别名。"

#: ../../c-api/tuple.rst:238
msgid ""
"Sets the field at index *pos* of the struct sequence *p* to value *o*.  Like"
" :c:func:`PyTuple_SET_ITEM`, this should only be used to fill in brand new "
"instances."
msgstr ""
"将结构序列 *p* 的索引 *pos* 处的字段设置为值 *o*。 与 :c:func:`PyTuple_SET_ITEM` "
"一样，它应该只用于填充全新的实例。"

#: ../../c-api/tuple.rst:247
msgid "This function \"steals\" a reference to *o*."
msgstr "这个函数“窃取”了指向 *o* 的一个引用。"

#: ../../c-api/tuple.rst:252
msgid "Alias to :c:func:`PyStructSequence_SetItem`."
msgstr ":c:func:`PyStructSequence_SetItem` 的别名。"

#: ../../c-api/tuple.rst:254
msgid "Now implemented as an alias to :c:func:`PyStructSequence_SetItem`."
msgstr "现在被实现为 :c:func:`PyStructSequence_SetItem` 的别名。"

#: ../../c-api/tuple.rst:8
msgid "object"
msgstr "object -- 对象"

#: ../../c-api/tuple.rst:8
msgid "tuple"
msgstr "元组"
