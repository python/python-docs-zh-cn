# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Fw[a]rd <howard.main@outlook.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "公用对象结构体"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr "大量的结构体被用于定义Python的对象类型。这一节描述了这些的结构体和它们的使用方法。"

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "基本的对象类型和宏"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"所有的 Python 对象最终都会在对象的内存表示的开始部分共享少量的字段。 这些字段由 :c:type:`PyObject` 和 "
":c:type:`PyVarObject` 类型来表示，相应地，这些类型又是由一些宏扩展来定义的，它们也直接或间接地被用于所有其他 Python "
"对象的定义。 附加的宏可以在 :ref:`引用计数 <countingrefs>` 下找到。"

#: ../../c-api/structures.rst:26
msgid ""
"All object types are extensions of this type.  This is a type which contains"
" the information Python needs to treat a pointer to an object as an object."
"  In a normal \"release\" build, it contains only the object's reference "
"count and a pointer to the corresponding type object. Nothing is actually "
"declared to be a :c:type:`PyObject`, but every pointer to a Python object "
"can be cast to a :c:expr:`PyObject*`.  Access to the members must be done by"
" using the macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"所有对象类型都是此类型的扩展。 这是一个包含了 Python 将对象的指针当作对象来处理所需的信息的类型。 "
"在一个普通的“发行”编译版中，它只包含对象的引用计数和指向对应类型对象的指针。 没有什么对象被实际声明为 "
":c:type:`PyObject`，但每个指向 Python 对象的指针都可以被转换为 :c:expr:`PyObject*`。 "
"对成员的访问必须通过使用 :c:macro:`Py_REFCNT` 和 :c:macro:`Py_TYPE` 宏来完成。"

#: ../../c-api/structures.rst:38
msgid ""
"This is an extension of :c:type:`PyObject` that adds the "
":c:member:`~PyVarObject.ob_size` field.  This is only used for objects that "
"have some notion of *length*. This type does not often appear in the "
"Python/C API. Access to the members must be done by using the macros "
":c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, and :c:macro:`Py_SIZE`."
msgstr ""
"这是一个添加了 :c:member:`~PyVarObject.ob_size` 字段的 :c:type:`PyObject` 扩展。 它仅用于具有某些"
" *长度* 标记的对象。 此类型并不经常在 Python/C API 中出现。 对成员的访问必须通过使用 :c:macro:`Py_REFCNT`, "
":c:macro:`Py_TYPE` 和 :c:macro:`Py_SIZE` 宏来完成。"

#: ../../c-api/structures.rst:47
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr "这是一个在声明代表无可变长度对象的新类型时所使用的宏。 PyObject_HEAD 宏被扩展为::"

#: ../../c-api/structures.rst:50
msgid "PyObject ob_base;"
msgstr "PyObject ob_base;"

#: ../../c-api/structures.rst:52
msgid "See documentation of :c:type:`PyObject` above."
msgstr "参见上面 :c:type:`PyObject` 的文档。"

#: ../../c-api/structures.rst:57
msgid ""
"This is a macro used when declaring new types which represent objects with a"
" length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr "这是一个在声明代表每个实例具有可变长度的对象时所使用的宏。 PyObject_VAR_HEAD 宏被扩展为::"

#: ../../c-api/structures.rst:61
msgid "PyVarObject ob_base;"
msgstr "PyVarObject ob_base;"

#: ../../c-api/structures.rst:63
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "参见上面 :c:type:`PyVarObject` 的文档。"

#: ../../c-api/structures.rst:68
msgid ""
"The base class of all other objects, the same as :class:`object` in Python."
msgstr "所有其他对象的基类，与 Python 中的 :class:`object` 相同。"

#: ../../c-api/structures.rst:73
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr "测试 *x* 是否为 *y* 对象，与 Python 中的 ``x is y`` 相同。"

#: ../../c-api/structures.rst:80
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr "测试一个对象是否为 ``None`` 单例，与 Python 中的 ``x is None`` 相同。"

#: ../../c-api/structures.rst:88
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr "测试一个对象是否为 ``True`` 单例，与 Python 中的 ``x is True`` 相同。"

#: ../../c-api/structures.rst:96
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr "测试一个对象是否为 ``False`` 单例，与 Python 中的 ``x is False`` 相同。"

#: ../../c-api/structures.rst:104
msgid "Get the type of the Python object *o*."
msgstr "获取 Python 对象 *o* 的类型。"

#: ../../c-api/structures.rst:106
msgid "Return a :term:`borrowed reference`."
msgstr "返回一个 :term:`borrowed reference`。"

#: ../../c-api/structures.rst:108
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr "使用 :c:func:`Py_SET_TYPE` 函数来设置一个对象类型。"

#: ../../c-api/structures.rst:110
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ":c:func:`Py_TYPE()` 被改为一个内联的静态函数。 形参类型不再是 :c:expr:`const PyObject*`。"

#: ../../c-api/structures.rst:117
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr "如果对象 *o* 的类型为 *type* 则返回非零值。 否则返回零。 等价于: ``Py_TYPE(o) == type``。"

#: ../../c-api/structures.rst:125
msgid "Set the object *o* type to *type*."
msgstr "将对象 *o* 的类型设为 *type*。"

#: ../../c-api/structures.rst:132
msgid "Get the size of the Python object *o*."
msgstr "获取 Python 对象 *o* 的大小。"

#: ../../c-api/structures.rst:134
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr "使用 :c:func:`Py_SET_SIZE` 函数来设置一个对象大小。"

#: ../../c-api/structures.rst:136
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` 被改为一个内联静态函数。 形参类型不再是 :c:expr:`const PyVarObject*`。"

#: ../../c-api/structures.rst:143
msgid "Set the object *o* size to *size*."
msgstr "将对象 *o* 的大小设为 *size*。"

#: ../../c-api/structures.rst:150
msgid ""
"This is a macro which expands to initialization values for a new "
":c:type:`PyObject` type.  This macro expands to::"
msgstr "这是一个为新的 :c:type:`PyObject` 类型扩展初始化值的宏。 该宏扩展为::"

#: ../../c-api/structures.rst:153
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type,"

#: ../../c-api/structures.rst:159
msgid ""
"This is a macro which expands to initialization values for a new "
":c:type:`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` "
"field. This macro expands to::"
msgstr ""
"这是一个为新的 :c:type:`PyVarObject` 类型扩展初始化值的宏，包括 :c:member:`~PyVarObject.ob_size`"
" 字段。 该宏会扩展为::"

#: ../../c-api/structures.rst:163
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"

#: ../../c-api/structures.rst:168
msgid "Implementing functions and methods"
msgstr "实现函数和方法"

#: ../../c-api/structures.rst:172
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"用于在 C 中实现大多数 Python 可调用对象的函数类型。 该类型的函数接受两个 :c:expr:`PyObject*` 形参并返回一个这样的值。 "
"如果返回值为 ``NULL``，则将设置一个异常。 如果不为 ``NULL``，则返回值将被解读为 Python 中暴露的函数的返回值。 "
"此函数必须返回一个新的引用。"

#: ../../c-api/structures.rst:179
msgid "The function signature is::"
msgstr "函数的签名为::"

#: ../../c-api/structures.rst:181
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"

#: ../../c-api/structures.rst:186
msgid ""
"Type of the functions used to implement Python callables in C with signature"
" :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. The "
"function signature is::"
msgstr ""
"用于在 C 中实现具有 :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`"
" 签名的 Python 可调用对象的函数类型。 函数的签名为::"

#: ../../c-api/structures.rst:190
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"

#: ../../c-api/structures.rst:197
msgid ""
"Type of the functions used to implement Python callables in C with signature"
" :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr "用于在 C 中实现具有 :c:macro:`METH_FASTCALL` 签名的 Python 可调用对象的函数类型。 函数的签名为::"

#: ../../c-api/structures.rst:201
msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"

#: ../../c-api/structures.rst:207
msgid ""
"Type of the functions used to implement Python callables in C with signature"
" :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>`. The "
"function signature is::"
msgstr ""
"用于在 C 中实现具有 :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` 签名的 Python 可调用对象的函数类型。 函数的签名为::"

#: ../../c-api/structures.rst:211
msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"

#: ../../c-api/structures.rst:218
msgid ""
"Type of the functions used to implement Python callables in C with signature"
" :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"用于在 C 中实现具有 :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>` 签名的 Python 可调用对象的函数类型。 函数的签名为::"

#: ../../c-api/structures.rst:222
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"

#: ../../c-api/structures.rst:233
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr "用于描述一个扩展类型的方法的结构体。 该结构体有四个字段:"

#: ../../c-api/structures.rst:238
msgid "Name of the method."
msgstr "方法的名称。"

#: ../../c-api/structures.rst:242
msgid "Pointer to the C implementation."
msgstr "指向 C 语言实现的指针。"

#: ../../c-api/structures.rst:246
msgid "Flags bits indicating how the call should be constructed."
msgstr "指明调用应当如何构建的旗标位。"

#: ../../c-api/structures.rst:250
msgid "Points to the contents of the docstring."
msgstr "指向文档字符串的内容。"

#: ../../c-api/structures.rst:252
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`~PyMethodDef.ml_meth` 是一个 C 函数指针。 该函数可以为不同类型，但它们将总是返回 "
":c:expr:`PyObject*`。 如果该函数不属于 :c:type:`PyCFunction`，则编译器将要求在方法表中进行转换。 尽管 "
":c:type:`PyCFunction` 将第一个参数定义为 :c:expr:`PyObject*`，但该方法的实现使用 *self* 对象的特定 C"
" 类型也很常见。"

#: ../../c-api/structures.rst:260
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ":c:member:`~PyMethodDef.ml_flags` 字段是可以包含以下旗标的位字段。 每个旗标表示一个调用惯例或绑定惯例。"

#: ../../c-api/structures.rst:265
msgid "There are these calling conventions:"
msgstr "调用惯例有如下这些:"

#: ../../c-api/structures.rst:269
msgid ""
"This is the typical calling convention, where the methods have the type "
":c:type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. "
"The first one is the *self* object for methods; for module functions, it is "
"the module object.  The second parameter (often called *args*) is a tuple "
"object representing all arguments. This parameter is typically processed "
"using :c:func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"这是典型的调用惯例，其中方法的类型为 :c:type:`PyCFunction`。 该函数接受两个 :c:expr:`PyObject*` 值。 "
"第一个是用于方法的 *self* 对象；对于模块函数，它将为模块对象。 第二个形参 (常被命名为 *args*) 是一个代表所有参数的元组对象。 "
"该形参通常是使用 :c:func:`PyArg_ParseTuple` 或 :c:func:`PyArg_UnpackTuple` 来处理的。"

#: ../../c-api/structures.rst:279
msgid ""
"Can only be used in certain combinations with other flags: "
":ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, "
":ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and "
":ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"只能用于同其他旗标形成特定的组合: :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`, :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` 和 :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`。"

#: ../../c-api/structures.rst:287
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

#: ../../c-api/structures.rst:288
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"带有这些旗标的方法必须为 :c:type:`PyCFunctionWithKeywords` 类型。 该函数接受三个形参: *self*, "
"*args*, *kwargs* 其中 *kwargs* 是一个包含所有关键字参数的字典或者如果没有关键字参数则可以为 ``NULL``。 "
"这些形参通常是使用 :c:func:`PyArg_ParseTupleAndKeywords` 来处理的。"

#: ../../c-api/structures.rst:297
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"快速调用惯例仅支持位置参数。 这些方法的类型为 :c:type:`PyCFunctionFast`。 第一个形参为 "
"*self*，第二个形参是由表示位置参数的由 :c:expr:`PyObject*` 值组成的 C 数组而第三个形参是位置参数的数量（数组的长度）。"

#: ../../c-api/structures.rst:307
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "``METH_FASTCALL`` 现在是 :ref:`稳定 ABI <stable-abi>` 的一部分。"

#: ../../c-api/structures.rst:312
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:313
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
":c:macro:`METH_FASTCALL` 的扩展也支持关键字参数，它使用类型为 "
":c:type:`PyCFunctionFastWithKeywords` 的方法。 关键字参数的传递方式与 :ref:`vectorcall 协议 "
"<vectorcall>` 中的相同：还存在额外的第四个 :c:expr:`PyObject*` "
"形参，它是一个代表关键字参数名称（它会保证是字符串）的元组，或者如果没有关键字则可以是 ``NULL``。 关键字参数的值存放在 *args* "
"数组中，在位置参数之后。"

#: ../../c-api/structures.rst:328
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"只能与其他旗标组合使用: :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`。"

#: ../../c-api/structures.rst:334
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:335
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of"
" ``Py_TYPE(self)``."
msgstr ""
":ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` 的扩展支持 "
"*定义式类*，也就是包含相应方法的类。 定义式类可以是 ``Py_TYPE(self)`` 的超类。"

#: ../../c-api/structures.rst:340
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"该方法必须为 :c:type:`PyCMethod` 类型，与在 ``self`` 之后添加了 ``defining_class`` 参数的 "
"``METH_FASTCALL | METH_KEYWORDS`` 一样。"

#: ../../c-api/structures.rst:349
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of"
" type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"如果通过 :c:macro:`METH_NOARGS` 旗标列出了参数则没有形参的方法无需检查是否给出了参数。 它们必须为 "
":c:type:`PyCFunction` 类型。 第一个形参通常被命名为 *self* 并将持有对模块或对象实例的引用。 在所有情况下第二个形参都将为"
" ``NULL``。"

#: ../../c-api/structures.rst:355
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, "
":c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr "该函数必须有 2 个形参。 由于第二个形参不会被使用，:c:macro:`Py_UNUSED` 可以被用来防止编译器警告。"

#: ../../c-api/structures.rst:361
msgid ""
"Methods with a single object argument can be listed with the "
":c:macro:`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with "
"a ``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"具有一个单独对象参数的方法可使用 :c:macro:`METH_O` 旗标列出，而不必唤起 :c:func:`PyArg_ParseTuple` 并附带"
" ``\"O\"`` 参数。 它们的类型为 :c:type:`PyCFunction`，带有 *self* 形参，以及代表该单独参数的 "
":c:expr:`PyObject*` 形参。"

#: ../../c-api/structures.rst:367
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"这两个常量不是被用来指明调用惯例而是在配合类方法使用时指明绑定。 它们不会被用于在模块上定义的函数。 对于任何给定方法这些旗标最多只会设置其中一个。"

#: ../../c-api/structures.rst:377
msgid ""
"The method will be passed the type object as the first parameter rather than"
" an instance of the type.  This is used to create *class methods*, similar "
"to what is created when using the :func:`classmethod` built-in function."
msgstr ""
"该方法将接受类型对象而不是类型的实例作为第一个形参。 它会被用于创建 *类方法*，类似于使用 :func:`classmethod` "
"内置函数所创建的结果。"

#: ../../c-api/structures.rst:387
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"该方法将接受 ``NULL`` 而不是类型的实例作为第一个形参。 它会被用于创建 *静态方法*，类似于使用 :func:`staticmethod` "
"内置函数所创建的结果。"

#: ../../c-api/structures.rst:391
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr "另一个常量控制方法是否将被载入来替代具有相同方法名的另一个定义。"

#: ../../c-api/structures.rst:397
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named "
":meth:`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will"
" be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"该方法将被加载以替代现有的定义。 如果没有 *METH_COEXIST*，默认将跳过重复的定义。 由于槽位包装器会在方法表之前被加载，例如 当存在 "
"*sq_contains* 槽位时，将会生成一个名为 :meth:`~object.__contains__` 的已包装方法并阻止加载同名的相应 "
"PyCFunction。 如果定义了此旗标，PyCFunction 将被加载以替代此包装器对象并与槽位共存。 因为对 PyCFunction "
"的调用相比对包装器对象调用更为优化所以这是很有帮助的。"

#: ../../c-api/structures.rst:409
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that"
" *ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"将 *ml* 转为一个 Python :term:`callable` 对象。 调用方必须确保 *ml* 的生命期长于 "
":term:`callable`。 通常，*ml* 会被定义为一个静态变量。"

#: ../../c-api/structures.rst:413
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function"
" in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"*self* 形参将在唤起时作为 ``ml->ml_meth`` 中 C 函数的 *self* 参数传入。 *self* 可以为 ``NULL``。"

#: ../../c-api/structures.rst:417
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
":term:`callable` 对象的 ``__module__`` 属性可以根据给定的 *module* 参数来设置。 *module* 应为一个 "
"Python 字符串，它将被用作函数定义所在的模块名称。 如果不可用，它将被设为 :const:`None` 或 ``NULL``。"

#: ../../c-api/structures.rst:423
msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

#: ../../c-api/structures.rst:425
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C"
" function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"*cls* 形参将被作为 C 函数的 *defining_class* 参数传入。 如果在 ``ml->ml_flags`` 上设置了 "
":c:macro:`METH_METHOD` 则必须设置该形参。"

#: ../../c-api/structures.rst:434
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "等价于 ``PyCMethod_New(ml, self, module, NULL)``。"

#: ../../c-api/structures.rst:439
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "等价于 ``PyCMethod_New(ml, self, NULL, NULL)``。"

#: ../../c-api/structures.rst:443
msgid "Accessing attributes of extension types"
msgstr "访问扩展类型的属性"

#: ../../c-api/structures.rst:447
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"描述某个 C 结构成员对应类型的属性的结构体。 在定义类时，要把由这些结构组成的以 NULL 结尾的数组 放在 "
":c:member:`~PyTypeObject.tp_members` 槽位中。"

#: ../../c-api/structures.rst:452
msgid "Its fields are, in order:"
msgstr "其中的字段及顺序如下:"

#: ../../c-api/structures.rst:456
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr "成员名称。 NULL 值表示 ``PyMemberDef[]`` 数组的结束。"

#: ../../c-api/structures.rst:459
msgid "The string should be static, no copy is made of it."
msgstr "字符串应当是静态的，它不会被复制。"

#: ../../c-api/structures.rst:463
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the"
" possible values."
msgstr "C 结构体中成员的类型。 请参阅 :ref:`PyMemberDef-types` 了解可能的取值。"

#: ../../c-api/structures.rst:468
msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr "成员在类型的对象结构体中所在位置的以字节为单位的偏移量。"

#: ../../c-api/structures.rst:472
msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr "零个或多个 :ref:`PyMemberDef-flags`，使用按位或运算进行组合。"

#: ../../c-api/structures.rst:476
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr "文档字符串，或者为空。 该字符串应当是静态的，它不会被拷贝。 通常，它是使用 :c:macro:`PyDoc_STR` 来定义的。"

#: ../../c-api/structures.rst:480
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply "
":c:macro:`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy "
":c:macro:`T_OBJECT`) members can be deleted."
msgstr ""
"默认情况下 (当 :c:member:`~PyMemberDef.flags` 为 ``0`` 时)，成员同时允许读取和写入访问。 使用 "
":c:macro:`Py_READONLY` 旗标表示只读访问。 某些类型，如 :c:macro:`Py_T_STRING`，隐含要求 "
":c:macro:`Py_READONLY`。 只有 :c:macro:`Py_T_OBJECT_EX` (以及旧式的 "
":c:macro:`T_OBJECT`) 成员可以删除。"

#: ../../c-api/structures.rst:489
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to "
":c:member:`~PyTypeObject.tp_vectorcall_offset` in type objects. This member "
"must be defined with ``Py_T_PYSSIZET``, and either ``Py_READONLY`` or "
"``Py_READONLY | Py_RELATIVE_OFFSET``. For example::"
msgstr ""
"对于堆分配类型（使用 :c:func:`PyType_FromSpec` 或类似函数创建），``PyMemberDef`` 可能包含特殊成员 "
"``\"__vectorcalloffset__\"`` 的定义，与类型对象中的 "
":c:member:`~PyTypeObject.tp_vectorcall_offset` 相对应。此成员必须用 ``Py_T_PYSSIZET`` "
"和 ``Py_READONLY`` 或``Py_READONLY | Py_RELATIVE_OFFSET``来定义，例如::"

#: ../../c-api/structures.rst:496
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* 哨兵 */\n"
"};"

#: ../../c-api/structures.rst:502
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr "（您可能需要为 :c:func:`!offsetof` 添加 ``#include <stddef.h>``。）"

#: ../../c-api/structures.rst:504
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and "
":c:member:`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT`"
" and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"旧式的偏移量 :c:member:`~PyTypeObject.tp_dictoffset` 和 "
":c:member:`~PyTypeObject.tp_weaklistoffset` 可使用 ``\"__dictoffset__\"`` 和 "
"``\"__weaklistoffset__\"`` 成员进行类似的定义，但强烈建议扩展程序改用 "
":c:macro:`Py_TPFLAGS_MANAGED_DICT` 和 :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF`。"

#: ../../c-api/structures.rst:512
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr "``PyMemberDef`` 将始终可用。在之前版本中，它需要包括 ``\"structmember.h\"``。"

#: ../../c-api/structures.rst:517
msgid ""
":c:macro:`Py_RELATIVE_OFFSET` is now allowed for "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` and "
"``\"__weaklistoffset__\"``."
msgstr ""
"宏 "
":c:macro:`Py_RELATIVE_OFFSET`现在允许用于``\"__vectorcalloffset__\"``、``\"__dictoffset__\"``"
" 和``\"__weaklistoffset__\"`` 。"

#: ../../c-api/structures.rst:523
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"获取属于地址Get an attribute belonging to the object at address *obj_addr* "
"上的对象的某个属性。 该属性是以 ``PyMemberDef`` *m* 来描述的。 出错时返回 ``NULL``。"

#: ../../c-api/structures.rst:529
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr "``PyMember_GetOne`` 将总是可用。 在之前版本中，它需要包括 ``\"structmember.h\"``。"

#: ../../c-api/structures.rst:534
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"将属于位于地址 *obj_addr* 的对象的属性设置到对象 *o*。 要设置的属性由 ``PyMemberDef`` *m* 描述。 成功时返回 "
"``0`` 而失败时返回负值。"

#: ../../c-api/structures.rst:540
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr "``PyMember_SetOne`` 将总是可用。 在之前版本中，它需要包括 ``\"structmember.h\"``。"

#: ../../c-api/structures.rst:546
msgid "Member flags"
msgstr "成员旗标"

#: ../../c-api/structures.rst:548
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr "以下旗标可被用于 :c:member:`PyMemberDef.flags`:"

#: ../../c-api/structures.rst:552
msgid "Not writable."
msgstr "不可写入。"

#: ../../c-api/structures.rst:556
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr "在读取之前发出一个 ``object.__getattr__`` :ref:`审计事件 <audit-events>`。"

#: ../../c-api/structures.rst:561
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"表示该 ``PyMemberDef`` 条目的 :c:member:`~PyMemberDef.offset` "
"是指明来自子类专属数据的偏移量，而不是来自 ``PyObject`` 的偏移量。"

#: ../../c-api/structures.rst:565
msgid ""
"Can only be used as part of :c:member:`Py_tp_members "
"<PyTypeObject.tp_members>` :c:type:`slot <PyType_Slot>` when creating a "
"class using negative :c:member:`~PyType_Spec.basicsize`. It is mandatory in "
"that case."
msgstr ""
"只能在使用负的 :c:member:`~PyType_Spec.basicsize` 创建类时被用作 :c:member:`Py_tp_members "
"<PyTypeObject.tp_members>` :c:type:`槽位 <PyType_Slot>` 的组成部分。 它在此种情况下是强制要求。"

#: ../../c-api/structures.rst:570
msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When setting "
":c:member:`~PyTypeObject.tp_members` during class creation, Python clears it"
" and sets :c:member:`PyMemberDef.offset` to the offset from the ``PyObject``"
" struct."
msgstr ""
"这个旗标只能在 :c:type:`PyType_Slot` 中使用。 在类创建期间设置 "
":c:member:`~PyTypeObject.tp_members` 时，Python 会清除它并将 "
":c:member:`PyMemberDef.offset` 设为相对于 ``PyObject`` 结构体的偏移量。"

#: ../../c-api/structures.rst:582
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and "
":c:macro:`!WRITE_RESTRICTED` macros available with ``#include "
"\"structmember.h\"`` are deprecated. :c:macro:`!READ_RESTRICTED` and "
":c:macro:`!RESTRICTED` are equivalent to :c:macro:`Py_AUDIT_READ`; "
":c:macro:`!WRITE_RESTRICTED` does nothing."
msgstr ""
"通过 ``#include \"structmember.h\"`` 提供的 "
":c:macro:`!RESTRICTED`、:c:macro:`!READ_RESTRICTED` 和 "
":c:macro:`!WRITE_RESTRICTED` 宏已被弃用。 :c:macro:`!READ_RESTRICTED` 和 "
":c:macro:`!RESTRICTED` 等同于 "
":c:macro:`Py_AUDIT_READ`；:c:macro:`!WRITE_RESTRICTED` 则没有任何作用。"

#: ../../c-api/structures.rst:593
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The "
":c:macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new"
" names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
":c:macro:`!READONLY` 宏被更名为 :c:macro:`Py_READONLY`。 :c:macro:`!PY_AUDIT_READ`"
" 宏被更名为 ``Py_`` 前缀。 新名称现在将始终可用。 在之前的版本中，这些名称需要 ``#include "
"\"structmember.h\"``。该头文件仍然可用并提供了原有的名称。"

#: ../../c-api/structures.rst:602
msgid "Member types"
msgstr "成员类型"

#: ../../c-api/structures.rst:604
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python,"
" it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
":c:member:`PyMemberDef.type` 可以是下列与各种 C 类型相对应的宏之一。 在 Python "
"中访问该成员时，它将被转换为对应的 Python 类型。 当从 Python 设置成员时，它将被转换回 C 类型。 如果无法转换，则会引发一个异常如 "
":exc:`TypeError` 或 :exc:`ValueError`。"

#: ../../c-api/structures.rst:612
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. "
":keyword:`del` or :py:func:`delattr`."
msgstr "除非标记为 (D)，否则不能使用 :keyword:`del` 或 :py:func:`delattr` 删除以这种方式定义的属性。"

#: ../../c-api/structures.rst:616
msgid "Macro name"
msgstr "宏名称"

#: ../../c-api/structures.rst:616
msgid "C type"
msgstr "C 类型"

#: ../../c-api/structures.rst:616
msgid "Python type"
msgstr "Python 类型"

#: ../../c-api/structures.rst:618
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../c-api/structures.rst:618 ../../c-api/structures.rst:619
#: ../../c-api/structures.rst:620 ../../c-api/structures.rst:621
#: ../../c-api/structures.rst:622 ../../c-api/structures.rst:623
#: ../../c-api/structures.rst:624 ../../c-api/structures.rst:625
#: ../../c-api/structures.rst:626 ../../c-api/structures.rst:627
#: ../../c-api/structures.rst:628
msgid ":py:class:`int`"
msgstr ":py:class:`int`"

#: ../../c-api/structures.rst:619
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../c-api/structures.rst:620
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/structures.rst:621
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../c-api/structures.rst:622
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../c-api/structures.rst:623
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../c-api/structures.rst:624
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../c-api/structures.rst:625
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../c-api/structures.rst:626
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../c-api/structures.rst:627
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../c-api/structures.rst:628
msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

#: ../../c-api/structures.rst:629
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../c-api/structures.rst:629 ../../c-api/structures.rst:630
msgid ":py:class:`float`"
msgstr ":py:class:`float`"

#: ../../c-api/structures.rst:630
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../c-api/structures.rst:631
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (写为 0 或 1)"

#: ../../c-api/structures.rst:631
msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

#: ../../c-api/structures.rst:633
msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

#: ../../c-api/structures.rst:633 ../../c-api/structures.rst:634
msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (RO)"

#: ../../c-api/structures.rst:634
msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

#: ../../c-api/structures.rst:635
msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

#: ../../c-api/structures.rst:635
msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

#: ../../c-api/structures.rst:636
msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

#: ../../c-api/structures.rst:636
msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (D)"

#: ../../c-api/structures.rst:639
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): 以零结束的 UTF8 编码的 C 字符串。 使用 :c:macro:`!Py_T_STRING` 时的 C 表示形式是一个指针；使用 "
":c:macro:`!Py_T_STRING_INPLACE` 时字符串将直接存储在结构体中。"

#: ../../c-api/structures.rst:644
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): 长度为 1 的字符串。 只接受 ASCII 字符。"

#: ../../c-api/structures.rst:646
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(RO)：表示 :c:macro:`Py_READONLY`。"

#: ../../c-api/structures.rst:648
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a"
" ``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(D)：可以删除，在这种情况下指针会被设为 ``NULL``。 读取 ``NULL`` 指针会引发 :py:exc:`AttributeError`。"

#: ../../c-api/structures.rst:674
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"在之前的版本中，这些宏仅通过 ``#include \"structmember.h\"`` 提供并且其名称不带 ``Py_`` 前缀 (例如 "
"``T_INT``)。 头文件仍然可用并包含这些旧名称，以及下列已被弃用的类型："

#: ../../c-api/structures.rst:682
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results"
" in surprising behavior in Python: deleting the attribute effectively sets "
"it to ``None``."
msgstr ""
"与 ``Py_T_OBJECT_EX`` 类似，但 ``NULL`` 会被转换为 ``None``。 这将在 Python "
"中产生令人吃惊的行为：删除该属性实际上会将其设置为 ``None``。"

#: ../../c-api/structures.rst:688
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "总是为 ``None``。 必须与 :c:macro:`Py_READONLY` 一起使用。"

#: ../../c-api/structures.rst:691
msgid "Defining Getters and Setters"
msgstr "定义读取器和设置器"

#: ../../c-api/structures.rst:695
msgid ""
"Structure to define property-like access for a type. See also description of"
" the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"用于定义针对某个类型的特征属性式的访问的结构体。 另请参阅 :c:member:`PyTypeObject.tp_getset` 槽位的描述。"

#: ../../c-api/structures.rst:700
msgid "attribute name"
msgstr "属性名称"

#: ../../c-api/structures.rst:704
msgid "C function to get the attribute."
msgstr "用于获取属性的 C 函数。"

#: ../../c-api/structures.rst:708
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr "可选的用于设置或删除属性的 C 函数。 如为 ``NULL``，则属性将是只读的。"

#: ../../c-api/structures.rst:713
msgid "optional docstring"
msgstr "可选的文档字符串"

#: ../../c-api/structures.rst:717
msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr "可选的用户数据指针，为 getter 和 setter 提供附加数据。"

#: ../../c-api/structures.rst:721
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"``get`` 函数接受一个 :c:expr:`PyObject*` 形参 (相应的实例) 和一个用户数据指针 (关联的 ``closure``):"

#: ../../c-api/structures.rst:724
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception"
" on failure."
msgstr "它应当在成功时返回一个新的引用或在失败时返回 ``NULL`` 并设置异常。"

#: ../../c-api/structures.rst:729
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"``set`` 函数接受两个 :c:expr:`PyObject*` 形参 (相应的实例和要设置的值) 和一个用户数据指针 (关联的 "
"``closure``):"

#: ../../c-api/structures.rst:732
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr "对于属性要被删除的情况第二个形参应为 ``NULL``。 成功时应返回 ``0`` 或在失败时返回 ``-1`` 并设置异常。"

#: ../../c-api/structures.rst:375 ../../c-api/structures.rst:385
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/structures.rst:375
msgid "classmethod"
msgstr "类方法"

#: ../../c-api/structures.rst:385
msgid "staticmethod"
msgstr "静态方法"

#: ../../c-api/structures.rst:575
msgid "READ_RESTRICTED (C macro)"
msgstr "READ_RESTRICTED (C 宏)"

#: ../../c-api/structures.rst:575
msgid "WRITE_RESTRICTED (C macro)"
msgstr "WRITE_RESTRICTED (C 宏)"

#: ../../c-api/structures.rst:575
msgid "RESTRICTED (C macro)"
msgstr "RESTRICTED (C 宏)"

#: ../../c-api/structures.rst:588
msgid "READONLY (C macro)"
msgstr "READONLY (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_BYTE (C macro)"
msgstr "T_BYTE (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_SHORT (C macro)"
msgstr "T_SHORT (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_INT (C macro)"
msgstr "T_INT (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_LONG (C macro)"
msgstr "T_LONG (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_USHORT (C macro)"
msgstr "T_USHORT (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_UINT (C macro)"
msgstr "T_UINT (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_ULONG (C macro)"
msgstr "T_ULONG (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_BOOL (C macro)"
msgstr "T_BOOL (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_CHAR (C macro)"
msgstr "T_CHAR (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_STRING (C macro)"
msgstr "T_STRING (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (C 宏)"

#: ../../c-api/structures.rst:651
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (C 宏)"

#: ../../c-api/structures.rst:651
msgid "structmember.h"
msgstr "structmember.h"
