# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Freesand Leo <yuqinju@163.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 05:02+0000\n"
"PO-Revision-Date: 2017-02-16 17:38+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/objbuffer.rst:4
msgid "Old Buffer Protocol"
msgstr "旧缓冲协议"

#: ../../c-api/objbuffer.rst:8
msgid ""
"These functions were part of the \"old buffer protocol\" API in Python 2. In"
" Python 3, this protocol doesn't exist anymore but the functions are still "
"exposed to ease porting 2.x code.  They act as a compatibility wrapper "
"around the :ref:`new buffer protocol <bufferobjects>`, but they don't give "
"you control over the lifetime of the resources acquired when a buffer is "
"exported."
msgstr ""
"这些函数是 Python 2 中“旧缓冲协议”API 的组成部分。 在 Python 3 中，此协议已不复存在，但这些函数仍然被公开以便移植 2.x "
"的代码。 它们被用作 :ref:`新缓冲协议 <bufferobjects>` "
"的兼容性包装器，但它们并不会在缓冲被导出时向你提供对所获资源的生命周期控制。"

#: ../../c-api/objbuffer.rst:15
msgid ""
"Therefore, it is recommended that you call :c:func:`PyObject_GetBuffer` (or "
"the ``y*`` or ``w*`` :ref:`format codes <arg-parsing>` with the "
":c:func:`PyArg_ParseTuple` family of functions) to get a buffer view over an"
" object, and :c:func:`PyBuffer_Release` when the buffer view can be "
"released."
msgstr ""
"因此，推荐你调用 :c:func:`PyObject_GetBuffer` (或者配合 :c:func:`PyArg_ParseTuple` 函数族使用"
" ``y*`` 或 ``w*`` :ref:`格式码 <arg-parsing>`) 来获取一个对象的缓冲视图，并在缓冲视图可被释放时调用 "
":c:func:`PyBuffer_Release`。"

#: ../../c-api/objbuffer.rst:23
msgid ""
"Returns a pointer to a read-only memory location usable as character-based "
"input.  The *obj* argument must support the single-segment character buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a "
":exc:`TypeError` on error."
msgstr ""
"返回一个指向可用作基于字符的输入的只读内存地址的指针。 *obj* 参数必须支持单段字符缓冲接口。 成功时返回 ``0``，将 *buffer* "
"设为内存地址并将 *buffer_len* 设为缓冲区长度。 出错时返回 ``-1`` 并设置一个 :exc:`TypeError`。"

#: ../../c-api/objbuffer.rst:32
msgid ""
"Returns a pointer to a read-only memory location containing arbitrary data. "
"The *obj* argument must support the single-segment readable buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a "
":exc:`TypeError` on error."
msgstr ""
"返回一个指向包含任意数据的只读内存地址的指针。 *obj* 参数必须支持单段可读缓冲接口。 成功时返回 ``0``，将 *buffer* "
"设为内存地址并将 *buffer_len* 设为缓冲区长度。 出错时返回 ``-1`` 并设置一个 :exc:`TypeError`。"

#: ../../c-api/objbuffer.rst:41
msgid ""
"Returns ``1`` if *o* supports the single-segment readable buffer interface. "
"Otherwise returns ``0``.  This function always succeeds."
msgstr "如果 *o* 支持单段可读缓冲接口则返回 ``1``。 否则返回 ``0``。 此函数总是会成功执行。"

#: ../../c-api/objbuffer.rst:44
msgid ""
"Note that this function tries to get and release a buffer, and exceptions "
"which occur while calling corresponding functions will get suppressed. To "
"get error reporting use :c:func:`PyObject_GetBuffer()` instead."
msgstr ""
"请注意此函数会尝试获取并释放一个缓冲区，并且在调用对应函数期间发生的异常会被屏蔽。 要获取错误报告则应改用 "
":c:func:`PyObject_GetBuffer()`。"

#: ../../c-api/objbuffer.rst:51
msgid ""
"Returns a pointer to a writable memory location.  The *obj* argument must "
"support the single-segment, character buffer interface.  On success, returns"
" ``0``, sets *buffer* to the memory location and *buffer_len* to the buffer "
"length.  Returns ``-1`` and sets a :exc:`TypeError` on error."
msgstr ""
"返回一个指向可写内存地址的指针。 *obj* 必须支持单段字符缓冲接口。 成功时返回 ``0``，将 *buffer* 设为内存地址并将 "
"*buffer_len* 设为缓冲区长度。 出错时返回 ``-1`` 并设置一个 :exc:`TypeError`。"
