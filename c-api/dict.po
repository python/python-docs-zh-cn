# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# Josh Ouyang <me@joshoy.org>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# 安龙, 2023
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/dict.rst:6
msgid "Dictionary Objects"
msgstr "字典对象"

#: ../../c-api/dict.rst:13
msgid ""
"This subtype of :c:type:`PyObject` represents a Python dictionary object."
msgstr "这个 :c:type:`PyObject` 的子类型代表一个Python字典对象。"

#: ../../c-api/dict.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python dictionary "
"type.  This is the same object as :class:`dict` in the Python layer."
msgstr ""
"Python字典类型表示为 :c:type:`PyTypeObject` 的实例。这与Python层面的 :class:`dict` 是相同的对象。"

#: ../../c-api/dict.rst:24
msgid ""
"Return true if *p* is a dict object or an instance of a subtype of the dict "
"type.  This function always succeeds."
msgstr "如果 *p* 是一个 dict 对象或者 dict 类型的子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/dict.rst:30
msgid ""
"Return true if *p* is a dict object, but not an instance of a subtype of the"
" dict type.  This function always succeeds."
msgstr "如果 *p* 是一个 dict 对象但不是 dict 类型的子类型的实例则返回真值。 此函数总是会成功执行。"

#: ../../c-api/dict.rst:36
msgid "Return a new empty dictionary, or ``NULL`` on failure."
msgstr "返回一个新的空字典，失败时返回 ``NULL``。"

#: ../../c-api/dict.rst:41
msgid ""
"Return a :class:`types.MappingProxyType` object for a mapping which enforces"
" read-only behavior.  This is normally used to create a view to prevent "
"modification of the dictionary for non-dynamic class types."
msgstr ""
"返回 :class:`types.MappingProxyType` 对象，用于强制执行只读行为的映射。这通常用于创建视图以防止修改非动态类类型的字典。"

#: ../../c-api/dict.rst:48
msgid "Empty an existing dictionary of all key-value pairs."
msgstr "清空现有字典的所有键值对。"

#: ../../c-api/dict.rst:53
msgid ""
"Determine if dictionary *p* contains *key*.  If an item in *p* is matches "
"*key*, return ``1``, otherwise return ``0``.  On error, return ``-1``. This "
"is equivalent to the Python expression ``key in p``."
msgstr ""
"确定 *key* 是否包含在字典 *p* 中。如果 *key* 匹配上 *p* 的某一项，则返回 ``1`` ，否则返回 ``0`` 。返回 "
"``-1`` 表示出错。这等同于Python表达式 ``key in p`` 。"

#: ../../c-api/dict.rst:60
msgid ""
"This is the same as :c:func:`PyDict_Contains`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyDict_Contains` 相同，但 *key* 被指定为一个 :c:expr:`const char*` UTF-8 "
"编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:69
msgid "Return a new dictionary that contains the same key-value pairs as *p*."
msgstr "返回与 *p* 包含相同键值对的新字典。"

#: ../../c-api/dict.rst:74
msgid ""
"Insert *val* into the dictionary *p* with a key of *key*.  *key* must be "
":term:`hashable`; if it isn't, :exc:`TypeError` will be raised. Return ``0``"
" on success or ``-1`` on failure.  This function *does not* steal a "
"reference to *val*."
msgstr ""
"使用 *key* 作为键将 *val* 插入字典 *p*。 *key* 必须为 :term:`hashable`；如果不是，则将引发 "
":exc:`TypeError`。 成功时返回 ``0``，失败时返回 ``-1``。 此函数 *不会* 附带对 *val* 的引用。"

#: ../../c-api/dict.rst:82
msgid ""
"This is the same as :c:func:`PyDict_SetItem`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyDict_SetItem` 相同，但 *key* 被指定为 :c:expr:`const char*` UTF-8 "
"编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:89
msgid ""
"Remove the entry in dictionary *p* with key *key*. *key* must be "
":term:`hashable`; if it isn't, :exc:`TypeError` is raised. If *key* is not "
"in the dictionary, :exc:`KeyError` is raised. Return ``0`` on success or "
"``-1`` on failure."
msgstr ""
"移除字典 *p* 中键为 *key* 的条目。 *key* 必须是 :term:`hashable`；如果不是，则会引发 "
":exc:`TypeError`。 如果字典中没有 *key*，则会引发 :exc:`KeyError`。 成功时返回 ``0`` 或者失败时返回 "
"``-1``。"

#: ../../c-api/dict.rst:97
msgid ""
"This is the same as :c:func:`PyDict_DelItem`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyDict_DelItem` 相同，但 *key* 被指定为 :c:expr:`const char*` UTF-8 "
"编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:104
msgid ""
"Return a new :term:`strong reference` to the object from dictionary *p* "
"which has a key *key*:"
msgstr "返回一个新的指向字典 *p* 中对应键 *key* 的对象的 :term:`strong reference`:"

#: ../../c-api/dict.rst:107
msgid ""
"If the key is present, set *\\*result* to a new :term:`strong reference` to "
"the value and return ``1``."
msgstr "如果存在该键，则将 *\\*result* 设为一个新的指向该值的 :term:`strong reference` 并返回 ``1``。"

#: ../../c-api/dict.rst:109
msgid "If the key is missing, set *\\*result* to ``NULL`` and return ``0``."
msgstr "如果不存在该键，则将 *\\*result* 设为 ``NULL`` 并返回 ``0``。"

#: ../../c-api/dict.rst:110 ../../c-api/dict.rst:207
msgid "On error, raise an exception and return ``-1``."
msgstr "发生错误时，将引发异常并返回 ``-1``。"

#: ../../c-api/dict.rst:114
msgid "See also the :c:func:`PyObject_GetItem` function."
msgstr "另请参阅 :c:func:`PyObject_GetItem` 函数。"

#: ../../c-api/dict.rst:119
msgid ""
"Return a :term:`borrowed reference` to the object from dictionary *p* which "
"has a key *key*.  Return ``NULL`` if the key *key* is missing *without* "
"setting an exception."
msgstr ""
"返回一个指向字典 *p* 中对应键 *key* 的对象的 :term:`borrowed reference`。 如果不存在键 *key* 则返回 "
"``NULL`` 且 *不会* 设置异常。"

#: ../../c-api/dict.rst:125
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and "
":meth:`~object.__eq__` methods are silently ignored. Prefer the "
":c:func:`PyDict_GetItemWithError` function instead."
msgstr ""
"在调用 :meth:`~object.__hash__` 和 :meth:`~object.__eq__` 方法时发生的异常将被静默地忽略。 建议改用 "
":c:func:`PyDict_GetItemWithError` 函数。"

#: ../../c-api/dict.rst:129
msgid ""
"Calling this API without an :term:`attached thread state` had been allowed "
"for historical reason. It is no longer allowed."
msgstr ""

#: ../../c-api/dict.rst:136
msgid ""
"Variant of :c:func:`PyDict_GetItem` that does not suppress exceptions. "
"Return ``NULL`` **with** an exception set if an exception occurred.  Return "
"``NULL`` **without** an exception set if the key wasn't present."
msgstr ""
":c:func:`PyDict_GetItem` 的变种，它不会屏蔽异常。 当异常发生时将返回 ``NULL`` **并且** 设置一个异常。 "
"如果键不存在则返回 ``NULL`` **并且不会** 设置一个异常。"

#: ../../c-api/dict.rst:144
msgid ""
"This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"这与 :c:func:`PyDict_GetItem` 一样，但 *key* 是由一个 :c:expr:`const char*` UTF-8 "
"编码的字节串来指定的，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:150
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and "
":meth:`~object.__eq__` methods or while creating the temporary :class:`str` "
"object are silently ignored. Prefer using the "
":c:func:`PyDict_GetItemWithError` function with your own "
":c:func:`PyUnicode_FromString` *key* instead."
msgstr ""
"在调用 :meth:`~object.__hash__` 和 :meth:`~object.__eq__` 方法时或者在创建临时 "
":class:`str` 对象期间发生的异常将被静默地忽略。 建议改用 :c:func:`PyDict_GetItemWithError` "
"函数并附带你自己的 :c:func:`PyUnicode_FromString` *key*。"

#: ../../c-api/dict.rst:159
msgid ""
"Similar to :c:func:`PyDict_GetItemRef`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"类似于 :c:func:`PyDict_GetItemRef`，但 *key* 被指定为一个 :c:expr:`const char*` UTF-8 "
"编码的字节串，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:168
msgid ""
"This is the same as the Python-level :meth:`dict.setdefault`.  If present, "
"it returns the value corresponding to *key* from the dictionary *p*.  If the"
" key is not in the dict, it is inserted with value *defaultobj* and "
"*defaultobj* is returned.  This function evaluates the hash function of "
"*key* only once, instead of evaluating it independently for the lookup and "
"the insertion."
msgstr ""
"这跟Python层面的 :meth:`dict.setdefault` 一样。如果键 *key* 存在，它返回在字典 *p* "
"里面对应的值。如果键不存在，它会和值 *defaultobj* 一起插入并返回 *defaultobj* 。这个函数只计算 *key* "
"的哈希函数一次，而不是在查找和插入时分别计算它。"

#: ../../c-api/dict.rst:179
msgid ""
"Inserts *default_value* into the dictionary *p* with a key of *key* if the "
"key is not already present in the dictionary. If *result* is not ``NULL``, "
"then *\\*result* is set to a :term:`strong reference` to either "
"*default_value*, if the key was not present, or the existing value, if *key*"
" was already present in the dictionary. Returns ``1`` if the key was present"
" and *default_value* was not inserted, or ``0`` if the key was not present "
"and *default_value* was inserted. On failure, returns ``-1``, sets an "
"exception, and sets ``*result`` to ``NULL``."
msgstr ""
"如果键 *key* 在字典 *p* 中尚不存在则将该键和值 *default_value* 插入到该字典中。 如果 *result* 不为 "
"``NULL``，那么当该键不存在时将 *\\*result* 设为指向 *default_value* 的 :term:`strong "
"reference`，或者当 *key* 已存在于该字典中时将其设为原有的值。 如果该键已存在并且未插入 *default_value* 则返回 "
"``1``，或者如果如果该键不存在并且已插入 *default_value* 则返回 ``0``。 当执行失败时，将返回 "
"``-1``，设置一个异常，并将 ``*result`` 设为 ``NULL``。"

#: ../../c-api/dict.rst:189
msgid ""
"For clarity: if you have a strong reference to *default_value* before "
"calling this function, then after it returns, you hold a strong reference to"
" both *default_value* and *\\*result* (if it's not ``NULL``). These may "
"refer to the same object: in that case you hold two separate references to "
"it."
msgstr ""
"澄清一点：如果你在调用此函数前持有指向 *default_value* 的强引用，那么在它返回之后，你将同时持有指向 *default_value* 和"
" *\\*result* (如果它不为 ``NULL``) 的强引用。 两者可能指向同一个对象：在此情况下你将持有两个指向它的单独引用。"

#: ../../c-api/dict.rst:200
msgid ""
"Remove *key* from dictionary *p* and optionally return the removed value. Do"
" not raise :exc:`KeyError` if the key missing."
msgstr "从字典 *p* 中移除 *key* 并可选择返回被移除的值。 当键不存在时不会引发 :exc:`KeyError`。"

#: ../../c-api/dict.rst:203
msgid ""
"If the key is present, set *\\*result* to a new reference to the removed "
"value if *result* is not ``NULL``, and return ``1``."
msgstr "如果键存在，则在 *result* 不为 ``NULL`` 时将 *\\*result* 设为一个新的指向被移除值的引用，并返回 ``1``。"

#: ../../c-api/dict.rst:205
msgid ""
"If the key is missing, set *\\*result* to ``NULL`` if *result* is not "
"``NULL``, and return ``0``."
msgstr "如果不存在该键，则在 *result* 不为 ``NULL`` 时将 *\\*result* 设为 ``NULL``，并返回 ``0``。"

#: ../../c-api/dict.rst:209
msgid ""
"Similar to :meth:`dict.pop`, but without the default value and not raising "
":exc:`KeyError` if the key missing."
msgstr "类似于 :meth:`dict.pop`，但没有默认值并且当键不存在时不会引发 :exc:`KeyError`。"

#: ../../c-api/dict.rst:217
msgid ""
"Similar to :c:func:`PyDict_Pop`, but *key* is specified as a :c:expr:`const "
"char*` UTF-8 encoded bytes string, rather than a :c:expr:`PyObject*`."
msgstr ""
"类似于 :c:func:`PyDict_Pop`，但 *key* 是以一个 :c:expr:`const char*` UTF-8 "
"编码的字节串形式指定的，而不是 :c:expr:`PyObject*`。"

#: ../../c-api/dict.rst:226
msgid ""
"Return a :c:type:`PyListObject` containing all the items from the "
"dictionary."
msgstr "返回一个包含字典中所有键值项的 :c:type:`PyListObject`。"

#: ../../c-api/dict.rst:231
msgid ""
"Return a :c:type:`PyListObject` containing all the keys from the dictionary."
msgstr "返回一个包含字典中所有键(keys)的 :c:type:`PyListObject`。"

#: ../../c-api/dict.rst:236
msgid ""
"Return a :c:type:`PyListObject` containing all the values from the "
"dictionary *p*."
msgstr "返回一个包含字典中所有值(values)的 :c:type:`PyListObject`。"

#: ../../c-api/dict.rst:244
msgid ""
"Return the number of items in the dictionary.  This is equivalent to "
"``len(p)`` on a dictionary."
msgstr "返回字典中项目数，等价于对字典 *p* 使用 ``len(p)``。"

#: ../../c-api/dict.rst:250
msgid ""
"Iterate over all key-value pairs in the dictionary *p*.  The "
":c:type:`Py_ssize_t` referred to by *ppos* must be initialized to ``0`` "
"prior to the first call to this function to start the iteration; the "
"function returns true for each pair in the dictionary, and false once all "
"pairs have been reported.  The parameters *pkey* and *pvalue* should either "
"point to :c:expr:`PyObject*` variables that will be filled in with each key "
"and value, respectively, or may be ``NULL``.  Any references returned "
"through them are borrowed.  *ppos* should not be altered during iteration. "
"Its value represents offsets within the internal dictionary structure, and "
"since the structure is sparse, the offsets are not consecutive."
msgstr ""
"迭代字典 *p* 中的所有键值对。 在第一次调用此函数开始迭代之前，由 *ppos* 所引用的 :c:type:`Py_ssize_t` 必须被初始化为"
" ``0``；该函数将为字典中的每个键值对返回真值，一旦所有键值对都报告完毕则返回假值。 形参 *pkey* 和 *pvalue* 应当指向 "
":c:expr:`PyObject*` 变量，它们将分别使用每个键和值来填充，或者也可以为 ``NULL``。 通过它们返回的任何引用都是暂借的。 "
"*ppos* 在迭代期间不应被更改。 它的值表示内部字典结构中的偏移量，并且由于结构是稀疏的，因此偏移量并不连续。"

#: ../../c-api/dict.rst:261
msgid "For example::"
msgstr "例如："

#: ../../c-api/dict.rst:263
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* 用这些值做些有趣的事... */\n"
"    ...\n"
"}"

#: ../../c-api/dict.rst:271
msgid ""
"The dictionary *p* should not be mutated during iteration.  It is safe to "
"modify the values of the keys as you iterate over the dictionary, but only "
"so long as the set of keys does not change.  For example::"
msgstr "字典 *p* 不应该在遍历期间发生改变。在遍历字典时，改变键中的值是安全的，但仅限于键的集合不发生改变。例如::"

#: ../../c-api/dict.rst:275
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"

#: ../../c-api/dict.rst:293
msgid ""
"The function is not thread-safe in the :term:`free-threaded <free "
"threading>` build without external synchronization.  You can use "
":c:macro:`Py_BEGIN_CRITICAL_SECTION` to lock the dictionary while iterating "
"over it::"
msgstr ""
"此函数在没有外部同步的 :term:`自由线程 <free threading>` 编译版中不是线程安全的。 你可以使用 "
":c:macro:`Py_BEGIN_CRITICAL_SECTION` 在迭代字典时锁定它::"

#: ../../c-api/dict.rst:298
msgid ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../c-api/dict.rst:307
msgid ""
"Iterate over mapping object *b* adding key-value pairs to dictionary *a*. "
"*b* may be a dictionary, or any object supporting :c:func:`PyMapping_Keys` "
"and :c:func:`PyObject_GetItem`. If *override* is true, existing pairs in *a*"
" will be replaced if a matching key is found in *b*, otherwise pairs will "
"only be added if there is not a matching key in *a*. Return ``0`` on success"
" or ``-1`` if an exception was raised."
msgstr ""
"对映射对象 *b* 进行迭代，将键值对添加到字典 *a*。 *b* 可以是一个字典，或任何支持 :c:func:`PyMapping_Keys` 和 "
":c:func:`PyObject_GetItem` 的对象。 如果 *override* 为真值，则如果在 *b* 中找到相同的键则 *a* "
"中已存在的相应键值对将被替换，否则如果在 *a* 中没有相同的键则只是添加键值对。 当成功时返回 ``0`` 或者当引发异常时返回 ``-1``。"

#: ../../c-api/dict.rst:317
msgid ""
"This is the same as ``PyDict_Merge(a, b, 1)`` in C, and is similar to "
"``a.update(b)`` in Python except that :c:func:`PyDict_Update` doesn't fall "
"back to the iterating over a sequence of key value pairs if the second "
"argument has no \"keys\" attribute.  Return ``0`` on success or ``-1`` if an"
" exception was raised."
msgstr ""
"这与 C 中的 ``PyDict_Merge(a, b, 1)`` 一样，也类似于 Python 中的 ``a.update(b)``，差别在于 "
":c:func:`PyDict_Update` 在第二个参数没有 \"keys\" 属性时不会回退到迭代键值对的序列。 当成功时返回 ``0`` "
"或者当引发异常时返回 ``-1``。"

#: ../../c-api/dict.rst:326
msgid ""
"Update or merge into dictionary *a*, from the key-value pairs in *seq2*. "
"*seq2* must be an iterable object producing iterable objects of length 2, "
"viewed as key-value pairs.  In case of duplicate keys, the last wins if "
"*override* is true, else the first wins. Return ``0`` on success or ``-1`` "
"if an exception was raised. Equivalent Python (except for the return "
"value)::"
msgstr ""
"将 *seq2* 中的键值对更新或合并到字典 *a*。 *seq2* 必须为产生长度为 2 的用作键值对的元素的可迭代对象。 当存在重复的键时，如果 "
"*override* 真值则最后出现的键胜出。 当成功时返回 ``0`` 或者当引发异常时返回 ``-1``。 等价的 Python "
"代码（返回值除外）::"

#: ../../c-api/dict.rst:333
msgid ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"
msgstr ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"

#: ../../c-api/dict.rst:340
msgid ""
"Register *callback* as a dictionary watcher. Return a non-negative integer "
"id which must be passed to future calls to :c:func:`PyDict_Watch`. In case "
"of error (e.g. no more watcher IDs available), return ``-1`` and set an "
"exception."
msgstr ""
"在字典上注册 *callback* 来作为 watcher。返回值为非负数的整数 id，作为将来调用 :c:func:`PyDict_Watch` "
"的时候使用。如果出现错误（比如没有足够的可用 watcher ID），返回 ``-1`` 并且设置异常。"

#: ../../c-api/dict.rst:349
msgid ""
"Clear watcher identified by *watcher_id* previously returned from "
":c:func:`PyDict_AddWatcher`. Return ``0`` on success, ``-1`` on error (e.g. "
"if the given *watcher_id* was never registered.)"
msgstr ""
"清空由之前从 :c:func:`PyDict_AddWatcher` 返回的 *watcher_id* 所标识的 watcher。 成功时返回 "
"``0``，出错时（例如当给定的 *watcher_id* 未被注册）返回 ``-1``。"

#: ../../c-api/dict.rst:357
msgid ""
"Mark dictionary *dict* as watched. The callback granted *watcher_id* by "
":c:func:`PyDict_AddWatcher` will be called when *dict* is modified or "
"deallocated. Return ``0`` on success or ``-1`` on error."
msgstr ""
"将字典 *dict* 标记为已被监视。 由 :c:func:`PyDict_AddWatcher` 授权 *watcher_id* 对应的回调将在 "
"*dict* 被修改或释放时被调用。 成功时返回 ``0``，出错时返回 ``-1``。"

#: ../../c-api/dict.rst:365
msgid ""
"Mark dictionary *dict* as no longer watched. The callback granted "
"*watcher_id* by :c:func:`PyDict_AddWatcher` will no longer be called when "
"*dict* is modified or deallocated. The dict must previously have been "
"watched by this watcher. Return ``0`` on success or ``-1`` on error."
msgstr ""
"将字典 *dict* 标记为不再被监视。 由 :c:func:`PyDict_AddWatcher` 授权 *watcher_id* 对应的回调在 "
"*dict* 被修改或释放时将不再被调用。 该字典在此之前必须已被此监视器所监视。 成功时返回 ``0``，出错时返回 ``-1``。"

#: ../../c-api/dict.rst:374
msgid ""
"Enumeration of possible dictionary watcher events: ``PyDict_EVENT_ADDED``, "
"``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED``, or "
"``PyDict_EVENT_DEALLOCATED``."
msgstr ""
"由以下可能的字典监视器事件组成的枚举: ``PyDict_EVENT_ADDED``, ``PyDict_EVENT_MODIFIED``, "
"``PyDict_EVENT_DELETED``, ``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED`` "
"或 ``PyDict_EVENT_DEALLOCATED``。"

#: ../../c-api/dict.rst:382
msgid "Type of a dict watcher callback function."
msgstr "字典监视器回调函数的类型。"

#: ../../c-api/dict.rst:384
msgid ""
"If *event* is ``PyDict_EVENT_CLEARED`` or ``PyDict_EVENT_DEALLOCATED``, both"
" *key* and *new_value* will be ``NULL``. If *event* is "
"``PyDict_EVENT_ADDED`` or ``PyDict_EVENT_MODIFIED``, *new_value* will be the"
" new value for *key*. If *event* is ``PyDict_EVENT_DELETED``, *key* is being"
" deleted from the dictionary and *new_value* will be ``NULL``."
msgstr ""
"如果 *event* 是 ``PyDict_EVENT_CLEARED`` 或 ``PyDict_EVENT_DEALLOCATED``，则 *key*"
" 和 *new_value* 都将为 ``NULL``。 如果 *event* 是 ``PyDict_EVENT_ADDED`` 或 "
"``PyDict_EVENT_MODIFIED``，则 *new_value* 将为 *key* 的新值。 如果 *event* 是 "
"``PyDict_EVENT_DELETED``，则将从字典中删除 *key* 而 *new_value* 将为 ``NULL``。"

#: ../../c-api/dict.rst:390
msgid ""
"``PyDict_EVENT_CLONED`` occurs when *dict* was previously empty and another "
"dict is merged into it. To maintain efficiency of this operation, per-key "
"``PyDict_EVENT_ADDED`` events are not issued in this case; instead a single "
"``PyDict_EVENT_CLONED`` is issued, and *key* will be the source dictionary."
msgstr ""
"``PyDict_EVENT_CLONED`` 会在另一个字典合并到之前为空的 *dict* 时发生。 为保证此操作的效率，该场景不会发出针对单个键的 "
"``PyDict_EVENT_ADDED`` 事件；而是发出单个 ``PyDict_EVENT_CLONED``，而 *key* 将为源字典。"

#: ../../c-api/dict.rst:396
msgid ""
"The callback may inspect but must not modify *dict*; doing so could have "
"unpredictable effects, including infinite recursion. Do not trigger Python "
"code execution in the callback, as it could modify the dict as a side "
"effect."
msgstr ""
"该回调可以检查但不能修改 *dict*；否则会产生不可预料的影响，包括无限递归。 请不要在该回调中触发 Python 代码的执行，因为它可能产生修改 "
"dict 的附带影响。"

#: ../../c-api/dict.rst:400
msgid ""
"If *event* is ``PyDict_EVENT_DEALLOCATED``, taking a new reference in the "
"callback to the about-to-be-destroyed dictionary will resurrect it and "
"prevent it from being freed at this time. When the resurrected object is "
"destroyed later, any watcher callbacks active at that time will be called "
"again."
msgstr ""
"如果 *event* 是 "
"``PyDict_EVENT_DEALLOCATED``，则在回调中接受一个对即将销毁的字典的新引用将使其重生并阻止其在此时被释放。 "
"当重生的对象以后再被销毁时，任何在当时已激活的监视器回调将再次被调用。"

#: ../../c-api/dict.rst:406
msgid ""
"Callbacks occur before the notified modification to *dict* takes place, so "
"the prior state of *dict* can be inspected."
msgstr "回调会在已通知的对 *dict* 的修改完成之前执行，这样在此之前的 *dict* 状态可以被检查。"

#: ../../c-api/dict.rst:409
msgid ""
"If the callback sets an exception, it must return ``-1``; this exception "
"will be printed as an unraisable exception using "
":c:func:`PyErr_WriteUnraisable`. Otherwise it should return ``0``."
msgstr ""
"如果该回调设置了一个异常，则它必须返回 ``-1``；此异常将作为不可引发的异常使用 :c:func:`PyErr_WriteUnraisable` "
"打印出来。 在其他情况下它应当返回 ``0``。"

#: ../../c-api/dict.rst:413
msgid ""
"There may already be a pending exception set on entry to the callback. In "
"this case, the callback should return ``0`` with the same exception still "
"set. This means the callback may not call any other API that can set an "
"exception unless it saves and clears the exception state first, and restores"
" it before returning."
msgstr ""
"在进入回调时可能已经设置了尚未处理的异常。 在此情况下，回调应当返回 ``0`` 并仍然设置同样的异常。 这意味着该回调可能不会调用任何其他可设置异常的"
" API 除非它先保存并清空异常状态，并在返回之前恢复它。"

#: ../../c-api/dict.rst:8
msgid "object"
msgstr "object -- 对象"

#: ../../c-api/dict.rst:8
msgid "dictionary"
msgstr "dictionary -- 字典"

#: ../../c-api/dict.rst:242
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/dict.rst:242
msgid "len"
msgstr "len"
