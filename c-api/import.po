# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 汪心禾 <wangxinhe06@gmail.com>, 2021
# Lordran <xuzhaoyang1990@live.cn>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-31 10:59+0000\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "导入模块"

#: ../../c-api/import.rst:16
msgid ""
"This is a wrapper around :c:func:`PyImport_Import()` which takes a "
":c:expr:`const char *` as an argument instead of a :c:expr:`PyObject *`."
msgstr ""
"这是一个对 :c:func:`PyImport_Import()` 的包装器，它接受一个 :c:expr:`const char *` 作为参数而不是 "
":c:expr:`PyObject *`。"

#: ../../c-api/import.rst:21
msgid ""
"This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "该函数是 :c:func:`PyImport_ImportModule` 的一个被遗弃的别名。"

#: ../../c-api/import.rst:23
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"在导入锁被另一线程掌控时此函数会立即失败。 但是从 Python 3.3 "
"起，锁方案在大多数情况下都已切换为针对每个模块加锁，所以此函数的特殊行为已无必要。"

#: ../../c-api/import.rst:29
msgid "Use :c:func:`PyImport_ImportModule` instead."
msgstr "使用 :c:func:`PyImport_ImportModule` 来代替。"

#: ../../c-api/import.rst:37
msgid ""
"Import a module.  This is best described by referring to the built-in Python"
" function :func:`__import__`."
msgstr "导入一个模块。 请参阅内置 Python 函数 :func:`__import__` 获取完善的相关描述。"

#: ../../c-api/import.rst:40 ../../c-api/import.rst:56
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for "
":func:`__import__`, the return value when a submodule of a package was "
"requested is normally the top-level package, unless a non-empty *fromlist* "
"was given."
msgstr ""
"返回值是一个对所导入模块或最高层级包的新引用，或是在导入失败时则为 ``NULL`` 并设置一个异常。 与 :func:`__import__` "
"类似，当请求一个包的子模块时返回值通常为该最高层级包，除非给出了一个非空的 *fromlist*。"

#: ../../c-api/import.rst:46
msgid ""
"Failing imports remove incomplete module objects, like with "
":c:func:`PyImport_ImportModule`."
msgstr "导入失败将移动不完整的模块对象，就像 :c:func:`PyImport_ImportModule` 那样。"

#: ../../c-api/import.rst:52
msgid ""
"Import a module.  This is best described by referring to the built-in Python"
" function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"导入一个模块。 关于此函数的最佳说明请参考内置 Python 函数 :func:`__import__`，因为标准 :func:`__import__`"
" 函数会直接调用此函数。"

#: ../../c-api/import.rst:66
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"类似于 :c:func:`PyImport_ImportModuleLevelObject`，但其名称为 UTF-8 编码的字符串而不是 Unicode"
" 对象。"

#: ../../c-api/import.rst:69
msgid "Negative values for *level* are no longer accepted."
msgstr "不再接受 *level* 为负数值。"

#: ../../c-api/import.rst:74
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"这是一个调用了当前“导入钩子函数”的更高层级接口（显式指定 *level* 为 0，表示绝对导入）。 它将发起调用当前全局作用域下 "
"``__builtins__`` 中的 :func:`__import__` 函数。 这意味着将使用当前环境下安装的任何导入钩子来完成导入。"

#: ../../c-api/import.rst:80
msgid "This function always uses absolute imports."
msgstr "该函数总是使用绝对路径导入。"

#: ../../c-api/import.rst:85
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL``"
" with an exception set on failure (the module still exists in this case)."
msgstr "重载一个模块。 返回一个指向被重载模块的新引用，或者在失败时返回 ``NULL`` 并设置一个异常（在此情况下模块仍然会存在）。"

#: ../../c-api/import.rst:91
msgid "Return the module object corresponding to a module name."
msgstr "返回对应于模块名称的模块对象。"

#: ../../c-api/import.rst:93
msgid ""
"The *name* argument may be of the form ``package.module``. First check the "
"modules dictionary if there's one there, and if not, create a new one and "
"insert it in the modules dictionary."
msgstr ""
"*name* 参数的形式可以为 ``package.module``。 如果存在 modules 字典则首先检查它，如果不存在，则创建一个新模块并在 "
"modules 字典中插入它。"

#: ../../c-api/import.rst:97
msgid ""
"Return a :term:`strong reference` to the module on success. Return ``NULL`` "
"with an exception set on failure."
msgstr "成功时返回一个指向模块的 :term:`strong reference`。 失败时返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/import.rst:100
msgid "The module name *name* is decoded from UTF-8."
msgstr "模块名称 *name* 将使用 UTF-8 解码。"

#: ../../c-api/import.rst:102
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use "
":c:func:`PyImport_ImportModule` or one of its variants to import a module. "
"Package structures implied by a dotted name for *name* are not created if "
"not already present."
msgstr ""
"此函数不会加载或导入指定模块；如果模块还未被加载，你将得到一个空的模块对象。 请使用 :c:func:`PyImport_ImportModule` "
"或它的某个变体形式来导入模块。 *name* 使用的带点号名称的包结构如果尚不存在则不会被创建。"

#: ../../c-api/import.rst:113
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference` and *name* is a Python :class:`str` object."
msgstr ""
"类似于 :c:func:`PyImport_AddModuleRef`，但会返回一个 :term:`borrowed reference` 并且 "
"*name* 将是一个 Python :class:`str` 对象。"

#: ../../c-api/import.rst:121
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference`."
msgstr ""
"类似于 :c:func:`PyImport_AddModuleRef`，但会返回一个 :term:`borrowed reference`。"

#: ../../c-api/import.rst:129
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :data:`sys.modules` in error cases, even if *name* "
"was already in :data:`sys.modules` on entry to "
":c:func:`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules"
" in :data:`sys.modules` is dangerous, as imports of such modules have no way"
" to know that the module object is an unknown (and probably damaged with "
"respect to the module author's intents) state."
msgstr ""
"给定一个模块名称（可能为 ``package.module`` 形式）和一个从 Python 字节码文件读取或从内置函数 :func:`compile`"
" 获取的代码对象，加载该模块。 返回对该模块对象的新引用，或者如果发生错误则返回 ``NULL`` 并设置一个异常。 在发生错误的情况下 *name* "
"会从 :data:`sys.modules` 中被移除，即使 *name* 在进入 :c:func:`PyImport_ExecCodeModule` "
"时已存在于 :data:`sys.modules` 中。 在 :data:`sys.modules` "
"中保留未完全初始化的模块是危险的，因为导入这样的模块没有办法知识模块对象是否处于一种未知的（对于模块作者的意图来说可能是已损坏的）状态。"

#: ../../c-api/import.rst:139
msgid ""
"The module's :attr:`__spec__` and :attr:`__loader__` will be set, if not set"
" already, with the appropriate values.  The spec's loader will be set to the"
" module's ``__loader__`` (if set) and to an instance of "
":class:`~importlib.machinery.SourceFileLoader` otherwise."
msgstr ""
"模块的 :attr:`__spec__` 和 :attr:`__loader__` 如果尚未设置的话，将被设为适当的值。  相应 spec "
"的加载器（如果已设置）将被设为模块的 ``__loader__`` 而在其他情况下将被设为 "
":class:`~importlib.machinery.SourceFileLoader` 的实例。"

#: ../../c-api/import.rst:144
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's "
":attr:`~codeobject.co_filename`.  If applicable, :attr:`__cached__` will "
"also be set."
msgstr ""
"模块的 :attr:`__file__` 属性将被设为代码对象的 :attr:`~codeobject.co_filename`。 如果适用，还将设置 "
":attr:`__cached__`。"

#: ../../c-api/import.rst:148
msgid ""
"This function will reload the module if it was already imported.  See "
":c:func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr "如果模块已被导入则此函数将重载它。 请参阅 :c:func:`PyImport_ReloadModule` 了解重载模块的预定方式。"

#: ../../c-api/import.rst:151
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr "如果 *name* 指向一个形式为 ``package.module`` 的带点号的名称，则任何尚未创建的包结构仍然不会被创建。"

#: ../../c-api/import.rst:154
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and "
":c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"另请参阅 :c:func:`PyImport_ExecCodeModuleEx` 和 "
":c:func:`PyImport_ExecCodeModuleWithPathnames`。"

#: ../../c-api/import.rst:157
msgid ""
"The setting of :attr:`__cached__` and :attr:`__loader__` is deprecated. See "
":class:`~importlib.machinery.ModuleSpec` for alternatives."
msgstr ""
":attr:`__cached__` 和 :attr:`__loader__` 的设置已被弃用。 替代设置参见 "
":class:`~importlib.machinery.ModuleSpec`。"

#: ../../c-api/import.rst:165
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"类似于 :c:func:`PyImport_ExecCodeModule`，但如果 *pathname* 不为 ``NULL`` 则会被设为模块对象的 "
":attr:`__file__` 属性的值。"

#: ../../c-api/import.rst:168
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "参见 :c:func:`PyImport_ExecCodeModuleWithPathnames`。"

#: ../../c-api/import.rst:173
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``."
"  Of the three functions, this is the preferred one to use."
msgstr ""
"类似于 :c:func:`PyImport_ExecCodeModuleEx`，但如果 *cpathname* 不为 ``NULL`` "
"则会被设为模块对象的 :attr:`__cached__` 值。 在三个函数中，这是推荐使用的一个。"

#: ../../c-api/import.rst:179
msgid ""
"Setting :attr:`__cached__` is deprecated. See "
":class:`~importlib.machinery.ModuleSpec` for alternatives."
msgstr ""
":attr:`__cached__` 的设置已被弃用。 替代设置参见 :class:`~importlib.machinery.ModuleSpec`。"

#: ../../c-api/import.rst:186
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"类似于 :c:func:`PyImport_ExecCodeModuleObject`，但 *name*, *pathname* 和 "
"*cpathname* 为 UTF-8 编码的字符串。如果 *pathname* 也被设为 ``NULL`` 则还会尝试根据 *cpathname* "
"推断出前者的值。"

#: ../../c-api/import.rst:192
msgid ""
"Uses :func:`!imp.source_from_cache` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""

#: ../../c-api/import.rst:195
msgid "No longer uses the removed :mod:`!imp` module."
msgstr "不再使用已移除的 :mod:`!imp` 模块。"

#: ../../c-api/import.rst:201
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"返回 Python 字节码文件（即 :file:`.pyc` 文件）的魔数。 此魔数应当存在于字节码文件的开头四个字节中，按照小端字节序。 出错时返回 "
"``-1``。"

#: ../../c-api/import.rst:205
msgid "Return value of ``-1`` upon failure."
msgstr "失败时返回值 ``-1``。"

#: ../../c-api/import.rst:211
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"针对 :pep:`3147` 格式的 Python 字节码文件名返回魔术标签字符串。 请记住在 "
"``sys.implementation.cache_tag`` 上的值是应当被用来代替此函数的更权威的值。"

#: ../../c-api/import.rst:219
msgid ""
"Return the dictionary used for the module administration (a.k.a. "
"``sys.modules``).  Note that this is a per-interpreter variable."
msgstr "返回用于模块管理的字典 (即 ``sys.modules``)。 请注意这是针对每个解释器的变量。"

#: ../../c-api/import.rst:224
msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr "返回给定名称的已导入模块。 如果模块尚未导入则返回 ``NULL`` 但不会设置错误。 如果查找失败则返回 ``NULL`` 并设置错误。"

#: ../../c-api/import.rst:232
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook"
" is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in "
":data:`sys.path_importer_cache`. Return a new reference to the finder "
"object."
msgstr ""
"返回针对一个 :data:`sys.path`/:attr:`!pkg.__path__` 中条目 *path* 的查找器对象，可能会从 "
":data:`sys.path_importer_cache` 字典中获取。 如果它尚未被缓存，则会遍历 :data:`sys.path_hooks` "
"直至找到一个能处理该路径条目的钩子。 如果没有可用的钩子则返回 ``None``；这将告知调用方 :term:`path based finder` "
"无法为该路径条目找到查找器。 结果将缓存到 :data:`sys.path_importer_cache` 中。 返回一个指向查找器对象的新引用。"

#: ../../c-api/import.rst:243
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use "
":c:func:`PyImport_ImportModule`.  (Note the misnomer --- this function would"
" reload the module if it was already imported.)"
msgstr ""
"加载名称为 *name* 的已冻结模块。 成功时返回 ``1``，如果未找到模块则返回 ``0``，如果初始化失败则返回 ``-1`` 并设置一个异常。"
" 要在加载成功后访问被导入的模块，请使用 :c:func:`PyImport_ImportModule`。 （请注意此名称有误导性 --- "
"如果模块已被导入此函数将重载它。）"

#: ../../c-api/import.rst:251
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "``__file__`` 属性将不再在模块上设置。"

#: ../../c-api/import.rst:257
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"类似于 :c:func:`PyImport_ImportFrozenModuleObject`，但其名称为 UTF-8 编码的字符串而不是 "
"Unicode 对象。"

#: ../../c-api/import.rst:265
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the"
" Python source distribution).  Its definition, found in "
":file:`Include/import.h`, is::"
msgstr ""
"这是针对已冻结模块描述器的结构类型定义，与由 :program:`freeze` 工具所生成的一致 (请参看 Python 源代码发行版中的 "
":file:`Tools/freeze/`)。 其定义可在 :file:`Include/import.h` 中找到::"

#: ../../c-api/import.rst:270
msgid ""
"struct _frozen {\n"
"    const char *name;\n"
"    const unsigned char *code;\n"
"    int size;\n"
"    bool is_package;\n"
"};"
msgstr ""

#: ../../c-api/import.rst:277
msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr "新的 ``is_package`` 字段指明模块是否为一个包。 这替代了将 ``size`` 设为负值的做法。"

#: ../../c-api/import.rst:283
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"该指针被初始化为指向一个 :c:struct:`_frozen` 记录的数组，以一个所有成员均为 ``NULL`` 或零的记录表示结束。 "
"当一个冻结模块被导入时，它将在此表中被搜索。 第三方代码可以利用此方式来提供动态创建的冻结模块集。"

#: ../../c-api/import.rst:291
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called before"
" :c:func:`Py_Initialize`."
msgstr ""
"向现有的内置模块表添加一个模块。 这是对 :c:func:`PyImport_ExtendInittab` 的便捷包装，如果无法扩展表则返回 "
"``-1``。 新的模块可使用名称 *name* 来导入，并使用函数 *initfunc* 作为在第一次尝试导入时调用的初始化函数。 此函数应当在 "
":c:func:`Py_Initialize` 之前调用。"

#: ../../c-api/import.rst:301
msgid ""
"Structure describing a single entry in the list of built-in modules. "
"Programs which embed Python may use an array of these structures in "
"conjunction with :c:func:`PyImport_ExtendInittab` to provide additional "
"built-in modules. The structure consists of two members:"
msgstr ""
"描述内置模块列表中一个单独条目的结构体。 嵌入 Python 的程序可以将这些结构体的数组与 "
":c:func:`PyImport_ExtendInittab` 结合使用以提供额外的内置模块。 该结构体由两个成员组成:"

#: ../../c-api/import.rst:309
msgid "The module name, as an ASCII encoded string."
msgstr "模块名称，为一个 ASCII 编码的字符串。"

#: ../../c-api/import.rst:313
msgid "Initialization function for a module built into the interpreter."
msgstr "针对内置于解释器的模块的初始化函数。"

#: ../../c-api/import.rst:318
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the "
":c:member:`~_inittab.name` field; failure to provide the sentinel value can "
"result in a memory fault. Returns ``0`` on success or ``-1`` if insufficient"
" memory could be allocated to extend the internal table.  In the event of "
"failure, no modules are added to the internal table.  This must be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"向内置模块表添加一组模块。 *newtab* 数组必须以一个包含 ``NULL`` 作为 :c:member:`~_inittab.name` "
"字段的哨兵条目结束；未提供哨兵值可能导致内存错误。 成功时返回 ``0`` 或者如果无法分配足够内存来扩展内部表则返回 ``-1``。 "
"当失败时，将不会向内部表添加任何模块。 该函数必须在 :c:func:`Py_Initialize` 之前调用。"

#: ../../c-api/import.rst:325
msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` or"
" :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"如果 Python 要被多次初始化，则 :c:func:`PyImport_AppendInittab` 或 "
":c:func:`PyImport_ExtendInittab` 必须在每次 Python 初始化之前调用。"

#: ../../c-api/import.rst:11
msgid "package variable"
msgstr "包变量"

#: ../../c-api/import.rst:11
msgid "__all__"
msgstr "__all__"

#: ../../c-api/import.rst:11
msgid "__all__ (package variable)"
msgstr "__all__ (包变量)"

#: ../../c-api/import.rst:11
msgid "modules (in module sys)"
msgstr "modules (在 sys 模块中)"

#: ../../c-api/import.rst:35 ../../c-api/import.rst:127
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/import.rst:35
msgid "__import__"
msgstr "__import__"

#: ../../c-api/import.rst:127
msgid "compile"
msgstr "编译"

#: ../../c-api/import.rst:263
msgid "freeze utility"
msgstr "冻结工具"
