# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# nick <2330458484@qq.com>, 2021
# ruoyu zhang <ruoyu0088@gmail.com>, 2021
# 文博 周 <zhouwenbonwpu@mail.nwpu.edu.cn>, 2021
# WH-2099 <wh2099@outlook.com>, 2021
# Lu <lu2github@gmail.com>, 2022
# ww song <sww4718168@gmail.com>, 2022
# chime z <chimez@163.com>, 2022
# 高乐喆 <gaolezhe@outlook.com>, 2023
# Shan Su, 2023
# ProgramRipper, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# Nyuan Zhang, 2023
# Kevin Deng <kevindeng55+transifex@gmail.com>, 2024
# Wulian233 <xiguawulian@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Object Structures"
msgstr "类型对象结构体"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` structure."
"  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so"
" they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Python 对象系统中最重要的一个结构体也许是定义新类型的结构体: :c:type:`PyTypeObject` 结构体。 类型对象可以使用任何 "
"``PyObject_*`` 或 ``PyType_*`` 函数来处理，但并未提供大多数 Python 应用程序会感兴趣的东西。 "
"这些对象是对象行为的基础，所以它们对解释器本身及任何实现新类型的扩展模块都非常重要。"

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of"
" the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存储了大量的值，大部分是C函数指针，每个指针实现了类型功能的一小部分。本节将详细描述类型对象的字段。这些字段将按照它们在结构中出现的顺序进行描述。"

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of "
":c:type:`PyTypeObject`."
msgstr ""
"除了下面的快速参考， :ref:`typedef-examples` 小节提供了快速了解 :c:type:`PyTypeObject` "
"的含义和用法的例子。"

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "快速参考"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp 槽位\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject 槽位 [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`类型 <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "特殊方法/属性"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "信息 [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:347
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:371
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:376
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:369
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:405
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:441
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:382
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:387
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:351
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:430
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:407
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:413
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:415
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:342 ../../c-api/typeobj.rst:347
#: ../../c-api/typeobj.rst:357 ../../c-api/typeobj.rst:369
#: ../../c-api/typeobj.rst:371 ../../c-api/typeobj.rst:382
#: ../../c-api/typeobj.rst:393 ../../c-api/typeobj.rst:405
#: ../../c-api/typeobj.rst:407 ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:415 ../../c-api/typeobj.rst:417
#: ../../c-api/typeobj.rst:430 ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:436 ../../c-api/typeobj.rst:441
#: ../../c-api/typeobj.rst:447
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:393
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:399
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:363
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:342
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:357
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:349
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:349
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:150
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

#: ../../c-api/typeobj.rst:150
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr "**（）**：括号中的插槽名称表示（实际上）已弃用。"

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr "**<>**: 尖括号内的名称在初始时应设为 ``NULL`` 并被视为是只读的。"

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: 方括号内的名称仅供内部使用。"

#: ../../c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr "**<R>** (作为前缀) 表示字段是必需的 (不能是 ``NULL``)。"

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "列："

#: ../../c-api/typeobj.rst:166
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**:  在 :c:data:`PyBaseObject_Type` 上设置"

#: ../../c-api/typeobj.rst:168
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**:  在 :c:data:`PyType_Type` 上设置"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: 默认设置(如果方法槽被设置为NULL)"

#: ../../c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""
"X - PyType_Ready 如其为 NULL 则设置该值\n"
"~ - PyType_Ready 始终设置该值 (它应当为 NULL)\n"
"? - PyType_Ready 根据其他槽位可能设置该值\n"
"\n"
"另请参阅继承列 (\"I\")。"

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: 继承"

#: ../../c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's description\n"
"? - it's complicated; see the slot's description"
msgstr ""
"X - 如果使用 *NULL* 值定义则类型槽位将通过 *PyType_Ready* 继承\n"
"% - 子结构体的槽位是单独继承的\n"
"G - 已继承，但仅会与其他槽位相结合；参见槽位的说明\n"
"? - 较复杂；参见槽位的说明"

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr "注意，有些方法槽是通过普通属性查找链有效继承的。"

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "子槽位"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "槽位"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "特殊方法"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:436
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:463
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:447
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:452
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid "__buffer__"
msgstr "__buffer__"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:330
msgid "__release_\\ buffer\\__"
msgstr "__release_\\ buffer\\__"

#: ../../c-api/typeobj.rst:337
msgid "slot typedefs"
msgstr "槽位 typedef"

#: ../../c-api/typeobj.rst:340
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:340
msgid "Parameter Types"
msgstr "参数类型"

#: ../../c-api/typeobj.rst:340
msgid "Return Type"
msgstr "返回类型"

#: ../../c-api/typeobj.rst:347 ../../c-api/typeobj.rst:349
#: ../../c-api/typeobj.rst:425
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:351
#: ../../c-api/typeobj.rst:363 ../../c-api/typeobj.rst:376
#: ../../c-api/typeobj.rst:387 ../../c-api/typeobj.rst:399
#: ../../c-api/typeobj.rst:419 ../../c-api/typeobj.rst:430
#: ../../c-api/typeobj.rst:452 ../../c-api/typeobj.rst:458
#: ../../c-api/typeobj.rst:463
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:405
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:419
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:425
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:470
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "请参阅 :ref:`slot-typedefs` 里有更多详细信息。"

#: ../../c-api/typeobj.rst:474
msgid "PyTypeObject Definition"
msgstr "PyTypeObject 定义"

#: ../../c-api/typeobj.rst:476
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in "
":file:`Include/cpython/object.h`.  For convenience of reference, this "
"repeats the definition found there:"
msgstr ""
"针对 :c:type:`PyTypeObject` 的结构定义可以在 :file:`Include/cpython/object.h` 中找到。 "
"为了方便参考，这里复述了其中的定义："

#: ../../c-api/typeobj.rst:482
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache; /* no longer used */\n"
"    void *tp_subclasses;  /* for static builtin types this is an index */\n"
"    PyObject *tp_weaklist; /* not used for static builtin types */\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6.\n"
"     * If zero, the cache is invalid and must be initialized.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* Number of tp_version_tag values used.\n"
"     * Set to _Py_ATTR_CACHE_UNUSED if the attribute cache is\n"
"     * disabled for this type (e.g. due to custom MRO entries).\n"
"     * Otherwise, limited to MAX_VERSIONS_PER_CLASS (defined elsewhere).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"
msgstr ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* 用于打印，格式为 \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* 用于分配 */\n"
"\n"
"    /* 用于实现标准操作的方法 */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* 原名为 tp_compare (Python 2)\n"
"                                    或 tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* 用于标准类的方法集 */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* 更多标准操作 (这些用于二进制兼容) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* 用于以输入/输出缓冲区方式访问对象的函数 */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* 用于定义可选/扩展特性是否存在的旗标 */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* 文档字符串 */\n"
"\n"
"    /* 在 2.0 发布版中分配的含义 */\n"
"    /* 为所有可访问的对象调用函数 */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* 删除对所包含对象的引用 */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* 在 2.1 发布版中分配的含义 */\n"
"    /* 富比较操作 */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* 启用弱引用 */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* 迭代器 */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* 属性描述器和子类化内容 */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // 堆类型的强引用，静态类型的借入引用\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* 层级的释放内存例程 */\n"
"    inquiry tp_is_gc; /* 用于 PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* 方法解析顺序 */\n"
"    PyObject *tp_cache; /* 不再被使用 */\n"
"    void *tp_subclasses;  /* 对于静态内置类型这将是一个索引 */\n"
"    PyObject *tp_weaklist; /* 不被用于静态内置类型 */\n"
"    destructor tp_del;\n"
"\n"
"    /* 类型属性缓存版本标签。 在 2.6 版中添加。\n"
"     * 如果为零，则缓存无效并且必须被初始化。\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* 类型监视器针对此类型的位设置 */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* 使用的 tp_version_tag 值数量。\n"
"     * 如果针对此类型的属性缓存被禁用则设为 _Py_ATTR_CACHE_UNUSED\n"
"     * （例如由于自定义的 MRO 条目而被禁用）。\n"
"     * 在其他情况下，将被限制为 MAX_VERSIONS_PER_CLASS (在其他地方定义)。\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"

#: ../../c-api/typeobj.rst:486
msgid "PyObject Slots"
msgstr "PyObject 槽位"

#: ../../c-api/typeobj.rst:488
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The "
":c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by"
" :c:func:`!type_new`, usually called from a class statement). Note that "
":c:data:`PyType_Type` (the metatype) initializes "
":c:member:`~PyTypeObject.tp_itemsize`, which means that its instances (i.e. "
"type objects) *must* have the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"类型对象结构体扩展了 :c:type:`PyVarObject` 结构体。 :c:member:`~PyVarObject.ob_size` "
"字段用于动态类型（由 :c:func:`!type_new` 创建，通常由 class 语句调用）。 请注意 :c:data:`PyType_Type`"
" （元类型）会初始化 :c:member:`~PyTypeObject.tp_itemsize`，这意味着它的实例（即类型对象） *必须* 具有 "
":c:member:`~PyVarObject.ob_size` 字段。"

#: ../../c-api/typeobj.rst:495
msgid ":c:member:`PyObject.ob_refcnt`"
msgstr ":c:member:`PyObject.ob_refcnt`"

#: ../../c-api/typeobj.rst:497
msgid ""
"The type object's reference count is initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type"
" objects <static-types>`, the type's instances (objects whose "
":c:member:`~PyObject.ob_type` points back to the type) do *not* count as "
"references.  But for :ref:`dynamically allocated type objects <heap-types>`,"
" the instances *do* count as references."
msgstr ""
"类型对象的引用计数由 ``PyObject_HEAD_INIT`` 宏初始化为 ``1``。请注意，对于 :ref:`静态分配的类型对象 "
"<static-types>`，该类型的实例（其 :c:member:`~PyObject.ob_type` 指回类型的对象）*不* 计为引用。但对于 "
":ref:`动态分配的类型对象 <heap-types>`，实例 *确实* 计为引用。"

#: ../../c-api/typeobj.rst:504 ../../c-api/typeobj.rst:527
#: ../../c-api/typeobj.rst:543 ../../c-api/typeobj.rst:587
#: ../../c-api/typeobj.rst:665 ../../c-api/typeobj.rst:807
#: ../../c-api/typeobj.rst:852 ../../c-api/typeobj.rst:869
#: ../../c-api/typeobj.rst:886 ../../c-api/typeobj.rst:904
#: ../../c-api/typeobj.rst:928 ../../c-api/typeobj.rst:945
#: ../../c-api/typeobj.rst:957 ../../c-api/typeobj.rst:969
#: ../../c-api/typeobj.rst:1002 ../../c-api/typeobj.rst:1024
#: ../../c-api/typeobj.rst:1044 ../../c-api/typeobj.rst:1065
#: ../../c-api/typeobj.rst:1091 ../../c-api/typeobj.rst:1110
#: ../../c-api/typeobj.rst:1126 ../../c-api/typeobj.rst:1166
#: ../../c-api/typeobj.rst:1177 ../../c-api/typeobj.rst:1187
#: ../../c-api/typeobj.rst:1197 ../../c-api/typeobj.rst:1211
#: ../../c-api/typeobj.rst:1229 ../../c-api/typeobj.rst:1252
#: ../../c-api/typeobj.rst:1270 ../../c-api/typeobj.rst:1283
#: ../../c-api/typeobj.rst:1305 ../../c-api/typeobj.rst:1349
#: ../../c-api/typeobj.rst:1370 ../../c-api/typeobj.rst:1389
#: ../../c-api/typeobj.rst:1419 ../../c-api/typeobj.rst:1441
#: ../../c-api/typeobj.rst:1467 ../../c-api/typeobj.rst:1558
#: ../../c-api/typeobj.rst:1702 ../../c-api/typeobj.rst:1767
#: ../../c-api/typeobj.rst:1803 ../../c-api/typeobj.rst:1828
#: ../../c-api/typeobj.rst:1851 ../../c-api/typeobj.rst:1864
#: ../../c-api/typeobj.rst:1879 ../../c-api/typeobj.rst:1893
#: ../../c-api/typeobj.rst:1923 ../../c-api/typeobj.rst:1955
#: ../../c-api/typeobj.rst:1981 ../../c-api/typeobj.rst:1999
#: ../../c-api/typeobj.rst:2028 ../../c-api/typeobj.rst:2072
#: ../../c-api/typeobj.rst:2089 ../../c-api/typeobj.rst:2129
#: ../../c-api/typeobj.rst:2152 ../../c-api/typeobj.rst:2190
#: ../../c-api/typeobj.rst:2218 ../../c-api/typeobj.rst:2231
#: ../../c-api/typeobj.rst:2241 ../../c-api/typeobj.rst:2258
#: ../../c-api/typeobj.rst:2275 ../../c-api/typeobj.rst:2289
#: ../../c-api/typeobj.rst:2431 ../../c-api/typeobj.rst:2489
msgid "**Inheritance:**"
msgstr "**继承：**"

#: ../../c-api/typeobj.rst:506 ../../c-api/typeobj.rst:545
#: ../../c-api/typeobj.rst:589
msgid "This field is not inherited by subtypes."
msgstr "子类型不继承此字段。"

#: ../../c-api/typeobj.rst:509
msgid ":c:member:`PyObject.ob_type`"
msgstr ":c:member:`PyObject.ob_type`"

#: ../../c-api/typeobj.rst:511
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"这是类型的类型，换句话说就是元类型，它由宏 ``PyObject_HEAD_INIT`` 的参数来做初始化，它的值一般情况下是 "
"``&PyType_Type`` 。可是为了使动态可载入扩展模块至少在Windows上可用，编译器会报错这是一个不可用的初始化。因此按照惯例传递 "
"``NULL`` 给宏 ``PyObject_HEAD_INIT`` 并且在模块的初始化函数开始时候其他任何操作之前初始化这个字段。典型做法是这样的："

#: ../../c-api/typeobj.rst:520
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr "Foo_Type.ob_type = &PyType_Type;"

#: ../../c-api/typeobj.rst:522
msgid ""
"This should be done before any instances of the type are created. "
":c:func:`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, "
"and if so, initializes it to the :c:member:`~PyObject.ob_type` field of the "
"base class. :c:func:`PyType_Ready` will not change this field if it is non-"
"zero."
msgstr ""
"这应当在创建类型的任何实例之前完成。 :c:func:`PyType_Ready` 会检查 :c:member:`~PyObject.ob_type` "
"是否为 ``NULL``，如果是，则将其初始化为基类的 :c:member:`~PyObject.ob_type` 字段。 如果该字段为非零值则 "
":c:func:`PyType_Ready` 将不会更改它。"

#: ../../c-api/typeobj.rst:529 ../../c-api/typeobj.rst:809
#: ../../c-api/typeobj.rst:930 ../../c-api/typeobj.rst:1026
#: ../../c-api/typeobj.rst:1046 ../../c-api/typeobj.rst:1830
#: ../../c-api/typeobj.rst:1853 ../../c-api/typeobj.rst:1983
#: ../../c-api/typeobj.rst:2001 ../../c-api/typeobj.rst:2074
#: ../../c-api/typeobj.rst:2192 ../../c-api/typeobj.rst:2433
msgid "This field is inherited by subtypes."
msgstr "此字段会被子类型继承。"

#: ../../c-api/typeobj.rst:533
msgid "PyVarObject Slots"
msgstr "PyVarObject 槽位"

#: ../../c-api/typeobj.rst:535
msgid ":c:member:`PyVarObject.ob_size`"
msgstr ":c:member:`PyVarObject.ob_size`"

#: ../../c-api/typeobj.rst:537
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"对于 :ref:`静态分配的内存对象<static-types>`，它应该初始化为 0。对于 :ref:`动态分配的类型对象<heap-"
"types>`，该字段具有特殊的内部含义。"

#: ../../c-api/typeobj.rst:541
msgid "This field should be accessed using the :c:func:`Py_SIZE()` macro."
msgstr "应使用 :c:func:`Py_SIZE()` 宏来访问此字段。"

#: ../../c-api/typeobj.rst:549
msgid "PyTypeObject Slots"
msgstr "PyTypeObject 槽"

#: ../../c-api/typeobj.rst:551
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on "
":c:data:`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as "
"defaults.)"
msgstr ""
"每个槽位都有一个小节来描述继承关系。 如果 :c:func:`PyType_Ready` 可以在字段被设为 ``NULL`` "
"时设置一个值那么还会有一个“默认”小节。 （请注意在 :c:data:`PyBaseObject_Type` 和 "
":c:data:`PyType_Type` 上设置的许多字段实际上就是默认值。）"

#: ../../c-api/typeobj.rst:558
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage "
":mod:`!Q` in package :mod:`!P` should have the "
":c:member:`~PyTypeObject.tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"指向包含类型名称的以 NUL 结尾的字符串的指针。 "
"对于可作为模块全局访问的类型，该字符串应为模块全名，后面跟一个点号，然后再加类型名称；对于内置类型，它应当只是类型名称。 "
"如果模块是包的子模块，则包的全名将是模块的全名的一部分。 例如，在包 :mod:`!P` 的子包 :mod:`!Q` 中的模块 :mod:`!M` "
"中定义的名为 :class:`!T` 的类型应当具有 :c:member:`~PyTypeObject.tp_name` 初始化器 "
"``\"P.Q.M.T\"``。"

#: ../../c-api/typeobj.rst:566
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just"
" be the type name, and the module name explicitly stored in the type dict as"
" the value for key ``'__module__'``."
msgstr ""
"对于 :ref:`动态分配的类型对象 <heap-types>`，这应为类型名称，而模块名称将作为 ``'__module__'`` "
"键的值显式地保存在类型字典中。"

#: ../../c-api/typeobj.rst:571
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"对于 :ref:`静态分配的类型对象 <static-types>`，*tp_name* 字段应当包含一个点号。 最后一个点号之前的所有内容都可作为 "
":attr:`~type.__module__` 属性访问，而最后一个点号之后的所有内容都可作为 :attr:`~type.__name__` "
"属性访问。"

#: ../../c-api/typeobj.rst:577
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and the "
":attr:`~type.__module__` attribute is undefined (unless explicitly set in "
"the dictionary, as explained above).  This means your type will be "
"impossible to pickle.  Additionally, it will not be listed in module "
"documentations created with pydoc."
msgstr ""
"如果不存在点号，则整个 :c:member:`~PyTypeObject.tp_name` 字段将作为 :attr:`~type.__name__` "
"属性访问，而 :attr:`~type.__module__` 属性则将是未定义的（除非在字典中显式地设置，如上文所述）。 这意味着无法对你的类型执行 "
"pickle。 此外，它也不会在用 pydoc 创建的模块文档中列出。"

#: ../../c-api/typeobj.rst:583
msgid ""
"This field must not be ``NULL``.  It is the only required field in "
":c:func:`PyTypeObject` (other than potentially "
":c:member:`~PyTypeObject.tp_itemsize`)."
msgstr ""
"该字段不可为 ``NULL``。 它是 :c:func:`PyTypeObject` 中唯一的必填字段（除了潜在的 "
":c:member:`~PyTypeObject.tp_itemsize` 以外）。"

#: ../../c-api/typeobj.rst:595
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr "通过这些字段可以计算出该类型实例以字节为单位的大小。"

#: ../../c-api/typeobj.rst:597
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero "
":c:member:`!tp_itemsize` field, types with variable-length instances have a "
"non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-length "
"instances, all instances have the same size, given in "
":c:member:`!tp_basicsize`. (Exceptions to this rule can be made using "
":c:func:`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"类型可分为两种：实例为固定长度且 :c:member:`!tp_itemsize` 字段值为零的类型；实例为可变长度且 "
":c:member:`!tp_itemsize` 字段值不为零的类型。 对于实例为固定长度的类型，所有实例都具有相同的由 "
":c:member:`!tp_basicsize` 给出的大小。 （这条规则的例外情况可通过使用 "
":c:func:`PyUnstable_Object_GC_NewWithExtraData` 来实现。）"

#: ../../c-api/typeobj.rst:604
msgid ""
"For a type with variable-length instances, the instances must have an "
":c:member:`~PyVarObject.ob_size` field, and the instance size is "
":c:member:`!tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N is "
"the \"length\" of the object."
msgstr ""
"对于实例为可变长度的类型，其实例必须具有 :c:member:`~PyVarObject.ob_size` 字段，且实例大小为 "
":c:member:`!tp_basicsize` 加 N 乘以 :c:member:`!tp_itemsize`，其中 N 为对象的“长度”。"

#: ../../c-api/typeobj.rst:609
msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the bits "
"of :c:member:`~PyVarObject.ob_size` in an implementation-defined way; the "
"underlying storage and its size should be accessed using "
":c:func:`PyLong_Export`."
msgstr ""
"像 :c:func:`PyObject_NewVar` 这样的函数接受 N 值作为参数，并会将其保存在实例的 "
":c:member:`~PyVarObject.ob_size` 字段中。 请注意 :c:member:`~PyVarObject.ob_size` "
"字段在此之后可能还有其他用处。 例如，:py:type:`int` 实例会以具体实现所定义的方式来使用 "
":c:member:`~PyVarObject.ob_size` 的比特位；下层的存储及其大小应当使用 :c:func:`PyLong_Export` "
"来访问。"

#: ../../c-api/typeobj.rst:619
msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the "
":c:func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""
":c:member:`~PyVarObject.ob_size` 字段应当使用 :c:func:`Py_SIZE()` 和 "
":c:func:`Py_SET_SIZE()` 宏来访问。"

#: ../../c-api/typeobj.rst:622
msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-length."
" For example, the :py:type:`list` type has fixed-length instances, yet those"
" instances have a :c:member:`~PyVarObject.ob_size` field. (As with "
":py:type:`int`, avoid reading lists' :c:member:`!ob_size` directly. Call "
":c:func:`PyList_Size` instead.)"
msgstr ""
"此外，实例布局中存在 :c:member:`~PyVarObject.ob_size` 字段并不意味着该实例结构体是可变长度的。 "
"例如，:py:type:`list` 类型实例即为固定长度，虽然其实例具有 :c:member:`~PyVarObject.ob_size` 字段。 "
"（和 :py:type:`int` 一样，请避免直接读取 list 的 :c:member:`!ob_size`。 要改为调用 "
":c:func:`PyList_Size` 函数。）"

#: ../../c-api/typeobj.rst:629
msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's "
":c:member:`~PyTypeObject.tp_base`, plus any extra data needed by each "
"instance."
msgstr ""
":c:member:`!tp_basicsize` 包括类型的 :c:member:`~PyTypeObject.tp_base` "
"所需数据大小，加上每个实例所需额外数据的大小。"

#: ../../c-api/typeobj.rst:633
msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the ``sizeof`` "
"operator on the struct used to declare the instance layout. This struct must"
" include the struct used to declare the base type. In other words, "
":c:member:`!tp_basicsize` must be greater than or equal to the base's "
":c:member:`!tp_basicsize`."
msgstr ""
"设置 :c:member:`!tp_basicsize` 的正确方式是在被用于声明实例布局的结构体上使用 ``sizeof`` 运算符。 "
"这个结构体必须包括被用于声明基类型的结构体。 换句话说，:c:member:`!tp_basicsize` 必须大于等于基类型的 "
":c:member:`!tp_basicsize`。"

#: ../../c-api/typeobj.rst:639
msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must include"
" :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether "
":c:member:`~PyVarObject.ob_size` should be included). These are usually "
"defined by the macro :c:macro:`PyObject_HEAD` or "
":c:macro:`PyObject_VAR_HEAD`, respectively."
msgstr ""
"由于任何类型都是 :py:type:`object` 的子类型，这个结构体必须包括 :c:type:`PyObject` 或 "
":c:type:`PyVarObject` (具体取决于 :c:member:`~PyVarObject.ob_size` 是否应当被包括)。 "
"它们通常是分别由 :c:macro:`PyObject_HEAD` 或 :c:macro:`PyObject_VAR_HEAD` 宏来定义的。"

#: ../../c-api/typeobj.rst:645
msgid ""
"The basic size does not include the GC header size, as that header is not "
"part of :c:macro:`PyObject_HEAD`."
msgstr "基础大小不包括 GC 标头大小，因为该标头不是 :c:macro:`PyObject_HEAD` 的一部分。"

#: ../../c-api/typeobj.rst:648
msgid ""
"For cases where struct used to declare the base type is unknown, see "
":c:member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""
"对于用于声明基类型的结构体位置未知的情况，请参见 :c:member:`PyType_Spec.basicsize` 和 "
":c:func:`PyType_FromMetaclass`。"

#: ../../c-api/typeobj.rst:651
msgid "Notes about alignment:"
msgstr "有关对齐的说明："

#: ../../c-api/typeobj.rst:653
msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. When"
" using ``sizeof`` on a ``struct`` that includes :c:macro:`PyObject_HEAD`, as"
" recommended, the compiler ensures this. When not using a C ``struct``, or "
"when using compiler extensions like ``__attribute__((packed))``, it is up to"
" you."
msgstr ""
":c:member:`!tp_basicsize` 必须是 ``_Alignof(PyObject)`` 的位数。 当如建议的那样在包括了 "
":c:macro:`PyObject_HEAD` 的 ``struct`` 上使用 ``sizeof`` 时，编译器会确保这一点。 当没有使用 C "
"``struct``，或者当使用像 ``__attribute__((packed))`` 这样的编译器扩展时，这将是你的责任。"

#: ../../c-api/typeobj.rst:658
msgid ""
"If the variable items require a particular alignment, "
":c:member:`!tp_basicsize` and :c:member:`!tp_itemsize` must each be a "
"multiple of that alignment. For example, if a type's variable part stores a "
"``double``, it is your responsibility that both fields are a multiple of "
"``_Alignof(double)``."
msgstr ""
"如果可变条目需要特定的对齐，则 :c:member:`!tp_basicsize` 和 :c:member:`!tp_itemsize` "
"必须均为该对齐值的倍数。 举例来说，如果一个类型的可变部分存储了一个 ``double``，你就要负责让这两个字段都是 "
"``_Alignof(double)`` 的倍数。"

#: ../../c-api/typeobj.rst:667
msgid ""
"These fields are inherited separately by subtypes. (That is, if the field is"
" set to zero, :c:func:`PyType_Ready` will copy the value from the base type,"
" indicating that the instances do not need additional storage.)"
msgstr ""
"这些字段是由子类型分别来继承的。 （也就是说，如果字段被设为零，则 :c:func:`PyType_Ready` "
"将拷贝来自基类型的值，这表示实例不需要额外的存储。）"

#: ../../c-api/typeobj.rst:672
msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is"
" generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"如果基类型有一个非零的 :c:member:`~PyTypeObject.tp_itemsize`，那么在子类型中将 "
":c:member:`~PyTypeObject.tp_itemsize` 设置为不同的非零值通常是不安全的（不过这取决于该基类型的具体实现）。"

#: ../../c-api/typeobj.rst:679
msgid ""
"A pointer to the instance destructor function.  The function signature is::"
msgstr "一个指向实例析构函数的指针。 函数的签名为::"

#: ../../c-api/typeobj.rst:681
msgid "void tp_dealloc(PyObject *self);"
msgstr "void tp_dealloc(PyObject *self);"

#: ../../c-api/typeobj.rst:683
msgid ""
"The destructor function should remove all references which the instance owns"
" (e.g., call :c:func:`Py_CLEAR`), free all memory buffers owned by the "
"instance, and call the type's :c:member:`~PyTypeObject.tp_free` function to "
"free the object itself."
msgstr ""
"析构函数应移除该实例所拥有的所有引用（例如，调用 :c:func:`Py_CLEAR`），释放该实例所拥有的所有内存缓冲区，并调用该类型的 "
":c:member:`~PyTypeObject.tp_free` 函数来释放对象本身。"

#: ../../c-api/typeobj.rst:688
msgid ""
"If you may call functions that may set the error indicator, you must use "
":c:func:`PyErr_GetRaisedException` and :c:func:`PyErr_SetRaisedException` to"
" ensure you don't clobber a preexisting error indicator (the deallocation "
"could have occurred while processing a different error):"
msgstr ""
"如果您可能会调用那些可能设置错误指示器的函数，则必须使用 :c:func:`PyErr_GetRaisedException` 和 "
":c:func:`PyErr_SetRaisedException`，以确保不会破坏已存在的错误指示器（在处理另一个错误的过程中，可能已发生了内存释放）："

#: ../../c-api/typeobj.rst:693
msgid ""
"static void\n"
"foo_dealloc(foo_object *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(foo_object *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:704
msgid ""
"The dealloc handler itself must not raise an exception; if it hits an error "
"case it should call :c:func:`PyErr_FormatUnraisable` to log (and clear) an "
"unraisable exception."
msgstr ""
"释放处理程序本身不应引发异常；若遇到错误情况，应调用 :c:func:`PyErr_FormatUnraisable` 记录（并清除）不可抛出的异常。"

#: ../../c-api/typeobj.rst:708
msgid "No guarantees are made about when an object is destroyed, except:"
msgstr "关于对象何时被销毁，不做任何保证，除非："

#: ../../c-api/typeobj.rst:710
msgid ""
"Python will destroy an object immediately or some time after the final "
"reference to the object is deleted, unless its finalizer "
"(:c:member:`~PyTypeObject.tp_finalize`) subsequently resurrects the object."
msgstr ""
"Python "
"会在对象的最后一个引用被删除后立即销毁该对象，或者在一段时间后再销毁，除非其终结器（:c:member:`~PyTypeObject.tp_finalize`）在此期间重新激活了该对象。"

#: ../../c-api/typeobj.rst:714
msgid ""
"An object will not be destroyed while it is being automatically finalized "
"(:c:member:`~PyTypeObject.tp_finalize`) or automatically cleared "
"(:c:member:`~PyTypeObject.tp_clear`)."
msgstr ""
"在对象被自动终结（:c:member:`~PyTypeObject.tp_finalize`）或自动清理（:c:member:`~PyTypeObject.tp_clear`）的过程中，不会销毁该对象。"

#: ../../c-api/typeobj.rst:718
msgid ""
"CPython currently destroys an object immediately from :c:func:`Py_DECREF` "
"when the new reference count is zero, but this may change in a future "
"version."
msgstr "当前 CPython 在引用计数归零时，会立即通过 :c:func:`Py_DECREF` 销毁对象，但这一行为在未来版本中可能会改变。"

#: ../../c-api/typeobj.rst:722
msgid ""
"It is recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the"
" beginning of :c:member:`!tp_dealloc` to guarantee that the object is always"
" finalized before destruction."
msgstr ""
"建议在 :c:member:`!tp_dealloc` 的开头调用 "
":c:func:`PyObject_CallFinalizerFromDealloc` 以确保对象在销毁前始终被终结。"

#: ../../c-api/typeobj.rst:726
msgid ""
"If the type supports garbage collection (the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag is set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"若该类型支持垃圾回收（即设置了 :c:macro:`Py_TPFLAGS_HAVE_GC` 标志），则析构函数应在清理任何成员字段之前调用 "
":c:func:`PyObject_GC_UnTrack`。"

#: ../../c-api/typeobj.rst:730
msgid ""
"It is permissible to call :c:member:`~PyTypeObject.tp_clear` from "
":c:member:`!tp_dealloc` to reduce code duplication and to guarantee that the"
" object is always cleared before destruction.  Beware that "
":c:member:`!tp_clear` might have already been called."
msgstr ""
"允许从 :c:member:`!tp_dealloc` 方法中调用 "
":c:member:`~PyTypeObject.tp_clear`，以减少代码重复并确保对象在销毁前始终被清理。但需注意，:c:member:`!tp_clear`"
" 可能已被提前调用。"

#: ../../c-api/typeobj.rst:735
msgid ""
"If the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via "
":c:func:`Py_DECREF`) after calling the type deallocator.  See the example "
"code below.::"
msgstr ""
"如果该类型是堆分配的（:c:macro:`Py_TPFLAGS_HEAPTYPE`），则释放器应在调用类型释放器之后，释放对其类型对象的自有引用（通过 "
":c:func:`Py_DECREF`）。参见下面的示例代码。::"

#: ../../c-api/typeobj.rst:740
msgid ""
"static void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(self->ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(self->ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"

#: ../../c-api/typeobj.rst:749
msgid ""
":c:member:`!tp_dealloc` must leave the exception status unchanged.  If it "
"needs to call something that might raise an exception, the exception state "
"must be backed up first and restored later (after logging any exceptions "
"with :c:func:`PyErr_WriteUnraisable`)."
msgstr ""
":c:member:`!tp_dealloc` 必须保持异常状态不变。如果它需要调用可能引发异常的函数，必须先备份异常状态，之后（在用 "
":c:func:`PyErr_WriteUnraisable` 记录任何异常后）再恢复该状态。"

#: ../../c-api/typeobj.rst:754
msgid "Example::"
msgstr "示例："

#: ../../c-api/typeobj.rst:756
msgid ""
"static void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // self was resurrected.\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // Optional, but convenient to avoid code duplication.\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // Any additional destruction goes here.\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL;  // In case PyErr_WriteUnraisable() is called below.\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // Optional, if something was called that might have raised an\n"
"    // exception.\n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // 自我复活了。\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // 可选，但可以避免代码重复，较为方便。\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // 此处可执行任何额外的销毁操作。\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL;  // 若后续调用了 PyErr_WriteUnraisable() 函数。\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // 可选操作：若之前调用的操作可能引发了异常。\n"
"    //  \n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:795
msgid ""
":c:member:`!tp_dealloc` may be called from any Python thread, not just the "
"thread which created the object (if the object becomes part of a refcount "
"cycle, that cycle might be collected by a garbage collection on any thread)."
"  This is not a problem for Python API calls, since the thread on which "
":c:member:`!tp_dealloc` is called with an :term:`attached thread state`.  "
"However, if the object being destroyed in turn destroys objects from some "
"other C library, care should be taken to ensure that destroying those "
"objects on the thread which called :c:member:`!tp_dealloc` will not violate "
"any assumptions of the library."
msgstr ""
":c:member:`!tp_dealloc` 可能从任意 Python "
"线程调用，而不仅限于创建该对象的线程（如果对象成为引用循环的一部分，该循环可能由任意线程的垃圾回收操作回收）。 这对 Python API "
"调用不是问题，因为调用 :c:member:`!tp_dealloc` 的线程会带有 :term:`attached thread "
"state`。然而，如果被销毁的对象反过来会销毁其他 C 库中的对象，则需要确保在调用 :c:member:`!tp_dealloc` "
"的线程上销毁这些对象不会违反该库的任何假设条件。"

#: ../../c-api/typeobj.rst:813 ../../c-api/typeobj.rst:1713
#: ../../c-api/typeobj.rst:2446
msgid ""
":ref:`life-cycle` for details about how this slot relates to other slots."
msgstr "有关此槽位如何与其他槽位关联的详细信息，请参阅 :ref:`life-cycle`。"

#: ../../c-api/typeobj.rst:818
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"一个相对使用 :ref:`vectorcall 协议 <vectorcall>` 实现调用对象的实例级函数的可选的偏移量，这是一种比简单的 "
":c:member:`~PyTypeObject.tp_call` 更有效的替代选择。"

#: ../../c-api/typeobj.rst:823
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is"
" set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"该字段仅在设置了 :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` 旗标时使用。 在此情况下，它必须为一个包含 "
":c:type:`vectorcallfunc` 指针实例中的偏移量的正整数。"

#: ../../c-api/typeobj.rst:827
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the"
" instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"*vectorcallfunc* 指针可能为 ``NULL``，在这种情况下实例的行为就像 "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` 没有被设置一样：调用实例操作会回退至 "
":c:member:`~PyTypeObject.tp_call`。"

#: ../../c-api/typeobj.rst:831
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set "
":c:member:`~PyTypeObject.tp_call` and make sure its behaviour is consistent "
"with the *vectorcallfunc* function. This can be done by setting *tp_call* to"
" :c:func:`PyVectorcall_Call`."
msgstr ""
"任何设置了 ``Py_TPFLAGS_HAVE_VECTORCALL`` 的类也必须设置 "
":c:member:`~PyTypeObject.tp_call` 并确保其行为与 *vectorcallfunc* 函数一致。 这可以通过将 "
"*tp_call* 设为 :c:func:`PyVectorcall_Call` 来实现。"

#: ../../c-api/typeobj.rst:838
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"在 3.8 版之前，这个槽位被命名为 ``tp_print``。 在 Python 2.x 中，它被用于打印到文件。 在 Python 3.0 至 "
"3.7 中，它没有被使用。"

#: ../../c-api/typeobj.rst:844
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets "
":attr:`~object.__call__` in Python code, only *tp_call* is updated, likely "
"making it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"在 3.12 版之前，不推荐 :ref:`可变堆类型 <heap-types>` 实现 vectorcall 协议。 当用户在 Python 代码中设置"
" :attr:`~object.__call__` 时，只有 *tp_call* 会被更新，很可能使它与 vectorcall 函数不一致。 自 "
"3.12 起，设置 ``__call__`` 将通过清除 :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` 旗标来禁用 "
"vectorcall 优化。"

#: ../../c-api/typeobj.rst:854
msgid ""
"This field is always inherited. However, the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's "
"not set, then the subclass won't use :ref:`vectorcall <vectorcall>`, except "
"when :c:func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"该字段总是会被继承。 但是，:c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` 旗标并不总是会被继承。 "
"如果它未被设置，则子类不会使用 :ref:`vectorcall <vectorcall>`，除非显式地调用了 "
":c:func:`PyVectorcall_Call`。"

#: ../../c-api/typeobj.rst:863
msgid "An optional pointer to the get-attribute-string function."
msgstr "一个指向获取属性字符串函数的可选指针。"

#: ../../c-api/typeobj.rst:865
msgid ""
"This field is deprecated.  When it is defined, it should point to a function"
" that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"该字段已弃用。当它被定义时，应该和 :c:member:`~PyTypeObject.tp_getattro` "
"指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。"

#: ../../c-api/typeobj.rst:871 ../../c-api/typeobj.rst:1067
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, "
":c:member:`~PyTypeObject.tp_getattro`"
msgstr ""
"分组: :c:member:`~PyTypeObject.tp_getattr`, "
":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:873
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"该字段会被子类和 :c:member:`~PyTypeObject.tp_getattro` 所继承：当子类型的 "
":c:member:`~PyTypeObject.tp_getattr` 和 :c:member:`~PyTypeObject.tp_getattro`"
" 均为 ``NULL`` 时该子类型将从它的基类型同时继承 :c:member:`~PyTypeObject.tp_getattr` 和 "
":c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:880 ../../c-api/typeobj.rst:1080
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "一个指向函数以便设置和删除属性的可选指针。"

#: ../../c-api/typeobj.rst:882
msgid ""
"This field is deprecated.  When it is defined, it should point to a function"
" that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"该字段已弃用。当它被定义时，应该和 :c:member:`~PyTypeObject.tp_setattro` "
"指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。"

#: ../../c-api/typeobj.rst:888 ../../c-api/typeobj.rst:1093
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, "
":c:member:`~PyTypeObject.tp_setattro`"
msgstr ""
"分组: :c:member:`~PyTypeObject.tp_setattr`, "
":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:890
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"该字段会被子类型和 :c:member:`~PyTypeObject.tp_setattro` 所继承：当子类型的 "
":c:member:`~PyTypeObject.tp_setattr` 和 :c:member:`~PyTypeObject.tp_setattro`"
" 均为 ``NULL`` 时该子类型将同时从它的基类型继承 :c:member:`~PyTypeObject.tp_setattr` 和 "
":c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:897
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"指向一个包含仅与在 C 层级上实现 :term:`awaitable` 和 :term:`asynchronous iterator` "
"协议的对象相关联的字段的附加结构体。 请参阅 :ref:`async-structs` 了解详情。"

#: ../../c-api/typeobj.rst:901
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "在之前被称为 ``tp_compare`` 和 ``tp_reserved``。"

#: ../../c-api/typeobj.rst:906
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_async` 字段不会被继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:914
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`repr`."
msgstr "一个实现了内置函数 :func:`repr` 的函数的可选指针。"

#: ../../c-api/typeobj.rst:917
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "该签名与 :c:func:`PyObject_Repr` 的相同::"

#: ../../c-api/typeobj.rst:919
msgid "PyObject *tp_repr(PyObject *self);"
msgstr "PyObject *tp_repr(PyObject *self);"

#: ../../c-api/typeobj.rst:921
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not"
" feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"该函数必须返回一个字符串或 Unicode 对象。 在理想情况下，该函数应当返回一个字符串，当将其传给 :func:`eval` "
"时，只要有合适的环境，就会返回一个具有相同值的对象。 如果这不可行，则它应当返回一个以 ``'<'`` 开头并以 ``'>'`` "
"结尾的可被用来推断出对象的类型和值的字符串。"

#: ../../c-api/typeobj.rst:932 ../../c-api/typeobj.rst:1011
#: ../../c-api/typeobj.rst:1048 ../../c-api/typeobj.rst:1073
#: ../../c-api/typeobj.rst:1099 ../../c-api/typeobj.rst:1141
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1810
#: ../../c-api/typeobj.rst:1927 ../../c-api/typeobj.rst:1960
#: ../../c-api/typeobj.rst:2035 ../../c-api/typeobj.rst:2076
#: ../../c-api/typeobj.rst:2096 ../../c-api/typeobj.rst:2135
#: ../../c-api/typeobj.rst:2163 ../../c-api/typeobj.rst:2194
msgid "**Default:**"
msgstr "**默认：**"

#: ../../c-api/typeobj.rst:934
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"如果未设置该字段，则返回 ``<%s object at %p>`` 形式的字符串，其中 ``%s`` 将替换为类型名称，``%p`` "
"将替换为对象的内存地址。"

#: ../../c-api/typeobj.rst:941
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented in"
" :ref:`number-structs`."
msgstr "指向一个附加结构体的指针，其中包含只与执行数字协议的对象相关的字段。 这些字段的文档参见 :ref:`number-structs`。"

#: ../../c-api/typeobj.rst:947
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_number` 字段不会被继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:953
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr "指向一个附加结构体的指针，其中包含只与执行序列协议的对象相关的字段。 这些字段的文档见 :ref:`sequence-structs`。"

#: ../../c-api/typeobj.rst:959
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the"
" contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_sequence` 字段不会被继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:965
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr "指向一个附加结构体的指针，其中包含只与执行映射协议的对象相关的字段。 这些字段的文档见 :ref:`mapping-structs`。"

#: ../../c-api/typeobj.rst:971
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_mapping` 字段不会继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:979
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`hash`."
msgstr "一个指向实现了内置函数 :func:`hash` 的函数的可选指针。"

#: ../../c-api/typeobj.rst:982
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "其签名与 :c:func:`PyObject_Hash` 的相同::"

#: ../../c-api/typeobj.rst:984
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr "Py_hash_t tp_hash(PyObject *);"

#: ../../c-api/typeobj.rst:986
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr "``-1`` 不应作为正常返回值被返回；当计算哈希值过程中发生错误时，函数应设置一个异常并返回 ``-1``。"

#: ../../c-api/typeobj.rst:990
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises "
":exc:`TypeError`. This is the same as setting it to "
":c:func:`PyObject_HashNotImplemented`."
msgstr ""
"当该字段（*和* :c:member:`~PyTypeObject.tp_richcompare`）都未设置，尝试对该对象取哈希会引发 "
":exc:`TypeError`。这与将其设为 :c:func:`PyObject_HashNotImplemented` 相同。"

#: ../../c-api/typeobj.rst:994
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to"
" block inheritance of the hash method from a parent type. This is "
"interpreted as the equivalent of ``__hash__ = None`` at the Python level, "
"causing ``isinstance(o, collections.Hashable)`` to correctly return "
"``False``. Note that the converse is also true - setting ``__hash__ = None``"
" on a class at the Python level will result in the ``tp_hash`` slot being "
"set to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"此字段可被显式设为 :c:func:`PyObject_HashNotImplemented` 以阻止从父类型继承哈希方法。在 Python "
"层面这被解释为 ``__hash__ = None`` 的等价物，使得 ``isinstance(o, collections.Hashable)`` "
"正确返回 ``False``.。请注意反过来也是如此：在 Python 层面设置一个类的 ``__hash__ = None`` 会使得 "
"``tp_hash`` 槽位被设置为 :c:func:`PyObject_HashNotImplemented`。"

#: ../../c-api/typeobj.rst:1004 ../../c-api/typeobj.rst:1769
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, "
":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ""
"分组: :c:member:`~PyTypeObject.tp_hash`, "
":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:1006
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both of "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash`, when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"该字段会被子类型同 :c:member:`~PyTypeObject.tp_richcompare` 一起继承：当子类型的 "
":c:member:`~PyTypeObject.tp_richcompare` 和 :c:member:`~PyTypeObject.tp_hash`"
" 均为 ``NULL`` 时子类型将同时继承 :c:member:`~PyTypeObject.tp_richcompare` 和 "
":c:member:`~PyTypeObject.tp_hash`。"

#: ../../c-api/typeobj.rst:1013
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:data:`PyBaseObject_Type` 使用 :c:func:`PyObject_GenericHash`。"

#: ../../c-api/typeobj.rst:1018
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same"
" as for :c:func:`PyObject_Call`::"
msgstr ""
"一个可选的实现对象调用的指向函数的指针。 如果对象不是可调用对象则该值应为 ``NULL``。 其签名与 :c:func:`PyObject_Call`"
" 的相同::"

#: ../../c-api/typeobj.rst:1022
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"

#: ../../c-api/typeobj.rst:1031
msgid ""
"An optional pointer to a function that implements the built-in operation "
":func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls "
":c:func:`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` "
"will call this handler.)"
msgstr ""
"一个可选的实现内置 :func:`str` 操作的函数的指针。 （请注意 :class:`str` 现在是一个类型，:func:`str` "
"是调用该类型的构造器。 该构造器将调用 :c:func:`PyObject_Str` 执行实际操作，而 :c:func:`PyObject_Str` "
"将调用该处理器。）"

#: ../../c-api/typeobj.rst:1036
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "其签名与 :c:func:`PyObject_Str` 的相同::"

#: ../../c-api/typeobj.rst:1038
msgid "PyObject *tp_str(PyObject *self);"
msgstr "PyObject *tp_str(PyObject *self);"

#: ../../c-api/typeobj.rst:1040
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"该函数必须返回一个字符串或 Unicode 对象。 它应当是一个“友好”的对象字符串表示形式，因为这就是要在 :func:`print` "
"函数中与其他内容一起使用的表示形式。"

#: ../../c-api/typeobj.rst:1050
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr "当未设置该字段时，将调用 :c:func:`PyObject_Repr` 来返回一个字符串表示形式。"

#: ../../c-api/typeobj.rst:1056
msgid "An optional pointer to the get-attribute function."
msgstr "一个指向获取属性字符串函数的可选指针。"

#: ../../c-api/typeobj.rst:1058
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "其签名与 :c:func:`PyObject_GetAttr` 的相同::"

#: ../../c-api/typeobj.rst:1060
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr "PyObject *tp_getattro(PyObject *self, PyObject *attr);"

#: ../../c-api/typeobj.rst:1062
msgid ""
"It is usually convenient to set this field to "
":c:func:`PyObject_GenericGetAttr`, which implements the normal way of "
"looking for object attributes."
msgstr "可以方便地将该字段设为 :c:func:`PyObject_GenericGetAttr`，它实现了查找对象属性的通常方式。"

#: ../../c-api/typeobj.rst:1069
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"该字段会被子类同 :c:member:`~PyTypeObject.tp_getattr` 一起继承：当子类型的 "
":c:member:`~PyTypeObject.tp_getattr` 和 :c:member:`~PyTypeObject.tp_getattro`"
" 均为 ``NULL`` 时子类型将同时继承 :c:member:`~PyTypeObject.tp_getattr` 和 "
":c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:1075
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:data:`PyBaseObject_Type` 使用 :c:func:`PyObject_GenericGetAttr`。"

#: ../../c-api/typeobj.rst:1082
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "其签名与 :c:func:`PyObject_SetAttr` 的相同::"

#: ../../c-api/typeobj.rst:1084
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"

#: ../../c-api/typeobj.rst:1086
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to "
":c:func:`PyObject_GenericSetAttr`, which implements the normal way of "
"setting object attributes."
msgstr ""
"此外，还必须支持将 *value* 设为 ``NULL`` 来删除属性。 通常可以方便地将该字段设为 "
":c:func:`PyObject_GenericSetAttr`，它实现了设备对象属性的通常方式。"

#: ../../c-api/typeobj.rst:1095
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"该字段会被子类型同 :c:member:`~PyTypeObject.tp_setattr` 一起继承：当子类型的 "
":c:member:`~PyTypeObject.tp_setattr` 和 :c:member:`~PyTypeObject.tp_setattro`"
" 均为 ``NULL`` 时子类型将同时继承 :c:member:`~PyTypeObject.tp_setattr` 和 "
":c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:1101
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:data:`PyBaseObject_Type` 使用 :c:func:`PyObject_GenericSetAttr`。"

#: ../../c-api/typeobj.rst:1106
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr "指向一个包含只与实现缓冲区接口的对象相关的字段的附加结构体的指针。 这些字段的文档参见 :ref:`buffer-structs`。"

#: ../../c-api/typeobj.rst:1112
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_buffer` 字段不会被继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:1118
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via "
":c:member:`~PyTypeObject.tp_as_number`, "
":c:member:`~PyTypeObject.tp_as_sequence`, "
":c:member:`~PyTypeObject.tp_as_mapping`, and "
":c:member:`~PyTypeObject.tp_as_buffer`) that were historically not always "
"present are valid; if such a flag bit is clear, the type fields it guards "
"must not be accessed and must be considered to have a zero or ``NULL`` value"
" instead."
msgstr ""
"该字段是针对多个旗标的位掩码。 某些旗标指明用于特定场景的变化语义；另一些旗标则用于指明类型对象（或通过 "
":c:member:`~PyTypeObject.tp_as_number`, "
":c:member:`~PyTypeObject.tp_as_sequence`, "
":c:member:`~PyTypeObject.tp_as_mapping` 和 "
":c:member:`~PyTypeObject.tp_as_buffer` "
"引用的扩展结构体）中的特定字段，它们在历史上并不总是有效；如果这样的旗标位是清晰的，则它所保护的类型字段必须不可被访问并且必须被视为具有零或 "
"``NULL`` 值。"

#: ../../c-api/typeobj.rst:1128
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits"
" this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` and"
" :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the "
":c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear`"
" fields in the subtype exist and have ``NULL`` values."
msgstr ""
"此字段的继承较为复杂。大多数标志位是单独继承的，即如果基类型设置了某个标志位，子类型继承该标志位。与扩展结构体相关的标志位在扩展结构体被继承时严格继承，即基类型的标志位值与指向扩展结构体的指针一起复制到子类型中。:c:macro:`Py_TPFLAGS_HAVE_GC`"
" 标志位与 :c:member:`~PyTypeObject.tp_traverse` 和 "
":c:member:`~PyTypeObject.tp_clear` 字段一起继承，即如果子类型中的 "
":c:macro:`Py_TPFLAGS_HAVE_GC` 标志位未设置，且子类型中的 "
":c:member:`~PyTypeObject.tp_traverse` 和 :c:member:`~PyTypeObject.tp_clear` "
"字段存在且值为 ``NULL``。"

#: ../../c-api/typeobj.rst:1143
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` 使用 ``Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE``。"

#: ../../c-api/typeobj.rst:1146
msgid "**Bit Masks:**"
msgstr "**位掩码:**"

#: ../../c-api/typeobj.rst:1150
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the "
":c:member:`~PyTypeObject.tp_flags` field.  The macro "
":c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and *f*, "
"and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""
"目前定义了以下位掩码；可以使用 ``|`` 运算符对它们进行 OR 运算以形成 :c:member:`~PyTypeObject.tp_flags` "
"字段的值。 宏 :c:func:`PyType_HasFeature` 接受一个类型和一个旗标值 *tp* 和 *f*，并检查 "
"``tp->tp_flags & f`` 是否为非零值。"

#: ../../c-api/typeobj.rst:1157
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this"
" case, the :c:member:`~PyObject.ob_type` field of its instances is "
"considered a reference to the type, and the type object is INCREF'ed when a "
"new instance is created, and DECREF'ed when an instance is destroyed (this "
"does not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should also "
":ref:`support garbage collection <supporting-cycle-detection>` as they can "
"form a reference cycle with their own module object."
msgstr ""
"当类型对象本身在堆上被分配时会设置这个比特位，例如，使用 :c:func:`PyType_FromSpec` 动态创建的类型。 在此情况下，其实例的 "
":c:member:`~PyObject.ob_type` 字段会被视为指向该类型的引用，而类型对象将在一个新实例被创建时执行 "
"INCREF，并在实例被销毁时执行 DECREF（这不会应用于子类型的实例；只有实例的 ob_type 所引用的类型会执行 INCREF 和 "
"DECREF）。 堆类型应当也 :ref:`支持垃圾回收 <supporting-cycle-detection>` "
"因为它们会形成对它们自己的模块对象的循环引用。"

#: ../../c-api/typeobj.rst:1168 ../../c-api/typeobj.rst:1179
#: ../../c-api/typeobj.rst:1189 ../../c-api/typeobj.rst:1199
#: ../../c-api/typeobj.rst:1231
msgid "???"
msgstr "？？？"

#: ../../c-api/typeobj.rst:1173
msgid ""
"This bit is set when the type can be used as the base type of another type."
"  If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"当此类型可被用作另一个类型的基类型时该比特位将被设置。 如果该比特位被清除，则此类型将无法被子类型化（类似于 Java 中的 \"final\" 类）。"

#: ../../c-api/typeobj.rst:1184
msgid ""
"This bit is set when the type object has been fully initialized by "
":c:func:`PyType_Ready`."
msgstr "当此类型对象通过 :c:func:`PyType_Ready` 被完全实例化时该比特位将被设置。"

#: ../../c-api/typeobj.rst:1194
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr "当 :c:func:`PyType_Ready` 处在初始化此类型对象过程中时该比特位将被设置。"

#: ../../c-api/typeobj.rst:1204
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is"
" set, memory for new instances (see :c:member:`~PyTypeObject.tp_alloc`) must"
" be allocated using :c:macro:`PyObject_GC_New` or "
":c:func:`PyType_GenericAlloc` and deallocated (see "
":c:member:`~PyTypeObject.tp_free`) using :c:func:`PyObject_GC_Del`.  More "
"information in section :ref:`supporting-cycle-detection`."
msgstr ""
"当对象支持垃圾回收时，此比特位被设置。如果设置了此位，新实例（参见 :c:member:`~PyTypeObject.tp_alloc`）的内存必须使用"
" :c:macro:`PyObject_GC_New` 或 :c:func:`PyType_GenericAlloc` 分配，并使用 "
":c:func:`PyObject_GC_Del` 释放（参见 :c:member:`~PyTypeObject.tp_free`）。更多信息见 "
":ref:`supporting-cycle-detection` 部分。"

#: ../../c-api/typeobj.rst:1213 ../../c-api/typeobj.rst:1560
#: ../../c-api/typeobj.rst:1704
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`,"
" :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"分组: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`, "
":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:1215
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the "
":c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear`"
" fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the"
" subtype and the :c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
":c:macro:`Py_TPFLAGS_HAVE_GC` 旗标位会与 :c:member:`~PyTypeObject.tp_traverse` 和 "
":c:member:`~PyTypeObject.tp_clear` 字段一起被继承，也就是说，如果 "
":c:macro:`Py_TPFLAGS_HAVE_GC` 旗标位在子类型中被清空并且子类型中的 "
":c:member:`~PyTypeObject.tp_traverse` 和 :c:member:`~PyTypeObject.tp_clear` "
"字段存在并具有 ``NULL`` 值的话。"

#: ../../c-api/typeobj.rst:1225
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"这是一个从属于类型对象及其扩展结构体的存在的所有位的位掩码。 目前，它包括以下的位: "
":c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`。"

#: ../../c-api/typeobj.rst:1236
msgid "This bit indicates that objects behave like unbound methods."
msgstr "这个位指明对象的行为类似于未绑定方法。"

#: ../../c-api/typeobj.rst:1238
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "如果为 ``type(meth)`` 设置了该旗标，那么："

#: ../../c-api/typeobj.rst:1240
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (其中 ``obj`` 不为 None) 必须等价于 "
"``meth(obj, *args, **kwds)``。"

#: ../../c-api/typeobj.rst:1243
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` 必须等价于 ``meth(*args, **kwds)``。"

#: ../../c-api/typeobj.rst:1246
msgid ""
"This flag enables an optimization for typical method calls like "
"``obj.meth()``: it avoids creating a temporary \"bound method\" object for "
"``obj.meth``."
msgstr "此旗标为 ``obj.meth()`` 这样的典型方法调用启用优化：它将避免为 ``obj.meth`` 创建临时的“绑定方法”对象。"

#: ../../c-api/typeobj.rst:1254
msgid ""
"This flag is never inherited by types without the "
":c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is "
"inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"此旗标绝不会被没有设置 :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` 旗标的类型所继承。 对于扩展类型，当 "
":c:member:`~PyTypeObject.tp_descr_get` 被继承时它也会被继承。"

#: ../../c-api/typeobj.rst:1260
msgid ""
"This bit indicates that instances of the class have a "
":attr:`~object.__dict__` attribute, and that the space for the dictionary is"
" managed by the VM."
msgstr "该比特位指明类的实例具有 :attr:`~object.__dict__` 属性，并且该字典的空间是由 VM 管理的。"

#: ../../c-api/typeobj.rst:1263
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr "如果设置了该旗标，则 :c:macro:`Py_TPFLAGS_HAVE_GC` 也应当被设置。"

#: ../../c-api/typeobj.rst:1265
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and"
" its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""
"类型遍历函数必须调用 :c:func:`PyObject_VisitManagedDict` 而它的清空函数必须调用 "
":c:func:`PyObject_ClearManagedDict`。"

#: ../../c-api/typeobj.rst:1272
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr "此旗标将被继承，除非某个超类设置了 :c:member:`~PyTypeObject.tp_dictoffset` 字段。"

#: ../../c-api/typeobj.rst:1278
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr "该比特位表示类的实例应当是可被弱引用的。"

#: ../../c-api/typeobj.rst:1285
msgid ""
"This flag is inherited unless the "
":c:member:`~PyTypeObject.tp_weaklistoffset` field is set in a superclass."
msgstr "此旗标将被继承，除非某个超类设置了 :c:member:`~PyTypeObject.tp_weaklistoffset` 字段。"

#: ../../c-api/typeobj.rst:1291
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero "
":c:member:`~PyTypeObject.tp_itemsize`."
msgstr "仅适用于可变大小的类型，也就是说，具有非零 :c:member:`~PyTypeObject.tp_itemsize` 值的类型。"

#: ../../c-api/typeobj.rst:1294
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of "
"``Py_TYPE(obj)->tp_basicsize`` (which may be different in each subclass)."
msgstr ""
"表示此类型的实例的可变大小部分位于该实例内存区的末尾，其偏移量为 ``Py_TYPE(obj)->tp_basicsize`` (每个子类可能不一样)。"

#: ../../c-api/typeobj.rst:1299
msgid ""
"When setting this flag, be sure that all superclasses either use this memory"
" layout, or are not variable-sized. Python does not check this."
msgstr "当设置此旗标时，请确保所有子类要么使用此内存布局，要么不是可变大小。 Python 不会检查这一点。"

#: ../../c-api/typeobj.rst:1307
msgid "This flag is inherited."
msgstr "这个旗标会被继承。"

#: ../../c-api/typeobj.rst:1321
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their "
":c:member:`~PyTypeObject.tp_flags` set appropriately, or the code that "
"interacts with such types will behave differently depending on what kind of "
"check is used."
msgstr ""
"这些旗标被 :c:func:`PyLong_Check` 等函数用来快速确定一个类型是否为内置类型的子类；这样的专用检测比泛用检测如 "
":c:func:`PyObject_IsInstance` 要更快速。 继承自内置类型的自定义类型应当正确地设置其 "
":c:member:`~PyTypeObject.tp_flags`，否则与这样的类型进行交互的代码将因所使用的检测种类而出现不同的行为。"

#: ../../c-api/typeobj.rst:1332
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr "当类型结构体中存在 :c:member:`~PyTypeObject.tp_finalize` 槽位时会设置这个比特位。"

#: ../../c-api/typeobj.rst:1337
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the "
":c:member:`~PyTypeObject.tp_finalize` slot is always present in the type "
"structure."
msgstr ""
"此旗标已不再是必要的，因为解释器会假定类型结构体中总是存在 :c:member:`~PyTypeObject.tp_finalize` 槽位。"

#: ../../c-api/typeobj.rst:1345
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"当类实现了 :ref:`vectorcall 协议 <vectorcall>` 时会设置这个比特位。 请参阅 "
":c:member:`~PyTypeObject.tp_vectorcall_offset` 了解详情。"

#: ../../c-api/typeobj.rst:1351
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also "
"inherited."
msgstr "如果继承了 :c:member:`~PyTypeObject.tp_call` 则也会继承这个比特位。"

#: ../../c-api/typeobj.rst:1358
msgid ""
"This flag is now removed from a class when the class's "
":py:meth:`~object.__call__` method is reassigned."
msgstr "现在当类的 :py:meth:`~object.__call__` 方法被重新赋值时该旗标将从类中移除。"

#: ../../c-api/typeobj.rst:1361
msgid "This flag can now be inherited by mutable classes."
msgstr "现在该旗标能被可变类所继承。"

#: ../../c-api/typeobj.rst:1365
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr "不可变的类型对象会设置这个比特位：类型属性无法被设置或删除。"

#: ../../c-api/typeobj.rst:1367
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types"
" <static-types>`."
msgstr ":c:func:`PyType_Ready` 会自动对 :ref:`静态类型 <static-types>` 应用这个旗标。"

#: ../../c-api/typeobj.rst:1372
msgid "This flag is not inherited."
msgstr "这个旗标不会被继承。"

#: ../../c-api/typeobj.rst:1378
msgid ""
"Disallow creating instances of the type: set "
":c:member:`~PyTypeObject.tp_new` to NULL and don't create the ``__new__`` "
"key in the type dictionary."
msgstr ""
"不允许创建此类型的实例：将 :c:member:`~PyTypeObject.tp_new` 设为 NULL 并且不会在类型字符中创建 "
"``__new__`` 键。"

#: ../../c-api/typeobj.rst:1382
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr "这个旗标必须在创建该类型之前设置，而不是在之后。 例如，它必须在该类型调用 :c:func:`PyType_Ready` 之前被设置。"

#: ../../c-api/typeobj.rst:1385
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if "
":c:member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and "
":c:member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"如果 :c:member:`~PyTypeObject.tp_base` 为 NULL 或者 ``&PyBaseObject_Type`` 和 "
":c:member:`~PyTypeObject.tp_new` 为 NULL 则该旗标会在 :ref:`静态类型 <static-types>` "
"上自动设置。"

#: ../../c-api/typeobj.rst:1391
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"这个旗标不会被继承。 但是，子类将不能被实例化，除非它们提供了不为 NULL 的 :c:member:`~PyTypeObject.tp_new` "
"(这只能通过 C API 实现)。"

#: ../../c-api/typeobj.rst:1398
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"要禁止直接实例化一个类但允许实例化其子类 (例如对于 :term:`abstract base class`)，请勿使用此旗标。 替代的做法是，让 "
":c:member:`~PyTypeObject.tp_new` 只对子类可用。"

#: ../../c-api/typeobj.rst:1409
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"这个比特位指明该类的实例可以在被用作 :keyword:`match` 代码块的目标时匹配映射模式。 它会在注册或子类化 "
":class:`collections.abc.Mapping` 时自动设置，并在注册 "
":class:`collections.abc.Sequence` 时取消设置。"

#: ../../c-api/typeobj.rst:1416 ../../c-api/typeobj.rst:1438
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` 和 :c:macro:`Py_TPFLAGS_SEQUENCE` "
"是互斥的；同时启用两个旗标将导致报错。"

#: ../../c-api/typeobj.rst:1421
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_SEQUENCE`."
msgstr "这个旗标将被尚未设置 :c:macro:`Py_TPFLAGS_SEQUENCE` 的类型所继承。"

#: ../../c-api/typeobj.rst:1424 ../../c-api/typeobj.rst:1446
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` —— 结构化模式匹配：规范"

#: ../../c-api/typeobj.rst:1431
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"这个比特位指明该类的实例可以在被用作 :keyword:`match` 代码块的目标时匹配序列模式。 它会在注册或子类化 "
":class:`collections.abc.Sequence` 时自动设置，并在注册 "
":class:`collections.abc.Mapping` 时取消设置。"

#: ../../c-api/typeobj.rst:1443
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_MAPPING`."
msgstr "这个旗标将被尚未设置 :c:macro:`Py_TPFLAGS_MAPPING` 的类型所继承。"

#: ../../c-api/typeobj.rst:1453
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr "内部使用。 请不要设置或取消设置此旗标。 用于指明一个类具有被修改的调用 :c:func:`PyType_Modified`"

#: ../../c-api/typeobj.rst:1457
msgid ""
"This flag is present in header files, but is not be used. It will be removed"
" in a future version of CPython"
msgstr "此旗标存在于头文件中，但未被使用。 它将在未来某个 CPython 版本中被移除。"

#: ../../c-api/typeobj.rst:1463
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on"
" the type and instances of the type."
msgstr ""
"一个可选的指向给出该类型对象的文档字符串的以 NUL 结束的 C 字符串的指针。 该指针被暴露为类型和类型实例上的 "
":attr:`~type.__doc__` 属性。"

#: ../../c-api/typeobj.rst:1469
msgid "This field is *not* inherited by subtypes."
msgstr "这个字段 *不会* 被子类型继承。"

#: ../../c-api/typeobj.rst:1474
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This"
" is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"一个可选的指向针对垃圾回收器的遍历函数的指针。 该指针仅会在设置了 :c:macro:`Py_TPFLAGS_HAVE_GC` 旗标位时被使用。 "
"函数签名为::"

#: ../../c-api/typeobj.rst:1477
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr "int tp_traverse(PyObject *self, visitproc visit, void *arg);"

#: ../../c-api/typeobj.rst:1479 ../../c-api/typeobj.rst:1699
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr "有关 Python 垃圾回收方案的更多信息可在 :ref:`supporting-cycle-detection` 一节中查看。"

#: ../../c-api/typeobj.rst:1482
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a "
":c:member:`~PyTypeObject.tp_traverse` function simply calls "
":c:func:`Py_VISIT` on each of the instance's members that are Python objects"
" that the instance owns. For example, this is function "
":c:func:`!local_traverse` from the :mod:`!_thread` extension module::"
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` 指针被垃圾回收器用来检测循环引用。 "
":c:member:`~PyTypeObject.tp_traverse` 函数的典型实现会在实例的每个属于该实例所拥有的 Python "
"对象的成员上简单地调用 :c:func:`Py_VISIT`。 例如，以下是来自 :mod:`!_thread` 扩展模块的函数 "
":c:func:`!local_traverse`::"

#: ../../c-api/typeobj.rst:1488
msgid ""
"static int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"

#: ../../c-api/typeobj.rst:1498
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"请注意 :c:func:`Py_VISIT` 仅能在可以参加循环引用的成员上被调用。 虽然还存在一个 ``self->key`` 成员，但它只能为 "
"``NULL`` 或 Python 字符串因而不能成为循环引用的一部分。"

#: ../../c-api/typeobj.rst:1502
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"在另一方面，即使你知道某个成员永远不会成为循环引用的一部分，作为调试的辅助你仍然可能想要访问它因此 :mod:`gc` 模块的 "
":func:`~gc.get_referents` 函数将会包括它。"

#: ../../c-api/typeobj.rst:1506
msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr "堆类型 (:c:macro:`Py_TPFLAGS_HEAPTYPE`) 必须这样访问其类型::"

#: ../../c-api/typeobj.rst:1508
msgid "Py_VISIT(Py_TYPE(self));"
msgstr "Py_VISIT(Py_TYPE(self));"

#: ../../c-api/typeobj.rst:1510
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr "它只是从 Python 3.9 开始才需要。 为支持 Python 3.8 和更旧的版本，这一行必须是有条件的::"

#: ../../c-api/typeobj.rst:1513
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"

#: ../../c-api/typeobj.rst:1517
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, the traverse function must call "
":c:func:`PyObject_VisitManagedDict` like this::"
msgstr ""
"如果在 :c:member:`~PyTypeObject.tp_flags` 字段中设置了 "
":c:macro:`Py_TPFLAGS_MANAGED_DICT` 比特位，则遍历函数必须这样调用 "
":c:func:`PyObject_VisitManagedDict`::"

#: ../../c-api/typeobj.rst:1521
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"

#: ../../c-api/typeobj.rst:1524
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references"
" to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"当实现 :c:member:`~PyTypeObject.tp_traverse` 时，只有实例所 *拥有* 的成员 (就是有指向它们的 "
":term:`强引用 <strong reference>`) 才必须被访问。 举例来说，如果一个对象通过 "
":c:member:`~PyTypeObject.tp_weaklist` 槽位支持弱引用，那么支持链表 (*tp_weaklist* 所指向的对象) "
"的指针就 **不能** 被访问因为实例并不直接拥有指向自身的弱引用 "
"(弱引用列表被用来支持弱引用机制，但实例没有指向其中的元素的强引用，因为即使实例还存在它们也允许被删除)。"

#: ../../c-api/typeobj.rst:1535
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to "
":c:func:`!local_traverse` to have these specific names; don't name them just"
" anything."
msgstr ""
"请注意 :c:func:`Py_VISIT` 要求传给 :c:func:`!local_traverse` 的 *visit* 和 *arg* "
"形参具有指定的名称；不要随意命名它们。"

#: ../../c-api/typeobj.rst:1539
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit "
":c:func:`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by "
"calling ``tp_traverse`` of another heap-allocated type (such as a heap-"
"allocated superclass). If they do not, the type object may not be garbage-"
"collected."
msgstr ""
":ref:`堆分配类型 <heap-types>` 的实例会持有一个指向其类型的引用。 因此它们的遍历函数必须要么访问 "
":c:func:`Py_TYPE(self) <Py_TYPE>`，要么通过调用其他堆分配类型（例如一个堆分配超类）的 ``tp_traverse`` "
"将此任务委托出去。 如果没有这样做，类型对象可能不会被垃圾回收。"

#: ../../c-api/typeobj.rst:1548
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` function can be called from any "
"thread."
msgstr ":c:member:`~PyTypeObject.tp_traverse` 函数可以从任何线程调用。"

#: ../../c-api/typeobj.rst:1553
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 "
"<https://bugs.python.org/issue40217>`_, doing this may lead to crashes in "
"subclasses."
msgstr ""
"堆分配类型应当访问 ``tp_traverse`` 中的 ``Py_TYPE(self)``。 在较早的 Python 版本中，由于 `bug "
"40217 <https://bugs.python.org/issue40217>`_，这样做可能会导致在超类中发生崩溃。"

#: ../../c-api/typeobj.rst:1562
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if "
"they are all zero in the subtype."
msgstr ""
"该字段会与 :c:member:`~PyTypeObject.tp_clear` 和 :c:macro:`Py_TPFLAGS_HAVE_GC` "
"旗标位一起被子类型所继承：如果旗标位, :c:member:`~PyTypeObject.tp_traverse` 和 "
":c:member:`~PyTypeObject.tp_clear` 在子类型中均为零则它们都将从基类型继承。"

#: ../../c-api/typeobj.rst:1570
msgid "An optional pointer to a clear function.  The signature is::"
msgstr "一个可选的指向清除函数的指针。其签名如下::"

#: ../../c-api/typeobj.rst:1572
msgid "int tp_clear(PyObject *);"
msgstr "int tp_clear(PyObject *);"

#: ../../c-api/typeobj.rst:1574
msgid ""
"The purpose of this function is to break reference cycles that are causing a"
" :term:`cyclic isolate` so that the objects can be safely destroyed.  A "
"cleared object is a partially destroyed object; the object is not obligated "
"to satisfy design invariants held during normal use."
msgstr ""
"此函数的目的是打破导致 :term:`cyclic isolate` 的引用循环，以便可以安全地销毁对象。 "
"已清除的对象是部分销毁的对象；该对象不一定要满足正常使用期间保持的设计不变量。"

#: ../../c-api/typeobj.rst:1579
msgid ""
":c:member:`!tp_clear` does not need to delete references to objects that "
"can't participate in reference cycles, such as Python strings or Python "
"integers.  However, it may be convenient to clear all references, and write "
"the type's :c:member:`~PyTypeObject.tp_dealloc` function to invoke "
":c:member:`!tp_clear` to avoid code duplication.  (Beware that "
":c:member:`!tp_clear` might have already been called. Prefer calling "
"idempotent functions like :c:func:`Py_CLEAR`.)"
msgstr ""
":c:member:`!tp_clear` 不需要删除不能参与引用循环的对象的引用，例如 Python 字符串或 Python 整数。 "
"然而，清除所有引用可能更方便，并编写类型的 :c:member:`~PyTypeObject.tp_dealloc` 函数来调用 "
":c:member:`!tp_clear` 以避免代码重复。（注意 :c:member:`!tp_clear` 可能已经被调用。建议调用幂等函数如 "
":c:func:`Py_CLEAR`。）"

#: ../../c-api/typeobj.rst:1587
msgid ""
"Any non-trivial cleanup should be performed in "
":c:member:`~PyTypeObject.tp_finalize` instead of :c:member:`!tp_clear`."
msgstr ""
"任何非平凡的清理应在 :c:member:`~PyTypeObject.tp_finalize` 中执行，而不是在 "
":c:member:`!tp_clear` 中。"

#: ../../c-api/typeobj.rst:1592
msgid ""
"If :c:member:`!tp_clear` fails to break a reference cycle then the objects "
"in the :term:`cyclic isolate` may remain indefinitely uncollectable "
"(\"leak\").  See :data:`gc.garbage`."
msgstr ""
"如果 :c:member:`!tp_clear` 未能打破引用循环，则 :term:`cyclic isolate` "
"中的对象可能永远无法回收（“泄漏”）。参见 :data:`gc.garbage`。"

#: ../../c-api/typeobj.rst:1598
msgid ""
"Referents (direct and indirect) might have already been cleared; they are "
"not guaranteed to be in a consistent state."
msgstr "引用对象（直接和间接）可能已经被清除；它们不一定处于一致状态。"

#: ../../c-api/typeobj.rst:1603
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` function can be called from any "
"thread."
msgstr ":c:member:`~PyTypeObject.tp_clear` 函数可以从任何线程调用。"

#: ../../c-api/typeobj.rst:1608
msgid ""
"An object is not guaranteed to be automatically cleared before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called."
msgstr "在调用对象的析构函数（:c:member:`~PyTypeObject.tp_dealloc`）之前，不能保证对象会自动清除。"

#: ../../c-api/typeobj.rst:1611
msgid ""
"This function differs from the destructor "
"(:c:member:`~PyTypeObject.tp_dealloc`) in the following ways:"
msgstr "此函数与析构函数（:c:member:`~PyTypeObject.tp_dealloc`）在以下方面有所不同："

#: ../../c-api/typeobj.rst:1614
msgid ""
"The purpose of clearing an object is to remove references to other objects "
"that might participate in a reference cycle.  The purpose of the destructor,"
" on the other hand, is a superset: it must release *all* resources it owns, "
"including references to objects that cannot participate in a reference cycle"
" (e.g., integers) as well as the object's own memory (by calling "
":c:member:`~PyTypeObject.tp_free`)."
msgstr ""
"清除对象的目的在于移除可能参与引用循环的其他对象的引用。另一方面，析构函数的目的是一个超集：它必须释放其拥有的 *所有* "
"资源，包括不能参与引用循环的对象的引用（例如，整数）以及对象自身的内存（通过调用 :c:member:`~PyTypeObject.tp_free`）。"

#: ../../c-api/typeobj.rst:1620
msgid ""
"When :c:member:`!tp_clear` is called, other objects might still hold "
"references to the object being cleared.  Because of this, "
":c:member:`!tp_clear` must not deallocate the object's own memory "
"(:c:member:`~PyTypeObject.tp_free`).  The destructor, on the other hand, is "
"only called when no (strong) references exist, and as such, must safely "
"destroy the object itself by deallocating it."
msgstr ""
"当调用 :c:member:`!tp_clear` 时，其他对象可能仍然持有对正在清除的对象的引用。因此，:c:member:`!tp_clear` "
"不能释放对象自身的内存 "
"(:c:member:`~PyTypeObject.tp_free`)。另一方面，析构函数只有在不存在（强）引用时才会被调用，因此必须通过释放内存来安全地销毁对象本身。"

#: ../../c-api/typeobj.rst:1626
msgid ""
":c:member:`!tp_clear` might never be automatically called.  An object's "
"destructor, on the other hand, will be automatically called some time after "
"the object becomes unreachable (i.e., either there are no references to the "
"object or the object is a member of a :term:`cyclic isolate`)."
msgstr ""
":c:member:`!tp_clear` "
"可能永远不会自动调用。另一方面，对象的析构函数会在对象变得不可达后的一段时间内自动调用（即，没有对对象的引用，或者对象是 :term:`cyclic "
"isolate` 的成员）。"

#: ../../c-api/typeobj.rst:1631
msgid ""
"No guarantees are made about when, if, or how often Python automatically "
"clears an object, except:"
msgstr "Python 自动清除对象的时间、是否清除以及清除频率没有任何保证，除了以下情况："

#: ../../c-api/typeobj.rst:1634
msgid ""
"Python will not automatically clear an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr "如果对象是可达的，即存在对它的引用，并且它不是 :term:`cyclic isolate` 的成员，Python 不会自动清除该对象。"

#: ../../c-api/typeobj.rst:1637
msgid ""
"Python will not automatically clear an object if it has not been "
"automatically finalized (see :c:member:`~PyTypeObject.tp_finalize`).  (If "
"the finalizer resurrected the object, the object may or may not be "
"automatically finalized again before it is cleared.)"
msgstr ""
"如果对象尚未自动完成终结（参见 :c:member:`~PyTypeObject.tp_finalize`），Python "
"不会自动清除该对象。（如果终结器使对象复活，则在清除之前，对象可能会再次自动完成终结，也可能不会。）"

#: ../../c-api/typeobj.rst:1641
msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically clear it if any member of the cyclic isolate has not yet been "
"automatically finalized (:c:member:`~PyTypeObject.tp_finalize`)."
msgstr ""
"如果对象是 :term:`cyclic isolate` 的成员，并且循环隔离中的任何成员尚未自动完成终结 "
"(:c:member:`~PyTypeObject.tp_finalize`)，Python 不会自动清除该对象。"

#: ../../c-api/typeobj.rst:1644
msgid ""
"Python will not destroy an object until after any automatic calls to its "
":c:member:`!tp_clear` function have returned.  This ensures that the act of "
"breaking a reference cycle does not invalidate the ``self`` pointer while "
":c:member:`!tp_clear` is still executing."
msgstr ""
"Python 会在任何对 :c:member:`!tp_clear` 函数的自动调用返回之后才销毁对象。这确保了在 "
":c:member:`!tp_clear` 仍在执行时，打破引用循环的行为不会使 ``self`` 指针失效。"

#: ../../c-api/typeobj.rst:1648
msgid ""
"Python will not automatically call :c:member:`!tp_clear` multiple times "
"concurrently."
msgstr "Python 不会并发地多次自动调用 :c:member:`!tp_clear`。"

#: ../../c-api/typeobj.rst:1651
msgid ""
"CPython currently only automatically clears objects as needed to break "
"reference cycles in a :term:`cyclic isolate`, but future versions might "
"clear objects regularly before their destruction."
msgstr ""
"目前 CPython 只在需要打破 :term:`cyclic isolate` "
"中的引用循环时自动清除对象，但未来版本可能会在对象销毁之前定期清除对象。"

#: ../../c-api/typeobj.rst:1655
msgid ""
"Taken together, all :c:member:`~PyTypeObject.tp_clear` functions in the "
"system must combine to break all reference cycles.  This is subtle, and if "
"in any doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For "
"example, the tuple type does not implement a "
":c:member:`~PyTypeObject.tp_clear` function, because it's possible to prove "
"that no reference cycle can be composed entirely of tuples.  Therefore the "
":c:member:`~PyTypeObject.tp_clear` functions of other types are responsible "
"for breaking any cycle containing a tuple.  This isn't immediately obvious, "
"and there's rarely a good reason to avoid implementing "
":c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"综合考虑，系统中所有 :c:member:`~PyTypeObject.tp_clear` "
"函数必须共同作用以打破所有引用循环。这一点非常微妙，如果有任何疑问，请提供一个 :c:member:`~PyTypeObject.tp_clear` "
"函数。例如，元组类型没有实现 :c:member:`~PyTypeObject.tp_clear` "
"函数，因为可以证明不可能完全由元组组成引用循环。因此，其他类型的 :c:member:`~PyTypeObject.tp_clear` "
"函数负责打破包含元组的任何循环。这并非显而易见，而且通常没有充分的理由不实现 :c:member:`~PyTypeObject.tp_clear`。"

#: ../../c-api/typeobj.rst:1666
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 的实现应当丢弃实例指向其成员的可能为 Python "
"对象的引用，并将指向这些成员的指针设为 ``NULL``，如下面的例子所示::"

#: ../../c-api/typeobj.rst:1670
msgid ""
"static int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"

#: ../../c-api/typeobj.rst:1681
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via "
":c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity"
" that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"应当使用 :c:func:`Py_CLEAR` 宏，因为清除引用是很微妙的：指向被包含对象的引用必须在指向被包含对象的指针被设为 ``NULL`` "
"之后才能被释放 (通过 :c:func:`Py_DECREF`)。 "
"这是因为释放引用可能会导致被包含的对象变成垃圾，触发一连串的回收活动，其中可能包括唤起任意 Python 代码 "
"(由于关联到被包含对象的终结器或弱引用回调)。 如果这样的代码有可能再次引用 *self*，那么这时指向被包含对象的指针为 ``NULL`` "
"就是非常重要的，这样 *self* 就知道被包含对象不可再被使用。 :c:func:`Py_CLEAR` 宏将以安全的顺序执行此操作。"

#: ../../c-api/typeobj.rst:1693
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, the traverse function must call "
":c:func:`PyObject_ClearManagedDict` like this::"
msgstr ""
"如果在 :c:member:`~PyTypeObject.tp_flags` 字段中设置了 "
":c:macro:`Py_TPFLAGS_MANAGED_DICT` 比特位，则遍历函数必须这样调用 "
":c:func:`PyObject_ClearManagedDict`::"

#: ../../c-api/typeobj.rst:1697
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr "PyObject_ClearManagedDict((PyObject*)self);"

#: ../../c-api/typeobj.rst:1706
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if "
"they are all zero in the subtype."
msgstr ""
"该字段会与 :c:member:`~PyTypeObject.tp_traverse` 和 :c:macro:`Py_TPFLAGS_HAVE_GC` "
"旗标位一起被子类型所继承：如果旗标位, :c:member:`~PyTypeObject.tp_traverse` 和 "
":c:member:`~PyTypeObject.tp_clear` 在子类型中均为零则它们都将从基类型继承。"

#: ../../c-api/typeobj.rst:1718
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr "一个可选的指向富比较函数的指针，函数的签名为::"

#: ../../c-api/typeobj.rst:1720
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"

#: ../../c-api/typeobj.rst:1722
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr "第一个形参将保证为 :c:type:`PyTypeObject` 所定义的类型的实例。"

#: ../../c-api/typeobj.rst:1725
msgid ""
"The function should return the result of the comparison (usually ``Py_True``"
" or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and"
" set an exception condition."
msgstr ""
"该函数应当返回比较的结果 (通常为 ``Py_True`` 或 ``Py_False``)。 如果未定义比较运算，它必须返回 "
"``Py_NotImplemented``，如果发生了其他错误则它必须返回 ``NULL`` 并设置一个异常条件。"

#: ../../c-api/typeobj.rst:1730
msgid ""
"The following constants are defined to be used as the third argument for "
":c:member:`~PyTypeObject.tp_richcompare` and for "
":c:func:`PyObject_RichCompare`:"
msgstr ""
"以下常量被定义用作 :c:member:`~PyTypeObject.tp_richcompare` 和 "
":c:func:`PyObject_RichCompare` 的第三个参数："

#: ../../c-api/typeobj.rst:1736
msgid "Constant"
msgstr "常量"

#: ../../c-api/typeobj.rst:1736
msgid "Comparison"
msgstr "对照"

#: ../../c-api/typeobj.rst:1738
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1740
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1742
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1744
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1746
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1748
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1751
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr "定义以下宏是为了简化编写丰富的比较函数："

#: ../../c-api/typeobj.rst:1755
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"从该函数返回 ``Py_True`` 或 ``Py_False``，这取决于比较的结果。 VAL_A 和 VAL_B 必须是可通过 C "
"比较运算符进行排序的（例如，它们可以为 C 整数或浮点数）。 第三个参数指明所请求的运算，与 "
":c:func:`PyObject_RichCompare` 的参数一样。"

#: ../../c-api/typeobj.rst:1761
msgid "The returned value is a new :term:`strong reference`."
msgstr "返回值是一个新的 :term:`strong reference`。"

#: ../../c-api/typeobj.rst:1763
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "发生错误时，将设置异常并从该函数返回 ``NULL``。"

#: ../../c-api/typeobj.rst:1771
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_hash`: a subtype inherits "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"该字段会被子类型同 :c:member:`~PyTypeObject.tp_hash` 一起继承：当子类型的 "
":c:member:`~PyTypeObject.tp_richcompare` 和 :c:member:`~PyTypeObject.tp_hash`"
" 均为 ``NULL`` 时子类型将同时继承 :c:member:`~PyTypeObject.tp_richcompare` 和 "
":c:member:`~PyTypeObject.tp_hash`。"

#: ../../c-api/typeobj.rst:1778
msgid ""
":c:data:`PyBaseObject_Type` provides a "
":c:member:`~PyTypeObject.tp_richcompare` implementation, which may be "
"inherited.  However, if only :c:member:`~PyTypeObject.tp_hash` is defined, "
"not even the inherited function is used and instances of the type will not "
"be able to participate in any comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` 提供了一个 :c:member:`~PyTypeObject.tp_richcompare` "
"的实现，它可以被继承。 但是，如果只定义了 "
":c:member:`~PyTypeObject.tp_hash`，则不会使用被继承的函数并且该类型的实例将无法参加任何比较。"

#: ../../c-api/typeobj.rst:1787
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr "虽然此字段仍然受到支持，但是如果可能就应当改用 :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF`。"

#: ../../c-api/typeobj.rst:1790
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type "
":c:expr:`PyObject*` which is initialized to ``NULL``."
msgstr ""
"如果此类型的实例是可被弱引用的，则该字段将大于零并包含在弱引用列表头的实例结构体中的偏移量（忽略 GC 头，如果存在的话）；该偏移量将被 "
":c:func:`PyObject_ClearWeakRefs` 和 ``PyWeakref_*`` 函数使用。 实例结构体需要包括一个 "
":c:expr:`PyObject*` 类型的字段并初始化为 ``NULL``。"

#: ../../c-api/typeobj.rst:1797
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr "不要将该字段与 :c:member:`~PyTypeObject.tp_weaklist` 混淆；后者是指向类型对象本身的弱引用的列表头。"

#: ../../c-api/typeobj.rst:1800
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit and"
" :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"同时设置 :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` 位和 "
":c:member:`~PyTypeObject.tp_weaklistoffset` 将导致错误。"

#: ../../c-api/typeobj.rst:1805
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should"
" not be a problem."
msgstr ""
"该字段会被子类型继承，但注意参阅下面列出的规则。 子类型可以覆盖此偏移量；这意味着子类型将使用不同于基类型的弱引用列表。 由于列表头总是通过 "
":c:member:`~PyTypeObject.tp_weaklistoffset` 找到的，所以这应该不成问题。"

#: ../../c-api/typeobj.rst:1812
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, then "
":c:member:`~PyTypeObject.tp_weaklistoffset` will be set to a negative value,"
" to indicate that it is unsafe to use this field."
msgstr ""
"如果在 :c:member:`~PyTypeObject.tp_flags` 字段中设置了 "
":c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` 位，则 "
":c:member:`~PyTypeObject.tp_weaklistoffset` 将被设为负值，用以表明使用此字段是不安全的。"

#: ../../c-api/typeobj.rst:1820
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are "
":term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"一个可选的指向函数的指针，该函数返回对象的 :term:`iterator`。 它的存在通常表明该类型的实例为 :term:`iterable` "
"(尽管序列在没有此函数的情况下也可能为可迭代对象)。"

#: ../../c-api/typeobj.rst:1824
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "此函数的签名与 :c:func:`PyObject_GetIter` 的相同::"

#: ../../c-api/typeobj.rst:1826
msgid "PyObject *tp_iter(PyObject *self);"
msgstr "PyObject *tp_iter(PyObject *self);"

#: ../../c-api/typeobj.rst:1835
msgid ""
"An optional pointer to a function that returns the next item in an "
":term:`iterator`. The signature is::"
msgstr "一个可选的指向函数的指针，该函数返回 :term:`iterator` 中的下一项。 其签名为::"

#: ../../c-api/typeobj.rst:1838
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr "PyObject *tp_iternext(PyObject *self);"

#: ../../c-api/typeobj.rst:1840
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a "
":exc:`StopIteration` exception may or may not be set.  When another error "
"occurs, it must return ``NULL`` too.  Its presence signals that the "
"instances of this type are iterators."
msgstr ""
"当该迭代器被耗尽时，它必须返回 ``NULL``；:exc:`StopIteration` 异常可能会设置也可能不设置。 "
"当发生另一个错误时，它也必须返回 ``NULL``。 它的存在表明该类型的实际是迭代器。"

#: ../../c-api/typeobj.rst:1845
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"迭代器类型也应当定义 :c:member:`~PyTypeObject.tp_iter` "
"函数，并且该函数应当返回迭代器实例本身（而不是新的迭代器实例）。"

#: ../../c-api/typeobj.rst:1849
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "此函数的签名与 :c:func:`PyIter_Next` 的相同。"

#: ../../c-api/typeobj.rst:1858
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMethodDef` structures, declaring regular methods of this type."
msgstr "一个可选的指向 :c:type:`PyMethodDef` 结构体的以 ``NULL`` 结束的静态数组的指针，它声明了此类型的常规方法。"

#: ../../c-api/typeobj.rst:1861
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"对于该数组中的每一项，都会向类型的字典 (参见下面的 :c:member:`~PyTypeObject.tp_dict`) "
"添加一个包含方法描述器的条目。"

#: ../../c-api/typeobj.rst:1866
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr "该字段不会被子类型所继承（方法是通过不同的机制来继承的）。"

#: ../../c-api/typeobj.rst:1872
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMemberDef` structures, declaring regular data members (fields or "
"slots) of instances of this type."
msgstr ""
"一个可选的指向 :c:type:`PyMemberDef` 结构体的以 ``NULL`` "
"结束的静态数组的指针，它声明了此类型的常规数据成员（字段或槽位）。"

#: ../../c-api/typeobj.rst:1876
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"对于该数组中的每一项，都会向类型的字典 (参见下面的 :c:member:`~PyTypeObject.tp_dict`) "
"添加一个包含方法描述器的条目。"

#: ../../c-api/typeobj.rst:1881
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr "该字段不会被子类型所继承（成员是通过不同的机制来继承的）。"

#: ../../c-api/typeobj.rst:1887
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyGetSetDef` structures, declaring computed attributes of instances"
" of this type."
msgstr ""
"一个可选的指向 :c:type:`PyGetSetDef` 结构体的以 ``NULL`` 结束的静态数组的指针，它声明了此类型的实例中的被计算属性。"

#: ../../c-api/typeobj.rst:1890
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"对于该数组中的每一项，都会向类型的字典 (参见下面的 :c:member:`~PyTypeObject.tp_dict`) "
"添加一个包含读写描述器的条目。"

#: ../../c-api/typeobj.rst:1895
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr "该字段不会被子类型所继承（被计算属性是通过不同的机制来继承的）。"

#: ../../c-api/typeobj.rst:1901
msgid ""
"An optional pointer to a base type from which type properties are inherited."
"  At this level, only single inheritance is supported; multiple inheritance "
"require dynamically creating a type object by calling the metatype."
msgstr "一个可选的指向类型特征属性所继承的基类型的指针。 在这个层级上，只支持单继承；多重继承需要通过调用元类型动态地创建类型对象。"

#: ../../c-api/typeobj.rst:1909
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators"
" like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, "
"are valid C99 address constants."
msgstr ""
"槽位初始化需要遵循初始化全局变量的规则。 C99 要求初始化器为“地址常量”。 隐式转换为指针的函数指示器如 "
":c:func:`PyType_GenericNew` 都是有效的 C99 地址常量。"

#: ../../c-api/typeobj.rst:1914
msgid ""
"However, the unary '&' operator applied to a non-static variable like "
":c:data:`PyBaseObject_Type` is not required to produce an address constant."
"  Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"但是，生成地址常量并不需要应用于非静态变量如 :c:data:`PyBaseObject_Type` 的单目运算符 '&'。 编译器可能支持该运算符（如"
" gcc），但 MSVC 则不支持。 这两种编译器在这一特定行为上都是严格符合标准的。"

#: ../../c-api/typeobj.rst:1920
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr "因此，应当在扩展模块的初始化函数中设置 :c:member:`~PyTypeObject.tp_base`。"

#: ../../c-api/typeobj.rst:1925
msgid "This field is not inherited by subtypes (obviously)."
msgstr "该字段不会被子类型继承（显然）。"

#: ../../c-api/typeobj.rst:1929
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr "该字段默认为 ``&PyBaseObject_Type`` (对 Python 程序员来说即 :class:`object` 类型)。"

#: ../../c-api/typeobj.rst:1935
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "类型的字典将由 :c:func:`PyType_Ready` 存储到这里。"

#: ../../c-api/typeobj.rst:1937
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is"
" called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like "
":meth:`~object.__add__`).  Once initialization for the type has finished, "
"this field should be treated as read-only."
msgstr ""
"该字段通常应当在 PyType_Ready 被调用之前初始化为 ``NULL``；它也可以初始化为一个包含类型初始属性的字典。 一旦 "
":c:func:`PyType_Ready` 完成类型的初始化，该类型的额外属性只有在它们不与被重载的操作 (如 "
":meth:`~object.__add__`) 相对应的情况下才会被添加到该字典中。 一旦类型的初始化结束，该字段就应被视为是只读的。"

#: ../../c-api/typeobj.rst:1945
msgid ""
"Some types may not store their dictionary in this slot. Use "
":c:func:`PyType_GetDict` to retrieve the dictionary for an arbitrary type."
msgstr "某些类型不会将它们的字典存储在该槽位中。 请使用 :c:func:`PyType_GetDict` 来获取任意类型对应的字典。"

#: ../../c-api/typeobj.rst:1951
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use "
":c:func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""
"内部细节：对于静态内置类型，该值总是为 ``NULL``。 这种类型的字典是存储在 ``PyInterpreterState`` 中。 请使用 "
":c:func:`PyType_GetDict` 来获取任意类型的字典。"

#: ../../c-api/typeobj.rst:1957
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr "该字段不会被子类型所继承（但在这里定义的属性是通过不同的机制来继承的）。"

#: ../../c-api/typeobj.rst:1962
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr "如果该字段为 ``NULL``，:c:func:`PyType_Ready` 将为它分配一个新字典。"

#: ../../c-api/typeobj.rst:1967
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify "
":c:member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"通过字典 C-API 使用 :c:func:`PyDict_SetItem` 或修改 :c:member:`~PyTypeObject.tp_dict`"
" 是不安全的。"

#: ../../c-api/typeobj.rst:1973
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "一个可选的指向“描述器获取”函数的指针。"

#: ../../c-api/typeobj.rst:1975 ../../c-api/typeobj.rst:1991
#: ../../c-api/typeobj.rst:2055 ../../c-api/typeobj.rst:2085
#: ../../c-api/typeobj.rst:2108
msgid "The function signature is::"
msgstr "函数的签名为::"

#: ../../c-api/typeobj.rst:1977
msgid ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"

#: ../../c-api/typeobj.rst:1988
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr "一个指向用于设置和删除描述器值的函数的选项指针。"

#: ../../c-api/typeobj.rst:1993
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"

#: ../../c-api/typeobj.rst:1995
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "将 *value* 参数设为 ``NULL`` 以删除该值。"

#: ../../c-api/typeobj.rst:2006
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr "虽然此字段仍然受到支持，但是如果可能就应当改用 :c:macro:`Py_TPFLAGS_MANAGED_DICT`。"

#: ../../c-api/typeobj.rst:2009
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by "
":c:func:`PyObject_GenericGetAttr`."
msgstr ""
"如果该类型的实例具有一个包含实例变量的字典，则此字段将为非零值并包含该实例变量字典的类型的实例的偏移量；该偏移量将由 "
":c:func:`PyObject_GenericGetAttr` 使用。"

#: ../../c-api/typeobj.rst:2014
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr "不要将该字段与 :c:member:`~PyTypeObject.tp_dict` 混淆；后者是由类型对象本身的属性组成的字典。"

#: ../../c-api/typeobj.rst:2017
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr "该值指定字典相对实例结构体开始位置的偏移量。"

#: ../../c-api/typeobj.rst:2019
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call "
":c:func:`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict`"
" may need to allocate memory for the dictionary, so it is may be more "
"efficient to call :c:func:`PyObject_GetAttr` when accessing an attribute on "
"the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` 应当被视为是只读的。 用于获取指向字典调用 "
":c:func:`PyObject_GenericGetDict` 的指针。 调用 :c:func:`PyObject_GenericGetDict` "
"可能需要为字典分配内存，因此在访问对象上的属性时调用 :c:func:`PyObject_GetAttr` 可能会更有效率。"

#: ../../c-api/typeobj.rst:2025
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and "
":c:member:`~PyTypeObject.tp_dictoffset`."
msgstr ""
"同时设置 :c:macro:`Py_TPFLAGS_MANAGED_DICT` 位和 "
":c:member:`~PyTypeObject.tp_dictoffset` 将导致报错。"

#: ../../c-api/typeobj.rst:2030
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use "
":c:macro:`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""
"该字段会被子类型所继承。 子类型不应重写这个偏移量；这样做是不安全的，如果 C 代码试图在之前的偏移量上访问字典的话。 要正确地支持继承，请使用 "
":c:macro:`Py_TPFLAGS_MANAGED_DICT`。"

#: ../../c-api/typeobj.rst:2037
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"这个槽位没有默认值。 对于 :ref:`静态类型 <static-types>`，如果该字段为 ``NULL`` 则不会为实例创建 "
":attr:`~object.__dict__`。"

#: ../../c-api/typeobj.rst:2040
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, then "
":c:member:`~PyTypeObject.tp_dictoffset` will be set to ``-1``, to indicate "
"that it is unsafe to use this field."
msgstr ""
"如果在 :c:member:`~PyTypeObject.tp_flags` 字段中设置了 "
":c:macro:`Py_TPFLAGS_MANAGED_DICT` 比特位，则 "
":c:member:`~PyTypeObject.tp_dictoffset` 将被设为 ``-1``，以表明使用该字段是不安全的。"

#: ../../c-api/typeobj.rst:2048
msgid "An optional pointer to an instance initialization function."
msgstr "一个可选的指向实例初始化函数的指针。"

#: ../../c-api/typeobj.rst:2050
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of classes."
"  Like :meth:`!__init__`, it is possible to create an instance without "
"calling :meth:`!__init__`, and it is possible to reinitialize an instance by"
" calling its :meth:`!__init__` method again."
msgstr ""
"此函数对应于类的 :meth:`~object.__init__` 方法。 和 :meth:`!__init__` 一样，创建实例时不调用 "
":meth:`!__init__` 是有可能的，并且通过再次调用实例的 :meth:`!__init__` 方法将其重新初始化也是有可能的。"

#: ../../c-api/typeobj.rst:2057
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:2059
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to "
":meth:`~object.__init__`."
msgstr ""
"self 参数是将要初始化的实例；*args* 和 *kwds* 参数代表调用 :meth:`~object.__init__` "
"时传入的位置和关键字参数。"

#: ../../c-api/typeobj.rst:2063
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's "
":c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no "
":c:member:`~PyTypeObject.tp_init` function is called; if "
":c:member:`~PyTypeObject.tp_new` returns an instance of a subtype of the "
"original type, the subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
":c:member:`~PyTypeObject.tp_init` 函数如果不为 ``NULL``，将在通过调用类型正常创建其实例时被调用，即在类型的 "
":c:member:`~PyTypeObject.tp_new` 函数返回一个该类型的实例时。 如果 "
":c:member:`~PyTypeObject.tp_new` 函数返回了一个不是原始类型的子类型的其他类型的实例，则 "
":c:member:`~PyTypeObject.tp_init` 函数不会被调用；如果 "
":c:member:`~PyTypeObject.tp_new` 返回了一个原始类型的子类型的实例，则该子类型的 "
":c:member:`~PyTypeObject.tp_init` 将被调用。"

#: ../../c-api/typeobj.rst:2070
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"成功时返回 ``0``，发生错误时则返回 ``-1`` 并在错误上设置一个异常。and sets an exception on error."

#: ../../c-api/typeobj.rst:2078
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr "对于 :ref:`静态类型 <static-types>` 来说该字段没有默认值。"

#: ../../c-api/typeobj.rst:2083
msgid "An optional pointer to an instance allocation function."
msgstr "指向一个实例分配函数的可选指针。"

#: ../../c-api/typeobj.rst:2087
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"

#: ../../c-api/typeobj.rst:2091
msgid ""
"Static subtypes inherit this slot, which will be "
":c:func:`PyType_GenericAlloc` if inherited from :class:`object`."
msgstr ""
"静态子类型继承此槽位，如果从 :class:`object` 继承，则此槽位为 :c:func:`PyType_GenericAlloc`。"

#: ../../c-api/typeobj.rst:2094 ../../c-api/typeobj.rst:2161
msgid ":ref:`Heap subtypes <heap-types>` do not inherit this slot."
msgstr ":ref:`堆子类型 <heap-types>` 不继承此槽位。"

#: ../../c-api/typeobj.rst:2098
msgid ""
"For heap subtypes, this field is always set to "
":c:func:`PyType_GenericAlloc`."
msgstr "对于堆子类型，此字段始终设置为 :c:func:`PyType_GenericAlloc`。"

#: ../../c-api/typeobj.rst:2101 ../../c-api/typeobj.rst:2169
msgid "For static subtypes, this slot is inherited (see above)."
msgstr "对于静态子类型，此槽位是继承的（见上文）。"

#: ../../c-api/typeobj.rst:2106
msgid "An optional pointer to an instance creation function."
msgstr "一个可选的指向实例创建函数的指针。"

#: ../../c-api/typeobj.rst:2110
msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:2112
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose "
":c:member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"*subtype* 参数是被创建的对象的类型；*args* 和 *kwds* 参数表示调用类型时传入的位置和关键字参数。 请注意 *subtype* "
"不是必须与被调用的 :c:member:`~PyTypeObject.tp_new` "
"函数所属的类型相同；它可以是该类型的子类型（但不能是完全无关的类型）。"

#: ../../c-api/typeobj.rst:2118
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call "
"``subtype->tp_alloc(subtype, nitems)`` to allocate space for the object, and"
" then do only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that"
" for immutable types, all initialization should take place in "
":c:member:`~PyTypeObject.tp_new`, while for mutable types, most "
"initialization should be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
":c:member:`~PyTypeObject.tp_new` 函数应当调用 ``subtype->tp_alloc(subtype, "
"nitems)`` 来为对象分配空间，然后只执行绝对有必要的进一步初始化操作。 可以安全地忽略或重复的初始化操作应当放在 "
":c:member:`~PyTypeObject.tp_init` 处理器中。 一个关键的规则是对于不可变类型来说，所有初始化操作都应当在 "
":c:member:`~PyTypeObject.tp_new` 中发生，而对于可变类型，大部分初始化操作都应当推迟到 "
":c:member:`~PyTypeObject.tp_init` 再执行。"

#: ../../c-api/typeobj.rst:2126
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"设置 :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` 旗标以禁止在 Python 中创建该类型的实例。"

#: ../../c-api/typeobj.rst:2131
msgid ""
"This field is inherited by subtypes, except it is not inherited by "
":ref:`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` "
"is ``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"该字段会被子类型所继承，例外情况是它不会被 :c:member:`~PyTypeObject.tp_base` 为 ``NULL`` 或 "
"``&PyBaseObject_Type`` 的 :ref:`静态类型 <static-types>` 所继承。"

#: ../../c-api/typeobj.rst:2137
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means"
" if the slot is defined as ``NULL``, the type cannot be called to create new"
" instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"对于 :ref:`静态类型 <static-types>` 该字段没有默认值。 这意味着如果槽位被定义为 "
"``NULL``，则无法调用此类型来创建新的实例；应当存在 其他办法来创建实例，例如工厂函数等。"

#: ../../c-api/typeobj.rst:2145
msgid ""
"An optional pointer to an instance deallocation function.  Its signature "
"is::"
msgstr "一个可选的指向实例释放函数的指针。 函数的签名为::"

#: ../../c-api/typeobj.rst:2147
msgid "void tp_free(void *self);"
msgstr "void tp_free(void *self);"

#: ../../c-api/typeobj.rst:2149
msgid ""
"This function must free the memory allocated by "
":c:member:`~PyTypeObject.tp_alloc`."
msgstr "此函数必须释放由 :c:member:`~PyTypeObject.tp_alloc` 分配的内存。"

#: ../../c-api/typeobj.rst:2154
msgid ""
"Static subtypes inherit this slot, which will be :c:func:`PyObject_Free` if "
"inherited from :class:`object`.  Exception: If the type supports garbage "
"collection (i.e., the :c:macro:`Py_TPFLAGS_HAVE_GC` flag is set in "
":c:member:`~PyTypeObject.tp_flags`) and it would inherit "
":c:func:`PyObject_Free`, then this slot is not inherited but instead "
"defaults to :c:func:`PyObject_GC_Del`."
msgstr ""
"静态子类型继承此槽位，如果从 :class:`object` 继承，则此槽位为 "
":c:func:`PyObject_Free`。例外情况：如果类型支持垃圾回收（即 :c:member:`~PyTypeObject.tp_flags`"
" 中设置了 :c:macro:`Py_TPFLAGS_HAVE_GC` 标志），并且它将继承 "
":c:func:`PyObject_Free`，则此槽位不继承，而是默认为 :c:func:`PyObject_GC_Del`。"

#: ../../c-api/typeobj.rst:2165
msgid ""
"For :ref:`heap subtypes <heap-types>`, this slot defaults to a deallocator "
"suitable to match :c:func:`PyType_GenericAlloc` and the value of the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"对于 :ref:`堆子类型 <heap-types>`，此槽位默认为一个适合匹配 :c:func:`PyType_GenericAlloc` 和 "
":c:macro:`Py_TPFLAGS_HAVE_GC` 标志值的释放器。"

#: ../../c-api/typeobj.rst:2174
msgid "An optional pointer to a function called by the garbage collector."
msgstr "可选的指向垃圾回收器所调用的函数的指针。"

#: ../../c-api/typeobj.rst:2176
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of "
"statically and dynamically allocated instances, and the statically allocated"
" instances are not collectible.  Such types should define this function; it "
"should return ``1`` for a collectible instance, and ``0`` for a non-"
"collectible instance. The signature is::"
msgstr ""
"垃圾回收器需要知道某个特定的对象是否可以被回收。在一般情况下，垃圾回收器只需要检查这个对象类型的 "
":c:member:`~PyTypeObject.tp_flags` 字段、以及 :c:macro:`Py_TPFLAGS_HAVE_GC` "
"标识位即可做出判断；但是有一些类型同时混合包含了静态和动态分配的实例，其中静态分配的实例不应该也无法被回收。本函数为后者情况而设计：对于可被垃圾回收的实例，本函数应当返回"
" ``1`` ；对于不可被垃圾回收的实例，本函数应当返回 ``0`` 。函数的签名为::"

#: ../../c-api/typeobj.rst:2184
msgid "int tp_is_gc(PyObject *self);"
msgstr "int tp_is_gc(PyObject *self);"

#: ../../c-api/typeobj.rst:2186
msgid ""
"(The only example of this are types themselves.  The metatype, "
":c:data:`PyType_Type`, defines this function to distinguish between "
"statically and :ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"（此对象的唯一样例是类型本身。 元类型 :c:data:`PyType_Type` 定义了该函数来区分静态和 :ref:`动态分配的类型 <heap-"
"types>`。）"

#: ../../c-api/typeobj.rst:2196
msgid ""
"This slot has no default.  If this field is ``NULL``, "
":c:macro:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"此槽位没有默认值。 如果该字段为 ``NULL``，则将使用 :c:macro:`Py_TPFLAGS_HAVE_GC` 作为相同功能的替代。"

#: ../../c-api/typeobj.rst:2202
msgid "Tuple of base types."
msgstr "基类型的元组。"

#: ../../c-api/typeobj.rst:2204 ../../c-api/typeobj.rst:2228
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"此字段应当被设为 ``NULL`` 并被视为只读。 Python 将在类型 :c:func:`初始化时 <PyType_Ready>` 填充它。"

#: ../../c-api/typeobj.rst:2207
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of "
":c:func:`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"对于动态创建的类，可以使用 ``Py_tp_bases`` :c:type:`槽位 <PyType_Slot>` 来代替 "
":c:func:`PyType_FromSpecWithBases` 的 *bases* 参数。 推荐使用参数形式。"

#: ../../c-api/typeobj.rst:2214
msgid ""
"Multiple inheritance does not work well for statically defined types. If you"
" set ``tp_bases`` to a tuple, Python will not raise an error, but some slots"
" will only be inherited from the first base."
msgstr ""
"多重继承不适合静态定义的类型。 如果你将 ``tp_bases`` 设为一个元组，Python 将不会引发错误，但某些槽位将只从第一个基类型继承。"

#: ../../c-api/typeobj.rst:2220 ../../c-api/typeobj.rst:2243
#: ../../c-api/typeobj.rst:2260 ../../c-api/typeobj.rst:2277
#: ../../c-api/typeobj.rst:2291
msgid "This field is not inherited."
msgstr "这个字段不会被继承。"

#: ../../c-api/typeobj.rst:2225
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr "包含基类型的扩展集的元组，以类型本身开始并以 :class:`object` 作为结束，使用方法解析顺序。"

#: ../../c-api/typeobj.rst:2233
msgid ""
"This field is not inherited; it is calculated fresh by "
":c:func:`PyType_Ready`."
msgstr "这个字段不会被继承；它是通过 :c:func:`PyType_Ready` 计算得到的。"

#: ../../c-api/typeobj.rst:2239
msgid "Unused.  Internal use only."
msgstr "尚未使用。 仅供内部使用。"

#: ../../c-api/typeobj.rst:2248
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr "一组子类。 仅限内部使用的。 可能为无效的指针。"

#: ../../c-api/typeobj.rst:2250
msgid ""
"To get a list of subclasses, call the Python method "
":py:meth:`~type.__subclasses__`."
msgstr "要获取子类的列表，则调用 Python 方法 :py:meth:`~type.__subclasses__`。"

#: ../../c-api/typeobj.rst:2255
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr "对于某些类型，该字段将不带有效的 :c:expr:`PyObject*`。 类型已被改为 :c:expr:`void*` 以指明这一点。"

#: ../../c-api/typeobj.rst:2265
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr "弱引用列表头，用于指向该类型对象的弱引用。 不会被继承。 仅限内部使用。"

#: ../../c-api/typeobj.rst:2270
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even"
" if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""
"内部细节：对于静态内置类型这将总是为 ``NULL``，即使添加了弱引用也是如此。 每个弱引用都转而保存在 ``PyInterpreterState``"
" 上。 请使用公共 C-API 或内部 ``_PyObject_GET_WEAKREFS_LISTPTR()`` 宏来避免此差异。"

#: ../../c-api/typeobj.rst:2282
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` "
"instead."
msgstr "该字段已被弃用。 请改用 :c:member:`~PyTypeObject.tp_finalize`。"

#: ../../c-api/typeobj.rst:2287
msgid "Used to index into the method cache.  Internal use only."
msgstr "用于索引至方法缓存。 仅限内部使用。"

#: ../../c-api/typeobj.rst:2296
msgid ""
"An optional pointer to an instance finalization function.  This is the C "
"implementation of the :meth:`~object.__del__` special method.  Its signature"
" is::"
msgstr "一个可选的指向实例终结函数的指针。这是 :meth:`~object.__del__` 特殊方法的 C 实现。其签名如下::"

#: ../../c-api/typeobj.rst:2300
msgid "void tp_finalize(PyObject *self);"
msgstr "void tp_finalize(PyObject *self);"

#: ../../c-api/typeobj.rst:2302
msgid ""
"The primary purpose of finalization is to perform any non-trivial cleanup "
"that must be performed before the object is destroyed, while the object and "
"any other objects it directly or indirectly references are still in a "
"consistent state.  The finalizer is allowed to execute arbitrary Python "
"code."
msgstr ""
"终结器的主要目的是在对象被销毁之前执行任何必须进行的非平凡的清理工作——此时对象及其直接或间接引用的任何其他对象仍处于一致状态。终结器允许执行任意的Python代码。"

#: ../../c-api/typeobj.rst:2308
msgid ""
"Before Python automatically finalizes an object, some of the object's direct"
" or indirect referents might have themselves been automatically finalized. "
"However, none of the referents will have been automatically cleared "
"(:c:member:`~PyTypeObject.tp_clear`) yet."
msgstr ""
"在Python自动终结一个对象之前，该对象的一些直接或间接引用对象可能已经自动终结。然而，这些引用对象尚未被自动清除（:c:member:`~PyTypeObject.tp_clear`）。"

#: ../../c-api/typeobj.rst:2313
msgid ""
"Other non-finalized objects might still be using a finalized object, so the "
"finalizer must leave the object in a sane state (e.g., invariants are still "
"met)."
msgstr "其他未终结的对象可能仍在使用已终结的对象，因此终结器必须确保该对象保持合理状态（例如，仍满足所有不变式条件）。"

#: ../../c-api/typeobj.rst:2319
msgid ""
"After Python automatically finalizes an object, Python might start "
"automatically clearing (:c:member:`~PyTypeObject.tp_clear`) the object and "
"its referents (direct and indirect).  Cleared objects are not guaranteed to "
"be in a consistent state; a finalized object must be able to tolerate "
"cleared referents."
msgstr ""
"在Python自动终结一个对象之后，Python可能会开始自动清除（:c:member:`~PyTypeObject.tp_clear`）该对象及其（直接和间接）引用对象。被清除的对象不保证处于一致状态；已终结的对象必须能够容忍被清除的引用对象。"

#: ../../c-api/typeobj.rst:2327
msgid ""
"An object is not guaranteed to be automatically finalized before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called.  It is "
"recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the "
"beginning of :c:member:`!tp_dealloc` to guarantee that the object is always "
"finalized before destruction."
msgstr ""
"不保证在对象的析构函数（:c:member:`~PyTypeObject.tp_dealloc`）被调用之前自动终结对象。建议在 "
":c:member:`!tp_dealloc` 的开始处调用 "
":c:func:`PyObject_CallFinalizerFromDealloc`，以确保在销毁之前总是终结对象。"

#: ../../c-api/typeobj.rst:2335
msgid ""
"The :c:member:`~PyTypeObject.tp_finalize` function can be called from any "
"thread, although the :term:`GIL` will be held."
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` 函数可以从任何线程调用，尽管 :term:`GIL` 会被持有。"

#: ../../c-api/typeobj.rst:2340
msgid ""
"The :c:member:`!tp_finalize` function can be called during shutdown, after "
"some global variables have been deleted.  See the documentation of the "
":meth:`~object.__del__` method for details."
msgstr ""
":c:member:`!tp_finalize` 函数可以在关闭过程中调用，此时一些全局变量可能已被删除。 详见 "
":meth:`~object.__del__` 方法的文档。"

#: ../../c-api/typeobj.rst:2344
msgid ""
"When Python finalizes an object, it behaves like the following algorithm:"
msgstr "当Python终结一个对象时，其行为类似于以下算法："

#: ../../c-api/typeobj.rst:2346
msgid ""
"Python might mark the object as *finalized*.  Currently, Python always marks"
" objects whose type supports garbage collection (i.e., the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag is set in "
":c:member:`~PyTypeObject.tp_flags`) and never marks other types of objects; "
"this might change in a future version."
msgstr ""
"Python可能会将对象标记为 "
"*已终结*。目前，Python总是标记那些其类型支持垃圾收集的对象（即，:c:macro:`Py_TPFLAGS_HAVE_GC` 标志在 "
":c:member:`~PyTypeObject.tp_flags` 中设置）并且从不标记其他类型的对象；这一点在未来版本中可能会改变。"

#: ../../c-api/typeobj.rst:2351
msgid ""
"If the object is not marked as *finalized* and its :c:member:`!tp_finalize` "
"finalizer function is non-``NULL``, the finalizer function is called."
msgstr ""
"如果对象未被标记为 *已终结* 且其 :c:member:`!tp_finalize` 终结器函数不为 ``NULL``，则会调用该终结器函数。"

#: ../../c-api/typeobj.rst:2354
msgid ""
"If the finalizer function was called and the finalizer made the object "
"reachable (i.e., there is a reference to the object and it is not a member "
"of a :term:`cyclic isolate`), then the finalizer is said to have "
"*resurrected* the object.  It is unspecified whether the finalizer can also "
"resurrect the object by adding a new reference to the object that does not "
"make it reachable, i.e., the object is (still) a member of a cyclic isolate."
msgstr ""
"如果终结器函数被调用并且终结器使对象变得可达（即，存在对该对象的引用且它不是 :term:`cyclic isolate` 的成员），则称终结器 "
"*复活* 了该对象。若终结器通过添加新引用使对象变为可达（但该对象仍属于某个循环隔离），则是否算作复活行为是未定义的。"

#: ../../c-api/typeobj.rst:2361
msgid ""
"If the finalizer resurrected the object, the object's pending destruction is"
" canceled and the object's *finalized* mark might be removed if present.  "
"Currently, Python never removes the *finalized* mark; this might change in a"
" future version."
msgstr ""
"如果终结器复活了对象，对象的待销毁状态将被取消，并且如果存在，对象的 *已终结* 标记可能会被移除。目前，Python从不移除 *已终结* "
"标记；这一点在未来版本中可能会改变。"

#: ../../c-api/typeobj.rst:2366
msgid ""
"*Automatic finalization* refers to any finalization performed by Python "
"except via calls to :c:func:`PyObject_CallFinalizer` or "
":c:func:`PyObject_CallFinalizerFromDealloc`.  No guarantees are made about "
"when, if, or how often an object is automatically finalized, except:"
msgstr ""
"*自动终结* 指的是由Python执行的任何终结操作，但不包括通过调用 :c:func:`PyObject_CallFinalizer` 或 "
":c:func:`PyObject_CallFinalizerFromDealloc` "
"进行的终结。关于对象何时、是否或多久被自动终结一次，没有任何保证，除了："

#: ../../c-api/typeobj.rst:2371
msgid ""
"Python will not automatically finalize an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr "如果对象是可达的，即存在对它的引用且它不是 :term:`cyclic isolate` 的成员，Python 不会自动终结该对象。"

#: ../../c-api/typeobj.rst:2374
msgid ""
"Python will not automatically finalize an object if finalizing it would not "
"mark the object as *finalized*.  Currently, this applies to objects whose "
"type does not support garbage collection, i.e., the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag is not set.  Such objects can still be "
"manually finalized by calling :c:func:`PyObject_CallFinalizer` or "
":c:func:`PyObject_CallFinalizerFromDealloc`."
msgstr ""
"如果终结对象不会将其标记为 *已终结*，Python也不会自动终结该对象。目前，这适用于那些其类型不支持垃圾收集的对象，即 "
":c:macro:`Py_TPFLAGS_HAVE_GC` 标志未设置。此类对象仍然可以通过调用 "
":c:func:`PyObject_CallFinalizer` 或 "
":c:func:`PyObject_CallFinalizerFromDealloc` 进行手动终结。"

#: ../../c-api/typeobj.rst:2380
msgid ""
"Python will not automatically finalize any two members of a :term:`cyclic "
"isolate` concurrently."
msgstr "Python 不会自动并发地终结 :term:`cyclic isolate` 的任意两个成员。"

#: ../../c-api/typeobj.rst:2382
msgid ""
"Python will not automatically finalize an object after it has automatically "
"cleared (:c:member:`~PyTypeObject.tp_clear`) the object."
msgstr "Python 不会在自动清除（:c:member:`~PyTypeObject.tp_clear`）对象后自动终结该对象。"

#: ../../c-api/typeobj.rst:2384
msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically finalize it after automatically clearing (see "
":c:member:`~PyTypeObject.tp_clear`) any other member."
msgstr ""
"如果一个对象是 :term:`cyclic isolate` 的成员，Python 不会在自动清除 (参见 "
":c:member:`~PyTypeObject.tp_clear`) 其他成员后自动终结它。"

#: ../../c-api/typeobj.rst:2387
msgid ""
"Python will automatically finalize every member of a :term:`cyclic isolate` "
"before it automatically clears (see :c:member:`~PyTypeObject.tp_clear`) any "
"of them."
msgstr ""
"Python 会在自动清除 (参见 :c:member:`~PyTypeObject.tp_clear`) 任何成员之前，自动终结 "
":term:`cyclic isolate` 的所有成员。"

#: ../../c-api/typeobj.rst:2390
msgid ""
"If Python is going to automatically clear an object "
"(:c:member:`~PyTypeObject.tp_clear`), it will automatically finalize the "
"object first."
msgstr "如果 Python 将要自动清除一个对象（:c:member:`~PyTypeObject.tp_clear`），它将首先自动终结该对象。"

#: ../../c-api/typeobj.rst:2394
msgid ""
"Python currently only automatically finalizes objects that are members of a "
":term:`cyclic isolate`, but future versions might finalize objects regularly"
" before their destruction."
msgstr ""
"目前 Python 只会自动终结属于 :term:`cyclic isolate` 的成员对象，但未来版本可能会在对象销毁前常规性地终结对象。"

#: ../../c-api/typeobj.rst:2398
msgid ""
"To manually finalize an object, do not call this function directly; call "
":c:func:`PyObject_CallFinalizer` or "
":c:func:`PyObject_CallFinalizerFromDealloc` instead."
msgstr ""
"要手动终结一个对象，请勿直接调用此函数；而应调用 :c:func:`PyObject_CallFinalizer` 或 "
":c:func:`PyObject_CallFinalizerFromDealloc`。"

#: ../../c-api/typeobj.rst:2402
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should leave the current exception "
"status unchanged.  The recommended way to write a non-trivial finalizer is "
"to back up the exception at the beginning by calling "
":c:func:`PyErr_GetRaisedException` and restore the exception at the end by "
"calling :c:func:`PyErr_SetRaisedException`.  If an exception is encountered "
"in the middle of the finalizer, log and clear it with "
":c:func:`PyErr_WriteUnraisable` or :c:func:`PyErr_FormatUnraisable`.  For "
"example::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` 应保持当前异常状态不变。编写非平凡终结器的推荐方法是，在开始时通过调用 "
":c:func:`PyErr_GetRaisedException` 备份异常，并在结束时通过调用 "
":c:func:`PyErr_SetRaisedException` 恢复异常。如果在终结器中间遇到异常，请使用 "
":c:func:`PyErr_WriteUnraisable` 或 :c:func:`PyErr_FormatUnraisable` "
"记录并清除它。例如："

#: ../../c-api/typeobj.rst:2411
msgid ""
"static void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // Save the current exception, if any.\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // Restore the saved exception.  This silently discards any exception\n"
"    // raised above, so be sure to call PyErr_WriteUnraisable first if\n"
"    // necessary.\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // 保存当前异常（如果有）。\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // 恢复保存的异常。这将静默丢弃上述任何异常，\n"
"    // 因此在必要时请先调用 PyErr_WriteUnraisable。\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:2439
msgid ""
"Before version 3.8 it was necessary to set the "
":c:macro:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be "
"used.  This is no longer required."
msgstr ""
"在 3.8 版之前必须设置 :c:macro:`Py_TPFLAGS_HAVE_FINALIZE` 标志信才能让该字段被使用。 现在已不再需要这样做。"

#: ../../c-api/typeobj.rst:2445
msgid ":pep:`442`: \"Safe object finalization\""
msgstr ":pep:`442`: \"安全对象终结\""

#: ../../c-api/typeobj.rst:2448
msgid ":c:func:`PyObject_CallFinalizer`"
msgstr ":c:func:`PyObject_CallFinalizer`"

#: ../../c-api/typeobj.rst:2449
msgid ":c:func:`PyObject_CallFinalizerFromDealloc`"
msgstr ":c:func:`PyObject_CallFinalizerFromDealloc`"

#: ../../c-api/typeobj.rst:2454
msgid ""
"A :ref:`vectorcall function <vectorcall>` to use for calls of this type "
"object (rather than instances). In other words, ``tp_vectorcall`` can be "
"used to optimize ``type.__call__``, which typically returns a new instance "
"of *type*."
msgstr ""
"用于此类型对象（而不是实例）调用的 :ref:`vectorcall 函数 <vectorcall>`。 换句话说，``tp_vectorcall`` "
"可以用来优化 ``type.__call__``，这通常会返回 *type* 的新实例。"

#: ../../c-api/typeobj.rst:2459
msgid ""
"As with any vectorcall function, if ``tp_vectorcall`` is ``NULL``, the "
"*tp_call* protocol (``Py_TYPE(type)->tp_call``) is used instead."
msgstr ""
"与任何 vectorcall 函数一样，如果 ``tp_vectorcall`` 为 ``NULL``，则使用 *tp_call* "
"协议（``Py_TYPE(type)->tp_call``）。"

#: ../../c-api/typeobj.rst:2464
msgid ""
"The :ref:`vectorcall protocol <vectorcall>` requires that the vectorcall "
"function has the same behavior as the corresponding ``tp_call``. This means "
"that ``type->tp_vectorcall`` must match the behavior of "
"``Py_TYPE(type)->tp_call``."
msgstr ""
":ref:`vectorcall 协议 <vectorcall>` 要求 vectorcall 函数具有与相应的 ``tp_call`` "
"相同的行为。这意味着 ``type->tp_vectorcall`` 必须与 ``Py_TYPE(type)->tp_call`` 的行为相匹配。"

#: ../../c-api/typeobj.rst:2469
msgid ""
"Specifically, if *type* uses the default metaclass, ``type->tp_vectorcall`` "
"must behave the same as :c:expr:`PyType_Type->tp_call`, which:"
msgstr ""
"具体来说，如果 *type* 使用默认的元类，``type->tp_vectorcall`` 的行为必须与 "
":c:expr:`PyType_Type->tp_call` 相同："

#: ../../c-api/typeobj.rst:2473
msgid "calls ``type->tp_new``,"
msgstr "调用 ``type->tp_new``，"

#: ../../c-api/typeobj.rst:2475
msgid ""
"if the result is a subclass of *type*, calls ``type->tp_init`` on the result"
" of ``tp_new``, and"
msgstr "当结果是 *type* 的子类时，将在 ``tp_new`` 的结果上调用 ``type->tp_init``，并且"

#: ../../c-api/typeobj.rst:2478
msgid "returns the result of ``tp_new``."
msgstr "返回 ``tp_new`` 的结果。"

#: ../../c-api/typeobj.rst:2480
msgid ""
"Typically, ``tp_vectorcall`` is overridden to optimize this process for "
"specific :c:member:`~PyTypeObject.tp_new` and "
":c:member:`~PyTypeObject.tp_init`. When doing this for user-subclassable "
"types, note that both can be overridden (using :py:func:`~object.__new__` "
"and :py:func:`~object.__init__`, respectively)."
msgstr ""
"通常，``tp_vectorcall`` 会被重写以针对特定的 :c:member:`~PyTypeObject.tp_new` 和 "
":c:member:`~PyTypeObject.tp_init` 优化此进程。当为可被用户子类化的类型上这样做时，请注意两者都可被重写 (分别使用 "
":py:func:`~object.__new__` 和 :py:func:`~object.__init__`)。"

#: ../../c-api/typeobj.rst:2491
msgid "This field is never inherited."
msgstr "这个字段不会被继承。"

#: ../../c-api/typeobj.rst:2493
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "（这个字段从 3.8 起即存在，但是从 3.9 开始投入使用）"

#: ../../c-api/typeobj.rst:2498
msgid "Internal. Do not use."
msgstr "内部对象。 请勿使用。"

#: ../../c-api/typeobj.rst:2506
msgid "Static Types"
msgstr "静态类型"

#: ../../c-api/typeobj.rst:2508
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static "
":c:type:`PyTypeObject` structure is defined directly in code and initialized"
" using :c:func:`PyType_Ready`."
msgstr ""
"在传统上，在 C 代码中定义的类型都是 *静态的*，也就是说，:c:type:`PyTypeObject` 结构体在代码中直接定义并使用 "
":c:func:`PyType_Ready` 来初始化。"

#: ../../c-api/typeobj.rst:2512
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr "这就导致了与在 Python 中定义的类型相关联的类型限制："

#: ../../c-api/typeobj.rst:2514
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr "静态类型只能拥有一个基类；换句话说，他们不能使用多重继承。"

#: ../../c-api/typeobj.rst:2516
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr "静态类型对象（但并非它们的实例）是不可变对象。 不可能在 Python 中添加或修改类型对象的属性。"

#: ../../c-api/typeobj.rst:2518
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"静态类型对象是跨 :ref:`子解释器 <sub-interpreter-support>` 共享的，因此它们不应包括任何子解释器专属的状态。"

#: ../../c-api/typeobj.rst:2522
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"此外，由于 :c:type:`PyTypeObject` 只是作为不透明结构的 :ref:`受限 API <limited-c-api>` "
"的一部分，因此任何使用静态类型的扩展模块都必须针对特定的 Python 次版本进行编译。"

#: ../../c-api/typeobj.rst:2530
msgid "Heap Types"
msgstr "堆类型"

#: ../../c-api/typeobj.rst:2532
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the "
":c:macro:`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"一种 :ref:`静态类型的 <static-types>` 替代物是 *堆分配类型*，或者简称 *堆类型*，它与使用 Python 的 "
"``class`` 语句创建的类紧密对应。 堆类型设置了 :c:macro:`Py_TPFLAGS_HEAPTYPE` 旗标。"

#: ../../c-api/typeobj.rst:2537
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling "
":c:func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, "
":c:func:`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
"这是通过填充 :c:type:`PyType_Spec` 结构体并调用 :c:func:`PyType_FromSpec`, "
":c:func:`PyType_FromSpecWithBases`, :c:func:`PyType_FromModuleAndSpec` 或 "
":c:func:`PyType_FromMetaclass` 来实现的。"

#: ../../c-api/typeobj.rst:2545
msgid "Number Object Structures"
msgstr "数字对象结构体"

#: ../../c-api/typeobj.rst:2552
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr "该结构体持有指向被对象用来实现数字协议的函数的指针。 每个函数都被 :ref:`number` 一节中记录的对应名称的函数所使用。"

#: ../../c-api/typeobj.rst:2558 ../../c-api/typeobj.rst:2882
msgid "Here is the structure definition::"
msgstr "结构体定义如下::"

#: ../../c-api/typeobj.rst:2560
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"

#: ../../c-api/typeobj.rst:2605
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"双目和三目函数必须检查其所有操作数的类型，并实现必要的转换（至少有一个操作数是所定义类型的实例）。 "
"如果没有为所给出的操作数定义操作，则双目和三目函数必须返回 ``Py_NotImplemented``，如果发生了其他错误则它们必须返回 "
"``NULL`` 并设置一个异常。"

#: ../../c-api/typeobj.rst:2614
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in"
" Python 3.0.1."
msgstr ""
":c:member:`~PyNumberMethods.nb_reserved` 字段应当始终为 ``NULL``。 在之前版本中其名称为 "
":c:member:`!nb_long`，并在 Python 3.0.1 中改名。"

#: ../../c-api/typeobj.rst:2659
msgid "Mapping Object Structures"
msgstr "映射对象结构体"

#: ../../c-api/typeobj.rst:2666
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr "该结构体持有指向对象用于实现映射协议的函数的指针。 它有三个成员："

#: ../../c-api/typeobj.rst:2671
msgid ""
"This function is used by :c:func:`PyMapping_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  This slot may be set "
"to ``NULL`` if the object has no defined length."
msgstr ""
"该函数将被 :c:func:`PyMapping_Size` 和 :c:func:`PyObject_Size` 使用，并具有相同的签名。 "
"如果对象没有定义长度则此槽位可被设为 ``NULL``。"

#: ../../c-api/typeobj.rst:2677
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and "
":c:func:`PySequence_GetSlice`, and has the same signature as "
":c:func:`!PyObject_GetItem`.  This slot must be filled for the "
":c:func:`PyMapping_Check` function to return ``1``, it can be ``NULL`` "
"otherwise."
msgstr ""
"该函数将被 :c:func:`PyObject_GetItem` 和 :c:func:`PySequence_GetSlice` 使用，并具有与 "
":c:func:`!PyObject_GetItem` 相同的签名。 此槽位必须被填充以便 :c:func:`PyMapping_Check` 函数返回"
" ``1``，否则它可以为 ``NULL``。"

#: ../../c-api/typeobj.rst:2685
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, "
":c:func:`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and "
":c:func:`PySequence_DelSlice`.  It has the same signature as "
":c:func:`!PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete "
"an item.  If this slot is ``NULL``, the object does not support item "
"assignment and deletion."
msgstr ""
"该函数将被 :c:func:`PyObject_SetItem`, :c:func:`PyObject_DelItem`, "
":c:func:`PySequence_SetSlice` 和 :c:func:`PySequence_DelSlice` 使用。 它具有与 "
":c:func:`!PyObject_SetItem` 相同的签名，但 *v* 也可以被设为 ``NULL`` 以删除一个条目。 如果此槽位为 "
"``NULL``，则对象将不支持条目赋值和删除。"

#: ../../c-api/typeobj.rst:2696
msgid "Sequence Object Structures"
msgstr "序列对象结构体"

#: ../../c-api/typeobj.rst:2703
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr "该结构体持有指向对象用于实现序列协议的函数的指针。"

#: ../../c-api/typeobj.rst:2708
msgid ""
"This function is used by :c:func:`PySequence_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  It is also used for "
"handling negative indices via the :c:member:`~PySequenceMethods.sq_item` and"
" the :c:member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"此函数被 :c:func:`PySequence_Size` 和 :c:func:`PyObject_Size` 所使用，并具有与它们相同的签名。 "
"它还被用于通过 :c:member:`~PySequenceMethods.sq_item` 和 "
":c:member:`~PySequenceMethods.sq_ass_item` 槽位来处理负索引号。"

#: ../../c-api/typeobj.rst:2715
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"此函数被 :c:func:`PySequence_Concat` 所使用并具有相同的签名。 在尝试通过 "
":c:member:`~PyNumberMethods.nb_add` 槽位执行数值相加之后它还会被用于 ``+`` 运算符。"

#: ../../c-api/typeobj.rst:2721
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"此函数被 :c:func:`PySequence_Repeat` 所使用并具有相同的签名。 在尝试通过 "
":c:member:`~PyNumberMethods.nb_multiply` 槽位执行数值相乘之后它还会被用于 ``*`` 运算符。"

#: ../../c-api/typeobj.rst:2727
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"此函数被 :c:func:`PySequence_GetItem` 所使用并具有相同的签名。 在尝试通过 "
":c:member:`~PyMappingMethods.mp_subscript` 槽位执行下标操作之后它还会被用于 "
":c:func:`PyObject_GetItem`。 该槽位必须被填充以便 :c:func:`PySequence_Check` 函数返回 "
"``1``，否则它可以为 ``NULL``。"

#: ../../c-api/typeobj.rst:2733
msgid ""
"Negative indexes are handled as follows: if the "
":c:member:`~PySequenceMethods.sq_length` slot is filled, it is called and "
"the sequence length is used to compute a positive index which is passed to  "
":c:member:`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is "
"``NULL``, the index is passed as is to the function."
msgstr ""
"负索引号是按如下方式处理的：如果 :c:member:`~PySequenceMethods.sq_length` "
"槽位已被填充，它将被调用并使用序列长度来计算出正索引号并传给 :c:member:`~PySequenceMethods.sq_item`。 如果 "
":c:member:`!sq_length` 为 ``NULL``，索引号将原样传给此函数。"

#: ../../c-api/typeobj.rst:2740
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and "
":c:func:`PyObject_DelItem`, after trying the item assignment and deletion "
"via the :c:member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may "
"be left to ``NULL`` if the object does not support item assignment and "
"deletion."
msgstr ""
"此函数被 :c:func:`PySequence_SetItem` 所使用并具有相同的签名。 在尝试通过 "
":c:member:`~PyMappingMethods.mp_ass_subscript` 槽位执行条目赋值和删除操作之后它还会被用于 "
":c:func:`PyObject_SetItem` 和 :c:func:`PyObject_DelItem`。 "
"如果对象不支持条目和删除则该槽位可以保持为 ``NULL``。"

#: ../../c-api/typeobj.rst:2749
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case "
":c:func:`!PySequence_Contains` simply traverses the sequence until it finds "
"a match."
msgstr ""
"该函数可供 :c:func:`PySequence_Contains` 使用并具有相同的签名。 此槽位可以保持为 ``NULL``，在此情况下 "
":c:func:`!PySequence_Contains` 只需遍历该序列直到找到一个匹配。"

#: ../../c-api/typeobj.rst:2756
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same"
" signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the "
":c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"此函数被 :c:func:`PySequence_InPlaceConcat` 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 "
"该槽位可以保持为 ``NULL``，在此情况下 :c:func:`!PySequence_InPlaceConcat` 将回退到 "
":c:func:`PySequence_Concat`。 在尝试通过 "
":c:member:`~PyNumberMethods.nb_inplace_add` 槽位执行数字原地相加之后它还会被用于增强赋值运算符 "
"``+=``。"

#: ../../c-api/typeobj.rst:2765
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same"
" signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"此函数被 :c:func:`PySequence_InPlaceRepeat` 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 "
"该槽位可以保持为 ``NULL``，在此情况下 :c:func:`!PySequence_InPlaceRepeat` 将回退到 "
":c:func:`PySequence_Repeat`。 在尝试通过 "
":c:member:`~PyNumberMethods.nb_inplace_multiply` 槽位执行数字原地相乘之后它还会被用于增强赋值运算符 "
"``*=``。"

#: ../../c-api/typeobj.rst:2776
msgid "Buffer Object Structures"
msgstr "缓冲区对象结构体"

#: ../../c-api/typeobj.rst:2784
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"此结构体持有指向 :ref:`缓冲区协议 <bufferobjects>` 所需要的函数的指针。 "
"该协议定义了导出方对象要如何向消费方对象暴露其内部数据。"

#: ../../c-api/typeobj.rst:2790 ../../c-api/typeobj.rst:2839
#: ../../c-api/typeobj.rst:2893 ../../c-api/typeobj.rst:2904
#: ../../c-api/typeobj.rst:2916 ../../c-api/typeobj.rst:2926
msgid "The signature of this function is::"
msgstr "此函数的签名为::"

#: ../../c-api/typeobj.rst:2792
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr "int (PyObject *exporter, Py_buffer *view, int flags);"

#: ../../c-api/typeobj.rst:2794
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr "处理发给 *exporter* 的请求来填充 *flags* 所指定的 *view*。 除第 (3) 点外，此函数的实现必须执行以下步骤："

#: ../../c-api/typeobj.rst:2798
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set "
":c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"检查请求是否能被满足。 如果不能，则会引发 :exc:`BufferError`，将 :c:expr:`view->obj` 设为 ``NULL`` "
"并返回 ``-1``。"

#: ../../c-api/typeobj.rst:2801
msgid "Fill in the requested fields."
msgstr "填充请求的字段。"

#: ../../c-api/typeobj.rst:2803
msgid "Increment an internal counter for the number of exports."
msgstr "递增用于保存导出次数的内部计数器。"

#: ../../c-api/typeobj.rst:2805
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr "将 :c:expr:`view->obj` 设为 *exporter* 并递增 :c:expr:`view->obj`。"

#: ../../c-api/typeobj.rst:2807
msgid "Return ``0``."
msgstr "返回 ``0``。"

#: ../../c-api/typeobj.rst:2809
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr "如果 *exporter* 是缓冲区提供方的链式或树型结构的一部分，则可以使用两种主要方案："

#: ../../c-api/typeobj.rst:2812
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets "
":c:expr:`view->obj` to a new reference to itself."
msgstr "重导出：树型结构的每个成员作为导出对象并将 :c:expr:`view->obj` 设为对其自身的新引用。"

#: ../../c-api/typeobj.rst:2815
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr "重定向：缓冲区请求将被重定向到树型结构的根对象。 在此，:c:expr:`view->obj` 将为对根对象的新引用。"

#: ../../c-api/typeobj.rst:2819
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"*view* 中每个字段的描述参见 :ref:`缓冲区结构体 <buffer-structure>` 一节，导出方对于特定请求应当如何反应参见 "
":ref:`缓冲区请求类型 <buffer-request-types>` 一节。"

#: ../../c-api/typeobj.rst:2824
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. "
":c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` and "
":c:member:`~Py_buffer.internal` are read-only for the consumer."
msgstr ""
"所有在 :c:type:`Py_buffer` 结构体中被指向的内存都属于导出方并必须保持有效直到不再有任何消费方。 "
":c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` 和 "
":c:member:`~Py_buffer.internal` 对于消费方来说是只读的。"

#: ../../c-api/typeobj.rst:2831
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ":c:func:`PyBuffer_FillInfo` 提供了一种暴露简单字节缓冲区同时正确处理地所有请求类型的简便方式。"

#: ../../c-api/typeobj.rst:2834
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ":c:func:`PyObject_GetBuffer` 是针对包装此函数的消费方的接口。"

#: ../../c-api/typeobj.rst:2841
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr "void (PyObject *exporter, Py_buffer *view);"

#: ../../c-api/typeobj.rst:2843
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"处理释放缓冲区资源的请求。 如果不需要释放任何资源，则 :c:member:`PyBufferProcs.bf_releasebuffer` 可以为 "
"``NULL``。 在其他情况下，此函数的标准实现将执行以下的可选步骤："

#: ../../c-api/typeobj.rst:2848
msgid "Decrement an internal counter for the number of exports."
msgstr "递减用于保存导出次数的内部计数器。"

#: ../../c-api/typeobj.rst:2850
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "如果计数器为 ``0``，则释放所有关联到 *view* 的内存。"

#: ../../c-api/typeobj.rst:2852
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"导出方必须使用 :c:member:`~Py_buffer.internal` 字段来记录缓冲区专属的资源。 "
"该字段将确保恒定，而消费方则可能将原始缓冲区作为 *view* 参数传入。"

#: ../../c-api/typeobj.rst:2858
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"此函数不可递减 :c:expr:`view->obj`，因为这是在 :c:func:`PyBuffer_Release` "
"中自动完成的（此方案适用于打破循环引用）。"

#: ../../c-api/typeobj.rst:2863
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this"
" function."
msgstr ":c:func:`PyBuffer_Release` 是针对包装此函数的消费方的接口。"

#: ../../c-api/typeobj.rst:2871
msgid "Async Object Structures"
msgstr "异步对象结构体"

#: ../../c-api/typeobj.rst:2879
msgid ""
"This structure holds pointers to the functions required to implement "
":term:`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"此结构体将持有指向需要用来实现 :term:`awaitable` 和 :term:`asynchronous iterator` 对象的函数的指针。"

#: ../../c-api/typeobj.rst:2884
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"

#: ../../c-api/typeobj.rst:2895
msgid "PyObject *am_await(PyObject *self);"
msgstr "PyObject *am_await(PyObject *self);"

#: ../../c-api/typeobj.rst:2897
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check`"
" must return ``1`` for it."
msgstr "返回的对象必须为 :term:`iterator`，即对其执行 :c:func:`PyIter_Check` 必须返回 ``1``。"

#: ../../c-api/typeobj.rst:2900
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr "如果一个对象不是 :term:`awaitable` 则此槽位可被设为 ``NULL``。"

#: ../../c-api/typeobj.rst:2906
msgid "PyObject *am_aiter(PyObject *self);"
msgstr "PyObject *am_aiter(PyObject *self);"

#: ../../c-api/typeobj.rst:2908
msgid ""
"Must return an :term:`asynchronous iterator` object. See "
":meth:`~object.__anext__` for details."
msgstr ""
"必须返回一个 :term:`asynchronous iterator` 对象。 请参阅 :meth:`~object.__anext__` 了解详情。"

#: ../../c-api/typeobj.rst:2911
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr "如果一个对象没有实现异步迭代协议则此槽位可被设为 ``NULL``。"

#: ../../c-api/typeobj.rst:2918
msgid "PyObject *am_anext(PyObject *self);"
msgstr "PyObject *am_anext(PyObject *self);"

#: ../../c-api/typeobj.rst:2920
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"必须返回一个 :term:`awaitable` 对象。 请参阅 :meth:`~object.__anext__` 了解详情。 此槽位可被设为 "
"``NULL``。"

#: ../../c-api/typeobj.rst:2928
msgid ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"

#: ../../c-api/typeobj.rst:2930
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr "请参阅 :c:func:`PyIter_Send` 了解详情。 此槽位可被设为 ``NULL``。"

#: ../../c-api/typeobj.rst:2939
msgid "Slot Type typedefs"
msgstr "槽位类型 typedef"

#: ../../c-api/typeobj.rst:2943
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate"
" length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and "
":c:member:`~PyObject.ob_type` set to the type argument.  If the type's "
":c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's "
":c:member:`~PyVarObject.ob_size` field should be initialized to *nitems* and"
" the length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be "
":c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"此函数的设计目标是将内存分配与内存初始化进行分离。 它应当返回一个指向足够容纳实例长度，适当对齐，并初始化为零的内存块的指针，但将 "
":c:member:`~PyObject.ob_refcnt` 设为 ``1`` 并将 :c:member:`~PyObject.ob_type` 设为"
" type 参数。 如果类型的 :c:member:`~PyTypeObject.tp_itemsize` 为非零值，则对象的 "
":c:member:`~PyVarObject.ob_size` 字段应当被初始化为 *nitems* 而分配内存块的长度应为 "
"``tp_basicsize + nitems*tp_itemsize``，并舍入到 ``sizeof(void*)`` "
"的倍数；在其他情况下，*nitems* 将不会被使用而内存块的长度应为 :c:member:`~PyTypeObject.tp_basicsize`。"

#: ../../c-api/typeobj.rst:2953
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by "
":c:member:`~PyTypeObject.tp_new`."
msgstr ""
"此函数不应执行任何其他实例初始化操作，即使是分配额外内存也不应执行；那应当由 :c:member:`~PyTypeObject.tp_new` 来完成。"

#: ../../c-api/typeobj.rst:2960
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "参见 :c:member:`~PyTypeObject.tp_free`。"

#: ../../c-api/typeobj.rst:2964
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "参见 :c:member:`~PyTypeObject.tp_new`。"

#: ../../c-api/typeobj.rst:2968
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "参见 :c:member:`~PyTypeObject.tp_init`。"

#: ../../c-api/typeobj.rst:2972
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "参见 :c:member:`~PyTypeObject.tp_repr`。"

#: ../../c-api/typeobj.rst:2976 ../../c-api/typeobj.rst:2985
msgid "Return the value of the named attribute for the object."
msgstr "返回对象的指定属性的值。"

#: ../../c-api/typeobj.rst:2980 ../../c-api/typeobj.rst:2991
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr "为对象设置指定属性的值。 将 value 参数设为 ``NULL`` 将删除该属性。"

#: ../../c-api/typeobj.rst:2987
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "参见 :c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:2994
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "参见 :c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:2998
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "参见 :c:member:`~PyTypeObject.tp_descr_get`。"

#: ../../c-api/typeobj.rst:3002
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "参见 :c:member:`~PyTypeObject.tp_descr_set`。"

#: ../../c-api/typeobj.rst:3006
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "参见 :c:member:`~PyTypeObject.tp_hash`。"

#: ../../c-api/typeobj.rst:3010
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "参见 :c:member:`~PyTypeObject.tp_richcompare`。"

#: ../../c-api/typeobj.rst:3014
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "参见 :c:member:`~PyTypeObject.tp_iter`。"

#: ../../c-api/typeobj.rst:3018
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "参见 :c:member:`~PyTypeObject.tp_iternext`。"

#: ../../c-api/typeobj.rst:3032
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "参见 :c:member:`~PyAsyncMethods.am_send`。"

#: ../../c-api/typeobj.rst:3048
msgid "Examples"
msgstr "例子"

#: ../../c-api/typeobj.rst:3050
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types`"
" and :ref:`new-types-topics`."
msgstr ""
"下面是一些 Python 类型定义的简单示例。 其中包括你可能会遇到的通常用法。 有些演示了令人困惑的边际情况。 "
"要获取更多示例、实践信息以及教程，请参阅 :ref:`defining-new-types` 和 :ref:`new-types-topics`。"

#: ../../c-api/typeobj.rst:3055
msgid "A basic :ref:`static type <static-types>`::"
msgstr "一个基本的 :ref:`静态类型 <static-types>`::"

#: ../../c-api/typeobj.rst:3057
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:3072
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr "你可能还会看到带有更繁琐的初始化器的较旧代码（特别是在 CPython 代码库中）::"

#: ../../c-api/typeobj.rst:3075
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"

#: ../../c-api/typeobj.rst:3116
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "一个支持弱引用、实例字典和哈希运算的类型::"

#: ../../c-api/typeobj.rst:3118
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"

#: ../../c-api/typeobj.rst:3141
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using "
":c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"一个不能被子类化且不能被调用以使用 :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` "
"旗标创建实例（例如使用单独的工厂函数）的 str 子类::"

#: ../../c-api/typeobj.rst:3145
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:3160
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr "最简单的固定长度实例 :ref:`静态类型 <static-types>`::"

#: ../../c-api/typeobj.rst:3162
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"

#: ../../c-api/typeobj.rst:3171
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr "最简单的具有可变长度实例的 :ref:`静态类型 <static-types>`::"

#: ../../c-api/typeobj.rst:3173
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"

#: ../../c-api/typeobj.rst:912 ../../c-api/typeobj.rst:977
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/typeobj.rst:912
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:977
msgid "hash"
msgstr "hash"
