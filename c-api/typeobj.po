# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2021
# nick <2330458484@qq.com>, 2021
# ruoyu zhang <ruoyu0088@gmail.com>, 2021
# 文博 周 <zhouwenbonwpu@mail.nwpu.edu.cn>, 2021
# WH-2099 <wh2099@outlook.com>, 2021
# Lu <lu2github@gmail.com>, 2022
# ww song <sww4718168@gmail.com>, 2022
# chime z <chimez@163.com>, 2022
# 高乐喆 <gaolezhe@outlook.com>, 2023
# Shan Su, 2023
# Bryan不可思议, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# Dai Xu <daixu61@hotmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-28 14:13+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "类型对象"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` structure."
"  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so"
" they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Python 对象系统中最重要的一个结构体也许是定义新类型的结构体: :c:type:`PyTypeObject` 结构体。 类型对象可以使用任何 "
"``PyObject_*`` 或 ``PyType_*`` 函数来处理，但并未提供大多数 Python 应用程序会感兴趣的东西。 "
"这些对象是对象行为的基础，所以它们对解释器本身及任何实现新类型的扩展模块都非常重要。"

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of"
" the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存储了大量的值，大部分是C函数指针，每个指针实现了类型功能的一小部分。本节将详细描述类型对象的字段。这些字段将按照它们在结构中出现的顺序进行描述。"

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of "
":c:type:`PyTypeObject`."
msgstr ""
"除了下面的快速参考， :ref:`typedef-examples` 小节提供了快速了解 :c:type:`PyTypeObject` "
"的含义和用法的例子。"

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "快速参考"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp_方法槽\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject 槽 [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "特殊方法/属性"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "信息 [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:70
#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:90
#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:103
#: ../../c-api/typeobj.rst:105 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:109 ../../c-api/typeobj.rst:111
#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:117
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:416 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:346
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:370
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:375
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:368
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:404
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:440
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:381
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:386
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:350
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:429
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:406
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:412
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:414
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:0
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134 ../../c-api/typeobj.rst:136
#: ../../c-api/typeobj.rst:140 ../../c-api/typeobj.rst:341
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:356
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:368
#: ../../c-api/typeobj.rst:368 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:370 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:381
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:392 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:404 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:406
#: ../../c-api/typeobj.rst:412 ../../c-api/typeobj.rst:412
#: ../../c-api/typeobj.rst:414 ../../c-api/typeobj.rst:414
#: ../../c-api/typeobj.rst:416 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:431 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:435
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:440
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:446
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:392
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:398
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:362
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:341
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:356
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:348
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138 ../../c-api/typeobj.rst:279
#: ../../c-api/typeobj.rst:346 ../../c-api/typeobj.rst:348
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:429
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:150
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

#: ../../c-api/typeobj.rst:150
msgid "char"
msgstr "char"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr "**（）**：括号中的插槽名称表示（实际上）已弃用。"

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr "**<>**: 尖括号内的名称在初始时应设为 ``NULL`` 并被视为是只读的。"

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: 方括号内的名称仅供内部使用。"

#: ../../c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr "**<R>** (作为前缀) 表示字段是必需的 (不能是 ``NULL``)。"

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "列："

#: ../../c-api/typeobj.rst:166
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**:  在 :c:data:`PyBaseObject_Type` 上设置"

#: ../../c-api/typeobj.rst:168
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**:  在 :c:data:`PyType_Type` 上设置"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: 默认设置(如果方法槽被设置为NULL)"

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: 继承"

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr "注意，有些方法槽是通过普通属性查找链有效继承的。"

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "子方法槽（方法域）"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "方法槽"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "特殊方法"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:431
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:435
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:416
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:462
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:446
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:451
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:457
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:336
msgid "slot typedefs"
msgstr "槽位 typedef"

#: ../../c-api/typeobj.rst:339
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:339
msgid "Parameter Types"
msgstr "参数类型"

#: ../../c-api/typeobj.rst:339
msgid "Return Type"
msgstr "返回类型"

#: ../../c-api/typeobj.rst:346 ../../c-api/typeobj.rst:348
#: ../../c-api/typeobj.rst:424
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:350 ../../c-api/typeobj.rst:362
#: ../../c-api/typeobj.rst:375 ../../c-api/typeobj.rst:386
#: ../../c-api/typeobj.rst:398 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:418
#: ../../c-api/typeobj.rst:429 ../../c-api/typeobj.rst:451
#: ../../c-api/typeobj.rst:457 ../../c-api/typeobj.rst:462
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:404
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:418
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:424
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:469
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "请参阅 :ref:`slot-typedefs` 里有更多详细信息。"

#: ../../c-api/typeobj.rst:473
msgid "PyTypeObject Definition"
msgstr "PyTypeObject 定义"

#: ../../c-api/typeobj.rst:475
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in "
":file:`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
":c:type:`PyTypeObject` 的结构定义可以在 :file:`Include/object.h` 中找到。 "
"为了方便参考，此处复述了其中的定义:"

#: ../../c-api/typeobj.rst:485
msgid "PyObject Slots"
msgstr "PyObject 槽位"

#: ../../c-api/typeobj.rst:487
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The "
":c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by"
" :c:func:`!type_new`, usually called from a class statement). Note that "
":c:data:`PyType_Type` (the metatype) initializes "
":c:member:`~PyTypeObject.tp_itemsize`, which means that its instances (i.e. "
"type objects) *must* have the :c:member:`~PyVarObject.ob_size` field."
msgstr ""

#: ../../c-api/typeobj.rst:496
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type"
" objects <static-types>`, the type's instances (objects whose "
":c:member:`~PyObject.ob_type` points back to the type) do *not* count as "
"references.  But for :ref:`dynamically allocated type objects <heap-types>`,"
" the instances *do* count as references."
msgstr ""

#: ../../c-api/typeobj.rst:503 ../../c-api/typeobj.rst:526
#: ../../c-api/typeobj.rst:548 ../../c-api/typeobj.rst:562
#: ../../c-api/typeobj.rst:606 ../../c-api/typeobj.rst:649
#: ../../c-api/typeobj.rst:707 ../../c-api/typeobj.rst:748
#: ../../c-api/typeobj.rst:765 ../../c-api/typeobj.rst:782
#: ../../c-api/typeobj.rst:800 ../../c-api/typeobj.rst:824
#: ../../c-api/typeobj.rst:841 ../../c-api/typeobj.rst:853
#: ../../c-api/typeobj.rst:865 ../../c-api/typeobj.rst:898
#: ../../c-api/typeobj.rst:916 ../../c-api/typeobj.rst:936
#: ../../c-api/typeobj.rst:957 ../../c-api/typeobj.rst:983
#: ../../c-api/typeobj.rst:1002 ../../c-api/typeobj.rst:1018
#: ../../c-api/typeobj.rst:1056 ../../c-api/typeobj.rst:1067
#: ../../c-api/typeobj.rst:1077 ../../c-api/typeobj.rst:1087
#: ../../c-api/typeobj.rst:1101 ../../c-api/typeobj.rst:1119
#: ../../c-api/typeobj.rst:1142 ../../c-api/typeobj.rst:1157
#: ../../c-api/typeobj.rst:1170 ../../c-api/typeobj.rst:1192
#: ../../c-api/typeobj.rst:1236 ../../c-api/typeobj.rst:1257
#: ../../c-api/typeobj.rst:1276 ../../c-api/typeobj.rst:1306
#: ../../c-api/typeobj.rst:1328 ../../c-api/typeobj.rst:1354
#: ../../c-api/typeobj.rst:1422 ../../c-api/typeobj.rst:1489
#: ../../c-api/typeobj.rst:1550 ../../c-api/typeobj.rst:1586
#: ../../c-api/typeobj.rst:1611 ../../c-api/typeobj.rst:1634
#: ../../c-api/typeobj.rst:1647 ../../c-api/typeobj.rst:1662
#: ../../c-api/typeobj.rst:1676 ../../c-api/typeobj.rst:1706
#: ../../c-api/typeobj.rst:1738 ../../c-api/typeobj.rst:1764
#: ../../c-api/typeobj.rst:1782 ../../c-api/typeobj.rst:1811
#: ../../c-api/typeobj.rst:1855 ../../c-api/typeobj.rst:1872
#: ../../c-api/typeobj.rst:1913 ../../c-api/typeobj.rst:1935
#: ../../c-api/typeobj.rst:1967 ../../c-api/typeobj.rst:1995
#: ../../c-api/typeobj.rst:2008 ../../c-api/typeobj.rst:2018
#: ../../c-api/typeobj.rst:2035 ../../c-api/typeobj.rst:2052
#: ../../c-api/typeobj.rst:2066 ../../c-api/typeobj.rst:2112
#: ../../c-api/typeobj.rst:2135
msgid "**Inheritance:**"
msgstr "**继承：**"

#: ../../c-api/typeobj.rst:505 ../../c-api/typeobj.rst:564
#: ../../c-api/typeobj.rst:608
msgid "This field is not inherited by subtypes."
msgstr "子类型不继承此字段。"

#: ../../c-api/typeobj.rst:510
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"这是类型的类型，换句话说就是元类型，它由宏 ``PyObject_HEAD_INIT`` 的参数来做初始化，它的值一般情况下是 "
"``&PyType_Type`` 。可是为了使动态可载入扩展模块至少在Windows上可用，编译器会报错这是一个不可用的初始化。因此按照惯例传递 "
"``NULL`` 给宏 ``PyObject_HEAD_INIT`` 并且在模块的初始化函数开始时候其他任何操作之前初始化这个字段。典型做法是这样的："

#: ../../c-api/typeobj.rst:521
msgid ""
"This should be done before any instances of the type are created. "
":c:func:`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, "
"and if so, initializes it to the :c:member:`~PyObject.ob_type` field of the "
"base class. :c:func:`PyType_Ready` will not change this field if it is non-"
"zero."
msgstr ""

#: ../../c-api/typeobj.rst:528 ../../c-api/typeobj.rst:709
#: ../../c-api/typeobj.rst:826 ../../c-api/typeobj.rst:918
#: ../../c-api/typeobj.rst:938 ../../c-api/typeobj.rst:1613
#: ../../c-api/typeobj.rst:1636 ../../c-api/typeobj.rst:1766
#: ../../c-api/typeobj.rst:1784 ../../c-api/typeobj.rst:1857
#: ../../c-api/typeobj.rst:1969 ../../c-api/typeobj.rst:2114
msgid "This field is inherited by subtypes."
msgstr "此字段会被子类型继承。"

#: ../../c-api/typeobj.rst:534
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined "
"(see the :option:`configure --with-trace-refs option <--with-trace-refs>`)."
msgstr ""
"这些字段仅在定义了宏 ``Py_TRACE_REFS`` 时存在（参阅 :option:`configure --with-trace-refs "
"option <--with-trace-refs>`）。"

#: ../../c-api/typeobj.rst:537
msgid ""
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For :ref:`statically allocated objects "
"<static-types>`, these fields always remain ``NULL``.  For :ref:`dynamically"
" allocated objects <heap-types>`, these two fields are used to link the "
"object into a doubly linked list of *all* live objects on the heap."
msgstr ""
"由 ``PyObject_HEAD_INIT`` 宏负责将它们初始化为 ``NULL`` 。对于 :ref:`静态分配的对象 <static-"
"types>`，这两个字段始终为 ``NULL`` 。对于 :ref:`动态分配的对象 <heap-"
"types>`，这两个字段用于将对象链接到堆上所有活动对象的双向链表中。"

#: ../../c-api/typeobj.rst:543
msgid ""
"This could be used for various debugging purposes; currently the only uses "
"are the :func:`sys.getobjects` function and to print the objects that are "
"still alive at the end of a run when the environment variable "
":envvar:`PYTHONDUMPREFS` is set."
msgstr ""
"它们可用于各种调试目的。目前唯一的用途是 :func:`sys.getobjects` 函数，在设置了环境变量 "
":envvar:`PYTHONDUMPREFS` 时，打印运行结束时仍然活跃的对象。"

#: ../../c-api/typeobj.rst:550
msgid "These fields are not inherited by subtypes."
msgstr "这些字段不会被子类型继承。"

#: ../../c-api/typeobj.rst:554
msgid "PyVarObject Slots"
msgstr "PyVarObject 槽位"

#: ../../c-api/typeobj.rst:558
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"对于 :ref:`静态分配的内存对象<static-types>`，它应该初始化为 0。对于 :ref:`动态分配的类型对象<heap-"
"types>`，该字段具有特殊的内部含义。"

#: ../../c-api/typeobj.rst:568
msgid "PyTypeObject Slots"
msgstr "PyTypeObject 槽"

#: ../../c-api/typeobj.rst:570
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on "
":c:data:`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as "
"defaults.)"
msgstr ""

#: ../../c-api/typeobj.rst:577
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage "
":mod:`!Q` in package :mod:`!P` should have the "
":c:member:`~PyTypeObject.tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""

#: ../../c-api/typeobj.rst:585
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just"
" be the type name, and the module name explicitly stored in the type dict as"
" the value for key ``'__module__'``."
msgstr ""
"对于 :ref:`动态分配的类型对象 <heap-types>`，这应为类型名称，而模块名称将作为 ``'__module__'`` "
"键的值显式地保存在类型字典中。"

#: ../../c-api/typeobj.rst:590
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`__module__` attribute, and everything after the "
"last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""

#: ../../c-api/typeobj.rst:596
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the "
":attr:`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to"
" pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""

#: ../../c-api/typeobj.rst:602
msgid ""
"This field must not be ``NULL``.  It is the only required field in "
":c:func:`PyTypeObject` (other than potentially "
":c:member:`~PyTypeObject.tp_itemsize`)."
msgstr ""

#: ../../c-api/typeobj.rst:614
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""

#: ../../c-api/typeobj.rst:616
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero "
":c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""

#: ../../c-api/typeobj.rst:621
msgid ""
"For a type with variable-length instances, the instances must have an "
":c:member:`~PyVarObject.ob_size` field, and the instance size is "
":c:member:`~PyTypeObject.tp_basicsize` plus N times "
":c:member:`~PyTypeObject.tp_itemsize`, where N is the \"length\" of the "
"object.  The value of N is typically stored in the instance's "
":c:member:`~PyVarObject.ob_size` field.  There are exceptions:  for example,"
" ints use a negative :c:member:`~PyVarObject.ob_size` to indicate a negative"
" number, and N is ``abs(ob_size)`` there.  Also, the presence of an "
":c:member:`~PyVarObject.ob_size` field in the instance layout doesn't mean "
"that the instance structure is variable-length (for example, the structure "
"for the list type has fixed-length instances, yet those instances have a "
"meaningful :c:member:`~PyVarObject.ob_size` field)."
msgstr ""

#: ../../c-api/typeobj.rst:632
msgid ""
"The basic size includes the fields in the instance declared by the macro "
":c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used "
"to declare the instance struct) and this in turn includes the  "
":c:member:`~PyObject._ob_prev` and :c:member:`~PyObject._ob_next` fields if "
"they are present.  This means that the only correct way to get an "
"initializer for the :c:member:`~PyTypeObject.tp_basicsize` is to use the "
"``sizeof`` operator on the struct used to declare the instance layout. The "
"basic size does not include the GC header size."
msgstr ""

#: ../../c-api/typeobj.rst:640
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of "
":c:member:`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements "
"an array of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is "
"``sizeof(double)``. It is the programmer's responsibility that "
":c:member:`~PyTypeObject.tp_basicsize` is a multiple of ``sizeof(double)`` "
"(assuming this is the alignment requirement for ``double``)."
msgstr ""

#: ../../c-api/typeobj.rst:647
msgid ""
"For any type with variable-length instances, this field must not be "
"``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:651
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a"
" subtype (though this depends on the implementation of the base type)."
msgstr ""

#: ../../c-api/typeobj.rst:659
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"指向实例析构函数的指针。除非保证类型的实例永远不会被释放（就像单例对象 ``None`` 和 ``Ellipsis`` "
"那样），否则必须定义这个函数。函数声明如下："

#: ../../c-api/typeobj.rst:665
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and "
":c:func:`Py_XDECREF` macros when the new reference count is zero.  At this "
"point, the instance is still in existence, but there are no references to "
"it.  The destructor function should free all references which the instance "
"owns, free all memory buffers owned by the instance (using the freeing "
"function corresponding to the allocation function used to allocate the "
"buffer), and call the type's :c:member:`~PyTypeObject.tp_free` function.  If"
" the type is not subtypable (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE`"
" flag bit set), it is permissible to call the object deallocator directly "
"instead of via :c:member:`~PyTypeObject.tp_free`.  The object deallocator "
"should be the one used to allocate the instance; this is normally "
":c:func:`PyObject_Del` if the instance was allocated using "
":c:macro:`PyObject_New` or :c:macro:`PyObject_NewVar`, or "
":c:func:`PyObject_GC_Del` if the instance was allocated using "
":c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""

#: ../../c-api/typeobj.rst:680
msgid ""
"If the type supports garbage collection (has the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should call "
":c:func:`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""

#: ../../c-api/typeobj.rst:692
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the"
" deallocator should decrement the reference count for its type object after "
"calling the type deallocator. In order to avoid dangling pointers, the "
"recommended way to achieve this is:"
msgstr ""

#: ../../c-api/typeobj.rst:714
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:719
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is"
" set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""

#: ../../c-api/typeobj.rst:723
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the"
" instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:727
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set "
":c:member:`~PyTypeObject.tp_call` and make sure its behaviour is consistent "
"with the *vectorcallfunc* function. This can be done by setting *tp_call* to"
" :c:func:`PyVectorcall_Call`."
msgstr ""

#: ../../c-api/typeobj.rst:734
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""

#: ../../c-api/typeobj.rst:740
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets "
":attr:`~object.__call__` in Python code, only *tp_call* is updated, likely "
"making it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""

#: ../../c-api/typeobj.rst:750
msgid ""
"This field is always inherited. However, the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's "
"not set, then the subclass won't use :ref:`vectorcall <vectorcall>`, except "
"when :c:func:`PyVectorcall_Call` is explicitly called."
msgstr ""

#: ../../c-api/typeobj.rst:759
msgid "An optional pointer to the get-attribute-string function."
msgstr "一个指向获取属性字符串函数的可选指针。"

#: ../../c-api/typeobj.rst:761
msgid ""
"This field is deprecated.  When it is defined, it should point to a function"
" that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"该字段已弃用。当它被定义时，应该和 :c:member:`~PyTypeObject.tp_getattro` "
"指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。"

#: ../../c-api/typeobj.rst:767 ../../c-api/typeobj.rst:959
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, "
":c:member:`~PyTypeObject.tp_getattro`"
msgstr ""

#: ../../c-api/typeobj.rst:769
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"该字段会被子类和 :c:member:`~PyTypeObject.tp_getattro` 所继承：当子类型的 "
":c:member:`~PyTypeObject.tp_getattr` 和 :c:member:`~PyTypeObject.tp_getattro`"
" 均为 ``NULL`` 时该子类型将从它的基类型同时继承 :c:member:`~PyTypeObject.tp_getattr` 和 "
":c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:776 ../../c-api/typeobj.rst:972
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "一个指向函数以便设置和删除属性的可选指针。"

#: ../../c-api/typeobj.rst:778
msgid ""
"This field is deprecated.  When it is defined, it should point to a function"
" that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"该字段已弃用。当它被定义时，应该和 :c:member:`~PyTypeObject.tp_setattro` "
"指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。"

#: ../../c-api/typeobj.rst:784 ../../c-api/typeobj.rst:985
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, "
":c:member:`~PyTypeObject.tp_setattro`"
msgstr ""

#: ../../c-api/typeobj.rst:786
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"该字段会被子类型和 :c:member:`~PyTypeObject.tp_setattro` 所继承：当子类型的 "
":c:member:`~PyTypeObject.tp_setattr` 和 :c:member:`~PyTypeObject.tp_setattro`"
" 均为 ``NULL`` 时该子类型将同时从它的基类型继承 :c:member:`~PyTypeObject.tp_setattr` 和 "
":c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:793
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"指向一个包含仅与在 C 层级上实现 :term:`awaitable` 和 :term:`asynchronous iterator` "
"协议的对象相关联的字段的附加结构体。 请参阅 :ref:`async-structs` 了解详情。"

#: ../../c-api/typeobj.rst:797
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "在之前被称为 ``tp_compare`` 和 ``tp_reserved``。"

#: ../../c-api/typeobj.rst:802
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_async` 字段不会被继承，但所包含的字段会被单独继承。"

#: ../../c-api/typeobj.rst:810
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`repr`."
msgstr "一个实现了内置函数 :func:`repr` 的函数的可选指针。"

#: ../../c-api/typeobj.rst:813
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "该签名与 :c:func:`PyObject_Repr` 的相同::"

#: ../../c-api/typeobj.rst:817
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not"
" feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"该函数必须返回一个字符串或 Unicode 对象。 在理想情况下，该函数应当返回一个字符串，当将其传给 :func:`eval` "
"时，只要有合适的环境，就会返回一个具有相同值的对象。 如果这不可行，则它应当返回一个以 ``'<'`` 开头并以 ``'>'`` "
"结尾的可被用来推断出对象的类型和值的字符串。"

#: ../../c-api/typeobj.rst:828 ../../c-api/typeobj.rst:940
#: ../../c-api/typeobj.rst:965 ../../c-api/typeobj.rst:991
#: ../../c-api/typeobj.rst:1032 ../../c-api/typeobj.rst:1559
#: ../../c-api/typeobj.rst:1593 ../../c-api/typeobj.rst:1710
#: ../../c-api/typeobj.rst:1743 ../../c-api/typeobj.rst:1818
#: ../../c-api/typeobj.rst:1859 ../../c-api/typeobj.rst:1877
#: ../../c-api/typeobj.rst:1919 ../../c-api/typeobj.rst:1940
#: ../../c-api/typeobj.rst:1971
msgid "**Default:**"
msgstr "**默认：**"

#: ../../c-api/typeobj.rst:830
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""

#: ../../c-api/typeobj.rst:837
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented in"
" :ref:`number-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:843
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:849
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:855
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the"
" contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:861
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:867
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:875
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`hash`."
msgstr ""

#: ../../c-api/typeobj.rst:878
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr ""

#: ../../c-api/typeobj.rst:882
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""

#: ../../c-api/typeobj.rst:886
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises "
":exc:`TypeError`. This is the same as setting it to "
":c:func:`PyObject_HashNotImplemented`."
msgstr ""

#: ../../c-api/typeobj.rst:890
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to"
" block inheritance of the hash method from a parent type. This is "
"interpreted as the equivalent of ``__hash__ = None`` at the Python level, "
"causing ``isinstance(o, collections.Hashable)`` to correctly return "
"``False``. Note that the converse is also true - setting ``__hash__ = None``"
" on a class at the Python level will result in the ``tp_hash`` slot being "
"set to :c:func:`PyObject_HashNotImplemented`."
msgstr ""

#: ../../c-api/typeobj.rst:900 ../../c-api/typeobj.rst:1552
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, "
":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ""

#: ../../c-api/typeobj.rst:902
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both of "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash`, when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:910
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same"
" as for :c:func:`PyObject_Call`::"
msgstr ""

#: ../../c-api/typeobj.rst:923
msgid ""
"An optional pointer to a function that implements the built-in operation "
":func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls "
":c:func:`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` "
"will call this handler.)"
msgstr ""

#: ../../c-api/typeobj.rst:928
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr ""

#: ../../c-api/typeobj.rst:932
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""

#: ../../c-api/typeobj.rst:942
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""

#: ../../c-api/typeobj.rst:948
msgid "An optional pointer to the get-attribute function."
msgstr ""

#: ../../c-api/typeobj.rst:950
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:954
msgid ""
"It is usually convenient to set this field to "
":c:func:`PyObject_GenericGetAttr`, which implements the normal way of "
"looking for object attributes."
msgstr ""

#: ../../c-api/typeobj.rst:961
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:967
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:974
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:978
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to "
":c:func:`PyObject_GenericSetAttr`, which implements the normal way of "
"setting object attributes."
msgstr ""

#: ../../c-api/typeobj.rst:987
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:993
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:998
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:1004
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:1010
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via "
":c:member:`~PyTypeObject.tp_as_number`, "
":c:member:`~PyTypeObject.tp_as_sequence`, "
":c:member:`~PyTypeObject.tp_as_mapping`, and "
":c:member:`~PyTypeObject.tp_as_buffer`) that were historically not always "
"present are valid; if such a flag bit is clear, the type fields it guards "
"must not be accessed and must be considered to have a zero or ``NULL`` value"
" instead."
msgstr ""

#: ../../c-api/typeobj.rst:1020
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits"
" this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` and"
" :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the "
":c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear`"
" fields in the subtype exist and have ``NULL`` values. .. XXX are most flag "
"bits *really* inherited individually?"
msgstr ""

#: ../../c-api/typeobj.rst:1034
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""

#: ../../c-api/typeobj.rst:1037
msgid "**Bit Masks:**"
msgstr ""

#: ../../c-api/typeobj.rst:1041
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the "
":c:member:`~PyTypeObject.tp_flags` field.  The macro "
":c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and *f*, "
"and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""

#: ../../c-api/typeobj.rst:1048
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this"
" case, the :c:member:`~PyObject.ob_type` field of its instances is "
"considered a reference to the type, and the type object is INCREF'ed when a "
"new instance is created, and DECREF'ed when an instance is destroyed (this "
"does not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed)."
msgstr ""

#: ../../c-api/typeobj.rst:1058 ../../c-api/typeobj.rst:1069
#: ../../c-api/typeobj.rst:1079 ../../c-api/typeobj.rst:1089
#: ../../c-api/typeobj.rst:1121
msgid "???"
msgstr "？？？"

#: ../../c-api/typeobj.rst:1063
msgid ""
"This bit is set when the type can be used as the base type of another type."
"  If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"当此类型可被用作另一个类型的基类型时该比特位将被设置。 如果该比特位被清除，则此类型将无法被子类型化（类似于 Java 中的 \"final\" 类）。"

#: ../../c-api/typeobj.rst:1074
msgid ""
"This bit is set when the type object has been fully initialized by "
":c:func:`PyType_Ready`."
msgstr "当此类型对象通过 :c:func:`PyType_Ready` 被完全实例化时该比特位将被设置。"

#: ../../c-api/typeobj.rst:1084
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr "当 :c:func:`PyType_Ready` 处在初始化此类型对象过程中时该比特位将被设置。"

#: ../../c-api/typeobj.rst:1094
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is"
" set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in section "
":ref:`supporting-cycle-detection`.  This bit also implies that the GC-"
"related fields :c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` are present in the type object."
msgstr ""

#: ../../c-api/typeobj.rst:1103 ../../c-api/typeobj.rst:1424
#: ../../c-api/typeobj.rst:1491
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`,"
" :c:member:`~PyTypeObject.tp_clear`"
msgstr ""

#: ../../c-api/typeobj.rst:1105
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the "
":c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear`"
" fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the"
" subtype and the :c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""

#: ../../c-api/typeobj.rst:1115
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""

#: ../../c-api/typeobj.rst:1126
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""

#: ../../c-api/typeobj.rst:1128
msgid "If this flag is set for ``type(meth)``, then:"
msgstr ""

#: ../../c-api/typeobj.rst:1130
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1133
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1136
msgid ""
"This flag enables an optimization for typical method calls like "
"``obj.meth()``: it avoids creating a temporary \"bound method\" object for "
"``obj.meth``."
msgstr ""

#: ../../c-api/typeobj.rst:1144
msgid ""
"This flag is never inherited by types without the "
":c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is "
"inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1150
msgid ""
"This bit indicates that instances of the class have a ``__dict__`` "
"attribute, and that the space for the dictionary is managed by the VM."
msgstr ""

#: ../../c-api/typeobj.rst:1153
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""

#: ../../c-api/typeobj.rst:1159
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""

#: ../../c-api/typeobj.rst:1165
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr ""

#: ../../c-api/typeobj.rst:1172
msgid ""
"This flag is inherited unless the "
":c:member:`~PyTypeObject.tp_weaklistoffset` field is set in a superclass."
msgstr ""

#: ../../c-api/typeobj.rst:1178
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero "
":c:member:`~PyTypeObject.tp_itemsize`."
msgstr ""

#: ../../c-api/typeobj.rst:1181
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of "
"``Py_TYPE(obj)->tp_basicsize`` (which may be different in each subclass)."
msgstr ""

#: ../../c-api/typeobj.rst:1186
msgid ""
"When setting this flag, be sure that all superclasses either use this memory"
" layout, or are not variable-sized. Python does not check this."
msgstr ""

#: ../../c-api/typeobj.rst:1194
msgid "This flag is inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1208
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their "
":c:member:`~PyTypeObject.tp_flags` set appropriately, or the code that "
"interacts with such types will behave differently depending on what kind of "
"check is used."
msgstr ""

#: ../../c-api/typeobj.rst:1219
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr "当类型结构体中存在 :c:member:`~PyTypeObject.tp_finalize` 槽位时会设置这个比特位。"

#: ../../c-api/typeobj.rst:1224
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the "
":c:member:`~PyTypeObject.tp_finalize` slot is always present in the type "
"structure."
msgstr ""
"此旗标已不再是必要的，因为解释器会假定类型结构体中总是存在 :c:member:`~PyTypeObject.tp_finalize` 槽位。"

#: ../../c-api/typeobj.rst:1232
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"当类实现了 :ref:`vectorcall 协议 <vectorcall>` 时会设置这个比特位。 请参阅 "
":c:member:`~PyTypeObject.tp_vectorcall_offset` 了解详情。"

#: ../../c-api/typeobj.rst:1238
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also "
"inherited."
msgstr "如果继承了 :c:member:`~PyTypeObject.tp_call` 则也会继承这个比特位。"

#: ../../c-api/typeobj.rst:1245
msgid ""
"This flag is now removed from a class when the class's "
":py:meth:`~object.__call__` method is reassigned."
msgstr ""

#: ../../c-api/typeobj.rst:1248
msgid "This flag can now be inherited by mutable classes."
msgstr ""

#: ../../c-api/typeobj.rst:1252
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr "不可变的类型对象会设置这个比特位：类型属性无法被设置或删除。"

#: ../../c-api/typeobj.rst:1254
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types"
" <static-types>`."
msgstr ":c:func:`PyType_Ready` 会自动对 :ref:`静态类型 <static-types>` 应用这个旗标。"

#: ../../c-api/typeobj.rst:1259
msgid "This flag is not inherited."
msgstr "这个旗标不会被继承。"

#: ../../c-api/typeobj.rst:1265
msgid ""
"Disallow creating instances of the type: set "
":c:member:`~PyTypeObject.tp_new` to NULL and don't create the ``__new__`` "
"key in the type dictionary."
msgstr ""
"不允许创建此类型的实例：将 :c:member:`~PyTypeObject.tp_new` 设为 NULL 并且不会在类型字符中创建 "
"``__new__`` 键。"

#: ../../c-api/typeobj.rst:1269
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr "这个旗标必须在创建该类型之前设置，而不是在之后。 例如，它必须在该类型调用 :c:func:`PyType_Ready` 之前被设置。"

#: ../../c-api/typeobj.rst:1272
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if "
":c:member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and "
":c:member:`~PyTypeObject.tp_new` is NULL."
msgstr ""

#: ../../c-api/typeobj.rst:1278
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""

#: ../../c-api/typeobj.rst:1285
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""

#: ../../c-api/typeobj.rst:1296
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""

#: ../../c-api/typeobj.rst:1303 ../../c-api/typeobj.rst:1325
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""

#: ../../c-api/typeobj.rst:1308
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_SEQUENCE`."
msgstr ""

#: ../../c-api/typeobj.rst:1311 ../../c-api/typeobj.rst:1333
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` —— 结构化模式匹配：规范"

#: ../../c-api/typeobj.rst:1318
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""

#: ../../c-api/typeobj.rst:1330
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_MAPPING`."
msgstr ""

#: ../../c-api/typeobj.rst:1340
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""

#: ../../c-api/typeobj.rst:1344
msgid ""
"This flag is present in header files, but is an internal feature and should "
"not be used. It will be removed in a future version of CPython"
msgstr ""

#: ../../c-api/typeobj.rst:1350
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""

#: ../../c-api/typeobj.rst:1356
msgid "This field is *not* inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:1361
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This"
" is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1366 ../../c-api/typeobj.rst:1486
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""

#: ../../c-api/typeobj.rst:1369
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a "
":c:member:`~PyTypeObject.tp_traverse` function simply calls "
":c:func:`Py_VISIT` on each of the instance's members that are Python objects"
" that the instance owns. For example, this is function "
":c:func:`!local_traverse` from the :mod:`!_thread` extension module::"
msgstr ""

#: ../../c-api/typeobj.rst:1384
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""

#: ../../c-api/typeobj.rst:1388
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""

#: ../../c-api/typeobj.rst:1393
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references"
" to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""

#: ../../c-api/typeobj.rst:1404
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to "
":c:func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""

#: ../../c-api/typeobj.rst:1408
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit "
":c:func:`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by "
"calling ``tp_traverse`` of another heap-allocated type (such as a heap-"
"allocated superclass). If they do not, the type object may not be garbage-"
"collected."
msgstr ""

#: ../../c-api/typeobj.rst:1417
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 "
"<https://bugs.python.org/issue40217>`_, doing this may lead to crashes in "
"subclasses."
msgstr ""

#: ../../c-api/typeobj.rst:1426
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if "
"they are all zero in the subtype."
msgstr ""

#: ../../c-api/typeobj.rst:1434
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1439
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken"
" together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the "
":c:member:`~PyTypeObject.tp_clear` functions of other types must be "
"sufficient to break any cycle containing a tuple.  This isn't immediately "
"obvious, and there's rarely a good reason to avoid implementing "
":c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1449
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""

#: ../../c-api/typeobj.rst:1463
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to ``NULL``.  This is"
" because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be ``NULL`` at that time, so that *self* knows the contained object "
"can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations"
" in a safe order."
msgstr ""

#: ../../c-api/typeobj.rst:1474
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""

#: ../../c-api/typeobj.rst:1480
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break"
" reference cycles, it's not necessary to clear contained objects like Python"
" strings or Python integers, which can't participate in reference cycles. On"
" the other hand, it may be convenient to clear all contained Python objects,"
" and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1493
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if "
"they are all zero in the subtype."
msgstr ""

#: ../../c-api/typeobj.rst:1501
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1505
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""

#: ../../c-api/typeobj.rst:1508
msgid ""
"The function should return the result of the comparison (usually ``Py_True``"
" or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and"
" set an exception condition."
msgstr ""

#: ../../c-api/typeobj.rst:1513
msgid ""
"The following constants are defined to be used as the third argument for "
":c:member:`~PyTypeObject.tp_richcompare` and for "
":c:func:`PyObject_RichCompare`:"
msgstr ""

#: ../../c-api/typeobj.rst:1519
msgid "Constant"
msgstr "常量"

#: ../../c-api/typeobj.rst:1519
msgid "Comparison"
msgstr "对照"

#: ../../c-api/typeobj.rst:1521
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1523
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1525
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1527
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1529
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1531
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1534
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr "定义以下宏是为了简化编写丰富的比较函数："

#: ../../c-api/typeobj.rst:1538
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""

#: ../../c-api/typeobj.rst:1544
msgid "The return value's reference count is properly incremented."
msgstr ""

#: ../../c-api/typeobj.rst:1546
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr ""

#: ../../c-api/typeobj.rst:1554
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_hash`: a subtype inherits "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:1561
msgid ""
":c:data:`PyBaseObject_Type` provides a "
":c:member:`~PyTypeObject.tp_richcompare` implementation, which may be "
"inherited.  However, if only :c:member:`~PyTypeObject.tp_hash` is defined, "
"not even the inherited function is used and instances of the type will not "
"be able to participate in any comparisons."
msgstr ""

#: ../../c-api/typeobj.rst:1570
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""

#: ../../c-api/typeobj.rst:1573
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type "
":c:expr:`PyObject*` which is initialized to ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:1580
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""

#: ../../c-api/typeobj.rst:1583
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit and"
" :c:member:`~PyTypeObject.tp_weaklist`."
msgstr ""

#: ../../c-api/typeobj.rst:1588
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should"
" not be a problem."
msgstr ""

#: ../../c-api/typeobj.rst:1595
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the "
":c:member:`~PyTypeObject.tp_dict` field, then "
":c:member:`~PyTypeObject.tp_weaklistoffset` will be set to a negative value,"
" to indicate that it is unsafe to use this field."
msgstr ""

#: ../../c-api/typeobj.rst:1603
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are "
":term:`iterable` (although sequences may be iterable without this function)."
msgstr ""

#: ../../c-api/typeobj.rst:1607
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr ""

#: ../../c-api/typeobj.rst:1618
msgid ""
"An optional pointer to a function that returns the next item in an "
":term:`iterator`. The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1623
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a "
":exc:`StopIteration` exception may or may not be set.  When another error "
"occurs, it must return ``NULL`` too.  Its presence signals that the "
"instances of this type are iterators."
msgstr ""

#: ../../c-api/typeobj.rst:1628
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""

#: ../../c-api/typeobj.rst:1632
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr ""

#: ../../c-api/typeobj.rst:1641
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1644
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1649
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1655
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMemberDef` structures, declaring regular data members (fields or "
"slots) of instances of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1659
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1664
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1670
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyGetSetDef` structures, declaring computed attributes of instances"
" of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1673
msgid ""
"For each entry in the array, an entry is added to the type's dictionary (see"
" :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1678
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1684
msgid ""
"An optional pointer to a base type from which type properties are inherited."
"  At this level, only single inheritance is supported; multiple inheritance "
"require dynamically creating a type object by calling the metatype."
msgstr ""

#: ../../c-api/typeobj.rst:1692
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators"
" like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, "
"are valid C99 address constants."
msgstr ""

#: ../../c-api/typeobj.rst:1697
msgid ""
"However, the unary '&' operator applied to a non-static variable like "
":c:func:`PyBaseObject_Type` is not required to produce an address constant."
"  Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""

#: ../../c-api/typeobj.rst:1703
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""

#: ../../c-api/typeobj.rst:1708
msgid "This field is not inherited by subtypes (obviously)."
msgstr ""

#: ../../c-api/typeobj.rst:1712
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""

#: ../../c-api/typeobj.rst:1718
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1720
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is"
" called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like "
":meth:`~object.__add__`).  Once initialization for the type has finished, "
"this field should be treated as read-only."
msgstr ""

#: ../../c-api/typeobj.rst:1728
msgid ""
"Some types may not store their dictionary in this slot. Use "
":c:func:`PyType_GetDict` to retreive the dictionary for an arbitrary type."
msgstr ""

#: ../../c-api/typeobj.rst:1734
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use "
":c:func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""

#: ../../c-api/typeobj.rst:1740
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1745
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""

#: ../../c-api/typeobj.rst:1750
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify "
":c:member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""

#: ../../c-api/typeobj.rst:1756
msgid "An optional pointer to a \"descriptor get\" function."
msgstr ""

#: ../../c-api/typeobj.rst:1758 ../../c-api/typeobj.rst:1774
#: ../../c-api/typeobj.rst:1838 ../../c-api/typeobj.rst:1868
#: ../../c-api/typeobj.rst:1892
msgid "The function signature is::"
msgstr "函数的签名为::"

#: ../../c-api/typeobj.rst:1771
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""

#: ../../c-api/typeobj.rst:1778
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr ""

#: ../../c-api/typeobj.rst:1789
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""

#: ../../c-api/typeobj.rst:1792
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by "
":c:func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:1797
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""

#: ../../c-api/typeobj.rst:1800
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr ""

#: ../../c-api/typeobj.rst:1802
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call "
":c:func:`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict`"
" may need to allocate memory for the dictionary, so it is may be more "
"efficient to call :c:func:`PyObject_GetAttr` when accessing an attribute on "
"the object."
msgstr ""

#: ../../c-api/typeobj.rst:1808
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit and"
" :c:member:`~PyTypeObject.tp_dictoffset`."
msgstr ""

#: ../../c-api/typeobj.rst:1813
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use "
":c:macro:`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""

#: ../../c-api/typeobj.rst:1820
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""

#: ../../c-api/typeobj.rst:1823
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_dict` field, then "
":c:member:`~PyTypeObject.tp_dictoffset` will be set to ``-1``, to indicate "
"that it is unsafe to use this field."
msgstr ""

#: ../../c-api/typeobj.rst:1831
msgid "An optional pointer to an instance initialization function."
msgstr ""

#: ../../c-api/typeobj.rst:1833
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of classes."
"  Like :meth:`!__init__`, it is possible to create an instance without "
"calling :meth:`!__init__`, and it is possible to reinitialize an instance by"
" calling its :meth:`!__init__` method again."
msgstr ""

#: ../../c-api/typeobj.rst:1842
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to "
":meth:`~object.__init__`."
msgstr ""

#: ../../c-api/typeobj.rst:1846
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's "
":c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no "
":c:member:`~PyTypeObject.tp_init` function is called; if "
":c:member:`~PyTypeObject.tp_new` returns an instance of a subtype of the "
"original type, the subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""

#: ../../c-api/typeobj.rst:1853
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"成功时返回 ``0``，发生错误时则返回 ``-1`` 并在错误上设置一个异常。and sets an exception on error."

#: ../../c-api/typeobj.rst:1861
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr "对于 :ref:`静态类型 <static-types>` 来说该字段没有默认值。"

#: ../../c-api/typeobj.rst:1866
msgid "An optional pointer to an instance allocation function."
msgstr "指向一个实例分配函数的可选指针。"

#: ../../c-api/typeobj.rst:1874
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""

#: ../../c-api/typeobj.rst:1879
msgid ""
"For dynamic subtypes, this field is always set to "
":c:func:`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""

#: ../../c-api/typeobj.rst:1883
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses "
":c:func:`PyType_GenericAlloc`.  That is the recommended value for all "
"statically defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1890
msgid "An optional pointer to an instance creation function."
msgstr ""

#: ../../c-api/typeobj.rst:1896
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose "
":c:member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""

#: ../../c-api/typeobj.rst:1902
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call "
"``subtype->tp_alloc(subtype, nitems)`` to allocate space for the object, and"
" then do only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that"
" for immutable types, all initialization should take place in "
":c:member:`~PyTypeObject.tp_new`, while for mutable types, most "
"initialization should be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""

#: ../../c-api/typeobj.rst:1910
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""

#: ../../c-api/typeobj.rst:1915
msgid ""
"This field is inherited by subtypes, except it is not inherited by "
":ref:`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` "
"is ``NULL`` or ``&PyBaseObject_Type``."
msgstr ""

#: ../../c-api/typeobj.rst:1921
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means"
" if the slot is defined as ``NULL``, the type cannot be called to create new"
" instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""

#: ../../c-api/typeobj.rst:1929
msgid ""
"An optional pointer to an instance deallocation function.  Its signature "
"is::"
msgstr ""

#: ../../c-api/typeobj.rst:1933
msgid ""
"An initializer that is compatible with this signature is "
":c:func:`PyObject_Free`."
msgstr ""

#: ../../c-api/typeobj.rst:1937
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""

#: ../../c-api/typeobj.rst:1942
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match "
":c:func:`PyType_GenericAlloc` and the value of the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""

#: ../../c-api/typeobj.rst:1946
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses "
":c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/typeobj.rst:1951
msgid "An optional pointer to a function called by the garbage collector."
msgstr "可选的指向垃圾回收器所调用的函数的指针。"

#: ../../c-api/typeobj.rst:1953
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of "
"statically and dynamically allocated instances, and the statically allocated"
" instances are not collectible.  Such types should define this function; it "
"should return ``1`` for a collectible instance, and ``0`` for a non-"
"collectible instance. The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1963
msgid ""
"(The only example of this are types themselves.  The metatype, "
":c:data:`PyType_Type`, defines this function to distinguish between "
"statically and :ref:`dynamically allocated types <heap-types>`.)"
msgstr ""

#: ../../c-api/typeobj.rst:1973
msgid ""
"This slot has no default.  If this field is ``NULL``, "
":c:macro:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""

#: ../../c-api/typeobj.rst:1979
msgid "Tuple of base types."
msgstr ""

#: ../../c-api/typeobj.rst:1981 ../../c-api/typeobj.rst:2005
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""

#: ../../c-api/typeobj.rst:1984
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of "
":c:func:`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""

#: ../../c-api/typeobj.rst:1991
msgid ""
"Multiple inheritance does not work well for statically defined types. If you"
" set ``tp_bases`` to a tuple, Python will not raise an error, but some slots"
" will only be inherited from the first base."
msgstr ""

#: ../../c-api/typeobj.rst:1997 ../../c-api/typeobj.rst:2020
#: ../../c-api/typeobj.rst:2037 ../../c-api/typeobj.rst:2054
#: ../../c-api/typeobj.rst:2068
msgid "This field is not inherited."
msgstr "这个字段不会被继承。"

#: ../../c-api/typeobj.rst:2002
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr "包含基类型的扩展集的元组，以类型本身开始并以 :class:`object` 作为结束，使用方法解析顺序。"

#: ../../c-api/typeobj.rst:2010
msgid ""
"This field is not inherited; it is calculated fresh by "
":c:func:`PyType_Ready`."
msgstr "这个字段不会被继承；它是通过 :c:func:`PyType_Ready` 计算得到的。"

#: ../../c-api/typeobj.rst:2016
msgid "Unused.  Internal use only."
msgstr "尚未使用。 仅供内部使用。"

#: ../../c-api/typeobj.rst:2025
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""

#: ../../c-api/typeobj.rst:2027
msgid ""
"To get a list of subclasses, call the Python method "
":py:meth:`~class.__subclasses__`."
msgstr ""

#: ../../c-api/typeobj.rst:2032
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""

#: ../../c-api/typeobj.rst:2042
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:2047
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even"
" if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""

#: ../../c-api/typeobj.rst:2059
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` "
"instead."
msgstr ""

#: ../../c-api/typeobj.rst:2064
msgid "Used to index into the method cache.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:2073
msgid ""
"An optional pointer to an instance finalization function.  Its signature "
"is::"
msgstr ""

#: ../../c-api/typeobj.rst:2077
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called"
" before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""

#: ../../c-api/typeobj.rst:2084
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""

#: ../../c-api/typeobj.rst:2101
msgid ""
"Also, note that, in a garbage collected Python, "
":c:member:`~PyTypeObject.tp_dealloc` may be called from any Python thread, "
"not just the thread which created the object (if the object becomes part of "
"a refcount cycle, that cycle might be collected by a garbage collection on "
"any thread).  This is not a problem for Python API calls, since the thread "
"on which tp_dealloc is called will own the Global Interpreter Lock (GIL). "
"However, if the object being destroyed in turn destroys objects from some "
"other C or C++ library, care should be taken to ensure that destroying those"
" objects on the thread which called tp_dealloc will not violate any "
"assumptions of the library."
msgstr ""

#: ../../c-api/typeobj.rst:2120
msgid ""
"Before version 3.8 it was necessary to set the "
":c:macro:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be "
"used.  This is no longer required."
msgstr ""

#: ../../c-api/typeobj.rst:2124
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr ""

#: ../../c-api/typeobj.rst:2129
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it"
" is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using "
":meth:`~object.__new__` and :meth:`~object.__init__` is used."
msgstr ""

#: ../../c-api/typeobj.rst:2137
msgid "This field is never inherited."
msgstr "这个字段不会被继承。"

#: ../../c-api/typeobj.rst:2139
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "（这个字段从 3.8 起即存在，但是从 3.9 开始投入使用）"

#: ../../c-api/typeobj.rst:2144
msgid "Internal. Do not use."
msgstr ""

#: ../../c-api/typeobj.rst:2152
msgid "Static Types"
msgstr ""

#: ../../c-api/typeobj.rst:2154
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static "
":c:type:`PyTypeObject` structure is defined directly in code and initialized"
" using :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:2158
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""

#: ../../c-api/typeobj.rst:2160
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""

#: ../../c-api/typeobj.rst:2162
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""

#: ../../c-api/typeobj.rst:2164
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""

#: ../../c-api/typeobj.rst:2168
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""

#: ../../c-api/typeobj.rst:2176
msgid "Heap Types"
msgstr "堆类型"

#: ../../c-api/typeobj.rst:2178
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the "
":c:macro:`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""

#: ../../c-api/typeobj.rst:2183
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling "
":c:func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, "
":c:func:`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""

#: ../../c-api/typeobj.rst:2191
msgid "Number Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2198
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""

#: ../../c-api/typeobj.rst:2204 ../../c-api/typeobj.rst:2528
msgid "Here is the structure definition::"
msgstr ""

#: ../../c-api/typeobj.rst:2251
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""

#: ../../c-api/typeobj.rst:2260
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in"
" Python 3.0.1."
msgstr ""

#: ../../c-api/typeobj.rst:2305
msgid "Mapping Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2312
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""

#: ../../c-api/typeobj.rst:2317
msgid ""
"This function is used by :c:func:`PyMapping_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  This slot may be set "
"to ``NULL`` if the object has no defined length."
msgstr ""

#: ../../c-api/typeobj.rst:2323
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and "
":c:func:`PySequence_GetSlice`, and has the same signature as "
":c:func:`!PyObject_GetItem`.  This slot must be filled for the "
":c:func:`PyMapping_Check` function to return ``1``, it can be ``NULL`` "
"otherwise."
msgstr ""

#: ../../c-api/typeobj.rst:2331
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, "
":c:func:`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and "
":c:func:`PySequence_DelSlice`.  It has the same signature as "
":c:func:`!PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete "
"an item.  If this slot is ``NULL``, the object does not support item "
"assignment and deletion."
msgstr ""

#: ../../c-api/typeobj.rst:2342
msgid "Sequence Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2349
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""

#: ../../c-api/typeobj.rst:2354
msgid ""
"This function is used by :c:func:`PySequence_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  It is also used for "
"handling negative indices via the :c:member:`~PySequenceMethods.sq_item` and"
" the :c:member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""

#: ../../c-api/typeobj.rst:2361
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2367
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2373
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""

#: ../../c-api/typeobj.rst:2379
msgid ""
"Negative indexes are handled as follows: if the "
":c:member:`~PySequenceMethods.sq_length` slot is filled, it is called and "
"the sequence length is used to compute a positive index which is passed to  "
":c:member:`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is "
"``NULL``, the index is passed as is to the function."
msgstr ""

#: ../../c-api/typeobj.rst:2386
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and "
":c:func:`PyObject_DelItem`, after trying the item assignment and deletion "
"via the :c:member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may "
"be left to ``NULL`` if the object does not support item assignment and "
"deletion."
msgstr ""

#: ../../c-api/typeobj.rst:2395
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case "
":c:func:`!PySequence_Contains` simply traverses the sequence until it finds "
"a match."
msgstr ""

#: ../../c-api/typeobj.rst:2402
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same"
" signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the "
":c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2411
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same"
" signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2422
msgid "Buffer Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2430
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""

#: ../../c-api/typeobj.rst:2436 ../../c-api/typeobj.rst:2485
#: ../../c-api/typeobj.rst:2539 ../../c-api/typeobj.rst:2550
#: ../../c-api/typeobj.rst:2562 ../../c-api/typeobj.rst:2572
msgid "The signature of this function is::"
msgstr ""

#: ../../c-api/typeobj.rst:2440
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""

#: ../../c-api/typeobj.rst:2444
msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""

#: ../../c-api/typeobj.rst:2447
msgid "Fill in the requested fields."
msgstr ""

#: ../../c-api/typeobj.rst:2449
msgid "Increment an internal counter for the number of exports."
msgstr ""

#: ../../c-api/typeobj.rst:2451
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""

#: ../../c-api/typeobj.rst:2453
msgid "Return ``0``."
msgstr ""

#: ../../c-api/typeobj.rst:2455
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""

#: ../../c-api/typeobj.rst:2458
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets "
":c:expr:`view->obj` to a new reference to itself."
msgstr ""

#: ../../c-api/typeobj.rst:2461
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""

#: ../../c-api/typeobj.rst:2465
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""

#: ../../c-api/typeobj.rst:2470
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. "
":c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` and "
":c:member:`~Py_buffer.internal` are read-only for the consumer."
msgstr ""

#: ../../c-api/typeobj.rst:2477
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""

#: ../../c-api/typeobj.rst:2480
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""

#: ../../c-api/typeobj.rst:2489
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""

#: ../../c-api/typeobj.rst:2494
msgid "Decrement an internal counter for the number of exports."
msgstr ""

#: ../../c-api/typeobj.rst:2496
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr ""

#: ../../c-api/typeobj.rst:2498
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""

#: ../../c-api/typeobj.rst:2504
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""

#: ../../c-api/typeobj.rst:2509
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this"
" function."
msgstr ""

#: ../../c-api/typeobj.rst:2517
msgid "Async Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2525
msgid ""
"This structure holds pointers to the functions required to implement "
":term:`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""

#: ../../c-api/typeobj.rst:2543
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check`"
" must return ``1`` for it."
msgstr ""

#: ../../c-api/typeobj.rst:2546
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""

#: ../../c-api/typeobj.rst:2554
msgid ""
"Must return an :term:`asynchronous iterator` object. See "
":meth:`~object.__anext__` for details."
msgstr ""

#: ../../c-api/typeobj.rst:2557
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""

#: ../../c-api/typeobj.rst:2566
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:2576
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:2585
msgid "Slot Type typedefs"
msgstr ""

#: ../../c-api/typeobj.rst:2589
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate"
" length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and "
":c:member:`~PyObject.ob_type` set to the type argument.  If the type's "
":c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's "
":c:member:`~PyVarObject.ob_size` field should be initialized to *nitems* and"
" the length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be "
":c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""

#: ../../c-api/typeobj.rst:2599
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by "
":c:member:`~PyTypeObject.tp_new`."
msgstr ""

#: ../../c-api/typeobj.rst:2606
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "参见 :c:member:`~PyTypeObject.tp_free`。"

#: ../../c-api/typeobj.rst:2610
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "参见 :c:member:`~PyTypeObject.tp_new`。"

#: ../../c-api/typeobj.rst:2614
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "参见 :c:member:`~PyTypeObject.tp_init`。"

#: ../../c-api/typeobj.rst:2618
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "参见 :c:member:`~PyTypeObject.tp_repr`。"

#: ../../c-api/typeobj.rst:2622 ../../c-api/typeobj.rst:2631
msgid "Return the value of the named attribute for the object."
msgstr "返回对象的指定属性的值。"

#: ../../c-api/typeobj.rst:2626 ../../c-api/typeobj.rst:2637
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""

#: ../../c-api/typeobj.rst:2633
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "参见 :c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:2640
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "参见 :c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:2644
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "参见 :c:member:`~PyTypeObject.tp_descr_get`。"

#: ../../c-api/typeobj.rst:2648
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "参见 :c:member:`~PyTypeObject.tp_descr_set`。"

#: ../../c-api/typeobj.rst:2652
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "参见 :c:member:`~PyTypeObject.tp_hash`。"

#: ../../c-api/typeobj.rst:2656
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "参见 :c:member:`~PyTypeObject.tp_richcompare`。"

#: ../../c-api/typeobj.rst:2660
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "参见 :c:member:`~PyTypeObject.tp_iter`。"

#: ../../c-api/typeobj.rst:2664
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "参见 :c:member:`~PyTypeObject.tp_iternext`。"

#: ../../c-api/typeobj.rst:2678
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "参见 :c:member:`~PyAsyncMethods.am_send`。"

#: ../../c-api/typeobj.rst:2694
msgid "Examples"
msgstr "例子"

#: ../../c-api/typeobj.rst:2696
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types`"
" and :ref:`new-types-topics`."
msgstr ""
"下面是一些 Python 类型定义的简单示例。 其中包括你可能会遇到的通常用法。 有些演示了令人困惑的边际情况。 "
"要获取更多示例、实践信息以及教程，请参阅 :ref:`defining-new-types` 和 :ref:`new-types-topics`。"

#: ../../c-api/typeobj.rst:2701
msgid "A basic :ref:`static type <static-types>`::"
msgstr "一个基本的 :ref:`静态类型 <static-types>`::"

#: ../../c-api/typeobj.rst:2718
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr "你可能还会看到带有更繁琐的初始化器的较旧代码（特别是在 CPython 代码库中）::"

#: ../../c-api/typeobj.rst:2762
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "一个支持弱引用、实例字典和哈希运算的类型::"

#: ../../c-api/typeobj.rst:2787
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using "
":c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""

#: ../../c-api/typeobj.rst:2806
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr "最简单的固定长度实例 :ref:`静态类型 <static-types>`::"

#: ../../c-api/typeobj.rst:2817
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""

#: ../../c-api/typeobj.rst:808 ../../c-api/typeobj.rst:873
msgid "built-in function"
msgstr "内置函数"

#: ../../c-api/typeobj.rst:808
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:873
msgid "hash"
msgstr "hash"
