# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 汪心禾 <wangxinhe06@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Yifan Sun, 2022
# Shan Su, 2023
# ProgramRipper, 2023
# WH-2099 <wh2099@outlook.com>, 2023
# 汇民 王 <whuim@qq.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "模块对象"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"这个 C 类型实例 :c:type:`PyTypeObject` 用来表示Python中的模块类型。在 Python 程序中该实例被暴露为 "
"``types.ModuleType``。"

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This"
" function always succeeds."
msgstr "当 *p* 为模块类型的对象，或是模块子类型的对象时返回真值。该函数永远有返回值。"

#: ../../c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of "
":c:data:`PyModule_Type`.  This function always succeeds."
msgstr "当 *p* 为模块类型的对象且不是 :c:data:`PyModule_Type` 的子类型的对象时返回真值。该函数永远有返回值。"

#: ../../c-api/module.rst:40
msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. The "
"module's :attr:`!__name__`, :attr:`~module.__doc__`, "
":attr:`~module.__package__` and :attr:`~module.__loader__` attributes are "
"filled in (all but :attr:`!__name__` are set to ``None``). The caller is "
"responsible for setting a :attr:`~module.__file__` attribute."
msgstr ""
"返回一个新的模块对象，该对象的 :attr:`module.__name__` 将设为 *name*。 模块的 :attr:`!__name__`, "
":attr:`~module.__doc__`, :attr:`~module.__package__` 和 "
":attr:`~module.__loader__` 属性将被填充 (除 :attr:`!__name__` 外全都设为 ``None``)。 "
"调用方要负责设置 :attr:`~module.__file__` 属性。"

#: ../../c-api/module.rst:46 ../../c-api/module.rst:416
#: ../../c-api/module.rst:443
msgid "Return ``NULL`` with an exception set on error."
msgstr "当发生错误时将返回 ``NULL`` 并设置一个异常。"

#: ../../c-api/module.rst:50
msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to "
"``None``."
msgstr ""
"现在 :attr:`~module.__package__` 和 :attr:`~module.__loader__` 将被设为 ``None``。"

#: ../../c-api/module.rst:57
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr "这类似于 :c:func:`PyModule_NewObject`， 但其名称为 UTF-8 编码的字符串而不是 Unicode 对象。"

#: ../../c-api/module.rst:65
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"返回实现 *module* 的命名空间的字典对象；此对象与模块对象的 :attr:`~object.__dict__` 属性相同。 如果 "
"*module* 不是一个模块对象（或模块对象的子类型），则会引发 :exc:`SystemError` 并返回 ``NULL``。"

#: ../../c-api/module.rst:70
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's "
":attr:`~object.__dict__`."
msgstr ""
"建议扩展使用其他 ``PyModule_*`` 和 ``PyObject_*`` 函数而不是直接操纵模块的 "
":attr:`~object.__dict__`。"

#: ../../c-api/module.rst:81
msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not "
"provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""
"返回 *module* 的 :attr:`~module.__name__` 值。 如果模块未提供该值，或者如果它不是一个字符串，则会引发 "
":exc:`SystemError` 并返回 ``NULL``。"

#: ../../c-api/module.rst:90
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr "类似于 :c:func:`PyModule_GetNameObject` 但返回 ``'utf-8'`` 编码的名称。"

#: ../../c-api/module.rst:95
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See "
":c:member:`PyModuleDef.m_size`."
msgstr ""
"返回模块的“状态”，也就是说，返回指向在模块创建时分配的内存块的指针，或者 ``NULL``。 参见 "
":c:member:`PyModuleDef.m_size`。"

#: ../../c-api/module.rst:102
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"返回指向模块创建所使用的 :c:type:`PyModuleDef` 结构体的指针，或者如果模块不是使用结构体定义创建的则返回 ``NULL``。"

#: ../../c-api/module.rst:112
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s "
":attr:`~module.__file__` attribute.  If this is not defined, or if it is not"
" a string, raise :exc:`SystemError` and return ``NULL``; otherwise return a "
"reference to a Unicode object."
msgstr ""
"返回使用 *module* 的 :attr:`~module.__file__` 属性所加载的 *module* 所对应的文件名。 "
"如果未定义该属性，或者如果它不是一个字符串，则会引发 :exc:`SystemError` 并返回 ``NULL``；在其他情况下将返回一个指向 "
"Unicode 对象的引用。"

#: ../../c-api/module.rst:122
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr "类似于 :c:func:`PyModule_GetFilenameObject` 但会返回编码为 'utf-8' 的文件名。"

#: ../../c-api/module.rst:125
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` 对于不可编码的文件名会引发 :exc:`UnicodeEncodeError`，请改用 "
":c:func:`PyModule_GetFilenameObject`。"

#: ../../c-api/module.rst:133
msgid "Module definitions"
msgstr "模块定义"

#: ../../c-api/module.rst:135
msgid ""
"The functions in the previous section work on any module object, including "
"modules imported from Python code."
msgstr "上一节中的函数适用于任何模块对象，包括从 Python 代码导入的模块。"

#: ../../c-api/module.rst:138
msgid ""
"Modules defined using the C API typically use a *module definition*, "
":c:type:`PyModuleDef` -- a statically allocated, constant “description\" of "
"how a module should be created."
msgstr ""
"使用 C API 定义的模块通常使用一个 *模块定义*，即 :c:type:`PyModuleDef` -- "
"有关模块应当如何被创建的静态分配的、常量形式的“描述”。"

#: ../../c-api/module.rst:142
msgid ""
"The definition is usually used to define an extension's “main” module object"
" (see :ref:`extension-modules` for details). It is also used to :ref:`create"
" extension modules dynamically <moduledef-dynamic>`."
msgstr ""
"该定义通常被用来定义扩展的 “main” 模块对象（参阅 :ref:`extension-modules` 了解详情）。 它还会被用来 "
":ref:`动态创建扩展模块 <moduledef-dynamic>`。"

#: ../../c-api/module.rst:147
msgid ""
"Unlike :c:func:`PyModule_New`, the definition allows management of *module "
"state* -- a piece of memory that is allocated and cleared together with the "
"module object. Unlike the module's Python attributes, Python code cannot "
"replace or delete data stored in module state."
msgstr ""
"不同于 :c:func:`PyModule_New`，该定义管理 *模块状态* -- 一块随同模块对象被分配和清空的内存。 不同于模块的 Python "
"属性，Python 代码无法替换或删除存储在模块状态中的数据。"

#: ../../c-api/module.rst:155
msgid ""
"The module definition struct, which holds all information needed to create a"
" module object. This structure must be statically allocated (or be otherwise"
" guaranteed to be valid while any modules created from it exist). Usually, "
"there is only one variable of this type for each extension module."
msgstr ""
"模块定义结构体，它保存着创建模块对象所有的全部信息。 该结构体必须被静态地分配（或者应在自其存在起的任何模块被创建期间确保可用）。 "
"通常，每个扩展模块仅有一个该类型的变量。"

#: ../../c-api/module.rst:163
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr "始终将此成员初始化为 :c:macro:`PyModuleDef_HEAD_INIT`。"

#: ../../c-api/module.rst:167
msgid "Name for the new module."
msgstr "新模块的名称。"

#: ../../c-api/module.rst:171
msgid ""
"Docstring for the module; usually a docstring variable created with "
":c:macro:`PyDoc_STRVAR` is used."
msgstr "模块的文档字符串；一般会使用通过 :c:macro:`PyDoc_STRVAR` 创建的文档字符串变量。"

#: ../../c-api/module.rst:176
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"可以把模块的状态保存在为单个模块分配的内存区域中，使用 :c:func:`PyModule_GetState` "
"检索，而不是保存在静态全局区。这使得模块可以在多个子解释器中安全地使用。"

#: ../../c-api/module.rst:180
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the "
":c:member:`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"这个内存区域将在创建模块时根据 *m_size* 分配，并在调用 :c:member:`~PyModuleDef.m_free` "
"函数（如果存在）在取消分配模块对象时释放。"

#: ../../c-api/module.rst:184
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state."
msgstr "将其设置为非负值意味着可以重新初始化模块，并指定其状态所需的额外内存量。"

#: ../../c-api/module.rst:188
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state. Negative ``m_size`` is only "
"allowed when using :ref:`legacy single-phase initialization <single-phase-"
"initialization>` or when :ref:`creating modules dynamically <moduledef-"
"dynamic>`."
msgstr ""
"将``m_size``设置为``-1``意味着模块不支持子解析器，因为它具有全局状态。负``m_size``只允许在使用 :ref:`遗留单阶段初始化 "
"<single-phase-initialization>` 或 :ref:`动态创建模块 <moduledef-dynamic>` 时使用。"

#: ../../c-api/module.rst:194
msgid "See :PEP:`3121` for more details."
msgstr "请参阅 :PEP:`3121` 了解详情。"

#: ../../c-api/module.rst:198
msgid ""
"A pointer to a table of module-level functions, described by "
":c:type:`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr "一个指向模块函数表的指针，由 :c:type:`PyMethodDef` 描述。如果模块没有函数，可以为 ``NULL``。"

#: ../../c-api/module.rst:203
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a"
" ``{0, NULL}`` entry. When using legacy single-phase initialization, "
"*m_slots* must be ``NULL``."
msgstr ""
"由针对多阶段初始化的槽位定义组成的数组，以一个 ``{0, NULL}`` 条目结束。 当使用遗留单阶段初始化时，*m_slots* 必须为 "
"``NULL``。"

#: ../../c-api/module.rst:209
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "在 3.5 版之前，此成员总是被设为 ``NULL``，并被定义为:"

#: ../../c-api/module.rst:216
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr "在模块对象的垃圾回收遍历期间所调用的遍历函数，如果不需要则为 ``NULL``。"

#: ../../c-api/module.rst:219 ../../c-api/module.rst:234
#: ../../c-api/module.rst:255
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is"
" greater than 0 and the module state (as returned by "
":c:func:`PyModule_GetState`) is ``NULL``."
msgstr ""
"如果模块状态已被请求但尚未分配则不会调用此函数。 在模块创建之后至模块执行之前（调用 :c:data:`Py_mod_exec` 函数）就属于这种情况。"
" 更确切地说，如果 :c:member:`~PyModuleDef.m_size` 大于 0 且模块状态（由 "
":c:func:`PyModule_GetState` 返回）为 ``NULL`` 则不会调用此函数。"

#: ../../c-api/module.rst:226 ../../c-api/module.rst:247
#: ../../c-api/module.rst:262
msgid "No longer called before the module state is allocated."
msgstr "在模块状态被分配之前不再调用。"

#: ../../c-api/module.rst:231
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr "在模块对象的垃圾回收清理期间所调用的清理函数，如果不需要则为 ``NULL``。"

#: ../../c-api/module.rst:241
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called"
" before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"就像 :c:member:`PyTypeObject.tp_clear` "
"那样，这个函数并不总是在模块被释放前被调用。例如，当引用计数足以确定一个对象不再被使用时，就会直接调用 "
":c:member:`~PyModuleDef.m_free`，而不使用循环垃圾回收器。"

#: ../../c-api/module.rst:252
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr "在模块对象的释放期间所调用的函数，如果不需要则为 ``NULL``。"

#: ../../c-api/module.rst:267
msgid "Module slots"
msgstr "模块槽位"

#: ../../c-api/module.rst:273
msgid "A slot ID, chosen from the available values explained below."
msgstr "槽位 ID，从下面介绍的可用值中选择。"

#: ../../c-api/module.rst:277
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "槽位值，其含义取决于槽位 ID。"

#: ../../c-api/module.rst:281
msgid "The available slot types are:"
msgstr "可用的槽位类型是:"

#: ../../c-api/module.rst:285
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr "指定一个函数供调用以创建模块对象本身。 该槽位的 *value* 指针必须指向一个具有如下签名的函数:"

#: ../../c-api/module.rst:292
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"该函数接受一个 :py:class:`~importlib.machinery.ModuleSpec` 实例，如 :PEP:`451` "
"所定义的，以及模块定义。 它应当返回一个新的模块对象，或者设置一个错误并返回 ``NULL``。"

#: ../../c-api/module.rst:297
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr "此函数应当保持最小化。 特别地，它不应当调用任意 Python 代码，因为尝试再次导入同一个模块可能会导致无限循环。"

#: ../../c-api/module.rst:301
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "多个 ``Py_mod_create`` 槽位不能在一个模块定义中指定。"

#: ../../c-api/module.rst:304
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust"
" to their place in the module hierarchy and be imported under different "
"names through symlinks, all while sharing a single module definition."
msgstr ""
"如果未指定 ``Py_mod_create``，导入机制将使用 :c:func:`PyModule_New` 创建一个普通的模块对象。 名称是获取自 "
"*spec* 而非定义，以允许扩展模块动态地调整它们在模块层级结构中的位置并通过符号链接以不同的名称被导入，同时共享同一个模块定义。"

#: ../../c-api/module.rst:310
msgid ""
"There is no requirement for the returned object to be an instance of "
":c:type:`PyModule_Type`. Any type can be used, as long as it supports "
"setting and getting import-related attributes. However, only "
"``PyModule_Type`` instances may be returned if the ``PyModuleDef`` has "
"non-``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; non-zero ``m_size``; "
"or slots other than ``Py_mod_create``."
msgstr ""
"不要求返回的对象必须为 :c:type:`PyModule_Type` 的实例。 任何类型均可使用，只要它支持设置和获取导入相关的属性。 但是，如果 "
"``PyModuleDef`` 具有非 ``NULL`` 的 ``m_traverse``, ``m_clear``, ``m_free``；非零的 "
"``m_size``；或者 ``Py_mod_create`` 以外的槽位则只能返回 ``PyModule_Type`` 的实例。"

#: ../../c-api/module.rst:319
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr "指定一个供调用以 *执行* 模块的函数。 这造价于执行一个 Python 模块的代码：通常，此函数会向模块添加类和常量。 此函数的签名为:"

#: ../../c-api/module.rst:328
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr "如果指定了多个 ``Py_mod_exec`` 槽位，将按照它们在*m_slots*数组中出现的顺序进行处理。"

#: ../../c-api/module.rst:333 ../../c-api/module.rst:366
msgid "Specifies one of the following values:"
msgstr "指定以下的值之一:"

#: ../../c-api/module.rst:339
msgid "The module does not support being imported in subinterpreters."
msgstr "该模块不支持在子解释器中导入。"

#: ../../c-api/module.rst:343
msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"该模块支持在子解释器中导入，但是它们必须要共享主解释器的 GIL。 （参见 :ref:`isolating-extensions-howto`。）"

#: ../../c-api/module.rst:349
msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr "该模块支持在子解释器中导入，即使它们有自己的 GIL。 （参见 :ref:`isolating-extensions-howto`。）"

#: ../../c-api/module.rst:353
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr "此槽位决定在子解释器中导入此模块是否会失败。"

#: ../../c-api/module.rst:356
msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in one "
"module definition."
msgstr "在一个模块定义中不能指定多个 ``Py_mod_multiple_interpreters`` 槽位。"

#: ../../c-api/module.rst:359
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""
"如果未指定 ``Py_mod_multiple_interpreters``，则导入机制默认为 "
"``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``。"

#: ../../c-api/module.rst:372
msgid ""
"The module depends on the presence of the global interpreter lock (GIL), and"
" may access global state without synchronization."
msgstr "这个模块依赖于全局解释器锁 (GIL) 的存在，并可访问全局状态而不带同步。"

#: ../../c-api/module.rst:377
msgid "The module is safe to run without an active GIL."
msgstr "这个模块可以在不激活 GIL 的情况下安全运行。"

#: ../../c-api/module.rst:379
msgid ""
"This slot is ignored by Python builds not configured with "
":option:`--disable-gil`.  Otherwise, it determines whether or not importing "
"this module will cause the GIL to be automatically enabled. See "
":ref:`whatsnew313-free-threaded-cpython` for more detail."
msgstr ""
"这个槽位会被未配置 :option:`--disable-gil` 的 Python 构建版所忽略。 在其他情况下，它将决定导入此模块是否会导致 GIL"
" 被自动启用。 请参阅 :ref:`whatsnew313-free-threaded-cpython` 了解详情。"

#: ../../c-api/module.rst:384
msgid ""
"Multiple ``Py_mod_gil`` slots may not be specified in one module definition."
msgstr "多个 ``Py_mod_gil`` 槽位不能在一个模块定义中指定。"

#: ../../c-api/module.rst:386
msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr "如果未指定 ``Py_mod_gil``，则导入机制默认为 ``Py_MOD_GIL_USED``。"

#: ../../c-api/module.rst:395
msgid "Creating extension modules dynamically"
msgstr "动态创建扩展模块"

#: ../../c-api/module.rst:397
msgid ""
"The following functions may be used to create a module outside of an "
"extension's :ref:`initialization function <extension-export-hook>`. They are"
" also used in :ref:`single-phase initialization <single-phase-"
"initialization>`."
msgstr ""
"以下函数可用于在扩展的 :ref:`初始化函数 <extension-export-hook>` 之外创建模块。 它们也用于 :ref:`单阶段初始化 "
"<single-phase-initialization>`。"

#: ../../c-api/module.rst:404
msgid ""
"Create a new module object, given the definition in *def*. This is a macro "
"that calls :c:func:`PyModule_Create2` with *module_api_version* set to "
":c:macro:`PYTHON_API_VERSION`, or to :c:macro:`PYTHON_ABI_VERSION` if using "
"the :ref:`limited API <limited-c-api>`."
msgstr ""
"根据 *def* 中的定义创建一个新的模块对象。这是一个调用 :c:func:`PyModule_Create2` 的宏，其中 "
"*module_api_version* 设置为 :c:macro:`PYTHON_API_VERSION`，或者如果使用 :ref:`受限 API "
"<limited-c-api>`，则设置为 :c:macro:`PYTHON_ABI_VERSION`。"

#: ../../c-api/module.rst:412
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of"
" the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"创建一个新的模块对象，在参数 *def* 中给出定义，设定API版本为参数 *module_api_version* "
"。如果该版本与正在运行的解释器版本不匹配，则会触发 :exc:`RuntimeWarning`。"

#: ../../c-api/module.rst:418
msgid ""
"This function does not support slots. The :c:member:`~PyModuleDef.m_slots` "
"member of *def* must be ``NULL``."
msgstr "此函数不支持槽位。 *def* 的 :c:member:`~PyModuleDef.m_slots` 成员必须为 ``NULL``。"

#: ../../c-api/module.rst:424
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr "大多数时候应该使用 :c:func:`PyModule_Create` 代替使用此函数，除非你确定需要使用它。"

#: ../../c-api/module.rst:429
msgid ""
"This macro calls :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`, or to "
":c:macro:`PYTHON_ABI_VERSION` if using the :ref:`limited API <limited-c-"
"api>`."
msgstr ""
"这个宏调用 :c:func:`PyModule_FromDefAndSpec2`， *module_api_version* 设置为 "
":c:macro:`PYTHON_API_VERSION`，或者如果使用 :ref:`受限 API <limited-c-api>`，则设置为 "
":c:macro:`PYTHON_ABI_VERSION`。"

#: ../../c-api/module.rst:438
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec"
" *spec*, assuming the API version *module_api_version*. If that version does"
" not match the version of the running interpreter, a :exc:`RuntimeWarning` "
"is emitted."
msgstr ""
"创建一个新的模块对象，在参数 *def* 和 *spec* 中给出定义，设置API版本为参数 "
"*module_api_version*。如果该版本与正在运行的解释器版本不匹配，则会触发 :exc:`RuntimeWarning`。"

#: ../../c-api/module.rst:445
msgid ""
"Note that this does not process execution slots (:c:data:`Py_mod_exec`). "
"Both ``PyModule_FromDefAndSpec`` and ``PyModule_ExecDef`` must be called to "
"fully initialize a module."
msgstr ""
"注意，这不会处理执行槽（:c:data:`Py_mod_exec`）。必须调用``PyModule_FromDefAndSpec``和``PyModule_ExecDef``来完全初始化模块。"

#: ../../c-api/module.rst:451
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec`"
" instead; only use this if you are sure you need it."
msgstr "大多数时候应该使用 :c:func:`PyModule_FromDefAndSpec` 代替使用此函数，除非你确定需要使用它。"

#: ../../c-api/module.rst:458
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "执行参数*def*中给出的任意执行槽（:c:data:`Py_mod_exec`）。"

#: ../../c-api/module.rst:464
msgid "The C API version. Defined for backwards compatibility."
msgstr "C API 版本，为向后兼容性而定义。"

#: ../../c-api/module.rst:466 ../../c-api/module.rst:473
msgid ""
"Currently, this constant is not updated in new Python versions, and is not "
"useful for versioning. This may change in the future."
msgstr "目前，该常量在新的Python版本中没有更新，并且对于版本控制没有用处。这在未来可能会改变。"

#: ../../c-api/module.rst:471
msgid "Defined as ``3`` for backwards compatibility."
msgstr "为向后兼容性定义为``3``。"

#: ../../c-api/module.rst:478
msgid "Support functions"
msgstr "支持函数"

#: ../../c-api/module.rst:480
msgid ""
"The following functions are provided to help initialize a module state. They"
" are intended for a module's execution slots (:c:data:`Py_mod_exec`), the "
"initialization function for legacy :ref:`single-phase initialization "
"<single-phase-initialization>`, or code that creates modules dynamically."
msgstr ""
"提供以下函数来帮助初始化模块状态。它们用于模块的执行槽（:c:data:`Py_mod_exec`）、遗留的 :ref:`单阶段初始化 <single-"
"phase-initialization>` 的初始化函数，或动态创建模块的代码。"

#: ../../c-api/module.rst:488
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr "将一个名称为*name*的对象添加到*module*模块中。这是一个方便的函数，可以在模块的初始化函数中使用。"

#: ../../c-api/module.rst:491
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr "如果成功，返回 ``0``。如果发生错误，引发异常并返回 ``-1``。"

#: ../../c-api/module.rst:493 ../../c-api/module.rst:544
#: ../../c-api/module.rst:571
msgid "Example usage::"
msgstr "用法示例："

#: ../../c-api/module.rst:495
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:507
msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception "
"set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr "为了方便，该函数接受 ``NULL`` *value* 并设置一个异常。 在此情况下，将返回 ``-1`` 并让所引发的异常保持不变。"

#: ../../c-api/module.rst:511
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr "这个例子也可以写成不显式地检查 *obj* 是否为 ``NULL``::"

#: ../../c-api/module.rst:514
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:523
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this"
" case, since *obj* can be ``NULL``."
msgstr ""
"注意在此情况下应当使用 ``Py_XDECREF()`` 而不是 ``Py_DECREF()``，因为 *obj* 可能为 ``NULL``。"

#: ../../c-api/module.rst:526
msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*. "
"For names that aren't known at compile time, prefer calling "
":c:func:`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For "
"more details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""
"传给该函数的不同 *name* 字符串应当保持在较少的数量，通常是通过仅使用静态分配的字符串作为 *name* 来做到这一点。 "
"对于编译时未知的名称，建议直接调用 :c:func:`PyUnicode_FromString` 和 "
":c:func:`PyObject_SetAttr`。 更多相关细节，请参阅 "
":c:func:`PyUnicode_InternFromString`，它可在内部用于创建键对象。"

#: ../../c-api/module.rst:539
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to "
"*value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""
"类似于 :c:func:`PyModule_AddObjectRef`，但会“偷取”一个指向 *value* 的引用。 "
"它在被调用时可附带一个返回新引用的函数的结果而无需检查其结果或是将其保存到一个变量。"

#: ../../c-api/module.rst:546
msgid ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"
msgstr ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"

#: ../../c-api/module.rst:555
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"类似于 :c:func:`PyModule_AddObjectRef`，但会在成功时偷取一个对 *value* 的引用（如果它返回 ``0`` 值）。"

#: ../../c-api/module.rst:558
msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` functions "
"are recommended, since it is easy to introduce reference leaks by misusing "
"the :c:func:`PyModule_AddObject` function."
msgstr ""
"推荐使用新的 :c:func:`PyModule_Add` 或 :c:func:`PyModule_AddObjectRef` 函数，因为误用 "
":c:func:`PyModule_AddObject` 函数很容易导致引用泄漏。"

#: ../../c-api/module.rst:565
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr "与其他窃取引用的函数不同，``PyModule_AddObject()`` 只在 **成功** 时释放对 *value* 的引用。"

#: ../../c-api/module.rst:568
msgid ""
"This means that its return value must be checked, and calling code must "
":c:func:`Py_XDECREF` *value* manually on error."
msgstr "这意味着必须检查它的返回值，调用方代码必须在发生错误时手动为 *value* 执行 :c:func:`Py_XDECREF`。"

#: ../../c-api/module.rst:573
msgid ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."
msgstr ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // 如果 'obj' 不为 NULL 且 PyModule_AddObject() 执行失败，\n"
"    // 则 'obj' 强引用必须使 Py_XDECREF() 来删除。\n"
"    // 如果 'obj' 为 NULL，则 Py_XDECREF() 不做任何操作。\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() 会偷取一个对 obj 的引用：\n"
"// 这里不需要 Py_XDECREF(obj)。"

#: ../../c-api/module.rst:586
msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ":c:func:`PyModule_AddObject` 处于 :term:`soft deprecated` 状态。"

#: ../../c-api/module.rst:591
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` with an"
" exception set on error, ``0`` on success."
msgstr ""
"将一个整数常量作为 *name* 添加到 *module* 中。 这个便捷函数可在模块的初始化函数中使用。 当发生错误时将返回 ``-1`` "
"并设置一个异常，成功时则返回 ``0``。"

#: ../../c-api/module.rst:595
msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and "
":c:func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""
"这是一个调用 :c:func:`PyLong_FromLong` 和 :c:func:`PyModule_AddObjectRef` "
"的便捷函数；请参阅其文档了解详情。"

#: ../../c-api/module.rst:601
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated. Return ``-1`` with an exception set on error, ``0`` "
"on success."
msgstr ""
"将一个字符串常量作为 *name* 添加到 *module* 中。 这个便捷函数可在模块初始化函数中使用。 字符串 *value* 必须以 "
"``NULL`` 结尾。 当发生错误时将返回 ``-1``，成功时则返回 ``0``。"

#: ../../c-api/module.rst:606
msgid ""
"This is a convenience function that calls "
":c:func:`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`; "
"see their documentation for details."
msgstr ""
"这是一个调用 :c:func:`PyUnicode_InternFromString` 和 "
":c:func:`PyModule_AddObjectRef` 的便捷函数；请参阅其文档了解详情。"

#: ../../c-api/module.rst:613
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""
"将一个整数常量添加到 *module* 中。 名称和值取自 *macro*。 例如 ``PyModule_AddIntMacro(module, "
"AF_INET)`` 将值为 *AF_INET* 的整数常量 *AF_INET* 添加到 *module* 中。 当发生错误时将抬 ``-1`` "
"并设置一个异常，成功时将返回 ``0``。"

#: ../../c-api/module.rst:621
msgid "Add a string constant to *module*."
msgstr "将一个字符串常量添加到*module*模块中。"

#: ../../c-api/module.rst:625
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from"
" the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"将一个类型对象添加到 *module* 中。 类型对象是通过在内部调用 :c:func:`PyType_Ready` 来最终化的。 类型对象的名称取自 "
":c:member:`~PyTypeObject.tp_name` 在点号之后的部分。 当发生错误时将返回 ``-1`` 并设置一个异常，成功时将返回 "
"``0``。"

#: ../../c-api/module.rst:635
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes)."
msgstr ""
"将以 ``NULL`` 结尾的 *functions* 数组中的函数添加到 *module* 中。有关单个条目的更多细节，请参阅 "
":c:type:`PyMethodDef` "
"文档（由于缺少共享的模块命名空间，在C中实现的模块级“函数”通常将模块作为它的第一个形参，与Python类的实例方法类似）。"

#: ../../c-api/module.rst:641
msgid ""
"This function is called automatically when creating a module from "
"``PyModuleDef`` (such as when using :ref:`multi-phase-initialization`, "
"``PyModule_Create``, or ``PyModule_FromDefAndSpec``). Some module authors "
"may prefer defining functions in multiple :c:type:`PyMethodDef` arrays; in "
"that case they should call this function directly."
msgstr ""
"此函数在从 ``PyModuleDef`` 创建模块时自动调用（例如使用 :ref:`multi-phase-initialization`、 "
"``PyModule_Create`` 或 ``PyModule_FromDefAndSpec`` 等）。 一些模块作者可能更喜欢在多个 "
":c:type:`PyMethodDef` 数组中定义函数；在这种情况下，他们应该直接调用这个函数。"

#: ../../c-api/module.rst:652
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef`` (such as when "
"using :ref:`multi-phase-initialization`, ``PyModule_Create``, or "
"``PyModule_FromDefAndSpec``)."
msgstr ""
"将 *module* 的文档字符串设置为 *docstring* 。 此函数在使用 ``PyModuleDef`` 创建模块时自动调用（例如使用 "
":ref:`multi-phase-initialization`、``PyModule_Create`` 或 "
"``PyModule_FromDefAndSpec`` 时）。"

#: ../../c-api/module.rst:661
msgid ""
"Indicate that *module* does or does not support running without the global "
"interpreter lock (GIL), using one of the values from :c:macro:`Py_mod_gil`. "
"It must be called during *module*'s initialization function when using "
":ref:`single-phase-initialization`. If this function is not called during "
"module initialization, the import machinery assumes the module does not "
"support running without the GIL. This function is only available in Python "
"builds configured with :option:`--disable-gil`. Return ``-1`` with an "
"exception set on error, ``0`` on success."
msgstr ""
"指明 *module* 是否支持不带全局解释器锁 (GIL) 运行，使用一个来自 :c:macro:`Py_mod_gil` 的值 。 当使用 "
":ref:`single-phase-initialization` 时它必须在 *module* 的初始化函数执行期间被调用。 "
"如果此函数在模块初始化期间未被调用，导入机制将假定该模块不支持不带 GIL 运行。 此函数仅在配置了 :option:`--disable-gil` 的"
" Python 构建版中可用。 当发生错误时将返回 ``-1`` 并设置一个异常，成功时将返回 ``0``。"

#: ../../c-api/module.rst:675
msgid "Module lookup (single-phase initialization)"
msgstr "模块查找（单阶段初始化）"

#: ../../c-api/module.rst:677
msgid ""
"The legacy :ref:`single-phase initialization <single-phase-initialization>` "
"initialization scheme creates singleton modules that can be looked up in the"
" context of the current interpreter. This allows the module object to be "
"retrieved later with only a reference to the module definition."
msgstr ""
"遗留的 :ref:`单阶段初始化 <single-phase-initialization>` "
"初始化方案创建可以在当前解释器上下文中被查找的单例模块。这使得仅通过模块定义的引用，就可以检索模块对象。"

#: ../../c-api/module.rst:682
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr "这些函数不适用于通过多阶段初始化创建的模块，因为可以从一个模块定义创建多个模块对象。"

#: ../../c-api/module.rst:687
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"返回当前解释器中由 *def* 创建的模块对象。此方法要求模块对象此前已通过 :c:func:`PyState_AddModule` "
"函数附加到解释器状态中。如果找不到相应的模块对象，或模块对象还未附加到解释器状态，返回 ``NULL``。"

#: ../../c-api/module.rst:694
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via "
":c:func:`PyState_FindModule`."
msgstr "将传给函数的模块对象附加到解释器状态。 这将允许通过 :c:func:`PyState_FindModule` 来访问该模块对象。"

#: ../../c-api/module.rst:697
msgid "Only effective on modules created using single-phase initialization."
msgstr "仅在使用单阶段初始化创建的模块上有效。"

#: ../../c-api/module.rst:699
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module "
"that uses :ref:`single-phase initialization <single-phase-initialization>`, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python 会在使用 :ref:`单阶段初始化 <single-phase-initialization>` 导入一个模块后自动调用 "
"``PyState_AddModule``，因此从模块初始化代码中调用它是没有必要的（但也没有害处）。 显式的调用仅在模块自己的初始化代码后继调用了 "
"``PyState_FindModule`` 的情况下才是必要的。 "
"此函数主要是为了实现替代导入机制（或是通过直接调用它，或是通过引用它的实现来获取所需的状态更新详情）。"

#: ../../c-api/module.rst:708
msgid ""
"If a module was attached previously using the same *def*, it is replaced by "
"the new *module*."
msgstr "如果先前使用相同的 *def* 附加了一个模块，则将其替换为新的 *module*。"

#: ../../c-api/module.rst:711 ../../c-api/module.rst:722
msgid "The caller must have an :term:`attached thread state`."
msgstr "调用方必须有已附加的线程状态 :term:`attached thread state`。"

#: ../../c-api/module.rst:713
msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr "出错时返回 ``-1`` 并设置一个异常，成功时返回 ``0``。"

#: ../../c-api/module.rst:719
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr "从解释器状态中移除由 *def* 创建的模块对象。 当发生错误时将返回 ``-1`` 并设置一个异常，成功时将返回 ``0``。"

#: ../../c-api/module.rst:8
msgid "object"
msgstr "object -- 对象"

#: ../../c-api/module.rst:8
msgid "module"
msgstr "module"

#: ../../c-api/module.rst:13
msgid "ModuleType (in module types)"
msgstr "ModuleType (在 types 模块中)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:77
msgid "__name__ (module attribute)"
msgstr "__name__ (模块属性)"

#: ../../c-api/module.rst:33
msgid "__doc__ (module attribute)"
msgstr "__doc__ (模块属性)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:108
msgid "__file__ (module attribute)"
msgstr "__file__ (模块属性)"

#: ../../c-api/module.rst:33
msgid "__package__ (module attribute)"
msgstr "__package__ (模块属性)"

#: ../../c-api/module.rst:33
msgid "__loader__ (module attribute)"
msgstr "__loader__ (模块属性)"

#: ../../c-api/module.rst:63
msgid "__dict__ (module attribute)"
msgstr "__dict__ (模块属性)"

#: ../../c-api/module.rst:77 ../../c-api/module.rst:108
msgid "SystemError (built-in exception)"
msgstr "SystemError (内置异常)"
