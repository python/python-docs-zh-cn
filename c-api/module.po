# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 汪心禾 <wangxinhe06@gmail.com>, 2019
# Yifan Sun, 2022
# 高乐喆 <gaolezhe@outlook.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2023
# Shan Su, 2023
# Bryan不可思议, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:40+0000\n"
"PO-Revision-Date: 2019-09-01 03:40+0000\n"
"Last-Translator: Bryan不可思议, 2023\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:6
msgid "Module Objects"
msgstr "模块对象"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"这个 :c:type:`PyTypeObject` 的实例代表 Python 模块类型。 它以 ``types.ModuleType`` 的形式暴露给 "
"Python 程序。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:26
msgid ""
"Return true if *p* is a module object, but not a subtype of "
":c:data:`PyModule_Type`."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:39
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`,"
" and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a "
":attr:`__file__` attribute."
msgstr ""
"返回新的模块对象，其属性 :attr:`__name__`  为 *name* 。模块的这些属性 :attr:`__name__`, "
":attr:`__doc__`, :attr:`__package__`, and :attr:`__loader__` （所有属性除了 "
":attr:`__name__` 都被设为``None``）。调用时应当提供 :attr:`__file__` 属性。 "

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:47
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr "属性 :attr:`__package__` 和 :attr:`__loader__` 被设为``None``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:53
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr "这类似于 :c:func:`PyModule_NewObject`， 但其名称为 UTF-8 编码的字符串而不是 Unicode 对象。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:61
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"返回实现 *module* 的命名空间的字典对象；此对象与模块对象的 :attr:`~object.__dict__` 属性相同。 如果 "
"*module* 不是一个模块对象（或模块对象的子类型），则会引发 :exc:`SystemError` 并返回 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:66
msgid ""
"It is recommended extensions use other :c:func:`PyModule_\\*` and "
":c:func:`PyObject_\\*` functions rather than directly manipulate a module's "
":attr:`~object.__dict__`."
msgstr ""
"建议扩展使用其他 :c:func:`PyModule_\\*` and :c:func:`PyObject_\\*` 函数而不是直接操纵模块的 "
":attr:`~object.__dict__`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:77
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and ``NULL`` is "
"returned."
msgstr ""
"返回 *module* 的 :attr:`__name__` 值。 如果模块未提供该值，或者如果它不是一个字符串，则会引发 "
":exc:`SystemError` 并返回 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:85
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr "类似于 :c:func:`PyModule_GetNameObject` 但返回 ``'utf-8'`` 编码的名称。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:90
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See "
":c:member:`PyModuleDef.m_size`."
msgstr ""
"返回模块的“状态”，也就是说，返回指向在模块创建时分配的内存块的指针，或者 ``NULL``。 参见 "
":c:member:`PyModuleDef.m_size`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:97
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"返回指向模块创建所使用的 :c:type:`PyModuleDef` 结构体的指针，或者如果模块不是使用结构体定义创建的则返回 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:107
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s "
":attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return ``NULL``; otherwise "
"return a reference to a Unicode object."
msgstr ""
"返回使用 *module* 的 :attr:`__file__` 属性所加载的 *模块* 的文件名。 如果属性未定义，或者如果它不是一个 Unicode"
" 字符串，则会引发 :exc:`SystemError` 并返回 ``NULL``；在其他情况下将返回一个指向 Unicode 对象的引用。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:117
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr "类似于 :c:func:`PyModule_GetFilenameObject` 但会返回编码为 'utf-8' 的文件名。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:120
msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` 对于不可编码的文件名会引发 "
":c:type:`UnicodeEncodeError`，请改用 :c:func:`PyModule_GetFilenameObject`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:128
msgid "Initializing C modules"
msgstr "初始化 C 模块"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:130
msgid ""
"Modules objects are usually created from extension modules (shared libraries"
" which export an initialization function), or compiled-in modules (where the"
" initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"模块对象通常是基于扩展模块（导出初始化函数的共享库），或内部编译模块（其中使用 :c:func:`PyImport_AppendInittab` "
"添加初始化函数）。 请参阅 :ref:`building` 或 :ref:`extending-with-embedding` 了解详情。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:135
msgid ""
"The initialization function can either pass a module definition instance to "
":c:func:`PyModule_Create`, and return the resulting module object, or "
"request \"multi-phase initialization\" by returning the definition struct "
"itself."
msgstr ""
"初始化函数可以向 :c:func:`PyModule_Create` "
"传入一个模块定义实例，并返回结果模块对象，或者通过返回定义结构体本身来请求“多阶段初始化”。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:141
msgid ""
"The module definition struct, which holds all information needed to create a"
" module object. There is usually only one statically initialized variable of"
" this type for each module."
msgstr "模块定义结构，它保存创建模块对象所需的所有信息。每个模块通常只有一个这种类型的静态初始化变量"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:147
msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr "总是将此成员初始化为 :const:`PyModuleDef_HEAD_INIT`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:151
msgid "Name for the new module."
msgstr "新模块的名称。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:155
msgid ""
"Docstring for the module; usually a docstring variable created with "
":c:macro:`PyDoc_STRVAR` is used."
msgstr "模块的文档字符串；一般会使用通过 :c:macro:`PyDoc_STRVAR` 创建的文档字符串变量。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:160
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"可以把模块的状态保存在为单个模块分配的内存区域中，使用 :c:func:`PyModule_GetState` "
"检索，而不是保存在静态全局区。这使得模块可以在多个子解释器中安全地使用。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:164
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free` "
"function has been called, if present."
msgstr "这个内存区域在模块创建时根据 *m_size* 分配，并在调用 :c:member:`m_free` （如果存在）释放模块对象后释放。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:168
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr "将``m_size``设置为``-1``，意味着这个模块具有全局状态，因此不支持子解释器。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:171
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr "将其设置为非负值，意味着模块可以重新初始化，并指定其状态所需要的额外内存大小。多阶段初始化需要非负的``m_size``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:176
msgid "See :PEP:`3121` for more details."
msgstr "请参阅 :PEP:`3121` 了解详情。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:180
msgid ""
"A pointer to a table of module-level functions, described by "
":c:type:`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr "一个指向模块函数表的指针，由 :c:type:`PyMethodDef` 描述。如果模块没有函数，可以为 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:185
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a"
" ``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must"
" be ``NULL``."
msgstr ""
"由针对多阶段初始化的槽位定义组成的数组，以一个 ``{0, NULL}`` 条目结束。 当使用单阶段初始化时，*m_slots* 必须为 "
"``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:191
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "在 3.5 版之前，此成员总是被设为 ``NULL``，并被定义为:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:198
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed. This function may be called before module state is "
"allocated (:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:205
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed. This function may be called before module state is "
"allocated (:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:212
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed. This function may be called before module state is allocated "
"(:c:func:`PyModule_GetState()` may return `NULL`), and before the "
":c:member:`Py_mod_exec` function is executed."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:218
msgid "Single-phase initialization"
msgstr "单相初始化"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:220
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr "模块初始化函数可以直接创建并返回模块对象，称为“单阶段初始化”，使用以下两个模块创建函数中的一个："

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:226
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to "
":const:`PYTHON_API_VERSION`."
msgstr ""
"创建一个新的模块对象，在参数 *def* 中给出定义。它等同于将参数 *module_api_version* 设置为 "
":const:`PYTHON_API_VERSION` 的 :c:func:`PyModule_Create2` 函数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:233
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of"
" the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"创建一个新的模块对象，在参数 *def* 中给出定义，设定API版本为参数 "
"*module_api_version*。如果该版本与正在运行的解释器版本不匹配，则会触发 :exc:`RuntimeWarning`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:239
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr "大多数时候应该使用 :c:func:`PyModule_Create` 代替使用此函数，除非你确定需要使用它。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:242
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like "
":c:func:`PyModule_AddObject`."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:248
msgid "Multi-phase initialization"
msgstr "多阶段初始化"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:250
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python"
" modules: the initialization is split between the *creation phase*, when the"
" module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__`"
" methods of classes."
msgstr ""
"另一种指定扩展的方式是“多阶段初始化”。以这种方式创建的扩展模块的行为更类似 Python 模块：初始化分成两个阶段，*创建阶段* "
"创建模块对象，*执行阶段* 填充模块对象。它们的区别类似类的 :py:meth:`__new__` 和 :py:meth:`__init__` 方法。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:257
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using "
":c:func:`PyModule_GetState`), or its contents (such as the module's "
":attr:`__dict__` or individual classes created with "
":c:func:`PyType_FromSpec`)."
msgstr ""
"与使用单阶段初始化创建的模块不同，这些模块不是单例：如果 *sys.modules* "
"被移除、模块被重新导入，将会创建一个新的模块对象，旧模块将进入常规的垃圾回收——就像 Python "
"模块那样。默认情况下，根据同一个定义创建的多个模块应该是相互独立的：修改其中之一不应该影响其它模块。这意味着所有状态都应该特定于模块对象（例如使用 "
":c:func:`PyModule_GetState`），或是它的内容（例如模块的 :attr:`__dict__` 属性，或是使用 "
":c:func:`PyType_FromSpec` 创建的独立的类）。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:267
msgid ""
"All modules created using multi-phase initialization are expected to support"
" :ref:`sub-interpreters <sub-interpreter-support>`. Making sure multiple "
"modules are independent is typically enough to achieve this."
msgstr ""
"所有使用多阶段初始化创建的模块都应该支持 :ref:`子解释器<sub-interpreter-"
"support>`。保证多个模块之间相互独立，通常就可以实现这一点。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:271
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty "
":c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef``"
" instance must be initialized with the following function:"
msgstr ""
"要请求多阶段初始化，初始化函数 (PyInit_modulename) 返回一个包含非空的 "
":c:member:`~PyModuleDef.m_slots` 属性的 :c:type:`PyModuleDef` 实例。在它被返回之前，这个 "
"``PyModuleDef`` 实例必须先使用以下函数初始化："

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:278
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr "确保模块定义是一个正确初始化的Python对象，拥有正确的类型和引用计数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:281
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr "返回转换为``PyObject*``的*def*，如果发生错误，则返回``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:285
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr "模块定义的 *m_slots* 成员必须指向一个 ``PyModuleDef_Slot`` 结构体数组:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:292
msgid "A slot ID, chosen from the available values explained below."
msgstr "槽位 ID，从下面介绍的可用值中选择。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:296
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "槽位值，其含义取决于槽位 ID。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:300
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "*m_slots* 数组必须以一个 id 为 0 的槽位结束。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:302
msgid "The available slot types are:"
msgstr "可用的槽位类型是:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:306
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr "指定一个函数供调用以创建模块对象本身。 该槽位的 *value* 指针必须指向一个具有如下签名的函数:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:311
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"该函数接受一个 :py:class:`~importlib.machinery.ModuleSpec` 实例，如 :PEP:`451` "
"所定义的，以及模块定义。 它应当返回一个新的模块对象，或者设置一个错误并返回 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:316
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr "此函数应当保持最小化。 特别地，它不应当调用任意 Python 代码，因为尝试再次导入同一个模块可能会导致无限循环。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:320
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "多个 ``Py_mod_create`` 槽位不能在一个模块定义中指定。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:323
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust"
" to their place in the module hierarchy and be imported under different "
"names through symlinks, all while sharing a single module definition."
msgstr ""
"如果未指定 ``Py_mod_create``，导入机制将使用 :c:func:`PyModule_New` 创建一个普通的模块对象。 名称是获取自 "
"*spec* 而非定义，以允许扩展模块动态地调整它们在模块层级结构中的位置并通过符号链接以不同的名称被导入，同时共享同一个模块定义。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:329
msgid ""
"There is no requirement for the returned object to be an instance of "
":c:type:`PyModule_Type`. Any type can be used, as long as it supports "
"setting and getting import-related attributes. However, only "
"``PyModule_Type`` instances may be returned if the ``PyModuleDef`` has "
"non-``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; non-zero ``m_size``; "
"or slots other than ``Py_mod_create``."
msgstr ""
"不要求返回的对象必须为 :c:type:`PyModule_Type` 的实例。 任何类型均可使用，只要它支持设置和获取导入相关的属性。 但是，如果 "
"``PyModuleDef`` 具有非 ``NULL`` 的 ``m_traverse``, ``m_clear``, ``m_free``；非零的 "
"``m_size``；或者 ``Py_mod_create`` 以外的槽位则只能返回 ``PyModule_Type`` 的实例。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:338
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr "指定一个供调用以 *执行* 模块的函数。 这造价于执行一个 Python 模块的代码：通常，此函数会向模块添加类和常量。 此函数的签名为:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:345
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr "如果指定了多个``Py_mod_exec``槽位，将按照它们在*m_slots*数组中出现的顺序进行处理。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:348
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr "有关多阶段初始化的更多细节，请参阅PEP:`489`"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:351
msgid "Low-level module creation functions"
msgstr "底层模块创建函数"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:353
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"当使用多阶段初始化时，将会调用以下函数。例如，在动态创建模块对象的时候，可以直接使用它们。注意，必须调用``PyModule_FromDefAndSpec``和``PyModule_ExecDef``来完整地初始化一个模块。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:360
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` "
"with *module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""
"创建一个新的模块对象，在参数 *module* 和 *spec* 中给出定义。它等同于将参数 *module_api_version* 设置为 "
":const:`PYTHON_API_VERSION` 的 :c:func:`PyModule_FromDefAndSpec2` 函数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:368
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*, assuming the API version *module_api_version*. If that "
"version does not match the version of the running interpreter, a "
":exc:`RuntimeWarning` is emitted."
msgstr ""
"创建一个新的模块对象，在参数 *module* 和 *spec* 中给出定义，设置API版本为参数 "
"*module_api_version*。如果该版本与正在运行的解释器版本不匹配，则会触发 :exc:`RuntimeWarning`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:375
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec`"
" instead; only use this if you are sure you need it."
msgstr "大多数时候应该使用 :c:func:`PyModule_FromDefAndSpec` 代替使用此函数，除非你确定需要使用它。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:382
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "执行参数*def*中给出的任意执行槽（:c:data:`Py_mod_exec`）。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:388
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"将 *module* 的文档字符串设置为 *docstring*。当使用 ``PyModuleDef``、``PyModule_Create`` 或 "
"``PyModule_FromDefAndSpec`` 创建模块时，会自动调用此函数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:397
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes)."
" This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"将以 ``NULL`` 结尾的 *functions* 数组中的函数添加到 *module* 模块中。有关单个条目的更多细节，请参与 "
":c:type:`PyMethodDef` 文档（由于缺少共享的模块命名空间，在C中实现的模块级“函数”通常将模块作为它的第一个参数，与 Python "
"类的实例方法类似）。当使用 ``PyModule_Create`` 或 ``PyModule_FromDefAndSpec`` 从 "
"``PyModuleDef`` 创建模块时，会自动调用此函数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:409
msgid "Support functions"
msgstr "支持函数"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:411
msgid ""
"The module initialization function (if using single phase initialization) or"
" a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr "模块初始化函数（单阶段初始化）或通过模块的执行槽位调用的函数（多阶段初始化），可以使用以下函数，来帮助初始化模块的状态："

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:418
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function.  This steals a "
"reference to *value* on success.  Return ``-1`` on error, ``0`` on success."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:424
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"decrements the reference count of *value* **on success**."
msgstr "和其它窃取引用的函数不同，``PyModule_AddObject()`` 只在**成功**时减少 *value* 的引用计数。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:427
msgid ""
"This means that its return value must be checked, and calling code must "
":c:func:`Py_DECREF` *value* manually on error. Example usage::"
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:439
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"将一个名称为*name*的整型常量添加到*module*模块中。这个方便的函数可以在模块的初始化函数中使用。如果发生错误，返回``-1``，成功返回``0``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:446
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"将一个名称为*name*的字符串常量添加到*module*模块中。这个方便的函数可以在模块的初始化函数中使用。字符串*value*必须以``NULL``结尾。如果发生错误，返回``-1``，成功返回``0``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:453
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on"
" error, ``0`` on success."
msgstr ""
"将一个整型常量添加到*module*模块中。名称和值取自*macro*参数。例如，``PyModule_AddIntMacro(module, "
"AF_INET)``将值为*AF_INET*的整型常量*AF_INET*添加到*module*模块中。如果发生错误，返回``-1``，成功返回``0``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:461
msgid "Add a string constant to *module*."
msgstr "将一个字符串常量添加到*module*模块中。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:465
msgid "Module lookup"
msgstr "查找模块"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:467
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr "单阶段初始化创建可以在当前解释器上下文中被查找的单例模块。这使得仅通过模块定义的引用，就可以检索模块对象。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:471
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr "这些函数不适用于通过多阶段初始化创建的模块，因为可以从一个模块定义创建多个模块对象。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:476
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"返回当前解释器中由*def*创建的模块对象。此方法要求模块对象此前已通过 :c:func:`PyState_AddModule` "
"函数附加到解释器状态中。如果找不到相应的模块对象，或模块对象还未附加到解释器状态，返回 ``NULL``。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:483
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via "
":c:func:`PyState_FindModule`."
msgstr "将传给函数的模块对象附加到解释器状态。 这将允许通过 :c:func:`PyState_FindModule` 来访问该模块对象。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:486
msgid "Only effective on modules created using single-phase initialization."
msgstr "仅在使用单阶段初始化创建的模块上有效。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:488
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python 会在导入一个模块后自动调用 ``PyState_AddModule``，因此从模块初始化代码中调用它是没有必要的（但也没有害处）。 "
"显式的调用仅在模块自己的初始化代码后继调用了 ``PyState_FindModule`` 的情况下才是必要的。 "
"此函数主要是为了实现替代导入机制（或是通过直接调用它，或是通过引用它的实现来获取所需的状态更新详情）。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:496
msgid "Return 0 on success or -1 on failure."
msgstr "成功是返回 0 或者失败时返回 -1。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/c-api/module.rst:502
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr "从解释器状态中移除由 *def* 创建的模块对象。 成功时返回 0，者失败时返回 -1。"
