# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ppcfish <ppcfish@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/sys.rst:6
msgid "Operating System Utilities"
msgstr "操作系统实用工具"

#: ../../c-api/sys.rst:11
msgid ""
"Return the file system representation for *path*. If the object is a "
":class:`str` or :class:`bytes` object, then a new :term:`strong reference` "
"is returned. If the object implements the :class:`os.PathLike` interface, "
"then :meth:`~os.PathLike.__fspath__` is returned as long as it is a "
":class:`str` or :class:`bytes` object. Otherwise :exc:`TypeError` is raised "
"and ``NULL`` is returned."
msgstr ""
"返回 *path* 在文件系统中的表示形式。 如果该对象是一个 :class:`str` 或 :class:`bytes` 对象，则返回一个新的 "
":term:`strong reference`。 如果对象实现了 :class:`os.PathLike` 接口，则只要它是一个 "
":class:`str` 或 :class:`bytes` 对象就将返回 :meth:`~os.PathLike.__fspath__`。 "
"在其他情况下将引发 :exc:`TypeError` 并返回 ``NULL``。"

#: ../../c-api/sys.rst:24
msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the :c:member:`PyConfig.interactive` is "
"non-zero, this function also returns true if the *filename* pointer is "
"``NULL`` or if the name is equal to one of the strings ``'<stdin>'`` or "
"``'???'``."
msgstr ""
"如果名称为 *filename* 的标准Return true (nonzero) if the standard I/O 文件 *fp* "
"被确认为可交互的则返回真（非零）值。 所有 ``isatty(fileno(fp))`` 为真值的文件都属于这种情况。 如果 "
":c:member:`PyConfig.interactive` 为非零值，此函数在 *filename* 指针为 ``NULL`` "
"或者其名称等于字符串 ``'<stdin>'`` 或 ``'???'`` 之一时也将返回真值。"

#: ../../c-api/sys.rst:30
msgid "This function must not be called before Python is initialized."
msgstr "此函数不可在 Python 被初始化之前调用。"

#: ../../c-api/sys.rst:35
msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"在进程分叉之前准备某些内部状态的函数。 此函数应当在调用 :c:func:`fork` 或者任何类似的克隆当前进程的函数之前被调用。 只适用于定义了 "
":c:func:`fork` 的系统。"

#: ../../c-api/sys.rst:41
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread"
" <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"C :c:func:`fork` 调用应当只在 :ref:`\"main\" 线程 <fork-and-threads>` (位于 "
":ref:`\"main\" 解释器 <sub-interpreter-support>`) 中进行。 对于 ``PyOS_BeforeFork()``"
" 来说也是如此。"

#: ../../c-api/sys.rst:51
msgid ""
"Function to update some internal state after a process fork.  This should be"
" called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"在进程分叉之后更新某些内部状态的函数。 此函数应当在调用 :c:func:`fork` 或任何类似的克隆当前进程的函数之后被调用，无论进程克隆是否成功。"
" 只适用于定义了 :c:func:`fork` 的系统。"

#: ../../c-api/sys.rst:58
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread"
" <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"C :c:func:`fork` 调用应当只在 :ref:`\"main\" 线程 <fork-and-threads>` (位于 "
":ref:`\"main\" 解释器 <sub-interpreter-support>`) 中进行。 对于 "
"``PyOS_AfterFork_Parent()`` 来说也是如此。"

#: ../../c-api/sys.rst:68
msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the"
" process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"在进程分叉之后更新内部解释器状态的函数。 此函数必须在调用 :c:func:`fork` "
"或任何类似的克隆当前进程的函数之后在子进程中被调用，如果该进程有机会回调到 Python 解释器的话。 只适用于定义了 :c:func:`fork` "
"的系统。"

#: ../../c-api/sys.rst:75
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread"
" <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"C :c:func:`fork` 调用应当只在 :ref:`\"main\" 线程 <fork-and-threads>` (位于 "
":ref:`\"main\" 解释器 <sub-interpreter-support>`) 中进行。 对于 "
"``PyOS_AfterFork_Child()`` 来说也是如此。"

#: ../../c-api/sys.rst:83
msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be"
" called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and"
"  :c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` 允许注册可被 :c:func:`PyOS_BeforeFork()`, "
":c:func:`PyOS_AfterFork_Parent` 和 :c:func:`PyOS_AfterFork_Child` 调用的自定义 "
"Python 函数。"

#: ../../c-api/sys.rst:90
msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does"
" not need to be called."
msgstr ""
"在进程分叉之后更新某些内部状态的函数；如果要继续使用 Python 解释器则此函数应当在新进程中被调用。 "
"如果已将一个新的可执行文件载入到新进程中，则不需要调用此函数。"

#: ../../c-api/sys.rst:95
msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "此函数已被 :c:func:`PyOS_AfterFork_Child()` 取代。"

#: ../../c-api/sys.rst:103
msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :c:macro:`!USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft Visual"
" C++ compiler). :c:macro:`!USE_STACKCHECK` will be defined automatically; "
"you should never change the definition in your own code."
msgstr ""
"当解释器耗尽栈空间时返回真值。 这是一个可靠的检测，但仅在定义了 :c:macro:`!USE_STACKCHECK` 时可用（目前是在使用 "
"Microsoft Visual C++ 编译器的特定 Windows 版本上）。 :c:macro:`!USE_STACKCHECK` "
"将被自动定义；你绝不应该在你自己的代码中改变此定义。"

#: ../../c-api/sys.rst:115
msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those "
"functions directly!"
msgstr ""
"返回信号 *i* 当前的信号处理器。 这是一个对 :c:func:`!sigaction` 或 :c:func:`!signal` 的简单包装器。 "
"请不要直接调用这两个函数！"

#: ../../c-api/sys.rst:122
msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`!sigaction` or "
":c:func:`!signal`.  Do not call those functions directly!"
msgstr ""
"将信号 *i* 的信号处理器设为 *h*；返回原来的信号处理器。 这是一个对 :c:func:`!sigaction` 或 "
":c:func:`!signal` 的简单包装器。 请不要直接调用这两个函数！"

#: ../../c-api/sys.rst:129
msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that "
":ref:`Python is preinitialized <c-preinit>`."
msgstr ""
"此函数不应当被直接调用：请使用 :c:type:`PyConfig` API 以及可确保 :ref:`对 Python 进行预初始化 "
"<c-preinit>` 的  :c:func:`PyConfig_SetBytesString` 函数。"

#: ../../c-api/sys.rst:133 ../../c-api/sys.rst:200
msgid ""
"This function must not be called before :ref:`Python is preinitialized "
"<c-preinit>` and so that the LC_CTYPE locale is properly configured: see the"
" :c:func:`Py_PreInitialize` function."
msgstr ""
"此函数不可在This function must not be called before :ref:`对 Python 进行预初始化 "
"<c-preinit>` 之前被调用以便正确地配置 LC_CTYPE 语言区域：请参阅 :c:func:`Py_PreInitialize` 函数。"

#: ../../c-api/sys.rst:137
msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`."
" If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"使用 :term:`filesystem encoding and error handler` 来解码一个字节串。 如果错误处理器为 "
":ref:`surrogateescape 错误处理器 <surrogateescape>`，则不可解码的字节将被解码为 U+DC80..U+DCFF "
"范围内的字符；而如果一个字节序列可被解码为代理字符，则其中的字节会使用 surrogateescape 错误处理器来转义而不是解码它们。"

#: ../../c-api/sys.rst:144
msgid ""
"Return a pointer to a newly allocated wide character string, use "
":c:func:`PyMem_RawFree` to free the memory. If size is not ``NULL``, write "
"the number of wide characters excluding the null character into ``*size``"
msgstr ""
"返回一个指向新分配的由宽字符组成的字符串的指针，使用 :c:func:`PyMem_RawFree` 来释放内存。 如果 size 不为 "
"``NULL``，则将排除了 null 字符的宽字符数量写入到 ``*size``"

#: ../../c-api/sys.rst:148
msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"在解码错误或内存分配错误时返回 ``NULL``。 如果 *size* 不为 ``NULL``，则 ``*size`` 将在内存错误时设为 "
"``(size_t)-1`` 或在解码错误时设为 ``(size_t)-2``。"

#: ../../c-api/sys.rst:152 ../../c-api/sys.rst:192
msgid ""
"The :term:`filesystem encoding and error handler` are selected by "
":c:func:`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` 是由 :c:func:`PyConfig_Read` "
"来选择的: 参见 :c:type:`PyConfig` 的 :c:member:`~PyConfig.filesystem_encoding` 和 "
":c:member:`~PyConfig.filesystem_errors` 等成员。"

#: ../../c-api/sys.rst:156
msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr "解码错误绝对不应当发生，除非 C 库有程序缺陷。"

#: ../../c-api/sys.rst:159
msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr "请使用 :c:func:`Py_EncodeLocale` 函数来将字符串编码回字节串。"

#: ../../c-api/sys.rst:164
msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and "
":c:func:`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
":c:func:`PyUnicode_DecodeFSDefaultAndSize` 和 "
":c:func:`PyUnicode_DecodeLocaleAndSize` 函数。"

#: ../../c-api/sys.rst:169 ../../c-api/sys.rst:211
msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr "现在此函数在 :ref:`Python UTF-8 模式 <utf8-mode>` 下将使用 UTF-8 编码格式。"

#: ../../c-api/sys.rst:173
msgid ""
"The function now uses the UTF-8 encoding on Windows if "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero;"
msgstr ""
"现在如果在 Windows 上 :c:member:`PyPreConfig.legacy_windows_fs_encoding` 为零则此函数将使用"
" UTF-8 编码格式；"

#: ../../c-api/sys.rst:180
msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"将一个由宽字符组成的字符串编码为 :term:`filesystem encoding and error handler`。 如果错误处理器为 "
":ref:`surrogateescape 错误处理器 <surrogateescape>`，则在 U+DC80..U+DCFF "
"范围内的代理字符会被转换为字节值 0x80..0xFF。"

#: ../../c-api/sys.rst:185
msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"返回一个指向新分配的字节串的指针，使用 :c:func:`PyMem_Free` 来释放内存。 当发生编码错误或内存分配错误时返回 ``NULL``。"

#: ../../c-api/sys.rst:189
msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"如果 error_pos 不为 ``NULL``，则成功时会将 ``*error_pos`` 设为 "
"``(size_t)-1``，或是在发生编码错误时设为无效字符的索引号。"

#: ../../c-api/sys.rst:196
msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr "请使用 :c:func:`Py_DecodeLocale` 函数来将字节串解码回由宽字符组成的字符串。"

#: ../../c-api/sys.rst:206
msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale`"
" functions."
msgstr ""
":c:func:`PyUnicode_EncodeFSDefault` 和 :c:func:`PyUnicode_EncodeLocale` 函数。"

#: ../../c-api/sys.rst:215
msgid ""
"The function now uses the UTF-8 encoding on Windows if "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero."
msgstr ""
"现在如果在 Windows 上 :c:member:`PyPreConfig.legacy_windows_fs_encoding` 为零则此函数将使用"
" UTF-8 编码格式。"

#: ../../c-api/sys.rst:223
msgid "System Functions"
msgstr "系统功能"

#: ../../c-api/sys.rst:225
msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread"
" state structure."
msgstr ""
"这些是使来自 :mod:`sys` 模块的功能可以让 C 代码访问的工具函数。 它们都可用于当前解释器线程的 :mod:`sys` "
"模块的字典，该字典包含在内部线程状态结构体中。"

#: ../../c-api/sys.rst:231
msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr "返回来自 :mod:`sys` 模块的对象 *name* 或者如果它不存在则返回 ``NULL``，并且不会设置异常。"

#: ../../c-api/sys.rst:236
msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1``"
" on error."
msgstr ""
"将 :mod:`sys` 模块中的 *name* 设为 *v* 除非 *v* 为 ``NULL``，在此情况下 *name* 将从 sys "
"模块中被删除。 成功时返回 ``0``，发生错误时返回 ``-1``。"

#: ../../c-api/sys.rst:242
msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"将 :data:`sys.warnoptions` 重置为空列表。 此函数可在 :c:func:`Py_Initialize` 之前被调用。"

#: ../../c-api/sys.rst:245
msgid "Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead."
msgstr "改为清除 :data:`sys.warnoptions` 和 :data:`!warnings.filters`。"

#: ../../c-api/sys.rst:250
msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr "将以 *format* 描述的输出字符串写入到 :data:`sys.stdout`。 不会引发任何异常，即使发生了截断（见下文）。"

#: ../../c-api/sys.rst:253
msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* 应当将已格式化的输出字符串的总大小限制在 1000 字节以下 -- 超过 1000 字节后，输出字符串会被截断。 "
"特别地，这意味着不应出现不受限制的 \"%s\" 格式；它们应当使用 \"%.<N>s\" 来限制，其中 <N> 是一个经计算使得 <N> "
"与其他已格式化文本的最大尺寸之和不会超过 1000 字节的十进制数字。 还要注意 \"%f\"，它可能为非常大的数字打印出数以百计的数位。"

#: ../../c-api/sys.rst:261
msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr "如果发生了错误，:data:`sys.stdout` 会被清空，已格式化的消息将被写入到真正的 (C 层级) *stdout*。"

#: ../../c-api/sys.rst:266
msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr "类似 :c:func:`PySys_WriteStdout`，但改为写入到 :data:`sys.stderr` 或 *stderr*。"

#: ../../c-api/sys.rst:271
msgid ""
"Function similar to PySys_WriteStdout() but format the message using "
":c:func:`PyUnicode_FromFormatV` and don't truncate the message to an "
"arbitrary length."
msgstr ""
"类似 PySys_WriteStdout() 的函数将会使用 :c:func:`PyUnicode_FromFormatV` "
"来格式化消息并且不会将消息截短至任意长度。"

#: ../../c-api/sys.rst:279
msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr*"
" instead."
msgstr "类似 :c:func:`PySys_FormatStdout`，但改为写入到 :data:`sys.stderr` 或 *stderr*。"

#: ../../c-api/sys.rst:286
msgid ""
"Return the current dictionary of :option:`-X` options, similarly to "
":data:`sys._xoptions`.  On error, ``NULL`` is returned and an exception is "
"set."
msgstr ""
"返回当前 :option:`-X` 选项的字典，类似于 :data:`sys._xoptions`。 发生错误时，将返回 ``NULL`` "
"并设置一个异常。"

#: ../../c-api/sys.rst:295
msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr "引发一个审计事件并附带任何激活的钩子。 成功时返回零值或在失败时返回非零值并设置一个异常。"

#: ../../c-api/sys.rst:298
msgid "The *event* string argument must not be *NULL*."
msgstr "*event* 字符串参数必须不为 *NULL*。"

#: ../../c-api/sys.rst:300
msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple."
msgstr ""
"如果已添加了任何钩子，则将使用 *format* 和其他参数来构造一个要传入的元组。 除 ``N`` 以外，还可使用在 "
":c:func:`Py_BuildValue` 中使用的相同格式字符。 如果构建的值不是一个元组，它将被添加到一个单元素的元组中。"

#: ../../c-api/sys.rst:305
msgid ""
"The ``N`` format option must not be used. It consumes a reference, but since"
" there is no way to know whether arguments to this function will be "
"consumed, using it may cause reference leaks."
msgstr "不可使用 ``N`` 格式选项。 它会消耗一个引用，但是由于无法获知传给此函数的参数是否会被消耗，使用它可能导致引用泄漏。"

#: ../../c-api/sys.rst:309
msgid ""
"Note that ``#`` format characters should always be treated as "
":c:type:`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was "
"defined."
msgstr ""
"请注意 ``#`` 格式字符应当总是被当作 :c:type:`Py_ssize_t` 来处理，无论是否定义了 ``PY_SSIZE_T_CLEAN``。"

#: ../../c-api/sys.rst:312
msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` 会执行与来自 Python 代码的函数相同的操作。"

#: ../../c-api/sys.rst:314
msgid "See also :c:func:`PySys_AuditTuple`."
msgstr "另请参阅 :c:func:`PySys_AuditTuple`。"

#: ../../c-api/sys.rst:320
msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr "要求 :c:type:`Py_ssize_t` 用于 ``#`` 格式字符。 在此之前，会引发一个不可避免的弃用警告。"

#: ../../c-api/sys.rst:326
msgid ""
"Similar to :c:func:`PySys_Audit`, but pass arguments as a Python object. "
"*args* must be a :class:`tuple`. To pass no arguments, *args* can be *NULL*."
msgstr ""
"与 :c:func:`PySys_Audit` 类似，但会将参数作为 Python 对象传入。 *args* 必须是一个 :class:`tuple`。"
" 如果不传入参数，则 *args* 可以为 *NULL*。"

#: ../../c-api/sys.rst:334
msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero"
" on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"将可调用对象 *hook* 添加到激活的审计钩子列表。 在成功时返回零而在失败时返回非零值。 如果运行时已经被初始化，还会在失败时设置一个错误。 通过此"
" API 添加的钩子会针对在运行时创建的所有解释器被调用。"

#: ../../c-api/sys.rst:340
msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr "*userData* 指针会被传入钩子函数。 因于钩子函数可能由不同的运行时调用，该指针不应直接指向 Python 状态。"

#: ../../c-api/sys.rst:344
msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from "
":class:`Exception` (other errors will not be silenced)."
msgstr ""
"此函数可在 :c:func:`Py_Initialize` 之前被安全地调用。 "
"如果在运行时初始化之后被调用，现有的审计钩子将得到通知并可能通过引发一个从 :class:`Exception` "
"子类化的错误静默地放弃操作（其他错误将不会被静默）。"

#: ../../c-api/sys.rst:349
msgid ""
"The hook function is always called with the GIL held by the Python "
"interpreter that raised the event."
msgstr "钩子函数总是会由引发异常的 Python 解释器在持有 GIL 的情况下调用。"

#: ../../c-api/sys.rst:352
msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit"
" events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"请参阅 :pep:`578` 了解有关审计的详细描述。 在运行时和标准库中会引发审计事件的函数清单见 :ref:`审计事件表 <audit-"
"events>`。 更多细节见每个函数的文档。"

#: ../../c-api/sys.rst:357 ../../c-api/sys.rst:359
msgid ""
"If the interpreter is initialized, this function raises an auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"如果解释器已被初始化，此函数将引发一个审计事件 ``sys.addaudithook`` 且不附带任何参数。 如果有任何现存的钩子引发了一个派生自 "
":class:`Exception` 的异常，新的钩子将不会被添加且该异常会被清除。 "
"因此，调用方不可假定他们的钩子已被添加除非他们能控制所有现存的钩子。"

#: ../../c-api/sys.rst:368
msgid ""
"The type of the hook function. *event* is the C string event argument passed"
" to :c:func:`PySys_Audit` or :c:func:`PySys_AuditTuple`. *args* is "
"guaranteed to be a :c:type:`PyTupleObject`. *userData* is the argument "
"passed to PySys_AddAuditHook()."
msgstr ""
"钩子函数的类型。 *event* 是传给 :c:func:`PySys_Audit` 或 :c:func:`PySys_AuditTuple` 的 C "
"字符串形式的事件参数。 *args* 会确保为一个 :c:type:`PyTupleObject`。 *userData* 是传给 "
"PySys_AddAuditHook() 的参数。"

#: ../../c-api/sys.rst:380
msgid "Process Control"
msgstr "过程控制"

#: ../../c-api/sys.rst:387
msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would"
" make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`!abort` is called which will attempt to produce a "
":file:`core` file."
msgstr ""
"打印一个致命错误消息并杀死进程。 不会执行任何清理。 此函数应当仅在检测到可能令继续使用 Python "
"解释器会有危险的情况时被唤起；例如对象管理已被破坏的时候。 在 Unix 上，会调用标准 C 库函数 :c:func:`!abort` "
"并将由它来尝试生成一个 :file:`core` 文件。"

#: ../../c-api/sys.rst:394
msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
" ``Py_FatalError()`` 函数会被替换为一个将自动记录当前函数名称的宏，除非定义了 ``Py_LIMITED_API`` 宏。"

#: ../../c-api/sys.rst:398
msgid "Log the function name automatically."
msgstr "自动记录函数名称。"

#: ../../c-api/sys.rst:408
msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls"
" the standard C library function ``exit(status)``.  If "
":c:func:`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"退出当前进程。 这将调用 :c:func:`Py_FinalizeEx` 然后再调用标准 C 库函数 ``exit(status)``。 如果 "
":c:func:`Py_FinalizeEx` 提示错误，退出状态将被设为 120。"

#: ../../c-api/sys.rst:412
msgid "Errors from finalization no longer ignored."
msgstr "来自最终化的错误不会再被忽略。"

#: ../../c-api/sys.rst:422
msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs"
" should be called by *func*."
msgstr ""
"注册一个由 :c:func:`Py_FinalizeEx` 调用的清理函数。 调用清理函数将不传入任何参数且不应返回任何值。 最多可以注册32 "
"个清理函数。 当注册成功时，:c:func:`Py_AtExit` 将返回 ``0``；失败时，它将返回 ``-1``。 "
"最后注册的清理函数会最先被调用。 每个清理函数将至多被调用一次。 由于 Python 的内部最终化将在清理函数之前完成，因此 Python API "
"不应被 *func* 调用。"

#: ../../c-api/sys.rst:432
msgid ":c:func:`PyUnstable_AtExit` for passing a ``void *data`` argument."
msgstr ":c:func:`PyUnstable_AtExit` 用于传递 ``void *data`` 参数。"

#: ../../c-api/sys.rst:101
msgid "USE_STACKCHECK (C macro)"
msgstr "USE_STACKCHECK (C 宏)"

#: ../../c-api/sys.rst:385
msgid "abort (C function)"
msgstr "abort (C 函数)"

#: ../../c-api/sys.rst:404 ../../c-api/sys.rst:418
msgid "Py_FinalizeEx (C function)"
msgstr "Py_FinalizeEx (C 函数)"

#: ../../c-api/sys.rst:404
msgid "exit (C function)"
msgstr "exit (C 函数)"

#: ../../c-api/sys.rst:418
msgid "cleanup functions"
msgstr "清理函数"
