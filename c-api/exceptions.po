# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-20 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:08+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "异常处理"

#: ../../c-api/exceptions.rst:10
msgid ""
"The functions described in this chapter will let you handle and raise Python"
" exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it"
" to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a"
" pointer, or ``-1`` if they return an integer (exception: the ``PyArg_*`` "
"functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"本章描述的函数将让你处理和触发 Python 异常。 了解一些 Python 异常处理的基础知识是很重要的。 它的工作原理有点像 POSIX "
":c:data:`errno` 变量: (每个线程) 有一个最近发生的错误的全局指示器。 大多数 C API 函数在成功执行时将不理会它。 大多数 C "
"API 函数也会返回一个错误指示器，如果它们应当返回一个指针则会返回 ``NULL``，或者如果它们应当返回一个整数则会返回 ``-1`` (例外情况:"
" ``PyArg_*`` 函数返回 ``1`` 表示成功而 ``0`` 表示失败)。"

#: ../../c-api/exceptions.rst:20
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"具体地说，错误指示器由三个对象指针组成：异常的类型，异常的值，和回溯对象。如果没有错误被设置，这些指针都可以是 ``NULL`` "
"（尽管一些组合使禁止的，例如，如果异常类型是 ``NULL``，你不能有一个非 ``NULL`` 的回溯）。"

#: ../../c-api/exceptions.rst:26
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it"
" is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"当一个函数由于它调用的某个函数失败而必须失败时，通常不会设置错误指示器；它调用的那个函数已经设置了它。而它负责处理错误和清理异常，或在清除其拥有的所有资源后返回（如对象应用或内存分配）。如果不准备处理异常，则"
" *不* 应该正常地继续。如果是由于一个错误返回，那么一定要向调用者表明已经设置了错误。如果错误没有得到处理或小心传播，对 Python/C "
"API的其它调用可能不会有预期的行为，并且可能会以某种神秘的方式失败。"

#: ../../c-api/exceptions.rst:37
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught"
" (and has therefore stopped propagating)."
msgstr ""
"错误指示器 **不是** :func:`sys.exc_info` 的执行结果。 "
"前者对应于尚未捕获（因而仍在传播）的异常，而后者会在异常被捕获之后（因而已停止传播）返回它。"

#: ../../c-api/exceptions.rst:44
msgid "Printing and clearing"
msgstr "打印和清理"

#: ../../c-api/exceptions.rst:49
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr "清除错误指示器。如果没有设置错误指示器，则不会有作用。"

#: ../../c-api/exceptions.rst:55
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"将标准回溯打印到 ``sys.stderr`` 并清除错误指示器。**除非** 错误是 "
"``SystemExit``，这种情况下不会打印回溯进程，且会退出 Python 进程，并显示 ``SystemExit`` 实例指定的错误代码。"

#: ../../c-api/exceptions.rst:60
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr "只有在错误指示器被设置时才需要调用这个函数，否则这会导致错误！"

#: ../../c-api/exceptions.rst:63
msgid ""
"If *set_sys_last_vars* is nonzero, the variable :data:`sys.last_exc` is set "
"to the printed exception. For backwards compatibility, the deprecated "
"variables :data:`sys.last_type`, :data:`sys.last_value` and "
":data:`sys.last_traceback` are also set to the type, value and traceback of "
"this exception, respectively."
msgstr ""
"如果 *set_sys_last_vars* 为非零值，则变量 :data:`sys.last_exc` 将被设为要打印的异常。 "
"出于向下兼容性考虑，已弃用的变量 :data:`sys.last_type`, :data:`sys.last_value` 和 "
":data:`sys.last_traceback` 也会被分别设为该异常的类型, 值和回溯。"

#: ../../c-api/exceptions.rst:69
msgid "The setting of :data:`sys.last_exc` was added."
msgstr "增加了对 :data:`sys.last_exc` 的设置。"

#: ../../c-api/exceptions.rst:75
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "``PyErr_PrintEx(1)`` 的别名。"

#: ../../c-api/exceptions.rst:80
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr "使用当前异常和 *obj* 参数调用 :func:`sys.unraisablehook`。"

#: ../../c-api/exceptions.rst:83
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`~object.__del__` method."
msgstr ""
"当异常已被设置但解释器不可能实际引发该异常时，这个工具函数会向 ``sys.stderr`` 打印一条警告消息。 例如，当异常发生在 "
":meth:`~object.__del__` 方法中时就会使用该函数。"

#: ../../c-api/exceptions.rst:88
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of"
" *obj* will be printed in the warning message. If *obj* is ``NULL``, only "
"the traceback is printed."
msgstr ""
"该函数调用时将传入单个参数 *obj*，它标识发生不可引发的异常所在的上下文。 如果可能，*obj* 的表示形式将打印在警告消息中。 如果 *obj* "
"为 ``NULL``，将只打印回溯。"

#: ../../c-api/exceptions.rst:93
msgid "An exception must be set when calling this function."
msgstr "调用此函数时必须设置一个异常。"

#: ../../c-api/exceptions.rst:95
msgid "Print a traceback. Print only traceback if *obj* is ``NULL``."
msgstr "打印回溯信息。 如果 *obj* 为 ``NULL`` 将只打印回溯。"

#: ../../c-api/exceptions.rst:98
msgid "Use :func:`sys.unraisablehook`."
msgstr "使用 :func:`sys.unraisablehook`。"

#: ../../c-api/exceptions.rst:104
msgid ""
"Similar to :c:func:`PyErr_WriteUnraisable`, but the *format* and subsequent "
"parameters help format the warning message; they have the same meaning and "
"values as in :c:func:`PyUnicode_FromFormat`. ``PyErr_WriteUnraisable(obj)`` "
"is roughly equivalent to ``PyErr_FormatUnraisable(\"Exception ignored in: "
"%R\", obj)``. If *format* is ``NULL``, only the traceback is printed."
msgstr ""
"与 :c:func:`PyErr_WriteUnraisable` 类似，但 *format* 和后续的形参有助于格式化警告消息；它们的含义和值与 "
":c:func:`PyUnicode_FromFormat` 中的相同。 ``PyErr_WriteUnraisable(obj)`` 大致等价于 "
"``PyErr_FormatUnraisable(\"Exception ignored in: %R\", obj)``。 如果 *format* 为"
" ``NULL``，则只打印回溯信息。"

#: ../../c-api/exceptions.rst:116
msgid ""
"Print the standard traceback display of ``exc`` to ``sys.stderr``, including"
" chained exceptions and notes."
msgstr "将 ``exc`` 的标准回溯显示打印到 ``sys.stderr``，包括链式异常和注释。"

#: ../../c-api/exceptions.rst:123
msgid "Raising exceptions"
msgstr "抛出异常"

#: ../../c-api/exceptions.rst:125
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr "这些函数可帮助你设置当前线程的错误指示器。为了方便起见，一些函数将始终返回 ``NULL`` 指针，以便用于 ``return`` 语句。"

#: ../../c-api/exceptions.rst:132
msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions,"
" e.g. :c:data:`PyExc_RuntimeError`.  You need not create a new :term:`strong"
" reference` to it (e.g. with :c:func:`Py_INCREF`). The second argument is an"
" error message; it is decoded from ``'utf-8'``."
msgstr ""
"这是设置错误指示器最常用的方式。 第一个参数指定异常类型；它通常为某个标准异常，例如 :c:data:`PyExc_RuntimeError`。 "
"你无需为其创建新的 :term:`strong reference` (例如使用 :c:func:`Py_INCREF`)。 "
"第二个参数是一条错误消息；它是用 ``'utf-8'`` 解码的。"

#: ../../c-api/exceptions.rst:141
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr "此函数类似于 :c:func:`PyErr_SetString`，但是允许你为异常的“值”指定任意一个 Python 对象。"

#: ../../c-api/exceptions.rst:147
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in "
":c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"这个函数设置了一个错误指示器并且返回了 ``NULL``，*exception* 应当是一个 Python 中的异常类。*format* "
"和随后的形参会帮助格式化这个错误的信息；它们与 :c:func:`PyUnicode_FromFormat` 有着相同的含义和值。*format* "
"是一个ASCII编码的字符串。"

#: ../../c-api/exceptions.rst:156
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"和 :c:func:`PyErr_Format` 相同，但它接受一个 :c:type:`va_list` 类型的参数而不是可变数量的参数集。"

#: ../../c-api/exceptions.rst:164
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "这是 ``PyErr_SetObject(type, Py_None)`` 的简写。"

#: ../../c-api/exceptions.rst:169
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where"
" *message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"这是 ``PyErr_SetString(PyExc_TypeError, message)`` 的简写，其中 *message* "
"指出使用了非法参数调用内置操作。它主要用于内部使用。"

#: ../../c-api/exceptions.rst:176
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"这是 ``PyErr_SetNone(PyExc_MemoryError)`` 的简写；它返回 ``NULL`` ，以便当内存耗尽时，对象分配函数可以写"
" ``return PyErr_NoMemory();`` 。"

#: ../../c-api/exceptions.rst:185
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from "
":c:func:`!strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :c:macro:`!EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"这是一个便捷函数，当在 C 库函数返回错误并设置 C 变量 :c:data:`errno` 时它会引发一个异常。 它构造了一个元组对象，其第一项是整数值"
" :c:data:`errno` 而第二项是对应的错误信息（从 :c:func:`!strerror` 获取），然后调用 "
"``PyErr_SetObject(type, object)``。 在 Unix 上，当 :c:data:`errno` 的值为 "
":c:macro:`!EINTR` 时，表示有一个中断的系统调用，这将会调用 "
":c:func:`PyErr_CheckSignals`，如果它设置了错误指示符，则让其保持该设置。 该函数总是返回 "
"``NULL``，因此当系统调用返回错误时该系统调用的包装函数可以写入 ``return PyErr_SetFromErrno(type);``。"

#: ../../c-api/exceptions.rst:199
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`!filename` attribute of the exception instance."
msgstr ""
"与 :c:func:`PyErr_SetFromErrno` 类似，但如果 *filenameObject* 不为 "
"``NULL``，它将作为第三个参数传递给 *type* 的构造函数。 在 :exc:`OSError` 异常的情况下，它将被用于定义异常实例的 "
":attr:`!filename` 属性。"

#: ../../c-api/exceptions.rst:208
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"类似于 :c:func:`PyErr_SetFromErrnoWithFilenameObject` ，但接受第二个 filename "
"对象，用于当一个接受两个 filename 的函数失败时触发错误。"

#: ../../c-api/exceptions.rst:217
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"类似于 :c:func:`PyErr_SetFromErrnoWithFilenameObject`，但文件名以 C 字符串形式给出。 "
"*filename* 是用 :term:`filesystem encoding and error handler` 解码的。"

#: ../../c-api/exceptions.rst:224
msgid ""
"This is a convenience function to raise :exc:`OSError`. If called with "
"*ierr* of ``0``, the error code returned by a call to "
":c:func:`!GetLastError` is used instead.  It calls the Win32 function "
":c:func:`!FormatMessage` to retrieve the Windows description of error code "
"given by *ierr* or :c:func:`!GetLastError`, then it constructs a "
":exc:`OSError` object with the :attr:`~OSError.winerror` attribute set to "
"the error code, the :attr:`~OSError.strerror` attribute set to the "
"corresponding error message (gotten from :c:func:`!FormatMessage`), and then"
" calls ``PyErr_SetObject(PyExc_OSError, object)``. This function always "
"returns ``NULL``."
msgstr ""
"这是一个用于引发 :exc:`OSError` 的便捷函数。 如果调用时传入的 *ierr* 值为 ``0``，则会改用对 "
":c:func:`!GetLastError` 的调用所返回的错误代码。 它将调用 Win32 函数 :c:func:`!FormatMessage` "
"来获取 *ierr* 或 :c:func:`!GetLastError` 所给出的错误代码的 Windows 描述，然后构造一个 "
":exc:`OSError` 对象，其中 :attr:`~OSError.winerror` "
"属性将设为该错误代码，:attr:`~OSError.strerror` 属性将设为相应的错误消息（从 :c:func:`!FormatMessage`"
" 获得），然后再调用 ``PyErr_SetObject(PyExc_OSError, object)``。 该函数将总是返回 ``NULL``。"

#: ../../c-api/exceptions.rst:234 ../../c-api/exceptions.rst:242
#: ../../c-api/exceptions.rst:253 ../../c-api/exceptions.rst:263
#: ../../c-api/exceptions.rst:271 ../../c-api/exceptions.rst:281
msgid "Availability"
msgstr "Availability"

#: ../../c-api/exceptions.rst:239
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr "类似于 :c:func:`PyErr_SetFromWindowsErr` ，额外的参数指定要触发的异常类型。"

#: ../../c-api/exceptions.rst:247
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with the additional behavior "
"that if *filename* is not ``NULL``, it is decoded from the filesystem "
"encoding (:func:`os.fsdecode`) and passed to the constructor of "
":exc:`OSError` as a third parameter to be used to define the "
":attr:`!filename` attribute of the exception instance."
msgstr ""
"与 :c:func:`PyErr_SetFromWindowsErr` 类似，额外的不同点是如果 *filename* 不为 ``NULL`` "
"，则会使用文件系统编码格式 (:func:`os.fsdecode`) 进行解码并作为第三个参数传递给 :exc:`OSError` "
"的构造器用于定义异常实例的 :attr:`!filename` 属性。"

#: ../../c-api/exceptions.rst:258
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErr`, with the additional "
"behavior that if *filename* is not ``NULL``, it is passed to the constructor"
" of :exc:`OSError` as a third parameter to be used to define the "
":attr:`!filename` attribute of the exception instance."
msgstr ""
"与 :c:func:`PyErr_SetExcFromWindowsErr` 类似，额外的不同点是如果 *filename* 不为 "
"``NULL``，它将作为第三个参数传递给 :exc:`OSError` 的构造器用于定义异常实例的 :attr:`!filename` 属性。"

#: ../../c-api/exceptions.rst:268
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"类似于 :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject` ，但是接受第二个 filename"
" 对象。"

#: ../../c-api/exceptions.rst:278
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional"
" parameter specifying the exception type to be raised."
msgstr "类似于 :c:func:`PyErr_SetFromWindowsErrWithFilename` ，额外参数指定要触发的异常类型。"

#: ../../c-api/exceptions.rst:286
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and"
" ``path`` attributes."
msgstr ""
"这是触发 :exc:`ImportError` 的便捷函数。 *msg* 将被设为异常的消息字符串。 *name* 和 *path* ，（都可以为 "
"``NULL`` ），将用来被设置 :exc:`ImportError` 对应的属性 ``name`` 和 ``path``。"

#: ../../c-api/exceptions.rst:296
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"和 :c:func:`PyErr_SetImportError` 很类似，但这个函数允许指定一个 :exc:`ImportError` 的子类来触发。"

#: ../../c-api/exceptions.rst:304
msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"设置当前异常的文件，行和偏移信息。如果当前异常不是 :exc:`SyntaxError` ，则它设置额外的属性，使异常打印子系统认为异常是 "
":exc:`SyntaxError`。"

#: ../../c-api/exceptions.rst:314
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"类似于 :c:func:`PyErr_SyntaxLocationObject`，但 *filename* 是用 :term:`filesystem "
"encoding and error handler` 解码的字节串。"

#: ../../c-api/exceptions.rst:322
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr "类似于 :c:func:`PyErr_SyntaxLocationEx`，但省略了 *col_offset* parameter 形参。"

#: ../../c-api/exceptions.rst:328
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"这是 ``PyErr_SetString(PyExc_SystemError, message)`` 的缩写，其中 *message* "
"表示使用了非法参数调用内部操作（例如，Python/C API 函数）。它主要用于内部使用。"

#: ../../c-api/exceptions.rst:335
msgid "Issuing warnings"
msgstr "发出警告"

#: ../../c-api/exceptions.rst:337
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if"
" an exception is raised.  (It is not possible to determine whether a warning"
" message is actually printed, nor what the reason is for the exception; this"
" is intentional.)  If an exception is raised, the caller should do its "
"normal exception handling (for example, :c:func:`Py_DECREF` owned references"
" and return an error value)."
msgstr ""
"这些函数可以从 C 代码中发出警告。它们仿照了由 Python 模块 :mod:`warnings` 导出的那些函数。它们通常向 "
"*sys.stderr* "
"打印一条警告信息；当然，用户也有可能已经指定将警告转换为错误，在这种情况下，它们将触发异常。也有可能由于警告机制出现问题，使得函数触发异常。如果没有触发异常，返回值为"
" ``0`` ；如果触发异常，返回值为 "
"``-1``。（无法确定是否实际打印了警告信息，也无法确定异常触发的原因。这是故意为之）。如果触发了异常，调用者应该进行正常的异常处理（例如，:c:func:`Py_DECREF`"
" 持有引用并返回一个错误值）。"

#: ../../c-api/exceptions.rst:352
msgid ""
"Issue a warning message.  The *category* argument is a warning category (see"
" below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling "
":c:func:`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"发出一个警告信息。参数 *category* 是一个警告类别（见下面）或 ``NULL`` ； *message* 是一个 UTF-8 编码的字符串。 "
"*stack_level* 是一个给出栈帧数量的正数；警告将从该栈帧中当前正在执行的代码行发出。 *stack_level* 为 1 的是调用 "
":c:func:`PyErr_WarnEx` 的函数，2 是在此之上的函数，以此类推。"

#: ../../c-api/exceptions.rst:359
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; "
":c:data:`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the "
"default warning category is :c:data:`PyExc_RuntimeWarning`. The standard "
"Python warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"警告类别必须是 :c:data:`PyExc_Warning` 的子类， :c:data:`PyExc_Warning` 是 "
":c:data:`PyExc_Exception` 的子类；默认警告类别是 :c:data:`PyExc_RuntimeWarning` 。标准 "
"Python 警告类别作为全局变量可用，所有其名称见 :ref:`standardwarningcategories` 。"

#: ../../c-api/exceptions.rst:365
msgid ""
"For information about warning control, see the documentation for the "
":mod:`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"有关警告控制的信息，参见模块文档 :mod:`warnings` 和命令行文档中的 :option:`-W` 选项。没有用于警告控制的 C API。"

#: ../../c-api/exceptions.rst:372
msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function "
":func:`warnings.warn_explicit`; see there for more information.  The "
"*module* and *registry* arguments may be set to ``NULL`` to get the default "
"effect described there."
msgstr ""
"发出一个对所有警告属性进行显式控制的警告消息。 这是位于 Python 函数 :func:`warnings.warn_explicit` "
"外层的直接包装；请查看其文档了解详情。 *module* 和 *registry* 参数可被设为 ``NULL`` 以得到相关文档所描述的默认效果。"

#: ../../c-api/exceptions.rst:383
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the "
":term:`filesystem encoding and error handler`."
msgstr ""
"类似于 :c:func:`PyErr_WarnExplicitObject` 不过 *message* 和 *module* 是 UTF-8 "
"编码的字符串，而 *filename* 是由 :term:`filesystem encoding and error handler` 解码的。"

#: ../../c-api/exceptions.rst:390
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use "
":c:func:`PyUnicode_FromFormat` to format the warning message.  *format* is "
"an ASCII-encoded string."
msgstr ""
"类似于 :c:func:`PyErr_WarnEx` 的函数，但使用 :c:func:`PyUnicode_FromFormat` 来格式化警告消息。 "
"*format* 是使用 ASCII 编码的字符串。"

#: ../../c-api/exceptions.rst:399
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is "
":exc:`ResourceWarning` and it passes *source* to "
":class:`!warnings.WarningMessage`."
msgstr ""
"类似于 :c:func:`PyErr_WarnFormat` 的函数，但 *category* 是 :exc:`ResourceWarning` "
"并且它会将 *source* 传给 :class:`!warnings.WarningMessage`。"

#: ../../c-api/exceptions.rst:406
msgid "Querying the error indicator"
msgstr "查询错误指示器"

#: ../../c-api/exceptions.rst:410
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the ``PyErr_Set*`` "
"functions or to :c:func:`PyErr_Restore`).  If not set, return ``NULL``.  You"
" do not own a reference to the return value, so you do not need to "
":c:func:`Py_DECREF` it."
msgstr ""
"测试是否设置了错误指示器。 如已设置，则返回异常 *type* (传给对某个 ``PyErr_Set*`` 函数或 "
":c:func:`PyErr_Restore` 的最后一次调用的第一个参数)。 如未设置，则返回 ``NULL``。 "
"你并不会拥有对返回值的引用，因此你不需要对它执行 :c:func:`Py_DECREF`。"

#: ../../c-api/exceptions.rst:416
msgid "The caller must hold the GIL."
msgstr "调用时必须持有GIL。"

#: ../../c-api/exceptions.rst:420
msgid ""
"Do not compare the return value to a specific exception; use "
":c:func:`PyErr_ExceptionMatches` instead, shown below.  (The comparison "
"could easily fail since the exception may be an instance instead of a class,"
" in the case of a class exception, or it may be a subclass of the expected "
"exception.)"
msgstr ""
"不要将返回值与特定的异常进行比较；请改为使用 :c:func:`PyErr_ExceptionMatches`，如下所示。 "
"（比较很容易失败因为对于类异常来说，异常可能是一个实例而不是类，或者它可能是预期的异常的一个子类。）"

#: ../../c-api/exceptions.rst:428
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"等价于 ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``。 "
"此函数应当只在实际设置了异常时才被调用；如果没有任何异常被引发则将发生非法内存访问。"

#: ../../c-api/exceptions.rst:435
msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"如果 *given* 异常与 *exc* 中的异常类型相匹配则返回真值。 如果 *exc* 是一个类对象，则当 *given* "
"是一个子类的实例时也将返回真值。 如果 *exc* 是一个元组，则该元组（以及递归的子元组）中的所有异常类型都将被搜索进行匹配。"

#: ../../c-api/exceptions.rst:443
msgid ""
"Return the exception currently being raised, clearing the error indicator at"
" the same time. Return ``NULL`` if the error indicator is not set."
msgstr "返回当前被引发的异常，同时清除错误指示器。 如果错误指示器尚未设置则返回 ``NULL``。"

#: ../../c-api/exceptions.rst:446
msgid ""
"This function is used by code that needs to catch exceptions, or code that "
"needs to save and restore the error indicator temporarily."
msgstr "此函数会被需要捕获异常的代码，或需要临时保存和恢复错误指示器的代码所使用。"

#: ../../c-api/exceptions.rst:449 ../../c-api/exceptions.rst:493
msgid "For example::"
msgstr "例如："

#: ../../c-api/exceptions.rst:451
msgid ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... 可能产生其他错误的代码 ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/exceptions.rst:459
msgid ""
":c:func:`PyErr_GetHandledException`, to save the exception currently being "
"handled."
msgstr ":c:func:`PyErr_GetHandledException`，保存当前正在处理的异常。"

#: ../../c-api/exceptions.rst:467
msgid ""
"Set *exc* as the exception currently being raised, clearing the existing "
"exception if one is set."
msgstr "将 *exc* 设为当前被引发的异常，如果已设置则清空现有的异常。"

#: ../../c-api/exceptions.rst:472
msgid ""
"This call steals a reference to *exc*, which must be a valid exception."
msgstr "此调用将偷取一个对 *exc* 的引用，它必须是一个有效的异常。"

#: ../../c-api/exceptions.rst:481
msgid "Use :c:func:`PyErr_GetRaisedException` instead."
msgstr "使用 :c:func:`PyErr_GetRaisedException` 代替。"

#: ../../c-api/exceptions.rst:483
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"将错误指示符提取到三个变量中并传递其地址。 如果未设置错误指示符，则将三个变量都设为 ``NULL``。 "
"如果已设置，则将其清除并且你将得到对所提取的每个对象的引用。 值和回溯对象可以为 ``NULL`` 即使类型对象不为空。"

#: ../../c-api/exceptions.rst:490
msgid ""
"This function is normally only used by legacy code that needs to catch "
"exceptions or save and restore the error indicator temporarily."
msgstr "此函数通常只被需要捕获异常或临时保存和恢复错误指示符的旧式代码所使用。"

#: ../../c-api/exceptions.rst:495
msgid ""
"{\n"
"   PyObject *type, *value, *traceback;\n"
"   PyErr_Fetch(&type, &value, &traceback);\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_Restore(type, value, traceback);\n"
"}"
msgstr ""
"{\n"
"   PyObject *type, *value, *traceback;\n"
"   PyErr_Fetch(&type, &value, &traceback);\n"
"\n"
"   /* ... 可能产生其他错误的代码 ... */\n"
"\n"
"   PyErr_Restore(type, value, traceback);\n"
"}"

#: ../../c-api/exceptions.rst:509
msgid "Use :c:func:`PyErr_SetRaisedException` instead."
msgstr "请改用 :c:func:`PyErr_SetRaisedException`。"

#: ../../c-api/exceptions.rst:511
msgid ""
"Set the error indicator from the three objects, *type*, *value*, and "
"*traceback*, clearing the existing exception if one is set. If the objects "
"are ``NULL``, the error indicator is cleared.  Do not pass a ``NULL`` type "
"and non-``NULL`` value or traceback.  The exception type should be a class."
"  Do not pass an invalid exception type or value. (Violating these rules "
"will cause subtle problems later.)  This call takes away a reference to each"
" object: you must own a reference to each object before the call and after "
"the call you no longer own these references.  (If you don't understand this,"
" don't use this function.  I warned you.)"
msgstr ""
"根据 *type*, *value* 和 *traceback* 这三个对象设置错误指示符，如果已设置了错误指示符则先清除它。如果三个对象均为 "
"``NULL``，则清除错误指示符。 请不要传入 ``NULL`` 类型和非 ``NULL`` 的值或回溯。 异常类型应当是一个类。 "
"请不要传入无效的异常类型或值。 （违反这些规则将导致微妙的后继问题。） "
"此调用会带走对每个对象的引用：你必须在调用之前拥有对每个对象的引用并且在调用之后你将不再拥有这些引用。 （如果你不理解这一点，就不要使用此函数。 "
"勿谓言之不预。）"

#: ../../c-api/exceptions.rst:525
msgid ""
"This function is normally only used by legacy code that needs to save and "
"restore the error indicator temporarily. Use :c:func:`PyErr_Fetch` to save "
"the current error indicator."
msgstr "此函数通常只被需要临时保存和恢复错误指示符的旧代码所使用。 请使用 :c:func:`PyErr_Fetch` 来保存当前的错误指示符。"

#: ../../c-api/exceptions.rst:534
msgid ""
"Use :c:func:`PyErr_GetRaisedException` instead, to avoid any possible de-"
"normalization."
msgstr "请改用 :c:func:`PyErr_GetRaisedException`，以避免任何可能的去正规化。"

#: ../../c-api/exceptions.rst:537
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"在特定情况下，下面 :c:func:`PyErr_Fetch` 所返回的值可以是“非正规化的”，即 ``*exc`` 是一个类对象而 ``*val`` "
"不是同一个类的实例。 在这种情况下此函数可以被用来实例化类。 如果值已经是正规化的，则不做任何操作。 实现这种延迟正规化是为了提升性能。"

#: ../../c-api/exceptions.rst:545
msgid ""
"This function *does not* implicitly set the "
":attr:`~BaseException.__traceback__` attribute on the exception value. If "
"setting the traceback appropriately is desired, the following additional "
"snippet is needed::"
msgstr ""
"此函数 *不会* 隐式地在异常值上设置 :attr:`~BaseException.__traceback__` 属性。 "
"如果想要适当地设置回溯，还需要以下附加代码片段::"

#: ../../c-api/exceptions.rst:550
msgid ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"
msgstr ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"

#: ../../c-api/exceptions.rst:557
msgid ""
"Retrieve the active exception instance, as would be returned by "
":func:`sys.exception`. This refers to an exception that was *already "
"caught*, not to an exception that was freshly raised. Returns a new "
"reference to the exception or ``NULL``. Does not modify the interpreter's "
"exception state."
msgstr ""
"提取激活的异常实例，就如 :func:`sys.exception` 所返回的一样。 这是指一个 *已被捕获* 的异常，而不是刚被引发的异常。 "
"返回一个指向该异常的新引用或者 ``NULL``。 不会修改解释器的异常状态。 Does not modify the interpreter's "
"exception state."

#: ../../c-api/exceptions.rst:564
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetHandledException` to restore or "
"clear the exception state."
msgstr ""
"此函数通常不会被需要处理异常的代码所使用。 它可被使用的场合是当代码需要临时保存并恢复异常状态的时候。 请使用 "
":c:func:`PyErr_SetHandledException` 来恢复或清除异常状态。"

#: ../../c-api/exceptions.rst:573
msgid ""
"Set the active exception, as known from ``sys.exception()``.  This refers to"
" an exception that was *already caught*, not to an exception that was "
"freshly raised. To clear the exception state, pass ``NULL``."
msgstr ""
"设置激活的异常，就是从 ``sys.exception()`` 所获得的。 这是指一个 *已被捕获* 的异常，而不是刚被引发的异常。 "
"要清空异常状态，请传入 ``NULL``。"

#: ../../c-api/exceptions.rst:580
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetHandledException` to get the "
"exception state."
msgstr ""
"此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保存并恢复异常状态的时候。 请使用 "
":c:func:`PyErr_GetHandledException` 来获取异常状态。"

#: ../../c-api/exceptions.rst:589
msgid ""
"Retrieve the old-style representation of the exception info, as known from "
":func:`sys.exc_info`.  This refers to an exception that was *already "
"caught*, not to an exception that was freshly raised.  Returns new "
"references for the three objects, any of which may be ``NULL``.  Does not "
"modify the exception info state.  This function is kept for backwards "
"compatibility. Prefer using :c:func:`PyErr_GetHandledException`."
msgstr ""
"提取旧式的异常信息表示形式，就是从 :func:`sys.exc_info` 所获得的。 这是指一个 *已被捕获* 的异常，而不是刚被引发的异常。 "
"返回分别指向三个对象的新引用，其中任何一个都可以为 ``NULL``。 不会修改异常信息的状态。 此函数是为了向下兼容而保留的。 更推荐使用 "
":c:func:`PyErr_GetHandledException`。"

#: ../../c-api/exceptions.rst:598
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保存并恢复异常状态的时候。 请使用 "
":c:func:`PyErr_SetExcInfo` 来恢复或清除异常状态。"

#: ../../c-api/exceptions.rst:608
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an"
" exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. This function is "
"kept for backwards compatibility. Prefer using "
":c:func:`PyErr_SetHandledException`."
msgstr ""
"设置异常信息，就是从 ``sys.exc_info()`` 所获得的，这是指一个 *已被捕获* 的异常，而不是刚被引发的异常。 "
"此函数会偷取对参数的引用。 要清空异常状态，请为所有三个参数传入 ``NULL``。 此函数是为了向下兼容而保留的。 更推荐使用 "
":c:func:`PyErr_SetHandledException`。"

#: ../../c-api/exceptions.rst:617
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保存并恢复异常状态的情况。 请使用 "
":c:func:`PyErr_GetExcInfo` 来读取异常状态。"

#: ../../c-api/exceptions.rst:624
msgid ""
"The ``type`` and ``traceback`` arguments are no longer used and can be NULL."
" The interpreter now derives them from the exception instance (the ``value``"
" argument). The function still steals references of all three arguments."
msgstr ""
"``type`` 和 ``traceback`` 参数已不再被使用并且可以为 NULL。 解释器现在会根据异常实例（即 ``value`` "
"参数）来推断出它们。 此函数仍然会偷取对所有三个参数的引用。"

#: ../../c-api/exceptions.rst:632
msgid "Signal Handling"
msgstr "信号处理"

#: ../../c-api/exceptions.rst:642
msgid "This function interacts with Python's signal handling."
msgstr "这个函数与Python的信号处理交互。"

#: ../../c-api/exceptions.rst:644
msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"如果在主 Python 解释器下从主线程调用该函数，它将检查是否向进程发送了信号，如果是，则唤起相应的信号处理器。 如果支持 :mod:`signal`"
" 模块，则可以唤起以 Python 编写的信号处理器。"

#: ../../c-api/exceptions.rst:649
msgid ""
"The function attempts to handle all pending signals, and then returns ``0``."
" However, if a Python signal handler raises an exception, the error "
"indicator is set and the function returns ``-1`` immediately (such that "
"other pending signals may not have been handled yet: they will be on the "
"next :c:func:`PyErr_CheckSignals()` invocation)."
msgstr ""
"该函数会尝试处理所有待处理信号，然后返回 ``0``。 但是，如果 Python 信号处理器引发了异常，则设置错误指示符并且函数将立即返回 ``-1``"
" (这样其他待处理信号可能还没有被处理：它们将在下次唤起 :c:func:`PyErr_CheckSignals()` 时被处理)。"

#: ../../c-api/exceptions.rst:655
msgid ""
"If the function is called from a non-main thread, or under a non-main Python"
" interpreter, it does nothing and returns ``0``."
msgstr "如果函数从非主线程调用，或在非主Python解释器下调用，则它不执行任何操作并返回0。"

#: ../../c-api/exceptions.rst:658
msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr "这个函数可以由希望被用户请求(例如按Ctrl-C)中断的长时间运行的C代码调用。"

#: ../../c-api/exceptions.rst:662
msgid ""
"The default Python signal handler for :c:macro:`!SIGINT` raises the "
":exc:`KeyboardInterrupt` exception."
msgstr ""
"针对 :c:macro:`!SIGINT` 的默认 Python 信号处理器会引发 :exc:`KeyboardInterrupt` 异常。"

#: ../../c-api/exceptions.rst:673
msgid ""
"Simulate the effect of a :c:macro:`!SIGINT` signal arriving. This is "
"equivalent to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""
"模拟一个 :c:macro:`!SIGINT` 信号到达的效果。 这等价于 ``PyErr_SetInterruptEx(SIGINT)``。"

#: ../../c-api/exceptions.rst:677 ../../c-api/exceptions.rst:704
msgid ""
"This function is async-signal-safe.  It can be called without the "
":term:`GIL` and from a C signal handler."
msgstr "此函数是异步信号安全的。 它可以不带 :term:`GIL` 并由 C 信号处理器来调用。"

#: ../../c-api/exceptions.rst:687
msgid ""
"Simulate the effect of a signal arriving. The next time "
":c:func:`PyErr_CheckSignals` is called,  the Python signal handler for the "
"given signal number will be called."
msgstr ""
"模拟一个信号到达的效果。 当下次 :c:func:`PyErr_CheckSignals` 被调用时，将会调用针对指定的信号编号的 Python "
"信号处理器。"

#: ../../c-api/exceptions.rst:691
msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"此函数可由自行设置信号处理，并希望 Python 信号处理器会在请求中断时（例如当用户按下 Ctrl-C 来中断操作时）按照预期被唤起的 C "
"代码来调用。"

#: ../../c-api/exceptions.rst:696
msgid ""
"If the given signal isn't handled by Python (it was set to "
":py:const:`signal.SIG_DFL` or :py:const:`signal.SIG_IGN`), it will be "
"ignored."
msgstr ""
"如果给定的信号不是由 Python 来处理的 (即被设为 :py:const:`signal.SIG_DFL` 或 "
":py:const:`signal.SIG_IGN`)，它将会被忽略。"

#: ../../c-api/exceptions.rst:699
msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"如果 *signum* 在被允许的信号编号范围之外，将返回 ``-1``。 在其他情况下，则返回 ``0``。 错误指示符绝不会被此函数所修改。"

#: ../../c-api/exceptions.rst:712
msgid ""
"This utility function specifies a file descriptor to which the signal number"
" is written as a single byte whenever a signal is received. *fd* must be "
"non-blocking. It returns the previous such file descriptor."
msgstr ""
"这个工具函数指定了一个每当收到信号时将被作为以单个字节的形式写入信号编号的目标的文件描述符。 *fd* 必须是非阻塞的。 "
"它将返回前一个这样的文件描述符。"

#: ../../c-api/exceptions.rst:716
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only"
" be called from the main thread."
msgstr ""
"设置值 ``-1`` 将禁用该特性；这是初始状态。 这等价于 Python 中的 "
":func:`signal.set_wakeup_fd`，但是没有任何错误检查。 *fd* 应当是一个有效的文件描述符。 此函数应当只从主线程来调用。"

#: ../../c-api/exceptions.rst:721
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，此函数现在也支持套接字处理。"

#: ../../c-api/exceptions.rst:726
msgid "Exception Classes"
msgstr "Exception 类"

#: ../../c-api/exceptions.rst:730
msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"这个工具函数会创建并返回一个新的异常类。 *name* 参数必须为新异常的名称，是 ``module.classname`` 形式的 C 字符串。 "
"*base* 和 *dict* 参数通常为 ``NULL``。 这将创建一个派生自 :exc:`Exception` 的类对象（在 C 中可以通过 "
":c:data:`PyExc_Exception` 访问）。"

#: ../../c-api/exceptions.rst:736
msgid ""
"The :attr:`~type.__module__` attribute of the new class is set to the first "
"part (up to the last dot) of the *name* argument, and the class name is set "
"to the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class"
" variables and methods."
msgstr ""
"新类的 :attr:`~type.__module__` 属性将被设为 *name* "
"参数的前半部分（最后一个点号之前），而类名将被设为后半部分（最后一个点号之后）。 *base* "
"参数可被用来指定替代基类；它可以是一个类或是一个由类组成的元组。 *dict* 参数可被用来指定一个由类变量和方法组成的字典。"

#: ../../c-api/exceptions.rst:745
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"和 :c:func:`PyErr_NewException` 一样，除了可以轻松地给新的异常类一个文档字符串：如果 *doc* "
"属性非空，它将用作异常类的文档字符串。"

#: ../../c-api/exceptions.rst:754
msgid ""
"Return non-zero if *ob* is an exception class, zero otherwise. This function"
" always succeeds."
msgstr "如果 *ob* 是一个异常类则返回非零值，否则返回零。 此函数总是会成功执行。"

#: ../../c-api/exceptions.rst:759
msgid "Return :c:member:`~PyTypeObject.tp_name` of the exception class *ob*."
msgstr "返回异常类 *ob* 的 :c:member:`~PyTypeObject.tp_name`。"

#: ../../c-api/exceptions.rst:763
msgid "Exception Objects"
msgstr "异常对象"

#: ../../c-api/exceptions.rst:767
msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__traceback__` "
"attribute. If there is no traceback associated, this returns ``NULL``."
msgstr ""
"将与异常相关联的回溯作为一个新引用返回，可以通过 :attr:`~BaseException.__traceback__` 属性在 Python "
"中访问。 如果没有已关联的回溯，则返回 ``NULL``。"

#: ../../c-api/exceptions.rst:775
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to"
" clear it."
msgstr "将异常关联的回溯设置为 *tb* 。使用 ``Py_None`` 清除它。"

#: ../../c-api/exceptions.rst:781
msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through the :attr:`~BaseException.__context__` attribute. If "
"there is no context associated, this returns ``NULL``."
msgstr ""
"将与异常相关联的上下文（在处理 *ex* 过程中引发的另一个异常实例）作为一个新引用返回，可以通过 "
":attr:`~BaseException.__context__` 属性在 Python 中访问。 如果没有已关联的上下文，则返回 ``NULL``。"

#: ../../c-api/exceptions.rst:789
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"将与异常相关联的上下文设置为 *ctx*。 使用 ``NULL`` 来清空它。 没有用来确保 *ctx* 是一个异常实例的类型检查。 这将窃取一个指向 "
"*ctx* 的引用。"

#: ../../c-api/exceptions.rst:796
msgid ""
"Return the cause (either an exception instance, or ``None``, set by ``raise "
"... from ...``) associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__cause__` "
"attribute."
msgstr ""
"将与异常相关联的原因（一个异常实例，或为 ``None``，由 ``raise ... from ...`` 设置）作为一个新引用返回，可通过 "
":attr:`~BaseException.__cause__` 属性在 Python 中访问。"

#: ../../c-api/exceptions.rst:804
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or ``None``.  This steals a reference to *cause*."
msgstr ""
"将与异常相关联的原因设为 *cause*。 使用 ``NULL`` 来清空它。 不存在类型检查用来确保 *cause* 是一个异常实例或为 "
"``None``。 这个偷取一个指向 *cause* 的引用。"

#: ../../c-api/exceptions.rst:808
msgid ""
"The :attr:`~BaseException.__suppress_context__` attribute is implicitly set "
"to ``True`` by this function."
msgstr ":attr:`~BaseException.__suppress_context__` 属性会被此函数隐式地设为 ``True``。"

#: ../../c-api/exceptions.rst:814
msgid "Return :attr:`~BaseException.args` of exception *ex*."
msgstr "返回异常 *ex* 的 :attr:`~BaseException.args`。"

#: ../../c-api/exceptions.rst:819
msgid "Set :attr:`~BaseException.args` of exception *ex* to *args*."
msgstr "将异常 *ex* 的 :attr:`~BaseException.args` 设为 *args*。"

#: ../../c-api/exceptions.rst:823
msgid ""
"Implement part of the interpreter's implementation of :keyword:`!except*`. "
"*orig* is the original exception that was caught, and *excs* is the list of "
"the exceptions that need to be raised. This list contains the unhandled part"
" of *orig*, if any, as well as the exceptions that were raised from the "
":keyword:`!except*` clauses (so they have a different traceback from *orig*)"
" and those that were reraised (and have the same traceback as *orig*). "
"Return the :exc:`ExceptionGroup` that needs to be reraised in the end, or "
"``None`` if there is nothing to reraise."
msgstr ""
"解释器的 :keyword:`!except*` 实现的具体实现部分。 *orig* 是被捕获的原始异常，而 *excs* "
"是需要被引发的异常组成的列表。 该列表包含 *orig* 可能存在的未被处理的部分，以及在 :keyword:`!except*` "
"子句中被引发的异常（因而它们具有与 *orig* 不同的回溯数据）和被重新引发的异常（因而它们具有与 *orig* 相同的回溯）。 返回需要被最终引发的"
" :exc:`ExceptionGroup`，或者如果没有要被引发的异常则返回 ``None``。"

#: ../../c-api/exceptions.rst:837
msgid "Unicode Exception Objects"
msgstr "Unicode 异常对象"

#: ../../c-api/exceptions.rst:839
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr "下列函数被用于创建和修改来自 C 的 Unicode 异常。"

#: ../../c-api/exceptions.rst:843
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are"
" UTF-8 encoded strings."
msgstr ""
"创建一个 :class:`UnicodeDecodeError` 对象并附带 *encoding*, *object*, *length*, "
"*start*, *end* 和 *reason* 等属性。 *encoding* 和 *reason* 为 UTF-8 编码的字符串。"

#: ../../c-api/exceptions.rst:850
msgid "Return the *encoding* attribute of the given exception object."
msgstr "返回给定异常对象的 *encoding* 属性"

#: ../../c-api/exceptions.rst:856
msgid "Return the *object* attribute of the given exception object."
msgstr "返回给定异常对象的 *object* 属性"

#: ../../c-api/exceptions.rst:862
msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"获取给定异常对象的 *start* 属性并将其放入 *\\*start*。 *start* 必须不为 ``NULL``。 成功时返回 "
"``0``，失败时返回 ``-1``。"

#: ../../c-api/exceptions.rst:870
msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr "将给定异常对象的 *start* 属性设为 *start*。 成功时返回 ``0``，失败时返回 ``-1``。"

#: ../../c-api/exceptions.rst:877
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"获取给定异常对象的 *end* 属性并将其放入 *\\*end*。 *end* 必须不为 ``NULL``。 成功时返回 ``0``，失败时返回 "
"``-1``。"

#: ../../c-api/exceptions.rst:885
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr "将给定异常对象的 *end* 属性设为 *end*。 成功时返回 ``0``，失败时返回 ``-1``。"

#: ../../c-api/exceptions.rst:892
msgid "Return the *reason* attribute of the given exception object."
msgstr "返回给定异常对象的 *reason* 属性"

#: ../../c-api/exceptions.rst:898
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr "将给定异常对象的 *reason* 属性设为 *reason*。 成功时返回 ``0``，失败时返回 ``-1``。"

#: ../../c-api/exceptions.rst:905
msgid "Recursion Control"
msgstr "递归控制"

#: ../../c-api/exceptions.rst:907
msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"这两个函数提供了一种在 C 层级上进行安全的递归调用的方式，在核心模块与扩展模块中均适用。 当递归代码不一定会唤起 Python "
"代码（后者会自动跟踪其递归深度）时就需要用到它们。 它们对于 *tp_call* 实现来说也无必要因为 :ref:`调用协议 <call>` "
"会负责递归处理。"

#: ../../c-api/exceptions.rst:916
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr "标记一个递归的 C 层级调用即将被执行的点位。"

#: ../../c-api/exceptions.rst:918
msgid ""
"If :c:macro:`!USE_STACKCHECK` is defined, this function checks if the OS "
"stack overflowed using :c:func:`PyOS_CheckStack`.  If this is the case, it "
"sets a :exc:`MemoryError` and returns a nonzero value."
msgstr ""
"如果定义了 :c:macro:`!USE_STACKCHECK`，此函数会使用 :c:func:`PyOS_CheckStack` 来检查 OS "
"栈是否溢出。 如果发生了这种情况，它将设置一个 :exc:`MemoryError` 并返回非零值。"

#: ../../c-api/exceptions.rst:922
msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""
"随后此函数将检查是否达到递归限制。 如果是的话，将设置一个 :exc:`RecursionError` 并返回一个非零值。 在其他情况下，则返回零。"

#: ../../c-api/exceptions.rst:926
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*where* 应为一个 UTF-8 编码的字符串如 ``\" in instance check\"``，它将与由递归深度限制所导致的 "
":exc:`RecursionError` 消息相拼接。"

#: ../../c-api/exceptions.rst:930 ../../c-api/exceptions.rst:938
msgid ""
"This function is now also available in the :ref:`limited API <limited-c-"
"api>`."
msgstr "此函数现在也在 :ref:`受限 API <limited-c-api>` 中可用。"

#: ../../c-api/exceptions.rst:935
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"结束一个 :c:func:`Py_EnterRecursiveCall`。 必须针对 :c:func:`Py_EnterRecursiveCall` "
"的每个 *成功的* 唤起操作执行一次调用。"

#: ../../c-api/exceptions.rst:941
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, "
":c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"正确地针对容器类型实现 :c:member:`~PyTypeObject.tp_repr` 需要特别的递归处理。 "
"在保护栈之外，:c:member:`~PyTypeObject.tp_repr` 还需要追踪对象以防止出现循环。 以下两个函数将帮助完成此功能。 "
"从实际效果来说，这两个函数是 C 中对应 :func:`reprlib.recursive_repr` 的等价物。"

#: ../../c-api/exceptions.rst:949
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr "在 :c:member:`~PyTypeObject.tp_repr` 实现的开头被调用以检测循环。"

#: ../../c-api/exceptions.rst:952
msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, "
":class:`dict` objects return ``{...}`` and :class:`list` objects return "
"``[...]``."
msgstr ""
"如果对象已经被处理，此函数将返回一个正整数。 在此情况下 :c:member:`~PyTypeObject.tp_repr` "
"实现应当返回一个指明发生循环的字符串对象。 例如，:class:`dict` 对象将返回 ``{...}`` 而 :class:`list` 对象将返回"
" ``[...]``。"

#: ../../c-api/exceptions.rst:958
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"如果已达到递归限制则此函数将返回一个负正数。 在此情况下 :c:member:`~PyTypeObject.tp_repr` 实现通常应当返回 "
"``NULL``。"

#: ../../c-api/exceptions.rst:962
msgid ""
"Otherwise, the function returns zero and the "
":c:member:`~PyTypeObject.tp_repr` implementation can continue normally."
msgstr "在其他情况下，此函数将返回零而 :c:member:`~PyTypeObject.tp_repr` 实现将可正常继续。"

#: ../../c-api/exceptions.rst:967
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of "
":c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"结束一个 :c:func:`Py_ReprEnter`。 必须针对每个返回零的 :c:func:`Py_ReprEnter` 的唤起操作调用一次。"

#: ../../c-api/exceptions.rst:974
msgid "Standard Exceptions"
msgstr "标准异常"

#: ../../c-api/exceptions.rst:976
msgid ""
"All standard Python exceptions are available as global variables whose names"
" are ``PyExc_`` followed by the Python exception name.  These have the type "
":c:expr:`PyObject*`; they are all class objects.  For completeness, here are"
" all the variables:"
msgstr ""
"所有的标准 Python 异常都可作为名称为 ``PyExc_`` 跟上 Python 异常名称的全局变量来访问。 这些变量的类型为 "
":c:expr:`PyObject*`；它们都是类对象。 下面完整列出了全部的变量:"

#: ../../c-api/exceptions.rst:1039 ../../c-api/exceptions.rst:1179
#: ../../c-api/exceptions.rst:1225
msgid "C Name"
msgstr "C 名称"

#: ../../c-api/exceptions.rst:1039 ../../c-api/exceptions.rst:1225
msgid "Python Name"
msgstr "Python 名称"

#: ../../c-api/exceptions.rst:1039 ../../c-api/exceptions.rst:1179
#: ../../c-api/exceptions.rst:1225
msgid "Notes"
msgstr "备注"

#: ../../c-api/exceptions.rst:1041
msgid ":c:data:`PyExc_BaseException`"
msgstr ":c:data:`PyExc_BaseException`"

#: ../../c-api/exceptions.rst:1041
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:1041 ../../c-api/exceptions.rst:1043
#: ../../c-api/exceptions.rst:1045 ../../c-api/exceptions.rst:1047
#: ../../c-api/exceptions.rst:1093 ../../c-api/exceptions.rst:1105
msgid "[1]_"
msgstr "[1]_"

#: ../../c-api/exceptions.rst:1043
msgid ":c:data:`PyExc_BaseExceptionGroup`"
msgstr ":c:data:`PyExc_BaseExceptionGroup`"

#: ../../c-api/exceptions.rst:1043
msgid ":exc:`BaseExceptionGroup`"
msgstr ":exc:`BaseExceptionGroup`"

#: ../../c-api/exceptions.rst:1045
msgid ":c:data:`PyExc_Exception`"
msgstr ":c:data:`PyExc_Exception`"

#: ../../c-api/exceptions.rst:1045
msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

#: ../../c-api/exceptions.rst:1047
msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ":c:data:`PyExc_ArithmeticError`"

#: ../../c-api/exceptions.rst:1047
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

#: ../../c-api/exceptions.rst:1049
msgid ":c:data:`PyExc_AssertionError`"
msgstr ":c:data:`PyExc_AssertionError`"

#: ../../c-api/exceptions.rst:1049
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:1051
msgid ":c:data:`PyExc_AttributeError`"
msgstr ":c:data:`PyExc_AttributeError`"

#: ../../c-api/exceptions.rst:1051
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:1053
msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ":c:data:`PyExc_BlockingIOError`"

#: ../../c-api/exceptions.rst:1053
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:1055
msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ":c:data:`PyExc_BrokenPipeError`"

#: ../../c-api/exceptions.rst:1055
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:1057
msgid ":c:data:`PyExc_BufferError`"
msgstr ":c:data:`PyExc_BufferError`"

#: ../../c-api/exceptions.rst:1057
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:1059
msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ":c:data:`PyExc_ChildProcessError`"

#: ../../c-api/exceptions.rst:1059
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:1061
msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ":c:data:`PyExc_ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:1061
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:1063
msgid ":c:data:`PyExc_ConnectionError`"
msgstr ":c:data:`PyExc_ConnectionError`"

#: ../../c-api/exceptions.rst:1063
msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

#: ../../c-api/exceptions.rst:1065
msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ":c:data:`PyExc_ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:1065
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:1067
msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ":c:data:`PyExc_ConnectionResetError`"

#: ../../c-api/exceptions.rst:1067
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

#: ../../c-api/exceptions.rst:1069
msgid ":c:data:`PyExc_EOFError`"
msgstr ":c:data:`PyExc_EOFError`"

#: ../../c-api/exceptions.rst:1069
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:1071
msgid ":c:data:`PyExc_FileExistsError`"
msgstr ":c:data:`PyExc_FileExistsError`"

#: ../../c-api/exceptions.rst:1071
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:1073
msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ":c:data:`PyExc_FileNotFoundError`"

#: ../../c-api/exceptions.rst:1073
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:1075
msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ":c:data:`PyExc_FloatingPointError`"

#: ../../c-api/exceptions.rst:1075
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:1077
msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ":c:data:`PyExc_GeneratorExit`"

#: ../../c-api/exceptions.rst:1077
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:1079
msgid ":c:data:`PyExc_ImportError`"
msgstr ":c:data:`PyExc_ImportError`"

#: ../../c-api/exceptions.rst:1079
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:1081
msgid ":c:data:`PyExc_IndentationError`"
msgstr ":c:data:`PyExc_IndentationError`"

#: ../../c-api/exceptions.rst:1081
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:1083
msgid ":c:data:`PyExc_IndexError`"
msgstr ":c:data:`PyExc_IndexError`"

#: ../../c-api/exceptions.rst:1083
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:1085
msgid ":c:data:`PyExc_InterruptedError`"
msgstr ":c:data:`PyExc_InterruptedError`"

#: ../../c-api/exceptions.rst:1085
msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

#: ../../c-api/exceptions.rst:1087
msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ":c:data:`PyExc_IsADirectoryError`"

#: ../../c-api/exceptions.rst:1087
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:1089
msgid ":c:data:`PyExc_KeyError`"
msgstr ":c:data:`PyExc_KeyError`"

#: ../../c-api/exceptions.rst:1089
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:1091
msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ":c:data:`PyExc_KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:1091
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:1093
msgid ":c:data:`PyExc_LookupError`"
msgstr ":c:data:`PyExc_LookupError`"

#: ../../c-api/exceptions.rst:1093
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:1095
msgid ":c:data:`PyExc_MemoryError`"
msgstr ":c:data:`PyExc_MemoryError`"

#: ../../c-api/exceptions.rst:1095
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:1097
msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ":c:data:`PyExc_ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:1097
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:1099
msgid ":c:data:`PyExc_NameError`"
msgstr ":c:data:`PyExc_NameError`"

#: ../../c-api/exceptions.rst:1099
msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

#: ../../c-api/exceptions.rst:1101
msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ":c:data:`PyExc_NotADirectoryError`"

#: ../../c-api/exceptions.rst:1101
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:1103
msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ":c:data:`PyExc_NotImplementedError`"

#: ../../c-api/exceptions.rst:1103
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:1105
msgid ":c:data:`PyExc_OSError`"
msgstr ":c:data:`PyExc_OSError`"

#: ../../c-api/exceptions.rst:1105
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:1107
msgid ":c:data:`PyExc_OverflowError`"
msgstr ":c:data:`PyExc_OverflowError`"

#: ../../c-api/exceptions.rst:1107
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:1109
msgid ":c:data:`PyExc_PermissionError`"
msgstr ":c:data:`PyExc_PermissionError`"

#: ../../c-api/exceptions.rst:1109
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:1111
msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ":c:data:`PyExc_ProcessLookupError`"

#: ../../c-api/exceptions.rst:1111
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:1113
msgid ":c:data:`PyExc_PythonFinalizationError`"
msgstr ":c:data:`PyExc_PythonFinalizationError`"

#: ../../c-api/exceptions.rst:1113
msgid ":exc:`PythonFinalizationError`"
msgstr ":exc:`PythonFinalizationError`"

#: ../../c-api/exceptions.rst:1115
msgid ":c:data:`PyExc_RecursionError`"
msgstr ":c:data:`PyExc_RecursionError`"

#: ../../c-api/exceptions.rst:1115
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:1117
msgid ":c:data:`PyExc_ReferenceError`"
msgstr ":c:data:`PyExc_ReferenceError`"

#: ../../c-api/exceptions.rst:1117
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:1119
msgid ":c:data:`PyExc_RuntimeError`"
msgstr ":c:data:`PyExc_RuntimeError`"

#: ../../c-api/exceptions.rst:1119
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:1121
msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ":c:data:`PyExc_StopAsyncIteration`"

#: ../../c-api/exceptions.rst:1121
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:1123
msgid ":c:data:`PyExc_StopIteration`"
msgstr ":c:data:`PyExc_StopIteration`"

#: ../../c-api/exceptions.rst:1123
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:1125
msgid ":c:data:`PyExc_SyntaxError`"
msgstr ":c:data:`PyExc_SyntaxError`"

#: ../../c-api/exceptions.rst:1125
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:1127
msgid ":c:data:`PyExc_SystemError`"
msgstr ":c:data:`PyExc_SystemError`"

#: ../../c-api/exceptions.rst:1127
msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

#: ../../c-api/exceptions.rst:1129
msgid ":c:data:`PyExc_SystemExit`"
msgstr ":c:data:`PyExc_SystemExit`"

#: ../../c-api/exceptions.rst:1129
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:1131
msgid ":c:data:`PyExc_TabError`"
msgstr ":c:data:`PyExc_TabError`"

#: ../../c-api/exceptions.rst:1131
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:1133
msgid ":c:data:`PyExc_TimeoutError`"
msgstr ":c:data:`PyExc_TimeoutError`"

#: ../../c-api/exceptions.rst:1133
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:1135
msgid ":c:data:`PyExc_TypeError`"
msgstr ":c:data:`PyExc_TypeError`"

#: ../../c-api/exceptions.rst:1135
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:1137
msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ":c:data:`PyExc_UnboundLocalError`"

#: ../../c-api/exceptions.rst:1137
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:1139
msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ":c:data:`PyExc_UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:1139
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:1141
msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ":c:data:`PyExc_UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:1141
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:1143
msgid ":c:data:`PyExc_UnicodeError`"
msgstr ":c:data:`PyExc_UnicodeError`"

#: ../../c-api/exceptions.rst:1143
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:1145
msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ":c:data:`PyExc_UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:1145
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:1147
msgid ":c:data:`PyExc_ValueError`"
msgstr ":c:data:`PyExc_ValueError`"

#: ../../c-api/exceptions.rst:1147
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:1149
msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ":c:data:`PyExc_ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1149
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1152
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and "
":c:data:`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and "
":c:data:`PyExc_TimeoutError` 介绍如下 :pep:`3151`."

#: ../../c-api/exceptions.rst:1162
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` 和 :c:data:`PyExc_RecursionError`."

#: ../../c-api/exceptions.rst:1165
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

#: ../../c-api/exceptions.rst:1168
msgid ":c:data:`PyExc_BaseExceptionGroup`."
msgstr ":c:data:`PyExc_BaseExceptionGroup`."

#: ../../c-api/exceptions.rst:1171
msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr "这些是兼容性别名 :c:data:`PyExc_OSError`:"

#: ../../c-api/exceptions.rst:1181
msgid ":c:data:`!PyExc_EnvironmentError`"
msgstr ":c:data:`!PyExc_EnvironmentError`"

#: ../../c-api/exceptions.rst:1183
msgid ":c:data:`!PyExc_IOError`"
msgstr ":c:data:`!PyExc_IOError`"

#: ../../c-api/exceptions.rst:1185
msgid ":c:data:`!PyExc_WindowsError`"
msgstr ":c:data:`!PyExc_WindowsError`"

#: ../../c-api/exceptions.rst:1185
msgid "[2]_"
msgstr "[2]_"

#: ../../c-api/exceptions.rst:1188
msgid "These aliases used to be separate exception types."
msgstr "这些别名曾经是单独的异常类型。"

#: ../../c-api/exceptions.rst:1191 ../../c-api/exceptions.rst:1258
msgid "Notes:"
msgstr "注："

#: ../../c-api/exceptions.rst:1194
msgid "This is a base class for other standard exceptions."
msgstr "这是其他标准异常的基类。"

#: ../../c-api/exceptions.rst:1197
msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr "仅在 Windows 中定义；检测是否定义了预处理程序宏 ``MS_WINDOWS`` ，以便保护用到它的代码。"

#: ../../c-api/exceptions.rst:1203
msgid "Standard Warning Categories"
msgstr "标准警告类别"

#: ../../c-api/exceptions.rst:1205
msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These have"
" the type :c:expr:`PyObject*`; they are all class objects. For completeness,"
" here are all the variables:"
msgstr ""
"所有的标准 Python 警告类别都可以用作全局变量，其名称为 ``PyExc_`` 加上 Python 异常名称。 这些类型是 "
":c:expr:`PyObject*` 类型；它们都是类对象。 以下列出了全部的变量名称:"

#: ../../c-api/exceptions.rst:1227
msgid ":c:data:`PyExc_Warning`"
msgstr ":c:data:`PyExc_Warning`"

#: ../../c-api/exceptions.rst:1227
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1227
msgid "[3]_"
msgstr "[3]_"

#: ../../c-api/exceptions.rst:1229
msgid ":c:data:`PyExc_BytesWarning`"
msgstr ":c:data:`PyExc_BytesWarning`"

#: ../../c-api/exceptions.rst:1229
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1231
msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ":c:data:`PyExc_DeprecationWarning`"

#: ../../c-api/exceptions.rst:1231
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1233
msgid ":c:data:`PyExc_EncodingWarning`"
msgstr ":c:data:`PyExc_EncodingWarning`"

#: ../../c-api/exceptions.rst:1233
msgid ":exc:`EncodingWarning`"
msgstr ":exc:`EncodingWarning`"

#: ../../c-api/exceptions.rst:1235
msgid ":c:data:`PyExc_FutureWarning`"
msgstr ":c:data:`PyExc_FutureWarning`"

#: ../../c-api/exceptions.rst:1235
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1237
msgid ":c:data:`PyExc_ImportWarning`"
msgstr ":c:data:`PyExc_ImportWarning`"

#: ../../c-api/exceptions.rst:1237
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1239
msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ":c:data:`PyExc_PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1239
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1241
msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ":c:data:`PyExc_ResourceWarning`"

#: ../../c-api/exceptions.rst:1241
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1243
msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ":c:data:`PyExc_RuntimeWarning`"

#: ../../c-api/exceptions.rst:1243
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1245
msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ":c:data:`PyExc_SyntaxWarning`"

#: ../../c-api/exceptions.rst:1245
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1247
msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ":c:data:`PyExc_UnicodeWarning`"

#: ../../c-api/exceptions.rst:1247
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1249
msgid ":c:data:`PyExc_UserWarning`"
msgstr ":c:data:`PyExc_UserWarning`"

#: ../../c-api/exceptions.rst:1249
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1252
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1255
msgid ":c:data:`PyExc_EncodingWarning`."
msgstr ":c:data:`PyExc_EncodingWarning`."

#: ../../c-api/exceptions.rst:1261
msgid "This is a base class for other standard warning categories."
msgstr "这是其他标准警告类别的基类。"

#: ../../c-api/exceptions.rst:183
msgid "strerror (C function)"
msgstr "strerror (C 函数)"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "module"
msgstr "module"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "signal"
msgstr "signal"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
msgid "SIGINT (C macro)"
msgstr "SIGINT (C 宏)"

#: ../../c-api/exceptions.rst:637 ../../c-api/exceptions.rst:668
#: ../../c-api/exceptions.rst:683
msgid "KeyboardInterrupt (built-in exception)"
msgstr "KeyboardInterrupt (内置异常)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_BaseException (C var)"
msgstr "PyExc_BaseException (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_BaseExceptionGroup (C var)"
msgstr "PyExc_BaseExceptionGroup (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_Exception (C var)"
msgstr "PyExc_Exception (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ArithmeticError (C var)"
msgstr "PyExc_ArithmeticError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_AssertionError (C var)"
msgstr "PyExc_AssertionError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_AttributeError (C var)"
msgstr "PyExc_AttributeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_BlockingIOError (C var)"
msgstr "PyExc_BlockingIOError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_BrokenPipeError (C var)"
msgstr "PyExc_BrokenPipeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_BufferError (C var)"
msgstr "PyExc_BufferError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ChildProcessError (C var)"
msgstr "PyExc_ChildProcessError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ConnectionAbortedError (C var)"
msgstr "PyExc_ConnectionAbortedError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ConnectionError (C var)"
msgstr "PyExc_ConnectionError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ConnectionRefusedError (C var)"
msgstr "PyExc_ConnectionRefusedError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ConnectionResetError (C var)"
msgstr "PyExc_ConnectionResetError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_EOFError (C var)"
msgstr "PyExc_EOFError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_FileExistsError (C var)"
msgstr "PyExc_FileExistsError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_FileNotFoundError (C var)"
msgstr "PyExc_FileNotFoundError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_FloatingPointError (C var)"
msgstr "PyExc_FloatingPointError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_GeneratorExit (C var)"
msgstr "PyExc_GeneratorExit (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ImportError (C var)"
msgstr "PyExc_ImportError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_IndentationError (C var)"
msgstr "PyExc_IndentationError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_IndexError (C var)"
msgstr "PyExc_IndexError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_InterruptedError (C var)"
msgstr "PyExc_InterruptedError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_IsADirectoryError (C var)"
msgstr "PyExc_IsADirectoryError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_KeyError (C var)"
msgstr "PyExc_KeyError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_KeyboardInterrupt (C var)"
msgstr "PyExc_KeyboardInterrupt (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_LookupError (C var)"
msgstr "PyExc_LookupError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_MemoryError (C var)"
msgstr "PyExc_MemoryError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ModuleNotFoundError (C var)"
msgstr "PyExc_ModuleNotFoundError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_NameError (C var)"
msgstr "PyExc_NameError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_NotADirectoryError (C var)"
msgstr "PyExc_NotADirectoryError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_NotImplementedError (C var)"
msgstr "PyExc_NotImplementedError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_OSError (C var)"
msgstr "PyExc_OSError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_OverflowError (C var)"
msgstr "PyExc_OverflowError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_PermissionError (C var)"
msgstr "PyExc_PermissionError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ProcessLookupError (C var)"
msgstr "PyExc_ProcessLookupError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_PythonFinalizationError (C var)"
msgstr "PyExc_PythonFinalizationError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_RecursionError (C var)"
msgstr "PyExc_RecursionError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ReferenceError (C var)"
msgstr "PyExc_ReferenceError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_RuntimeError (C var)"
msgstr "PyExc_RuntimeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_StopAsyncIteration (C var)"
msgstr "PyExc_StopAsyncIteration (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_StopIteration (C var)"
msgstr "PyExc_StopIteration (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_SyntaxError (C var)"
msgstr "PyExc_SyntaxError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_SystemError (C var)"
msgstr "PyExc_SystemError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_SystemExit (C var)"
msgstr "PyExc_SystemExit (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_TabError (C var)"
msgstr "PyExc_TabError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_TimeoutError (C var)"
msgstr "PyExc_TimeoutError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_TypeError (C var)"
msgstr "PyExc_TypeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_UnboundLocalError (C var)"
msgstr "PyExc_UnboundLocalError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_UnicodeDecodeError (C var)"
msgstr "PyExc_UnicodeDecodeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_UnicodeEncodeError (C var)"
msgstr "PyExc_UnicodeEncodeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_UnicodeError (C var)"
msgstr "PyExc_UnicodeError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_UnicodeTranslateError (C var)"
msgstr "PyExc_UnicodeTranslateError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ValueError (C var)"
msgstr "PyExc_ValueError (C 变量)"

#: ../../c-api/exceptions.rst:981
msgid "PyExc_ZeroDivisionError (C var)"
msgstr "PyExc_ZeroDivisionError (C 变量)"

#: ../../c-api/exceptions.rst:1173
msgid "PyExc_EnvironmentError (C var)"
msgstr "PyExc_EnvironmentError (C 变量)"

#: ../../c-api/exceptions.rst:1173
msgid "PyExc_IOError (C var)"
msgstr "PyExc_IOError (C 变量)"

#: ../../c-api/exceptions.rst:1173
msgid "PyExc_WindowsError (C var)"
msgstr "PyExc_WindowsError (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_Warning (C var)"
msgstr "PyExc_Warning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_BytesWarning (C var)"
msgstr "PyExc_BytesWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_DeprecationWarning (C var)"
msgstr "PyExc_DeprecationWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_EncodingWarning (C var)"
msgstr "PyExc_EncodingWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_FutureWarning (C var)"
msgstr "PyExc_FutureWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_ImportWarning (C var)"
msgstr "PyExc_ImportWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_PendingDeprecationWarning (C var)"
msgstr "PyExc_PendingDeprecationWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_ResourceWarning (C var)"
msgstr "PyExc_ResourceWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_RuntimeWarning (C var)"
msgstr "PyExc_RuntimeWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_SyntaxWarning (C var)"
msgstr "PyExc_SyntaxWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_UnicodeWarning (C var)"
msgstr "PyExc_UnicodeWarning (C 变量)"

#: ../../c-api/exceptions.rst:1210
msgid "PyExc_UserWarning (C var)"
msgstr "PyExc_UserWarning (C 变量)"
