# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# cdarlint <cdarling@126.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# 欢 王 <whthu168@163.com>, 2021
# Woostundy <woostundy@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Natasha Li <lihaiyanziji@126.com>, 2021
# Yan Gao <gao.yan.gg1994@gmail.com>, 2021
# Meng Du <alphanow@gmail.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging.rst:3
msgid "Logging HOWTO"
msgstr "日志常用指引"

#: ../../howto/logging.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/logging.rst:5
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging.rst:12
msgid "Basic Logging Tutorial"
msgstr "日志基础教程 "

#: ../../howto/logging.rst:14
msgid ""
"Logging is a means of tracking events that happen when some software runs. "
"The software's developer adds logging calls to their code to indicate that "
"certain events have occurred. An event is described by a descriptive message"
" which can optionally contain variable data (i.e. data that is potentially "
"different for each occurrence of the event). Events also have an importance "
"which the developer ascribes to the event; the importance can also be called"
" the *level* or *severity*."
msgstr ""
"日志是对软件执行时所发生事件的一种追踪方式。软件开发人员对他们的代码添加日志调用，借此来指示某事件的发生。一个事件通过一些包含变量数据的描述信息来描述（比如：每个事件发生时的数据都是不同的）。开发者还会区分事件的重要性，重要性也被称为"
" *等级* 或 *严重性*。"

#: ../../howto/logging.rst:23
msgid "When to use logging"
msgstr "什么时候使用日志"

#: ../../howto/logging.rst:25
msgid ""
"Logging provides a set of convenience functions for simple logging usage. "
"These are :func:`debug`, :func:`info`, :func:`warning`, :func:`error` and "
":func:`critical`. To determine when to use logging, see the table below, "
"which states, for each of a set of common tasks, the best tool to use for "
"it."
msgstr ""
"对于简单的日志使用来说日志功能提供了一系列便利的函数。它们是 "
":func:`debug`，:func:`info`，:func:`warning`，:func:`error` 和 "
":func:`critical`。想要决定何时使用日志，请看下表，其中显示了对于每个通用任务集合来说最好的工具。"

#: ../../howto/logging.rst:31
msgid "Task you want to perform"
msgstr "你想要执行的任务"

#: ../../howto/logging.rst:31
msgid "The best tool for the task"
msgstr "此任务最好的工具"

#: ../../howto/logging.rst:33
msgid ""
"Display console output for ordinary usage of a command line script or "
"program"
msgstr "对于命令行或程序的应用，结果显示在控制台。"

#: ../../howto/logging.rst:33
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../howto/logging.rst:37
msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr "在对程序的普通操作发生时提交事件报告(比如：状态监控和错误调查)"

#: ../../howto/logging.rst:37
msgid ""
":func:`logging.info` (or :func:`logging.debug` for very detailed output for "
"diagnostic purposes)"
msgstr ":func:`logging.info` 函数(当有诊断目的需要详细输出信息时使用 :func:`logging.debug` 函数)"

#: ../../howto/logging.rst:42
msgid "Issue a warning regarding a particular runtime event"
msgstr "提出一个警告信息基于一个特殊的运行时事件"

#: ../../howto/logging.rst:42
msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ":func:`warnings.warn` 位于代码库中，该事件是可以避免的，需要修改客户端应用以消除告警"

#: ../../howto/logging.rst:47
msgid ""
":func:`logging.warning` if there is nothing the client application can do "
"about the situation, but the event should still be noted"
msgstr ":func:`logging.warning` 不需要修改客户端应用，但是该事件还是需要引起关注"

#: ../../howto/logging.rst:52
msgid "Report an error regarding a particular runtime event"
msgstr "对一个特殊的运行时事件报告错误"

#: ../../howto/logging.rst:52
msgid "Raise an exception"
msgstr "引发异常"

#: ../../howto/logging.rst:55
msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr "报告错误而不引发异常(如在长时间运行中的服务端进程的错误处理)"

#: ../../howto/logging.rst:55
msgid ""
":func:`logging.error`, :func:`logging.exception` or :func:`logging.critical`"
" as appropriate for the specific error and application domain"
msgstr ""
":func:`logging.error`, :func:`logging.exception` 或 :func:`logging.critical` "
"分别适用于特定的错误及应用领域"

#: ../../howto/logging.rst:62
msgid ""
"The logging functions are named after the level or severity of the events "
"they are used to track. The standard levels and their applicability are "
"described below (in increasing order of severity):"
msgstr "日志功能应以所追踪事件级别或严重性而定。各级别适用性如下（以严重性递增）："

#: ../../howto/logging.rst:69 ../../howto/logging.rst:854
msgid "Level"
msgstr "级别"

#: ../../howto/logging.rst:69
msgid "When it's used"
msgstr "何时使用"

#: ../../howto/logging.rst:71 ../../howto/logging.rst:864
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../howto/logging.rst:71
msgid ""
"Detailed information, typically of interest only when diagnosing problems."
msgstr "细节信息，仅当诊断问题时适用。"

#: ../../howto/logging.rst:74 ../../howto/logging.rst:862
msgid "``INFO``"
msgstr "``INFO``"

#: ../../howto/logging.rst:74
msgid "Confirmation that things are working as expected."
msgstr "确认程序按预期运行。"

#: ../../howto/logging.rst:77 ../../howto/logging.rst:860
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../howto/logging.rst:77
msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr "表明有已经或即将发生的意外（例如：磁盘空间不足）。程序仍按预期进行。"

#: ../../howto/logging.rst:82 ../../howto/logging.rst:858
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../howto/logging.rst:82
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr "由于严重的问题，程序的某些功能已经不能正常执行"

#: ../../howto/logging.rst:85 ../../howto/logging.rst:856
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../howto/logging.rst:85
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr "严重的错误，表明程序已不能继续执行"

#: ../../howto/logging.rst:89
msgid ""
"The default level is ``WARNING``, which means that only events of this level"
" and above will be tracked, unless the logging package is configured to do "
"otherwise."
msgstr "默认的级别是 ``WARNING``，意味着只会追踪该级别及以上的事件，除非更改日志配置。"

#: ../../howto/logging.rst:93
msgid ""
"Events that are tracked can be handled in different ways. The simplest way "
"of handling tracked events is to print them to the console. Another common "
"way is to write them to a disk file."
msgstr "所追踪事件可以以不同形式处理。最简单的方式是输出到控制台。另一种常用的方式是写入磁盘文件。"

#: ../../howto/logging.rst:101
msgid "A simple example"
msgstr "一个简单的例子"

#: ../../howto/logging.rst:103
msgid "A very simple example is::"
msgstr "一个非常简单的例子::"

#: ../../howto/logging.rst:109
msgid "If you type these lines into a script and run it, you'll see:"
msgstr "如果你在命令行中输入这些代码并运行，你将会看到："

#: ../../howto/logging.rst:115
msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because the "
"default level is ``WARNING``. The printed message includes the indication of"
" the level and the description of the event provided in the logging call, "
"i.e. 'Watch out!'. Don't worry about the 'root' part for now: it will be "
"explained later. The actual output can be formatted quite flexibly if you "
"need that; formatting options will also be explained later."
msgstr ""
"输出到命令行。``INFO`` 消息并没有出现，因为默认级别是 ``WARNING`` 。打印的信息包含事件的级别以及在日志调用中的对于事件的描述，例如"
" “Watch out!”。暂时不用担心 “root” 部分：之后会作出解释。输出格式可按需要进行调整，格式化选项同样会在之后作出解释。"

#: ../../howto/logging.rst:124
msgid "Logging to a file"
msgstr "记录日志到文件"

#: ../../howto/logging.rst:126
msgid ""
"A very common situation is that of recording logging events in a file, so "
"let's look at that next. Be sure to try the following in a newly-started "
"Python interpreter, and don't just continue from the session described "
"above::"
msgstr "一种非常常见的情况是将日志事件记录到文件，让我们继续往下看。请确认启动新的Python 解释器，不要在上一个环境中继续操作::"

#: ../../howto/logging.rst:137
msgid ""
"The *encoding* argument was added. In earlier Python versions, or if not "
"specified, the encoding used is the default value used by :func:`open`. "
"While not shown in the above example, an *errors* argument can also now be "
"passed, which determines how encoding errors are handled. For available "
"values and the default, see the documentation for :func:`open`."
msgstr ""
"增加了 *encoding* 参数。在更早的 Python 版本中或没有指定时，编码会用 :func:`open` "
"使用的默认值。尽管在上面的例子中没有展示，但也可以传入一个决定如何处理编码错误的 *errors* 参数。可使用的值和默认值，请参照 "
":func:`open` 的文档。"

#: ../../howto/logging.rst:144
msgid ""
"And now if we open the file and look at what we have, we should find the log"
" messages:"
msgstr "现在，如果我们打开日志文件，我们应当能看到日志信息："

#: ../../howto/logging.rst:154
msgid ""
"This example also shows how you can set the logging level which acts as the "
"threshold for tracking. In this case, because we set the threshold to "
"``DEBUG``, all of the messages were printed."
msgstr "该示例同样展示了如何设置日志追踪级别的阈值。该示例中，由于我们设置的阈值是 ``DEBUG``，所有信息都将被打印。"

#: ../../howto/logging.rst:158
msgid ""
"If you want to set the logging level from a command-line option such as:"
msgstr "如果你想从命令行设置日志级别，例如："

#: ../../howto/logging.rst:164
msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr "并且在一些 *loglevel* 变量中你可以获得 ``--log`` 命令的参数，你可以使用::"

#: ../../howto/logging.rst:169
msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level* "
"argument. You may want to error check any user input value, perhaps as in "
"the following example::"
msgstr "通过 *level* 参数获得你将传递给 :func:`basicConfig` 的值。你需要对用户输入数据进行错误排查，可如下例::"

#: ../../howto/logging.rst:181
msgid ""
"The call to :func:`basicConfig` should come *before* any calls to "
":func:`debug`, :func:`info` etc. As it's intended as a one-off simple "
"configuration facility, only the first call will actually do anything: "
"subsequent calls are effectively no-ops."
msgstr ""
"对 :func:`basicConfig` 的调用应该在  :func:`debug` ， :func:`info` "
"等的前面。因为它被设计为一次性的配置，只有第一次调用会进行操作，随后的调用不会产生有效操作。"

#: ../../howto/logging.rst:186
msgid ""
"If you run the above script several times, the messages from successive runs"
" are appended to the file *example.log*. If you want each run to start "
"afresh, not remembering the messages from earlier runs, you can specify the "
"*filemode* argument, by changing the call in the above example to::"
msgstr ""
"如果多次运行上述脚本，则连续运行的消息将追加到文件 *example.log* 。 "
"如果你希望每次运行重新开始，而不是记住先前运行的消息，则可以通过将上例中的调用更改为来指定 *filemode* 参数::"

#: ../../howto/logging.rst:193
msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr "输出将与之前相同，但不再追加进日志文件，因此早期运行的消息将丢失。"

#: ../../howto/logging.rst:198
msgid "Logging from multiple modules"
msgstr "从多个模块记录日志"

#: ../../howto/logging.rst:200
msgid ""
"If your program consists of multiple modules, here's an example of how you "
"could organize logging in it::"
msgstr "如果你的程序包含多个模块，这里有一个如何组织日志记录的示例::"

#: ../../howto/logging.rst:224
msgid "If you run *myapp.py*, you should see this in *myapp.log*:"
msgstr "如果你运行 *myapp.py* ，你应该在 *myapp.log* 中看到："

#: ../../howto/logging.rst:232
msgid ""
"which is hopefully what you were expecting to see. You can generalize this "
"to multiple modules, using the pattern in *mylib.py*. Note that for this "
"simple usage pattern, you won't know, by looking in the log file, *where* in"
" your application your messages came from, apart from looking at the event "
"description. If you want to track the location of your messages, you'll need"
" to refer to the documentation beyond the tutorial level -- see :ref"
":`logging-advanced-tutorial`."
msgstr ""
"这是你期待看到的。 你可以使用 *mylib.py* 中的模式将此概括为多个模块。 "
"请注意，对于这种简单的使用模式，除了查看事件描述之外，你不能通过查看日志文件来了解应用程序中消息的 *来源* 。 "
"如果要跟踪消息的位置，则需要参考教程级别以外的文档 —— 请参阅 :ref:`logging-advanced-tutorial` 。"

#: ../../howto/logging.rst:242
msgid "Logging variable data"
msgstr "记录变量数据"

#: ../../howto/logging.rst:244
msgid ""
"To log variable data, use a format string for the event description message "
"and append the variable data as arguments. For example::"
msgstr "要记录变量数据，请使用格式字符串作为事件描述消息，并附加传入变量数据作为参数。 例如::"

#: ../../howto/logging.rst:250
msgid "will display:"
msgstr "将显示："

#: ../../howto/logging.rst:256
msgid ""
"As you can see, merging of variable data into the event description message "
"uses the old, %-style of string formatting. This is for backwards "
"compatibility: the logging package pre-dates newer formatting options such "
"as :meth:`str.format` and :class:`string.Template`. These newer formatting "
"options *are* supported, but exploring them is outside the scope of this "
"tutorial: see :ref:`formatting-styles` for more information."
msgstr ""
"如你所见，将可变数据合并到事件描述消息中使用旧的 %-s形式的字符串格式化。 这是为了向后兼容：logging 包的出现时间早于较新的格式化选项例如 "
":meth:`str.format` 和 :class:`string.Template`。 这些较新格式化选项 *是* "
"受支持的，但探索它们超出了本教程的范围：有关详细信息，请参阅 :ref:`formatting-styles`。"

#: ../../howto/logging.rst:265
msgid "Changing the format of displayed messages"
msgstr "更改显示消息的格式"

#: ../../howto/logging.rst:267
msgid ""
"To change the format which is used to display messages, you need to specify "
"the format you want to use::"
msgstr "要更改用于显示消息的格式，你需要指定要使用的格式::"

#: ../../howto/logging.rst:276
msgid "which would print:"
msgstr "这将输出："

#: ../../howto/logging.rst:284
msgid ""
"Notice that the 'root' which appeared in earlier examples has disappeared. "
"For a full set of things that can appear in format strings, you can refer to"
" the documentation for :ref:`logrecord-attributes`, but for simple usage, "
"you just need the *levelname* (severity), *message* (event description, "
"including variable data) and perhaps to display when the event occurred. "
"This is described in the next section."
msgstr ""
"请注意，前面示例中出现的 “root” 已消失。 对于可以出现在格式字符串中的全部内容，你可以参考以下文档 :ref:`logrecord-"
"attributes` ，但为了简单使用，你只需要 *levelname* （严重性）， *message* "
"（事件描述，包括可变数据），也许在事件发生时显示。 这将在下一节中介绍。"

#: ../../howto/logging.rst:293
msgid "Displaying the date/time in messages"
msgstr "在消息中显示日期/时间"

#: ../../howto/logging.rst:295
msgid ""
"To display the date and time of an event, you would place '%(asctime)s' in "
"your format string::"
msgstr "要显示事件的日期和时间，你可以在格式字符串中放置 '%(asctime)s' ::"

#: ../../howto/logging.rst:302
msgid "which should print something like this:"
msgstr "应该打印这样的东西："

#: ../../howto/logging.rst:308
msgid ""
"The default format for date/time display (shown above) is like ISO8601 or "
":rfc:`3339`. If you need more control over the formatting of the date/time, "
"provide a *datefmt* argument to ``basicConfig``, as in this example::"
msgstr ""
"日期/时间显示的默认格式（如上所示）类似于 ISO8601 或 :rfc:`3339` 。 如果你需要更多地控制日期/时间的格式，请为 "
"``basicConfig`` 提供 *datefmt* 参数，如下例所示::"

#: ../../howto/logging.rst:316
msgid "which would display something like this:"
msgstr "这会显示如下内容："

#: ../../howto/logging.rst:322
msgid ""
"The format of the *datefmt* argument is the same as supported by "
":func:`time.strftime`."
msgstr "*datefmt* 参数的格式与 :func:`time.strftime` 支持的格式相同。"

#: ../../howto/logging.rst:327
msgid "Next Steps"
msgstr "后续步骤"

#: ../../howto/logging.rst:329
msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers, "
"but to get the best out of it, you'll need to invest a little more of your "
"time in reading the following sections. If you're ready for that, grab some "
"of your favourite beverage and carry on."
msgstr ""
"基本教程到此结束。 它应该足以让你启动并运行日志记录。 logging 包提供了更多功能，但为了充分利用它，你需要花更多的时间来阅读以下部分。 "
"如果你准备好了，可以拿一些你最喜欢的饮料然后继续。"

#: ../../howto/logging.rst:335
msgid ""
"If your logging needs are simple, then use the above examples to incorporate"
" logging into your own scripts, and if you run into problems or don't "
"understand something, please post a question on the comp.lang.python Usenet "
"group (available at "
"https://groups.google.com/forum/#!forum/comp.lang.python) and you should "
"receive help before too long."
msgstr ""
"如果你的日志记录需求很简单，那么使用上面的示例将日志记录合并到你自己的脚本中，如果你遇到问题或者不理解某些内容，请在 comp.lang.python "
"Usenet 组上发布一个问题（在 https://groups.google.com/forum/#!forum/comp.lang.python ）"
" ，你将在短时间内得到帮助。"

#: ../../howto/logging.rst:341
msgid ""
"Still here? You can carry on reading the next few sections, which provide a "
"slightly more advanced/in-depth tutorial than the basic one above. After "
"that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"还不够？ 你可以继续阅读接下来的几个部分，这些部分提供了比上面基本部分更高级或深入的教程。 之后，你可以看一下 :ref:`logging-"
"cookbook` 。"

#: ../../howto/logging.rst:349
msgid "Advanced Logging Tutorial"
msgstr "进阶日志教程"

#: ../../howto/logging.rst:351
msgid ""
"The logging library takes a modular approach and offers several categories "
"of components: loggers, handlers, filters, and formatters."
msgstr "日志库采用模块化方法，并提供几类组件：记录器、处理器、过滤器和格式器。"

#: ../../howto/logging.rst:354
msgid "Loggers expose the interface that application code directly uses."
msgstr "记录器暴露了应用程序代码直接使用的接口。"

#: ../../howto/logging.rst:355
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "处理器将日志记录（由记录器创建）发送到适当的目标。"

#: ../../howto/logging.rst:357
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr "过滤器提供了更细粒度的功能，用于确定要输出的日志记录。"

#: ../../howto/logging.rst:359
msgid "Formatters specify the layout of log records in the final output."
msgstr "格式器指定最终输出中日志记录的样式。"

#: ../../howto/logging.rst:361
msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr "日志事件信息在 :class:`LogRecord` 实例中的记录器、处理器、过滤器和格式器之间传递。"

#: ../../howto/logging.rst:364
msgid ""
"Logging is performed by calling methods on instances of the :class:`Logger` "
"class (hereafter called :dfn:`loggers`). Each instance has a name, and they "
"are conceptually arranged in a namespace hierarchy using dots (periods) as "
"separators. For example, a logger named 'scan' is the parent of loggers "
"'scan.text', 'scan.html' and 'scan.pdf'. Logger names can be anything you "
"want, and indicate the area of an application in which a logged message "
"originates."
msgstr ""
"通过调用 :class:`Logger` 类（以下称为 :dfn:`loggers`  ， 记录器）的实例来执行日志记录。 "
"每个实例都有一个名称，它们在概念上以点（句点）作为分隔符排列在命名空间的层次结构中。 例如，名为 'scan' 的记录器是记录器 'scan.text'"
" ，'scan.html' 和 'scan.pdf' 的父级。 记录器名称可以是你想要的任何名称，并指示记录消息源自的应用程序区域。"

#: ../../howto/logging.rst:371
msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr "在命名记录器时使用的一个好习惯是在每个使用日志记录的模块中使用模块级记录器，命名如下::"

#: ../../howto/logging.rst:376
msgid ""
"This means that logger names track the package/module hierarchy, and it's "
"intuitively obvious where events are logged just from the logger name."
msgstr "这意味着记录器名称跟踪包或模块的层次结构，并且直观地从记录器名称显示记录事件的位置。"

#: ../../howto/logging.rst:379
msgid ""
"The root of the hierarchy of loggers is called the root logger. That's the "
"logger used by the functions :func:`debug`, :func:`info`, :func:`warning`, "
":func:`error` and :func:`critical`, which just call the same-named method of"
" the root logger. The functions and the methods have the same signatures. "
"The root logger's name is printed as 'root' in the logged output."
msgstr ""
"记录器层次结构的根称为根记录器。 这是函数 :func:`debug` 、 :func:`info` 、 :func:`warning` 、 "
":func:`error` 和 :func:`critical` 使用的记录器，它们就是调用了根记录器的同名方法。 函数和方法具有相同的签名。 "
"根记录器的名称在输出中打印为 'root' 。"

#: ../../howto/logging.rst:385
msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, HTTP "
"GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific "
"logging mechanisms such as syslog or the Windows NT event log. Destinations "
"are served by :dfn:`handler` classes. You can create your own log "
"destination class if you have special requirements not met by any of the "
"built-in handler classes."
msgstr ""
"当然，可以将消息记录到不同的地方。 软件包中的支持包含，用于将日志消息写入文件、 HTTP GET/POST 位置、通过 SMTP "
"发送电子邮件、通用套接字、队列或特定于操作系统的日志记录机制（如 syslog 或 Windows NT 事件日志）。 目标由 "
":dfn:`handler` 类提供。 如果你有任何内置处理器类未满足的特殊要求，则可以创建自己的日志目标类。"

#: ../../howto/logging.rst:392
msgid ""
"By default, no destination is set for any logging messages. You can specify "
"a destination (such as console or file) by using :func:`basicConfig` as in "
"the tutorial examples. If you call the functions  :func:`debug`, "
":func:`info`, :func:`warning`, :func:`error` and :func:`critical`, they will"
" check to see if no destination is set; and if one is not set, they will set"
" a destination of the console (``sys.stderr``) and a default format for the "
"displayed message before delegating to the root logger to do the actual "
"message output."
msgstr ""
"默认情况下，没有为任何日志消息设置目标。 你可以使用 :func:`basicConfig` 指定目标（例如控制台或文件），如教程示例中所示。 "
"如果你调用函数 :func:`debug` 、 :func:`info` 、 :func:`warning` 、 :func:`error` 和 "
":func:`critical` ，它们将检查是否有设置目标；如果没有设置，将在委托给根记录器进行实际的消息输出之前设置目标为控制台（ "
"``sys.stderr`` ）并设置显示消息的默认格式。"

#: ../../howto/logging.rst:400
msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr "由 :func:`basicConfig` 设置的消息默认格式为："

#: ../../howto/logging.rst:406
msgid ""
"You can change this by passing a format string to :func:`basicConfig` with "
"the *format* keyword argument. For all options regarding how a format string"
" is constructed, see :ref:`formatter-objects`."
msgstr ""
"你可以通过使用 *format* 参数将格式字符串传递给 :func:`basicConfig` 来更改此设置。有关如何构造格式字符串的所有选项，请参阅"
" :ref:`formatter-objects` 。"

#: ../../howto/logging.rst:411
msgid "Logging Flow"
msgstr "记录流程"

#: ../../howto/logging.rst:413
msgid ""
"The flow of log event information in loggers and handlers is illustrated in "
"the following diagram."
msgstr "记录器和处理器中的日志事件信息流程如下图所示。"

#: ../../howto/logging.rst:419
msgid "Loggers"
msgstr "记录器"

#: ../../howto/logging.rst:421
msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several "
"methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested log"
" handlers."
msgstr ""
":class:`Logger` "
"对象有三重任务。首先，它们向应用程序代码公开了几种方法，以便应用程序可以在运行时记录消息。其次，记录器对象根据严重性（默认过滤工具）或过滤器对象确定要处理的日志消息。第三，记录器对象将相关的日志消息传递给所有感兴趣的日志处理器。"

#: ../../howto/logging.rst:427
msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr "记录器对象上使用最广泛的方法分为两类：配置和消息发送。"

#: ../../howto/logging.rst:430
msgid "These are the most common configuration methods:"
msgstr "这些是最常见的配置方法："

#: ../../howto/logging.rst:432
msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a logger "
"will handle, where debug is the lowest built-in severity level and critical "
"is the highest built-in severity.  For example, if the severity level is "
"INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL "
"messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel` 指定记录器将处理的最低严重性日志消息，其中 debug 是最低内置严重性级别， critical "
"是最高内置严重性级别。 例如，如果严重性级别为 INFO ，则记录器将仅处理 INFO 、 WARNING 、 ERROR 和 CRITICAL "
"消息，并将忽略 DEBUG 消息。"

#: ../../howto/logging.rst:438
msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove "
"handler objects from the logger object.  Handlers are covered in more detail"
" in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` 和 :meth:`Logger.removeHandler` "
"从记录器对象中添加和删除处理器对象。处理器在以下内容中有更详细的介绍 :ref:`handler-basic` 。"

#: ../../howto/logging.rst:442
msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more detail "
"in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` 和 :meth:`Logger.removeFilter` 可以添加或移除记录器对象中的过滤器。 "
":ref:`filter` 包含更多的过滤器细节。"

#: ../../howto/logging.rst:446
msgid ""
"You don't need to always call these methods on every logger you create. See "
"the last two paragraphs in this section."
msgstr "你不需要总是在你创建的每个记录器上都调用这些方法。 请参阅本节的最后两段。"

#: ../../howto/logging.rst:449
msgid ""
"With the logger object configured, the following methods create log "
"messages:"
msgstr "配置记录器对象后，以下方法将创建日志消息："

#: ../../howto/logging.rst:451
msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, "
":meth:`Logger.error`, and :meth:`Logger.critical` all create log records "
"with a message and a level that corresponds to their respective method "
"names. The message is actually a format string, which may contain the "
"standard string substitution syntax of ``%s``, ``%d``, ``%f``, and so on.  "
"The rest of their arguments is a list of objects that correspond with the "
"substitution fields in the message.  With regard to ``**kwargs``, the "
"logging methods care only about a keyword of ``exc_info`` and use it to "
"determine whether to log exception information."
msgstr ""
":meth:`Logger.debug` 、 :meth:`Logger.info` 、 :meth:`Logger.warning` 、 "
":meth:`Logger.error` 和 :meth:`Logger.critical` "
"都创建日志记录，包含消息和与其各自方法名称对应的级别。该消息实际上是一个格式化字符串，它可能包含标题字符串替换语法 ``%s`` 、 ``%d`` 、 "
"``%f`` 等等。其余参数是与消息中的替换字段对应的对象列表。关于 ``**kwargs`` ，日志记录方法只关注 ``exc_info`` "
"的关键字，并用它来确定是否记录异常信息。"

#: ../../howto/logging.rst:461
msgid ""
":meth:`Logger.exception` creates a log message similar to "
":meth:`Logger.error`.  The difference is that :meth:`Logger.exception` dumps"
" a stack trace along with it.  Call this method only from an exception "
"handler."
msgstr ""
":meth:`Logger.exception` 创建与 :meth:`Logger.error` 相似的日志信息。 不同之处是， "
":meth:`Logger.exception` 同时还记录当前的堆栈追踪。仅从异常处理程序调用此方法。"

#: ../../howto/logging.rst:465
msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` "
"将日志级别作为显式参数。对于记录消息而言，这比使用上面列出的日志级别便利方法更加冗长，但这是使用自定义日志级别的方法。"

#: ../../howto/logging.rst:469
msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are period-"
"separated hierarchical structures.  Multiple calls to :func:`getLogger` with"
" the same name will return a reference to the same logger object.  Loggers "
"that are further down in the hierarchical list are children of loggers "
"higher up in the list. For example, given a logger with a name of ``foo``, "
"loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all "
"descendants of ``foo``."
msgstr ""
":func:`getLogger` 返回对具有指定名称的记录器实例的引用（如果已提供），或者如果没有则返回 ``root`` "
"。名称是以句点分隔的层次结构。多次调用 :func:`getLogger` "
"具有相同的名称将返回对同一记录器对象的引用。在分层列表中较低的记录器是列表中较高的记录器的子项。例如，给定一个名为 ``foo`` 的记录器，名称为 "
"``foo.bar`` 、 ``foo.bar.baz`` 和 ``foo.bam`` 的记录器都是 ``foo`` 子项。"

#: ../../howto/logging.rst:477
msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly "
"set on a logger, the level of its parent is used instead as its effective "
"level. If the parent has no explicit level set, *its* parent is examined, "
"and so on - all ancestors are searched until an explicitly set level is "
"found. The root logger always has an explicit level set (``WARNING`` by "
"default). When deciding whether to process an event, the effective level of "
"the logger is used to determine whether the event is passed to the logger's "
"handlers."
msgstr ""
"记录器具有 *有效等级* 的概念。如果未在记录器上显式设置级别，则使用其父记录器的级别作为其有效级别。如果父记录器没有明确的级别设置，则检查 *其* "
"父级。依此类推，搜索所有上级元素，直到找到明确设置的级别。根记录器始终具有显式级别集（默认情况下为 ``WARNING`` "
"）。在决定是否处理事件时，记录器的有效级别用于确定事件是否传递给记录器相关的处理器。"

#: ../../howto/logging.rst:485
msgid ""
"Child loggers propagate messages up to the handlers associated with their "
"ancestor loggers. Because of this, it is unnecessary to define and configure"
" handlers for all the loggers an application uses. It is sufficient to "
"configure handlers for a top-level logger and create child loggers as "
"needed. (You can, however, turn off propagation by setting the *propagate* "
"attribute of a logger to ``False``.)"
msgstr ""
"子记录器将消息传播到与其父级记录器关联的处理器。因此，不必为应用程序使用的所有记录器定义和配置处理器。一般为顶级记录器配置处理器，再根据需要创建子记录器就足够了。（但是，你可以通过将记录器的"
" *propagate* 属性设置为 ``False`` 来关闭传播。）"

#: ../../howto/logging.rst:496
msgid "Handlers"
msgstr "处理器"

#: ../../howto/logging.rst:498
msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or "
"more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, and "
"all messages of critical to an email address. This scenario requires three "
"individual handlers where each handler is responsible for sending messages "
"of a specific severity to a specific location."
msgstr ""
":class:`~logging.Handler` 对象负责将适当的日志消息（基于日志消息的严重性）分派给处理器的指定目标。 "
":class:`Logger` 对象可以使用 :meth:`~Logger.addHandler` "
"方法向自己添加零个或多个处理器对象。作为示例场景，应用程序可能希望将所有日志消息发送到日志文件，将错误或更高的所有日志消息发送到标准输出，以及将所有关键消息发送至一个邮件地址。"
" 此方案需要三个单独的处理器，其中每个处理器负责将特定严重性的消息发送到特定位置。"

#: ../../howto/logging.rst:508
msgid ""
"The standard library includes quite a few handler types (see :ref:`useful-"
"handlers`); the tutorials use mainly :class:`StreamHandler` and "
":class:`FileHandler` in its examples."
msgstr ""
"标准库包含很多处理器类型（参见 :ref:`useful-handlers` ）；教程主要使用 :class:`StreamHandler` 和 "
":class:`FileHandler` 。"

#: ../../howto/logging.rst:512
msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for "
"application developers who are using the built-in handler objects (that is, "
"not creating custom handlers) are the following configuration methods:"
msgstr "处理器中很少有方法可供应用程序开发人员使用。使用内置处理器对象（即不创建自定义处理器）的应用程序开发人员能用到的仅有以下配置方法："

#: ../../howto/logging.rst:517
msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, specifies "
"the lowest severity that will be dispatched to the appropriate destination."
"  Why are there two :func:`setLevel` methods?  The level set in the logger "
"determines which severity of messages it will pass to its handlers.  The "
"level set in each handler determines which messages that handler will send "
"on."
msgstr ""
":meth:`~handler.setLevel` 方法，就像在记录器对象中一样，指定将被分派到适当目标的最低严重性。为什么有两个 "
":func:`setLevel` 方法？记录器中设置的级别确定将传递给其处理器的消息的严重性。每个处理器中设置的级别确定该处理器将发送哪些消息。"

#: ../../howto/logging.rst:523
msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler to"
" use."
msgstr ":meth:`~Handler.setFormatter` 选择一个该处理器使用的 Formatter 对象。"

#: ../../howto/logging.rst:526
msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively "
"configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` 和 :meth:`~Handler.removeFilter` "
"分别在处理器上配置和取消配置过滤器对象。"

#: ../../howto/logging.rst:529
msgid ""
"Application code should not directly instantiate and use instances of "
":class:`Handler`.  Instead, the :class:`Handler` class is a base class that "
"defines the interface that all handlers should have and establishes some "
"default behavior that child classes can use (or override)."
msgstr ""
"应用程序代码不应直接实例化并使用 :class:`Handler` 的实例。 相反， :class:`Handler` "
"类是一个基类，它定义了所有处理器应该具有的接口，并建立了子类可以使用（或覆盖）的一些默认行为。"

#: ../../howto/logging.rst:536
msgid "Formatters"
msgstr "格式器"

#: ../../howto/logging.rst:538
msgid ""
"Formatter objects configure the final order, structure, and contents of the "
"log message.  Unlike the base :class:`logging.Handler` class, application "
"code may instantiate formatter classes, although you could likely subclass "
"the formatter if your application needs special behavior.  The constructor "
"takes three optional arguments -- a message format string, a date format "
"string and a style indicator."
msgstr ""
"格式化器对象配置日志消息的最终顺序、结构和内容。 与 :class:`logging.Handler` "
"类不同，应用程序代码可以实例化格式器类，但如果应用程序需要特殊行为，则可能会对格式化器进行子类化定制。构造函数有三个可选参数 —— "
"消息格式字符串、日期格式字符串和样式指示符。"

#: ../../howto/logging.rst:547
msgid ""
"If there is no message format string, the default is to use the raw message."
"  If there is no date format string, the default date format is:"
msgstr "如果没有消息格式字符串，则默认使用原始消息。如果没有日期格式字符串，则默认日期格式为："

#: ../../howto/logging.rst:554
msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of `%`, '{'"
" or '$'. If one of these is not specified, then '%' will be used."
msgstr "最后加上毫秒数。 ``style`` 是 `％`，'{ ' 或 '$' 之一。 如果未指定，则将使用 '％'。"

#: ../../howto/logging.rst:557
msgid ""
"If the ``style`` is '%', the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in "
":ref:`logrecord-attributes`. If the style is '{', the message format string "
"is assumed to be compatible with :meth:`str.format` (using keyword "
"arguments), while if the style is '$' then the message format string should "
"conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"如果 ``style`` 是 '％'，则消息格式字符串使用 ``%(<dictionary key>)s`` 样式字符串替换；可能的键值在 :ref"
":`logrecord-attributes` 中。 如果样式为 '{'，则假定消息格式字符串与 :meth:`str.format` "
"（使用关键字参数）兼容，而如果样式为 '$' ，则消息格式字符串应符合 :meth:`string.Template.substitute` 。"

#: ../../howto/logging.rst:564
msgid "Added the ``style`` parameter."
msgstr "添加 ``style`` 形参。"

#: ../../howto/logging.rst:567
msgid ""
"The following message format string will log the time in a human-readable "
"format, the severity of the message, and the contents of the message, in "
"that order::"
msgstr "以下消息格式字符串将以人类可读的格式记录时间、消息的严重性以及消息的内容，按此顺序::"

#: ../../howto/logging.rst:573
msgid ""
"Formatters use a user-configurable function to convert the creation time of "
"a record to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute of"
" the instance to a function with the same signature as "
":func:`time.localtime` or :func:`time.gmtime`. To change it for all "
"formatters, for example if you want all logging times to be shown in GMT, "
"set the ``converter`` attribute in the Formatter class (to ``time.gmtime`` "
"for GMT display)."
msgstr ""
"格式器通过用户可配置的函数将记录的创建时间转换为元组。 默认情况下，使用 :func:`time.localtime` "
"；要为特定格式器实例更改此项，请将实例的 ``converter`` 属性设置为与 :func:`time.localtime` 或 "
":func:`time.gmtime` 具有相同签名的函数。 要为所有格式器更改它，例如，如果你希望所有记录时间都以 GMT 显示，请在格式器类中设置 "
"``converter`` 属性（对于 GMT 显示，设置为 ``time.gmtime`` ）。"

#: ../../howto/logging.rst:583
msgid "Configuring Logging"
msgstr "配置日志记录"

#: ../../howto/logging.rst:587
msgid "Programmers can configure logging in three ways:"
msgstr "开发者可以通过三种方式配置日志记录："

#: ../../howto/logging.rst:589
msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code that"
" calls the configuration methods listed above."
msgstr "使用调用上面列出的配置方法的 Python 代码显式创建记录器、处理器和格式器。"

#: ../../howto/logging.rst:591
msgid ""
"Creating a logging config file and reading it using the :func:`fileConfig` "
"function."
msgstr "创建日志配置文件并使用 :func:`fileConfig` 函数读取它。"

#: ../../howto/logging.rst:593
msgid ""
"Creating a dictionary of configuration information and passing it to the "
":func:`dictConfig` function."
msgstr "创建配置信息字典并将其传递给 :func:`dictConfig` 函数。"

#: ../../howto/logging.rst:596
msgid ""
"For the reference documentation on the last two options, see :ref:`logging-"
"config-api`.  The following example configures a very simple logger, a "
"console handler, and a simple formatter using Python code::"
msgstr ""
"有关最后两个选项的参考文档，请参阅 :ref:`logging-config-api` 。 以下示例使用 Python "
"代码配置一个非常简单的记录器、一个控制台处理器和一个简单的格式器::"

#: ../../howto/logging.rst:626
msgid ""
"Running this module from the command line produces the following output:"
msgstr "从命令行运行此模块将生成以下输出："

#: ../../howto/logging.rst:637
msgid ""
"The following Python module creates a logger, handler, and formatter nearly "
"identical to those in the example listed above, with the only difference "
"being the names of the objects::"
msgstr "以下 Python 模块创建的记录器、处理器和格式器几乎与上面列出的示例中的相同，唯一的区别是对象的名称::"

#: ../../howto/logging.rst:656
msgid "Here is the logging.conf file:"
msgstr "这是 logging.conf 文件："

#: ../../howto/logging.rst:688
msgid ""
"The output is nearly identical to that of the non-config-file-based example:"
msgstr "其输出与不基于配置文件的示例几乎相同："

#: ../../howto/logging.rst:699
msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the "
"ability of noncoders to easily modify the logging properties."
msgstr "你可以看到配置文件方法相较于 Python 代码方法有一些优势，主要是配置和代码的分离以及非开发者轻松修改日志记录属性的能力。"

#: ../../howto/logging.rst:703
msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it will "
"cause any non-root loggers existing before the :func:`fileConfig` call to be"
" disabled unless they (or an ancestor) are explicitly named in the "
"configuration. Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
":func:`fileConfig` 函数接受一个默认参数 ``disable_existing_loggers`` ，出于向后兼容的原因，默认为 "
"``True`` 。这可能与您的期望不同，因为除非在配置中明确命名它们（或其父级），否则它将导致在 :func:`fileConfig` "
"调用之前存在的任何非 root 记录器被禁用。有关更多信息，请参阅参考文档，如果需要，请将此参数指定为 ``False`` 。"

#: ../../howto/logging.rst:711
msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean value"
" with key ``disable_existing_loggers``, which if not specified explicitly in"
" the dictionary also defaults to being interpreted as ``True``. This leads "
"to the logger-disabling behaviour described above, which may not be what you"
" want - in which case, provide the key explicitly with a value of ``False``."
msgstr ""
"传递给 :func:`dictConfig` 的字典也可以用键 ``disable_existing_loggers`` "
"指定一个布尔值，如果没有在字典中明确指定，也默认被解释为 ``True`` "
"。这会导致上面描述的记录器禁用行为，这可能与你的期望不同——在这种情况下，请明确地为其提供 ``False`` 值。"

#: ../../howto/logging.rst:721
msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either "
":class:`~logging.handlers.WatchedFileHandler` (relative to the logging "
"module) or ``mypackage.mymodule.MyHandler`` (for a class defined in package "
"``mypackage`` and module ``mymodule``, where ``mypackage`` is available on "
"the Python import path)."
msgstr ""
"请注意，配置文件中引用的类名称需要相对于日志记录模块，或者可以使用常规导入机制解析的绝对值。因此，你可以使用 "
":class:`~logging.handlers.WatchedFileHandler` （相对于日志记录模块）或 "
"``mypackage.mymodule.MyHandler`` （对于在 ``mypackage`` 包中定义的类和模块 ``mymodule`` "
"，其中 ``mypackage`` 在 Python 导入路径上可用）。"

#: ../../howto/logging.rst:729
msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, using"
" dictionaries to hold configuration information. This provides a superset of"
" the functionality of the config-file-based approach outlined above, and is "
"the recommended configuration method for new applications and deployments. "
"Because a Python dictionary is used to hold configuration information, and "
"since you can populate that dictionary using different means, you have more "
"options for configuration. For example, you can use a configuration file in "
"JSON format, or, if you have access to YAML processing functionality, a file"
" in YAML format, to populate the configuration dictionary. Or, of course, "
"you can construct the dictionary in Python code, receive it in pickled form "
"over a socket, or use whatever approach makes sense for your application."
msgstr ""
"在 Python 3.2 中，引入了一种新的配置日志记录的方法，使用字典来保存配置信息。 "
"这提供了上述基于配置文件方法的功能的超集，并且是新应用程序和部署的推荐配置方法。 因为 Python "
"字典用于保存配置信息，并且由于你可以使用不同的方式填充该字典，因此你有更多的配置选项。 例如，你可以使用 JSON 格式的配置文件，或者如果你有权访问 "
"YAML 处理功能，则可以使用 YAML 格式的文件来填充配置字典。当然，你可以在 Python 代码中构造字典，通过套接字以 pickle "
"形式接收它，或者使用对你的应用程序合理的任何方法。"

#: ../../howto/logging.rst:741
msgid ""
"Here's an example of the same configuration as above, in YAML format for the"
" new dictionary-based approach:"
msgstr "以下是与上述相同配置的示例，采用 YAML 格式，用于新的基于字典的方法："

#: ../../howto/logging.rst:765
msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr "有关使用字典进行日志记录的更多信息，请参阅 :ref:`logging-config-api`。"

#: ../../howto/logging.rst:769
msgid "What happens if no configuration is provided"
msgstr "如果没有提供配置会发生什么"

#: ../../howto/logging.rst:771
msgid ""
"If no logging configuration is provided, it is possible to have a situation "
"where a logging event needs to be output, but no handlers can be found to "
"output the event. The behaviour of the logging package in these "
"circumstances is dependent on the Python version."
msgstr ""
"如果未提供日志记录配置，则可能出现需要输出日志记录事件但无法找到输出事件的处理器的情况。 在这些情况下，logging 包的行为取决于 Python "
"版本。"

#: ../../howto/logging.rst:776
msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "对于 3.2 之前的 Python 版本，行为如下："

#: ../../howto/logging.rst:778
msgid ""
"If *logging.raiseExceptions* is ``False`` (production mode), the event is "
"silently dropped."
msgstr "如果 *logging.raiseExceptions* 为 ``False`` （生产模式），则会以静默方式丢弃该事件。"

#: ../../howto/logging.rst:781
msgid ""
"If *logging.raiseExceptions* is ``True`` (development mode), a message 'No "
"handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
"如果 *logging.raiseExceptions* 为 ``True`` （开发模式），则会打印一条消息 'No handlers could "
"be found for logger X.Y.Z'。"

#: ../../howto/logging.rst:784
msgid "In Python 3.2 and later, the behaviour is as follows:"
msgstr "在 Python 3.2 及更高版本中，行为如下："

#: ../../howto/logging.rst:786
msgid ""
"The event is output using a 'handler of last resort', stored in "
"``logging.lastResort``. This internal handler is not associated with any "
"logger, and acts like a :class:`~logging.StreamHandler` which writes the "
"event description message to the current value of ``sys.stderr`` (therefore "
"respecting any redirections which may be in effect). No formatting is done "
"on the message - just the bare event description message is printed. The "
"handler's level is set to ``WARNING``, so all events at this and greater "
"severities will be output."
msgstr ""
"事件使用 “最后的处理器” 输出，存储在 ``logging.lastResort`` 中。 这个内部处理器与任何记录器都没有关联，它的作用类似于 "
":class:`~logging.StreamHandler` ，它将事件描述消息写入 ``sys.stderr`` "
"的当前值（因此服从任何可能的重定向影响）。 没有对消息进行格式化——只打印裸事件描述消息。处理器的级别设置为 "
"``WARNING``，因此将输出此级别和更高级别的所有事件。"

#: ../../howto/logging.rst:795
msgid ""
"To obtain the pre-3.2 behaviour, ``logging.lastResort`` can be set to "
"``None``."
msgstr "要获得 3.2 之前的行为，可以设置 ``logging.lastResort`` 为 ``None``。"

#: ../../howto/logging.rst:800
msgid "Configuring Logging for a Library"
msgstr "配置库的日志记录"

#: ../../howto/logging.rst:802
msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers "
"used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library "
"code makes logging calls, then (as described in the previous section) events"
" of severity ``WARNING`` and greater will be printed to ``sys.stderr``. This"
" is regarded as the best default behaviour."
msgstr ""
"在开发使用日志记录的库时，你应该注意记录库如何使用日志记录——例如，使用的记录器的名称。还需要考虑其日志记录配置。如果应用程序不使用日志记录，并且库代码进行日志记录调用，那么（如上一节所述）严重性为"
" ``WARNING`` 及更高级别的事件将打印到 ``sys.stderr`` 。这被认为是最好的默认行为。"

#: ../../howto/logging.rst:810
msgid ""
"If for some reason you *don't* want these messages printed in the absence of"
" any logging configuration, you can attach a do-nothing handler to the top-"
"level logger for your library. This avoids the message being printed, since "
"a handler will always be found for the library's events: it just doesn't "
"produce any output. If the library user configures logging for application "
"use, presumably that configuration will add some handlers, and if levels are"
" suitably configured then logging calls made in library code will send "
"output to those handlers, as normal."
msgstr ""
"如果由于某种原因，你 *不* "
"希望在没有任何日志记录配置的情况下打印这些消息，则可以将无操作处理器附加到库的顶级记录器。这样可以避免打印消息，因为将始终为库的事件找到处理器：它不会产生任何输出。如果库用户配置应用程序使用的日志记录，可能是配置将添加一些处理器，如果级别已适当配置，则在库代码中进行的日志记录调用将正常地将输出发送给这些处理器。"

#: ../../howto/logging.rst:819
msgid ""
"A do-nothing handler is included in the logging package: "
":class:`~logging.NullHandler` (since Python 3.1). An instance of this "
"handler could be added to the top-level logger of the logging namespace used"
" by the library (*if* you want to prevent your library's logged events being"
" output to ``sys.stderr`` in the absence of logging configuration). If all "
"logging by a library *foo* is done using loggers with names matching "
"'foo.x', 'foo.x.y', etc. then the code::"
msgstr ""
"日志包中包含一个不做任何事情的处理器： :class:`~logging.NullHandler` （自 Python 3.1 "
"起）。可以将此处理器的实例添加到库使用的日志记录命名空间的顶级记录器中（ *如果* 你希望在没有日志记录配置的情况下阻止库的记录事件输出到 "
"``sys.stderr`` ）。如果库 *foo* 的所有日志记录都是使用名称匹配 'foo.x' ， 'foo.x.y' "
"等的记录器完成的，那么代码::"

#: ../../howto/logging.rst:830
msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather than "
"just 'foo'."
msgstr "应该有预计的效果。如果一个组织生成了许多库，则指定的记录器名称可以是 “orgname.foo” 而不仅仅是 “foo” 。"

#: ../../howto/logging.rst:834
msgid ""
"It is strongly advised that you *do not add any handlers other than* "
":class:`~logging.NullHandler` *to your library's loggers*. This is because "
"the configuration of handlers is the prerogative of the application "
"developer who uses your library. The application developer knows their "
"target audience and what handlers are most appropriate for their "
"application: if you add handlers 'under the hood', you might well interfere "
"with their ability to carry out unit tests and deliver logs which suit their"
" requirements."
msgstr ""
"强烈建议你 *不要将* :class:`~logging.NullHandler` *以外的任何处理器添加到库的记录器中* "
"。这是因为处理器的配置是使用你的库的应用程序开发人员的权利。应用程序开发人员了解他们的目标受众以及哪些处理器最适合他们的应用程序：如果你在“底层”添加处理器，则可能会干扰他们执行单元测试和提供符合其要求的日志的能力。"

#: ../../howto/logging.rst:845
msgid "Logging Levels"
msgstr "日志级别"

#: ../../howto/logging.rst:847
msgid ""
"The numeric values of logging levels are given in the following table. These"
" are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值，那么这你可能对以下内容感兴趣。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称将失效。"

#: ../../howto/logging.rst:854
msgid "Numeric value"
msgstr "数值"

#: ../../howto/logging.rst:856
msgid "50"
msgstr "50"

#: ../../howto/logging.rst:858
msgid "40"
msgstr "40"

#: ../../howto/logging.rst:860
msgid "30"
msgstr "30"

#: ../../howto/logging.rst:862
msgid "20"
msgstr "20"

#: ../../howto/logging.rst:864
msgid "10"
msgstr "10"

#: ../../howto/logging.rst:866
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../howto/logging.rst:866
msgid "0"
msgstr "0"

#: ../../howto/logging.rst:869
msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a logging "
"method is called on a logger, the logger compares its own level with the "
"level associated with the method call. If the logger's level is higher than "
"the method call's, no logging message is actually generated. This is the "
"basic mechanism controlling the verbosity of logging output."
msgstr ""
"级别也可以与记录器相关联，由开发人员设置或通过加载已保存的日志记录配置。在记录器上调用日志记录方法时，记录器会将其自己的级别与与方法调用关联的级别进行比较。如果记录器的级别高于方法调用的级别，则实际上不会生成任何记录消息。这是控制日志记录输出详细程度的基本机制。"

#: ../../howto/logging.rst:876
msgid ""
"Logging messages are encoded as instances of the :class:`~logging.LogRecord`"
" class. When a logger decides to actually log an event, a "
":class:`~logging.LogRecord` instance is created from the logging message."
msgstr ""
"记录消息被编码为 :class:`~logging.LogRecord` 类的实例。当记录器决定实际记录事件时，将用记录消息创建 "
":class:`~logging.LogRecord` 实例。"

#: ../../howto/logging.rst:880
msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of "
":dfn:`handlers`, which are instances of subclasses of the :class:`Handler` "
"class. Handlers are responsible for ensuring that a logged message (in the "
"form of a :class:`LogRecord`) ends up in a particular location (or set of "
"locations) which is useful for the target audience for that message (such as"
" end users, support desk staff, system administrators, developers). Handlers"
" are passed :class:`LogRecord` instances intended for particular "
"destinations. Each logger can have zero, one or more handlers associated "
"with it (via the :meth:`~Logger.addHandler` method of :class:`Logger`). In "
"addition to any handlers directly associated with a logger, *all handlers "
"associated with all ancestors of the logger* are called to dispatch the "
"message (unless the *propagate* flag for a logger is set to a false value, "
"at which point the passing to ancestor handlers stops)."
msgstr ""
"记录消息受 :dfn:`handlers` 建立的调度机制控制，它们是 :class:`Handler` 类的子类实例。处理器负责确保记录的消息（以 "
":class:`LogRecord` 的形式）最终位于对该消息的目标受众（例如最终用户、 "
"支持服务台员工、系统管理员、开发人员）有用的特定位置（或一组位置）上。处理器传递适用于特定目标的 :class:`LogRecord` 实例。 "
"每个记录器可以有零个、一个或多个与之关联的处理器（通过 :class:`Logger` 的 :meth:`~Logger.addHandler` "
"方法）。除了与记录器直接关联的所有处理器之外，还调用与记录器的 *所有祖先关联的处理器来分派消息（除非记录器的 *propagate* 标志设置为 "
"false 值，这将停止传递到上级处理器）。"

#: ../../howto/logging.rst:894
msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level does. "
"If a handler decides to actually dispatch an event, the "
":meth:`~Handler.emit` method is used to send the message to its destination."
" Most user-defined subclasses of :class:`Handler` will need to override this"
" :meth:`~Handler.emit`."
msgstr ""
"就像记录器一样，处理器可以具有与它们相关联的级别。处理器的级别作为过滤器，其方式与记录器级别相同。如果处理器决定调度一个事件，则使用 "
":meth:`~handler.emit` 方法将消息发送到其目标。大多数用户定义的 :class:`Handler` 子类都需要重载 "
":meth:`~handler.emit` 。"

#: ../../howto/logging.rst:903
msgid "Custom Levels"
msgstr "自定义级别"

#: ../../howto/logging.rst:905
msgid ""
"Defining your own levels is possible, but should not be necessary, as the "
"existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care should"
" be exercised when doing this, and it is possibly *a very bad idea to define"
" custom levels if you are developing a library*. That's because if multiple "
"library authors all define their own custom levels, there is a chance that "
"the logging output from such multiple libraries used together will be "
"difficult for the using developer to control and/or interpret, because a "
"given numeric value might mean different things for different libraries."
msgstr ""
"定义你自己的级别是可能的，但不一定是必要的，因为现有级别是根据实践经验选择的。但是，如果你确信需要自定义级别，那么在执行此操作时应特别小心，如果你正在开发库，则"
" *定义自定义级别可能是一个非常糟糕的主意* 。 "
"这是因为如果多个库作者都定义了他们自己的自定义级别，那么使用开发人员很难控制和解释这些多个库的日志记录输出，因为给定的数值对于不同的库可能意味着不同的东西。"

#: ../../howto/logging.rst:918
msgid "Useful Handlers"
msgstr "有用的处理器"

#: ../../howto/logging.rst:920
msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses are "
"provided:"
msgstr "作为 :class:`Handler` 基类的补充，提供了很多有用的子类："

#: ../../howto/logging.rst:923
msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ":class:`StreamHandler` 实例发送消息到流（类似文件对象）。"

#: ../../howto/logging.rst:926
msgid ":class:`FileHandler` instances send messages to disk files."
msgstr ":class:`FileHandler` 实例将消息发送到硬盘文件。"

#: ../../howto/logging.rst:928
msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers that "
"rotate log files at a certain point. It is not meant to be  instantiated "
"directly. Instead, use :class:`~handlers.RotatingFileHandler` or "
":class:`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` 是轮换日志文件的处理器的基类。它并不应该直接实例化。而应该使用 "
":class:`~handlers.RotatingFileHandler` 或 "
":class:`~handlers.TimedRotatingFileHandler` 代替它。"

#: ../../howto/logging.rst:933
msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
":class:`~handlers.RotatingFileHandler` 实例将消息发送到硬盘文件，支持最大日志文件大小和日志文件轮换。"

#: ../../howto/logging.rst:936
msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to disk "
"files, rotating the log file at certain timed intervals."
msgstr ""
":class:`~handlers.TimedRotatingFileHandler` 实例将消息发送到硬盘文件，以特定的时间间隔轮换日志文件。"

#: ../../howto/logging.rst:939
msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.SocketHandler` 实例将消息发送到 TCP/IP 套接字。从 3.4 开始，也支持 Unix 域套接字。"

#: ../../howto/logging.rst:942
msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.DatagramHandler` 实例将消息发送到 UDP 套接字。从 3.4 开始，也支持 Unix 域套接字。"

#: ../../howto/logging.rst:945
msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated email"
" address."
msgstr ":class:`~handlers.SMTPHandler` 实例将消息发送到指定的电子邮件地址。"

#: ../../howto/logging.rst:948
msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog "
"daemon, possibly on a remote machine."
msgstr ":class:`~handlers.SysLogHandler` 实例将消息发送到 Unix syslog 守护程序，可能在远程计算机上。"

#: ../../howto/logging.rst:951
msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows "
"NT/2000/XP event log."
msgstr ""
":class:`~handlers.NTEventLogHandler` 实例将消息发送到 Windows NT/2000/XP 事件日志。"

#: ../../howto/logging.rst:954
msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ":class:`~handlers.MemoryHandler` 实例将消息发送到内存中的缓冲区，只要满足特定条件，缓冲区就会刷新。"

#: ../../howto/logging.rst:957
msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
":class:`~handlers.HTTPHandler` 实例使用 ``GET`` 或 ``POST`` 方法将消息发送到 HTTP 服务器。"

#: ../../howto/logging.rst:960
msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file "
"name. This handler is only useful on Unix-like systems; Windows does not "
"support the underlying mechanism used."
msgstr ""
":class:`~handlers.WatchedFileHandler` "
"实例会监视他们要写入日志的文件。如果文件发生更改，则会关闭该文件并使用文件名重新打开。此处理器仅在类 Unix 系统上有用； Windows "
"不支持依赖的基础机制。"

#: ../../howto/logging.rst:965
msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such as "
"those implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":class:`~handlers.QueueHandler` 实例将消息发送到队列，例如在 :mod:`queue` 或 "
":mod:`multiprocessing` 模块中实现的队列。"

#: ../../howto/logging.rst:968
msgid ""
":class:`NullHandler` instances do nothing with error messages. They are used"
" by library developers who want to use logging, but want to avoid the 'No "
"handlers could be found for logger XXX' message which can be displayed if "
"the library user has not configured logging. See :ref:`library-config` for "
"more information."
msgstr ""
":class:`NullHandler` "
"实例对错误消息不执行任何操作。它们由想要使用日志记录的库开发人员使用，但是想要避免如果库用户没有配置日志记录，则显示 'No handlers "
"could be found for logger XXX' 消息的情况。更多有关信息，请参阅 :ref:`library-config` 。"

#: ../../howto/logging.rst:974
msgid "The :class:`NullHandler` class."
msgstr ":class:`NullHandler` 类。"

#: ../../howto/logging.rst:977
msgid "The :class:`~handlers.QueueHandler` class."
msgstr ":class:`~handlers.QueueHandler` 类。"

#: ../../howto/logging.rst:980
msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler` "
"classes are defined in the core logging package. The other handlers are "
"defined in a sub-module, :mod:`logging.handlers`. (There is also another "
"sub-module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
"The :class:`NullHandler` 、 :class:`StreamHandler` 和 :class:`FileHandler` "
"类在核心日志包中定义。其他处理器定义在 :mod:`logging.handlers` 中。（还有另一个子模块 "
":mod:`logging.config` ，用于配置功能）"

#: ../../howto/logging.rst:985
msgid ""
"Logged messages are formatted for presentation through instances of the "
":class:`Formatter` class. They are initialized with a format string suitable"
" for use with the % operator and a dictionary."
msgstr ""
"记录的消息通过 :class:`Formatter` 类的实例进行格式化后呈现。 它们使用能与 ％ 运算符一起使用的格式字符串和字典进行初始化。"

#: ../../howto/logging.rst:989
msgid ""
"For formatting multiple messages in a batch, instances of "
":class:`~handlers.BufferingFormatter` can be used. In addition to the format"
" string (which is applied to each message in the batch), there is provision "
"for header and trailer format strings."
msgstr ""
"要批量格式化多个消息，可以使用 :class:`~handlers.BufferingFormatter` "
"的实例。除了格式字符串（应用于批处理中的每个消息）之外，还提供了标题和尾部格式字符串。"

#: ../../howto/logging.rst:994
msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and "
":class:`Handler` instances (through their :meth:`~Handler.addFilter` "
"method). Before deciding to process a message further, both loggers and "
"handlers consult all their filters for permission. If any filter returns a "
"false value, the message is not processed further."
msgstr ""
"当基于记录器级别和处理器级别的过滤不够时，可以将 :class:`Filter` 的实例添加到 :class:`Logger` 和 "
":class:`Handler` 实例（通过它们的 :meth:`~Handler.addFilter` "
"方法）。在决定进一步处理消息之前，记录器和处理器都会查询其所有过滤器以获得许可。如果任何过滤器返回 false 值，则不会进一步处理该消息。"

#: ../../howto/logging.rst:1001
msgid ""
"The basic :class:`Filter` functionality allows filtering by specific logger "
"name. If this feature is used, messages sent to the named logger and its "
"children are allowed through the filter, and all others dropped."
msgstr ""
"基本 :class:`Filter` "
"的功能允许按特定的记录器名称进行过滤。如果使用此功能，则允许通过过滤器发送到指定记录器及其子项的消息，并丢弃其他所有消息。"

#: ../../howto/logging.rst:1009
msgid "Exceptions raised during logging"
msgstr "记录日志时引发的异常"

#: ../../howto/logging.rst:1011
msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other similar "
"errors - do not cause the application using logging to terminate "
"prematurely."
msgstr ""
"logging "
"包设计为忽略记录日志生产时发生的异常。这样，处理日志记录事件时发生的错误（例如日志记录错误配置、网络或其他类似错误）不会导致使用日志记录的应用程序过早终止。"

#: ../../howto/logging.rst:1016
msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its "
":meth:`~Handler.handleError` method."
msgstr ""
":class:`SystemExit` 和 :class:`KeyboardInterrupt` 异常永远不会被忽略。 在 "
":class:`Handler` 子类的 :meth:`~handler.emit` 方法中发生的其他异常被传递给它的 "
":meth:`~handler.handleError` 方法。"

#: ../../howto/logging.rst:1021
msgid ""
"The default implementation of :meth:`~Handler.handleError` in "
":class:`Handler` checks to see if a module-level variable, "
":data:`raiseExceptions`, is set. If set, a traceback is printed to "
":data:`sys.stderr`. If not set, the exception is swallowed."
msgstr ""
":class:`Handler` 中默认实现的 :meth:`~handler.handleError` 检查是否设置了模块级变量 "
":data:`raiseExceptions` 。如果有设置，则会将回溯打印到 :data:`sys.stderr` 。如果未设置，则忽略异常。"

#: ../../howto/logging.rst:1026
msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because "
"during development, you typically want to be notified of any exceptions that"
" occur. It's advised that you set :data:`raiseExceptions` to ``False`` for "
"production usage."
msgstr ""
":data:`raiseExceptions` 默认值是 ``True``。 这是因为在开发期间，你通常希望收到任何发生异常的通知。建议你将 "
":data:`raiseExceptions` 设置为 ``False`` 以供生产环境使用。"

#: ../../howto/logging.rst:1036
msgid "Using arbitrary objects as messages"
msgstr "使用任意对象作为消息"

#: ../../howto/logging.rst:1038
msgid ""
"In the preceding sections and examples, it has been assumed that the message"
" passed when logging the event is a string. However, this is not the only "
"possibility. You can pass an arbitrary object as a message, and its "
":meth:`~object.__str__` method will be called when the logging system needs "
"to convert it to a string representation. In fact, if you want to, you can "
"avoid computing a string representation altogether - for example, the "
":class:`~handlers.SocketHandler` emits an event by pickling it and sending "
"it over the wire."
msgstr ""
"在前面的部分和示例中，都假设记录事件时传递的消息是字符串。 "
"但是，这不是唯一的可能性。你可以将任意对象作为消息传递，并且当日志记录系统需要将其转换为字符串表示时，将调用其 :meth:`~object .__ "
"str__` 方法。实际上，如果你愿意，你可以完全避免计算字符串表示。例如， :class:`~handlers.SocketHandler` 用 "
"pickle 处理事件后，通过网络发送。"

#: ../../howto/logging.rst:1049
msgid "Optimization"
msgstr "优化"

#: ../../howto/logging.rst:1051
msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be "
"expensive, and you may want to avoid doing it if the logger will just throw "
"away your event. To decide what to do, you can call the "
":meth:`~Logger.isEnabledFor` method which takes a level argument and returns"
" true if the event would be created by the Logger for that level of call. "
"You can write code like this::"
msgstr ""
"消息参数的格式化将被推迟，直到无法避免。但是，计算传递给日志记录方法的参数也可能很消耗资源，如果记录器只是丢弃你的事件，你可能希望避免这样做。要决定做什么，可以调用"
" :meth:`~Logger.isEnabledFor` 方法，该方法接受一个 level 参数，如果记录器为该级别的调用创建了该事件，则返回 "
"true 。 你可以写这样的代码::"

#: ../../howto/logging.rst:1063
msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to "
":func:`expensive_func1` and :func:`expensive_func2` are never made."
msgstr ""
"因此，如果记录器的阈值设置在“DEBUG”以上，则永远不会调用 :func:`expensive_func1` 和 "
":func:`expensive_func2` 。"

#: ../../howto/logging.rst:1066
msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level is "
"only set high up in the logger hierarchy). In such cases (or if you want to "
"avoid calling a method in tight loops), you can cache the result of a call "
"to :meth:`~Logger.isEnabledFor` in a local or instance variable, and use "
"that instead of calling the method each time. Such a cached value would only"
" need to be recomputed when the logging configuration changes dynamically "
"while the application is running (which is not all that common)."
msgstr ""
"在某些情况下， :meth:`~Logger.isEnabledFor` "
"本身可能比你想要的更消耗资源（例如，对于深度嵌套的记录器，其中仅在记录器层次结构中设置了显式级别）。在这种情况下（或者如果你想避免在紧密循环中调用方法），你可以在本地或实例变量中将调用的结果缓存到"
" :meth:`~Logger.isEnabledFor` "
"，并使用它而不是每次调用方法。在日志记录配置在应用程序运行时动态更改（这不常见）时，只需要重新计算这样的缓存值即可。"

#: ../../howto/logging.rst:1075
msgid ""
"There are other optimizations which can be made for specific applications "
"which need more precise control over what logging information is collected. "
"Here's a list of things you can do to avoid processing during logging which "
"you don't need:"
msgstr "对于需要对收集的日志信息进行更精确控制的特定应用程序，还可以进行其他优化。以下列出了在日志记录过程中您可以避免的非必须处理操作："

#: ../../howto/logging.rst:1081
msgid "What you don't want to collect"
msgstr "你不想收集的内容"

#: ../../howto/logging.rst:1081
msgid "How to avoid collecting it"
msgstr "如何避免收集它"

#: ../../howto/logging.rst:1083
msgid "Information about where calls were made from."
msgstr "有关调用来源的信息"

#: ../../howto/logging.rst:1083
msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling "
":func:`sys._getframe`, which may help to speed up your code in environments "
"like PyPy (which can't speed up code that uses :func:`sys._getframe`)."
msgstr ""
"将 ``logging._srcfile`` 设置为 ``None`` 。这避免了调用 :func:`sys._getframe` ，如果 PyPy "
"支持 Python 3.x ，这可能有助于加速 PyPy （无法加速使用 :func:`sys._getframe` 的代码）等环境中的代码。"

#: ../../howto/logging.rst:1089
msgid "Threading information."
msgstr "线程信息"

#: ../../howto/logging.rst:1089
msgid "Set ``logging.logThreads`` to ``False``."
msgstr "将 ``logging.logThreads`` 设为 ``False``。"

#: ../../howto/logging.rst:1091
msgid "Current process ID (:func:`os.getpid`)"
msgstr "当前进程 ID (:func:`os.getpid`)"

#: ../../howto/logging.rst:1091
msgid "Set ``logging.logProcesses`` to ``False``."
msgstr "将 ``logging.logProcesses`` 设为 ``False``。"

#: ../../howto/logging.rst:1093
msgid ""
"Current process name when using ``multiprocessing`` to manage multiple "
"processes."
msgstr "当使用 ``multiprocessing`` 来管理多个进程时的当前进程名称。"

#: ../../howto/logging.rst:1093
msgid "Set ``logging.logMultiprocessing`` to ``False``."
msgstr "将 ``logging.logMultiprocessing`` 设为 ``False``。"

#: ../../howto/logging.rst:1097
msgid ""
"Also note that the core logging module only includes the basic handlers. If "
"you don't import :mod:`logging.handlers` and :mod:`logging.config`, they "
"won't take up any memory."
msgstr ""
"另请注意，核心日志记录模块仅包含基本处理器。如果你不导入 :mod:`logging.handlers` 和 :mod:`logging.config`"
" ，它们将不会占用任何内存。"

#: ../../howto/logging.rst:1104
msgid "Module :mod:`logging`"
msgstr "模块 :mod:`logging`"

#: ../../howto/logging.rst:1104
msgid "API reference for the logging module."
msgstr "日志记录模块的 API 参考。"

#: ../../howto/logging.rst:1107
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模块"

#: ../../howto/logging.rst:1107
msgid "Configuration API for the logging module."
msgstr "日志记录模块的配置 API 。"

#: ../../howto/logging.rst:1110
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模块"

#: ../../howto/logging.rst:1110
msgid "Useful handlers included with the logging module."
msgstr "日志记录模块附带的有用处理器。"

#: ../../howto/logging.rst:1112
msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`日志操作手册 <logging-cookbook>`"
