# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Siyuan Xu, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Siyuan Xu, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/curses.rst:5
msgid "Curses Programming with Python"
msgstr "用 Python 进行 Curses 编程"

#: ../../howto/curses.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/curses.rst:7
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: ../../howto/curses.rst:0
msgid "Release"
msgstr "发布版本"

#: ../../howto/curses.rst:8
msgid "2.04"
msgstr "2.04"

#: ../../howto/curses.rstNone
msgid "Abstract"
msgstr "摘要"

#: ../../howto/curses.rst:13
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr "本文档介绍了如何使用 :mod:`curses` 扩展模块控制文本模式的显示。"

#: ../../howto/curses.rst:18
msgid "What is curses?"
msgstr "curses 是什么？"

#: ../../howto/curses.rst:20
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common"
" operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their"
" own minor quirks."
msgstr ""
"curses 库为基于文本的终端提供了独立于终端的屏幕绘制和键盘处理功能；这些终端包括 VT100，Linux "
"控制台以及各种程序提供的模拟终端。显示终端支持各种控制代码以执行常见的操作，例如移动光标，滚动屏幕和擦除区域。不同的终端使用相差很大的代码，并且往往有自己的小怪癖。"

#: ../../howto/curses.rst:28
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run"
" an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is "
"available."
msgstr ""
"在普遍使用图形显示的世界中，人们可能会问“为什么自找要麻烦”？毕竟字符单元显示终端确实是一种过时的技术，但是在某些领域中，能够用它们做花哨的事情仍然很有价值。一个小众市场是在不运行"
" X server 的小型或嵌入式 Unix 上。另一个是在提供图形支持之前，可能需要运行的工具，例如操作系统安装程序和内核配置程序。"

#: ../../howto/curses.rst:36
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such"
" features, consider a user interface library such as `Urwid "
"<https://pypi.org/project/urwid/>`_."
msgstr ""
"curses 库提供了相当基础的功能，为程序员提供了包含多个非重叠文本窗口的显示的抽象。窗口的内容可以通过多种方式更改---"
"添加文本，擦除文本，更改其外观---以及curses库将确定需要向终端发送哪些控制代码以产生正确的输出。 "
"curses并没有提供诸多用户界面概念，例如按钮，复选框或对话框。如果需要这些功能，请考虑用户界面库，例如 `Urwid "
"<https://pypi.org/project/urwid/>`_ 。"

#: ../../howto/curses.rst:46
msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an"
" open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"curses 库最初是为BSD Unix 编写的。 后来 AT&T 的Unix System V 版本加入了许多增强功能和新功能。如今BSD "
"curses已不再维护，被ncurses取代，ncurses是 AT&T 接口的开源实现。如果使用的是 Linux 或 FreeBSD "
"等开源Unix系统，则几乎肯定会使用ncurses。由于大多数当前的商业Unix版本都基于System "
"V代码，因此这里描述的所有功能可能都可用。但是，某些专有Unix所带来的较早版本的curses可能无法支持所有功能。"

#: ../../howto/curses.rst:56
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called `UniCurses <https://pypi.org/project/UniCurses>`_ is "
"available.  You could also try `the Console module <http://effbot.org/zone"
"/console-index.htm>`_ written by Fredrik Lundh, which doesn't use the same "
"API as curses but provides cursor-addressable text output and full support "
"for mouse and keyboard input."
msgstr ""
"Windows 版本的 Python 不包含 :mod:`curses` 模块。提供了一个名为 `UniCurses "
"<https://pypi.org/project/UniCurses>`_ 的移植版本。也可以尝试使用 Fredrik Lundh 编写 `the "
"Console module <http://effbot.org/zone/console-"
"index.htm>`_，它使用了与curses不相同的API，但提供了可光标定位的文本输出，完全支持鼠标和键盘输入。"

#: ../../howto/curses.rst:66
msgid "The Python curses module"
msgstr "Python 的 curses 模块"

#: ../../howto/curses.rst:68
msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is"
" that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`addstr`, :c:func:`mvaddstr`, and "
":c:func:`mvwaddstr` into a single :meth:`~curses.window.addstr` method.  "
"You'll see this covered in more detail later."
msgstr ""
"此 Python 模块相当简单地封装了 curses 提供的 C 函数；如果你已经熟悉在 C 语言中使用 curses 编程，把这些知识转移的 "
"Python 是非常容易的。最大的差异在于 Python 中的接口通过把不同的 C 函数合并来让事情变得更简单，比如 "
":c:func:`addstr`、:c:func:`mvaddstr` 和 :c:func:`mvwaddstr` 三个 C 函数被并入 "
":meth:`~curses.window.addstr` 这一个方法。下文中会描述更多的细节。"

#: ../../howto/curses.rst:76
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"本 HOWTO 是关于使用 curses 和 Python 编写文本模式程序的概述。它并不被设计为一个 curses API "
"的完整指南；如需完整指南，请参见 ncurses 的 Python 库指南章节和 ncurses 的 C 手册页。相对地，本 HOWTO "
"将会给你一些基本思路。"

#: ../../howto/curses.rst:83
msgid "Starting and ending a curses application"
msgstr "开始和结束 curses 应用程序"

#: ../../howto/curses.rst:85
msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""
"在做任何事情之前，curses 必须先被初始化。可以通过调用函数 :func:`~curses.initscr` "
"来实现，它将查明终端的类型，向终端发送任何必须的设置代码，并创建多种内部数据结构。如果此操作成功，:func:`initscr` "
"将会返回一个代表整个屏幕的窗口对象；它通常会遵循对应的 C 变量名被称作 ``stdscr``："

#: ../../howto/curses.rst:96
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain"
" circumstances.  This requires calling the :func:`~curses.noecho` function. "
"::"
msgstr ""
"使用 curses 的应用程序通常会关闭按键自动上屏，目的是读取按键并只在特定情况下展示它们。这需要调用函数 "
":func:`~curses.noecho`："

#: ../../howto/curses.rst:103
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr "应用程序也会广泛地需要立即响应按键，而不需要按下回车键；这被称为 “cbreak” 模式，与通常的缓冲输入模式相对："

#: ../../howto/curses.rst:109
msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation"
" keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as "
":const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to "
"enable keypad mode. ::"
msgstr ""
"终端通常会以多字节转义序列的形式返回特殊按键，比如光标键和导航键比如 Page Up 键和 Home "
"键。尽管你可以编写你的程序来应对这些序列，curses 能够代替你做到这件事，返回一个特殊值比如 "
":const:`curses.KEY_LEFT`。为了让 curses 做这项工作，你需要启用 keypad 模式："

#: ../../howto/curses.rst:118
msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr "终止一个 curses 应用程序比建立一个容易得多，你只需要调用："

#: ../../howto/curses.rst:125
msgid ""
"to reverse the curses-friendly terminal settings. Then call the "
":func:`~curses.endwin` function to restore the terminal to its original "
"operating mode. ::"
msgstr "来还原对终端作出的 curses 友好设置。然后，调用函数 :func:`~curses.endwin` 来将终端还原到它的原始操作模式："

#: ../../howto/curses.rst:131
msgid ""
"A common problem when debugging a curses application is to get your terminal"
" messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and"
" raises an uncaught exception.  Keys are no longer echoed to the screen when"
" you type them, for example, which makes using the shell difficult."
msgstr ""
"调试一个 curses 应用程序时常会发生，一个应用程序还未能还原终端到原本的状态就意外退出了，这会搅乱你的终端。在 Python "
"中这常常会发生在你的代码中有 bug 并引发了一个未捕获的异常。当你尝试输入时按键不会上屏，这使得使用终端变得困难。"

#: ../../howto/curses.rst:137
msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr ""
"在 Python 中你可以避免这些复杂问题并让调试变得更简单，只需要导入 :func:`curses.wrapper` 函数并像这样使用它："

#: ../../howto/curses.rst:156
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`wrapper` then runs your provided callable. Once the "
"callable returns, :func:`wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ "
":keyword:`except` that catches exceptions, restores the state of the "
"terminal, and then re-raises the exception.  Therefore your terminal won't "
"be left in a funny state on exception and you'll be able to read the "
"exception's message and traceback."
msgstr ""
"函数 :func:`~curses.wrapper` 接受一个可调用对象并首先进行上述初始化过程，在终端支持着色时还会初始化颜色。接着 "
":func:`wrapper` 运行你提供的可调用对象。当该可调用对象返回时，:func:`wrapper` 会还原终端到初始状态。该可调用对象会在 "
":keyword:`try`...\\ :keyword:`except` "
"这样的结构内被调用，当它捕获到异常时，会先还原终端再重新引发这个异常。所以你的终端不会因为异常而被留在一个搞笑的状态，你也可以正常阅读异常消息和回溯信息。"

#: ../../howto/curses.rst:168
msgid "Windows and Pads"
msgstr "窗口和面板"

#: ../../howto/curses.rst:170
msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr "窗口是 curses 中的基本抽象。一个窗口对象表示了屏幕上的一个矩形区域，并且提供方法来显示文本、擦除文本、允许用户输入字符串等等。"

#: ../../howto/curses.rst:174
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The "
":func:`~curses.newwin` function creates a new window of a given size, "
"returning the new window object. ::"
msgstr ""
"函数 :func:`~curses.initscr` 返回的 ``stdscr`` "
"对象覆盖整个屏幕。许多程序可能只需要这一个窗口，但你可能希望把屏幕分割为多个更小的窗口，来分别重绘或者清除它们。函数 "
":func:`~curses.newwin` 根据给定的尺寸创建一个新窗口，并返回这个新的窗口对象："

#: ../../howto/curses.rst:185
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"注意 curses 使用的坐标系统与寻常的不同。坐标始终是以 *y,x* 的顺序传递，并且左上角是坐标 (0,0)。这打破了正常的坐标处理约定，即 "
"*x* 坐标在前。这是一个与其他计算机应用程序糟糕的差异，但这从 curses 最初被编写出来就已是它的一部分，现在想要修改它已为时已晚。"

#: ../../howto/curses.rst:193
msgid ""
"Your application can determine the size of the screen by using the "
":data:`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and"
" *x* sizes.  Legal coordinates will then extend from ``(0,0)`` to "
"``(curses.LINES - 1, curses.COLS - 1)``."
msgstr ""
"你的应用程序能够查明屏幕的尺寸，:data:`curses.LINES` 和 :data:`curses.COLS` 分别代表了 *y* 和 *x* "
"方向上的尺寸。合理的坐标应位于 ``(0,0)`` 到 ``(curses.LINES - 1, curses.COLS - 1)`` 范围内。"

#: ../../howto/curses.rst:198
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the "
":meth:`~curses.window.refresh` method of window objects to update the "
"screen."
msgstr ""
"当你调用一个方法来显示或擦除文本时，效果并不会立即显示。相反，你必须调用窗口对象的 :meth:`~curses.window.refresh` "
"方法来更新屏幕。"

#: ../../howto/curses.rst:203
msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to"
" the screen and displays them in the most efficient manner when you call "
":meth:`refresh`.  For example, if your program displays some text in a "
"window and then clears the window, there's no need to send the original text"
" because they're never visible."
msgstr ""
"这是因为 curses 最初是为 300 波特的龟速终端连接编写的；在这些终端上，压制重绘屏幕的时间就非常重要。相对地，当你调用 "
":meth:`refresh` 时，curses "
"会累积屏幕的修改并以效率最高的方式显示它们。打个比方，如果你的程序在一个窗口内显示一些文本然后清楚了这个窗口，那么这些原始文本不需要被发送，因为它们甚至不曾能被看见。"

#: ../../howto/curses.rst:212
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been"
" redrawn before pausing to wait for user input, by first calling "
"``stdscr.refresh()`` or the :meth:`refresh` method of some other relevant "
"window."
msgstr ""
"在实践中，显式地告诉 curses 来重绘一个窗口并不会太复杂化 curses "
"编程。大部分程序会显示一堆内容然后等待按键或者其他某些用户侧动作。你要做的事情就是，保证屏幕在暂停并等待用户输入前被重绘，只需要先调用 "
"``stdscr.refresh()`` 或者其他相关窗口的 :meth:`refresh` 方法。"

#: ../../howto/curses.rst:220
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"一个面板是一种特殊的窗口，它可以比实际的显示屏幕更大，并且能只显示它的一部分。创建面板需要指定面板的高度和宽度，但刷新一个面板需要给出屏幕坐标和面板的需要显示的局部。"

#: ../../howto/curses.rst:241
msgid ""
"The :meth:`refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""
"此 :meth:`refresh` 调用会在屏幕坐标 (5,5) 到坐标 (20,75) 的矩形范围内显示面板的一个部分，被显示的部分在面板上的坐标是 "
"(0,0)。除了上述差异，面板与常规的窗口相同，也支持相同的方法。"

#: ../../howto/curses.rst:247
msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of"
" the screen gets updated.  :meth:`refresh` actually does two things:"
msgstr ""
"如果你在屏幕上有多个窗口和面板，有一个更有效率的方法来更新窗口，避免每个部分单独更新时烦人的屏幕闪烁。:meth:`refresh` 实际上做了两件事："

#: ../../howto/curses.rst:252
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update"
" an underlying data structure representing the desired state of the screen."
msgstr "调用每个窗口的  :meth:`~curses.window.noutrefresh` 方法来更新一个表达屏幕期望状态的底层的数据结构。"

#: ../../howto/curses.rst:255
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr "调用函数 :func:`~curses.doupdate` 来改变物理屏幕来符合这个数据结构中记录的期望状态。"

#: ../../howto/curses.rst:258
msgid ""
"Instead you can call :meth:`noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`doupdate` to update the screen."
msgstr ""
"你可以改为调用在多个窗口上 :meth:`noutrefresh` 方法来更新该数据结构，然后调用函数 :func:`doupdate` 来更新屏幕。"

#: ../../howto/curses.rst:264
msgid "Displaying Text"
msgstr "显示文字"

#: ../../howto/curses.rst:266
msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty"
" maze of functions, all subtly different.  For example, :c:func:`addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`waddstr` is just like :c:func:`addstr`, but "
"allows specifying a window to use instead of using ``stdscr`` by default. "
":c:func:`mvwaddstr` allows specifying both a window and a coordinate."
msgstr ""
"从一名 C 语言程序员的视角来看，curses 有时看起来就像是一堆略有差异的函数组成的扭曲迷宫。举个例子，:c:func:`addstr` 在 "
"``stdscr`` 窗口的当前光标位置显示一个字符串，而 :c:func:`mvaddstr` 则是先移动到一个给定的 y,x "
"坐标再显示字符串。:c:func:`waddstr` 与 :c:func:`addstr` 类似，但允许指定一个窗口而非默认的 "
"``stdscr``。:c:func:`mvwaddstr` 允许同时指定一个窗口和一个坐标。"

#: ../../howto/curses.rst:275
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as "
":meth:`~curses.window.addstr` accept multiple argument forms.  Usually there"
" are four different forms."
msgstr ""
"幸运的是，Python 接口隐藏了所有这些细节。``stdscr`` 和其他任何窗口一样是一个窗口对象，并且诸如 "
":meth:`~curses.window.addstr` 之类的方法接受多种参数形式。通常有四种形式。"

#: ../../howto/curses.rst:281
msgid "Form"
msgstr "形式"

#: ../../howto/curses.rst:281 ../../howto/curses.rst:350
msgid "Description"
msgstr "描述"

#: ../../howto/curses.rst:283
msgid "*str* or *ch*"
msgstr "*str* 或 *ch*"

#: ../../howto/curses.rst:283
msgid "Display the string *str* or character *ch* at the current position"
msgstr "在当前位置显示字符串 *str* 或字符 *ch*"

#: ../../howto/curses.rst:286
msgid "*str* or *ch*, *attr*"
msgstr "*str* 或 *ch*, *attr*"

#: ../../howto/curses.rst:286
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr "在当前位置使用 *attr* 属性显示字符串 *str* 或字符 *ch*"

#: ../../howto/curses.rst:290
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* 或 *ch*"

#: ../../howto/curses.rst:290
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "移动到窗口内的 *y,x* 位置，并显示 *str* 或 *ch*"

#: ../../howto/curses.rst:293
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* 或 *ch*, *attr*"

#: ../../howto/curses.rst:293
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr "移至窗口内的 *y,x* 位置，并使用 *attr* 属性显示 *str* 或 *ch*"

#: ../../howto/curses.rst:297
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr "属性允许以突出显示形态显示文本，比如加粗、下划线、反相或添加颜色。这些属性将来下一小节细说。"

#: ../../howto/curses.rst:302
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring"
" as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`encoding` attribute; this defaults to the default system "
"encoding as returned by :func:`locale.getpreferredencoding`."
msgstr ""
"方法 :meth:`~curses.window.addstr` 接受一个 Python "
"字符串或字节串作为用于显示的值。字节串的内容会被原样发送到终端。字符串会使用窗口的 :attr:`encoding` 属性值编码为字节，它默认为 "
":func:`locale.getpreferredencoding` 返回的系统默认编码。"

#: ../../howto/curses.rst:309
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
"方法 :meth:`~curses.window.addch` 接受一个字符，可以是长度为 1 的字符串，长度为 1 的字节串或者一个整数。"

#: ../../howto/curses.rst:312
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"对于特殊扩展字符有一些常量，这些常量是大于 255 的整数。比如，:const:`ACS_PLMINUS` 是一个 “加减” "
"符号，:const:`ACS_ULCORNER` 是一个框的左上角（方便绘制边界）。你也可以使用正确的 Unicode 字符。"

#: ../../howto/curses.rst:318
msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display"
" a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the"
" cursor blinking at some apparently random location."
msgstr ""
"窗口会记住上次操作之后光标所在位置，所以如果你忽略 *y,x* 坐标，字符串和字符会出现在上次操作结束的位置。你也可以通过 ``move(y,x)`` "
"的方法来移动光标。因为一些终端始终会显示一个闪烁的光标，你可能会想要保证光标处于一些不会让人感到分心的位置。在看似随机的位置出现一个闪烁的光标会令人非常迷惑。"

#: ../../howto/curses.rst:326
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for "
":func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"如果你的应用程序完全不需要一个闪烁的光标，你可以调用 ``curs_set(False)`` 来使它隐形。为与旧版本 curses "
"的兼容性的关系，有函数 ``leaveok(bool)`` 作为 :func:`~curses.curs_set` 的等价替换。如果 *bool* "
"是真值，curses 库会尝试移除闪烁光标，并且你也不必担心它会留在一些奇怪的位置。"

#: ../../howto/curses.rst:335
msgid "Attributes and Color"
msgstr "属性和颜色"

#: ../../howto/curses.rst:337
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based"
" application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify"
" an attribute for each cell on the screen."
msgstr ""
"字符可以以不同的方式显示。基于文本的应用程序常常以反相显示状态行，一个文本查看器可能需要突出显示某些单词。为了支持这种用法，curses "
"允许你为屏幕上的每个单元指定一个属性值。"

#: ../../howto/curses.rst:342
msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"属性值是一个整数，它的每一个二进制位代表一个不同的属性。你可以尝试以多种不属性位组合来显示文本，但 curses "
"不保证所有的组合都是有效的，或者看上去有明显不同。这一点取决于用户终端的能力，所以最稳妥的方式是只采用最常见的有效属性，见下表。"

#: ../../howto/curses.rst:350
msgid "Attribute"
msgstr "属性"

#: ../../howto/curses.rst:352
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: ../../howto/curses.rst:352
msgid "Blinking text"
msgstr "闪烁文本"

#: ../../howto/curses.rst:354
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: ../../howto/curses.rst:354
msgid "Extra bright or bold text"
msgstr "超亮或粗体文本"

#: ../../howto/curses.rst:356
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: ../../howto/curses.rst:356
msgid "Half bright text"
msgstr "半明亮文本"

#: ../../howto/curses.rst:358
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: ../../howto/curses.rst:358
msgid "Reverse-video text"
msgstr "反相显示文本"

#: ../../howto/curses.rst:360
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: ../../howto/curses.rst:360
msgid "The best highlighting mode available"
msgstr "可用的最佳突出显示模式"

#: ../../howto/curses.rst:362
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: ../../howto/curses.rst:362
msgid "Underlined text"
msgstr "带下划线的文本"

#: ../../howto/curses.rst:365
msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr "所以，为了在屏幕顶部显示一个反相的状态行，你可以这么编写："

#: ../../howto/curses.rst:372
msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr ""
"curses 库还支持在提供了颜色功能的终端上显示颜色的功能。最常见的提供颜色的终端很可能是 Linux 控制台，采用了 xterms 配色方案。"

#: ../../howto/curses.rst:376
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling"
" 'color', instead of the Canadian/British spelling 'colour'.  If you're used"
" to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"为了使用颜色，你必须在调用完函数 :func:`~curses.initscr` 后尽快调用函数 "
":func:`~curses.start_color`，来初始化默认颜色集 (:func:`curses.wrapper` 函数自动完成了这一点)。 "
"当它完成后，如果使用中的终端支持显示颜色， :func:`~curses.has_colors` 会返回真值。 （注意：curses 使用美式拼写 "
"“color”，而不是英式／加拿大拼写 “colour”。如果你习惯了英式拼写，你需要避免自己在这些函数上拼写错误。）"

#: ../../howto/curses.rst:386
msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the "
":func:`~curses.color_pair` function; this can be bitwise-OR'ed with other "
"attributes such as :const:`A_REVERSE`, but again, such combinations are not "
"guaranteed to work on all terminals."
msgstr ""
"curses 库维护一个有限数量的颜色对，包括一个前景（文本）色和一个背景色。你可以使用函数  :func:`~curses.color_pair` "
"获得一个颜色对对应的属性值。它可以通过按位或运算与其他属性，比如 :const:`A_REVERSE` "
"组合。但再说明一遍，这种组合并不保证在所有终端上都有效。"

#: ../../howto/curses.rst:393
msgid "An example, which displays a line of text using color pair 1::"
msgstr "一个样例，用 1 号颜色对显示一行文本："

#: ../../howto/curses.rst:398
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"如前所述， 颜色对由前景色和背景色组成。  ``init_pair(n, f, b)`` 函数可改变颜色对 *n* 的定义 为前景色 f 和背景色 b。"
" 颜色对 0 硬编码为黑底白字，不能改变。"

#: ../../howto/curses.rst:403
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when"
" it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, "
"4:blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, "
":const:`curses.COLOR_RED`, and so forth."
msgstr ""
"颜色已经被编号，并且当其激活 color 模式时 :func:`start_color` 会初始化 8 种基本颜色。 它们是: 0:black, "
"1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan 和 7:white。 :mod:`curses`"
" 模块为这些颜色定义了相应的名称常量: :const:`curses.COLOR_BLACK`, :const:`curses.COLOR_RED` "
"等等。"

#: ../../howto/curses.rst:409
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr "让我们来做个综合练习。 要将颜色 1 改为红色文本白色背景，你应当调用::"

#: ../../howto/curses.rst:414
msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr "当你改变一个颜色对时，任何已经使用该颜色对来显示的文本将会更改为新的颜色。 你还可以这样来显示新颜色的文本::"

#: ../../howto/curses.rst:420
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide"
" any examples.  You can check if your terminal can do this by calling "
":func:`~curses.can_change_color`, which returns ``True`` if the capability "
"is there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"某些非常花哨的终端可以将实际颜色定义修改为给定的 RGB 值。 这允许你将通常为红色的 1 号颜色改成紫色或蓝色或者任何你喜欢的颜色。 "
"不幸的是，Linux 控制台不支持此特性，所以我无法尝试它，也无法提供任何示例。 想要检查你的终端是否能做到你可以调用 "
":func:`~curses.can_change_color`，如果有此功能则它将返回 ``True``。 "
"如果你幸运地拥有一个如此优秀的终端，请查询你的系统的帮助页面来了解详情。"

#: ../../howto/curses.rst:431
msgid "User Input"
msgstr "用户输入"

#: ../../howto/curses.rst:433
msgid ""
"The C curses library offers only very simple input mechanisms. Python's "
":mod:`curses` module adds a basic text-input widget.  (Other libraries such "
"as `Urwid <https://pypi.org/project/urwid/>`_ have more extensive "
"collections of widgets.)"
msgstr ""
"C curses 库提供了非常简单的输入机制。 Python 的 :mod:`curses` 模块添加了一个基本的文本输入控件。 （其他的库例如 "
"`Urwid <https://pypi.org/project/urwid/>`_ 拥有更丰富的控件集。）"

#: ../../howto/curses.rst:438
msgid "There are two methods for getting input from a window:"
msgstr "有两个方法可以从窗口获取输入:"

#: ../../howto/curses.rst:440
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor"
" should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` 会刷新屏幕然后等待用户按键，如果之前调用过 :func:`~curses.echo` "
"还会显示所按的键。 你还可以选择指定一个坐标以便在暂停之前让光标移动到那里。"

#: ../../howto/curses.rst:445
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and"
" special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` 将做同样的事但是会把整数转换为字符串。 每个字符将返回为长度为 1 "
"个字符的字符串，特殊键例如函数键将返回包含键名的较长字符串例如 ``KEY_UP`` 或 ``^G``。"

#: ../../howto/curses.rst:450
msgid ""
"It's possible to not wait for the user using the "
":meth:`~curses.window.nodelay` window method. After ``nodelay(True)``, "
":meth:`getch` and :meth:`getkey` for the window become non-blocking. To "
"signal that no input is ready, :meth:`getch` returns ``curses.ERR`` (a value"
" of -1) and :meth:`getkey` raises an exception. There's also a "
":func:`~curses.halfdelay` function, which can be used to (in effect) set a "
"timer on each :meth:`getch`; if no input becomes available within a "
"specified delay (measured in tenths of a second), curses raises an "
"exception."
msgstr ""
"使用 :meth:`~curses.window.nodelay` 窗口方法可以做到不等待用户。 在 ``nodelay(True)`` 之后，窗口的 "
":meth:`getch` 和 :meth:`getkey` 将成为非阻塞的。 为表明输入未就绪，:meth:`getch` 会返回 "
"``curses.ERR`` (值为 -1) 而 :meth:`getkey` 会引发异常。 此外还有 "
":func:`~curses.halfdelay` 函数，它可被用来（实际地）在每个 :meth:`getch` "
"上设置一个计时器；如果在指定的延迟内没有输入可用（以十分之一秒为单位），curses 将引发异常。"

#: ../../howto/curses.rst:460
msgid ""
"The :meth:`getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, "
":const:`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of "
"your program may look something like this::"
msgstr ""
":meth:`getch` 方法返回一个整数；如果数值在 0 到 255 之间，它代表所按下键的 ASCII 码。 大于 255 的值为特殊键例如 "
"Page Up, Home 或方向键等。 你可以将返回的值与 :const:`curses.KEY_PPAGE`, "
":const:`curses.KEY_HOME` 或 :const:`curses.KEY_LEFT` 等常量做比较。 "
"你的程序主循环看起来可能是这样::"

#: ../../howto/curses.rst:476
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
":mod:`curses.ascii` 模块提供了一些 ASCII 类成员函数，它们接受整数或长度为 1 "
"个字符的字符串参数；这些函数在为这样的循环编写更具可读性的测试时可能会很有用。 它还提供了一些转换函数，它们接受整数或长度为 1 "
"个字符的字符串参数并返回同样的类型。 例如，:func:`curses.ascii.ctrl` 返回与其参数相对应的控制字符。"

#: ../../howto/curses.rst:483
msgid ""
"There's also a method to retrieve an entire string, "
":meth:`~curses.window.getstr`.  It isn't used very often, because its "
"functionality is quite limited; the only editing keys available are the "
"backspace key and the Enter key, which terminates the string.  It can "
"optionally be limited to a fixed number of characters. ::"
msgstr ""
"还有一个可以提取整个字符串的方法 :meth:`~curses.window.getstr`。 它并不经常被使用，因为它的功能相当受限；可用的编辑键只有"
" Backspace 和 Enter 键，它们会结束字符串。 也可以选择限制为固定数量的字符。 ::"

#: ../../howto/curses.rst:494
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the "
":class:`~curses.textpad.Textbox` class support editing with input validation"
" and gathering the edit results either with or without trailing spaces.  "
"Here's an example::"
msgstr ""
":mod:`curses.textpad` 模块提供了一个文本框，它支持类似 Emacs 的键绑定集。 "
":class:`~curses.textpad.Textbox` 类的各种方法支持带输入验证的编辑及包含或不包含末尾空格地收集编辑结果。 "
"下面是一个例子::"

#: ../../howto/curses.rst:518
msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr "请查看 :mod:`curses.textpad` 的库文档了解更多细节。"

#: ../../howto/curses.rst:522
msgid "For More Information"
msgstr "更多的信息"

#: ../../howto/curses.rst:524
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably complete."
"  You should browse it next."
msgstr ""
"本 HOWTO 没有涵盖一些进阶主题，例如读取屏幕的内容或从 xterm 实例捕获鼠标事件等，但是 :mod:`curses` 模块的 Python "
"库文档页面现在已相当完善。 接下来你应当去浏览一下其中的内容。"

#: ../../howto/curses.rst:529
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and "
":const:`ACS_\\*` characters available to you."
msgstr ""
"如果你对 curses 函数的细节行为有疑问，请查看你的 curses 实现版本的说明页面，不论它是 ncurses 还是特定 Unix 厂商的版本。 "
"说明页面将记录任何具体问题，并提供所有函数、属性以及可用 :const:`ACS_\\*` 字符的完整列表。"

#: ../../howto/curses.rst:536
msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide "
"<https://devguide.python.org/>`_ to learn more about submitting patches to "
"Python."
msgstr ""
"由于 curses API 是如此的庞大，某些函数并不被 Python 接口所支持。 这往往不是因为它们难以实现，而是因为还没有人需要它们。 "
"此外，Python 尚不支持与 ncurses 相关联的菜单库。 欢迎提供添加这些功能的补丁；请参阅 `Python 开发者指南 "
"<https://devguide.python.org/>`_ 了解有关为 Python 提交补丁的详情。"

#: ../../howto/curses.rst:544
msgid ""
"`Writing Programs with NCURSES <http://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`使用 NCURSES 编写程序 <http://invisible-island.net/ncurses/ncurses-intro.html>`_:"
" 一篇面向 C 程序员的详细教程。"

#: ../../howto/curses.rst:546
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "ncurses 手册主页 <https://linux.die.net/man/3/ncurses>`_"

#: ../../howto/curses.rst:547
msgid ""
"`The ncurses FAQ <http://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr "ncurses 常见问题 <http://invisible-island.net/ncurses/ncurses.faq.html>`_"

#: ../../howto/curses.rst:548
msgid ""
"`\"Use curses... don't swear\" "
"<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk "
"on controlling terminals using curses or Urwid."
msgstr ""
"`\"使用 curses... 请勿爆粗\" <https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: "
"一场有关使用 curses 或 Urwid 来控制终端的 PyCon 2013 演讲的视频。"

#: ../../howto/curses.rst:550
msgid ""
"`\"Console Applications with Urwid\" <http://www.pyvideo.org/video/1568"
"/console-applications-with-urwid>`_: video of a PyCon CA 2012 talk "
"demonstrating some applications written using Urwid."
msgstr ""
"`\"使用 Urwid 的控制台应用程序\" <http://www.pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: 一场演示使用 Urwid 编写应用程序的 PyCon CA 2012 演讲的视频。"
