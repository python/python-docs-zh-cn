# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# 乐成 王, 2024
# lian Wu (Wulian) <xiguawulian@gmail.com>, 2024
# LeeWendao <LeeWendao@outlook.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/sorting.rst:4
msgid "Sorting Techniques"
msgstr "排序的技术"

#: ../../howto/sorting.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/sorting.rst:6
msgid "Andrew Dalke and Raymond Hettinger"
msgstr "Andrew Dalke 与 Raymond Hettinger"

#: ../../howto/sorting.rst:9
msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the list"
" in-place.  There is also a :func:`sorted` built-in function that builds a "
"new sorted list from an iterable."
msgstr "内置列表方法 :meth:`list.sort` 原地修改列表，而内置函数 :func:`sorted` 由可迭代对象新建有序列表。"

#: ../../howto/sorting.rst:13
msgid ""
"In this document, we explore the various techniques for sorting data using "
"Python."
msgstr "在本文档中，我们将探索使用 Python 对数据进行排序的各种技术。"

#: ../../howto/sorting.rst:17
msgid "Sorting Basics"
msgstr "排序的基础知识"

#: ../../howto/sorting.rst:19
msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` function."
" It returns a new sorted list:"
msgstr "普通的升序排序非常容易：只需调用 :func:`sorted` 函数。它返回新有序列表："

#: ../../howto/sorting.rst:22
msgid ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:27
msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-place"
" (and returns ``None`` to avoid confusion). Usually it's less convenient "
"than :func:`sorted` - but if you don't need the original list, it's slightly"
" more efficient."
msgstr ""
"亦可用 :meth:`list.sort` 方法。它原地修改原列表（并返回 ``None`` 以避免混淆）。往往不如 :func:`sorted` "
"方便——但若不需原列表，用它会略高效些。"

#: ../../howto/sorting.rst:32
msgid ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:39
msgid ""
"Another difference is that the :meth:`list.sort` method is only defined for "
"lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr "另一个区别是 :meth:`list.sort` 方法只为列表定义，而 :func:`sorted` 函数接受任何可迭代对象。"

#: ../../howto/sorting.rst:42
msgid ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:48
msgid "Key Functions"
msgstr "键函数"

#: ../../howto/sorting.rst:50
msgid ""
"The :meth:`list.sort` method and the functions :func:`sorted`, :func:`min`, "
":func:`max`, :func:`heapq.nsmallest`, and :func:`heapq.nlargest` have a "
"*key* parameter to specify a function (or other callable) to be called on "
"each list element prior to making comparisons."
msgstr ""
":meth:`list.sort` 方法以及 :func:`sorted`, :func:`min`, :func:`max`, "
":func:`heapq.nsmallest` 和 :func:`heapq.nlargest` 等函数都有一个 *key* "
"形参用以指定要在进行比较之前对每个列表元素调用的函数（或其它可调用对象）。"

#: ../../howto/sorting.rst:56
msgid ""
"For example, here's a case-insensitive string comparison using "
":meth:`str.casefold`:"
msgstr "例如，下面是使用 :meth:`str.casefold` 进行不区分大小写的字符串比较："

#: ../../howto/sorting.rst:59
msgid ""
">>> sorted(\"This is a test string from Andrew\".split(), key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"
msgstr ""
">>> sorted(\"This is a test string from Andrew\".split(), key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"

#: ../../howto/sorting.rst:64
msgid ""
"The value of the *key* parameter should be a function (or other callable) "
"that takes a single argument and returns a key to use for sorting purposes. "
"This technique is fast because the key function is called exactly once for "
"each input record."
msgstr "*key* 形参的值需为一元函数（或其它可调用对象），其返回值用于排序。这很快，因为键函数只需在输入的每个记录上调用恰好一次。"

#: ../../howto/sorting.rst:69
msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr "常见的模式是用对象的某一些索引作为键对复杂对象排序。例如："

#: ../../howto/sorting.rst:72
msgid ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # sort by age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # 按年龄排序\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:82
msgid ""
"The same technique works for objects with named attributes. For example:"
msgstr "同样的方法对于有具名属性的对象也适用。例如："

#: ../../howto/sorting.rst:84
msgid ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # sort by age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # 按年龄排序\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:102
msgid ""
"Objects with named attributes can be made by a regular class as shown above,"
" or they can be instances of :class:`~dataclasses.dataclass` or a "
":term:`named tuple`."
msgstr ""
"有具名属性的对象可像上面这样用一个常规的类来创建，亦可是 :class:`~dataclasses.dataclass` 实例或 "
":term:`named tuple`。"

#: ../../howto/sorting.rst:107
msgid "Operator Module Functions and Partial Function Evaluation"
msgstr "运算符模块的函数与函数的偏求值"

#: ../../howto/sorting.rst:109
msgid ""
"The :term:`key function` patterns shown above are very common, so Python "
"provides convenience functions to make accessor functions easier and faster."
" The :mod:`operator` module has :func:`~operator.itemgetter`, "
":func:`~operator.attrgetter`, and a :func:`~operator.methodcaller` function."
msgstr ""
"上述 :term:`key function` 模式相当常见，为了让访问器函数更加好写好用，Python "
"提供了一些便捷函数。:mod:`operator` 模块里有 "
":func:`~operator.itemgetter`、:func:`~operator.attrgetter` 和 "
":func:`~operator.methodcaller` 函数。"

#: ../../howto/sorting.rst:114
msgid "Using those functions, the above examples become simpler and faster:"
msgstr "用了那些函数之后，前面的示例变得更简单，运行起来也更快："

#: ../../howto/sorting.rst:116
msgid ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:126
msgid ""
"The operator module functions allow multiple levels of sorting. For example,"
" to sort by *grade* then by *age*:"
msgstr "运算符模块的函数可以用来作多级排序。例如，按 *grade* 排序，然后按 *age* 排序："

#: ../../howto/sorting.rst:129
msgid ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"

#: ../../howto/sorting.rst:137
msgid ""
"The :mod:`functools` module provides another helpful tool for making key-"
"functions.  The :func:`~functools.partial` function can reduce the `arity "
"<https://en.wikipedia.org/wiki/Arity>`_ of a multi-argument function making "
"it suitable for use as a key-function."
msgstr ""
"另一个有助于创建键函数的工具位于 :mod:`functools` 模块。:func:`~functools.partial` 函数可以降低多元函数的 "
"`元数 <https://en.wikipedia.org/wiki/Arity>`_ 使之适合做键函数。"

#: ../../howto/sorting.rst:142
msgid ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"
msgstr ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"

#: ../../howto/sorting.rst:156
msgid "Ascending and Descending"
msgstr "升序与降序"

#: ../../howto/sorting.rst:158
msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter with "
"a boolean value. This is used to flag descending sorts. For example, to get "
"the student data in reverse *age* order:"
msgstr ""
":meth:`list.sort` 和 :func:`sorted` 接受布尔形参 *reverse* 用于标记降序排序。例如，将学生数据按 *age*"
" 倒序排序："

#: ../../howto/sorting.rst:162
msgid ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

#: ../../howto/sorting.rst:171
msgid "Sort Stability and Complex Sorts"
msgstr "排序稳定性与复杂排序"

#: ../../howto/sorting.rst:173
msgid ""
"Sorts are guaranteed to be `stable "
"<https://en.wikipedia.org/wiki/Sorting_algorithm#Stability>`_\\. That means "
"that when multiple records have the same key, their original order is "
"preserved."
msgstr ""
"排序保证 `稳定 "
"<https://en.wikipedia.org/wiki/Sorting_algorithm#Stability>`_：等键记录保持原始顺序。"

#: ../../howto/sorting.rst:177
msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"
msgstr ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"

#: ../../howto/sorting.rst:183
msgid ""
"Notice how the two records for *blue* retain their original order so that "
"``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr "注意 *blue* 的两个记录是如何保序的：``('blue', 1)`` 保证先于 ``('blue', 2)``。"

#: ../../howto/sorting.rst:186
msgid ""
"This wonderful property lets you build complex sorts in a series of sorting "
"steps. For example, to sort the student data by descending *grade* and then "
"ascending *age*, do the *age* sort first and then sort again using *grade*:"
msgstr ""
"这个了不起的特性使得借助一系列排序步骤构建出复杂排序成为可能。例如，要按 *grade* 降序后 *age* 升序排序学生数据，只需先用 *age* "
"排序再用 *grade* 排序即可："

#: ../../howto/sorting.rst:190
msgid ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # 根据次要键（年龄）排序\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # 现在根据主要键（成绩）降序排序\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)"

#: ../../howto/sorting.rst:196
msgid ""
"This can be abstracted out into a wrapper function that can take a list and "
"tuples of field and order to sort them on multiple passes."
msgstr "可抽象为包装函数，依据接收的一些字段序的元组对接收的列表做多趟排序。"

#: ../../howto/sorting.rst:199
msgid ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:209
msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of any "
"ordering already present in a dataset."
msgstr ""
"Python 中曾用的 `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ "
"算法借助数据集中任何已有的有序性来高效进行多种排序。"

#: ../../howto/sorting.rst:214
msgid "Decorate-Sort-Undecorate"
msgstr "装饰-排序-去装饰"

#: ../../howto/sorting.rst:216
msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "装饰-排序-去装饰 (Decorate-Sort-Undecorate) 得名于它的三个步骤："

#: ../../howto/sorting.rst:218
msgid ""
"First, the initial list is decorated with new values that control the sort "
"order."
msgstr "首先，用控制排序顺序的新值装饰初始列表。"

#: ../../howto/sorting.rst:220
msgid "Second, the decorated list is sorted."
msgstr "其次，排序装饰后的列表。"

#: ../../howto/sorting.rst:222
msgid ""
"Finally, the decorations are removed, creating a list that contains only the"
" initial values in the new order."
msgstr "最后，去除装饰即得按新顺序排列的初始值的列表。"

#: ../../howto/sorting.rst:225
msgid ""
"For example, to sort the student data by *grade* using the DSU approach:"
msgstr "例如，用 DSU 方法按 *grade* 排序学生数据："

#: ../../howto/sorting.rst:227
msgid ""
">>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # undecorate\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # 取消装饰\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

#: ../../howto/sorting.rst:234
msgid ""
"This idiom works because tuples are compared lexicographically; the first "
"items are compared; if they are the same then the second items are compared,"
" and so on."
msgstr "这方法语有效是因为元组按字典顺序进行比较，先比较第一项；如果它们相同则比较第二个项目，依此类推。"

#: ../../howto/sorting.rst:238
msgid ""
"It is not strictly necessary in all cases to include the index *i* in the "
"decorated list, but including it gives two benefits:"
msgstr "不一定在所有情况下都要在装饰列表中包含索引 *i* ，但包含它有两个好处："

#: ../../howto/sorting.rst:241
msgid ""
"The sort is stable -- if two items have the same key, their order will be "
"preserved in the sorted list."
msgstr "排序是稳定的——如果两个项具有相同的键，它们的顺序将保留在排序列表中。"

#: ../../howto/sorting.rst:244
msgid ""
"The original items do not have to be comparable because the ordering of the "
"decorated tuples will be determined by at most the first two items. So for "
"example the original list could contain complex numbers which cannot be "
"sorted directly."
msgstr "原始项目不必具有可比性，因为装饰元组的排序最多由前两项决定。 因此，例如原始列表可能包含无法直接排序的复数。"

#: ../../howto/sorting.rst:249
msgid ""
"Another name for this idiom is `Schwartzian transform "
"<https://en.wikipedia.org/wiki/Schwartzian_transform>`_\\, after Randal L. "
"Schwartz, who popularized it among Perl programmers."
msgstr ""
"这个方法的另一个名字是 Randal L. Schwartz 在 Perl 程序员中推广的 `Schwartzian transform "
"<https://en.wikipedia.org/wiki/Schwartzian_transform>`_\\ 。"

#: ../../howto/sorting.rst:253
msgid ""
"Now that Python sorting provides key-functions, this technique is not often "
"needed."
msgstr "既然 Python 排序提供了键函数，那么通常不需要这种技术。"

#: ../../howto/sorting.rst:256
msgid "Comparison Functions"
msgstr "比较函数"

#: ../../howto/sorting.rst:258
msgid ""
"Unlike key functions that return an absolute value for sorting, a comparison"
" function computes the relative ordering for two inputs."
msgstr "与返回一个用于排序的绝对值的键函数不同，比较函数是计算两个输入的相对排序。"

#: ../../howto/sorting.rst:261
msgid ""
"For example, a `balance scale "
"<https://upload.wikimedia.org/wikipedia/commons/1/17/Balance_à_tabac_1850.JPG>`_"
" compares two samples giving a relative ordering: lighter, equal, or "
"heavier. Likewise, a comparison function such as ``cmp(a, b)`` will return a"
" negative value for less-than, zero if the inputs are equal, or a positive "
"value for greater-than."
msgstr ""
"例如，一个 `天平 "
"<https://upload.wikimedia.org/wikipedia/commons/1/17/Balance_à_tabac_1850.JPG>`_"
" 会比较两个样本并给出一个相对排序：较轻、相等或较重。 类似地，一个比较函数如 ``cmp(a, b)`` "
"将返回一个负值表示小于，零表示相等，或是一个正值表示大于。"

#: ../../howto/sorting.rst:268
msgid ""
"It is common to encounter comparison functions when translating algorithms "
"from other languages.  Also, some libraries provide comparison functions as "
"part of their API.  For example, :func:`locale.strcoll` is a comparison "
"function."
msgstr ""
"当从其他语言转写算法时经常会遇到比较函数。 此外，某些库也提供了比较函数作为其 API 的组成部分。 例如，:func:`locale.strcoll`"
" 就是一个比较函数。"

#: ../../howto/sorting.rst:272
msgid ""
"To accommodate those situations, Python provides "
":class:`functools.cmp_to_key` to wrap the comparison function to make it "
"usable as a key function::"
msgstr ""
"为了适应这些情况，Python 提供了 :class:`functools.cmp_to_key` 用来包装比较函数使其可以作为键函数来使用::"

#: ../../howto/sorting.rst:276
msgid "sorted(words, key=cmp_to_key(strcoll))  # locale-aware sort order"
msgstr "sorted(words, key=cmp_to_key(strcoll))  # 基于地区的排序规则"

#: ../../howto/sorting.rst:279
msgid "Strategies For Unorderable Types and Values"
msgstr "不可排序类型和值的策略"

#: ../../howto/sorting.rst:281
msgid ""
"A number of type and value issues can arise when sorting. Here are some "
"strategies that can help:"
msgstr "在排序时可能出现多种涉及类型和值的问题。 下面是一些有助于解决问题的策略："

#: ../../howto/sorting.rst:284
msgid "Convert non-comparable input types to strings prior to sorting:"
msgstr "在排序之前将不可比较的输入类型转换为字符串。"

#: ../../howto/sorting.rst:286
msgid ""
">>> data = ['twelve', '11', 10]\n"
">>> sorted(map(str, data))\n"
"['10', '11', 'twelve']"
msgstr ""
">>> data = ['twelve', '11', 10]\n"
">>> sorted(map(str, data))\n"
"['10', '11', 'twelve']"

#: ../../howto/sorting.rst:292
msgid ""
"This is needed because most cross-type comparisons raise a :exc:`TypeError`."
msgstr "需要这样做是因为大多数跨类型比较都会引发 :exc:`TypeError`。"

#: ../../howto/sorting.rst:295
msgid "Remove special values prior to sorting:"
msgstr "在排序之前移除特殊的值："

#: ../../howto/sorting.rst:297
msgid ""
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
">>> data = [3.3, float('nan'), 1.1, 2.2]\n"
">>> sorted(filterfalse(isnan, data))\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
">>> data = [3.3, float('nan'), 1.1, 2.2]\n"
">>> sorted(filterfalse(isnan, data))\n"
"[1.1, 2.2, 3.3]"

#: ../../howto/sorting.rst:305
msgid ""
"This is needed because the `IEEE-754 standard "
"<https://en.wikipedia.org/wiki/IEEE_754>`_ specifies that, \"Every NaN shall"
" compare unordered with everything, including itself.\""
msgstr ""

#: ../../howto/sorting.rst:309
msgid "Likewise, ``None`` can be stripped from datasets as well:"
msgstr ""

#: ../../howto/sorting.rst:311
msgid ""
">>> data = [3.3, None, 1.1, 2.2]\n"
">>> sorted(x for x in data if x is not None)\n"
"[1.1, 2.2, 3.3]"
msgstr ""

#: ../../howto/sorting.rst:317
msgid "This is needed because ``None`` is not comparable to other types."
msgstr ""

#: ../../howto/sorting.rst:319
msgid "Convert mapping types into sorted item lists before sorting:"
msgstr ""

#: ../../howto/sorting.rst:321
msgid ""
">>> data = [{'a': 1}, {'b': 2}]\n"
">>> sorted(data, key=lambda d: sorted(d.items()))\n"
"[{'a': 1}, {'b': 2}]"
msgstr ""

#: ../../howto/sorting.rst:327
msgid ""
"This is needed because dict-to-dict comparisons raise a :exc:`TypeError`."
msgstr ""

#: ../../howto/sorting.rst:330
msgid "Convert set types into sorted lists before sorting:"
msgstr ""

#: ../../howto/sorting.rst:332
msgid ""
">>> data = [{'a', 'b', 'c'}, {'b', 'c', 'd'}]\n"
">>> sorted(map(sorted, data))\n"
"[['a', 'b', 'c'], ['b', 'c', 'd']]"
msgstr ""

#: ../../howto/sorting.rst:338
msgid ""
"This is needed because the elements contained in set types do not have a "
"deterministic order.  For example, ``list({'a', 'b'})`` may produce either "
"``['a', 'b']`` or ``['b', 'a']``."
msgstr ""

#: ../../howto/sorting.rst:343
msgid "Odds and Ends"
msgstr "杂项说明"

#: ../../howto/sorting.rst:345
msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function or "
":func:`locale.strcoll` for a comparison function.  This is necessary because"
" \"alphabetical\" sort orderings can vary across cultures even if the "
"underlying alphabet is the same."
msgstr ""
"对于可感知语言区域的排序，请使用 :func:`locale.strxfrm` 作为键函数或使用 :func:`locale.strcoll` "
"作为比较函数。 因为在不同语言中即便字母表相同“字母”排列顺序也可能不同所以这样做是必要的。"

#: ../../howto/sorting.rst:350
msgid ""
"The *reverse* parameter still maintains sort stability (so that records with"
" equal keys retain the original order). Interestingly, that effect can be "
"simulated without the parameter by using the builtin :func:`reversed` "
"function twice:"
msgstr ""
"*reverse* 参数仍然保持排序稳定性（因此具有相等键的记录保留原始顺序）。 有趣的是，通过使用内置的 :func:`reversed` "
"函数两次，可以在没有参数的情况下模拟该效果："

#: ../../howto/sorting.rst:355
msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> standard_way = sorted(data, key=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_way\n"
"[('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]"
msgstr ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> standard_way = sorted(data, key=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_way\n"
"[('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]"

#: ../../howto/sorting.rst:364
msgid ""
"The sort routines use ``<`` when making comparisons between two objects. So,"
" it is easy to add a standard sort order to a class by defining an "
":meth:`~object.__lt__` method:"
msgstr ""
"排序例程在两个对象之间进行比较时使用 ``<``。 因此，通过定义一个 :meth:`~object.__lt__` "
"方法，就可以轻松地为类添加标准排序顺序:"

#: ../../howto/sorting.rst:368
msgid ""
">>> Student.__lt__ = lambda self, other: self.age < other.age\n"
">>> sorted(student_objects)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> Student.__lt__ = lambda self, other: self.age < other.age\n"
">>> sorted(student_objects)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:374
msgid ""
"However, note that ``<`` can fall back to using :meth:`~object.__gt__` if "
":meth:`~object.__lt__` is not implemented (see :func:`object.__lt__` for "
"details on the mechanics).  To avoid surprises, :pep:`8` recommends that all"
" six comparison methods be implemented. The "
":func:`~functools.total_ordering` decorator is provided to make that task "
"easier."
msgstr ""
"不过，请注意 ``<`` 在 :meth:`~object.__lt__` 未被实现时可以回退为使用 :meth:`~object.__gt__` "
"(请参阅 :func:`object.__lt__` 了解相关机制的细节)。 为避免意外，:pep:`8` 建议实现所有的六个比较方法。 "
":func:`~functools.total_ordering` 装饰器被提供用来令此任务更为容易。"

#: ../../howto/sorting.rst:381
msgid ""
"Key functions need not depend directly on the objects being sorted. A key "
"function can also access external resources. For instance, if the student "
"grades are stored in a dictionary, they can be used to sort a separate list "
"of student names:"
msgstr "键函数不需要直接依赖于被排序的对象。键函数还可以访问外部资源。例如，如果学生成绩存储在字典中，则可以使用它们对单独的学生姓名列表进行排序："

#: ../../howto/sorting.rst:386
msgid ""
">>> students = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}\n"
">>> sorted(students, key=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"
msgstr ""
">>> students = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}\n"
">>> sorted(students, key=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"

#: ../../howto/sorting.rst:394
msgid "Partial Sorts"
msgstr "部分排序"

#: ../../howto/sorting.rst:396
msgid ""
"Some applications require only some of the data to be ordered.  The standard"
" library provides several tools that do less work than a full sort:"
msgstr "有些应用程序只需要对部分数据进行排序。 标准库提供了几种工具可以执行比完整排序更轻量的任务："

#: ../../howto/sorting.rst:399
msgid ""
":func:`min` and :func:`max` return the smallest and largest values, "
"respectively.  These functions make a single pass over the input data and "
"require almost no auxiliary memory."
msgstr ":func:`min` 和 :func:`max` 可分别返回最小和最大值。 这两个函数只需逐一检查输入数据而几乎不需要任何额外的内存。"

#: ../../howto/sorting.rst:403
msgid ""
":func:`heapq.nsmallest` and :func:`heapq.nlargest` return the *n* smallest "
"and largest values, respectively.  These functions make a single pass over "
"the data keeping only *n* elements in memory at a time.  For values of *n* "
"that are small relative to the number of inputs, these functions make far "
"fewer comparisons than a full sort."
msgstr ""
":func:`heapq.nsmallest` 和 :func:`heapq.nlargest` 可分别返回 *n* 个最小和最大的值。 "
"这两个函数每次只需逐一检查数据并仅需在内存中保留 *n* 个元素。 对于相对于输入总数来说较小的 *n* 值来说，这两个函数将进行远少于完整排序的比较。"

#: ../../howto/sorting.rst:409
msgid ""
":func:`heapq.heappush` and :func:`heapq.heappop` create and maintain a "
"partially sorted arrangement of data that keeps the smallest element at "
"position ``0``.  These functions are suitable for implementing priority "
"queues which are commonly used for task scheduling."
msgstr ""
":func:`heapq.heappush` 和 :func:`heapq.heappop` 会创建并维护一组部分排序的数据其中最小的元素将处在 "
"``0`` 位置上。 这两个函数很适合实现常用于任务调度的优先级队列。"
