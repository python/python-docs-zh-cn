# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# telnetning <telnetning@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2022
# ProgramRipper, 2023
# 乐成 王, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "注解最佳实践"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rst-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with"
" annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr "本文档旨在概括与注解字典打交道的最佳实践。查看 Python 对象的 ``__annotations__`` 的代码应遵循下面的准则。"

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"本文档按四部分组织：在 3.10 及更高版本的 Python 中查看对象注解的最佳实践、在 3.9 及更低版本的 Python "
"中查看对象注解的最佳实践、其它一些适于任何版本的 Python 的 ``__annotations__`` "
"的最佳实践、``__annotations__`` 的一些“坑”。"

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the "
":mod:`typing` module."
msgstr ""
"本文是 ``__annotations__`` 的文档，不是注解的用法。如果在寻找如何使用“类型提示”，请参阅 :mod:`typing` 模块。"

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "在 3.10 及更高版本的 Python 中访问对象的注解字典"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: "
":func:`inspect.get_annotations`.  In Python versions 3.10 through 3.13, "
"calling this function is the best practice for accessing the annotations "
"dict of any object that supports annotations.  This function can also \"un-"
"stringize\" stringized annotations for you."
msgstr ""

#: ../../howto/annotations.rst:42
msgid ""
"In Python 3.14, there is a new :mod:`annotationlib` module with "
"functionality for working with annotations. This includes a "
":func:`annotationlib.get_annotations` function, which supersedes "
":func:`inspect.get_annotations`."
msgstr ""

#: ../../howto/annotations.rst:47
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use"
" case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, "
"``o.__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"不用 :func:`inspect.get_annotations` 也可以手动访问 ``__annotations__``  "
"这一数据成员。该方法的最佳实践在 Python 3.10 中也发生了变化：从 Python 3.10 开始，对于 Python "
"函数、类和模块，``o.__annotations__`` *保证* 会正常工作。只要你确信所检查的对象是这三种之一，你便可以用 "
"``o.__annotations__`` 获取该对象的注解字典。"

#: ../../howto/annotations.rst:57
msgid ""
"However, other types of callables--for example, callables created by "
":func:`functools.partial`--may not have an ``__annotations__`` attribute "
"defined.  When accessing the ``__annotations__`` of a possibly unknown "
"object,  best practice in Python versions 3.10 and newer is to call "
":func:`getattr` with three arguments, for example ``getattr(o, "
"'__annotations__', None)``."
msgstr ""
"不过，其它类型的可调用对象可不一定定义了 ``__annotations__`` 属性，就比如说，:func:`functools.partial` "
"创建的可调用对象。当访问某个未知对象的 ``__annotations__`` 时，3.10 及更高版本的 Python 中的最佳实践是用三个参数去调用"
" :func:`getattr`，像 ``getattr(o, '__annotations__', None)`` 这样。"

#: ../../howto/annotations.rst:65
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no"
" annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"Python 3.10 之前，在一个没定义注解而其父类定义了注解的类上访问 ``__annotations__`` 将返回父类的 "
"``__annotations__``。在 3.10 及更高版本的 Python 中，这样的子类的注解是个空字典。"

#: ../../howto/annotations.rst:73
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "在 3.9 及更低版本的 Python 中访问对象的注解字典"

#: ../../howto/annotations.rst:75
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much"
" more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr "在 3.9 及更低版本的 Python 中访问对象的注解字典要比新版复杂。这是低版本 Python 的设计缺陷，特别是类的注解。"

#: ../../howto/annotations.rst:80
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"访问其它对象——函数、其它可调用对象和模块——的注解字典的最佳实践与 3.10 版本相同，如果不用 "
":func:`inspect.get_annotations`，就用三个参数去调用 :func:`getattr` 以访问对象的 "
"``__annotations__`` 属性。"

#: ../../howto/annotations.rst:87
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"不幸的是，对类而言，这并不是最佳实践。问题在于，由于 ``__annotations__`` "
"在某个类上是可有可无的，而类又可以从基类继承属性，所以访问某个类的 ``__annotations__`` 属性可能会无意间返回 *基类* "
"的注解字典。如："

#: ../../howto/annotations.rst:94
msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"

#: ../../howto/annotations.rst:103
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "会打印出 ``Base`` 的注解字典，而非 ``Derived`` 的。"

#: ../../howto/annotations.rst:106
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""
"如果你所检查的对象是一个类 (``isinstance(o, type)``) 则你的代码将不得不使用单独的代码路径。 在此情况下，最佳实践依赖于 "
"Python 3.9 及之前版本的一个实现细节：如果一个类定义了标注，它们将存储在类的 :attr:`~type.__dict__` 字典中。 "
"由于类可能有也可能没有定义标注，因此最佳实践是在类的 dict 字典上调用 :meth:`~dict.get` 方法。"

#: ../../howto/annotations.rst:114
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"综上所述，下面给出一些示例代码，可以在 Python 3.9 及之前版本安全地访问任意对象的 ``__annotations__`` 属性："

#: ../../howto/annotations.rst:118
msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"

#: ../../howto/annotations.rst:123
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``."
"  You're encouraged to double-check the type of ``ann`` using "
":func:`isinstance` before further examination."
msgstr ""
"运行之后，``ann`` 应为一个字典对象或 ``None``。建议在继续之前，先用 :func:`isinstance` 再次检查 ``ann`` "
"的类型。"

#: ../../howto/annotations.rst:128
msgid ""
"Note that some exotic or malformed type objects may not have a "
":attr:`~type.__dict__` attribute, so for extra safety you may also wish to "
"use :func:`getattr` to access :attr:`!__dict__`."
msgstr ""
"请注意某些特别的或错误的类型对象可能没有 :attr:`~type.__dict__` 属性，因此为确保绝对安全你可能会需要使用 "
":func:`getattr` 来访问 :attr:`!__dict__`。"

#: ../../howto/annotations.rst:134
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "解析字符串形式的注解"

#: ../../howto/annotations.rst:136
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"有时注释可能会被“字符串化”，解析这些字符串可以求得其所代表的 Python 值，最好是调用 "
":func:`inspect.get_annotations` 来完成这项工作。"

#: ../../howto/annotations.rst:142
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use "
":func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're"
" encouraged to examine the implementation of :func:`inspect.get_annotations`"
" in the current Python version and follow a similar approach."
msgstr ""
"如果是 Python 3.9 及之前的版本，或者由于某种原因无法使用  :func:`inspect.get_annotations` "
"，那就需要重现其代码逻辑。建议查看一下当前 Python 版本中 :func:`inspect.get_annotations` "
"的实现代码，并遵照实现。"

#: ../../howto/annotations.rst:148
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr "简而言之，假设要对任一对象解析其字符串化的注释 ``o`` ："

#: ../../howto/annotations.rst:151
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling "
":func:`eval`."
msgstr "如果 ``o`` 是个模块，在调用 :func:`eval` 时，``o.__dict__``  可视为 ``globals`` 。"

#: ../../howto/annotations.rst:153
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling "
":func:`eval`."
msgstr ""
"如果 ``o`` 是一个类，在调用 :func:`eval` 时，``sys.modules[o.__module__].__dict__`` 视作  "
"``globals``，``dict(vars(o))`` 视作 ``locals`` 。"

#: ../../howto/annotations.rst:156
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, "
":func:`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it"
" by accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until "
"you have found the root unwrapped function."
msgstr ""
"如果 ``o`` 是一个用 :func:`functools.update_wrapper` 、 :func:`functools.wraps` 或 "
":func:`functools.partial` 封装的可调用对象，可酌情访问 ``o.__wrapped__`` 或 ``o.func`` "
"进行反复解包，直到你找到未经封装的根函数。"

#: ../../howto/annotations.rst:160
msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ "
"<function.__globals__>` as the globals when calling :func:`eval`."
msgstr ""
"如果 ``o`` 为可调用对象（但不是类），则在调用 :func:`eval` 时可以使用 :attr:`o.__globals__ "
"<function.__globals__>` 作为 globals。"

#: ../../howto/annotations.rst:164
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically"
" contain any valid string, and in practice there are valid use cases for "
"type hints that require annotating with string values that specifically "
"*can't* be evaluated.  For example:"
msgstr ""
"但并不是所有注解字符串都可以通过 :func:`eval` 成功地转化为 Python "
"值。理论上，注解字符串中可以包含任何合法字符串，确实有一些类型提示的场合，需要用到特殊的 *无法* 被解析的字符串来作注解。比如："

#: ../../howto/annotations.rst:171
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr "在 Python 支持 :pep:`604` 的联合类型 ``|`` (Python 3.10) 之前使用它。"

#: ../../howto/annotations.rst:173
msgid ""
"Definitions that aren't needed at runtime, only imported when "
":const:`typing.TYPE_CHECKING` is true."
msgstr "运行时用不到的定义，只在 :const:`typing.TYPE_CHECKING` 为 True 时才会导入。"

#: ../../howto/annotations.rst:176
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"如果 :func:`eval` 试图求值，将会失败并触发异常。因此，当要设计一个可采用注解的库 API ，建议只在调用方显式请求的时才对字符串求值。"

#: ../../howto/annotations.rst:184
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "任何版本 Python 中使用 ``__annotations__`` 的最佳实践"

#: ../../howto/annotations.rst:186
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr "应避免直接给对象的 ``__annotations__`` 成员赋值。请让 Python 来管理 ``__annotations__``。"

#: ../../howto/annotations.rst:189
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr "如果直接给某对象的 ``__annotations__`` 成员赋值，应该确保设成一个 ``dict`` 对象。"

#: ../../howto/annotations.rst:192
msgid ""
"You should avoid accessing ``__annotations__`` directly on any object. "
"Instead, use :func:`annotationlib.get_annotations` (Python 3.14+) or "
":func:`inspect.get_annotations` (Python 3.10+)."
msgstr ""

#: ../../howto/annotations.rst:196
msgid ""
"If you do directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""

#: ../../howto/annotations.rst:200
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "应避免修改 ``__annotations__`` 字典。"

#: ../../howto/annotations.rst:202
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "应避免删除对象的 ``__annotations__`` 属性。"

#: ../../howto/annotations.rst:207
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` 的一些“坑”"

#: ../../howto/annotations.rst:209
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"在 Python 3 的所有版本中，如果对象没有定义注解，函数对象就会直接创建一个注解字典对象。用 ``del fn.__annotations__``"
" 可删除 ``__annotations__`` 属性，但如果后续再访问 "
"``fn.__annotations__``，该对象将新建一个空的字典对象，用于存放并返回注解。在函数直接创建注解字典前，删除注解操作会抛出 "
"``AttributeError`` 异常；连续两次调用 ``del fn.__annotations__`` 一定会抛出一次 "
"``AttributeError`` 异常。"

#: ../../howto/annotations.rst:219
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr "以上同样适用于 Python 3.10 以上版本中的类和模块对象。"

#: ../../howto/annotations.rst:222
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that"
" object using ``fn.__annotations__`` will lazy-create an empty dictionary as"
" per the first paragraph of this section.  This is *not* true of modules and"
" classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"所有版本的 Python 3 中，均可将函数对象的 ``__annotations__`` 设为 ``None``。但后续用 "
"``fn.__annotations__`` 访问该对象的注解时，会像本节第一段所述那样，直接创建一个空字典。但在任何 Python "
"版本中，模块和类均非如此，他们允许将 ``__annotations__`` 设为任意 Python 值，并且会留存所设值。"

#: ../../howto/annotations.rst:230
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string"
" will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"如果 Python 会对注解作字符串化处理（用 ``from __future__ import annotations`` "
"），并且注解本身就是一个字符串，那么将会为其加上引号。实际效果就是，注解加了 *两次* 引号。例如："

#: ../../howto/annotations.rst:236
msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"

#: ../../howto/annotations.rst:241
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr "这会打印出 ``{'a': \"'str'\"}``。这不应算是个“坑”；只是因为可能会让人吃惊，所以才提一下。"

#: ../../howto/annotations.rst:244
msgid ""
"If you use a class with a custom metaclass and access ``__annotations__`` on"
" the class, you may observe unexpected behavior; see :pep:`749 "
"<749#pep749-metaclasses>` for some examples. You can avoid these quirks by "
"using :func:`annotationlib.get_annotations` on Python 3.14+ or "
":func:`inspect.get_annotations` on Python 3.10+. On earlier versions of "
"Python, you can avoid these bugs by accessing the annotations from the "
"class's :attr:`~type.__dict__` (e.g., ``cls.__dict__.get('__annotations__', "
"None)``)."
msgstr ""
