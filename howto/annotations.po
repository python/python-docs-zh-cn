# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2021
# telnetning <telnetning@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: ww song <sww4718168@gmail.com>, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "对象注解属性的最佳实践"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rstNone
msgid "Abstract"
msgstr "摘要"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with"
" annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"本文意在汇聚对象的注解字典用法的最佳实践。 如果 Python 代码会去查看 Python 对象的 ``__annotations__`` "
"属性，建议遵循以下准则。"

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"本文分为四个部分：在 Python 3.10 以上版本中访问对象注解的最佳实践、在Python 3.9 以上版本中访问对象注解的最佳实践、适用于任何 "
"Python 版本的其他 ```__annotations__`` 最佳实践、``__annotations__`` 的特别之处。"

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the "
":mod:`typing` module."
msgstr ""
"请注意，本文是专门介绍 ``__annotations__`` 的，而不是介绍注解的用法。若要了解“类型提示”的使用信息，请参阅 "
":mod:`typing` 模块。"

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "在 Python 3.10 以上版本中访问对象的注解字典"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: "
":func:`inspect.get_annotations`.  In Python versions 3.10 and newer, calling"
" this function is the best practice for accessing the annotations dict of "
"any object that supports annotations.  This function can also \"un-"
"stringize\" stringized annotations for you."
msgstr ""
"Python 3.10 在标准库中加入了一个新函数：:func:`inspect.get_annotations`。在 Python 3.10 "
"以上的版本中，调用该函数就是访问对象注解字典的最佳做法。该函数还可以“解析”字符串形式的注解。"

#: ../../howto/annotations.rst:42
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use"
" case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, "
"``o.__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"有时会因为某些原因看不到 :func:`inspect.get_annotations` ，也可以直接访问 ``__annotations__`` "
"数据成员。这方面的最佳实践在 Python 3.10 中也发生了变化：从 Python 3.10 开始，Python 函数、类和模块的 "
"``o.__annotations__`` *保证* 可用。如果确定是要查看这三种对象，只要利用 ``o.__annotations__`` "
"读取对象的注释字典即可。"

#: ../../howto/annotations.rst:52
msgid ""
"However, other types of callables--for example, callables created by "
":func:`functools.partial`--may not have an ``__annotations__`` attribute "
"defined.  When accessing the ``__annotations__`` of a possibly unknown "
"object,  best practice in Python versions 3.10 and newer is to call "
":func:`getattr` with three arguments, for example ``getattr(o, "
"'__annotations__', None)``."
msgstr ""
"不过其他类型的可调用对象可能就没有定义 ``__annotations__`` 属性，比如由 :func:`functools.partial` "
"创建的可调用对象。当访问某个未知对象的``__annotations__`` 时，Python 3.10 以上版本的最佳做法是带三个参数去调用 "
":func:`getattr` ，比如 ``getattr(o, '__annotations__', None)``。"

#: ../../howto/annotations.rst:62
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "在 Python 3.9 及更早的版本中访问对象的注解字典"

#: ../../howto/annotations.rst:64
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much"
" more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"在 Python 3.9 及之前的版本中，访问对象的注解字典要比新版本中复杂得多。这个是 Python 低版本的一个设计缺陷，特别是访问类的注解时。"

#: ../../howto/annotations.rst:69
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"要访问其他对象——函数、可调用对象和模块——的注释字典，最佳做法与 3.10 版本相同，假定不想调用 "
":func:`inspect.get_annotations`：你应该用三个参数调用 :func:`getattr` ，以访问对象的 "
"``__annotations__`` 属性。"

#: ../../howto/annotations.rst:76
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"不幸的是，对于类而言，这并不是最佳做法。因为 ```__annotations__`` 是类的可选属性，并且类可以从基类继承属性，访问某个类的 "
"``__annotations__`` 属性可能会无意间返回 *基类* 的注解数据。例如："

#: ../../howto/annotations.rst:92
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "如此会打印出 ``Base`` 的注解字典，而非 ``Derived`` 的。"

#: ../../howto/annotations.rst:95
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's ``__dict__`` dictionary."
"  Since the class may or may not have annotations defined, best practice is "
"to call the ``get`` method on the class dict."
msgstr ""
"若要查看的对象是个类（``isinstance(o, type)``），代码不得不另辟蹊径。这时的最佳做法依赖于 Python 3.9 "
"及之前版本的一处细节：若某个类定义了注解，则会存放于字典 ``__dict__`` 中。由于类不一定会定义注解，最好的做法是在类的 dict 上调用 "
"``get`` 方法。"

#: ../../howto/annotations.rst:103
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"综上所述，下面给出一些示例代码，可以在 Python 3.9 及之前版本安全地访问任意对象的 ``__annotations__`` 属性："

#: ../../howto/annotations.rst:112
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``."
"  You're encouraged to double-check the type of ``ann`` using "
":func:`isinstance` before further examination."
msgstr ""
"运行之后，``ann`` 应为一个字典对象或 ``None``。建议在继续之前，先用 :func:`isinstance` 再次检查 ``ann`` "
"的类型。"

#: ../../howto/annotations.rst:117
msgid ""
"Note that some exotic or malformed type objects may not have a ``__dict__`` "
"attribute, so for extra safety you may also wish to use :func:`getattr` to "
"access ``__dict__``."
msgstr ""
"请注意，有些特殊的或畸形的类型对象可能没有 ``__dict__`` 属性，为了以防万一，可能还需要用 :func:`getattr` 来访问 "
"``__dict__``。"

#: ../../howto/annotations.rst:123
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "解析字符串形式的注解"

#: ../../howto/annotations.rst:125
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"有时注释可能会被“字符串化”，解析这些字符串可以求得其所代表的 Python 值，最好是调用 "
":func:`inspect.get_annotations` 来完成这项工作。"

#: ../../howto/annotations.rst:131
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use "
":func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're"
" encouraged to examine the implementation of :func:`inspect.get_annotations`"
" in the current Python version and follow a similar approach."
msgstr ""
"如果是 Python 3.9 及之前的版本，或者由于某种原因无法使用  :func:`inspect.get_annotations` "
"，那就需要重现其代码逻辑。建议查看一下当前 Python 版本中 :func:`inspect.get_annotations` "
"的实现代码，并遵照实现。"

#: ../../howto/annotations.rst:137
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr "简而言之，假设要对任一对象解析其字符串化的注释 ``o`` ："

#: ../../howto/annotations.rst:140
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling "
":func:`eval`."
msgstr "如果 ``o`` 是个模块，在调用 :func:`eval` 时，``o.__dict__``  可视为 ``globals`` 。"

#: ../../howto/annotations.rst:142
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling "
":func:`eval`."
msgstr ""
"如果 ``o`` 是一个类，在调用 :func:`eval` 时，``sys.modules[o.__module__].__dict__`` 视作  "
"``globals``，``dict(vars(o))`` 视作 ``locals`` 。"

#: ../../howto/annotations.rst:145
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, "
":func:`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it"
" by accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until "
"you have found the root unwrapped function."
msgstr ""
"如果 ``o`` 是一个用 :func:`functools.update_wrapper` 、 :func:`functools.wraps` 或 "
":func:`functools.partial` 封装的可调用对象，可酌情访问 ``o.__wrapped__`` 或 ``o.func`` "
"进行反复解包，直到你找到未经封装的根函数。"

#: ../../howto/annotations.rst:149
msgid ""
"If ``o`` is a callable (but not a class), use ``o.__globals__`` as the "
"globals when calling :func:`eval`."
msgstr ""
"如果 ``o`` 是个可调用对象（但不是一个类），在调用 :func:`eval` 时，``o.__dict__``  可视为 ``globals`` "
"。"

#: ../../howto/annotations.rst:152
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically"
" contain any valid string, and in practice there are valid use cases for "
"type hints that require annotating with string values that specifically "
"*can't* be evaluated.  For example:"
msgstr ""
"但并不是所有注解字符串都可以通过 :func:`eval` 成功地转化为 Python "
"值。理论上，注解字符串中可以包含任何合法字符串，确实有一些类型提示的场合，需要用到特殊的 *无法* 被解析的字符串来作注解。比如："

#: ../../howto/annotations.rst:159
msgid ""
":pep:`604` union types using `|`, before support for this was added to "
"Python 3.10."
msgstr "在从 Python 3.10 加入支持之前，:pep:`604` 联合类型用到了 `|` 。"

#: ../../howto/annotations.rst:161
msgid ""
"Definitions that aren't needed at runtime, only imported when "
":const:`typing.TYPE_CHECKING` is true."
msgstr "运行时用不到的定义，只在 :const:`typing.TYPE_CHECKING` 为 True 时才会导入。"

#: ../../howto/annotations.rst:164
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"如果 :func:`eval` 试图求值，将会失败并触发异常。因此，当要设计一个可采用注解的库 API ，建议只在调用方显式请求的时才对字符串求值。"

#: ../../howto/annotations.rst:172
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "任何版本 Python 中使用 ``__annotations__`` 的最佳实践"

#: ../../howto/annotations.rst:174
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr "应避免直接给对象的 ``__annotations__`` 成员赋值。请让 Python 来管理``__annotations__``。"

#: ../../howto/annotations.rst:177
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr "如果直接给某对象的 ``__annotations__`` 成员赋值，应该确保设成一个``dict`` 对象。"

#: ../../howto/annotations.rst:180
msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr "如果直接访问某个对象的 ``__annotations__`` 成员，在解析其值之前，应先确认其为字典类型。"

#: ../../howto/annotations.rst:184
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "应避免修改 ``__annotations__`` 字典。"

#: ../../howto/annotations.rst:186
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "应避免删除对象的 ``__annotations__`` 属性。"

#: ../../howto/annotations.rst:191
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` 的坑"

#: ../../howto/annotations.rst:193
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"在 Python 3 的所有版本中，如果对象没有定义注解，函数对象就会直接创建一个注解字典对象。用 ``del fn.__annotations__``"
" 可删除 ``__annotations__`` 属性，但如果后续再访问 "
"``fn.__annotations__``，该对象将新建一个空的字典对象，用于存放并返回注解。在函数直接创建注解字典前，删除注解操作会抛出 "
"``AttributeError`` 异常；连续两次调用 ``del fn.__annotations__`` 一定会抛出一次 "
"``AttributeError`` 异常。"

#: ../../howto/annotations.rst:203
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr "以上同样适用于 Python 3.10 以上版本中的类和模块对象。"

#: ../../howto/annotations.rst:206
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that"
" object using ``fn.__annotations__`` will lazy-create an empty dictionary as"
" per the first paragraph of this section.  This is *not* true of modules and"
" classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"所有版本的 Python 3 中，均可将函数对象的 ``__annotations__`` 设为 ``None``。但后续用 "
"``fn.__annotations__`` 访问该对象的注解时，会像本节第一段所述那样，直接创建一个空字典。但在任何 Python "
"版本中，模块和类均非如此，他们允许将 ``__annotations__`` 设为任意 Python 值，并且会留存所设值。"

#: ../../howto/annotations.rst:214
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string"
" will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"如果 Python 会对注解作字符串化处理（用 ``from __future__ import annotations`` "
"），并且注解本身就是一个字符串，那么将会为其加上引号。实际效果就是，注解加了 *两次* 引号。例如："

#: ../../howto/annotations.rst:225
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr "这会打印出 ``{'a': \"'str'\"}``。这不应算是个“坑”；只是因为可能会让人吃惊，所以才提一下。"
